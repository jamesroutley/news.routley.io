<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samwho.dev/hashing/">Original</a>
    <h1>Hashing</h1>
    
    <div id="readability-page-1" class="page"><div>
        

<p>As a programmer, you use hash functions every day. They&#39;re used in databases
to optimise queries, they&#39;re used in data structures to make things faster,
they&#39;re used in security to keep data safe. Almost every interaction you have
with technology will involve hash functions in one way or another.</p>
<p>Hash functions are foundational, and they are <strong>everywhere</strong>.</p>
<p>But what <em>is</em> a hash function, and how do they work?</p>
<p>In this post, we&#39;re going to demystify hash functions. We&#39;re going to start by
looking at a simple hash function, then we&#39;re going to learn how to test if a
hash function is good or not, and then we&#39;re going to look at a real-world use
of hash functions: the hash map.</p>

<div>
  
  <p>
    This article has visualisations that can be <span>clicked</span>.
  </p>
</div>
<h2 id="what-is-a-hash-function"><a href="#what-is-a-hash-function">#</a>
What <em>is</em> a hash function?</h2>
<p>Hash functions are functions that take an input, usually a string, and produce a
number. If you were to call a hash function multiple times with the same input,
it will always return the same number, and that number returned will always be
within a promised range. What that range is will depend on the hash function,
some use 32-bit integers (so 0 to 4 billion), others go much larger.</p>
<p>If we were to write a dummy hash function in JavaScript, it might look like
this:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>function </span><span>hash</span><span>(input) {
</span><span>  </span><span>return </span><span>0</span><span>;
</span><span>}
</span></code></pre>
<p>Even without knowing <em>how</em> hash functions are used, it&#39;s probably no surprise
that this hash function is useless. Let&#39;s see how we can measure how good a
hash function is, and after that we&#39;ll do a deep dive on how they&#39;re used
within hash maps.</p>
<h2 id="what-makes-a-hash-function-good"><a href="#what-makes-a-hash-function-good">#</a>
What makes a hash function good?</h2>
<p>Because <code>input</code> can be any string, but the number returned is within some
promised range, it&#39;s possible that two different inputs can return the same
number.  This is called a &#34;collision,&#34; and good hash functions try to minimise
how many collisions they produce.</p>
<p>It&#39;s not possible to completely eliminate collisions, though. If we wrote a hash
function that returned a number in the range 0 to 7, and we gave it 9 unique
inputs, we&#39;re guaranteed at least 1 collision.</p>
<div>
  <p><code>hash(&#34;to&#34;)         == 3</code>
    <code>hash(&#34;the&#34;)        == 2</code>
    <code>hash(&#34;caf√©&#34;)       == 0</code>
    <code>hash(&#34;de&#34;)         == 6</code>
    <code>hash(&#34;versailles&#34;) == 4</code>
    <code>hash(&#34;for&#34;)        == 5</code>
    <code>hash(&#34;coffee&#34;)     == 0</code>
    <code>hash(&#34;we&#34;)         == 7</code>
    <code>hash(&#34;had&#34;)        == 1</code>
  </p>
<p>
    Output values from a well-known hash function, modulo 8. No matter what 9
    values we pass, there are only 8 unique numbers and so collisions are
    inevitable.  The goal is to have as few as possible.
  </p>
</div>
<p>To visualise collisions, I&#39;m going to use a grid. Each square of the grid is
going to represent a number output by a hash function.  Here&#39;s an example 8x2
grid. <span>Click</span> on the grid to increment the
example hash output value and see how we map it to a grid square. See what
happens when you get a number larger than the number of grid squares.</p>

<p><code>
    <span id="grid-hash">13</span> % 16 == <span id="grid-modulo">13</span>
  </code>
</p>
<div id="first-grid">
  <p>0</p>
  <p>1</p>
  <p>2</p>
  <p>3</p>
  <p>4</p>
  <p>5</p>
  <p>6</p>
  <p>7</p>
  <p>8</p>
  <p>9</p>
  <p>10</p>
  <p>11</p>
  <p>12</p>
  <p>13</p>
  <p>14</p>
  <p>15</p>
</div>
<p>Every time we hash a value, we&#39;re going to make its corresponding square on the
grid a bit darker. The idea is to create an easy way to see how well a hash
function avoids collisions. What we&#39;re looking for is a nice, even distribution.
We&#39;ll know that the hash function isn&#39;t good if we have clumps or patterns of
dark squares.</p>
<blockquote>
<img src="https://samwho.dev/images/haskie-confused.png"/>
<p>
  You said that when a hash function outputs the same value for 2 different
  inputs, that&#39;s a collision. But if we have a hash function that outputs values
  in a big range, and we mapped those to a small grid, aren&#39;t we going to create
  lots of collisions on the grid that aren&#39;t actually collisions? On our 8x2
  grid, 1 and 17 both map to the 2nd square.
</p>
</blockquote>
<p>This is a great observation. You&#39;re absolutely right, we&#39;re going to be creating
&#34;pseudo-collisions&#34; on our grid. It&#39;s okay, though, because if the hash function
is good we will still see an even distribution. Incrementing every square by 100
is just as good a distribution as incrementing every square by 1. If we have a
bad hash function that collides a lot, that will still stand out. We&#39;ll see
this shortly.</p>
<p>Let&#39;s take a larger grid and hash 1,000 randomly-generated strings.  You can
<span>click</span> on the grid to hash a new set of random
inputs, and the grid will animate to show you each input being hashed and placed
on the grid.</p>

<p>The values are nice and evenly distributed because we&#39;re using a good,
well-known hash function called <code>murmur3</code>. This hash
is widely used in the real-world because it has great distribution while also
being really, really fast.</p>
<p>What would our grid look like if we used a <em>bad</em> hash function?</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>function </span><span>hash</span><span>(input) {
</span><span>  </span><span>let </span><span>hash </span><span>= </span><span>0</span><span>;
</span><span>  </span><span>for </span><span>(</span><span>let </span><span>c </span><span>of </span><span>input) {
</span><span>    hash </span><span>+= </span><span>c</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span><span>;
</span><span>  }
</span><span>  </span><span>return </span><span>hash </span><span>% </span><span>1000000</span><span>;
</span><span>}
</span></code></pre>
<p>This hash function loops through the string that we&#39;re given and sums the
numeric values of each character. It then makes sure that the value is between 0
and 1000000 by using the modulus operator (<code>%</code>). Let&#39;s call this hash function
<code>stringSum</code>.</p>
<p>Here it is on the grid. Reminder, this is 1,000 randomly generated strings that
we&#39;re hashing.</p>

<p>This doesn&#39;t look all that different from <code>murmur3</code>.
What gives?</p>
<p>The problem is that the strings we&#39;re giving to be hashed are random. Let&#39;s see
how each function performs when given input that is not random: the numbers from
1 to 1000 converted to strings.</p>

<p>Now the problem is more clear. When the input isn&#39;t random, the output of <code>stringSum</code> forms a pattern.  Our <code>murmur3</code> grid, however, looks the same as how it looked with
random values.</p>
<p>How about if we hash the <a href="https://github.com/powerlanguage/word-lists/blob/master/1000-most-common-words.txt">top 1,000 most common English words</a>:</p>

<p>It&#39;s more subtle, but we do see a pattern on the <code>stringSum</code> grid. As usual, <code>murmur3</code>
looks the same as it always does.</p>
<p>This is the power of a good hash function: no matter the input,
the output is evenly distributed. Let&#39;s talk about one more way to visualise
this and then talk about why it matters.</p>
<h3 id="the-avalanche-effect"><a href="#the-avalanche-effect">#</a>
The avalanche effect</h3>
<p>Another way hash functions get evaluated is on something called the &#34;avalanche
effect.&#34; This refers to how many bits in the output value change when just a
single bit of the input changes. To say that a hash function has a good
avalanche effect, a single bit flip in the input should result in an average of
50% the output bits flipping.</p>
<p>It&#39;s this property that helps hash functions avoid forming patterns in the grid.
If small changes in the input result in small changes in the output, you get
patterns. Patterns indicate poor distribution, and a higher rate of collisions.</p>
<p>Below, we are visualising the avalanche effect by showing two 8-bit binary
numbers. The top number is the input value, and the bottom number is the <code>murmur3</code> output value. <span>Click</span> on it to <span>flip a single bit</span>
in the input. Bits that change in the output will be <span>green</span>, bits that stay the same will be <span>red</span>.</p>

<p><span>murmur3</span> does well, though you will notice that
sometimes fewer than 50% of the bits flip and sometimes more.  This is okay,
provided that it is 50% on average.</p>
<p>Let&#39;s see how <span>stringSum</span> performs.</p>

<p>Well this is embarassing. The output is equal to the input, and so only a single
bit flips each time. This does make sense, because <span>stringSum</span> just sums the numeric value of each character in the
string.  This example only hashes the equivalent of a single character, which
means the output will always be the same as the input.</p>
<h2 id="why-all-of-this-matters"><a href="#why-all-of-this-matters">#</a>
Why all of this matters</h2>
<p>We&#39;ve taken the time to understand some of the ways to determine if a hash
function is good, but we&#39;ve not spent any time talking about why it matters.
Let&#39;s fix that by talking about hash maps.</p>
<p>To understand hash maps, we first must understand what a map is. A map is a data
structure that allows you to store key-value pairs. Here&#39;s an example in
JavaScript:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>map </span><span>= new </span><span>Map</span><span>()</span><span>;
</span><span>map</span><span>.</span><span>set</span><span>(</span><span>&#34;hello&#34;</span><span>, </span><span>&#34;world&#34;</span><span>)</span><span>;
</span><span>console</span><span>.</span><span>log</span><span>(map</span><span>.</span><span>get</span><span>(</span><span>&#34;hello&#34;</span><span>))</span><span>;
</span></code></pre>
<p>Here we take a key-value pair (<code>&#34;hello&#34;</code> ‚Üí <code>&#34;world&#34;</code>) and store it in the map.
Then we print out the value associated with the key <code>&#34;hello&#34;</code>, which will be
<code>&#34;world&#34;</code>.</p>
<p>A more fun real-world use-case would be to find anagrams. An anagram is when two
different words contain the same letters, for example &#34;antlers&#34; and &#34;rentals&#34;
or &#34;article&#34; and &#34;recital.&#34; If you have a list of words and you want to find
all of the anagrams, you can sort the letters in each word alphabetically and
use that as a key in a map.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>words </span><span>= </span><span>[
</span><span>  </span><span>&#34;antlers&#34;</span><span>,
</span><span>  </span><span>&#34;rentals&#34;</span><span>,
</span><span>  </span><span>&#34;sternal&#34;</span><span>,
</span><span>  </span><span>&#34;article&#34;</span><span>,
</span><span>  </span><span>&#34;recital&#34;</span><span>,
</span><span>  </span><span>&#34;flamboyant&#34;</span><span>,
</span><span>]
</span><span>
</span><span>let </span><span>map </span><span>= new </span><span>Map</span><span>()</span><span>;
</span><span>
</span><span>for </span><span>(</span><span>let </span><span>word </span><span>of </span><span>words) {
</span><span>  </span><span>let </span><span>key </span><span>= </span><span>word
</span><span>    </span><span>.</span><span>split</span><span>(</span><span>&#39;&#39;</span><span>)
</span><span>    </span><span>.</span><span>sort</span><span>()
</span><span>    </span><span>.</span><span>join</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;
</span><span>
</span><span>  </span><span>if </span><span>(</span><span>!</span><span>map</span><span>.</span><span>has</span><span>(key)) {
</span><span>    map</span><span>.</span><span>set</span><span>(key</span><span>, </span><span>[])</span><span>;
</span><span>  }
</span><span>  map</span><span>.</span><span>get</span><span>(key)</span><span>.</span><span>push</span><span>(word)</span><span>;
</span><span>}
</span></code></pre>
<p>This code results in a map with the following structure:</p>
<pre data-lang="json"><code data-lang="json"><span>{
</span><span>  </span><span>&#34;aelnrst&#34;</span><span>: </span><span>[
</span><span>    </span><span>&#34;antlers&#34;</span><span>,
</span><span>    </span><span>&#34;rentals&#34;</span><span>,
</span><span>    </span><span>&#34;sternal&#34;
</span><span>  ]</span><span>,
</span><span>  </span><span>&#34;aceilrt&#34;</span><span>: </span><span>[
</span><span>    </span><span>&#34;article&#34;</span><span>,
</span><span>    </span><span>&#34;recital&#34;
</span><span>  ]</span><span>,
</span><span>  </span><span>&#34;aabflmnoty&#34;</span><span>: </span><span>[
</span><span>    </span><span>&#34;flamboyant&#34;
</span><span>  ]
</span><span>}
</span></code></pre>
<h3 id="implementing-our-own-simple-hash-map"><a href="#implementing-our-own-simple-hash-map">#</a>
Implementing our own simple hash map</h3>
<p>Hash maps are one of many map implementations, and there are many ways to
implement hash maps. The simplest way, and the way we&#39;re going to demonstrate,
is to use a list of lists. The inner lists are often referred to as &#34;buckets&#34; in
the real-world, so that&#39;s what we&#39;ll call them here. A hash function is used on
the key to determine which bucket to store the key-value pair in, then the
key-value pair is added to that bucket.</p>
<p>Let&#39;s walk through a simple hash map implementation in JavaScript. We&#39;re going
to go through it bottom-up, so we&#39;ll see some utility methods before getting to
the <code>set</code> and <code>get</code> implementations.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>class </span><span>HashMap </span><span>{
</span><span>  </span><span>constructor</span><span>() {
</span><span>    </span><span>this.</span><span>bs </span><span>= </span><span>[[]</span><span>, </span><span>[]</span><span>, </span><span>[]]</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>We start off by creating a <code>HashMap</code> class with a constructor that sets up 3
buckets. We use 3 buckets and the short variable name <code>bs</code> so that this code
displays nicely on devices with smaller screens. In reality, you could have
however many buckets you want (and better variable names).</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>class </span><span>HashMap </span><span>{
</span><span>  </span><span>// ...
</span><span>  </span><span>bucket</span><span>(key) {
</span><span>    </span><span>let </span><span>h </span><span>= </span><span>murmur3</span><span>(key)</span><span>;
</span><span>    </span><span>return this.</span><span>bs[
</span><span>      h </span><span>% this.</span><span>bs</span><span>.</span><span>length
</span><span>    ]</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>The <code>bucket</code> method uses <code>murmur3</code> on the <code>key</code>
passed in to find a bucket to use. This is the only place in our hash map code
that a hash function is used.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>class </span><span>HashMap </span><span>{
</span><span>  </span><span>// ...
</span><span>  </span><span>entry</span><span>(bucket</span><span>, </span><span>key) {
</span><span>    </span><span>for </span><span>(</span><span>let </span><span>e </span><span>of </span><span>bucket) {
</span><span>      </span><span>if </span><span>(e</span><span>.</span><span>key </span><span>=== </span><span>key) {
</span><span>        </span><span>return </span><span>e</span><span>;
</span><span>      }
</span><span>    }
</span><span>    </span><span>return null</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>The <code>entry</code> method takes a <code>bucket</code> and a <code>key</code> and scans the bucket until it
finds an entry with the given key. If no entry is found, <code>null</code> is returned.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>class </span><span>HashMap </span><span>{
</span><span>  </span><span>// ...
</span><span>  </span><span>set</span><span>(key</span><span>, </span><span>value) {
</span><span>    </span><span>let </span><span>b </span><span>= this.</span><span>bucket</span><span>(key)</span><span>;
</span><span>    </span><span>let </span><span>e </span><span>= this.</span><span>entry</span><span>(b</span><span>, </span><span>key)</span><span>;
</span><span>    </span><span>if </span><span>(e) {
</span><span>      e</span><span>.</span><span>value </span><span>= </span><span>value</span><span>;
</span><span>      </span><span>return</span><span>;
</span><span>    }
</span><span>    b</span><span>.</span><span>push</span><span>({ key</span><span>, </span><span>value })</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>The <code>set</code> method is the first one we should recognise from our earlier
JavaScript <code>Map</code> examples. It takes a key-value pair and stores it in our hash
map. It does this by using the <code>bucket</code> and <code>entry</code> methods we created earlier.
If an entry is found, its value is overwritten. If no entry is found, the
key-value pair is added to the map. In JavaScript, <code>{ key, value }</code> is
shorthand for <code>{ key: key, value: value }</code>.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>class </span><span>HashMap </span><span>{
</span><span>  </span><span>// ...
</span><span>  </span><span>get</span><span>(key) {
</span><span>    </span><span>let </span><span>b </span><span>= this.</span><span>bucket</span><span>(key)</span><span>;
</span><span>    </span><span>let </span><span>e </span><span>= this.</span><span>entry</span><span>(b</span><span>, </span><span>key)</span><span>;
</span><span>    </span><span>if </span><span>(e) {
</span><span>      </span><span>return </span><span>e</span><span>.</span><span>value</span><span>;
</span><span>    }
</span><span>    </span><span>return null</span><span>;
</span><span>  }
</span><span>}
</span></code></pre>
<p>The <code>get</code> method is very similar to <code>set</code>. It uses <code>bucket</code> and <code>entry</code> to find
the entry related to the <code>key</code> passed in, just like <code>set</code> does. If an entry is
found, its <code>value</code> is returned. If one isn&#39;t found, <code>null</code> is returned.</p>
<p>That was quite a lot of code. What you should take away from it is that our
hash map is a list of lists, and a hash function is used to know which of the
lists to store and retrieve a given key from.</p>
<p>Here&#39;s a visual representation of this hash map in action. <span>Click</span> anywhere on the buckets to add a new key-value pair using our
<code>set</code> method. To keep the visualisation simple, if a bucket were to &#34;overflow&#34;,
the buckets are all reset.</p>

<p>Because we&#39;re using <code>murmur3</code> as our hash
function, you should see good distribution between the buckets.  It&#39;s expected
you&#39;ll see <em>some</em> imbalance, but it should generally be quite even.</p>
<p>To get a value out of the hash map, we first hash the key to figure out which
bucket the value will be in. Then we have to compare the key we&#39;re searching for
against all of the keys in the bucket.</p>
<p>It&#39;s this search step that we minimise through hashing, and why <code>murmur3</code> is optimised for speed. The faster the hash
function, the faster we find the right bucket to search, the faster our hash
map is overall.</p>
<p>This is also why reducing collisions is so crucial. If we did decide to use that
dummy hash function from all the way at the start of this article, the one that
returns 0 all the time, we&#39;ll put all of our key-value pairs into the first
bucket. Finding anything could mean we have to check all of the values in the
hash map. With a good hash function, with good distribution, we reduce the
amount of searching we have to do to 1/N, where N is the number of buckets.</p>
<p>Let&#39;s see how <code>stringSum</code> does.</p>

<p>Interestingly, <code>stringSum</code> seems to distribute
values quite well. You notice a pattern, but the overall distribution looks
good.</p>
<blockquote>
<img src="https://samwho.dev/images/haskie-triumphant.png"/>
<p>
  Finally! A win for <code>stringSum</code>. I knew it would
  be good for something.
</p>
</blockquote>
<p>Not so fast, Haskie. We need to talk about a serious problem. The distribution
looks okay on these sequential numbers, but we&#39;ve seen that <code>stringSum</code> doesn&#39;t have a good avalanche effect. This doesn&#39;t end
well.</p>
<h2 id="real-world-collisions"><a href="#real-world-collisions">#</a>
Real-world collisions</h2>
<p>Let&#39;s look at 2 real-world data sets: IP addresses and English words. What I&#39;m
going to do is take 100,000,000 random IP addresses and <a href="https://github.com/dwyl/english-words">466,550 English
words</a>, hash all of them with both <code>murmur3</code>
and <code>stringSum</code>, and see how many collisions we get.</p>
<p><b>IP Addresses</b></p>
<table>
  <tbody><tr><th>
  </th>
  <th>
    <code>murmur3</code>
  </th>
  <th>
    <code>stringSum</code>
  </th>
</tr><tr>
    <td>Collisions</td>
    <td>1,156,959</td>
    <td>99,999,566</td>
  </tr>
<tr>
    <td></td>
    <td>1.157%</td>
    <td>99.999%</td>
  </tr>
</tbody></table>
<p><b>English words</b></p>
<table>
  <tbody><tr><th>
  </th>
  <th>
    <code>murmur3</code>
  </th>
  <th>
    <code>stringSum</code>
  </th>
</tr><tr>
    <td>Collisions</td>
    <td>25</td>
    <td>464,220</td>
  </tr>
<tr>
    <td></td>
    <td>0.005%</td>
    <td>99.5%</td>
  </tr>
</tbody></table>
<p>When we use hash maps for real, we aren&#39;t usually storing random values in them.
We can imagine counting the number of times we&#39;ve seen an IP address in rate
limiting code for a server. Or code that counts the occurrences of words in
books throughout history to track their origin and popularity. <code>stringSum</code> sucks for these applications because of it&#39;s extremely
high collision rate.</p>
<h2 id="manufactured-collisions"><a href="#manufactured-collisions">#</a>
Manufactured collisions</h2>
<p>Now it&#39;s <code>murmur3</code>&#39;s turn for some bad news.
It&#39;s not just collisions caused by similarity in the input we have to worry
about. Check this out.</p>

<p>What&#39;s happening here? Why do all of these jibberish strings hash to the same
number?</p>
<p>I hashed 141 trillion random strings to find values that hash to the number
<code>1228476406</code> when using <code>murmur3</code>.  Hash functions
have to always return the same output for a specific input, so it&#39;s possible to
find collisions by brute force.</p>
<blockquote>
<img src="https://samwho.dev/images/haskie-concerned.png"/>
<p>
  I&#39;m sorry, 141 <b>trillion</b>? Like... 141 and then 12 zeroes?
</p>
</blockquote>
<p>Yes, and it only took me 25 minutes. <a href="https://computers-are-fast.github.io/">Computers are fast</a>.</p>
<p>Bad actors having easy access to collisions can be devastating if your software
builds hash maps out of user input.  Take HTTP headers, for example. An HTTP
request looks like this:</p>
<pre data-lang="txt"><code data-lang="txt"><span>GET / HTTP/1.1
</span><span>Accept: */*
</span><span>Accept-Encoding: gzip, deflate
</span><span>Connection: keep-alive
</span><span>Host: google.com
</span></code></pre>
<p>You don&#39;t have to understand all of the words, just that the first line is the
path being requested and all of the other lines are headers. Headers are <code>Key: Value</code> pairs, so HTTP servers tend to use maps to store them.  Nothing stops us
from passing any headers we want, so we can be really mean and pass headers we
know will cause collisions. This can significantly slow down the server.</p>
<p><a href="https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/">This isn&#39;t
theoretical, either</a>.
If you search &#34;HashDoS&#34; you&#39;ll find a lot more examples of this. It was a really
big deal in the mid-2000s.</p>
<p>There are a few ways to mitigate this specific to HTTP servers: ignoring
jibberish header keys and limiting the number of headers you store, for
example. But modern hash functions like <code>murmur3</code>
offer a more generalised solution: randomisation.</p>
<p>Earlier in this post we showed some examples of hash function implementations.
Those implementations took a single argument: <code>input</code>. Lots of modern hash
functions take a 2nd parameter: <code>seed</code> (sometimes called <code>salt</code>). In the case
of <code>murmur3</code>, this seed is a number.</p>
<p>So far, we&#39;ve been using 0 as the seed. Let&#39;s see what happens with the
collisions I&#39;ve collected when we use a seed of 1.</p>

<p>Just like that, 0 to 1, the collisions are gone. This is the purpose of the
seed: it randomises the output of the hash function in an unpredictable way.
How it achieves this is beyond the scope of this article, all hash functions do
this in their own way.</p>
<p>The hash function still returns the same output for the same input, it&#39;s just
that the input is a combination of <code>input</code> and <code>seed</code>.  Things that collide with
one seed shouldn&#39;t collide when using another.  Programming languages often
generate a random number to use as the seed when the process starts, so that
every time you run your program the seed is different. As a bad guy, not knowing
the seed, it is now impossible for me to reliably cause harm.</p>
<p>If you look closely in the above visualisation and the one before it, they&#39;re
the same values being hashed but they produce different hash values. The
implication of this is that if you hash a value with one seed, and want to be
able to compare against it in the future, you need to make sure you use the same
seed.</p>
<p>Having different values for different seeds doesn&#39;t affect the hash map
use-case, because hash maps only live for the duration the program is running.
Provided you use the same seed for the lifetime of the program, your hash maps
will continue to work just fine. If you ever store hash values outside of your
program, in a file for example, you need to be careful you know what seed has
been used.</p>
<h2 id="playground"><a href="#playground">#</a>
Playground</h2>
<p>As is tradition, I&#39;ve made a playground for you to write your own hash functions
and see them visualised with the grids seen in this article.  Click
<a href="https://samwho.dev/hashing-playground/">here</a> to try it!</p>
<h2 id="conclusion"><a href="#conclusion">#</a>
Conclusion</h2>
<p>We&#39;ve covered what a hash function is, some ways to measure how good it is,
what happens when it&#39;s not good, and some of the ways they can be broken by
bad actors.</p>
<p>The universe of hash functions is a large one, and we&#39;ve really only scratched
the surface in this post. We haven&#39;t spoken about cryptographic vs
non-cryptographic hashing, we&#39;ve touched on only 1 of the thousands of use-cases
for hash functions, and we haven&#39;t talked about how exactly modern hash
functions actually work.</p>
<p>Some further reading I recommend if you&#39;re really enthusiastic about this topic
and want to learn more:</p>
<ul>
<li><a href="https://github.com/rurban/smhasher">https://github.com/rurban/smhasher</a> this repository is the gold standard
for testing how good hash functions are. They run a tonne of tests against
a wide number of hash functions and present the results in a big table. It
will be difficult to understand what all of the tests are for, but this is
where the state of the art of hash testing lives.</li>
<li><a href="https://djhworld.github.io/hyperloglog/">https://djhworld.github.io/hyperloglog/</a> this is an interactive piece
on a data structure called HyperLogLog. It&#39;s used to efficiently count the
number of unique elements in very, very large sets. It uses
hashing to do it in a really clever way.</li>
<li><a href="https://www.gnu.org/software/gperf/">https://www.gnu.org/software/gperf/</a> is a piece of software that, when given
the expected set of things you want to hash, can generate a &#34;perfect&#34; hash
function automatically.</li>
</ul>
<p>Feel free to join the discussion on <a href="https://news.ycombinator.com/item?id=36401747">Hacker News</a>!</p>
<h2 id="acknowledgements"><a href="#acknowledgements">#</a>
Acknowledgements</h2>
<p>Thanks to everyone who read early drafts and provided invaluable feedback.</p>
<ul>
<li><a href="https://delroth.net/">delroth</a>, <a href="https://twitter.com/Manon_Lef/">Manon</a>, <a href="https://medium.com/@AaronKalair">Aaron</a>, <a href="https://twitter.com/TheCoppinger">Charlie</a></li>
</ul>
<p>And everyone who helped me find <code>murmur3</code> hash
collisions:</p>
<ul>
<li><a href="https://indy.codes/">Indy</a>, <a href="https://medium.com/@AaronKalair">Aaron</a>, Max</li>
</ul>
<h2 id="patreon"><a href="#patreon">#</a>
Patreon</h2>
<p>After the success of <a href="https://samwho.dev/load-balancing/">Load Balancing</a> and <a href="https://samwho.dev/memory-allocation/">Memory
Allocation</a>, I have decided to set up a Patreon page:
<a href="https://patreon.com/samwho">https://patreon.com/samwho</a>. For all of these articles going forward, I am
going to post a Patreon-exclusive behind-the-scenes post talking about
decisions, difficulties, and lessons learned from each post. It will give you
a deep look in to how these articles evolve, and I&#39;m really stoked about
the one I&#39;ve written for this one.</p>
<p>If you enjoy my writing, and want to support it going forward, I&#39;d really
appreciate you becoming a Patreon. ‚ù§Ô∏è</p>

    </div></div>
  </body>
</html>
