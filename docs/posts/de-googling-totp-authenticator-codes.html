<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://imrannazar.com/articles/degoogle-otp">Original</a>
    <h1>De-Googling TOTP Authenticator Codes</h1>
    
    <div id="readability-page-1" class="page"><div>
   <article>
<p><a href="https://imrannazar.com/articles" id="parent">Back to Articles</a></p>
<time datetime="2025-09-01 07:28:06" pubdate="">1st Sep 2025</time>
<p>In the ongoing effort to extricate myself from Google&#39;s services, I&#39;ve been paring down my usage of their apps on my (admittedly Android) phone. I&#39;m now down to two Google apps I use regularly: Maps (for traffic data) and Authenticator (for TOTP<cite><sup>[A]</sup><mark>Time-based One Time Password</mark></cite> codes).</p>
<p>Now, I spend most of my time in a terminal window on MacOS or connected to a Linux machine; it&#39;d be nice if I could get TOTPs on the command-line, and it turns out there&#39;s a utility called <code>oathtool</code> that allows for TOTP generation on the CLI. However, that would mean switching my OTP provider, which usually involves:</p>
<ul>
 <li>Logging into each service that has an OTP registered in the app;</li>
 <li>Disabling two-factor authentication (2FA);</li>
 <li>Re-enabling 2FA and using the &#34;manual entry&#34; code as input to <code>oathtool</code>;</li>
 <li>Doing it all again for the next website or service.</li>
</ul>
<p>Fortunately, Google&#39;s Authenticator provides a way to migrate codes between instances of the app based on scanning QR codes, and we can use this to migrate them away from Google into a TOTP handler of our choosing. It&#39;s another four-step process:</p>
<ul>
 <li><strong>Generating a QR code</strong> in Google Authenticator for the codes you want to export;</li>
 <li><strong>Decoding the QR</strong> somewhere off-device, into a URL;</li>
 <li><strong>Decoding the URL</strong> into its constituent services and secret values;</li>
 <li><strong>Setting up <code>oathtool</code></strong> to use the secrets.</li>
</ul>
<p>Note that the below steps are presented just as I went through them, you may be able to find efficiencies or you may run into troubles that I didn&#39;t (especially if you&#39;re trying this exclusively on Windows); &#34;your mileage may vary&#34; is apt here.</p>
<h2>Going from Authenticator to a migration URL</h2>
<p>The first step is getting the code out of Authenticator, through the Transfer Codes menu option in the app. Picking the services you&#39;d like to extract leads you to a code like this:</p>
<figure>
 <img src="https://imrannazar.com/content/img/totp-cli-qr.png" alt="QR code for The Rickroll Store&#39;s OTP"/>
 <figcaption>Figure 1: QR code exported from Google Authenticator</figcaption>
</figure>
<p>You may have an app on your phone that decodes QRs, but I don&#39;t; instead, I transferred the file to my MacOS machine over Tailscale, and used a command-line tool called <code>qrtool</code> to get the QR content:</p>
<samp>
 <h3>Decoding the migration QR</h3>
 <pre>$ brew install qrtool
$ qrtool decode Screenshot_20250901_062719_Authenticator.jpg
otpauth-migration://offline?data=CjwKC2kqSJnNaAyKkw6jEhJUaGUgUmlja3JvbGwgU3RvcmUgASgBMAJCEzg4Yzg5ZTE3NTY3MDQzOTE0MzkQAhgBIAA%3D</pre>
</samp>
<h2>Decoding the URL into secrets</h2>
<p>So we have our migration URL, with a Base64-encoded data block. Unfortunately, if we were to simply decode the data, we&#39;d end up with some binary gibberish:</p>
<samp>
 <h3>Trying to decode the URL directly</h3>
 <pre>$ php -r &#39;var_dump(base64_decode(&#34;CjwKC2kqSJnNaAyKkw6jEhJUaGUgUmlja3JvbGwgU3RvcmUgASgBMAJCEzg4Yzg5ZTE3NTY3MDQzOTE0MzkQAhgBIAA%3D&#34;));&#39;
string(69) &#34;
&lt;

i*H??h??Ã½</pre>
</samp>
<p>It turns out that this is a Protobuf-encoded data string, and we need to use Google&#39;s Protobuf library to get the data out. It turns out Tim Brooks has already done this with a short piece of Python at: <a href="https://github.com/brookst/otpauth_migrate" target="_blank" rel="nofollower noreferrer">https://github.com/brookst/otpauth_migrate</a></p>
<p>I decided to install this on a Linux machine I tend to be connected to (entirely unrelated to my Python installation being broken on Mac...):</p>
<samp>
 <h3>Extracting the data via <code>otpauth_migrate</code></h3>
 <pre>$ git clone https://github.com/brookst/otpauth_migrate
$ cd otpauth_migrate
$ ./otpauth_migrate.py otpauth-migration://offline?data=CjwKC2kqSJnNaAyKkw6jEhJUaGUgUmlja3JvbGwgU3RvcmUgASgBMAJCEzg4Yzg5ZTE3NTY3MDQzOTE0MzkQAhgBIAA%3D
secret: &#34;i*H\231\315h\014\212\223\016\243&#34;
name: &#34;The Rickroll Store&#34;
algorithm: ALGORITHM_SHA1
digits: DIGIT_COUNT_SIX
type: OTP_TYPE_TOTP

Secret code = NEVERGONNAGIVEYOUM======</pre>
</samp>
<p>This tool is intelligent enough to extract any number of names and secrets from a migration URL, so you can export all your codes from Authenticator into one giant QR without needing to do each separately.</p>
<h2>Using oathtool to generate OTPs</h2>
<p>The final step is to use this secret code with <code>oathtool</code>, which takes the secret directly as a parameter. If you instead want to refer to the service by name, Michael Bushey<cite><sup>[1]</sup><mark><a href="https://www.sendthemtomir.com/blog/cli-2-factor-authentication">&#34;CLI 2-Factor Authentication&#34;</a>, Michael Bushey, 2023</mark></cite> has a quick wrapper script which extracts the secrets from a locally-stored file:</p>
<samp>
 <h3>Wrapper script to generate OTPs: <code>/usr/local/bin/otp</code></h3>
 <pre><s>#!/bin/bash</s>
<var>OTPKEY</var>=<var>&#34;$(<kbd>sed</kbd> -n &#34;s/${1}=//p&#34; ~/.otpkeys)&#34;</var>
<kbd>if</kbd> [ -z <var>&#34;$OTPKEY&#34;</var> ]; <kbd>then</kbd>
   <kbd>echo</kbd> <var>&#34;$(<kbd>basename</kbd> $0): Bad Service Name &#39;$1&#39;&#34;</var>
   <kbd>exit
fi
date
oathtool</kbd> --totp -b <var>&#34;$OTPKEY&#34;</var></pre>
 <h3>OTP key store: <code>~/.otpkeys</code></h3>
 <pre>rickroll=NEVERGONNAGIVEYOUM======</pre>
</samp>
<p>With this in place, you won&#39;t need to use your Authenticator app again. The tool outputs the current date and time, so you can double-check that your code won&#39;t expire (at :00 seconds) before you get a chance to type it in:</p>
<samp>
 <pre>$ otp rickroll
Mon Sep  1 07:10:42 AM UTC 2025
200213</pre>
</samp>
<h2>Future expansion</h2>
<p>There&#39;s a security issue here, of course, which is the exposed secret key sitting in a file on-disk. I&#39;m happy to sit with that and not require a password to generate OTPs every time, but if you&#39;re interested in adapting the wrapper script to use symmetric encryption to secure the keys, Vivek Gite<cite><sup>[2]</sup><mark><a href="https://www.cyberciti.biz/faq/use-oathtool-linux-command-line-for-2-step-verification-2fa/" target="_blank" rel="noreferrer nofollower">&#34;Use oathtool Linux command line for 2 step verification (2FA)&#34;</a>, Vivek Gite, updated Feb 2025</mark></cite> has a set of scripts which employ <code>gpg</code> for the job.</p>
<p>Now I just need to find a way to get traffic data into a maps App that doesn&#39;t involve Google&#39;s servers... Thoughts welcome.</p>
  
  
 
    </article>
  </div></div>
  </body>
</html>
