<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pagetable.com/?p=1107">Original</a>
    <h1>Fitting 44% More Data on a C64/1541 Floppy Disk</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			<p>The physical data format on a Commodore 1541 5¼-inch floppy disk as used by the C64 is completely defined in software. The drive’s operating system fits 170 KB on a disk. This article explores different strategies, each with its pros and cons, to fit up to 246 KB.</p>
<h2 id="Regular-1541-Disk-Format">Regular 1541 Disk Format</h2>
<p>These are the specifications of the original 5¼-inch “minifloppy” from 1976:</p>
<ul>
<li>35 tracks</li>
<li>radius of outermost track: 57.150 mm</li>
<li>track spacing: 1/48 inch (i.e. 48 tpi, tracks-per-inch)</li>
<li>track capacity: 50 Kbit/track<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (= 25.4 bytes per millimeter on track 35)</li>
</ul>
<p>The Shugart SA-400 drive, which defined the minifloppy, included a controller that formatted the disk with 90 KB. <a href="http://www.apple1notes.com/old_apple/Huston_Stories_files/Disk%20SN1.htm">Like Apple</a>, Commodore bought just the mechanism without the controller (Shugart called this the SA-390), and used its own 6502-based system as the controller (which was cheaper) and defined their own format (which made better use of the disk).</p>
<p>The Shugart format was using the same number of sectors on each track. But tracks on the outside are longer: track 1 is 46% longer than track 35. And if the material on the disk must be able to hold 50 Kbit on track 35, it must be safe to store 70 KBit on track 1. The combined length of all tracks is 10590 mm, so based on the 50 KBit for track 35, the whole disk can hold 269 KB<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, if every track is read and written at its individual speed.</p>
<p>Commodore chose to support four speed <em>zones</em>. The fastest one on the outside tracks reads and writes a byte every 26 µs (at 300 rpm), the slowest one on the inside does this every 32 µs.</p>
<table>
<thead>
<tr>
<th> Track   </th>
<th> # Sectors </th>
<th> Speed Zone </th>
<th> µs/Byte </th>
<th> Raw Kbit/Track </th>
</tr>
</thead>
<tbody>
<tr>
<td>  1 – 17 </td>
<td> 21        </td>
<td> 3          </td>
<td> 26      </td>
<td> 60.0           </td>
</tr>
<tr>
<td> 18 – 24 </td>
<td> 19        </td>
<td> 2          </td>
<td> 28      </td>
<td> 55.8           </td>
</tr>
<tr>
<td> 25 – 30 </td>
<td> 18        </td>
<td> 1          </td>
<td> 30      </td>
<td> 52.1           </td>
</tr>
<tr>
<td> 31 – 35 </td>
<td> 17        </td>
<td> 0          </td>
<td> 32      </td>
<td> 48.8           </td>
</tr>
</tbody>
</table>
<p>The following graph shows the data densities per millimeter for tracks 1 to 35. The 25.4 bytes per millimeter of the original specification are never exceeded<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. (An optimum scheme would max out the 25.4 bytes/mm on all tracks.)</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/chart1.png" height="250" width="600" alt=""/></p>
<p>It is interesting to note that track 18, which holds the filesystem metadata, and is therefore the most important track of the disk, has a comparably low density and should therefore have higher reliability.</p>
<p>With the 17 to 21 sectors per track, this makes a total of 683 sectors of 256 bytes each, or 170.75 KB.</p>
<h2 id="Tracks-36-41">Tracks 36-41</h2>
<p>While the original “minifloppy” disk format only specified 35 tracks, later disks (with larger cutouts) and drive mechanics supported 40 tracks.</p>
<p>While the firmware of all 48 tpi Commodore 5¼-inch drives stayed with the original 35 track format, the mechanics of the 1541 and later drives are designed for 40 tracks, and in practice, all drives can even reach track 41, and the magnetic layer of disks is still reliable on track 41 as well<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>
<p>There have always been a number of tools to format, read and write data in tracks 36-40 (or 41). They usually use speed zone 0, the slowest one, so each track fits another 17 sectors, for a total of 85 (or 102) extra sectors, or 21 (25) KB. This is a disk capacity increase of 12% (15%).</p>
<p>It seems straightforward and safe to use the extra tracks (at least until track 40) like this, but the density used on these tracks actually exceeds the specified 25.4 bytes per millimeter by up to 8.7%</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/chart2.png" height="250" width="600" alt=""/></p>
<h2 id="Max-Speed-Zones">Max Speed Zones</h2>
<p>A more radical approach to fitting more data is to use the fastest speed zone for all tracks. This way, every track will hold 21 sectors, for a total disk capacity of 861 sectors (215 KB) when using 41 tracks.</p>
<p>(In practice, track 18 of disks in a custom format have to be formatted in the original format, otherwise the original DOS won’t be able to e.g. load the boot program of a game or an application. This limitation does of course not apply to extra data disks of a game, or pure user data disks.)</p>
<p>But this will exceed the specified capacity of the medium for tracks 18 and above: in the case of track 41 even by 34%!</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/chart3.png" height="250" width="600" alt=""/></p>
<p>How reliable is a disk written with too high a density? Let’s do an experiment.</p>
<p>The following Python script will create a description of an all-speed-zone-3 test disk. Each of the 41 tracks contains 21 sectors filled with 0..255. Otherwise, the disk is completely consistent with the Commodore “2A” on-disk format.</p>
<pre><code>print &#39;no-tracks 84&#39;  
print &#39;track-size 7928&#39;  
for track in range(1,42):  
    print &#39;track {}&#39;.format(track)  
    print &#39;   speed 3&#39;  
    print &#39;   begin-at 0&#39;  
    for sector in range(0, 21):  
        print &#39;   sync 40&#39;  
        print &#39;   gcr 08&#39; # header  
        print &#39;   begin-checksum&#39;  
        print &#39;      checksum {:02x}&#39;.format(track ^ sector)  
        print &#39;      gcr {:02x}&#39;.format(sector)  
        print &#39;      gcr {:02x}&#39;.format(track)  
        print &#39;      gcr 30 30&#39; # ID  
        print &#39;   end-checksum&#39;  
        print &#39;   gcr 0f 0f&#39; # OFF bytes  
        print &#39;   ; Trk {} Sec {}&#39;.format(track, sector)  
        print &#39;   bytes 55 55 55 55 55 55 55 55 55&#39; # gap  
        print &#39;   sync 40&#39;  
        print &#39;   gcr 07&#39; # data  
        print &#39;   begin-checksum&#39;  
        print &#39;      gcr&#39;,  
        for i in range(0, 256):  
            print &#39;{:02x}&#39;.format(i),  
        print &#39;&#39;  
        print &#39;      checksum 00&#39;  
        print &#39;   end-checksum&#39;  
        print &#39;   gcr 00 00&#39; # OFF bytes  
        print &#39;   bytes 55 55 55 55 55 55 55&#39; # gap  
    print &#39;end-track&#39;
</code></pre>
<p>The <code>.TXT</code> output of the script can be converted into a binary <code>.G64</code> image using the excellent <a href="https://github.com/markusC64/g64conv">g64conv</a> utility. Using a <a href="http://store.go4retro.com/zoomfloppy/">ZoomFloppy</a>, <a href="https://c64preservation.com/nibtools">nibtools</a> and either a 1541 with a parallel cable mod or a 1571, you can write this image to disk (<code>nibwrite</code>), and then keep reading it in a loop (<code>nibread</code>). I was able to read such a disk 1000 times on a 1571 without any errors.</p>
<h2 id="Minimizing-Gaps">Minimizing Gaps</h2>
<p>But there is a way to fit 41 more blocks (10.25 KB, 20% extra) without exceeceding the specs of 48 tpi disks – and still being read compatible with the original firmware.</p>
<p>Let’s look at track 1 with its 21 sectors. For every sector, there is a SYNC mark, a header, another sync mark, and the sector data.</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/sector.png" height="140" width="600" alt=""/></p>
<p>This structure gets written when a disk is first formatted. When reading a sector, the drive looks for a SYNC pattern, reads the header, which contains among other data the number of the sector that follows, and if it is the correct sector number, it waits for another SYNC mark and reads the sector data.</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/rawdata1.png" height="64" width="600" alt=""/></p>
<p>When writing a sector, the drive also looks for the correct header, and then overwrites the section afterwards, including the SYNC mark.</p>
<p>Since it is impossible to hit one particular byte location when switching to write mode, there is a 9 byte gap after the header, and another gap (usually 8 bytes) after the sector contents<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. It won’t matter if the newly written sector is a few bytes too early or too late, because it will only spill into one of the two gaps:</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/rawdata2.png" height="100" width="600" alt=""/></p>
<p>In addition, there are “tail gaps” at the end of each track:</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/track_ends.png" height="346" width="280" alt=""/></p>
<p>The lengths of the sectors in each speed zone don’t add up to the complete length of the track. This is because the tracks are not evenly divisible by their number of sectors, and also to account for drives with slightly incorrect motor speeds.</p>
<p>By minimzing some of these accounting structures and using more of the tail gaps for data, it is possible to fit one or two additional sectors onto each track.</p>
<h3 id="Data-Gaps">Data Gaps</h3>
<p>There are usually around 8 gap bytes after the sector data. If we remove them, reading the disk will not be impacted in any way: After reading a sector, a drive never immediately reads the next one, because it will have to decode and transmit the data first. And even if it did, in the worst case, it might miss the next sector, because the next header has arrived too quickly, but it will catch it again after one rotation.</p>
<p>Removing the gap after the sector data will make correctly writing to the disk impossible though. There is very little wiggle room for hitting the correct range of bytes when overwriting a sector. Overshooting the area will easily destroy the next SYNC mark or the next header, so the following sector won’t be readable any more.</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/rawdata3.png" height="100" width="600" alt=""/></p>

<p>A standard disk has 9 gap bytes after the header. It is not possible to completely remove it and still be compatible with the sector read routines in the 1541 firmware: After the drive has read the header, it needs to decode it and decide whether this is the sector it is looking for. If it is, it will scan for the next SYNC mark and then read the data. But decoding and deciding takes time, and every 26 to 32 CPU clock cycles, the next byte passes the read head. So if there is no gap, the SYNC mark will have passed the read head before the drive has made the decision to read this sector.</p>
<p>With 2 gap bytes instead of 9, the original read code still works, and so does most other third party read code.</p>
<p>Like removing the data gap, minimizing the gap after the header will also break writing, and this time horribly. When overwriting the sector, the original firmware code will skip 9 bytes before beginning to write the SYNC mark and the sector data. If there is no gap at the end of the data, it is guaranteed to overwrite the next header. But even if there is, when skipping the supposed header gap (“wait 9 bytes”), it is actually skipping the SYNC mark and the beginning of the old sector data. So when the sector gets read again, the first SYNC mark gets detected, but the data is overwritten by the misaligned new sector data.</p>
<p><img src="https://www.pagetable.com/docs/1541_max_data/rawdata4.png" height="140" width="600" alt=""/></p>
<h3 id="SYNC-Marks">SYNC Marks</h3>
<p>The SYNC marks consists of sequences of consecutive 1-bits, which cannot otherwise be part of the data stream. For a SYNC to be detected, it needs to be at least 10 bits long. The original firmware always writes 40 bits, but we can trim this down to 16 bits, saving 2×3 bytes for every sector.</p>
<h3 id="The-Format">The Format</h3>
<p>With a 2 byte header gap, no sector gap and 16 bit SYNC marks, we have saved 18 bytes per sector. Now there is space for one more sector on tracks 1-17 and 25-35, and even two more sectors on tracks 18-24<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>.</p>
<p>The following python code will generate a <code>.TXT</code> test file that can be converted to a <code>.G64</code> using <code>g64conv</code>.</p>
<pre><code>def speed_for_track(track):  
    if track &lt; 18:  
        return 3  
    if track &lt; 25:  
        return 2  
    if track &lt; 31:  
        return 1  
    return 0

def sectors_for_track(track):  
    return [18, 19, 21, 22][speed_for_track(track)]

    print &#39;no-tracks 84&#39;  
    print &#39;track-size 7928&#39;  
    for track in range(1, 36):  
        print &#39;track {}&#39;.format(track)  
        print &#39;   speed &#39;.format(speed_for_track(track))  
        print &#39;   begin-at 0&#39;  
        for sector in range(0, sectors_for_track(track)):  
            print &#39;   sync 16&#39;  
            print &#39;   gcr 08&#39; # header  
            print &#39;   begin-checksum&#39;  
            print &#39;      checksum {:02x}&#39;.format(track ^ sector)  
            print &#39;      gcr {:02x}&#39;.format(sector)  
            print &#39;      gcr {:02x}&#39;.format(track)  
            print &#39;      gcr 30 30&#39; # ID  
            print &#39;   end-checksum&#39;  
            print &#39;   gcr 0f 0f&#39; # OFF bytes  
            print &#39;   ; Trk {} Sec {}&#39;.format(track, sector)  
            print &#39;   bytes 55 55&#39; # gap  
            print &#39;   sync 16&#39;  
            print &#39;   gcr 07&#39; # data  
            print &#39;   begin-checksum&#39;  
            print &#39;      gcr&#39;,  
            for i in range(0, 128):  
                print &#39;{:02x} {:02x}&#39;.format(track, sector),  
            print &#39;&#39;  
            print &#39;      checksum 00&#39;  
            print &#39;   end-checksum&#39;  
            if track &gt;= 18:  
                print &#39;   bits 1111&#39;  
        print &#39;end-track&#39;
</code></pre>
<h3 id="Reading/Writing">Reading/Writing</h3>
<p>The original 1541 firmware can still read all regular sectors, but since it checks track/sector numbers for validity, the new sectors won’t be legal for regular files, and they can’t be read using the <code>U1</code> block read command either. The internal “job queue” API won’t do this check though. The following BASIC program will allocate buffer #2 (line 30), send a read command for track <code>T</code>, sector <code>S</code> into buffer 2 (lines 40-50), wait for its completion (lines 60-70), and receive and print the buffer (line 90-100).</p>
<pre><code>10 t=18:s=19  
20 open1,8,15  
30 open2,8,2,&#34;#2&#34;  
40 print#1,&#34;m-w&#34;+chr$(10)+chr$(0)+chr$(2)+chr$(t)+chr$(s);  
50 print#1,&#34;m-w&#34;+chr$(2)+chr$(0)+chr$(1)+chr$(128);  
60 print#1,&#34;m-r&#34;+chr$(2)+chr$(0)+chr$(1);  
70 get#1,a$:a=asc(a$+chr$(0)):ifaand128thenprint&#34;.&#34;;:goto70  
80 ifa&lt;&gt;1thenprint&#34;error &#34;;a:end  
90 print#1,&#34;b-p 2 0&#34;  
100 fori=0to255:get#2,a$:printasc(a$+chr$(0));:next  
110 close2:close1
</code></pre>
<p>Since writing any sector will destroy it as well as the following sectors, care must be taken that the user does not attempt to write to it. Commodore DOS stores a filesystem version identifier at track 18, sector 0, offset 2. This is “A” (0x41) on the 1541. Overwriting this byte with any other value will soft write protect the disk: All write accesses through the filesystem API will fail with code 73, but it cannot prevent direct block writes (command <code>U2</code>).</p>
<p>So with the caveat of not being able to write to the disk any more, we can create a disk with extra sectors that can still be read with the original software – a perfect use for game disks, for example. A game could use a disk that uses the extra sectors on all tracks including the directory track (track 18), and have the user load the initial boot program using the original 1541 DOS functionality. (The boot program cannot use any of the extra sectors.) Then, a fast loader would take over to load the actual game program and data. This can be any existing fast loader without any adaptations, as long as it doesn’t check for the validity of sector numbers.</p>
<h2 id="Max-Speed-Zones-+-Minimizing-Gaps">Max Speed Zones + Minimizing Gaps</h2>
<p>We can also use the fastest speed zone together with minimal gaps. This way, all tracks will have 22 sectors. With 41 tracks, that’s a total of 924 sectors (231 KB), which is 241 extra sectors, or 35% more capacity.</p>
<p>(Again, if the disk is supposed to be bootable, track 18 will have to have the regular format.)</p>
<h2 id="Custom-Format">Custom Format</h2>
<p>The Commodore DOS format uses a SYNC-prefixed header and a separate SYNC-prefixed data section, which is required so that sectors can be rewritten reliably. If a disk is not meant to be modified, we can change a sector to only pretty much only consist of a SYNC mark, its sector number, the 256 data bytes and a checksum. The next sector can just follow without any gap.</p>
<p>This format is of course completely incompatible with Commodore DOS and requires uploading custom read code into the 1541.</p>
<p>But it allows us to fit two extra sectors per track compared to the original format.</p>
<pre><code>def speed_for_track(track):  
    if track &lt; 18:  
        return 3  
    if track &lt; 25:  
        return 2  
    if track &lt; 31:  
        return 1  
    return 0

def sectors_for_track(track):  
    return [19, 20, 21, 23][speed_for_track(track)]

print &#39;no-tracks 84&#39;  
print &#39;track-size 7928&#39;  
for track in range(1, 36):  
    print &#39;track {}&#39;.format(track)  
    print &#39;   speed &#39;.format(speed_for_track(track))  
    print &#39;   begin-at 0&#39;  
    for sector in range(0, sectors_for_track(track)):  
        print &#39;   sync 16&#39;  
        print &#39;   gcr {:02x}&#39;.format(sector)  
        print &#39;   begin-checksum&#39;  
        print &#39;      gcr&#39;,  
        for i in range(0, 128):  
            print &#39;{:02x} {:02x}&#39;.format(track, sector),  
        print &#39;&#39;  
        print &#39;      checksum 00&#39;  
        print &#39;   end-checksum&#39;  
        print &#39;   bits 1111&#39;  
    print &#39;end-track&#39;
</code></pre>
<h2 id="Max-Speed-Zones-+-Custom-Format">Max Speed Zones + Custom Format</h2>
<p>Again, we can use speed zone 3 for all tracks, so they all have 23 sectors each, for a total of 943 sectors, or 38% more than a regular disk.</p>
<h2 id="Theoretical-Maximum">Theoretical Maximum</h2>
<p>The custom format was still using 256 byte sectors, each with a SYNC mark, a sector number and a checksum. What if we just stored everything in one giant sector? We still need one SYNC mark on the track, so we know where it starts, and in order to reset the hardware’s bit alignment logic. Speed zone 3 fits 7692 raw bytes onto a track. At least two bytes will be needed for the SYNC mark, and with the data GCR-encoded (and the size increasing by 5/4), we will have 6152 bytes for data, which is 24 sectors, with only 8 bytes to spare. Writing such a disk is only possible if the drive is no faster than 0.1% above the specified 300 rpm.</p>
<p>Writing this format onto all 41 tracks will give us 984 blocks (246 KB), or 44% more.</p>
<pre><code>print &#39;no-tracks 84&#39;  
print &#39;track-size 7928&#39;  
for track in range(1,42):  
    print &#39;track {}&#39;.format(track)  
    print &#39;   speed 3&#39;  
    print &#39;   begin-at 0&#39;  
    print &#39;   sync 16&#39;  
    print &#39;      gcr&#39;,  
    for i in range(0, 24 * 256):  
        print &#39;{:02x}&#39;.format(i &amp; 0xff),  
    print &#39;&#39;  
    print &#39;end-track&#39;
</code></pre>
<p>But reading will be tricky and <strong>slow</strong>. There is only one SYNC mark, so reading any portion of the track will first require waiting for the SYNC mark (1/10 sec on average). The single sector holds 6 KB of data, but the drive’s buffer RAM ist only 2 KB total, so it cannot store the whole sector. It therefore needs to skip any number of bytes until the requested section data stream is reached.</p>
<p>Using 512 or 1024 byte sectors that can still fit the drive’s RAM wouldn’t work though: The single giant 6 KB sector just barely fit with only 8 bytes to spare, breaking it up into smaller sectors would overflow the available space.</p>
<h2 id="Comparison">Comparison</h2>
<p>The following table is sorted by capacity:</p>
<table>
<thead>
<tr>
<th> Method                            </th>
<th> Capacity (blocks) </th>
<th> Capacity % </th>
<th> Compatible with DOS </th>
<th> Density Spec Compliant </th>
</tr>
</thead>
<tbody>
<tr>
<td> Regular Format                    </td>
<td> 683 (170 KB) </td>
<td> 100%       </td>
<td> yes                 </td>
<td> yes                    </td>
</tr>
<tr>
<td> Minimizing Gaps                   </td>
<td> 724 (181 KB) </td>
<td> 106%       </td>
<td> read-only           </td>
<td> yes                    </td>
</tr>
<tr>
<td> Custom Format                     </td>
<td> 753 (188 KB) </td>
<td> 110%       </td>
<td> no                  </td>
<td> yes                    </td>
</tr>
<tr>
<td> Tracks 36-41                      </td>
<td> 785 (196 KB) </td>
<td> 115%       </td>
<td> yes                 </td>
<td> kind of                </td>
</tr>
<tr>
<td> Minimizing Gaps + Tracks 36-41    </td>
<td> 832 (208 KB) </td>
<td> 122%       </td>
<td> read-only           </td>
<td> kind of                </td>
</tr>
<tr>
<td> Max Speed Zones<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>               </td>
<td> 861 (215 KB) </td>
<td> 126%       </td>
<td> no                  </td>
<td> no                     </td>
</tr>
<tr>
<td> Custom Format + Tracks 36-41      </td>
<td> 867 (216 KB) </td>
<td> 127%       </td>
<td> no                  </td>
<td> kind of                </td>
</tr>
<tr>
<td> Max Speed Zones + Minimizing Gaps </td>
<td> 902 (225 KB) </td>
<td> 132%       </td>
<td> no                  </td>
<td> no                     </td>
</tr>
<tr>
<td> Custom Format + Max Speed Zones   </td>
<td> 943 (235 KB) </td>
<td> 138%       </td>
<td> no                  </td>
<td> no                     </td>
</tr>
<tr>
<td> Theoretical Maximum               </td>
<td> 984 (246 KB) </td>
<td> 144%       </td>
<td> no                  </td>
<td> no                     </td>
</tr>
</tbody>
</table>
<p>The highest gains can be achieved by breaking the density spec, which will also make the disk incompatible with DOS. Using tracks 36-41 and just breaking the density spec a little will also help a lot. Optimizing the on-disk data structures only helps a bit, but in the case of “Minimizing Gaps” retains read-only DOS compatibility.</p>

		</div></div>
  </body>
</html>
