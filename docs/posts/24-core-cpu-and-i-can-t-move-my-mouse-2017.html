<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2017/07/09/24-core-cpu-and-i-cant-move-my-mouse/">Original</a>
    <h1>24-core CPU and I can’t move my mouse (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>This story begins, <a href="https://randomascii.wordpress.com/category/investigative-reporting/">as they so often do</a>, when I noticed that my machine was behaving poorly. My Windows 10 work machine has 24 cores (48 hyper-threads) and they were 50% idle. It has 64 GB of RAM and that was less than half used. It has a fast SSD that was mostly idle. And yet, as I moved the mouse around it kept hitching – sometimes locking up for seconds at a time.</p>
<blockquote><p>Update July 27, 2017: a <a href="https://randomascii.wordpress.com/2017/07/27/what-is-windows-doing-while-hogging-that-lock/">follow-up post</a> dissects the problem and finds the root cause.</p>
<p>Update Oct 29, 2017: a video showing how to see if the bug is fixed can be found <a href="https://www.youtube.com/watch?v=cbg5O2Kbb9A">here</a>, and the bug is fixed in the 17025 insider preview builds.</p>
<p>Update Nov 20, 2017: the fix has made it to Creators Update (RS2) which means I can now build Chrome without encountering micro-hangs!</p>
<p>Update, March 22, 2018: the fix has made it to Fall Creators Update (RS3), finally, so the fix is now everywhere.</p>
<p>Update, August 17, 2018: analysis of an unrelated bug that also caused UI hangs due to lock contention is <a href="https://randomascii.wordpress.com/2018/08/16/24-core-cpu-and-i-cant-type-an-email-part-one/">available here</a>.</p>
<p>Update, September, 2020: the original issue was UserCrit contention while many processes were destroyed, whether they had gdi32.dll loaded or not. That issue was fixed but if many processes are destroyed that <em>do </em>have gdi32.dll loaded then the issue still happens. That is, the mouse hitches and the horrible performance are still a risk. Maybe someday Microsoft will fix that, but probably not. <a href="https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/">For details see this blog post</a>.</p></blockquote>
<p>So I did what I always do – I grabbed an ETW trace and analyzed it. The result was the discovery of a serious process-destruction performance bug in Windows 10.</p>

<p>The ETW trace showed UI hangs in multiple programs. I decided to investigate a 1.125 s hang in Task Manager:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image.png"><img title="UI Delays graph in WPA" src="https://randomascii.files.wordpress.com/2017/07/image_thumb.png?w=629&amp;h=159" alt="UI Delays graph in WPA" width="629" height="159"/></a></p>
<p>In the image below you can see CPU usage for the system during the hang, grouped by process name – notice that total CPU usage rarely goes above 50%:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image1.png"><img title="CPU Usage grouped by process name" src="https://randomascii.files.wordpress.com/2017/07/image_thumb1.png?w=641&amp;h=272" alt="CPU Usage grouped by process name" width="641" height="272"/></a></p>
<p>The <em><a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/">CPU Usage (Precise)</a></em> table showed that Task Manager’s UI thread was repeatedly blocked on calls to functions like <em>SendMessageW</em>, apparently waiting on a kernel critical region (which are the kernel-mode version of critical sections), deep in the call stack in win32kbase.sys!EnterCrit (not shown):</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image2.png"><img title="CPU Usage (Precise) showing where TaskMgr.exe was blocked" src="https://randomascii.files.wordpress.com/2017/07/image_thumb2.png?w=678&amp;h=334" alt="CPU Usage (Precise) showing where TaskMgr.exe was blocked" width="678" height="334"/></a></p>
<p>I <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/">manually followed the wait chain</a> through a half-dozen processes to see who was hogging the lock. My notes from the analysis look something like this:</p>
<blockquote><p>Taskmgr.exe (72392) hung for 1.125 s (MsgCheckDelay) on thread 69,196. Longest delay was 115.6 ms on win32kbase.sys!EnterCrit, readied by conhost.exe (16264), thread 2560 at 3.273101862. conhost.exe (16264), 2560 was readied at 3.273077782 after waiting 115,640.966 ms, by mstsc.exe (79392), 71272. mstsc.exe was readied (same time, same delay) by TabTip.exe (8284), 8348, which was readied by UIforETW.exe (78120), 79584, which was readied by conhost.exe (16264), 58696, which was readied by gomacc.exe (93668), 59948, which was readied by gomacc.exe (95164), 76844.</p></blockquote>
<p>I had to keep going because most of the processes were releasing the lock after holding it for just a few microseconds. But eventually I found several processes (the gomacc.exe processes) that looked like they were holding the lock for a few <em>hundred</em> microseconds. Or, at least, they were readied by somebody holding the lock and then a few hundred microseconds later they readied somebody else by releasing the lock. These processes were all releasing the lock from within <em>NtGdiCloseProcess</em>.</p>
<p>I was tired of manually following these wait chains so I decided to see if the same readying call stack was showing up a lot of times. I did that by dragging the <em>Ready Thread Stack</em> column to the left and searching the column for <em>NtGdiCloseProcess</em>. I then used WPA’s <em>View Callers-&gt; By Function</em> option to show me all of the <em>Ready Thread Stacks</em> that went through that function – in this view the stack roots are at the bottom:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image3.png"><img title="CPU Usage (Precise) showing all readying by NtGdiCloseProcess" src="https://randomascii.files.wordpress.com/2017/07/image_thumb3.png?w=629&amp;h=262" alt="CPU Usage (Precise) showing all readying by NtGdiCloseProcess" width="629" height="262"/></a></p>
<p>There were 5,768 context switches where <em>NtGdiCloseProcess</em> was on the <em>Ready Thread Stack</em>, each one representing a time when the critical region was released. The threads readied on these call stacks had been waiting a combined total of 63.3 seconds – pretty impressive for a 1.125 second period! And, if each of these readying events happened after the thread had held the lock for just <em>200</em> microseconds then the 5,768 readying events would be enough to account for the 1.125 second hang.</p>
<p>I’m not familiar with this part of Windows but the combination of <em>PspExitThread</em> and <em>NtGdiCloseProcess</em> made it clear that this behavior was happening during process exit.</p>
<p>This was happening during a build of Chrome, and a build of Chrome creates a <em>lot</em> of processes. I was using our distributed build system which means that these processes were being created – and destroyed – quite quickly.</p>
<p>The next step was to find out how much time was being spent inside of <em>NtGdiCloseProcess</em>. So I moved to the <em><a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/">CPU Usage (Sampled)</a></em> table in WPA and got a butterfly graph, this time of callees of <em>NtGdiCloseProcess</em>. You can see from the screen shot below that over a 1.125 s period there was, across the entire system, about 1085 ms of time spent inside of <em>NtGdiCloseProcess</em>, representing 96% of the wall time:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image4.png"><img title="CPU Usage (Sampled) data showing how much time was spent inside of NtGdiCloseProcess" src="https://randomascii.files.wordpress.com/2017/07/image_thumb4.png?w=623&amp;h=273" alt="CPU Usage (Sampled) data showing how much time was spent inside of NtGdiCloseProcess" width="623" height="273"/></a></p>
<p>Anytime you have a lock that is held more than 95% of the time by one function you are in a very bad place – especially if that same lock must be acquired in order to call <em>GetMessage </em>or update the mouse position. In order to experiment better I wrote a test program that creates 1,000 processes as quickly as possible, waits half a second, and then tells all of the processes to exit simultaneously. The CPU usage of this test program on my four-core eight-thread home laptop, grouped by process name, can be seen below:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image5.png"><img title="Left block is process creation, devil horns to the right are process destruction" src="https://randomascii.files.wordpress.com/2017/07/image_thumb5.png?w=632&amp;h=302" alt="Left block is process creation, devil horns to the right are process destruction" width="632" height="302"/></a></p>
<p>Well, what do you know. Process creation is CPU bound, as it should be. Process shutdown, however, is CPU bound at the beginning and the end, but there is a long period in the middle (about a second) where it is serialized – using just one of the eight hyperthreads on the system, as 1,000 processes fight over a single lock inside of <em>NtGdiCloseProcess</em>. This is a serious problem. This period represents a time when programs will hang and mouse movements will hitch – and sometimes this serialized period is several seconds longer.</p>
<p>I’d noticed that this problem seems to be worse when my computer has been running for a while so I rebooted and ran the test as soon as my laptop had settled down. The process-shutdown serialization is indeed less severe, but the issue is still clearly present on the freshly rebooted machine:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image6.png"><img title="Devil horns are narrower after rebooting, but process destruction is still serialized for a while" src="https://randomascii.files.wordpress.com/2017/07/image_thumb6.png?w=633&amp;h=305" alt="Devil horns are narrower after rebooting, but process destruction is still serialized for a while" width="633" height="305"/></a></p>
<p>I then ran the same test on an old Windows 7 machine (Intel Core 2 Q8200, circa 2008) – you can see the results here:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/image7.png"><img title="Windows 7 CPU usage shows no serialization on process destruction" src="https://randomascii.files.wordpress.com/2017/07/image_thumb7.png?w=634&amp;h=307" alt="Windows 7 CPU usage shows no serialization on process destruction" width="634" height="307"/></a></p>
<p>Process creation is slower, as you would expect from a much slower CPU, but process destruction is as fast as my new laptop at its best, and is fully parallelized.</p>
<p>This tells us that this serialization on process shutdown is a new issue, introduced sometime between Windows 7 and Windows 10.</p>
<h2>48 hyper-threads, 47 of them idle</h2>
<p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a> says that if you throw enough cores at your problem then the parts that cannot be parallelized will eventually dominate execution. When my work machine has been heavily used for a few days this serialization issue gets bad enough that process-shutdown becomes a significant part of my distributed build times – and more cores can’t help with that. In order to get maximum build speeds (and if I want to move my mouse while doing builds) I need to <a href="https://www.youtube.com/watch?v=Qx07z3XezWA">reboot my machine</a> every few days. Even then my build speeds are not as fast as they should be, and Windows 7 starts to look tempting.</p>
<p>In fact, adding more cores to my workstation makes the UI <em>less</em> responsive. That is because Chrome’s build system is smart enough to spawn more processes if you have more cores, which means that there are more terminating processes fighting over the global lock. So it’s not just “24-core CPU and I can’t move my mouse” it’s “24-core CPU and <em>therefore</em> I can’t move my mouse.”</p>
<p>This problem has been reported to Microsoft and they are investigating.</p>
<h2>Just one more thing…</h2>
<p>This is what what my process create test program looks like when run on my 24-core work machine:</p>
<p><a href="https://randomascii.files.wordpress.com/2017/07/clip_image002.png"><img title="Process destruction serialization is worse on my 24-core workstation" src="https://randomascii.files.wordpress.com/2017/07/clip_image002_thumb.png?w=476&amp;h=213" alt="Process destruction serialization is worse on my 24-core workstation" width="476" height="213"/></a></p>
<p>See that tiny horizontal red line on the bottom right? That’s Amdahl’s law visualized, as 98% of my machine’s CPU resources sit idle for almost two seconds, while process destruction hogs the lock that I need in order to move the mouse.</p>
<p>These are before/after traces from March 22, 2018, the date the fix made it to Fall Creators Update. The images show the process-destruction portion of ProcessCreateTests.exe. You can clearly see the serialization (one out of four cores allowed to run at a time) in the before image, and the perfect parallelization and much better performance in the after image. The horizontal (time) scales are the same in both images.</p>
<p><img data-attachment-id="2776" data-permalink="https://randomascii.wordpress.com/2017/07/09/24-core-cpu-and-i-cant-move-my-mouse/gdi-serialization-fixed/" data-orig-file="https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png" data-orig-size="1334,962" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="GDI Serialization fixed" data-image-description="" data-image-caption="" data-medium-file="https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=300" data-large-file="https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=640" src="https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=640" alt="GDI Serialization fixed" srcset="https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=640 640w, https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=1280 1280w, https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=150 150w, https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=300 300w, https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=768 768w, https://randomascii.files.wordpress.com/2017/07/gdi-serialization-fixed.png?w=1024 1024w" sizes="(max-width: 640px) 100vw, 640px"/></p>
<h2>Resources</h2>
<p>The ProcessCreateTests code is <a href="https://github.com/randomascii/blogstuff/tree/master/ProcessCreateTests">available here</a>. Deeper investigation of the functions that hog the lock was done in a <a href="https://randomascii.wordpress.com/2017/07/27/what-is-windows-doing-while-hogging-that-lock/">follow-up post here</a>, including an understanding of the likely root cause of this new problem. A video showing how to investigate this bug can be <a href="https://www.youtube.com/watch?v=cbg5O2Kbb9A">found here</a>.</p>
<p>Discussions of this post can be found at:</p>
<ol>
<li><a title="https://news.ycombinator.com/item?id=14733829" href="https://news.ycombinator.com/item?id=14733829">https://news.ycombinator.com/item?id=14733829</a></li>
<li><a title="https://www.reddit.com/r/programming/comments/6mcruo" href="https://www.reddit.com/r/programming/comments/6mcruo">https://www.reddit.com/r/programming/comments/6mcruo</a></li>
<li><a title="https://m.habrahabr.ru/post/332816/" href="https://m.habrahabr.ru/post/332816/">https://m.habrahabr.ru/post/332816/</a> (popular Russian translation)</li>
<li><a title="https://www.meneame.net/story/tengo-cpu-24-nucleos-no-puedo-mover-raton-eng" href="https://www.meneame.net/story/tengo-cpu-24-nucleos-no-puedo-mover-raton-eng">https://www.meneame.net/story/tengo-cpu-24-nucleos-no-puedo-mover-raton-eng</a></li>
<li><a title="https://tech.slashdot.org/story/17/07/11/2055251" href="https://tech.slashdot.org/story/17/07/11/2055251">https://tech.slashdot.org/story/17/07/11/2055251</a></li>
<li><a href="https://twitter.com/brucedawson0xb/status/884280598348480512?lang=en">https://twitter.com/brucedawson0xb/status/884280598348480512?lang=en</a></li>
</ol>
<p>If you liked this post you might like these other investigative reporting posts:</p>
<h4><a href="https://randomascii.wordpress.com/2014/03/31/you-got-your-web-browser-in-my-compiler/">You Got Your Web Browser in my Compiler!</a></h4>
<h4><a href="https://randomascii.wordpress.com/2012/09/04/windows-slowdown-investigated-and-identified/">Windows Slowdown, Investigated and Identified</a> (and the <a href="https://randomascii.wordpress.com/2012/12/05/windows-slowdown-investigated-identified-and-now-fixed/">follow-up</a>)</h4>
<h4><a href="https://randomascii.wordpress.com/2011/08/29/powerpoint-poor-performance-problem/">PowerPoint Poor Performance Problem</a></h4>
<p><a href="https://randomascii.wordpress.com/2014/04/15/self-inflicted-denial-of-service-in-visual-studio-search/">Self Inflicted Denial of Service in Visual Studio Search</a></p>
<p><a href="https://randomascii.wordpress.com/2018/08/16/24-core-cpu-and-i-cant-type-an-email-part-one/">24-core CPU and I can’t type an email (part one)</a></p>
											</div></div>
  </body>
</html>
