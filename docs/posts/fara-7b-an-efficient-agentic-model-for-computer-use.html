<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/microsoft/fara">Original</a>
    <h1>Fara-7B: An efficient agentic model for computer use</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2025-11-23</p>

<p>I&#39;ve started writing my own software for the <a href="https://github.com/gligli/rx5usb">RX5USB</a> aftermarket memory cartridge for the Yamaha RX5 drum machine.</p>

<p>I have previously demonstrated this software in this <a href="https://www.youtube.com/watch?v=c1J6XAVyTX0">video</a>.</p>

<h2>The RX5 and the RX5USB</h2>

<p>The <a href="https://yamahablackboxes.com/collection/yamaha-rx5-drum-machine/">Yamaha RX5</a> is a 1986 drum machine. It generates its sound by playing back ROM samples, either from internal memory or from an external cartridge. The <a href="https://github.com/gligli/rx5usb">RX5USB</a> is a programmable aftermarket waveform cartridge for the RX5 made by <a href="https://gliglisynth.blogspot.com/">GliGli</a> in 2012. What is particularly nice about the RX5USB is that it is an open source design: both the PCB design files and the source code for the Windows software you need to put audio data on the cartridge are freely available.</p>

<p>I&#39;ve owned an RX5 for a long time but I don&#39;t use it much because the built-in sounds are not that nice. A friend encouraged me to check out the RX5USB, which I was reluctant to do because I don&#39;t have a Windows computer. But then I started thinking, surely I can make something that allows me to program the cartridge from macOS?</p>

<h2>How the RX5USB works</h2>

<p>The RX5USB hardware consists of a circuit board board that fits in the RX5 cartridge slot. The circuit board contains a flash memory chip, which looks like ROM memory to the RX5, and a <a href="https://www.pjrc.com/teensy/">Teensy</a> microcontroller development board which lets you write waveform data to the flash memory chip via USB.</p>

<p>The <a href="https://github.com/gligli/rx5usb/blob/master/teensy_fw/rx5usb_fw.c">firmware</a> on the Teensy runs in a loop waiting for a USB connection. When one comes in, it receives data and overwrites part of the flash memory chip. In normal use, seated in the RX5, the Teensy does nothing: the RX5 talks directly to the flash memory chip as if it is a ROM chip.</p>

<p>So on a hardware level, the RX5USB is a programmable flash memory that uses a custom USB protocol to store data on the flash chip. One of the functions of the Windows RX5USB software is to write data via USB using this custom protocol.</p>

<p>The other function of the RX5USB software is to pack WAV samples into the internal memory layout of the RX5, and to edit sample metadata.</p>

<h2>Challenge 0: parsing the RX5 memory format</h2>

<p>I ordered a pre-fabricated RX5USB board on Reverb.com. While waiting for the board to come in, I started writing a parser for the RX5 wave memory format, based on the RX5USB Windows software. This helped me get familiar with the project. The original software is written in Delphi, which is an object-oriented extension of Pascal. It&#39;s been a very long time since I used Pascal but it was not too difficult to make sense of the program.</p>

<p>The RX5 wave memory format consists of a 1KB header followed by 127KB of PCM data. The procedure <a href="https://github.com/gligli/rx5usb/blob/f3660a5a9947c54db7efff5203ed77daf0cf5a24/gui_tool/rx5classes.pas#L442C11-L442C39">TRX5Sound.ImportFromBankData</a> converts the RX5 format to the internal representation of the RX5USB software. My <a href="https://github.com/jacobvosmaer/rx5rom/blob/fe3b83ecfe3a82f4f39a8a3d1a5c7ca29168f170/rx5.c#L13-L36">C version</a> looks like this:</p>

<pre><code>void loadvoice(struct rx5voice *v, uint8_t *p) {
  memset(v, 0, sizeof(*v));
  v-&gt;octave = p[0];
  v-&gt;note = p[1];
  v-&gt;pcmformat = p[2] &amp; 1;
  v-&gt;loop = !(p[3] &amp; 0x40);
  v-&gt;pcmstart = getaddr(p + 3) &amp; ~0xff;
  v-&gt;loopstart = getaddr(p + 5);
  v-&gt;loopend = getaddr(p + 8);
  v-&gt;pcmend = getaddr(p + 11);
  v-&gt;ar = p[14];
  v-&gt;d1r = p[15];
  v-&gt;rr = p[16];
  v-&gt;d2r = p[17];
  v-&gt;d1l = p[18];
  v-&gt;gt = p[19];
  v-&gt;bendrate = p[20];
  v-&gt;bendrange = p[21];
  v-&gt;unknown = p[22];
  v-&gt;level = p[23];
  v-&gt;channel = p[24];
  memmove(v-&gt;name, p + 26, 6);
  v-&gt;name[6] = 0;
}
</code></pre>

<p>PCM data addresses are relative to the start of the 128KB wave memory block, using 24-bit addressing. Because the <code>pcmstart</code> address always starts at a multiple of 256, the RX5 only stores the two high bytes.</p>

<p>Figuring out the parser allowed me to make <a href="https://github.com/jacobvosmaer/rx5rom/blob/fe3b83ecfe3a82f4f39a8a3d1a5c7ca29168f170/rx5-ls.c">rx5-ls</a>, which lists the metadata of the sounds in an RX5 ROM, and <a href="https://github.com/jacobvosmaer/rx5rom/blob/fe3b83ecfe3a82f4f39a8a3d1a5c7ca29168f170/rx5-split.c">rx5-split</a>, which extracts the audio data as separate WAV files.</p>

<p>One interesting feature here is that the RX5 supports 8-bit and 12-bit PCM audio data. The 12-bit format is squeezed so that 2 12-bit words use 3 bytes of memory. Even and odd 12-bit words are stored differently.</p>

<pre><code>uint8_t *p, *pcmstart = rom.data + v-&gt;pcmstart,
        *pcmend = rom.data + v-&gt;pcmend;
uint16_t *q = pcmdata; /* Write 16-bit audio to here */
if (v-&gt;pcmformat) { /* 12-bit audio */
  for (p = pcmstart + 2; p &lt; pcmend; p++, q++) {
    if ((q - pcmdata) &amp; 1) {
      *q = (p[0] &lt;&lt; 8) | (p[-2] &amp; 0xf0);
      p++;
    } else {
      *q = (p[0] &lt;&lt; 8) | ((p[-1] &amp; 0x0f) &lt;&lt; 4);
    }
  }
} else { /* 8-bit audio */
  for (p = pcmstart; p &lt; pcmend; p++, q++)
    *q = *p &lt;&lt; 8;
}
</code></pre>

<p>Because I have a binary dump of the original Yamaha WRC01 cartridge, and the cartridge itself, I was able to check that I got the parser right: you can look up most of the parameters in the RX5 user interface. For the PCM audio data I checked the result by listening to the WAV files.</p>

<h2>Challenge 1: communicating with the Teensy firmware</h2>

<p>Once I had access to an RX5USB board I started working on talking to the Teensy. It presents itself as a &#34;raw&#34; <a href="https://en.wikipedia.org/wiki/USB_human_interface_device_class">HID device</a>. After trying a few USB libraries I settled on <a href="https://github.com/libusb/hidapi">HIDAPI</a>. The magic numbers for connecting to the RX5USB Teensy are <a href="https://github.com/gligli/rx5usb/blob/f3660a5a9947c54db7efff5203ed77daf0cf5a24/gui_tool/rx5classes.pas#L972">in the original software</a>. Translated to C that became:</p>

<pre><code>hid_device *usbopen(void) {
  struct hid_device_info *devinfo;
  for (devinfo = hid_enumerate(0x6112, 0x5550); devinfo;
       devinfo = devinfo-&gt;next)
    if (devinfo-&gt;usage_page == 0xffab &amp;&amp; devinfo-&gt;usage == 0x200)
      return hid_open_path(devinfo-&gt;path);
  return 0;
}
</code></pre>

<p>This makes it sound easy but it took quite a bit of trial and error to get this working.</p>

<p>The communication protocol of the RX5USB is a series of 64-byte messages. The host sends a message to the Teensy, the Teensy responds. Repeat many times. The first message is a handshake and it also tells the Teensy what address range of the flash chip the host wants to overwrite. Then the new contents of the flash chip are sent from the host to the Teensy 64 bytes at a time. The Teensy receive 64 bytes, writes them to flash, reads them back and sends the result back to the host.</p>

<p>It took me a frustrating amount of time to get this working because I was sending an incorrect address range in the first message. I misread the source code of the original software: the <a href="https://github.com/gligli/rx5usb/blob/f3660a5a9947c54db7efff5203ed77daf0cf5a24/gui_tool/rx5classes.pas#L934-L941">order of the fields</a> in the handshake message is not the order that the original software <a href="https://github.com/gligli/rx5usb/blob/f3660a5a9947c54db7efff5203ed77daf0cf5a24/gui_tool/rx5classes.pas#L985-L989">sets the fields</a>.</p>

<p>On top of that it turns out that the RX5USB board does not always make good electrical contact with the RX5, and then the RX5 will complain about a checksum error. I kept thinking this was because of a mistake in my software but it had nothing to do with it.</p>

<p>In spite of these difficulties I got <a href="https://github.com/jacobvosmaer/rx5rom/blob/fe3b83ecfe3a82f4f39a8a3d1a5c7ca29168f170/rx5-program.c">rx5-program</a> working, and I was able to test it by writing known-good RX5 ROM images to the flash chip and reading them in the RX5 itself.</p>

<h2>Challenge 2: loading my own sounds into the RX5</h2>

<p>Now that I was able to load existing ROM images onto the RX5USB I started working on creating new ROM images myself. To keep things simple, I started out by writing a program <code>rx5-build</code> that takes a list of WAV files as command line arguments and tries to pack them into a 128KB ROM file using default playback parameters.</p>

<p>This worked but I had a few more occasions to doubt myself because of the dodgy electrical contacts I mentioned earlier: sometimes   garbled sounds would come out. I also encountered a bug that I still have not been able to fix. The RX5 has a reverse playback function where you can play any of the drum sounds backwards. When I load my samples, reverse playback works for some of them but not all: some sounds come out garbled in reverse mode. I hope to fix this one day because reversing sounds is nice.</p>

<h2>Challenge 3: editing parameters</h2>

<p>Because editing sounds on the RX5 is tedious I wanted to have a way to edit sound parameters on my computer before I put them on the RX5USB. I came up with a simple text file format to describe a bank layout, and I modified <code>rx5-build</code> to read that file format instead of taking a list of WAV files as command line arguments.</p>

<p>The file format uses key value pairs, one per line, with a space after the key. A bank description is a series of sound descriptions. Each sound starts with a <code>file</code> key that refers to a WAV file. Lines that start with <code>#</code> are ignored. For example:</p>

<pre><code># Add kick.wav with custom envelope settings and name
file kick.wav
name Kick!!
decay1rate 50
decay1level 0
# Add rim.wav with default settings
file rim.wav
# Add snare.wave with custom level
file snare.wav
level 30
</code></pre>

<p>Each sound must be assigned to one of the 12 RX5 output channels. If the description does not specify a <code>channel</code> for a sound, the ROM builder uses round-robin assignment to assign the sound to a new channel.
Sounds must also have names. If you omit the <code>name</code> key, the ROM builder derives a sound name from the WAV file name.</p>

<p>I dreaded the complexity of making a file format for a while but it turned not to be complicated or a lot of work. I used a table to handle all the numerical parameters.</p>

<pre><code>struct {
  ptrdiff_t offset;
  char *field;
  int min, max;
} params[] =
    {
        {offsetof(struct rx5voice, octave), fOCTAVE, 0, 4},
        {offsetof(struct rx5voice, note), fNOTE, 0, 120},
        {offsetof(struct rx5voice, ar), fATTACKRATE, 0, 99},
        {offsetof(struct rx5voice, d1r), fDECAY1RATE, 0, 99},
        {offsetof(struct rx5voice, d1l), fDECAY1LEVEL, 0, 60},
        {offsetof(struct rx5voice, d2r), fDECAY2RATE, 0, 99},
        {offsetof(struct rx5voice, rr), fRELEASERATE, 0, 99},
        {offsetof(struct rx5voice, gt), fGATETIME, 0, 255},
        {offsetof(struct rx5voice, bendrate), fBENDRATE, 0, 255},
        {offsetof(struct rx5voice, bendrange), fBENDRANGE, 0, 255},
        {offsetof(struct rx5voice, unknown), fUNKNOWN, 0, 255},
        {offsetof(struct rx5voice, level), fLEVEL, 0, 31},
        {offsetof(struct rx5voice, channel), fCHANNEL, 0, 11},
    },
  *pp;
for (pp = params; pp &lt; params + nelem(params); pp++) {
  if (s = matchfield(line, pp-&gt;field), s) {
    int x = atoi(s);
    if (!rom.nvoice)
      errx(-1, &#34;%s before file statement&#34;, pp-&gt;field);
    if (x &lt; pp-&gt;min || x &gt; pp-&gt;max)
      errx(-1, &#34;%s out of range: %s&#34;, pp-&gt;field, s);
    ((u8 *)v)[pp-&gt;offset] = x;
    break;
  }
}
</code></pre>

<p>So far the main thing I&#39;m using the bank description file format for is assigning channels. The RX5 channels have hard-wired pan positions in the stereo field and I like putting kick drums in the middle. Now that I write this I realize configuring this in the ROM parameters is unnecessary because the RX5 has individual outputs and for sounds where I care about the pan position, I usually bypass the internal RX5 mixer anyway.</p>

<h2>Further challenges</h2>

<p>I&#39;d like to fix the sound reversing bug I mentioned earlier. It would also be nice to know what the &#34;unknown&#34; field is for; I copied this field name <a href="https://github.com/gligli/rx5usb/blob/f3660a5a9947c54db7efff5203ed77daf0cf5a24/gui_tool/rx5classes.pas#L493">from the original RX5USB software</a>.</p>

<p>Finally it would be nice to get looping working. I would like to be able to load <a href="https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/">AdventureKid Waveforms</a> into the RX5 and use it as a synthesizer. I know looping is possible because the original RX5USB software can do it. I just haven&#39;t gotten around to implementing it in my bank description file format.</p>

<h2>Conclusion</h2>

<p>I would now normally say &#34;this was a nice challenge&#34; but it wasn&#39;t a challenge really, I knew this would work. I still find it satisfying that I got to make my own tools. Even though there are still bugs and missing features, the tools work and I have been using them to <a href="https://soundcloud.com/collector-current/rx5-workout">make music</a>!</p>

<p>If you would like to know more you can also watch this <a href="https://www.youtube.com/watch?v=c1J6XAVyTX0">demonstration video</a> I made.</p>

<p>Thank you <a href="https://gliglisynth.blogspot.com/">GliGli</a> for creating the RX5USB and sharing it as open source!</p>
<p>Tags:  <a href="https://blog.jacobvosmaer.nl/tags/music.html">music</a> <a href="https://blog.jacobvosmaer.nl/tags/c.html">c</a></p>
<p><a href="https://blog.jacobvosmaer.nl/">Index</a> â€” <a href="mailto:contact@jacobvosmaer.nl">Contact</a></p>

</div></div>
  </body>
</html>
