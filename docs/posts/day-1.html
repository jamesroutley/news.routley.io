<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samgeo.codes/series/aoc2022/day01/">Original</a>
    <h1>Day 1</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Day 1! A great place to start.</p>
<p>I previously wrote a <a href="https://www.searchthedeck.com/aoc-template">post</a> discussing some basic templates for getting started
with Advent of Code in Python and JavaScript. I think that&#39;s a solid place to
start, but I like to use something a little bit different for Python.</p>
<p>In particular, <a href="https://docs.python.org/3/library/fileinput.html">fileinput</a>
reads input files line-by-line which can occasionally make it awkward to parse
certain inputs. You know what? Let&#39;s try day 1 using the template I suggest and
then see if we can make some basic improvements.</p>
<p>In case you forgot, the template looks like this:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>
</span><span>lines = [line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>fileinput.</span><span>input</span><span>()]
</span></code></pre>
<p>To store my solutions, I use a directory named <code>2022</code>. Since I am going to
produce solutions using both Python and Rust, I have the subdirectories <code>py</code>,
<code>rust</code> and <code>input</code>. To get started, I&#39;m going to save my Python template under <code>2022/py/day01/sol.py</code>
and my input under <code>2022/input/01/input.txt</code>. I am also going to save the example input
under <code>2022/input/01/example.txt</code>.</p>
<p>So far, my directory structure looks like this:</p>
<pre><code><span>.
</span><span>└── 2022/
</span><span>    ├── input/
</span><span>    │   └── 01/
</span><span>    │       ├── input.txt
</span><span>    │       └── example.txt
</span><span>    ├── py/
</span><span>    │   └── day01/
</span><span>    │       └── sol.py
</span><span>    └── rust
</span></code></pre>
<h2 id="problem-statement">Problem statement</h2>
<p>The example input looks like this:</p>
<pre><code><span>1000
</span><span>2000
</span><span>3000
</span><span>
</span><span>4000
</span><span>
</span><span>5000
</span><span>6000
</span><span>
</span><span>7000
</span><span>8000
</span><span>9000
</span><span>
</span><span>10000
</span></code></pre>
<p>Each contiguous group of lines represents the food carried by a single elf.
Each line within each group represents the calories contained within a single
food item.</p>
<p>For part one, we want to find the elf carrying the most total calories.</p>
<p><a href="https://adventofcode.com/2022/day/1">Link</a> to the prompt if you want some
festive winteriness.</p>
<h2 id="let-s-go">Let&#39;s go!</h2>
<p>If we go ahead and print out our lines:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>
</span><span>lines = [line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>fileinput.</span><span>input</span><span>()]
</span><span>print</span><span>(lines)
</span></code></pre>
<p>When we run our solution against the example, this is what we get:</p>
<pre><code><span>$ python py/day01/sol.py input/01/example.txt
</span><span>[&#39;1000&#39;, &#39;2000&#39;, &#39;3000&#39;, &#39;&#39;, &#39;4000&#39;, &#39;&#39;, &#39;5000&#39;, &#39;6000&#39;, &#39;&#39;, &#39;7000&#39;, &#39;8000&#39;, &#39;9000&#39;, &#39;&#39;, &#39;10000&#39;]
</span></code></pre>
<p>It might be easier to rebuild the input and then re-split to divide our input into
one section per elf, then we can process each of those sections. We&#39;ll define
a helper function to determine the total calories that a single elf is carrying.</p>
<h3 id="generator-expressions">Generator Expressions</h3>
<p>Many people are familiar with
<a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehensions</a>.
<a href="https://peps.python.org/pep-0289/">Generator expressions</a> behave very similarly
to list comprehensions but have lazy semantics: they don&#39;t compute elements
until they are asked for. We will see some great parallels with Rust&#39;s iterators
later in the post. Unlike iterators in Rust, generator expressions have some
runtime overhead because Python is an interpreted language.</p>
<p>In general, I like to use generator expressions instead of list comprehensions
when feasible. For most applications, list comprehensions
are just fine (and might even be faster), but when working with potentially large collections, it can be
prohibitively expensive to materialize the entire collection in-memory.</p>
<p>Some may see this as an unnecessary optimization, but I like to get into habits
that lead to reasonably fast code.</p>
<p>We&#39;ll use a few Python built-ins for our solution:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#int"><code>int</code></a>: constructs an integer from a number or a string</li>
<li><a href="https://docs.python.org/3/library/functions.html#sum"><code>sum</code></a>: sums the items of an <em>iterable</em>, note that generator expressions produce iterables</li>
<li><a href="https://docs.python.org/3/library/functions.html#max"><code>max</code></a>: finds the largest item in an <em>iterable</em>; again note that generator expressions produce iterables</li>
</ul>
<p>With that all in mind, let&#39;s see what our solution to part one looks like:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>):
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>lines = (line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>fileinput.</span><span>input</span><span>())
</span><span>puzzle_input = &#34;</span><span>\n</span><span>&#34;.</span><span>join</span><span>(lines)
</span><span>sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>solution = </span><span>max</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)
</span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{solution}&#34;)
</span></code></pre>
<p>Let&#39;s run it against the example:</p>
<pre><code><span>$ python py/day01/sol.py input/01/example.txt
</span><span>Part one: 24000
</span></code></pre>
<p>That&#39;s what we wanted! Let&#39;s see if we can run it against our input:</p>
<pre><code><span>$ python py/day01/sol.py input/01/input.txt
</span><span>Part one: 70509
</span></code></pre>
<p>We enter that into the website and hooray! One star! Off to a great
start.</p>
<h2 id="part-two">Part Two</h2>
<p>Now we want the total of the top 3 elves!</p>
<p>We can use <a href="https://docs.python.org/3/library/functions.html#sorted"><code>sorted</code></a>
(which also accepts an iterable, noticing a trend?)
to make a sorted list of all of the elves, then take the top 3:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>):
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>lines = (line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>fileinput.</span><span>input</span><span>())
</span><span>puzzle_input = &#34;</span><span>\n</span><span>&#34;.</span><span>join</span><span>(lines)
</span><span>sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>solution = </span><span>max</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)
</span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{solution}&#34;)
</span><span>top_three = </span><span>sorted</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)[-</span><span>3</span><span>:]
</span><span>solution = </span><span>sum</span><span>(top_three)
</span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{solution}&#34;)
</span></code></pre>
<p>Let&#39;s run it against the example:</p>
<pre><code><span>$ python py/day01/sol.py input/01/example.txt
</span><span>Part one: 24000
</span><span>Part two: 45000
</span></code></pre>
<p>Neato! We&#39;re on a roll.</p>
<p>Now on our input:</p>
<pre><code><span>$ python py/day01/sol.py input/01/input.txt
</span><span>Part one: 70509
</span><span>Part two: 208567
</span></code></pre>
<h2 id="improvements">Improvements</h2>
<p>Maybe we can do a little bit better, while also learning a bit more about the
(unnecessarily enormous) Python standard library!</p>
<p>First, let&#39;s try to pull our solution into function scope. We&#39;ll check to see
if our solution module should be run by comparing the global value <code>__name__</code>
against the string <code>&#34;__main__&#34;</code>. Check out the <a href="https://docs.python.org/3/tutorial/modules.html#tut-modules">Modules</a>
section of the Python tutorial for more details.</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>):
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>():
</span><span>    lines = (line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>fileinput.</span><span>input</span><span>())
</span><span>    puzzle_input = &#34;</span><span>\n</span><span>&#34;.</span><span>join</span><span>(lines)
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    solution = </span><span>max</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{solution}&#34;)
</span><span>    top_three = </span><span>sorted</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)[-</span><span>3</span><span>:]
</span><span>    solution = </span><span>sum</span><span>(top_three)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{solution}&#34;)
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>main</span><span>()
</span></code></pre>
<p>As mentioned above, using <code>fileinput</code> is pretty awkward since we are basically
reconstructing our input from the file contents, anyway. Let&#39;s define a helper
module to make reading input a little bit nicer. We&#39;ll put this module in the file
<code>2022/py/read_input.py</code>:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>argparse
</span><span>from </span><span>pathlib </span><span>import </span><span>Path
</span><span>
</span><span>
</span><span>def </span><span>read_input</span><span>(</span><span>day</span><span>: int) -&gt; str:
</span><span>    parser = argparse.</span><span>ArgumentParser</span><span>()
</span><span>    parser.</span><span>add_argument</span><span>(&#34;</span><span>input</span><span>&#34;, </span><span>nargs</span><span>=&#34;</span><span>?</span><span>&#34;, </span><span>default</span><span>=&#34;</span><span>input.txt</span><span>&#34;)
</span><span>    args = parser.</span><span>parse_args</span><span>()
</span><span>
</span><span>    padded_day = </span><span>str</span><span>(day).</span><span>rjust</span><span>(</span><span>2</span><span>, &#34;</span><span>0</span><span>&#34;)
</span><span>    filename = </span><span>Path</span><span>(&#34;</span><span>input</span><span>&#34;) / padded_day / args.input
</span><span>
</span><span>    </span><span>with </span><span>open</span><span>(filename) </span><span>as </span><span>f:
</span><span>        </span><span>return </span><span>f.</span><span>read</span><span>()
</span></code></pre>
<p>I guess there&#39;s a few things to mention, here:</p>
<ul>
<li><strong>What&#39;s that <code> -&gt; str</code> nonsense?</strong>: That&#39;s a return value type hint.
Check out the <a href="https://docs.python.org/3/library/typing.html"><code>typing</code></a> module documentation for more information.</li>
<li>The <code>argparse</code> standard library module allows you to write simple CLI scripts. There are a lot of
great argument parsing libraries available on <a href="https://pypi.org">PyPI</a>, but we don&#39;t need to pull in any
external dependencies for <code>argparse</code> and it suits our needs just fine.</li>
<li>The <code>pathlib</code> standard library module makes it easy to build up file paths in a
platform-independent way.</li>
</ul>
<p>Now, to use this new module, we also need to add a blank <code>__init__.py</code> file to
our <code>2022/py</code> directory; and while we&#39;re at it, let&#39;s add one to our <code>2022/py/day01</code> directory, as well:</p>
<pre><code><span>$ touch 2022/py/__init__.py
</span><span>$ touch 2022/py/day01/__init__.py
</span></code></pre>
<p>This might all seem like a lot of boilerplate, but we won&#39;t really touch any of
this after day 1!</p>
<p>Finally, we can use the new module in our solution:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>):
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>():
</span><span>    puzzle_input = </span><span>read_input</span><span>(</span><span>1</span><span>)
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    solution = </span><span>max</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{solution}&#34;)
</span><span>    top_three = </span><span>sorted</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)[-</span><span>3</span><span>:]
</span><span>    solution = </span><span>sum</span><span>(top_three)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{solution}&#34;)
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>main</span><span>()
</span></code></pre>
<p>To avoid Python path nonsense we need to change our command line invocation
slightly:</p>
<pre><code><span>$ python -m py.day01.sol
</span><span>Part one: 70509
</span><span>Part two: 208567
</span></code></pre>
<p>Still works! And now we don&#39;t even need to enter the filename if we just want
to run against our input. Nice.</p>
<h3 id="type-hints">Type Hints</h3>
<p>I&#39;m a bit of a type hinting fanatic: type hints help me avoid making careless
mistakes and force me to refine the flow of information around my programs.</p>
<p>Let&#39;s add them to what we have so far and we can try to keep everything working
as we restructure our program.</p>
<p>First, let&#39;s set up a <code>venv</code> within our <code>py</code> subdirectory. I&#39;m using
the <code>python3.11</code> binary installed on my machine, so that looks like this:</p>
<pre><code><span>$ python3.11 -m venv py/.venv
</span><span>$ source py/.venv/bin/activate
</span></code></pre>
<p>I personally like to use the <code>pyright</code> LSP, so I&#39;ll go ahead and install the
dev tools that I typically use. If you want to follow along, at least install
<code>mypy</code>:</p>
<pre><code><span>$ pip install pyright flake8 black mypy
</span></code></pre>
<p>Let&#39;s run <code>mypy</code> in strict mode:</p>
<pre><code><span>$ mypy --strict py
</span><span>py/day01/sol.py:6: error: Function is missing a type annotation  [no-untyped-def]
</span><span>py/day01/sol.py:10: error: Function is missing a return type annotation  [no-untyped-def]
</span><span>py/day01/sol.py:10: note: Use &#34;-&gt; None&#34; if function does not return a value
</span><span>py/day01/sol.py:13: error: Call to untyped function &#34;total_calories&#34; in typed context  [no-untyped-call]
</span><span>py/day01/sol.py:15: error: Call to untyped function &#34;total_calories&#34; in typed context  [no-untyped-call]
</span><span>py/day01/sol.py:21: error: Call to untyped function &#34;main&#34; in typed context  [no-untyped-call]
</span><span>Found 5 errors in 1 file (checked 4 source files)
</span></code></pre>
<p>Paydirt! Let&#39;s go ahead and fix all of those. While we are at it, we will also
make <code>main</code> return an integer value so we can be a good command line citizen.</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>: str) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    puzzle_input = </span><span>read_input</span><span>(</span><span>1</span><span>)
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    solution = </span><span>max</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{solution}&#34;)
</span><span>    top_three = </span><span>sorted</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)[-</span><span>3</span><span>:]
</span><span>    solution = </span><span>sum</span><span>(top_three)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{solution}&#34;)
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>If we run <code>mypy</code> again:</p>
<pre><code><span>$ mypy --strict py
</span><span>Success: no issues found in 4 source files
</span></code></pre>
<p>Huzzah!</p>
<p>Now, let&#39;s see if we can identify some common ground between parts 1 and 2 and maybe
improve our runtime performance.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> I&#39;ll be using code literals for math until I figure out a nice way to
use KaTeX with Zola (or another SSG).</p>
</blockquote>
<p>Let&#39;s consider the runtime complexity of the solution that we currently have. We&#39;ll
say that <code>I</code> is the length of our input and <code>N</code> is the number of elves in the input.</p>
<p>Our part 1 boils down to a linear scan over our input, so it runs in <code>O(I + N)</code>
time (and <code>N</code> is bounded by <code>I</code>, so it&#39;s really <code>O(I)</code>). Our part 2 sorts the collection of elves, so it runs in <code>O(I + N log N)</code> time.</p>
<p>Can we do better? Well, when we fetch the top 3 elves, we are discarding a bunch of
information that we spent time assembling when we sorted the entire collection of elves.
Maybe we can avoid doing all that work when we only really care about the top 3
elves. Heaps are a wonderful data structure that work perfectly for this kind of
operation (and they&#39;re great to be aware of for all sorts of interview problems).
In particular, we can heapify a list of <code>N</code> elements in <code>O(N)</code> time. And then fetching
<code>K</code> elements from that heap costs <code>O(K log N)</code> time. Since we want to fetch a constant number of
elements (3), the cost of fetching becomes <code>O(log N)</code>.</p>
<p>So if we can leverage a heap to solve the problem, we will have an <code>O(I)</code> solution!</p>
<p>There is a very handy module in the standard library called <a href="https://docs.python.org/3/library/heapq.html"><code>heapq</code></a>.
This library maintains the heap invariant (for a min-heap) atop a vanilla
Python list. It also has a couple of very handy functions: <code>nlargest</code> and <code>nsmallest</code>
for generating lists of the <code>n</code> largest or smallest elements, respectively.
And they do indeed first heapify the input collection and then fetch the first <code>n</code> elements.</p>
<p>And if we look at the documentation, it looks like the result is returned in
reverse sorted order, so we can also use the result for part 1!</p>
<p>Let&#39;s see how we can use that and set up a bit of infrastructure for comparing
the new implementation with our original sort-based approach. I&#39;ve adjusted
our original solution slightly to avoid some duplicate work.</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>heapq </span><span>import </span><span>nlargest
</span><span>from </span><span>time </span><span>import </span><span>perf_counter
</span><span>from </span><span>typing </span><span>import </span><span>Callable
</span><span>
</span><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>: str) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>def </span><span>sort_sol</span><span>(</span><span>puzzle_input</span><span>: str) -&gt; tuple[int, int]:
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    top_three = </span><span>sorted</span><span>(</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections)[-</span><span>3</span><span>:]
</span><span>    </span><span>return </span><span>top_three[-</span><span>1</span><span>], </span><span>sum</span><span>(top_three)
</span><span>
</span><span>
</span><span>def </span><span>heap_sol</span><span>(</span><span>puzzle_input</span><span>: str) -&gt; tuple[int, int]:
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    top_three = </span><span>nlargest</span><span>(</span><span>3</span><span>, (</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections))
</span><span>    </span><span>return </span><span>top_three[</span><span>0</span><span>], </span><span>sum</span><span>(top_three)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    puzzle_input = </span><span>read_input</span><span>(</span><span>1</span><span>)
</span><span>    expected_output = </span><span>sort_sol</span><span>(puzzle_input)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{expected_output[</span><span>0</span><span>]}&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{expected_output[</span><span>1</span><span>]}&#34;)
</span><span>
</span><span>    </span><span>def </span><span>benchmark</span><span>(</span><span>solution</span><span>: Callable[[str], tuple[int, int]]) -&gt; float:
</span><span>        start = </span><span>perf_counter</span><span>()
</span><span>        </span><span>for </span><span>_ </span><span>in </span><span>range</span><span>(</span><span>1000</span><span>):
</span><span>            </span><span>assert </span><span>solution</span><span>(puzzle_input) == expected_output
</span><span>        end = </span><span>perf_counter</span><span>()
</span><span>        </span><span>return </span><span>end - start
</span><span>
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Sort solution takes </span><span>{</span><span>benchmark</span><span>(sort_sol)}</span><span>s</span><span>&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Heap solution takes </span><span>{</span><span>benchmark</span><span>(heap_sol)}</span><span>s</span><span>&#34;)
</span><span>
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>Let&#39;s run it and see how much improvement we get!</p>
<pre><code><span>$ python -m py.day01.sol example.txt
</span><span>Part one: 24000
</span><span>Part two: 45000
</span><span>Sort solution takes 0.0033642500020505395s
</span><span>Heap solution takes 0.0045546660003310535s
</span></code></pre>
<p>Now you might be saying, &#34;hey Sam, I thought using a heap would make things
<em>faster</em>, what gives?&#34;</p>
<p>Well, unfortunately big-O analysis throws away a bunch of constants and it turns
out that in the real world, constants matter. <code>sorted</code> is very well optimized since
it is one of the most commonly used built-ins in Python.</p>
<p>This was just our example input, let&#39;s try our real input:</p>
<pre><code><span>$ python -m py.day01.sol
</span><span>Part one: 70509
</span><span>Part two: 208567
</span><span>Sort solution takes 0.24173837499984074s
</span><span>Heap solution takes 0.23308020799959195s
</span></code></pre>
<p>Faster, but not by much.</p>
<p>Our puzzle input still only consists of 2237 elves. What if we crank that up
a little bit?</p>
<p>We replace our line <code>puzzle_input = read_input(1)</code> with
<code>puzzle_input = &#34;\n\n&#34;.join([read_input(1).strip()] * 1000)</code> and reduce
the number of benchmark iterations down to 10:</p>
<pre><code><span>$ python -m py.day01.sol
</span><span>Part one: 70509
</span><span>Part two: 211527
</span><span>Sort solution takes 2.4853763329992944s
</span><span>Heap solution takes 2.3238277089985786s
</span></code></pre>
<p>Better, but still not that satisfying of an improvement. I guess the two
lessons are:</p>
<ul>
<li>constants matter</li>
<li><code>log</code> grows <em>very</em> slowly</li>
</ul>
<p>Let&#39;s put our heap-based solution in place without all of the benchmarking
boilerplate:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>heapq </span><span>import </span><span>nlargest
</span><span>
</span><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>def </span><span>total_calories</span><span>(</span><span>elf</span><span>: str) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>int</span><span>(item) </span><span>for </span><span>item </span><span>in </span><span>elf.</span><span>splitlines</span><span>())
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    puzzle_input = </span><span>read_input</span><span>(</span><span>1</span><span>)
</span><span>    sections = puzzle_input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>    top_three = </span><span>nlargest</span><span>(</span><span>3</span><span>, (</span><span>total_calories</span><span>(section) </span><span>for </span><span>section </span><span>in </span><span>sections))
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{top_three[</span><span>0</span><span>]}&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{</span><span>sum</span><span>(top_three)}&#34;)
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>So now our directory structure looks like this:</p>
<pre><code><span>.
</span><span>└── 2022/
</span><span>    ├── input/
</span><span>    │   └── 01/
</span><span>    │       ├── input.txt
</span><span>    │       └── example.txt
</span><span>    ├── py/
</span><span>    │   ├── __init__.py
</span><span>    │   ├── read_input.py
</span><span>    │   └── 01/
</span><span>    │       ├── __init__.py
</span><span>    │       └── sol.py
</span><span>    └── rust
</span></code></pre>
<p>That&#39;s enough Python for now, let&#39;s see what this looks like in Rust.</p>
<h2 id="rust">Rust</h2>
<p>In Rust, I like to use a new crate for each day. I also like to use
the nightly toolchain so that I can play around with unstable features.</p>
<p>To get started, check out <a href="https://rustup.rs/"><code>rustup</code></a>.</p>
<p>For now, here is what my active toolchain looks like:</p>
<pre><code><span>$ rustup show
</span><span>active toolchain
</span><span>----------------
</span><span>
</span><span>nightly-aarch64-apple-darwin (default)
</span><span>rustc 1.69.0-nightly (5e37043d6 2023-01-22)
</span></code></pre>
<p>Alright, let&#39;s get this show on the road!</p>
<pre><code><span>$ cargo new rust/day01 --vcs none --lib
</span><span>$ cd rust/day01
</span></code></pre>
<p>This creates a new binary crate without version control (hopefully you have
version control on your solutions). Your working directory should now look
something like this:</p>
<pre><code><span>.
</span><span>└── day01/
</span><span>    ├── Cargo.toml
</span><span>    └── src/
</span><span>        └── lib.rs
</span></code></pre>
<p>And you&#39;ll have the default <code>lib.rs</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>add</span><span>(</span><span>left</span><span>: </span><span>usize</span><span>, </span><span>right</span><span>: </span><span>usize</span><span>) -&gt; </span><span>usize </span><span>{
</span><span>    left + right
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(test)]
</span><span>mod </span><span>tests {
</span><span>    </span><span>use super</span><span>::*;
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>it_works</span><span>() {
</span><span>        </span><span>let</span><span> result = </span><span>add</span><span>(</span><span>2</span><span>, </span><span>2</span><span>);
</span><span>        assert_eq!(result, </span><span>4</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let&#39;s try a similar comparison in Rust between a sort-based and heap-based
solution.</p>
<p>First, let&#39;s define a function for the sort-based approach:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::error::Error;
</span><span>
</span><span>pub fn </span><span>sort_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; Result&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let mut</span><span> elves = input
</span><span>        .</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>        .</span><span>map</span><span>(|</span><span>elf</span><span>| {
</span><span>            elf.</span><span>trim</span><span>()
</span><span>                .</span><span>lines</span><span>()
</span><span>                .</span><span>map</span><span>(|</span><span>line</span><span>| -&gt; Result&lt;</span><span>i32</span><span>, Box&lt;dyn Error&gt;&gt; { line.</span><span>parse</span><span>().</span><span>map_err</span><span>(From::from) })
</span><span>                .</span><span>sum</span><span>()
</span><span>        })
</span><span>        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
</span><span>    elves.</span><span>sort_by</span><span>(|</span><span>a</span><span>: &amp;</span><span>i32</span><span>, </span><span>b</span><span>| b.</span><span>cmp</span><span>(a));
</span><span>    Ok((elves[</span><span>0</span><span>], elves.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>3</span><span>).</span><span>sum</span><span>()))
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(test)]
</span><span>mod </span><span>tests {
</span><span>    </span><span>use super</span><span>::*;
</span><span>
</span><span>    </span><span>const </span><span>EXAMPLE</span><span>: &amp;</span><span>str </span><span>= </span><span>r</span><span>#&#34;</span><span>1000
</span><span>2000
</span><span>3000
</span><span>
</span><span>4000
</span><span>
</span><span>5000
</span><span>6000
</span><span>
</span><span>7000
</span><span>8000
</span><span>9000
</span><span>
</span><span>10000</span><span>&#34;#;
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_sort_sol</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>        assert_eq!(</span><span>sort_sol</span><span>(</span><span>EXAMPLE</span><span>)?, (</span><span>24000</span><span>, </span><span>45000</span><span>));
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span></code></pre>
<p>This somewhat resembles our Python implementation:</p>
<ul>
<li>we split the input into elf sections,</li>
<li>we calculate the sum of each section,</li>
<li>we sort the resulting collection and determine our results.</li>
</ul>
<p>For the most part, Rust just makes us be a little bit more explicit about our
error conditions. This solution will still panic for empty inputs, for instance.
But our python solution would throw for lines that don&#39;t contain valid integers.</p>
<p>Let&#39;s see if our test passes!</p>
<pre><code><span>$ cargo test
</span><span>   Compiling day01 v0.1.0 (/Users/sgeisenh/projects/aoc/2022/rust/day01)
</span><span>    Finished test [unoptimized + debuginfo] target(s) in 0.45s
</span><span>     Running unittests src/lib.rs (target/debug/deps/day01-1b30f96f7eb97059)
</span><span>
</span><span>running 1 test
</span><span>test tests::test_sort_sol ... ok
</span><span>
</span><span>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>   Doc-tests day01
</span><span>
</span><span>running 0 tests
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span></code></pre>
<p>Excellent.</p>
<p>Let&#39;s wire it up into a binary by creating a <code>day01/src/bin/main.rs</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::error::Error;
</span><span>
</span><span>use </span><span>day01::sort_sol;
</span><span>
</span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let</span><span> input = include_str!(&#34;</span><span>../../../../input/01/input.txt</span><span>&#34;);
</span><span>    </span><span>let </span><span>(part1, part2) = </span><span>sort_sol</span><span>(input)?;
</span><span>    println!(&#34;</span><span>Sort sol p1: </span><span>{part1}</span><span>, p2: </span><span>{part2}</span><span>&#34;);
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>Let&#39;s run it!</p>
<pre><code><span>$ cargo run
</span><span>   Compiling day01 v0.1.0 (/Users/sgeisenh/projects/aoc/2022/rust/day01)
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
</span><span>     Running `target/debug/main`
</span><span>Sort sol p1: 70509, p2: 208567
</span></code></pre>
<p>Cool beans. Let&#39;s try to get the heap implementation in place. We can use
the unstable <code>into_iter_sorted</code> function to convert a <code>BinaryHeap</code>
directly to an <code>Iterator</code> and then take the first 3 elements for part 2.</p>
<p>Here&#39;s what that looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#![</span><span>feature</span><span>(binary_heap_into_iter_sorted)]
</span><span>use </span><span>std::{collections::BinaryHeap, error::Error};
</span><span>
</span><span>pub fn </span><span>sort_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; Result&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let mut</span><span> elves = input
</span><span>        .</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>        .</span><span>map</span><span>(|</span><span>elf</span><span>| {
</span><span>            elf.</span><span>trim</span><span>()
</span><span>                .</span><span>lines</span><span>()
</span><span>                .</span><span>map</span><span>(|</span><span>line</span><span>| -&gt; Result&lt;</span><span>i32</span><span>, Box&lt;dyn Error&gt;&gt; { line.</span><span>parse</span><span>().</span><span>map_err</span><span>(From::from) })
</span><span>                .</span><span>sum</span><span>()
</span><span>        })
</span><span>        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
</span><span>    elves.</span><span>sort_by</span><span>(|</span><span>a</span><span>: &amp;</span><span>i32</span><span>, </span><span>b</span><span>| b.</span><span>cmp</span><span>(a));
</span><span>    Ok((elves[</span><span>0</span><span>], elves.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>3</span><span>).</span><span>sum</span><span>()))
</span><span>}
</span><span>
</span><span>pub fn </span><span>heap_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; Result&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let</span><span> elves = input
</span><span>        .</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;)
</span><span>        .</span><span>map</span><span>(|</span><span>elf</span><span>| {
</span><span>            elf.</span><span>trim</span><span>()
</span><span>                .</span><span>lines</span><span>()
</span><span>                .</span><span>map</span><span>(|</span><span>line</span><span>| -&gt; Result&lt;</span><span>i32</span><span>, Box&lt;dyn Error&gt;&gt; { line.</span><span>parse</span><span>().</span><span>map_err</span><span>(From::from) })
</span><span>                .</span><span>sum</span><span>()
</span><span>        })
</span><span>        .collect::&lt;Result&lt;BinaryHeap&lt;_&gt;, _&gt;&gt;()?;
</span><span>    Ok((
</span><span>        *elves.</span><span>peek</span><span>().</span><span>unwrap</span><span>(),
</span><span>        elves.</span><span>into_iter_sorted</span><span>().</span><span>take</span><span>(</span><span>3</span><span>).</span><span>sum</span><span>(),
</span><span>    ))
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(test)]
</span><span>mod </span><span>tests {
</span><span>    </span><span>use super</span><span>::*;
</span><span>
</span><span>    </span><span>const </span><span>EXAMPLE</span><span>: &amp;</span><span>str </span><span>= </span><span>r</span><span>#&#34;</span><span>1000
</span><span>2000
</span><span>3000
</span><span>
</span><span>4000
</span><span>
</span><span>5000
</span><span>6000
</span><span>
</span><span>7000
</span><span>8000
</span><span>9000
</span><span>
</span><span>10000</span><span>&#34;#;
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_sort_sol</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>        assert_eq!(</span><span>sort_sol</span><span>(</span><span>EXAMPLE</span><span>)?, (</span><span>24000</span><span>, </span><span>45000</span><span>));
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_heap_sol</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>        assert_eq!(</span><span>heap_sol</span><span>(</span><span>EXAMPLE</span><span>)?, (</span><span>24000</span><span>, </span><span>45000</span><span>));
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span></code></pre>
<p>We run the tests...</p>
<pre><code><span>$ cargo test
</span><span>   Compiling day01 v0.1.0 (/Users/sgeisenh/projects/aoc/2022/rust/day01)
</span><span>    Finished test [unoptimized + debuginfo] target(s) in 0.23s
</span><span>     Running unittests src/lib.rs (target/debug/deps/day01-1b30f96f7eb97059)
</span><span>
</span><span>running 2 tests
</span><span>test tests::test_heap_sol ... ok
</span><span>test tests::test_sort_sol ... ok
</span><span>
</span><span>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>     Running unittests src/bin/main.rs (target/debug/deps/main-abe929b1b2534503)
</span><span>
</span><span>running 0 tests
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>   Doc-tests day01
</span><span>
</span><span>running 0 tests
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span></code></pre>
<p>wire it up to our binary...</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::error::Error;
</span><span>
</span><span>use </span><span>day01::{heap_sol, sort_sol};
</span><span>
</span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let</span><span> input = include_str!(&#34;</span><span>../../../../input/01/input.txt</span><span>&#34;);
</span><span>    </span><span>let </span><span>(sp1, sp2) = </span><span>sort_sol</span><span>(input)?;
</span><span>    println!(&#34;</span><span>Sort sol p1: </span><span>{sp1}</span><span>, p2: </span><span>{sp2}</span><span>&#34;);
</span><span>    </span><span>let </span><span>(hp1, hp2) = </span><span>heap_sol</span><span>(input)?;
</span><span>    println!(&#34;</span><span>Heap sol p1: </span><span>{hp1}</span><span>, p2: </span><span>{hp2}</span><span>&#34;);
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>and run it:</p>
<pre><code><span>$ cargo run
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</span><span>     Running `/Users/sgeisenh/projects/aoc/2022/rust/day01/target/debug/main`
</span><span>Sort sol p1: 70509, p2: 208567
</span><span>Heap sol p1: 70509, p2: 208567
</span></code></pre>
<p>Neat.</p>
<p>There&#39;s a little bit of common code that I feel like we should be able to pull
into it&#39;s own function. Let&#39;s give it a shot!</p>
<pre data-lang="rust"><code data-lang="rust"><span>#![</span><span>feature</span><span>(binary_heap_into_iter_sorted)]
</span><span>use </span><span>std::{collections::BinaryHeap, error::Error};
</span><span>
</span><span>pub type </span><span>AocResult&lt;</span><span>&#39;a</span><span>, T&gt; = Result&lt;T, Box&lt;dyn Error + </span><span>&#39;a</span><span>&gt;&gt;;
</span><span>
</span><span>fn </span><span>parse_input</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; impl Iterator&lt;Item = AocResult&lt;</span><span>i32</span><span>&gt;&gt; {
</span><span>    input.</span><span>split</span><span>(&#34;</span><span>\n\n</span><span>&#34;).</span><span>map</span><span>(|</span><span>elf</span><span>| {
</span><span>        elf.</span><span>trim</span><span>()
</span><span>            .</span><span>lines</span><span>()
</span><span>            .</span><span>map</span><span>(|</span><span>line</span><span>| -&gt; AocResult&lt;</span><span>i32</span><span>&gt; { line.</span><span>parse</span><span>().</span><span>map_err</span><span>(From::from) })
</span><span>            .</span><span>sum</span><span>()
</span><span>    })
</span><span>}
</span><span>
</span><span>pub fn </span><span>sort_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; AocResult&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>)&gt; {
</span><span>    </span><span>let mut</span><span> elves = </span><span>parse_input</span><span>(input).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
</span><span>    elves.</span><span>sort_by</span><span>(|</span><span>a</span><span>: &amp;</span><span>i32</span><span>, </span><span>b</span><span>| b.</span><span>cmp</span><span>(a));
</span><span>    Ok((elves[</span><span>0</span><span>], elves.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>3</span><span>).</span><span>sum</span><span>()))
</span><span>}
</span><span>
</span><span>pub fn </span><span>heap_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; AocResult&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>)&gt; {
</span><span>    </span><span>let</span><span> elves = </span><span>parse_input</span><span>(input).collect::&lt;Result&lt;BinaryHeap&lt;_&gt;, _&gt;&gt;()?;
</span><span>    Ok((
</span><span>        *elves.</span><span>peek</span><span>().</span><span>unwrap</span><span>(),
</span><span>        elves.</span><span>into_iter_sorted</span><span>().</span><span>take</span><span>(</span><span>3</span><span>).</span><span>sum</span><span>(),
</span><span>    ))
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(test)]
</span><span>mod </span><span>tests {
</span><span>    </span><span>use super</span><span>::*;
</span><span>
</span><span>    </span><span>const </span><span>EXAMPLE</span><span>: &amp;</span><span>str </span><span>= </span><span>r</span><span>#&#34;</span><span>1000
</span><span>2000
</span><span>3000
</span><span>
</span><span>4000
</span><span>
</span><span>5000
</span><span>6000
</span><span>
</span><span>7000
</span><span>8000
</span><span>9000
</span><span>
</span><span>10000</span><span>&#34;#;
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_parse_input</span><span>() -&gt; AocResult&lt;</span><span>&#39;static</span><span>, ()&gt; {
</span><span>        assert_eq!(
</span><span>            </span><span>parse_input</span><span>(</span><span>EXAMPLE</span><span>).collect::&lt;AocResult&lt;Vec&lt;_&gt;&gt;&gt;()?,
</span><span>            vec![</span><span>6000</span><span>, </span><span>4000</span><span>, </span><span>11000</span><span>, </span><span>24000</span><span>, </span><span>10000</span><span>]
</span><span>        );
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_sort_sol</span><span>() -&gt; AocResult&lt;</span><span>&#39;static</span><span>, ()&gt; {
</span><span>        assert_eq!(</span><span>sort_sol</span><span>(</span><span>EXAMPLE</span><span>)?, (</span><span>24000</span><span>, </span><span>45000</span><span>));
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_heap_sol</span><span>() -&gt; AocResult&lt;</span><span>&#39;static</span><span>, ()&gt; {
</span><span>        assert_eq!(</span><span>heap_sol</span><span>(</span><span>EXAMPLE</span><span>)?, (</span><span>24000</span><span>, </span><span>45000</span><span>));
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span><span>
</span></code></pre>
<p>Now it&#39;s time to see how our solutions compare.</p>
<p>For that we&#39;ll use <a href="https://docs.rs/criterion/latest/criterion/">Criterion.rs</a>.</p>
<p>First we install <code>criterion</code>:</p>
<pre><code><span>$ cargo add criterion
</span></code></pre>
<p>Then we add a benchmark to our <code>Cargo.toml</code>:</p>
<pre data-lang="toml"><code data-lang="toml"><span>[dev-dependencies]
</span><span>criterion </span><span>= { </span><span>version </span><span>= &#34;</span><span>0.4.0</span><span>&#34;, </span><span>features </span><span>= [&#34;</span><span>html_reports</span><span>&#34;] }
</span><span>
</span><span>
</span><span>[[bench]]
</span><span>name </span><span>= &#34;</span><span>my_benchmark</span><span>&#34;
</span><span>harness </span><span>= </span><span>false
</span></code></pre>
<p>And add our benchmark file <code>benches/my_benchmark.rs</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::hint::black_box;
</span><span>
</span><span>use </span><span>criterion::{criterion_group, criterion_main, Criterion};
</span><span>
</span><span>static </span><span>INPUT</span><span>: &amp;</span><span>str </span><span>= include_str!(&#34;</span><span>../../../input/01/input.txt</span><span>&#34;);
</span><span>
</span><span>pub fn </span><span>criterion_benchmark</span><span>(</span><span>c</span><span>: &amp;</span><span>mut</span><span> Criterion) {
</span><span>    c.</span><span>bench_function</span><span>(&#34;</span><span>sort_sol</span><span>&#34;, |</span><span>b</span><span>| b.</span><span>iter</span><span>(|| day01::sort_sol(</span><span>black_box</span><span>(</span><span>INPUT</span><span>))));
</span><span>    c.</span><span>bench_function</span><span>(&#34;</span><span>heap_sol</span><span>&#34;, |</span><span>b</span><span>| b.</span><span>iter</span><span>(|| day01::heap_sol(</span><span>black_box</span><span>(</span><span>INPUT</span><span>))));
</span><span>}
</span><span>
</span><span>criterion_group!(benches, criterion_benchmark);
</span><span>criterion_main!(benches);
</span></code></pre>
<p>And now we run our benchmarks:</p>
<pre><code><span>$ cargo bench
</span><span>...
</span><span>     Running unittests src/lib.rs (target/release/deps/day01-aec6c446d7e6dd94)
</span><span>
</span><span>running 3 tests
</span><span>test tests::test_heap_sol ... ignored
</span><span>test tests::test_parse_input ... ignored
</span><span>test tests::test_sort_sol ... ignored
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 3 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>     Running unittests src/bin/main.rs (target/release/deps/main-cc52451e5c082913)
</span><span>
</span><span>running 0 tests
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>     Running benches/my_benchmark.rs (target/release/deps/my_benchmark-710fed971563135d)
</span><span>Gnuplot not found, using plotters backend
</span><span>sort_sol                time:   [35.656 µs 35.678 µs 35.699 µs]
</span><span>                        change: [-0.1767% -0.0397% +0.1173%] (p = 0.60 &gt; 0.05)
</span><span>                        No change in performance detected.
</span><span>Found 5 outliers among 100 measurements (5.00%)
</span><span>  5 (5.00%) high severe
</span><span>
</span><span>heap_sol                time:   [32.523 µs 32.553 µs 32.601 µs]
</span><span>                        change: [-0.3934% -0.2565% -0.1198%] (p = 0.00 &lt; 0.05)
</span><span>                        Change within noise threshold.
</span><span>Found 6 outliers among 100 measurements (6.00%)
</span><span>  2 (2.00%) high mild
</span><span>  4 (4.00%) high severe
</span></code></pre>
<p>Nice, our heap solution is slightly faster than our sort solution. Also, 32 <em>microseconds</em>
is pretty quick... so quick that it&#39;s not even really worth benchmarking our solution with <a href="https://github.com/sharkdp/hyperfine">hyperfine</a>.
We&#39;ll save that for another time.</p>
<h2 id="that-s-it">That&#39;s it!</h2>
<p>That&#39;s all for now. Now that most of the boilerplate is out of the way, I&#39;m hopeful that
the next several days will go much quicker! See you next time.</p>

        </div></div>
  </body>
</html>
