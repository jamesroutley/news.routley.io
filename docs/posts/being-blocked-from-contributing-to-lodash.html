<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://c.ruatta.com/on-being-blocked-from-contributing-to-lodash/">Original</a>
    <h1>Being blocked from contributing to lodash</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-10-06T18:36Z">
                    06 Oct, 2025
                </time>
            </i>
        </p>
    

    <p>My Github account was blocked from contributing security improvements to the <a href="https://github.com/lodash">lodash</a> project. This was my first open source work in a while, and unfortunately, it appears it was a waste of time. That said, I did learn a few lessons about contributing to open source projects that others might benefit from.</p>
<h2 id="background">Background</h2><p>I&#39;ve been going down a rabbit hole to figure out how to improve supply chain security in the JavaScript ecosystem. A common problem is the inability to trust the true origin of code within a package and how that package was built and published. Phishing attacks on npm registry users exploit this weakness - threat actors with stolen credentials will directly publish malicious package versions to the npm registry, bypassing CI/CD entirely. A consumer of the package will be none the wiser. <code>npm install</code> will happily install the malicious package version if configured to do so.</p>
<p>One way to detect this type of attack is through package provenance. <a href="https://docs.npmjs.com/generating-provenance-statements">Publishing packages with provenance</a> is the process of creating a signed statement of attestation during the building of a package so that the build process can later be verified. The statement of attestation contains metadata about the build, provided in part by a trusted CI/CD platform, like Github Actions runners. While not a security panacea, dependent projects can check the statement of attestation to detect whether a package was published by a trusted CI/CD process or directly uploaded to the artifact registry, bypassing CI/CD.</p>
<p>The npm client itself has made the process of generating and publishing a statement of attestation trivial - all you need is a Github Actions workflow that runs the <code>publish</code> command with these flags.</p>
<div><pre><span></span>npm publish --provenance --access public
</pre></div>
<p>For packages that already use Github as a code forge, adopting a workflow to publish packages with these additional flags is, in most cases, a low-effort task. Despite this, the adoption of package provenance appears abysmally low. Of the ten most popular packages on the npm registry, only two are published with provenance. Even the <code>typescript</code> package is not published with provenance.</p>
<h2 id="trying-to-help">Trying to Help</h2><p>I&#39;ve always felt like an outsider in the world of open source -  mostly a consumer, not a contributor. It occurred to me that since I value having npm packages published with provenance, I could be the one to push those PRs. This could be my way of giving something back.</p>
<p>Among the top ten packages on npmjs.com without provenance, <a href="https://github.com/lodash/lodash">lodash</a> was the one that caught my eye. I have used lodash many times, both professionally and personally. What stood out specifically about it is that there has not been a new release in over 5 years, but it&#39;s still being downloaded tens of millions of times per week. When I went to the Github repo, I saw the main branch had not received a new commit in 9 months. When I checked for a workflow to publish the package, I found nothing. I saw what I thought was a good opportunity. I was certain I could figure out the build process, create a new Github Actions workflow to automatically build lodash, and add provenance to boot. I figured if my initial PR was rejected, I could at least start a conversation about supply chain security and reproducible builds for this very popular project.</p>
<p>Within a few hours, I had a workflow that was mostly working. I reverse-engineered the packaging workflow by digging through git history, reading docs and the wiki. I even managed to publish a forked version of <a href="https://www.npmjs.com/package/@provenance-labs/lodash">lodash to npmjs with provenance</a> after some trial and error.</p>
<p>Unfortunately for me, that trial and error included <a href="https://github.com/lodash/lodash/pull/6014">opening a PR</a> against the lodash repo before I was ready. I quickly closed the PR because I realized that the build artifacts in my version were not quite a 1-to-1 match with what was in the latest build of lodash.</p>
<p>I spent a few more hours in vain trying to figure out how to replicate the build. Eventually, I called it a day and decided to open an issue in the morning to ask the last maintainer who published a build how they managed to generate it.</p>
<h2 id="blocked">Blocked</h2><p>I quickly typed up a Github issue the next morning and pressed &#34;Create&#34;. Nothing happened. I looked around and saw an error I had never seen before on Github: &#34;Error - Failed to create the issue.&#34;</p>
<p>I figured Github was having an outage, so I took a break and did something else. When I tried again though, I saw the same error repeatedly, even after changing the title and content of the issue several times in the off chance I was triggering some kind of blocklist. I decided to try and reproduce the issue in my own repository. No error - I was able to create a Github issue successfully.</p>
<p>At this point, I suspected something was up specifically with lodash but I wasn&#39;t sure what. I went back to my closed PR on a hunch and noticed some new activity. The PR, despite being already closed, was locked and limited to collaborators. At this point, I was fairly certain I had been blocked. What finally gave it away was when I tried to use the watch action on the lodash Github repo, I got a truly bizarre and nonsensical error - I couldn&#39;t watch more than 10,000 repos on Github. I don&#39;t even watch 100 repos, and I could watch any other repo I wanted, outside of the lodash organization.</p>
<p>In an attempt to reach out to clear up any misunderstandings, I opened a Github issue on my forked repo, tagged the lodash org and primary maintainer, and explained the situation. I gave context as to why I had opened the PR, and what I wanted to achieve. Two weeks later, no response. As a last-ditch effort, I sent an email directly to the same primary maintainer, using an email I found in git commit history, but I have also received no response there either. At this point, I believe I&#39;ve been permanently blocked.</p>
<h2 id="lessons-learned">Lessons Learned</h2><p>While the effort I ultimately put into this project appears not to have furthered my goals, at least this was a learning experience. My contributions being rejected reinforces a belief I already held before going into this project - open source maintainers don&#39;t owe me anything. That said, I&#39;m still confused as to why I was blocked for opening a single PR. I wanted to spark a conversation on how to publish a new version of lodash and ultimately make the build process transparent and trustworthy. I&#39;m genuinely curious if my PR was viewed incorrectly as malicious, or if the maintainer who blocked me simply has no interest in what I was trying to do and is signaling that to the lodash community.</p>
<p>When I have time, I will continue to try and add provenance to open source NPM packages where I believe there is value, but I will start slowly and open an issue first to discuss the change. If there&#39;s interest, I&#39;ll create a pull request. If I&#39;m ignored, I&#39;ll move on. My mistake with lodash was jumping in headfirst without gauging the interest of the maintainers or getting a better sense of what was happening in the project. I found out after the fact that the primary maintainer of lodash <a href="https://news.ycombinator.com/item?id=37538426">declared &#34;issue bankruptcy&#34; back in 2023</a>, closing a slew of open Github issues and starting from scratch, and that a major <a href="https://github.com/lodash/lodash/tree/v5-wip">rewrite of the codebase</a> seems to have stalled out with no progress in 11 months. While the <a href="https://github.com/lodash/lodash/blob/main/.github/CONTRIBUTING.md">CONTRIBUTING.md</a> in the repo indicates &#34;Contributions are always welcome&#34;, I mistakenly believed that demonstrating enthusiasm through a pull request was the best way to contribute to open source. I should have known better. As a professional software engineer, I&#39;ve learned this lesson before: more effort upfront doesn&#39;t guarantee results. A five-minute conversation to gauge interest can save hours of work on an unwanted PR.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
