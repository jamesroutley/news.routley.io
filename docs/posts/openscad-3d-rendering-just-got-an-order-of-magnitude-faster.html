<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ochafik.com/jekyll/update/2022/02/09/openscad-fast-csg-contibution.html">Original</a>
    <h1>OpenSCAD 3D rendering just got an order of magnitude faster</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><strong>TL;DR: <a href="https://openscad.org/">OpenSCAD</a> users: download a <a href="https://openscad.org/downloads.html#snapshots">nightly build</a> &amp; enable <code>fast-csg</code> in settings for 10x faster render (YMMV). Make your models more ambitious and report issues / successes <a href="https://github.com/openscad/openscad/pull/4087">here</a>!</strong></p>

<p><em>Note: opinions expressed here are my own.</em></p>

<ul id="markdown-toc">
  <li><a href="#openscad--3d-cad-for-developers" id="markdown-toc-openscad--3d-cad-for-developers">OpenSCAD = 3D CAD for developers</a></li>
  <li><a href="#cgal-nef-polyhedra--gmp--so-precise-it-hurts-performance" id="markdown-toc-cgal-nef-polyhedra--gmp--so-precise-it-hurts-performance">CGAL Nef Polyhedra + GMP = so precise it hurts (performance)</a></li>
  <li><a href="#just-concatenating-meshes-huh" id="markdown-toc-just-concatenating-meshes-huh">Just concatenating meshes, huh?</a></li>
  <li><a href="#cgals-other-hidden-gem-corefinement-functions" id="markdown-toc-cgals-other-hidden-gem-corefinement-functions">CGAL‚Äôs other hidden gem: corefinement functions</a></li>
  <li><a href="#great-results-already" id="markdown-toc-great-results-already">Great results already</a></li>
  <li><a href="#what-about-multithreading-or-skipping-operations-altogether-" id="markdown-toc-what-about-multithreading-or-skipping-operations-altogether-">What about multithreading? Or skipping operations altogether? üôÉ</a></li>
  <li><a href="#rewriting-trees-to-increase-laziness-and-parallelizability" id="markdown-toc-rewriting-trees-to-increase-laziness-and-parallelizability">Rewriting trees to increase laziness and parallelizability</a></li>
  <li><a href="#whats-next" id="markdown-toc-whats-next">What‚Äôs next?</a></li>
  <li><a href="#thanks" id="markdown-toc-thanks">Thanks!</a></li>
</ul>

<h2 id="openscad--3d-cad-for-developers">OpenSCAD = 3D CAD for developers</h2>

<p>OpenSCAD is a popular open-source design tool for 3D printing afficionados (and others). It‚Äôs essentially a CAD software for programmers with a minimalist UI. A simple declarative programming language defines <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">Constructive Solid Geometry</a> (CSG) operations like unions, intersections, differences, which can be parameterized with loops and variables.</p>

<p><img src="https://user-images.githubusercontent.com/273860/153035451-e0ab2792-d6de-449b-9fb3-ae22307d48f6.png" alt="image"/></p>

<p>Last year I grew fond of it to design ever more complex models, but started running into limitations: while interactive rendering was fine, the final rendering (creating the STL files to give to the 3D printing slicer) was horrendously slow. Slow enough to prevent me from doing what I wanted, which was to generate large, varying scalemail patterns:</p>

<p><img src="https://user-images.githubusercontent.com/273860/153035188-d18a8db7-a18c-4d04-aecc-0b7cabfa77e8.png" alt="a very slow model to render"/></p>

<p>But something was off: my slicer software (Cura) was able to handle 10x10 grids of my scalemail pattern without breaking a sweat, so why was OpenSCAD so slow? So after investigating alternatives (wasn‚Äôt keen to get locked in a certain popular but proprietary CAD software with huge a learning curve and high prices after its 1 year hobbyist licenses), I dove into OpenSCAD‚Äôs codebase and tried to understand what it was up to.</p>

<h2 id="cgal-nef-polyhedra--gmp--so-precise-it-hurts-performance">CGAL Nef Polyhedra + GMP = so precise it hurts (performance)</h2>

<p>As it turns out, OpenSCAD is using the <a href="https://www.cgal.org/">Computational Geometry Algorithms Library</a> (CGAL) for its CSG operations. That amazing library allows for completely generic numeric types, and the type OpenSCAD is using is some voodoo magic ‚Äúexact‚Äù numeric type based on the <a href="https://gmplib.org/">GNU Multiple Precision Arithmetic Library</a> (GMP).</p>

<p>More specifically, OpenSCAD is using <a href="https://doc.cgal.org/latest/Nef_3/classCGAL_1_1Nef__polyhedron__3.html">3D boolean operations on Nef Polyhedra</a>, which provides extrely robust and accurate results, two welcome properties in the 3D printing hobby, but also is extremely complex and slow to run (especially with those exact underlying number abstractions).</p>

<h2 id="just-concatenating-meshes-huh">Just concatenating meshes, huh?</h2>

<p>But surely I thought, if we just need to assemble a grid of my interlocking patterns without any intersection, it‚Äôs just a matter of concatenating the meshes, no special operations needed.</p>

<p>Even for unions, many geometrical operations are required when overlaps / intersections require creating new points, new edges, so as to maintain the topological soundness (<a href="https://en.wikipedia.org/wiki/Manifold">manifoldness</a>) of solids so they can be 3D-printed later, etc.</p>

<p>So I started exploring the ‚Äúfast-union‚Äù route (<a href="https://github.com/openscad/openscad/pull/3636">openscad#3636</a>), in which I‚Äôd literally concatenated meshes if I could determine that they can‚Äôt actually intersect with each other based on their bounding boxes. This worked great for some models, but ran into weird performance for others. Searching for good operands to union together is important for many models, e.g. in a grid of overlapping tiles you can skip a tile to do a fast-union but two consecutive tiles would need a proper union. That search neededs to be bounded (otherwise would be in quadratic time of # of operands; randomizing the operands would kind of work well enough), the bounding box operations need to be lighter than the geometry itself (e.g. not true when unioning a swarm of cubes), many other things needed to be taken into account.</p>

<p>I‚Äôve paused this track for now but might explore it again.</p>



<p>As some of the extremely friendly and helpful OpenSCAD project maintainers ‚ù§Ô∏è pointed out <a href="https://openscad.org/community.html#irc">on IRC</a>, there was another option in stock: faster operations using the <a href="https://doc.cgal.org/latest/Polygon_mesh_processing/index.html">Polygon Mesh Processing</a> CGAL package (authored by <a href="https://github.com/sloriot">sloriot@</a>) and its ‚Äúcorefinement‚Äù functions. For that I had to introduce <a href="https://doc.cgal.org/latest/Surface_mesh/index.html">Surface_mesh</a> (after trying w/ less efficient <a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a>) into OpenSCAD.</p>

<p>Corefinement works great in some cases, crashes (sometimes in unrecoverable ways) or politely fails in others (for instance it dislikes non-manifold inputs, or inputs that share edges / vertices). So I ended up creating a hybrid of Surface_mesh corefinement and Nef operations, reverting to the slow safety of Nefs when we detect it‚Äôs likely unsafe to use corefinement (<a href="https://github.com/openscad/openscad/pull/4087">openscad#4087</a>). My goals was to provide the maximum possible backwards compatibility with all the existing model files out there.</p>

<h2 id="great-results-already">Great results already</h2>

<p><strong>The result: 10x faster or more for <a href="https://gist.github.com/ochafik/2db96400e3c1f73558fcede990b8a355">my models</a> üéâüéâüéâ</strong></p>

<p>And <strong>up to 100x</strong> if you remove the aforementioned safety checks with the <code>fast-csg-trust-corefinement</code> feature (<a href="https://github.com/openscad/openscad/pull/4101, which may earn you some crashes ü§∑‚Äç‚ôÇÔ∏è">openscad#4101</a>.</p>

<p>You should test it yourself (<a href="https://openscad.org/downloads.html#snapshots">grab a nightly build</a>; also hopefully we get some official benchmark suite soon, see discussion in <a href="https://github.com/openscad/openscad/issues/3931">openscad#3931</a>).</p>

<h2 id="what-about-multithreading-or-skipping-operations-altogether-">What about multithreading? Or skipping operations altogether? üôÉ</h2>

<p>So I was getting there, performance-wise, but my models were still too slow to <em>really</em> scale up in complexity.</p>

<p>It was quite obvious from the start that OpenSCAD‚Äôs rendering is mono-threaded, so <a href="https://github.com/ochafik/openscad/commits/multithreaded-hack2">I tried multithreading it</a> (as others had done <a href="https://github.com/openscad/openscad/pull/3636">here</a> and <a href="https://github.com/openscad/openscad/pull/3193">there</a>, which I didn‚Äôt know yet) but found it hard to get good speedups because of the tree structure of lots of models. Dependencies limit the amount of parallel operations that can be performed.</p>

<p>I then discovered that new experimental <code>lazy-union</code> feature (<a href="https://ochafik.com/jekyll/update/2022/02/09/url">openscad#350</a>, in nightly builds since a year) which essentially leaves the final top-level union up to the slicer to do. This can be a big deal if your model is just a top-level concatenation of very complex models, as it literally takes no time at all to (not) do that top-level union.</p>

<p><strong>BUT</strong>, as soon as modules are involved, or for loops, or transforms, etc, <code>lazy-union</code>‚Äôs benefits are out of reach and OpenSCAD does perform actual unions, which may be 100x faster with <code>fast-csg</code>, but still not fast enough to scale my scalemail to 100x100 grids :-D</p>

<h2 id="rewriting-trees-to-increase-laziness-and-parallelizability">Rewriting trees to increase laziness and parallelizability</h2>

<p>So the other promising approach is rewriting the CSG tree to something that provides more lazy-unioniable top-level operands, and also increases the arity of each individual CGS operation, especially those that can be parallelized (e.g. union and intersection).</p>

<div><div><pre><code><span>union</span><span>()</span> <span>{</span>
  <span>a</span><span>();</span>
  <span>translate</span><span>([</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>])</span>
    <span>union</span><span>()</span> <span>{</span>
      <span>color</span><span>(</span><span>&#34;</span><span>red</span><span>&#34;</span><span>)</span> <span>square</span><span>(</span><span>1</span><span>);</span>
      <span>color</span><span>(</span><span>&#34;</span><span>green</span><span>&#34;</span><span>)</span> <span>sphere</span><span>(</span><span>1</span><span>);</span>
      <span>translate</span><span>([</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>])</span> <span>sphere</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The result of flattening this tree is to have a top-level union that can be skipped w/ <code>lazy-unions</code>:</p>

<div><div><pre><code><span>a</span><span>();</span>
<span>color</span><span>(</span><span>&#34;</span><span>red</span><span>&#34;</span><span>)</span> <span>translate</span><span>([</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>])</span> <span>square</span><span>(</span><span>1</span><span>);</span>
<span>color</span><span>(</span><span>&#34;</span><span>green</span><span>&#34;</span><span>)</span> <span>translate</span><span>([</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>])</span> <span>sphere</span><span>(</span><span>1</span><span>);</span>
<span>translate</span><span>([</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>])</span> <span>sphere</span><span>(</span><span>1</span><span>);</span>
</code></pre></div></div>

<p>So there you go: <code>rewrite-tree</code> (incubated <a href="https://github.com/ochafik/openscad/commits/rewrite-tree">in this branch</a>) completely drops the amount of time it takes to render this from 1min to 400ms (<code>rewrite-tree</code> + <code>lazy-union</code>). It would have taken 2sec with <code>fast-csg</code>. You can even go to <code>N=10</code> (100 spheres) in 4 seconds, which wouldn‚Äôt complete in reasonable time without the new options (you‚Äôd then typically reduce <code>$fn=50</code> or use other tricks).</p>

<div><div><pre><code><span>$fn</span><span>=</span><span>50</span><span>;</span>
<span>for</span> <span>(</span><span>i</span><span>=</span><span>[</span><span>0</span><span>:</span><span>N</span><span>-</span><span>1</span><span>])</span> <span>translate</span><span>([</span><span>i</span><span>,</span><span>0</span><span>,</span><span>0</span><span>])</span>
  <span>for</span> <span>(</span><span>j</span><span>=</span><span>[</span><span>0</span><span>:</span><span>N</span><span>-</span><span>1</span><span>])</span> <span>translate</span><span>([</span><span>0</span><span>,</span><span>j</span><span>,</span><span>0</span><span>])</span>
    <span>sphere</span><span>(</span><span>d</span><span>=</span><span>1.1</span><span>);</span>
</code></pre></div></div>

<h2 id="whats-next">What‚Äôs next?</h2>

<p>Please <a href="https://openscad.org/downloads.html#snapshots">download a nightly build</a> and (stress) test these features (enable in the settings, or in CLI with <code>--enable=fast-csg</code>), <a href="https://github.com/openscad/openscad/issues">file bugs</a> (or simply report any success on the <a href="https://github.com/openscad/openscad/pull/3641">umbrella PR</a>). That‚Äôs how open-source software gets better üôè.</p>

<p>Roadmap to making OpenSCAD lightning fast:</p>

<ul>
  <li>Introduce corefinement CSG operations instead of Nef polyhedra (<code>fast-csg</code> feature in Nightly builds, <a href="https://github.com/openscad/openscad/pull/4087">openscad#4087</a>; initial discussions in <a href="https://github.com/openscad/openscad/pull/3641">openscad#3641</a>)</li>
  <li>Trust corefinement to handle more cases (<code>fast-cst-trust-corefinement</code> feature, <a href="https://github.com/openscad/openscad/pull/4101">openscad#4101</a>). Likely to get more crashes here.</li>
  <li>Investigate non-lazy CGAL kernels. Currently need <code>fast-csg-exact</code> feature to avoid some extreme cases.</li>
  <li>Experiment with CGAL‚Äôs upcoming simplification routines (<a href="https://github.com/CGAL/cgal/pull/5461">cgal#5461</a>). Corefinement currently produces more triangles than Nefs, which can make some models larger and even slower.</li>
  <li>Enable <code>fast-csg</code> (and maybe <code>fast-csg-trust-corefinement</code>) by default in the next OpenSCAD release unless blockers are found.</li>
  <li>Introduce <code>rewrite-tree</code> feature to vastly expand cases covered by <code>lazy-union</code>.</li>
  <li>Ensure unions and intersections are parallelized to some level, maybe using one of the existing experiments.</li>
</ul>

<h2 id="thanks">Thanks!</h2>

<p>Huge thanks to the dedicated team of OpenSCAD maintainers for their endless patience &amp; support (special shoutouts to <a href="https://github.com/t-paul">t-paul</a>, <a href="https://github.com/thehans">thehans</a>, <a href="https://github.com/redlizard">redlizard</a>, <a href="https://github.com/rcolyer">rcolyer</a> and <a href="https://github.com/MichaelAtOz">MichaelAtOz</a>) and CGAL corefinement guru <a href="https://github.com/thehans">sloriot</a> for providing the magic (and prompt support) to make the magic happen.</p>

<p>Oh and thank <em>you</em> for reading!</p>

<p>Please <strong>add any comments to <a href="https://gist.github.com/ochafik/6e95596a6e6188b2062ee056b55ce47d">this gist</a></strong>
(there are also comment <strong>threads <a href="https://www.reddit.com/r/openscad/comments/so3gv2/openscad_3d_rendering_just_got_an_order_of/">on reddit</a>, <a href="https://news.ycombinator.com/item?id=30277356">hacker news</a> and <a href="https://lists.openscad.org/empathy/thread/B7O2DPEAFI44QV76F2DO2YGKYSFVA54J">on the openscad mailing-list</a></strong>).</p>

<p><strong>Follow <a href="https://twitter.com/ochafik">ochafik@</a></strong> on Twitter to follow my next experiments!</p>

  </div></div>
  </body>
</html>
