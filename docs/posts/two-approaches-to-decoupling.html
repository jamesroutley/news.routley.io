<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://htmx.org/essays/two-approaches-to-decoupling/">Original</a>
    <h1>Two Approaches to Decoupling</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  
  <blockquote>
<p>The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on 
a uniform interface between components. By applying the software engineering principle of generality to the component 
interface, the overall system architecture is simplified and the visibility of interactions is improved. 
Implementations are decoupled from the services they provide, which encourages independent evolvability.</p>
</blockquote>
<p><em>-Roy Fielding, <a rel="noopener" target="_blank" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5</a></em></p>
<p>In this essay we will look at two different types of decoupling in the context of web applications:</p>
<ul>
<li>Decoupling at the <em>application level</em> via a generic JSON Data API</li>
<li>Decoupling at the <em>network architecture level</em> via a hypermedia API</li>
</ul>
<p>We will see that, at the application level, a hypermedia API tighlty couples your front-end and back-end.  Despite this
fact, surprisingly, the hypermedia API is in fact more resilient in the face of change.</p>
<h2 id="coupling"><a href="#coupling" aria-label="Anchor link for: coupling">üîó</a>Coupling</h2>
<p><a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29">Coupling</a> is a property of a software system in which
two modules or aspects of the system have a high degree of interdependence. <em>Decoupling</em> software is the act of reducing this 
interdependence between unrelated modules so that they can evolve independently of one another.</p>
<p>The concept of coupling and decoupling is closely (and inversely) related to 
<a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">cohesion</a>.  Highly cohesive software has related logic 
within a module or conceptual boundary, rather than spread out throughout a codebase.  (A related concept is our own idea
of <a href="https://htmx.org/essays/locality-of-behaviour/">Locality of Behavior</a>)</p>
<p>Broadly, experienced developers strive for decoupled and cohesive systems.</p>
<h2 id="json-data-apis-application-level-decoupling"><a href="#json-data-apis-application-level-decoupling" aria-label="Anchor link for: json-data-apis-application-level-decoupling">üîó</a>JSON Data APIs - Application Level Decoupling</h2>
<p>A common approach to building web applications today is to create a JSON Data API and then consume that JSON API using
a JavaScript framework such as React.  This application-level architectural decision decouples the front-end code
from the back-end code, and allows the re-use of the JSON API in other contexts, such as a mobile applications, 3rd 
party client integrations, etc.</p>
<p>This is an <em>application-level</em> decoupling because the decision and implementation of the decoupling is done by the
application developer themselves.  The JSON API provides a ‚Äúhard‚Äù interface between the two pieces of software.</p>
<p>Using my favorite example, consider a simple JSON for a bank that has a <code>GET</code> end point at <code>https://example.com/account/12345</code>.
This API might return the following content:</p>
<pre data-lang="json"><code data-lang="json"><span>HTTP/</span><span>1.1 200</span><span> OK
</span><span>
</span><span>{
</span><span>    </span><span>&#34;account&#34;</span><span>: {
</span><span>        </span><span>&#34;account_number&#34;</span><span>: </span><span>12345</span><span>,
</span><span>        </span><span>&#34;balance&#34;</span><span>: {
</span><span>            </span><span>&#34;currency&#34;</span><span>: </span><span>&#34;usd&#34;</span><span>,
</span><span>            </span><span>&#34;value&#34;</span><span>: </span><span>-50.00
</span><span>        },
</span><span>        </span><span>&#34;status&#34;</span><span>: </span><span>&#34;overdrawn&#34;
</span><span>    }
</span><span>}
</span></code></pre>
<p>This Data API can be consumed by any client: a web application, a mobile client, a third party, etc.  It is, therefore
decoupled from any particular client.</p>
<h3 id="decoupling-via-a-json-api-in-practice"><a href="#decoupling-via-a-json-api-in-practice" aria-label="Anchor link for: decoupling-via-a-json-api-in-practice">üîó</a>Decoupling Via A JSON API In Practice</h3>
<p>So far, so good.  But how does this decoupling work out in practice?</p>
<p>In our essay <a rel="noopener" target="_blank" href="https://htmx.org/essays/splitting-your-apis/">Splitting Your Data &amp; Application APIs: Going Further</a> you
will find the following quote:</p>
<blockquote>
<p>The worst part of my job these days is designing APIs for front-end developers. The conversation goes inevitably as:</p>
<p>Dev ‚Äì So, this screen has data element x,y,z‚Ä¶ could you please create an API with the response format {x: , y:, z: }</p>
<p>Me ‚Äì Ok</p>
<p>Jean-Jacques Dubray - <a rel="noopener" target="_blank" href="https://www.infoq.com/articles/no-more-mvc-frameworks">https://www.infoq.com/articles/no-more-mvc-frameworks</a></p>
</blockquote>
<p>This quote shows that, although we have driven coupling out with a pitchfork (or, in our case, with a JSON API) it has come 
back through requests for web application-specific JSON API end points.  These sorts of requests end up recoupling the
front-end and back-end code: the JSON API is longer providing a generic JSON Data API, but rather a specific API for 
the front-end needs.</p>
<p>Worse, these front-end needs will often change frequently as your application evolves, necessitating the modification
of your JSON API.  What if other non-web application clients have come to depend on the original API?</p>
<p>This problem leads to the ‚Äúversioning hell‚Äù that many JSON Data APIs that are supporting both web applications as well
as other non-web application clients.</p>
<h4 id="a-solution-graphql"><a href="#a-solution-graphql" aria-label="Anchor link for: a-solution-graphql">üîó</a>A Solution: GraphQL</h4>
<p>One potential solution to this problem is to introduce <a rel="noopener" target="_blank" href="https://graphql.org/">GraphQL</a>, which allows you to have a much
more expressive JSON API.  This means that you don‚Äôt need to change it as often when application needs change.</p>
<p>This is a reasonable approach for addressing the problem outlined above, but there are problems with it.  The biggest 
issue that we see is security, as we outline this in <a rel="noopener" target="_blank" href="https://intercoolerjs.org/2016/02/17/api-churn-vs-security.html">The API Churn/Security Trade-off</a> essay.</p>
<p>Apparently facebook uses a <a rel="noopener" target="_blank" href="https://twitter.com/AdamChainz/status/1392162996844212232">whitelist</a> to deal with the security
issues introduced by GraphQL, but many developers who are using GraphQL appear to not understand the security threats 
involved with it.</p>
<h4 id="another-solution-splitting-your-application-general-data-apis"><a href="#another-solution-splitting-your-application-general-data-apis" aria-label="Anchor link for: another-solution-splitting-your-application-general-data-apis">üîó</a>Another Solution: Splitting Your Application &amp; General Data APIs</h4>
<p>Another approach recommended by <a rel="noopener" target="_blank" href="https://max.engineer/">Max Chernyak</a> in his article
<a rel="noopener" target="_blank" href="https://max.engineer/server-informed-ui">Don‚Äôt Build A General Purpose API To Power Your Own Front End</a>, is two build
<em>two</em> JSON APIs: </p>
<ul>
<li>An application specific JSON API that can be modified as needed</li>
<li>A general purpose JSON API that can be consumed by other clients such as mobile, etc.</li>
</ul>
<p>This is a pragmatic solution to address what appears to be the <em>inherent</em> coupling between your web application‚Äôs front-end
and the back-end code supporting it, and it doesn‚Äôt involve the security tradeoffs involved in a general GraphQL API.</p>

<p>Now let us consider how a <em>hypermedia API</em> decouples software.</p>
<p>Consider a potential response to the same <code>GET</code> for <code>https://example.com/account/12345</code> that we saw above:</p>
<pre data-lang="html"><code data-lang="html"><span>HTTP/1.1 200 OK
</span><span>
</span><span>&lt;</span><span>html</span><span>&gt;
</span><span>  &lt;</span><span>body</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Account number: 12345&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Balance: $100.00 USD&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Links:
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/deposits&#34;</span><span>&gt;deposits&lt;/</span><span>a</span><span>&gt;
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/withdrawals&#34;</span><span>&gt;withdrawals&lt;/</span><span>a</span><span>&gt;
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/transfers&#34;</span><span>&gt;transfers&lt;/</span><span>a</span><span>&gt;
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/close-requests&#34;</span><span>&gt;close-requests&lt;/</span><span>a</span><span>&gt;
</span><span>    &lt;/</span><span>div</span><span>&gt;
</span><span>  &lt;</span><span>body</span><span>&gt;
</span><span>&lt;/</span><span>html</span><span>&gt;
</span></code></pre>
<p>(Yes, this is an API response.  It just happens to be a hypermedia-formatted response, in this case HTML.)</p>
<p>Here we see that, at the application level, this response could not be more tightly coupled to the ‚Äúfront-end‚Äù.  In fact,
it <em>is</em> the front-end, in the sense that the API response specifies not only the data for the resource, but also provides
layout information on how, exactly, to display this data to the user.</p>
<p>The response also contains <em>hypermedia controls</em>, in this case, links, that an end user can select from to continue
navigating the hypermedia API that this <a rel="noopener" target="_blank" href="https://htmx.org/essays/hypermedia-driven-applications/">Hypermedia-Driven Application</a> provides.</p>
<p>So, where is the decoupling in this case?</p>
<h3 id="rest-the-uniform-interface"><a href="#rest-the-uniform-interface" aria-label="Anchor link for: rest-the-uniform-interface">üîó</a>REST &amp; The Uniform Interface</h3>
<p>The decoupling in this case is occurring at a <em>lower level</em>.  It is happening at the <em>network architecture</em> level, which
is to say, at the system level.  <a rel="noopener" target="_blank" href="https://hypermedia.systems">Hypermedia systems</a> are designed to decouple the hypermedia
client (in the case of the web, the browser) from the hypermedia server.</p>
<p>This is accomplished primarily via the Uniform Interface constraint of REST and, in particular, by using 
Hypermedia As The Engine of Application State (<a href="https://htmx.org/essays/hateoas">HATOEAS</a>).</p>
<h3 id="decoupling-via-hypermedia-in-practice"><a href="#decoupling-via-hypermedia-in-practice" aria-label="Anchor link for: decoupling-via-hypermedia-in-practice">üîó</a>Decoupling Via Hypermedia In Practice</h3>
<p>How does this sort of decoupling work in practice?  Well, let‚Äôs say that we wish to remove the ability to transfer money 
from our bank to other banks as well as the ability to close accounts.</p>
<p>What does our hypermedia response for this <code>GET</code> request now look like?</p>
<pre data-lang="html"><code data-lang="html"><span>HTTP/1.1 200 OK
</span><span>
</span><span>&lt;</span><span>html</span><span>&gt;
</span><span>  &lt;</span><span>body</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Account number: 12345&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Balance: $100.00 USD&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div</span><span>&gt;Links:
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/deposits&#34;</span><span>&gt;deposits&lt;/</span><span>a</span><span>&gt;
</span><span>        &lt;</span><span>a </span><span>href</span><span>=</span><span>&#34;/accounts/12345/withdrawals&#34;</span><span>&gt;withdrawals&lt;/</span><span>a</span><span>&gt;
</span><span>    &lt;/</span><span>div</span><span>&gt;
</span><span>  &lt;</span><span>body</span><span>&gt;
</span><span>&lt;/</span><span>html</span><span>&gt;
</span></code></pre>
<p>You can see that in this response, links for those two actions have been removed from the HTML.  The browser simply 
render the new HTML to the user.  To a rounding error, there are no clients sitting around using the <em>old</em> API.  The
API is encoded within and discovered through the hypermedia.</p>
<p>This means we can dramatically change our API without breaking our clients.</p>
<p>This flexibility is the crux of the REST-ful network architecture and, in particular, of <a href="https://htmx.org/essays/hateoas/">HATEOAS</a>.</p>
<p>As you can see, despite much tighter <em>application-level</em> coupling between our front-end and back-end, we actually have
more flexibility due to the <em>networks architecture</em> decoupling afforded to us by the Uniform Interface aspect of 
REST-ful <a rel="noopener" target="_blank" href="https://hypermedia.systems">hypermedia systems</a>.</p>
<h3 id="but-that-s-a-terrible-data-api"><a href="#but-that-s-a-terrible-data-api" aria-label="Anchor link for: but-that-s-a-terrible-data-api">üîó</a>But That‚Äôs A Terrible (Data) API!</h3>
<p>Many people would object that, sure, this hypermedia API may be flexible for our web application, but it makes for a 
terrible general purpose API.</p>
<p>This is quite true.  This hypermedia API is tuned for a specific web application.  It would be cumbersome and error-prone
to try to download this HTML, parse it and try to extract information from it.  This hypermedia API only makes sense as part
of a larger hypermedia system, being consumed by a proper hypermedia client.</p>
<p>This is exactly why we recommend creating a general purpose JSON API alongside your hypermedia API in
<a rel="noopener" target="_blank" href="https://htmx.org/essays/splitting-your-apis/">Splitting Your Data &amp; Application APIs: Going Further</a>.  You can
take advantage of the flexibility of hypermedia for your own web application, while providing a 
general purpose JSON API for mobile applications, third party applications, etc.</p>
<p>(Although, we should mention, a <a rel="noopener" target="_blank" href="https://hyperview.org">hypermedia-based mobile application</a> might be a good choice too!)</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion">üîó</a>Conclusion</h2>
<p>In this essay we looked at two different types of decoupling:</p>
<ul>
<li>Application level decoupling via a JSON Data API</li>
<li>Network-architecture decoupling via REST/HATEOAS in a hypermedia system</li>
</ul>
<p>And we saw that despite the tighter application-level coupling found in a hypermedia-based application, it is the
hypermedia system that handles changes more gracefully.</p>

  <p>
      &lt;/&gt;
    </p>
  </div></div>
  </body>
</html>
