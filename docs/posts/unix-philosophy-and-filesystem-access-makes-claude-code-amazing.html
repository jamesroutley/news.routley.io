<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.alephic.com/writing/the-magic-of-claude-code">Original</a>
    <h1>Unix philosophy and filesystem access makes Claude Code amazing</h1>
    
    <div id="readability-page-1" class="page"><p>If you&#39;ve talked to me lately about AI, you&#39;ve almost certainly been subject to a long soliloquy about the wonders of Claude Code. What started as a tool I ran in parallel with other tools to aid coding has turned into my full-fledged agentic operating system, supporting all kinds of workflows.</p><div><p>Most notably, <a href="https://obsidian.md/"><span>Obsidian</span></a>, the tool I use for note-taking. The difference between Obsidian and Notion or Evernote is that all the files are just plain old Markdown files stored on your computer. You can sync, style, and save them, but ultimately, it&#39;s still a text file on your hard drive. A few months ago, I realized that this fact made my Obsidian notes and research a particularly interesting target for AI coding tools. What first started with trying to open my vault in <a href="https://cursor.com/"><span>Cursor</span></a> quickly moved to a sort of note-taking operating system that I grew so reliant on, I ended up standing up a server in my house so I could connect via SSH from my phone into my Claude Code + Obsidian setup and take notes, read notes, and think through things on the go.</p><p><img alt="CleanShot 2025-09-30 at 09.48.05@2x.png" height="2010" src="https://www.alephic.com/api/media/file/CleanShot%202025-09-30%20at%2009.48.05%402x.png" width="3248"/></p><p>A few weeks ago, I went on <a href="https://every.to/podcast/how-to-use-claude-code-as-a-thinking-partner"><span>Dan Shipper&#39;s AI &amp; I Podcast</span></a> to wax poetic about my love for this setup. I did a pretty deep dive into the system I use, how it works, why it works, etc. I won&#39;t retread all those details—you can read the transcript or listen to the podcast—but I want to talk about a few other things related to Claude Code that I&#39;ve come to realize since the conversation.</p><h2>Why is Claude Code special? What makes it better than Cursor?</h2><p>I&#39;ve really struggled to answer this question. I&#39;m also not sure it&#39;s better than Cursor for all things, but I do think there are a set of fairly exceptional pieces that work together in concert to make me turn to Claude Code whenever I need to build anything these days. Increasingly, that&#39;s not even about applying it to existing codebases as much as it&#39;s building entirely new things on top of its functionality (more on that in a bit).</p><p>So what&#39;s the secret? Part of it lies in how Claude Code approaches tools. As a terminal-based application, it trades accessibility for something powerful: native Unix command integration. While I typically avoid long blockquotes, the <a href="https://en.wikipedia.org/wiki/Unix_philosophy"><span>Unix Philosophy</span></a> deserves an exception—Doug McIlroy&#39;s original formulation captures it perfectly:</p><p>The Unix philosophy is documented by <a href="https://en.wikipedia.org/wiki/Doug_McIlroy"><span>Doug McIlroy</span></a> in the <a href="https://en.wikipedia.org/wiki/Bell_System_Technical_Journal"><span>Bell System Technical Journal</span></a> from 1978:</p><ol><li value="1"><ol><li value="1">Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new &#34;features&#34;.</li><li value="2">Expect the output of every program to become the input to another, as yet unknown, program. Don&#39;t clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don&#39;t insist on interactive input.</li><li value="3">Design and build software, even operating systems, to be tried early, ideally within weeks. Don&#39;t hesitate to throw away the clumsy parts and rebuild them.</li><li value="4">Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you&#39;ve finished using them.</li></ol></li></ol><p>It was later summarized by <a href="https://en.wikipedia.org/wiki/Peter_H._Salus"><span>Peter H. Salus</span></a> in A Quarter-Century of Unix (1994):</p><ul><li value="1"><ul><li value="1">Write programs that do one thing and do it well.</li><li value="2">Write programs to work together.</li><li value="3">Write programs to handle text streams, because that is a universal interface.</li></ul></li></ul><p>These fifty-year-old principles are exactly how LLMs want to use tools. If you look at how these models actually use the tools they&#39;re given, they are constantly &#34;piping&#34; output to input (albeit using their own fuzziness in between). (As an aside, the Unix | command allows you to string the output from one command into the input of another.) When models fail to weld their tools effectively, it is almost always because the tools are overly complex.</p><p><img alt="CleanShot 2025-09-30 at 09.49.30.gif" height="628" src="https://www.alephic.com/api/media/file/CleanShot%202025-09-30%20at%2009.49.30.gif" width="800"/></p><p>So part one of why Claude Code can be so mind-blowing is that the commands that power Unix happen to be perfectly suited for use by LLMs. This is both because they&#39;re simple and also incredibly well-documented, meaning the models had ample source material to teach them the literal ins and outs.</p><p>But that still wasn&#39;t the whole thing. The other piece was obviously Claude Code&#39;s ability to write code initially and, more recently, prose (for me, at least). But while other applications like ChatGPT and Claude can write output, there was something different going on here. Last week, while reading <a href="https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built"><span>The Pragmatic Engineer&#39;s deep dive into how Claude Code is built</span></a>. The answer was staring me in the face: filesystem access. </p><p>The filesystem changes everything. ChatGPT and Claude in the browser have two fatal flaws: no memory between conversations and a cramped context window. A filesystem solves both. Claude Code writes notes to itself, accumulates knowledge, and keeps running tallies. It has state and memory. It can think beyond a single conversation.</p><h2>AI Overhang</h2><p>Back in 2022, when I first played with the GPT-3 API, I said that even if models never got better than they were in that moment, we would still have a decade to discover the use cases. They did get better—reasoning models made tool calling reliable—but the filesystem discovery proves my point.</p><p>I bring this up because <a href="https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built">in the Pragmatic Engineer interview</a>, Boris Cherney, who built the initial version of Claude Code, uses it to describe the aha:</p><p>In AI, we talk about “product overhang”, and this is what we discovered with the prototype. Product overhang means that a model is able to do a specific thing, but the product that the AI runs in isn’t built in a way that captures this capability. What I discovered about Claude exploring the filesystem was pure product overhang. The model could already do this, but there wasn’t a product built around this capability!</p><p>Again, I&#39;d argue it&#39;s filesystem + Unix commands, but the point is that the capability was there in the model just waiting to be woken up, and once it was, we were off to the races. Claude Code works as a blueprint for building reliable agentic systems because it captures model capabilities instead of limiting them through over-engineered interfaces.</p><h2>Going Beyond Code</h2><p>I talked about my Claude Code + Obsidian setup, and I&#39;ve actually taken it a step further by open-sourcing &#34;<a href="https://github.com/heyitsnoah/claudesidian"><span>Claudesidian</span></a>,&#34; which pulls in a bunch of the tools and commands I use in my own Claude Code + Obsidian setup. It also goes beyond that and was a fun experimental ground for me. Most notably, I built an initial upgrade tool so that if changes are made centrally, you can pull them into your own Claudesidian, and the AI will help you check to see if you&#39;ve made changes to the files being updated and, if so, attempt to smartly merge your changes with the new updates. Both projects follow the same Unix philosophy principles—simple, composable tools that do one thing well and work together. This is the kind of stuff that Claude Code makes possible, and why it&#39;s so exciting for me as a new way of building applications.</p><p>Speaking of which, one I&#39;m not quite ready to release, but hopefully will be soon, is something I&#39;ve been calling &#34;Inbox Magic,&#34; though I&#39;ll surely come up with a better name. It&#39;s a Claude Code repo with access to a set of Gmail tools and a whole bunch of prompts and commands to effectively start operating like your own email EA. Right now, the functionality is fairly simple: it can obviously run searches or send emails on your behalf, but it can also do things like triage and actually run a whole training run on how you sound over email so it can more effectively draft emails for you. While Claude Code and ChatGPT both have access to my emails, they mostly grab one or two at a time. This system, because it can write things out to files and do lots of other fancy tricks, can perform a task like “find every single travel-related email in my inbox and use that to build a profile of my travel habits that I can use as a prompt to help ChatGPT/Claude do travel research that&#39;s actually aligned with my preferences.” Anyway, more on this soon, and if it&#39;s something you want to try out, ping me with your GitHub username, and as soon as I feel like I have something ready to test, I&#39;ll happily share it.</p><h2>A Few Takeaways</h2><p>While I generally shy away from conclusions, I think there are a few here worth reiterating.</p><ol><li value="1">The filesystem is a great tool to get around the lack of memory and state in LLMs and should be used more often.</li><li value="2">If you&#39;re trying to get tool calling working, focus on following the Unix philosophy.</li><li value="3">Claude Code represents a blueprint for future agentic systems—filesystem + Unix philosophy should be the template for building reliable, debuggable AI agents rather than complex multi-agent stuff that&#39;s floating around today. Tactically, this means when you’re building tool calling into your own projects, keeping them simple and letting the main model thread “pipe” them is the key. (As an aside, one big problem that needs to be solved in all these agents/chatbots is the ability to pipe things without it going through the context window.)</li><li value="4">Anyone who can&#39;t find use cases for LLMs isn&#39;t trying hard enough</li></ol></div></div>
  </body>
</html>
