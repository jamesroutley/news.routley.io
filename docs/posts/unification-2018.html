<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2018/unification/">Original</a>
    <h1>Unification (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
    <section id="content">
        <article>
            
            <div>
                
                <p>In logic and computer science, unification is a process of automatically solving
equations between symbolic terms. Unification has several interesting
applications, notably in logic programming and <a href="https://eli.thegreenplace.net/2018/type-inference/">type inference</a>. In this post I want to
present the basic unification algorithm with a complete implementation.</p>
<p>Let&#39;s start with some terminology. We&#39;ll be using <em>terms</em> built from
constants, variables and function applications:</p>
<ul>
<li>A lowercase letter represents a constant (could be any kind of constant, like
an integer or a string)</li>
<li>An uppercase letter represents a variable</li>
<li><tt><span>f(...)</span></tt> is an application of function <tt>f</tt> to some parameters, which
are <em>terms</em> themselves</li>
</ul>
<p>This representation is borrowed from <a href="https://en.wikipedia.org/wiki/First-order_logic">first-order logic</a> and is also used in the
Prolog programming language. Some examples:</p>
<ul>
<li><tt>V</tt>: a single variable term</li>
<li><tt>foo(V, k)</tt>: function <tt>foo</tt> applied to variable V and constant k</li>
<li><tt>foo(bar(k), baz(V))</tt>: a nested function application</li>
</ul>
<div id="pattern-matching">
<h2>Pattern matching</h2>
<p>Unification can be seen as a generalization of <em>pattern matching</em>, so let&#39;s
start with that first.</p>
<p>We&#39;re given a constant term and a pattern term. The pattern
term has variables. Pattern matching is the problem of finding a variable
assignment that will make the two terms match. For example:</p>
<ul>
<li>Constant term: <tt>f(a, b, bar(t))</tt></li>
<li>Pattern term: <tt>f(a, V, X)</tt></li>
</ul>
<p>Trivially, the assignment <tt>V=b</tt> and <tt>X=bar(t)</tt> works here. Another name to
call such an assignment is a <em>substitution</em>, which maps variables to their
assigned values. In a less trivial case, variables can appear multiple times in
a pattern:</p>
<ul>
<li>Constant term: <tt>f(top(a), a, <span>g(top(a)),</span> t)</tt></li>
<li>Pattern term: <tt>f(V, a, g(V), t)</tt></li>
</ul>
<p>Here the right substitution is <tt>V=top(a)</tt>.</p>
<p>Sometimes, no valid substitutions exist. If we change the constant term in the
latest example to <tt>f(top(b), a, <span>g(top(a)),</span> t)</tt>, then there is no valid
substitution becase V would have to match <tt>top(b)</tt> and <tt>top(a)</tt>
simultaneously, which is not possible.</p>
</div>
<div id="unification-1">
<h2>Unification</h2>
<p>Unification is just like pattern matching, except that both terms can contain
variables. So we can no longer say one is the pattern term and the other the
constant term. For example:</p>
<ul>
<li>First term: <tt>f(a, V, bar(D))</tt></li>
<li>Second term <tt>f(D, k, bar(a))</tt></li>
</ul>
<p>Given two such terms, finding a variable substitution that will make them
equivalent is called <em>unification</em>. In this case the substitution is <tt>{D=a,
V=k}</tt>.</p>
<p>Note that there is an infinite number of possible unifiers for some solvable
unification problem. For example, given:</p>
<ul>
<li>First term: <tt>f(X, Y)</tt></li>
<li>Second term: <tt>f(Z, g(X))</tt></li>
</ul>
<p>We have the substitution <tt>{X=Z, Y=g(X)}</tt> but also something like <tt>{X=K, Z=K,
Y=g(K)}</tt> and <tt>{X=j(K), Z=j(K), <span>Y=g(j(K))}</span></tt> and so on. The first substitution
is the simplest one, and also the most general. It&#39;s called the <em>most general
unifier</em> or <em>mgu</em>. Intuitively, the <em>mgu</em> can be turned into any other unifier
by performing another substitution. For example <tt>{X=Z, Y=g(X)}</tt> can be turned
into <tt>{X=j(K), Z=j(K), <span>Y=g(j(K))}</span></tt> by applying the substitution <tt>{Z=j(K)}</tt>
to it. Note that the reverse doesn&#39;t work, as we can&#39;t turn the second into the
first by using a substitution. So we say that <tt>{X=Z, Y=g(X)}</tt> is the most
general unifier for the two given terms, and it&#39;s the <em>mgu</em> we want to find.</p>
</div>
<div id="an-algorithm-for-unification">
<h2>An algorithm for unification</h2>
<p>Solving unification problems may seem simple, but there are a number of subtle
corner cases to be aware of. In his 1991 paper <a href="https://www.semanticscholar.org/paper/Correcting-a-Widespread-Error-in-Unification-Norvig/95af3dc93c2e69b2c739a9098c3428a49e54e1b6">Correcting a Widespread Error in
Unification Algorithms</a>,
Peter Norvig noted a common error that exists in many books presenting the
algorithm, including SICP.</p>
<p>The correct algorithm is based on J.A. Robinson&#39;s 1965 paper &#34;A machine-oriented
logic based on the resolution principle&#34;. More efficient algorithms have been
developed over time since it was first published, but our focus here will be
on correctness and simplicity rather than performance.</p>
<p>The following implementation is based on Norvig&#39;s, and the full code (with
tests) is <a href="https://github.com/eliben/code-for-blog/blob/main/2018/unif/unifier.py">available on GitHub</a>.
This implementation uses Python 3, while Norvig&#39;s original is in Common Lisp.
There&#39;s a slight difference in representations too, as Norvig uses the Lisp-y
<tt>(f X Y)</tt> syntax to denote an application of function <tt>f</tt>. The two
representations are isomorphic, and I&#39;m picking the more classical one which is
used in most papers on the subject. In any case, if you&#39;re interested in the
more Lisp-y version, I have some Clojure <a href="https://github.com/eliben/paip-in-clojure/tree/master/src/paip/11_logic">code online</a> that
ports Norvig&#39;s implementation more directly.</p>
<p>We&#39;ll start by defining the data structure for terms:</p>
<div><pre><span></span><span>class</span> <span>Term</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>App</span><span>(</span><span>Term</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>fname</span><span>,</span> <span>args</span><span>=</span><span>()):</span>
       <span>self</span><span>.</span><span>fname</span> <span>=</span> <span>fname</span>
       <span>self</span><span>.</span><span>args</span> <span>=</span> <span>args</span>

    <span># Not shown here: __str__ and __eq__, see full code for the details...</span>


<span>class</span> <span>Var</span><span>(</span><span>Term</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>


<span>class</span> <span>Const</span><span>(</span><span>Term</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>value</span><span>):</span>
        <span>self</span><span>.</span><span>value</span> <span>=</span> <span>value</span>
</pre></div>
<p>An <tt>App</tt> represents the application of function <tt>fname</tt> to a sequence of
arguments.</p>
<div><pre><span></span><span>def</span> <span>unify</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>subst</span><span>):</span>
    <span>&#34;&#34;&#34;Unifies term x and y with initial subst.</span>

<span>    Returns a subst (map of name-&gt;term) that unifies x and y, or None if</span>
<span>    they can&#39;t be unified. Pass subst={} if no subst are initially</span>
<span>    known. Note that {} means valid (but empty) subst.</span>
<span>    &#34;&#34;&#34;</span>
    <span>if</span> <span>subst</span> <span>is</span> <span>None</span><span>:</span>
        <span>return</span> <span>None</span>
    <span>elif</span> <span>x</span> <span>==</span> <span>y</span><span>:</span>
        <span>return</span> <span>subst</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>Var</span><span>):</span>
        <span>return</span> <span>unify_variable</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>y</span><span>,</span> <span>Var</span><span>):</span>
        <span>return</span> <span>unify_variable</span><span>(</span><span>y</span><span>,</span> <span>x</span><span>,</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>App</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span><span>y</span><span>,</span> <span>App</span><span>):</span>
        <span>if</span> <span>x</span><span>.</span><span>fname</span> <span>!=</span> <span>y</span><span>.</span><span>fname</span> <span>or</span> <span>len</span><span>(</span><span>x</span><span>.</span><span>args</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>y</span><span>.</span><span>args</span><span>):</span>
            <span>return</span> <span>None</span>
        <span>else</span><span>:</span>
            <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>x</span><span>.</span><span>args</span><span>)):</span>
                <span>subst</span> <span>=</span> <span>unify</span><span>(</span><span>x</span><span>.</span><span>args</span><span>[</span><span>i</span><span>],</span> <span>y</span><span>.</span><span>args</span><span>[</span><span>i</span><span>],</span> <span>subst</span><span>)</span>
            <span>return</span> <span>subst</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>None</span>
</pre></div>
<p><tt>unify</tt> is the main function driving the algorithm. It looks for a
<em>substitution</em>, which is a Python dict mapping variable names to terms.
When either side is a variable, it calls <tt>unify_variable</tt> which is shown next.
Otherwise, if both sides are function applications, it ensures they apply the
same function (otherwise there&#39;s no match) and then unifies their arguments
one by one, carefully carrying the updated substitution throughout the process.</p>
<div><pre><span></span><span>def</span> <span>unify_variable</span><span>(</span><span>v</span><span>,</span> <span>x</span><span>,</span> <span>subst</span><span>):</span>
    <span>&#34;&#34;&#34;Unifies variable v with term x, using subst.</span>

<span>    Returns updated subst or None on failure.</span>
<span>    &#34;&#34;&#34;</span>
    <span>assert</span> <span>isinstance</span><span>(</span><span>v</span><span>,</span> <span>Var</span><span>)</span>
    <span>if</span> <span>v</span><span>.</span><span>name</span> <span>in</span> <span>subst</span><span>:</span>
        <span>return</span> <span>unify</span><span>(</span><span>subst</span><span>[</span><span>v</span><span>.</span><span>name</span><span>],</span> <span>x</span><span>,</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>Var</span><span>)</span> <span>and</span> <span>x</span><span>.</span><span>name</span> <span>in</span> <span>subst</span><span>:</span>
        <span>return</span> <span>unify</span><span>(</span><span>v</span><span>,</span> <span>subst</span><span>[</span><span>x</span><span>.</span><span>name</span><span>],</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>occurs_check</span><span>(</span><span>v</span><span>,</span> <span>x</span><span>,</span> <span>subst</span><span>):</span>
        <span>return</span> <span>None</span>
    <span>else</span><span>:</span>
        <span># v is not yet in subst and can&#39;t simplify x. Extend subst.</span>
        <span>return</span> <span>{</span><span>**</span><span>subst</span><span>,</span> <span>v</span><span>.</span><span>name</span><span>:</span> <span>x</span><span>}</span>
</pre></div>
<p>The key idea here is recursive unification. If <tt>v</tt> is bound in the
substitution, we try to unify its definition with <tt>x</tt> to guarantee consistency
throughout the unification process (and vice versa when <tt>x</tt> is a variable).
There&#39;s another function being used here - <tt>occurs_check</tt>; I&#39;m retaining its
classical name from early presentations of unification. Its goal is to guarantee
that we don&#39;t have self-referential variable bindings like <tt>X=f(X)</tt> that would
lead to potentially infinite unifiers.</p>
<div><pre><span></span><span>def</span> <span>occurs_check</span><span>(</span><span>v</span><span>,</span> <span>term</span><span>,</span> <span>subst</span><span>):</span>
    <span>&#34;&#34;&#34;Does the variable v occur anywhere inside term?</span>

<span>    Variables in term are looked up in subst and the check is applied</span>
<span>    recursively.</span>
<span>    &#34;&#34;&#34;</span>
    <span>assert</span> <span>isinstance</span><span>(</span><span>v</span><span>,</span> <span>Var</span><span>)</span>
    <span>if</span> <span>v</span> <span>==</span> <span>term</span><span>:</span>
        <span>return</span> <span>True</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>term</span><span>,</span> <span>Var</span><span>)</span> <span>and</span> <span>term</span><span>.</span><span>name</span> <span>in</span> <span>subst</span><span>:</span>
        <span>return</span> <span>occurs_check</span><span>(</span><span>v</span><span>,</span> <span>subst</span><span>[</span><span>term</span><span>.</span><span>name</span><span>],</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>isinstance</span><span>(</span><span>term</span><span>,</span> <span>App</span><span>):</span>
        <span>return</span> <span>any</span><span>(</span><span>occurs_check</span><span>(</span><span>v</span><span>,</span> <span>arg</span><span>,</span> <span>subst</span><span>)</span> <span>for</span> <span>arg</span> <span>in</span> <span>term</span><span>.</span><span>args</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>False</span>
</pre></div>
<p>Let&#39;s see how this code handles some of the unification examples discussed
earlier in the post. Starting with the pattern matching example, where variables
are just one one side:</p>
<div><pre><span></span>&gt;&gt;&gt; unify(parse_term(&#39;f(a, b, bar(t))&#39;), parse_term(&#39;f(a, V, X)&#39;), {})
{&#39;V&#39;: b, &#39;X&#39;: bar(t)}
</pre></div>
<p>Now the examples from the <em>Unification</em> section:</p>
<div><pre><span></span>&gt;&gt;&gt; unify(parse_term(&#39;f(a, V, bar(D))&#39;), parse_term(&#39;f(D, k, bar(a))&#39;), {})
{&#39;D&#39;: a, &#39;V&#39;: k}
&gt;&gt;&gt; unify(parse_term(&#39;f(X, Y)&#39;), parse_term(&#39;f(Z, g(X))&#39;), {})
{&#39;X&#39;: Z, &#39;Y&#39;: g(X)}
</pre></div>
<p>Finally, let&#39;s try one where unification will fail due to two conflicting
definitions of variable X.</p>
<div><pre><span></span>&gt;&gt;&gt; unify(parse_term(&#39;f(X, Y, X)&#39;), parse_term(&#39;f(r, g(X), p)&#39;), {})
None
</pre></div>
<p>Lastly, it&#39;s instructive to trace through the execution of the algorithm for
a non-trivial unification to see how it works. Let&#39;s unify the terms
<tt><span>f(X,h(X),Y,g(Y))</span></tt> and <tt><span>f(g(Z),W,Z,X)</span></tt>:</p>
<ul>
<li><tt>unify</tt> is called, sees the root is an <tt>App</tt> of function <tt>f</tt> and loops
over the arguments.<ul>
<li><tt>unify(X, g(Z))</tt> invokes <tt>unify_variable</tt> because <tt>X</tt> is a variable,
and the result is augmenting subst with <tt>X=g(Z)</tt></li>
<li><tt>unify(h(X), W)</tt> invokes <tt>unify_variable</tt> because <tt>W</tt> is a variable,
so the subst grows to <tt>{X=g(Z), W=h(X)}</tt></li>
<li><tt>unify(Y, Z)</tt> invokes <tt>unify_variable</tt>; since neither <tt>Y</tt> nor <tt>Z</tt>
are in subst yet, the subst grows to <tt>{X=g(Z), W=h(X), Y=Z}</tt> (note that
the binding between two variables is arbitrary; <tt>Z=Y</tt> would be equivalent)</li>
<li><tt>unify(g(Y), X)</tt> invokes <tt>unify_variable</tt>; here things get more
interesting, because <tt>X</tt> is already in the subst, so now we call
<tt>unify</tt> on <tt>g(Y)</tt> and <tt>g(Z)</tt> (what <tt>X</tt> is bound to)<ul>
<li>The functions match for both terms (<tt>g</tt>), so there&#39;s another loop over
arguments, this time only for unifying <tt>Y</tt> and <tt>Z</tt></li>
<li><tt>unify_variable</tt> for <tt>Y</tt> and <tt>Z</tt> leads to lookup of <tt>Y</tt> in the
subst and then <tt>unify(Z, Z)</tt>, which returns the unmodified subst;
the result is that nothing new is added to the subst, but the unification
of <tt>g(Y)</tt> and <tt>g(Z)</tt> succeeds, because it agrees with the existing
bindings in subst</li>
</ul>
</li>
</ul>
</li>
<li>The final result is <tt>{X=g(Z), W=h(X), Y=Z}</tt></li>
</ul>
</div>
<div id="efficiency">
<h2>Efficiency</h2>
<p>The algorithm presented here is not particularly efficient, and when dealing
with large unification problems it&#39;s wise to consider more advanced options. It
does too much copying around of subst, and also too much work is repeated
because we don&#39;t try to cache terms that have already been unified.</p>
<p>For a good overview of the efficiency of unification algorithms, I recommend
checking out two papers:</p>
<ul>
<li>&#34;An Efficient Unificaiton algorithm&#34; by Martelli and Montanari</li>
<li>&#34;Unification: A Multidisciplinary survey&#34; by Kevin Knight</li>
</ul>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<p>
For comments, please send me
<a href="mailto:eliben@gmail.com"><i></i> an email</a>.
</p>        </article>
    </section>

    </div>
</div></div>
  </body>
</html>
