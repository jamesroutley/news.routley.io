<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://collindonnell.com/mvc-isnt-mvc">Original</a>
    <h1>MVC Isn’t MVC</h1>
    
    <div id="readability-page-1" class="page"><div><p>In December of 1979 <a href="https://en.wikipedia.org/wiki/Trygve_Reenskaug">Tyrgve Reenskaug</a>, an employee of <a href="https://en.wikipedia.org/wiki/PARC_(company)">Xerox PARC</a>, published a paper called <a href="https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf">MODELS-VIEWS-CONTROLLERS</a> about a design pattern he had invented for developing applications with a graphical user interface. The entire document was around 500 words long and described each component in it’s own section.</p>

<p>To summarize an already brief document, the components were described this way:</p>
<ul><li>Models: The part of the application which represents the abstractions used for organizing the application’s data. Each part of the model should represent a part of the problem. Models notify views when their data has changed.</li>
<li>Views: A visual representation of a model. Views are updated by querying the model directly, and are notified by the model of updates. A view <em>can</em> update it’s model directly. A view should never know about things like keyboard and mouse events directly.</li>
<li>Controllers: Link between the user and the system. Arranges views on the screen, receives input from the user, passes messages on to views, and updates the model.</li></ul>

<p>He also mentions a special kind of controller called an “editor” which you might be less familiar with:</p>
<ul><li>Editors: A kind of controller which is temporarily inserted between the controller and a view for editing. If you imagine a contacts app, an editor might be created when the user hits edit, and then be discarded when they save or cancel, updating the model as needed.</li></ul>

<p>When you put it all together, you get this kind of beautifully circular system:</p>

<p><a href="https://i.snap.as/onaddV2k.png"><img src="https://i.snap.as/onaddV2k.png" alt="MVC diagram" width="200"/></a></p>

<p>This makes a lot of sense to me, and I think I understand it pretty well. The thing, however, is that the MVC I’ve experienced writing macOS, iOS, and web apps doesn’t really match that description.</p>

<h2 id="apple-style-mvc" id="apple-style-mvc">Apple-Style MVC</h2>

<p>When I first started learning to write apps for Apple platforms around 2007, the way I learned model-view-controller looked like this:</p>

<p><a href="https://i.snap.as/KN4lupSH.png"><img src="https://i.snap.as/KN4lupSH.png" width="600"/></a></p>

<p>In this version, models and views got dumber and controllers handle a lot more. The way I was taught was:</p>
<ul><li>Models are dumb data containers.</li>
<li>Views display data and pass user actions to the controller.</li>
<li>Controllers manage the model, update views, get notified of user actions, update the model, and then also update views as needed when the model changes.</li></ul>

<p>This is still sort-of recognizably MVC, but it’s most accurately described as a <em>variation</em>. The idea with this style  is to decouple views and controllers. In Smalltalk-80, views had a reference to their controller and models notified views directly when their data changed. In Apple-style MVC, more responsibilities are pushed onto the controller, which decouples views, but also means controllers get larger.</p>

<p>The way it often tended to work was that the controller would set individual properties on a view (<code>personView.nameLabel.text = person.name</code>) which would then pass changes to a <a href="https://en.wikipedia.org/wiki/Delegation_pattern">delegate</a> (a helper object that conformed to a specific <a href="https://en.wikipedia.org/wiki/Interface_(object-oriented_programming)">protocol</a>), which didn&#39;t have to be, but was usually the controller. The controller would then update model.</p>

<p>It could also go the other way, where the model changes, and the controller updates the view. For example, in an app which spoke to a web API, the controller would start the API request, get the results, update the model, and then update the view. There could also be another class in there so your networking code wasn’t in the controller, but everything would still usually go <em>through</em> the controller.</p>

<p>Okay, so Apple-style MVC is still MVC, but kind of a different dialect with some different tradeoffs. Some things are less coupled, but controllers tend to get bloated. Cool.</p>

<h2 id="java-model-2-and-ruby-on-rails" id="java-model-2-and-ruby-on-rails">Java, Model-2, and Ruby on Rails</h2>

<p>In the late 1990s, Java developers writing for the web created a new variation of MVC to deal with the fact that web and desktop apps are different. It was called <a href="https://en.wikipedia.org/wiki/JSP_model_2_architecture">Model-2</a>.</p>

<p>In Model-2, the cycle looks like this:</p>
<ol><li>There is a new HTTP request.</li>
<li>The request is routed to a controller action.</li>
<li>The controller renders an appropriate view.</li></ol>

<p>In 2004, a Danish man released a new open source framework based on the Ruby programming language called <a href="https://rubyonrails.org">Ruby on Rails</a> which began the modern web as we know it. Rails used a Model-2 style architecture, but is generally just referred to as an MVC framework.</p>

<p><a href="https://i.snap.as/rPuD4bP9.jpeg"><img src="https://i.snap.as/rPuD4bP9.jpeg" width="250"/></a></p>

<p>The difference here is that things tend to go through a request/response cycle and that they are optimized for <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> applications. In this style, models tend to have a corresponding controller (<code>User</code> goes with <code>UsersController</code>), and each controller method maps to a “view”, which maps to the URL being requested.</p>

<p>It might look like this:</p>

<pre><code>class UserController &lt; ApplicationController
  def index
    @users = User.all
  end
	
  def show
    @user = User.find(params[:id])
  end
end
</code></pre>

<p>This is pretty different than either MVC or Apple-style MVC, but in a way that makes sense for the web. The components don&#39;t have references to each other, because and nothing is <em>alive</em>. Each object is only around long enough for the page to be rendered, and then not again until another request happens.</p>

<p>If you squint you can still see it, though. Here&#39;s the chain of events:</p>
<ol><li>A <code>GET</code> request is made to <code>/users/new</code>.</li>
<li>The request gets routed to the <code>new</code> method on <code>UsersController</code>, renders a page with a user creation form.</li>
<li>The form is submitted, sending a <code>POST</code> request which gets routed to the <code>create</code> method of <code>UsersController</code>.</li>
<li><code>UsersController</code> creates the user using the request data and redirects <code>/users/&lt;user_id&gt;</code>.</li>
<li>The request is routed back to the controller which gets the user from the database and renders the page.</li></ol>

<p>Instead of the components having references or a delegate where different objects stay alive and talk to each other, each of those messages is mapped to an HTTP request. It’s still MVC, kind of, but if you think about it, it’s pretty different. It&#39;s taking something that was designed around stateful objects and adapting it to a stateless environment. It’s more like Apple-style MVC in that everything goes through the controller, but in this case it <em>had</em> to since things only get triggered when there’s a new request.</p>

<p>So again, recognizably in the same family, but still a <em>variation</em> of the original idea.</p>

<h2 id="so-what" id="so-what">So what?</h2>

<p>So what, indeed? Does any of this matter? I mean, not really. One the one hand, the two different styles I looked at are both pretty different versions from what was described in 1979, but, at the same time, how could they not be? 1979 was <em>forty-three</em> years ago.</p>

<p>There are aspects of the original design that could be applied and might be useful — models notifying views of updates while remaining decoupled using <a href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app">observable objects with SwiftUI</a> in Swift or something like <a href="https://rubydoc.info/github/hotwired/turbo-rails/Turbo/Streams/Broadcasts">Turbo Stream broadcasts</a> for Rails style web frameworks — but what is interesting to me is how an idea that could be described in a page and a half the year after Star Wars came out has managed to evolve and remain relevant in such different environments.</p>

<p>It’s a testament to how strong the original idea was, but also to the people who could adapt it to their needs while keeping it basically recognizable.</p>
</div></div>
  </body>
</html>
