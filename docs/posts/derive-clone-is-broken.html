<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgbcu.be/blog/derive-broken/">Original</a>
    <h1># [derive(Clone)] Is Broken</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div><pre><code><span>use</span> std::sync::Arc;

<span>struct</span> <span>NoClone</span>;

<span>#[derive(Clone)]</span>
<span>struct</span> <span>WrapArc</span>&lt;T&gt;(Arc&lt;T&gt;);

<span>fn</span> <span>main</span>() {
  <span>let</span> <span>foo</span> = <span>WrapArc</span>(Arc::<span>new</span>(NoClone));
  <span>let</span> <span>foo_</span> = foo.<span>clone</span>();
}
</code></pre></div>
<p>Do you think this code should compile?</p>
<p>What about the following code:</p>
<div><pre><code><span>struct</span> <span>AlwaysEq</span>&lt;T&gt;(T);

<span>impl</span>&lt;T&gt; <span>PartialEq</span> <span>for</span> <span>AlwaysEq</span>&lt;T&gt; {
   <span>fn</span> <span>eq</span>(&amp;<span>self</span>, _other: &amp;<span>Self</span>) <span>-&gt;</span> <span>bool</span> {
      <span>true</span>
   }
}

<span>impl</span>&lt;T&gt; <span>Eq</span> <span>for</span> <span>AlwaysEq</span>&lt;T&gt; {}

<span>struct</span> <span>NotEq</span>;

<span>#[derive(PartialEq, Eq)]</span>
<span>struct</span> <span>WrapAlwaysEq</span>&lt;T&gt;(AlwaysEq&lt;T&gt;);

<span>fn</span> <span>assert_is_eq</span>(_: <span>impl</span> <span>Eq</span>) {}

<span>fn</span> <span>main</span>() {
   <span>let</span> <span>x</span> = <span>WrapAlwaysEq</span>(<span>AlwaysEq</span>(NotEq));
   <span>assert_is_eq</span>(x);
}
</code></pre></div>
<p>The second example is a bit far fetched, but you probably answered yes.</p>
<p>But
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=0d9a89eccb4773ce32e7a3cec5cf8603">neither</a>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=30233aea9cf20c3299cd5c1fc6e7ec8c">do</a>.</p>
<a href="#why-not"></a>
<p>The
<a href="https://github.com/rust-lang/rust/blob/0c4fa2690de945f062668acfc36b3f8cfbd013e2/compiler/rustc_builtin_macros/src/deriving/clone.rs">implementation of <code>#[derive(Clone)] in the Rust compiler</code></a>
generates a <code>Clone</code> implementation with the following requirements on the
derived type:</p>
<ul>
<li>All fields must be <code>Clone</code>.</li>
<li>All generic parameters must be <code>Clone</code>.</li>
</ul>
<p>Can you spot the issue here? It&#39;s the latter requirement: <strong>we cannot just
require all generic parameters to be <code>Clone</code>, as we cannot assume they are used
in such a way that requires them to be cloned</strong>.<sup><a id="ref:1" href="#fn:1">^1</a></sup></p>
<p>This applies to practically all builtin derive traits, such as <code>Clone</code>,
<code>PartialEq</code>, <code>Eq</code>, or
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b419e34c9f00d0fca92c40739f6c9fb2">even <code>Debug</code></a>.</p>
<a href="#what-can-we-do-to-fix-this"></a>
<p>There are two solutions to this. Both require deleting that second requirement.</p>
<a href="#the-hard-way"><h2 id="the-hard-way">The hard way</h2></a>
<p>We could create a Rust RFC, hopefully not bikeshed it to death, and get it
stabilized in the next Rust edition as it is a breaking change.<sup><a id="ref:2" href="#fn:2">^2</a></sup></p>
<p>This would take 4+ years to stabilize and be available to everyone. That sucks,
but is the correct thing to do in the long-term.</p>
<a href="#the-quick-way"><h2 id="the-quick-way">The quick way</h2></a>
<p>We can just write our own macro that generates the following code:</p>
<div><pre><code>
<span>#[derive(CustomClone)]</span>
<span>struct</span> <span>WrapArc</span>&lt;T&gt;(Arc&lt;T&gt;);


<span>impl</span>&lt;T&gt; <span>Clone</span> <span>for</span> <span>WrapArc</span>&lt;T&gt;
<span>where</span>
   Arc&lt;T&gt;: <span>Clone</span>,
   
{
   
}
</code></pre></div>
<p>This does the job correctly.</p>
<p>And it&#39;s not even hard to do. I know people who do this internally in their
company codebases - it&#39;s not much code.</p>
<p>So I&#39;ve <a href="https://github.com/JelteF/derive_more/issues/490">opened an issue</a>
about replicating the builtin derive traits in a less restrictive and thus
correct way in the <code>derive_more</code> crate&#39;s GitHub repository. The reason I chose
this crate is because it already has a lot of users and is the main place for
derive implementations.</p>
<p>Replicating already-existing behaviour of the std may not be in the scope of the
crate, which is a perfectly fine stance to take. If that doesn&#39;t get accepted,
I&#39;ll probably create my own crate and release it on
<a href="https://crates.io/">crates.io</a>.</p>
<p>Stay tuned, I&#39;ll update this blog post.</p>


  
</div></div>
  </body>
</html>
