<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://dmitry.gr/?r=05.Projects&amp;proj=34.%20springSD">Original</a>
    <h1>A minimal-part-count way to connect an SD card to a 68K</h1>
    
    <div id="readability-page-1" class="page"><div><div>




<p><span>SpringSD</span></p><h2>Table of Contents</h2>
<ol type="1"><li><a href="#_TOC_de0f1abf9bb5237cb3eac6d75f864d51">Hmm...</a></li><li><a href="#_TOC_5bdd29f9295e0d9f8418d1073a88dac2">The story so far</a><ol type="a"><li><a href="#_TOC_131a08a40cd66953a48397581b470c19">Springboard Accessories</a></li></ol></li><li><a href="#_TOC_fe297a53811cd726647017e276a42563">To make your own springboard device...</a><ol type="a"><li><a href="#_TOC_b7e0ba55c911214b9843963c1d0eb5fd">The proper way</a></li><li><a href="#_TOC_e555b9ceb0d7ac6fa68098fbf9eef58f">The cheapskate way</a></li></ol></li><li><a href="#_TOC_23222c885a808d39ac7577c6970bdcc1">A minimal SD interface</a><ol type="a"><li><a href="#_TOC_33dc5312b091968f5a120c2484d40df8">SPI</a></li></ol></li><li><a href="#_TOC_977a6e7840cf8b60e99de48ca2cf8998">Interfacing to the 68k bus</a><ol type="a"><li><a href="#_TOC_c7237e7a2765b7e0f056256449f9a15c">The first congruency</a></li><li><a href="#_TOC_3ec72eedc3cebcb50beeafffaf5976af">Chip select</a></li><li><a href="#_TOC_1571a221a50d89371048accf96cee041">Not so easy</a></li></ol></li><li><a href="#_TOC_8e64a609e66214066595e6300aaab281">Drivers</a><ol type="a"><li><a href="#_TOC_5f936d66726370eea0749c9a4d3cca5c">The basics</a></li><li><a href="#_TOC_c730389bc8d99e59c867766babdd48b5">Polish</a></li></ol></li><li><a href="#_TOC_5f12a06561716fe48aa95eaa7cec02cd">Finally</a></li><li><a href="#_TOC_7e1e75c32bc9b275daf70df8cba8efb5">Comments...</a></li></ol>







<h2>Hmm...</h2>
<p><a href="http://dmitry.gr/images/springSD_real.jpg"><img src="http://dmitry.gr/images/springSD_real_small.jpg"/></a></p><p>What is the minimal-part-count way to connect an SD card to a Handspring device? Three SOT-23 chips, as you can see in the image. Basically, an SD card wired directly to the 68k bus :)</p>

<h2>The story so far</h2>
<p>When <a href="https://en.wikipedia.org/wiki/Handspring,_Inc.">Handspring</a> released the <a href="https://the-gadgeteer.com/1999/10/05/handspring_visor_deluxe_review/">Visor</a> PDA line, the main distinguishing characteristic of it was the <a href="https://www.peachpit.com/articles/article.aspx?p=23184">Springboard slot</a>. It was an expansion mechanism via which the device could access wireless internet, make phone calls, play MP3s or radio, capture images, or export the displayed screen image to an external monitor. The springboard slot was very versatile and many accessories for it were made. Its power came from the fact that it was basically a direct connection to the main CPU&#39;s bus. The 68k CPU used in the Visor line was the MC68EZ328 for the first few devices. Later devices switched to MC68VZ328. For all practical purposes this is just the SoC version of the good[[citation needed]] old 68k.
</p>
<h3>Springboard Accessories</h3>
<p>The springboard slot exposes 24 address lines (of which the bottom is never used), 16 data lines, an interrupt request line to the host CPU, two chip select lines, the usual bus control lines (<span>nOE</span> and <span>nWE</span>), and a few other misc things, like power supply, low battery indication, ground, etc. As per the official docs, the bus is always 16-bits-wide (this can actually be configured otherwise, but not via the official API). To the host CPU the springboard device&#39;s first chip select is required to look like a x16 ROM containing a valid PalmOS <span>Card</span>. This will usually contain the applications and drivers needed to make use of the module. Some modules only contained software and thus were made of only a single x16 flash chip. The more interesting modules contained some other hardware, and thus used the second chip select to communicate with it.
</p>
<h2>To make your own springboard device...</h2>
<p><a href="http://dmitry.gr/images/springSD_diagram.png"><img src="http://dmitry.gr/images/springSD_diagram_small.png"/></a>
<a name="_TOC_b7e0ba55c911214b9843963c1d0eb5fd"></a></p><h3>The proper way</h3>
<p>Handspring published <a href="http://dmitry.gr/images/handspring_docs.zip">great many documents</a> on how to make proper a springboard device. These contain all the info one needs to create a proper springboard-compatible accessory. The main issue you&#39;d face today is the 34x2 1.27mm connector. It is similar to PCMCIA, but with different plastic keys around it. The other option is to use a connector without keys. There are such connectors available in some places, but they are becoming more and more rare. I found <a href="https://www.lcsc.com/product-detail/Female-Headers_XKB-Connectivity-X1321FV-2x34-C43D24_C2881777.html">a source</a> of them on LCSC and ordered a few dozen for all my future projects. 
</p>
<p>The second required part is the ROM to contain the driver. It is required officially, but not checked for by the device.
</p>
<h3>The cheapskate way</h3>
<p>If you are willing to be a bit of a pain for the users, however, you can skip the ROM and tell them to load the driver in another way (infra-red or pc-sync). This would violate the requirements and your module would not be approved by Handspring. Handspring no longer exists, so we can live with that. Not having the ROM onboard allows for a much simpler board and fewer parts. A win!
</p>
<h2>A minimal SD interface</h2>
<h3>SPI</h3>
<p>The SD protocol provides for a simple way to communicate with an SD card - SPI. This has been supported since long before dinosaurs roamed the earth, and there are rumors that even single-celled organisms at the dawn of time interfaced to the SD cards of yore via SPI. The SPI protocol requires four unidirectional lines. The first is <span>nCS</span> is used to select the card and tell it that upcoming communication is with it. It is normally high, and must go low for every transaction with the SD card. The second is <span>CLK</span> and is the clock for the interface. SD card protocol over SPI is explicitly byte-based (SDIO protocol is not) and so clock pulses will always come in groups of eight. The last two are <span>MOSI</span> and <span>MISO</span>. These are the data lines that, when indicated by the clock pulses, carry the data to and from the card.
</p>
<p>There are a few things about SPI that we can make use of. First is that a proper SPI slave does not care about what the <span>MISO</span>, <span>MOSI</span>, and <span>CLK</span> lines do while the <span>nCS</span> line is high. In real SPI systems this is what access to other slaves would look like. In theory, in SPI mode 0 (the only one that matters), no device should care what <span>MOSI</span> does while the clock line is not changing. That should give us more leeway about what we do with the <span>MOSI</span> line.
</p>
<h2>Interfacing to the 68k bus</h2>
<h3>The first congruency</h3>
<p><a href="http://dmitry.gr/images/springSD_accessCycles.png"><img src="http://dmitry.gr/images/springSD_accessCycles_small.png"/></a></p><p>Handspring docs (as well as the MC68k docs) explain the 68k bus cycles quite well. Here you can see both the read and the write cycles. It looks nothing like SPI. Not even a little. So what can we do? First, let&#39;s look only at read cycles. Imagine the chip select line being inverted. Suddenly you see that you can consider any address line to be <span>MOSI</span>, any data line to be <span>MISO</span>, and the inverted chip select as <span>CLK</span>. This is something we can build on.
</p>
<h3>Chip select</h3>
<p>Clearly there is no signal that we can control long term to act as <span>nCS</span> for the card. We&#39;ll need something that can hold a state until changed somehow. That&#39;s a D-latch. We can use the other chip select to trigger it, and any address line as the data input. Thus, a read access to the proper address can be used to set and reset its output. I chose <span>74LVC1G80GW</span> for this, as it is easily available in a cute SOT-23 package. (The inverter I used is also a SOT-23 - the <span>74HCT1G04GW</span>). With this we seemingly have all the building blocks we need and we&#39;re only using two tiny chips. All done, right?
</p>
<h3>Not so easy</h3>
<p><a href="http://dmitry.gr/images/springSD_schem.png"><img src="http://dmitry.gr/images/springSD_schem_small.png"/></a></p><p>I tried this design and it did not work. The issue is that our <span>MOSI</span> line will move wildly while <span>CLK</span> is stable, since we&#39;re seeing <em>all</em> the 68k bus accesses. Now, in theory, this should not matter, but in practice all the SD cards seem to care. So what can we do? Stick another latch into there, of course. And...that works... Here you can see the final schematic. 
</p>
<p>So what are the bus accesses needed? As I had mentioned, only read accesses are used, since we use data pins for output and address lines for input. Bit 17 of any access (inverted) becomes the new value for card&#39;s <span>nCS</span> pin. Bit 8 (inverted) becomes the <span>MOSI</span> that the card sees. This means that doing a read to chip select 1 address <span>0x20100</span> will set <span>MOSI</span> low and <span>nCS</span> low. A read access to any address in chip select 2 address space will clock a bit in from the card (on data line 0). Thus, we&#39;ve sent a 1 to the card and read in a bit. An access to chip select 1&#39;s offset <span>0x20000</span> will set <span>MOSI</span> high while keeping <span>nCS</span> low. This is how a zero is sent to the card. So, for every SPI bit transacted we need to do two accesses. This is not too bad speed-wise. For pure read transactions (when <span>MOSI</span> state need not change), we can read in a bit in only one access. This is quite fast.
</p>
<h2>Drivers</h2>
<h3>The basics</h3>
<p>Some Handspring devices shipped with PalmOS old enough that it would not properly support installing <span>Expansion Manager</span>. Luckily <a href="http://dmitry.gr/?r=05.Projects&amp;proj=32.%20SASD">I had resolved this problem before</a>. From there, I picked up the PalmOS patches, a FAT12/16/32 filesystem driver, and the patched <span>Expansion Manager</span>. The only thing left was to write a <span>Slot Driver</span> that accesses this hardware properly. I configure the chip selects to be 1MB in size each, starting at <span>0x28000000</span>, and the rest is as simple as promised:
</p>
<p>#define ADDR_PIN_NCS        17
#define ADDR_PIN_MOSI       8		//some asm code depends on this
#define CS_SIZE             (0x100000ul)

#define NCS_BASE            0x28000000ul
#define UNSELECTED_BASE     (NCS_BASE + (0ul &lt;&lt; ADDR_PIN_NCS))
#define SELECTED_BASE       (NCS_BASE + (1ul &lt;&lt; ADDR_PIN_NCS))
#define SELECTED_BASE_0     (SELECTED_BASE + (1ul &lt;&lt; ADDR_PIN_MOSI))
#define SELECTED_BASE_1     (SELECTED_BASE + (0ul &lt;&lt; ADDR_PIN_MOSI))
#define UNSELECTED_BASE_0   (UNSELECTED_BASE + (1ul &lt;&lt; ADDR_PIN_MOSI))
#define UNSELECTED_BASE_1   (UNSELECTED_BASE + (0ul &lt;&lt; ADDR_PIN_MOSI))
#define CLK_BASE            (NCS_BASE + CS_SIZE)

static uint8_t sdSpiByte(uint16_t val)
{
    uint_fast8_t i;

    val = ~val;
    for (i = 0; i &lt; 8; i++) {
        val &lt;&lt;= 1;
        (void)*(volatile uint16_t*)(SELECTED_BASE + (val &amp; 0x100));
        val += (1 &amp; *(volatile uint16_t*)CLK_BASE);
    }
    return val;
}

static void sdChipSelect(void)
{
    (void)*(volatile uint16_t*)SELECTED_BASE;
}

static void sdChipDeselect(void)
{
    (void)*(volatile uint16_t*)UNSELECTED_BASE_1;
}
</p>
<h3>Polish</h3>
<p><a href="http://dmitry.gr/images/springSD_render.png"><img src="http://dmitry.gr/images/springSD_render_small.png"/></a></p><p>The code above is pretty slow. But this is good since SD card init needs to be done at a clock of 400KHz or less. After init is completed, higher clock rates are allowed. This will require assembly. The situation where speed is most important is reading the data, so the most effort went into that. A few clever tricks go into this, including the fact that reading a 32-bit value from a 16-bit interface will perform two back-to-back accesses, much faster than they could be performed any other way. Additionally, <span>MOSI</span> can just stay high the entire time and needs no changes. Here is what the code looks like that will read &#34;sz&#34; bytes into a block pointed to by &#34;data&#34;, assuming that size is a multiple of two bytes and data is appropriately aligned.
</p>
<p>(void)*(volatile uint16_t*)SELECTED_BASE_1;
sz = sz / 2 - 1;
asm volatile(
    &#34;2:                     \n\t&#34;
    &#34;   moveq  #0, %2       \n\t&#34;
    &#34;.rept 8                \n\t&#34; //unrolling is faster than loop control
    &#34;   move.l (%4), %0     \n\t&#34;
    &#34;   and.l  %5, %0       \n\t&#34;
    &#34;   lsl.l  #2, %2       \n\t&#34;
    &#34;   or.l   %0, %2       \n\t&#34;
    &#34;.endr                  \n\t&#34;
    &#34;   move.w %2, %0       \n\t&#34; //lows
    &#34;   swap   %2           \n\t&#34;
    &#34;   lsl.w  #1, %2       \n\t&#34; //highs &lt;&lt; 1
    &#34;   or.w   %0, %2       \n\t&#34; //interleave
    &#34;   move.w %2, (%1)+    \n\t&#34;
    &#34;   dbra   %3, 2b       \n\t&#34;
    :&#34;=&amp;d&#34;(dummy0), &#34;+a&#34;(data), &#34;=&amp;d&#34;(dummy1), &#34;+d&#34;(sz)
    :&#34;a&#34;(CLK_BASE), &#34;d&#34;(0x00010001)
    :&#34;cc&#34;, &#34;memory&#34;
);
</p>
<p>Why do I need to mask the data with <span>0x00010001</span>? Because I do not drive the data lines other than 0. This <span>AND</span> instruction could be removed if I were to include 15 pull-down resistors on the card, but that would make it less simple, and I like simple. There is also an assembly implementation of write, but that is less interesting. You can see it in the source code archive.
</p>
<h2>Finally</h2>
<p>So, does it work? Yes, it does and the boards (which <a href="https://github.com/GeorgeRudolf">George</a> graciously designed in ten minutes) can be assembled for $3 each at <a href="https://jlcpcb.com/">JLC</a>. With my driver, any Handspring device with this $3 board can now read/write SD cards, and so can all PalmOS applications. This same cheap SD-card-interfacing method can be used for any other 68k device! All the hardware design files can be downloaded <a href="http://dmitry.gr/images/springSD_hw.zip">here</a>. The slot driver sources and binaries are <a href="http://dmitry.gr/images/springSD_sw.zip">here</a>. You&#39;ll also need the following files from the SASD page: ExpansionMgr, SlimFat, and RetroFix. The license is simple: free for all non-commercial use. For commercial use (like if you wish to sell kits of this project), <a href="mailto:licensing@dmitry.gr">contact me</a>. 
</p>



<!--- We do not show this to the user, but ToC system will index this and we'll get a link to comments in the ToC -->






					
					</div></div></div>
  </body>
</html>
