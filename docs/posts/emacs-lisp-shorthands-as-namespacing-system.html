<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreyorst.gitlab.io/posts/2022-11-01-emacs-lisp-shorthands-as-namespacing-system/">Original</a>
    <h1>Emacs Lisp shorthands as namespacing system</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>In Emacs version 28 Emacs developers introduced so-called read symbol shorthands.
If you’re interested in the rationale, feel free to search the Emacs developer mailing list for the discussion.
However, it does seem that not everyone likes the idea of shorthands as a substitution for namespaces (or packages, if you’re coming from Common Lisp).
Neither did I.
And recently, a <a href="https://lists.gnu.org/archive/html/emacs-devel/2022-10/msg01654.html" target="_blank">branch was set up</a> that implements Common Lisp-style packages for Emacs.
In the discussion Richard Stallman, however, notes:</p>
<blockquote>
<p>CL packages are the wrong way to implement packages in Lisp.
As I explained in a discussion two years ago, packages implemented using obarrays (or equivalent) don’t work reliably.</p>
<p>We have a much better basis for Lisp packages in the shorthands mechanism.
It only needs to be completed.</p>
</blockquote>

<p>I’ve read the discussion further and wanted to express some of my thoughts on the namespacing problem and how shorthands may help solve it in Emacs.</p>
<p>While I’m not entirely sure how CL packages work underneath, I more or less know how namespaces in Clojure work (and to my knowledge these namespaces/package systems are quite similar), and I think that this is how I want namespaces to work in general.
As far as I can understand, Richard Stallman doesn’t like the idea of namespaces in general - he does mention it in some subsequent emails when he talks about obarrays.
Another quote from the mailing:</p>
<blockquote>
<p>The reason namespaces systems do not fit well into Lisp is that they have to operate in ‘read’, in the choice of which symbol object you get.</p>
</blockquote>

<p>Later on same message, he mentions that Clojure is not a Lisp, but we will not go there.</p>
<p>Assuming the above, I guess <code>read-symbol-shorthands</code> are going to be the way to do namespaces in Emacs in the future.
So let’s figure out how you actually use them and what they really do.</p>
<h2 id="read-symbol-shorthands"><code>read-symbol-shorthands</code></h2>
<p>According to the Emacs manual, shorthands are symbols renamed at read-time.
Because the shorthands are read-time, we need to set them in the local variables’ section at the end of the file, which, as far as I understand, is processed before the <code>read</code> step happens.
An example from the manual:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>defun</span> <span>snu-lines</span> (<span>s</span>)
</span></span><span><span>  <span>&#34;Split string  wholeS into a list of strings on newline characters.&#34;</span>
</span></span><span><span>  (<span>snu-split</span> <span>&#34;\\(\r\n\\|[\n\r]\\)&#34;</span> <span>s</span>))
</span></span><span><span>
</span></span><span><span><span>;; Local Variables:</span>
</span></span><span><span><span>;; read-symbol-shorthands: ((&#34;snu-&#34; . &#34;some-nice-string-utils-&#34;))</span>
</span></span><span><span><span>;; End:</span>
</span></span></code></pre></div><p>When the Emacs Lisp reader reads the name <code>snu-lines</code> it will substitute the <code>snu-</code> prefix with <code>some-nice-string-utils-</code> and instead return the name <code>some-nice-string-utils-lines</code> as if it was written like this.</p>
<p>I guess this <em>kinda</em> addresses one complaint I often hear about Emacs Lisp - you always have to write full symbol names.
And in Common Lisp or Clojure, you don’t need to do that, because the package/namespace system takes care of it.
I’m not really that good with CL, but Clojure has the same approach, so I’ll use it to demonstrate:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>ns </span><span>some-nice-string-utils</span>)
</span></span><span><span>
</span></span><span><span>(<span>defn </span><span>lines</span>
</span></span><span><span>  <span>&#34;Split string `s` into a list of strings on newline characters.&#34;</span>
</span></span><span><span>  [<span>s</span>]
</span></span><span><span>  (<span>clojure.string/split-lines</span> <span>s</span>))
</span></span></code></pre></div><p><span>Code Snippet 1:</span>
  I believe in Common Lisp this would be something like <code>cl-user:split-lines</code>, if there was such a function there
</p>
<p>This code defines the function <code>lines</code> which can be used as <code>(lines &#34;foo\nbar&#34;)</code> if you’re currently in the <code>some-nice-string-utils</code> namespace.
If you’re in some other namespace, you have to use the full name: <code>(some-nice-string-utils/lines &#34;foo\nbar&#34;)</code> (after you’ve required the namespace), or provide an explicit alias.</p>
<p>So, similarly to Emacs Lisp, we can use the shortened name in the current file, but provide a less common name for the users.
And I can see how this can be seen as namespaces from Emacs standpoint, but it’s not that simple.</p>
<p>My point here is that it’s not enough for Emacs package author to use <em>some</em> prefix for their library - it would be better if it contained some author identification, so we could distinguish libraries that try to do similar things and share the name.
Instead, we get the situation where there can be only one <code>auto-complete.el</code> package, despite the fact that “auto-complete” is a very generic way.
Other packages have to come up with different names, like <code>corfu</code> or <code>company</code>, because there’s no other way to distinguish packages other than by their name.</p>
<p>So let’s have a look at how this is solved in other systems.</p>
<h2 id="namespaces-in-other-systems">Namespaces in other systems</h2>
<p>We, as programmers, live in quite big ecosystems, meaning we need ways to avoid confusion, and any programming language is one such ecosystem.
Once the popularity of a certain language grows to a certain point there is a possibility of name clashes - when someone made a function that is named exactly like yours but does an entirely different thing.
So language designers wanted to fix this problem, and a lot of languages have some notion of namespaces as a result.
I don’t really like Java, but I think it has a decent enough way of avoiding the problem of a name clash.</p>
<p>Java libraries are written as packages that belong to a certain organization or individual, which is then used in the package name.
When you’re creating a library project, Java IDE will ask you about your organization, and the default value is <code>com.company</code>.
And when I first saw this I didn’t understand why it is needed, but after some time it clicked on me.</p>
<p>Even if some other company (or individual) will create a library that is named the same as mine, it will be still possible to distinguish them.
This works because Java widely uses the <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation" target="_blank">reverse domain grouping</a> for their dependencies, and hence there’s very little possibility of a clash.
Library repositories, such as Maven then group artifacts by their group ID, which is exactly the <code>com.company</code> thing, so it’s easy to distinguish libraries.</p>
<p>So, for example, if I were to use this blog as a way to represent my identity in the Java libraries world, and I were to make the mentioned <code>some-nice-string-utils</code> library, it would be used by others as <code>io.gitlab.andreyorst.some-nice-string-utils</code>.
And if some other person wanted to make their own version of this library it could be <code>com.github.someuser.some-nice-string-utils</code>, and everybody could still use it alongside mine without name clashes.</p>
<p>This gives quite a long name to type, but the catch is that the user of the library doesn’t have to write full names, like <code>io.gitlab.andreyorst.some-nice-string-utils/lines</code>.
They can import names directly into the current scope, and just use <code>lines</code>, or define a shorthand, like <code>snu/lines</code>, in case of Clojure.</p>
<p>This still pollutes the global namespace of the runtime (kinda), it is just done in a much more controllable way, and possibilities of name clashing are minimized, and ways to recover from them are provided.
The renaming just doesn’t happen in read time, as in Emacs Lisp, but at load time, when the runtime modifies its global namespace registry to hold new namespaces.</p>
<p>There’s another approach for namespacing, which is a bit simpler and doesn’t need a global namespace for packages at all.
Here’s what a typical Lua package looks like:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> <span>function</span> <span>lines</span>(s)
</span></span><span><span>  <span>local</span> lines = {}
</span></span><span><span>  <span>for</span> line <span>in</span> s:gmatch(<span>&#34;([^</span><span>\n</span><span>]+)&#34;</span>) <span>do</span>
</span></span><span><span>    lines[#lines+1] = line
</span></span><span><span>  <span>end</span>
</span></span><span><span>  <span>return</span> lines
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>return</span> {lines=lines}
</span></span></code></pre></div><p><span>Code Snippet 2:</span>
  some-nice-string-utils.lua
</p>
<p>This file creates a function, which is only visible in this file, it doesn’t pollute the global namespace in any way.
Then at the end of the file, the table is returned, with one key <code>lines</code> set to the definition of the function <code>lines</code>.
So it is essentially a hash table object with one key representing the function name, and its value is the function object.</p>
<p>You use this library in another file by simply requiring it into another local variable:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> snu = require <span>&#34;some-nice-string-utils&#34;</span>
</span></span><span><span>print(snu.lines(<span>&#34;foo</span><span>\n</span><span>bar&#34;</span>))
</span></span></code></pre></div><p>Again, the library is imported into a local variable, because the library is essentially just a hash table object, holding closures.
Then you index this hash table like <code>snu.lines</code> which obtains the function object, which is then executed.</p>
<p>It is a really simple system, that doesn’t require anything from the language except hash tables and first-class functions.
In fact, global scope in Lua is also just a table, named <code>_G</code> - we could make it so that there’s no way to add stuff into it and the system would still work.
The beauty of it is that you can put your library file into a directory, like <code>my/snu.lua</code> and require it as <code>require(&#34;my.snu&#34;)</code>, and if someone else has the same named library it doesn’t matter, as the file system takes care of the problem already.
This comes with the overhead of the repeated table lookup, but you can always create another <code>local lines = snu.lines</code> and use <code>lines</code> without the additional lookup.
And LuaJIT actually optimizes repeated lookups away.</p>
<p>Both systems solve the problem of the name clash, just a bit differently, and programmers can build their applications without worrying about overriding some other function.
But there’s still one more problem.</p>
<h2 id="library-versioning">Library versioning</h2>
<p>Neither Emacs Lisp approach to packages, nor Java’s approach to libraries really solve one problem - version clash.
Lua’s approach kinda allows you to manually solve it, as you can manually install a library into a versioned directory, and use both versions, but it requires some manual work.
You may wonder why would you want to use two versions of the same library, and while I agree that it is strange, it’s still not uncommon, because when you depend on several libraries, they also can have dependencies, and it is possible that they depend on the same thing but of different version.</p>
<p>For example, let’s imagine that you have a project that depends on library A, and library B.
You describe it like this:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>{<span>:deps</span> {<span>com.company.A</span> {<span>:version</span> 1.1<span>.0</span>}
</span></span><span><span>        <span>io.gitlab.user.B</span> {<span>:version</span> 2022-10-01<span>-patch135</span>}}}
</span></span></code></pre></div><p>These libraries are not connected to each other in any way whatsoever, but each of them specifies its own dependencies:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>{<span>:deps</span> {<span>org.important.C</span> {<span>:version</span> 1.0<span>.0</span>}}}
</span></span></code></pre></div><p><span>Code Snippet 3:</span>
  library A dependencies
</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>{<span>:deps</span> {<span>org.important.C</span> {<span>:version</span> 2.4<span>.0</span>}}}
</span></span></code></pre></div><p><span>Code Snippet 4:</span>
  library B dependencies
</p>
<p>This creates a situation when both libraries require one library C, but the versions are incompatible.
In your project you just use A and B and don’t even know about C, so here’s the question: what version of C you’ll get in your project after you’ve built it?</p>
<p>The answer: it depends on the build system, language, alignment of the stars, and possibly other things.
Maven will likely pick the more recent version for you, other build tools may have other solutions.
Fennel, a language that compiles down to Lua, can include both dependencies, and it will work just fine without any clashes if you’ve used versioned paths in your <code>require</code> calls.</p>
<p>Clojure author Rich Hickey once said<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> that each major version of the library should just have a different artifact name, because if something broke it is a different thing now.</p>
<p>I think that there may be other ways around this, not because that proposed way isn’t useful, but because we already have a version of the artifact, it’s there, we just need a system that respects it in the actual code.
Especially since Fennel already can do it.
File systems are great at this, in fact in Maven’s case, it is possible to have multiple versions of the same library available on the file system, it’s just the fact that most languages for some reason omit the version completely, and Java is no different.</p>
<p>And Emacs’ shorthand system actually allows us to do exactly this, even with the same artifact name.
So let’s get back to Emacs’ side of things.</p>
<h2 id="shorthands-as-a-solution-to-both-name-and-version-clashing">Shorthands as a solution to both name and version clashing</h2>
<p>Let’s create a library package that will be useless, but helps demonstrate the usefulness of shorthands:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>;;; foobar.el --- Useless library -*- lexical-binding: t -*-</span>
</span></span><span><span><span>;;</span>
</span></span><span><span><span>;; Author: Andrey Listopadov</span>
</span></span><span><span><span>;; Homepage: https://gitlab.com/andreyorst/foobar.1.0.0.el</span>
</span></span><span><span><span>;; Package-Requires: ((emacs &#34;28.1&#34;))</span>
</span></span><span><span><span>;; Keywords: lisp</span>
</span></span><span><span><span>;; Prefix: foobar</span>
</span></span><span><span><span>;; Version: 1.0.0</span>
</span></span><span><span><span>;;; Commentary:</span>
</span></span><span><span><span>;; no comments</span>
</span></span><span><span><span>;;; Code:</span>
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>foobar-foo</span> ()
</span></span><span><span>  <span>&#34;...&#34;</span>
</span></span><span><span>  <span>;; ...</span>
</span></span><span><span>  )
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>foobar-bar</span> ()
</span></span><span><span>  <span>&#34;...&#34;</span>
</span></span><span><span>  <span>;; ...</span>
</span></span><span><span>  )
</span></span><span><span>
</span></span><span><span>(<span>provide</span> <span>&#39;foobar</span>)
</span></span><span><span><span>;;; foobar.el ends here</span>
</span></span><span><span>
</span></span><span><span><span>;; Local Variables:</span>
</span></span><span><span><span>;; read-symbol-shorthands: ((&#34;foobar&#34; . &#34;io.gitlab.andreyorst.foobar.1.0.0&#34;))</span>
</span></span><span><span><span>;; End:</span>
</span></span></code></pre></div><p><span>Code Snippet 5:</span>
  foobar.el
</p>
<p>We use a shorthand to transform our short package prefix into a versioned one with some author identity included.
To my knowledge, this should work absolutely fine - all <code>foobar</code> entries are replaced with the <code>io.gitlab.andreyorst.foobar.1.0.0</code>, even the at the <code>provide</code> call end of the file.
Upon loading this file, Emacs has a feature, named <code>io.gitlab.andreyorst.foobar.1.0.0</code>, and when we require it, it has two functions with the same prefix: <code>io.gitlab.andreyorst.foobar.1.0.0-foo</code> and <code>io.gitlab.andreyorst.foobar.1.0.0-bar</code>.</p>
<p>Now, let’s say we’ve introduced our breaking change, and removed the <code>foobar-bar</code> function.
What should we do?</p>
<p>We just change the shorthand to <code>io.gitlab.andreyorst.foobar.2.0.0</code>, and the version header to <code>2.0.0</code>.
That’s it, we can ship it.
How will it affect our users?</p>
<p>Let’s create two more packages that require our useless one (I’ll omit all stuff that is not necessary for this to “work” to keep it short):</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>;; Package-Requires: ((emacs &#34;28.1&#34;) (foobar &#34;1.0.0&#34;))</span>
</span></span><span><span>(<span>require</span> <span>&#39;foobar</span>) <span>; requires the &#39;io.gitlab.andreyorst.foobar.1.0.0 feature</span>
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>some-project-a-function</span> (<span>&amp;rest</span> <span>args</span>)
</span></span><span><span>  (<span>foobar-bar</span> <span>args</span>))
</span></span><span><span>
</span></span><span><span>(<span>provide</span> <span>&#39;some-project-a</span>)
</span></span><span><span><span>;; Local Variables:</span>
</span></span><span><span><span>;; read-symbol-shorthands: ((&#34;foobar&#34; . &#34;io.gitlab.andreyorst.foobar.1.0.0&#34;))</span>
</span></span><span><span><span>;; End:</span>
</span></span></code></pre></div><p><span>Code Snippet 6:</span>
  some-project-a.el
</p>
<p>The first package pulls in our <code>foobar</code> package of version <code>1.0.0</code> as a dependency and uses its <code>foobar-bar</code> function.
At the end of the file, we specify that <code>foobar-bar</code> is actually <code>io.gitlab.andreyorst.foobar.1.0.0-bar</code> and our <code>require</code> also pulls in the correct feature (if the <code>foobar.el</code> file was loaded).
Then there’s another package:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>;; Package-Requires: ((emacs &#34;28.1&#34;) (foobar &#34;2.0.0&#34;))</span>
</span></span><span><span>(<span>require</span> <span>&#39;foobar</span>) <span>; requires the &#39;io.gitlab.andreyorst.foobar.2.0.0 feature</span>
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>some-project-b-function</span> (<span>&amp;rest</span> <span>args</span>)
</span></span><span><span>  (<span>foobar-foo</span> <span>args</span>))
</span></span><span><span>
</span></span><span><span>(<span>provide</span> <span>&#39;some-project-b</span>)
</span></span><span><span><span>;; Local Variables:</span>
</span></span><span><span><span>;; read-symbol-shorthands: ((&#34;foobar&#34; . &#34;io.gitlab.andreyorst.foobar.2.0.0&#34;))</span>
</span></span><span><span><span>;; End:</span>
</span></span></code></pre></div><p><span>Code Snippet 7:</span>
  some-project-b.el
</p>
<p>Again, we pull in <code>foobar</code> as a dependency, but we use the <code>2.0.0</code> version.
As you may remember, there’s no function <code>foobar-bar</code> in this version, but there’s still <code>foobar-foo</code>, and that’s what this package uses.
And we know that it uses the correct one, because again at the end of the file, we specify that <code>foobar</code> is actually <code>io.gitlab.andreyorst.foobar.2.0.0</code>, and our <code>require</code> also pulls in the correct feature.</p>
<p>Both packages are not affected at all, because each still uses a different feature.
And both features can co-exist, without any name clashes.</p>
<p>Problem solved, right?</p>
<h2 id="problems">Problems</h2>
<p>There are, of course, some problems with this approach.</p>
<p>The first one is that we’re replacing a common prefix, that doesn’t end on a <code>-</code> symbol, so if any of the projects using our library had defined something like <code>foobarbaz</code> it may be a source of errors.
In a language with proper namespaces, defining something outside the current namespace, which is what essentially happens here, is either impossible or a compile-time error.</p>
<p>While this can be ignored in most cases, if the project uses a multi-file approach, it may cause problems that shorthands exist for one file, and it replaces <code>foobarbaz</code> with some other name <code>foobar-expanded-shorthand-baz</code>.
And if another file, that requires the previous one, doesn’t have the same shorthand, it may search for <code>foobarbaz</code> and be unable to find it.
Multi-file dependencies also have to maintain the same shorthands for all files they require internally, which can be a burden.</p>
<p>Another problem is that we have to maintain the package version in two separate places - one in the package header, and another in the shorthand.
And we <strong>have</strong> to keep the version in the shorthand, to allow several versions of the same feature to coexist.
Which is crucial in a system such as Emacs, where there are tons of old or not-maintained packages, which require older dependencies, many of which were already updated in an incompatible way, and there’s a possibility of another package requiring newer version.</p>
<p>This can lead to problems when the package is large enough not to fit on the screen, and the contributor fixes some bug in one of the functions, and updates the header, but is completely unaware that there’s a shorthand defined down below.
Tests will not be able to catch this unless things like <code>flymake</code> will learn to detect versioned shorthands.
And while this problem may seem strange to mention - we’re all people, so I can easily see it happening.</p>
<p>Yet another thing to remember is that the order of shorthands is important.
You should position more specific shorthands first, and less specific last.
For example:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>defvar</span> <span>a-foo</span> 42)
</span></span><span><span>(<span>defvar</span> <span>a-b-bar</span> 1337)
</span></span><span><span><span>;; Local Variables:</span>
</span></span><span><span><span>;; read-symbol-shorthands: ((&#34;a-&#34; . &#34;less-specific-&#34;) (&#34;a-b-&#34; . &#34;more-specific-&#34;))</span>
</span></span><span><span><span>;; End:</span>
</span></span></code></pre></div><p>In this case, both vars will transform to <code>less-specific-foo</code> and <code>less-specific-b-bar</code>.
Changing <code>read-symbol-shorthands</code> to <code>((&#34;a-b-&#34; . &#34;more-specific-&#34;) (&#34;a-&#34; . &#34;less-specific-&#34;))</code> will produce <code>less-specific-foo</code> and <code>more-specific-bar</code>.
Perhaps, Emacs could sort shorthands in such a way that more specific ones come first, but this may have unexpected effects from the user’s perspective.
With a more advanced namespace system, this won’t be an issue at all.</p>
<p>And a final problem - package managers.
Emacs’ builtin package manager <code>package.el</code> can work with this kind of system because when you install a package, it ends up in a versioned directory, e.g. <code>&lt;user-emacs-directory&gt;/elpa/&lt;package&gt;-&lt;version&gt;/package.el</code>.
So in this case, when we’re updating a such package, it will be installed with no problem, and packages that require it via shorthand will still work.</p>
<p>However, there are such package managers as <code>straight.el</code> which work by pulling packages from git repositories, and as far as I know, straight doesn’t support package versioning.
There are other package managers, like <code>borg</code>, <code>elget</code>, etc. which I’m not familiar with, maybe they support versioning, maybe not - it is a thing to be concerned about when suggesting symbol shorthands as a namespace alternative.</p>
<p>Finally, though, not really a problem, but it is still a concerning point - older Emacs releases don’t support shorthands.
If I were to adopt the scheme I’ve described above for my packages, I would have to abandon users of anything below Emacs 28.
According to the unofficial Emacs survey, in the year 2020 57% of participants used Emacs 27, and another 20% were on Emacs 26, so I imagine that there will be users who don’t have shorthands for a couple of years.</p>
<p>All of this can be fixed though.</p>
<h2 id="so-why-we-don-t-like-shorthands-again">So why we don’t like shorthands again?</h2>
<p>When I was talking about our three packages in Emacs Lisp, I had to write all names starting with a <em>unique</em> prefix that then can be distinguished by the reader.
And I believe this is the main problem here - usually, we don’t want to write the full, versioned name of the feature for each function or var, yet we want them to stay unique, and reader shorthands are a hacky way to achieve that.
The key word here is <em>hacky</em>.</p>
<p>It requires the programmer to create and manage shorthands in a special comment section instead of providing a way of doing it with regular code.
In my opinion, we could still do things read time, but give it a more general interface, instead of just the text substitution, and that is what actually leads us to CL-style packages or Clojure-like namespace systems.</p>
<p>I’m not sure if it is possible in Emacs Lisp, but if we could define a special that would affect the reader, similarly to how the <code>read-symbol-shorthands</code> setting in the local variables comment does, we could have a system pretty close to CL ones.
E.g. the reader could automatically prepend package name while reading code, especially the definitions like <code>defun</code> or <code>defvar</code>, we could have this done automatically without any prefixes.
And when reading a free symbol<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, automatically intern it in the current package, by prepending a package name while reading its name:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>package</span> <span>&#39;io.gitlab.andreyorst.foobar.3.0.0</span>) <span>; configure reader at the top of the file</span>
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>lines</span> ()          <span>; reads (defun io.gitlab.andreyorst.foobar.3.0.0:lines ...)</span>
</span></span><span><span>  <span>;; ...</span>
</span></span><span><span>  )
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>some-other-fn</span> (<span>s</span>) <span>; reads</span>
</span></span><span><span>                         <span>; (defun io.gitlab.andreyorst.foobar.3.0.0:some-other-fn ...)</span>
</span></span><span><span>  (<span>list</span> 1 2 3)           <span>; reads (emacs.28.c-core:list 1 2 3)</span>
</span></span><span><span>                         <span>; because there was no definition of the list</span>
</span></span><span><span>                         <span>; in this package, and no prefix is used</span>
</span></span><span><span>
</span></span><span><span>  (<span>lines</span> <span>s</span>)              <span>; reads</span>
</span></span><span><span>                         <span>; (io.gitlab.andreyorst.foobar.3.0.0:lines s)</span>
</span></span><span><span>                         <span>; because its already interned</span>
</span></span><span><span>  <span>;; ...</span>
</span></span><span><span>  )
</span></span></code></pre></div><p>And when the library requires such a package, we could again set up the reader with a special syntax to do the shorthands stuff:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require-package</span> &#39;(<span>io.gitlab.andreyorst.foobar.3.0.0</span> <span>:as</span> <span>fb</span>))
</span></span><span><span>
</span></span><span><span>(<span>fb:lines</span> <span>&#34;...&#34;</span>)  <span>; reads (io.gitlab.andreyorst.foobar.3.0.0:lines &#34;...&#34;)</span>
</span></span><span><span>                  <span>; because of the configured prefix alias</span>
</span></span></code></pre></div><p>Where require-package is another special, that sets up shorthands for the reader, and expands to actual <code>require</code> call.</p>
<p>This is just a quick draft of what it could have looked like if instead of a comment we could deal with a new small set of specials that did the setup for us based on what we actually require or provide.
Again, Richard Stallman considers the Common Lisp style package system broken, maybe the automatic interning is one of the unknown symbols one of the reasons, I don’t know, but this is still pretty much the same implementation as with the shorthands.
It is just more automated.</p>
<h2 id="alternatives">Alternatives</h2>
<p>In the already mentioned <a href="https://www.youtube.com/watch?v=oyLBGkS5ICk" target="_blank">Spec-ulation Keynote</a> talk, Rich Hickey gave, he mentions that actual dependencies are not artifacts but <a href="https://www.youtube.com/watch?v=oyLBGkS5ICk&amp;t=646s" target="_blank">the code itself</a>.
Names, if you will.
If a function <code>A/foo</code> only needs <code>B/bar</code> function, and in our project, we only use the function <code>A/foo</code>, our dependencies are not <code>A</code> and <code>B</code>, our dependencies are <code>A/foo</code> and <code>B/foo</code>.
It’s just the fact that our packaging systems require us to pull all code from the library, not just definitions.
Of course, there are languages that do tree shaking, excluding unused code from the final application build, but this doesn’t affect our dependencies - we still pull libraries as a whole.</p>
<p>There’s an interesting language, called <a href="https://www.unison-lang.org/" target="_blank">Unison</a>.
It is quite different from other languages because they implemented the idea of code-level dependencies:</p>
<blockquote>
<p>Here’s the big idea behind Unison, which we’ll explain along with some of its benefits:</p>
<p><em>Each Unison definition is identified by <strong>a hash of its syntax tree</strong>.
Put another way, Unison code is content-addressed.</em></p>
</blockquote>
<p>This essentially means that each definition has a unique ID, so if you depend on some definition you can refer to its hash to obtain the exact thing you’re dependent on.
It also means that there’s no need for namespaces at all.
If you have written a definition that does one thing, it will have a unique hash, which the rest of the world will use to refer to your definition - it will never collide.
You can give it an appropriate and descriptive name in <strong>your</strong> program, but this name will never affect other people’s code.</p>
<p>Emacs is way beyond the point where such a system could be introduced, but I think it is still worth mentioning it.</p>
<h2 id="can-shorthands-be-used-as-a-namespacing-system">Can shorthands be used as a namespacing system?</h2>
<p>So this is the main question I wanted to answer here.</p>
<p>I think yes, symbol shorthands can be used for namespacing, and if used properly, they can also solve versioning problems, at least to some degree.
However, this is really a poor man’s namespacing system, as in reality, it’s just a text substitution, and we’re still acting in one giant global namespace, it’s just the fact that the name clash is made harder.</p>
<p>A key point of namespacing systems is to be able to reuse the same name across different namespaces, and that’s what shorthands in their current form don’t provide at all.
Using a short enough prefix is a workaround, though.</p>
<p>As much as I would like to have a better system, I guess I’ll have to stick to what Emacs developers decide to use in the future.
Richard Stallman mentions that “It only needs to be completed”, so I guess we will see the improvements in the future.
But again, it may actually delay the ability to actually use these namespaces for another few years from that point.</p>


  </article></div>
  </body>
</html>
