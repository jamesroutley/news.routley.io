<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/">Original</a>
    <h1>GPU Caching Compared Among AMD, Intel UHD, Apple M1</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Like CPUs, modern GPUs have evolved to use complex, multi level cache hierarchies. Integrated GPUs are no exception. In fact, they’re a special case because they share a memory bus with CPU cores. The iGPU has to contend with CPUs for limited memory bandwidth, making caching even more important than with dedicated GPUs. </p>
<p>At the same time, the integrated nature of integrated GPUs provides a lot of interesting cache design options. We’re going to take a look at paths taken by AMD, Intel, and Apple.</p>
<h2>Global Memory Latency</h2>
<p>GPUs are given a lot of explicit parallelism, so memory latency isn’t as critical as it is for CPUs. Still, latency can play a role. GPUs often don’t run at full occupancy – that is, the amount of parallel work they’re tracking isn’t maximized. We have more on that <a href="https://chipsandcheese.com/2021/05/13/gpu-memory-latencys-impact-and-updated-test/">in another article</a>, so we’ll go right to the data.</p>
<p>Testing latency is also a good way of probing the cache setup. Doing so with bandwidth isn’t as straightforward because requests can be combined at various levels in the memory hierarchy, and defeating that to get clean breaks between cache levels can be surprisingly difficult.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7204"><img data-attachment-id="7204" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/igpu_latency-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?fit=1148%2C613&amp;ssl=1" data-orig-size="1148,613" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="igpu_latency-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?fit=1148%2C613&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?fit=688%2C367&amp;ssl=1" decoding="async" width="688" height="367" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?resize=688%2C367&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?w=1148&amp;ssl=1 1148w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?resize=768%2C410&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/igpu_latency-1.png?resize=688%2C367&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>The Ryzen 4800H’s cache hierarchy is exactly what you’d expect from AMD’s well known GCN graphics architecture. Each of the 4800H’s seven GCN-based CUs have a fast 16 KB L1 cache. Then, a larger 1 MB L2 is shared by all of the CUs. AMD’s strategy for dealing with memory bus constraints appears quite simple: use a higher L2 capacity to compute ratio than that of discrete GPUs. A fully enabled Renoir iGPU has 8 CUs, giving 128 KB per CU. Contrast this with AMD’s Vega 64, where 4 MB of L2 gives it 64 KB per CU.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7224"><img data-attachment-id="7224" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/gcn_latency-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?fit=1149%2C617&amp;ssl=1" data-orig-size="1149,617" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="gcn_latency-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?fit=1149%2C617&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?fit=688%2C369&amp;ssl=1" decoding="async" width="688" height="369" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?resize=688%2C369&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?w=1149&amp;ssl=1 1149w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?resize=768%2C412&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/gcn_latency-1.png?resize=688%2C369&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>GCN’s simple, two-level cache hierarchy with a 16 KB L1 is instantly recognizable across generations and form factors. Thanks to cha0s for contributing data</figcaption></figure></div>
<p>Apple’s cache setup is similar, with a fast L1 followed by a large 1 MB L2. Apple’s L1 is half of AMD’s size at 8 KB, but has similar latency. This low latency suggests it’s placed within iGPU cores, though we don’t have a test to directly verify this. Compared to AMD, Apple’s L2 is a bit lower latency, which should help make up for the smaller L1. We also expect to see a 8 MB SLC, but that doesn’t really show up in the latency test. It could be the somewhat lower latency area up to 32 MB.</p>
<p>Then, we have Intel. Compared to AMD and Apple, Intel tends to use a less conventional cache setup. Right off the bat, we’re hitting a large cache shared by all of the GPU’s cores. It’s at least 1.5 MB in size, making it bigger than AMD and Apple’s GPU-level caches. In terms of latency, it’s somewhere between AMD and Apple’s L2 caches. That’s not particularly good, because we don’t see a smaller, faster cache in front of it. But its large size should help Intel keep more memory traffic within the iGPU block. Intel should have <a href="https://www.realworldtech.com/ivy-bridge-gpu/6/">smaller, presumably faster caches</a> in front of the large shared iGPU-level cache. But we weren’t able to see them through testing.</p>
<p>Like Apple, Intel has a large, shared chip-level cache that’s very hard to spot on a latency plot. This is strange – our latency test clearly shows the shared L3 on prior generations of Intel integrated graphics.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7120"><img data-attachment-id="7120" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/intel_ocl_latency-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?fit=1140%2C619&amp;ssl=1" data-orig-size="1140,619" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="intel_ocl_latency-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?fit=1140%2C619&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?fit=688%2C374&amp;ssl=1" decoding="async" width="688" height="374" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?resize=688%2C374&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?w=1140&amp;ssl=1 1140w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?resize=768%2C417&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/intel_ocl_latency-1.png?resize=688%2C374&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Looks like the shared chip-level L3 doesn’t help latency much in certain Intel iGPU designs</figcaption></figure></div>
<p>From this first glance at latency, we can already get a good idea of how each manufacturer approaches caching. Let’s move on to bandwidth now.</p>
<h2>Global Memory Bandwidth</h2>
<p>Bandwidth is more important to GPUs than to CPUs. Usually, CPUs only see high bandwidth usage in heavily vectorized workloads. For GPUs though, all workloads are vectorized by nature. And bandwidth limitations can show up even when cache hitrates are high.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7128"><img data-attachment-id="7128" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/image-3-13/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?fit=1066%2C543&amp;ssl=1" data-orig-size="1066,543" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?fit=1066%2C543&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?fit=688%2C350&amp;ssl=1" decoding="async" width="688" height="350" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?resize=688%2C350&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?w=1066&amp;ssl=1 1066w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?resize=768%2C391&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-3.png?resize=688%2C350&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>AMD and Apple’s iGPU private caches have roughly comparable bandwidth. Intel’s is much lower. Part of that is because Alder Lake’s integrated graphics have somewhat different goals. Comparing the GPU configurations makes this quite obvious:</p>
<figure><table><tbody><tr><td></td><td>FP32 ALUs</td><td>Clock Speed</td><td>FP32 FMA Vector Throughput</td></tr><tr><td>AMD Ryzen 4800H, Vega 7</td><td>448 (out of 512 possible)</td><td>1.6 GHz</td><td>1433.6 GFLOPs</td></tr><tr><td>Intel Core i5-12600K, Xe GT1</td><td>256</td><td>1.45 GHz</td><td>742.4 GFLOPs</td></tr><tr><td>Apple M1, 7 Core iGPU</td><td>896 (out of 1024 possible)</td><td><a href="https://www.anandtech.com/show/17024/apple-m1-max-performance-review/6">1.278 GHz?</a></td><td>2290.2 GFLOPs</td></tr></tbody></table></figure>
<p>AMD’s Renoir and Apple’s M1 are designed to provide low end gaming capability to thin and light laptops, where a separate GPU can be hard to fit. But desktop Alder Lake definitely expects to be paired with a discrete GPU for gaming. Understandably, that means Intel’s iGPU is pretty far down on on the priority list when it comes to power and die area allocation. Smaller iGPUs will have less cache bandwidth, so let’s try to level out the comparison by using vector FP32 throughput to normalize for GPU size.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7141"><img data-attachment-id="7141" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/image-4-14/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?fit=942%2C459&amp;ssl=1" data-orig-size="942,459" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?fit=942%2C459&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?fit=688%2C335&amp;ssl=1" decoding="async" width="688" height="335" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?resize=688%2C335&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?w=942&amp;ssl=1 942w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?resize=768%2C374&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-4.png?resize=688%2C335&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Measured bandwidth values are used. If a cache level isn’t present, the next one down is used. GTX 1070 Max-Q was tested with Vulkan, because the L1 is not used for OpenCL. Intel shows no faster cache level even with Vulkan</figcaption></figure></div>
<p>Intel’s cache bandwidth now looks better, at least if we compare from L2 onward. Bytes per FLOP is roughly comparable to that of other iGPUs. Its shared chip-level L3 also looks excellent, mostly because its bandwidth is over-provisioned for such a small GPU.</p>
<p>As far as caches are concerned, AMD is the star of the show. Renoir’s Vega iGPU enjoys higher cache bandwidth to compute ratios than Intel or Apple. But its performance will likely be dependent on cache hitrate. L2 misses go directly to memory, because AMD doesn’t have another cache behind it. And Renoir has the weakest memory setup of all the iGPUs here. DDR4 may be flexible and economical, but it’s not winning any bandwidth contests. Apple and Intel both have a stronger memory setup, augmented by a big on-chip cache. </p>
<h2>Local Memory Latency</h2>
<p>GPU memory access is more complicated than on CPUs, where programs access a single pool of memory. On GPUs, there’s global memory that works like CPU memory. There’s constant memory, which is read only. And there’s local memory, which acts as a fast scratchpad shared by a small group of threads. Everyone has a different name for this scratchpad memory. Intel calls it SLM (Shared Local Memory), Nvidia calls it Shared Memory, and AMD calls it LDS (Local Data Share). Apple calls it Tile Memory. To keep things simple, we’re going to use OpenCL terminology, and just call it local memory.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=7146"><img data-attachment-id="7146" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/image-5-13/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-5.png?fit=668%2C449&amp;ssl=1" data-orig-size="668,449" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-5" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-5.png?fit=668%2C449&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-5.png?fit=668%2C449&amp;ssl=1" decoding="async" width="668" height="449" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-5.png?resize=668%2C449&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-5.png?resize=668%2C449&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Pointer chasing latency with local memory</figcaption></figure></div>
<p>AMD and Apple take about as long to access local memory as they do to hit their first level caches. Of course, latency isn’t the whole story here. Each of AMD’s GCN CUs has 64 KB of LDS – four times the capacity of its L1D cache. Bandwidth from local memory is likely higher too, though we currently don’t have a test for that. Clinfo on M1 shows 32 KB of local memory, so M1 has at least that much available. That figure likely only indicates the maximum local memory allocation by a group of threads, so the hardware value could be higher.</p>
<p>Intel meanwhile enjoys very fast access to local memory, as does Nvidia, which is here for perspective. Their story is an interesting one too. Prior to Gen10, Intel put their SLM along the iGPU’s L3, outside the the subslices (Intel’s cloest equivalent to GPU cores on Apple and CUs on AMD). For a long time, that meant Intel iGPUs had unimpressive local memory latency.</p>
<div>
<figure><img data-attachment-id="7149" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/image-6-14/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-6.png?fit=667%2C324&amp;ssl=1" data-orig-size="667,324" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-6" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-6.png?fit=667%2C324&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-6.png?fit=667%2C324&amp;ssl=1" decoding="async" width="667" height="324" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-6.png?resize=667%2C324&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-6.png?resize=667%2C324&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Good job Intel</figcaption></figure></div>
<p>Starting with Gen 11, Intel thankfully moved the SLM into the subslice, making the local memory configuration similar to AMD and Nvidia’s. Apple likely does the same (putting “tile memory” within iGPU cores) since local memory latency on Apple’s iGPU is also quite low. </p>
<h2>CPU to GPU Copy Bandwidth</h2>
<p>A shared, chip-level cache can bring other benefits. In theory, transfers between CPU and GPU memory spaces can go through the shared cache, basically providing a very high bandwidth link between the CPU and GPU. Due to time and resource constraints, slightly different devices are tested here. But Renoir and Cezanne should be similar, and Intel’s behavior is unlikely to regress from Skylake’s.</p>
<figure><img data-attachment-id="7259" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/image-8-13/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?fit=938%2C458&amp;ssl=1" data-orig-size="938,458" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-8" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?fit=938%2C458&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?fit=688%2C336&amp;ssl=1" decoding="async" width="688" height="336" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?resize=688%2C336&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?w=938&amp;ssl=1 938w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?resize=768%2C375&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/image-8.png?resize=688%2C336&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>
<p>Only Intel is able to take advantage of the shared cache to accelerate data movement across different blocks. As long as buffer sizes fit in L3, Skylake handles copies completely within the chip, with performance counters showing very little memory traffic. Larger copies are still limited by memory bandwidth. The Core i7-7700K tested here only has a dual channel DDR4-2400 setup, so that’s not exactly a strong point. </p>
<p>Apple in theory should be able to do the same. However, we don’t see an improvement for small copy sizes that should fit within M1’s system level cache. There are a couple of explanations. One is that M1 is unable to keep CPU to GPU transfers on-die. Another is that small transfers are kept on-die, but commands to the GPU suffer from very high latency, resulting in poor performance for small copies. Intel’s Haswell iGPU suffers from the same issue, so the second is a very likely explanation. When we get to larger copy sizes, M1’s high bandwidth LPDDR4X setup does a very good job.</p>
<p>AMD’s performance is very easy to understand. There’s no shared cache, so bandwidth between the CPU and GPU is limited by memory bandwidth. </p>
<p>Finally, it’s worth noting that all of the iGPUs here, as well as modern dedicated GPUs, can theoretically do zero-copy transfers by mapping the appropriate memory on both the CPU and GPU. But we currently don’t have a test written to analyze transfer speeds with mapped memory.</p>
<h2>Final Words</h2>
<p>GPUs tend to be memory bandwidth guzzlers, and feeding an integrated GPU is particularly challenging. Their memory subsystems are typically not as beefy as those of dedicated GPUs. To make matters worse, the iGPU has to fight with the CPU for memory bandwidth. </p>
<p>Apple and Intel both tackle this challenge with sophisticated cache hierarchies, including a large on-chip cache that serves the CPU and GPU. The two companies take different approaches to implementing that cache, based on how they’ve evolved their designs. Intel has the most integrated solution. Its L3 cache does double duty. It’s tied very closely to the CPU cores on a high speed ring interconnect, in order to provide low latency for CPU-side accesses. The iGPU is simply another agent on the ring bus, and L3 slices handle iGPU and CPU core requests in the same way.</p>
<div>
<figure><img data-attachment-id="7163" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/adl/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?fit=603%2C263&amp;ssl=1" data-orig-size="603,263" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="adl" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?fit=603%2C263&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?fit=603%2C263&amp;ssl=1" decoding="async" width="603" height="263" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?resize=603%2C263&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?w=603&amp;ssl=1 603w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?resize=600%2C263&amp;ssl=1 600w" data-lazy-sizes="(max-width: 603px) 100vw, 603px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/adl.png?resize=603%2C263&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Intel has a fast, flexible ring bus that can connect a variety of agents. The iGPU is simply another agent on the ring bus</figcaption></figure></div>
<p>Apple uses more specialized caches instead of trying to optimize one cache for both the CPU and GPU. M1 implements a 12 MB L2 cache within the Firestorm CPU cluster, which fills a similar role to Intel’s L3 from the CPU’s perspective. A separate 8 MB system level cache helps reduce DRAM bandwidth demands from all blocks on the chip, and acts as a last stop before hitting the memory controller. By dividing up responsibilities, Apple can tightly optimize the 12 MB L2 for low latency to the CPU cores. Because the L2 is large enough to absorb the bulk of CPU-side requests, the system level cache’s latency can be higher in order to save power.</p>
<p>M1 still has a bit of room for improvement. Its cache bandwidth to compute ratio could be a touch higher. Transfers between the CPU and GPU could take full advantage of the system level cache to improve bandwidth. But these are pretty minor complaints, and overall Apple has a pretty solid setup.</p>
<div>
<figure><img data-attachment-id="7292" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/m1cache/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/m1cache.png?fit=533%2C285&amp;ssl=1" data-orig-size="533,285" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="m1cache" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/m1cache.png?fit=533%2C285&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/m1cache.png?fit=533%2C285&amp;ssl=1" decoding="async" width="533" height="285" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/m1cache.png?resize=533%2C285&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/m1cache.png?resize=533%2C285&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Apple has a slower, SoC-wide interconnect and a variety of blocks on it. Only the Firestorm cluster and GPU are drawn to save space</figcaption></figure></div>
<p>AMD’s caching setup is bare-bones in comparison. Renoir (and Cezanne) are basically a CPU and GPU glued together. Extra GPU-side L2 is the only concession made to reduce memory bandwidth requirements. And “extra” here only applies in comparison to discrete GCN cards. 1 MB of L2 isn’t anything special next to Apple and Intel, both of which have 1 MB or larger caches within their iGPUs. If the L2 is missed, AMD goes straight to memory. Memory bandwidth isn’t exactly AMD’s strong point, making Renoir’s lack of cache even worse. Renoir’s CPU-side setup isn’t helping matters either. A L3 setup that’s only 1/4 the size of desktop Zen 2’s will lead to additional memory traffic from CPU cores, putting even more pressure on the memory controller. </p>
<div>
<figure><img data-attachment-id="7180" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/renoir/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?fit=821%2C323&amp;ssl=1" data-orig-size="821,323" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="renoir" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?fit=821%2C323&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?fit=688%2C271&amp;ssl=1" decoding="async" width="688" height="271" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?resize=688%2C271&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?w=821&amp;ssl=1 821w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?resize=768%2C302&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/renoir.png?resize=688%2C271&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Cezanne has a pretty similar layout, but with Zen 3 cores in a single core complex</figcaption></figure></div>
<p>AMD’s APU caching setup leaves a lot to be desired. Somehow, AMD’s iGPU <a href="https://www.techspot.com/review/2158-intel-tiger-lake-core-i7-1165g7/">still manages to be competitive against Intel’s Tiger Lake iGPU</a>, which speaks to the strength of their GCN graphics architecture. I just wish they took advantage of that potential to deliver a killer APU. After all, AMD has a lot of low hanging fruit to improve with. RDNA 2 based discrete GPUs use a large “Infinity Cache” sitting behind Infinity Fabric to reduce memory bandwidth requirements. Experience gained implementing that cache could trickle down to AMD’s integrated GPUs. </p>
<figure><img data-attachment-id="7264" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/rdna2_ga102_latency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?fit=1057%2C540&amp;ssl=1" data-orig-size="1057,540" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_ga102_latency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?fit=1057%2C540&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?fit=688%2C351&amp;ssl=1" decoding="async" width="688" height="351" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?resize=688%2C351&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?w=1057&amp;ssl=1 1057w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?resize=768%2C392&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/rdna2_ga102_latency.jpg?resize=688%2C351&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>AMD’s RDNA2 uses a giant 128 MB Infinity Cache to compete with Nvidia while having a lot less memory bandwidth</figcaption></figure>
<p>It’s easy to imagine an Infinity Cache delivering benefits beyond reducing GPU memory bandwidth requirements too. For example, the cache could enable faster copies between GPU and CPU memory. And it could benefit CPU performance, especially since AMD likes to give their APUs less CPU-side L3 compared to desktop chips.</p>
<p>But such a move is unlikely with in the next generation or two. With AMD moving to LP/DDR5, the bandwidth boost along with large architecture changes allowed AMD to double iGPU performance with Rembrandt. Factor in Renoir and Cezanne’s already adequate graphics performance, Intel’s inability to capitalize on their superior cache setup, and Apple’s closed ecosystem, there’s little pressure on AMD to make aggressive moves. </p>
<p>Infinity cache on an APU will also require significant die area to be effective. Hitrate with a 8 MB system level cache is abysmal:</p>
<div>
<figure><img data-attachment-id="7283" data-permalink="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/arm_corelink_slc/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?fit=1369%2C768&amp;ssl=1" data-orig-size="1369,768" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="arm_corelink_slc" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?fit=1369%2C768&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?fit=688%2C386&amp;ssl=1" decoding="async" width="688" height="386" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?resize=688%2C386&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?w=1369&amp;ssl=1 1369w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?resize=768%2C431&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?resize=1200%2C673&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?resize=1320%2C741&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/05/arm_corelink_slc.jpg?resize=688%2C386&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>28% bandwidth reduction implies a 28% hitrate. Source – <a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/new-arm-interconnect">ARM</a></figcaption></figure></div>
<p>Cache hitrate tends to increase with the logarithm of size, so AMD would probably want to start with at least 32 MB of cache to make it worth the effort. That means a bigger die, and unfortunately, I’m not sure if there’s a market for a powerful APU in the consumer x86 realm.</p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<h2>Test Setup</h2>
<figure><table><tbody><tr><td></td><td>Memory Setup</td><td>Notes</td></tr><tr><td>AMD Ryzen 4800H (Renoir)</td><td>Dual channel DDR4-3200 22-22-22-52</td><td>Eluktronics RP-15 laptop</td></tr><tr><td>Intel Core i5-12600K (Alder Lake)</td><td>2x DDR5-4800 CL40</td><td>Thanks to Luma for running the tests</td></tr><tr><td>Apple M1</td><td>On-package LPDDR4X</td><td>Macbook Air with 7 core GPU, thanks to Longhorn for running tests</td></tr></tbody></table></figure>
<div>

<ul>
<li>
<p><img alt="clamchowder" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" decoding="async" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
</p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
