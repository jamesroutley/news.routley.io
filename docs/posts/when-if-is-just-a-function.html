<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ryelang.org/blog/posts/if-as-function-blogpost-working-on-it_ver1/">Original</a>
    <h1>When if is just a function</h1>
    
    <div id="readability-page-1" class="page"><div><p>In Python, when you write <code>if x &gt; 5: print(&#34;big&#34;)</code>, you’re using special syntax baked into the language. You can’t change how <code>if</code> works. You can’t compose it, pipe it, or partially apply it. You can’t pass <code>if</code> as an argument to another function.</p>
<p>But what if you could? What if <code>if</code>, <code>for</code>, <code>while</code> and even <code>fn</code> and <code>var</code> were just regular functions?</p>
<p>In languages like REBOL, Red and Rye they are.</p>
<h2 id="three-reasons-this-matters">Three Reasons This Matters</h2>
<p><strong>Consistency.</strong> Most languages treat control structures as special forms, exceptions to the normal rules. In languages like Rye and REBOL, they’re ordinary functions that follow the same patterns as everything else.</p>
<p><strong>Flexibility.</strong> Functions can be composed, passed around, and combined. When control structures are functions, you inherit all those capabilities.</p>
<p><strong>Extensibility.</strong> If <code>if</code> and <code>for</code> are just functions, you can create your own specialized versions for specific purposes. No part of the language remains off-limits.</p>
<p>Let’s see what this looks like in practice.</p>
<h2 id="looking-at-if">Looking at If</h2>
<p>Here’s a conditional in Python:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>temperature</span> <span>=</span> <span>36</span>
</span></span><span><span>
</span></span><span><span><span># We can evaluate and print an expression</span>
</span></span><span><span><span>print</span><span>(</span><span>temperature</span> <span>&gt;</span> <span>30</span><span>)</span>
</span></span><span><span><span># prints: True</span>
</span></span><span><span>
</span></span><span><span><span># We can&#39;t really print or evaluate a block of code</span>
</span></span><span><span><span># except if we turn it back to string</span>
</span></span><span><span>
</span></span><span><span><span># Standard conditional - special syntax</span>
</span></span><span><span><span>if</span> <span>temperature</span> <span>&gt;</span> <span>30</span><span>:</span>
</span></span><span><span>    <span>print</span><span>(</span><span>&#34;It&#39;s hot!&#34;</span><span>)</span>
</span></span><span><span><span># prints: It&#39;s hot!</span>
</span></span></code></pre></div><p>Compare this to Rye:</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>temperature:</span> <span>36</span>
</span></span><span><span>
</span></span><span><span><span>; Evaluates expression and prints the result</span>
</span></span><span><span><span>print</span> <span>temperature</span> <span>&gt;</span> <span>30</span>
</span></span><span><span><span>; prints: true</span>
</span></span><span><span>
</span></span><span><span><span>; In Rye, blocks are data - we can print them</span>
</span></span><span><span><span>print</span> <span>{</span> <span>print</span> <span>&#34;It&#39;s hot!&#34;</span> <span>}</span>
</span></span><span><span><span>; prints: print &#34;It&#39;s hot!&#34;</span>
</span></span><span><span>
</span></span><span><span><span>; The &#39;do&#39; function evaluates a block of Rye values / code</span>
</span></span><span><span><span>do</span> <span>{</span> <span>print</span> <span>&#34;It&#39;s hot!&#34;</span> <span>}</span>
</span></span><span><span><span>; prints: It&#39;s hot!</span>
</span></span><span><span>
</span></span><span><span><span>; And here&#39;s the conditional - also just a function</span>
</span></span><span><span><span>if</span> <span>temperature</span> <span>&gt;</span> <span>30</span> <span>{</span>
</span></span><span><span>    <span>print</span> <span>&#34;It&#39;s hot!&#34;</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>; prints: It&#39;s hot!</span>
</span></span></code></pre></div><p>Look at that last <code>if</code> statement. It’s not special syntax it’s a function call. While functions <code>print</code> and <code>do</code> take one argument, <code>if</code> function takes two arguments:</p>
<ol>
<li>A condition that evaluates to true or false</li>
<li>A block of code to run if the condition is true</li>
</ol>
<p>You might wonder: “Won’t the block execute immediately when passed as an argument?” Here’s the key insight: in Rye, code blocks <code>{ ... }</code> are values. They don’t evaluate until you explicitly tell them to. The <code>if</code> function receives the block as data and decides whether to evaluate it based on the condition.</p>
<p>When code is data, control flow doesn’t need to be special.</p>
<h2 id="single-pattern">Single pattern</h2>
<p>In Python, every language feature has its own syntax:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Conditionals - keywords and colons</span>
</span></span><span><span><span>if</span> <span>x</span> <span>==</span> <span>5</span><span>:</span> 
</span></span><span><span>    <span>print</span><span>(</span><span>&#34;five&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># Loop</span>
</span></span><span><span><span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span> 
</span></span><span><span>    <span>print</span><span>(</span><span>i</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># Iteration</span>
</span></span><span><span><span>for</span> <span>item</span> <span>in</span> <span>[</span><span>&#34;milk&#34;</span><span>,</span> <span>&#34;bread&#34;</span><span>,</span> <span>&#34;pickles&#34;</span><span>]:</span> 
</span></span><span><span>    <span>print</span><span>(</span><span>item</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># Functions - def keyword, parentheses, colons, indentation</span>
</span></span><span><span><span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span> 
</span></span><span><span>    <span>return</span> <span>a</span> <span>+</span> <span>b</span>
</span></span></code></pre></div><p>In Rye, one pattern applies everywhere:</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>; Conditionals - function taking a boolean and a block</span>
</span></span><span><span><span>if</span> <span>x</span> <span>=</span> <span>5</span> <span>{</span> <span>print</span> <span>&#34;five&#34;</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>; Counting loop - function taking an integer and a block</span>
</span></span><span><span><span>loop</span> <span>10</span> <span>{</span> <span>.</span><span>print</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>; Iteration - function taking a collection and a block</span>
</span></span><span><span><span>for</span> <span>{</span> <span>&#34;milk&#34;</span> <span>&#34;bread&#34;</span> <span>&#34;pickles&#34;</span> <span>}</span> <span>{</span> <span>.</span><span>print</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>; Functions - function taking argument list and body block</span>
</span></span><span><span><span>add:</span> <span>fn</span> <span>{</span> <span>a</span> <span>b</span> <span>}</span> <span>{</span> <span>a</span> <span>+</span> <span>b</span> <span>}</span>
</span></span></code></pre></div><p>Every construct follows the same shape: a name, followed by arguments, some of which happen to be blocks of code.</p>
<p>There’s no longer a meaningful distinction between “language features” and “library functions.”</p>
<h2 id="consistency--flexibility">Consistency &amp; Flexibility</h2>
<p>In Python, <code>if</code> and <code>for</code> are statements, not values. But in Rye they are functions, and first of all we can compose functions.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>loop</span> <span>either</span> <span>temperature</span> <span>&gt;</span> <span>32</span> <span>{</span> <span>3</span> <span>}</span> <span>{</span> <span>1</span> <span>}</span> <span>{</span> <span>prns</span> <span>&#34;Hot!&#34;</span> <span>}</span>
</span></span><span><span><span>; Prints: Hot! Hot! Hot!</span>
</span></span><span><span>
</span></span><span><span><span>; We can use optional parenthesis to better show the evaluation order (similar to lisp-s)</span>
</span></span><span><span><span>(</span> <span>loop</span> <span>(</span> <span>either</span> <span>(</span> <span>temperature</span> <span>&gt;</span> <span>32</span> <span>)</span> <span>{</span> <span>3</span> <span>}</span> <span>{</span> <span>1</span> <span>}</span> <span>)</span> <span>{</span> <span>prns</span> <span>&#34;Hot!&#34;</span> <span>}</span> <span>)</span>
</span></span><span><span><span>; Prints: Hot! Hot! Hot!</span>
</span></span></code></pre></div><blockquote>
<p>prns prints a value with a space (no newline)</p>
</blockquote>
<p>In Python when using the <code>if</code> statement, this would take multiple lines and a variable mutation:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>repeats</span> <span>=</span> <span>1</span>
</span></span><span><span><span>if</span> <span>temperature</span> <span>&gt;</span> <span>32</span><span>:</span>
</span></span><span><span>    <span>repeats</span> <span>=</span> <span>3</span>
</span></span><span><span>
</span></span><span><span><span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>repeats</span><span>):</span>
</span></span><span><span>    <span>print</span><span>(</span><span>&#34;Hot!&#34;</span><span>,</span> <span>end</span><span>=</span><span>&#39;&#39;</span><span>)</span>
</span></span><span><span><span># Prints: Hot! Hot! Hot! </span>
</span></span></code></pre></div><p>Luckily, python has another <em>special syntax</em> in which <code>if</code> keyword creates an expression:</p>
<pre tabindex="0"><code>for _ in range(3 if temperature &gt; 31 else 1):
    print(&#34;Hot!&#34;, end=&#39;&#39;)
# Prints: Hot! Hot! Hot! 
</code></pre><p>While special syntax is usualy cemented in place, there are multiple ways to provide arguments to function calls.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>hot-code:</span> <span>{</span> <span>print</span> <span>&#34;Hot!&#34;</span> <span>}</span>
</span></span><span><span><span>is-hot:</span> <span>temperature</span> <span>&gt;</span> <span>30</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>is-hot</span> <span>hot-code</span>
</span></span><span><span><span>; prints Hot!</span>
</span></span><span><span>
</span></span><span><span><span>loop</span> <span>2</span> <span>hot-code</span>
</span></span><span><span><span>; Prints: Hot!</span>
</span></span><span><span><span>;         Hot!</span>
</span></span></code></pre></div><h3 id="piping-into-control-flow">Piping Into Control Flow</h3>
<p>Functions in Rye can accept a first (or second) argument from the left, so the same applies to “flow control”-like functions of course.
Read more about this in <a href="https://ryelang.org/meet_rye/specifics/opwords/">Meet Rye</a>.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>; Pipe a condition into if</span>
</span></span><span><span><span>temperature</span> <span>&gt;</span> <span>30</span> <span>|if { print &#34;Hot!&#34; }
</span></span></span><span><span><span>; Prints: Hot!
</span></span></span><span><span><span>
</span></span></span><span><span><span>3 .loop { .prns }
</span></span></span><span><span><span>; Prints: 0 1 2
</span></span></span><span><span><span>
</span></span></span><span><span><span>; Pipe a collection into for
</span></span></span><span><span><span>{ &#34;Hot&#34; &#34;Pockets&#34; } |for</span> <span>{</span> <span>.</span><span>print</span> <span>}</span>
</span></span><span><span><span>; Prints: Hot</span>
</span></span><span><span><span>;         Pockets</span>
</span></span></code></pre></div><p>In Python, you can’t pipe into <code>if</code> or <code>for</code> because they’re not values, they’re syntax.</p>
<h3 id="applying-functions">Applying functions</h3>
<p>In Rye we can apply functions to it’s arguments.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>apply</span> <span>?concat</span> <span>{</span> <span>&#34;Bob&#34;</span> <span>&#34;Odenkirk&#34;</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>woof:</span> <span>{</span> <span>print</span> <span>&#34;woof&#34;</span> <span>}</span>
</span></span><span><span><span>meov:</span> <span>{</span> <span>print</span> <span>&#34;meov&#34;</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>animals:</span> <span>[</span> <span>[</span> <span>false</span> <span>woof</span> <span>]</span> <span>[</span> <span>true</span> <span>meov</span> <span>]</span> <span>]</span>
</span></span><span><span>
</span></span><span><span><span>for</span> <span>animals</span> <span>{</span> <span>.</span><span>apply*</span> <span>?if</span> <span>}</span>
</span></span><span><span><span>; Prints: meov</span>
</span></span></code></pre></div><blockquote>
<p>?word - is a get-word, it doesn’t evaluate a function bound to the word but returns it
word* - star at the end of the word causes function to take second argument from the left, not the first one</p>
</blockquote>
<h3 id="partial-application">Partial Application</h3>
<p>In Rye we can also partially apply functions.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>add-five:</span> <span>partial</span> <span>?_+</span> <span>[</span> <span>_</span> <span>5</span> <span>]</span>
</span></span><span><span>
</span></span><span><span><span>add-five</span> <span>10</span>
</span></span><span><span><span>; returns 15</span>
</span></span><span><span>
</span></span><span><span><span>three-times:</span> <span>partial</span> <span>?loop</span> <span>[</span> <span>3</span> <span>_</span> <span>]</span>
</span></span><span><span>
</span></span><span><span><span>; Use it like any other function</span>
</span></span><span><span><span>three-times</span> <span>{</span> <span>prns</span> <span>&#34;Hey!&#34;</span> <span>}</span>
</span></span><span><span><span>; Hey! Hey! Hey!</span>
</span></span></code></pre></div><p>We’ve created a custom “control structure” <code>three-times</code> by partially applying a built-in <code>loop</code>.</p>
<h3 id="higher-order-control-flow">Higher-Order Control Flow</h3>
<p>We can pass function as arguments to other functions.</p>
<p>Here we create a function that takes a function and reates the same function that prints it’s arguments.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>verbosify\2:</span> <span>fn</span> <span>{</span> <span>fnc</span> <span>}</span> <span>{</span>
</span></span><span><span>    <span>closure</span> <span>{</span> <span>a</span> <span>b</span> <span>}</span> <span>{</span>
</span></span><span><span>	<span>probe</span> <span>a</span> 
</span></span><span><span>        <span>probe</span> <span>b</span>
</span></span><span><span>        <span>fnc</span> <span>a</span> <span>b</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>myconcat:</span> <span>verbosify\2</span> <span>?concat</span>
</span></span><span><span><span>myconcat</span> <span>&#34;AAA&#34;</span> <span>&#34;BBB&#34;</span>
</span></span><span><span><span>; Prints:</span>
</span></span><span><span><span>;  [String: AAA]</span>
</span></span><span><span><span>;  [String: BBB]</span>
</span></span><span><span><span>; Returns:</span>
</span></span><span><span><span>;  AAABBB</span>
</span></span><span><span>
</span></span><span><span><span>myif:</span> <span>verbosify\2</span> <span>?if</span>
</span></span><span><span><span>myif</span> <span>temperature</span> <span>&lt;</span> <span>30</span> <span>{</span> <span>print</span> <span>&#34;cold!&#34;</span> <span>}</span>
</span></span><span><span><span>; Prints:</span>
</span></span><span><span><span>;  [Boolean: false]</span>
</span></span><span><span><span>;  [Block: ^[Word: print] [String: cold!] ]</span>
</span></span></code></pre></div><h2 id="extensibility">Extensibility</h2>
<p>Since control flow is just functions, you can write your <strong>own control structures</strong> indistinguishable from built-ins.</p>
<h3 id="unless-and-until">Unless and Until</h3>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>; Want the opposite of if?</span>
</span></span><span><span><span>unless:</span> <span>fn</span> <span>{</span> <span>condition</span> <span>block</span> <span>}</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>not</span> <span>condition</span> <span>block</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>unless</span> <span>tired</span> <span>{</span> 
</span></span><span><span>    <span>print</span> <span>&#34;Keep working!&#34;</span> 
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>; Need an until loop?</span>
</span></span><span><span><span>until:</span> <span>fn</span> <span>{</span> <span>condition</span> <span>block</span> <span>}</span> <span>{</span>
</span></span><span><span>    <span>loop</span> <span>{</span>
</span></span><span><span>        <span>r::</span> <span>do</span> <span>block</span>
</span></span><span><span>        <span>if</span> <span>do</span> <span>condition</span> <span>{</span> <span>return</span> <span>r</span> <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>count::</span> <span>0</span>
</span></span><span><span><span>until</span> <span>{</span> <span>count</span> <span>&gt;</span> <span>5</span> <span>}</span> <span>{</span>
</span></span><span><span>    <span>print</span> <span>count</span>
</span></span><span><span>    <span>count::</span> <span>inc</span> <span>count</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h3 id="unlimited-control-flow-functions">Unlimited control flow functions</h3>
<p>When you accept this you see that there is no hard border of hard limit to what control strucutre like function you should have. You load them on library level
and specific libraries can provide new ones or offer you functionality in shape that would usually be reserved to special forms.</p>
<p>Part of the base functions, but could be considered special</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span>
</span></span><span><span><span>switch</span> <span>password</span> <span>{</span>
</span></span><span><span>	<span>&#34;sesame&#34;</span> <span>{</span> <span>&#34;Opening ...&#34;</span> <span>}</span>
</span></span><span><span>	<span>&#34;123456&#34;</span> <span>{</span> <span>&#34;Self destructing!&#34;</span> <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>; I&#39;l admit, I added cases control-function just for the fizz-buzz </span>
</span></span><span><span><span>; because I could :P</span>
</span></span><span><span>
</span></span><span><span><span>for</span> <span>range</span> <span>1</span> <span>100</span> <span>{</span> <span>:n</span>
</span></span><span><span>	<span>cases</span> <span>&#34; &#34;</span> <span>{</span>
</span></span><span><span>		<span>{</span> <span>n</span> <span>.</span><span>multiple-of</span> <span>3</span> <span>}</span> <span>{</span> <span>&#34;Fizz&#34;</span> <span>}</span>
</span></span><span><span>		<span>{</span> <span>n</span> <span>.</span><span>multiple-of</span> <span>5</span> <span>}</span> <span>{</span> <span>+</span> <span>&#34;Buzz&#34;</span> <span>}</span>
</span></span><span><span>		<span>_</span> <span>{</span> <span>n</span> <span>}</span>
</span></span><span><span>	<span>}</span> <span>|</span><span>prns</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>; outputs: 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 ...</span>
</span></span></code></pre></div><p>Higher order functions <code>map filter reduce</code> in Rye also function just like control structures accepting direct code blocks.</p>
<p>They can also accept functions so you can also use them as classic HOF-s.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span>
</span></span><span><span><span>{</span> <span>&#34;anne&#34;</span> <span>&#34;bob&#34;</span> <span>&#34;alan&#34;</span> <span>}</span> 
</span></span><span><span><span>|filter { .start-with &#34;a&#34; }
</span></span></span><span><span><span>|</span><span>map</span> <span>{</span> <span>uppercase</span> <span>}</span> <span>:names</span>
</span></span><span><span><span>|</span><span>for</span> <span>{</span> <span>.</span><span>print</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>names</span> <span>.</span><span>reduce</span> <span>&#39;acc</span> <span>{</span> <span>.</span><span>concat</span> <span>acc</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>; classic HOF patterns also work</span>
</span></span><span><span><span>{</span> <span>1</span> <span>2</span> <span>3</span> <span>}</span> <span>.</span><span>map</span> <span>fn</span> <span>{</span> <span>x</span> <span>}</span> <span>{</span> <span>x</span> <span>+</span> <span>1</span> <span>}</span>
</span></span></code></pre></div><p>Even <strong>external libraries</strong> can have their own functions that utilize <strong>blocks of code directly</strong>.</p>
<p>For example OpenAI library has a Chat\stream function that accepts a block of
code into which it injects a part of string for each stream event, similar to <strong>for loop</strong>.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>openai</span> <span>Read</span> <span>%.token</span>
</span></span><span><span><span>|</span><span>Chat\stream</span> <span>&#34;A joke of the day?&#34;</span> <span>{</span> <span>.</span><span>prn</span> <span>}</span>
</span></span></code></pre></div><blockquote>
<p>prn - prints a string without adding a newline or space at the end</p>
</blockquote>
<h2 id="the-trade-offs">The Trade-offs</h2>
<h3 id="performance">Performance</h3>
<p>Python can optimize special forms at compile time. In Rye, <code>if</code> is a function call with some runtime overhead.</p>
<h3 id="tooling">Tooling</h3>
<p>IDEs know what Python’s <code>if</code>, <code>for</code>, <code>def</code> are and can provide specialized support. When everything is a function, you are not limited to a few keywords.</p>
<h3 id="on-the-other-hand">On the other hand</h3>
<p>With langauge like Python you have to optimize and provide tools for every special syntax and construct separately.</p>
<p>In Rye, you “just” have to make function calls (builtin function and Rye functions) as fast as possible. And
builtins and functions are self-documenting so if you do make good tools for them you could solve <em>all</em> tooling problems at once.</p>
<hr/>
<p><em>Interested in learning more? Check out <a href="https://ryelang.org">Rye</a>, <a href="http://www.rebol.com">REBOL</a> or <a href="http://www.red-lang.org">Red</a> to see these ideas in action.</em></p>
<p><em>And follow our <a href="https://github.com/refaktor/rye">Github Repo</a>.</em></p>


  </div></div>
  </body>
</html>
