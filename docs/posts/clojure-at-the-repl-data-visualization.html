<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://clojure.org/guides/repl/data_visualization_at_the_repl#_graphical_and_web_based_visualizations">Original</a>
    <h1>Clojure at the REPL: Data Visualization</h1>
    
    <div id="readability-page-1" class="page"><p>Sometimes, the printed representation of a value in the REPL is not very informative; sometimes,
it can even be misleading as to the nature of that value.
This often happens with values which are obtained via Java interop.</p><p>As an example, we’ll create an InputStream object using the <a href="https://clojuredocs.org/clojure.java.io"><code>clojure.java.io</code></a> lib. If you don’t know
what an InputStream is, all the better - the point of this section is to teach you how to find your footing
in uncharted territory:</p><p>The above code sample defined an InputStream named <code>v</code>.</p><p>Now imagine you don’t know where <code>v</code> comes from, and let’s try to interact with it at the REPL
so as to gain more understanding of it.</p><div>
<h4 id="_viewing_the_type_hierarchy_using_type_and_ancestors"><a href="#_viewing_the_type_hierarchy_using_type_and_ancestors"></a>Viewing the type hierarchy using <code>type</code> and <code>ancestors</code></h4>
<p>The printed representation of <code>v</code> tells us one thing about it: its <em>runtime type</em>, in this case <code>java.io.BufferedInputStream</code>.
The <em>type</em> of a value can help us know what operations we may call on it.
We can evaluate <code>(<a href="https://clojuredocs.org/clojure.core/type">type</a> v)</code> to obtain the <em>concrete type</em> of <code>v</code>, and
<code>(<a href="https://clojuredocs.org/clojure.core/ancestors">ancestors</a> (type v))</code> to obtain its entire <em>type hierarchy:</em></p>
<div>
<div>
<pre><code data-lang="clojure-repl">user=&gt; (type v) ;; what is the type of our obscure value?
java.io.BufferedInputStream
user=&gt; (ancestors (type v))
#{java.io.InputStream java.lang.AutoCloseable java.io.Closeable java.lang.Object java.io.FilterInputStream}</code></pre>
</div>
</div>
</div><div>
<h4 id="_using_javadoc"><a href="#_using_javadoc"></a>Using Javadoc</h4>
<p>As we saw in the previous section, we can use the <a href="https://clojure.github.io/clojure/clojure.java.javadoc-api.html">clojure.java.javadoc</a> lib
to view online documentation about a Java type:</p>
<div>
<div>
<pre><code data-lang="clojure-repl">user=&gt; (require &#39;[clojure.java.javadoc :as jdoc])
nil
user=&gt; (jdoc/javadoc java.io.InputStream) ;; should open a web page about java.io.InputStream
true</code></pre>
</div>
</div>
</div><div>
<h4 id="_inspecting_java_types_with_clojure_reflect"><a href="#_inspecting_java_types_with_clojure_reflect"></a>Inspecting Java types with <code>clojure.reflect</code></h4>
<p>Javadoc is helpful, but sometimes Javadoc won’t even be available. In such cases, we can use
the REPL itself to inspect types, via Java reflection.</p>
<p>We can use the <code><a href="https://clojure.github.io/clojure/clojure.reflect-api.html#clojure.reflect/reflect">clojure.reflect/reflect</a></code>
function to obtain information about a Java type as a plain Clojure data structure:</p>
<div>
<div>
<pre><code data-lang="clojure-repl">user=&gt; (require &#39;[clojure.reflect :as reflect])
nil
user=&gt; (reflect/reflect java.io.InputStream)
{:bases #{java.lang.Object java.io.Closeable}, :flags #{:public :abstract}, :members #{#clojure.reflect.Method{:name close, :return-type void, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name mark, :return-type void, :declaring-class java.io.InputStream, :parameter-types [int], :exception-types [], :flags #{:public :synchronized}} #clojure.reflect.Method{:name available, :return-type int, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public :abstract}} #clojure.reflect.Method{:name markSupported, :return-type boolean, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [], :flags #{:public}} #clojure.reflect.Field{:name MAX_SKIP_BUFFER_SIZE, :type int, :declaring-class java.io.InputStream, :flags #{:private :static :final}} #clojure.reflect.Constructor{:name java.io.InputStream, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [], :flags #{:public}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [byte&lt;&gt;], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name skip, :return-type long, :declaring-class java.io.InputStream, :parameter-types [long], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name reset, :return-type void, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public :synchronized}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [byte&lt;&gt; int int], :exception-types [java.io.IOException], :flags #{:public}}}}</code></pre>
</div>
</div>
<p>Now, that is a <em>very</em> hairy data structure. Fortunately, we have learned how to deal with hairy data structures in the
<a href="#_pretty_printing_using_code_clojure_pprint_code">first section</a> of this chapter: pretty-printing to the rescue!
Let’s use pretty-printing to display the methods exposed by <code>java.io.InputStream</code> in a table:</p>
<div>
<div>
<pre><code data-lang="clojure-repl">user=&gt; (-&gt;&gt; (reflect/reflect java.io.InputStream) :members (sort-by :name) (pp/print-table [:name :flags :parameter-types :return-type]))

|                :name |                     :flags | :parameter-types | :return-type |
|----------------------+----------------------------+------------------+--------------|
| MAX_SKIP_BUFFER_SIZE | #{:private :static :final} |                  |              |
|            available |                 #{:public} |               [] |          int |
|                close |                 #{:public} |               [] |         void |
|  java.io.InputStream |                 #{:public} |               [] |              |
|                 mark |   #{:public :synchronized} |            [int] |         void |
|        markSupported |                 #{:public} |               [] |      boolean |
|                 read |       #{:public :abstract} |               [] |          int |
|                 read |                 #{:public} |         [byte&lt;&gt;] |          int |
|                 read |                 #{:public} | [byte&lt;&gt; int int] |          int |
|                reset |   #{:public :synchronized} |               [] |         void |
|                 skip |                 #{:public} |           [long] |         long |
nil</code></pre>
</div>
</div>
<p>For example, this tells us that we can call a <code>.read</code> method on <code>v</code> with no arguments, which will return an <code>int</code>:</p>
<div>
<div>
<pre><code data-lang="clojure-repl">user=&gt; (.read v)
60
user=&gt; (.read v)
33
user=&gt; (.read v)
68</code></pre>
</div>
</div>
<p>Without any prior knowledge, we have managed to learn that <code>v</code> is an InputStream, and read bytes from it.</p>
</div></div>
  </body>
</html>
