<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bloop.ai/blog/gpu_with_ggml">Original</a>
    <h1>GPU Embedding with GGML</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>Semantic search is great for building chatbots, but indexing can be slow. In our case (bloop is a chatbot that answers questions about your code) we split code files into chunks, feed them to an embedding model and stick the resulting vectors into a vector DB. We do this on-device with a local embedding model so that code doesn’t leave the device during indexing, and to save index disk-space by using a model that generates really small vectors.</p><p>Code search is most useful on large codebases, and it turns out that some of our users were indexing very large repositories. As large as <a href="https://github.com/llvm/llvm-project">LLVM</a> with 13 million lines of code. So we set ourselves the challenge of radically improving our index speeds by running the embedding model on the MacBook’s GPU. This turned out to be more of an undertaking than we’d anticipated, taking us on a journey through the fast-moving world of open-source AI.</p><p>On CPU we were using the <a href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2">MiniLM-L6-v2</a> embedding model which we’d converted to <a href="https://onnx.ai/">ONNX</a> and quantised to 8-bits. It had several characteristics that we liked:</p><ol><li><p>It’s small (on disk it takes up 22Mb)</p></li><li><p>It generates 384 dimensional vectors (smaller than most comparable models)</p></li><li></li></ol><p>With it we could embed 20, 256-token sequences a second. Assuming that there are 18 tokens in a line of code, it would take nearly 12 hours to index LLVM. </p><p>Speeding this up by sticking it on the MacBook GPU seemed straightforward. One of ONNX Runtime’s selling points is that it can take advantage of a load of different hardware accelerators, including Apple Core ML. All we had to do was tell ONNX Runtime to use Core ML and it should magically take care of the rest, running our embedding model on the GPU:</p><pre><code><span>Environment</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>
</span><span>       </span><span>.</span><span>with_log_level</span><span>(</span><span>LoggingLevel</span><span>::</span><span>Warning</span><span>)</span><span>
</span><span>       </span><span>.</span><span>with_execution_providers</span><span>(</span><span>[</span><span>ExecutionProvider</span><span>::</span><span>coreml</span><span>(</span><span>)</span><span>]</span><span>)</span><span>
</span><span>       </span><span>.</span><span>with_telemetry</span><span>(</span><span>false</span><span>)</span><span>
</span><span>       </span><span>.</span><span>build</span><span>(</span><span>)</span><span>?</span></code></pre><p>But, when we checked out the GPU usage, nothing…</p><p><img src="https://bloop-web-app.s3.eu-west-1.amazonaws.com/blog/image1.png"/></p><p>We took a closer look at the ONNX Runtime documentation and it turns out that not all of the operations in our MiniLM model are supported for Core ML (like GeLU and QuantizeLinear). Adding support for them ourselves didn’t look too appetising. So we cast around for alternatives.</p><p><a href="https://github.com/ggerganov/ggml">ggml</a> has been getting a lot of attention in the open-source AI community recently and it&#39;s being used to run some pretty big LLMs on-device (it powers <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a>). It also supports 4-bit quantisation, half the lowest precision supported by ONNX, and now can run operations on MacBook GPUs with Metal Performance Shaders. The performance is impressive:</p><p>But surprisingly we couldn’t find any projects using ggml for GPU embedding. We were going to have to do it ourselves. How hard could it be?</p><p>At this point that we should note that bloop is <a href="https://github.com/BloopAI/bloop">written in Rust</a>. Rather than directly interface with ggml (which is written in C++) we used <a href="https://github.com/rustformers/llm">llm</a> an excellent crate that wraps it.</p><p>Step one was to port a <a href="https://github.com/skeskinen/bert.cpp">ggml implementation of Bert</a> - the transformer architecture that MiniLM uses - into llm. This went smoothly, and it wasn’t long before we had something up and running, but we quickly spotted a problem. When we inspected the vector outputs we found that they contained NaNs (not-a-number). Even worse, this behaviour was non-deterministic. For the same input sequence we’d sometimes output NaNs and sometimes not.</p><p>Debugging this was tricky. We dropped down into ggml itself and found the <a href="https://github.com/ggerganov/llama.cpp/blob/e1886cf4fe0d0f31661dda52a4a9f34bd9b9009a/ggml-metal.m#L341">ggml_metal_graph_compute function</a> which is responsible for passing input data through the model itself. It queues up the operations defined in the computation graph and executes the corresponding metal kernels. At this level we have access to the intermediate tensors, so we logged these and found the culprit. The GeLU activation function in the Multi-Head Attention layer was non-deterministic:</p><pre><code><span>// intermediate output</span><span>
</span><span>current </span><span>=</span><span> ctx0</span><span>.</span><span>op_mul_mat</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>layers</span><span>[</span><span>il</span><span>]</span><span>.</span><span>ff_i_w</span><span>,</span><span> </span><span>&amp;</span><span>current</span><span>)</span><span>;</span><span>
</span><span>current </span><span>=</span><span> ctx0</span><span>.</span><span>op_add</span><span>(</span><span>&amp;</span><span>current</span><span>,</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>layers</span><span>[</span><span>il</span><span>]</span><span>.</span><span>ff_i_b</span><span>)</span><span>;</span><span>
</span><span>current </span><span>=</span><span> ctx0</span><span>.</span><span>op_gelu</span><span>(</span><span>&amp;</span><span>current</span><span>)</span><span>;</span></code></pre><p>We started psyching ourselves up to delve into the implementation of the GeLU kernel, but then we noticed that a fix had just been pushed to llama.cpp! All we needed to do was use the <code>precise::tanh</code> function in the kernel:</p><pre><code><span>kernel </span><span>void</span><span> </span><span>kernel_gelu</span><span>(</span><span>
</span><span>    device </span><span>const</span><span> float4 </span><span>*</span><span> src0</span><span>,</span><span>
</span><span>    device       float4 </span><span>*</span><span> dst</span><span>,</span><span>
</span><span>    uint tpig</span><span>[</span><span>[</span><span>thread_position_in_grid</span><span>]</span><span>]</span><span>)</span><span> </span><span>{</span><span>
</span><span>    device </span><span>const</span><span> float4 </span><span>&amp;</span><span> x </span><span>=</span><span> src0</span><span>[</span><span>tpig</span><span>]</span><span>;</span><span>
</span>
<span>    </span><span>// BEWARE !!!</span><span>
</span><span>    </span><span>// Simply using &#34;tanh&#34; instead of &#34;precise::tanh&#34; will sometimes results in NaNs!</span><span>
</span><span>    </span><span>// This was observed with Falcon 7B and 40B models</span><span>
</span><span>    </span><span>//</span><span>
</span><span>    dst</span><span>[</span><span>tpig</span><span>]</span><span> </span><span>=</span><span> </span><span>0.5f</span><span>*</span><span>x</span><span>*</span><span>(</span><span>1.0f</span><span> </span><span>+</span><span> precise</span><span>:</span><span>:</span><span>tanh</span><span>(</span><span>SQRT_2_OVER_PI</span><span>*</span><span>x</span><span>*</span><span>(</span><span>1.0f</span><span> </span><span>+</span><span> GELU_COEF_A</span><span>*</span><span>x</span><span>*</span><span>x</span><span>)</span><span>)</span><span>)</span><span>;</span><span>
</span><span></span><span>}</span></code></pre><p>No more NaNs. Now we were rolling. We still had to check whether the vectors that our ggml model was generating were similar to the ones we were generating with ONNX (we knew that they weren’t going to be identical as the ggml model uses 4-bit rather than 8-bit quantisation). So we benchmarked the embeddings produced by both models on our internal retrieval benchmark and found that the Mean Reciprocal Rank (a common IR metric) was close:</p><table><thead><tr><th>Model</th><th>MRR</th></tr></thead><tbody><tr><td>ONNX</td><td>0.47058</td></tr><tr><td>GGML</td><td>0.498775</td></tr></tbody></table><p>Even though the ggml embeddings aren&#39;t the same, when using them for semantic retrieval a relevant chunk of code appears on average as the second ranked result in the search results list. Now we could hit run and…</p><p><img src="https://bloop-web-app.s3.eu-west-1.amazonaws.com/blog/image2.png"/></p><p>Boom! Look at that GPU spike.</p><p>But we weren&#39;t finished yet. The real beauty of indexing on the GPU is to batch inputs, parallelising the computation across multiple sequences. In our indexing pipline we split code files into chunks roughly 256 tokens long, so we wouldn’t waste much time computing padding tokens between inputs of varying length. And all we’d need to do is add an extra <code>batch_size</code> dimension to all our tensors, right? Well, ggml doesn’t have Metal kernels for 4 dimensional matrix multiplications, but that’s not a problem. We can reshape the <code>[d_head, sequence_len, n_head, batch_size]</code> tensors to <code>[d_head, sequence_len, n_head * batch_size]</code>, perform the matrix multiplication, then reshape them back:</p><pre><code><span>let</span><span> q </span><span>=</span><span> ctx0</span><span>.</span><span>op_reshape_3d</span><span>(</span><span>&amp;</span><span>q</span><span>,</span><span> d_head</span><span>,</span><span> sequence_len</span><span>,</span><span> n_head </span><span>*</span><span> batch_size</span><span>)</span><span>;</span><span>
</span><span></span><span>let</span><span> k </span><span>=</span><span> ctx0</span><span>.</span><span>op_reshape_3d</span><span>(</span><span>&amp;</span><span>k</span><span>,</span><span> d_head</span><span>,</span><span> sequence_len</span><span>,</span><span> n_head </span><span>*</span><span> batch_size</span><span>)</span><span>;</span><span>
</span><span></span><span>let</span><span> </span><span>mut</span><span> kq </span><span>=</span><span> ctx0</span><span>.</span><span>op_mul_mat</span><span>(</span><span>&amp;</span><span>k</span><span>,</span><span> </span><span>&amp;</span><span>q</span><span>)</span><span>;</span><span>
</span>
<span>kq </span><span>=</span><span> ctx0</span><span>.</span><span>op_scale</span><span>(</span><span>
</span><span>       </span><span>&amp;</span><span>kq</span><span>,</span><span>
</span><span>       </span><span>&amp;</span><span>ctx0</span><span>.</span><span>new_f32</span><span>(</span><span>1.0</span><span> </span><span>/</span><span> </span><span>(</span><span>(</span><span>n_embd </span><span>as</span><span> </span><span>f32</span><span> </span><span>/</span><span> n_head </span><span>as</span><span> </span><span>f32</span><span>)</span><span>.</span><span>sqrt</span><span>(</span><span>)</span><span>)</span><span>)</span><span>,</span><span>
</span><span></span><span>)</span><span>;</span><span>
</span>
<span></span><span>let</span><span> kq </span><span>=</span><span> ctx0</span><span>.</span><span>op_reshape_4d</span><span>(</span><span>&amp;</span><span>kq</span><span>,</span><span> sequence_len</span><span>,</span><span> sequence_len</span><span>,</span><span> n_head</span><span>,</span><span> batch_size</span><span>)</span><span>;</span></code></pre><p>After some fiddling around with padding and masking we had it. Batched embedding running on the MacBook GPU. </p><p>Time to run some benchmarks. We collected 10 sequences from a sample codebase, where each was 256 tokens long. For models without batching we timed how long it took to pass each of the 10 sequences to the model in serial, and for batched models we passed all 10 sequences at once in a single batch. </p><p>Here are the results on an M2 Mac mini (8GB unified memory):</p><p>That’s roughly a 13x speedup over our original CPU model. At that rate it would only take 54 minutes to index LLVM. Not instantaneous, but you wouldn&#39;t have to leave it running overnight. And even better, the 4-bit ggml model is faster on the CPU so we can use it on machines that don’t have a GPU too.</p><p>So what did we learn? While the ecosystem for running open-source AI models on-device is immature, and there are still plenty of holes, it’s developing incredibly fast! Features and fixes are rushing into libraries like ggml and llm. And a lot of it is being built in Rust 🦀. We didn’t even get to talk about other Rust ML projects like <a href="https://github.com/burn-rs/burn">burn</a> or <a href="https://github.com/huggingface/candle">Huggingface’s Candle</a>.</p><p>Thanks to all of the open-source projects mentioned in this post. You can check out our <a href="https://github.com/BloopAI/llm">fork of llm here</a>, our quantised <a href="https://huggingface.co/nerdypepper/minilm-l6-v2-ggml">ggml-format MiniLM model here</a>, and our <a href="https://github.com/BloopAI/embed-bench">benchmark repo</a> here.</p></article></div></div>
  </body>
</html>
