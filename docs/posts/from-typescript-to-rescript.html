<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.greyblake.com/blog/from-typescript-to-rescript/">Original</a>
    <h1>From TypeScript to ReScript</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  
  <p><span>2022-01-12</span></p><p>About three weeks ago I decided to completely rewrite the frontend of <a href="https://inhyped.com/">Inhyped.com</a> from TypeScript to <a href="https://rescript-lang.org/">ReScript</a>.
In this article, I&#39;d like to share my experience and learnings.</p>
<p>You can see my tweets regarding the rewriting, they&#39;re marked with hashtag <a href="https://twitter.com/hashtag/FromTypescriptToRescript">#FromTypescriptToRescript</a>.</p>
<p>The source code of both TypeScript and ReScript versions is <a href="https://github.com/greyblake/from-typescript-to-rescript">available on GitHub</a>.</p>
<h2 id="why-rescript">Why ReScript?</h2>
<p>I enjoy Rust&#39;s type safety and I&#39;ve been searching for something similar in the frontend world.
In 2021 tried to implement small projects in <a href="https://elm-lang.org/">Elm</a> and <a href="https://seed-rs.org/">Seed</a>.
Elm is great and it&#39;s the safest language I&#39;ve ever tried.
Seed is a framework in Rust inspired by Elm, meaning I was able to reuse a big portion of code for backend and frontend (data structures and validation rules),
which was also amazing!
However, both are quite distant from the big existing JS ecosystem.</p>
<p>Eventually, I had decided to use TypeScript when I started working on <a href="https://inhyped.com/">Inhyped.com</a> as my hobby project. At that moment I had some
experience with React and was aware of techniques that helped me to squeeze maximum safety from TypeScript.</p>
<p>A few months ago I got ReasonML/ReScript on my radar thanks to this <a href="https://www.youtube.com/watch?v=nZDN6XCM1X0">interview (RU)</a>.
However, I did not dare to touch the new technology until one Friday evening, when I got extremely upset with TypeScript at my daily job.</p>
<p>I can foresee readers asking why I do not like TypeScript. Don&#39;t get me wrong, TS brings a lot of value and
prevents many errors if we compare it to the raw JS.
But &#34;why TypeScript is not good enough&#34; is a very broad topic, that requires its own article. Here I put it very shortly:</p>
<ul>
<li>TypeScript&#39;s type system is over-complex since it tries to be a superset of JS.</li>
<li>Despite requiring very verbose type annotations, <strong>TypeScript does not have a sound type system,
meaning it does not guarantee the absence of type-related errors in runtime even if everything compiles fine</strong>.</li>
</ul>
<h2 id="learning">Learning</h2>
<p>Next Saturday I spent 5-6 hours reading through the <a href="https://rescript-lang.org/docs/manual/latest/introduction">official ReScript Manual</a>
and playing with the language in the <a href="https://rescript-lang.org/try">playground</a>.</p>
<p>For me, it was very plain to learn, mostly just getting familiar with the syntax. I can attribute it to my prior knowledge of Elm, Haskell, and Rust.
Anyone else, who has a small prior experience with functional programming would feel the same. For those who never touched it before, it&#39;s a great
opportunity to stretch your skills and get the taste of functional programming =).</p>
<p>The next day, on Sunday, I started rewriting my project. Of course, there were still things to learn on the way.</p>
<h2 id="stats">Stats</h2>
<p>Let&#39;s compare both implementations in terms of line of codes.</p>
<p>TypeScript:</p>
<pre><code><span>✦ ❯ tokei -t=TSX,TypeScript,Rescript
</span><span>===============================================================================
</span><span> Language            Files        Lines         Code     Comments       Blanks
</span><span>===============================================================================
</span><span> TSX                    19         2233         1941           18          274
</span><span> TypeScript             15          675          554           22           99
</span><span>===============================================================================
</span><span> Total                  34         2908         2495           40          373
</span><span>===============================================================================
</span></code></pre>
<p>Rescript:</p>
<pre><code><span>✦ ❯ tokei -t=TSX,TypeScript,Rescript
</span><span>===============================================================================
</span><span> Language            Files        Lines         Code     Comments       Blanks
</span><span>===============================================================================
</span><span> ReScript               31         3259         2838           43          378
</span><span>===============================================================================
</span><span> Total                  31         3259         2838           43          378
</span><span>===============================================================================
</span></code></pre>
<p>From those 2838 LOC in ReScript, 430 are bindings and about 250 LOC are decoders.
If we disregard those, we get 2158 LOC in ReScipt VS 2495 LOC in TypeScript.
Considering that TypeScript has a lot of imports, the code density of ReScript and TypeScript is pretty much the same.</p>
<h2 id="rescript-overview">ReScript overview</h2>
<h3 id="react">React</h3>
<p>ReScript&#39;s ecosystem is well-tuned to be used with React, and honestly, I haven&#39;t heard about anyone using it (successfully) with
Angular or Vue. In particular, it works well with React hooks, and I am less sure what it would be like to implement class components.</p>
<h3 id="javascript-interoperability">JavaScript interoperability</h3>
<p>What makes ReScript stand out from the type-safe alternatives is JavaScript interoperability:
reusing existing JavaScript libraries or frameworks is very easy.
It&#39;s just a matter of finding existing or defining own binding, which is surprisingly easy.</p>
<p>Consider the following example:</p>
<pre data-lang="res"><code data-lang="res"><span>module </span><span>Big </span><span>= </span><span>{
</span><span>  </span><span>type</span><span> t
</span><span>
</span><span>  </span><span>@</span><span>module</span><span>(&#34;</span><span>big.js</span><span>&#34;)
</span><span>  </span><span>external</span><span> fromString: string </span><span>=&gt;</span><span> t </span><span>= </span><span>&#34;</span><span>Big</span><span>&#34;
</span><span>}
</span></code></pre>
<p>Here we define a module <code>Big</code> which has function <code>fromString</code>. The function takes a string argument and passes it to <code>Big()</code> from <code>big.js</code>.</p>
<p>So the following ReScript code</p>
<pre data-lang="res"><code data-lang="res"><span>let</span><span> amount </span><span>= </span><span>Big.fromString(&#34;</span><span>12.34</span><span>&#34;)
</span></code></pre>
<p>compiles into this JavaScript:</p>
<pre data-lang="js"><code data-lang="js"><span>import </span><span>{ </span><span>Big </span><span>} </span><span>from </span><span>&#34;</span><span>big.js</span><span>&#34;;
</span><span>
</span><span>let </span><span>amount </span><span>= </span><span>Big</span><span>(&#34;</span><span>12.34</span><span>&#34;);
</span></code></pre>
<p>For more examples you can take a look at my bindings for <a href="https://github.com/greyblake/from-typescript-to-rescript/blob/master/rescript/src/bindings/Mui.res">MUI</a>
or <a href="https://github.com/greyblake/from-typescript-to-rescript/blob/master/rescript/src/bindings/NearApi.res">near-api-js</a>.</p>
<p>What if you implemented components or functions in ReScript and want to use them in your app which is mostly written in TypeScript?
ReScript has <a href="https://rescript-lang.org/docs/gentype/latest/introduction"><code>@genType</code></a> macro which generates <code>.tsx</code> files with all the interfaces.
You just have to annotate a function or type:</p>
<pre data-lang="res"><code data-lang="res"><span>@</span><span>genType
</span><span>let</span><span> add(a: int, b: int): int </span><span>=&gt;</span><span> a </span><span>+</span><span> b
</span></code></pre>
<p>Mostly this works just great, although there sometimes nuances that one needs to learn.</p>
<p>Unfortunately, there is nothing that would convert type definitions from TypeScript to ReScript,
because TypeScript&#39;s type system is much more complex than ReScript&#39;s one.</p>
<h3 id="reason-vs-rescript">Reason VS ReScript</h3>
<p>About a year ago Reason(ML) was rebranded into ReScript with some changes in the language syntax.
It often causes some confusion for newcomers (me including).
I recommend learning a little bit of history:</p>
<ul>
<li><a href="https://rescript-lang.org/blog/bucklescript-is-rebranding">BuckleScript &amp; Reason Rebranding</a></li>
<li><a href="https://ersin-akinci.medium.com/confused-about-rescript-rescript-reason-reasonml-and-bucklescript-explained-ab4230555230">ReScript, Reason, ReasonML, and BuckleScript explained</a></li>
</ul>
<p>Unfortunately, today it&#39;s necessary to understand difference between OCaml, BuckleScript, Reason and ReScript to navigate in the ecosystem comfortably.
It&#39;s not uncommon when one has to rely on packages written in Reason which has slightly different syntax than ReScript.</p>
<h3 id="http">HTTP</h3>
<p>To send HTTP queries you&#39;re likely to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.
It&#39;s possible to implement our own bindings, but fortunately, it&#39;s done already for us by others:</p>
<ul>
<li><a href="https://github.com/reasonml-community/bs-fetch">bs-fetch</a></li>
<li><a href="https://github.com/tinymce/rescript-webapi">rescript-webapi</a></li>
</ul>
<p>I prefer wrapping API calls with functions that receive parameters and return a result with either a successful payload or an error.
You can see some examples <a href="https://github.com/greyblake/from-typescript-to-rescript/blob/master/rescript/src/shared/Api.res#L99-L101">here</a>.</p>
<h3 id="json-codecs">JSON codecs</h3>
<p>Once JSON is received from a remote server you want to turn it into a more specific data type.
The official ReScript tutorial gives <a href="https://rescript-lang.org/docs/manual/latest/json#parse">an example</a> of casting a random JSON into a
value of a &#34;concrete&#34; type by leveraging <code>external</code>, which is mostly meant for interoperability with JavaScript.
I see it rather as anti-pattern, because:</p>
<ul>
<li>It&#39;s hard to keep JSON produced by backend and an internal ReScript type representation in sync.</li>
<li>It&#39;s practically impossible, if you use variant types.</li>
<li>After all, you go for ReScript over TypeScript not to cast types blindly, right? :)</li>
</ul>
<p>The proper alternative is to use codecs (encoders and decoders) to parse JSON into domain types.
The same concept is used in Elm.</p>
<p>I found 3 libraries for this:</p>
<ul>
<li><a href="https://github.com/glennsl/bs-json">bs-json</a> - the oldest one, implemented in Reason</li>
<li><a href="https://github.com/reasonml-labs/decco">decco</a> - implemented in Reason, provides macro to generate codecs automatically</li>
<li><a href="https://github.com/nkrkv/jzon">jzon</a>- implemented in Rescript</li>
</ul>
<p>Initially, I wanted to use <code>decco</code>, but it is not flexible enough. In particular, the way it handles variant type is not compatible with the way
<a href="https://github.com/serde-rs/serde">serde</a> handles <code>enum</code> on backend.</p>
<p><code>jzon</code> looks unnecessary too verbose to me. So I went with <code>bs-json</code> and it serves me well, except <a href="https://github.com/glennsl/bs-json/issues/23">optional decoder</a>,
which catches the internal exception and returns <code>None</code>, when it actually must raise. But this can be worked around by implementing
our own decoder.</p>
<p>Here is an example of a decoder:</p>
<pre data-lang="res"><code data-lang="res"><span>module </span><span>D </span><span>= </span><span>Json.Decode
</span><span>
</span><span>module </span><span>ClaimableRetweetOrderView </span><span>= </span><span>{
</span><span>  </span><span>type</span><span> t </span><span>= </span><span>{
</span><span>    id: RetweetOrderId.t,
</span><span>    reward: Big.t,
</span><span>    tweet: TweetView.t,
</span><span>  }
</span><span>
</span><span>  </span><span>let</span><span> decode </span><span>= </span><span>(json: Js.Json.t): t </span><span>=&gt; </span><span>{
</span><span>    {
</span><span>      id: D.field(&#34;</span><span>id</span><span>&#34;, RetweetOrderId.decode, json),
</span><span>      reward: D.field(&#34;</span><span>reward</span><span>&#34;, D.string, json)</span><span>-&gt;</span><span>Big.fromString,
</span><span>      tweet: D.field(&#34;</span><span>tweet</span><span>&#34;, TweetView.decode, json),
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre>
<p>There is our domain type <code>ClaimableRetweetOrderView.t</code> and function <code>ClaimableRetweetOrderView.decode</code> which turns
an amorphic JSON into <code>t</code> type, performing all necessary checks and raising an error if JSON is not correctly shaped.</p>
<p>Consider the line:</p>
<pre data-lang="res"><code data-lang="res"><span>reward: D.field(&#34;</span><span>reward</span><span>&#34;, D.string, json)</span><span>-&gt;</span><span>Big.fromString
</span></code></pre>
<ul>
<li>We take a field <code>reward</code> from input <code>json</code> and try to decode it into a ReScript string.</li>
<li>Then we pass that string using pipe operator <code>-&gt;</code> to <code>Big.fromString</code> function, which returns <code>Big.t</code> type.</li>
<li>We set the result to <code>reward</code> property of <code>ClaimableRetweetOrderView.t</code>.</li>
</ul>
<h3 id="async-await">Async/await</h3>
<p>ReScript has no async/await support. It was one of my big concerns, but it turned out fine: I had no pain using piped promises.
I&#39;d highly recommend using <a href="https://github.com/ryyppy/rescript-promise">ryyppy/rescript-promise</a> package.</p>
<p>Here is a typical example:</p>
<pre data-lang="res"><code data-lang="res"><span>Api.createRetweetOrder(validParams)
</span><span>-&gt;</span><span>Promise.then(result </span><span>=&gt; </span><span>{
</span><span>  </span><span>switch</span><span> result {
</span><span>  | </span><span>Ok</span><span>(_) </span><span>=&gt; </span><span>{
</span><span>      reloadUser()
</span><span>      navigateTo(&#34;</span><span>/orders/my</span><span>&#34;)
</span><span>    }
</span><span>  | </span><span>Error</span><span>(error) </span><span>=&gt; </span><span>{
</span><span>      </span><span>let</span><span> errors </span><span>=</span><span> convertCreateOrderErrorToFormErrors(error)
</span><span>      setFormErrors(_ </span><span>=&gt;</span><span> errors)
</span><span>    }
</span><span>  }
</span><span>  Promise.resolve()
</span><span>})
</span><span>-&gt;</span><span>ignore
</span></code></pre>
<ul>
<li>Call an endpoint with valid parameters (<code>Api.createRetweetOrder(validParams)</code>)</li>
<li>If the result is <code>Ok</code> reload user information and navigate to <code>/orders/my</code></li>
<li>If the result is <code>Error</code>, do some error transformation and set them as a component state with <code>setFormErrors</code></li>
</ul>
<p><code>Promise.resolve()</code> is needed just to satisfy the interface of <code>Promise.then</code> because it requires a function that returns a promise.
<code>ignore()</code> function is converting anything into unit type <code>()</code> (which means &#34;Nothing&#34;). It&#39;s required otherwise the compiler
complains about type mismatch: usually, if an expression returns a value it must be used in some way (e.g. be assigned to a variable).</p>
<h3 id="module-system">Module System</h3>
<p>The way the module system interacts with a file system is a little bit weird. It&#39;s not like in other languages I know.
Module names are inferred from filenames, but every module is global. This means having two files with the same name in different
directories is not allowed. E.g. these two would collide:</p>
<pre><code><span>/models/User.res
</span><span>/utils/User.res
</span></code></pre>
<p>Both files define a module with a name <code>User</code>.</p>
<p>This restriction requires some rethinking about how to structure a large code base.</p>
<p>There is also a common workaround for this, which can be seen in <a href="https://github.com/tinymce/rescript-webapi/tree/main/src/Webapi/Dom">rescript-webapi</a> project.</p>
<p>The files above can be restructured as:</p>
<pre><code><span>/Models/Models__User.res
</span><span>/Models.res
</span><span>/Utils/Utils__User.res
</span><span>/Utils.res
</span></code></pre>
<p>Then within <code>Models.res</code> we create an alias:</p>
<pre data-lang="res"><code data-lang="res"><span>module </span><span>User </span><span>= </span><span>Models__User
</span></code></pre>
<p>Now we can access <code>Models.User</code>.
Same trick applies to <code>Utils.res</code>.</p>
<p>This is a little bit annoying, but not very crucial.</p>
<h3 id="data-types">Data types</h3>
<p>Today I hardly imagine myself programming in a language that does not support algebraic data types (don&#39;t look at me, I do not miss you Ruby!).
TypeScript&#39;s union type doing a great job (considering that everything is built on top of JS) , but it never felt natural to me.
E.g. <a href="https://github.com/greyblake/from-typescript-to-rescript/blob/master/typescript/src/result.ts">I reinvented my own <code>Result</code> type in TypeScript</a> with
proper pattern matching.</p>
<p>Now I have my <code>option</code>, <code>result</code> types in place, and proper pattern matching with <code>switch</code>.
Often <a href="https://rescript-lang.org/docs/manual/latest/variant">variant types</a> allow us to model domains much more accurately.</p>
<p>A big gain for me as an ability to use newtype (opaque type) technique, something that is not possible with structural typing in TS.</p>
<p>Consider the following code snippet. Both types <code>productId</code> and <code>userId</code> are strings under the hood, but the compiler prevents us from making a mistake
by accidentally passing <code>productId</code> to a function that expects <code>userId</code>:</p>
<pre data-lang="res"><code data-lang="res"><span>type</span><span> productId </span><span>= </span><span>ProductId</span><span>(string)
</span><span>type</span><span> userId </span><span>= </span><span>UserId</span><span>(string)
</span><span>
</span><span>let</span><span> fetchUserById </span><span>= </span><span>(id: userId) </span><span>=&gt; </span><span>{
</span><span>  </span><span>// ...
</span><span>}
</span><span>
</span><span>let</span><span> productUserById </span><span>= </span><span>ProductId</span><span>(&#34;</span><span>123</span><span>&#34;)
</span><span>
</span><span>// ERROR:
</span><span>// This has type: productId
</span><span>// Somewhere wanted: userId
</span><span>fetchUser(productId)
</span></code></pre>
<p>In TypeScript, I implemented <a href="https://github.com/greyblake/from-typescript-to-rescript/blob/master/typescript/src/remoteData.ts">RemoteData</a> inspired
by <a href="https://package.elm-lang.org/packages/krisajenkins/remotedata/latest/">the Elm package</a>.
For ReScript there is a similar package, called <a href="https://github.com/bloodyowl/rescript-asyncdata">asyncdata</a>.</p>
<h3 id="error-handling">Error handling</h3>
<p>ReScript provides the following mechanisms to express errors:</p>
<ul>
<li><a href="https://rescript-lang.org/docs/manual/latest/api/belt/result">Result type</a></li>
<li><a href="https://rescript-lang.org/docs/manual/latest/exception">ReScript exceptions</a></li>
<li>JavaScript exceptions</li>
</ul>
<p>Whenever is possible you should use <a href="https://rescript-lang.org/docs/manual/latest/api/belt/result">result</a> to return errors.
In rare cases, you may want raise ReScript exceptions, which are in fact compiled down to JS exceptions with special markers.
Hopefully, you&#39;ll never need to throw JS exceptions.</p>
<p>ReScript exceptions must be preferred over the regular JavaScript exceptions because they&#39;re strictly typed and the compiler
is aware of their data shape.</p>
<h3 id="order-of-definitions">Order of definitions</h3>
<p>ReScript does not allow to refer to functions, which are not yet defined. I speculate saying that this is due to the fact,
that functions are just variables. Nevertheless, it forces me to structure my code in a file up side down: usually, I try to keep
the most important high-level things on top and details below, but with ReScript it&#39;s the other way around.</p>
<h3 id="react-component-a-la-jsx">@react.component (à la JSX)</h3>
<p>There is <code>@react.component</code> macro that turns a module with function <code>make</code> into React component and allows to use JSX-like syntax.</p>
<p>There is a few points to be made about it:</p>
<ul>
<li>Properties are turned into labeled (named) function arguments and are type-safe</li>
<li>It&#39;s possible to use normal ReScript comments</li>
<li>Regular text has to be wrapped in <code>React.string()</code> which is a little bit annoying</li>
<li>CSS props have to be built with <code>ReactDOM.Style.make</code> which is again, slightly annoying.</li>
</ul>
<pre data-lang="res"><code data-lang="res"><span>@</span><span>react.component
</span><span>let</span><span> make </span><span>= </span><span>(~children: React.element, ~href: string) </span><span>=&gt; </span><span>{
</span><span>  </span><span>let</span><span> iconStyle </span><span>= </span><span>ReactDOM.Style.make(~verticalAlign</span><span>=</span><span>&#34;</span><span>middle</span><span>&#34;, ~marginLeft</span><span>=</span><span>&#34;</span><span>4px</span><span>&#34;, ())
</span><span>
</span><span>  &lt;Link href target</span><span>=</span><span>&#34;</span><span>_blank</span><span>&#34; rel</span><span>=</span><span>&#34;</span><span>noopener</span><span>&#34; underline</span><span>=</span><span>#</span><span>hover</span><span>&gt;
</span><span>    </span><span>// This comment would not be possible in normal JSX/TSX
</span><span>    {children}
</span><span>    &lt;LaunchIcon fontSize</span><span>=</span><span>#</span><span>small</span><span> sx</span><span>=</span><span>iconStyle /&gt;
</span><span>    {React.string(&#34;</span><span>In JSX it would be just a text...</span><span>&#34;)}
</span><span>  &lt;/Link&gt;
</span><span>}
</span></code></pre>
<h3 id="compiler">Compiler</h3>
<p>Under the hood ReScript is just a tweaked OCaml compiler that compiles OCaml&#39;s AST into JavaScript.</p>
<p>The error messages are not that good as in Elm or Rust, but I&#39;d say still better than TypeScript.</p>
<p>However, error messages can be a bit confusing when <code>&gt;</code> in a generic is forgotten or <code>=</code> is typed instead of <code>=&gt;</code>,
or <code>|</code> is forgotten in a patter matching <code>| _ =&gt; doDefaultAction()</code>.
Those are typical errors I did and it took me a few days to pay extra attention to this.</p>
<p>OCaml is super smart by inferencing types. But I am not smart enough for OCaml. I was abusing type inferencing, by living
types for most of the functions undefined, until once I got into a trap: there was a type mismatch, but the error the compiler reported
was quite far from the original error made by me. It&#39;s not a compiler&#39;s fault, the fault was purely mine.</p>
<p>So, after this I prefer to explicitly define function interfaces (hello Rust!), to ensure the compiler reasoning about types
is in sync with my real intentions.</p>
<p>I got used to Rust, so I was not complaining about TypeScript compilation time.
But ReScript&#39;s feedback loop is insane, it&#39;s just instant: usually in the range of 20ms-60ms when I change a file.</p>
<h3 id="ide-support">IDE support</h3>
<p>I did not have high expectations about this, so I was positively surprised.
ReScript has relatively good IDE/editor support (at least for <a href="https://github.com/rescript-lang/vim-rescript">Vim</a>). I have all what I need:</p>
<ul>
<li>Syntax highlight</li>
<li>Jump to definition</li>
<li>Type hints</li>
<li>Autocomplete</li>
<li>Simple refactorings (e.g. renaming)</li>
</ul>

<p>The ReScript community is very friendly, I got a lot of help, posting random questions on Twitter, StackOverFlow and the <a href="https://forum.rescript-lang.org/">ReScript forum</a>.
But let&#39;s be honest: the community is very small at the moment. As result, there are not many maintained bindings available out there.
This is probably the biggest weak point.</p>
<h3 id="idioms">Idioms</h3>
<p>There is a few idioms I wish I could learn from the <a href="https://rescript-lang.org/docs/manual/latest/introduction">official tutorial</a>.</p>
<p>It&#39;s common to use very small modules for each single data type coupled with associated functions.
The type within a module is typically named <code>t</code>, for example:</p>
<pre data-lang="res"><code data-lang="res"><span>module </span><span>UserId
</span><span>  </span><span>type</span><span> t </span><span>= </span><span>UserId</span><span>(string)
</span><span>
</span><span>  </span><span>let</span><span> fromString </span><span>= </span><span>(id: string): t </span><span>=&gt; </span><span>UserId</span><span>(id)
</span><span>  </span><span>let</span><span> toString </span><span>= </span><span>(</span><span>UserId</span><span>(id)): string </span><span>=&gt;</span><span> id
</span><span>}
</span></code></pre>
<p>Functions named <code>make</code> usually act like constructors of complex types. For example, the following snippet
creates CSS properties:</p>
<pre data-lang="res"><code data-lang="res"><span>let</span><span> style </span><span>= </span><span>ReactDOM.Style.make(
</span><span>  ~verticalAlign</span><span>=</span><span>&#34;</span><span>middle</span><span>&#34;,
</span><span>  ~marginLeft</span><span>=</span><span>&#34;</span><span>4px</span><span>&#34;,
</span><span>  ()
</span><span>)
</span></code></pre>
<h3 id="debugger-and-source-maps">Debugger and source maps?</h3>
<p>Those questions are often raised by newcomers.</p>
<p>The answer: ReScript has no special debugging support or source maps.</p>
<p>However, there is a good part:</p>
<ul>
<li>You are going to have much less runtime errors to investigate.</li>
<li>You still have <code>console.log</code> (<code>Js.log</code>).</li>
<li>Generated JavaScript code is human-readable and it&#39;s not hard to related a generated code to its original sources.</li>
<li>You can still use the regular JavaScript break points.</li>
</ul>
<h3 id="types-are-not-capitalized">Types are not capitalized</h3>
<p>Type names start with a lowercase letter. E.g. <code>array&lt;user&gt;</code>, not <code>Array&lt;User&gt;</code>, it feels a bit weird after long programming
in Rust and TypeScript, but again, it&#39;s just a question of habits.</p>
<h2 id="summary">Summary</h2>
<p>ReScript is not without its drawbacks,
the small community and lack of maintained bindings for popular JavaScript libraries is probably the weakest point.</p>
<p>But it stays on the very strong foundation of OCaml and
has a very unique value proposition among other frontend technologies I am aware of:
<strong>Rescript offers the sound type system without giving up on the existing JavaScript/React ecosystem</strong>.</p>
<p>Is that not amazing?</p>

</div>

        </div></div>
  </body>
</html>
