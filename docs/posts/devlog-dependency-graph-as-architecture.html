<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstract.properties/devlog-dependency-graph-as-architecture.html">Original</a>
    <h1>Devlog: dependency graph as architecture</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>Time for devlog #4! <a href="https://abstract.properties/devlog-a-sketch-of-this-application.html">Last week&#39;s was here</a>.</p>
<p>The visual, live development environment I&#39;ve been working on could not have been built without Gooey, my frontend web
framework.</p>
<p>Let&#39;s get into how it works.</p>
<a id="gooey:-a-dependency-graph-engine" href="#gooey%3A-a-dependency-graph-engine"><h2>Gooey: a dependency graph engine</h2></a>
<p>Though it calls itself a &#34;focused and flexible frontend web framework,&#34; <a href="https://gooey.abstract.properties/">Gooey</a> is
really a dependency graph engine.</p>
<p>In this dependency graph, nodes are either pieces of data or calculations, and the edges represent the flow of this
data.</p>
<p>To demonstrate, here&#39;s a little interactive tool to visualize the angle of a line segment:</p>
<content-switcher dynamic-height="" active="viz">
<figure slot="viz">

</figure>
<div slot="code">
<p>The full code <a href="https://gist.github.com/sufianrhazi/385727c0300d177d8d411cd6bb18e50d">can be found here</a>.</p>
<div><pre><span>import</span> <span>Gooey</span>, { calc, field, mount, ref } <span>from</span> <span>&#39;@srhazi/gooey&#39;</span>;
<span>import</span> <span>type</span> { <span>Component</span>, <span>Field</span> } <span>from</span> <span>&#39;@srhazi/gooey&#39;</span>;

<span>const</span> <span>NumericInput</span>: <span>Component</span>&lt;{
    <span>value</span>: <span>Field</span>&lt;<span>number</span>&gt;;
    <span>id</span>?: <span>string</span>;
    <span>type</span>: <span>string</span>;
    <span>min</span>: <span>string</span>;
    <span>max</span>: <span>string</span>;
}&gt; = <span>(<span>{ value, ...rest }</span>) =&gt;</span> (
    <span><span>&lt;<span>input</span>
        {<span>...rest</span>}
        <span>value</span>=<span>{value}</span>
        <span>on:input</span>=<span>{(e,</span> <span>el</span>) =&gt;</span> value.set(el.valueAsNumber)}
    /&gt;</span>
);

<span>const</span> <span>Visualization</span>: <span>Component</span> = <span>(<span>props, { onMount }</span>) =&gt;</span> {
    <span>const</span> canvasRef = ref&lt;<span>HTMLCanvasElement</span>&gt;();
    <span>let</span> <span>ctx</span>: <span>CanvasRenderingContext2D</span> | <span>null</span> = <span>null</span>;

    <span>// Input data, just X &amp; Y coordinates</span>
    <span>const</span> x = <span>field</span>(<span>40</span>);
    <span>const</span> y = <span>field</span>(<span>30</span>);

    <span>// Derived data, calculations that show angle &amp; degrees</span>
    <span>const</span> angle = <span>calc</span>(<span>() =&gt;</span> {
        <span>const</span> baseAngle = <span>Math</span>.<span>atan</span>(y.<span>get</span>() / x.<span>get</span>());
        <span>if</span> (x.<span>get</span>() &lt; <span>0</span>) {
            <span>return</span> baseAngle + <span>Math</span>.<span>PI</span>;
        }
        <span>if</span> (y.<span>get</span>() &lt; <span>0</span>) {
            <span>return</span> baseAngle + <span>2</span> * <span>Math</span>.<span>PI</span>;
        }
        <span>return</span> baseAngle;
    });
    <span>const</span> degrees = <span>calc</span>(<span>() =&gt;</span> (angle.<span>get</span>() * <span>360</span>) / (<span>2</span> * <span>Math</span>.<span>PI</span>));

    <span>// A calculation which is re-evaluated when dependencies change, but doesn&#39;t return anything.</span>
    <span>// This can be used to subscribe to multiple things at once.</span>
    <span>const</span> render = <span>calc</span>(<span>() =&gt;</span> {
        <span>update</span>({
            <span>x</span>: x.<span>get</span>(),
            <span>y</span>: y.<span>get</span>(),
            <span>angle</span>: angle.<span>get</span>(),
        });
    });

    <span>onMount</span>(<span>() =&gt;</span> {
        <span>if</span> (canvasRef.<span>current</span>) {
            ctx = canvasRef.<span>current</span>.<span>getContext</span>(<span>&#39;2d&#39;</span>);
        }
        <span>// By subscribing to our render calculation, it becomes &#34;alive&#34; and is recalculated when the x/y/angle changes</span>
        <span>return</span> render.<span>subscribe</span>(<span>() =&gt;</span> {});
    });

    <span>const</span> <span>update</span> = (<span>{
        x,
        y,
        angle,
    }: {
        x: <span>number</span>;
        y: <span>number</span>;
        angle: <span>number</span>;
    }</span>) =&gt; {
        <span>if</span> (!ctx) {
            <span>return</span>;
        }
        ctx.<span>fillStyle</span> = <span>&#39;#F4F2F4&#39;</span>;
        ctx.<span>rect</span>(<span>0</span>, <span>0</span>, ctx.<span>canvas</span>.<span>width</span>, ctx.<span>canvas</span>.<span>height</span>);
        ctx.<span>fill</span>();
        ctx.<span>save</span>();
        ctx.<span>scale</span>(ctx.<span>canvas</span>.<span>width</span> / <span>200</span>, ctx.<span>canvas</span>.<span>height</span> / <span>200</span>);
        ctx.<span>translate</span>(<span>100</span>, <span>100</span>);

        <span>// Draw outline for angle</span>
        ctx.<span>beginPath</span>();
        ctx.<span>save</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#C0C000&#39;</span>;
        ctx.<span>setLineDash</span>([<span>2.5</span>, <span>2.5</span>]);
        ctx.<span>arc</span>(<span>0</span>, <span>0</span>, <span>20</span>, <span>0</span>, <span>2</span> * <span>Math</span>.<span>PI</span>, angle &gt; <span>0</span>);
        ctx.<span>stroke</span>();
        ctx.<span>restore</span>();

        <span>// Draw orange arc for angle</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#C0C000&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#808000&#39;</span>;
        ctx.<span>arc</span>(<span>0</span>, <span>0</span>, <span>20</span>, <span>0</span>, -angle, angle &gt; <span>0</span>);
        ctx.<span>stroke</span>();
        ctx.<span>lineTo</span>(<span>0</span>, <span>0</span>);
        ctx.<span>fill</span>();

        <span>// Draw red line for X axis</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#800000&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#C00000&#39;</span>;
        ctx.<span>moveTo</span>(<span>0</span>, <span>0</span>);
        ctx.<span>lineTo</span>(<span>0</span> + x, <span>0</span>);
        ctx.<span>stroke</span>();

        <span>// Draw green line for Y axis</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#008000&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#00C000&#39;</span>;
        ctx.<span>moveTo</span>(<span>0</span> + x, <span>0</span>);
        ctx.<span>lineTo</span>(<span>0</span> + x, <span>0</span> - y);
        ctx.<span>stroke</span>();

        <span>// Draw blue line for hypotenuse</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#0000C0&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#000080&#39;</span>;
        ctx.<span>moveTo</span>(<span>0</span>, <span>0</span>);
        ctx.<span>lineTo</span>(<span>0</span> + x, <span>0</span> - y);
        ctx.<span>stroke</span>();

        <span>// Red X point</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#800000&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#C00000&#39;</span>;
        ctx.<span>arc</span>(<span>0</span> + x, <span>0</span>, <span>4</span>, <span>0</span>, <span>2</span> * <span>Math</span>.<span>PI</span>);
        ctx.<span>stroke</span>();
        ctx.<span>fill</span>();

        <span>// Green Y point</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#008000&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#00C000&#39;</span>;
        ctx.<span>arc</span>(<span>0</span> + x, <span>0</span> - y, <span>4</span>, <span>0</span>, <span>2</span> * <span>Math</span>.<span>PI</span>);
        ctx.<span>stroke</span>();
        ctx.<span>fill</span>();

        <span>// Blue center point</span>
        ctx.<span>beginPath</span>();
        ctx.<span>strokeStyle</span> = <span>&#39;#0000C0&#39;</span>;
        ctx.<span>fillStyle</span> = <span>&#39;#000080&#39;</span>;
        ctx.<span>arc</span>(<span>0</span>, <span>0</span>, <span>4</span>, <span>0</span>, <span>2</span> * <span>Math</span>.<span>PI</span>);
        ctx.<span>stroke</span>();
        ctx.<span>fill</span>();

        ctx.<span>restore</span>();
    };

    <span>return</span> (
        <span><span>&lt;<span>div</span>&gt;</span>
            <span>&lt;<span>style</span>&gt;</span><span>
                {`
<span>.triangle-canvas</span> {
    <span>position</span>: relative;
    <span>cursor</span>: crosshair;
    <span>width</span>: <span>400px</span>;
    <span>height</span>: auto;
}
<span>.triangle-canvas-controls</span> {
    <span>display</span>: grid;
    <span>padding</span>: <span>16px</span>;
    <span>gap</span>:  <span>16px</span>;
    <span>grid-template-columns</span>: auto <span>1</span>fr;
}
<span>.triangle-angle-input</span> {
    <span>text-align</span>: right;
}
        `}
            </span><span>&lt;/<span>style</span>&gt;</span>
            <span>&lt;<span>canvas</span>
                <span>class</span>=<span>&#34;triangle-canvas&#34;</span>
                <span>ref</span>=<span>{canvasRef}</span>
                <span>width</span>=<span>&#34;800&#34;</span>
                <span>height</span>=<span>&#34;800&#34;</span>
                <span>on:mousemove</span>=<span>{(e,</span> <span>el</span>) =&gt;</span> {
                    const box = el.getBoundingClientRect();
                    const mouseX =
                        2 * ((e.clientX - box.left) / box.width - 0.5);
                    const mouseY =
                        2 * ((e.clientY - box.top) / box.height - 0.5);
                    x.set(Math.round(mouseX * 1000) / 10);
                    y.set(Math.round(-mouseY * 1000) / 10);
                }}
                on:touchmove={(e: TouchEvent, el) =&gt; {
                    if (e.targetTouches[0]) {
                        e.preventDefault();
                        const box = el.getBoundingClientRect();
                        const touchX =
                            2 *
                            ((e.targetTouches[0].clientX - box.left) /
                                box.width -
                                0.5);
                        const touchY =
                            2 *
                            ((e.targetTouches[0].clientY - box.top) /
                                box.height -
                                0.5);
                        x.set(Math.round(touchX * 10000) / 10);
                        y.set(Math.round(-touchY * 1000) / 10);
                    }
                }}
            /&gt;
            <span>&lt;<span>fieldset</span> <span>class</span>=<span>&#34;triangle-canvas-controls&#34;</span>&gt;</span>
                <span>&lt;<span>legend</span>&gt;</span>Controls<span>&lt;/<span>legend</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>&#34;x-value&#34;</span>&gt;</span>X Value<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>NumericInput</span>
                    <span>id</span>=<span>&#34;x-value&#34;</span>
                    <span>type</span>=<span>&#34;number&#34;</span>
                    <span>value</span>=<span>{x}</span>
                    <span>min</span>=<span>&#34;-100&#34;</span>
                    <span>max</span>=<span>&#34;100&#34;</span>
                /&gt;</span>
                <span>&lt;<span>span</span> /&gt;</span>
                <span>&lt;<span>NumericInput</span> <span>type</span>=<span>&#34;range&#34;</span> <span>value</span>=<span>{x}</span> <span>min</span>=<span>&#34;-100&#34;</span> <span>max</span>=<span>&#34;100&#34;</span> /&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>&#34;y-value&#34;</span>&gt;</span>Y Value<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>NumericInput</span>
                    <span>id</span>=<span>&#34;y-value&#34;</span>
                    <span>type</span>=<span>&#34;number&#34;</span>
                    <span>value</span>=<span>{y}</span>
                    <span>min</span>=<span>&#34;-100&#34;</span>
                    <span>max</span>=<span>&#34;100&#34;</span>
                /&gt;</span>
                <span>&lt;<span>span</span> /&gt;</span>
                <span>&lt;<span>NumericInput</span> <span>type</span>=<span>&#34;range&#34;</span> <span>value</span>=<span>{y}</span> <span>min</span>=<span>&#34;-100&#34;</span> <span>max</span>=<span>&#34;100&#34;</span> /&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>&#34;angle&#34;</span>&gt;</span>Angle<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>input</span>
                    <span>class</span>=<span>&#34;triangle-angle-input&#34;</span>
                    <span>id</span>=<span>&#34;angle&#34;</span>
                    <span>type</span>=<span>&#34;text&#34;</span>
                    <span>value</span>=<span>{calc(()</span> =&gt;</span> `${angle.get().toFixed(3)} radians`)}
                    readonly
                /&gt;
                <span>&lt;<span>label</span> <span>for</span>=<span>&#34;degrees&#34;</span>&gt;</span>Degrees<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>input</span>
                    <span>class</span>=<span>&#34;triangle-angle-input&#34;</span>
                    <span>id</span>=<span>&#34;degrees&#34;</span>
                    <span>type</span>=<span>&#34;text&#34;</span>
                    <span>value</span>=<span>{calc(()</span> =&gt;</span> `${degrees.get().toFixed(3)} degrees`)}
                    readonly
                /&gt;
            <span>&lt;/<span>fieldset</span>&gt;</span>
        <span>&lt;/<span>div</span>&gt;</span></span>
    );
};

<span>const</span> angleViz = <span>document</span>.<span>getElementById</span>(<span>&#39;angleViz&#39;</span>);
<span>if</span> (angleViz) {
    <span>mount</span>(angleViz, <span><span>&lt;<span>Visualization</span> /&gt;</span></span>);
}
</pre></div>
</div>
</content-switcher>
<p>The most important part of that code is its data model.</p>
<p>It is built from <strong>Fields</strong> and <strong>Calculations</strong>, which form a <strong>dependency graph</strong>.</p>
<div><pre><span>const</span> <span>Visualization</span>: <span>Component</span> = <span>(<span>props, { onMount }</span>) =&gt;</span> {
  <span>// ...canvas code omitted...</span>

  <span>// Input data, just X &amp; Y coordinates</span>
  <span>const</span> x = <span>field</span>(<span>40</span>);
  <span>const</span> y = <span>field</span>(<span>30</span>);
</pre></div>
<p>Here we have a <code>Visualization</code> component—a render function that creates 2 <strong>fields</strong>: <code>x</code> and <code>y</code>.</p>
<p>Fields are like containers, they hold a piece of data that be swapped out over time.</p>
<div><pre>  <span>// Derived data, calculations that show angle &amp; degrees</span>
  <span>const</span> angle = <span>calc</span>(<span>() =&gt;</span> {
    <span>const</span> baseAngle = <span>Math</span>.<span>atan</span>(y.<span>get</span>() / x.<span>get</span>());
    <span>if</span> (x.<span>get</span>() &lt; <span>0</span>) {
      <span>return</span> baseAngle + <span>Math</span>.<span>PI</span>;
    }
    <span>if</span> (y.<span>get</span>() &lt; <span>0</span>) {
      <span>return</span> baseAngle + <span>2</span> * <span>Math</span>.<span>PI</span>;
    }
    <span>return</span> baseAngle;
  });

  <span>const</span> degrees = <span>calc</span>(<span>() =&gt;</span> (angle.<span>get</span>() * <span>360</span>) / (<span>2</span> * <span>Math</span>.<span>PI</span>));
</pre></div>
<p>And here we have two <strong>calculations</strong> defined: <code>angle</code> and <code>degrees</code>.</p>
<p>Calculations are like derived fields, they produce a value that depends the data read.</p>
<p>Both fields and calculations live on the dependency graph as nodes.</p>
<p>When a calculation&#39;s function reads a piece of data, an edge is added to the dependency graph going
from the node read to the node doing the reading.</p>
<ul>
<li>When <code>angle</code> calls <code>y.get()</code> and <code>x.get()</code>, two edges are added: <code>y -&gt; angle</code> &amp; <code>x -&gt; angle</code></li>
<li>When <code>degrees</code> calls <code>angle.get()</code>, one edge is added: <code>angle -&gt; degrees</code></li>
</ul>
<p>Calculations don&#39;t always need to return a value:</p>
<div><pre>  <span>// A calculation which is re-evaluated when dependencies change, but doesn&#39;t return anything.</span>
  <span>// This can be used to subscribe to multiple things at once.</span>
  <span>const</span> render = <span>calc</span>(<span>() =&gt;</span> {
    <span>update</span>({
      <span>x</span>: x.<span>get</span>(),
      <span>y</span>: y.<span>get</span>(),
      <span>angle</span>: angle.<span>get</span>(),
    });
  });
</pre></div>
<p>Here, a <code>render</code> calculation reads some data from the fields and calculations it depends on (<code>x</code>, <code>y</code>, and <code>angle</code>), and
passes their values to an <code>update()</code> function which does the work of drawing to the canvas.</p>
<p>This may feel a bit like an <code>useEffect</code> in React, except you don&#39;t need to list out all the dependencies.</p>

<p>If we draw this dependency graph out as a diagram, we get this visual:</p>
<figure>
<svg style="padding-left: 40px" width="186pt" height="188pt" viewBox="0.00 0.00 185.94 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 184)">
<title>angleviz</title>
<!-- x -->
<g id="node_x">
<title>x</title>
<polygon fill="#ffffff" stroke="black" points="58.7,-180 4.7,-180 4.7,-144 58.7,-144 58.7,-180"></polygon>
<text text-anchor="middle" x="31.7" y="-158.3" font-size="14.00">x</text>
</g>
<!-- angle -->
<g id="node_angle">
<title>angle</title>
<ellipse fill="#ffffff" stroke="black" cx="67.7" cy="-90" rx="32.49" ry="18"></ellipse>
<text text-anchor="middle" x="67.7" y="-86.3" font-size="14.00">angle</text>
</g>
<!-- x->angle -->
<g id="edge1">
<title>x-&gt;angle</title>
<path fill="none" stroke="black" d="M40.6,-143.7C44.62,-135.87 49.47,-126.44 53.95,-117.73"></path>
<polygon fill="black" stroke="black" points="56.99,-119.46 58.46,-108.97 50.77,-116.26 56.99,-119.46"></polygon>
</g>
<!-- render -->
<g id="node_render">
<title>render</title>
<ellipse fill="#ffffff" stroke="black" cx="37.7" cy="-18" rx="37.89" ry="18"></ellipse>
<text text-anchor="middle" x="37.7" y="-14.3" font-size="14.00">render</text>
</g>
<!-- x->render -->
<g id="edge4">
<title>x-&gt;render</title>
<path fill="none" stroke="black" d="M29.09,-143.57C26.79,-125.6 24.15,-96.79 26.7,-72 27.54,-63.83 29.08,-55.07 30.76,-47.07"></path>
<polygon fill="black" stroke="black" points="34.12,-48.05 32.9,-37.52 27.29,-46.51 34.12,-48.05"></polygon>
</g>
<!-- y -->
<g id="node_y">
<title>y</title>
<polygon fill="#ffffff" stroke="black" points="142.7,-180 88.7,-180 88.7,-144 142.7,-144 142.7,-180"></polygon>
<text text-anchor="middle" x="115.7" y="-158.3" font-size="14.00">y</text>
</g>
<!-- y->angle -->
<g id="edge2">
<title>y-&gt;angle</title>
<path fill="none" stroke="black" d="M103.83,-143.7C98.2,-135.49 91.37,-125.52 85.17,-116.48"></path>
<polygon fill="black" stroke="black" points="88.17,-114.66 79.62,-108.39 82.39,-118.62 88.17,-114.66"></polygon>
</g>
<!-- y->render -->
<g id="edge5">
<title>y-&gt;render</title>
<path fill="none" stroke="black" d="M118.35,-143.75C120.39,-124.89 121.05,-94.39 108.7,-72 100.69,-57.48 86.83,-45.78 73.47,-37.12"></path>
<polygon fill="black" stroke="black" points="75.58,-34.3 65.22,-32.12 71.96,-40.29 75.58,-34.3"></polygon>
</g>
<!-- degrees -->
<g id="node_degrees">
<title>degrees</title>
<ellipse fill="#ffffff" stroke="black" cx="135.7" cy="-18" rx="42.49" ry="18"></ellipse>
<text text-anchor="middle" x="135.7" y="-14.3" font-size="14.00">degrees</text>
</g>
<!-- angle->degrees -->
<g id="edge3">
<title>angle-&gt;degrees</title>
<path fill="none" stroke="black" d="M82.45,-73.81C91.12,-64.89 102.27,-53.41 112.13,-43.26"></path>
<polygon fill="black" stroke="black" points="114.51,-45.83 118.97,-36.22 109.49,-40.95 114.51,-45.83"></polygon>
</g>
<!-- angle->render -->
<g id="edge6">
<title>angle-&gt;render</title>
<path fill="none" stroke="black" d="M60.43,-72.05C57.12,-64.32 53.11,-54.96 49.38,-46.27"></path>
<polygon fill="black" stroke="black" points="52.64,-44.99 45.49,-37.18 46.21,-47.75 52.64,-44.99"></polygon>
</g>
</g>
</svg>
<figcaption><strong>Fields are rectangles; Calculations are ellipses; Edges show the flow of data</strong><span id="sequence_description"></span></figcaption>
</figure>
<a id="processing-the-dependency-graph" href="#processing-the-dependency-graph"><h3>Processing the dependency graph</h3></a>
<p>When Gooey sees that an authoritative piece of data has changed (i.e. <code>x.set(10)</code>), the corresponding node is marked as
&#34;dirty&#34; and an asynchronous task is scheduled to process the graph (via
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/queueMicrotask"><code>queueMicrotask</code></a>).</p>
<p>Dirty nodes are processed in topological order and may mark their downstream neighbors as &#34;dirty&#34;.</p>
<p>When a calculation is processed after being marked as dirty, its function is called again. If its return value differs,
it marks its downstream neighbors as dirty.</p>
<a id="always-in-order" href="#always-in-order"><h4>Always in order</h4></a>
<p>Gooey always processes the graph in topological order—even if nodes and edges in the graph change as nodes are
processed!</p>
<p>This is tricky, and may cause a node to be processed multiple times. For example, a calculation&#39;s function may be called
multiple times if it gains a dependency by reading a new node which happens to depend on a dirty value.</p>
<p>To manage this in-order processing, Gooey maintains a linear ordering of all nodes in its dependency graph. Think of
this ordering as an array of nodes, where all of the edges go left-to-right.</p>
<p>If an edge is added which goes in the opposite direction, the ordering is now wrong. To correct this, the out-of-order
slice of that array is reordered to maintain the left-to-right invariant.</p>
<a id="always-memoized" href="#always-memoized"><h4>Always memoized</h4></a>
<p>Because the dependency graph is processed following the flow of data, calculations can be stateful: they hold onto their
function&#39;s return values until marked as dirty.</p>
<p>This means that any <code>calc()</code> encountered in Gooey is automatically memoized based on the data it has read. It&#39;s a bit
like a <code>useMemo</code> in React, except you also don&#39;t need to list out all the dependencies.</p>
<a id="not-just-single-value-fields" href="#not-just-single-value-fields"><h4>Not just single-value fields</h4></a>
<p>Collections in Gooey are like arrays of Fields: each item in the collection lives in the dependency graph as a node.</p>
<p>Unlike fields, collections may be subscribed to in a more array-oriented way. Collections have a <a href="https://gooey.abstract.properties/api.html#api_collection_subscribe">subscribe
method</a> for observing changes.</p>
<p>Similar to how <strong>calculations</strong> are the derived counterpoint to authoritative <strong>fields</strong>, <strong>views</strong> are the derived counterpoint
to authoritative <strong>collections</strong>.</p>
<ul>
<li>Want a derived collection where each item is transformed? Use <a href="https://gooey.abstract.properties/api.html#api_collection_mapView">.mapView()</a></li>
<li>Want a derived collection where each item is conditionally present? Use <a href="https://gooey.abstract.properties/api.html#api_collection_filterView">.filterView()</a></li>
<li>Want both? Use <a href="https://gooey.abstract.properties/api.html#api_collection_flatMapView">.flatMapView()</a></li>
</ul>
<a id="binding-nodes-to-ui" href="#binding-nodes-to-ui"><h3>Binding nodes to UI</h3></a>
<p>Gooey also allows you to bind nodes in the dependency graph directly to the DOM via JSX.</p>
<p>In our visualization, we can see this in how the <code>input</code> text boxes have their <code>value</code> property bound directly to the
result of a calculation:</p>
<div><pre>&lt;input
    <span>class</span>=<span>&#34;triangle-angle-input&#34;</span>
    id=<span>&#34;angle&#34;</span>
    <span>type</span>=<span>&#34;text&#34;</span>
    value={<span>calc</span>(<span>() =&gt;</span> <span>`<span>${angle.get().toFixed(<span>3</span>)}</span> radians`</span>)}
    <span>readonly</span>
/&gt;
</pre></div>
<p>And if JSX is returned by a calculation, it will be rendered to the DOM in place and replaced by its contents when the
calculation is processed.</p>
<a id="a-dependency-graph-as-an-architecture" href="#a-dependency-graph-as-an-architecture"><h2>A dependency graph as an architecture</h2></a>
<p>If all of your application&#39;s data is built from these fields and calculations (and collections, etc...), then your
application has a clear defined separation between <strong>authoritative data</strong> and <strong>derived data</strong>.</p>
<p>A funny thing happens when you start structuring your application this way.</p>
<p>Since this state can live <strong>anywhere</strong> in your application, you stop needing rules around the structure and
subscriptions of your &#34;data store&#34;.</p>
<p>You can model your application&#39;s state naturally, using <code>field()</code>, <code>calc()</code>, and <code>collection()</code>. And regardless of where
that state is placed or how it&#39;s accessed, it will be automatically updated and memoized efficiently.</p>

<p>For example, the <a href="https://board.abstract.properties" target="_blank">development environment</a> I&#39;m building
roughly models a JavaScript module.</p>
<figure>
<img src="https://claude.ai/img/screenshot/project-2024-10-29.png"/>
<figcaption>A screenshot showing a module with a few cells</figcaption>
</figure>
<p>There&#39;s a <code>ModuleModel</code> class which holds its name bindings in a collection of <code>ModuleNameBinding</code> instances. These name
bindings have fields representing the name (so names can change without impacting the value), and value at that binding.</p>
<div><pre><span>class</span> <span>ModuleNameBinding</span> {
    <span>name</span>: <span>Field</span>&lt;<span>string</span>&gt;;
    <span>value</span>: <span>CellModel</span> | <span>FunctionModel</span> | ...;

    <span>// ... implementation code ...</span>
}

<span>class</span> <span>ModuleModel</span> {
    <span>bindings</span>: <span>Collection</span>&lt;<span>ModuleNameBinding</span>&gt;;

    <span>// ... implementation code ...</span>
}
</pre></div>
<p>This allows name bindings to be dynamically added/removed from the module, and bindings to be renamed / their value
changed.</p>
<p>Similarly, &#34;Cells&#34; in the application are instances of the <code>CellModel</code> class. They hold their dynamic properties in a
collection of property bindings which hold <code>AtomModel</code> class instances, which are &#34;dynamic property objects&#34; which
contain source code that is evaluated to produce their result.</p>
<div><pre><span>class</span> <span>AtomModel</span> {
  <span>sourceCode</span>: <span>Field</span>&lt;<span>string</span>&gt;;
  <span>value</span>: <span>Calculation</span>&lt;<span>any</span>&gt;; <span>// sourceCode evaluation result</span>

  <span>// ... implementation code ...</span>
}

<span>class</span> <span>CellModelProperty</span> {
  <span>name</span>: <span>Field</span>&lt;<span>string</span>&gt;;
  <span>value</span>: <span>AtomModel</span>;

  <span>// ... implementation code ...</span>
}

<span>class</span> <span>CellModel</span> {
  <span>properties</span>: <span>Collection</span>&lt;<span>AtomModel</span>&gt;

  <span>// ... implementation code ...</span>
}
</pre></div>
<p>Since calculations automatically add dependencies when they&#39;re read, there&#39;s no need to worry about adding subscriptions
to this data. If the underlying data changes, the Calculation will be re-evaluated.</p>
<p>This is even true for <code>AtomModel</code> which has user-provided source code. If the evaluation of that source code happens to
read any data in the dependency graph, it will be re-evaluated if (and only if) the dependencies change.</p>
<p>This gives a ton of flexibility to the data model over time. Since calculations don&#39;t need to worry about subscribing to
changes, fields can change freely over time and calculations don&#39;t need to change at all!</p>
<p>It&#39;s a lot more forgiving than other state management solutions, which can be brittle and hard to change over time.</p>



                </div></div>
  </body>
</html>
