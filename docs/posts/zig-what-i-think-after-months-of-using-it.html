<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://strongly-typed-thoughts.net/blog/zig-2025">Original</a>
    <h1>Zig; what I think after months of using it</h1>
    
    <div id="readability-page-1" class="page"><section>
  
<!--toc:start-->
<ul>
<li><a href="#what-i-like">What I like</a>
<ul>
<li><a href="#arbitrary-sized-integers-and-packed-structs">Arbitrary sized-integers and packed structs</a></li>
<li><a href="#generic-types-are-just-functions-at-the-type-level">Generic types are just functions at the type level</a></li>
<li><a href="#error-union-types">Error Union Types</a></li>
<li><a href="#c-interop-is-probably-the-best">C interop is probably the best</a></li>
<li><a href="#the-build-system-is-nice">The build system is nice</a></li>
</ul>
</li>
<li><a href="#what-i-like-less">What I like less</a>
<ul>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#shadowing-is-forbidden">Shadowing is forbidden</a></li>
<li><a href="#compile-time-duck-typing">Compile-time duck typing</a></li>
<li><a href="#no-typeclasses-traits">No typeclasses / traits</a></li>
<li><a href="#comptime-is-probably-not-as-interesting-as-it-looks"><code>comptime</code> is probably not as interesting as it looks</a></li>
<li><a href="#no-encapsulation">No encapsulation</a></li>
<li><a href="#memory-safety-is-highly-underestimated-and-fallacious">Memory safety is highly underestimated and fallacious</a></li>
<li><a href="#lazy-compilation-and-compilation-errors-instead-of-warnings">Lazy compilation and compilation errors instead of warnings</a></li>
<li><a href="#no-destructors">No destructors</a></li>
<li><a href="#no-unicode-strings">No (unicode) strings</a></li>
</ul>
</li>
<li><a href="#conclusion-simplicity-rhymes-with-unrestricted-power-which-rhymes-with">Conclusion: simplicity rhymes with unrestricted power, which rhymes with…</a></li>
</ul>
<!--toc:end-->
<p>Ah, <a href="https://ziglang.org/">Zig</a>. I have a love-hate relationship with this one. A “new” (reading: <em>appeared a couple years ago</em>,
already — yes, <em>already</em>), language with high ambitions. Zig was made to run at low-level, with a simple design
to solve many problems C has (macros, allocators, error handling, more powerful types like baked-in tagged
unions and bitsets, a better build system, no hidden control flow, etc.). The language claims to be the C
successor, and today, many people claim that Zig is simpler and even safer than most languages out there —
even Rust! — allowing to focus more on the technical challenges around your problem space rather
than — quoting from the Zig mantra — <em>your language knowledge</em>. I think I need to put the full mantra
because I will reuse it through this article:</p>
<blockquote>
<p>Focus on debugging your application rather than debugging your programming language knowledge.</p>
</blockquote>
<p>We will come back to that.</p>
<p>I had already <a href="https://strongly-typed-thoughts.net/blog/zig-linear-pwtp">written about Zig a while ago</a> when I
initially approached it. I thought the language was really interesting and I needed to dig deeper. That blog
article was made in July, 2024. I’m writing these lines in February, 2025. Time has passed, and yet I have been
busy rewriting some Rust code of mine in Zig, and trying out new stuff <em>not really easy or doable in Rust</em>, in
Zig, just to see the kind of power I have.</p>
<p>Today, I want to provide a more matured opinion of Zig. I need to make the obvious disclaimer that because I
mainly work in Rust — both spare-time and work — I have a bias here (and I have a long past of Haskell projects
too). Also, take notice that Zig is still in its pre-1.0 era (but heck, people still mention that <em>Bun</em>,
<em>Tigerbeetle</em>, <em>Ghostty</em> are all written in Zig, even though it hasn’t reached 1.0).</p>
<p>I split this article in two simple sections:</p>
<ul>
<li>What I like about Zig.</li>
<li>What I dislike about Zig.</li>
</ul>
<h2>What I like</h2>
<h3>Arbitrary sized-integers and packed structs</h3>
<p>Zig has many interesting properties. The first one that comes to mind is its <em>arbitrary-sized integers</em>. That
sounds weird at first, but yes, you can have the regular <code>u8</code>, <code>u16</code>, <code>u32</code> etc., but also <code>u3</code>. At first it
might sound like dark magic, but it makes sense with a good example that is actually a defect in Rust to me.</p>
<p>Consider the following code:</p>
<pre><code>struct Flags {
  bool clear_screen;
  bool reset_input;
  bool exit;
};

// …
if (flags.clear_screen || flags.reset_input) {
  // …
}
</code></pre>
<p>That is some very typical need: you want a set of flags (booleans) and depending on their state, you want to
perform some actions. Usually — at least in C, but really everyone should do it this way — we don’t represent
such flags as structs of booleans, because booleans are — most of the time — 8-bit integers. What it means is
that <code>sizeof(Flags)</code> here is <code>3</code> bytes (24 bits, 8 * 3). For 3 bits of information. So what we do instead is
to use a single byte and perform some bitwise operations to extract the bits:</p>
<pre><code>#define FLAGS_CLEAR_SCREEN 0b001
#define FLAGS_RESET_INPUT  0b010
#define FLAGS_EXIT         0b100

struct Flags {
  uint8_t bits;
};

bool Flags_contains(Flags const* flags, uint8_t bit) {
  return flags.bits &amp; bit != 0;
}

Flags Flags_set(Flags flags, uint8_t bit) {
  flags.bits |= bit;
  return flags;
}

Flags Flags_unset(Flags flags, uint8_t bit) {
  flags.bits &amp;= ~bit;
  return flags;
}
</code></pre>
<p>That is obviously very error-prone: we use CPP macros (yikes), bits are not properly typed, etc. Zig can
use its arbitrary-sized integer types and <em>packed structs</em> to automatically implement similar code:</p>
<pre><code>const Flags = packed struct {
  clear_screen: bool,
  reset_input: bool,
  exit: bool,
};
</code></pre>
<p>This structure has two <em>sizes</em>: its bit-size, and its byte-size. The bit-size represents the minimum
number of bits it uses (3), and the byte-size represents the number of bytes required to hold the type
(1). We can then use it like so:</p>
<pre><code>if (flags.clear_screen or flags.reset_input) {
  // …
}
</code></pre>
<p>This is an awesome feature, especially because lots of C libraries expect such bitfields, for instance
in the form of a <code>u32</code>. You can easily and naturally convert the <code>Flags</code> type to a <code>u32</code> with
<code>@bitCast(flags)</code> — you need to ensure the booleans are in the right order (big endianness here in Zig
if I recall correctly).</p>
<blockquote>
<p>Note: in Rust, we don’t really have a nice way to do this without requiring a dependency on
<a href="https://crates.io/crates/bitflags">bitflags</a>, which still requires you to provide the binary value of each logical boolean in binary,
usually done with <code>const</code> expressions using <code>1 &lt;&lt; n</code>..</p>
</blockquote>
<h3>Generic types are just functions at the type level</h3>
<p>As a Haskeller, this is also something that makes a lot of sense to me. A typical <code>struct Vec&lt;i32&gt;</code> in
most languages is actually a function taking a <code>type</code> and returning a <code>type</code> in Zig;
<code>fn Vec(comptime T: type) type</code>.</p>
<p>Although more verbose, it allows a lot of flexbility, without introducing a new layer specific to the type
system. For instance, specialization can be written in the most natural way:</p>
<pre><code>fn Vec(comptime T: type) type {
  if (@sizeOf(T) == 0) {
    return VecAsUsize;
  } else {
    return struct {
      // …
    };
}
</code></pre>
<p>Another use case that I think is pretty nice is when you need to implement something that depends on the actual
type structure. Zig has compile-time reflection, which means that you can analyze the fields, type information
etc. of a type to implement a specialized version of your algorithm. You can then write your JSON serializer
without depending on a middleware (e.g. in Rust, <a href="https://crates.io/crates/serde">serde</a>).</p>
<h3>Error Union Types</h3>
<p>This one is a half love / half dislike — you will find the dislike part in the appropriate section of this article.
In Zig, the core of error handling is Error Union Types. It’s straight-forward: take an <code>enum</code> (integer tags)
and glue it with a regular <code>T</code> value in a tagged union. You either get the error discriminant, or your
<code>T</code> value. In Rust terms:</p>
<pre><code>enum ErrorUnion&lt;T&gt; {
  Err(ErrorType),
  Ok(T),
}
</code></pre>
<p>There’s a catch, though. Unlike Rust, <code>ErrorType</code> is global to your whole program, and is nominally typed. Error
types are declared with the <code>error {}</code> construct:</p>
<pre><code>const MyError = error {
  FileNotFound,
  NoPermision,
};
</code></pre>
<p>Error types can be glued together to create more complex error types:</p>
<pre><code>const OtherError = error {
  OOM,
  NotANumber,
};

const AppError = MyError || OtherError;
</code></pre>
<p>Thus, an Error Union Type is <em>either an error or a value</em>, and it’s written <code>E!T</code> (<code>E</code> the error type, <code>T</code>
the value). An interesting aspect of that is that <em>all</em> error types are flat (there is no nesting), and
because they are nominal, you can even return error values without declaring them in the first place. If
you do not care about the actual type of your error, you can use the <code>anyerror</code> special type to refer to
the global error type, or leave it empty (<code>!T</code>) to infer the type based on the body of the function.</p>
<p>All of that is interesting, but one <em>very cool</em> aspect that I think I really miss when writing Rust is
coercion. Because of coercion rules, a regular value <code>T</code> coerces to <code>E!T</code>, and an error type <code>E</code> coerces to
<code>E!T</code>. So you can completely write this:</p>
<pre><code>fn foo() !i32 {
  return 3;
}
</code></pre>
<p>And the same is true for <code>void</code>:</p>
<pre><code>fn checkOrError(input: i32) !void {
  if (input &lt; 10) {
    return error.TooSmall;
  }
}
</code></pre>
<p>There is no need to wrap results in “success paths”, such as <code>Ok(())</code> in Rust.</p>
<h3>C interop is probably the best</h3>
<p>If you need to work with C libraries a lot, Zig has some really good features and built-ins baked-in,
especially if you combine them with <code>comptime</code> functions to perform various transformations automatically.</p>
<p><code>@cImport / @cInclude</code> allow to read a <code>.h</code>, parse it at compile-time, and expose its content as Zig
symbols (functions, constants, etc.), exposed in a big struct. For instance:</p>
<pre><code>const c = @cImport({
  @cInclude(&#34;GLFW/glfw3.h&#34;);
});

// c.glfwInit() is now available
</code></pre>
<p>This is honestly pretty nice, especially since you can iterate on the contents of <code>c</code> with an <code>inline for</code>
at <code>comptime</code> to transform functions the way you want.</p>
<h3>The build system is nice</h3>
<p>The build configuration of your project is written in Zig. Even though I don’t think I like <em>configuration as
code</em>, it’s still an interesting idea. It will probably feel like fresh air for
people having to use CMake or similar tools. Zig build module is not very complex to understand and allows a
great deal of flexibility when configuring your targets, optimizations, CPU architectures, ABI, CLI options,
steps and all.</p>
<p>At the current time of writing this, however, even <code>zig</code> does build and package, dependency handling is far
behind anything you might be used to (<code>cargo</code>, <code>pip</code>, <code>node</code>, <code>cabal</code>, etc.). I don’t think it would be fair
to judge it for now.</p>
<h2>What I like less</h2>
<p>Even tough Zig is full of nice surprises, it’s also full of what I would call <em>flaws</em> that — personal
opinion – make it a bad fit for robust and sound systems.</p>
<h3>Error handling</h3>
<p>As mentioned earlier, error handling in Zig is nice, but it lacks one important feature: you can’t carry
values. It’s likely due to the fact errors flow via a different path than “normal” code, and require owned
values, so in many cases it will require allocations, which is not something Zig wants on its error path.</p>
<p>It makes sense, but it’s really annoying. Something like <code>error.FileNotFound</code> will require you extra
code infrastructure to find <em>exactly which file was not found</em> — maybe you can deduce it from the caller
and match on the error via <code>catch</code> — but maybe you can’t (the path might be computed by the function
returning the error). You can’t even pass integers around in errors, since it’s already used for the
variant of the error itself.</p>
<p>Coming from Rust, obviously, that feels very weak. The <code>Result&lt;A, E&gt;</code> type — that I’ve been using in Haskell
as <code>Either e a</code> — is a godsend. Not having something like that in Zig creates frustration and will likely
generate less interesting error values, or more convoluted code infrastructure around the callers.</p>
<p>On a similar note, the <code>try</code> keyword (which takes an <code>E!A</code> expression and is equal to <code>A</code> or <code>return E;</code>,
depending on the presence of error) allows to propagate errors, but it won’t do much more than that. You can
think of <code>try foo()</code> as the same as <code>foo() catch |err| return err;</code>. That obviously works only with
error union types, so if you happen to have a function returning a <code>?A</code> (optional), you can’t shortcircuit
in a nice way with <code>try</code> and instead needs to use the more verbose <code>orelse return null;</code>. This monadic
approach is pretty powerful in Haskell and Rust, and it wouldn’t hurt much to allow it for error union
types and optionals, since both are built-ins (so you don’t get to pay for the complexity of it).</p>
<p>Another thing I dislike about <code>try</code> is that it’s a prefix keyword which chains really badly:</p>
<pre><code>try (try foo()).bar()
</code></pre>
<h3>Shadowing is forbidden</h3>
<p><em>Shadowing</em> is the act of using the same name for two different bindings available in a scope hierarchy.
Rust is an excellent example of how to do shadowing correctly. For instance, in Rust:</p>
<pre><code>fn foo(input: &amp;str) {
  // input refers to the argument and has type &amp;str

  let input = input.to_owned();
  // input refers to this function stackframe local owned string and has type String
  // we don’t have access to the argument anymore

  {
    let input = 12;
    // input is integer, and we don’t have access to the String in this block
  }

  // input is the String
}
</code></pre>
<p>This lexical scoping in Rust prevents tons of boilerplate or having to come up with useless names. Zig not
having that causes annoyances, especially with error handling:</p>
<pre><code>const foo = Foo.init();
const foo2 = try foo.addFeatureA();
const foo3 = try foo.addFeatureB();
</code></pre>
<p>This is maybe a sign of the design choice (no move semantics), but all in all, I don’t like having
to come up with either obscure names or just bad names for something that should be chained calls, or just
reusing the same name. Sometimes, naming things is something we should refrain from.</p>
<h3>Compile-time duck typing</h3>
<p>This is an important issue I have with Zig, as it’s present everywhere and implies a lot of cascaded issues.
<code>comptime</code> is not only a keyword, as you might have guessed. Take this example for instance:</p>
<pre><code>fn doMath(x: anytype) @TypeOf(x) {
  // …
}
</code></pre>
<p>There is <strong>no way</strong> to know what that function <em>requires</em> as input. The very first line of the <code>zig zen</code> states</p>
<pre><code> * Communicate intent precisely.
</code></pre>
<p>And even though I do agree with that, I think it’s poorly implemented, for two reasons:</p>
<ol>
<li>Requiring users to read the code of a function is everything but a good and precise way to communicate intent.</li>
<li>Requiring users to read the documentation is flawed by design.</li>
</ol>
<p>The second point is even violated by the standard library itself. Consider
<a href="https://ziglang.org/documentation/master/std/#std.fs.Dir.iterate">std.fs.Dir.iterate</a>, which is a function
used to iterate on a directory entries. There is no documentation at all, nor even comment, and you are left with its
implementation, which is:</p>
<pre><code>pub fn iterate(self: Dir) Iterator {
    return self.iterateImpl(true);
}
</code></pre>
<p>You can click on <a href="https://ziglang.org/documentation/master/std/#std.fs.Dir.Iterator">Iterator</a> to end up on another
documentation page with no actual documentation and a lengthy implementation. I highly suggest reading the comment
on the <code>next()</code> function:</p>
<pre><code>/// Memory such as file names referenced in this returned entry becomes invalid
/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.
</code></pre>
<p>This is <em>incredibly error-prone</em>, and the mere fact that even the standard library fails to abide by the very first
rule of <code>zig zen</code> proves the point that communicating intent precisely via documentation is hard, and probably not a
good design decision for a modern language.</p>
<p>And there is worse. As your software matures and you write more and more code, you will <em>eventually</em> change some
internals. Imagine what would happen if the documentation and/or comments go out of sync with the code. In languages
with type systems, it’s a minor annoyance — you will get angry people complaining about the fact the documentation
has typos / errors, and fixing them will be a patch release. In a language such as Zig where the documentation <em>is</em>
the contract, the source of the issue is vague and harder to understand: do they misuse the function? Is the function
buggy? Both?</p>
<h3>No typeclasses / traits</h3>
<p>Another point that I want to discuss is the lack of traits. Zig is a simple language and per-se, I guess, traits
were ruled out — and don’t <a href="https://github.com/ziglang/zig/issues/21544#issuecomment-2382542913">even think about proposing them</a>.
However, they do solve a real-world problem: programming contract. There are two important parts:</p>
<ol>
<li>
<p>Programming contracts convey useful information to the programmers. If you have a function like the <code>doMath</code>
presented above, you have no clue what you are supposed to call it with. If you have something like:</p>
<pre><code>fn do_math&lt;T&gt;(input: T) T where T: Add + Mul {
  // …
}
</code></pre>
<p>You know <em>exactly</em> what you can call it with. Additionally, you get <em>discoverability</em> — it’s super easy
to build a reverse list of implementations based off some traits — Rust does it for you in both the
docs and LSP.</p>
</li>
<li>
<p>Programming contracts are part of the public-facing side of your API. They should be items that are
versioned as the rest. If you decide to change the allowed properties of an input, just updating the
documentation will make it harder to realize you have to do a minor bump and not a patch bump.</p>
<p>Moreover, typeclasses allow for more control on the code <em>you don’t run / test</em>. If someone decides to
implement your trait for their types, having a clear interface to implement is far sounder than having
to go fishing for the programming contract in the documentation, assuming it even exists in the first
place.</p>
</li>
</ol>
<h3><code>comptime</code> is probably not as interesting as it looks</h3>
<p>I’ve been wondering a lot about this one lately. Yes, compile-time reflection is nice… but is it really?
When you think about it, implementing a JSON serializer for <code>anytype</code> is probably very unlikely to be
completely <em>true</em>. There will be hidden constraints. For instance, does it make sense to serialize a
pointer? Probably not, so the implementation might check the type info and refuse to serialize a
pointer. And — c.f. the previous section — that information is missing from the interface.</p>
<p>When you think about it, this problem is everywhere, as soon as you use <code>comptime</code>, because of the lack
of traits. If you want to understand the contracts / preconditions / postconditions / invariants… just
read the documentation… and the code, because well, you can’t be sure that the doc is not out of sync.</p>
<p><code>comptime</code> is one of those features that feel like a candy, but has a bitter taste to it. It feels like
C++ templates back again, and the community will not address that.</p>
<p>I hate the idea. After decades of programming, I can say with full certainty that besides teams with
extremely talented people that have been doing that kind of things for more than I’ve lived (old C
programmers, Linux maintainers, maybe a bunch of driver maintainers), it will only end up with tears.
I can’t in good faith suggest to use Zig at work given how complex our programming contracts are. I’m
far from being a perfect programmer — I make mistakes. We do have junior developers in our teams, work
or spare-time projects, people more or less used to our code bases and guidelines, and we are not 100%
perfect while reviewing either. Sometimes some code will be reviewed by someone else that is less severe
than you are. Sometimes it’s your future-self that will actually misuse something you thought was easy to understand. Etc.</p>
<h3>No encapsulation</h3>
<p>This is a continuation of the previous section. For a reason that I don’t understand, Zig doesn’t have
encapsulation. What it means is that if you use a type such as <code>ArrayList(i32)</code>, you <em>must</em> know how it’s
implemented to be able to get useful functions and properties, such as its <code>len</code> length. Still with the
same example, the <a href="https://ziglang.org/documentation/master/std/#std.array_list.ArrayListAligned">documentation of <code>ArrayList</code></a>
doesn’t show anything regarding the length of the array, nor even a way to iterate on its
elements. You have to know — read the code please — that what you are looking for is <code>.items.len</code> for the
length. If you want to use the <code>for</code> loop syntax, you do it on the <code>.items</code>:</p>
<pre><code>for (array.items) |item| {
  // …
}
</code></pre>
<p>Even worse, you can actually mutate the internals. How do we ensure that we can expose types to our users
without causing them to break invariants? Well, <code>zig zen</code>: communicate intent precisely, of course! Redirect
them to the code and ensure to slap <code>// INVARIANT</code> in your comments / documentation.</p>
<blockquote>
<p>Sigh…</p>
</blockquote>
<p>I’m a bit dishonest, though. Zig does have a form of access control. At the module level, you can decide
whether a symbol is private (default), or <code>pub</code>. That’s all you get.</p>
<p>In essence, this is similar to C.</p>
<h3>Memory safety is highly underestimated and fallacious</h3>
<p>I read in numerous places that Zig is safer than <code>unsafe</code> Rust, which is not true, and fallacious.
Andrew Kelley <a href="https://andrewkelley.me/post/unsafe-zig-safer-than-unsafe-rust.html">wrote a blog article</a>
where he built his argumentation on the fact that Rust will compile and will run into UB, while Zig won’t.
Here’s the Rust code:</p>
<pre><code>struct Foo {
    a: i32,
    b: i32,
}

fn main() {
    unsafe {
        let mut array: [u8; 1024] = [1; 1024];
        let foo = std::mem::transmute::&lt;&amp;mut u8, &amp;mut Foo&gt;(&amp;mut array[0]);
        foo.a += 1;
    }
}
</code></pre>
<p>The first thing to say is that there is indeed a UB, and it’s not easy to spot; transmuting a <code>&amp;mut u8</code> to
<code>&amp;mut Foo</code> is the same as casting an aligned pointer to an unaligned pointer, which is indeed UB. Back when
he wrote his article, I’m not sure he knew about <a href="https://github.com/rust-lang/miri">miri</a> — which has been around since
<a href="https://github.com/rust-lang/rust/pull/45002">October 2017</a> — given that his article was released in 2018,
but even then, I think it’s important to draw people’s attention to something important here. Zig does have
this unaligned pointer cast detection by default, but you’re just one <code>rustup components add miri</code> call away:</p>
<pre><code>cargo miri run
…
error: Undefined Behavior: constructing invalid value: encountered an unaligned reference (required 4 byte alignment but found 1)
 --&gt; src/main.rs:9:19
  |
9 |         let foo = std::mem::transmute::&lt;&amp;mut u8, &amp;mut Foo&gt;(&amp;mut array[0]);
  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 4 byte alignment but found 1)
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:9:19: 9:74

note: some details are omitted, run with `miriFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted
</code></pre>
<p>It would have been nice to point that out. Yes, Zig has it by default, but Rust has it too by adding a tool
that is available via <code>rustup</code>. I do have to agree that <code>unsafe</code> Rust is probably harder to write than
regular Zig, because of all the rules you have to manually ensure not to violate (stacked borrows, etc.), and
for 90% of the time, what you will be doing will be to call a C function via the FFI, so you should be fine.
For more complicated <code>unsafe</code> usage, just use <a href="https://github.com/rust-lang/miri">miri</a>. Actually, I think it should be a good practice to use
<a href="https://github.com/rust-lang/miri">miri</a>, at least in the CI.</p>
<p>I could understand Andrew missed that when he wrote his article (hm…). But today? People still mention that
Zig is <em>sooooo</em> much safer than Rust.</p>
<p>So let’s see how Zig is safer now. Up to this day, Zig doesn’t see Use After Free (UAF). Not at compile-time. Not at
runtime. They are just plain Undefined Behavior (UB). For instance:</p>
<pre><code>const std = @import(&#34;std&#34;);

fn getPtr(value: i32) *i32 {
    var x = value;
    x += 1;
    return &amp;x;
}

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();

    const ptr = getPtr(123);
    try stdout.print(&#34;ptr.* = {d}\n&#34;, .{ptr.*});

    ptr.* += 10;
    try stdout.print(&#34;ptr.* = {d}\n&#34;, .{ptr.*});
}
</code></pre>
<p>If you compile this with the default optimization option (<code>Debug</code>), you get this:</p>
<pre><code>$ zig build run
ptr.* = 124
ptr.* = 134
</code></pre>
<p>If you compile with <code>ReleaseFast</code>:</p>
<pre><code>$ zig build -Doptimize=ReleaseFast run
ptr.* = 0
ptr.* = 0
</code></pre>
<p><em>Oh le malaise</em>. This, here; this exact situation is the main reason why I refrain myself from using Zig
in production. The idea that I could end up in such a situation <em>and not even knowing about it</em>. There
are discussions to track all possible UB and turn them into <a href="https://github.com/ziglang/zig/issues/2301">checked illegal behavior</a>.
That issue has been opened since 2019. I’m not saying it won’t ever be a thing — I guess it’s required
to hit 1.0. <em>But still</em>. The language cannot in good faith state that it’s safer than <code>unsafe</code> Rust. Let’s
convert that code to Rust and run miri on it…</p>
<blockquote>
<p>I would <em>obviously</em> never suggest to use raw pointers but instead references, but references will trigger
a compilation error so it’s not really fair for this comparison, and the Zig community always compares it
to <code>unsafe</code> Rust, so let’s get unsafe!</p>
</blockquote>
<pre><code>fn get_ptr(input: i32) -&gt; *mut i32 {
    let mut value = input;
    value += 1;
    &amp;mut value as *mut _
}

fn main() {
    unsafe {
        let ptr = get_ptr(123);
        println!(&#34;*ptr = {}&#34;, *ptr);

        *ptr += 10;
        println!(&#34;*ptr = {}&#34;, *ptr);
    }
}
</code></pre>
<p>Running miri:</p>
<pre><code>error: Undefined Behavior: out-of-bounds pointer use: alloc565 has been freed, so this pointer is dangling
  --&gt; src/main.rs:10:31
   |
10 |         println!(&#34;*ptr = {}&#34;, *ptr);
   |                               ^^^^ out-of-bounds pointer use: alloc565 has been freed, so this pointer is dangling
   |
   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
help: alloc565 was allocated here:
  --&gt; src/main.rs:2:9
   |
2  |     let mut value = input;
   |         ^^^^^^^^^
help: alloc565 was deallocated here:
  --&gt; src/main.rs:5:1
   |
5  | }
   | ^
   = note: BACKTRACE (of the first span):
   = note: inside `main` at src/main.rs:10:31: 10:35
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>The message has some weird mentions in (<code>alloc565</code>), but the actual useful information is there: a pointer is
dangling.</p>
<p>So no, I strongly disagree that Zig is safer than — even — <code>unsafe</code> Rust. Anyone telling you otherwise is
either purposefully lying, or ignorant. And I think I need to mention the misconception that you need to
drop to <code>unsafe</code> often in Rust. This is simply not true. Some libraries — especially interfacing with C
libraries — do use <code>unsafe</code> to make FFI calls (usually, they just do that). <code>unsafe</code> might be required for
some very specific tricks required to implement safer abstractions, but you are not supposed to write a full
library or application in <code>unsafe</code>.</p>
<blockquote>
<p>Just test your software correctly!</p>
</blockquote>
<p>Again that argument… UB cannot be tested and requires statical analysis — or some kind of runtime protections
that is currently not implemented in Zig — and coverage in a langage that is built off lazy compilation everywhere
is probably not something I will discuss here…</p>
<h3>Lazy compilation and compilation errors instead of warnings</h3>
<p>Heck, I thought I would dodge this one. So… yeah… this is a bit embarrassing, but Zig implements lazy compilation.
The idea is that you write code, and it doesn’t compile it. That sounds so <em>exotic</em> that the standard library
has a helper function to mitigate that weird design decision (<a href="https://ziglang.org/documentation/master/std/#std.testing.refAllDecls"><code>std.testing.refAllDecls</code></a>).
You must use it in a <em>very natural way</em>:</p>
<pre><code>test {
  std.testing.refAllDecls(some_module_of_yours);
}
</code></pre>
<p>It’s a common idiom I have seen in many places (Ghostty <a href="https://github.com/ghostty-org/ghostty/blob/f0d276062b78658fc1f3857e9ea104788f1f4e58/src/cli.zig#L10">1</a>
<a href="https://github.com/ghostty-org/ghostty/blob/f0d276062b78658fc1f3857e9ea104788f1f4e58/src/input.zig#L38">2</a> <a href="https://github.com/ghostty-org/ghostty/blob/f0d276062b78658fc1f3857e9ea104788f1f4e58/src/termio/message.zig#L192">3</a>
<a href="https://github.com/ghostty-org/ghostty/blob/f0d276062b78658fc1f3857e9ea104788f1f4e58/src/crash/minidump/stream.zig#L29">4</a>; TigerBeetle
<a href="https://github.com/tigerbeetle/tigerbeetle/blob/d6eff0f84b76ea40ef1898778e7594a319c46698/src/lsm/forest_table_iterator.zig#L199">1</a> <a href="https://github.com/tigerbeetle/tigerbeetle/blob/d6eff0f84b76ea40ef1898778e7594a319c46698/src/lsm/groove.zig#L1505-L1507">2</a>;
vulkan-zig <a href="https://github.com/Snektron/vulkan-zig/blob/1fd5a6e217dfcc7e4406d449924a1feb1ecffbb9/test/ref_all_decls.zig#L101-L122">hmm</a>).</p>
<p>So… if everyone really mitigates this <em>“feature”</em>… was it really worth it? In the end, it makes sense not to
include code that is not participating in the final binary, but… have you thought about refactoring? Have you
thought about systems that add code that will be used <em>later</em>? That happens a lot and I was bitten so many
times while writing some disjoint sections of code and having to spend much more time later when gluing
everything together — <em>because the code was actually never checked</em>!</p>
<p>And there is the opposite problem. Zig makes some assumptions on what is important, so obviously, a parameter of
a function that is not used should be a hard error. It lazy-checks functions you wrote and ignores them if you
don’t use them right away, but refuses to compile arguments you ignore?! I mean, I get <em>why</em> (not using an
argument could hide a bug), but a warning would suffice.</p>
<blockquote>
<p>I haven’t found a way to disable that linter and make it a warning, and I think it’s unlikely to ever happen.</p>
</blockquote>
<h3>No destructors</h3>
<p>This one <em>I could get</em>, but not implemented the way it is. Zig doesn’t have any sound way to ensure proper
resource management — just like C. See the previous section about communicating intent properly. Zig <em>requires</em>
the call site to deallocate properly, and you have to mention the deinit logic in your documentation.</p>
<p><code>defer</code> – and <code>errdefer</code>, which is for a different usecase, but it’s not really important here — is a tool you
<em>can</em> use at call site to implement resource cleanup, whether it’s memory deallocation or file descriptors close.
The concept has been around for a long time, and as mentioned in the previous sentence, it’s not automatic. The
caller <em>must know</em> that they have to call <code>defer</code>. The documentation <em>might</em> forget to mention it and the user
<em>might</em> forget to call it. On memory cleanup, if you are lucky and your tests run that code, you will get a traced
leak. For more complex resources such as GPU queues, database handles, etc., well, it’s probably a leaked file
descriptor?</p>
<p>I’m not entirely sure whether destructors are the best solution to this problem, but they allow to ensure that
the code calls the cleanup routine. There are alternatives — explored in <a href="https://www.cs.bu.edu/~hwxi/atslangweb/">ATS</a>, probably too complex
for now, requiring linear types and/or proofs to force the caller to get rid of the resource — Rust <em>could have</em>
something along those lines, since it has move semantics and an affine type system; I don’t think people will
trade <code>Drop</code> for linear types though.</p>
<p>It’s a bit a pity, to be honest, to see such a design in Zig, because it does have the infrastructure to do
better in my humble opinion. For instance, this won’t compile:</p>
<pre><code>fn foo() i32 { return 123; }

// …
pub fn main() !void {
  foo();
}
</code></pre>
<p>Because the return value of <code>foo</code> is ignored. To make that compile, you need to explicitly ignore the
returned value:</p>
<pre><code>pub fn main() !void {
  _ = foo();
}
</code></pre>
<p>So it’s a bit weird to see that Zig can prevent compilation if you do not use an argument or the returned
value of a function, but doesn’t provide the proper tooling to force the user to correctly deinit
resources. If you pull the problem a bit more, it shows that the design of Zig — in its current state —
doesn’t permit that, since you would need linear types/values (i.e. a value <em>must</em> be used once and only
once). I would have loved something like a <code>#</code> linear marker that would cause a linear resource to be dangling
if it’s not eventually consumed by a function taking it with the marker as argument:</p>
<pre><code>const Resource = struct {
  …

  pub fn init() #Resource {
    …
  }

  pub fn deinit(r: #Resource) {
  }
};
</code></pre>
<p>Obviously, as soon as you see that, it causes issues with the Zig type system, because you can still bit-copy
values, so you duplicate a resource and might cause double-frees — but copying should be disallowed in a linear
type system. So Zig cannot have linear types/values without changing <em>all</em> the properties of such types, and
purely linear values are often not enough; we eventually want to <em>weaken</em> the restriction (relevant type system)
to be able to use the resource value in a controlled way, via, for instance, borrowing. Which leads to more
complexity in the language, so clearly not something we will ever see in Zig.</p>
<h3>No (unicode) strings</h3>
<p>The standard library doesn’t have a good support for unicode strings. There is a discussion opened by
<a href="https://drewdevault.com/">Drew DeVault</a> about <a href="https://github.com/ziglang/zig/issues/234">improving strings and unicode handling</a>.
I share the link so that you make your own opinion about what to think of all that, but not having a
string type and recommending users to “iterate on bytes” is a big no to me. It’s the open door to a wide variety
of issues / corrupted data. People in the thread even recommend using <code>.len</code> on <code>[]u8</code> to get length of strings
(never do that, unless you are doing <a href="https://adventofcode.com/">Advent of Code</a>).</p>
<p>It <a href="https://github.com/ziglang/zig/issues/7734#issuecomment-758167124">will never happen</a>, whatever your arguments.
You are left with user-land support, such as <a href="https://codeberg.org/atman/zg">zg</a>.</p>
<h2>Conclusion: simplicity rhymes with unrestricted power, which rhymes with…</h2>
<p><img src="https://strongly-typed-thoughts.net/media/uploads/footguns_everywhere.jpg" alt=""/></p>
<p>I get it. Zig has the ambition to replace C, and as such, doesn’t want to have to deal with complex abstractions.
It trades memory safety and soundness for simplicity. If I’ve been around Zig and actually writing Zig code that
much, it’s because I wanted to check whether
<a href="https://steveklabnik.com/writing/memory-safety-is-a-red-herring">memory safety is a red herring</a> myself. In the
end, maybe Zig is right. Maybe we can achieve <em>enough</em> with a simple language, and deal with the remaining issues
with other approaches. There is nothing wrong with that.</p>
<p><em>However</em>, I think it’s too soon to make any useful conclusion. I really want to have a look at reports about
projects that are entirely written in Zig (Ghostty, TigerBeetle, etc.) after they have matured enough. It’s great
that those projects are successful with Zig; I’m honestly happy for them. But a robust and scientific approach
requires us to go further than just assumptions and feelings. I do think we have data about CVE issues (we
all know the <a href="https://www.chromium.org/Home/chromium-security/memory-safety/">70% number</a>, right?), and it took time and lots of software history to have enough hindsight. I do
think that hindsight is required on Zig to know whether it’s actually contributing to more reliable software. Very
personal opinion: given all the points I mentioned, I really doubt it.</p>
<p>I don’t think that <em>simplicity</em> is a good vector of reliable software. At most, it’s a happy side-effect. It’s
not a requirement, and should remain a secondary mission. What the industry needs is to identify problems (we have)
and designs solutions that solve those problems. Anyone has the right to select a subset of those problems (even Rust
can’t solve everything) and solve those specifically, ignoring the others or pushing their resolution to
user-land / process etc. But here, I think there is a big misconception.</p>
<p>Zig does enhance on C, there is no doubt. I would rather write Zig than C. The design is better, more modern, and
the language is safer. But why stop half way? Why fix <em>some</em> problems and ignore the most damaging ones?</p>
<p>Remember the introduction:</p>
<blockquote>
<p>Focus on debugging your application rather than debugging your programming language knowledge.</p>
</blockquote>
<p>Do you see why this is such a poignant take? Is it really better to spend time in <code>gdb</code> / whatever debugger
you are using, or having your users opening bug issues than having to spend a bit more time reading compiler
error messages? That mantra seems to make it like it’s a bad thing to have a compiler yell at you because you
are <em>very likely</em> doing something you don’t really intend to. Why? It’s a well known fact that bugs don’t
write themselves. At some point, a developer wrote some code <em>expressing</em> a solution that was, in fact,
<em>actually written</em> a different way, in dissonance with the initial intent. This is part of being a human. So
why would you complain that a compiler tells you that what you are doing is very likely wrong? Because in a
few instances, it was unable to see that what you were doing was, actually, fine? You base a full language
experience based solely on some exceptional occurrences / issues? And trust me, I also do have those moments
with Rust from time to time (especially with the lack of view types and partial mutable borrows).</p>
<p>Seeking <em>simple</em> is just not the right move to me. To me, a more robust approach is ensuring people can’t shoot
themselves, while seeking <em>simpler</em>. Simpler doesn’t mean <em>simple</em>; it means that you design a solution,
whatever the complexity, and tries to make it as simple <em>as possible</em>. Rust is honestly not that hard, but it is
definitely not a simple language. However, for all the problems it solves at compile-time, it’s definitely simpler
than all other approaches (e.g. <a href="https://www.cs.bu.edu/~hwxi/atslangweb/">ATS</a>). And it’s not unlikely that it will get simpler and simpler as we discover
new ways of expressing language constructs.</p>
<p>I think my adventure with Zig stops here. I have had too frustration regarding correctness and reliability
concerns. Where people see simplicity as a building block for a more approachable and safe-enough language, I see
simplicity as an excuse not to tackle hard and damaging problems and causing unacceptable tradeoffs. I’m also
fed up of the <em>skill issue</em> culture. If Zig requires programmers to be flawless, well, I’m probably not a good
fit for the role.</p>


  <hr/>

	<div>
    <p><a href="https://strongly-typed-thoughts.net/blog/zig-2025">
      ↑ My second opinion on Zig
    </a></p><p><em>zig</em>
    </p>

    <p>
      Wed Feb  5 00:25:00 2025 UTC
    </p>
	</div>
</section></div>
  </body>
</html>
