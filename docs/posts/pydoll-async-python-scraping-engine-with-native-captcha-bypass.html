<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/autoscrape-labs/pydoll">Original</a>
    <h1>Show HN: PyDoll â€“ Async Python scraping engine with native CAPTCHA bypass</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/101291018/452653415-219f2dbc-37ed-4aea-a289-ba39cdbb335d.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDk1ODMyMDMsIm5iZiI6MTc0OTU4MjkwMywicGF0aCI6Ii8xMDEyOTEwMTgvNDUyNjUzNDE1LTIxOWYyZGJjLTM3ZWQtNGFlYS1hMjg5LWJhMzljZGJiMzM1ZC5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjEwJTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYxMFQxOTE1MDNaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT01N2I5MzE1YmI3ZTExYzE1YTk5MjcwMWE2YTYwYzAzOWFiNGUyODgxZGMyMDlhNjg5N2FiYjE0NTdhYTIxNTgwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.NLPuNuamNDrpj7t1DMCklfvJVveLYmIG3SsK-dms3_U"><img src="https://private-user-images.githubusercontent.com/101291018/452653415-219f2dbc-37ed-4aea-a289-ba39cdbb335d.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDk1ODMyMDMsIm5iZiI6MTc0OTU4MjkwMywicGF0aCI6Ii8xMDEyOTEwMTgvNDUyNjUzNDE1LTIxOWYyZGJjLTM3ZWQtNGFlYS1hMjg5LWJhMzljZGJiMzM1ZC5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNjEwJTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDYxMFQxOTE1MDNaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT01N2I5MzE1YmI3ZTExYzE1YTk5MjcwMWE2YTYwYzAzOWFiNGUyODgxZGMyMDlhNjg5N2FiYjE0NTdhYTIxNTgwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.NLPuNuamNDrpj7t1DMCklfvJVveLYmIG3SsK-dms3_U" alt="Pydoll Logo"/></a> </p>
<p dir="auto">
    <a href="https://codecov.io/gh/autoscrape-labs/pydoll" rel="nofollow">
        <img src="https://camo.githubusercontent.com/89a01b6336655dc81749f71323b9a8b741d16d0b4b664a8864c90ab6f61e863b/68747470733a2f2f636f6465636f762e696f2f67682f6175746f7363726170652d6c6162732f7079646f6c6c2f67726170682f62616467652e7376673f746f6b656e3d3430493933384f474d39" data-canonical-src="https://codecov.io/gh/autoscrape-labs/pydoll/graph/badge.svg?token=40I938OGM9"/> 
    </a>
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/thalissonvs/pydoll/actions/workflows/tests.yml/badge.svg"><img src="https://github.com/thalissonvs/pydoll/actions/workflows/tests.yml/badge.svg" alt="Tests"/></a>
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/thalissonvs/pydoll/actions/workflows/ruff-ci.yml/badge.svg"><img src="https://github.com/thalissonvs/pydoll/actions/workflows/ruff-ci.yml/badge.svg" alt="Ruff CI"/></a>
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/thalissonvs/pydoll/actions/workflows/release.yml/badge.svg"><img src="https://github.com/thalissonvs/pydoll/actions/workflows/release.yml/badge.svg" alt="Release"/></a>
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/thalissonvs/pydoll/actions/workflows/mypy.yml/badge.svg"><img src="https://github.com/thalissonvs/pydoll/actions/workflows/mypy.yml/badge.svg" alt="MyPy CI"/></a>
    <a href="https://deepwiki.com/autoscrape-labs/pydoll" rel="nofollow"><img src="https://camo.githubusercontent.com/e7d4bb1a32530e373bb53fbe8eea825440ad27c7531d8f144d561acdd20c093a/68747470733a2f2f6465657077696b692e636f6d2f62616467652e737667" alt="Ask DeepWiki" data-canonical-src="https://deepwiki.com/badge.svg"/></a>
</p>
<p dir="auto">
  <a href="https://autoscrape-labs.github.io/pydoll/" rel="nofollow">Documentation</a> â€¢
  <a href="#getting-started">Getting Started</a> â€¢
  <a href="#advanced-features">Advanced Features</a> â€¢
  <a href="#contributing">Contributing</a> â€¢
  <a href="#support-my-work">Support</a> â€¢
  <a href="#license">License</a>
</p>

<p dir="auto">ðŸ”¹ <strong>Zero Webdrivers!</strong> Say goodbye to webdriver compatibility nightmares</p>

<p dir="auto">Picture this: you need to automate browser tasks. Maybe it&#39;s testing your web application, scraping data from websites, or automating repetitive processes. Traditionally, this meant dealing with external drivers, complex configurations, and a host of compatibility issues that seemed to appear out of nowhere.</p>
<p dir="auto">But there&#39;s another challenge that&#39;s even more frustrating: <strong>modern web protection systems</strong>. Cloudflare Turnstile captchas, reCAPTCHA v3, and sophisticated bot detection algorithms that can instantly identify and block traditional automation tools. Your perfectly written automation script fails not because of bugs, but because websites can tell it&#39;s not human.</p>
<p dir="auto"><strong>Pydoll was born to change that.</strong></p>
<p dir="auto">Built from the ground up with a different philosophy, Pydoll connects directly to the Chrome DevTools Protocol (CDP), eliminating the need for external drivers entirely. More importantly, it incorporates advanced human behavior simulation and intelligent captcha bypass capabilities that make your automations virtually indistinguishable from real human interactions.</p>
<p dir="auto">We believe that powerful automation shouldn&#39;t require you to become a configuration expert or constantly battle with anti-bot systems. With Pydoll, you focus on what matters: your automation logic, not the underlying complexity or protection bypassing.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">What Makes Pydoll Special</h2><a id="user-content-what-makes-pydoll-special" aria-label="Permalink: What Makes Pydoll Special" href="#what-makes-pydoll-special"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>
<p dir="auto"><strong>Intelligent Captcha Bypass</strong>: Built-in automatic solving for Cloudflare Turnstile and reCAPTCHA v3 captchas without external services, API keys, or complex configurations. Your automations continue seamlessly even when encountering protection systems.</p>
</li>
<li>
<p dir="auto"><strong>Truly Human Interactions</strong>: Advanced algorithms simulate authentic human behavior patterns - from realistic timing between actions to natural mouse movements, scroll patterns, and typing rhythms that fool even sophisticated bot detection systems.</p>
</li>
<li>
<p dir="auto"><strong>Genuine Simplicity</strong>: We don&#39;t want you wasting time configuring drivers or dealing with compatibility issues. With Pydoll, you install and you&#39;re ready to automate, even on protected sites.</p>
</li>
<li>
<p dir="auto"><strong>Native Async Performance</strong>: Built from the ground up with <code>asyncio</code>, Pydoll doesn&#39;t just support asynchronous operations - it was designed for them, enabling concurrent processing of multiple protected sites.</p>
</li>
<li>
<p dir="auto"><strong>Powerful Network Monitoring</strong>: Intercept, modify, and analyze all network traffic with ease, giving you complete control over requests and responses - perfect for bypassing additional protection layers.</p>
</li>
<li>
<p dir="auto"><strong>Event-Driven Architecture</strong>: React to page events, network requests, and user interactions in real-time, enabling sophisticated automation flows that adapt to dynamic protection systems.</p>
</li>
<li>
<p dir="auto"><strong>Intuitive Element Finding</strong>: Modern <code>find()</code> and <code>query()</code> methods that make sense and work as you&#39;d expect, even with dynamically loaded content from protection systems.</p>
</li>
<li>
<p dir="auto"><strong>Robust Type Safety</strong>: Comprehensive type system for better IDE support and error prevention in complex automation scenarios.</p>
</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="pip install pydoll-python"><pre>pip install pydoll-python</pre></div>
<p dir="auto">That&#39;s it. No drivers to download, no complex configurations. Just install and start automating.</p>


<p dir="auto">Let&#39;s start with something simple. The code below opens a browser, navigates to a website, and interacts with elements:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser import Chrome

async def my_first_automation():
    # Create a browser instance
    async with Chrome() as browser:
        # Start the browser and get a tab
        tab = await browser.start()
        
        # Navigate to a website
        await tab.go_to(&#39;https://example.com&#39;)
        
        # Find elements intuitively
        button = await tab.find(tag_name=&#39;button&#39;, class_name=&#39;submit&#39;)
        await button.click()
        
        # Or use CSS selectors/XPath directly
        link = await tab.query(&#39;a[href*=&#34;contact&#34;]&#39;)
        await link.click()

# Run the automation
asyncio.run(my_first_automation())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>

<span>async</span> <span>def</span> <span>my_first_automation</span>():
    <span># Create a browser instance</span>
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span># Start the browser and get a tab</span>
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        
        <span># Navigate to a website</span>
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://example.com&#39;</span>)
        
        <span># Find elements intuitively</span>
        <span>button</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;button&#39;</span>, <span>class_name</span><span>=</span><span>&#39;submit&#39;</span>)
        <span>await</span> <span>button</span>.<span>click</span>()
        
        <span># Or use CSS selectors/XPath directly</span>
        <span>link</span> <span>=</span> <span>await</span> <span>tab</span>.<span>query</span>(<span>&#39;a[href*=&#34;contact&#34;]&#39;</span>)
        <span>await</span> <span>link</span>.<span>click</span>()

<span># Run the automation</span>
<span>asyncio</span>.<span>run</span>(<span>my_first_automation</span>())</pre></div>

<p dir="auto">Sometimes you need more control. Pydoll offers flexible configuration options:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from pydoll.browser import Chrome
from pydoll.browser.options import ChromiumOptions

async def custom_automation():
    # Configure browser options
    options = ChromiumOptions()
    options.add_argument(&#39;--proxy-server=username:password@ip:port&#39;)
    options.add_argument(&#39;--window-size=1920,1080&#39;)
    options.add_argument(&#39;--disable-web-security&#39;)
    options.binary_location = &#39;/path/to/your/browser&#39;

    async with Chrome(options=options) as browser:
        tab = await browser.start()
        
        # Your automation code here
        await tab.go_to(&#39;https://example.com&#39;)
        
        # The browser is now using your custom settings

asyncio.run(custom_automation())"><pre><span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>
<span>from</span> <span>pydoll</span>.<span>browser</span>.<span>options</span> <span>import</span> <span>ChromiumOptions</span>

<span>async</span> <span>def</span> <span>custom_automation</span>():
    <span># Configure browser options</span>
    <span>options</span> <span>=</span> <span>ChromiumOptions</span>()
    <span>options</span>.<span>add_argument</span>(<span>&#39;--proxy-server=username:password@ip:port&#39;</span>)
    <span>options</span>.<span>add_argument</span>(<span>&#39;--window-size=1920,1080&#39;</span>)
    <span>options</span>.<span>add_argument</span>(<span>&#39;--disable-web-security&#39;</span>)
    <span>options</span>.<span>binary_location</span> <span>=</span> <span>&#39;/path/to/your/browser&#39;</span>

    <span>async</span> <span>with</span> <span>Chrome</span>(<span>options</span><span>=</span><span>options</span>) <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        
        <span># Your automation code here</span>
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://example.com&#39;</span>)
        
        <span># The browser is now using your custom settings</span>

<span>asyncio</span>.<span>run</span>(<span>custom_automation</span>())</pre></div>

<div dir="auto"><h3 tabindex="-1" dir="auto">Intelligent Captcha Bypass</h3><a id="user-content-intelligent-captcha-bypass" aria-label="Permalink: Intelligent Captcha Bypass" href="#intelligent-captcha-bypass"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">One of Pydoll&#39;s most revolutionary features is its ability to automatically handle modern captcha systems that typically block automation tools. This isn&#39;t just about solving captchas - it&#39;s about making your automations completely transparent to protection systems.</p>
<p dir="auto"><strong>Supported Captcha Types:</strong></p>
<ul dir="auto">
<li><strong>Cloudflare Turnstile</strong> - The modern replacement for reCAPTCHA</li>
<li><strong>reCAPTCHA v3</strong> - Google&#39;s invisible captcha system</li>
<li><strong>Custom implementations</strong> - Extensible framework for new captcha types</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser import Chrome

async def advanced_captcha_bypass():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Method 1: Context manager (waits for captcha completion)
        async with tab.expect_and_bypass_cloudflare_captcha():
            await tab.go_to(&#39;https://site-with-cloudflare.com&#39;)
            print(&#34;Cloudflare Turnstile automatically solved!&#34;)
            
            # Continue with your automation - captcha is handled
            await tab.find(id=&#39;username&#39;).type_text(&#39;user@example.com&#39;)
            await tab.find(id=&#39;password&#39;).type_text(&#39;password123&#39;)
            await tab.find(tag_name=&#39;button&#39;, text=&#39;Login&#39;).click()
        
        # Method 2: Background processing (non-blocking)
        await tab.enable_auto_solve_cloudflare_captcha()
        await tab.go_to(&#39;https://another-protected-site.com&#39;)
        # Captcha solved automatically in background while code continues
        
        # Method 3: Custom captcha selector for specific implementations
        await tab.enable_auto_solve_cloudflare_captcha(
            custom_selector=(By.CLASS_NAME, &#39;custom-captcha-widget&#39;),
            time_before_click=3,  # Wait 3 seconds before solving
            time_to_wait_captcha=10  # Timeout after 10 seconds
        )
        
        await tab.disable_auto_solve_cloudflare_captcha()

asyncio.run(advanced_captcha_bypass())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>

<span>async</span> <span>def</span> <span>advanced_captcha_bypass</span>():
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        
        <span># Method 1: Context manager (waits for captcha completion)</span>
        <span>async</span> <span>with</span> <span>tab</span>.<span>expect_and_bypass_cloudflare_captcha</span>():
            <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://site-with-cloudflare.com&#39;</span>)
            <span>print</span>(<span>&#34;Cloudflare Turnstile automatically solved!&#34;</span>)
            
            <span># Continue with your automation - captcha is handled</span>
            <span>await</span> <span>tab</span>.<span>find</span>(<span>id</span><span>=</span><span>&#39;username&#39;</span>).<span>type_text</span>(<span>&#39;user@example.com&#39;</span>)
            <span>await</span> <span>tab</span>.<span>find</span>(<span>id</span><span>=</span><span>&#39;password&#39;</span>).<span>type_text</span>(<span>&#39;password123&#39;</span>)
            <span>await</span> <span>tab</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;button&#39;</span>, <span>text</span><span>=</span><span>&#39;Login&#39;</span>).<span>click</span>()
        
        <span># Method 2: Background processing (non-blocking)</span>
        <span>await</span> <span>tab</span>.<span>enable_auto_solve_cloudflare_captcha</span>()
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://another-protected-site.com&#39;</span>)
        <span># Captcha solved automatically in background while code continues</span>
        
        <span># Method 3: Custom captcha selector for specific implementations</span>
        <span>await</span> <span>tab</span>.<span>enable_auto_solve_cloudflare_captcha</span>(
            <span>custom_selector</span><span>=</span>(<span>By</span>.<span>CLASS_NAME</span>, <span>&#39;custom-captcha-widget&#39;</span>),
            <span>time_before_click</span><span>=</span><span>3</span>,  <span># Wait 3 seconds before solving</span>
            <span>time_to_wait_captcha</span><span>=</span><span>10</span>  <span># Timeout after 10 seconds</span>
        )
        
        <span>await</span> <span>tab</span>.<span>disable_auto_solve_cloudflare_captcha</span>()

<span>asyncio</span>.<span>run</span>(<span>advanced_captcha_bypass</span>())</pre></div>

<p dir="auto">Pydoll offers multiple intuitive ways to find elements. No matter how you prefer to work, we have an approach that makes sense for you:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser import Chrome

async def element_finding_examples():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to(&#39;https://example.com&#39;)
        
        # Find by attributes (most intuitive)
        submit_btn = await tab.find(
            tag_name=&#39;button&#39;,
            class_name=&#39;btn-primary&#39;,
            text=&#39;Submit&#39;
        )
        
        # Find by ID
        username_field = await tab.find(id=&#39;username&#39;)
        
        # Find multiple elements
        all_links = await tab.find(tag_name=&#39;a&#39;, find_all=True)
        
        # CSS selectors and XPath
        nav_menu = await tab.query(&#39;nav.main-menu&#39;)
        specific_item = await tab.query(&#39;//div[@data-testid=&#34;item-123&#34;]&#39;)
        
        # With timeout and error handling
        delayed_element = await tab.find(
            class_name=&#39;dynamic-content&#39;,
            timeout=10,
            raise_exc=False  # Returns None if not found
        )
        
        # Advanced: Custom attributes
        custom_element = await tab.find(
            data_testid=&#39;submit-button&#39;,
            aria_label=&#39;Submit form&#39;
        )

asyncio.run(element_finding_examples())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>

<span>async</span> <span>def</span> <span>element_finding_examples</span>():
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://example.com&#39;</span>)
        
        <span># Find by attributes (most intuitive)</span>
        <span>submit_btn</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(
            <span>tag_name</span><span>=</span><span>&#39;button&#39;</span>,
            <span>class_name</span><span>=</span><span>&#39;btn-primary&#39;</span>,
            <span>text</span><span>=</span><span>&#39;Submit&#39;</span>
        )
        
        <span># Find by ID</span>
        <span>username_field</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(<span>id</span><span>=</span><span>&#39;username&#39;</span>)
        
        <span># Find multiple elements</span>
        <span>all_links</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;a&#39;</span>, <span>find_all</span><span>=</span><span>True</span>)
        
        <span># CSS selectors and XPath</span>
        <span>nav_menu</span> <span>=</span> <span>await</span> <span>tab</span>.<span>query</span>(<span>&#39;nav.main-menu&#39;</span>)
        <span>specific_item</span> <span>=</span> <span>await</span> <span>tab</span>.<span>query</span>(<span>&#39;//div[@data-testid=&#34;item-123&#34;]&#39;</span>)
        
        <span># With timeout and error handling</span>
        <span>delayed_element</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(
            <span>class_name</span><span>=</span><span>&#39;dynamic-content&#39;</span>,
            <span>timeout</span><span>=</span><span>10</span>,
            <span>raise_exc</span><span>=</span><span>False</span>  <span># Returns None if not found</span>
        )
        
        <span># Advanced: Custom attributes</span>
        <span>custom_element</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(
            <span>data_testid</span><span>=</span><span>&#39;submit-button&#39;</span>,
            <span>aria_label</span><span>=</span><span>&#39;Submit form&#39;</span>
        )

<span>asyncio</span>.<span>run</span>(<span>element_finding_examples</span>())</pre></div>

<p dir="auto">One of the great advantages of Pydoll&#39;s asynchronous design is the ability to process multiple tasks simultaneously:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser import Chrome

async def scrape_page(url):
    &#34;&#34;&#34;Extract data from a single page&#34;&#34;&#34;
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to(url)
        
        title = await tab.execute_script(&#39;return document.title&#39;)
        links = await tab.find(tag_name=&#39;a&#39;, find_all=True)
        
        return {
            &#39;url&#39;: url,
            &#39;title&#39;: title,
            &#39;link_count&#39;: len(links)
        }

async def concurrent_scraping():
    urls = [
        &#39;https://example1.com&#39;,
        &#39;https://example2.com&#39;,
        &#39;https://example3.com&#39;
    ]
    
    # Process all URLs simultaneously
    tasks = [scrape_page(url) for url in urls]
    results = await asyncio.gather(*tasks)
    
    for result in results:
        print(f&#34;{result[&#39;url&#39;]}: {result[&#39;title&#39;]} ({result[&#39;link_count&#39;]} links)&#34;)

asyncio.run(concurrent_scraping())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>

<span>async</span> <span>def</span> <span>scrape_page</span>(<span>url</span>):
    <span>&#34;&#34;&#34;Extract data from a single page&#34;&#34;&#34;</span>
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>url</span>)
        
        <span>title</span> <span>=</span> <span>await</span> <span>tab</span>.<span>execute_script</span>(<span>&#39;return document.title&#39;</span>)
        <span>links</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;a&#39;</span>, <span>find_all</span><span>=</span><span>True</span>)
        
        <span>return</span> {
            <span>&#39;url&#39;</span>: <span>url</span>,
            <span>&#39;title&#39;</span>: <span>title</span>,
            <span>&#39;link_count&#39;</span>: <span>len</span>(<span>links</span>)
        }

<span>async</span> <span>def</span> <span>concurrent_scraping</span>():
    <span>urls</span> <span>=</span> [
        <span>&#39;https://example1.com&#39;</span>,
        <span>&#39;https://example2.com&#39;</span>,
        <span>&#39;https://example3.com&#39;</span>
    ]
    
    <span># Process all URLs simultaneously</span>
    <span>tasks</span> <span>=</span> [<span>scrape_page</span>(<span>url</span>) <span>for</span> <span>url</span> <span>in</span> <span>urls</span>]
    <span>results</span> <span>=</span> <span>await</span> <span>asyncio</span>.<span>gather</span>(<span>*</span><span>tasks</span>)
    
    <span>for</span> <span>result</span> <span>in</span> <span>results</span>:
        <span>print</span>(<span>f&#34;<span><span>{</span><span>result</span>[<span>&#39;url&#39;</span>]<span>}</span></span>: <span><span>{</span><span>result</span>[<span>&#39;title&#39;</span>]<span>}</span></span> (<span><span>{</span><span>result</span>[<span>&#39;link_count&#39;</span>]<span>}</span></span> links)&#34;</span>)

<span>asyncio</span>.<span>run</span>(<span>concurrent_scraping</span>())</pre></div>

<p dir="auto">React to page events and user interactions in real-time. This enables more sophisticated and responsive automations:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser import Chrome
from pydoll.protocol.page.events import PageEvent

async def event_driven_automation():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Enable page events
        await tab.enable_page_events()
        
        # React to page load
        async def on_page_load(event):
            print(&#34;Page loaded! Starting automation...&#34;)
            # Perform actions after page loads
            search_box = await tab.find(id=&#39;search-box&#39;)
            await search_box.type_text(&#39;automation&#39;)
        
        # React to navigation
        async def on_navigation(event):
            url = event[&#39;params&#39;][&#39;url&#39;]
            print(f&#34;Navigated to: {url}&#34;)
        
        await tab.on(PageEvent.LOAD_EVENT_FIRED, on_page_load)
        await tab.on(PageEvent.FRAME_NAVIGATED, on_navigation)
        
        await tab.go_to(&#39;https://example.com&#39;)
        await asyncio.sleep(5)  # Let events process

asyncio.run(event_driven_automation())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span> <span>import</span> <span>Chrome</span>
<span>from</span> <span>pydoll</span>.<span>protocol</span>.<span>page</span>.<span>events</span> <span>import</span> <span>PageEvent</span>

<span>async</span> <span>def</span> <span>event_driven_automation</span>():
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        
        <span># Enable page events</span>
        <span>await</span> <span>tab</span>.<span>enable_page_events</span>()
        
        <span># React to page load</span>
        <span>async</span> <span>def</span> <span>on_page_load</span>(<span>event</span>):
            <span>print</span>(<span>&#34;Page loaded! Starting automation...&#34;</span>)
            <span># Perform actions after page loads</span>
            <span>search_box</span> <span>=</span> <span>await</span> <span>tab</span>.<span>find</span>(<span>id</span><span>=</span><span>&#39;search-box&#39;</span>)
            <span>await</span> <span>search_box</span>.<span>type_text</span>(<span>&#39;automation&#39;</span>)
        
        <span># React to navigation</span>
        <span>async</span> <span>def</span> <span>on_navigation</span>(<span>event</span>):
            <span>url</span> <span>=</span> <span>event</span>[<span>&#39;params&#39;</span>][<span>&#39;url&#39;</span>]
            <span>print</span>(<span>f&#34;Navigated to: <span><span>{</span><span>url</span><span>}</span></span>&#34;</span>)
        
        <span>await</span> <span>tab</span>.<span>on</span>(<span>PageEvent</span>.<span>LOAD_EVENT_FIRED</span>, <span>on_page_load</span>)
        <span>await</span> <span>tab</span>.<span>on</span>(<span>PageEvent</span>.<span>FRAME_NAVIGATED</span>, <span>on_navigation</span>)
        
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://example.com&#39;</span>)
        <span>await</span> <span>asyncio</span>.<span>sleep</span>(<span>5</span>)  <span># Let events process</span>

<span>asyncio</span>.<span>run</span>(<span>event_driven_automation</span>())</pre></div>

<p dir="auto">Pydoll provides seamless iframe interaction through the <code>get_frame()</code> method. This is especially useful for dealing with embedded content:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
from pydoll.browser.chromium import Chrome

async def iframe_interaction():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to(&#39;https://example.com/page-with-iframe&#39;)
        
        # Find the iframe element
        iframe_element = await tab.query(&#39;.hcaptcha-iframe&#39;, timeout=10)
        
        # Get a Tab instance for the iframe content
        frame = await tab.get_frame(iframe_element)
        
        # Now interact with elements inside the iframe
        submit_button = await frame.find(tag_name=&#39;button&#39;, class_name=&#39;submit&#39;)
        await submit_button.click()
        
        # You can use all Tab methods on the frame
        form_input = await frame.find(id=&#39;captcha-input&#39;)
        await form_input.type_text(&#39;verification-code&#39;)
        
        # Find elements by various methods
        links = await frame.find(tag_name=&#39;a&#39;, find_all=True)
        specific_element = await frame.query(&#39;#specific-id&#39;)

asyncio.run(iframe_interaction())"><pre><span>import</span> <span>asyncio</span>
<span>from</span> <span>pydoll</span>.<span>browser</span>.<span>chromium</span> <span>import</span> <span>Chrome</span>

<span>async</span> <span>def</span> <span>iframe_interaction</span>():
    <span>async</span> <span>with</span> <span>Chrome</span>() <span>as</span> <span>browser</span>:
        <span>tab</span> <span>=</span> <span>await</span> <span>browser</span>.<span>start</span>()
        <span>await</span> <span>tab</span>.<span>go_to</span>(<span>&#39;https://example.com/page-with-iframe&#39;</span>)
        
        <span># Find the iframe element</span>
        <span>iframe_element</span> <span>=</span> <span>await</span> <span>tab</span>.<span>query</span>(<span>&#39;.hcaptcha-iframe&#39;</span>, <span>timeout</span><span>=</span><span>10</span>)
        
        <span># Get a Tab instance for the iframe content</span>
        <span>frame</span> <span>=</span> <span>await</span> <span>tab</span>.<span>get_frame</span>(<span>iframe_element</span>)
        
        <span># Now interact with elements inside the iframe</span>
        <span>submit_button</span> <span>=</span> <span>await</span> <span>frame</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;button&#39;</span>, <span>class_name</span><span>=</span><span>&#39;submit&#39;</span>)
        <span>await</span> <span>submit_button</span>.<span>click</span>()
        
        <span># You can use all Tab methods on the frame</span>
        <span>form_input</span> <span>=</span> <span>await</span> <span>frame</span>.<span>find</span>(<span>id</span><span>=</span><span>&#39;captcha-input&#39;</span>)
        <span>await</span> <span>form_input</span>.<span>type_text</span>(<span>&#39;verification-code&#39;</span>)
        
        <span># Find elements by various methods</span>
        <span>links</span> <span>=</span> <span>await</span> <span>frame</span>.<span>find</span>(<span>tag_name</span><span>=</span><span>&#39;a&#39;</span>, <span>find_all</span><span>=</span><span>True</span>)
        <span>specific_element</span> <span>=</span> <span>await</span> <span>frame</span>.<span>query</span>(<span>&#39;#specific-id&#39;</span>)

<span>asyncio</span>.<span>run</span>(<span>iframe_interaction</span>())</pre></div>

<p dir="auto">For comprehensive documentation, detailed examples, and deep dives into Pydoll&#39;s features, visit our <a href="https://autoscrape-labs.github.io/pydoll/" rel="nofollow">official documentation site</a>.</p>
<p dir="auto">The documentation includes:</p>
<ul dir="auto">
<li><strong>Getting Started Guide</strong> - Step-by-step tutorials</li>
<li><strong>API Reference</strong> - Complete method documentation</li>
<li><strong>Advanced Techniques</strong> - Network interception, event handling, performance optimization</li>
<li><strong>Troubleshooting</strong> - Common issues and solutions</li>
<li><strong>Best Practices</strong> - Patterns for reliable automation</li>
</ul>

<p dir="auto">We&#39;d love your help making Pydoll even better! Check out our <a href="https://github.com/autoscrape-labs/pydoll/blob/main/CONTRIBUTING.md">contribution guidelines</a> to get started. Whether it&#39;s fixing bugs, adding features, or improving documentation - all contributions are welcome!</p>
<p dir="auto">Please make sure to:</p>
<ul dir="auto">
<li>Write tests for new features or bug fixes</li>
<li>Follow coding style and conventions</li>
<li>Use conventional commits for pull requests</li>
<li>Run lint and test checks before submitting</li>
</ul>

<p dir="auto">If you find my projects helpful, consider <a href="https://github.com/sponsors/thalissonvs">sponsoring me on GitHub</a>.</p>
<p dir="auto">Can&#39;t sponsor right now? No problem â€” you can still help a lot by:</p>
<ul dir="auto">
<li>Starring the repo</li>
<li>Sharing it on social media</li>
<li>Writing blog posts or tutorials</li>
<li>Giving feedback or reporting issues</li>
</ul>
<p dir="auto">Every bit of support makes a difference â€” thank you!</p>

<p dir="auto">Pydoll is licensed under the <a href="https://github.com/autoscrape-labs/pydoll/blob/main/LICENSE">MIT License</a>.</p>
<p dir="auto">
  <b>Pydoll</b> â€” Making browser automation magical!
</p>
</article></div></div>
  </body>
</html>
