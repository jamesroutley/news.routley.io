<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://pepijndevos.nl/2023/02/25/running-julia-on-the-lego-robot-inventor-hub.html">Original</a>
    <h1>Running Julia on the Lego Robot Inventor Hub</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<article>
	<h2><a href="https://tilde.news/2023/02/25/running-julia-on-the-lego-robot-inventor-hub.html">Running Julia on the Lego Robot Inventor Hub</a></h2>
	<section>
	<p>Someone asked if anyone had any experience interfacing Lego Mindstorms with Julia, and I was like <strong>this is right up my alley</strong>, so I got a little bit very much nerdsniped into making this work.</p>

<p>You see, the sensible thing would be to just run Julia on the EV3 which runs a full Linux, but the <em>modern</em> approach would be to run Julia on the Robot Inventor/Spike Prime Hub, which is an STM32 running a MicroPython firmware.</p>

<p>Here is the game plan. Lacking a MicroJulia implementation and the resources to write a completely custom firmware, we’re going to compile Julia functions into MicroPython extension modules and run them on <a href="https://github.com/pybricks/pybricks-micropython">PyBricks</a>.</p>

<p>This way you can do all your fancy <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/">ControlSystems</a> stuff in Julia, compile it to machine code, and then write some Python glue for the sensors and motors.</p>

<p>We’ll basically need to do 3 things</p>

<ul>
  <li>Compile Julia into ARM machine code</li>
  <li>Link the machine code into an .mpy library</li>
  <li>Run said library on PyBricks</li>
</ul>

<h3 id="run-native-code-on-pybricks">Run native code on PyBricks</h3>

<p>MicroPython has <a href="https://docs.micropython.org/en/latest/develop/natmod.html">this whole page</a> about how to write native modules in C and compile them into .mpy files. This should be easy!</p>

<p>So I just copied their factorial example, changed <code>ARCH = armv7emsp</code>, and ran <code>make</code> to end up with a sweet native .mpy module. Cool now just upload it. Oh. Anyway after <a href="https://github.com/pybricks/pybricksdev/pull/52">some hacks</a> I could use <code>pybricksdev run ble test.py</code> to upload a tiny test program:</p>

<div><div><pre><code><span>import</span> <span>factorial</span>
<span>print</span><span>(</span><span>&#34;hello&#34;</span><span>,</span> <span>factorial</span><span>.</span><span>factorial</span><span>(</span><span>4</span><span>))</span>
</code></pre></div></div>

<p>Except it threw <code>ValueError: incompatible .mpy arch</code> at me no matter what I tried. A little digging later, I found that I needed to <a href="https://github.com/pybricks/pybricks-micropython/pull/149">enable</a> <code>MICROPY_EMIT_THUMB</code>. But then I got a weird error in MicroPython, which I <a href="https://github.com/micropython/micropython/pull/10855">hacked around</a> as well.</p>

<p>Then, a small victory: running C code! Now onto Julia.</p>

<h3 id="compile-julia-into-arm-machine-code">Compile Julia into ARM machine code</h3>

<p>For the first part I used the amazing <a href="https://github.com/Seelengrab/AVRCompiler.jl">AVRCompiler.jl</a> which ties into GPUCompiler.jl which ties into LLVM. Long story short, we can abuse the machinery Julia has for running a static subset of Julia on the GPU for generating machine code for other architectures.</p>

<p>All I did was compile Julia from source<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> while adding <code>ARM</code> to the supported architectures, and changed the target triple in AVRCompiler to the one I found by by copying the <a href="https://github.com/pybricks/pybricks-micropython/blob/830579b255b526779c1ec29c20dd4286bdff9080/bricks/_common/arm_none_eabi.mk#L130">CFLAGS from PyBricks</a> and asking LLVM:</p>

<div><div><pre><code>clang -print-effective-triple -mthumb -mtune=cortex-m4 -mcpu=cortex-m4 -mfpu=fpv4-sp-d16 -mfloat-abi=hard --target=arm-none-eabi
thumbv7em-none-unknown-eabihf
</code></pre></div></div>

<p>Once that is in place you can just do</p>

<div><div><pre><code><span>using</span> <span>AVRCompiler</span>

<span>function</span><span> factorial</span><span>(</span><span>x</span><span>)</span>
    <span>if</span> <span>x</span> <span>==</span> <span>0</span>
        <span>return</span> <span>1</span>
    <span>end</span>
    <span>return</span> <span>x</span> <span>*</span> <span>factorial</span><span>(</span><span>x</span> <span>-</span> <span>1</span><span>)</span>
<span>end</span>

<span>obj</span> <span>=</span> <span>AVRCompiler</span><span>.</span><span>build_obj</span><span>(</span><span>factorial</span><span>,</span> <span>(</span><span>Int32</span><span>,))</span>
<span>write</span><span>(</span><span>&#34;factorial.o&#34;</span><span>,</span> <span>obj</span><span>)</span>

</code></pre></div></div>

<h3 id="glueing-it-all-together">Glueing it all together</h3>

<p>So we have a way to run native .mpy modules, and we have a way to compile Julia functions to .o files. Now we just need some glue to link the object file into .mpy and make it accessible from MicroPython.</p>

<p>I basically took the factorial example, ripped out the <code>factorial_helper</code> and replaced it with <code>extern int julia_factorial(int);</code> and modified the Makefile to call my Julia script to generate the object file.</p>

<div><div><pre><code><span># Location of top-level MicroPython directory
</span><span>MPY_DIR</span> <span>=</span> ../pybricks-micropython/micropython
<span># Name of module
</span><span>MOD</span> <span>=</span> factorial
<span># Source files (.c or .py)
</span><span>SRC</span> <span>=</span> wrapper.c
<span>SRC_O</span> <span>=</span> factorial.o
<span># Architecture to build for (x86, x64, armv6m, armv7m, xtensa, xtensawin)
</span><span>ARCH</span> <span>=</span> armv7emsp
<span># Include to get the rules for compiling and linking the module
</span><span>include</span><span> $(MPY_DIR)/py/dynruntime.mk</span>
<span># Build .o from .jl source files
</span><span>%.o</span><span>:</span> <span>%.jl $(CONFIG_H) Makefile</span>
	<span>$(ECHO)</span> <span>&#34;JL </span><span>$&lt;</span><span>&#34;</span>
	julia <span>--project</span><span>=</span><span>.</span> <span>$&lt;</span>
</code></pre></div></div>

<p>This was all looking really promising until I ran <code>make</code> and was greeted by</p>

<div><div><pre><code>LinkError: factorial.o: undefined symbol: __aeabi_unwind_cpp_pr0
</code></pre></div></div>

<p>But, yolo, lemme just comment that out in <code>mpy_ld.py</code> and press on. This symbol appears to be related to exceptions and I don’t really care.</p>

<div><div><pre><code>$ pybricksdev run ble test.py
Searching for any hub with Pybricks service...
100%|████████████████████████████| 280/280 [00:00&lt;00:00, 2.15kB/s]
hello 24
</code></pre></div></div>

<p>At last! Julia code running on the Lego hub! TODO: make cool demo</p>



	</section>
	
</article>


		</div></div>
  </body>
</html>
