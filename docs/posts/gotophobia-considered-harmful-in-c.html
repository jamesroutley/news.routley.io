<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.joren.ga/gotophobia-harmful">Original</a>
    <h1>GOTOphobia Considered Harmful (In C)</h1>
    
    <div id="readability-page-1" class="page"><div>
<header>GOTOphobia considered harmful (in C)</header>



<p>Everybody and their grandpa knows (the meme title of) Dijkstra&#39;s
<a href="https://dl.acm.org/doi/epdf/10.1145/362929.362947"><em>Letters to the editor: go to statement considered harmful</em></a>
(submitted under the title: <em>A case against the goto statement</em>),
but most forget the context of the 60s in which it was written,
things we take for granted were a novelty back then.</p>

<p>A lot programmers learnt the craft in a world where <code>goto</code> was the main method
of flow control; even in structured languages it was easy for them to fall back
on the learned bad habits and techniques.
On the other hand, today we have the very opposite situation: programmers not
using <code>goto</code> when it&#39;s appropriate and abusing other constructs, what ironically
makes code only less readable. They overfocus on the <em>WHAT</em> (&#34;remove <code>goto</code>&#34;)
rather than the <em>WHY</em> (&#34;because it improves readability and maintainability&#34;).</p>

<p>Academic teachers parroting &#34;<code>goto</code> evil&#34; while not really understanding the
language they teach only worsens the matter [speaking from experience]. Because
who needs to learn good practices and discipline, right? It&#39;s obviously better
to just ignore the topic entirely and let the students later wonder why they get
<a href="https://www.explainxkcd.com/wiki/index.php/292:_goto">attacked by velociraptors</a>.</p>

<blockquote>
  <p>A &#34;goto&#34; is not, in and of itself, dangerous – it is a language feature,
one that directly translates to the jump instructions implemented in machine
code. Like pointers, operator overloading, and a host of other &#34;perceived&#34;
evils in programming, &#34;goto&#34; is widely hated by those who&#39;ve been bitten by
poor programming. Bad code is the product of bad programmers; in my
experience, a poor programmer will write a poor program, regardless of the
availability of &#34;goto.&#34;</p>

  <p>If you think people can&#39;t write spaghetti code in a &#34;goto-less&#34; language, I
can send you some <em>lovely</em> examples to disabuse you of that notion. ;)</p>

  <p>Used over short distances with well-documented labels, a &#34;goto&#34; can be more
effective, faster, and cleaner than a series of complex flags or other
constructs. The &#34;goto&#34; may also be safer and more intuitive than the
alternative. A &#34;break&#34; is a goto; a &#34;continue&#34; is a &#34;goto&#34; – these are
statements that move the point of execution explicitly.</p>

  <p>~ <a href="https://lkml.org/lkml/2003/1/12/245">Scott Robert Ladd</a></p>
</blockquote>

<p>Linux kernel is one thing, but if even such restrictive coding standard
as MISRA C (2012 edition) can downgrade the prohibition on <code>goto</code> from
<em>required</em> to <em>advisory</em>, I think in regular code we can safely use <code>goto</code>
in judicious manner. Thus I want to present some situations and patterns
where <code>goto</code> could be acceptable (perhaps the best?) choice and you could
maybe want to <em>consider</em> using it.</p>



<ul id="markdown-toc">
  <li><a href="#errorexception-handling--cleanup" id="markdown-toc-errorexception-handling--cleanup">Error/exception handling &amp; cleanup</a>    <ul>
      <li><a href="#goto-less-alternative-1-nested-ifs" id="markdown-toc-goto-less-alternative-1-nested-ifs"><code>goto</code>-less alternative 1: nested <code>if</code>s</a></li>
      <li><a href="#goto-less-alternative-2-if-not-then-clean" id="markdown-toc-goto-less-alternative-2-if-not-then-clean"><code>goto</code>-less alternative 2: if not then clean</a></li>
      <li><a href="#goto-less-alternative-3-flags" id="markdown-toc-goto-less-alternative-3-flags"><code>goto</code>-less alternative 3: flags</a></li>
      <li><a href="#goto-less-alternative-35-so-far-ok-flag" id="markdown-toc-goto-less-alternative-35-so-far-ok-flag"><code>goto</code>-less alternative 3.5: so-far-ok flag</a></li>
      <li><a href="#goto-less-alternative-4-functions" id="markdown-toc-goto-less-alternative-4-functions"><code>goto</code>-less alternative 4: functions</a></li>
      <li><a href="#goto-less-alternative-5-abuse-of-loops" id="markdown-toc-goto-less-alternative-5-abuse-of-loops"><code>goto</code>-less alternative 5: abuse of loops</a></li>
    </ul>
  </li>
  <li><a href="#restartretry" id="markdown-toc-restartretry">Restart/retry</a>    <ul>
      <li><a href="#goto-less-alternative-loop" id="markdown-toc-goto-less-alternative-loop"><code>goto</code>-less alternative: loop</a></li>
      <li><a href="#less-trivial-example" id="markdown-toc-less-trivial-example">Less trivial example</a>        <ul>
          <li><a href="#goto-version" id="markdown-toc-goto-version"><code>goto</code> version</a></li>
          <li><a href="#goto-less-version" id="markdown-toc-goto-less-version"><code>goto</code>-less version</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#common-code-in-switch-statement" id="markdown-toc-common-code-in-switch-statement">Common code in <code>switch</code> statement</a>    <ul>
      <li><a href="#goto-less-alternative-1-functions" id="markdown-toc-goto-less-alternative-1-functions"><code>goto</code>-less alternative 1: functions</a></li>
      <li><a href="#goto-less-alternative-2-ifs" id="markdown-toc-goto-less-alternative-2-ifs"><code>goto</code>-less alternative 2: <code>if</code>s</a></li>
      <li><a href="#goto-less-alternative-3-interlacing-if-0" id="markdown-toc-goto-less-alternative-3-interlacing-if-0"><code>goto</code>-less alternative 3: interlacing <code>if (0)</code></a></li>
      <li><a href="#goto-less-alternative-capturing-lambda" id="markdown-toc-goto-less-alternative-capturing-lambda"><del><code>goto</code>-less alternative: capturing lambda</del></a></li>
    </ul>
  </li>
  <li><a href="#nested-break-labeled-continue" id="markdown-toc-nested-break-labeled-continue">Nested <code>break</code>, labeled <code>continue</code></a></li>
  <li><a href="#simple-state-machines" id="markdown-toc-simple-state-machines">Simple state machines</a></li>
  <li><a href="#jumping-into-event-loop" id="markdown-toc-jumping-into-event-loop">Jumping into event loop</a>    <ul>
      <li><a href="#goto-less-alternative-1-guard-flag" id="markdown-toc-goto-less-alternative-1-guard-flag"><code>goto</code>-less alternative 1: guard flag</a></li>
      <li><a href="#goto-less-alternative-2-code-duplication" id="markdown-toc-goto-less-alternative-2-code-duplication"><code>goto</code>-less alternative 2: code duplication</a></li>
    </ul>
  </li>
  <li><a href="#optimizations" id="markdown-toc-optimizations">Optimizations</a></li>
  <li><a href="#structured-programming-with-go-to-statements" id="markdown-toc-structured-programming-with-go-to-statements"><em>Structured Programming with <strong>go to</strong> Statements</em></a></li>
</ul>

    

<p>Poster child of using <code>goto</code> – most of the times accepted, often recommended,
sometimes even straight up mandated. This pattern results in a good quality
code, because the operations of the algorithm are <em>structured</em> in a clear order,
while errors and other overhead is handled somewhere else, outside the mainline.
The alternatives make the code less readable as it&#39;s hard to spot where the
main code is buried among the error checks.</p>

<p>From SEI CERT C Coding Standard:</p>

<blockquote>
  <p>Many functions require the allocation of multiple resources. Failing and
returning somewhere in the middle of this function without freeing all of
the allocated resources could produce a memory leak. It is a common error
to forget to free one (or all) of the resources in this manner, so a <code>goto</code>
chain is the simplest and cleanest way to organize exits while preserving
the order of freed resources.</p>
</blockquote>

<pre><code>int* foo(int bar)
{
    int* return_value = NULL;

    if (!do_something(bar)) {
        goto error_1;
    }
    if (!init_stuff(bar)) {
        goto error_2;
    }
    if (!prepare_stuff(bar)) {
        goto error_3;
    }
    return_value = do_the_thing(bar);

error_3:
    cleanup_3();
error_2:
    cleanup_2();
error_1:
    cleanup_1();

    return return_value;
}
</code></pre>

<p><strong>Randomly taken real-life <a href="http://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/clk/mmp/clk-audio.c#n345">example from Linux kernel</a>:</strong></p>
<pre><code>// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * MMP Audio Clock Controller driver
 *
 * Copyright (C) 2020 Lubomir Rintel &lt;lkundrak@v3.sk&gt;
 */

static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
	struct mmp2_audio_clk *priv;
	int ret;

	priv = devm_kzalloc(&amp;pdev-&gt;dev,
			    struct_size(priv, clk_data.hws,
					MMP2_CLK_AUDIO_NR_CLKS),
			    GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	spin_lock_init(&amp;priv-&gt;lock);
	platform_set_drvdata(pdev, priv);

	priv-&gt;mmio_base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(priv-&gt;mmio_base))
		return PTR_ERR(priv-&gt;mmio_base);

	pm_runtime_enable(&amp;pdev-&gt;dev);
	ret = pm_clk_create(&amp;pdev-&gt;dev);
	if (ret)
		goto disable_pm_runtime;

	ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
	if (ret)
		goto destroy_pm_clk;

	ret = register_clocks(priv, &amp;pdev-&gt;dev);
	if (ret)
		goto destroy_pm_clk;

	return 0;

destroy_pm_clk:
	pm_clk_destroy(&amp;pdev-&gt;dev);
disable_pm_runtime:
	pm_runtime_disable(&amp;pdev-&gt;dev);

	return ret;
}
</code></pre>
<h2 id="goto-less-alternative-1-nested-ifs">
  
  
    <code>goto</code>-less alternative 1: nested <code>if</code>s <a href="#goto-less-alternative-1-nested-ifs">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li>nesting (<em>arrow anti-pattern</em>)</li>
  <li>potentially duplicated code (see example function from Linux)</li>
</ul>

<pre><code>int* foo(int bar)
{
    int* return_value = NULL;

    if (do_something(bar)) {
        if (init_stuff(bar)) {
            if (prepare_stuff(bar)) {
                return_value = do_the_thing(bar);
            }
            cleanup_3();
        }
        cleanup_2();
    }
    cleanup_1();

    return return_value;
}
</code></pre>

<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    ret = pm_clk_create(&amp;pdev-&gt;dev);
    if (!ret) {
        ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
        if (!ret) {
            ret = register_clocks(priv, &amp;pdev-&gt;dev);
            if (!ret) {
                pm_clk_destroy(&amp;pdev-&gt;dev);
                pm_runtime_disable(&amp;pdev-&gt;dev);
            }
        } else {
            pm_clk_destroy(&amp;pdev-&gt;dev);
            pm_runtime_disable(&amp;pdev-&gt;dev);
        }
    } else {
        pm_runtime_disable(&amp;pdev-&gt;dev);
    }

    return ret; // original was returning 0 explicitly
}
</code></pre>
  </div>
</details>

<p>And here Microsoft provides us with <a href="https://learn.microsoft.com/en-us/windows/win32/shell/common-file-dialog#basic-usage">lovely example of such ridiculous nesting</a>.</p>
<h2 id="goto-less-alternative-2-if-not-then-clean">
  
  
    <code>goto</code>-less alternative 2: if not then clean <a href="#goto-less-alternative-2-if-not-then-clean">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li>duplicated code</li>
  <li>multiple exit points</li>
</ul>

<pre><code>int* foo(int bar)
{
    int* return_value = NULL;

    if (!do_something(bar)) {
        cleanup_1();
        return return_value;
    }
    if (!init_stuff(bar)) {
        cleanup_2();
        cleanup_1();
        return return_value;
    }
    if (!prepare_stuff(bar)) {
        cleanup_3();
        cleanup_2();
        cleanup_1();
        return return_value;
    }

    cleanup_3();
    cleanup_2();
    cleanup_1();

    return do_the_thing(bar);
}
</code></pre>

<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    ret = pm_clk_create(&amp;pdev-&gt;dev);
    if (ret) {
        pm_runtime_disable(&amp;pdev-&gt;dev);
        return ret;
    }

    ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
    if (ret) {
        pm_clk_destroy(&amp;pdev-&gt;dev);
        pm_runtime_disable(&amp;pdev-&gt;dev);
        return ret;
    }

    ret = register_clocks(priv, &amp;pdev-&gt;dev);
    if (ret) {
        pm_clk_destroy(&amp;pdev-&gt;dev);
        pm_runtime_disable(&amp;pdev-&gt;dev);
        return ret;
    }

    return 0;
}
</code></pre>
  </div>
</details>
<h2 id="goto-less-alternative-3-flags">
  
  
    <code>goto</code>-less alternative 3: flags <a href="#goto-less-alternative-3-flags">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li>additional variables</li>
  <li>&#34;cascading&#34; booleans</li>
  <li>potential nesting</li>
  <li>potential complicated boolean expressions</li>
</ul>

<pre><code>int* foo(int bar)
{
    int* return_value = NULL;

    bool flag_1 = false;
    bool flag_2 = false;
    bool flag_3 = false;

    flag_1 = do_something(bar);
    if (flag_1) {
        flag_2 = init_stuff(bar);
    }
    if (flag_2) {
        flag_3 = prepare_stuff(bar);
    }
    if (flag_3) {
        return_value = do_the_thing(bar);
    }

    if (flag_3) {
        cleanup_3();
    }
    if (flag_2) {
        cleanup_2();
    }
    if (flag_1) {
        cleanup_1();
    }

    return return_value;
}
</code></pre>


<h2 id="goto-less-alternative-35-so-far-ok-flag">
  
  
    <code>goto</code>-less alternative 3.5: so-far-ok flag <a href="#goto-less-alternative-35-so-far-ok-flag">#</a>
  
  
</h2>
    

<pre><code>int foo(int bar)
{
    int return_value = 0;
    bool something_done = false;
    bool stuff_inited = false;
    bool stuff_prepared = false;
    bool oksofar = true;

    if (oksofar) {  // this IF is optional (always execs) but included for consistency
        if (do_something(bar)) {
            something_done = true;
        } else {
            oksofar = false;
        }
    }

    if (oksofar) {
        if (init_stuff(bar)) {
            stuff_inited = true;
        } else {
            oksofar = false;
        }
    }

    if (oksofar) {
        if (prepare_stuff(bar)) {
            stuff_prepared = true;
        } else {
            oksofar = false;
        }
    }

    // Do the thing
    if (oksofar) {
        return_value = do_the_thing(bar);
    }

    // Clean up
    if (stuff_prepared) {
        cleanup_3();
    }
    if (stuff_inited) {
        cleanup_2();
    }
    if (something_done) {
        cleanup_1();
    }

    return return_value;
}
</code></pre>

<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    bool destroy_pm_clk = false;

    ret = pm_clk_create(&amp;pdev-&gt;dev);
    if (!ret) {
        ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
        if (ret) {
            destroy_pm_clk = true;
        }
    }
    if (!ret) {
        ret = register_clocks(priv, &amp;pdev-&gt;dev);
        if (ret) {
            destroy_pm_clk = true;
        }
    }

    if (ret) {
        if (destroy_pm_clk) {
            pm_clk_destroy(&amp;pdev-&gt;dev);
        }
        pm_runtime_disable(&amp;pdev-&gt;dev);
        return ret;
    }

    return 0;
}
</code></pre>
  </div>
</details>
<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    bool destroy_pm_clk = false;
    bool disable_pm_runtime = false;

    ret = pm_clk_create(&amp;pdev-&gt;dev);
    if (ret) {
        disable_pm_runtime = true;
    }
    if (!ret) {
        ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
        if (ret) {
            destroy_pm_clk = true;
        }
    }
    if (!ret) {
        ret = register_clocks(priv, &amp;pdev-&gt;dev);
        if (ret) {
            destroy_pm_clk = true;
        }
    }

    if (destroy_pm_clk) {
        pm_clk_destroy(&amp;pdev-&gt;dev);
    }
    if (disable_pm_runtime) {
        pm_runtime_disable(&amp;pdev-&gt;dev);
    }

    return ret;
}
</code></pre>
  </div>
</details>
<h2 id="goto-less-alternative-4-functions">
  
  
    <code>goto</code>-less alternative 4: functions <a href="#goto-less-alternative-4-functions">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li><span title="Things should not be multiplied beyond what is required">&#34;Entia non sunt multiplicanda praeter necessitatem&#34;</span></li>
  <li>reading bottom-up instead of top-bottom</li>
  <li>may require passing context around</li>
</ul>

<pre><code>static inline int foo_2(int bar)
{
    int return_value = 0;
    if (prepare_stuff(bar)) {
        return_value = do_the_thing(bar);
    }
    cleanup_3();
    return return_value;
}

static inline int foo_1(int bar)
{
    int return_value = 0;
    if (init_stuff(bar)) {
        return_value = foo_2(bar);
    }
    cleanup_2();
    return return_value;
}

int foo(int bar)
{
    int return_value = 0;
    if (do_something(bar)) {
        return_value = foo_1(bar);
    }
    cleanup_1();
    return return_value;
}
</code></pre>

<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static inline int mmp2_audio_clk_probe_3(struct platform_device* pdev)
{
    int ret = register_clocks(priv, &amp;pdev-&gt;dev);
    if (ret) {
        pm_clk_destroy(&amp;pdev-&gt;dev);
    }
    return ret;
}

static inline int mmp2_audio_clk_probe_2(struct platform_device* pdev)
{
    int ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
    if (ret) {
        pm_clk_destroy(&amp;pdev-&gt;dev);
    } else {
        ret = mmp2_audio_clk_probe_3(pdev);
    }
    return ret;
}

static inline int mmp2_audio_clk_probe_1(struct platform_device* pdev)
{
    int ret = pm_clk_create(&amp;pdev-&gt;dev);
    if (ret) {
        pm_runtime_disable(&amp;pdev-&gt;dev);
    } else {
        ret = mmp2_audio_clk_probe_2(pdev);
        if (ret) {
            pm_runtime_disable(&amp;pdev-&gt;dev);
        }
    }
    return ret;
}

static int mmp2_audio_clk_probe(struct platform_device* pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    ret = mmp2_audio_clk_probe_1(pdev);

    return ret;
}
</code></pre>
  </div>
</details>
<h2 id="goto-less-alternative-5-abuse-of-loops">
  
  
    <code>goto</code>-less alternative 5: abuse of loops <a href="#goto-less-alternative-5-abuse-of-loops">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li>half of the drawback of <code>goto</code></li>
  <li>half of the drawback of other alternatives</li>
  <li>none of the benefits of either of the above</li>
  <li>not structural anyway</li>
  <li>creates loop which doesn&#39;t loop</li>
  <li>abuse of one language construct just to avoid using the right tool for the job</li>
  <li>less readable</li>
  <li>counter intuitive, confusing</li>
  <li>adds unnecessary nesting</li>
  <li>takes more lines</li>
  <li>don&#39;t even think about using a legitimate loop somewhere among this mess</li>
</ul>

<pre><code>int* foo(int bar)
{
    int* return_value = NULL;

    do {
        if (!do_something(bar)) break;
        do {
            if (!init_stuff(bar)) break;
            do {
                if (!prepare_stuff(bar)) break;
                return_value = do_the_thing(bar);
            } while (0);
            cleanup_3();
        } while (0);
        cleanup_2();
    } while (0);
    cleanup_1();

    return return_value;
}
</code></pre>

<details>
<summary>Example from Linux kernel rewritten</summary>
<div>
    <pre><code>static int mmp2_audio_clk_probe(struct platform_device *pdev)
{
    // ...
    pm_runtime_enable(&amp;pdev-&gt;dev);

    do {
        ret = pm_clk_create(&amp;pdev-&gt;dev);
        if (ret) break;

        do {
            ret = pm_clk_add(&amp;pdev-&gt;dev, &#34;audio&#34;);
            if (ret) break;

            ret = register_clocks(priv, &amp;pdev-&gt;dev);
            if (ret) break;
        } while (0);
        pm_clk_destroy(&amp;pdev-&gt;dev);
    } while (0);
    pm_runtime_disable(&amp;pdev-&gt;dev);

    return ret;
}
</code></pre>
  </div>
</details>

    

<p>Common especially on *nix systems when dealing with system calls returning
an error after being interrupted by a signal + setting <code>errno</code> to <code>EINTR</code>
to indicate the it was doing fine and was just interrupted.
Of course, it&#39;s not limited to system calls.</p>

<pre><code>#include &lt;errno.h&gt;

int main()
{
retry_syscall:
    if (some_syscall() == -1) {
        if (errno == EINTR) {
            goto retry_syscall;
        }

        // handle real errors
    }

    return 0;
}
</code></pre>


<h2 id="goto-less-alternative-loop">
  
  
    <code>goto</code>-less alternative: loop <a href="#goto-less-alternative-loop">#</a>
  
  
</h2>
    

<p>We can of course use a <code>do {} while</code> loop with conditions in <code>while</code>:</p>

<pre><code>#include &lt;errno.h&gt;

int main()
{
    int res;
    do {
        res = some_system_call();
    } while (res == -1 &amp;&amp; errno == EINTR);

    if (res == -1) {
        // handle real errors
    }

    return 0;
}
</code></pre>

<p>I think both versions are comparatively readable, but <code>goto</code> has slight advantage
by making it immediately clear the looping is not a desirable situation, while
<code>while</code> loop may be misinterpreted as <a href="https://en.wikipedia.org/wiki/Busy_waiting">waiting loop</a>.</p>
<h2 id="less-trivial-example">
  
  
    Less trivial example <a href="#less-trivial-example">#</a>
  
  
</h2>
    

<p>For those, I&#39;m willing to break the overall monochrome theme of the site and
define colors for syntax highlights. Even with simple parsing done by kramdown
(your code editor would certainty do a better job here), we already notice
labels and <code>goto</code> statements standing out a little from the rest of the code.
Flags on the other hand get lost among other variables.</p>


<h3 id="goto-version">
  
  
    <code>goto</code> version <a href="#goto-version">#</a>
  
  
</h3>
    

<div>

  <figure><pre><code data-lang="c"><span>#include &lt;string.h&gt;
</span>
<span>enum</span> <span>{</span>
    <span>PKT_THIS_OPERATION</span><span>,</span>
    <span>PKT_THAT_OPERATION</span><span>,</span>
    <span>PKT_PROCESS_CONDITIONALLY</span><span>,</span>
    <span>PKT_CONDITION_SKIPPED</span><span>,</span>
    <span>PKT_ERROR</span><span>,</span>
    <span>READY_TO_SEND</span><span>,</span>
    <span>NOT_READY_TO_SEND</span>
<span>};</span>

<span>int</span> <span>parse_packet</span><span>()</span>
<span>{</span>
    <span>static</span> <span>int</span> <span>packet_error_count</span> <span>=</span> <span>0</span><span>;</span>

    <span>int</span> <span>packet</span><span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0</span> <span>};</span>
    <span>int</span> <span>packet_length</span> <span>=</span> <span>123</span><span>;</span>
    <span>_Bool</span> <span>packet_condition</span> <span>=</span> <span>1</span><span>;</span>
    <span>int</span> <span>packet_status</span> <span>=</span> <span>4</span><span>;</span>

    <span>// get packet etc. ...</span>

<span>REPARSE_PACKET:</span>
    <span>switch</span> <span>(</span><span>packet</span><span>[</span><span>0</span><span>])</span> <span>{</span>
        <span>case</span> <span>PKT_THIS_OPERATION</span><span>:</span>
            <span>if</span> <span>(</span><span>/* problem condition */</span><span>)</span> <span>{</span>
                <span>goto</span> <span>PACKET_ERROR</span><span>;</span>
            <span>}</span>
            <span>// ... handle THIS_OPERATION</span>
            <span>break</span><span>;</span>

        <span>case</span> <span>PKT_THAT_OPERATION</span><span>:</span>
            <span>if</span> <span>(</span><span>/* problem condition */</span><span>)</span> <span>{</span>
                <span>goto</span> <span>PACKET_ERROR</span><span>;</span>
            <span>}</span>
            <span>// ... handle THAT_OPERATION</span>
            <span>break</span><span>;</span>

        <span>// ...</span>

        <span>case</span> <span>PKT_PROCESS_CONDITIONALLY</span><span>:</span>
            <span>if</span> <span>(</span><span>packet_length</span> <span>&lt;</span> <span>9</span><span>)</span> <span>{</span>
                <span>goto</span> <span>PACKET_ERROR</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span><span>packet_condition</span> <span>&amp;&amp;</span> <span>packet</span><span>[</span><span>4</span><span>])</span> <span>{</span>
                <span>packet_length</span> <span>-=</span> <span>5</span><span>;</span>
                <span>memmove</span><span>(</span><span>packet</span><span>,</span> <span>packet</span><span>+</span><span>5</span><span>,</span> <span>packet_length</span><span>);</span>
                <span>goto</span> <span>REPARSE_PACKET</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>packet</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>PKT_CONDITION_SKIPPED</span><span>;</span>
                <span>packet</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>packet_length</span><span>;</span>
                <span>packet_length</span> <span>=</span> <span>5</span><span>;</span>
                <span>packet_status</span> <span>=</span> <span>READY_TO_SEND</span><span>;</span>
            <span>}</span>
            <span>break</span><span>;</span>

        <span>// ...</span>

        <span>default:</span>
<span>PACKET_ERROR:</span>
            <span>packet_error_count</span><span>++</span><span>;</span>
            <span>packet_length</span> <span>=</span> <span>4</span><span>;</span>
            <span>packet</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>PKT_ERROR</span><span>;</span>
            <span>packet_status</span> <span>=</span> <span>READY_TO_SEND</span><span>;</span>
            <span>break</span><span>;</span>
    <span>}</span>

    <span>// ...</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

</div>
<h3 id="goto-less-version">
  
  
    <code>goto</code>-less version <a href="#goto-less-version">#</a>
  
  
</h3>
    
<div>

  <figure><pre><code data-lang="c"><span>#include &lt;string.h&gt;
</span>
<span>enum</span> <span>{</span>
    <span>PKT_THIS_OPERATION</span><span>,</span>
    <span>PKT_THAT_OPERATION</span><span>,</span>
    <span>PKT_PROCESS_CONDITIONALLY</span><span>,</span>
    <span>PKT_CONDITION_SKIPPED</span><span>,</span>
    <span>PKT_ERROR</span><span>,</span>
    <span>READY_TO_SEND</span><span>,</span>
    <span>NOT_READY_TO_SEND</span>
<span>};</span>

<span>int</span> <span>parse_packet</span><span>()</span>
<span>{</span>
    <span>static</span> <span>int</span> <span>packet_error_count</span> <span>=</span> <span>0</span><span>;</span>

    <span>int</span> <span>packet</span><span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0</span> <span>};</span>
    <span>int</span> <span>packet_length</span> <span>=</span> <span>123</span><span>;</span>
    <span>_Bool</span> <span>packet_condition</span> <span>=</span> <span>1</span><span>;</span>
    <span>int</span> <span>packet_status</span> <span>=</span> <span>4</span><span>;</span>

    <span>// get packet etc. ...</span>

    <span>_Bool</span> <span>REPARSE_PACKET</span> <span>=</span> <span>true</span><span>;</span>
    <span>_Bool</span> <span>PACKET_ERROR</span> <span>=</span> <span>false</span><span>;</span>

    <span>while</span> <span>(</span><span>REPARSE_PACKET</span><span>)</span> <span>{</span>
        <span>REPARSE_PACKET</span> <span>=</span> <span>false</span><span>;</span>
        <span>PACKET_ERROR</span> <span>=</span> <span>false</span><span>;</span>

        <span>switch</span> <span>(</span><span>packet</span><span>[</span><span>0</span><span>])</span> <span>{</span>
            <span>case</span> <span>PKT_THIS_OPERATION</span><span>:</span>
                <span>if</span> <span>(</span><span>/* problem condition */</span><span>)</span> <span>{</span>
                    <span>PACKET_ERROR</span> <span>=</span> <span>true</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// ... handle THIS_OPERATION</span>
                <span>break</span><span>;</span>

            <span>case</span> <span>PKT_THAT_OPERATION</span><span>:</span>
                <span>if</span> <span>(</span><span>/* problem condition */</span><span>)</span> <span>{</span>
                    <span>PACKET_ERROR</span> <span>=</span> <span>true</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// ... handle THAT_OPERATION</span>
                <span>break</span><span>;</span>

                <span>// ...</span>

            <span>case</span> <span>PKT_PROCESS_CONDITIONALLY</span><span>:</span>
                <span>if</span> <span>(</span><span>packet_length</span> <span>&lt;</span> <span>9</span><span>)</span> <span>{</span>
                    <span>PACKET_ERROR</span> <span>=</span> <span>true</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>packet_condition</span> <span>&amp;&amp;</span> <span>packet</span><span>[</span><span>4</span><span>])</span> <span>{</span>
                    <span>packet_length</span> <span>-=</span> <span>5</span><span>;</span>
                    <span>memmove</span><span>(</span><span>packet</span><span>,</span> <span>packet</span><span>+</span><span>5</span><span>,</span> <span>packet_length</span><span>);</span>
                    <span>REPARSE_PACKET</span> <span>=</span> <span>true</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>packet</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>PKT_CONDITION_SKIPPED</span><span>;</span>
                    <span>packet</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>packet_length</span><span>;</span>
                    <span>packet_length</span> <span>=</span> <span>5</span><span>;</span>
                    <span>packet_status</span> <span>=</span> <span>READY_TO_SEND</span><span>;</span>
                <span>}</span>
                <span>break</span><span>;</span>

                <span>// ...</span>

            <span>default:</span>
                <span>PACKET_ERROR</span> <span>=</span> <span>true</span><span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>PACKET_ERROR</span><span>)</span> <span>{</span>
            <span>packet_error_count</span><span>++</span><span>;</span>
            <span>packet_length</span> <span>=</span> <span>4</span><span>;</span>
            <span>packet</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>PKT_ERROR</span><span>;</span>
            <span>packet_status</span> <span>=</span> <span>NOT_READY_TO_SEND</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>// ...</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

</div>

    

<p>This situation may be a good opportunity to check if the code doesn&#39;t need to
be refactored altogether; that being said, sometimes you want to have <code>switch</code>
statement where cases make minor changes then run the same code.</p>

<p>Sure, you could extract the common code into function, but then you need to pass
all the context to it, but that may be inconvenient (for you may need to pass
a lot of parameters or making a dedicated structure, in both cases probably with
pointers) and may increase complexity of the code; in some cases, you may wish
there being only one call to the function instead of multiple.</p>

<p>So why not just jump to the common code?</p>

<pre><code>int foo(int v)
{
    // ...
    int something = 0;
    switch (v) {
        case FIRST_CASE:
            something = 2;
            goto common1;
        case SECOND_CASE:
            something = 7;
            goto common1;
        case THIRD_CASE:
            something = 9;
            goto common1;
common1:
            /* code common to FIRST, SECOND and THIRD cases */
            break;

        case FOURTH_CASE:
            something = 10;
            goto common2;
        case FIFTH_CASE:
            something = 42;
            goto common2;
common2:
            /* code common to FOURTH and FIFTH cases */
            break;
    }
    // ...
}
</code></pre>
<h2 id="goto-less-alternative-1-functions">
  
  
    <code>goto</code>-less alternative 1: functions <a href="#goto-less-alternative-1-functions">#</a>
  
  
</h2>
    

<p>Drawbacks:</p>
<ul>
  <li><span title="Things should not be multiplied beyond what is required">&#34;Entia non sunt multiplicanda praeter necessitatem&#34;</span></li>
  <li>reading bottom-up instead of top-bottom</li>
  <li>may require passing context around</li>
</ul>

<pre><code>struct foo_context {
    int* something;
    // ...
};

static void common1(struct foo_context ctx)
{
    /* code common to FIRST, SECOND and THIRD cases */
}

static void common2(struct foo_context ctx)
{
    /* code common to FOURTH and FIFTH cases */
}

int foo(int v)
{
    struct foo_context ctx = { NULL };
    // ...
    int something = 0;
    ctx.something = &amp;something;

    switch (v) {
        case FIRST_CASE:
            something = 2;
            common1(ctx);
            break;
        case SECOND_CASE:
            something = 7;
            common1(ctx);
            break;
        case THIRD_CASE:
            something = 9;
            common1(ctx);
            break;

        case FOURTH_CASE:
            something = 10;
            common2(ctx);
            break;
        case FIFTH_CASE:
            something = 42;
            common2(ctx);
            break;
    }
    // ...
}
</code></pre>
<h2 id="goto-less-alternative-2-ifs">
  
  
    <code>goto</code>-less alternative 2: <code>if</code>s <a href="#goto-less-alternative-2-ifs">#</a>
  
  
</h2>
    

<p>We can abandon elegance and replace the <code>switch</code> statement with <code>if</code>s</p>

<pre><code>int foo(int v)
{
    // ...
    int something = 0;
    if (v == FIRST_CASE || v == SECOND_CASE || v == THIRD_CASE) {
        if (v == FIRST_CASE) {
            something = 2;
        } else if (v == SECOND_CASE) {
            something = 7;
        } else if (v == THIRD_CASE) { // it could be just `else`
            something = 9;
        }
        /* code common to FIRST, SECOND and THIRD cases */
    } else if (v == FOURTH_CASE || v == FIFTH_CASE) {
        if (v == FOURTH_CASE) {
            something = 10;
        } else {
            something = 42;
        }
        /* code common to FOURTH and FIFTH cases */
    }
    // ...
}
</code></pre>
<h2 id="goto-less-alternative-3-interlacing-if-0">
  
  
    <code>goto</code>-less alternative 3: interlacing <code>if (0)</code> <a href="#goto-less-alternative-3-interlacing-if-0">#</a>
  
  
</h2>
    

<p>Please, don&#39;t, just don&#39;t…</p>

<pre><code>int foo(int v)
{
    // ...
    int something = 0;
    switch (v) {
        case FIRST_CASE:
            something = 2;
      if (0) {
        case SECOND_CASE:
            something = 7;
      }
      if (0) {
        case THIRD_CASE:
            something = 9;
      }
            /* code common to FIRST, SECOND and THIRD cases */
            break;

        case FOURTH_CASE:
            something = 10;
      if (0) {
        case FIFTH_CASE:
            something = 42;
      }
            /* code common to FOURTH and FIFTH cases */
            break;
    }
    // ...
}
</code></pre>
<h2 id="goto-less-alternative-capturing-lambda">
  
  
    <del><code>goto</code>-less alternative: capturing lambda</del> <a href="#goto-less-alternative-capturing-lambda">#</a>
  
  
</h2>
    

<p>Yeah, maybe some day…</p>

    

<p>I think this one doesn&#39;t require further explanation:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    for (int i = 1; i &lt;= 5; ++i) {
        printf(&#34;outer iteration (i): %d\n&#34;, i);

        for (int j = 1; j &lt;= 200; ++j) {
            printf(&#34;    inner iteration (j): %d\n&#34;, j);
            if (j &gt;= 3) {
                break; // breaks from inner loop, outer loop continues
            }
            if (i &gt;= 2) {
                goto outer; // breaks from outer loop, and directly to &#34;Done!&#34;
            }
        }
    }
outer:

    puts(&#34;Done!&#34;);

    return 0;
}
</code></pre>

<p>We can use <a href="https://beej.us/guide/bgc/html/split/goto.html#labeled-continue">analogous mechanism for <code>continue</code></a>.</p>



<p><em>Beej&#39;s Guide to C Programming</em> has nice example of using this technique alongside the cleanup one:</p>

<blockquote>
  <pre><code>    for (...) {
        for (...) {
            while (...) {
                do {
                    if (some_error_condition) {
                        goto bail;
                    }
                    // ...
                } while(...);
            }
        }
    }

bail:
    // Cleanup here
</code></pre>

  <p>Without <code>goto</code>, you’d have to check an error condition
flag in all of the loops to get all the way out.</p>
</blockquote>

    

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 130" style="font-family: Times">
  <g fill="#ffffff" stroke="#ffffff">
    <ellipse cx="80" cy="100" rx="10" ry="10"></ellipse>
    <ellipse cx="160" cy="101" rx="10" ry="10"></ellipse>
    <ellipse cx="120" cy="41" rx="10" ry="10"></ellipse>
  </g>

  <g fill="black">
    <text x="73" y="106">A</text>
    <text x="154" y="107">B</text>
    <text x="113" y="47">C</text>
  </g>

  <g fill="white">
    <g stroke="white">
      <path d="M 80 91 L 80 51 Q 80 41 90 41 L 105.88 41" fill="none"></path>
      <path d="M 108.88 41 L 104.88 43 L 105.88 41 L 104.88 39 Z"></path>

      <path d="M 130 41 L 150 41 Q 160 41 160 51 L 160 86.88" fill="none"></path>
      <path d="M 160 89.88 L 158 85.88 L 160 86.88 L 162 85.88 Z"></path>

      <path d="M 152.93 108.07 Q 140 121 120 121 Q 100 121 89.98 110.98" fill="none"></path>
      <path d="M 87.86 108.86 L 92.1 110.28 L 89.98 110.98 L 89.28 113.1 Z"></path>

      <path d="M 87.07 93.93 Q 100 81 120 81 Q 140 81 150.02 91.02" fill="none"></path>
      <path d="M 152.14 93.14 L 147.9 91.72 L 150.02 91.02 L 150.72 88.9 Z"></path>

      <path d="M 112.93 33.93 Q 113 11 120 11 Q 127 11 127.06 29.81" fill="none"></path>
      <path d="M 127.00 32.81 L 125.06 28.82 L 127.06 29.81 L 129.06 28.8 Z"></path>

      <path d="M 80 111 Q 80 131 70 126 Q 60 121 70.02 110.98" fill="none"></path>
      <path d="M 72.14 108.86 L 70.72 113.1 L 70.02 110.98 L 67.9 110.28 Z"></path>

      <path d="M 160 111 Q 160 131 170 126 Q 180 121 169.98 110.98" fill="none"></path>
      <path d="M 167.86 108.86 L 172.1 110.28 L 169.98 110.98 L 169.28 113.1 Z"></path>

      <path d="M 30 91 L 66 100" fill="none"></path>
      <path d="M 68.92 100.73 L 64.55 101.7 L 66 100 L 65.52 97.82 Z"></path>

      <path d="M 170 101 L 206 92" fill="none"></path>
      <path d="M 208.92 91.27 L 205.52 94.18 L 206 92 L 204.55 90.3 Z"></path>
    </g>

    <text x="16" y="90">S</text>
    <text x="214" y="90">F</text>

    <g font-size="0.7em">
      <text x="117" y="7">x</text>

      <text x="70" y="55">y</text>
      <text x="165" y="55">z</text>

      <text x="117" y="75">x</text>
      <text x="117" y="115">y</text>

      <text x="55" y="125">z</text>
      <text x="180" y="125">x</text>

      <text x="180" y="90" font-style="italic">nul</text>
    </g>
  </g>
</svg>

<p>The following is a 1:1, not far from <strong>verbatim mathematical notation</strong>,
implementation of the above state machine:</p>

<pre><code>_Bool machine(const char* c)
{
qA:
    switch (*(c++)) {
        case &#39;x&#39;: goto qB;
        case &#39;y&#39;: goto qC;
        case &#39;z&#39;: goto qA;
        default: goto err;
    }

qB:
    switch (*(c++)) {
        case &#39;x&#39;: goto qC;
        case &#39;z&#39;: goto qB;
        case &#39;\0&#39;: goto F;
        default: goto err;
    }

qC:
    switch (*(c++)) {
        case &#39;x&#39;: goto qB;
        case &#39;y&#39;: goto qA;
        default: goto err;
    }

F:
    return true;

err:
    return false;
}
</code></pre>

    

<p>Yeah, yeah, I know jumping <em>into</em> warrants at least a raised eyebrow.
That being said, there are cases when you may want to do just that.</p>

<p>Here in first iteration program skips increasing variable and goes straight
to allocation. Each following iteration executes code as written, ignoring
completely the label relevant only for the first run; so you do too during
analysis.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;fancy_alloc.h&gt;

int main()
{
    int* buf = NULL;
    size_t pos = 0;
    size_t sz = 8;

    int* temp;

    goto ALLOC;
    do {
        if (pos &gt; sz) { // resize array
            sz *= 2;
ALLOC:      temp = arrayAllocSmart(buf, sz, pos);
            /* check for errors */
            buf = temp;
        }

        /* do something with buf */
    } while (checkQuit());

    return 0;

    /* handle errors ... */
}
</code></pre>
<h3 id="goto-less-alternative-1-guard-flag">
  
  
    <code>goto</code>-less alternative 1: guard flag <a href="#goto-less-alternative-1-guard-flag">#</a>
  
  
</h3>
    

<p>I probably says more about the state of my sleep deprived brain than anything
else, but I actually managed to make an honest, very dumb mistake in this
simple snippet. I didn&#39;t notice until after examining the assembly output
and seeing way less instructions than expected. Since it&#39;s simple, yet quite
severe in consequences, I decided to leave it as an exercise for the reader
to spot the bug (should be easy since you already know about its existence).</p>

<p>The drawbacks as per usual: nesting and keeping track of flags.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;fancy_alloc.h&gt;

int main()
{
    int* buf = NULL;
    size_t pos = 0;
    size_t sz = 8;

    int ret = 0

    _Bool firstIter = true;

    do {
        if (pos &gt; sz || firstIter) { // resize array
            if (!firstIter) {
                sz *= 2;
                firstIter = false;
            }

            int* temp = arrayAllocSmart(buf, sz, pos);
            /* handle errors ... */
            buf = temp;
        }

        /* do something with buf */
    } while (checkQuit());

    return 0;
}
</code></pre>
<h3 id="goto-less-alternative-2-code-duplication">
  
  
    <code>goto</code>-less alternative 2: code duplication <a href="#goto-less-alternative-2-code-duplication">#</a>
  
  
</h3>
    

<p>The drawback is obvious, thus no further comment.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;fancy_alloc.h&gt;

int main()
{
    size_t pos = 0;
    size_t sz = 8;

    int* buf = arrayAllocSmart(NULL, sz, pos);
    /* handle errors ... */

    do {
        if (pos &gt; sz) { // resize array
            sz *= 2;
            int* temp = arrayAllocSmart(buf, sz, pos);
            /* handle errors ... */
            buf = temp;
        }

        /* do something with buf */
    } while (checkQuit());

    return 0;
}
</code></pre>

    







    

<p>Read at:
  <a href="https://dl.acm.org/doi/epdf/10.1145/356635.356640">[ACM Digital Library]</a>
  <a href="https://pic.plover.com/knuth-GOTO.pdf">[PDF]</a>
  <a href="http://www.kohala.com/start/papers.others/knuth.dec74.html">[HTML]</a></p>

<p>If I started from Dijkstra, it&#39;s only natural I need to conclude with Knuth. </p>

<blockquote>
  <p>One thing we haven&#39;t spelled out clearly, however, is what makes some
<strong>go to</strong>&#39;s bad and others acceptable. The reason is that we&#39;ve really
been directing our attention to the wrong issue, to the objective question of
<strong>go to</strong> elimination instead of the important subjective question of
program structure. In the words of John Brown, &#34;The act of focusing our
mightiest intellectual resources on the elusive goal of <strong>go to</strong>-less
programs has helped us get our minds off all those really tough and possibly
unresolvable problems and issues with which today&#39;s professional programmer
would otherwise have to grapple.&#34; By writing this long article I don&#39;t want
to add fuel to the controversy about go to elimination, since that topic
has already assumed entirely too much significance; my goal is to lay that
controversy to rest, and to help direct the discussion towards more fruitful
channels.</p>
</blockquote>


<time datetime="2023-02-26T00:00:00+00:00">2023-02-26</time>

  </div></div>
  </body>
</html>
