<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neugierig.org/software/blog/2022/10/retrowin32.html">Original</a>
    <h1>Retrowin32, a Win32 emulator</h1>
    
    <div id="readability-page-1" class="page"><div>



<p>My first <a href="https://neugierig.org/software/blog/2022/09/break.html">post-Figma</a>
hobby project is a win32 emulator I&#39;ve called
<a href="https://github.com/evmar/retrowin32">retrowin32</a>. It is now barely capable of
executing a few unmodified Windows exe files in a browser (see the site for some
links).</p>
<p>I think I started thinking about this idea when I read the remark &#34;win32 is the
stable Linux userland ABI&#34;. That is, Linux churns so much that a given program
written today won&#39;t work in a year; meanwhile, programs written in the Windows
95 32-bit era are guaranteed to never change again. You can kinda look at win32
(that is, 32-bit Windows) today as similar to a NES — an old platform that you
can emulate by &#34;just&#34; emulating all the chips.</p>
<p>There are other projects to run old Windows programs.
<a href="https://en.wikipedia.org/wiki/WoW64">WoW64</a> is the name of the system within
64-bit Windows that makes old 32-bit Windows programs run.
<a href="https://www.winehq.org/">Wine</a> shims the Windows API onto your host system —
see the great <a href="https://werat.dev/blog/how-wine-works-101/">How Wine works</a> for a
deep dive on what that means. And system emulator projects like
<a href="https://www.qemu.org/">qemu</a> emulate a full x86 machine such that you can
install Windows onto them. But Wow64 requires running 64-bit Windows, Wine
requires x86 hardware, and qemu requires installing the full Windows OS into the
emulator to run a Windows program.</p>
<p>In contrast, my toy emulates an x86 and enough of the Windows API to take a
plain exe file and run it directly in my browser. It&#39;s definitely still at the
&#34;toy&#34; phase of things but I&#39;ve only been tinkering on it a month and it&#39;s been
fun — exactly the kind of &#34;not very useful but brain-tickling&#34; kind of work I
would love to be able to retire and spend my days on.</p>
<h2>How it works</h2>
<p>There&#39;s two major pieces to emulating a Windows program, the x86 part and the
Windows part.</p>
<p>Fundamentally a Windows program includes x86 instructions, so you need to
emulate an x86. I made the dumbest slowest thing that iterates the instruction
stream and runs the operations as it sees them. In contrast, qemu has a
<a href="https://www.usenix.org/legacy/event/usenix05/tech/freenix/full_papers/bellard/bellard.pdf">neat technique</a>
for an architecture-independent(!) JIT for x86 code. (I really recommend the
paper, it&#39;s an easy read and pretty rad approach — pretty much what you&#39;d
expect from a genius like Bellard...). I think the
<a href="https://leaningtech.com/webvm/">CheerpX</a> people have done a similar thing
targeting Wasm, though I can&#39;t find much about it. I&#39;m interested in looking
into this area in general but I haven&#39;t yet.</p>
<p>The other piece to running a Windows program is all the things that make Windows
distinct from other x86 operating systems. A Windows exe file encodes a bunch of
information about how the file is to be loaded into memory and in particular
which calls it makes into the massive Windows API. retrowin32 loads such a file
into its simulated x86 memory and provides implementations of the API (more on
that in a sec).</p>
<h2>File formats</h2>
<p>It&#39;s kind of amazing to look at the archaeology of how Windows works because
it&#39;s the accumulation of cruft over literally decades. For example every exe
file first begins with a DOS program that prints &#34;This program cannot be run in
DOS mode&#34; followed by more headers that are then parsed by Windows. All over the
various formats there are places where things feel like they were retrofitted in
later — for example in the BMP format if the encoded image height is negative
that means the encoded pixel rows are top-down (vs BMP&#39;s default bottom-up).
Resources (static structured data like menus and icons) are modeled using a
generic nested directory structure of blocks pointing to child blocks, only to
only ever be used to have exactly three levels of nesting. And so on.</p>
<p>It&#39;s easy to say from today&#39;s world of JSON and protobufs that it feels much
more obvious that a file format benefits from having a unified structure that
has evolution built in. A lot of parsing PE ends up with one-offy like &#34;if the
high bit is set that means this is an integer, otherwise it&#39;s an offset relative
to some other field that points at a string&#34; kinds of encoding. In contrast, for
example Figma files are (mostly) in the <a href="https://github.com/evanw/kiwi">kiwi</a>
format (basically the same idea as protobuf) so the parser for them is a simple
codegen problem.</p>
<h2>Hooking the Windows API</h2>
<p>At a high level, DLLs work like this. The program&#39;s code at various points will
say &#34;call the function at memory address X&#34; for some specific X. Then there&#39;s a
table available at load time that says &#34;on startup, put the address of
user32.dll&#39;s LoadIconA function at address X&#34;. What retrowin32 does instead is
poke a special otherwise-inaccessible address at those locations. Then if the
CPU ever attempts to jump to one of these addresses, it instead calls out to my
custom implementations of these functions. (You can click &#39;imports&#39; in the UI to
see these.)</p>
<p>It&#39;s a curious echo of how Wasm vs the host system works. My functions are
passed parameters such as addresses, but those addresses refer to data within
the emulator&#39;s memory. And similarly to return data they must poke that data
back into the emulator&#39;s memory.</p>
<p>There&#39;s a further layer of indirection because the ultimate target of many of
these calls the TypeScript running the web page. So for example a call to
<code>WriteFile()</code> that passes the stdout handle will first jump to my <code>WriteFile()</code>
implementation, which then decodes the arguments and forwards them onward (via a
Wasm bridge) to a TypeScript interface.</p>
<h2>COM and DirectDraw</h2>
<p>One of the finickiest pieces of this so far has been
<a href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a>, which is (in part)
roughly the Windows mechanism for doing dynamic probing of API. In particular
DirectDraw (the &#34;fast&#34; graphics API) uses it.</p>
<p>Let me take a deep breath and try to describe the <code>DirectDrawCreate</code> function:</p>
<ul>
<li>It takes a parameter, a pointer.</li>
<li>Into that pointer the implementation writes a pointer to an <code>IDirectDraw</code>.</li>
<li>An <code>IDirectDraw</code> structure begins with a pointer to a vtable.</li>
<li>The vtable then has pointers to more functions.</li>
</ul>
<p>And those functions themselves may return further DirectDraw objects! DirectDraw
surfaces themselves get plumbed up to eventually map onto HTML <code>&lt;canvas&gt;</code>
elements. In all there are a lot of pointers, as well as multiple different
memory spaces, to keep straight.</p>
<h2>Old goop</h2>
<p>In getting the basic DirectDraw demo (see link on the project site) going I was
surprised by how much API I had to implement. It turns out that between the
kernel loading the executable and C reaching the <code>main()</code> function, there&#39;s a
ton of stuff getting computed — all this parsing of the command line and the
environment and so on. It&#39;s interesting how even in a low-level language like C
complexity has accumulated.</p>
<p>(If you load the demo, click &#34;imports&#34; in the lower left to see a dump of all
the Windows functions this program uses. All that to show a spinny car.)</p>
<h2>Debugging</h2>
<p>To get everything working (to the weak extent it does) I definitely spent some
quality time with a debugger on the Windows side of things. In particular it&#39;s
been fun learning <a href="https://ghidra-sre.org/">Ghidra</a> and mapping out my best
guesses of what executables are attempting.</p>
<p>Special shout out here to <a href="http://www.deanmcnamee.com/">Dean</a>, one of the
gnarliest hackers I know, for helping me talk through some of this.</p>
<p>Meanwhile, I also needed to debug what was going on within the emulator, so
there&#39;s a web UI on top of the whole thing that lets me single step and examine
the state. (I know the UI isn&#39;t great, sorry!) So on top of the emulator I guess
I&#39;ve built the beginnings of an x86/win32 debugger.</p>
<p>I think having a web frontend to it ends up a pretty powerful approach, though
maybe this is biased by my experience in web things. For one small example, if
you click the memory tab in the UI and then click an address in the instruction
stream it will jump the view to that address, and there are further effects on
mouse hover. Implementing that kind of UI is trivial with tools like React.</p>
<p>On the other hand, I&#39;m also pretty deep in a stack of technology, between x86
and Rust and Wasm and TypeScript, so it&#39;s possible a more straightforward simple
thing would&#39;ve been easier to put together.</p>
<p>(The way the code is structured it ought to be relatively easy to write a native
frontend for the emulator, one that doesn&#39;t involve any web stuff at all.
There&#39;s a &#34;Host&#34; abstraction that is implemented by a Wasm bridge but it could
just as well have been SDL.)</p>
<h2>Where I&#39;m headed</h2>
<p>The thing that started me down this path was looking at
<a href="https://www.pouet.net/prod.php?which=567">one of my favorite demos</a> and being
sad that I basically can&#39;t run this anymore. I tinkered a lot with trying to get
it to run under qemu running an old Windows but it would just close on startup,
maybe something about DirectDraw init failing? I ended up debugging it on a
native Windows computer, but that computer is getting pretty old.</p>
<p>It feels like there was kind of a sweet spot before GPUs took over everything
where there&#39;s software like demos and games that likely don&#39;t require a lot of
Windows API and are possibly old enough to be possible to emulate on one of
these fast new Macs. It remains to be seen whether I am ever able to actually
successfully execute <code>chillin.exe</code> — in particular I haven&#39;t thought much yet
about sound and also it possibly uses threads, eek, and maybe it will still be
too slow — but in all I feel like even if I fail, the general idea here is one
whose time has come.</p>

</div></div>
  </body>
</html>
