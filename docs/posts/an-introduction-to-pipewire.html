<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bootlin.com/blog/an-introduction-to-pipewire/">Original</a>
    <h1>An Introduction to PipeWire</h1>
    
    <div id="readability-page-1" class="page"><article id="post-16168">
	<!-- .entry-header -->

	
	
	<div>
		<p>This blog post is the first part of a series of 3 articles related to the PipeWire project and its usage in embedded Linux systems.</p>

<p><a href="https://pipewire.org/"><strong>PipeWire</strong></a> is a graph-based processing engine, that focuses on handling multimedia data (audio, video and <a href="https://www.midi.org/">MIDI</a> mainly).</p>
<p>It has gained steam early on by allowing screen sharing on <a href="https://wayland.freedesktop.org/">Wayland</a> desktops, which for security reasons, does not allow an application to access any framebuffer that does not concern it. The PipeWire daemon was run with sufficient privileges to access screen data; giving access through a <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> service to requesting applications, with file-descriptor passing for the actual video transfer. It was as such bundled in the <a href="https://getfedora.org/">Fedora distribution</a>, <a href="https://fedoramagazine.org/whats-new-fedora-27-workstation/">version 27</a>.</p>
<p>Later on, the idea was to expand this to also allow handling audio streams in the processing graph. Big progress has been done by Wim Taymans on this front, and PipeWire is now the default sound server of the desktop Fedora distribution, since <a href="https://fedoraproject.org/wiki/Releases/34/ChangeSet#Route_all_Audio_to_PipeWire">version 34</a>.</p>
<p>The project is currently in active development. It happens in the open, lead by Wim Taymans. The API and ABI can both be considered stable, even though version 1.0 has not been released yet. <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/NEWS">The changelog</a> exposes very few breaking changes (two years without one) and many bug fixes. It is developed in C, using a <a href="https://mesonbuild.com/">Meson</a> and <a href="https://ninja-build.org/">Ninja</a> based build system. It has very few unconditional runtime dependencies, but we’ll go through those during our first install.</p>
<p>Throughout this series of blog articles, our goal will be to discover PipeWire and the possiblities it provides, focusing upon audio usage on embedded platforms. A detailed theoretical overview at the start will allow us to follow up with a hands-on approach. Starting with a minimal Buildroot setup on a <a href="https://www.microchip.com/en-us/development-tool/atsama5d3-xpld">Microchip SAMA5D3 Xplained</a> board, we will create then our own custom PipeWire source node. We will then study how dynamic, low-latency routing can be done. We’ll end with experiments regarding audio-over-ethernet.</p>
<p>A note: we will start with many theoretical aspects, that are useful to get a good mental model of the way PipeWire works and how it can be used to implement any wanted behavior. This introduction might therefore get a little exhaustive at times, and it could be a good approach to skip even if a concept isn’t fully grasped, to come back later during hands-ons when details on a specific subject is required.</p>
<h2>Sky-high overview</h2>
<p>A PipeWire graph is composed of <strong>nodes</strong>. Each node takes an arbitrary number of inputs called <strong>ports</strong>, does some processing over this multimedia data, and sends data out of its output ports. The edges in the graph are here called <strong>links</strong>. They are capable of connecting an output port to an input port.</p>
<p>Nodes can have an arbitrary number of ports. A node with only output ports is often called a source, and a sink is a node that only possesses input ports. For example, a stereo ALSA PCM playback device can be seen as a sink with two input ports: front-left and front-right.</p>
<p>Here is a visual representation of a PipeWire graph instance, provided by the <a href="https://gitlab.freedesktop.org/pipewire/helvum">Helvum GTK patchbay</a>:</p>
<figure id="attachment_16175" aria-describedby="caption-attachment-16175"><a href="https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum.png"><img src="https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum.png" alt="" width="979" height="359" srcset="https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum.png 979w, https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum-300x110.png 300w, https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum-768x282.png 768w, https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum-24x9.png 24w, https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum-36x13.png 36w, https://bootlin.com/wp-content/uploads/2022/06/custom-source-remote-helvum-48x18.png 48w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a><figcaption id="caption-attachment-16175">Screenshot provided by the Helvum project</figcaption></figure>
<p>Visual attributes are used in Helvum to describe the state of nodes, ports and links:</p>
<ul>
<li>Node names are in white, with their ports being underneath the names. Input ports are on the left while output ports are on the right.</li>
<li>“Dummy-Driver” and “Freewheel-Driver” nodes have no ports. Those two are particular sinks (with dynamic input ports, that appear when we connect a node to them) used in specific conditions by PipeWire.</li>
<li>Red means MIDI, yellow means video and blue means audio.</li>
<li>Links are solid when active (data is “passing-through” them) and dashed when in a paused state.</li>
</ul>
<p>Note: if your Linux desktop is running PipeWire, trying installing Helvum to graphically monitor and edit your multimedia graph! It is currently packaged on <a href="https://packages.fedoraproject.org/pkgs/rust-helvum/helvum/">Fedora</a>, <a href="https://archlinux.org/packages/community/x86_64/helvum/">Arch Linux</a>, <a href="https://flathub.org/apps/details/org.pipewire.Helvum">Flathub</a>, <a href="https://crates.io/crates/helvum">crates.io</a> and <a href="https://repology.org/project/helvum/versions">others</a>.</p>
<h2>Design choices</h2>
<p>There are a few noticeable design choices that explain why PipeWire is being adopted for desktop and embedded Linux use cases.</p>
<h3>Session and policy management</h3>
<p>One first design choice was to <strong>avoid tackling any management logic directly inside PipeWire</strong>; context-dependent behaviour such as monitoring for new ALSA devices, and configuring them so that they appear as nodes, or automatically connecting nodes using links is not handled. It rather provides an API that allows spawning and controlling those graph objects. This API is then relied upon by client processes to control the graph structure, without having to worry about the graph execution process.</p>
<p>A pattern that is often used and is recommended is to have a single client be a daemon that deals with the whole session and policy management. Two implementations are known as of today:</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/pipewire/media-session">pipewire-media-session</a>, which was the first implementation of a session manager. It is now called an example and used mainly in debugging scenarios.</li>
<li><a href="https://pipewire.pages.freedesktop.org/wireplumber/"><strong>WirePlumber</strong></a>, which takes a modular approach: it provides another, higher-level API compared to the PipeWire one, and runs <a href="https://www.lua.org/">Lua</a> scripts that implement the management logic using the said API. In particular, this session manager gets used in Fedora since <a href="https://fedoraproject.org/wiki/Releases/35/ChangeSet#Switch_to_WirePlumber_as_the_PipeWire_session_manager">version 35</a>. It ships with default scripts and configuration that handle linking policies as well as monitoring and automatic spawning of <a href="https://alsa.opensrc.org/Device">ALSA</a>, <a href="http://www.bluez.org/">bluez</a>, <a href="https://www.libcamera.org/">libcamera</a> and <a href="https://www.kernel.org/doc/html/v5.18/userspace-api/media/v4l/v4l2.html">v4l2</a> devices. The API is available from any process, not only from WirePlumber’s Lua scripts.</li>
</ul>
<h3>Individual node execution</h3>
<p>As described above, the PipeWire daemon is responsible for handling the proper processing of the graph (executing nodes in the right order at the right time and forwarding data as described by links) and exposing an API to allow authorized clients to control the graph. Another key point of PipeWire’s design is that <strong>the node processing can be done in any Linux process</strong>. This has a few implications:</p>
<ul>
<li>The PipeWire daemon is capable of doing some node processing. This can be useful to expose a statically-configured ALSA device to the graph for example.</li>
<li>Any authorized process can create a PipeWire node and be responsible for the processing involved (getting some data from input ports and generating data for output ports). A process that wants to play stereo audio from a file could create a node with two output ports.</li>
<li>A process can create multiple PipeWire nodes. That allows one to create more complex applications; a browser would for example be able to create a node per tab that requests the ability to play audio, letting the session manager handle the routing: this allows the user to route different tab sources to different sinks. Another example would be an application that requires many inputs.</li>
</ul>
<h3>API and backward compatibility</h3>
<p>As we will see later on, PipeWire introduces a new API that allows one to read and write to the graph’s overall state. In particular, it allows one to implement a source and/or sink node that will be handling audio samples (or other multimedia data).</p>
<p>One key point for PipeWire’s quick adoption is a focus on <strong>providing a shim layer to currently-widespread audio API</strong> in the Linux environment. That is:</p>
<ul>
<li>
<ul>
<li>It can obviously expose <a href="https://www.alsa-project.org/">ALSA</a> sinks or sources inside the graph. This is at the heart of what makes PipeWire useful: it can interact with local audio hardware. It uses <a href="https://www.alsa-project.org/alsa-doc/alsa-lib/">alsa-lib</a> as any other ALSA client. PipeWire is also capable of creating virtual ALSA sinks or sources, to interface with applications that rely solely upon the <a href="https://www.alsa-project.org/alsa-doc/alsa-lib/">alsa-lib</a> API.</li>
<li>It can implement the <a href="https://www.freedesktop.org/wiki/Software/PulseAudio/">PulseAudio</a> API in place of PulseAudio itself. This simply requires starting a second PipeWire daemon, with a specific pulse configuration. Each PulseAudio sink/source will appear in the graph, as if native. PulseAudio is the main API used by Linux desktop users and this feature allows PipeWire to be used as a daily-driver while supporting all standard applications. An anecdote: relying on the PulseAudio API is still recommended for simple audio applications, for its more widespread and simpler API.</li>
<li>It also implements the <a href="https://jackaudio.org/">JACK Audio Connection Kit</a> (or JACK); this API has been in use by the pro-audio audience and targets low-latency for audio and MIDI connections between applications. This requires calling JACK-based applications using <code>pw-jack COMMAND</code>, which does the following according to its <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/man/pw-jack.1.rst.in">manual page</a>:</li>
</ul>
</li>
</ul>
<blockquote><p><strong>pw-jack</strong> modifies the <code>LD_LIBRARY_PATH</code> environment variable so that applications will load PipeWire’s reimplementation of the JACK client libraries instead of JACK’s own libraries. This results in JACK clients being redirected to PipeWire.</p></blockquote>
<figure id="attachment_16176" aria-describedby="caption-attachment-16176"><a href="https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat.jpg"><img loading="lazy" src="https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat.jpg" alt="" width="1202" height="402" srcset="https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat.jpg 1202w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-300x100.jpg 300w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-1024x342.jpg 1024w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-768x257.jpg 768w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-1200x401.jpg 1200w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-24x8.jpg 24w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-36x12.jpg 36w, https://bootlin.com/wp-content/uploads/2022/06/schema-backward-compat-48x16.jpg 48w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a><figcaption id="caption-attachment-16176">Schema illustrating the way PulseAudio and JACK applications are supported</figcaption></figure>
<p>About compatibility with Linux audio standards, the PipeWire FAQ has an interesting answer to the expected question whenever something new appears: <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/FAQ#why-another-audio-standard-linux-already-has-13-of-them">why another audio standard, Linux already has 13 of them?</a> For exhaustiveness, here is a quick rundown of the answer: it describes how Linux has one kernel audio subsystem (ALSA) and only two userspace audio servers: PulseAudio and JACK. Others are either frameworks relying on various audio backends, dead projects or wrappers around audio backends. PipeWire’s goal, on the audio side, is to provide an alternative to both PulseAudio and JACK.</p>
<h3>Real-time execution: push or pull?</h3>
<p>In the simple case of a producer and a consumer of data, two execution models are in theory possible:</p>
<ul>
<li>Push, where the producer generates data when it can into a shared buffer, from which the consumer reads. This is often associated with blocking writes to signal the producer when the buffer is full.</li>
<li>Pull, where the producer gets signaled when data is needed for the consumer, at which point the producer should generate data as fast as possible into the given shared buffer.</li>
</ul>
<p>In a real-time case scenario, latency is optimal when the data quantity in the shared buffer is minimised: when the producer adds data to the buffer, all the data already present in the buffer needs to be consumed before the new data gets processed as well. As such, the pull method allows the system to monitor the shared buffer state and signal the producer before the shared buffer gets empty; this garanties data that is as up-to-date as possible as it was generated as late as possible.</p>
<p>That was for a generic overview of pushed versus pulled communication models. <strong>PipeWire adopts the pull model as it has low latencies as a goal.</strong> Some notes:</p>
<ul>
<li>The structure is more complex compared to a single producer and single consumer architecture, as there can be many more producers and consumers, possibly with nodes depending on multiple other nodes.</li>
<li>The PipeWire daemon handles the signaling of nodes. Those get woken up, fill a shared memory buffer and pass it onto its target nodes; those are the nodes that take its output as an input (as described by link objects).</li>
<li>The concept of driver nodes is introduced; other nodes are called followers. For each <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">component</a> (subgraph of the whole PipeWire graph), one node is the driver and is responsible for timing information. It is the one that signals PipeWire when a new execution cycle is required. For the simple case of an audio source node (the producer) and an ALSA sink node (the consumer), the ALSA sink will send data to the hardware according to a timer, signaling PipeWire to start a new cycle when it has no more data to send: it <strong>pulls</strong> data from the graph by telling it that it needs more.</li>
</ul>
<p>Note: in this simple example, the buffer size provided to ALSA by PipeWire determines the time we have to generate new data. If we fail to execute the entire graph in time before the timer, the ALSA sink node will have no data and this will lead to an underrun.</p>
<h2>Implementation overview</h2>
<p>This introduction and the big design decisions naturally lead us to have a look at the actual implementation concepts. Here are the questions we will try to answer:</p>
<ul>
<li>How is the graph state represented?</li>
<li>How can a client process get access to the graph state and make changes?</li>
<li>How is IPC communication handled?</li>
</ul>
<h3>Graph state representation: objects, objects everywhere</h3>
<p>As said previously, PipeWire’s goal is to maintain, execute and expose a graph-structured multimedia execution engine. The graph state is maintained by the PipeWire daemon, which runs <strong>the core object</strong>. A fundamental principle is the concept of an object. Clients communicate with the core using IPC, and can create objects of various types, which can then be exported. Exporting an object means telling the core and its <strong>registry</strong> about it, so that the object becomes a part of the graph state.</p>
<p>Every object have at least the following: a unique integer identifier, some permissions flags for various operations, an object type, string key-value pairs of properties, methods and event types.</p>
<h4>Object types</h4>
<p>There is a fixed type list, so let’s go through the main existing types to understand the overall structure better:</p>
<ul>
<li>The <strong>core</strong> is the heart of the PipeWire daemon. There can only be one core per graph instance and it has the identifier zero. It maintains <strong>the registry</strong>, which has the list of exported objects.</li>
<li>A <strong>client</strong> object is the representation of an open connection with a client process, from within the daemon process.</li>
<li>A <strong>module</strong> is a shared object that is used to add functionality to a PipeWire client. It has an initialisation function that gets called when the module gets loaded. Modules can be loaded in the core process or in any client process. Clients do not export to the registry the modules they load. We’ll see examples of modules and how to load them later on.</li>
<li>A <strong>node</strong> is a producer and/or consumer of data; its main characteristic is to have input and output port objects, which can be connected using link objects to create the graph structure.</li>
<li>A <strong>port</strong> belongs to a node and represents an input or output of data. As such, it has a direction, a data format and can have a channel position if it is audio data that is being transferred.</li>
<li>A <strong>link</strong> object connects two ports of opposite direction together; it describes a graph edge.</li>
<li>A <strong>device</strong> is a handle representing an underlying API, which is then used to create nodes or other devices. Examples of devices are ALSA PCM cards or V4L2 devices. A device has a profile, which allows one to configure them.</li>
<li>A <strong>factory</strong> is an object whose sole capability is to create other objects. Once a factory is created, it can only emit the type of object it declared. Those are most often delivered as a module: the module creates the factory and stays alive to keep it accessible for clients.</li>
<li>A <strong>session</strong> object is supposed to represent the session manager, and allow it to expose APIs through the PipeWire communication methods. It is not currently used by WirePlumber but this is planned.</li>
<li>An <strong>endpoint</strong> is the concept of a (possibly empty) grouping of nodes. Associated with endpoint streams and links, they can represent a higher-level graph that is handled by the session manager. Those would allow modeling complex behaviors such as mutually-exclusive sinks (think laptop speakers and line-out port) or nodes to which PipeWire cannot send audio streams, such as analog peripherals for which the streams do not go through the CPU. Those peripherals would therefore appear in the graph, be controlled with the same API (routing using links, setting volume, muting, etc.) but the processing would be done outside PipeWire’s reach. See <a href="https://docs.pipewire.org/page_objects_design.html">PipeWire’s documentation</a> for more information on the potential of those advanced features.</li>
</ul>
<h4>Permissions</h4>
<p>The session and policy manager (most often WirePlumber) is also responsible for defining the list of <strong>permissions</strong> each client has. Each permission entry is an object ID and four flags. A special <code>PW_ID_ANY</code> ID means that those permissions are the default, to be used if a specific object is not described by any other permission. Here are the four flags:</p>
<ul>
<li><strong>R</strong>ead: the object can be seen and events can be received;</li>
<li><strong>W</strong>rite: the object can be modified, usually through methods (which requires the execute flag);</li>
<li>e<strong>X</strong>ecute: methods can be called;</li>
<li><strong>M</strong>etadata: metadata can be set on the object.</li>
</ul>
<p>This isn’t well leveraged upon yet, as all clients get default permissions of <code>rwxm</code>: read, write, execute, metadata.</p>
<h4>Properties</h4>
<p>All objects also have <strong>properties</strong> attributed to them, which is a list of string key-value pairs. Those are abitrary and various keys are expected for various object types. An example link object has the following properties (as reported by <code>pw-cli dump LINK_ID</code>):</p>
<pre># Link ID
object.id = &#34;95&#34;

# Source port
link.output.node = &#34;91&#34;
link.output.port = &#34;93&#34;

# Destination port
link.input.node = &#34;80&#34;
link.input.port = &#34;86&#34;

# Client that created the link
client.id = &#34;32&#34;

# Factory that was called to create the link
factory.id = &#34;20&#34;

# Serial identifier: an incremental identifier that garanties no
# duplicate across a single instance. That exists because standard
# IDs get reused to keep them user-friendly.
object.serial = &#34;677&#34;
</pre>
<h4>Parameters</h4>
<p>Some object types also have <strong>parameters</strong> (often abbreviated as params), which is a fixed-length list of parameters that the object possesses, specific to the object type. Currently, nodes, ports, devices, sessions, endpoints and endpoint streams have those. Those params have flags that define if they can be read and/or written, allowing things like constant parameters defined at the object creation.</p>
<p>Parameters are the key that allow WirePlumber to <strong>negociate data formats and port configuration</strong> with nodes: hardware that supports multiple sample rates? channel count and positions? sample format? enable monitor ports? etc. Nodes expose enumerations of what they are capable of, and the session manager writes the format/configuration it chose.</p>
<h4>Methods &amp; events</h4>
<p>An object’s implementation is defined by its <strong>list of methods</strong>. Each object type has a list of methods that it needs to implement. One note-worthy method is <code>process</code>, that can be found on nodes. It is the one that eats up data from input ports and provides data for each output port.</p>
<p>Every object implement at least the <code>add_listener</code> method, that <strong>allows any client to register event listeners</strong>. Events are used through the PipeWire API to expose information about an object that might change over time (the state of a node for example).</p>
<h3>Exposing the graph to clients: libpipewire and its configuration</h3>
<p>Once an object is created in a process, it can be exported to the core’s registry so that it becomes a part of the graph. Once exported, an object is exposed and can be accessed by other clients; this leads us into this new section: how clients can get access and interact with the graph.</p>
<p>The easiest way to interact with a PipeWire instance is to rely upon the <code>libpipewire</code> shared object library. It is a C library that allows one to connect to the core. The connection steps are as follows:</p>
<ol>
<li>Initialise the library using <code>pw_init</code>, whose main goal is to setup logging.</li>
<li>Create an event-loop instance, of which PipeWire provides multiple implementations. The library will later plug into this event-loop to register event listeners when requested.</li>
<li>Create a PipeWire context instance using <code>pw_context_new</code>. The context will handle the communication process with PipeWire, adding what it needs to the event-loop. It will also find and parse a configuration file from the filesystem.</li>
<li>Connect the context to the core daemon using <code>pw_context_connect</code>. This does two things: it initialises the communication method and it returns <strong>a proxy</strong> to the core object.</li>
</ol>
<h4>Proxies</h4>
<p><strong>A proxy is an important concept.</strong> It gives the client a handle to interact with a PipeWire object which is located elsewhere but which has been registered in the core’s registry. This allows one to get information about this specific object, modify it and register <strong>event listeners</strong>.</p>
<p>Event listeners are therefore callbacks that clients can register on proxy objects using <code>pw_*_add_listener</code>, which takes a <code>struct pw_*_events</code> defining a list of function pointers; the star should be replaced by the object type. The <code>libpipewire</code> library will tell the remote object about this new listener, so that it notifies the client when a new event occurs.</p>
<p>We’ll take an example to describe the concept of proxies:</p>
<figure id="attachment_16177" aria-describedby="caption-attachment-16177"><a href="https://bootlin.com/wp-content/uploads/2022/06/schema-proxies.jpg"><img loading="lazy" src="https://bootlin.com/wp-content/uploads/2022/06/schema-proxies.jpg" alt="" width="642" height="376" srcset="https://bootlin.com/wp-content/uploads/2022/06/schema-proxies.jpg 642w, https://bootlin.com/wp-content/uploads/2022/06/schema-proxies-300x176.jpg 300w, https://bootlin.com/wp-content/uploads/2022/06/schema-proxies-24x14.jpg 24w, https://bootlin.com/wp-content/uploads/2022/06/schema-proxies-36x21.jpg 36w, https://bootlin.com/wp-content/uploads/2022/06/schema-proxies-48x28.jpg 48w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a><figcaption id="caption-attachment-16177">Schema of a daemon and two clients, with one client having a proxy pointing to the remote node</figcaption></figure>
<p>In this schema, green blocks are objects (the core, clients and a node) and grey ones are proxies. Dotted blocks represent processes. Here is what would happen, in order, assuming client process 2 wants to get the the state of a node that lives in client process 1:</p>
<ol>
<li>Client process 2 creates a connection with the core, that means:
<ul>
<li>On the daemon side, a client object is created and exported to the registry;</li>
<li>On the client side, a proxy to the core object is acquired, which represents the connection with the core.</li>
</ul>
</li>
<li>It then uses the proxy to core and the <code>pw_core_get_registry</code> function to get a handle on the registry.</li>
<li>It registers an event listener on the registry’s <code>global</code> event, by passing a <code>struct pw_registry_events</code> to <code>pw_registry_add_listener</code>. That event listener will get called once for each object exported to the registry.</li>
<li>The <code>global</code> event handler will therefore get called once with the node as argument. When this happens, a proxy to the node can be obtained using <code>pw_registry_bind</code> and the <code>info</code> event can be listened upon using <code>pw_node_add_listener</code> on the node proxy with a <code>struct pw_client_events</code> containing the list of function pointers used as event handlers.</li>
<li>The <code>info</code> event handler will therefore be called once with a <code>struct pw_node_info</code> argument, that contains the node’s state. It will then be called each time the state changes.</li>
</ol>
<p>The same thing is done in <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/doc/tutorial6.c">tutorial6.c</a> to print every clients’ information.</p>
<h4>Context configuration</h4>
<p>When a PipeWire context is created using <code>pw_context_new</code>, we mentioned that it finds and parses a configuration file from the filesystem. To find a configuration file, PipeWire requires its name. It then searches for this file in following locations, <code>$sysconfdir</code> and <code>$datadir</code> being PipeWire build variables:</p>
<ol>
<li>Firstly, it checks in <code>$XDG_CONFIG_HOME/pipewire/</code> (most probably <code>~/.config/pipewire/</code>);</li>
<li>Then, it looks in <code>$sysconfdir/pipewire/</code> (most probably <code>/etc/pipewire/</code>);</li>
<li>As a last resort, it tries <code>$datadir/pipewire/</code> (most probably <code>/usr/share/pipewire/</code>).</li>
</ol>
<p>PipeWire ships with default configuration files, which are often put in the <code>$datadir/pipewire/</code> path by distributions, meaning those get used as long as they have not been overriden by custom global configuration files (in <code>$sysconfdir/pipewire/</code>) or personal configuration files (in <code>$XDG_CONFIG_HOME/pipewire/</code>). Those are namely:</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/pipewire.conf.in">pipewire.conf</a>, the daemon’s configuration file;</li>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/pipewire-pulse.conf.in">pipewire-pulse.conf</a>, for the daemon process that implements the PulseAudio API;</li>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client.conf.in">client.conf</a>, for processes that want to communicate using the PipeWire API;</li>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client-rt.conf.in">client-rt.conf</a>, for processes that want to implement node processing, RT meaning realtime;</li>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/jack.conf.in">jack.conf</a>, used by the PipeWire implementation of the JACK shared object library;</li>
<li><a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/minimal.conf.in">minimal.conf</a>, meant as an example for those that want to run PipeWire without a session manager (static configuration of an ALSA device, nodes and links).</li>
</ul>
<p>The default configuration name used by a context is <code>client.conf</code>. This can be overriden either through the <code>PIPEWIRE_CONFIG_NAME</code> environment variable or through the <code>PW_KEY_CONFIG_NAME</code> property, given as an argument to <code>pw_context_new</code>. The search path can also be modified using the <code>PIPEWIRE_CONFIG_PREFIX</code> environment variable.</p>
<p>Make sure to go through one of them to get familiar with them! The format is described as a <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/spa/include/spa/utils/json.h#L44">“relaxed JSON variant”</a>, where strings do not need to be quoted, the key-value separator is an equal symbol, commas are unnecessary and comments are allowed starting with an hash mark. Here are the sections that can be found in a configuration file:</p>
<ul>
<li><code>context.properties</code>, that configures the context (log level, <a href="https://man7.org/linux/man-pages/man2/mlock.2.html">memory locking</a>, D-Bus support, etc.). It is also used extensively by <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/pipewire.conf.in#L11-47">pipewire.conf</a> (the daemon’s configuration) to configure the graph default and allowed settings.</li>
<li><code>context.spa-libs</code> defines the shared object library that should be used when a SPA factory is asked for. The default values are best to be kept alone.</li>
<li><code>context.modules</code> lists the PipeWire modules that should be loaded. Each entry has an associated comment that explains clearly what each modules does. As an example, the difference between <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client.conf.in">client.conf</a> and <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client-rt.conf.in">client-rt.conf</a> is the loading of <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/modules/module-rt.c">libpipewire-module-rt</a> that turns on real-time priorities for the process and its threads.</li>
<li><code>context.objects</code> allows one to statically create objects by providing a factory name associated with arguments. This is what is used by the daemon’s <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/pipewire.conf.in">pipewire.conf</a> to create the dummy node, or by <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/minimal.conf.in">minimal.conf</a> to statically create an ALSA device and node as well as a static node.</li>
<li><code>context.exec</code> lists programs that will be executed as childs of the process (using <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a> followed by <a href="https://www.man7.org/linux/man-pages/man3/exec.3.html">execvp(3)</a>). This was primarily used to start the session manager; it is however recommended to handle its boot separately, using your init system of choice.</li>
<li><code>filter.properties</code> and <code>stream.properties</code> are used in <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client.conf.in">client.conf</a> and <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/daemon/client-rt.conf.in">client-rt.conf</a> to configure node implementations. Filters and streams are the two abstractions that can be used to implement custom nodes, which we will talk in detail in a later article.</li>
</ul>
<h3>Inter-Process Communication (IPC)</h3>
<p>Being a project that handles multimedia data, transfers it in-between processes and aims for low-latency, the inter-process communication it uses is at the heart of its implementation.</p>
<h4>Event loop</h4>
<p>The event-loop described previously is the scheduling mechanism for every PipeWire process (the daemon and every PipeWire client process, including WirePlumber, pipewire-pulse and others). This loop is an abstraction layer over the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> facility. The concept is rather simple: it allows one to monitor multiple file descriptors with a single blocking call, that will return once one file descriptor is available for an operation.</p>
<p>The main entry point to this event loop is <code>pw_loop_add_source</code> or its wrapper <code>pw_loop_add_io</code>, which adds a new file descriptor to be listened for and a callback to take action once an operation is possible. In addition to the loop instance, the file descriptor and the callback, it takes the following arguments:</p>
<ul>
<li>A mask describing the operations for which we should be waken up: <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> is possible (<code>SPA_IO_IN</code>), <a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a> is possible (<code>SPA_IO_OUT</code>), an error occured (<code>SPA_IO_ERR</code>) and a hang-up occured (<code>SPA_IO_HUP</code>);</li>
<li>A boolean describing whether the file descriptor should be closed automatically at the end of not;</li>
<li>A void pointer given to the callback; this is often called user data which means we can avoid static global variables.</li>
</ul>
<p>Note: this event loop implementation is not reserved to PipeWire-related processing; it can be used as a main event loop in your processes.</p>
<p>That leads us to the other synchronisation and communication primitives used, which are all file-descriptor-based for integration with the event loop.</p>
<h4>File-descriptor-based IPC</h4>
<p><a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> is used as the main wake-up method when that is required, such as with node objects that must run their process method. <a href="https://man7.org/linux/man-pages/man2/signalfd.2.html">signalfd(2)</a> is used to register signal callbacks in the event-loop.</p>
<p>epoll(7), eventfd(2) and signalfd(2) being Linux-specific, it should be noted that there is an abstraction layer that allows one to use other primitives for implementations. Currently, <a href="https://xenomai.org">Xenomai</a> primitives are supported through this layer.</p>
<p>The main communication protocol is based upon a local streaming <a href="https://www.man7.org/linux/man-pages/man2/socket.2.html">socket(2)</a>: <code>socket(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)</code>. The encoding scheme used is called <a href="https://docs.pipewire.org/page_spa_pod.html">Plain Object Data (POD)</a> and is a rather simple format; a POD has a 32-bits size, a 32-bits type followed by the content. There are basic types (none, bool, int, string, bytes, etc.) and container types (array, struct, object and sequence). In top of this encoding scheme is provided the Simple Plugin API (SPA) which implements a sort of Remote Procedure Call (RPC). See this <a href="https://venam.nixers.net/blog/unix/2021/06/23/pipewire-under-the-hood.html#the-blocks-podspa">PipeWire under the hood</a> blog article that has a detailed section on POD, SPA and example usage of the provided APIs.</p>
<h4 id="dbus">D-Bus</h4>
<p>PipeWire and WirePlumber also optionally depend on the higher-level <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> communication protocol for specific features:</p>
<ul>
<li><a href="https://www.flatpak.org/">Flatpaks</a> are desktop sandboxed applications, that rely on <a href="https://docs.flatpak.org/en/latest/portal-api-reference.html">portal</a> (a process that exposes D-Bus interfaces) to access system-wide features such as printing and audio. In our case, <code>libpipewire-module-portal</code> allows the portal process to handle permission management relative to audio for Flatpak applications. See <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/blob/0.3.52/src/modules/module-portal.c">module-portal.c</a> and <a href="https://github.com/flatpak/xdg-desktop-portal">xdg-desktop-portal</a> for more information.</li>
<li>WirePlumber, through its <a href="https://gitlab.freedesktop.org/pipewire/wireplumber/-/tree/0.4.10/modules/module-reserve-device">module-reserve-device</a>, supports the <code>org.freedesktop.ReserveDevice1</code> D-Bus interface. It allows one to reserve an audio device for exclusive use. See the quick and to-the-point <a href="https://git.0pointer.net/reserve.git/tree/reserve.txt">specification about the interface</a> for more information.</li>
<li>D-Bus support is required if Bluetooth is wanted, to allow communication with the <a href="http://www.bluez.org/">BlueZ</a> process. See the <a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/tree/0.3.52/spa/plugins/bluez5">SPA bluez5 plugin</a>.</li>
</ul>
<h2>Conclusion</h2>
<p>Now that the overall concepts as well as design and implementation choices have been covered, it is time for some hands-on! We will carry on with a bare install based upon a Linux kernel and a Buildroot-built root filesystem image. Our goal will be to output sound to an USB ALSA PCM sink, from an audio file.</p>
<p>Do not hesitate to come back to this article later on, that might help you clear-up some blurry concepts if needed!</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
