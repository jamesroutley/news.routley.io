<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://harihareswara.net/posts/2022/standup-comedy-in-november-2022/">Original</a>
    <h1>Stand-up comedy in November</h1>
    
    <div id="readability-page-1" class="page"><section><div><p><img src="https://upload.wikimedia.org/wikipedia/en/thumb/4/43/Feed-icon.svg/1200px-Feed-icon.svg.png"/></p><p>I recently I fell down the rabbit hole of building a
<a href="https://github.com/Jackevansevo/feedreader">feedreader</a>. At the time I was
unsatisfied with the free tier offering of tools like inoreader and feedly, so
nautrally I figured I‚Äôd try and build my own, after all, how hard could it be?</p><p><span><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M506.3 417 293 53c-16.33-28-57.54-28-73.98.0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6c32.76.0 53.26-35 36.96-63zM232 168c0-13.25 10.75-24 24-24s24 10.8 24 24v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zm24 248c-17.36.0-31.44-14.08-31.44-31.44s14.07-31.44 31.44-31.44 31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z"></path></svg></span></span><span><strong>Aside:</strong> This was well before discovering <a href="https://miniflux.app/">miniflux</a>,
which is a fantastic piece of software. I‚Äôve since decommissioned <a href="https://github.com/Jackevansevo/feedreader">my own
attempt</a> and now happly self host
my own miniflux instance instead.</span></p><hr/><p>Here‚Äôs a non exhaustive list of issues I‚Äôve encountered along the way.</p><h2 id="1-atom-vs-rss">1. Atom vs RSS <span><a href="#1-atom-vs-rss" aria-label="Anchor">#</a></span></h2><p>I‚Äôll start with perhpas the most obvious‚Ä¶</p><p>There‚Äôs multiple different competing standards to subscribe to represent web
feeds. Each with it‚Äôs own specification, quirks and features.</p><p>Thankfully there‚Äôs a sufficient amount of overlap between specifications that
it‚Äôs possible to store data in a consistent normalised format. However doing so
isn‚Äôt always straightforward.</p><p>One of the first challenges I faced when ingesting data from different formats
was designing a consistent normalised representation. I wanted a single <code>feed</code>
table to handle data from both atom/rss feeds.</p><p>Here‚Äôs a comparison table I grabbed from the Wikiepdia page for <a href="https://en.wikipedia.org/wiki/RSS#RSS_compared_with_Atom">RSS compared
with Atom</a> which
lists all the equivalent elements.</p><table><thead><tr><th>RSS 2.0</th><th>Atom 1.0</th></tr></thead><tbody><tr><td>author</td><td>author*</td></tr><tr><td>category</td><td>category</td></tr><tr><td>channel</td><td>feed</td></tr><tr><td>copyright</td><td>rights</td></tr><tr><td>‚Äî</td><td>subtitle</td></tr><tr><td>description*</td><td>summary and/or content</td></tr><tr><td>generator</td><td>generator</td></tr><tr><td>guid</td><td>id*</td></tr><tr><td>image</td><td>logo</td></tr><tr><td>item</td><td>entry</td></tr><tr><td>lastBuildDate (in channel)</td><td>updated*</td></tr><tr><td>link*</td><td>link*</td></tr><tr><td>managingEditor</td><td>author or contributor</td></tr><tr><td>pubDate</td><td>published (subelement of entry)</td></tr><tr><td>title*</td><td>title*</td></tr><tr><td>ttl</td><td>‚Äî</td></tr></tbody></table><p>An RSS feed has a <code>description</code> whereas an Atom feed has a <code>subtitle</code>. If
you wanted to store this information as a generic ‚Äòfeed‚Äô representation what
would you name this column?</p><p>In this instance the choice of name for the intenral representation doesn‚Äôt
particularly matter as both fields are equivalent.</p><p>But what about fields that are available in one specification that aren‚Äôt
available in another? Where would you store this data?</p><p>If you‚Äôre lucky, your language of choice might have some decent open source
libraries to parse these feeds and return a abstract/normalised ‚Äòfeed‚Äô for you.
If not: writing a parser for these from scratch can be a bit tedious.</p><p>I started off using a great library called
<a href="https://pypi.org/project/feedparser/">feedparser</a>, which I found to be super
simple and robust (shoutout to the maintainers üëè). This which was excellent
for building a prototype, but further along in development I decided to
experiment with writing my own from scratch.</p><p>I was quickly able to parse a bulk of feeds that I subscribe to, but ran into a
few edge cases which required defensive code. The parser itself is still very
brittle. This gave me a real appreciation for libraries like feedparser and all
the corner cases they‚Äôre able to handle.</p><h2 id="2-finding-feed-links-inconsistent-conventions">2. Finding Feed Links (Inconsistent conventions) <span><a href="#2-finding-feed-links-inconsistent-conventions" aria-label="Anchor">#</a></span></h2><p>Lets say I come across a site <code>example.com</code> which I‚Äôd like to subscribe to via
RSS/Atom. How do I find the feed URL?</p><p>Typically I‚Äôll try and look for an RSS link/icon on the page itself and copy
this value and paste into my feed reader of choice. Or I‚Äôll inspect the page
source and hunt down the link by CTRL+F searching for different patterns.</p><figure><img srcset="/rss-inspect-element_hu426b13a9b4bd1197a688681a3db1eaed_95286_330x0_resize_box_3.png 330w,
/rss-inspect-element_hu426b13a9b4bd1197a688681a3db1eaed_95286_660x0_resize_box_3.png 660w,
/rss-inspect-element_hu426b13a9b4bd1197a688681a3db1eaed_95286_1024x0_resize_box_3.png 1024w,
/rss-inspect-element_hu426b13a9b4bd1197a688681a3db1eaed_95286_1320x0_resize_box_3.png 2x" src="https://jackevansevo.github.io/rss-inspect-element_hu426b13a9b4bd1197a688681a3db1eaed_95286_660x0_resize_box_3.png" alt="RSS Inspecting Page Source"/><figcaption>Viewing the page source to find RSS links</figcaption></figure><p>So far I‚Äôve come across the following common patterns:</p><ul><li><code>example.com/rss.xml</code></li><li><code>example.com/index.xml</code></li><li><code>example.com/feed.xml</code></li><li><code>example.com/atom.xml</code></li><li><code>example.com/feed</code></li><li><code>example.com/rss</code></li></ul><h3 id="the-problem-with-automating-this-approach">The problem with automating this approach <span><a href="#the-problem-with-automating-this-approach" aria-label="Anchor">#</a></span></h3><p>In an ideal world I‚Äôd like users to be able to just subscribe to <code>example.com</code>
without having to manually find this link. How would you go about doing this?</p><p>There‚Äôs a few steps I can think of</p><h4 id="strategy-1">Strategy 1. <span><a href="#strategy-1" aria-label="Anchor">#</a></span></h4><p>You could scrape <code>example.com</code> and search for something like:</p><div><pre tabindex="0"><code data-lang="html"><span><span><span>&lt;</span><span>link</span> <span>rel</span><span>=</span><span>&#34;alternate&#34;</span> <span>type</span><span>=</span><span>&#34;application/rss+xml&#34;</span> <span>title</span><span>=</span><span>&#34;Example&#34;</span> <span>href</span><span>=</span><span>&#34;/rss.xml&#34;</span><span>&gt;</span>
</span></span></code></pre></div><p>Not all sites include a link to the RSS feed in the site <code>meta</code> (Occsionally
you have to parse the HTML body).</p><h4 id="strategy-2">Strategy 2. <span><a href="#strategy-2" aria-label="Anchor">#</a></span></h4><p>If this fails you could naively fall back to scraping common patterns, i.e:
<code>/rss.xml | /index.xml</code> to see if any of these pages exist and then parse the
first result.</p><h4 id="strategy-3">Strategy 3. <span><a href="#strategy-3" aria-label="Anchor">#</a></span></h4><p>Or you could not bother at all and leave it up to the end user to be explicit
about what feed they wish to subscribe to.</p><h2 id="3-finding-entr-links">3. Finding Entr Links <span><a href="#3-finding-entr-links" aria-label="Anchor">#</a></span></h2><p>Some Atom feed links might contain <code>&lt;link rel=&#34;alternate&#34; type=&#34;text/html&#34;&gt;</code>
indicating this is very likely the link to the underlying item/entry (not some
other external link).</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;entry&gt;</span>
</span></span><span><span><span>&lt;title&gt;</span>2021-03-28<span>&lt;/title&gt;</span>
</span></span><span><span><span>&lt;link</span> <span>rel=</span><span>&#34;alternate&#34;</span> <span>type=</span><span>&#34;text/html&#34;</span> <span>href=</span><span>&#34;https://www.suckless.org/#2021-03-28&#34;</span><span>/&gt;</span>
</span></span><span><span><span>&lt;id&gt;</span>https://www.suckless.org/#2021-03-28T00:00Z<span>&lt;/id&gt;</span>
</span></span><span><span><span>&lt;updated&gt;</span>2021-03-28T00:00Z<span>&lt;/updated&gt;</span>
</span></span><span><span><span>&lt;published&gt;</span>2021-03-28T00:00Z<span>&lt;/published&gt;</span>
</span></span><span><span><span>&lt;content</span> <span>type=</span><span>&#34;html&#34;</span><span>&gt;</span>
</span></span><span><span><span>&lt;p&gt;</span>On Wednesday, 2021-03-31 there will be scheduled maintenance of the suckless servers. It&#39;s estimated this will take about 2-3 hours from about 19:00 to 21:00 - 22:00 UTC+02:00.<span>&lt;/p&gt;</span> <span>&lt;p&gt;</span>The mailinglist, website and source-code repositories will have some downtime.<span>&lt;/p&gt;</span> <span>&lt;p&gt;&lt;strong&gt;</span>Update:<span>&lt;/strong&gt;</span> the maintenance was finished at 2021-03-31 19:10 UTC+02:00. Please let us know if there are issues.<span>&lt;/p&gt;</span>
</span></span><span><span><span>&lt;/content&gt;</span>
</span></span><span><span><span>&lt;/entry&gt;</span>
</span></span></code></pre></div><p>Some Atom feeds just contain a <code>&lt;link href=&#34;&#34;&gt;</code></p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;entry&gt;</span>
</span></span><span><span>  <span>&lt;title&gt;</span>
</span></span><span><span>    Finding performance problems: profiling or logging?
</span></span><span><span>  <span>&lt;/title&gt;</span>
</span></span><span><span>  <span>&lt;link</span> <span>href=</span><span>&#34;https://pythonspeed.com/articles/logging-vs-profiling/&#34;</span><span>/&gt;</span>
</span></span><span><span>  <span>&lt;updated&gt;</span>2022-08-09T00:00:00+00:00<span>&lt;/updated&gt;</span>
</span></span><span><span>  <span>&lt;id&gt;</span>
</span></span><span><span>    https://pythonspeed.com/articles/logging-vs-profiling
</span></span><span><span>  <span>&lt;/id&gt;</span>
</span></span><span><span><span>&lt;/entry&gt;</span>
</span></span></code></pre></div><p>Some feed might contain a combination of both!</p><p>All this can make it tricky when finding the ‚Äòright‚Äô link for a particular
entry/item.</p><p>For example here‚Äôs some (pretty naive) parsing logic I have in my Atom parser to
find the ‚Äòbest‚Äô link for each entry:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>link</span><span>(</span><span>self</span><span>):</span>
</span></span><span><span>    <span>links</span> <span>=</span> <span>self</span><span>.</span><span>et</span><span>.</span><span>findall</span><span>(</span><span>&#34;link&#34;</span><span>,</span> <span>namespaces</span><span>=</span><span>self</span><span>.</span><span>nsmap</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>link</span> <span>in</span> <span>links</span><span>:</span>
</span></span><span><span>        <span># Return the best matching link</span>
</span></span><span><span>        <span>if</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;rel&#34;</span><span>)</span> <span>==</span> <span>&#34;alternate&#34;</span> <span>and</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;type&#34;</span><span>)</span> <span>==</span> <span>&#34;text/html&#34;</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;href&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>link</span> <span>in</span> <span>links</span><span>:</span>
</span></span><span><span>        <span>if</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;rel&#34;</span><span>)</span> <span>==</span> <span>&#34;alternate&#34;</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;href&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>link</span> <span>in</span> <span>links</span><span>:</span>
</span></span><span><span>        <span>if</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;rel&#34;</span><span>)</span> <span>==</span> <span>&#34;self&#34;</span> <span>or</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;rel&#34;</span><span>)</span> <span>==</span> <span>&#34;hub&#34;</span><span>:</span>
</span></span><span><span>            <span>continue</span>
</span></span><span><span>
</span></span><span><span>        <span>href</span> <span>=</span> <span>link</span><span>.</span><span>get</span><span>(</span><span>&#34;href&#34;</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>href</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>href</span>
</span></span><span><span>        <span>else</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>link</span><span>.</span><span>text</span>
</span></span></code></pre></div><h2 id="4-published-vs-updated">4. Published vs Updated <span><a href="#4-published-vs-updated" aria-label="Anchor">#</a></span></h2><p>An entry might have <code>updated</code> but not published. If you weren‚Äôt lucky enough to
scrape/fetch the feed when the entry contained <code>published</code> you‚Äôll never know.</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;entry&gt;</span>
</span></span><span><span>  <span>&lt;title&gt;</span>
</span></span><span><span>    Blah Blah Blah
</span></span><span><span>  <span>&lt;/title&gt;</span>
</span></span><span><span>  <span>&lt;link</span> <span>href=</span><span>&#34;https://example.com/articles/example/&#34;</span><span>/&gt;</span>
</span></span><span><span>  <span>&lt;updated&gt;</span>2022-08-09T00:00:00+00:00<span>&lt;/updated&gt;</span>
</span></span><span><span>  <span>&lt;content</span> <span>type=</span><span>&#34;html&#34;</span> <span>xml:base=</span><span>&#34;https://example.com/articles/example/&#34;</span><span>&gt;</span>
</span></span><span><span>    Blah Blah Blah
</span></span><span><span>  <span>&lt;/content&gt;</span>
</span></span><span><span><span>&lt;/entry&gt;</span>
</span></span></code></pre></div><p>In my feedreader backend I had to include the following default behaviour:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>if</span> <span>published</span> <span>is</span> <span>None</span> <span>and</span> <span>updated</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
</span></span><span><span>    <span># Just for sorting</span>
</span></span><span><span>    <span>published</span> <span>=</span> <span>updated</span>
</span></span></code></pre></div><h2 id="5-description-vs-content">5. Description vs Content <span><a href="#5-description-vs-content" aria-label="Anchor">#</a></span></h2><p>The description field is intended to be a little snippet/preview of the article/entry itself.</p><p>Then the bulk of the article should end up in <code>content</code> itself.</p><p>Of course in practice that‚Äôs not how it works.</p><p>Some feeds store the entire article body in <code>description</code> and don‚Äôt have an empty <code>content</code></p><p>Some feeds completely duplicate the article content across both <code>description</code> and <code>content</code></p><p>I attempt to handle these scenarios with something like:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>if</span> <span>content</span> <span>is</span> <span>None</span> <span>and</span> <span>summary</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
</span></span><span><span>    <span>content</span> <span>=</span> <span>summary</span>
</span></span><span><span>    <span>summary</span> <span>=</span> <span>None</span>
</span></span><span><span><span>elif</span> <span>summary</span> <span>==</span> <span>content</span><span>:</span>
</span></span><span><span>    <span>summary</span> <span>=</span> <span>None</span>
</span></span></code></pre></div><p>Some feeds have an empty <code>description</code> and only serve <code>content</code>. To resolve
this this I opt to show a preview of the article content in place of the
missing description.</p><div><pre tabindex="0"><code data-lang="jinja"><span><span><span>{%</span> <span>if</span> <span>entry.summary</span> <span>%}</span><span>
</span></span></span><span><span><span>  </span><span>{{</span> <span>entry.summary</span><span>|</span><span>truncatewords</span><span>:</span><span>50</span> <span>}}</span><span>
</span></span></span><span><span><span></span><span>{%</span> <span>elif</span> <span>entry.content</span> <span>%}</span><span>
</span></span></span><span><span><span>  </span><span>{{</span> <span>entry.content</span><span>|</span><span>truncatewords</span><span>:</span><span>50</span> <span>}}</span><span>
</span></span></span><span><span><span></span><span>{%</span> <span>endif</span> <span>%}</span><span>
</span></span></span></code></pre></div><p>Sometimes the entry can just be completely devoid of any information, I‚Äôve encountered feeds like:</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;entry&gt;</span>
</span></span><span><span>  <span>&lt;title/&gt;</span>
</span></span><span><span>  <span>&lt;id/&gt;</span>
</span></span><span><span>  <span>&lt;updated&gt;</span>0001-01-01T00:00:00Z<span>&lt;/updated&gt;</span>
</span></span><span><span>  <span>&lt;content/&gt;</span>
</span></span><span><span><span>&lt;/entry&gt;</span>
</span></span></code></pre></div><p>Some feeds only serve up the <code>description</code> and have a blank <code>content</code>, forcing
users to link through to read the article on the original site (semi defeating
the point of subscribing via feedreader)</p><p>If you‚Äôre writing any parser that attempts to ingest feed data you‚Äôll need
robust and resilient parsing logic to handle all these different edge cases or
recover from failures when you hit an unknown problem.</p><h2 id="6-datetime-fields-not-timezone-aware">6. Datetime fields not timezone aware <span><a href="#6-datetime-fields-not-timezone-aware" aria-label="Anchor">#</a></span></h2><p>Many feeds include timestamps that don‚Äôt include any timezone information. It‚Äôs
still unclear to me how to best handle this case.</p><p>In practice this might lead to bogus <code>published</code> or <code>updated</code> values because
the author is in a different timezone to you.</p><p>I.e. what happens if the Author is in a future timezone and they publish a post 5 hours ahead?</p><p>I opted not showing posts with published dates in the future, but this feels
like a compromise.</p><h2 id="7-db-size-constraints">7. DB Size Constraints <span><a href="#7-db-size-constraints" aria-label="Anchor">#</a></span></h2><p>Because the RSS and Atom feeds are pretty loose specs, they don‚Äôt (to my
knowledge) impose any size constraints on field contents.</p><p>This can be an issue if you‚Äôre hosting a service on the world wide web that let
users enter data. This arbitrarity means you‚Äôre going to have to make some of
these decisions yourself (for me some of these decisions were wrong).</p><p>If you‚Äôre planning on scraping feeds/entries and saving the contents to your
database there‚Äôre some key things to consider:</p><ul><li>What‚Äôs the max length a feed/entry title/subtitle?</li><li>How much content are you willing to store?</li><li>What happens when you encounter a field bigger than the max size?</li></ul><p>Early on I added constraints to my DB layer thinking I had sensible limits that
would never be exceeded. But frequently ran into exceptions for perfectly valid
feeds forcing me to re-evaluate and bump max limit</p><p>At some point however there might be a cut-off after which you want to reject
content beyond a certain size threshold.</p><h2 id="8-attempting-to-slugify-resources">8. Attempting to slugify resources <span><a href="#8-attempting-to-slugify-resources" aria-label="Anchor">#</a></span></h2><p>I wanted nice links internal to my site, i.e. if you subscribed to:</p><p><a href="https://overreacted.io/rss.xml">https://overreacted.io/rss.xml</a></p><p>Which has a Feed title of <code>Dan Abramov&#39;s Overreacted Blog RSS Feed</code></p><p>I wanted the URL for this feed to be:</p><ul><li><code>/feed/dan-abramovs-overreacted-blog-rss-feed/</code></li></ul><p>This turned out to be a bit of a mistake because not every feed title is
guaranteed to be something you can slugify.</p><p>As an example I came across <a href="http://benyu.org/feed">http://benyu.org/feed</a></p><p>Which has the title: <code>&lt;title&gt;-‚Ä¶ ‚Äî ‚Äî&lt;/title&gt;</code></p><p>Good lucky trying to slugify that ü§¶</p><h3 id="better-solution">Better Solution <span><a href="#better-solution" aria-label="Anchor">#</a></span></h3><p>Feedly, inoreader and miniflux wisely completely sidestep this problem by instead just URL encoding the feed URL, i.e.</p><p><a href="https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Foverreacted.io%2Frss.xml">https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Foverreacted.io%2Frss.xml</a></p><p><a href="https://www.inoreader.com/feed/https%3A%2F%2Foverreacted.io%2Frss.xml">https://www.inoreader.com/feed/https%3A%2F%2Foverreacted.io%2Frss.xml</a></p><p>In hindsight I should have done the same.</p><h2 id="9-relative-vs-absolute-links">9. Relative vs Absolute Links <span><a href="#9-relative-vs-absolute-links" aria-label="Anchor">#</a></span></h2><p>Most feeds are pretty good about this, but every so often I run into:</p><p>Links to items/entries being relative:</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;item&gt;</span>
</span></span><span><span>  <span>&lt;title&gt;</span>On being a staff engineer<span>&lt;/title&gt;</span>
</span></span><span><span>  <span>&lt;link&gt;</span>/blog/2022/08/on-being-a-staff-engineer/<span>&lt;/link&gt;</span>
</span></span><span><span><span>&lt;/item&gt;</span>
</span></span></code></pre></div><p>Top level links (which should be absolute links back to the site) being relative:</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;link</span> <span>href=</span><span>&#34;//navoshta.com/&#34;</span> <span>rel=</span><span>&#34;alternate&#34;</span> <span>type=</span><span>&#34;text/html&#34;</span><span>/&gt;</span>
</span></span></code></pre></div><p>Other times the link to the parent site is sometimes malformed or refers to the same URL as the feed itself (not the parent site)</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;link&gt;</span>https://snapcraft.io//blog/feed<span>&lt;/link&gt;</span>
</span></span></code></pre></div><p>All these are trivally solvable, but something to be aware of nonetheless.</p><h2 id="10-feeds-not-respecting-etag-and-last-modified-headers">10. Feeds not respecting ETag and Last-Modified Headers <span><a href="#10-feeds-not-respecting-etag-and-last-modified-headers" aria-label="Anchor">#</a></span></h2><p>Including an ETag or Last-Modified header in the body of a request when
fetching a feed is a mechanism to tell the server to only return new/modified
entries/items (aka: a changeset) since a specific date.</p><p>The <a href="https://feedparser.readthedocs.io/en/latest/">feedparser</a> documentation
has some <a href="https://feedparser.readthedocs.io/en/latest/http-etag.html#etag-and-last-modified-headers">great
documentation</a>
explaining this concept. I‚Äôll let the following code snippet explain what‚Äôs
going on:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> <span>import</span> <span>feedparser</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d</span> <span>=</span> <span>feedparser</span><span>.</span><span>parse</span><span>(</span><span>&#39;http://feedparser.org/docs/examples/atom10.xml&#39;</span><span>)</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d</span><span>.</span><span>etag</span>
</span></span><span><span><span>&#39;&#34;6c132-941-ad7e3080&#34;&#39;</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d2</span> <span>=</span> <span>feedparser</span><span>.</span><span>parse</span><span>(</span><span>&#39;http://feedparser.org/docs/examples/atom10.xml&#39;</span><span>,</span> <span>etag</span><span>=</span><span>d</span><span>.</span><span>etag</span><span>)</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d2</span><span>.</span><span>status</span>
</span></span><span><span><span>304</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d2</span><span>.</span><span>feed</span>
</span></span><span><span><span>{}</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d2</span><span>.</span><span>entries</span>
</span></span><span><span><span>[]</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> <span>d2</span><span>.</span><span>debug_message</span>
</span></span><span><span><span>&#39;The feed has not changed since you last checked, so</span>
</span></span><span><span><span>the</span> <span>server</span> <span>sent</span> <span>no</span> <span>data</span><span>.</span>  <span>This</span> <span>is</span> <span>a</span> <span>feature</span><span>,</span> <span>not</span> <span>a</span> <span>bug</span><span>!</span><span>&#39;</span>
</span></span></code></pre></div><p>This makes logic for ingesting feed data super straightforward as you have a
decent guarantee that the feed body is only going to contain new content.
There‚Äôs no need to check whether entries/items have already been
parsed/ingested in your engine.</p><p>This makes it relatively cheap and straightforward to update feeds which adhere
to this convention. You simply fan out a bunch of requests and discard any
responses with a <code>304</code> status.</p><p>However not all feeds/servers have logic in place to correctly parse/handle
these optional headers. Some feeds will happily return idenitcal content
repeatedly.</p><p>This shifts the responsibility of checking which posts are new new/updated onto
the parser, which can be tedious and computationally expensive. To handle such
feeds you have to traverse the entire response performing a comparison check
for each item/entry determine whether it‚Äôs been seen before.</p><p>If your feed parser is eager and parses the entire content of the feed ahead of
time i.e. parsing the entire item/entry body + fields (instead of just checking
the links/ids), this can be wasted computation.</p><p>In this scenario it makes more sense to utilize lazy parsing logic that
traverses the feed but only checks the link/id fields, skipping/discarding
other fields until strictly necessary (once you‚Äôve worked out an item/entry
requires parsing). But this is a minor performance optimization at the expense
of convenience.</p></div></section></div>
  </body>
</html>
