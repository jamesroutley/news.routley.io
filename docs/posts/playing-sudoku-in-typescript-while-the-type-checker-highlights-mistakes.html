<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gruhn/typescript-sudoku">Original</a>
    <h1>Playing Sudoku in TypeScript while the type checker highlights mistakes</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This is an experiment to precisely define a Sudoku type.
The goal is that we can play Sudoku in TypeScript while the type checker complains about mistakes.
This is not about implementing a Sudoku solver.
Just about writing unnecessarily complicated type definitions.
For the final result, check out <a href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/sudoku_v2.ts">sudoku_v2.ts</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/sudoku_v2_demo.gif"><img src="https://ryanisaacg.com/gruhn/typescript-sudoku/raw/master/sudoku_v2_demo.gif" alt="demo video: final approach" data-animated-image=""/></a></p>
<p dir="auto">As a first approximation we can define the type as an array of numbers:</p>

<p dir="auto">This permits all valid Sudokus, but also allows many <em>invalid</em> Sudokus.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const invalidSudoku: Sudoku = [ -1, 7.5, 9, 9 ]"><pre><span>const</span> <span>invalidSudoku</span>: <span>Sudoku</span> <span>=</span> <span>[</span> <span>-</span><span>1</span><span>,</span> <span>7.5</span><span>,</span> <span>9</span><span>,</span> <span>9</span> <span>]</span></pre></div>
<p dir="auto">First, all array elements have to be integers in the range 1 to 9.
Second, Sudokus are 9-by-9 grids so we need an array with exactly 81 elements.
That&#39;s easy enough:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type Cell = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

type Sudoku = [
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
  Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell, Cell,
]"><pre><span>type</span> <span>Cell</span> <span>=</span> <span>1</span> <span>|</span> <span>2</span> <span>|</span> <span>3</span> <span>|</span> <span>4</span> <span>|</span> <span>5</span> <span>|</span> <span>6</span> <span>|</span> <span>7</span> <span>|</span> <span>8</span> <span>|</span> <span>9</span>

<span>type</span> <span>Sudoku</span> <span>=</span> <span>[</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
  <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span>
<span>]</span></pre></div>
<p dir="auto">But the interesting part is: how do we enforce the Sudoku rules?
Currently, this still type checks:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const invalidSudoku: Sudoku = [
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
]"><pre><span>const</span> <span>invalidSudoku</span>: <span>Sudoku</span> <span>=</span> <span>[</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
  <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span>
<span>]</span></pre></div>
<p dir="auto">We have to make sure that</p>
<ul dir="auto">
<li>all rows are duplicate free,</li>
<li>all columns are duplicate free and</li>
<li>each of the 3-by-3 squares is also duplicate free.</li>
</ul>
<p dir="auto">For simplicity, let&#39;s just consider a 3-cell Sudoku for now:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type BabySudoku = [ Cell, Cell, Cell ]"><pre><span>type</span> <span>BabySudoku</span> <span>=</span> <span>[</span> <span>Cell</span><span>,</span> <span>Cell</span><span>,</span> <span>Cell</span> <span>]</span></pre></div>
<p dir="auto">How can we require that the three cells all have different values?
The definition of a cell is dependent on other cells,
so we need a way to reference individual cells.
By introducing a type parameter for every cell,
we can refer to cells by name:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type BabySudoku&lt;X1 extends Cell, X2 extends Cell, X3 extends Cell&gt; = [ 
  X1, X2, X3 
]"><pre><span>type</span> <span>BabySudoku</span><span>&lt;</span><span>X1</span> <span>extends</span> <span>Cell</span><span>,</span> <span>X2</span> <span>extends</span> <span>Cell</span><span>,</span> <span>X3</span> <span>extends</span> <span>Cell</span><span>&gt;</span> <span>=</span> <span>[</span> 
  <span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span> 
<span>]</span></pre></div>
<p dir="auto">Guess how many parameters the full 9-by-9 Sudoku needs.</p>
<p dir="auto">A problem is, we have to instantiate these type parameters when we create <code>BabySudoku</code> values:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const s: BabySudoku&lt;1, 2, 3&gt; = [ 1, 2, 3 ]"><pre><span>const</span> <span>s</span>: <span>BabySudoku</span><span>&lt;</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>&gt;</span> <span>=</span> <span>[</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>]</span></pre></div>
<p dir="auto">This is redundant.
The type parameters should get inferred from the value.
Type parameters on functions are automatically inferred:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const func = &lt;T&gt;(val: T) =&gt; val

func&lt;string&gt;(&#34;hello&#34;) // type parameter can be provided ...
func(&#34;hello&#34;)         // ... but not necessary"><pre><span>const</span> <span>func</span> <span>=</span> <span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>val</span>: <span>T</span><span>)</span> <span>=&gt;</span> <span>val</span>

<span>func</span><span>&lt;</span><span>string</span><span>&gt;</span><span>(</span><span>&#34;hello&#34;</span><span>)</span> <span>// type parameter can be provided ...</span>
<span>func</span><span>(</span><span>&#34;hello&#34;</span><span>)</span>         <span>// ... but not necessary</span></pre></div>
<p dir="auto">So as a workaround we can define the type in the argument of some dummy function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const babySudoku = &lt;X1 extends Cell,  X2 extends Cell,  X3 extends Cell &gt;(
  grid: [ X1, X2, X3 ]
) =&gt; grid"><pre><span>const</span> <span>babySudoku</span> <span>=</span> <span>&lt;</span><span>X1</span> <span>extends</span> <span>Cell</span><span>,</span>  <span>X2</span> <span>extends</span> <span>Cell</span><span>,</span>  <span>X3</span> <span>extends</span> <span>Cell</span> <span>&gt;</span><span>(</span>
  <span>grid</span>: <span>[</span> <span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span> <span>]</span>
<span>)</span> <span>=&gt;</span> <span>grid</span></pre></div>
<p dir="auto">With that we can construct Sudokus,
without instantiating type parameters:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const s = babySudoku([1, 2, 3])"><pre><span>const</span> <span>s</span> <span>=</span> <span>babySudoku</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span></pre></div>
<p dir="auto">The runtime behavior of <code>babySudoku</code> is boring.
It just returns it&#39;s argument unchanged (aka. the identity function).</p>
<p dir="auto">This is a bit awkward but I haven&#39;t found a better way so far.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Constraints using <code>Exclude</code></h2><a id="user-content-constraints-using-exclude" aria-label="Permalink: Constraints using Exclude" href="#constraints-using-exclude"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We still need to ensure that all cells are different.
One way to do it, is with the built-in utility type <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers" rel="nofollow"><code>Exclude</code></a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const babySudoku = &lt;
  X1 extends Cell,
  X2 extends Cell, 
  X3 extends Cell
&gt;(
  grid: [ 
    Exclude&lt;X1, X2 | X3&gt;, 
    Exclude&lt;X2, X1 | X3&gt;, 
    Exclude&lt;X3, X1 | X2&gt;, 
  ]
) =&gt; grid"><pre><span>const</span> <span>babySudoku</span> <span>=</span> <span>&lt;</span>
  <span>X1</span> <span>extends</span> <span>Cell</span><span>,</span>
  <span>X2</span> <span>extends</span> <span>Cell</span><span>,</span> 
  <span>X3</span> <span>extends</span> <span>Cell</span>
<span>&gt;</span><span>(</span>
  <span>grid</span>: <span>[</span> 
    <span>Exclude</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span> <span>|</span> <span>X3</span><span>&gt;</span><span>,</span> 
    <span>Exclude</span><span>&lt;</span><span>X2</span><span>,</span> <span>X1</span> <span>|</span> <span>X3</span><span>&gt;</span><span>,</span> 
    <span>Exclude</span><span>&lt;</span><span>X3</span><span>,</span> <span>X1</span> <span>|</span> <span>X2</span><span>&gt;</span><span>,</span> 
  <span>]</span>
<span>)</span> <span>=&gt;</span> <span>grid</span></pre></div>
<p dir="auto">This works!
What&#39;s particularly nice about this approach is that the type checker highlights exactly the cells that are in conflict:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/sudoku_v1_demo.png"><img src="https://ryanisaacg.com/gruhn/typescript-sudoku/raw/master/sudoku_v1_demo.png" alt="demo: first approach"/></a></p>
<p dir="auto">A downside is that the <a href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/sudoku_v1.ts">full type definition</a> is very large.
For each cell we have to explicitly list the other cells that are required to be different.
Writing that out manually is tedious.
I ended up <a href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/generate_sudoku_v1.ts">creating a script</a> just to print out the type definition.</p>
<p dir="auto">I came up with another approach that is more complex but also more flexible.
Before we can talk about that we need to talk about the types <code>unknown</code> and <code>never</code>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Interlude: <code>unknown</code> and <code>never</code></h2><a id="user-content-interlude-unknown-and-never" aria-label="Permalink: Interlude: unknown and never" href="#interlude-unknown-and-never"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>never</code> is the empty type, making it a subtype of everything.
There is no value that has type <code>never</code>.
So you always get a type error no matter what you write on the right-hand side of <code>const value: never = ???</code>.
That is, unless the assignment is unreachable or you use some malicous type cast like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const value: never = &#34;obviously not never&#34; as never"><pre><span>const</span> <span>value</span>: <span>never</span> <span>=</span> <span>&#34;obviously not never&#34;</span> <span>as</span> <span>never</span></pre></div>
<p dir="auto"><code>never</code> is useful to strategically provoke a type error.
The plan is to formulate the Sudoku type in such a way,
that it is equal to <code>never</code> IF constraints are violated.</p>
<p dir="auto"><code>unknown</code> is a supertype of everything, similar to <code>any</code> (<a href="https://stackoverflow.com/a/51439876" rel="nofollow">What&#39;s the difference between <code>unknown</code> and <code>any</code>?</a>).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/type-hierarchie.png"><img alt="type hierarchie" src="https://ryanisaacg.com/gruhn/typescript-sudoku/raw/master/type-hierarchie.png" height="300px"/></a></p>
<p dir="auto">I find it useful to think of <code>unknown</code> and <code>never</code> as type-level analogs of <code>true</code> and <code>false</code>.
In combination with <code>unknown</code> and <code>never</code>, union types (<code>A | B</code>) and intersection types (<code>A &amp; B</code>)
behave just like boolean OR (<code>a || b</code>) and boolean AND (<code>a &amp;&amp; b</code>).
Notice the syntactic similarity of these operators.
For example, <code>unknown | never</code> is the same as <code>unknown</code>, because building the union of <em>absolutely-everything</em> and <em>absolutely-nothing</em> gives back <em>absolutely-everything</em>.
Analogously, <code>true || false</code> is <code>true</code>.</p>
<p dir="auto">Let&#39;s define type aliases, to make the relationship more obvious:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type True = unknown
type False = never"><pre><span>type</span> <span>True</span> <span>=</span> <span>unknown</span>
<span>type</span> <span>False</span> <span>=</span> <span>never</span></pre></div>
<p dir="auto">With that we have:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Term-level</th>
<th>Type-level</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true &amp;&amp; true</code> is <code>true</code></td>
<td><code>True &amp; True</code> is <code>True</code></td>
</tr>
<tr>
<td><code>true &amp;&amp; false</code> is <code>false</code></td>
<td><code>True &amp; False</code> is <code>False</code></td>
</tr>
<tr>
<td><code>true || false</code> is <code>true</code></td>
<td><code>True | False</code> is <code>True</code></td>
</tr>
<tr>
<td><code>false || false</code> is <code>false</code></td>
<td><code>False | False</code> is <code>False</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Now that we can talk about booleans on the type-level,
we can formulate arbitrary boolean constraints inside type definitions.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Constraints using Type-Level Predicates</h2><a id="user-content-constraints-using-type-level-predicates" aria-label="Permalink: Constraints using Type-Level Predicates" href="#constraints-using-type-level-predicates"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The plan is to come up with some type-level boolean expression that describes the Sudoku constraints.
Again, let&#39;s stick to a 3-cell grid for now, where all cells have to be different.
We want a to define a type</p>
<div dir="auto" data-snippet-clipboard-copy-content="type CheckSudokuConstraints&lt;X1, X2, X3&gt; = ??? // &#34;returns&#34; either `unknown` or `never`"><pre><span>type</span> <span>CheckSudokuConstraints</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span><span>&gt;</span> <span>=</span> ??? <span>// &#34;returns&#34; either `unknown` or `never`</span></pre></div>
<p dir="auto">At this point we can think of <code>CheckSudokuConstraints</code> as a function that returns <code>true</code> or <code>false</code> (aka. a predicate).
An analogous term-level function would look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function checkSudokuConstraints(x1: Cell, x2: Cell, x3: Cell): boolean {
   return ???
}"><pre><span>function</span> <span>checkSudokuConstraints</span><span>(</span><span>x1</span>: <span>Cell</span><span>,</span> <span>x2</span>: <span>Cell</span><span>,</span> <span>x3</span>: <span>Cell</span><span>)</span>: <span>boolean</span> <span>{</span>
   <span>return</span> ?<span>??</span>
<span>}</span></pre></div>
<p dir="auto">Once we know how to define <code>CheckSudokuConstraints</code> we build the intersection with the actual number grid:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[ X1, X2, X3 ] &amp; CheckSudokuConstraints&lt;X1, X2, X3&gt;"><pre><span>[</span> <span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span> <span>]</span> <span>&amp;</span> <span>CheckSudokuConstraints</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span><span>&gt;</span></pre></div>
<p dir="auto">IF some Sudoku constraint is violated, then <code>CheckSudokuConstraints&lt;X1, X2, X3&gt;</code> &#34;returns&#34; <code>never</code> and we get:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[ X1, X2, X3 ] &amp; never             // ==&gt; never"><pre><span>[</span> <span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span> <span>]</span> <span>&amp;</span> <span>never</span>             <span>// ==&gt; never</span></pre></div>
<p dir="auto">The intersection with <em>absolutely-nothing</em> is always <em>absolutely-nothing</em> again,
so the whole definition &#34;collapses&#34; down to <code>never</code>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/intersect_never.png"><img alt="Venn diagram: never intersection" src="https://ryanisaacg.com/gruhn/typescript-sudoku/raw/master/intersect_never.png" height="250px"/></a></p>
<p dir="auto">IF all Sudoku constraint are satisfied,
then <code>CheckSudokuConstraints&lt;X1, X2, X3&gt;</code> &#34;returns&#34; <code>unknown</code> and we get:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[ X1, X2, X3 ] &amp; unknown          // ==&gt; [ X1, X2, X3 ]"><pre><span>[</span> <span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span> <span>]</span> <span>&amp;</span> <span>unknown</span>          <span>// ==&gt; [ X1, X2, X3 ]</span></pre></div>
<p dir="auto">The intersection with <code>unknown</code> just leaves the left-hand side alone.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/intersect_unknown.png"><img alt="Venn diagram: unknown intersection" src="https://ryanisaacg.com/gruhn/typescript-sudoku/raw/master/intersect_unknown.png" height="250px"/></a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Defining <code>CheckSudokuConstraints</code></h3><a id="user-content-defining-checksudokuconstraints" aria-label="Permalink: Defining CheckSudokuConstraints" href="#defining-checksudokuconstraints"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">First we need a type-level predicate to compare two cells.
We can use <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="nofollow">conditional types</a> to check if two types are equal:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type Equal&lt;A, B&gt; = A extends B ? (B extends A ? unknown : never) : never
// Equal&lt;3, 3&gt;    ==&gt;    unknown
// Equal&lt;3, 4&gt;    ==&gt;    never"><pre><span>type</span> <span>Equal</span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>&gt;</span> <span>=</span> <span>A</span> <span>extends</span> <span>B</span> ? <span>(</span><span>B</span> <span>extends</span> <span>A</span> ? <span>unknown</span> : <span>never</span><span>)</span> : <span>never</span>
<span>// Equal&lt;3, 3&gt;    ==&gt;    unknown</span>
<span>// Equal&lt;3, 4&gt;    ==&gt;    never</span></pre></div>
<p dir="auto">If <code>A</code> is a subtype of <code>B</code> and <code>B</code> is a subtype of <code>A</code>,
then <code>A</code> and <code>B</code> must be the same type.
Thus, we return true (i.e. <code>unknown</code>).
Otherwise, we return false (i.e. <code>never</code>).</p>
<p dir="auto">By negating the logic,
we get a type-level predicate that tells us when two cells are different:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type Different&lt;A, B&gt; = A extends B ? (B extends A  ? never : unknown) : unknown
// Different&lt;3, 3&gt;    ==&gt;    never
// Different&lt;3, 4&gt;    ==&gt;    unkown"><pre><span>type</span> <span>Different</span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>&gt;</span> <span>=</span> <span>A</span> <span>extends</span> <span>B</span> ? <span>(</span><span>B</span> <span>extends</span> <span>A</span>  ? <span>never</span> : <span>unknown</span><span>)</span> : <span>unknown</span>
<span>// Different&lt;3, 3&gt;    ==&gt;    never</span>
<span>// Different&lt;3, 4&gt;    ==&gt;    unkown</span></pre></div>
<p dir="auto">To express that a bunch of cells are all different, we can go through all pairs.
Again, read the intersection type operator (<code>&amp;</code>) just like boolean AND:</p>
<div dir="auto" data-snippet-clipboard-copy-content="  Different&lt;X1, X2&gt; &amp; Different&lt;X1, X3&gt; 
&amp; Different&lt;X2, X1&gt; &amp; Different&lt;X2, X3&gt;
&amp; Different&lt;X3, X1&gt; &amp; Different&lt;X3, X2&gt;"><pre>  <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X3</span><span>&gt;</span> 
<span>&amp;</span> <span>Different</span><span>&lt;</span><span>X2</span><span>,</span> <span>X1</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X2</span><span>,</span> <span>X3</span><span>&gt;</span>
<span>&amp;</span> <span>Different</span><span>&lt;</span><span>X3</span><span>,</span> <span>X1</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X3</span><span>,</span> <span>X2</span><span>&gt;</span></pre></div>
<p dir="auto">Actually, <code>Different</code> is symmetric, i.e.
<code>Different&lt;X1, X2&gt;</code> and <code>Different&lt;X2, X1&gt;</code> are the same,
so we can skip half the pairs:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Different&lt;X1, X2&gt; &amp; Different&lt;X1, X3&gt; &amp; Different&lt;X2, X3&gt;"><pre><span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X3</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X2</span><span>,</span> <span>X3</span><span>&gt;</span></pre></div>
<p dir="auto">And that&#39;s already the definition of <code>CheckSudokuConstraints</code> if we only have three cells:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type CheckSudokuConstraints&lt;X1, X2, X3&gt; = Different&lt;X1, X2&gt; &amp; Different&lt;X1, X3&gt; &amp; Different&lt;X2, X3&gt;"><pre><span>type</span> <span>CheckSudokuConstraints</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span><span>&gt;</span> <span>=</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X3</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X2</span><span>,</span> <span>X3</span><span>&gt;</span></pre></div>
<p dir="auto">For the full 81-cell Sudoku, the number of cells to compare is getting a bit out of hand.
We want to express that the cells in each row, each column and each square are pairwise different.
Rows, columns and squares always have exactly 9 cells.
So we can define one more utility type that just checks pairwise difference of 9 arbitrary given cells:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type AllDifferent&lt;X1, X2, X3, X4, X5, X6, X7, X8, X9&gt; = 
    Different&lt;X1, X2&gt; &amp; Different&lt;X1, X3&gt; &amp; Different&lt;X1, X4&gt;
  &amp; Different&lt;X1, X5&gt; &amp; Different&lt;X1, X6&gt; &amp; Different&lt;X1, X7&gt;
  &amp; ..."><pre><span>type</span> <span>AllDifferent</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span><span>,</span> <span>X4</span><span>,</span> <span>X5</span><span>,</span> <span>X6</span><span>,</span> <span>X7</span><span>,</span> <span>X8</span><span>,</span> <span>X9</span><span>&gt;</span> <span>=</span> 
    <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X3</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X4</span><span>&gt;</span>
  <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X5</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X6</span><span>&gt;</span> <span>&amp;</span> <span>Different</span><span>&lt;</span><span>X1</span><span>,</span> <span>X7</span><span>&gt;</span>
  <span>&amp;</span> ...</pre></div>
<p dir="auto">Finally, we can define <code>CheckSudokuConstraints</code> for the full Sudoku:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type CheckSudokuConstraints&lt;
  X11, X12, X13,  X14, X15, X16,  X17, X18, X19,
  X21, X22, X23,  X24, X25, X26,  X27, X28, X29,
  X31, X32, X33,  X34, X35, X36,  X37, X38, X39,

  X41, X42, X43,  X44, X45, X46,  X47, X48, X49,
  X51, X52, X53,  X54, X55, X56,  X57, X58, X59,
  X61, X62, X63,  X64, X65, X66,  X67, X68, X69,

  X71, X72, X73,  X74, X75, X76,  X77, X78, X79,
  X81, X82, X83,  X84, X85, X86,  X87, X88, X89,
  X91, X92, X93,  X94, X95, X96,  X97, X98, X99,
&gt; = 
  // all 9 rows
  &amp; AllDifferent&lt;X11, X12, X13, X14, X15, X16, X17, X18, X19&gt;
  &amp; AllDifferent&lt;X21, X22, X23, X24, X25, X26, X27, X28, X29&gt;
  &amp; AllDifferent&lt;X31, X32, X33, X34, X35, X36, X37, X38, X39&gt;
  &amp; AllDifferent&lt;X41, X42, X43, X44, X45, X46, X47, X48, X49&gt;
  &amp; AllDifferent&lt;X51, X52, X53, X54, X55, X56, X57, X58, X59&gt;
  &amp; AllDifferent&lt;X61, X62, X63, X64, X65, X66, X67, X68, X69&gt;
  &amp; AllDifferent&lt;X71, X72, X73, X74, X75, X76, X77, X78, X79&gt;
  &amp; AllDifferent&lt;X81, X82, X83, X84, X85, X86, X87, X88, X89&gt;
  &amp; AllDifferent&lt;X91, X92, X93, X94, X95, X96, X97, X98, X99&gt;

  // all 9 columns
  &amp; AllDifferent&lt;X11, X21, X31, X41, X51, X61, X71, X81, X91&gt;
  &amp; AllDifferent&lt;X12, X22, X32, X42, X52, X62, X72, X82, X92&gt;
  &amp; AllDifferent&lt;X13, X23, X33, X43, X53, X63, X73, X83, X93&gt;
  &amp; AllDifferent&lt;X14, X24, X34, X44, X54, X64, X74, X84, X94&gt;
  &amp; AllDifferent&lt;X15, X25, X35, X45, X55, X65, X75, X85, X95&gt;
  &amp; AllDifferent&lt;X16, X26, X36, X46, X56, X66, X76, X86, X96&gt;
  &amp; AllDifferent&lt;X17, X27, X37, X47, X57, X67, X77, X87, X97&gt;
  &amp; AllDifferent&lt;X18, X28, X38, X48, X58, X68, X78, X88, X98&gt;
  &amp; AllDifferent&lt;X19, X29, X39, X49, X59, X69, X79, X89, X99&gt;

  // three upper squares
  &amp; AllDifferent&lt;X11, X12, X13, X21, X22, X23, X31, X32, X33&gt;
  &amp; AllDifferent&lt;X14, X15, X16, X24, X25, X26, X34, X35, X36&gt;
  &amp; AllDifferent&lt;X17, X18, X19, X27, X28, X29, X37, X38, X39&gt;

  // three center squares
  &amp; AllDifferent&lt;X41, X42, X43, X51, X52, X53, X61, X62, X63&gt;
  &amp; AllDifferent&lt;X44, X45, X46, X54, X55, X56, X64, X65, X66&gt;
  &amp; AllDifferent&lt;X47, X48, X49, X57, X58, X59, X67, X68, X69&gt;

  // three lower squares
  &amp; AllDifferent&lt;X71, X72, X73, X81, X82, X83, X91, X92, X93&gt;
  &amp; AllDifferent&lt;X74, X75, X76, X84, X85, X86, X94, X95, X96&gt;
  &amp; AllDifferent&lt;X77, X78, X79, X87, X88, X89, X97, X98, X99&gt;"><pre><span>type</span> <span>CheckSudokuConstraints</span><span>&lt;</span>
  <span>X11</span><span>,</span> <span>X12</span><span>,</span> <span>X13</span><span>,</span>  <span>X14</span><span>,</span> <span>X15</span><span>,</span> <span>X16</span><span>,</span>  <span>X17</span><span>,</span> <span>X18</span><span>,</span> <span>X19</span><span>,</span>
  <span>X21</span><span>,</span> <span>X22</span><span>,</span> <span>X23</span><span>,</span>  <span>X24</span><span>,</span> <span>X25</span><span>,</span> <span>X26</span><span>,</span>  <span>X27</span><span>,</span> <span>X28</span><span>,</span> <span>X29</span><span>,</span>
  <span>X31</span><span>,</span> <span>X32</span><span>,</span> <span>X33</span><span>,</span>  <span>X34</span><span>,</span> <span>X35</span><span>,</span> <span>X36</span><span>,</span>  <span>X37</span><span>,</span> <span>X38</span><span>,</span> <span>X39</span><span>,</span>

  <span>X41</span><span>,</span> <span>X42</span><span>,</span> <span>X43</span><span>,</span>  <span>X44</span><span>,</span> <span>X45</span><span>,</span> <span>X46</span><span>,</span>  <span>X47</span><span>,</span> <span>X48</span><span>,</span> <span>X49</span><span>,</span>
  <span>X51</span><span>,</span> <span>X52</span><span>,</span> <span>X53</span><span>,</span>  <span>X54</span><span>,</span> <span>X55</span><span>,</span> <span>X56</span><span>,</span>  <span>X57</span><span>,</span> <span>X58</span><span>,</span> <span>X59</span><span>,</span>
  <span>X61</span><span>,</span> <span>X62</span><span>,</span> <span>X63</span><span>,</span>  <span>X64</span><span>,</span> <span>X65</span><span>,</span> <span>X66</span><span>,</span>  <span>X67</span><span>,</span> <span>X68</span><span>,</span> <span>X69</span><span>,</span>

  <span>X71</span><span>,</span> <span>X72</span><span>,</span> <span>X73</span><span>,</span>  <span>X74</span><span>,</span> <span>X75</span><span>,</span> <span>X76</span><span>,</span>  <span>X77</span><span>,</span> <span>X78</span><span>,</span> <span>X79</span><span>,</span>
  <span>X81</span><span>,</span> <span>X82</span><span>,</span> <span>X83</span><span>,</span>  <span>X84</span><span>,</span> <span>X85</span><span>,</span> <span>X86</span><span>,</span>  <span>X87</span><span>,</span> <span>X88</span><span>,</span> <span>X89</span><span>,</span>
  <span>X91</span><span>,</span> <span>X92</span><span>,</span> <span>X93</span><span>,</span>  <span>X94</span><span>,</span> <span>X95</span><span>,</span> <span>X96</span><span>,</span>  <span>X97</span><span>,</span> <span>X98</span><span>,</span> <span>X99</span><span>,</span>
<span>&gt;</span> <span>=</span> 
  <span>// all 9 rows</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X11</span><span>,</span> <span>X12</span><span>,</span> <span>X13</span><span>,</span> <span>X14</span><span>,</span> <span>X15</span><span>,</span> <span>X16</span><span>,</span> <span>X17</span><span>,</span> <span>X18</span><span>,</span> <span>X19</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X21</span><span>,</span> <span>X22</span><span>,</span> <span>X23</span><span>,</span> <span>X24</span><span>,</span> <span>X25</span><span>,</span> <span>X26</span><span>,</span> <span>X27</span><span>,</span> <span>X28</span><span>,</span> <span>X29</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X31</span><span>,</span> <span>X32</span><span>,</span> <span>X33</span><span>,</span> <span>X34</span><span>,</span> <span>X35</span><span>,</span> <span>X36</span><span>,</span> <span>X37</span><span>,</span> <span>X38</span><span>,</span> <span>X39</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X41</span><span>,</span> <span>X42</span><span>,</span> <span>X43</span><span>,</span> <span>X44</span><span>,</span> <span>X45</span><span>,</span> <span>X46</span><span>,</span> <span>X47</span><span>,</span> <span>X48</span><span>,</span> <span>X49</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X51</span><span>,</span> <span>X52</span><span>,</span> <span>X53</span><span>,</span> <span>X54</span><span>,</span> <span>X55</span><span>,</span> <span>X56</span><span>,</span> <span>X57</span><span>,</span> <span>X58</span><span>,</span> <span>X59</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X61</span><span>,</span> <span>X62</span><span>,</span> <span>X63</span><span>,</span> <span>X64</span><span>,</span> <span>X65</span><span>,</span> <span>X66</span><span>,</span> <span>X67</span><span>,</span> <span>X68</span><span>,</span> <span>X69</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X71</span><span>,</span> <span>X72</span><span>,</span> <span>X73</span><span>,</span> <span>X74</span><span>,</span> <span>X75</span><span>,</span> <span>X76</span><span>,</span> <span>X77</span><span>,</span> <span>X78</span><span>,</span> <span>X79</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X81</span><span>,</span> <span>X82</span><span>,</span> <span>X83</span><span>,</span> <span>X84</span><span>,</span> <span>X85</span><span>,</span> <span>X86</span><span>,</span> <span>X87</span><span>,</span> <span>X88</span><span>,</span> <span>X89</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X91</span><span>,</span> <span>X92</span><span>,</span> <span>X93</span><span>,</span> <span>X94</span><span>,</span> <span>X95</span><span>,</span> <span>X96</span><span>,</span> <span>X97</span><span>,</span> <span>X98</span><span>,</span> <span>X99</span><span>&gt;</span>

  <span>// all 9 columns</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X11</span><span>,</span> <span>X21</span><span>,</span> <span>X31</span><span>,</span> <span>X41</span><span>,</span> <span>X51</span><span>,</span> <span>X61</span><span>,</span> <span>X71</span><span>,</span> <span>X81</span><span>,</span> <span>X91</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X12</span><span>,</span> <span>X22</span><span>,</span> <span>X32</span><span>,</span> <span>X42</span><span>,</span> <span>X52</span><span>,</span> <span>X62</span><span>,</span> <span>X72</span><span>,</span> <span>X82</span><span>,</span> <span>X92</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X13</span><span>,</span> <span>X23</span><span>,</span> <span>X33</span><span>,</span> <span>X43</span><span>,</span> <span>X53</span><span>,</span> <span>X63</span><span>,</span> <span>X73</span><span>,</span> <span>X83</span><span>,</span> <span>X93</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X14</span><span>,</span> <span>X24</span><span>,</span> <span>X34</span><span>,</span> <span>X44</span><span>,</span> <span>X54</span><span>,</span> <span>X64</span><span>,</span> <span>X74</span><span>,</span> <span>X84</span><span>,</span> <span>X94</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X15</span><span>,</span> <span>X25</span><span>,</span> <span>X35</span><span>,</span> <span>X45</span><span>,</span> <span>X55</span><span>,</span> <span>X65</span><span>,</span> <span>X75</span><span>,</span> <span>X85</span><span>,</span> <span>X95</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X16</span><span>,</span> <span>X26</span><span>,</span> <span>X36</span><span>,</span> <span>X46</span><span>,</span> <span>X56</span><span>,</span> <span>X66</span><span>,</span> <span>X76</span><span>,</span> <span>X86</span><span>,</span> <span>X96</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X17</span><span>,</span> <span>X27</span><span>,</span> <span>X37</span><span>,</span> <span>X47</span><span>,</span> <span>X57</span><span>,</span> <span>X67</span><span>,</span> <span>X77</span><span>,</span> <span>X87</span><span>,</span> <span>X97</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X18</span><span>,</span> <span>X28</span><span>,</span> <span>X38</span><span>,</span> <span>X48</span><span>,</span> <span>X58</span><span>,</span> <span>X68</span><span>,</span> <span>X78</span><span>,</span> <span>X88</span><span>,</span> <span>X98</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X19</span><span>,</span> <span>X29</span><span>,</span> <span>X39</span><span>,</span> <span>X49</span><span>,</span> <span>X59</span><span>,</span> <span>X69</span><span>,</span> <span>X79</span><span>,</span> <span>X89</span><span>,</span> <span>X99</span><span>&gt;</span>

  <span>// three upper squares</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X11</span><span>,</span> <span>X12</span><span>,</span> <span>X13</span><span>,</span> <span>X21</span><span>,</span> <span>X22</span><span>,</span> <span>X23</span><span>,</span> <span>X31</span><span>,</span> <span>X32</span><span>,</span> <span>X33</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X14</span><span>,</span> <span>X15</span><span>,</span> <span>X16</span><span>,</span> <span>X24</span><span>,</span> <span>X25</span><span>,</span> <span>X26</span><span>,</span> <span>X34</span><span>,</span> <span>X35</span><span>,</span> <span>X36</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X17</span><span>,</span> <span>X18</span><span>,</span> <span>X19</span><span>,</span> <span>X27</span><span>,</span> <span>X28</span><span>,</span> <span>X29</span><span>,</span> <span>X37</span><span>,</span> <span>X38</span><span>,</span> <span>X39</span><span>&gt;</span>

  <span>// three center squares</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X41</span><span>,</span> <span>X42</span><span>,</span> <span>X43</span><span>,</span> <span>X51</span><span>,</span> <span>X52</span><span>,</span> <span>X53</span><span>,</span> <span>X61</span><span>,</span> <span>X62</span><span>,</span> <span>X63</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X44</span><span>,</span> <span>X45</span><span>,</span> <span>X46</span><span>,</span> <span>X54</span><span>,</span> <span>X55</span><span>,</span> <span>X56</span><span>,</span> <span>X64</span><span>,</span> <span>X65</span><span>,</span> <span>X66</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X47</span><span>,</span> <span>X48</span><span>,</span> <span>X49</span><span>,</span> <span>X57</span><span>,</span> <span>X58</span><span>,</span> <span>X59</span><span>,</span> <span>X67</span><span>,</span> <span>X68</span><span>,</span> <span>X69</span><span>&gt;</span>

  <span>// three lower squares</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X71</span><span>,</span> <span>X72</span><span>,</span> <span>X73</span><span>,</span> <span>X81</span><span>,</span> <span>X82</span><span>,</span> <span>X83</span><span>,</span> <span>X91</span><span>,</span> <span>X92</span><span>,</span> <span>X93</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X74</span><span>,</span> <span>X75</span><span>,</span> <span>X76</span><span>,</span> <span>X84</span><span>,</span> <span>X85</span><span>,</span> <span>X86</span><span>,</span> <span>X94</span><span>,</span> <span>X95</span><span>,</span> <span>X96</span><span>&gt;</span>
  <span>&amp;</span> <span>AllDifferent</span><span>&lt;</span><span>X77</span><span>,</span> <span>X78</span><span>,</span> <span>X79</span><span>,</span> <span>X87</span><span>,</span> <span>X88</span><span>,</span> <span>X89</span><span>,</span> <span>X97</span><span>,</span> <span>X98</span><span>,</span> <span>X99</span><span>&gt;</span></pre></div>

<p dir="auto">Until now we have only described complete Sudokus,
where every cell is already filled with an integer.
To actually play Sudoku, we need to allow empty cells.</p>
<p dir="auto">For that we pick some dummy value to represent an empty cell.
This can be anything, as long as it&#39;s not a number from 1 to 9:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const _ = &#34;empty cell&#34;

type EmptyCell = typeof _"><pre><span>const</span> <span>_</span> <span>=</span> <span>&#34;empty cell&#34;</span>

<span>type</span> <span>EmptyCell</span> <span>=</span> <span>typeof</span> <span>_</span></pre></div>
<p dir="auto">Now we <em>could</em> redefine <code>Cell</code> to include this value:</p>
<div dir="auto" data-snippet-clipboard-copy-content="type Cell = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | EmptyCell // won&#39;t work"><pre><span>type</span> <span>Cell</span> <span>=</span> <span>1</span> <span>|</span> <span>2</span> <span>|</span> <span>3</span> <span>|</span> <span>4</span> <span>|</span> <span>5</span> <span>|</span> <span>6</span> <span>|</span> <span>7</span> <span>|</span> <span>8</span> <span>|</span> <span>9</span> <span>|</span> <span>EmptyCell</span> <span>// won&#39;t work</span></pre></div>
<p dir="auto">But then the constraints also apply to empty cells
and the type checker starts complaining about things like two empty cells in the same row.
Empty cells should be unconstrained and allowed everywhere.
We can do that by explicitly annotating each cell with <code>| EmptyCell</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[ X1 | EmptyCell, X2 | EmptyCell, X3 | EmptyCell ] &amp; CheckSudokuConstraints&lt;X1, X2, X3&gt;"><pre><span>[</span> <span>X1</span> <span>|</span> <span>EmptyCell</span><span>,</span> <span>X2</span> <span>|</span> <span>EmptyCell</span><span>,</span> <span>X3</span> <span>|</span> <span>EmptyCell</span> <span>]</span> <span>&amp;</span> <span>CheckSudokuConstraints</span><span>&lt;</span><span>X1</span><span>,</span> <span>X2</span><span>,</span> <span>X3</span><span>&gt;</span></pre></div>
<p dir="auto">So in each cell we either allow an empty cell or we allow an integer from 1-9 that is additionally constrained.</p>
<p dir="auto">For the full type definition, check out <a href="https://ryanisaacg.com/gruhn/typescript-sudoku/blob/master/sudoku_v2.ts">sudoku_v2.ts</a>.</p>

<p dir="auto">This is pretty useless.
One could try to implement a statically verified Sudoku solver based on these types:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function solveSudoku(grid: IncompleteSudoku): CompleteSudoku { /* ... */ }"><pre><span>function</span> <span>solveSudoku</span><span>(</span><span>grid</span>: <span>IncompleteSudoku</span><span>)</span>: <span>CompleteSudoku</span> <span>{</span> <span>/* ... */</span> <span>}</span></pre></div>
<p dir="auto">This would give very high confidence in the implementations correctness.
However, it&#39;s probably hard to convince the type checker that the code really matches the spec.
Even then, error messages are not very friendly and,
depending on the TypeScript version,
it can take multiple seconds to type check the code.</p>
<p dir="auto">Nevertheless, I think it&#39;s interesting to see how much expressivity one can squeeze out of the type system.</p>
</article></div></div>
  </body>
</html>
