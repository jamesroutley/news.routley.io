<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kyju.org/blog/rust-safe-garbage-collection/">Original</a>
    <h1>Techniques for safe garbage collection in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    

<p><strong>2024-01-13</strong></p>

    <ul>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#rust-and-garbage-collection">Rust and Garbage Collection</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#tracing-and-interior-mutability">Tracing and Interior Mutability</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#finding-gc-roots-with-generativity">Finding GC Roots with Generativity</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#lifetime-projection">Lifetime Projection</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#putting-it-all-together">Putting It All Together</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#closing-thoughts">Closing Thoughts</a>
            
        </li>
    
    </ul>

<hr/>
<p>This will be the first in a series of posts describing different design
decisions made writing two Rust crates:</p>
<ul>
<li><a href="https://github.com/kyren/gc-arena">gc-arena</a> - A system for safely fitting
Rust with incremental garbage collection, used by
<a href="https://ruffle.rs">Ruffle</a>.</li>
<li><a href="https://github.com/kyren/piccolo">piccolo</a> - A stackless Lua runtime
written in safe Rust with a focus on safe sandboxing.</li>
</ul>
<p>The goal of this series of posts is not really to sell anyone on these crates,
or even the ideas that went into them, but to document why I<span><sup><a data-aside="aside-1">[1]</a></sup><span id="aside-1">in the
case of <code>gc-arena</code>, <em>we</em></span></span>
 made the design decisions I did, and to touch
on a web of issues and potential solutions that might<span><sup><a data-aside="aside-2">[2]</a></sup><span id="aside-2"><em>might</em></span></span>
 be applicable to the larger Rust ecosystem.</p>
<p>This is going to be a pretty long post, and also very technical and pretty
dry. I&#39;m not even going to cover every technique developed for <code>gc-arena</code>, I&#39;m
just aiming to cover the ideas that you are guaranteed to encounter when trying
to use it at all. I may come back and cover things like the details around
<code>Collect</code> impls and GC &#34;finalization&#34; in a future post.</p>
<p>This post also doesn&#39;t really ask any big questions or present any big, unsolved
problems, it is meant mostly as an answer to a set of very common questions,
asking why exactly <code>gc-arena</code> is the way it is. This is also an essential
pre-requisite to talk at <em>all</em> about <code>piccolo</code>, so I&#39;m just going to have to get
this out of the way first before a hopefully much more interesting discussion of
<code>piccolo</code> itself.</p>
<h2 id="rust-and-garbage-collection">Rust and Garbage Collection</h2>
<p>Rust as she is spoke,<span><sup><a data-aside="aside-3">[3]</a></sup><span id="aside-3">and
<a href="https://en.wikipedia.org/wiki/English_as_She_Is_Spoke">English</a> for that
matter</span></span>
 at least currently, does not have &#34;true&#34; garbage collection.
The terms around this are a bit contentious,<span><sup><a data-aside="aside-4">[4]</a></sup><span id="aside-4">It is not inaccurate to
refer to <code>Rc</code> and <code>Arc</code> as a form of garbage collection without cycle detection,
and some people prefer to view them as part of the same continuum.</span></span>
 but
what I mean is garbage collection with cycle detection, the kind of which allows
you to more or less stop thinking about <em>ownership</em> and instead only think
about <em>reachability</em>. The fact that Rust did not ship with this feature is maybe
unsurprising in retrospect, since it is at odds in several ways with its design
ethos,<span><sup><a data-aside="aside-5">[5]</a></sup><span id="aside-5">ownership semantics, mutability XOR aliasing, and minimal
behind-the-scenes runtime</span></span>
 but this wasn&#39;t always the plan! Rust used to
have built-in garbage-collected
<a href="https://steveklabnik.com/writing/pointers-in-rust-a-guide">managed pointers</a>,
and there has been at least
<a href="https://manishearth.github.io/blog/2016/08/18/gc-support-in-rust-api-design/">some discussion</a>
on bringing them back. <code>gc-arena</code> represents my<span><sup><a data-aside="aside-6">[6]</a></sup><span id="aside-6">I can no longer take
sole credit for <code>gc-arena</code>, it has other major contributors since being used in
the Ruffle project, and in fact I have those contributors to thank for me even
continuing to work on it at all. More on this later.</span></span>
 attempt to
retrofit Rust with these types of garbage-collected pointers purely as a
library.</p>
<p>I&#39;m far from the first person to attempt this, I think
<a href="https://manishearth.github.io/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/">this</a>
post by <a href="https://manishearth.github.io">Manish Goregaokar</a> is the best starting
point I know of to read about some of the landscape, <code>gc-arena</code> is featured in
that article as one point in a complex design space, and I&#39;m only going to cover
the part of the space I&#39;m familiar with.</p>
<p><code>gc-arena</code> exists because <code>piccolo</code> (formerly &#34;luster&#34;) needed a garbage
collector, and I had a very specific set of requirements in mind when I started:</p>
<ul>
<li>I was heavily borrowing<span><sup><a data-aside="aside-7">[7]</a></sup><span id="aside-7">shamelessly stealing</span></span>
 much
of the interpreter design from the <a href="https://lua.org">Ur Lua</a> (The version
developed at PUC-Rio), and my chief goal was that <code>piccolo</code> should never be
somehow doomed to be forever slower or inferior to PUC-Rio Lua. What I mean
by this is complex and I hope to cover in a later post, but for now, what
I mean is that, like PUC-Rio Lua and all of its forks, garbage-collected
pointers needed to be <em>zero-cost plain pointers</em>, which in Rust terms means
that they are <code>Copy</code> and don&#39;t include bookkeeping during normal use. This
was important for the stack-based design of the Lua VM, which was going to be
inspired<span><sup><a data-aside="aside-8">[8]</a></sup><span id="aside-8">stolen</span></span>
 from PUC-Rio Lua.</li>
<li><code>piccolo</code> needed to be written in (almost) entirely safe Rust. It exists as
an experiment to see how <em>far</em> I could go writing a Lua runtime with provable
memory safety and performance that was not fundamentally any slower than an
equivalent runtime without memory safety.</li>
</ul>
<p>These two requirements together, that garbage-collected pointers are (when
ignoring the actual process of garbage collection) <em>free</em>, and that the
runtime needed to be majority memory safe,<span><sup><a data-aside="aside-9">[9]</a></sup><span id="aside-9">What I mean by this
is much more complex but it&#39;s too much to go into here. It needed to have no
<em>infectious unsafety</em> like PUC-Rio Lua has. Normal C code is always
memory unsafe, PUC-Rio Lua and her forks are on an entirely
<a href="https://github.com/luau-lang/luau/blob/e76802f2ce698ca090a793b24c07e336b21ade9f/VM/src/lvmexecute.cpp#L26">different plane of existence</a>,
my goal was to avoid things like <em>this</em>.</span></span>
 meant that none of the
existing designs I could find would work.<span><sup><a data-aside="aside-10">[10]</a></sup><span id="aside-10">at least as of late 2018,
when these projects were originally conceived</span></span>
 I found a way forward
to satisfy both of these requirements, and with a garbage collector very similar
to the incremental collector in PUC-Rio Lua,<span><sup><a data-aside="aside-11">[11]</a></sup><span id="aside-11">Because I stole the
design outright. Stealing is easy and fun!</span></span>
 and thus <code>gc-arena</code> was
born.</p>
<h2 id="tracing-and-interior-mutability">Tracing and Interior Mutability</h2>
<p>Designing a tracing garbage collector library for Rust with a safe interface
is challenging. Usually, most of the difficulty orbits around the problems of
correctly tracing values which hold managed (garbage-collected) pointers and
deterministically knowing the set of garbage collector &#34;roots&#34; (the places
where some non-managed value holds a pointer to a managed value, and thus
garbage-collected values that are <em>known</em> to be externally reachable).<span><sup><a data-aside="aside-12">[12]</a></sup><span id="aside-12">These problems often arise when retrofitting garbage collection to systems
programming languages generally, the lack of a language runtime or some kind
of machinery to know where managed pointers could be held often necessitates
conservative stack / heap scanning, which isn&#39;t <em>great</em>.</span></span>
</p>
<p>The best way to explore these problems and how <code>gc-arena</code> solves them is with
an example, and in this post we&#39;re going to slowly build up a doubly-linked
list data structure, covering different issues as they come up. We&#39;ll start with
defining a single <code>Node</code> of this doubly-linked list:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span>//</span> Node of a doubly-linked list data structure.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Garbage collected pointers in `gc-arena` are called `Gc`, and all carry a &#39;gc
</span></span><span><span><span>//</span> lifetime with them. Don&#39;t worry too much about &#39;gc yet, it will be explained
</span></span><span><span><span>//</span> in detail in just a bit.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> The `prev` and `next` fields are plain pointers with no implicit bookkeeping.
</span></span><span><span><span>//</span> The garbage collector ensures that all unreachable pointers are freed (and
</span></span><span><span><span>//</span> their values dropped).
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> When using `gc-arena`, especially since it is focused on single-threaded
</span></span><span><span><span>//</span> use, types can feel like they belong in a different language entirely. Often
</span></span><span><span><span>//</span> everything will implement `Copy`, and back or even self references abound.
</span></span><span><span><span>//</span> This makes sense, as `gc-arena` was designed to implement runtimes for
</span></span><span><span><span>//</span> languages where this is the norm.
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We&#39;ll put the problem of deterministically finding roots aside for the moment.
Assuming we know the GC roots, we need to be able to trace every possible
reachable garbage collected pointer from them. This is a safety issue, if we
were to miss any reachable pointer, we might improperly collect it and this
could lead to a UAF (Use After Free). <code>gc-arena</code> handles this requirement with
its
<a href="https://github.com/kyren/gc-arena/blob/6ee59df2cfe67b273a6cb1fc4d65b4e61b77d537/src/gc-arena/src/collect.rs#L22">Collect</a>
trait, which all garbage-collectable types must implement. The trait is unsafe
to implement, because implementations must ensure that every reachable pointer
is traced.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> `unsafe`, because implementing this trait incorrectly can lead to UB.
</span></span><span><span>unsafe</span> <span><span>impl</span></span><span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> Collect<span>&gt;</span></span></span><span> Collect <span>for</span></span><span> <span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>trace</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>cc</span><span>:</span> <span>&amp;</span>Collection</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>prev<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> If we were to forget to trace a field here, for example the `next`
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> field, then the garbage collector might believe that `next` is
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> unreachable and drop it. This could lead to a UAF, so `Collect`
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> *must* be correctly implemented for every garbage collected type
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> for safety.
</span></span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>next<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>value<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>However, this trait <em>can</em> safely be implemented via proc-macro! As long as the
implementation requires that every field itself implement <code>Collect</code> and the
generated <code>Collect::trace</code> implementation calls the <code>Collect::trace</code> method of
every field, nothing can go wrong. The end result looks like this, which allows
defining and using custom garbage collected types without needing any unsafe
code at all!</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span>//</span> Safely implements the `Collect` trait (only when `T: Collect`) via procedural
</span></span><span><span><span>//</span> derive.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> There is another issue that I haven&#39;t covered yet, and it might be pretty
</span></span><span><span><span>//</span> obvious what it is from the `#[collect(no_drop)]` attribute here.
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Since `Gc` internally holds a `NonNull`, `Option&lt;Gc&lt;_&gt;&gt;` is pointer
</span></span></span></span><span><span><span>    <span><span>//</span> sized!
</span></span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The only remaining problem is the <code>Drop</code> trait... since objects can contain
circular references, there is no order in which we can drop them such that every
object would contain only un-dropped pointers. If we allowed users to implement
<code>Drop::drop</code> for <code>Collect</code> types, they could cause memory unsafety by accessing
these dropped values. This is easy to see with our linked list example, if there
was a <code>Drop</code> implementation on our <code>Node</code> type that accessed either <code>prev</code> or
<code>next</code>, in a circularly linked list that would mean that there would be <em>no</em>
possible safe order to drop our nodes in! <code>gc-arena</code> solves this by forbidding
<code>Drop</code> impls on types using auto-generated <code>Collect</code> impls using a trick,<span><sup><a data-aside="aside-13">[13]</a></sup><span id="aside-13">which I stole from
<a href="https://github.com/taiki-e/pin-project">pin-project</a>. Fun <em>and</em> easy!</span></span>
 internal to <code>gc-arena</code>, there is a trait called <code>MustNotImplDrop</code> that looks
like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>trait</span> <span>MustNotImplDrop</span> <span><span>{</span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span></span><span><span><span>&lt;</span>T<span>:</span> <span>Drop</span><span>&gt;</span></span></span><span> MustNotImplDrop <span>for</span></span><span> <span>T</span> </span><span><span><span>{</span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Auto-generated <code>Collect</code> impls (without an unsafe buy-in to allow custom <code>Drop</code>
impls) generate an impl for <code>MustNotImplDrop</code>, thus, if the user tries to
implement <code>Drop</code> for their type, this causes a conflicting implementation and a
compiler error.</p>
<hr/>
<p><code>gc-arena</code> is also an incremental collector, which poses a new problem...
Imagine that we have already traced an object during our incremental tracing
operation, then we allow the user to mutate that object. If the user puts a
pointer to an un-traced object inside the already traced object, we now have
an object which is marked as having been traced pointing to an object that
has <em>not</em> been traced. This also can lead to dangling pointers, so we need
to protect against this somehow. <code>gc-arena</code> refers to this as the <em>color
invariant</em>, a &#34;black&#34; object (fully traced), may not point to a &#34;white&#34; object
(untraced).</p>
<p>The solution lies again with the <code>Collect</code> trait. <code>Gc</code> pointers are always
presumed to be aliased (they have no bookkeeping to prove otherwise) so <code>Gc</code>
provides only <em>shared</em> references to its inner type. Any mutation for garbage
collected values must come solely from types that provide <em>interior mutability</em>
through a shared reference. Such types are not allowed to implement <code>Collect</code>
directly,<span><sup><a data-aside="aside-14">[14]</a></sup><span id="aside-14">They also can&#39;t implement <code>Collect</code> via procedural derive
because we purposefully do not include <code>Collect</code> impls for interior mutability
primitives. In order to implement <code>Collect</code> for a type with its own interior
mutability, you must have an unsafe <code>Collect</code> impl which asserts that you follow
the write barrier contract.</span></span>
 instead <code>gc-arena</code> provides its own
versions of interior mutability (<code>Lock</code> instead of <code>Cell</code>, <code>RefLock</code> instead of
<code>RefCell</code>) which always require &#34;write barriers&#34; to enable mutation. A &#34;write
barrier&#34; is jargon from garbage collection literature, in our case it is
always a backwards write barrier (but we may add forward write barriers in the
future). If a &#34;black&#34; object is written to, it gets put back into the queue
of to-be-traced objects (&#34;gray&#34; objects, specifically the &#34;gray again&#34; list),
meaning it will be re-traced. In this way, we can&#39;t lose track of any reachable
objects. (There is a great
<a href="https://www.youtube.com/watch?v=wGizKsOJQuE">talk</a> about the PUC-Rio garbage
collector which implements the same<span><sup><a data-aside="aside-15">[15]</a></sup><span id="aside-15">because that&#39;s where I stole it
from</span></span>
 incremental design (as well as his newer generational collector)
by the creator of Lua, Roberto Ierusalimschy.)</p>
<p>This lack of interior mutability by default means that our previous linked list
<code>Node</code> example is woefully incomplete! As it is written, we would never be able
to mutate any nodes once they were placed in a <code>Gc</code>, so the data structure as
defined above would be almost useless. We need to enable safe mutation by using
one of the <code>gc-arena</code> types which provide it:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc<span>,</span> <span>lock<span>::</span></span>RefLock</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span>//</span> More realistic node type of a doubly-linked list data structure with safe
</span></span><span><span><span>//</span> interior mutability.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> We use `RefLock` here, but if we knew `T: Copy`, we could also use `Lock`.
</span></span><span>
</span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span>type</span> <span>NodePtr</span><span>&lt;</span><span>&#39;gc</span><span>,</span> T<span>&gt;</span> <span>=</span> <span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>RefLock<span>&lt;</span><span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span><span>;</span>
</span></code></pre>
<p>Now, we&#39;re able to safely mutate values of this type that live inside <code>Gc</code>
pointers:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> Set the `value` field of a `Node&lt;&#39;gc, T&gt;`.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> This example is much more verbose than what you would actually write in order
</span></span><span><span><span>//</span> to fully illustrate the machinery at work. There are convenience methods on
</span></span><span><span><span>//</span> `Gc&lt;Lock&lt;_&gt;&gt;` and `Gc&lt;RefLock&lt;_&gt;&gt;` that allow you to skip interacting with
</span></span><span><span><span>//</span> the `Write` marker at all, which is normally what you&#39;d use.
</span></span><span><span><span><span>fn</span> </span><span>node_set_value</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>Copy</span><span>&gt;</span></span><span><span><span>(</span>
</span></span></span><span><span><span>    <span><span>//</span> This is one of the &#34;context&#34; types provided by `gc-arena`. This is almost
</span></span></span></span><span><span><span>    <span><span>//</span> always required to safely mutate object graph, more on this in a bit.
</span></span></span></span><span><span><span>    <span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span><span>//</span> The node pointer we want to mutate.
</span></span></span></span><span><span><span>    <span>node_ptr</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span>    <span><span>//</span> The value we&#39;re going to set.
</span></span></span></span><span><span><span>    <span>value</span><span>:</span> T
</span></span></span><span><span><span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Invoke the &#34;write barrier&#34;. If the `node` pointer is currently
</span></span></span></span><span><span><span>    <span><span>//</span> &#34;black&#34; (marked as fully traced), this will make it &#34;gray&#34; again. This
</span></span></span></span><span><span><span>    <span><span>//</span> is what allows us to safely mutate the pointer, so `gc-arena` must
</span></span></span></span><span><span><span>    <span><span>//</span> assume that the object may adopt new pointers which might be &#34;white&#34;,
</span></span></span></span><span><span><span>    <span><span>//</span> invalidating the color invariant, so the object *must* be re-traced. This
</span></span></span></span><span><span><span>    <span><span>//</span> is a &#34;backwards&#34; write barrier. In the future, we should have a way to
</span></span></span></span><span><span><span>    <span><span>//</span> mark a pointer being *adopted* as gray immediately, also satisfying the
</span></span></span></span><span><span><span>    <span><span>//</span> color invariant. This would be a &#34;forward&#34; write barrier.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> The type that this method returns is a bit gnarly (It&#39;s
</span></span></span></span><span><span><span>    <span><span>//</span> `&amp;&#39;gc Write&lt;RefLock&lt;Node&lt;&#39;gc, T&gt;&gt;&gt;` for reference). There are several
</span></span></span></span><span><span><span>    <span><span>//</span> internal tricks involved which are not important right now for why the
</span></span></span></span><span><span><span>    <span><span>//</span> type signature can safely look like this, but the important part is the
</span></span></span></span><span><span><span>    <span><span>//</span> `Write` marker. This is a `#[repr(transparent)]` wrapper type that marks
</span></span></span></span><span><span><span>    <span><span>//</span> a *reference* from the interior of the object graph as safely mutable,
</span></span></span></span><span><span><span>    <span><span>//</span> because we know the write barrier has been triggered on its owning `Gc`
</span></span></span></span><span><span><span>    <span><span>//</span> pointer.
</span></span></span></span><span><span><span>    <span>let</span> write <span>=</span> node_ptr<span>.</span><span>write</span><span><span>(</span>mc</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Now that we have a `Write` reference, we can safely call `Write::unlock`
</span></span></span></span><span><span><span>    <span><span>//</span> and get back a `&amp;RefCell&lt;Node&lt;&#39;gc, T&gt;&gt;`.
</span></span></span></span><span><span><span>    <span>let</span> ref_cell <span>=</span> write<span>.</span><span>unlock</span><span><span>(</span>mc</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> And we can safely use it like any other `RefCell` type, including
</span></span></span></span><span><span><span>    <span><span>//</span> potentially adopting new pointers.
</span></span></span></span><span><span><span>    ref_cell<span>.</span><span>borrow_mut</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value <span>=</span> value<span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<hr/>
<p>This strategy of using a custom unsafe trait with safe proc-macro generation
for tracing is not new, it was used by Manish in his
<a href="https://github.com/Manishearth/rust-gc">rust-gc library</a>, from which <code>gc-arena</code>
heavily borrows.<span><sup><a data-aside="aside-16">[16]</a></sup><span id="aside-16">steals... you might be noticing a pattern</span></span>

<code>rust-gc</code> calls its <code>Collect</code> trait <code>Trace</code>, and has a similar system to manage
otherwise unsafe mutability, where internally mutable types do <em>not</em> implement
<code>Trace</code> directly for safety (though since <code>rust-gc</code> is not an incremental
collector, the mutability safety problems are slightly different).</p>
<p>The <code>Collect</code> trait forms one of the two pillars of <code>gc-arena</code>&#39;s soundness
story, but it is only half of the story. We need to be able to deterministically
find all of the garbage collector&#39;s roots, AND to make sure that no internal
mutability occurs during incremental collection. For this we use another
trick...</p>
<h2 id="finding-gc-roots-with-generativity">Finding GC Roots with Generativity</h2>
<p>There is an accidental feature of the Rust borrow checker that introduces
something called &#34;generativity&#34; into Rust. This was, AFAIK, first described in
<a href="https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">Alexis Beingessner&#39;s Master&#39;s thesis</a>,<span><sup><a data-aside="aside-17">[17]</a></sup><span id="aside-17">You can find the description under the section &#34;Hacking Generativity
into Rust&#34;, right before she says &#34;we <em>really</em> don’t recommend doing this&#34;.</span></span>
 and you can see her thesis for probably a much better explanation,
but I&#39;ll try my best to explain the concept very briefly. &#34;Generativity&#34; as it
exists in Rust allows us a sort of very limited form of dependent typing: each
time a closure is executed <em>at runtime</em>, a brand new type (in this case, a Rust
lifetime) is generated that cannot be unified with any other generated instance.
Of course, the Rust compiler and thus any notion of types does not exist at
runtime, so this is only one way to look at what is happening. Really, the
technique can be boiled down to a simple fact about lifetimes in Rust function
types: you can construct a function that must work <em>for any</em> given lifetime,
so every time such a function is called, the body of such a function only knows
that <em>there exists</em> some lifetime that must satisfy its signature and nothing
else, so the lifetime from one call of a function cannot be unified with any
other. This technique has seen some existing use in Rust, there&#39;s even a
<a href="https://github.com/CAD97/generativity">crate</a> for it,<span><sup><a data-aside="aside-18">[18]</a></sup><span id="aside-18">It doesn&#39;t
use the closure lifetime trick, but it uses something equivalent.</span></span>
 but
it is not widely used because frankly it can be a bit of a <em>pain in the butt</em>.</p>
<p>This trick is sometimes also called &#34;lifetime branding&#34;, which is a name more
appropriate for how it is used in <code>gc-arena</code>: if you have a generative lifetime
<code>&#39;id</code>, any type &#34;branded&#34; with this <code>&#39;id</code> cannot ever be unified with another
type branded with a different <code>&#39;id</code>. In <code>gc-arena</code> this lifetime is called
<code>&#39;gc</code>, and it brands all garage-collected values (garbage-collected <code>Gc</code>
pointers and anything transitively containing them).</p>
<p>Describing this trick in thick jargon like this is not very useful, it&#39;s much
easier to understand when we look concretely at how it is actually used in
<code>gc-arena</code>.</p>
<hr/>
<p>The word &#34;arena&#34; is commonly used in systems programming to refer to a technique
of allocating memory from a single pool such that every allocation shares
the same lifetime. The name &#34;arena&#34; is meant to be evocative of some kind of
<em>enclosure</em>, all allocations are kept enclosed in an &#34;arena&#34; and ultimately
share the same fate: allocations will always have a lifetime tied to their
parent arena, and they are all freed when the arena is destroyed (or reset,
depending on how the arena works). There is a great explanation of this &#34;arena
technique&#34; as it appears in Rust on
<a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">Manish&#39;s blog</a>,
allocated references returned from arenas all share some kind of &#39;arena lifetime
such that all of the allocations can be invalidated at the same point, when the
whole arena is reset.</p>
<p>The &#34;arena&#34; in &#34;gc-arena&#34; means sort of the same thing, that allocated pointers
are kept in an <em>enclosure</em> and may not escape it, and all of them must share
the same fate of being forever bound inside the arena they were birthed in.<span><sup><a data-aside="aside-19">[19]</a></sup><span id="aside-19">Sometimes programmer-speak can be a bit <em>too</em> evocative.</span></span>

<code>gc-arena</code> is different in that pointers do not <em>necessarily</em> have to live for
the entire lifetime of the arena, only <em>reachable</em> pointers, but the idea is
similar enough to other arena allocators that I picked the name &#34;gc-arena&#34;.</p>
<p><code>gc-arena</code> is also different from other arena allocators in specifically how
it uses its arena lifetime (which <code>gc-arena</code> calls <code>&#39;gc</code>). Rather than only
ensuring that pointers do not outlive some moment in time where every arena
pointer is freed, <code>gc-arena</code> uses the same technique repeatedly over the
lifetime of the <em>same</em> arena, ensuring that pointers must not escape <em>a single
unit of mutation</em>. &#34;Mutation&#34; here is garbage collector jargon, and simply means
&#34;things that are not <em>collection</em>&#34;, which is, well, any actual work your program
will do. Since <em>useful work</em> may <em>mutate</em> the object graph, everything useful
your program actually <em>does</em> is lumped together and called &#34;mutation&#34;.<span><sup><a data-aside="aside-20">[20]</a></sup><span id="aside-20">Sometimes programmers also can get tunnel vision.</span></span>
</p>
<p>The <code>Gc</code> pointer in <code>gc-arena</code> looks something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>///</span> A garbage collected pointer to a type `T`.
</span></span><span><span><span>pub</span> <span>struct</span> </span><span><span><span>Gc</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span></span><span>
</span></span><span><span>    where T: ?Sized + &#39;gc
</span></span><span><span></span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> This type is a pointer (potentially wide) to a struct which contains a
</span></span></span></span><span><span><span>    <span><span>//</span> value of type `T`. There is a small overhead per allocation for a header
</span></span></span></span><span><span><span>    <span><span>//</span> section, and the last field is a (potentially unsized) `T`. In the
</span></span></span></span><span><span><span>    <span><span>//</span> future, we might store a bare `T` pointer and use pointer math to find
</span></span></span></span><span><span><span>    <span><span>//</span> the header when necessary (such as during tracing).
</span></span></span></span><span><span><span>    <span>ptr</span><span>:</span> <span>NonNull<span>&lt;</span><span>GcBox<span>&lt;</span>T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> We also contain a `PhantomData` type which marks the struct as being
</span></span></span></span><span><span><span>    <span><span>//</span> *invariant* over the &#39;gc lifetime. This is essential to prevent lifetime
</span></span></span></span><span><span><span>    <span><span>//</span> branding from being defeated and for the soundness of `gc-arena`.
</span></span></span></span><span><span><span>    <span>_invariant</span><span>:</span> <span>Invariant<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We have a simple pointer value (<code>Gc</code> implements a slew of traits, but notably it
is always <code>Copy</code>) and a zero-size marker type that both binds the <code>Gc</code> pointer
to <code>&#39;gc</code> and also makes it <em>invariant</em><span><sup><a data-aside="aside-21">[21]</a></sup><span id="aside-21">You can see a great
explanation of lifetime subtyping and variance in the Rustonomicon
<a href="https://doc.rust-lang.org/nomicon/subtyping.html">here</a>.</span></span>
 over <code>&#39;gc</code>
(more on this in a second). Since every <code>Gc</code> pointer is &#34;branded&#34; with this
<code>&#39;gc</code> lifetime, we can leverage the power of the Rust borrow checker to tightly
control their lifetime.</p>
<p>The top-level type in <code>gc-arena</code> is called <code>Arena</code>, and it is parameterized
over an <code>R</code> which is the arena&#39;s <em>root type</em>.<span><sup><a data-aside="aside-22">[22]</a></sup><span id="aside-22">Sort of, I&#39;ll explain
in a bit</span></span>
 Everything that the arena will ever store must fit into this
single root type, so all long-term reachable pointers must always be reachable
somehow from this single root.<span><sup><a data-aside="aside-23">[23]</a></sup><span id="aside-23">This is restrictive, but there are
things like
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/dynamic_roots.rs#L28">DynamicRootSet</a>
which make this less restrictive than it sounds.</span></span>
 It provides methods
to <em>mutate</em> this single root, and by using lifetime branding, we can prove that
in-between calls to mutate, <em>every reachable pointer must be reachable from
the root</em>.</p>
<p>Whew, this is a lot setup to describe the main idea of <code>gc-arena</code>, and this will
make a lot more sense with a concrete example. We&#39;ll use the linked list example
from before and decide that a <code>NodePtr&lt;&#39;gc, i32&gt;</code> should be our root type. I&#39;m
skipping the part where we actually <em>construct</em> the arena because this requires
one final trick which I haven&#39;t talked about yet, but a full example will be
provided by the end, I promise.<span><sup><a data-aside="aside-24">[24]</a></sup><span id="aside-24"><a href="https://xkcd.com/365/">Bare with me for a moment.</a></span></span>
</p>
<p>Access to an arena is tightly controlled in single units of <em>mutation</em>. This
is not as complex as it sounds, what it effectively means is that in order
to access an arena, you just need to call a method on the arena which takes
a callback:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Construct an arena with a root of type `NodePtr&lt;&#39;gc, i32&gt;`. I will cover
</span></span></span></span><span><span><span>    <span><span>//</span> how to actually do this in the next section.
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> We can &#34;mutate&#34; our arena by using the `Arena::mutate` method, which
</span></span></span></span><span><span><span>    <span><span>//</span> always takes a callback that is passed a `&amp;Root` parameter. &#34;Mutation&#34;
</span></span></span></span><span><span><span>    <span><span>//</span> again is garbage collector jargon, really *any access at all* must take
</span></span></span></span><span><span><span>    <span><span>//</span> place inside calls to `Arena::mutate` (or equivalent), since we have
</span></span></span></span><span><span><span>    <span><span>//</span> full access to the object graph and can mutate it using methods for safe
</span></span></span></span><span><span><span>    <span><span>//</span> internal mutation.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> The first `mc` parameter is the &#34;mutation context&#34; of type
</span></span></span></span><span><span><span>    <span><span>//</span> `&amp;Mutation&lt;&#39;gc&gt;`. Anything that may mutate the object graph generally
</span></span></span></span><span><span><span>    <span><span>//</span> requires a `mc: &amp;Mutation&lt;&#39;gc&gt;` parameter, and the &#39;gc brading lifetime
</span></span></span></span><span><span><span>    <span><span>//</span> of the mutation context and the `Gc` pointer must match.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> This allows accessing arena-wide bookkeeping data without having to
</span></span></span></span><span><span><span>    <span><span>//</span> keep an extra pointer for every allocation back to the parent arena, but
</span></span></span></span><span><span><span>    <span><span>//</span> it is also useful in soundness reasoning. There are multiple different
</span></span></span></span><span><span><span>    <span><span>//</span> context types, the existence of a `&amp;Mutation&lt;&#39;gc&gt;` acts as a witness
</span></span></span></span><span><span><span>    <span><span>//</span> that we are doing *mutation* rather than *collection*. These are mostly
</span></span></span></span><span><span><span>    <span><span>//</span> internal details of `gc-arena`, just know that these annoying context
</span></span></span></span><span><span><span>    <span><span>//</span> types you have to pass around are very often a load-bearing part of
</span></span></span></span><span><span><span>    <span><span>//</span> soundness proofs.
</span></span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>dbg!</span><span><span>(</span>root<span>.</span>prev<span>.</span><span>is_some</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> If we need to access the root type mutably, there&#39;s a special method
</span></span></span></span><span><span><span>    <span><span>//</span> for this which is passed a `&amp;mut Root` parameter instead of `&amp;Root`.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> The root type is a bit special in that it *itself* isn&#39;t allocated
</span></span></span></span><span><span><span>    <span><span>//</span> inside a `Gc` pointer, so there is a special method to safely mutate the
</span></span></span></span><span><span><span>    <span><span>//</span> root type *itself*, and the write barrier for the root type is handled
</span></span></span></span><span><span><span>    <span><span>//</span> slightly differently than write barriers for `Gc` pointers. This is
</span></span></span></span><span><span><span>    <span><span>//</span> not really essential to the design of `gc-arena`, it&#39;s mostly just an
</span></span></span></span><span><span><span>    <span><span>//</span> accident of history. We could instead provide a `Gc&lt;&#39;gc, Root&gt;` here
</span></span></span></span><span><span><span>    <span><span>//</span> instead of a `&amp;Root` or `&amp;mut Root` to allow internal mutation the same
</span></span></span></span><span><span><span>    <span><span>//</span> way as everything else, but doing it this way saves having to always wrap
</span></span></span></span><span><span><span>    <span><span>//</span> the root type in `RefLock` which you would usually always want.
</span></span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        root<span>.</span>prev <span>=</span> <span>None</span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The signature for <code>Arena::mutate</code> looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span></span><span><span><span>&lt;</span>R<span>&gt;</span></span></span><span> <span>Arena</span><span><span>&lt;</span>R<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>mutate</span></span><span><span>&lt;</span>T<span>&gt;</span></span><span><span><span>(</span>
</span></span></span></span></span><span><span><span><span><span>        <span>&amp;</span><span>self</span>,
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> `Root&lt;&#39;gc, R&gt;` will be explained shortly, but it is the root type you
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> actually expect, rather than `R` which is *not*.
</span></span></span></span></span></span><span><span><span><span><span>        <span>f</span><span>:</span> impl <span>for<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span> FnOnce<span><span>(</span></span><span>&amp;&#39;<span>gc</span> <span>Mutation</span>&lt;&#39;<span>gc</span>&gt;<span>,</span> &amp;&#39;<span>gc</span> <span>Root</span>&lt;&#39;<span>gc</span><span>,</span> <span>R</span>&gt;</span><span><span>)</span></span> -&gt; T
</span></span></span></span></span><span><span><span><span><span>    </span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> T</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> Accursed, unutterable unsafe code.
</span></span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The most important part of the callback signature is the <code>for&lt;&#39;gc&gt;</code> part, which
is known as Higher Rank Trait Bounds or HRTBs, and it is how you do &#34;universal
quantification&#34; for a lifetime in Rust. The Rustonomicon
<a href="https://doc.rust-lang.org/nomicon/hrtb.html">explains it better</a>, but
<code>for&lt;&#39;gc&gt;</code> means &#34;for all choices of <code>&#39;gc</code>&#34;,<span><sup><a data-aside="aside-25">[25]</a></sup><span id="aside-25">aka
<a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a></span></span>
 and it requires that the callback be valid for <em>any possible choice
of <code>&#39;gc</code></em>. This means that the callback effectively can know <em>nothing</em> about
the <code>&#39;gc</code> lifetime at all, so the borrow checker must prevent types with this
lifetime from escaping out of the single callback call. After all, we <em>could</em>
choose an arbitrarily small <code>&#39;gc</code>, so any escape from the callback at all <em>must</em>
be treated as a borrow checker error. This is the key trick for &#34;generativity&#34;
that was discussed at the beginning of this section, and you can check Gankra&#39;s
thesis for a more complete explanation.</p>
<pre data-lang="rust"><code data-lang="rust"><span>    <span><span>//</span> This will cause some kind of &#34;lifetime may not live long enough&#34; error,
</span></span><span>    <span><span>//</span> because any type with &#39;gc lifetime is prevented from escaping the arena.
</span></span><span>    <span><span>//</span>
</span></span><span>    <span><span>//</span> The error message may not be *good*, but we know and can rely on this
</span></span><span>    <span><span>//</span> always triggering an error.
</span></span><span>    <span><span>//</span>
</span></span><span>    <span><span>//</span> BAD, SHOULD NOT COMPILE!
</span></span><span>    <span>let</span> escape <span>=</span> arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span>root<span>.</span>prev</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>We&#39;ve also made a big deal about ensuring that <code>Gc</code> pointers are <em>invariant</em>
over the <code>&#39;gc</code> branding lifetime, and here&#39;s why we do that: If <code>Gc</code> pointers
were <em>covariant</em> over <code>&#39;gc</code>, which we might accidentally do if we were not
careful, we could accidentally allow the user to <em>shorten</em> <code>&#39;gc</code> which could
still cause problems:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Two arenas with a root of type `NodePtr&lt;&#39;gc, i32&gt;`.
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena1 <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena2 <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena1<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root1</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>      arena2<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root2</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> If `Gc` pointers were covariant in &#39;gc, then the borrow checker
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> would shorten &#39;gc in its attempt to make everything borrow check,
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> and this would allow us to place a &#34;longer-lived&#34; &#39;`gc&#39; type into
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> a shorter-lived one. We need *invariance* to ensure that the mutate
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> callback knows as *little* about the &#39;gc lifetime as possible.
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span>
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        <span><span>//</span> BAD, SHOULD NOT COMPILE!
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        root2<span>.</span>prev <span>=</span> root1<span>.</span>next<span>;</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>      </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>So FINALLY we can put all the pieces together... IF we know that all garbage
collector pointers are branded by <code>&#39;gc</code> AND we know that we can only access any
garbage collected pointers through a callback which is universally quantified
over <code>&#39;gc</code>, THEN we can finally prove all of the properties we need for safe
garbage collection:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> An arena of some root type, it doesn&#39;t matter for this explanation.
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> Inside a call to `Arena::mutate`, we know that we can access `root`
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> and thus the full object graph, and we can change the object graph
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> by using safe, internal mutation which deterministically triggers
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> write barriers.
</span></span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Outside of any call to `Arena::mutate` though, we *know* that we cannot
</span></span></span></span><span><span><span>    <span><span>//</span> access any `Gc` pointer. No `Gc` pointer can be alive anywhere on the
</span></span></span></span><span><span><span>    <span><span>//</span> Rust stack, in thread local storage, smuggled into a different arena,
</span></span></span></span><span><span><span>    <span><span>//</span> anywhere at all *except* the arena&#39;s root, which we cannot observe
</span></span></span></span><span><span><span>    <span><span>//</span> without another call to `Arena::mutate`.
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Thus, we can safely perform *collection* on this arena, and our collector
</span></span></span></span><span><span><span>    <span><span>//</span> knows where the (single) GC root is, and it knows that the object graph
</span></span></span></span><span><span><span>    <span><span>//</span> cannot be changed out from underneath us during collection.
</span></span></span></span><span><span><span>    arena<span>.</span><span>collect_all</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> If any object was collected, then it could not have possibly been
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> safely reachable, so there&#39;s no way to (safely) cause any sort of
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> UAF. Every pointer that was reachable from `root` will still be
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> live, and any other dead pointers could not have been safely stored
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> anywhere at all.
</span></span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>WHEW! All that is left is to explain one last trick that allows us to define our
root type and thus the type of the arena itself.</p>
<h2 id="lifetime-projection">Lifetime Projection</h2>
<p>The last piece of the puzzle is how to define <code>Arena</code> itself. I&#39;ve talked about
<code>Arena</code> having a <em>root type</em>, and conceptually this is not at all difficult
to understand. During calls to <code>Arena::mutate</code>, this is the type of the <code>root</code>
callback parameter:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span><span>/*</span> something <span>*/</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span><span>//</span>                ^^^^ In our example, this is `NodePtr&lt;&#39;gc, i32&gt;`.
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The problem is the <code>&#39;gc</code> lifetime. As we have covered, the <code>&#39;gc</code> lifetime
is <em>generative</em>, meaning, at least conceptually, that every invocation of
<code>Arena::mutate</code> must get its own <em>unique</em> <code>&#39;gc</code> parameter that can never be
unified with any other:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span><span>/*</span> something <span>*/</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span><span>//</span>                ^^^^ `NodePtr&lt;&#39;gc, i32&gt;`
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span><span>//</span>                ^^^^ `NodePtr&lt;&#39;gc, i32&gt;` with *different* &#39;gc.
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span><span>//</span>                ^^^^ `NodePtr&lt;&#39;gc, i32&gt;` with *yet another* &#39;gc.
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Besides this, there is another practical problem: the type of the <code>arena</code> itself
should <em>not</em> have any sort lifetime associated with it at all. It is, after
all, a normal value and doesn&#39;t hold any borrows, and if it <em>was</em> branded with a
<code>&#39;gc</code> lifetime and then that lifetime was used in mutation callbacks, that would
allow pointers to escape the callbacks (assuming they didn&#39;t outlive the <code>arena</code>
itself at least), breaking our &#34;mutation XOR collection&#34; soundness system.</p>
<p>What we actually need is some kind of <em><code>&#39;static</code></em> type that if we give it a
<code>&#39;gc</code>, we get back whatever our root type is with that <code>&#39;gc</code> applied to it.
Hey.. that kinda sounds like a <a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">GAT</a>!</p>
<hr/>
<p>So what we need to give <code>Arena</code> is some kind of type that it can <em>substitute</em>
different <code>&#39;gc</code> lifetimes into, enabling it to use lifetime generativity to
protect pointers from leaking out of calls to <code>Arena::mutate</code>, and indeed, a GAT
fits the bill here:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> We could define some kind of `Rootable` trait that the `R` parameter on
</span></span><span><span><span>//</span> `Arena` must implement.
</span></span><span><span><span>pub</span> <span>trait</span> <span>Rootable</span> <span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> And we could have an associated type on the trait that took the &#39;gc
</span></span></span></span><span><span><span>    <span><span>//</span> lifetime as a generic parameter. That way, if we needed to make a root
</span></span></span></span><span><span><span>    <span><span>//</span> with some *specific* &#39;gc, we could use `&lt;R as Rootable&gt;::Root&lt;&#39;gc&gt;` for
</span></span></span></span><span><span><span>    <span><span>//</span> such a root.
</span></span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>&gt;</span><span>:</span> Collect <span>+</span> <span>&#39;gc</span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>This <code>Rootable</code> trait does, in fact, work perfectly to let us define <code>Arena</code>
types! This is <em>not</em> what <code>gc-arena</code> does, which I&#39;ll get to in just a second,
but there&#39;s no reason this couldn&#39;t work instead. Going back to our concrete
linked list example, we could define a <code>Rootable</code> impl this way:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>NodeRootable</span></span><span>;</span>
</span><span>
</span><span><span><span>impl</span> </span><span>Rootable <span>for</span></span><span> <span>NodeRootable</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>&gt;</span> <span>=</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, <span>i32</span><span>&gt;</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>and then we could create a new arena of type <code>Arena&lt;NodeRootable&gt;</code> like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Finally, we can actually define an arena! (Or we *could*, if this was
</span></span></span></span><span><span><span>    <span><span>//</span> actually how `Arena` worked).
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>NodeRootable<span>&gt;</span></span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> The `mc` parameter has a generative &#39;gc lifetime, and the returned
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> root type needs to match it.
</span></span></span></span></span></span></span><span><span><span><span><span><span>        Node <span><span>{</span> prev<span>:</span> <span>None</span><span>,</span> next<span>:</span> <span>None</span><span>,</span> value<span>:</span> <span>0</span> </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> The `NodePtr&lt;&#39;gc, i32&gt;` stored inside the arena has its &#39;gc lifetime
</span></span></span></span><span><span><span>    <span><span>//</span> erased, `Arena&lt;NodeRootable&gt;` is a &#39;static type.
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Bingo! this is the last piece we need to complete a workable <code>gc-arena</code> design.
I sometimes refer to this idea of globally substituting a <code>&#39;gc</code> lifetime as
&#34;lifetime projection&#34;, but it is nothing more complicated than what a GAT
provides. BUT, like I said, this is not exactly what <code>gc-arena</code> actually does,
so if it does not do this, what DOES it do, and why?</p>
<hr/>
<p>The biggest reason that <code>gc-arena</code> does not use GATs to define root types
is that <code>gc-arena</code> predates stable GATs by almost <em>four years</em><span><sup><a data-aside="aside-26">[26]</a></sup><span id="aside-26"><code>gc-arena</code> didn&#39;t start by having a nice API for this either, at the beginning
you had to declare <code>Arena</code> types with a <em>macro</em> instead and it was horrible.</span></span>
, but there is another very good reason we do not do this. First, I&#39;ll
show you what the <code>Rootable</code> type <em>actually</em> looks like in <code>gc-arena</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> Rather than use a GAT, we use a regular ol&#39; lifetime parameter on a trait.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Way before proper GATs were stabilized, there was sort of an &#34;open secret&#34;
</span></span><span><span><span>//</span> in Rust that GATs were already sort of... &#34;&#34;&#34;available&#34;&#34;&#34; with trickery.
</span></span><span><span><span>//</span> However, the poor rustc compiler would get um... upset... if you tried to
</span></span><span><span><span>//</span> use them in anything other than simplistic ways. Here is one of those tricks!
</span></span><span><span><span>//</span> Rather than use a GAT, you can use a lifetime parameter on a trait, combined
</span></span><span><span><span>//</span> with a trait bound like this:
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> `where R: for&lt;&#39;gc&gt; Rootable&lt;&#39;gc&gt;`
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Once you do this, instead of referring to `&lt;R as Rootable&gt;::Root&lt;&#39;gc&gt;`, you
</span></span><span><span><span>//</span> can instead refer to `&lt;R as Rootable&lt;&#39;gc&gt;&gt;::Root` to get basically the same
</span></span><span><span><span>//</span> result! At the time this feature went into `gc-arena`, rustc had calmed down
</span></span><span><span><span>//</span> enough to make the technique workable even without fully stabilized proper
</span></span><span><span><span>//</span> GATs.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> The &#39;static bound is not super important, it&#39;s an extra convenience to save
</span></span><span><span><span>//</span> having to write `R: &#39;static` bounds in a lot of places.
</span></span><span><span><span>pub</span> <span>trait</span> <span>Rootable</span>&lt;&#39;gc&gt;: &#39;static <span><span>{</span>
</span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>:</span> Collect <span>+</span> <span>&#39;gc</span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> Since `&lt;R as Rootable&lt;&#39;gc&gt;&gt;::Root` is a lot to type, we have a type alias
</span></span><span><span><span>//</span> for it. This is where the `Root&lt;&#39;gc, R&gt;` in the signature for `Arena::mutate`
</span></span><span><span><span>//</span> comes from.
</span></span><span><span>pub</span> <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>,</span> R<span>&gt;</span> <span>=</span> <span><span>&lt;</span>R <span>as</span> <span>Rootable<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span><span>&gt;</span></span><span><span>::</span></span>Root<span>;</span>
</span></code></pre>
<p>But so far this is just really a GAT with more steps. The <em>real</em> reason that we
have not moved off of this technique is this <em>whopper</em> of a cool hack:<span><sup><a data-aside="aside-27">[27]</a></sup><span id="aside-27">which I absolutely did
<a href="https://github.com/kyren/gc-arena/commit/1eabebcad371c19f51dc9b572ce87a131f4f6035"><em>not</em> invent</a></span></span>
</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> Instead of requiring the user to declare a new type that implements
</span></span><span><span><span>//</span> `Rootable` for every new `Arena` type they want to declare, we instead abuse
</span></span><span><span><span>//</span> trait objects.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Since every trait object always implements its own trait, by simply
</span></span><span><span><span>//</span> *referring* to a trait object for `Rootable`, we automatically get a type
</span></span><span><span><span>//</span> that implements this trait without having to declare any additional new
</span></span><span><span><span>//</span> types, and every identical invocation of `Rootable!` will always refer to the
</span></span><span><span><span>//</span> same type! Wow!!
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Currently, traits with GATs are not object safe (*yet*, this will be fixed).
</span></span><span><span><span>//</span> However, our Cheater McCheaterson GATs sure *are* object safe!
</span></span><span><span><span>#</span><span>[</span><span>macro_export</span><span>]</span></span>
</span><span><span><span>macro_rules!</span> <span>Rootable</span> <span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span><span>(</span>$gc:lifetime =&gt; <span>$root</span><span>:</span><span>ty</span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        dyn <span>for</span><span>&lt;</span><span>$gc</span><span>&gt;</span> <span>$crate</span><span><span>::</span></span>Rootable<span><span>&lt;</span><span>$gc</span>, Root = <span>$root</span><span>&gt;</span></span>
</span></span></span></span><span><span><span><span>    <span>}</span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>There&#39;s
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/arena.rs#L24">one</a>
or
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena-derive/src/lib.rs#L275">two</a>
more small pieces that I have not covered here for the
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/arena.rs#L70">real</a>
<code>Rootable!</code> macro, but these details are truly <em>not</em> that important. They
are but small QoL improvements over what I have just shown, which is the
most important part. The <code>Rootable!</code> macro is also essential in understanding
how to actually <em>use</em> <code>gc-arena</code>, because without it, using <code>Arena</code> or
<code>DynamicRootSet</code> is <em>extremely</em> annoying, and most example code will use it
heavily.</p>
<p><em>Finally</em>, here is what the actual declaration of an <code>Arena</code> that holds a
<code>NodePtr&lt;&#39;gc, i32&gt;</code> would actually look like in practice:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> No tricks this time. This is actually what you would write when using
</span></span></span></span><span><span><span>    <span><span>//</span> `gc-arena` today.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> The `Rootable!` macro is in reality a bit nicer than the one that was
</span></span></span></span><span><span><span>    <span><span>//</span> included above. In the real version, if you don&#39;t specify a lifetime with
</span></span></span></span><span><span><span>    <span><span>//</span> the `&#39;gc =&gt; _` syntax, by default just using &#39;_ will work.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> `Rootable![NodePtr&lt;&#39;_, i32&gt;]` is a type that implements the `Rootable`
</span></span></span></span><span><span><span>    <span><span>//</span> trait and becomes the `R` parameter in `Arena&lt;R&gt;`. Each time that
</span></span></span></span><span><span><span>    <span><span>//</span> `Arena::mutate` is called, the callback receives a `Root&lt;&#39;gc, R&gt;` with
</span></span></span></span><span><span><span>    <span><span>//</span> a *new* &#39;gc lifetime. `R` is not just one type but an infinite list of
</span></span></span></span><span><span><span>    <span><span>//</span> types, one for any &#39;gc we provide, which is exactly what we need.
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>Rootable<span>!</span></span><span><span>[</span><span>NodePtr<span>&lt;</span>&#39;<span>_</span>, <span>i32</span><span>&gt;</span></span><span>]</span></span><span>&gt;</span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        Node <span><span>{</span> prev<span>:</span> <span>None</span><span>,</span> next<span>:</span> <span>None</span><span>,</span> value<span>:</span> <span>0</span> </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="putting-it-all-together">Putting It All Together</h2>
<p>Okay, after ALL of this explanation, we can finally see a fully worked example
of our doubly-linked list, and understand each piece of it and how it fits
together...</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span><span>lock<span>::</span></span>RefLock<span>,</span> Arena<span>,</span> Collect<span>,</span> Gc<span>,</span> Mutation<span>,</span> Rootable</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span>//</span> We define a node of a doubly-linked list data structure.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> `Collect` is derived procedurally, meaning that we can&#39;t mess up and forget
</span></span><span><span><span>//</span> to trace our inner `prev`, `next`, or `value`.
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>//</span> For safety, we agree to not implement `Drop`. We could also use
</span></span><span><span><span>//</span> `#[collect(unsafe_drop)]` or `#[collect(require_static)]` (if our type were
</span></span><span><span><span>//</span> &#39;static) here instead.`
</span></span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> The representation of the `prev` and `next` fields is a plain machine
</span></span></span></span><span><span><span>    <span><span>//</span> pointer that might be NULL.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> Thanks, niche optimization!
</span></span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> By default, `Collect` types (other than &#39;static types) cannot have interior
</span></span><span><span><span>//</span> mutability. In order to provide safe mutation, we need to use `gc-arena`
</span></span><span><span><span>//</span> specific types to provide it which guarantee that write barriers are invoked.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> We use `RefLock` here as an alternative to `RefCell`.
</span></span><span><span>type</span> <span>NodePtr</span><span>&lt;</span><span>&#39;gc</span><span>,</span> T<span>&gt;</span> <span>=</span> <span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>RefLock<span>&lt;</span><span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span><span>;</span>
</span><span>
</span><span><span><span>//</span> Create a new `Node` and return a pointer to it.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> We need to pass the `&amp;Mutation&lt;&#39;gc&gt;` context here because we are mutating the
</span></span><span><span><span>//</span> object graph (by creating a new &#34;object&#34; with `Gc::new`).
</span></span><span><span><span><span>fn</span> </span><span>new_node</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> Collect<span>&gt;</span></span><span><span><span>(</span><span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>, <span>value</span><span>:</span> T</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>Gc<span>::</span></span>new<span><span>(</span>
</span></span></span></span><span><span><span><span>        mc<span>,</span>
</span></span></span></span><span><span><span><span>        <span>RefLock<span>::</span></span>new<span><span>(</span>Node <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            prev<span>:</span> <span>None</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            next<span>:</span> <span>None</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>    </span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> Join two nodes together, setting the `left` node&#39;s `next` field to `right`,
</span></span><span><span><span>//</span> and the `right` node&#39;s `prev` field to `left`.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Again, we are mutating the object graph, so we must pass in the
</span></span><span><span><span>//</span> `&amp;Mutation&lt;&#39;gc&gt;` context.
</span></span><span><span><span><span>fn</span> </span><span>node_join</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span>
</span></span></span><span><span><span>    <span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>left</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>right</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> This is `Gc&lt;RefLock&lt;_&gt;&gt;::borrow_mut`, which takes the mutation context as
</span></span></span></span><span><span><span>    <span><span>//</span> a parameter. Write barriers will always be invoked on the target pointer,
</span></span></span></span><span><span><span>    <span><span>//</span> so we know it is safe to mutate the value behind the pointer.
</span></span></span></span><span><span><span>    left<span>.</span><span>borrow_mut</span><span><span>(</span>mc</span><span><span>)</span></span><span>.</span>next <span>=</span> <span>Some</span><span><span>(</span>right</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    right<span>.</span><span>borrow_mut</span><span><span>(</span>mc</span><span><span>)</span></span><span>.</span>prev <span>=</span> <span>Some</span><span><span>(</span>left</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> Use a `NodePtr` as a cursor, move forward through a linked list by following
</span></span><span><span><span>//</span> `next` pointers.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Returns `true` if there was a `next` pointer and the target node has been
</span></span><span><span><span>//</span> changed.
</span></span><span><span><span><span>fn</span> </span><span>node_rotate_right</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span><span>node</span><span>:</span> <span>&amp;</span><span>mut</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>if</span> <span>let</span> <span>Some</span><span><span>(</span>next</span><span><span>)</span></span> <span>=</span> node<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>*</span>node <span>=</span> next<span>;</span>
</span></span></span></span><span><span><span><span>        <span>true</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>false</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> Use a `NodePtr` as a cursor, move backward through a linked list by following
</span></span><span><span><span>//</span> `prev` pointers.
</span></span><span><span><span>//</span>
</span></span><span><span><span>//</span> Returns `true` if there was a `prev` pointer and the target node has been
</span></span><span><span><span>//</span> changed.
</span></span><span><span><span><span>fn</span> </span><span>node_rotate_left</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span><span>node</span><span>:</span> <span>&amp;</span><span>mut</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>if</span> <span>let</span> <span>Some</span><span><span>(</span>prev</span><span><span>)</span></span> <span>=</span> node<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>prev <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>*</span>node <span>=</span> prev<span>;</span>
</span></span></span></span><span><span><span><span>        <span>true</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>false</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Create a new arena with a single `NodePtr&lt;&#39;_, i32&gt;` as the root type.
</span></span></span></span><span><span><span>    <span><span>//</span> 
</span></span></span></span><span><span><span>    <span><span>//</span> We can&#39;t refer to some *particular* `NodePtr&lt;&#39;gc, i32&gt;`, what we need to
</span></span></span></span><span><span><span>    <span><span>//</span> be able to refer to is a set of `NodePtr&lt;&#39;_, i32&gt;` for any possible &#39;_
</span></span></span></span><span><span><span>    <span><span>//</span> that we might pick. We use gc-arena&#39;s `Rootable!` macro for this.
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>Rootable<span>!</span></span><span><span>[</span><span>NodePtr<span>&lt;</span>&#39;<span>_</span>, <span>i32</span><span>&gt;</span></span><span>]</span></span><span>&gt;</span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> Create a simple linked list with three links.
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> 
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4
</span></span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> one <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>1</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> two <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> three <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>3</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> four <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>4</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> one<span>,</span> two</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> two<span>,</span> three</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> three<span>,</span> four</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> We return the pointer to 1 as our root
</span></span></span></span></span></span></span><span><span><span><span><span><span>        one
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Outside of a call to `Arena::new` or `Arena::mutate`, we have no access
</span></span></span></span><span><span><span>    <span><span>//</span> to anything *inside* the arena. We have to *visit* the arena with one of
</span></span></span></span><span><span><span>    <span><span>//</span> the mutation methods in order to access its interior.
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> We can examine the root type and see that our linked list is still
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> [1, 2, 3, 4]
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> i <span>in</span> <span>1</span><span>..</span><span>=</span><span>4</span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>node_rotate_right</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> Also, all of the reverse links work too.
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> i <span>in</span> <span><span>(</span><span>1</span><span>..</span><span>=</span><span>4</span></span><span><span>)</span></span><span>.</span><span>rev</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>node_rotate_left</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> Make the list circular! We sever the connection to 4 and link 3 back
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> to 1 making a list like this...
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> +-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-+
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> |                   |
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> +-------------------+
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> one <span>=</span> <span>*</span>root<span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> two <span>=</span> one<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next<span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> three <span>=</span> two<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next<span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> three<span>,</span> one</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> The node for 4 is now unreachable!
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> It can be freed during collection, but collection does not happen
</span></span></span></span><span><span><span>    <span><span>//</span> automatically. We have to trigger collection *outside* of a mutation
</span></span></span></span><span><span><span>    <span><span>//</span> method.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> The `Arena::collect_all` finishes the current collection cycle, but this
</span></span></span></span><span><span><span>    <span><span>//</span> is not the only way to trigger collection.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> `gc-arena` is an incremental collector, and so keeps track of &#34;debt&#34;
</span></span></span></span><span><span><span>    <span><span>//</span> during the GC cycle, pacing the collector based on the rate and size of new
</span></span></span></span><span><span><span>    <span><span>//</span> allocations.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> We can also call `Arena::collect_debt` to do a *bit* of collection at a
</span></span></span></span><span><span><span>    <span><span>//</span> time, based on the current collector debt.
</span></span></span></span><span><span><span>    <span><span>//</span>
</span></span></span></span><span><span><span>    <span><span>//</span> Since the collector has not yet started its marking phase, calling this
</span></span></span></span><span><span><span>    <span><span>//</span> will fully mark the arena and collect all the garbage, so this method
</span></span></span></span><span><span><span>    <span><span>//</span> will always free the 4 node.
</span></span></span></span><span><span><span>    arena<span>.</span><span>collect_all</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> Now we can see that if we rotate through our circular list, we will
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> get:
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span><span>//</span> 1 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 3
</span></span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>2</span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>for</span> i <span>in</span> <span>1</span><span>..</span><span>=</span><span>3</span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>node_rotate_right</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>Thank you for reading this far, I hope you found this tour of the design of
<code>gc-arena</code> interesting. It is a crate whose use requires understanding several
different unusual techniques all at one time, and explaining each piece is
difficult in isolation. Hopefully this post can serve as a good introduction to
someone who wants to use it in the future.</p>
<p>I understand that using <code>gc-arena</code> comes with a pretty high cognitive and
usability overhead. In particular, satisfying the &#34;mutability XOR collection&#34;
design by mutating via callback can be particularly challenging, and I will
cover this much more in future posts about <code>piccolo</code>. However, not many
languages can even be used to implement garbage collection at all, and even
fewer could hope to do so with provable memory safety. In many ways, trying
to design &#34;safe, isolated garbage collection as a library&#34; is wading through
uncharted territory, so I hope you can view <code>gc-arena</code>&#39;s rough edges with this
in mind.</p>
<p>In future posts, I want to talk about the way that I wish <code>gc-arena</code> <em>could</em>
work if there were enough features in Rust to make it possible, using <code>async</code>
and <code>.await</code> to express GC &#34;safe points&#34;, but that discussion is for another
time.</p>
<p>Bye!</p>


  </div></div>
  </body>
</html>
