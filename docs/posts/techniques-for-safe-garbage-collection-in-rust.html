<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kyju.org/blog/rust-safe-garbage-collection/">Original</a>
    <h1>Techniques for safe garbage collection in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    

<p><strong>2024-01-13</strong></p>

    <ul>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#rust-and-garbage-collection">Rust and Garbage Collection</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#tracing-and-interior-mutability">Tracing and Interior Mutability</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#finding-gc-roots-with-generativity">Finding GC Roots with Generativity</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#lifetime-projection">Lifetime Projection</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#putting-it-all-together">Putting It All Together</a>
            
        </li>
    
        <li>
            <a href="https://kyju.org/blog/rust-safe-garbage-collection/#closing-thoughts">Closing Thoughts</a>
            
        </li>
    
    </ul>

<hr/>
<p>This will be the first in a series of posts describing different design
decisions made writing two Rust crates:</p>
<ul>
<li><a href="https://github.com/kyren/gc-arena">gc-arena</a> - A system for safely fitting
Rust with incremental garbage collection, used by
<a href="https://ruffle.rs">Ruffle</a>.</li>
<li><a href="https://github.com/kyren/piccolo">piccolo</a> - A stackless Lua runtime
written in safe Rust with a focus on safe sandboxing.</li>
</ul>
<p>The goal of this series of posts is not really to sell anyone on these crates,
or even the ideas that went into them, but to document why I<span><sup><a data-aside="aside-1">[1]</a></sup><span id="aside-1">in the
case of <code>gc-arena</code>, <em>we</em></span></span>
 made the design decisions I did, and to touch
on a web of issues and potential solutions that might<span><sup><a data-aside="aside-2">[2]</a></sup><span id="aside-2"><em>might</em></span></span>
 be applicable to the larger Rust ecosystem.</p>
<p>This is going to be a pretty long post, and also very technical and pretty
dry. I&#39;m not even going to cover every technique developed for <code>gc-arena</code>, I&#39;m
just aiming to cover the ideas that you are guaranteed to encounter when trying
to use it at all. I may come back and cover things like the details around
<code>Collect</code> impls and GC &#34;finalization&#34; in a future post.</p>
<p>This post also doesn&#39;t really ask any big questions or present any big, unsolved
problems, it is meant mostly as an answer to a set of very common questions,
asking why exactly <code>gc-arena</code> is the way it is. This is also an essential
pre-requisite to talk at <em>all</em> about <code>piccolo</code>, so I&#39;m just going to have to get
this out of the way first before a hopefully much more interesting discussion of
<code>piccolo</code> itself.</p>
<h2 id="rust-and-garbage-collection">Rust and Garbage Collection</h2>
<p>Rust as she is spoke,<span><sup><a data-aside="aside-3">[3]</a></sup><span id="aside-3">and
<a href="https://en.wikipedia.org/wiki/English_as_She_Is_Spoke">English</a> for that
matter</span></span>
 at least currently, does not have &#34;true&#34; garbage collection.
The terms around this are a bit contentious,<span><sup><a data-aside="aside-4">[4]</a></sup><span id="aside-4">It is not inaccurate to
refer to <code>Rc</code> and <code>Arc</code> as a form of garbage collection without cycle detection,
and some people prefer to view them as part of the same continuum.</span></span>
 but
what I mean is garbage collection with cycle detection, the kind of which allows
you to more or less stop thinking about <em>ownership</em> and instead only think
about <em>reachability</em>. The fact that Rust did not ship with this feature is maybe
unsurprising in retrospect, since it is at odds in several ways with its design
ethos,<span><sup><a data-aside="aside-5">[5]</a></sup><span id="aside-5">ownership semantics, mutability XOR aliasing, and minimal
behind-the-scenes runtime</span></span>
 but this wasn&#39;t always the plan! Rust used to
have built-in garbage-collected
<a href="https://steveklabnik.com/writing/pointers-in-rust-a-guide">managed pointers</a>,
and there has been at least
<a href="https://manishearth.github.io/blog/2016/08/18/gc-support-in-rust-api-design/">some discussion</a>
on bringing them back. <code>gc-arena</code> represents my<span><sup><a data-aside="aside-6">[6]</a></sup><span id="aside-6">I can no longer take
sole credit for <code>gc-arena</code>, it has other major contributors since being used in
the Ruffle project, and in fact I have those contributors to thank for me even
continuing to work on it at all. More on this later.</span></span>
 attempt to
retrofit Rust with these types of garbage-collected pointers purely as a
library.</p>
<p>I&#39;m far from the first person to attempt this, I think
<a href="https://manishearth.github.io/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/">this</a>
post by <a href="https://manishearth.github.io">Manish Goregaokar</a> is the best starting
point I know of to read about some of the landscape, <code>gc-arena</code> is featured in
that article as one point in a complex design space, and I&#39;m only going to cover
the part of the space I&#39;m familiar with.</p>
<p><code>gc-arena</code> exists because <code>piccolo</code> (formerly &#34;luster&#34;) needed a garbage
collector, and I had a very specific set of requirements in mind when I started:</p>
<ul>
<li>I was heavily borrowing<span><sup><a data-aside="aside-7">[7]</a></sup><span id="aside-7">shamelessly stealing</span></span>
 much
of the interpreter design from the <a href="https://lua.org">Ur Lua</a> (The version
developed at PUC-Rio), and my chief goal was that <code>piccolo</code> should never be
somehow doomed to be forever slower or inferior to PUC-Rio Lua. What I mean
by this is complex and I hope to cover in a later post, but for now, what
I mean is that, like PUC-Rio Lua and all of its forks, garbage-collected
pointers needed to be <em>zero-cost plain pointers</em>, which in Rust terms means
that they are <code>Copy</code> and don&#39;t include bookkeeping during normal use. This
was important for the stack-based design of the Lua VM, which was going to be
inspired<span><sup><a data-aside="aside-8">[8]</a></sup><span id="aside-8">stolen</span></span>
 from PUC-Rio Lua.</li>
<li><code>piccolo</code> needed to be written in (almost) entirely safe Rust. It exists as
an experiment to see how <em>far</em> I could go writing a Lua runtime with provable
memory safety and performance that was not fundamentally any slower than an
equivalent runtime without memory safety.</li>
</ul>
<p>These two requirements together, that garbage-collected pointers are (when
ignoring the actual process of garbage collection) <em>free</em>, and that the
runtime needed to be majority memory safe,<span><sup><a data-aside="aside-9">[9]</a></sup><span id="aside-9">What I mean by this
is much more complex but it&#39;s too much to go into here. It needed to have no
<em>infectious unsafety</em> like PUC-Rio Lua has. Normal C code is always
memory unsafe, PUC-Rio Lua and her forks are on an entirely
<a href="https://github.com/luau-lang/luau/blob/e76802f2ce698ca090a793b24c07e336b21ade9f/VM/src/lvmexecute.cpp#L26">different plane of existence</a>,
my goal was to avoid things like <em>this</em>.</span></span>
 meant that none of the
existing designs I could find would work.<span><sup><a data-aside="aside-10">[10]</a></sup><span id="aside-10">at least as of late 2018,
when these projects were originally conceived</span></span>
 I found a way forward
to satisfy both of these requirements, and with a garbage collector very similar
to the incremental collector in PUC-Rio Lua,<span><sup><a data-aside="aside-11">[11]</a></sup><span id="aside-11">Because I stole the
design outright. Stealing is easy and fun!</span></span>
 and thus <code>gc-arena</code> was
born.</p>
<h2 id="tracing-and-interior-mutability">Tracing and Interior Mutability</h2>
<p>Designing a tracing garbage collector library for Rust with a safe interface
is challenging. Usually, most of the difficulty orbits around the problems of
correctly tracing values which hold managed (garbage-collected) pointers and
deterministically knowing the set of garbage collector &#34;roots&#34; (the places
where some non-managed value holds a pointer to a managed value, and thus
garbage-collected values that are <em>known</em> to be externally reachable).<span><sup><a data-aside="aside-12">[12]</a></sup><span id="aside-12">These problems often arise when retrofitting garbage collection to systems
programming languages generally, the lack of a language runtime or some kind
of machinery to know where managed pointers could be held often necessitates
conservative stack / heap scanning, which isn&#39;t <em>great</em>.</span></span>
</p>
<p>The best way to explore these problems and how <code>gc-arena</code> solves them is with
an example, and in this post we&#39;re going to slowly build up a doubly-linked
list data structure, covering different issues as they come up. We&#39;ll start with
defining a single <code>Node</code> of this doubly-linked list:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We&#39;ll put the problem of deterministically finding roots aside for the moment.
Assuming we know the GC roots, we need to be able to trace every possible
reachable garbage collected pointer from them. This is a safety issue, if we
were to miss any reachable pointer, we might improperly collect it and this
could lead to a UAF (Use After Free). <code>gc-arena</code> handles this requirement with
its
<a href="https://github.com/kyren/gc-arena/blob/6ee59df2cfe67b273a6cb1fc4d65b4e61b77d537/src/gc-arena/src/collect.rs#L22">Collect</a>
trait, which all garbage-collectable types must implement. The trait is unsafe
to implement, because implementations must ensure that every reachable pointer
is traced.</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span>unsafe</span> <span><span>impl</span></span><span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> Collect<span>&gt;</span></span></span><span> Collect <span>for</span></span><span> <span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>trace</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>cc</span><span>:</span> <span>&amp;</span>Collection</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>prev<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>next<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>value<span>.</span><span>trace</span><span><span>(</span>cc</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>However, this trait <em>can</em> safely be implemented via proc-macro! As long as the
implementation requires that every field itself implement <code>Collect</code> and the
generated <code>Collect::trace</code> implementation calls the <code>Collect::trace</code> method of
every field, nothing can go wrong. The end result looks like this, which allows
defining and using custom garbage collected types without needing any unsafe
code at all!</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The only remaining problem is the <code>Drop</code> trait... since objects can contain
circular references, there is no order in which we can drop them such that every
object would contain only un-dropped pointers. If we allowed users to implement
<code>Drop::drop</code> for <code>Collect</code> types, they could cause memory unsafety by accessing
these dropped values. This is easy to see with our linked list example, if there
was a <code>Drop</code> implementation on our <code>Node</code> type that accessed either <code>prev</code> or
<code>next</code>, in a circularly linked list that would mean that there would be <em>no</em>
possible safe order to drop our nodes in! <code>gc-arena</code> solves this by forbidding
<code>Drop</code> impls on types using auto-generated <code>Collect</code> impls using a trick,<span><sup><a data-aside="aside-13">[13]</a></sup><span id="aside-13">which I stole from
<a href="https://github.com/taiki-e/pin-project">pin-project</a>. Fun <em>and</em> easy!</span></span>
 internal to <code>gc-arena</code>, there is a trait called <code>MustNotImplDrop</code> that looks
like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>trait</span> <span>MustNotImplDrop</span> <span><span>{</span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span></span><span><span><span>&lt;</span>T<span>:</span> <span>Drop</span><span>&gt;</span></span></span><span> MustNotImplDrop <span>for</span></span><span> <span>T</span> </span><span><span><span>{</span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Auto-generated <code>Collect</code> impls (without an unsafe buy-in to allow custom <code>Drop</code>
impls) generate an impl for <code>MustNotImplDrop</code>, thus, if the user tries to
implement <code>Drop</code> for their type, this causes a conflicting implementation and a
compiler error.</p>
<hr/>
<p><code>gc-arena</code> is also an incremental collector, which poses a new problem...
Imagine that we have already traced an object during our incremental tracing
operation, then we allow the user to mutate that object. If the user puts a
pointer to an un-traced object inside the already traced object, we now have
an object which is marked as having been traced pointing to an object that
has <em>not</em> been traced. This also can lead to dangling pointers, so we need
to protect against this somehow. <code>gc-arena</code> refers to this as the <em>color
invariant</em>, a &#34;black&#34; object (fully traced), may not point to a &#34;white&#34; object
(untraced).</p>
<p>The solution lies again with the <code>Collect</code> trait. <code>Gc</code> pointers are always
presumed to be aliased (they have no bookkeeping to prove otherwise) so <code>Gc</code>
provides only <em>shared</em> references to its inner type. Any mutation for garbage
collected values must come solely from types that provide <em>interior mutability</em>
through a shared reference. Such types are not allowed to implement <code>Collect</code>
directly,<span><sup><a data-aside="aside-14">[14]</a></sup><span id="aside-14">They also can&#39;t implement <code>Collect</code> via procedural derive
because we purposefully do not include <code>Collect</code> impls for interior mutability
primitives. In order to implement <code>Collect</code> for a type with its own interior
mutability, you must have an unsafe <code>Collect</code> impl which asserts that you follow
the write barrier contract.</span></span>
 instead <code>gc-arena</code> provides its own
versions of interior mutability (<code>Lock</code> instead of <code>Cell</code>, <code>RefLock</code> instead of
<code>RefCell</code>) which always require &#34;write barriers&#34; to enable mutation. A &#34;write
barrier&#34; is jargon from garbage collection literature, in our case it is
always a backwards write barrier (but we may add forward write barriers in the
future). If a &#34;black&#34; object is written to, it gets put back into the queue
of to-be-traced objects (&#34;gray&#34; objects, specifically the &#34;gray again&#34; list),
meaning it will be re-traced. In this way, we can&#39;t lose track of any reachable
objects. (There is a great
<a href="https://www.youtube.com/watch?v=wGizKsOJQuE">talk</a> about the PUC-Rio garbage
collector which implements the same<span><sup><a data-aside="aside-15">[15]</a></sup><span id="aside-15">because that&#39;s where I stole it
from</span></span>
 incremental design (as well as his newer generational collector)
by the creator of Lua, Roberto Ierusalimschy.)</p>
<p>This lack of interior mutability by default means that our previous linked list
<code>Node</code> example is woefully incomplete! As it is written, we would never be able
to mutate any nodes once they were placed in a <code>Gc</code>, so the data structure as
defined above would be almost useless. We need to enable safe mutation by using
one of the <code>gc-arena</code> types which provide it:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span>Collect<span>,</span> Gc<span>,</span> <span>lock<span>::</span></span>RefLock</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span>
</span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span>type</span> <span>NodePtr</span><span>&lt;</span><span>&#39;gc</span><span>,</span> T<span>&gt;</span> <span>=</span> <span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>RefLock<span>&lt;</span><span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span><span>;</span>
</span></code></pre>
<p>Now, we&#39;re able to safely mutate values of this type that live inside <code>Gc</code>
pointers:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span></span><span></span><span></span><span></span><span></span><span><span><span><span>fn</span> </span><span>node_set_value</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>Copy</span><span>&gt;</span></span><span><span><span>(</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>node_ptr</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>value</span><span>:</span> T
</span></span></span><span><span><span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> write <span>=</span> node_ptr<span>.</span><span>write</span><span><span>(</span>mc</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> ref_cell <span>=</span> write<span>.</span><span>unlock</span><span><span>(</span>mc</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    ref_cell<span>.</span><span>borrow_mut</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value <span>=</span> value<span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<hr/>
<p>This strategy of using a custom unsafe trait with safe proc-macro generation
for tracing is not new, it was used by Manish in his
<a href="https://github.com/Manishearth/rust-gc">rust-gc library</a>, from which <code>gc-arena</code>
heavily borrows.<span><sup><a data-aside="aside-16">[16]</a></sup><span id="aside-16">steals... you might be noticing a pattern</span></span>

<code>rust-gc</code> calls its <code>Collect</code> trait <code>Trace</code>, and has a similar system to manage
otherwise unsafe mutability, where internally mutable types do <em>not</em> implement
<code>Trace</code> directly for safety (though since <code>rust-gc</code> is not an incremental
collector, the mutability safety problems are slightly different).</p>
<p>The <code>Collect</code> trait forms one of the two pillars of <code>gc-arena</code>&#39;s soundness
story, but it is only half of the story. We need to be able to deterministically
find all of the garbage collector&#39;s roots, AND to make sure that no internal
mutability occurs during incremental collection. For this we use another
trick...</p>
<h2 id="finding-gc-roots-with-generativity">Finding GC Roots with Generativity</h2>
<p>There is an accidental feature of the Rust borrow checker that introduces
something called &#34;generativity&#34; into Rust. This was, AFAIK, first described in
<a href="https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">Alexis Beingessner&#39;s Master&#39;s thesis</a>,<span><sup><a data-aside="aside-17">[17]</a></sup><span id="aside-17">You can find the description under the section &#34;Hacking Generativity
into Rust&#34;, right before she says &#34;we <em>really</em> donâ€™t recommend doing this&#34;.</span></span>
 and you can see her thesis for probably a much better explanation,
but I&#39;ll try my best to explain the concept very briefly. &#34;Generativity&#34; as it
exists in Rust allows us a sort of very limited form of dependent typing: each
time a closure is executed <em>at runtime</em>, a brand new type (in this case, a Rust
lifetime) is generated that cannot be unified with any other generated instance.
Of course, the Rust compiler and thus any notion of types does not exist at
runtime, so this is only one way to look at what is happening. Really, the
technique can be boiled down to a simple fact about lifetimes in Rust function
types: you can construct a function that must work <em>for any</em> given lifetime,
so every time such a function is called, the body of such a function only knows
that <em>there exists</em> some lifetime that must satisfy its signature and nothing
else, so the lifetime from one call of a function cannot be unified with any
other. This technique has seen some existing use in Rust, there&#39;s even a
<a href="https://github.com/CAD97/generativity">crate</a> for it,<span><sup><a data-aside="aside-18">[18]</a></sup><span id="aside-18">It doesn&#39;t
use the closure lifetime trick, but it uses something equivalent.</span></span>
 but
it is not widely used because frankly it can be a bit of a <em>pain in the butt</em>.</p>
<p>This trick is sometimes also called &#34;lifetime branding&#34;, which is a name more
appropriate for how it is used in <code>gc-arena</code>: if you have a generative lifetime
<code>&#39;id</code>, any type &#34;branded&#34; with this <code>&#39;id</code> cannot ever be unified with another
type branded with a different <code>&#39;id</code>. In <code>gc-arena</code> this lifetime is called
<code>&#39;gc</code>, and it brands all garage-collected values (garbage-collected <code>Gc</code>
pointers and anything transitively containing them).</p>
<p>Describing this trick in thick jargon like this is not very useful, it&#39;s much
easier to understand when we look concretely at how it is actually used in
<code>gc-arena</code>.</p>
<hr/>
<p>The word &#34;arena&#34; is commonly used in systems programming to refer to a technique
of allocating memory from a single pool such that every allocation shares
the same lifetime. The name &#34;arena&#34; is meant to be evocative of some kind of
<em>enclosure</em>, all allocations are kept enclosed in an &#34;arena&#34; and ultimately
share the same fate: allocations will always have a lifetime tied to their
parent arena, and they are all freed when the arena is destroyed (or reset,
depending on how the arena works). There is a great explanation of this &#34;arena
technique&#34; as it appears in Rust on
<a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">Manish&#39;s blog</a>,
allocated references returned from arenas all share some kind of &#39;arena lifetime
such that all of the allocations can be invalidated at the same point, when the
whole arena is reset.</p>
<p>The &#34;arena&#34; in &#34;gc-arena&#34; means sort of the same thing, that allocated pointers
are kept in an <em>enclosure</em> and may not escape it, and all of them must share
the same fate of being forever bound inside the arena they were birthed in.<span><sup><a data-aside="aside-19">[19]</a></sup><span id="aside-19">Sometimes programmer-speak can be a bit <em>too</em> evocative.</span></span>

<code>gc-arena</code> is different in that pointers do not <em>necessarily</em> have to live for
the entire lifetime of the arena, only <em>reachable</em> pointers, but the idea is
similar enough to other arena allocators that I picked the name &#34;gc-arena&#34;.</p>
<p><code>gc-arena</code> is also different from other arena allocators in specifically how
it uses its arena lifetime (which <code>gc-arena</code> calls <code>&#39;gc</code>). Rather than only
ensuring that pointers do not outlive some moment in time where every arena
pointer is freed, <code>gc-arena</code> uses the same technique repeatedly over the
lifetime of the <em>same</em> arena, ensuring that pointers must not escape <em>a single
unit of mutation</em>. &#34;Mutation&#34; here is garbage collector jargon, and simply means
&#34;things that are not <em>collection</em>&#34;, which is, well, any actual work your program
will do. Since <em>useful work</em> may <em>mutate</em> the object graph, everything useful
your program actually <em>does</em> is lumped together and called &#34;mutation&#34;.<span><sup><a data-aside="aside-20">[20]</a></sup><span id="aside-20">Sometimes programmers also can get tunnel vision.</span></span>
</p>
<p>The <code>Gc</code> pointer in <code>gc-arena</code> looks something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span>pub</span> <span>struct</span> </span><span><span><span>Gc</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span></span><span>
</span></span><span><span>    where T: ?Sized + &#39;gc
</span></span><span><span></span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>ptr</span><span>:</span> <span>NonNull<span>&lt;</span><span>GcBox<span>&lt;</span>T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>_invariant</span><span>:</span> <span>Invariant<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We have a simple pointer value (<code>Gc</code> implements a slew of traits, but notably it
is always <code>Copy</code>) and a zero-size marker type that both binds the <code>Gc</code> pointer
to <code>&#39;gc</code> and also makes it <em>invariant</em><span><sup><a data-aside="aside-21">[21]</a></sup><span id="aside-21">You can see a great
explanation of lifetime subtyping and variance in the Rustonomicon
<a href="https://doc.rust-lang.org/nomicon/subtyping.html">here</a>.</span></span>
 over <code>&#39;gc</code>
(more on this in a second). Since every <code>Gc</code> pointer is &#34;branded&#34; with this
<code>&#39;gc</code> lifetime, we can leverage the power of the Rust borrow checker to tightly
control their lifetime.</p>
<p>The top-level type in <code>gc-arena</code> is called <code>Arena</code>, and it is parameterized
over an <code>R</code> which is the arena&#39;s <em>root type</em>.<span><sup><a data-aside="aside-22">[22]</a></sup><span id="aside-22">Sort of, I&#39;ll explain
in a bit</span></span>
 Everything that the arena will ever store must fit into this
single root type, so all long-term reachable pointers must always be reachable
somehow from this single root.<span><sup><a data-aside="aside-23">[23]</a></sup><span id="aside-23">This is restrictive, but there are
things like
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/dynamic_roots.rs#L28">DynamicRootSet</a>
which make this less restrictive than it sounds.</span></span>
 It provides methods
to <em>mutate</em> this single root, and by using lifetime branding, we can prove that
in-between calls to mutate, <em>every reachable pointer must be reachable from
the root</em>.</p>
<p>Whew, this is a lot setup to describe the main idea of <code>gc-arena</code>, and this will
make a lot more sense with a concrete example. We&#39;ll use the linked list example
from before and decide that a <code>NodePtr&lt;&#39;gc, i32&gt;</code> should be our root type. I&#39;m
skipping the part where we actually <em>construct</em> the arena because this requires
one final trick which I haven&#39;t talked about yet, but a full example will be
provided by the end, I promise.<span><sup><a data-aside="aside-24">[24]</a></sup><span id="aside-24"><a href="https://xkcd.com/365/">Bare with me for a moment.</a></span></span>
</p>
<p>Access to an arena is tightly controlled in single units of <em>mutation</em>. This
is not as complex as it sounds, what it effectively means is that in order
to access an arena, you just need to call a method on the arena which takes
a callback:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>dbg!</span><span><span>(</span>root<span>.</span>prev<span>.</span><span>is_some</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        root<span>.</span>prev <span>=</span> <span>None</span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The signature for <code>Arena::mutate</code> looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span></span><span><span><span>&lt;</span>R<span>&gt;</span></span></span><span> <span>Arena</span><span><span>&lt;</span>R<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>mutate</span></span><span><span>&lt;</span>T<span>&gt;</span></span><span><span><span>(</span>
</span></span></span></span></span><span><span><span><span><span>        <span>&amp;</span><span>self</span>,
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        <span>f</span><span>:</span> impl <span>for<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span> FnOnce<span><span>(</span></span><span>&amp;&#39;<span>gc</span> <span>Mutation</span>&lt;&#39;<span>gc</span>&gt;<span>,</span> &amp;&#39;<span>gc</span> <span>Root</span>&lt;&#39;<span>gc</span><span>,</span> <span>R</span>&gt;</span><span><span>)</span></span> -&gt; T
</span></span></span></span></span><span><span><span><span><span>    </span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> T</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The most important part of the callback signature is the <code>for&lt;&#39;gc&gt;</code> part, which
is known as Higher Rank Trait Bounds or HRTBs, and it is how you do &#34;universal
quantification&#34; for a lifetime in Rust. The Rustonomicon
<a href="https://doc.rust-lang.org/nomicon/hrtb.html">explains it better</a>, but
<code>for&lt;&#39;gc&gt;</code> means &#34;for all choices of <code>&#39;gc</code>&#34;,<span><sup><a data-aside="aside-25">[25]</a></sup><span id="aside-25">aka
<a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a></span></span>
 and it requires that the callback be valid for <em>any possible choice
of <code>&#39;gc</code></em>. This means that the callback effectively can know <em>nothing</em> about
the <code>&#39;gc</code> lifetime at all, so the borrow checker must prevent types with this
lifetime from escaping out of the single callback call. After all, we <em>could</em>
choose an arbitrarily small <code>&#39;gc</code>, so any escape from the callback at all <em>must</em>
be treated as a borrow checker error. This is the key trick for &#34;generativity&#34;
that was discussed at the beginning of this section, and you can check Gankra&#39;s
thesis for a more complete explanation.</p>
<pre data-lang="rust"><code data-lang="rust"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    <span>let</span> escape <span>=</span> arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span>root<span>.</span>prev</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>We&#39;ve also made a big deal about ensuring that <code>Gc</code> pointers are <em>invariant</em>
over the <code>&#39;gc</code> branding lifetime, and here&#39;s why we do that: If <code>Gc</code> pointers
were <em>covariant</em> over <code>&#39;gc</code>, which we might accidentally do if we were not
careful, we could accidentally allow the user to <em>shorten</em> <code>&#39;gc</code> which could
still cause problems:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena1 <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena2 <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena1<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root1</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>      arena2<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root2</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        root2<span>.</span>prev <span>=</span> root1<span>.</span>next<span>;</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>      </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>So FINALLY we can put all the pieces together... IF we know that all garbage
collector pointers are branded by <code>&#39;gc</code> AND we know that we can only access any
garbage collected pointers through a callback which is universally quantified
over <code>&#39;gc</code>, THEN we can finally prove all of the properties we need for safe
garbage collection:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>unknowable<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    arena<span>.</span><span>collect_all</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>WHEW! All that is left is to explain one last trick that allows us to define our
root type and thus the type of the arena itself.</p>
<h2 id="lifetime-projection">Lifetime Projection</h2>
<p>The last piece of the puzzle is how to define <code>Arena</code> itself. I&#39;ve talked about
<code>Arena</code> having a <em>root type</em>, and conceptually this is not at all difficult
to understand. During calls to <code>Arena::mutate</code>, this is the type of the <code>root</code>
callback parameter:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The problem is the <code>&#39;gc</code> lifetime. As we have covered, the <code>&#39;gc</code> lifetime
is <em>generative</em>, meaning, at least conceptually, that every invocation of
<code>Arena::mutate</code> must get its own <em>unique</em> <code>&#39;gc</code> parameter that can never be
unified with any other:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span></span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Besides this, there is another practical problem: the type of the <code>arena</code> itself
should <em>not</em> have any sort lifetime associated with it at all. It is, after
all, a normal value and doesn&#39;t hold any borrows, and if it <em>was</em> branded with a
<code>&#39;gc</code> lifetime and then that lifetime was used in mutation callbacks, that would
allow pointers to escape the callbacks (assuming they didn&#39;t outlive the <code>arena</code>
itself at least), breaking our &#34;mutation XOR collection&#34; soundness system.</p>
<p>What we actually need is some kind of <em><code>&#39;static</code></em> type that if we give it a
<code>&#39;gc</code>, we get back whatever our root type is with that <code>&#39;gc</code> applied to it.
Hey.. that kinda sounds like a <a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">GAT</a>!</p>
<hr/>
<p>So what we need to give <code>Arena</code> is some kind of type that it can <em>substitute</em>
different <code>&#39;gc</code> lifetimes into, enabling it to use lifetime generativity to
protect pointers from leaking out of calls to <code>Arena::mutate</code>, and indeed, a GAT
fits the bill here:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span></span><span><span><span>pub</span> <span>trait</span> <span>Rootable</span> <span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>&gt;</span><span>:</span> Collect <span>+</span> <span>&#39;gc</span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>This <code>Rootable</code> trait does, in fact, work perfectly to let us define <code>Arena</code>
types! This is <em>not</em> what <code>gc-arena</code> does, which I&#39;ll get to in just a second,
but there&#39;s no reason this couldn&#39;t work instead. Going back to our concrete
linked list example, we could define a <code>Rootable</code> impl this way:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>NodeRootable</span></span><span>;</span>
</span><span>
</span><span><span><span>impl</span> </span><span>Rootable <span>for</span></span><span> <span>NodeRootable</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>&gt;</span> <span>=</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, <span>i32</span><span>&gt;</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>and then we could create a new arena of type <code>Arena&lt;NodeRootable&gt;</code> like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>NodeRootable<span>&gt;</span></span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        Node <span><span>{</span> prev<span>:</span> <span>None</span><span>,</span> next<span>:</span> <span>None</span><span>,</span> value<span>:</span> <span>0</span> </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Bingo! this is the last piece we need to complete a workable <code>gc-arena</code> design.
I sometimes refer to this idea of globally substituting a <code>&#39;gc</code> lifetime as
&#34;lifetime projection&#34;, but it is nothing more complicated than what a GAT
provides. BUT, like I said, this is not exactly what <code>gc-arena</code> actually does,
so if it does not do this, what DOES it do, and why?</p>
<hr/>
<p>The biggest reason that <code>gc-arena</code> does not use GATs to define root types
is that <code>gc-arena</code> predates stable GATs by almost <em>four years</em><span><sup><a data-aside="aside-26">[26]</a></sup><span id="aside-26"><code>gc-arena</code> didn&#39;t start by having a nice API for this either, at the beginning
you had to declare <code>Arena</code> types with a <em>macro</em> instead and it was horrible.</span></span>
, but there is another very good reason we do not do this. First, I&#39;ll
show you what the <code>Rootable</code> type <em>actually</em> looks like in <code>gc-arena</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span><span><span>pub</span> <span>trait</span> <span>Rootable</span>&lt;&#39;gc&gt;: &#39;static <span><span>{</span>
</span></span></span><span><span><span>    <span>type</span> <span>Root</span><span>:</span> Collect <span>+</span> <span>&#39;gc</span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span></span><span></span><span><span>pub</span> <span>type</span> <span>Root</span><span>&lt;</span><span>&#39;gc</span><span>,</span> R<span>&gt;</span> <span>=</span> <span><span>&lt;</span>R <span>as</span> <span>Rootable<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span><span>&gt;</span></span><span><span>::</span></span>Root<span>;</span>
</span></code></pre>
<p>But so far this is just really a GAT with more steps. The <em>real</em> reason that we
have not moved off of this technique is this <em>whopper</em> of a cool hack:<span><sup><a data-aside="aside-27">[27]</a></sup><span id="aside-27">which I absolutely did
<a href="https://github.com/kyren/gc-arena/commit/1eabebcad371c19f51dc9b572ce87a131f4f6035"><em>not</em> invent</a></span></span>
</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span><span><span>#</span><span>[</span><span>macro_export</span><span>]</span></span>
</span><span><span><span>macro_rules!</span> <span>Rootable</span> <span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span><span>(</span>$gc:lifetime =&gt; <span>$root</span><span>:</span><span>ty</span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        dyn <span>for</span><span>&lt;</span><span>$gc</span><span>&gt;</span> <span>$crate</span><span><span>::</span></span>Rootable<span><span>&lt;</span><span>$gc</span>, Root = <span>$root</span><span>&gt;</span></span>
</span></span></span></span><span><span><span><span>    <span>}</span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>There&#39;s
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/arena.rs#L24">one</a>
or
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena-derive/src/lib.rs#L275">two</a>
more small pieces that I have not covered here for the
<a href="https://github.com/kyren/gc-arena/blob/c70f83848decdf9a106817e2b432029d09e99481/src/gc-arena/src/arena.rs#L70">real</a>
<code>Rootable!</code> macro, but these details are truly <em>not</em> that important. They
are but small QoL improvements over what I have just shown, which is the
most important part. The <code>Rootable!</code> macro is also essential in understanding
how to actually <em>use</em> <code>gc-arena</code>, because without it, using <code>Arena</code> or
<code>DynamicRootSet</code> is <em>extremely</em> annoying, and most example code will use it
heavily.</p>
<p><em>Finally</em>, here is what the actual declaration of an <code>Arena</code> that holds a
<code>NodePtr&lt;&#39;gc, i32&gt;</code> would actually look like in practice:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>Rootable<span>!</span></span><span><span>[</span><span>NodePtr<span>&lt;</span>&#39;<span>_</span>, <span>i32</span><span>&gt;</span></span><span>]</span></span><span>&gt;</span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        Node <span><span>{</span> prev<span>:</span> <span>None</span><span>,</span> next<span>:</span> <span>None</span><span>,</span> value<span>:</span> <span>0</span> </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="putting-it-all-together">Putting It All Together</h2>
<p>Okay, after ALL of this explanation, we can finally see a fully worked example
of our doubly-linked list, and understand each piece of it and how it fits
together...</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>gc_arena<span>::</span></span><span><span>{</span><span>lock<span>::</span></span>RefLock<span>,</span> Arena<span>,</span> Collect<span>,</span> Gc<span>,</span> Mutation<span>,</span> Rootable</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Copy<span>,</span> Clone<span>,</span> Collect</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span></span><span></span><span></span><span><span><span>#</span><span>[</span><span>collect</span><span><span><span>(</span></span></span><span><span>no_drop</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span><span>Node</span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> <span>&#39;gc</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>prev</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>next</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>value</span><span>:</span> T,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span><span>type</span> <span>NodePtr</span><span>&lt;</span><span>&#39;gc</span><span>,</span> T<span>&gt;</span> <span>=</span> <span>Gc<span>&lt;</span><span>&#39;gc</span>, <span>RefLock<span>&lt;</span><span>Node<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span><span><span><span>fn</span> </span><span>new_node</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>:</span> Collect<span>&gt;</span></span><span><span><span>(</span><span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>, <span>value</span><span>:</span> T</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>Gc<span>::</span></span>new<span><span>(</span>
</span></span></span></span><span><span><span><span>        mc<span>,</span>
</span></span></span></span><span><span><span><span>        <span>RefLock<span>::</span></span>new<span><span>(</span>Node <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            prev<span>:</span> <span>None</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            next<span>:</span> <span>None</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>    </span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span><span><span><span>fn</span> </span><span>node_join</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span>
</span></span></span><span><span><span>    <span>mc</span><span>:</span> <span>&amp;</span><span>Mutation<span>&lt;</span><span>&#39;gc</span><span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>left</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>right</span><span>:</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    left<span>.</span><span>borrow_mut</span><span><span>(</span>mc</span><span><span>)</span></span><span>.</span>next <span>=</span> <span>Some</span><span><span>(</span>right</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    right<span>.</span><span>borrow_mut</span><span><span>(</span>mc</span><span><span>)</span></span><span>.</span>prev <span>=</span> <span>Some</span><span><span>(</span>left</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span><span><span><span>fn</span> </span><span>node_rotate_right</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span><span>node</span><span>:</span> <span>&amp;</span><span>mut</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>if</span> <span>let</span> <span>Some</span><span><span>(</span>next</span><span><span>)</span></span> <span>=</span> node<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>*</span>node <span>=</span> next<span>;</span>
</span></span></span></span><span><span><span><span>        <span>true</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>false</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span></span><span></span><span></span><span></span><span><span><span><span>fn</span> </span><span>node_rotate_left</span></span><span><span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span><span><span><span>(</span><span>node</span><span>:</span> <span>&amp;</span><span>mut</span> <span>NodePtr<span>&lt;</span><span>&#39;gc</span>, T<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>if</span> <span>let</span> <span>Some</span><span><span>(</span>prev</span><span><span>)</span></span> <span>=</span> node<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>prev <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>*</span>node <span>=</span> prev<span>;</span>
</span></span></span></span><span><span><span><span>        <span>true</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>false</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> <span>mut</span> arena <span>=</span> <span>Arena<span>::</span></span><span><span>&lt;</span>Rootable<span>!</span></span><span><span>[</span><span>NodePtr<span>&lt;</span>&#39;<span>_</span>, <span>i32</span><span>&gt;</span></span><span>]</span></span><span>&gt;</span><span><span>::</span></span>new<span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> one <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>1</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> two <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>2</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> three <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>3</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> four <span>=</span> <span>new_node</span><span><span>(</span>mc<span>,</span> <span>4</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> one<span>,</span> two</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> two<span>,</span> three</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> three<span>,</span> four</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        one
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> i <span>in</span> <span>1</span><span>..</span><span>=</span><span>4</span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>node_rotate_right</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> i <span>in</span> <span><span>(</span><span>1</span><span>..</span><span>=</span><span>4</span></span><span><span>)</span></span><span>.</span><span>rev</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>node_rotate_left</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>mc</span><span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> one <span>=</span> <span>*</span>root<span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> two <span>=</span> one<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next<span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>let</span> three <span>=</span> two<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>next<span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>node_join</span><span><span>(</span>mc<span>,</span> three<span>,</span> one</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    arena<span>.</span><span>collect_all</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    arena<span>.</span><span>mutate_root</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>,</span> <span>root</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        </span></span></span></span></span></span><span><span><span><span><span><span>        <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>2</span> <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>for</span> i <span>in</span> <span>1</span><span>..</span><span>=</span><span>3</span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>assert_eq!</span><span><span>(</span>root<span>.</span><span>borrow</span><span><span>(</span></span><span><span>)</span></span><span>.</span>value<span>,</span> i</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>node_rotate_right</span><span><span>(</span>root</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>Thank you for reading this far, I hope you found this tour of the design of
<code>gc-arena</code> interesting. It is a crate whose use requires understanding several
different unusual techniques all at one time, and explaining each piece is
difficult in isolation. Hopefully this post can serve as a good introduction to
someone who wants to use it in the future.</p>
<p>I understand that using <code>gc-arena</code> comes with a pretty high cognitive and
usability overhead. In particular, satisfying the &#34;mutability XOR collection&#34;
design by mutating via callback can be particularly challenging, and I will
cover this much more in future posts about <code>piccolo</code>. However, not many
languages can even be used to implement garbage collection at all, and even
fewer could hope to do so with provable memory safety. In many ways, trying
to design &#34;safe, isolated garbage collection as a library&#34; is wading through
uncharted territory, so I hope you can view <code>gc-arena</code>&#39;s rough edges with this
in mind.</p>
<p>In future posts, I want to talk about the way that I wish <code>gc-arena</code> <em>could</em>
work if there were enough features in Rust to make it possible, using <code>async</code>
and <code>.await</code> to express GC &#34;safe points&#34;, but that discussion is for another
time.</p>
<p>Bye!</p>


  </div></div>
  </body>
</html>
