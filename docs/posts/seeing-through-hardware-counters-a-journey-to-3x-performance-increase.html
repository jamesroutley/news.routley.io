<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822">Original</a>
    <h1>Seeing through hardware counters: A journey to 3x performance increase</h1>
    
    <div id="readability-page-1" class="page"><div><p id="2804"><em>By </em><a href="https://www.linkedin.com/in/vfilanovsky/" rel="noopener ugc nofollow" target="_blank"><em>Vadim Filanovsky</em></a><em> and </em><a href="https://www.linkedin.com/in/harshad-sane-56711a11/" rel="noopener ugc nofollow" target="_blank"><em>Harshad Sane</em></a></p><p id="e9d4">In one of our previous blogposts, <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/a-microscope-on-microservices-923b906103f4">A Microscope on Microservices</a> we outlined three broad domains of observability (or “levels of magnification,” as we referred to them) — Fleet-wide, Microservice and Instance. We described the tools and techniques we use to gain insight within each domain. There is, however, a class of problems that requires an even stronger level of magnification going deeper down the stack to introspect CPU microarchitecture. In this blogpost we describe one such problem and the tools we used to solve it.</p><p id="3d37">It started off as a routine migration. At Netflix, we periodically reevaluate our workloads to optimize utilization of available capacity. We decided to move one of our Java microservices — let’s call it GS2 — to a larger AWS instance size, from m5.4xl (16 vCPUs) to m5.12xl (48 vCPUs). The workload of GS2 is computationally heavy where CPU is the limiting resource. While we understand it’s virtually impossible to achieve a linear increase in throughput as the number of vCPUs grow, a near-linear increase is attainable. Consolidating on the larger instances reduces the amortized cost of background tasks, freeing up additional resources for serving requests and potentially offsetting the sub-linear scaling. Thus, we expected to roughly triple throughput per instance from this migration, as 12xl instances have three times the number of vCPUs compared to 4xl instances. A quick <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/automated-canary-analysis-at-netflix-with-kayenta-3260bc7acc69">canary test</a> was free of errors and showed lower latency, which is expected given that our standard canary setup routes an equal amount of traffic to both the baseline running on 4xl and the canary on 12xl. As GS2 relies on <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html" rel="noopener ugc nofollow" target="_blank">AWS EC2 Auto Scaling</a> to target-track CPU utilization, we thought we just had to redeploy the service on the larger instance type and wait for the <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html" rel="noopener ugc nofollow" target="_blank">ASG (Auto Scaling Group)</a> to settle on the CPU target. Unfortunately, the initial results were far from our expectations:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*YN0AGLHPUq8OxzI_ATijTw.webp 640w, https://miro.medium.com/max/720/1*YN0AGLHPUq8OxzI_ATijTw.webp 720w, https://miro.medium.com/max/750/1*YN0AGLHPUq8OxzI_ATijTw.webp 750w, https://miro.medium.com/max/786/1*YN0AGLHPUq8OxzI_ATijTw.webp 786w, https://miro.medium.com/max/828/1*YN0AGLHPUq8OxzI_ATijTw.webp 828w, https://miro.medium.com/max/1100/1*YN0AGLHPUq8OxzI_ATijTw.webp 1100w, https://miro.medium.com/max/1384/1*YN0AGLHPUq8OxzI_ATijTw.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*YN0AGLHPUq8OxzI_ATijTw.png 640w, https://miro.medium.com/max/720/1*YN0AGLHPUq8OxzI_ATijTw.png 720w, https://miro.medium.com/max/750/1*YN0AGLHPUq8OxzI_ATijTw.png 750w, https://miro.medium.com/max/786/1*YN0AGLHPUq8OxzI_ATijTw.png 786w, https://miro.medium.com/max/828/1*YN0AGLHPUq8OxzI_ATijTw.png 828w, https://miro.medium.com/max/1100/1*YN0AGLHPUq8OxzI_ATijTw.png 1100w, https://miro.medium.com/max/1384/1*YN0AGLHPUq8OxzI_ATijTw.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="736" loading="lazy" role="presentation"/></picture></div></figure><p id="8135">The first graph above represents average per-node throughput overlaid with average CPU utilization, while the second graph shows average request latency. We can see that as we reached roughly the same CPU target of 55%, the throughput increased only by ~25% on average, falling far short of our desired goal. What’s worse, average latency degraded by more than 50%, with both CPU and latency patterns becoming more “choppy.” GS2 is a stateless service that receives traffic through a flavor of round-robin load balancer, so all nodes should receive nearly equal amounts of traffic. Indeed, the RPS (Requests Per Second) data shows very little variation in throughput between nodes:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*Gfj06j1x8m284vbLjibeTg.webp 640w, https://miro.medium.com/max/720/1*Gfj06j1x8m284vbLjibeTg.webp 720w, https://miro.medium.com/max/750/1*Gfj06j1x8m284vbLjibeTg.webp 750w, https://miro.medium.com/max/786/1*Gfj06j1x8m284vbLjibeTg.webp 786w, https://miro.medium.com/max/828/1*Gfj06j1x8m284vbLjibeTg.webp 828w, https://miro.medium.com/max/1100/1*Gfj06j1x8m284vbLjibeTg.webp 1100w, https://miro.medium.com/max/1384/1*Gfj06j1x8m284vbLjibeTg.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*Gfj06j1x8m284vbLjibeTg.png 640w, https://miro.medium.com/max/720/1*Gfj06j1x8m284vbLjibeTg.png 720w, https://miro.medium.com/max/750/1*Gfj06j1x8m284vbLjibeTg.png 750w, https://miro.medium.com/max/786/1*Gfj06j1x8m284vbLjibeTg.png 786w, https://miro.medium.com/max/828/1*Gfj06j1x8m284vbLjibeTg.png 828w, https://miro.medium.com/max/1100/1*Gfj06j1x8m284vbLjibeTg.png 1100w, https://miro.medium.com/max/1384/1*Gfj06j1x8m284vbLjibeTg.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="295" loading="lazy" role="presentation"/></picture></div></figure><p id="b6d7">But as we started looking at the breakdown of CPU and latency by node, a strange pattern emerged:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*t8GZ405S_-mSZa31JJHlZA.webp 640w, https://miro.medium.com/max/720/1*t8GZ405S_-mSZa31JJHlZA.webp 720w, https://miro.medium.com/max/750/1*t8GZ405S_-mSZa31JJHlZA.webp 750w, https://miro.medium.com/max/786/1*t8GZ405S_-mSZa31JJHlZA.webp 786w, https://miro.medium.com/max/828/1*t8GZ405S_-mSZa31JJHlZA.webp 828w, https://miro.medium.com/max/1100/1*t8GZ405S_-mSZa31JJHlZA.webp 1100w, https://miro.medium.com/max/1384/1*t8GZ405S_-mSZa31JJHlZA.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*t8GZ405S_-mSZa31JJHlZA.png 640w, https://miro.medium.com/max/720/1*t8GZ405S_-mSZa31JJHlZA.png 720w, https://miro.medium.com/max/750/1*t8GZ405S_-mSZa31JJHlZA.png 750w, https://miro.medium.com/max/786/1*t8GZ405S_-mSZa31JJHlZA.png 786w, https://miro.medium.com/max/828/1*t8GZ405S_-mSZa31JJHlZA.png 828w, https://miro.medium.com/max/1100/1*t8GZ405S_-mSZa31JJHlZA.png 1100w, https://miro.medium.com/max/1384/1*t8GZ405S_-mSZa31JJHlZA.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="610" loading="lazy" role="presentation"/></picture></div></figure><p id="12be">Although we confirmed fairly equal traffic distribution between nodes, CPU and latency metrics surprisingly demonstrated a very different, bimodal distribution pattern. There is a “lower band” of nodes exhibiting much lower CPU and latency with hardly any variation; and there is an “upper band” of nodes with significantly higher CPU/latency and wide variation. We noticed only ~12% of the nodes fall into the lower band, a figure that was suspiciously consistent over time. In both bands, performance characteristics remain consistent for the entire uptime of the JVM on the node, i.e. nodes never jumped the bands. This was our starting point for troubleshooting.</p><p id="5187">Our first (and rather obvious) step at solving the problem was to compare <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/java-in-flames-e763b3d32166">flame graphs</a> for the “slow” and “fast” nodes. While flame graphs clearly reflected the difference in CPU utilization as the number of collected samples, the distribution across the stacks remained the same, thus leaving us with no additional insight. We turned to JVM-specific profiling, starting with the basic hotspot stats, and then switching to more detailed <a href="https://docs.oracle.com/en/java/java-components/jdk-mission-control/8/user-guide/using-jdk-flight-recorder.html" rel="noopener ugc nofollow" target="_blank">JFR (Java Flight Recorder)</a> captures to compare the distribution of the events. Again, we came away empty-handed as there was no noticeable difference in the amount or the distribution of the events between the “slow” and “fast” nodes. Still suspecting something might be off with JIT behavior, we ran some basic stats against symbol maps obtained by <a href="https://github.com/jvm-profiling-tools/perf-map-agent" rel="noopener ugc nofollow" target="_blank">perf-map-agent</a> only to hit another dead end.</p><p id="c613">Convinced we’re not missing anything on the app-, OS- and JVM- levels, we felt the answer might be hidden at a lower level. Luckily, the m5.12xl instance type exposes a set of core <a href="https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html" rel="noopener ugc nofollow" target="_blank">PMCs</a> (Performance Monitoring Counters, a.k.a. PMU counters), so we started by collecting a baseline set of counters using <a href="https://github.com/intel/PerfSpect" rel="noopener ugc nofollow" target="_blank">PerfSpect</a>:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 640w, https://miro.medium.com/max/720/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 720w, https://miro.medium.com/max/750/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 750w, https://miro.medium.com/max/786/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 786w, https://miro.medium.com/max/828/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 828w, https://miro.medium.com/max/1100/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 1100w, https://miro.medium.com/max/1384/1*2y_jlUWQdw8M0GP6VH8LAQ.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*2y_jlUWQdw8M0GP6VH8LAQ.png 640w, https://miro.medium.com/max/720/1*2y_jlUWQdw8M0GP6VH8LAQ.png 720w, https://miro.medium.com/max/750/1*2y_jlUWQdw8M0GP6VH8LAQ.png 750w, https://miro.medium.com/max/786/1*2y_jlUWQdw8M0GP6VH8LAQ.png 786w, https://miro.medium.com/max/828/1*2y_jlUWQdw8M0GP6VH8LAQ.png 828w, https://miro.medium.com/max/1100/1*2y_jlUWQdw8M0GP6VH8LAQ.png 1100w, https://miro.medium.com/max/1384/1*2y_jlUWQdw8M0GP6VH8LAQ.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="390" loading="lazy" role="presentation"/></picture></div></figure><p id="fe68">In the table above, the nodes showing low CPU and low latency represent a “fast node”, while the nodes with higher CPU/latency represent a “slow node”. Aside from obvious CPU differences, we can see that the slow node has almost 3x CPI (Cycles Per Instruction) of the fast node. We also see much higher L1 cache activity combined with 4x higher count of <a href="http://portal.nacad.ufrj.br/online/intel/vtune2017/help/GUID-F0FD7660-58B5-4B5D-AA9A-E1AF21DDCA0E.html" rel="noopener ugc nofollow" target="_blank">MACHINE_CLEARS</a>. One common cause of these symptoms is so-called “false sharing” — a usage pattern occurring when 2 cores reading from / writing to unrelated variables that happen to share the same L1 cache line. Cache line is a concept similar to memory page — a contiguous chunk of data (typically 64 bytes on x86 systems) transferred to and from the cache. This diagram illustrates it:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*-q8ZA_At1AAtXMp2WURdtg.webp 640w, https://miro.medium.com/max/720/1*-q8ZA_At1AAtXMp2WURdtg.webp 720w, https://miro.medium.com/max/750/1*-q8ZA_At1AAtXMp2WURdtg.webp 750w, https://miro.medium.com/max/786/1*-q8ZA_At1AAtXMp2WURdtg.webp 786w, https://miro.medium.com/max/828/1*-q8ZA_At1AAtXMp2WURdtg.webp 828w, https://miro.medium.com/max/1100/1*-q8ZA_At1AAtXMp2WURdtg.webp 1100w, https://miro.medium.com/max/1384/1*-q8ZA_At1AAtXMp2WURdtg.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*-q8ZA_At1AAtXMp2WURdtg.png 640w, https://miro.medium.com/max/720/1*-q8ZA_At1AAtXMp2WURdtg.png 720w, https://miro.medium.com/max/750/1*-q8ZA_At1AAtXMp2WURdtg.png 750w, https://miro.medium.com/max/786/1*-q8ZA_At1AAtXMp2WURdtg.png 786w, https://miro.medium.com/max/828/1*-q8ZA_At1AAtXMp2WURdtg.png 828w, https://miro.medium.com/max/1100/1*-q8ZA_At1AAtXMp2WURdtg.png 1100w, https://miro.medium.com/max/1384/1*-q8ZA_At1AAtXMp2WURdtg.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="469" loading="lazy" role="presentation"/></picture></div></figure><p id="5792">Each core in this diagram has its own private cache. Since both cores are accessing the same memory space, caches have to be consistent. This consistency is ensured with so-called “<a href="https://www.cs.auckland.ac.nz/~goodman/TechnicalReports/MESIF-2009.pdf" rel="noopener ugc nofollow" target="_blank">cache coherency protocol</a>.” As Thread 0 writes to the “red” variable, coherency protocol marks the whole cache line as “modified” in Thread 0’s cache and as “invalidated” in Thread 1’s cache. Later, when Thread 1 reads the “blue” variable, even though the “blue” variable is not modified, coherency protocol forces the entire cache line to be reloaded from the cache that had the last modification — Thread 0’s cache in this example. Resolving coherency across private caches takes time and causes CPU stalls. Additionally, ping-ponging coherency traffic has to be monitored through the <a href="https://cvw.cac.cornell.edu/ClusterArch/LastLevelCache" rel="noopener ugc nofollow" target="_blank">last level shared cache</a>’s controller, which leads to even more stalls. We take CPU cache consistency for granted, but this “false sharing” pattern illustrates there’s a huge performance penalty for simply reading a variable that is neighboring with some other unrelated data.</p><p id="d93c">Armed with this knowledge, we used <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html" rel="noopener ugc nofollow" target="_blank">Intel vTune</a> to run microarchitecture profiling. Drilling down into “hot” methods and further into the assembly code showed us blocks of code with some instructions exceeding 100 CPI, which is extremely slow. This is the summary of our findings:</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/max/640/1*pTN-nH9l4KXoW9XiStEavA.webp 640w, https://miro.medium.com/max/720/1*pTN-nH9l4KXoW9XiStEavA.webp 720w, https://miro.medium.com/max/750/1*pTN-nH9l4KXoW9XiStEavA.webp 750w, https://miro.medium.com/max/786/1*pTN-nH9l4KXoW9XiStEavA.webp 786w, https://miro.medium.com/max/828/1*pTN-nH9l4KXoW9XiStEavA.webp 828w, https://miro.medium.com/max/1100/1*pTN-nH9l4KXoW9XiStEavA.webp 1100w, https://miro.medium.com/max/1400/1*pTN-nH9l4KXoW9XiStEavA.webp 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*pTN-nH9l4KXoW9XiStEavA.png 640w, https://miro.medium.com/max/720/1*pTN-nH9l4KXoW9XiStEavA.png 720w, https://miro.medium.com/max/750/1*pTN-nH9l4KXoW9XiStEavA.png 750w, https://miro.medium.com/max/786/1*pTN-nH9l4KXoW9XiStEavA.png 786w, https://miro.medium.com/max/828/1*pTN-nH9l4KXoW9XiStEavA.png 828w, https://miro.medium.com/max/1100/1*pTN-nH9l4KXoW9XiStEavA.png 1100w, https://miro.medium.com/max/1400/1*pTN-nH9l4KXoW9XiStEavA.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="" width="700" height="270" loading="lazy" role="presentation"/></picture></div></div></figure><p id="e89b">Numbered markers from 1 to 6 denote the same code/variables across the sources and vTune assembly view. The red arrow indicates that the CPI value likely belongs to the previous instruction — this is due to the profiling skid in absence of PEBS (Processor Event-Based Sampling), and usually it’s off by a single instruction. Based on the fact that (5) <em>“repne scan”</em> is a rather rare operation in the JVM codebase, we were able to link this snippet to <a href="https://github.com/openjdk/jdk8u/blob/jdk8u352-b07/hotspot/src/cpu/x86/vm/macroAssembler_x86.cpp#L5142-L5174" rel="noopener ugc nofollow" target="_blank">the routine for subclass checking</a> (the same code exists in JDK mainline as of the writing of this blogpost). Going into the details of subtype checking in HotSpot is far beyond the scope of this blogpost, but curious readers can learn more about it from the 2002 publication <a href="https://www.researchgate.net/publication/221552851_Fast_subtype_checking_in_the_HotSpot_JVM" rel="noopener ugc nofollow" target="_blank">Fast Subtype Checking in the HotSpot JVM</a>. Due to the nature of the class hierarchy used in this particular workload, we keep hitting the code path that keeps updating (6) the <em>“_secondary_super_cache”</em> field, which is a single-element cache for the last-found secondary superclass. Note how this field is adjacent to the <em>“_secondary_supers”</em>, which is a list of all superclasses and is being read (1) in the beginning of the scan. Multiple threads do these read-write operations, and if fields (1) and (6) fall into the same cache line, then we hit a false sharing use case. We highlighted these fields with red and blue colors to connect to the false sharing diagram above.</p><p id="de07">Note that since the cache line size is 64 bytes and the pointer size is 8 bytes, we have a 1 in 8 chance of these fields falling on separate cache lines, and a 7 in 8 chance of them sharing a cache line. This 1-in-8 chance is 12.5%, matching our previous observation on the proportion of the “fast” nodes. Fascinating!</p><p id="ab68">Although the fix involved patching the JDK, it was a simple change. We inserted padding between <em>“_secondary_super_cache”</em> and <em>“_secondary_supers”</em> fields to ensure they never fall into the same cache line. Note that we did not change the functional aspect of JDK behavior, but rather the data layout:</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/max/640/1*390eHadYNHFdhHD3sbWr2A.webp 640w, https://miro.medium.com/max/720/1*390eHadYNHFdhHD3sbWr2A.webp 720w, https://miro.medium.com/max/750/1*390eHadYNHFdhHD3sbWr2A.webp 750w, https://miro.medium.com/max/786/1*390eHadYNHFdhHD3sbWr2A.webp 786w, https://miro.medium.com/max/828/1*390eHadYNHFdhHD3sbWr2A.webp 828w, https://miro.medium.com/max/1100/1*390eHadYNHFdhHD3sbWr2A.webp 1100w, https://miro.medium.com/max/1400/1*390eHadYNHFdhHD3sbWr2A.webp 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*390eHadYNHFdhHD3sbWr2A.png 640w, https://miro.medium.com/max/720/1*390eHadYNHFdhHD3sbWr2A.png 720w, https://miro.medium.com/max/750/1*390eHadYNHFdhHD3sbWr2A.png 750w, https://miro.medium.com/max/786/1*390eHadYNHFdhHD3sbWr2A.png 786w, https://miro.medium.com/max/828/1*390eHadYNHFdhHD3sbWr2A.png 828w, https://miro.medium.com/max/1100/1*390eHadYNHFdhHD3sbWr2A.png 1100w, https://miro.medium.com/max/1400/1*390eHadYNHFdhHD3sbWr2A.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="" width="700" height="227" loading="lazy" role="presentation"/></picture></div></div></figure><p id="e334">The results of deploying the patch were immediately noticeable. The graph below is a breakdown of CPU by node. Here we can see a <a href="https://spinnaker.io/docs/guides/user/kubernetes-v2/rollout-strategies/#redblack-rollouts" rel="noopener ugc nofollow" target="_blank">red-black deployment</a> happening at noon, and the new ASG with the patched JDK taking over by 12:15:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*8WfR5AF9_cjHIkiR0QFHwg.webp 640w, https://miro.medium.com/max/720/1*8WfR5AF9_cjHIkiR0QFHwg.webp 720w, https://miro.medium.com/max/750/1*8WfR5AF9_cjHIkiR0QFHwg.webp 750w, https://miro.medium.com/max/786/1*8WfR5AF9_cjHIkiR0QFHwg.webp 786w, https://miro.medium.com/max/828/1*8WfR5AF9_cjHIkiR0QFHwg.webp 828w, https://miro.medium.com/max/1100/1*8WfR5AF9_cjHIkiR0QFHwg.webp 1100w, https://miro.medium.com/max/1384/1*8WfR5AF9_cjHIkiR0QFHwg.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*8WfR5AF9_cjHIkiR0QFHwg.png 640w, https://miro.medium.com/max/720/1*8WfR5AF9_cjHIkiR0QFHwg.png 720w, https://miro.medium.com/max/750/1*8WfR5AF9_cjHIkiR0QFHwg.png 750w, https://miro.medium.com/max/786/1*8WfR5AF9_cjHIkiR0QFHwg.png 786w, https://miro.medium.com/max/828/1*8WfR5AF9_cjHIkiR0QFHwg.png 828w, https://miro.medium.com/max/1100/1*8WfR5AF9_cjHIkiR0QFHwg.png 1100w, https://miro.medium.com/max/1384/1*8WfR5AF9_cjHIkiR0QFHwg.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="295" loading="lazy" role="presentation"/></picture></div></figure><p id="71ad">Both CPU and latency (graph omitted for brevity) showed a similar picture — the “slow” band of nodes was gone!</p><p id="f795">We didn’t have much time to marvel at these results, however. As the autoscaling reached our CPU target, we noticed that we still couldn’t push more than ~150 RPS per node — well short of our goal of ~250 RPS. Another round of vTune profiling on the patched JDK version showed the same bottleneck around secondary superclass cache lookup. It was puzzling at first to see seemingly the same problem coming back right after we put in a fix, but upon closer inspection we realized we’re dealing with “true sharing” now. Unlike “false sharing,” where 2 independent variables share a cache line, “true sharing” refers to the same variable being read and written by multiple threads/cores. In this case, <a href="http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf" rel="noopener ugc nofollow" target="_blank">CPU-enforced memory ordering</a> is the cause of slowdown. We reasoned that removing the obstacle of false sharing and increasing the overall throughput resulted in increased execution of the same JVM superclass caching code path. Essentially, we have higher execution concurrency, causing excessive pressure on the superclass cache due to CPU-enforced memory ordering protocols. The common way to resolve this is to avoid writing to the shared variable altogether, effectively bypassing the JVM’s secondary superclass cache. Since this change altered the behavior of the JDK, we gated it behind a command line flag. This is the entirety of our patch:</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/max/640/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 640w, https://miro.medium.com/max/720/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 720w, https://miro.medium.com/max/750/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 750w, https://miro.medium.com/max/786/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 786w, https://miro.medium.com/max/828/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 828w, https://miro.medium.com/max/1100/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 1100w, https://miro.medium.com/max/1400/1*A8MKwVMA0AcOPHjxOPZgLQ.webp 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*A8MKwVMA0AcOPHjxOPZgLQ.png 640w, https://miro.medium.com/max/720/1*A8MKwVMA0AcOPHjxOPZgLQ.png 720w, https://miro.medium.com/max/750/1*A8MKwVMA0AcOPHjxOPZgLQ.png 750w, https://miro.medium.com/max/786/1*A8MKwVMA0AcOPHjxOPZgLQ.png 786w, https://miro.medium.com/max/828/1*A8MKwVMA0AcOPHjxOPZgLQ.png 828w, https://miro.medium.com/max/1100/1*A8MKwVMA0AcOPHjxOPZgLQ.png 1100w, https://miro.medium.com/max/1400/1*A8MKwVMA0AcOPHjxOPZgLQ.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="" width="700" height="702" loading="lazy" role="presentation"/></picture></div></div></figure><p id="3b0f">And here are the results of running with disabled superclass cache writes:</p><figure><div><picture><source srcset="https://miro.medium.com/max/640/1*ZDIqyco2WvSib87nzGr_SA.webp 640w, https://miro.medium.com/max/720/1*ZDIqyco2WvSib87nzGr_SA.webp 720w, https://miro.medium.com/max/750/1*ZDIqyco2WvSib87nzGr_SA.webp 750w, https://miro.medium.com/max/786/1*ZDIqyco2WvSib87nzGr_SA.webp 786w, https://miro.medium.com/max/828/1*ZDIqyco2WvSib87nzGr_SA.webp 828w, https://miro.medium.com/max/1100/1*ZDIqyco2WvSib87nzGr_SA.webp 1100w, https://miro.medium.com/max/1384/1*ZDIqyco2WvSib87nzGr_SA.webp 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/max/640/1*ZDIqyco2WvSib87nzGr_SA.png 640w, https://miro.medium.com/max/720/1*ZDIqyco2WvSib87nzGr_SA.png 720w, https://miro.medium.com/max/750/1*ZDIqyco2WvSib87nzGr_SA.png 750w, https://miro.medium.com/max/786/1*ZDIqyco2WvSib87nzGr_SA.png 786w, https://miro.medium.com/max/828/1*ZDIqyco2WvSib87nzGr_SA.png 828w, https://miro.medium.com/max/1100/1*ZDIqyco2WvSib87nzGr_SA.png 1100w, https://miro.medium.com/max/1384/1*ZDIqyco2WvSib87nzGr_SA.png 1384w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 692px"/><img alt="" width="692" height="736" loading="lazy" role="presentation"/></picture></div></figure><p id="9377">Our fix pushed the throughput to ~350 RPS at the same CPU autoscaling target of 55%. To put this in perspective, <strong>that’s a 3.5x improvement</strong> over the throughput we initially reached on m5.12xl, along with a reduction in both average and tail latency.</p><p id="35a5">Disabling writes to the secondary superclass cache worked well in our case, and even though this might not be a desirable solution in all cases, we wanted to share our methodology, toolset and the fix in the hope that it would help others encountering similar symptoms. While working through this problem, we came across <a href="https://bugs.openjdk.org/browse/JDK-8180450" rel="noopener ugc nofollow" target="_blank">JDK-8180450</a> — a bug that’s been dormant for more than five years that describes exactly the problem we were facing. It seems ironic that we could not find this bug until we actually figured out the answer. We believe our findings complement the great work that has been done in diagnosing and remediating it.</p><p id="31e5">We tend to think of modern JVMs as highly optimized runtime environments, in many cases rivaling more “performance-oriented” languages like C++. While it holds true for the majority of workloads, we were reminded that performance of certain workloads running within JVMs can be affected not only by the design and implementation of the application code, but also by the implementation of the JVM itself. In this blogpost we described how we were able to leverage PMCs in order to find a bottleneck in the JVM’s native code, patch it, and subsequently realize better than a threefold increase in throughput for the workload in question. When it comes to this class of performance issues, the ability to introspect the execution at the level of CPU microarchitecture proved to be the only solution. Intel vTune provides valuable insight even with the core set of PMCs, such as those exposed by m5.12xl instance type. Exposing a more comprehensive set of PMCs along with PEBS across all instance types and sizes in the cloud environment would pave the way for deeper performance analysis and potentially even larger performance gains.</p></div></div>
  </body>
</html>
