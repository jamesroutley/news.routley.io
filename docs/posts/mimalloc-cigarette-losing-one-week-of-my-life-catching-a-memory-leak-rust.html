<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pwy.io/posts/mimalloc-cigarette/">Original</a>
    <h1>Mimalloc Cigarette: Losing one week of my life catching a memory leak (Rust)</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
        

        <p>
          One of applications at my work has always been RAM-bound - it&#39;s a
          pricing engine that basically loads tons of hotels, builds some
          in-memory indices and then allows you to issue queries like
          <i>find me the cheapest hotel in berlin, pronto</i>.
        </p>

        <p>
          A pricing engine&#39;s main purpose is to price <s>engines</s> hotels, but
          in order to do that effectively, there&#39;s a lot of &#34;meta work&#34;
          involved, like:
        </p>

        <ul>
          <li>Where do we load the data from, how do we do it?</li>
          <li>Do we load the entire dataset or just some parts of it?</li>
          <li>
            Should we precalculate prices in order to speed-up the most popular
            queries?
          </li>
        </ul>

        <p>
          Such an engine poses an interesting technical challenge, even greater
          so when one day it starts OOMing on production, even though the entire
          dataset should fit in the memory multiple times...
        </p>

        <h2 id="hello-world"><a href="#hello-world"> Hello, World! </a></h2>

        <p>Simplifying <s>a bit</s> a lot, what we&#39;re dealing with is:</p>

        

        <div>
          <pre><span></span><span>struct</span> <span>State</span><span> </span><span>{</span>
<span>    </span><span>hotels</span>: <span>Vec</span><span>&lt;</span><span>Hotel</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>struct</span> <span>Hotel</span><span> </span><span>{</span>
<span>    </span><span>prices</span>: <span>Vec</span><span>&lt;</span><span>f32</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>// ---</span>

<span>impl</span><span> </span><span>State</span><span> </span><span>{</span>
<span>    </span><span>fn</span> <span>new</span><span>()</span><span> </span>-&gt; <span>Self</span><span> </span><span>{</span>
<span>        </span><span>Self</span><span> </span><span>{</span>
<span>            </span><span>hotels</span>: <span>load_hotels</span><span>().</span><span>collect</span><span>(),</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span> <span>refresh</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>hotel</span><span>)</span><span> </span><span>in</span><span> </span><span>load_hotels</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>self</span><span>.</span><span>hotels</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>hotel</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>

<span>fn</span> <span>load_hotels</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Hotel</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>(</span><span>0</span><span>..</span><span>1_000</span><span>).</span><span>map</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>Hotel</span><span> </span><span>{</span>
<span>        </span><span>prices</span>: <span>(</span><span>0</span><span>..</span><span>1_000_000</span><span>).</span><span>map</span><span>(</span><span>|</span><span>n</span><span>|</span><span> </span><span>n</span><span> </span><span>as</span><span> </span><span>f32</span><span>).</span><span>collect</span><span>(),</span>
<span>    </span><span>})</span>
<span>}</span>

<span>// ---</span>

<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>state</span><span> </span><span>=</span><span> </span><span>Arc</span>::<span>new</span><span>(</span><span>RwLock</span>::<span>new</span><span>(</span><span>State</span>::<span>new</span><span>()));</span>

<span>    </span><span>// Spawn a separate thread responsible for checking which hotels have</span>
<span>    </span><span>// changed and need to be refreshed etc.</span>
<span>    </span><span>thread</span>::<span>spawn</span><span>({</span>
<span>        </span><span>let</span><span> </span><span>state</span><span> </span><span>=</span><span> </span><span>Arc</span>::<span>clone</span><span>(</span><span>&amp;</span><span>state</span><span>);</span>

<span>        </span><span>move</span><span> </span><span>||</span><span> </span><span>loop</span><span> </span><span>{</span>
<span>            </span><span>thread</span>::<span>sleep</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>5</span><span>));</span>
<span>            </span><span>state</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>().</span><span>refresh</span><span>();</span>
<span>        </span><span>}</span>
<span>    </span><span>});</span>

<span>    </span><span>// Now in reality we start a Rocket server here, but for practical</span>
<span>    </span><span>// purposes stalling the main thread will be sufficient.</span>
<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>thread</span>::<span>sleep</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>1</span><span>));</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          Of course IRL there&#39;s <kbd>ArcSwap</kbd> instead of <kbd>RwLock</kbd>,
          every hotel contains much more information (like taxes, discounts or
          supplements) etc., but we&#39;ve got a reasonably good approximation here.
        </p>

        <p>
          Now, what if I told you that this code has <i>totally</i> different
          memory characteristics depending on which allocator you use?
        </p>

        <h2 id="practical-reasons">
          <a href="#practical-reasons"> Practical Reasons </a>
        </h2>

        <p>
          Memory allocator is the piece of software invoked whenever your
          program needs to get hands on extra memory, like when you&#39;re calling
          <kbd>Box::new()</kbd>. And memory allocation is quite a complex topic,
          with different solutions offering different trade-offs.
        </p>

        <p>
          Say, when implementing a firmware you might pick an allocator that
          works slower, because its implementation is just simpler and doesn&#39;t
          occupy much space in the final binary.
        </p>

        <p>
          (some would argue that embeddeed programs shouldn&#39;t allocate, yadda
          yadda, but you get the idea -- replace <i>firmware</i> with
          <i>wasm</i> and you end up with the same problem.)
        </p>

        <p>
          <a href="https://github.com/microsoft/mimalloc">mimalloc</a> is an
          allocator that fights tooth and nail for performance - and while most
          applications don&#39;t have to worry about allocation performance, in our
          case internal benchmarks have proven it gives us extra 10% for free;
          when your response times have to be within milliseconds, this matters.
        </p>

        <p>But there&#39;s a catch.</p>

        <h2 id="desenchantee"><a href="#desenchantee"> Désenchantée </a></h2>

        <p>
          That program from before, on my x86_64 Linux machine it allocates
          around 4 GB of memory and it remains on this level through the
          refreshing.
        </p>

        <p>
          This makes sense, right? We&#39;re using lazy iterators, replacing stuff
          in place one-by-one, there&#39;s no reason we&#39;d need more RAM.
        </p>

        <p>But if you use mimalloc:</p>

        <div>
          <pre><span></span><span>use</span><span> </span><span>mimalloc</span>::<span>MiMalloc</span><span>;</span>

<span>#[global_allocator]</span>
<span>static</span><span> </span><span>GLOBAL</span>: <span>MiMalloc</span><span> </span><span>=</span><span> </span><span>MiMalloc</span><span>;</span>
</pre>
        </div>

        <p>
          ... the program will first allocate 4 GB and then allocate
          <i>extra</i> 4 GB during the refreshing, oh noes!
        </p>

        <p>
          Getting to this point already took three days of my life - believe me
          or not, when faced with 200k lines of Arc-ridden Rust code that
          <i>seems</i> to generate a memory leak, one&#39;s first thought is not
          &#34;let&#39;s try with different allocator&#34;, but rather &#34;probably something&#39;s
          holding onto an Arc for too long&#34;.
        </p>

        <p>
          And so I&#39;ve valgrind-ed. I&#39;ve perf-ed. I&#39;ve analyzed assembly. I&#39;ve
          headbanged and I&#39;ve cried.
        </p>

        <p>No more.</p>

        <p>
          From now on I&#39;m always assuming it&#39;s someone else&#39;s fault - it&#39;s the
          allocator, it&#39;s the compiler, it&#39;s that crate Mike pulled last night.
          WHY DO YOU HATE ME MIKE, WHY ARE YOU PULLING RANDOM CRATES TO MY PURE
          <span>~~~tv noise~~~</span>
        </p>

        <h2 id="remede"><a href="#remede"> Remède </a></h2>

        <p>
          Allocators have different characteristics for a reason - they do some
          things differently between each other. What do you think mimalloc does
          that could account for this behavior?
        </p>

        <p>
          Let me give you two hints, two pieces of code that solve the problem,
          but feel cursed:
        </p>

        <div>
          <pre><span></span><span>// Approach 1:</span>
<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>state</span><span> </span><span>=</span><span> </span><span>thread</span>::<span>spawn</span><span>(</span><span>||</span><span> </span><span>{</span>
<span>        </span><span>Arc</span>::<span>new</span><span>(</span><span>RwLock</span>::<span>new</span><span>(</span><span>State</span>::<span>new</span><span>()))</span>
<span>    </span><span>}).</span><span>join</span><span>().</span><span>unwrap</span><span>();</span>

<span>    </span><span>/* ... */</span>
<span>}</span>

<span>// Approach 2:</span>
<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>Box</span>::<span>new</span><span>(</span><span>1234</span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>Any ideas? Last chance to win a plushie polar bear!</p>

        <p>
          Alright then, the issue is that mimalloc assumes that
          <b>every thread allocates every now and then</b>.
        </p>

        <p>
          Every now and then during <kbd>malloc()</kbd> mimalloc performs some
          internal bookkeeping, so when a thread goes to sleep (say, because it
          delegates handling HTTP requests into a separate thread pool...), this
          bookkeeping doesn&#39;t happen (for that particular thread).
        </p>

        <p>
          The most nasty edge case that can happen here, and the one that we&#39;ve
          stumbled upon, is when your thread allocates a lot of data, then
          launches other threads to work on that data, and then goes to sleep.
          As other threads work on memory and override stuff, Rust destructors
          <i>are</i> launched properly, but the underlying memory blocks simply
          get marked as &#34;to be released&#34;.
        </p>

        <p>
          Under normal conditions, these blocks get processed a moment later,
          during a call to <kbd>malloc()</kbd> on the thread that created them -
          but if that thread is asleep, those blocks never become available
          again (unless the thread dies, of course).
        </p>

        <p>
          To be sure, the problem is not that the memory is not returned to the
          kernel - that&#39;s alright. It&#39;s that unless this bookkeeping happens,
          mimalloc can&#39;t even use the memory <i>for itself</i> - all this free
          estate just lays there, dormant:
        </p>

        <ul>
          <li>
            <a href="https://github.com/microsoft/mimalloc/issues/537">https://github.com/microsoft/mimalloc/issues/537</a>
          </li>
          <li>
            <a href="https://github.com/microsoft/mimalloc/issues/214">https://github.com/microsoft/mimalloc/issues/214</a>
          </li>
        </ul>

        <p>
          Anyway, the solution we went with was to keep all refreshing on the
          same thread - when program starts, we spawn a dedicated
          refreshing-thread and use channels to let it know to do its thing.
        </p>

        <p>
          So yeah, that was fun; and health-wise probably more like seven
          cigarettes.
        </p>
      </div></div>
  </body>
</html>
