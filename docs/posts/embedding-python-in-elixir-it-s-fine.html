<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dashbit.co/blog/running-python-in-elixir-its-fine">Original</a>
    <h1>Embedding Python in Elixir, It&#39;s Fine</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
<ul>
  <li>
    <i></i> Jonatan Kłosko
  </li>
  <li>
    <i></i> February 21st, 2025
  </li>
  <li>
    <i></i><a href="https://dashbit.co/blog/tags/python">python</a>, <a href="https://dashbit.co/blog/tags/livebook">livebook</a>, <a href="https://dashbit.co/blog/tags/nifs">nifs</a>
  </li>
</ul>
<p>
In the recent years, Elixir has been expanding its capabilities in Machine Learning and Data through the <a href="https://github.com/elixir-nx">Nx (Numerical Elixir)</a> effort. A number of projects emerged (Nx, Explorer, Axon, Bumblebee, Scholar, and more), drawing learnings from decades of work in ecosystems such as Python and R, often standing on the shoulders of C++ and Rust codebases.</p>
<p>
When we started, we made the explicit choice to not depend on Python libraries directly. We wanted to design and develop our ecosystem with full control of making the best decisions for Elixir, which would not necessarily match the decisions made for Python. We also wished to avoid bringing to our ecosystem the complexities in getting a Python environment up and running. While young, the Nx ecosystem already enabled <a href="https://youtu.be/VcOvNTxUaIo">running pre-trained ML models</a>, <a href="https://youtu.be/5FlZHkc4Mq4">simplifying production systems with a unified AI stack</a>, <a href="https://youtu.be/4qoHPh0obv0">managing GPU cluster workflows from a notebook</a>, to point a few.</p>
<p>
A key component driving the adoption of Elixir in these areas is <a href="https://livebook.dev">Livebook</a>, a computational notebook platform that builds on the strengths of the Elixir and Erlang, bringing reproducibility, distributed execution, and app development to the forefront. With Livebook, we have seen a growing interest from teams and companies in dipping their toes into the Elixir ecosystem for the first time.</p>
<p>
All of this builds a good case to go all in with Elixir, but some hurdles remain. As one would expect, most companies interested in bringing Elixir and Livebook into their infrastructure, have existing workflows, packages, and repositories that they already rely on. The choices we have made so far imply that they either have to find an equivalent package in Elixir or write one from scratch, increasing the risk and costs of adding Elixir to their data stack.</p>
<p>
To address these concerns, today we announce Pythonx, which embeds the Python interpreter within the Erlang VM, bringing automatic data conversion between Elixir and Python, code evaluation, and automatic virtual environment management. We compare Pythonx with other options for interoperability and outline future work.</p>
<h2>
Enter Pythonx</h2>
<p>
Imagine we have an image and want to read the text on that image. We need to do what is known as Optical Character Recognition (OCR). Sure enough, there are a few Python packages doing just that, one of them being <code>pytesseract</code>. For the sake of this example, we will download the image using Req:</p>
<pre><code><span>Mix</span><span>.</span><span>install</span><span data-group-id="8115916589-1">(</span><span data-group-id="8115916589-2">[</span><span>
  </span><span data-group-id="8115916589-3">{</span><span>:pythonx</span><span>,</span><span> </span><span>&#34;~&gt; 0.4.0&#34;</span><span data-group-id="8115916589-3">}</span><span>,</span><span>
  </span><span data-group-id="8115916589-4">{</span><span>:req</span><span>,</span><span> </span><span>&#34;~&gt; 0.5.8&#34;</span><span data-group-id="8115916589-4">}</span><span>
</span><span data-group-id="8115916589-2">]</span><span data-group-id="8115916589-1">)</span><span>

</span><span>url</span><span> </span><span>=</span><span> </span><span>&#34;https://unsplash.com/photos/95t94hZTESw/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzQwMDYwMjg4fA&amp;force=true&amp;w=640&#34;</span><span>
</span><span>binary</span><span> </span><span>=</span><span> </span><span>Req</span><span>.</span><span>get!</span><span data-group-id="8115916589-5">(</span><span>url</span><span data-group-id="8115916589-5">)</span><span>.</span><span>body</span></code></pre>
<p>
Now, let’s bring in Python.</p>
<pre><code><span>Pythonx</span><span>.</span><span>uv_init</span><span data-group-id="6229236571-1">(</span><span>&#34;&#34;&#34;
[project]
name = &#34;project&#34;
version = &#34;0.0.0&#34;
requires-python = &#34;==3.13.*&#34;
dependencies = [
  &#34;pytesseract==0.3.13&#34;,
  &#34;pillow==11.1.0&#34;
]
&#34;&#34;&#34;</span><span data-group-id="6229236571-1">)</span></code></pre>
<p>
Calling <code>Pythonx.uv_init/1</code> downloads Python and the listed dependencies using the excellent <a href="https://docs.astral.sh/uv">uv</a> package manager. It also immediately initializes the Python interpreter for evaluation. Note the dependencies section where we list <code>pytesseract</code> for OCR and <code>pillow</code> for image handling.</p>
<p>
Next, let’s write some Python.</p>
<pre><code><span data-group-id="8721759126-1">{</span><span>result</span><span>,</span><span> </span><span>_globals</span><span data-group-id="8721759126-1">}</span><span> </span><span>=</span><span>
  </span><span>Pythonx</span><span>.</span><span>eval</span><span data-group-id="8721759126-2">(</span><span>
    </span><span>&#34;&#34;&#34;
    import pytesseract
    import io
    import PIL

    image = PIL.Image.open(io.BytesIO(binary))
    pytesseract.image_to_string(image)
    &#34;&#34;&#34;</span><span>,</span><span>
    </span><span data-group-id="8721759126-3">%{</span><span>&#34;binary&#34;</span><span> </span><span>=&gt;</span><span> </span><span>binary</span><span data-group-id="8721759126-3">}</span><span>
  </span><span data-group-id="8721759126-2">)</span><span>

</span><span>Pythonx</span><span>.</span><span>decode</span><span data-group-id="8721759126-4">(</span><span>result</span><span data-group-id="8721759126-4">)</span><span>
</span><span>#=&gt; &#34;The Journey\nof a thousand\nmiles begins\nwith a single\n\nstep.\n\n-Lao Tzu\n\n&#34;</span></code></pre>
<p>
Above we call <code>Pythonx.eval/2</code>, which accepts Python code and a map with variables for the evaluation. Note how we pass the Elixir binary and it is automatically converted to a <code>bytes</code> object on the Python side. The evaluation returns <code>result</code>, which is a <code>%Pythonx.Object{}</code>, and also an updated map with variables. In this case we only care about the result and we use <code>Pythonx.decode/1</code> to convert it to an Elixir string right away.</p>
<p>
There we go! To learn more about Pythonx, see <a href="https://hexdocs.pm/pythonx">the documentation</a>. And if you are struggling to write Python for your task, consult with your AI specialist, it went to school for that.</p>
<h2>
Under the hood</h2>
<p>
If you are raising your eyebrow, thinking that this just calls <code>python</code>, bear with me!</p>
<p>
So Python, or more specifically its <a href="https://github.com/python/cpython">CPython</a> reference implementation, has the interesting capability of being embedded into other applications. What this means is that the core functionality of the Python interpreter is available as a C library, so a C/C++ application can link that library and use its APIs to run code and interact with objects. In fact, you can think of the <code>python</code> executable as one such application.</p>
<p>
Elixir provides C/C++ interoperability via Erlang NIFs and that’s exactly what Pythonx uses to embed Python, which means that the Python interpreter operates in the same OS process as Elixir itself. By living in the same memory space, passing data between Elixir and Python is cheap. Pythonx ties Python and Erlang garbage collection, so that the objects can be safely kept between evaluations. Also, it conveniently handles conversion between Elixir and Python data structures, bubbles Python exceptions and captures standard output.</p>
<h2>
Livebook goes multilingual</h2>
<p>
To enable even more powerful workflows, we <a href="https://github.com/livebook-dev/livebook/pull/2936">started working</a> on Python support in Livebook, building on Pythonx. The idea, though, is not to support Python separately, but rather to allow Elixir and Python interacting in the same notebook! To give you a better picture, below you can see the same example using Python cells in Livebook nightly.</p>
<p><img src="https://dashbit.co/images/posts/2025/pythonx_ocr.png" width="100%"/></p>
<p>
Livebook automatically installs Python and its dependencies, as it manages Elixir’, ensuring a reproducible environment. It also tracks which Elixir variables are used by Python, and vice-versa, and automatically converts them between cells. While there is still work ahead of us, including code completion, documentation, and a few surprises, we are open to feedback. <a href="https://github.com/livebook-dev/livebook#desktop-app">You can download Livebook nightly</a> to give it a try. Once we add all bells and whistles, we will do an official announcement over <a href="https://news.livebook.dev">news.livebook.dev</a>.</p>
<p>
At this point I want to thank <a href="https://github.com/cocoa-xu">Cocoa Xu</a> for starting off the work on Embedded Python, and <a href="https://github.com/cigrainger">Christopher Grainger</a> for the initial push to run Python in Livebook.</p>
<h2>
Usage considerations and alternatives</h2>
<p>
The primary goal of Pythonx is to better integrate Python workflows within Livebook and scripts. Pythonx usage in actual projects must be done with care due to Python’s global interpreter lock (GIL). The GIL prevents multiple threads from executing Python code at the same time, so calling <code>Pythonx</code> from multiple Elixir processes does not provide the concurrency you might expect and thus it can be a source of bottlenecks. However, this limitation concerns regular Python code. Packages with CPU-intense functionality, such as <code>numpy</code>, have native implementation of many functions and invoking those releases the GIL. The GIL is also released when waiting on I/O operations. In other words, if you are using this library to integrate with Python, make sure it happens in a single Elixir process or that its underlying libraries can deal with concurrent invocation.</p>
<p>
If the above is a dealbreaker, remember that interoperability already exists at a few levels. For example, you could write a Python script and then invoke it with <a href="https://hexdocs.pm/elixir/System.html#cmd/3"><code>System.cmd/3</code></a> or open a <a href="https://hexdocs.pm/elixir/Port.html">Port</a>. In those cases, you could start several or even a pool of Python processes that you would manage.</p>
<p>
Furthermore, depending on your needs, you may also be able to interoperate through higher-level abstractions. For example, for AI workflows, you can run pre-trained models directly, some via <a href="https://github.com/elixir-nx/bumblebee">Bumblebee</a>, others via <a href="https://github.com/elixir-nx/ortex">Ortex</a>. When using an LLM, you often end up talking to a third-party provider, or perhaps you run a drop-in llama.cpp Docker container on-premise, optimised for inference. In such cases the interface is HTTP and Elixir has high-level tools for interacting with LLMs too, namely <a href="https://github.com/thmsmlr/instructor_ex">Instructor</a> and <a href="https://github.com/brainlid/langchain">LangChain</a>.</p>
<p>
That said, if you do decide that Pythonx fits into your application, you can configure it to download all Python dependencies at compile time and include them as part of the Elixir release. For more details, refer to <a href="https://hexdocs.pm/pythonx/Pythonx.html#module-usage-application">this section</a> in the doc.</p>
<p>
You could also use Pythonx to give you immediate access to more tools to unblock you. Once your idea pays off, you can invest more time to arrive at a Elixir-centric solution, if you so desire.</p>
<h2>
It’s Fine</h2>
<p>
Speaking of interoperability, I mentioned that Pythonx uses NIFs. NIFs are Elixir functions with the implementation living in C. We reach for NIFs either when we want to write native code with mutability for something performance-critical or when we integrate with third-party libraries via C API (often both).</p>
<p>
To give an example, below is a NIF implementation that adds two numbers.</p>
<pre><code><span>#include</span><span> </span><span>&lt;</span><span>erl_nif.h</span><span>&gt;</span><span>
</span><span>
</span><span>ERL_NIF_TERM </span><span>add</span><span>(</span><span>ErlNifEnv</span><span>*</span><span> </span><span>env</span><span>,</span><span> </span><span>int</span><span> </span><span>argc</span><span>,</span><span> </span><span>const</span><span> ERL_NIF_TERM </span><span>argv</span><span>[</span><span>]</span><span>)</span><span> </span><span>{</span><span>
</span><span>  </span><span>int</span><span> x</span><span>,</span><span> y</span><span>;</span><span>
</span><span>
</span><span>  </span><span>if</span><span> </span><span>(</span><span>argc </span><span>!=</span><span> </span><span>2</span><span> </span><span>||</span><span> </span><span>!</span><span>enif_get_int</span><span>(</span><span>env</span><span>,</span><span> argv</span><span>[</span><span>0</span><span>]</span><span>,</span><span> </span><span>&amp;</span><span>x</span><span>)</span><span> </span><span>||</span><span> </span><span>!</span><span>enif_get_int</span><span>(</span><span>env</span><span>,</span><span> argv</span><span>[</span><span>1</span><span>]</span><span>,</span><span> </span><span>&amp;</span><span>y</span><span>)</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>return</span><span> </span><span>enif_make_badarg</span><span>(</span><span>env</span><span>)</span><span>;</span><span>
</span><span>  </span><span>}</span><span>
</span><span>
</span><span>  </span><span>int</span><span> result </span><span>=</span><span> x </span><span>+</span><span> y</span><span>;</span><span>
</span><span>
</span><span>  </span><span>return</span><span> </span><span>enif_make_int</span><span>(</span><span>env</span><span>,</span><span> result</span><span>)</span><span>;</span><span>
</span><span>}</span><span>
</span><span>
</span><span>ErlNifFunc nif_funcs</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
</span><span>  </span><span>{</span><span>&#34;</span><span>add</span><span>&#34;</span><span>,</span><span> </span><span>2</span><span>,</span><span> add</span><span>}</span><span>
</span><span>}</span><span>;</span><span>
</span><span>
</span><span>ERL_NIF_INIT</span><span>(</span><span>Elixir</span><span>.</span><span>MyLib</span><span>.</span><span>NIF</span><span>,</span><span> nif_funcs</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>)</span></code></pre>
<p>
Looking at the signature, you can see that the function receives a C-array of Erlang terms and returns an Erlang term. We are responsible for converting between terms and C data structures using the <code>enif_*</code> APIs. The example may look pretty straightforward, though it is a fair amount of boilerplate code to end up adding two numbers. From there the ceremony escalates quickly once we need to deal with nested data structures and return errors more specific than <code>:badarg</code>. A natural progression is to extract some of the logic to helper functions, but this doesn’t fully alleviate the boilerplate and it results in reinventing the wheel a lot.</p>
<p>
Additionally, Pythonx (and other NIF-extensive projects) actually use C++, while the <code>enif_*</code> APIs are (rightfully so) C. Since C++ brings more powerful constructs, theoretically there is a possibility of a more expressive API, however it is also easy to get into weeds with C++ metaprogramming. The main question I asked myself is how far can we go inferring the conversion from types. With <a href="https://github.com/rusterlium/rustler">Rustler</a> and <a href="https://github.com/E-xyza/zigler">Zigler</a>, NIFs are written as regular functions and the data structures conversion is handled automatically based on the signature types.</p>
<p>
This brings us to <a href="https://github.com/elixir-nx/fine">Fine</a>, C++ library enabling more ergonomic NIFs, tailored to Elixir. Let’s see an update example:</p>
<pre><code><span>#include</span><span> </span><span>&lt;</span><span>fine.hpp</span><span>&gt;</span><span>
</span><span>
</span><span>int64_t</span><span> </span><span>add</span><span>(</span><span>ErlNifEnv </span><span>*</span><span>env</span><span>,</span><span> </span><span>int64_t</span><span> </span><span>x</span><span>,</span><span> </span><span>int64_t</span><span> </span><span>y</span><span>)</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> x </span><span>+</span><span> y</span><span>;</span><span>
</span><span>}</span><span>
</span><span>
</span><span>FINE_NIF</span><span>(</span><span>add</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span><span>
</span><span>
</span><span>FINE_INIT</span><span>(</span><span>&#34;</span><span>Elixir.MyLib.NIF</span><span>&#34;</span><span>)</span><span>;</span></code></pre>
<p>
Other than extendable encoding/decoding, Fine provides smart pointers to safely manage resource objects and support for raising exceptions anywhere in the NIF. I’ve refactored EXLA NIFs to use Fine and <a href="https://github.com/elixir-nx/nx/pull/1581">it removed over 1k LOC</a>, so it may be worth considering next time you have to write some NIFs.</p>
<h2>
Summing up</h2>
<p>
When we started Numerical Elixir, our goal was for Elixir to develop and have its own identity within the data and machine learning ecosystem. Now we are ready to make interoperability a key focus of our efforts too.</p>
<p>
Pythonx embeds Python into Elixir, bringing a new class of interoperability with a third-party language not seen before within the Erlang VM. It is more than just integrating the Python interpreter, it is about transparently translating idioms from one language to the other.</p>
<p>
The Fine project also consolidates and streamlines our collective experiences in integrating C++ and Elixir, tracing back to Sean Moriarity’s work on Nx four years ago.</p>
<p>
There is more to come.</p>
<p>
Stay interoperable!</p>

  </article>
</div></div>
  </body>
</html>
