<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.li/to-the-surprise-of-literally-no-one-im-working-on-implementing-a-programming-language-all-my-own">Original</a>
    <h1>I&#39;m working on implementing a programming language all my own</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
       

        <h2>To the surprise of literally no one, I&#39;m working on implementing a programming language all my own</h2>

        

        
<p>Inspired by conversation at a recent <a href="https://futureofcoding.org/">Future of Coding</a> event, I decided I’d write up a little something about the programming language I’ve been working on (for what feels like forever) before I’ve gotten it to a totally shareable state. I have a working interpreter that I’m pretty pleased with, but I don’t yet have an interactive environment for creating, exploring, debugging, and running code — I have this idea for a Smalltalk-flavored infinite canvas dev experience that’ll work in the browser. Hoping that’ll be ready soon(ish)!</p>
<hr/>
<p><strong><em>Author’s note:</em></strong> Cutting in real fast from the future with an after-the-fact update! I pulled together a <a href="https://smallandnearlysilent.com/baba-yaga/">relatively simple, standalone playground</a> for folks to explore Baba Yaga a bit more!</p>
<hr/>
<h2 id="meet-baba-yaga">Meet Baba Yaga!</h2>
<p>Baba Yaga started as a purely aesthetic endeavor. Like a beaver drawn to slowing the flow of a river, I had this idea that was haunting me about what I wanted a language to look like on screen and kinda worked backwards from there. To start, I wrote a few fantasy programs, and then started to think through how to get that code to run.</p>
<p>I have no intention whatsoever of Baba Yaga becoming anything but a curiosity and an exploratory project for me. Because of this, it is really, really biased towards the things I adore in a programming experience, including:</p>
<ul>
<li>immutability</li>
<li>functional-first everything everywhere</li>
<li>minimal syntax to learn</li>
<li><em>some</em> batteries included</li>
</ul>
<p>There is no real groundbreaking single feature that I think is especially notable about Baba Yaga. Instead, it mixes a bunch of familiar functional programming concepts into a hopefully cohesive and expressive combination that is orders of magnitude simpler than other such functional languages. Baba Yaga is kinda like <a href="https://en.wikipedia.org/wiki/Toki_Pona">Toki Pona</a> but for Haskell.</p>
<h3 id="basic-syntax-and-data-types">Basic Syntax and Data Types</h3>
<p>The syntax aims for visual clarity with minimal punctuation. Over the last few years, I’ve really fallen for typed languages, but I also don’t have a big capital T type theory brain. So, Baba Yaga only has some core types that fell out of its approach to control flow with pattern matching.</p>
<h4 id="declarations">Declarations</h4>
<p>Variables and functions use the same declaration pattern. Function calls don’t require parentheses, though you can use them for grouping and disambiguation.</p>
<pre><code>// Variables
transport : &#34;Chicken House&#34;;
number : 42;

// Functions
add : x y -&gt; x + y;
square : x -&gt; x * x;

// Function calls
result : add 5 3;
nested : add (square 4) 2;</code></pre>
<p>Functions can also be curried without additional ceremony:</p>
<pre><code>// Curried function
addCurried : x -&gt; y -&gt; x + y;
add5 : addCurried 5;
result : add5 3;  // 8</code></pre>
<h4 id="data-types">Data Types</h4>
<p>The language includes a few essential, immutable data types.</p>
<pre><code>// Numbers (Int and Float are distinct)
age : 36;
temperature : 32.6;
accountBalance: -12000;

// Strings with the &#39;..&#39; concatenation operator
fullName : &#34;Lucy&#34; .. &#34; &#34; .. &#34;Snowe&#34;;

// Booleans
isActive : true;

// Lists (immutable)
numbers : [1, 2, 3, 4, 5];
firstItem : numbers.0;  // zero-indexed access

// Tables (immutable key-value structures)
person : {name: &#34;Lucy Snowe&#34;, age: 23, city: &#34;Villette&#34;};
personName : person.name;</code></pre>
<h4 id="types-and-validation">Types and Validation</h4>
<p>Types are optional but can be explicitly declared. Without declarations, values carry runtime type tags (<code>Int</code>, <code>Float</code>, <code>String</code>, <code>Bool</code>, <code>List</code>, <code>Table</code>). Parameter and return type validation happens at call time only for that stuff which includes annotations. Anything without type annotations is left to do what it likes. Slip slip slip-and-slide.</p>
<pre><code>// Type declaration (name Type)
myValue Int;
myOtherValue Int;

// Assignment must match declared type
myValue : 10;        // OK
myOtherValue : &#34;x&#34;;  // Error: expected Int</code></pre>
<h3 id="control-flow-with-pattern-matching">Control Flow with Pattern Matching</h3>
<p>The <code>when</code> expression is the language’s only control flow construct. No <code>if</code>/<code>else</code> or <code>switch</code> statements exist. I did this mostly to see if I could, but also to help encourage thinking about the shape of data rather than imperative conditions. Philosophically speaking:</p>
<ul>
<li><strong>if/else</strong> asks<span></span> <span>“</span>is this condition true?”</li>
<li><strong>switch</strong> asks<span></span> <span>“</span>is this value equal to one of these constants?”</li>
<li><strong>pattern matching</strong> asks<span></span> <span>“</span>does this data look like this? If so, give me the pieces.”</li>
</ul>
<p>You can match on simple values, types, and use guards for more complex conditions.</p>
<pre><code>// Match on simple values
describe : x -&gt;
  when x is
    0 then &#34;Zero&#34;
    1 then &#34;One&#34;
    _ then &#34;Something else&#34;; // _ is the wildcard

// Match on types
processValue : value -&gt;
  when value is
    Int    then &#34;Got an integer&#34;
    String then &#34;Got text&#34;
    _      then &#34;Got something else&#34;;

// Use pattern guards for complex conditions
categorize : n -&gt;
  when n is
    x if (x &gt; 0 and x &lt; 10) then &#34;small positive&#34;
    x if (x &gt;= 10)          then &#34;large positive&#34;
    x if (x &lt; 0)            then &#34;negative&#34;
    0                       then &#34;zero&#34;;</code></pre>
<p>Baba Yaga also supports matching against multiple discriminants and destructuring data structures like tables.</p>
<pre><code>// Multiple discriminants
checkPosition : x y -&gt;
  when x y is
    0 0 then &#34;Origin&#34;
    1 1 then &#34;Diagonal&#34;
    _ _ then &#34;Somewhere else&#34;;

// Destructuring and nested matching
processUser : user -&gt;
  when user is
    {name: n, age: a, active: true} then
      when a is
        age if (age &lt; 18) then &#34;Minor: &#34; .. n
        age if (age &gt;= 18 and age &lt; 65) then &#34;Adult: &#34; .. n
        _ then &#34;Senior: &#34; .. n
    {name: n, active: false} then &#34;Inactive: &#34; .. n
    _ then &#34;Invalid user&#34;;</code></pre>
<p>Here’s a chunk of Conway’s Game of Life that I used to test if the language could handle non-trivial algorithms. Like the famous implementation in <span>APL</span>, each generation is a pure transformation of the previous state.</p>
<pre><code>// Apply Game of Life rules
nextCell : grid row col -&gt;
  with (
    current : grid.(row).(col);
    neighbors : countNeighbors grid row col;
  ) -&gt;
    when current is
      1 then when (neighbors = 2 or neighbors = 3) is true then 1 _ then 0
      _ then when (neighbors = 3) is true then 1 _ then 0;</code></pre>
<h3 id="working-with-collections">Working with Collections</h3>
<p>All list operations are immutable and return new lists. This includes standard functional staples as well as utilities inspired by other array programming languages.</p>
<h4 id="functional-staples">Functional Staples</h4>
<p>The higher-order functions that are the bread and butter of most functional programming work as expected.</p>
<pre><code>// Basic list operations
original : [1, 2, 3];
withFour : append original 4;      // [1, 2, 3, 4]
withZero : prepend 0 original;     // [0, 1, 2, 3]
combined : concat [1, 2] [3, 4];   // [1, 2, 3, 4]

// Higher-order functions
numbers : [1, 2, 3, 4, 5, 6];
doubled : map (x -&gt; x * 2) numbers;           // [2, 4, 6, 8, 10, 12]
evens : filter (x -&gt; x % 2 = 0) numbers;      // [2, 4, 6]
sum : reduce (acc x -&gt; acc + x) 0 numbers;    // 21</code></pre>
<h4 id="array-programming-utilities">Array Programming Utilities</h4>
<p>The array programming features follow the same pattern as the other higher-order functions.</p>
<pre><code>data : [10, 21, 30, 43, 50];

// Find indices where a predicate is true
evenIndices : where (x -&gt; x % 2 = 0) data;        // [0, 2, 4]

// Select elements at specific indices
selected : at [0, 2, 4] data;                     // [10, 30, 50]

// Cumulative operations (like APL&#39;s scan)
cumulative : cumsum [1, 2, 3, 4, 5];              // [0, 1, 3, 6, 10, 15]

// Broadcasting (apply a function with a scalar to each element)
addTen : broadcast (x y -&gt; x + y) 10 [1, 2, 3];   // [11, 12, 13]

// Reshape a flat array into a matrix
matrix : reshape [2, 3] [1, 2, 3, 4, 5, 6]; // [[1, 2, 3], [4, 5, 6]]</code></pre>
<p>These operations compose pretty well with the functional style. You can chain <code>where</code> to find indices, <code>at</code> to select values, and then process those with <code>map</code> without experiencing any wild dissonance, I don’t think.</p>
<h3 id="error-handling">Error Handling</h3>
<p>Instead of exceptions, Baba Yaga uses a <code>Result</code> type (<code>Ok value</code> or <code>Err message</code>) for operations that might fail. This introduces explicit error representation and handling.</p>
<pre><code>divide : x y -&gt;
  when y is
    0 then Err &#34;Cannot divide by zero&#34;
    _ then Ok (x / y);

handleDivision : x y -&gt;
  when (divide x y) is
    Ok result   then result
    Err message then 0; // Provide a default value on failure</code></pre>
<h3 id="local-bindings-and-utilities">Local Bindings and Utilities</h3>
<p>The <code>with</code> keyword creates immutable local bindings within an expression. For mutually recursive local functions, use <code>with rec</code>. Mutually recursive functions work without any special syntax at the global scope.</p>
<pre><code>// &#39;with&#39; for local, immutable bindings
processOrder : order -&gt;
  with (
    taxRate : 0.08;
    subtotal : order.items * order.price;
    total : subtotal + (subtotal * taxRate);
  ) -&gt;
    {subtotal: subtotal, total: total};

// &#39;with rec&#39; for mutual recursion
evenOdd : n -&gt;
  with rec (
    isEven : x -&gt; when x is 0 then true _ then isOdd (x - 1);
    isOdd : x -&gt; when x is 0 then false _ then isEven (x - 1);
  ) -&gt;
    {even: isEven n, odd: isOdd n};</code></pre>
<p>The language also comes with a handful of utilities organized in namespaces like <code>str</code>, <code>math</code>, and <code>validate</code>.</p>
<pre><code>words : str.split &#34;hello,world,banana&#34; &#34;,&#34;;    // [&#34;hello&#34;, &#34;world&#34;, &#34;banana&#34;]
absolute : math.abs -5;                        // 5
valid : validate.range 1 10 5;                 // true
debug.print &#34;Processing&#34; someValue;</code></pre>
<h3 id="javascript-interoperability">JavaScript Interoperability</h3>
<p>Since Baba Yaga runs on JavaScript, it needs a way to call <span>JS</span> functions…or, like, I wanted to have a way to call <span>JS</span> from Baba Yaga as a sort of escape hatch so that I didn’t have to remake the whole entire world. But <span>JS</span> doesn’t have the same kinda functional guarantees as Baba Yaga is trying to ensure, so all <span>JS</span> calls return <code>Result</code> types. This helps to maintain the functional programming model even when crossing into imperative territory. This means you can’t accidentally throw exceptions from <span>JS</span> that crash your functional program.</p>
<pre><code>// Call JavaScript functions (returns a Result type)
jsonResult : io.callJS &#34;JSON.parse&#34; [&#34;{\&#34;x\&#34;: 10}&#34;];

// Convert between JS and Baba Yaga data
jsArray : io.listToJSArray [1, 2, 3];
babaTable : when (io.callJS &#34;JSON.parse&#34; [&#34;{}&#34;]) is
  Ok obj then io.objectToTable obj
  Err msg then Err msg;</code></pre>
<p>This is likely the roughest edge of the entire language and where I need to spend the most time.</p>
<h2 id="dont-ya-know-theyre-talking-about-a-implementation">Don’t ya know / They’re talking about a implementation?</h2>
<p>In the past I’ve implemented a lot of toy languages. Working on Baba Yaga has been a great learning experience on how to implement a quote real language unquote. I’ve tried not to be slap-dash about my approach, and, while I don’t want Baba Yaga to take the world by storm, nor do I really expect many/any folks to really ever use it, I wanted it to be performant enough to use for games and sketches and maybe some live code stuff.</p>
<p>To help meet those goals, some things that I considered during th implementation:</p>
<ul>
<li><strong>Two engines</strong>: The project has a stable<span></span> <span>“</span>legacy” engine and an optimized one. The optimized one doesn’t work super duper well, though, so, it is turned off by default, but I should revisit that.</li>
<li><strong>Enormous test suite</strong>: Working on <a href="https://blog.veitheller.de/make-awk-rawk">rawk</a> I realized the only way to test a language is to use that language a lot, so having a test suite that covers all of the language features is really really useful…but also even a tiny language ends up having a whole freaking lot of surface area to test when it has non-trivial syntax rules more complicated than you get in a forth or a scheme.</li>
<li><strong>Developer-focused, Elm-inspired error handling</strong>: The error system provides detailed messages with source location, visual pointers, and suggestions…because Elm poisoned me, and because I think error handling shouldn’t be an implementation after thought but like the whole-freaking-point of the exercise.</li>
<li><strong>Security-focused interop</strong>: The JavaScript integration includes function allowlisting, execution timeouts, and memory limits to maintain functional guarantees and also to prevent ya from just writing <span>JS</span> all the time (looking at myself).</li>
<li><strong>Performance-aware design</strong>: This is a space I had literally no understanding of before starting this. I read a bunch of blog posts and combed through a number of implementations of other languages. The implementation uses stuff like object pooling for <span>AST</span> nodes and includes benchmarks to try and measure the impact of optimizations, like using arrays instead of hash maps for variable lookups…but I’ll be honest, this is the bit of the project where I likely have the most to learn, still.</li>
<li><strong>Runtime configuration</strong>: Because Baba Yaga targets a handful of JavaScript runtimes, the engine supports type-safe presets for the different environments (development, production, sandbox), allowing for different recursion depths and memory limits. I haven’t actually ever needed to tune these away from the default, but the option exists!</li>
</ul>
<h2 id="full-language-reference-card">Full Language Reference Card</h2>
<pre><code>BABA YAGA LANGUAGE REFERENCE
============================

SYNTAX
------
var : value;                    // assignment
var Type; var : value;          // typed assignment  
f : x -&gt; body;                  // function
f : x y -&gt; body;                // multi-param function
f : (x: Type) -&gt; Type -&gt; body;  // typed function
f : x -&gt; y -&gt; body;             // curried function
f : x -&gt; with (locals) -&gt; body; // with locals
f : x -&gt; with rec (fns) -&gt; body;// with mutual recursion

LITERALS
--------
42                              // Int
3.14                            // Float  
&#34;text&#34;                          // String
true false                      // Bool
[1,2,3]                         // List
{a:1, b:2}                      // Table
PI INFINITY                     // constants

OPERATORS (precedence high→low)
-------------------------------
f x, obj.prop                   // call, access
- !                             // unary minus, not
* / %                           // multiply, divide, modulo
+ -                             // add, subtract  
= != &lt; &lt;= &gt; &gt;=                  // comparison
and or                          // logical
..                              // string concat

CONTROL FLOW
------------
when x is                       // pattern match
  0 then &#34;zero&#34;
  Int then &#34;number&#34; 
  _ then &#34;other&#34;;

when x y is                     // multi-discriminant
  0 0 then &#34;origin&#34;
  _ _ then &#34;other&#34;;

x if (condition) then result    // pattern guard
_ then &#34;fallback&#34;;

TYPES
-----
Int Float Number String Bool List Table Result Function

Int ⊂ Float ⊂ Number            // type hierarchy
Ok value | Err message          // Result variants

ARRAY OPERATIONS
----------------
// Core HOFs
map f xs                        // [f x | x &lt;- xs]
filter p xs                     // [x | x &lt;- xs, p x]
reduce f z xs                   // f(...f(f(z,x1),x2)...,xn)

// Array programming  
scan f z xs                     // cumulative reduce
cumsum xs                       // cumulative sum
cumprod xs                      // cumulative product
at indices xs                   // xs[indices]
where p xs                      // indices where p x is true
take n xs                       // first n elements
drop n xs                       // drop first n elements
broadcast f scalar xs           // f scalar to each x
zipWith f xs ys                 // [f x y | (x,y) &lt;- zip xs ys]
reshape dims xs                 // reshape flat array to matrix
flatMap f xs                    // concat (map f xs)

// List manipulation
append xs x                     // xs ++ [x]
prepend x xs                    // [x] ++ xs  
concat xs ys                    // xs ++ ys
update xs i x                   // xs with xs[i] = x
removeAt xs i                   // xs without xs[i]
slice xs start end              // xs[start:end]
length xs                       // |xs|

// Utilities
chunk xs n                      // split xs into chunks of size n
range start end                 // [start..end]
repeat n x                      // [x,x,...] (n times)
sort.by xs f                    // sort xs by key function f
group.by xs f                   // group xs by key function f

TABLE OPERATIONS
----------------
set tbl k v                     // tbl with tbl[k] = v
remove tbl k                    // tbl without tbl[k]
merge tbl1 tbl2                 // tbl1 ∪ tbl2
keys tbl                        // [k | k &lt;- tbl]
values tbl                      // [tbl[k] | k &lt;- tbl]
shape x                         // metadata: kind, rank, shape, size

STRING OPERATIONS
-----------------
str.concat s1 s2 ...            // s1 + s2 + ...
str.split s delim               // split s by delim
str.join xs delim               // join xs with delim
str.length s                    // |s|
str.substring s start end       // s[start:end]
str.replace s old new           // replace old with new in s
str.trim s                      // strip whitespace
str.upper s                     // uppercase
str.lower s                     // lowercase
text.lines s                    // split by newlines
text.words s                    // split by whitespace

MATH OPERATIONS
---------------
// Arithmetic
math.abs x                      // |x|
math.sign x                     // -1, 0, or 1
math.min x y, math.max x y      // min/max
math.clamp x lo hi              // clamp x to [lo,hi]

// Rounding  
math.floor x, math.ceil x       // ⌊x⌋, ⌈x⌉
math.round x, math.trunc x      // round, truncate

// Powers &amp; logs
math.pow x y                    // x^y
math.sqrt x                     // √x
math.exp x, math.log x          // e^x, ln(x)

// Trigonometry
math.sin x, math.cos x, math.tan x
math.asin x, math.acos x, math.atan x, math.atan2 y x
math.deg x, math.rad x          // degrees ↔ radians

// Random
math.random                     // [0,1)
math.randomInt lo hi            // [lo,hi]

FUNCTION COMBINATORS
--------------------
flip f                          // λx y. f y x
apply f x                       // f x  
pipe x f                        // f x (reverse apply)
compose f g                     // λx. f (g x) (binary compose)

VALIDATION &amp; DEBUG
------------------
// Validation
validate.notEmpty x             // x is not empty
validate.range lo hi x          // lo ≤ x ≤ hi  
validate.type &#34;Type&#34; x          // x has type Type
validate.email x                // x is valid email

// Debugging
debug.print [name] value        // print with optional name
debug.inspect x                 // detailed inspection
assert condition message        // throw if condition false

I/O
---
io.out value                    // print value
io.in                           // read stdin

JAVASCRIPT INTEROP
------------------
io.callJS fnName args           // call JS function synchronously
io.callJSAsync fnName args      // call JS function asynchronously
io.getProperty obj propName     // get JS object property
io.setProperty obj propName val // set JS object property
io.hasProperty obj propName     // check if JS property exists
io.jsArrayToList jsArray        // convert JS array to Baba Yaga list
io.listToJSArray list           // convert Baba Yaga list to JS array
io.objectToTable jsObj          // convert JS object to Baba Yaga table
io.tableToObject table          // convert Baba Yaga table to JS object
io.getLastJSError               // get last JS error (if available)
io.clearJSError                 // clear last JS error (if available)

EXAMPLES
--------
// Fibonacci
fib : n -&gt; when n is 0 then 0 1 then 1 _ then (fib (n-1)) + (fib (n-2));

// Array processing pipeline
process : xs -&gt;
  with (
    filtered : filter (x -&gt; (x % 2) = 0) xs;
    doubled : map (x -&gt; x * 2) filtered;
    summed : reduce (acc x -&gt; acc + x) 0 doubled;
  ) -&gt; summed;

// Result handling
safeDivide : x y -&gt; when y is 0 then Err &#34;div by zero&#34; _ then Ok (x / y);
use : r -&gt; when r is Ok v then v Err _ then 0;

// Pattern matching with guards
classify : x -&gt; when x is
  n if ((n &gt; 0) and (n &lt; 10)) then &#34;small positive&#34;
  n if (n &gt;= 10) then &#34;large positive&#34;  
  n if (n &lt; 0) then &#34;negative&#34;
  _ then &#34;zero&#34;;

// Mutual recursion
evenOdd : n -&gt; with rec (
  even : x -&gt; when x is 0 then true _ then odd (x - 1);
  odd : x -&gt; when x is 0 then false _ then even (x - 1);
) -&gt; {even: even n, odd: odd n};

// Array programming
matrix : reshape [2,3] [1,2,3,4,5,6];   // [[1,2,3],[4,5,6]]
indices : where (x -&gt; x &gt; 3) [1,2,3,4,5]; // [3,4] 
selected : at indices [10,20,30,40,50];   // [40,50]</code></pre>

        <p>Published 
          <time datetime="2025-08-27T11:50:00-0400" title="Wednesday, August 27, 2025 11:50 AM EDT">August 27, 2025
          </time>
        </p>
        
        
        <details>
        <summary>Tags</summary>
        <ul>
        	<li><a href="https://blog.veitheller.de/tagged/baba-yaga">baba yaga</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/programming-language">programming language</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/functional-programming">functional programming</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/array-programming">array programming</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/hobby-projects">hobby projects</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/programming">programming</a></li>
        	<li><a href="https://blog.veitheller.de/tagged/programming-language-design">programming language design</a></li>
        </ul>
        </details>
        
        <details>
        <summary>Backlinks</summary>
        <ul>
        	<li><a href="https://blog.veitheller.de/wiki">Wiki</a></li>
        </ul>
        </details>
        
        <br/>
       
    </article>
</div></div>
  </body>
</html>
