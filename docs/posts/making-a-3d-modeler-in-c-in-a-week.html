<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielchasehooper.com/posts/shapeup/">Original</a>
    <h1>Making a 3D modeler in C in a week</h1>
    
    <div id="readability-page-1" class="page"><div><p>Last fall I participated in a week long programming event called the <a href="https://handmade.network/jam/2023" target="_blank" rel="noopener">Wheel Reinvention Jam</a>. The point of the Jam was to revisit existing software systems with fresh eyes. I ended up making a 3D modeler called “ShapeUp”. This post will make more sense if you watch the <a href="https://youtu.be/-Xb3Kk3HhIw" target="_blank" rel="noopener">video demo of ShapeUp</a> before reading more. You can <a href="https://danielchasehooper.com/projects/shapeup">try ShapeUp in your browser</a>.</p><p>This is what it looks like:</p><p><a href="https://danielchasehooper.com/posts/shapeup/mike.png" title="ShapeUp with a monster model"><img src="https://danielchasehooper.com/posts/shapeup/mike_hu8dfea9063e5ecc351e92b806a8a30330_158503_700x0_resize_box_3.png" srcset="/posts/shapeup/mike_hu8dfea9063e5ecc351e92b806a8a30330_158503_1050x0_resize_box_3.png 3x, /posts/shapeup/mike_hu8dfea9063e5ecc351e92b806a8a30330_158503_1050x0_resize_box_3.png 2x, /posts/shapeup/mike_hu8dfea9063e5ecc351e92b806a8a30330_158503_700x0_resize_box_3.png 1x" alt="ShapeUp with a monster model"/></a></p><h2 id="a-3d-modeler">A 3D Modeler</h2><p>I hate how slow the typescript compiler is (this connects, trust me). The jam seemed like a good opportunity to implement a faster subset of Typescript to beat <code>tsc</code>. Starting with the <a href="https://esbuild.github.io" target="_blank" rel="noopener">esbuild</a> or <a href="https://bun.sh" target="_blank" rel="noopener">Bun</a> typescript parser made the project seem plausible. It dawned on me that success would look like one terminal command finishing faster than another. As far as demos go, not super compelling. I wanted a cool demo. So I pivoted to 3D.</p><p>The only reason a 3D project from scratch in a week seemed doable was because of a technique called <a href="https://youtu.be/-Xb3Kk3HhIw?si=g95rRsHRZlJYznN8&amp;t=58" target="_blank" rel="noopener">ray marched signed distance fields</a> (SDFs). A ray marched SDF scene with colors, soft shadows, and ambient occlusion can be implemented much faster than an equivalent triangle based renderer. The amazing <a href="https://twitter.com/iquilezles" target="_blank" rel="noopener">Inigo Quilez</a> uses SDFs to create <a href="https://www.youtube.com/watch?v=8--5LwHRhjk" target="_blank" rel="noopener">pixar-like characters</a> in one sitting. I had written SDF shaders before but they were rudimentary. Modeling by editing code felt unnatural to me. I wanted to edit the shapes with a mouse. This jam seemed like my chance to make that a reality. I named it ShapeUp.</p><p><a href="https://danielchasehooper.com/posts/shapeup/sdf.png" title="The signed distance field visualized"><img src="https://danielchasehooper.com/posts/shapeup/sdf_hu0bc9c124672beefeb4a0e3eb8a4f4b40_275943_700x0_resize_box_3.png" srcset="/posts/shapeup/sdf_hu0bc9c124672beefeb4a0e3eb8a4f4b40_275943_1051x0_resize_box_3.png 3x, /posts/shapeup/sdf_hu0bc9c124672beefeb4a0e3eb8a4f4b40_275943_1051x0_resize_box_3.png 2x, /posts/shapeup/sdf_hu0bc9c124672beefeb4a0e3eb8a4f4b40_275943_700x0_resize_box_3.png 1x" alt="The signed distance field visualized"/>
</a>ShapeUp’s Signed Distance Field visualized</p><h2 id="in-c">In C</h2><p>I wrote ShapeUp in C, and used <a href="https://www.raylib.com" target="_blank" rel="noopener">raylib</a> to create the OpenGL window. Raylib turned out to be one of those libraries that gets you going quickly, but slows you down in the long run. More about that later.</p><p>Some view C as a language so simple and raw that you’ll spend all your time working around the language’s lack of built in data structures, and fixing pointer bugs. The truth is that C’s simplicity is a strength. It compiles quickly. Its syntax doesn’t hide complex operations. It’s simple enough that I don’t have to constantly look things up. And I can easily compile it to both native and web assembly. While C has its share of quirks, I avoid them by habits developed over 22 years of use.</p><p>My “day job” project is 177,000 lines of C and Objective-C. By comparison, ShapeUp’s small single C file is trivial. Even so, I think it’s interesting to look at how it uses data. Models are made up of Shapes:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Vector3</span> <span>pos</span><span>;</span>
</span></span><span><span>    <span>Vector3</span> <span>size</span><span>;</span>
</span></span><span><span>    <span>Vector3</span> <span>angle</span><span>;</span>
</span></span><span><span>    <span>float</span> <span>corner_radius</span><span>;</span>
</span></span><span><span>    <span>float</span> <span>blob_amount</span><span>;</span>
</span></span><span><span>    <span>struct</span> <span>{</span>
</span></span><span><span>        <span>uint8_t</span> <span>r</span><span>,</span><span>g</span><span>,</span><span>b</span><span>;</span>
</span></span><span><span>    <span>}</span> <span>color</span><span>;</span>
</span></span><span><span>    <span>struct</span> <span>{</span>
</span></span><span><span>        <span>bool</span> <span>x</span><span>,</span><span>y</span><span>,</span><span>z</span><span>;</span>
</span></span><span><span>    <span>}</span> <span>mirror</span><span>;</span>
</span></span><span><span>    <span>bool</span> <span>subtract</span><span>;</span>
</span></span><span><span><span>}</span> <span>Shape</span><span>;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>The Shapes are kept in a statically allocated array:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>#define MAX_SHAPE_COUNT 100
</span></span></span><span><span><span></span><span>Shape</span> <span>shapes</span><span>[</span><span>MAX_SHAPE_COUNT</span><span>];</span>
</span></span><span><span><span>int</span> <span>shape_count</span><span>;</span>
</span></span><span><span><span>int</span> <span>selected_shape</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Can’t fail to allocate, can’t be leaked, no fluff. Lovely. The 100 shape limit wasn’t limiting in practice. With very little time to optimize the renderer, the framerate would drop before you even got to 100 shapes. If there had been time, I would have <a href="https://youtu.be/u9KNtnCZDMI?si=8QTGMnqVV8TnEPf9&amp;t=937" target="_blank" rel="noopener">broken the model into little bricks</a> and then raymarched within each brick.</p><p>For dynamic memory, ShapeUp calls malloc in only 3 places:</p><ul><li>Saving (allocates a buffer big enough to hold the whole document)</li><li>.OBJ export (again, allocates a buffer large enough to hold all vertices)</li><li>GLSL shader generation (buffer for shader source)</li></ul><p>In all cases there is a single free at the end of the function. Again, this is all trivial - I mention it mostly as an existence proof that memory in C can be trivial. You could certainly make it harder on yourself by malloc-ing each <code>Shape</code> individually and storing those pointers in a dynamic array. Using a language like C#, Javascript, or Python would force that allocation structure. I appreciate that C gives me control over memory layout.</p><p>The UI is implemented as an <a href="https://www.youtube.com/watch?v=Z1qyvQsjK5Y" target="_blank" rel="noopener">immediate mode user interface</a> (IMGUI). I love this approach to UI. It’s very easy to debug and you use a real programming language to position elements (unlike CSS, constraints, or SwiftUI). Like most IMGUIs, I used an enum to keep track of what element had focus, or what action the mouse was making:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>enum</span> <span>{</span>
</span></span><span><span>    <span>CONTROL_NONE</span><span>,</span>
</span></span><span><span>    <span>CONTROL_POS_X</span><span>,</span>
</span></span><span><span>    <span>CONTROL_POS_Y</span><span>,</span>
</span></span><span><span>    <span>CONTROL_POS_Z</span><span>,</span>
</span></span><span><span>    <span>CONTROL_SCALE_X</span><span>,</span>
</span></span><span><span>    <span>CONTROL_SCALE_Y</span><span>,</span>
</span></span><span><span>    <span>CONTROL_SCALE_Z</span><span>,</span>
</span></span><span><span>    <span>CONTROL_ANGLE_X</span><span>,</span>
</span></span><span><span>    <span>CONTROL_ANGLE_Y</span><span>,</span>
</span></span><span><span>    <span>CONTROL_ANGLE_Z</span><span>,</span>
</span></span><span><span>    <span>CONTROL_COLOR_R</span><span>,</span>
</span></span><span><span>    <span>CONTROL_COLOR_G</span><span>,</span>
</span></span><span><span>    <span>CONTROL_COLOR_B</span><span>,</span>
</span></span><span><span>    <span>CONTROL_TRANSLATE</span><span>,</span>
</span></span><span><span>    <span>CONTROL_ROTATE</span><span>,</span>
</span></span><span><span>    <span>CONTROL_SCALE</span><span>,</span>
</span></span><span><span>    <span>CONTROL_CORNER_RADIUS</span><span>,</span>
</span></span><span><span>    <span>CONTROL_ROTATE_CAMERA</span><span>,</span>
</span></span><span><span>    <span>CONTROL_BLOB_AMOUNT</span><span>,</span>
</span></span><span><span><span>}</span> <span>Control</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>Control</span> <span>focused_control</span><span>;</span>
</span></span><span><span><span>Control</span> <span>mouse_action</span><span>;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>This project didn’t need dynamic arrays or hashmaps, but if it had, I would’ve used something like <a href="https://danielchasehooper.com/posts/shapeup/www.sdf.com">stb_ds.h</a>.</p><h3 id="aside-wrestling-raylib">Aside: Wrestling Raylib</h3><p>So while I feel good about deciding to use C, raylib turned out to be trouble. First off, it has strange design choices that harm the developer experience:</p><ul><li><p>Raylib uses <code>int</code> everywhere that you would expect an enum type. This prevents the compiler from type checking and the functions don’t self document. Take this line in raylib’s header for example:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>// Check if a gesture have been detected
</span></span></span><span><span><span></span><span>RLAPI</span> <span>bool</span> <span>IsGestureDetected</span><span>(</span><span>unsigned</span> <span>int</span> <span>gesture</span><span>);</span>    
</span></span></code></pre></td></tr></tbody></table></div></div><p>It looks like <code>gesture</code> might be an ID for a gesture you’ve registered for. Reading the raylib source reveals that <code>gesture</code> parameter is actually a <code>Gesture</code> enum! This happens everywhere. Raylib’s only documentation is the header file, so you have to go to the implementation to see if any <code>int</code> parameter is really an enum, and if it is, <em>which</em> enum.</p></li><li><p>Raylib doesn’t do basic parameter validation, <a href="https://github.com/raysan5/raylib/issues/3365#issuecomment-1743827668" target="_blank" rel="noopener">by design</a>. This function segfaults when dataSize is null:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>unsigned</span> <span>char</span> <span>*</span><span>LoadFileData</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>fileName</span><span>,</span> <span>int</span> <span>*</span><span>dataSize</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>The raylib header doesn’t indicate that dataSize is an out parameter, or that it must not be null. This no-validation choice affects many functions and made trivial problems hard to track down. If you’re lucky it segfaults somewhere useful (but it doesn’t log an error). If you’re unlucky it just silently does something weird.</p></li><li><p>Raylib doesn’t take responsibility for its dependencies. There are issues in GLFW that raylib won’t work around or submit a patch for. As an end user of raylib, the method they chose to create a window is an invisible implementation detail. I care about raylib’s features working for me, regardless of what that means internally.</p></li></ul><p>The raygui UI library is just a toy:</p><ul><li>can’t display floating point numbers. I had to make a float text field.</li><li>doesn’t handle mouse event routing for overlapping or clipped elements</li><li>can’t do rounded corners, which are everywhere in UIs.</li><li>can’t be styled to look good</li></ul><p>And finally just plain bugs:</p><ul><li>raygui tooling had a bug that prevented changing the font from the hyper-stylized default (please pick a reasonable default!)</li><li>Drawing functions like <code>DrawCircle(...)</code> don’t share vertices between triangles. That causes pixel gaps due to floating point error when the current matrix has scaling or rotation.</li></ul><p>For a while I reported issues as I found them, but almost all of them them were closed as “wont fix”. This was frustrating and discouraging, and it was time consuming to write the bug reports, so I just stopped.</p><p>So yeah, while it was great that raylib made me an OpenGL window, I paid dearly for that convenience. Luckily I usually found an escape hatch: either by using OpenGL functions directly, or implementing a feature from scratch. In the future I’ll go with <a href="https://github.com/floooh/sokol" target="_blank" rel="noopener">sokol</a>.</p><h2 id="in-a-week">In a Week</h2><p>At a high level, ShapeUp came down to 4 main parts that needed to be completed in 6 days:</p><ol><li>The user interface (3D gizmos, keyboard shortcuts, sidebar, game controller)</li><li>GLSL shader generator + Ray marching renderer (<a href="https://youtu.be/-Xb3Kk3HhIw?si=GvNTl31sHP0L2yey&amp;t=58" target="_blank" rel="noopener">explained in video</a>)</li><li>GPU-based mouse selection (<a href="https://youtu.be/-Xb3Kk3HhIw?si=epq9opaS74rgcJSL&amp;t=149" target="_blank" rel="noopener">explained in video</a>)</li><li>Marching cubes for export (<a href="https://youtu.be/-Xb3Kk3HhIw?si=UWTZE9hZKTW7yRbY&amp;t=172" target="_blank" rel="noopener">explained in video</a>)</li></ol><p>Each one individually was not hard. The hard thing was prioritizing correctly and not <a href="https://www.youtube.com/watch?v=AbSehcT19u0" target="_blank" rel="noopener">getting sidetracked</a>. It helped to solve finicky or time consuming problems by designing around them, or by using a dumb solution that works in 90% of cases. Sometimes punting a feature by a day gave my subconscious time to find a solution.</p><p>I tried to work in such a way that I always had a working 3D modeler, and progressively improved it as time allowed. I think about it like building a pyramid. If you build layer by layer, you don’t have a pyramid until the very end. On the other hand you can build it so that stopping at any step is a complete pyramid.</p><p><a href="https://danielchasehooper.com/posts/shapeup/Pyramid.png" title="Two ways to build a pyramid, in flat layers or as progressively bigger pyramids"><img src="https://danielchasehooper.com/posts/shapeup/Pyramid_hu023cf4e44e1a4c03b239c35c3afc4f1d_9722_534x0_resize_box_3.png" srcset="/posts/shapeup/Pyramid_hu023cf4e44e1a4c03b239c35c3afc4f1d_9722_534x0_resize_box_3.png 3x, /posts/shapeup/Pyramid_hu023cf4e44e1a4c03b239c35c3afc4f1d_9722_534x0_resize_box_3.png 2x, /posts/shapeup/Pyramid_hu023cf4e44e1a4c03b239c35c3afc4f1d_9722_534x0_resize_box_3.png 1x" alt="Two ways to build a pyramid, in flat layers or as progressively bigger pyramids"/></a></p><h2 id="closing">Closing</h2><p>By the end of the week I had a 3D program that could make meaningful 3D models and export them to an .obj file. It also runs on multiple platforms and has file open/save.</p><p><a href="https://danielchasehooper.com/posts/shapeup/wrench.png" title="a model of a wrench in ShapeUp"><img src="https://danielchasehooper.com/posts/shapeup/wrench_huc2d7734d2a9a96e05815e68917714e79_52979_700x0_resize_box_3.png" srcset="/posts/shapeup/wrench_huc2d7734d2a9a96e05815e68917714e79_52979_761x0_resize_box_3.png 3x, /posts/shapeup/wrench_huc2d7734d2a9a96e05815e68917714e79_52979_761x0_resize_box_3.png 2x, /posts/shapeup/wrench_huc2d7734d2a9a96e05815e68917714e79_52979_700x0_resize_box_3.png 1x" alt="a model of a wrench in ShapeUp"/>
</a>A Wrench Modeled in ShapeUp</p><p>The project is 2024 lines of C and 250 lines GLSL. Kind of surprising that a somewhat useful 3D modeler can be expressed in ~2300 lines.</p><p>I was fortunate enough to be asked to demo ShapeUp in the <a href="https://youtu.be/BuYoXfPZ6cI?si=NPHplwABaAB1HJ7p&amp;t=104" target="_blank" rel="noopener">jam recap</a>, and again at the Handmade Seattle conference, which had a <a href="https://vimeo.com/889290506/e5a560faba" target="_blank" rel="noopener">Q&amp;A portion</a>.</p><p>People seemed impressed by ShapeUp but I don’t feel like I achieved much. It’s a relatively simple project. If there is anything special about what I did, it is that I had the taste to choose what to make, the knowledge to make it, and the discipline to do it in a week.</p><p>You can try <a href="https://danielchasehooper.com/projects/shapeup">ShapeUp in your browser</a>, just keep in mind it was made in a week :)</p><p>The source code is <a href="https://github.com/danielchasehooper/ShapeUp-public" target="_blank" rel="noopener">avalible on github</a></p><p>Discuss on <a href="https://twitter.com/DanielcHooper/status/1786068396745937190" target="_blank" rel="noopener">Twitter</a></p></div></div>
  </body>
</html>
