<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ownyourbits.com/2018/06/13/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt_misc/">Original</a>
    <h1>Transparently running binaries from any architecture in Linux (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
		

<p>What? you can do that in Linux? It turns out you can!</p>
<p>First, let’s see it in action. Here I retrieve a binary from my Raspberry Pi which is an ARM binary and execute it in my <em>x86_64</em> machine transparently.</p>
<p><img loading="lazy" src="https://ownyourbits.com/wp-content/uploads/2018/05/arm-echo.gif" alt="" width="820" height="548"/></p>
<p>If you try to do this… it won’t work right away.</p>
<pre>$ ./echo
zsh: exec format error: ./echo</pre>
<p>First we have a couple things to set up. We will be using <a href="http://qemu.org">QEMU</a> in a slightly unconventional way in a combination with a kernel feature called <em>binfmt_misc</em>.</p>

<h4>QEMU user mode</h4>

<p>Obviously our CPU is not able to run foreign machine code instructions. We said we would be using QEMU, but in a slightly unconventional way.</p>
<p>We all know QEMU as a virtual machine, where we load a virtual (fake) hard drive with an operating system and we setup fake hardware to interface with it: a fake CPU, fake keyboard, fake network adapter and so on. This look like this</p>
<p><img loading="lazy" src="https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu.png" alt="" width="302" height="260" srcset="https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu.png 1763w, https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu-300x259.png 300w, https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu-768x662.png 768w, https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu-700x604.png 700w" sizes="(max-width: 302px) 100vw, 302px"/></p>
<p>But there is also another <em>mode</em> of use in QEMU, called <em>user emulation</em>.</p>
<p>When we write a program, we interact with the system through <a href="https://en.wikipedia.org/wiki/System_call"><em>system calls</em></a>. We need to do this in order to interact with the keyboard, terminal, screen, filesystem and so on. This means that when we execute a program, the code that we write is executed in <em>user space</em>, and then the kernel does the interacting with the system part for us. We just request things from the kernel such as writing to a file.</p>
<p>In QEMU <em>system emulation</em> this looks like this</p>
<p><img loading="lazy" src="https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system.png" alt="" width="304" height="261" srcset="https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system.png 1761w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system-300x257.png 300w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system-768x659.png 768w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system-700x601.png 700w" sizes="(max-width: 304px) 100vw, 304px"/></p>
<p>In <em>user mode</em>, QEMU doesn’t emulate all the hardware, only the CPU.  It executes foreign code in the emulated CPU, and then it captures the syscalls and  forwards them to the host kernel. This way, we are interfacing the native kernel in the same way as any native piece of software. This looks like this</p>
<p><img loading="lazy" src="https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user.png" alt="" width="298" height="256" srcset="https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user.png 1761w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user-300x257.png 300w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user-768x659.png 768w, https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user-700x601.png 700w" sizes="(max-width: 298px) 100vw, 298px"/></p>
<p>This has many benefits, because we are not emulating all the hardware, which is slow, and also we are not emulating the kernel which is a decent part of the computation that takes place. Actually we don’t even <em>need</em> a kernel. We can understand now why this runs much faster than full system emulation.</p>
<p>As an example, let’s crosscompile a static ARM binary</p>
<pre title="hello.c">#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    printf(&#34;hello world\n&#34;);
    return 0;
}</pre>
<p>we need to install the toolchain to crosscompile from <em>x86</em> to <em>armhf</em>, for instance</p>
<pre># apt-get install gcc-arm-linux-gnueabihf</pre>
<p>, or in Arch Linux</p>
<pre>$ pacaur -S aur/arm-linux-gnueabihf-gcc</pre>
<p>Then we generate the binary</p>
<pre>$ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static
$ file hello_arm_static
hello_arm_static: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=69ff53a55d64975f87b9ea3543d26bcbae31de9f, with debug_info, not stripped</pre>
<p>Now we can run it with <em>qemu-arm</em>. We need to install the package <em>qemu-user</em></p>
<pre># apt-get install qemu-user</pre>
<p>, and now we can run</p>
<pre>$ qemu-arm hello_arm_static
hello world</pre>
<p>This isn’t yet very useful because most programs are <em>dynamically linked</em>. We still have some work to do.</p>

<h4>Running ARM executables transparently</h4>

<p>Recall from the <a href="https://ownyourbits.com/2018/05/23/the-real-power-of-linux-executables/">last post</a> on Linux executables what happens when we execute a file and how we can use <em>binfmt_misc</em> to set up our own interpreters. Now we have all the pieces and we want to put them together. We need to setup <em>binfmt_misc</em> in order to use QEMU user mode as an interpreter for our <em>binary format</em>.</p>
<p>We can do it ourselves manually, or install the<em> qemu-user-binfmt</em> package, normally installed automatically with<em> qemu-user</em>. We end up with the<em> binfmt_misc</em> entries</p>
<pre>ls -l /proc/sys/fs/binfmt_misc
total 0
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-aarch64
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-alpha
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-arm
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-armeb
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-cris
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-m68k
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-microblaze
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-mips
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-mipsel
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc64
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc64abi32
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-s390x
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sh4
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sh4eb
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc32plus
-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc64
--w------- 1 root root 0 Jun  7 11:36 register
-rw-r--r-- 1 root root 0 Jun  7 11:36 status</pre>
<p>Now we can substitute</p>
<pre>$ qemu_arm hello_arm_static
hello world</pre>
<p>for</p>
<pre>$ ./hello_arm_static
hello world</pre>
<p>, because we have an active entry in <em>binfmt_misc</em></p>
<pre>$ cat /proc/sys/fs/binfmt_misc/qemu-arm
enabled
interpreter /usr/bin/qemu-arm-static
flags: OC
offset 0
magic 7f454c4601010100000000000000000002002800
mask ffffffffffffff00fffffffffffffffffeffffff</pre>
<p>The kernel recognizes the ARM <a href="http://man7.org/linux/man-pages/man5/elf.5.html">ELF magic</a>, and uses the interpreter <span>/usr/bin/qemu-arm-static</span> , which is the correct QEMU binary for the architecture. <span>0x7F ‘ELF’</span>  in hexadecimal is <span>7f 45 4c 46</span>, so we can see how the magic and the mask work together, considering the structure of the ELF header</p>
<pre>typedef struct {
    unsigned char e_ident[EI_NIDENT];   /* 0x7F &#39;ELF&#39; four byte ELF magic for any architecture */
    uint16_t e_type;
    uint16_t e_machine;                 /* architecture code, 40=0x28 in the case of ARM */
    uint32_t e_version;
    ElfN_Addr e_entry;
    ElfN_Off e_phoff;
    ElfN_Off e_shoff;
    uint32_t e_flags;
    uint16_t e_ehsize;
    uint16_t e_phentsize;
    uint16_t e_phnum;
    uint16_t e_shentsize;
    uint16_t e_shnum;
    uint16_t e_shstrndx;
} ElfN_Ehdr;</pre>
<p>At the end of the day, we want our code to tell the kernel to print <em>hello world. </em>Let’s compare the kernel interactions of the real</p>
<pre>$ strace ./hello_static 2&gt;&amp;1 | grep -e execve -e readlink -e write
execve(&#34;./hello_static&#34;, [&#34;./hello_static&#34;], 0x7ffd3d83b2b0 /* 41 vars */) = 0
readlink(&#34;/proc/self/exe&#34;, &#34;/home/nacho/srctest/hello_static&#34;, 4096) = 32
write(1, &#34;hello world\n&#34;, 12hello world</pre>
<p>and the emulated code</p>
<pre>$ strace ./hello_arm_static 2&gt;&amp;1 | grep -e execve -e readlink -e write
execve(&#34;./hello_arm_static&#34;, [&#34;./hello_arm_static&#34;], 0x7ffd4b19b5c0 /* 41 vars */) = 0
readlink(&#34;/proc/self/exe&#34;, &#34;/usr/bin/qemu-arm-static&#34;, 4096) = 24
write(1, &#34;hello world\n&#34;, 12hello world</pre>
<p>The <em>execve()</em> syscall is the same, and the <em>write()  </em>call too so we get the same behaviour. We can also see that a read to <em>/proc/self/exe</em> reveals that the binary being run natively is in fact <em>qemu-arm-static</em>, the interpreter.<em><br/>
</em></p>
<p>Again, most of the work is being done natively by the kernel, so this actually runs much faster than in QEMU full emulation because the part of the kernel execution would need to be emulated too, as well as the virtual hardware. It is also much easier to setup.<em><br/>
</em></p>
<p>This is still not <em>that</em> useful yet, because very few programs are statically linked. Let’s create <em>x86</em> and <em>amrhf</em> versions of <em>hello.c</em></p>
<pre>$ gcc hello.c -o hello
$ gcc hello.c -o hello_static -static
$ arm-linux-gnueabihf-gcc hello.c -o hello_arm
$ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static</pre>
<p>ARM binaries take much more space, because being a RISC architecture it has a smaller instruction set and so it needs more machine code to perform many common operations. Code density can be improved by using the <a href="https://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">THUMB instruction set</a>.</p>
<pre>$ dutree
[ crosshello 4.64 MiB ]
├─ hello_arm_static  │          ███████████████████████████████████████████████│  84%      3.91 MiB
├─ hello_static      │                                                   ██████│  15%    724.89 KiB
├─ hello_arm         │                                                         │   0%     15.62 KiB
├─ hello             │                                                         │   0%      8.16 KiB
└─ hello.c           │                                                         │   0%          97 B</pre>
<p>Let’s try this</p>
<pre>$ ./hello_arm
/lib/ld-linux-armhf.so.3: No such file or directory</pre>
<p>Dynamically linked executables provide the path of the runtime linker ( a.k.a ELF interpreter ) hardcoded at compile time.</p>
<pre>$ file hello_arm
hello_arm: ELF 32-bit LSB pie executable ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=2be332452ae4987fa763b6e75c359e08793572aa, with debug_info, not stripped

$ file hello
hello: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d11d6a23094a98009919746b13a1c064450aa944, not stripped
</pre>
<p>So the code fails because it cannot find the linker that it requires <em>/lib/ld-linux-armhf.so.3</em>. This normally comes with the cross-toolchain.</p>
<p>We <em>could </em>be tempted to do something really dirty like</p>
<pre># ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3</pre>
<p>We would need to do this not only for <em>ld-linux-armhf.so</em>, but also for <em>libc.so </em> and everything else our binary might need, and we don’t want to have a mix of libraries of different architectures in the same place, right?</p>
<p>We can tell QEMU where to look for the linker and libraries with</p>
<pre>$ qemu-arm -L /usr/arm-linux-gnueabihf hello_arm
hello world</pre>
<p>but we want <em>transparent</em> execution, so we can add this to <em>.bashrc </em>or <em>.zshrc</em></p>
<pre>export QEMU_LD_PREFIX=/usr/arm-linux-gnueabihf</pre>
<p>, or configure it system wide at <em>/etc/qemu-binfmt.conf</em></p>
<pre title="/etc/qemu-binfmt.conf">EXTRA_OPTS=&#34;-L /usr/arm-linux-gnueabihf&#34;</pre>
<p>Now it works transparently!</p>
<pre>$ ./hello_arm
hello world</pre>
<p>This is still not <em>that</em> useful. The reason is that we now need to have a copy of all the ARM libraries required by our ARM binaries.</p>
<p>Our example works because everything <em>hello.c</em> needs is so basic that comes with the toolchain.</p>
<pre>$ ldd hello
linux-vdso.so.1 (0x00007ffd71ab5000)
libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f536fe48000)
/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5370406000)</pre>
<p>The situation is not too bad in Debian, where you can install libraries from other architectures, for instance</p>
<pre># apt-get install libstdc++6:armhf</pre>

<h4>Emulating full ARM rootfs</h4>

<p>Most often in real situations we need to work in the final system where the binary is supposed to run. It makes more sense to have the whole ARM environment with its ARM libraries and all. Enter <a href="https://en.wikipedia.org/wiki/Chroot">chroot</a>.</p>
<p>chroot, for <em>change root</em> is a <a href="https://linux.die.net/man/2/chroot">system call</a> and corresponding command wrapper that changes the root directory location of a process and its children. Given a directory with a different root filesystem, we can execute anything in it so that their <em>view</em> of the filesystem has been moved to the new root directory. For this reason it is often called a <em>chroot jail</em>. This is the predecessor of filesystem namespaces, a key component that makes containers possible.</p>
<p>As an example, let’s execute <em>echo</em> inside an x86 jail. I have prepared a whole Debian filesystem in <span>new_root_folder</span> .</p>
<pre># chroot new_root_folder /bin/echo &#34;hello world&#34;
hello world</pre>
<p>This <em>echo</em>, or whatever  binary we run does not see anything outside of the jail. It is impossible for instance to remove or read a file outside of the new root folder.</p>
<p>We can get an existing ARM rootfs to work with, or we can generate one. In Debian we can use <a href="https://wiki.debian.org/Debootstrap"><em>debootstrap</em></a> with the <span>–arch</span>  switch to generate a Stretch ARM rootfs.</p>
<pre>$ debootstrap --arch=armhf stretch new_root_folder</pre>
<p>What we want to do now is to use chroot to make the binaries inside the jail view the filesystem just like they expect it. By using chroot we already have <em>/etc</em>, <em>/bin</em> and all the regular folders in place. Next, we need to add the virtual filesystems</p>
<pre># mount -t proc proc     new_root_folder/proc/
# mount -t sysfs sys     new_root_folder/sys/
# mount -o bind /dev     new_root_folder/dev/
# mount -o bind /dev/pts new_root_folder/dev/pts</pre>
<p>Finally, we will copy the <em>qemu-user-static</em> binary inside the ARM filesystem.</p>
<pre># cp /usr/bin/qemu-arm-static new_root_folder/usr/bin</pre>
<p>This little intruder will be the only x86 binary in an ARM filesystem, he’s surrounded!</p>
<p>We have everything in place! What will happen when we try to execute some ARM executable from the jail?</p>
<ul>
<li>The chroot command will call <em>execve()</em> on the ARM binary</li>
<li>The ARM binary will be handled by the <em>binfmt_misc</em> binary handler, according to its configured ARM ELF magic.</li>
<li>The entry in <em>binfmt_misc</em> instructs the kernel to use <em>/usr/bin/qemu-arm-static</em> as an interpreter, that is why we had to copy it inside the jail. Remember that by chroot magic /usr/bin is really inside <em>new_root_folder</em>.</li>
<li><em>qemu-arm-static</em> will interpret the ARM binary in user mode. We are using the <em>static</em> version of qemu-arm because we need the interpreter to be standalone, as it is the only x86 binary in the jail and will not have access to any x86 libraries.</li>
<li>Any ARM library that is expected by the programs inside the jail will be there, as provided by the ARM rootfs.</li>
</ul>
<p>Let’s see all this in action, opening a <em>bash</em> shell in a Raspbian rootfs</p>
<p><img loading="lazy" src="https://ownyourbits.com/wp-content/uploads/2018/06/qemu-chroot2.gif" alt="" width="1076" height="650"/></p>
<p>I had to configure the PATH variable to match the one Raspbian expects. Naturally, our original environment from <em>zsh</em> will be inherited by <em>chroot</em> and <em>arm-bash</em>. We have talked about full system <a href="https://ownyourbits.com/2017/02/06/raspbian-on-qemu-with-network-access/">QEMU Raspbian emulation</a> before, and this runs so much faster.</p>
<p>Things will work as long as the ARM binaries see what they expect to see. Binaries can <em>execve()</em> other executables and everything will mostly work perfectly well. An exception would be programs that use exotic system calls that QEMU user mode still has not implemented yet, for instance for using the pseudo random generator. As QEMU user mode becomes more mature, it is getting more strange to see this happen and normally libraries have fallback options for these situations anyway. In those cases you will see something like</p>
<pre>qemu: Unsupported syscall: 384</pre>
<p>Remember that we are still using our host kernel, so we can use networking, install packages with <em>apt</em> and all the rest. This is really useful for things like</p>
<ul>
<li>Manipulating rootfs images for other architectures transparently from our x86 workstation.</li>
<li>Compiling ARM binaries more easily. Cross-compiling is hard because you need to isolate the libraries and tools that the cross-compiling environment needs with the ones from your workstation. One way of saving some headaches is to emulate native compiling instead of cross compiling. You host can then help <em>natively </em>by setting up a <a href="https://en.wikipedia.org/wiki/Distcc"><em>distcc</em></a> system between jail and host.</li>
</ul>

	</div></div>
  </body>
</html>
