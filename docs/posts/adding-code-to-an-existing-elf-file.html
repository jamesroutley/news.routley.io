<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dropbear.sh/blog/elf-patching.html">Original</a>
    <h1>Adding code to an existing ELF file</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            <p>
                Recently I was reverse-engineering an Android
                app<sup>[<a id="footnote-a-ref" href="#footnote-a">a</a>]</sup>. The relevant details are as follows:
            </p>
            <ul>
                <li>Important stuff is handled in JNI shared objects</li>
                <li>Java component is UI/platform glue code</li>
                <li>The source language for the shared objects is C++</li>
            </ul>
            <p>
                My goal was to dump a buffer I found that contained some data,
                and I was able to write a Python/GDB script to do just that. This worked fine on an (x86_64) emulator,
                but I faced a problem when I finally got ahold of an Android device: Python/GDB is <i>very</i> slow on
                hardware, especially when you&#39;re writing to disk at each breakpoint invocation.
            </p>
            <p>So what&#39;s a gal to do with a laggy debugger and an app that crashes if it gets too far behind?</p>
            <p>Translate her Python script to AArch64 assembly and patch it into the app, of course!</p>
            <p>
                Because I had reverse-engineered the x86_64 binary and not the AArch64 one, I had to find the right
                registers to pull my buffer data from again. I also had to learn how to read (and write) ARMv8-A
                assembly. Thankfully, ARM is both a RISC and load-store architecture, so it was fairly easy to pick up
                on. I had a patch written fairly quickly<sup>[<a id="footnote-b-ref" href="#footnote-b">b</a>]</sup>.
            </p>
            <p>Applying it was another matter. My first attempt went as follows:</p>
            <ul>
                <li>Assemble my patch and dump the <code>.text</code> (code) section</li>
                <li>Use <code>objcopy</code> to append the patch to the end of the <code>.text</code> section</li>
                <li>Modify an instruction at the right address to jump to my code</li>
                <li>(Repackage APK, etc.)</li>
            </ul>
            <p>
                This prevented the app from being able to load the ELF file, because it would attempt to access a string
                in <code>.rodata</code> and would instead pull a different string.
            </p>
            <p>
                As it turns out, you can&#39;t just stick code to the end of the <code>.text</code> section,
                because relative addressing to later sections would be broken (and in this and most ELF files,
                <code>.data</code>, <code>.rodata</code>, <code>.bss</code>, etc. are all stored after
                <code>.text</code>.) In order to get this to work, I would have to find and modify every single
                relative address in the binary. Alternatively, I could try to somehow add my code <i>after</i> those
                sections. I decided on the latter, for what I&#39;m sure are obvious reasons.
            </p>
            <p>Time for a tour of the ELF format! (For simplicity, I&#39;ll be focusing on 64-bit ELF files.)</p>
            <p>
                An ELF file has &#34;segments&#34; and &#34;sections&#34;. The program header table contains segments, which hold
                runtime info and map out sections into memory segments. The section header table contains
                section descriptions, which map out the file contents. In order to add in our patch, we&#39;d have to add it
                to the file, and map it to a section. Then, we&#39;d have to map that section to a segment.
            </p>
            <p>
                Adding a section is easy, because the section header table is stored at the end of this file (by no
                means is this a requirement). The contents of this new section should just be the <code>.text</code>
                section of the compiled patch. However, we do need to make sure to set some flags so it&#39;s executable:
            </p>
            <pre><code>as patch.s -o patch.o
objcopy patch.o --dump-section .text=patch.text
objcopy file.so --add-section .patch=patch.text --set-section-flags .patch=code,readonly,alloc patch.out</code></pre>
            <p>
                Now we need to map this new <code>.patch</code> section to a segment. Sections are mapped to segments by
                checking what sections are in the segment&#39;s chunk of the file. Unfortunately, the program header is
                stored immediately after the ELF file header itself. This means we&#39;ll have to commandeer an existing
                segment header.
            </p>
            <p>Here is the program header of the ELF file I&#39;m working with:</p>
            <pre><code>Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000589c18 0x0000000000589c18  R E    0x1000
  LOAD           0x000000000058a530 0x000000000058b530 0x000000000058b530
                 0x000000000003a418 0x000000000003c268  RW     0x1000
  DYNAMIC        0x00000000005ba368 0x00000000005bb368 0x00000000005bb368
                 0x0000000000000320 0x0000000000000320  RW     0x8
  NOTE           0x0000000000000200 0x0000000000000200 0x0000000000000200
                 0x0000000000000024 0x0000000000000024  R      0x4
  NOTE           0x0000000000589b80 0x0000000000589b80 0x0000000000589b80
                 0x0000000000000098 0x0000000000000098  R      0x4
  GNU_EH_FRAME   0x0000000000509244 0x0000000000509244 0x0000000000509244
                 0x000000000000f97c 0x000000000000f97c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x000000000058a530 0x000000000058b530 0x000000000058b530
                 0x0000000000038ad0 0x0000000000038ad0  R      0x1</code></pre>
            <p>Each segment has a type, which describes what it stores. These are the ones in the file:</p>
            <ul>
                <li><code>LOAD</code> segments should be loaded/mapped into memory. All other
                    segments are not<sup>[<a id="footnote-c-ref" href="#footnote-c">c</a>]</sup>.</li>
                <li><code>DYNAMIC</code> segments contain dynamic linking information.</li>
                <li>
                    <code>NOTE</code> segments contain, you guessed it, notes about the file. The GNU linker uses
                    certain <code>.note</code> sections to get information about the file.
                </li>
                <li><code>GNU_EH_FRAME</code> contains exception unwinding information.</li>
                <li>
                    <code>GNU_STACK</code> tells the kernel how to handle the stack (e.g. if it needs to be executable).
                </li>
                <li><code>GNU_RELRO</code> marks sections that should be made read-only after being loaded.</li>
            </ul>
            <p>
                A <code>NOTE</code> segment is the best (read: only) choice we can make here, but how do we choose which
                one?
            </p>
            <pre><code> Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame_hdr .eh_frame .gcc_except_table .note.android.ident
   01     .init_array .fini_array .data.rel.ro .dynamic .got .data cfstring .bss
   02     .dynamic
   03     .note.gnu.build-id
   04     .note.android.ident
   05     .eh_frame_hdr
   06
   07     .init_array .fini_array .data.rel.ro .dynamic .got</code></pre>
            <p>
                <code>.note.gnu.build-id</code> seems the safest bet here, as that&#39;s only used to provide a unique
                identifier for the binary. So my new process was:
            </p>
            <ul>
                <li>Assemble my patch and dump the <code>.text</code> section</li>
                <li>
                    Create a new section, <code>.patch</code>, in the target ELF file with the dumped <code>.text</code>
                    section
                </li>
                <li>
                    Modify the first <code>NOTE</code> segment to be a <code>LOAD</code> segment and point it to the
                    <code>.patch</code> section
                </li>
                <li>
                    Modify the <code>.bss</code> section and its containing segment to be 8 bytes larger, so the patch
                    can store its state there.
                </li>
                <li>Modify an instruction at the right address to jump to my code</li>
                <li>(Repackage APK, etc.)</li>
            </ul>
            <p>
                Modifying the segment header is the meat of this process. Here is the segment header definition, from
                <code>elf(5)</code>:
            </p>
            <pre><code><span>// typedef uint64_t Elf64_Off</span>
<span>// typedef uint64_t Elf64_Addr</span>
<span>typedef</span> <span>struct</span> {
    <span>uint32_t</span>   p_type;
    <span>uint32_t</span>   p_flags;
    <span>Elf64_Off</span>  p_offset;
    <span>Elf64_Addr</span> p_vaddr;
    <span>Elf64_Addr</span> p_paddr;
    <span>uint64_t</span>   p_filesz;
    <span>uint64_t</span>   p_memsz;
    <span>uint64_t</span>   p_align;
} Elf64_Phdr;</code></pre>
            <ul>
                <li>
                    <code>p_type</code> is the type of segment. This should be set to <code>PT_LOAD</code>, which is
                    <code>1</code>.
                </li>
                <li>
                    <code>p_flags</code> holds RWX flags for the segment. This should be set to <code>5</code> (R+X).
                </li>
                <li>
                    <code>p_offset</code> is the start of the segment in the file. <code>objcopy</code> always adds the
                    new section at <code>0x5d0000</code>, so that&#39;s what we&#39;ll set this to.
                </li>
                <li>
                    <code>p_vaddr</code> is where the segment should be mapped to in process memory. Because the second
                    <code>LOAD</code> segment has a <code>p_memsz</code> larger than its <code>p_filesz</code>, we set
                    this to <code>0x5e0000</code> to be safe.
                </li>
                <li><code>p_paddr</code> is used for physical addressing, which is irrelevant here.</li>
                <li>
                    <code>p_filesz</code> describes the size of the segment in the file, which in this case is the size
                    of the patch.
                </li>
                <li>
                    <code>p_memsz</code> describes how much memory this segment needs, which is again the size of the
                    patch.
                </li>
                <li>
                    <code>p_align</code> is the alignment this segment needs. It&#39;s stored as a power of two. We just
                    copy from the first <code>LOAD</code> segment and set this to <code>1</code>.
                </li>
            </ul>
            <p>
                One problem: as far as I can tell, <code>objcopy</code> doesn&#39;t support modifying the program table. In
                order to solve this problem and avoid modifying it by hand, I wrote
                <a href="https://dropbear.sh/code/modelf.c">a small C program</a> capable of doing so.
            </p>
            <p>My final build script looks like this:</p>
            <pre><code><span>#!/usr/bin/bash</span>
as patch.s -o patch.o
objcopy patch.o --dump-section .text=patch.text
objcopy file.so --add-section .patch=patch.text --set-section-flags .patch=code,readonly,alloc patch.out
./modelf patch.out                          \
    --segment 3                             \
        --type   1                          \
        --offset 0x5d0000                   \
        --vaddr  0x5e0000                   \
        --paddr  0x5e0000                   \
        --filesz $(stat -c &#39;%s&#39; patch.text) \
        --memsz  $(stat -c &#39;%s&#39; patch.text) \
        --align  1                          \
        --flags  0x5                        \
    --section 26                            \
        --addr 0x5e0000                     \
    --segment 1                             \
        --memsz 0x3c270                     \
    --section 24                            \
        --size 0x1e50
./patch-binary.sh modelf-out.elf patchfile.pf</code></pre>
            <p>
                And there you have it! This method produces a working, patched shared object ready to be loaded by the
                Android app.
            </p>
            <p>
                If the ELF file didn&#39;t happen to have a spare <code>NOTE</code> segment, I would have needed to do
                something much uglier. I plan on experimenting with adding new segments in the future.
            </p>
            <!-- footnotes -->
            
            
            
            
<!--            <pre><code><span class="mc">#include <stdio.h></span>

<span class="kw">int</span> <span class="ufn">main</span>(<span class="kw">void</span>) {
    <span class="fn">printf</span>(<span class="str">"%s\n"</span>, <span class="str">"Hello, world!"</span>);
    <span class="kw">return</span> <span class="num">0</span>;
}</code></pre> -->
        </div></div>
  </body>
</html>
