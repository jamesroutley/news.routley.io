<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://underjord.io/unpacking-elixir-syntax.html">Original</a>
    <h1>Unpacking Elixir: Syntax</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <small>2023-09-01</small>
        <p>Elixir is a language with syntactical roots in Ruby. It also carries the Erlang legacy. Legacy used here as in “a great legacy” and not as in “system you don’t like anymore”. Ruby is an object-oriented language. Elixir is functional language. The Erlang part has an impact as Elixir was designed to provide strong interoperability with Erlang. Like Ruby and Erlang, Elixir offers a high-level of abstraction and is a very dynamic language. Overall I would say the Elixir syntax is pretty approachable and reasonable to learn. Let’s unpack it.</p>
<p>This is another piece of my series on “Unpacking Elixir”. The previously published part was on <a href="https://underjord.io/unpacking-elixir-concurrency.html">concurrency</a>.</p>
<p>My background is Python so I wasn’t familiar with Ruby before-hand and ran into all these Ruby-isms with some confusion. Overall it was still a pretty smooth ride for me. I had done PHP, Javascript, Python, some C/C++, C#. It is a slightly new style but it didn’t scare me.</p>
<p>The thing that many people will probably find unnecessary coming from C-style languages or find very verbose coming from Python is how a block is defined:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>do</span>
  <span># block contents go here</span>
<span>end</span>

<span>if</span> foo? <span>do</span>
	<span># true</span>
<span>else</span>
    <span># false</span>
<span>end</span>

<span>def</span> my_function(arg1) <span>do</span>
  <span># function body</span>
<span>end</span></code></pre></div>
  </div>

<p>It is fair to note that <code>end</code>  has a lot more characters than <code>}</code> but I do think it comes across as more human. A less dense and symbol-filled syntax could be argued to be more approachable and potentially less noisy. I don’t particularly care either way.</p>
<p>Let’s write a basic module:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>defmodule</span> <span>MyModule.SampleThing</span> <span>do</span>
	<span>@moduledoc</span> <span>&#34;&#34;&#34;
</span><span>	This is module documentation. Typically written as Markdown.
</span><span>	&#34;&#34;&#34;</span>
	
	<span># compile-time attribute, define-style</span>
	<span>@my_attribute</span> <span>1000</span>
	
	<span>@doc</span> <span>&#34;&#34;&#34;
</span><span>	This is function documentation.
</span><span>	&#34;&#34;&#34;</span>
	<span>def</span> public_function(arg1, arg2) <span>do</span>
	  <span># do thing</span>
	  new_arg <span>=</span> arg1 <span>+</span> arg2
	  <span># return the last thing done</span>
	  new_arg <span>+</span> <span>2</span>
	<span>end</span>

    <span># private function with an optional default argument</span>
	<span>defp</span> private_function(arg1, arg2 \\ <span>5</span>) <span>do</span>
	  <span># do something</span>
	<span>end</span>

	<span>defp</span> short_function(x), <span>do</span>: x <span>+</span> <span>1</span>
	<span>defp</span> no_args, <span>do</span>: <span>1</span>
<span>end</span></code></pre></div>
  </div>

<p>Modules are Pascal case. Functions, module attributes and bindings of values (variable names) are snake_case. Docstrings are multi-line text strings and also compile-time attributes. ExDoc can make very nice documentation with these. Both types of docs can also contain doctests which are a nice way of making simple tests, testing your sample code in the docs and encouraging code samples in the documentation.</p>
<p>Any do/end block can be replaced with <code>, do:</code>  for one-liners. If a function takes no args you can skip the parentheses. Functions return the value of the last expression. There is no early return without branching and you do not make the return explicit.</p>
<p>Quickly some values and types:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir">integer <span>=</span> <span>1</span>
float <span>=</span> <span>1.0</span>
boolean <span>=</span> <span>true</span> <span># true and false are both atoms</span>
null_value <span>=</span> <span>nil</span> <span># nil is also an atom</span>
atom <span>=</span> <span>:foo</span> <span># aside from true/false/nil you reference atoms with a colon :</span>
string <span>=</span> <span>&#34;lawik&#34;</span>
binary <span>=</span> &lt;&lt;<span>108</span>, <span>97</span>, <span>119</span>, <span>105</span>, <span>107</span>&gt;&gt; <span># equivalent to string above</span>

tuple <span>=</span> {<span>:ok</span>, <span>5</span>} <span># multiple values grouped, not limited to two</span>
list <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>]
map_of_strings <span>=</span> %{<span>&#34;username&#34;</span> <span>=&gt;</span> <span>&#34;lawik&#34;</span>, <span>&#34;site&#34;</span> <span>=&gt;</span> <span>&#34;underjord.io&#34;</span>}
map_of_atoms <span>=</span> %{<span>username</span>: <span>&#34;lawik&#34;</span>, <span>site</span>: <span>&#34;underjord.io&#34;</span>}
map_of_atoms_without_sugar <span>=</span> %{<span>:username</span> <span>=&gt;</span> <span>&#34;lawik&#34;</span>, <span>:site</span> <span>=&gt;</span> <span>&#34;underjord.io&#34;</span>} <span># Removing the syntactic sugar for colons</span>
struct <span>=</span> %<span>MyStruct</span>{<span>username</span>: <span>&#34;lawik&#34;</span>, <span>site</span>: <span>&#34;underjord.io&#34;</span>} <span># very special map</span>

<span># erlang compatibility</span>
keyword_list <span>=</span> [<span>username</span>: <span>&#34;lawik&#34;</span>, <span>site</span>: <span>&#34;underjord.io&#34;</span>] <span># the old-school Erlang map, but syntatically sugared</span>
same_but_in_lists_and_tuples <span>=</span> [{<span>:username</span>, <span>&#34;lawik&#34;</span>}, {<span>:site</span>, <span>&#34;underjord.io&#34;</span>}] <span># free from syntactic sugar</span>
charlist <span>=</span> <span>&#39;lawik&#39;</span> <span># the old-school Erlang string</span>
charlist_in_lists_and_numbers <span>=</span> [<span>108</span>, <span>97</span>, <span>119</span>, <span>105</span>, <span>107</span>]</code></pre></div>
  </div>

<p>Interesting sugar around these types.</p>
<p>Strings are binaries that fit within the constraints of a UTF-8-encoded binary. String and binary concatenation is <code>&#34;foo&#34; &lt;&gt; &#34;bar&#34;</code>. String interpolation is <code>&#34;Hello #{name} and welcome.&#34;</code> where <code>name</code> is a value or expression that converts to a string through a particular Protocol.</p>
<p>Lists have a syntax convenience for prepending. <code>new_list = [ new_value | old_list ]</code> will do it. It will return when we talk pattern matching. Lists are implemented as linked lists (not ideal, it is known) so appending is much less performant. List concatenation is <code>a ++ b</code> . Most operations are found in either the <code>List</code> or <code>Enum</code> modules.</p>
<p>Maps have a syntax convenience for updating an existing field. <code>new_map = %{ old_map | atom_key: new_value}</code> makes for a pretty simple process. Also works for structs. Overall map operations live in the <code>Map</code>  and <code>Enum</code> modules.</p>
<p>Keyword lists are very common in Erlang for options. Elixir added some nice sugar for that purpose. A list of tuples can be created with <code>[key1: 5, key2: 6]</code> and when calling a function which takes options as a Keyword list as the last argument you can drop into what feels like a python kwargs situation: <code>my_function(&#34;regular value&#34;, force: true, timeout: 553)</code> No double splat to speak of though.</p>
<p>Pipes are kind of neat:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>defmodule</span> <span>MyModule.Pipage</span> <span>do</span>
  <span>def</span> new <span>do</span>
    %{}
  <span>end</span>

  <span>def</span> add_defaults(thing) <span>do</span>
    thing
    <span>|&gt;</span> <span>Map</span><span>.</span>put(<span>:timeout</span>, <span>5000</span>)
    <span>|&gt;</span> <span>Map</span><span>.</span>put(<span>:weather</span>, <span>&#34;rainy&#34;</span>)
  <span>end</span>

  <span>def</span> set_name(thing, name) <span>do</span>
    <span>Map</span><span>.</span>put(thing, <span>:name</span>, name)
  <span>end</span>

  <span>def</span> do_all_of_it <span>do</span>
    new()
    <span>|&gt;</span> add_defaults()
    <span>|&gt;</span> set_name(<span>&#34;lawik&#34;</span>)
  <span>end</span>
<span>end</span></code></pre></div>
  </div>

<p>So pipes allow passing a value through and changing it. They don’t deal with failure or anything like that but in functional life there are many cases where this just becomes much more readable. Not that there is only one type of pipe <code>|&gt;</code> and it feeds the output into the first argument of the next function. This worked nicely for my brain. It will upset many established FP folks that want all kind of pipes and arrows. I also know there is some history with piping to the last position and I know Elm does it that way. I think this is more approachable but it might be the Python <code>self</code> OOP bleeding through rather than what humans expect as a general rule.</p>
<p>Let’s make an example that is more scripting-oriented and uses the Elixir standard library.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>&#34;~&#34;</span>
<span>|&gt;</span> <span>Path</span><span>.</span>expand()
<span>|&gt;</span> <span>Path</span><span>.</span>join(<span>&#34;.config/my_app&#34;</span>)
<span>|&gt;</span> <span>File</span><span>.</span>mkdir_p!()
<span>|&gt;</span> <span>File</span><span>.</span>ls!()</code></pre></div>
  </div>

<p>This shows one of two interesting conventions for Elixir function names. The <code>!</code> at the end of a function indicates a function that will raise an error on failure. Usually they have a sibling function without the bang that will return a tuple of <code>{:ok, result}</code> or <code>{:error, reason}</code>. The other one is <code>?</code> at the end of a function to indicate it typically provides a boolean result. This is not enforced, it is only a convention.</p>
<p>Why these result tuples? We don’t have static typing and Result types, monads or what have you in Elixir. The ok/error tuple is a convention from Erlang and is essentially an informal Result type. Elixir didn’t upend the convention which means interop with Erlang code feels normal.</p>
<p>The way they are generally used is with pattern matching. To extract the value and throw a MatchError if it does not you can use a bare pattern match inline in a function.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir">{<span>:ok</span>, status} <span>=</span> <span>File</span><span>.</span>stat(my_path)</code></pre></div>
  </div>

<p>Or you can do a case statement:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>case</span> <span>File</span><span>.</span>stat(my_path) <span>do</span>
  {<span>:ok</span>, %{<span>type</span>: <span>:directory</span>}} <span>-&gt;</span> <span># do thing</span>
  {<span>:ok</span>, _unused} <span>-&gt;</span> <span># do other thing</span>
  {<span>:error</span>, <span>:enoent</span>} <span>-&gt;</span> <span># specific error</span>
  _ <span>-&gt;</span> <span># any other result</span>
<span>end</span></code></pre></div>
  </div>

<p>You can also do nice things using the <code>if</code> macro, the <code>with</code> statement and a bunch of other things. I won’t attempt to cover all the syntax. The <code>for</code> macro comprehension thing is wildly feature-filled. One very nice place to use pattern matching is in function heads. Elixir supports overloading of a sort.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>defmodule</span> <span>MyApp.MyModule</span> <span>do</span>
	<span>def</span> eat_value(<span>nil</span>) <span>do</span>
		{<span>:error</span>, <span>:hates_nil</span>}
	<span>end</span>

	<span>def</span> eat_value(%{<span>style</span>: <span>:tasty</span>}), <span>do</span>: {<span>:ok</span>, <span>:tasty</span>}
	<span>def</span> eat_value(%{<span>flavor</span>: any_flavor}), <span>do</span>: {<span>:ok</span>, any_flavor}

	<span>def</span> eat_value(%{} <span>=</span> any_map_or_struct) <span>do</span>
		{<span>:ok</span>, <span>:tasted_fine</span>}
	<span>end</span>

	<span>def</span> eat_value([first_value, <span>|</span> _rest_of_list]) <span>do</span>
		{<span>:ok</span>, first_value}
	<span>end</span>

	<span>def</span> eat_value(num) <span>when</span> is_integer(num) <span>or</span> is_float(num) <span>do</span>
		{<span>:ok</span>, <span>&#34;I will consider it a </span><span>#{</span>num<span>}</span><span>.&#34;</span>}
	<span>end</span>

    <span># Convention dictates _ to ignore a value in a match</span>
	<span>def</span> eat_value(_), <span>do</span>: {<span>:ok</span>, <span>:nothing_special</span>}
<span>end</span></code></pre></div>
  </div>

<p>This fundamentally compiles down to a case statement in a single function and if none of the cases match it will raise a specific error. You can also apply guards for numeric ranges and such. This example has matching for; Specific value <code>nil</code>. Value of a key in a map. Value of a key in a map to a binding and using it later. Head of a list.</p>
<p>The <code>with is_integer(..</code> stuff is a guard clause. It also shows the convention of <code>_</code> marking unused bindings, either with a name like <code>_bla</code> or just the plain <code>_</code>.</p>
<p>Anonymous/lambda functions are an important thing in most functional programming and we certainly have those.</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span># We can bind an existing function to a value with this syntax</span>
referenced_function <span>=</span> <span>&amp;</span><span>File</span><span>.</span>stat<span>/</span><span>1</span>

<span># Anonymous function, full syntax</span>
anon <span>=</span> <span>fn</span> arg1, arg2 <span>-&gt;</span>
	arg1 <span>+</span> arg2
<span>end</span>

<span># Anonymous function, short syntax</span>
anon <span>=</span> <span>&amp;</span> &amp;1 <span>+</span> &amp;2

<span># Anonymous function, multiple clauses</span>
anon <span>=</span> <span>fn</span>
  {<span>:ok</span>, result} <span>-&gt;</span> result <span>+</span> <span>5</span>
  {<span>:error</span>, reason} <span>-&gt;</span> {<span>:error</span>, <span>:bad</span>, reason}
  other <span>-&gt;</span> other
<span>end</span>

<span># Calling an anonymous function</span>
anon<span>.</span>(my_first_arg)</code></pre></div>
  </div>

<p>These are commonly used in pipelines for things like the very important Enum module:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>File</span><span>.</span>ls!()
<span>|&gt;</span> <span>Enum</span><span>.</span>map(<span>fn</span> filename <span>-&gt;</span>
  <span>Path</span><span>.</span>join(my_path, filename)
<span>end</span>)</code></pre></div>
  </div>

<p>Something that is not Elixir syntax so much as something you run into using libraries within Elixir are macros and DSLs (domain-specific-languages) built from macros. Elixir does not allow a ton of hiding things in normal code. The code is explicit and mostly goes in a straight line. To avoid some things becoming very unwieldy, such as the Phoenix web framework’s routing and the Ecto database library’s schema/migration definitions they have built small sets of macros that generate the relevant functions for you. This is one of few places where I find things often feel a bit woo-woo and magical. But it is almost exlusively where the alternative would be worse, either for a technical reason or for a human reason.</p>
<p>So when you run into things that don’t feel like normal Elixir code. Odds are you are dealing with macros. They can define custom blocks and they can define custom keywords that are mostly like functions but actually expanded at compile-time.</p>
<p>Example of an Ecto database schema:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>defmodule</span> <span>MyApp.MyUser</span> <span>do</span>
	<span>use</span> <span>Ecto.Schema</span>

	schema <span>&#34;users&#34;</span> <span>do</span>
		field <span>:username</span>, <span>:string</span>
		field <span>:password</span>, <span>:string</span>, <span>redact</span>: <span>true</span>
		timestamps()
	<span>end</span>
<span>end</span></code></pre></div>
  </div>

<p>This generates a model with everything the database layer needs to know about the schema. Your <code>MyApp.MyUser</code> module will have a <code>__schema__()</code> function. <code>use Ecto.Schema</code> is what brings that magic into your module and your subsequent calls to the macro <code>schema</code>, <code>field</code> and <code>timestamps</code> do the rest.</p>
<p>This brings us to one thing that is a bit messy but learnable. <code>alias</code>, <code>import</code>, <code>require</code> and <code>use</code>. This is <a href="https://elixir-lang.org/getting-started/alias-require-and-import.html">also covered in the official guide</a> which is where I learned Elixir mostly.</p>
<ul>
<li><code>alias</code> shortens the name of a module or lets you change the name you use for a module.</li>
<li><code>require</code> makes macros available from a particular function.</li>
<li><code>import</code> brings in functions AND macros.</li>
<li><code>use</code> lets the specific module inject any code functions through macro madness.</li>
</ul>
<p>Erlang interop deserves a mention. Both Elixir and Erlang module and function names are atoms. <code>MyApp.MyUser</code> is actually syntactic sugar for <code>:Elixir.MyApp.MyUser</code> which is just an atom. So Erlang interop looks like this:</p>

  <div>
    <p><span>elixir</span>
      
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>:erlang_module_name</span><span>.</span>function_name(arg1, arg2)
<span># OR actual example</span>
im <span>=</span> <span>:egd</span><span>.</span>create(<span>200</span>, <span>200</span>)</code></pre></div>
  </div>

<p>This is already a bunch so I will end it. I have not covered all syntax in the language but I think I’ve given it a fair shake. I hope this is beneficial to you if you are curious to try the language or figure out if it is something you might enjoy.</p>
<hr/>
<p>If you have questions, comments or concerns you can reach me by my email at <a href="mailto:lars@underjord.io">lars@underjord.io</a> or on the socials <a href="https://twitter.com/lawik">@lawik</a>.</p>

        <p>Note: If you like my writing you might appreciate my videos. Give them a go over on <a href="https://youtube.com/c/underjord">the YouTube
                channel</a>.</p>
    </article></div>
  </body>
</html>
