<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://deno.com/blog/building-deno-kv">Original</a>
    <h1>Deno KV internals: building a database for the modern web</h1>
    
    <div id="readability-page-1" class="page"><div><p>Deno is designed to streamline web and cloud development with
<a href="https://deno.land/manual/tools" rel="noopener noreferrer">built-in modern tools</a>,
<a href="https://deno.land/manual/runtime/web_platform_apis" rel="noopener noreferrer">direct access to web platform APIs</a>,
and <a href="https://deno.land/manual/node" rel="noopener noreferrer">the capability to import modules via npm</a>.
Web apps very often require some persistent application state. Setting up a
database involves numerous configuration steps and the subsequent integration of
an ORM or other systems.</p>
<p>What if you could access such a database without any preliminary setup? This is
what <a href="https://deno.com/kv" rel="noopener noreferrer">Deno KV</a> allows you to do:</p>
<figure>

<div><pre><span>const</span> kv <span>=</span> <span>await</span> <span>Deno</span><span>.</span><span>openKv</span><span>(</span><span>)</span><span>;</span>
<span>const</span> userId <span>=</span> crypto<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>
<span>await</span> kv<span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;users&#34;</span><span>,</span> userId<span>]</span><span>,</span> <span>{</span> userId<span>,</span> name<span>:</span> <span>&#34;Alice&#34;</span> <span>}</span><span>)</span><span>;</span></pre></div></figure>

<h2 id="why-build-deno-kv"><a aria-hidden="true" tabindex="-1" href="#why-build-deno-kv"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why build Deno KV?</h2><p>The Deno runtime doesn’t just run on your local machine in the form of the
<code>deno</code> executable, but also on our <a href="https://deno.com/deploy" rel="noopener noreferrer">Deno Deploy</a> cloud platform which
allows you to deploy your Deno apps to many regions around the world. This
global deployment minimizes latency between your users and your app’s compute,
which can be a huge performance boost for your app.</p>
<p>We knew that we wanted to build a database for Deno, because of a very simple
problem we heard from many customers: unless your app’s data is also globally
distributed, you won’t be able to make use the performance benefits you get by
distributing your compute.</p>
<p>Additionally, because the Deno runtime is designed to run either locally in a
single instance scenario, or globally in a multi-instance scenario, any API we
introduce for one of the two scenarios should also work great in the other. This
makes it easy to develop and test your app locally, and then deploy it globally
without having to change your code or add any configuration.</p>
<p>This led us to a few design goals for Deno KV:</p>
<ul>
<li><strong>Scalable</strong>: a distributed database that can handle large volumes of data
with high throughput</li>
<li><strong>Highly performant</strong>: minimal high latency round-trips between compute and
database to minimize impact of network latency</li>
<li><strong>JavaScript-native</strong>: a database that’s designed to be used from JavaScript
and TypeScript, with an API that natively uses JavaScript types</li>
<li><strong>Atomic transactions</strong>: a database that provides atomic operations to ensure
data integrity and enable complex application logic</li>
<li><strong>Works seamlessly locally and globally</strong>: a database that works great in both
single-instance and multi-instance scenarios</li>
</ul>
<p>So, we set out to build two versions of the Deno KV system, with the same
user-facing API. A version of Deno KV for local development and testing, built
on SQLite, and a distributed systems version for use in production (especially
on Deno Deploy). This post is about the implementation of the production,
distributed systems version of Deno KV. If you’re interested in the SQLite
implementation of Deno KV, you can read the source code yourself
<a href="https://github.com/denoland/deno/blob/main/ext/kv/sqlite.rs" rel="noopener noreferrer">as it is open source</a>.</p>
<h2 id="foundationdb-scalable-distributed-flexible-and-production-ready"><a aria-hidden="true" tabindex="-1" href="#foundationdb-scalable-distributed-flexible-and-production-ready"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FoundationDB: scalable, distributed, flexible, and production-ready</h2><p>We chose to build Deno KV atop of
<a href="https://github.com/apple/foundationdb" rel="noopener noreferrer">FoundationDB</a>, Apple’s open source
distributed database used in iCloud and by Snowflake, since it’s perfect for
building scalable database solutions: it’s
<a href="https://apple.github.io/foundationdb/testing.html" rel="noopener noreferrer">thoroughly verified</a> with
deterministic simulation,
<a href="https://apple.github.io/foundationdb/performance.html" rel="noopener noreferrer">scalable and efficient</a>,
and provides the transactional key-value storage API.</p>
<p>While FoundationDB provides the necessary mechanisms of a robust distributed
database, there’s still several challenges when turning that into a seamless
JavaScript-native experience that works within our Deno Deploy platform:</p>
<ul>
<li>Deno KV is multi-tenant not only in data but also in configuration. Different
users have different replication setups, backup policies, and throughput
quotas. FoundationDB does not have native mechanisms to handle this.</li>
<li>We want Deno KV to be fully JavaScript-native and use JavaScript types. For
example, Deno KV can store signed varints (bigint), and we want to support an
atomic sum operation on these, but FoundationDB itself does not support atomic
sums on varints.</li>
<li>To minimize potential for unbounded latency between compute and data, the Deno
KV API is designed around non-interactive transactions (i.e. atomic
operations), while FoundationDB provides optimistic interactive transactions.
Even though possible, there is unnecessary overhead when implementing the Deno
KV API on top of FoundationDB.</li>
</ul>
<p>These constraints led us to design a new system ontop of a FoundationDB that we
call the “transaction layer”. It performs transaction processing and cross
region data repliation in a distributed way, while still delegating the
difficult aspects of a distributed database to FoundationDB: sharding,
synchronous replication within a cluster, ensuring serializable and linearizable
processing of transactions, and storing data durably.</p>
<figure>

<p><img src="https://deno.com/blog/building-deno-kv/transaction-layer-diagram.png" alt="Deno Deploy Transaction Layer that interfaces between Deno Deploy isolates and FoundationDB" title=""/></p>
<figcaption>Each Deno KV command from Deno Deploy is processed and optimized in our Transaction Layer before its committed to FoundationDB</figcaption>

</figure>

<p>Let’s dive into how we designed our transaction layer for atomicity, minimal
latency, and high concurrency.</p>
<h2 id="atomic-operations-with-minimal-network-requests"><a aria-hidden="true" tabindex="-1" href="#atomic-operations-with-minimal-network-requests"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Atomic operations with minimal network requests</h2><p><a href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)" rel="noopener noreferrer">Atomic operations</a>,
usually <em>interactive transactions</em>, as in they require multiple requests to the
database to guarantee atomicity.</p>
<figure>

<p><img src="https://deno.com/blog/building-deno-kv/interactive-atomic-operation.png" alt="Interactive atomic operation" title=""/></p>
</figure>

<p>However, for a globally distributed database, interactive transactions are
costly. If a write operation requires several trips between the compute server
and a database region, then a web app performing multiple write operations could
experience high network latency.</p>
<figure>

<p><img src="https://deno.com/blog/building-deno-kv/non-interactive-atomic-operation.png" alt="Non-interactive atomic operation in global Deno KV" title=""/></p>
</figure>

<p>To minimize latency, we designed global Deno KV to be <em>non-interactive</em> — all
transactions should complete within one or two network trips. We’ve done so by
enclosing all atomic writes into a “bag” of conditions, write commands, and
conflict-free mutations:</p>
<ul>
<li>Condition: to guarantee atomicity, we check the
<a href="https://deno.land/manual/runtime/kv/key_space#versionstamp" rel="noopener noreferrer"><code>versionstamp</code></a>
of the key. If it’s false at the time the operation is executed, the entire
operation is discarded</li>
<li>Write command: any
<a href="https://deno.land/manual/runtime/kv/operations#set" rel="noopener noreferrer"><code>.set()</code></a> or
<a href="https://deno.land/manual/runtime/kv/operations#delete" rel="noopener noreferrer"><code>.delete()</code></a> operation
on a key</li>
<li>Conflict-free mutation: any function that takes the old value of the key and
returns a new value. For example, the mutation type
<a href="https://deno.land/manual/runtime/kv/operations#sum" rel="noopener noreferrer"><code>.sum()</code></a> adds the
provided operand to the old value</li>
</ul>
<p>To create this “bag”, Deno KV requires all atomic operations to be chained
following
<a href="https://deno.land/api?s=Deno.Kv&amp;unstable=&amp;p=prototype.atomic" rel="noopener noreferrer"><code>.atomic()</code></a>:</p>
<figure>

<div><pre><span>const</span> kv <span>=</span> <span>await</span> <span>Deno</span><span>.</span><span>openKv</span><span>(</span><span>)</span><span>;</span>
<span>const</span> change <span>=</span> <span>10</span><span>;</span>

<span>const</span> bob <span>=</span> <span>await</span> kv<span>.</span><span>get</span><span>(</span><span>[</span><span>&#34;balance&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>)</span><span>;</span>
<span>const</span> liz <span>=</span> <span>await</span> kv<span>.</span><span>get</span><span>(</span><span>[</span><span>&#34;balance&#34;</span><span>,</span> <span>&#34;liz&#34;</span><span>]</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>bob<span>.</span><span>value</span> <span>&lt;</span> change<span>)</span> <span>{</span>
  <span>throw</span> <span>&#34;not enough balance&#34;</span><span>;</span>
<span>}</span>

<span>const</span> success <span>=</span> <span>await</span> kv<span>.</span><span>atomic</span><span>(</span><span>)</span>
  <span>.</span><span>check</span><span>(</span>bob<span>,</span> liz<span>)</span> 
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;balance&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>,</span> bob<span>.</span><span>value</span> <span>-</span> change<span>)</span>
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;balance&#34;</span><span>,</span> <span>&#34;liz&#34;</span><span>]</span><span>,</span> liz<span>.</span><span>value</span> <span>+</span> change<span>)</span>
  <span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span></pre></div></figure>

<p>This API design for atomic operations ensures minimal trips between compute and
database for optimum performance.</p>
<h2 id="building-on-top-of-foundationdbs-lock-free-system"><a aria-hidden="true" tabindex="-1" href="#building-on-top-of-foundationdbs-lock-free-system"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building on top of FoundationDB’s lock-free system</h2><p><a href="https://medium.com/inspiredbrilliance/what-are-database-locks-1aff9117c290" rel="noopener noreferrer">“Locks”</a>
in databases are mechanisms to ensure data integrity. These mechanisms only let
one transaction modify or access data. In contrast, a <em>lock-free system</em> allows
concurrent processes to access and modify data, providing parallelism and
scalability without sacrificing data integrity.</p>
<p>Despite FoundationDB using a lock-free design, simply delegating the
conflict-check mechanism to FoundationDB would lead to latency issues,
especially if the atomic operation performs a conflict-free mutation that cannot
be pushed down to a primitive of the underlying database.</p>
<figure>

<div><pre><span>await</span> kv<span>.</span><span>atomic</span><span>(</span><span>)</span><span>.</span><span>sum</span><span>(</span><span>[</span><span>&#34;visitor_count&#34;</span><span>]</span><span>,</span> <span>1n</span><span>)</span><span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span></pre></div><figcaption>This atomic operation cannot be pushed down because FoundationDB
does not natively understand variable size interger types, like JS bigints, so
does not implement any conflict-free mutation operation for that type.</figcaption>

</figure>

<p>To maximize performance and concurrency for atomic operations, we built the Deno
KV <em>Transaction Layer</em> that manages the <em>global</em> order of atomic operations. For
each transaction that is received by this <em>Transaction Layer</em>:</p>
<ol>
<li>The transaction is assigned a Transaction Sequence Number (“TSN”), a
monotonic integer whose order is equivalent to the linearized order of atomic
operations, by a <strong>sequencer</strong></li>
<li>The transaction is batched with other transactions, from which the
<strong>evaluator</strong> constructs a graph that describes the relations between all
conditions, write commands, and conflict-free mutations. The <strong>evaluator</strong>
then processes the graph with maximum concurrency until the value of every
graph node is known.</li>
<li>The transaction is finally committed to FoundationDB by the <strong>writer</strong></li>
</ol>
<p>The <strong>sequencer</strong>, <strong>evaluator</strong>, and <strong>writer</strong> are distinct components that
work together to process high volumes of operations. But how do we squeeze out
even more performance from this pipeline?</p>
<h2 id="faster-operations-with-speculative-execution"><a aria-hidden="true" tabindex="-1" href="#faster-operations-with-speculative-execution"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Faster operations with speculative execution</h2><p><a href="https://en.wikipedia.org/wiki/Speculative_execution" rel="noopener noreferrer">Speculative execution</a> is
a technique for maximizing instruction processing throughput where some work is
done that might not be needed.</p>
<p>Deno KV’s <em>Transaction Layer</em> uses this technique, where transactions are
assigned a global order in a centralized way, but processed out-of-order
elsewhere. Outputs of transactions are then used speculatively in future
transactions before they are durable on disk. The effect of a transaction is
only visible externally after it’s been committed to FoundationDB.</p>
<p>The core data structure of this mechanism is the “Transaction Reorder Buffer”,
which manages the flow of transactions to process:</p>
<figure>

<p><img src="https://deno.com/blog/building-deno-kv/transaction-reorder-buffer.png" alt="Transaction Reorder Buffer" title=""/></p>
<figcaption>The numbers above indicate Transaction Sequence Numbers and the
column beneath each represents a single operation received by Transaction Layer.</figcaption>

</figure>

<p>The sequencer is responsible for issuing monotonic integers that are continuous
within an epoch. While being a singleton for every KV database, sequencing is a
very cheap operation since it’s just an increment on an in-memory atomic
counter. The sequencer also only needs to wait for the previous sequencer to be
committed (green).</p>
<p>The evaluator processes transactions in batches. In each batch, the evaluator
constructs a “data flow subgraph” that describes the relations between all
conditions, write commands, and conflict-free mutations. It’s a graph of
operations that determine whether the transactions succeed or fail, and the
operations final values. The evaluator then processes the subgraph with maximum
concurrency until the value of every graph node is known.</p>
<p>To better illustrate this data flow subgraph, which enables high concurrency in
a lock-free system, let’s look at an example:</p>
<div><pre>

<span>await</span> kv
  <span>.</span><span>atomic</span><span>(</span><span>)</span>
  <span>.</span><span>check</span><span>(</span><span>{</span> key<span>:</span> <span>[</span><span>&#34;users&#34;</span><span>,</span> <span>UID1</span><span>]</span><span>,</span> versionstamp<span>:</span> <span>V1</span> <span>}</span><span>)</span>
  <span>.</span><span>check</span><span>(</span><span>{</span> key<span>:</span> <span>[</span><span>&#34;user_by_login&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>,</span> versionstamp<span>:</span> <span>null</span> <span>}</span><span>)</span>
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;users&#34;</span><span>,</span> <span>UID1</span><span>]</span><span>,</span> user1<span>)</span>
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;user_by_login&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>,</span> <span>UID1</span><span>)</span>
  <span>.</span><span>delete</span><span>(</span><span>[</span><span>&#34;user_by_login&#34;</span><span>,</span> <span>&#34;alice&#34;</span><span>]</span><span>)</span>
  <span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span>


<span>await</span> kv
  <span>.</span><span>atomic</span><span>(</span><span>)</span>
  <span>.</span><span>check</span><span>(</span><span>{</span> key<span>:</span> <span>[</span><span>&#34;user_by_login&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>,</span> versionstamp<span>:</span> <span>null</span> <span>}</span><span>)</span>
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;users&#34;</span><span>,</span> <span>UID2</span><span>]</span><span>,</span> user2<span>)</span>
  <span>.</span><span>set</span><span>(</span><span>[</span><span>&#34;user_by_login&#34;</span><span>,</span> <span>&#34;bob&#34;</span><span>]</span><span>,</span> <span>UID2</span><span>)</span>
  <span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span></pre></div><p>These two operations above are mutually conflicting, so only one can succeed.
Assuming the second operation is assigned a larger TSN than the first, this
would be the data flow subgraph constructed from an evaluator batch containing
these two operations:</p>
<figure>

<p><img src="https://deno.com/blog/building-deno-kv/data-flow-subgraph-example.png" alt="Data flow subgraph example" title=""/></p>
<figcaption>An example of a data flow subgraph, a graph of operations that determine whether the transactions succeed or fail, and the operations final values.</figcaption>

</figure>

<p>This diagram looks bit complicated - let’s walk through it.</p>
<p>The top row (with the two <code>GetMetadata</code> boxes) represents the two <code>.check()</code>
commands from Client 1 (<code>.check({ key: [&#34;users&#34;, UID1], versionstamp: V1 })</code> and
<code>.check({ key: [&#34;user_by_login&#34;, &#34;bob&#34;], versionstamp: null })</code>). They flow into
the horizontal <code>AND</code> line because both checks need to succeed.</p>
<p>The second row from the top (beneath the horizontal <code>AND</code> line) shows three
<code>MUX</code> (aka a
<a href="https://www.electronics-tutorials.ws/combination/comb_2.html" rel="noopener noreferrer">multiplexer logic gate</a>)
operations, which represents Client 1’s <code>.set()</code> and <code>.delete()</code> commands. Above
each <code>MUX</code> gate shows each commands inputs:</p>
<ul>
<li><code>.set([&#34;users&#34;, UID1], user1)</code> -&gt; <code>user1</code> and <code>[pass]</code></li>
<li><code>.set([&#34;users_by_login&#34;, &#34;bob&#34;], UID1)</code> -&gt; <code>UID1</code> and <code>[pass]</code></li>
<li><code>.delete([&#34;user_by_login&#34;, &#34;alice&#34;])</code> -&gt; <code>[delete]</code> and <code>[pass]</code></li>
</ul>
<p>Note that <code>[pass]</code> simply means keep the old value, since those commands have a
single input when <code>MUX</code> gates can accept two inputs.</p>
<p>While the first and third <code>MUX</code> gate output is green (final result), the middle
one is blue (intermediary result). Keep in mind that final result is not a
value; it’s a write function whose input (represented in the diagram by <code>?</code>)
will be evaluated after this graph is created.</p>
<p>So why is there an intermediary result? This is because Client 2’s <code>.check()</code>
needs to assert <code>versionstamp</code> on the shared key <code>[&#34;user_by_login&#34;, &#34;bob&#34;]</code>. In
order to resolve this intermediary result and get to a final result, we use
another <code>MUX</code> gate that takes the intermediary result and the <code>GetMetadata</code> of
<code>[&#34;user_by_login&#34;, &#34;bob&#34;]</code>.</p>
<p>This takes us to the bottom row, where there are two <code>MUX</code> gates representing
Client 2’s <code>.set()</code> commands (<code>.set([&#34;users&#34;, UID2], user2)</code> and
<code>.set([&#34;user_by_login&#34;, &#34;bob&#34;], UID2)</code>). From these gates, we can reach final
results.</p>
<p>After the evaluator creates this data flow subgraph from a batch of operations,
it calculates the results, and buffers them in memory. These in-memory results
are available to use in the next evaluator batches, for more speculative
execution, since the results may not yet be visible in FoundationDB. These
in-memory results will be discarded as the <em>known committed version</em> advances,
or when we know for sure we can read the data from FoundationDB.</p>
<p>Finally, the writer is initiated to persist the mutations. The writer also
processes transactions in batches. In each batch, the writer writes the outcome
of the transactions to the underlying database, and performs various other
tasks, like writing the replication log and
<a href="https://deno.com/blog/kv-open-beta#key-ttl-with-expirein" rel="noopener noreferrer">queuing up keys for expiration</a>.</p>
<p>Using speculative execution with the sequencer-evaluator-writer pipeline helps
maximize concurrency and performance while maintaining data integrity for atomic
operations.</p>
<h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conclusion</h2><p>The development of Deno KV was informed by the needs of modern web development
and the possibilities presented by FoundationDB. Our emphasis has always been on
functionality, scalability, and the seamless integration of JavaScript. By
leveraging FoundationDB’s lock-free system and introducing features like the
transaction layer and speculative execution, we aimed to address both
performance and user experience.</p>
<p>However, technology and needs evolve. While we believe in the foundation and
principles behind Deno KV, we’re also aware of the continuous advancements in
the tech landscape. Our journey with Deno KV is an ongoing one, shaped by both
our vision and the invaluable feedback from our user community.</p>
<p>As we look ahead, we are dedicated to refining Deno KV, responding to emerging
needs, and ensuring its adaptability in a rapidly evolving web and cloud
environment. We welcome all developers to try Deno KV, and more importantly, to
share insights and feedback that can guide its future direction.</p>
</div></div>
  </body>
</html>
