<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jakobmaier.at/posts/flight-simulation/">Original</a>
    <h1>Simple Physics-based Flight Simulation with C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    <h3 id="content" tabindex="-1">Content</h3>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#simulating-a-generic-rigid-body">Simulating a Generic Rigid Body</a></li>
<li><a href="#creating-the-flightmodel">Creating the Flightmodel</a></li>
<li><a href="#controlling-the-aircraft">Controlling the Aircraft</a></li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#sources">Sources</a></li>
</ul>
<h3 id="introduction" tabindex="-1">Introduction</h3>
<p>In this blog post I aim to show you how to create a reasonably realistic flight simulator in C++ from scratch, so no
physics engine needed.</p>
<p>A little disclaimer: I am by no means a physics expert, so take everything you
read here with a grain of salt. What I show here is what I have learnt from reading various books on the subject,
so please do not use this post to create a flight simulator to be used for pilot training. üòâ</p>
<h3 id="simulating-a-generic-rigid-body" tabindex="-1">Simulating a Generic Rigid Body</h3>
<p>Before we can get into programming a flight model we start with creating a generic <a href="https://en.wikipedia.org/wiki/Rigid_body">rigid body</a>.
Rigid bodies are used to simulate real-time physics for objects that do not deform under forces (they are &#39;rigid&#39;).</p>
<p>We would like to have an object that we can apply abitrary forces
to and that then reacts based on its current velocity and angular velocity, as well
as it&#39;s mass and inertia.</p>
<p>One important concept we need to understand is &#39;world coordinates&#39; vs &#39;body coordinates&#39;. World coordinates
are exactly what they sound like, the represent the position of our rigidbody in 3D space. I work with OpenGL,
so for me the Y-coordinate is up, X points to the right and Z is the direction out from the screen. Any
rigidbody will have both a position as well as an orientation. Now the body coordinates are coordinates in reference
to the rigidbody. With body coordinates Y always points up, even if the airplane is rotated in some way.
Body coordinates are very useful for calculating forces and torques, and we will use it to calculate our lift
and drag forces as well as the resulting torque.</p>
<pre><code>class RigidBody {
    private:
        glm::vec3 m_force{}; // world space
        glm::vec3 m_torque{}; // body space

    public:
        float mass = 1.0f;                                  // kg
        glm::vec3 position{};                               // world space
        glm::quat orientation{};                            // world space
        glm::vec3 velocity{};                               // world space, meter/second
        glm::vec3 angular_velocity{};                       // body space, radians/second
        glm::mat3 inertia{}, inverse_inertia{};             // inertia tensor, body space
        bool apply_gravity = true;

        // transform direction from body space to world space
        inline glm::vec3 transform_direction(const glm::vec3&amp; direction) const
        { return orientation * direction; }

        // transform direction from world space to body space
        inline glm::vec3 inverse_transform_direction(const glm::vec3&amp; direction) const
        { return glm::inverse(orientation) * direction;}

        // get velocity and angular velocity in body space
        inline glm::vec3 get_point_velocity(const glm::vec3&amp; point) const
        { return inverse_transform_direction(velocity) + glm::cross(angular_velocity, point); }

        // force and point vectors are in body space
        inline void add_force_at_point(const glm::vec3&amp; force, const glm::vec3&amp; point)
        { m_force += transform_direction(force), m_torque += glm::cross(point, force); }

        // force vector in body space
        inline void add_relative_force(const glm::vec3&amp; force)
        { m_force += transform_direction(force); }

        // integrate using the euler method
        void update(float dt)
        {
            // integrate position
            glm::vec3 acceleration = m_force / mass;
            if (apply_gravity) acceleration.y -= 9.81f;
            velocity += acceleration * dt;
            position += velocity * dt;
            
            // integrate orientation
            angular_velocity += inverse_inertia *
                (m_torque - glm::cross(angular_velocity, inertia * angular_velocity)) * dt;
            orientation += (rotation * glm::quat(0.0f, angular_velocity)) * (0.5f * dt);
            orientation = glm::normalize(rotation);

            // reset accumulators
            m_force = glm::vec3(0.0f), m_torque = glm::vec3(0.0f);
        }
};
</code></pre>
<p>You can find the code <a href="https://github.com/gue-ni/OpenGL_Flightsim/blob/b9e736643ca55c330095a13cc914c43df81c0516/OpenGL_Flightsim/phi.h#L197">here</a>.</p>
<h3 id="creating-the-flightmodel" tabindex="-1">Creating the Flightmodel</h3>
<p>We simulate our aircraft by splitting it up in a number of aerodynamic
surfaces, which we will call wings for simplicity, but they can also be control surfaces, the fuselage or even the landing gear.</p>
<p>After calculating the forces from the lift and drag one these surfaces as well as the thrust of the engine are then applied to our rigid body:</p>
<pre><code>struct Airplane {
    Engine engine;
    std::vector&lt;Wing&gt; elements;
    RigidBody rigid_body;

    void update(float dt)
    {
        engine.apply_force(rigid_body);

        for (auto&amp; wing : elements)
        {
            wing.apply_force(rigid_body);
        }

        rigid_body.update(dt);
    }
};
</code></pre>
<p>Wings create lift and drag depending on the speed of the air over them as well as the angle between the wing and the air flow. This angle is called &#39;angle of attack&#39; or &#39;alpha&#39;.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Airfoil_lift_and_drag.svg/520px-Airfoil_lift_and_drag.svg.png" alt=""/></p>
<p>The lift and drag force are calculated using these formulas:</p>
<p><img src="https://latex.codecogs.com/svg.image?F_%7BL%7D%20=%20%7B%5Ctfrac%20%7B1%7D%7B2%7D%7D%20%5Crho%20%20v%5E%7B2%7D%20C_%7BL%7D%20A" alt="Lift"/></p>
<p><img src="https://latex.codecogs.com/svg.image?F_%7BD%7D%20=%20%7B%5Ctfrac%20%7B1%7D%7B2%7D%7D%20%5Crho%20%20v%5E%7B2%7D%20C_%7BD%7D%20A" alt="Drag"/></p>
<p><img src="https://latex.codecogs.com/svg.image?F_%7Btotal%7D%20=%20F_%7BD%7D%20+%20F_%7BC%7D" alt="Total force"/></p>
<p>Where v is the velocity, A is the wing area, œÅ is the air pressure and Cl/Cd are the coefficients of lift and drag.</p>
<p>Coefficient of lift and coefficient of drag depend on the shape (airfoil) of the wing and the angle of attack. Data on standard airfoils is available online, I got the data from <a href="http://airfoiltools.com">airfoiltools.com</a>. As you can see, we sample these coefficients in <code>Wing</code> from <code>airfoil</code>.</p>
<pre><code>struct Wing {
    const float area;
    const glm::vec3 position; // offset from the center of gravity
    const glm::vec3 normal; // points &#39;upwards&#39; relative to the wing
    const Airfoil *airfoil;
    float deflection = 0.0f;
    
    Wing(const glm::vec3&amp; position, float area, const Airfoil* airfoil, 
        const glm::vec3&amp; normal = phi::UP)
        : position(position), area(area), airfoil(airfoil), normal(normal)
    {}

    void apply_force(RigidBody &amp;rigid_body) const
    {
        glm::vec3 local_velocity = rigid_body.get_point_velocity(position);
        float speed = glm::length(local_velocity);

        if (speed &lt;= 0.0f)
            return;

        // drag acts in the opposite direction of velocity
        glm::vec3 drag_direction = glm::normalize(-local_velocity);
        
        // lift is always perpendicular to drag
        glm::vec3 lift_direction
            = glm::normalize(glm::cross(glm::cross(drag_direction, normal), drag_direction));

        // angle between wing and air flow
        float angle_of_attack = glm::degrees(std::asin(glm::dot(drag_direction, normal)));

        // sample our aerodynamic data
        auto [lift_coefficient, drag_coefficient] = airfoil-&gt;sample(angle_of_attack);

        float tmp = 0.5f * rho * speed * speed * area;
        glm::vec3 lift = lift_direction * lift_coefficient * tmp;
        glm::vec3 drag = drag_direction * drag_coefficient * tmp;

        // apply forces
        rigid_body.add_force_at_point(drag + lift, position);
    }
};
</code></pre>
<p>To get our aerodynamic coefficients we simply sample from the array of data points we got from <a href="http://airfoiltools.com/polar/details?polar=xf-n0012-il-1000000">airfoiltools</a>:</p>
<pre><code>// NACA 0012: alpha, Cl, Cd
std::vector&lt;glm::vec3&gt; NACA_0012 = {
    {-18.500f, -1.2258f, 0.10236f},
    ...
    {18.500f, 1.2284f, 0.10229f}
};

struct Airfoil
{
    const float min_alpha, max_alpha;
    std::vector&lt;glm::vec3&gt; data;

    Airfoil(const std::vector&lt;glm::vec3&gt; &amp;curve) : data(curve)
    {
        min_alpha = curve[0].x, max_alpha = curve[curve.size() - 1].x;
    }

    // get Cl and Cd
    std::tuple&lt;float, float&gt; sample(float alpha) const
    {
        int i = static_cast&lt;int&gt;(scale(alpha, min_alpha, max_alpha, 0, data.size() - 1));
        return { data[i].y, data[i].z };
    }
};
</code></pre>
<p>Our airplane of course needs an engine, which we simulate by simply applying a force in the x direction directly to the center of gravity of the aircraft:</p>
<pre><code>struct Engine {
    float throttle = 1.0f, thrust = 10000.0f;
    
    Engine(float engine_thrust) : thrust(engine_thrust) {}
    
    void apply_force(RigidBody &amp;rigid_body)
    {
        // thrust is applied to the center of gravity and does not produce torque
        rigid_body.add_relative_force({throttle * thrust, 0.0f, 0.0f });
        
        // TODO: calculate torque from propellor
        // https://en.wikipedia.org/wiki/Torque#Relationship_between_torque,_power,_and_energy
    }
};
</code></pre>
<h3 id="controlling-the-aircraft" tabindex="-1">Controlling the Aircraft</h3>
<p>Airplanes manouver by deflecting their control surfaces, which then produces differential lift, creating a torque
on the aircraft.</p>
<p>The simplest way of controlling the aircraft is by cheating and applying the torque directly:</p>
<pre><code>struct Airplane {
    Engine engine;
    std::vector&lt;Wing&gt; elements;
    RigidBody rigid_body;
    
    Aircraft(float mass, float thrust, glm::mat3 inertia, std::vector&lt;Wing&gt; wings)
        : elements(wings), rigid_body({ .mass = mass, .inertia = inertia }), engine(thrust)
    {}

    glm::vec3 joystick{0.0f, 0.0f, 0.0f};
    const glm::vec3 max_control_torque{ 500000.0f, 1000.0f, 1000000.0f };

    void update(float dt)
    {
        engine.apply_force(rigid_body);
        
        for (auto&amp; wing : elements)
            wing.apply_force(rigid_body);

        joystick = glm::clamp(joystick, glm::vec3(-1.0f), glm::vec3(1.0f));
        rigid_body.add_relative_torque(joystick * max_control_torque);
        rigid_body.update(dt);
    }
};
</code></pre>
<p>Here <code>joystick</code> is a vector that represents our control input, so between -1.0 and 1.0 for pitch, roll and yaw
respectivly. The <code>max_torque</code> is the max torque that can be created by our control surfaces. This is of
course greatly simplified. In a real aircraft the amount of torque produced by the control surfaces depends, among
other things, on the speed of the aircraft.</p>
<p>If we were to simulate this more accuratly, we would have to calculate our
new wing <code>normal</code>, depending on the deflection of the control surface. To do this, let&#39;s
modify <code>Wing</code>:</p>
<pre><code>    void apply_force(RigidBody &amp;rigid_body) const
    {
        glm::vec3 local_velocity = rigid_body.get_point_velocity(position);
        float speed = glm::length(local_velocity);

        if (speed &lt;= 0.0f)
            return;
            
        glm::vec3 wing_normal = normal;
        
        if (abs(deflection) &gt; 1e-8)
        {
            auto axis = glm::normalize(glm::cross(phi::FORWARD, normal));
            auto rotation = glm::rotate(glm::mat4(1.0f), glm::radians(deflection), axis); 
            wing_normal = glm::vec3(rotation * glm::vec4(normal, 1.0f));
        }

        // drag acts in the opposite direction of velocity
        glm::vec3 drag_direction = glm::normalize(-local_velocity);
        
        // lift is always perpendicular to drag
        glm::vec3 lift_direction
            = glm::normalize(glm::cross(glm::cross(drag_direction, wing_normal), drag_direction));

        // angle between wing and air flow
        float angle_of_attack = glm::degrees(std::asin(glm::dot(drag_direction, wing_normal)));

        // sample our aerodynamic data
        auto [lift_coefficient, drag_coefficient] = airfoil-&gt;sample(angle_of_attack);

        float tmp = 0.5f * rho * speed * speed * area;
        glm::vec3 lift = lift_direction * lift_coefficient * tmp;
        glm::vec3 drag = drag_direction * drag_coefficient * tmp;

        // apply forces
        rigid_body.add_force_at_point(drag + lift, position);
    }
</code></pre>
<p>The full flightmodel code can be found <a href="https://github.com/gue-ni/OpenGL_Flightsim/blob/b9e736643ca55c330095a13cc914c43df81c0516/OpenGL_Flightsim/flightmodel.h#L66">here</a>.</p>
<h3 id="putting-it-all-together" tabindex="-1">Putting it all together</h3>
<p>One  of the hardest parts of doing simulations like this is plugging in the correct values to make it look reasonable.
Messing up the wing positions and area does not make a huge difference, but a wrong inertia tensor quickly makes the simulation
spin out of control. So here is a setup that ended up working for me:</p>
<pre><code>std::vector&lt;Wing&gt; wings = {
    Wing({-0.5f,   0.0f, -2.73f},      24.36f, &amp;naca2412, phi::UP),       // left wing
    Wing({ 0.0f,   0.0f, -2.0f},        8.79f, &amp;naca0012, phi::UP),       // left aileron
    Wing({ 0.0f,   0.0f,  2.0f},        8.79f, &amp;naca0012, phi::UP),       // right aileron
    Wing({-0.5f,   0.0f,  2.73f},      24.36f, &amp;naca2412, phi::UP),       // right wing
    Wing({-6.64f, -0.12f, 0.0f},       17.66f, &amp;naca0012, phi::UP),       // elevator
    Wing({-6.64f,  0.0f,  0.0f},       16.46f, &amp;naca0012, phi::RIGHT),    // rudder
};

glm::mat3 inertia = {
    100000.0f, 0.0f, 0.0f
    0.0f, 500000.0f, 0.0f,
    0.0f, 0.0f, 500000.0f
}; 

Aircraft aircraft(16000.0f, 20000.0f, inertia, wings);

aircraft.rigid_body.position = { 0.0f, 2000.0f, 0.0f };
aircraft.rigid_body.velocity = { phi::units::meter_per_second(600.0f), 0.0f, 0.0f };
</code></pre>
<p>As you can see, the results of our simple flightmodel look quite realistic:</p>
<video controls="" preload="metadata">
  <source src="./img/Flightsim_2023-01-25_20-37-48.mp4#t=0.5" type="video/mp4"/>
</video>
<p>Nevermind the ugly graphics, this is about the flightmodel. Generating pretty terrain is a topic for a future blog post...</p>
<p>The code can be found <a href="https://github.com/gue-ni/OpenGL_Flightsim">here</a>. If you have any suggestions, questions or problems, don&#39;t hesitate to
write me an email or open an issue on github.</p>
<h3 id="sources" tabindex="-1">Sources</h3>
<ul>
<li>Physics for Game Developers (2nd Edition)</li>
<li><a href="https://github.com/brihernandez/SimpleWings">brihernandez/SimpleWings</a></li>
<li><a href="http://airfoiltools.com/">airfoiltools.com</a></li>
<li><a href="https://github.com/idmillington/cyclone-physics">idmillington/cyclone-physics</a></li>
<li><a href="https://aircraftflightmechanics.com/NotesIntroduction.html">Aircraft Flight Mechanics by Harry Smith, PhD</a></li>
</ul>

    
    <p>
      <a href="#top">‚Üë back to top</a>
    </p>
    
  </div>
</div></div>
  </body>
</html>
