<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pjg1.site/gh-workflow-html.html">Original</a>
    <h1>A custom GitHub Actions workflow for static HTML pages</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  
  
  <p>I build files for this website locally and push the static HTML files to GitHub Pages, using the default workflow. At some point, I started noticing that the deploys were taking long to complete. A deploy from today shows that it took 40 seconds to render.</p>
<p>I decided to looked into the workflow itself using <a href="https://cli.github.com">GitHub’s command line tool</a>, and found a job called <code>build</code>, which takes the most time to complete.</p>
<pre><code>$ gh run list --limit 1
STATUS  TITLE              WORKFLOW        BRANCH  EVENT    ID           ELAPSED  AGE
✓       pages build an...  pages-build...  main    dynamic  19118060009  40s      about 50 mi...
$ gh run view 19118060009

✓ main pages-build-deployment · 19118060009
Triggered via dynamic about 50 minutes ago

JOBS
✓ build in 22s (ID 54632038648)
✓ deploy in 8s (ID 54632067818)
✓ report-build-status in 5s (ID 54632067849)
...
</code></pre>
<p>What does <code>build</code> do? It builds the site with <a href="https://jekyllrb.com">Jekyll</a>.</p>
<pre><code>$ gh run view --job=54632038648

✓ main pages-build-deployment · 19118060009
Triggered via dynamic about 50 minutes ago

✓ build in 22s (ID 54632038648)
  ✓ Set up job
  ✓ Pull ghcr.io/actions/jekyll-build-pages:v1.0.13
  ✓ Checkout
  ✓ Build with Jekyll
  ✓ Upload artifact
  ✓ Post Checkout
  ✓ Complete job
</code></pre>
<p>My website doesn’t need to be built by Jekyll, and GitHub provides a <a href="https://github.blog/news-insights/the-library/bypassing-jekyll-on-github-pages/">solution</a> to skip it—to add a file called <code>.nojekyll</code> to the root of the repository.</p>
<p>So I added the file and pushed the changes, and the workflow ran again. This time it took 20 seconds to run, half the time from the last workflow! However, the build step is still there.</p>
<pre><code>$ gh run list --limit 1
STATUS  TITLE              WORKFLOW        BRANCH  EVENT    ID           ELAPSED  AGE
✓       pages build an...  pages-build...  main    dynamic  19118930798  20s      about 9 min...
$ gh run view 19118930798

✓ main pages-build-deployment · 19118930798
Triggered via dynamic about 9 minutes ago

JOBS
✓ build in 4s (ID 54634839639)
✓ report-build-status in 3s (ID 54634846786)
✓ deploy in 8s (ID 54634846814)
...
</code></pre>
<p>I was under the assumption that <code>.nojekyll</code> would remove the build job, but that wasn’t the case. Instead, it only removes one of the steps in the job, that runs Jekyll.</p>
<pre><code>$ gh run view --job=54634839639

✓ main pages-build-deployment · 19118930798
Triggered via dynamic about 9 minutes ago

✓ build in 4s (ID 54634839639)
  ✓ Set up job
  ✓ Checkout
  ✓ Upload artifact
  ✓ Post Checkout
  ✓ Complete job
...
</code></pre>
<p>It feels unnecessary to have to run the <code>build</code> and <code>report-build-status</code> jobs each time, when all I really need is just the <code>deploy</code> job. I wanted to speed this up further.</p>
<p>After some clickity-clakity on the Pages section of the repository settings, I discovered two options for deployment. One is to deploy from a branch, which is the default GitHub Pages workflow. The other is GitHub Actions, which allows for custom workflows.</p>
<p>Clicking on the GitHub Actions option displayed some suggested templates. One of those templates is <a href="https://github.com/actions/starter-workflows/blob/main/pages/static.yml">Static HTML</a>, which sounds like exactly what I’m looking for! Here is an excerpt:</p>
<pre><code>jobs:
  # Single deploy job since we&#39;re just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: &#39;.&#39;
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</code></pre>
<p>In comparison to the GitHub Pages workflow which had three jobs, this has only one called <code>deploy</code>—perfect! I took the template as is and added it to my repository at <code>.github/workflows/</code>. One thing I changed was commenting out the <strong>Setup Pages</strong> step, as I didn’t recall seeing that step in the previous workflows.</p>
<p>I expected a much bigger speedup for the custom workflow run, but it was only a second faster.</p>
<pre><code>$ gh run list --limit 1
✓       *                  Deploy stat...  main    push     19120221474  18s      about 15 mi...
$ gh run view 19120221474

✓ main Deploy static content to Pages · 19120221474
Triggered via push about 15 minutes ago

JOBS
✓ deploy in 14s (ID 54638891569)
...
</code></pre>
<p>Looking closely at the steps, I get a better sense why. The <code>deploy</code> job is now a mix of the <code>build</code> and <code>deploy</code> jobs from the second workflow run (after adding <code>.nojekyll</code>). The number of jobs may have reduced from three to one, but the number of steps are more or less the same.</p>
<p>Combining all steps into one job does reduce some overhead. The original workflow ran a setup and cleanup for each of the three jobs. With one job, the setup and cleanup happens only once, which saves a second or two.</p>
<p>I’ll take a few seconds of speedup as a win.</p>

  </div></div>
  </body>
</html>
