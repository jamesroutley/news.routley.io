<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mill-build.org/blog/7-graal-native-executables.html">Original</a>
    <h1>Compiling Java into native binaries with Graal and Mill</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>At a glance, the difference between the traditional executable assembly
and the Graal native image we built above can be summarized below:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td></td>
<td><p>Executable Assembly</p></td>
<td><p>Native Image</p></td>
</tr>
<tr>
<td><p>Creation Time</p></td>
<td><p>0.8s</p></td>
<td><p>24.7s</p></td>
</tr>
<tr>
<td><p>Executable Size</p></td>
<td><p>2.5mb</p></td>
<td><p>17mb</p></td>
</tr>
<tr>
<td><p>Startup Time</p></td>
<td><p>235ms</p></td>
<td><p>62ms</p></td>
</tr>
<tr>
<td><p>Steady State Performance</p></td>
<td><p>190 iter/s</p></td>
<td><p>180 iter/s</p></td>
</tr>
<tr>
<td><p>Memory Footprint</p></td>
<td><p>373mb</p></td>
<td><p>20mb</p></td>
</tr>
<tr>
<td><p>JVM required to run</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p>OS/CPU-Specific executable</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>The remainder of this section will dive into the details of how each number was measured,
and a discussion of what these changes really mean.</p>
<div>
<h3 id="_creation_time"><a href="#_creation_time"></a>Creation Time</h3>
<p>JVM Executable assemblies are generally very cheap to create, whereas Graal native
image executables can take very long. For this tiny example project, we can see below
that the executable assembly takes about ~1s to create, while the native image takes ~25s:</p>
<p><em>Executable Assembly</em></p>
<div>
<div>
<pre><code data-lang="bash">$ time ./mill show foo.assembly
[1-41] [info] compiling 1 Java source...
&#34;.../out/foo/assembly.dest/out.jar&#34;
./mill show foo.assembly  0.12s user 0.06s system 21% cpu 0.818 total</code></pre>
</div>
</div>
<p><em>Native Image</em></p>
<div>
<div>
<pre><code data-lang="bash">$ time ./mill show foo.nativeImage
[1-50] GraalVM Native Image: Generating &#39;native-executable&#39; (executable)...
...
[1-50] [2/8] Performing analysis...  [****]                                                                     (7.9s @ 0.77GB)
...
[1-50] Finished generating &#39;native-executable&#39; in 26.0s.
&#34;.../out/foo/nativeImage.dest/native-executable&#34;
./mill show foo.nativeImage  0.70s user 1.11s system 7% cpu 24.762 total</code></pre>
</div>
</div>
</div>
<div>
<h3 id="_executable_size"><a href="#_executable_size"></a>Executable Size</h3>
<p>Graal native image binaries are typically larger than the equivalent executable assembly:</p>
<div>
<div>
<pre><code data-lang="bash">$ ls -lh out/foo/assembly.dest/out.jar
-rwxr-xr-x  1 lihaoyi  staff   2.5M Jan 16 15:33 out/foo/assembly.dest/out.jar</code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="bash">$ ls -lh out/foo/nativeImage.dest/native-executable
-rwxr-xr-x  1 lihaoyi  staff    17M Jan 16 15:34 out/foo/nativeImage.dest/native-executable</code></pre>
</div>
</div>
<p>Here, the assembly <code>out.jar</code> is ~2.5mb, while the native <code>native-executable</code> is ~17mb,
even for a tiny hello-world application using some trivial libraries. In general native
image binaries can be pretty large, which can have consequences in download sizes or deployment
times as you try to distribute these binaries to servers or users.</p>
</div>
<div>
<h3 id="_startup_time"><a href="#_startup_time"></a>Startup Time</h3>
<p>Executable assembly jars typically take longer than Graal native executables to run. For this
small example project, we can see the Executable assembly takes about ~235ms to run, while
the native image takes ~60ms</p>
<p><em>Executable Assembly</em></p>
<div>
<div>
<pre><code data-lang="bash">$ time ./out/foo/assembly.dest/out.jar --text hello-world
&lt;h1&gt;hello-world&lt;/h1&gt;
./out/foo/assembly.dest/out.jar --text hello-world
0.35s user 0.04s system 165% cpu 0.235 total</code></pre>
</div>
</div>
<p><em>Native Image</em></p>
<div>
<div>
<pre><code data-lang="bash">$ time ./out/foo/nativeImage.dest/native-executable --text hello-world
&lt;h1&gt;hello-world&lt;/h1&gt;
./out/foo/nativeImage.dest/native-executable --text hello-world
0.04s user 0.01s system 87% cpu 0.062 total</code></pre>
</div>
</div>
<p>The <code>~175ms</code> speedup shown is for a tiny example program, and can be expected to grow
for larger Java applications which normally can take multiple seconds to start up.
Nevertheless, whether this speedup is significant depends on the use case: for long-lived
webservers saving a few seconds on startup may not matter, but for short-lived command
line tools this startup overhead may dominate the actual work the program is trying to do,
and saving 100s to 1000s of milliseconds with a native binary can be worthwhile.
The <a href="https://mill-build.org/mill/index.html" class="page">Mill build tool</a> itself is distributed as native binaries:
this saves Mill ~100-200ms every time it is run from the command line, which goes a long
way to ensuring it feels snappy and responsive to users.</p>
</div>
<div>
<h3 id="_steady_state_performance"><a href="#_steady_state_performance"></a>Steady-State Performance</h3>
<p>To do a rough benchmark of the steady-state performance of the executable assembly and
native executable, we can adjust our Java program to run the same logic in a loop, and
every ~1s print out how many iterations of the loop have occurred:</p>
<div>
<div>
<pre><code data-lang="diff">   public static void main(String[] args) {
+    long count = 0;
+    long prevTime = System.currentTimeMillis();
+    String global = null;
+    while(count &gt;= 0){
       ArgumentParser parser = ArgumentParsers.newFor(&#34;template&#34;)
           .build()
           .defaultHelp(true)
@@ -28,7 +32,15 @@ public class Foo {
         System.out.println(e.getMessage());
         System.exit(1);
       }
+      global = generateHtml(ns.getString(&#34;text&#34;));
+      if (System.currentTimeMillis() - prevTime &gt; 1000){
+        prevTime = System.currentTimeMillis();
+        System.out.println(count);
+        count = 0;
+      }
+      count++;
+    }

-    System.out.println(generateHtml(ns.getString(&#34;text&#34;)));
+    System.out.println(global);
   }
 }</code></pre>
</div>
</div>
<p>Now, if we re-build our assembly and native image and run it, we can see the number
of iterations per second they are able to achieve below:</p>
<p><em>Executable Assembly</em></p>
<div>
<div>
<pre><code data-lang="bash">$ ./out/foo/assembly.dest/out.jar --text hello-world
135
170
178
188
191
192
192
189
190
188
195
185
182</code></pre>
</div>
</div>
<p><em>Native Image</em></p>
<div>
<div>
<pre><code data-lang="bash">$ time ./out/foo/nativeImage.dest/native-executable --text hello-world
171
163
180
173
182
182
181
184
181
181
182
183
181</code></pre>
</div>
</div>
<p>As you can see, the executable assembly and native image both have comparable performance,
although the executable assembly starts off lower (135 vs 171) for the first iteration due
to JVM warmup time, but eventually reaches a higher steady state than the native image
(~190 vs ~180).</p>
<p>While again this is for a toy program, for larger applications the same pattern applies: Graal
native binaries avoid the slow startup that JVM applications often exhibit, but in exchange
may not quite reach the same peak steady-state performance that a long-lived JVM application
would typically achieve.</p>
</div>
<div>
<h3 id="_memory_usage"><a href="#_memory_usage"></a>Memory Usage</h3>
<p>While our programs are looping, we can also see how much memory they take via <code>top</code>:</p>
<p><em>Executable Assembly</em></p>
<div>
<div>
<pre><code data-lang="bash">$ jps
58547 MillMain
86276 MillServerMain
24895 Jps
9263 Foo
1071 Main

$ top | grep 9263
9263   java             0.0  00:20.41 32/1   1   134    373M  0B    0B    9263  42892 running  *0[1]       0.00000 0.00000    501 93089     9569   5005      2470      387381     104652     75938      9       0        0.0   0      0      lihaoyi            N/A    N/A   N/A   N/A   N/A   N/A</code></pre>
</div>
</div>
<p><em>Native Image</em></p>
<div>
<div>
<pre><code data-lang="bash">$ ps aux | grep native-executable
lihaoyi          43880  46.1  0.1 408681792  30176 s000  S+    3:40PM   0:05.84 ./out/foo/nativeImage.dest/native-executable --text hello-world
lihaoyi          86276   0.0  2.1 420349904 720416 s000  S     3:14PM   1:00.88 /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/bin/java -cp /Users/lihaoyi/.cache/mill/download/0.12.5-68-e4bf78 mill.runner.MillServerMain /Users/lihaoyi/Github/mill/blog/modules/ROOT/attachments/7-graal-native-executables/out/mill-server/aa508f0984fd2811f6c6d8fae1362f1774e4f5f7-1
lihaoyi          48496   0.0  0.0 408626896   1376 s002  S+    3:40PM   0:00.00 grep native-executable

$ top | grep 43880
43880  native-executabl 0.0  00:10.19 3/1    0   26     20M   0B    0B    43880 42892 running  *0[1]       0.00000 0.00000    501 695907    44380  8100      4045      153233     8177       24637      313     0        0.0   0      0      lihaoyi            N/A    N/A   N/A   N/A   N/A   N/A</code></pre>
</div>
</div>
<p>The column <code>373M</code> and <code>20M</code> are the respective memory footprints of the executable assembly
and native image binary. In this small program, the native image uses almost 20x less memory
than the JVM executable assembly! That is a very significant reduction in resource footprint</p>
</div>
<div>
<h3 id="_portability_and_hermeticity"><a href="#_portability_and_hermeticity"></a>Portability and Hermeticity</h3>
<p>Executable assembly jars require a JVM installed globally in order to run. In a way they are
not hermetic, since the globally-installed JVM can differ resulting in the assembly behaving
differently at runtime. However, it does mean that the executable assembly is typically portable
across different operating systems and CPU architectures: as long as there is a JVM installed,
the executable assembly can be run.</p>
<p>Native images are the opposite: they do not depend on a globally installed JVM, and thus can
be run even in environments where pre-installing a JVM is inconvenient. On the other hand,
the fact that the native executable is OS/CPU-specific means that you need to specifically
generate separate native executables for each platform you want to support.</p>
<p>The Mill build tool takes advantage of this hermeticity for easier installation: it’s
<a href="https://mill-build.org/mill/cli/installation-ide.html#_mill_native_executable" class="page">Mill Native Executable</a> can be run on systems without
a JVM installed at all. Mill still needs a JVM later on, e.g. to compile and run user code, and so
the native launcher downloads one on-demand automatically from the
<a href="https://github.com/coursier/jvm-index">Coursier JVM Index</a>. But bootstrapping with a native
launcher means there’s one less thing for people to do during setup and installation,
and one less thing to go wrong and cause the user to get stuck.</p>
</div>
</div></div>
  </body>
</html>
