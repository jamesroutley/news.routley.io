<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lief.re/blog/2025-05-27-dwarf-editor/">Original</a>
    <h1>DWARF as a Shared Reverse Engineering Format</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://todaythings.substack.com/p/featured.webp" alt="Featuring Image"/></p><p>When reverse engineering binaries, we could want, at some point, to share the reverse-engineered
information with others. The DWARF format, originally designed to hold debug
information associated with the original source code, is also well-suited for
storing reverse-engineered informations such as structure, function names.</p><p>This blog post introduces a new API in <em>LIEF extended</em> to create DWARF files.
It also introduces two plugins for Ghidra and BinaryNinja to export binary analysis
into DWARF.</p><h2 id="creating-dwarf-with-lief-extended">Creating DWARF with LIEF (extended)</h2><p><a href="https://lief.re/doc/latest/extended/intro.html">LIEF extended</a> now provides a
comprehensive API to create DWARF files.</p><p>This API is available in Python, Rust, and C++ and it looks like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span> 1</span><span><span>import</span> <span>lief</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span>elf <span>=</span> lief<span>.</span>ELF<span>.</span>parse<span>(</span><span>&#34;./libd5A7BCF0524B8.so&#34;</span><span>)</span>
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>editor<span>:</span> lief<span>.</span>dwarf<span>.</span>Editor <span>=</span> lief<span>.</span>dwarf<span>.</span>Editor<span>.</span>from_binary<span>(</span>elf<span>)</span>
</span></span><span><span> 6</span><span>unit<span>:</span> lief<span>.</span>dwarf<span>.</span>editor<span>.</span>CompilationUnit <span>=</span> editor<span>.</span>create_compilation_unit<span>()</span>
</span></span><span><span> 7</span><span>unit<span>.</span>set_producer<span>(</span><span>&#34;Generated by LIEF (LLVM backend)&#34;</span><span>)</span>
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>func<span>:</span> lief<span>.</span>dwarf<span>.</span>editor<span>.</span>Function <span>=</span> unit<span>.</span>create_function<span>(</span><span>&#34;vm_set_register&#34;</span><span>)</span>
</span></span><span><span>10</span><span>func<span>.</span>set_address<span>(</span><span>0x1400023</span><span>)</span>
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span>editor<span>.</span>write<span>(</span><span>&#34;libd5A7BCF0524B8.dwarf&#34;</span><span>)</span>
</span></span></code></pre></div><p>Under the hood, LIEF uses the LLVM’s DWARF backend to create and generate the final DWARF.
In contrast to LLVM’s low-level API, LIEF provides an abstraction that simplifies
the implementation details of the DWARF format.</p><p>For instance, if we want to create a DWARF for a function
that contains a <strong>stack variable</strong> at the offset (on the stack) <code>8</code>,
we can use the following API:</p><div><pre tabindex="0"><code data-lang="python"><span><span>1</span><span>func<span>:</span> lief<span>.</span>dwarf<span>.</span>editor<span>.</span>Function <span>=</span> unit<span>.</span>create_function<span>(</span><span>&#34;vm_set_register&#34;</span><span>)</span>
</span></span><span><span>2</span><span>
</span></span><span><span>3</span><span>var<span>:</span> lief<span>.</span>dwarf<span>.</span>editor<span>.</span>Variable <span>=</span> func<span>.</span>create_stack_variable<span>(</span><span>&#34;my_stack_variable&#34;</span><span>)</span>
</span></span><span><span>4</span><span>var<span>.</span>set_stack_offset<span>(</span><span>8</span><span>)</span>
</span></span></code></pre></div><p>This code generates the following DWARF:</p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>0x0000000c: DW_TAG_compile_unit
</span></span><span><span> 2</span><span>              DW_AT_producer    (&#34;Generated by LIEF (LLVM backend)&#34;)
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>0x00000011:   DW_TAG_subprogram
</span></span><span><span> 5</span><span>                DW_AT_name      (&#34;vm_set_register&#34;)
</span></span><span><span> 6</span><span>                DW_AT_entry_pc  (0x0000000001400023)
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>0x0000001e:     DW_TAG_variable
</span></span><span><span> 9</span><span>                  DW_AT_name    (&#34;my_stack_variable&#34;)
</span></span><span><span>10</span><span>                  DW_AT_location        (DW_OP_fbreg -8)
</span></span></code></pre></div><p>Defining the <code>DW_AT_location</code> for a stack variable is not as simple as it sounds.
It requires defining some kind of DWARF expression and if you are curious about
the actual implementation, you can check this <a href="https://gist.github.com/romainthomas/1f7ba555c4439d9b4b457e293834ec5a">Github Gist</a>.</p><div><p>Summary</p><p>LIEF exposes a high-level API to create DWARF based on the LLVM&#39;s low-level API</p></div><h2 id="dwarf-and-reverse-engineering">DWARF and Reverse Engineering</h2><p>Reverse engineering tools typically use their own format to store information about
analyzed binaries such as <code>*.idb</code> and <code>*.bndb</code>. Most of these tools are not compatible
with each other, except Binary Ninja which has a support for loading IDB (<a href="https://docs.binary.ninja/guide/migration/migrationguideida.html"><em>Migrating from IDA</em></a>).
For Ghidra, importing IDA database is a non-goal (c.f. <a href="https://github.com/NationalSecurityAgency/ghidra/issues/2921">issue #2921</a>)</p><p>One alternative is to export binary information using <a href="https://github.com/google/binexport">BinExport</a>
or <a href="https://github.com/quarkslab/quokka">quokka</a>,
but many tools lack support for <strong>importing</strong> the exported data.</p><p>In contrast, Binary Ninja, Ghidra, and IDA all have built-in support for loading
DWARF files and external DWARF files.
The DWARF format is primarily designed to hold information about the original
source code, and the purpose of reverse engineering is to recover the semantic
of the source code information from the binary.</p><p>Therefore, we could use the DWARF as a reverse-engineering shared format to
export types, functions, and variables from reverse-engineered binaries.</p><p><img src="https://todaythings.substack.com/p/tool2dw.webp" alt=""/></p><p>It’s worth noting that DWARF is compatible with PE binaries, even though this
is not the default format for storing debug information on Windows.</p><div><p>PE / DWARF</p><p>If you compile a Windows executable with <code>clang[-cl]</code> and with the flags <code>-g -gdwarf-5</code>,
the final PE will contains DWARF information along with an external <code>.pdb</code>.</p></div><p>Currently, Binary Ninja is the only tool with a built-in plugin that can generate
a DWARF file from a <code>BinaryView</code> representation. However, it lacks the ability to
export stack-based variables, which can be crucial information.</p><p>The next section introduces two plugins for Ghidra and BinaryNinja to generate DWARF
from these tools.</p><h2 id="binaryninja--ghidra-plugins">BinaryNinja &amp; Ghidra Plugins</h2><p><img src="https://todaythings.substack.com/p/plugins.webp" alt=""/></p><p>To provide some background on this feature, I initially developed the BinaryNinja’s DWARF exporter plugin
for my own needs before Vector35 team released an official plugin in BinaryNinja 3.5.
I use this plugin in my reverse engineering workflow to
symbolize <a href="https://github.com/QBDI/QBDI">QBDI</a> traces from DWARF information:</p><ol><li>I statically reverse-engineer the binary</li><li>I generate a DWARF file</li><li>I trace the binary with QBDI that uses the DWARF file to symbolize:<ul><li>Stack accesses (hence the need to stack variables in the DWARF)</li><li>Function calls and their parameters</li><li>Static variables accesses</li></ul></li><li>goto 1.</li></ol><p>For instance, I used this process to reverse engineer the <a href="https://www.romainthomas.fr/publication/22-sstic-blackhat-droidguard-safetynet/">DroidGuard VM</a>
a few years ago.
I’ll take this blog post as an opportunity to share the DWARF associated with
my reverse engineering of the VM <code>libd5A7BCF0524B8.so</code>:</p><ul><li><strong>Original Binary:</strong> <a href="https://todaythings.substack.com/p/libd5A7BCF0524B8.so">libd5A7BCF0524B8.so</a></li><li><strong>Binary with generated DWARF:</strong> <a href="https://todaythings.substack.com/p/libd5A7BCF0524B8.so.debug">libd5A7BCF0524B8.so.debug</a></li></ul><p>As mentioned earlier, this functionality is integrated into BinaryNinja since version 3.5,
so I’ll focus more on the Ghidra plugin. For those interested in more details about the
BinaryNinja plugin, you can visit this page: <a href="https://lief.re/doc/latest/plugins/binaryninja/index.html">LIEF - BinaryNinja</a></p><p>The Ghidra plugin allows us to export Ghidra’s Program information into a DWARF file.
This can be done from the Project Manager interface by selecting the <code>DWARF</code> format
in the export section:</p><p><img src="https://todaythings.substack.com/p/project-dwarf-export.webp" alt=""/></p><p>You can also use this plugin from the <code>CodeBrowser</code> tool, by left-clicking on
the LIEF menu and selecting <code>Export as DWARF</code>:</p><p><img src="https://todaythings.substack.com/p/codebrowser-export-dwarf.webp" alt=""/></p><p>The plugin is primarily written in Java (using the JNI) and you can also generate a
DWARF file from a headless Java script:</p><div><pre tabindex="0"><code data-lang="java"><span><span> 1</span><span><span>import</span><span> </span><span>lief.ghidra.core.dwarf.export.Manager</span><span>;</span><span>
</span></span></span><span><span> 2</span><span><span></span><span>import</span><span> </span><span>lief.ghidra.core.NativeBridge</span><span>;</span><span>
</span></span></span><span><span> 3</span><span><span>
</span></span></span><span><span> 4</span><span><span></span><span>public</span><span> </span><span>class</span> <span>LiefDwarfExportScript</span><span> </span><span>extends</span><span> </span>GhidraScript<span> </span><span>{</span><span>
</span></span></span><span><span> 5</span><span><span>  </span><span>@Override</span><span>
</span></span></span><span><span> 6</span><span><span>  </span><span>protected</span><span> </span><span>void</span><span> </span><span>run</span><span>()</span><span> </span><span>throws</span><span> </span>Exception<span> </span><span>{</span><span>
</span></span></span><span><span> 7</span><span><span>    </span>NativeBridge<span>.</span><span>init</span><span>();</span><span>
</span></span></span><span><span> 8</span><span><span>    </span>Manager<span> </span>manager<span> </span><span>=</span><span> </span><span>new</span><span> </span>Manager<span>(</span>currentProgram<span>);</span><span>
</span></span></span><span><span> 9</span><span><span>    </span>File<span> </span>output<span> </span><span>=</span><span> </span><span>new</span><span> </span>File<span>(</span><span>&#34;/home/romain/output.dwarf&#34;</span><span>);</span><span>
</span></span></span><span><span>10</span><span><span>    </span>manager<span>.</span><span>export</span><span>(</span>output<span>);</span><span>
</span></span></span><span><span>11</span><span><span>  </span><span>}</span><span>
</span></span></span><span><span>12</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><div><p>IDA Support</p><p>I do not plan to support IDA for this functionality. However, if there is strong
demand for it, feel free to reach out to me. You can also create your own IDA
script using the Python or C++ API.</p></div><h2 id="last-word">Last Word</h2><p>This DWARF export functionality is still in early development, so I cannot
guarantee it is free of bugs. Additionally, the current version does not export
comments, but I plan to support this feature in the future.</p><p>The source code for the plugins are here:</p><ul><li><a href="https://github.com/lief-project/LIEF/tree/main/plugins/binaryninja">plugins/binaryninja</a></li><li><a href="https://github.com/lief-project/LIEF/tree/main/plugins/ghidra">plugins/ghidra</a></li></ul><p>Thank you for using LIEF.</p><p>Romain.</p></div></div>
  </body>
</html>
