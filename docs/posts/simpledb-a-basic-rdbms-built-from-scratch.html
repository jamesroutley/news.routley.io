<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.awelm.com/posts/simple-db/">Original</a>
    <h1>SimpleDB: A Basic RDBMS Built from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div>
		


		<div>
			
					
			<div>
				<p>My databases class at UCLA wasn’t very challenging so I never truly understood the internals of databases. This always bothered me so I vowed to build a simple database from scratch to learn the fundamentals. MIT’s Database Systems <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/" target="_blank">course</a> has their students implement a simple database from scratch and it provided me the perfect guidance in achieving my goal. The <a href="https://github.com/awelm/simpledb" target="_blank">SimpleDB</a> database I built has basic RDBMS features like a SQL query parser, transactions, and a query optimizer. This blog post provides an outline of SimpleDB’s architecture and implementation.</p>

<p><img src="http://mattambrogi.bearblog.dev/simpledb.png" alt="Architecture"/></p>
<h3 id="data-storage-and-access-methods"><strong>Data Storage and Access Methods</strong></h3>
<p>Database rows are referred to as <em>tuples</em> in SimpleDB. Each tuple has a set of <em>fields</em> which represent the column values for the given row. Currently the only supported field types are strings and integers. The current implementation also requires that all tuples with the same schema use the same number of bytes regardless of field values. Tuples are stored in <em>pages</em>, which are stored on disk. Pages belonging to the same table are grouped together under the same <code>DbFile</code> instance, which provides an interface to read/write pages and tuples to disk. Each database table is stored as a DbFile instance.</p>
<p>The <code>Catalog</code> singleton object manages adding new tables and viewing schemas and primary keys. The <code>BufferPool</code> singleton object manages all page access and modifications. Because BufferPool has a global view of all page accesses, it can cache frequently used pages in memory so that page fetches doesn’t always go to disk. Once the BufferPool cache gets full, it will need to evict pages using some eviction algorithm. The BufferPool evicts pages using the <em>no-steal</em> algorithm to provide ACID transaction guarantees, which is discussed more in the Transactions section below.</p>
<h3 id="operators"><strong>Operators</strong></h3>
<p>The query parser takes a SQL query and converts it into a <em>logical plan</em>. This logical plan represents the SQL query as a tree of <a href="https://www.tutorialspoint.com/dbms/relational_algebra.htm" target="_blank">relational algebra operators</a>. The query optimizer will then take this logical plan and convert it into a physical plan composed of physical <code>DBIterator</code> operators by applying equivalence rules and cost-based optimization.</p>
<p>The DBIterator physical operators are the actual primitives used to execute the query. Here is the list of physical operators currently supported by SimpleDB:</p>
<ol>
<li>Sequential Table Scans</li>
<li>Insert</li>
<li>Delete</li>
<li>Order By</li>
<li>Filter</li>
<li>Project</li>
<li>Aggregations</li>
<li>Nested-Loop Joins</li>
<li>Hash Joins</li>
</ol>
<p>The DbIterator interface lets physical operators fetch tuples from their children using <em>hasNext()</em> and <em>next()</em>. These tuples flow starting from the leaves of physical plan tree to the root while undergoing transformations performed by intermediate operators. The leaf nodes of the physical plan tree are always going to be operators that read tuples from the buffer pool. After the tuples reach the root node, they are displayed to the user as query results.</p>
<h3 id="query-optimization"><strong>Query Optimization</strong></h3>
<p>The query optimizer takes a logical plan as input and tries to convert it into the cheapest possible physical plan. In order to estimate the cost of a physical plan, we need statistics like table size and data skew. <code>TableStats</code> computes histograms for each column in a given table and these statistics are used to estimate selectivity, scan costs, and cardinality for a given physical plan. SimpleDB uses Selinger Optimization to determine the cheapest way to order multiple joins in a query. A naive solution to the NP-hard problem of ordering N joins would take $O(N!)$ time, but Selinger Optimization leverages dynamic programming to achieve $O(2^N)$ time.</p>
<h3 id="transactions"><strong>Transactions</strong></h3>
<p>Transactions provide ACID guarantees for SimpleDB queries. It should always seem like the operations in a transaction were executed as a single, indivisible action. Because transactions run in parallel, some form of locking is necessary to avoid data races between concurrently running transactions. SimpleDB uses strict <a href="https://www.geeksforgeeks.org/two-phase-locking-protocol/" target="_blank">2PL</a> for concurrency control and locks data at the page-level. <code>LockManager</code> provides support for both shared locks and exclusive locks to allow multiple readers to access the same data in parallel. Locks are grabbed when a page is fetched from BufferPool, and the page fetch function blocks until the page’s lock is acquired from LockManager. Blocking in this fashion runs the risk of deadlock, which is why SimpleDB also implements a <code>DependencyGraph</code> which detects deadlocks via topological sort. If fetching a page triggers a deadlock, the calling transaction will be aborted. All locks held by a transaction are released when a transaction completes.</p>
<p>To properly implement isolation, we use the <em>no-steal</em> eviction policy which guarantees that dirty pages won’t be evicted from the buffer pool. If eviction is triggered and all pages in the buffer pool are dirty, the calling transaction will be aborted. When a transaction decides to commit, we always flush its dirty pages to disk to ensure transaction durability. If a transaction decides to abort, we evict its dirty pages from the buffer pool. If the database crashes mid-transaction, the dirty pages in memory will be lost. When the database comes back online, the interrupted transactions that weren’t committed will be lost but the changes made by committed transactions will still be present since they were flushed to disk upon commit.</p>

<p>Clone <a href="https://github.com/awelm/simpledb" target="_blank">this</a> repository and run the following command to start a SimpleDB REPL that lets you query an example database:</p>
<div><pre tabindex="0"><code data-lang="bash">ant
java -jar dist/simpledb.jar parser nsf.schema
</code></pre></div><p>Then enter a query into the REPL. For example try:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>SELECT</span> <span>g</span>.title <span>FROM</span> grants <span>g</span> <span>WHERE</span> <span>g</span>.title <span>LIKE</span> <span>&#39;Monkey&#39;</span>;
</code></pre></div><p>For something more intensive try:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>SELECT</span> r2.name, <span>count</span>(<span>g</span>.id)
<span>FROM</span> grants <span>g</span>, researchers r, researchers r2, grant_researchers gr,
	grant_researchers gr2
<span>WHERE</span> r.name <span>=</span> <span>&#39;Samuel Madden&#39;</span> <span>AND</span> gr.researcherid <span>=</span> r.id
	<span>AND</span> gr.grantid <span>=</span> <span>g</span>.id <span>AND</span> gr2.researcherid <span>=</span> r2.id
	<span>AND</span> gr.grantid <span>=</span> gr2.grantid
<span>GROUP</span> <span>BY</span> r2.name
<span>ORDER</span> <span>BY</span> r2.name;
</code></pre></div>
<p>Implementing a simple database from scratch was very illuminating experience for me. The ACID guarantees always seemed like impossible magic, but now I actually understand how it works. I’ve also seen the
Volcano model (i.e. the DBIterator interface) show up a few times on the job so the knowledge I’ve gained from this project has also been useful in practice.</p>
<p>Here are some features that would make SimpleDB more efficient (but less simple):</p>
<ol>
<li>Add defragmentation for tuples stored in heap file pages</li>
<li>Allow for dynamically-sized tuples</li>
<li>Add support for indexes and clustered indexes</li>
<li>Add sort-merge join physical operator</li>
</ol>

			</div>

			</div>
	</div></div>
  </body>
</html>
