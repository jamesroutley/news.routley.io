<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ym2132.github.io/ONNX_MLProgram_NN_exploration">Original</a>
    <h1>ONNX Runtime and CoreML May Silently Convert Your Model to FP16</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-content">

<main id="quarto-document-content">




<div>

<div id="callout-1">
<div>
<p>Running an ONNX model in ONNX RunTime (ORT) with the CoreMLExecutionProvider may change the predictions your model makes implicitly and you may observe differences when running with PyTorch on MPS or ONNX on CPU. <b>This is because the default arguments ORT uses when converting your model to CoreML will cast the model to FP16</b>.</p>
<p>The fix is to use the following setup when creating the InferenceSession:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ort_session <span>=</span> ort.InferenceSession(onnx_model_path, providers<span>=</span>[(<span>&#34;CoreMLExecutionProvider&#34;</span>, {<span>&#34;ModelFormat&#34;</span>: <span>&#34;MLProgram&#34;</span>})])</span></code></pre></div>
<p>This ensures your model remains in FP32 when running on a Mac GPU.</p>
</div>
</div>
</div>
<section id="uncovering-an-issue-in-onnx-runtime---benchmarking-the-eyesoff-model">
<h2 data-anchor-id="uncovering-an-issue-in-onnx-runtime---benchmarking-the-eyesoff-model">Uncovering an Issue in ONNX Runtime - Benchmarking the EyesOff Model</h2>
<p>Having trained the <a href="https://ym2132.github.io/building_EyesOff_part2_model_training">EyesOff model</a>, I began evaluating the model and its run time. I was looking into the ONNX format and using it to run the model efficiently. I setup a little test bench in which I ran the model using PyTorch and ONNX with ONNX Runtime (ORT), both using MPS and CPU. While checking the outputs, I noticed that the metrics from the model ran on ONNX on MPS had a different output to those on ONNX CPU and PyTorch CPU and MPS. Note, the metrics from PyTorch on CPU and MPS were the same.</p>
<p>When I say ORT and MPS, this is achieved through ORT’s execution providers. To run an ONNX model on the Mac GPU you have to use the CoreMLExecutionProvider (more on this to come).</p>
<p>Now in Figure 1 and 2, observe the metric values - the PyTorch ones (Figure 1) are the same across CPU and MPS, this isn’t the same story for ONNX (Figure 2):</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/bd848010-963c-4e76-9c6d-8affd46ce2e4-1-89393f50-16c5-4777-b3ef-dd8662c2a68b.png"/></p>
<figcaption>Figure 1 - PyTorch CPU &amp; MPS metrics output</figcaption>
</figure>
</div>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/ff27f9d8-a88e-4bc2-b18d-e05b684a818a-1-594c5ef8-959b-4df0-8bfc-83d3f24a7e52.png"/></p>
<figcaption>Figure 2 - ORT CPU &amp; MPS metrics output</figcaption>
</figure>
</div>
<p>Wow, look at the diff in Figure 2! When I saw this it was quite concerning, floating point math can lead to differences in the calculations carried out across the GPU and CPU but the values here don’t appear to be a result of floating point math, the values are too large.</p>
<p>Given the difference in metrics, I was worried that running the model with ORT was changing the output of the model and hence the behaviour. The reason the metrics change is because some of the model predictions around the threshold flipped to the opposite side of the threshold (which is 0.5), this can be seen in the confusion matrices for the ONNX CPU run and MPS run:</p>
<section id="fp32-confusion-matrix">
<h4 data-anchor-id="fp32-confusion-matrix">FP32 Confusion Matrix</h4>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Predicted Negative</strong></th>
<th><strong>Predicted Positive</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Actual Negative</strong></td>
<td>207 (TN)</td>
<td>24 (FP)</td>
</tr>
<tr>
<td><strong>Actual Positive</strong></td>
<td>69 (FN)</td>
<td>164 (TP)</td>
</tr>
</tbody>
</table>
</section>
<section id="fp16-confusion-matrix">
<h4 data-anchor-id="fp16-confusion-matrix">FP16 Confusion Matrix</h4>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Predicted Negative</strong></th>
<th><strong>Predicted Positive</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Actual Negative</strong></td>
<td>206 (TN)</td>
<td>25 (FP)</td>
</tr>
<tr>
<td><strong>Actual Positive</strong></td>
<td>68 (FN)</td>
<td>165 (TP)</td>
</tr>
</tbody>
</table>
<p>So two predictions flipped from negative to positive.</p>
<p>Having said that, the first thing I did was to make my life easier, by simplifying the scenario from the large EyesOff model to a simple one layer MLP and using that to run the experiments.</p>
</section>
</section>
<section id="why-am-i-using-onnx-and-onnx-runtime">
<h2 data-anchor-id="why-am-i-using-onnx-and-onnx-runtime">Why am I Using ONNX and ONNX RunTime?</h2>
<p>Before going on it’s worth discussing what ONNX and ORT are, and why I’m even using them in the first place.</p>
<section id="onnx1">
<h3 data-anchor-id="onnx1">ONNX<a href="#1"><sup>1</sup></a></h3>
<p>ONNX stands for Open Neural Network Exchange. It can be thought of as a common programming language in which to describe ML models. Under the hood ONNX models are represented as graphs, these graphs outline the computation path of a model and it shows the operators and transformations required to get from input to prediction. These graphs are called ONNX graphs.</p>
<p>The use of a common language to describe models makes deployment easier and in some cases can add efficiency in terms of resource usage + or inference speed. Firstly, the ONNX graph itself can be optimised. Take PyTorch for example, you train the model in it and sure PyTorch is very mature and extremely optimised but it’s such a large package some things can be overlooked or difficult to change. By converting the model to ONNX, you take advantage of the fact that ONNX was built specifically with inference in mind and with that comes optimisations which the PyTorch team could implement but have not yet.</p>
<p>Furthermore, ONNX models can be ran cross platform in specialised runtimes. These runtimes are specially optimised for different architectures and add another layer of efficiency gains.</p>
</section>
<section id="onnx-runtime-ort2">
<h3 data-anchor-id="onnx-runtime-ort2">ONNX RunTime (ORT)<a href="#2"><sup>2</sup></a></h3>
<p>ORT is one of these runtimes. ORT actually runs the model, it can be though of as an interpreter, it takes the ONNX graph and actually implements the operators and runs them on the specified hardware. ORT has a lot of magic built into it, the operators are extremely optimised and through the use of execution providers they target a wide range of hardware. Each execution provider is optimised for the specific hardware it refers to, this enables the ORT team to implement extremely efficient operators giving us another efficiency gain.</p>
</section>
<section id="coreml3">
<h3 data-anchor-id="coreml3">CoreML<a href="#3"><sup>3</sup></a></h3>
<p>As mentioned before, I used the CoreMLExecutionProvider to run the model on a Mac GPU. This execution provider informs ORT to make use of CoreML. CoreML is an apple developed framework which lets models (neural networks and classical ML models) run on Apple hardware, CPU, GPU and ANE. ORT’s purpose in this phase is to take the ONNX graph and convert it to a CoreML model. CoreML is Apple’s answer to running efficient on device models on Apple hardware.</p>
<p>Note, that all of this doesn’t always mean the model will run faster. Some models may run faster in PyTorch, TensorRT or any other framework. This is why it is important to benchmark and test as many approaches as makes sense.</p>
</section>
</section>
<section id="finding-the-source-of-the-cpu-vs-mps-difference---with-an-mlp">
<h2 data-anchor-id="finding-the-source-of-the-cpu-vs-mps-difference---with-an-mlp">Finding the Source of the CPU vs MPS Difference - With an MLP</h2>
<p>The MLP used is very simple it has a single layer, with 4 inputs, 3 outputs and the bias turned off. So, I pretty much created a fancy matrix multiplication.</p>
<p>To understand where the issue was coming from I ran this MLP through some different setups:</p>
<pre><code>- PyTorch CPU
- PyTorch MPS
- ORT CPU
- ORT MPS
- CoreML FP32
- CoreML FP16</code></pre>
<p>The goal of this exercise is to find out if 1 - the difference in outputs is seen in a simple model and 2 - to figure out where exactly the issue arises.</p>
<p>Before showing the full results, I want to explain why I included the CoreML FP16 and FP32 runs - specifically why the FP16 one. When I initially ran the MLP experiment I only ran PyTorch, ORT and CoreML FP32 but the output numbers of ORT MPS looked like FP16 numbers. So, I tested if they were and also if the outputs from the other runs were true FP32 numbers. You can do this with a “round trip” test, by converting a number to FP16 and back to FP32. If after this process the number is unchanged then it is an FP16 number but if it changes then it was a true FP32. The number changes as FP16 can represent fewer floating point numbers than FP32. It’s a very simple check to carry out:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>import</span> numpy <span>as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>onnx_cpu <span>=</span> np.array([<span>0.6480752</span>, <span>-</span><span>0.34015813</span>, <span>1.4329923</span>], dtype<span>=</span>np.float32)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>onnx_coreml <span>=</span> np.array([<span>0.6484375</span>, <span>-</span><span>0.34033203</span>, <span>1.4326172</span>], dtype<span>=</span>np.float32)  <span># We cast the ort MPS numbers up to FP32, if they were FP16 this has no effect</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>cpu_roundtrip <span>=</span> onnx_cpu.astype(np.float16).astype(np.float32)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>coreml_roundtrip <span>=</span> onnx_coreml.astype(np.float16).astype(np.float32)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;ORT CPU values:&#34;</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  Original:&#34;</span>, onnx_cpu)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  fp16 roundtrip:&#34;</span>, cpu_roundtrip)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  Changed?&#34;</span>, <span>not</span> np.allclose(onnx_cpu, cpu_roundtrip, atol<span>=</span><span>0</span>))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;</span><span>\n</span><span>ORT CoreML values:&#34;</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  Original:&#34;</span>, onnx_coreml)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  fp16 roundtrip:&#34;</span>, coreml_roundtrip)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>&#34;  Changed?&#34;</span>, <span>not</span> np.allclose(onnx_coreml, coreml_roundtrip, atol<span>=</span><span>0</span>))</span></code></pre></div>
<p>The output of this is:</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/01a62170-326b-4682-8d76-9666e4f6565c-1-82960d41-7a49-4366-bc97-a0d2af9a223d.png"/></p>
<figcaption>Figure 3 - Roundtrip FP16 Test</figcaption>
</figure>
</div>
<p>The CPU values change and the MPS values don’t! Now it’s getting interesting - perhaps when using the CoreML execution provider the output is FP16? This prompted adding the CoreML direct run in FP16 precision.</p>
<p>I tested this theory with an experiment. Originally, when benchmarking it was all about inference speed, now it’s about floating point precision and figuring out where the diffs come from.</p>
<p>Running on PyTorch CPU and MPS gives a strong baseline, PyTorch is a very mature ecosystem and I used the results from that as my ground truth. It being so close together is what drove me to understand what caused ORT runs on different hardware to have a difference. Then using CoreML FP32 and FP16 aimed to show if the issue was an ONNX one or a CoreML one.</p>
<p>Check Figure 4 for the outputs and Figure 5 for differences in the outputs here:</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/0665b872-9570-4369-a5d7-c50e670b8170-1-8d55ad4b-b4ad-4a02-9f6f-68cadc712839.png"/></p>
<figcaption>Figure 4 - MLP Output in Different Scenarios</figcaption>
</figure>
</div>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/4d47293e-0add-4ec3-a7b4-bc94344c34b7-1-f16cdb07-9d46-4cbc-ad7e-3a194d9a7afb.png"/></p>
<figcaption>Figure 5 - MLP Output Diffs</figcaption>
</figure>
</div>
<p>Wow, would you look at that - once again PyTorch + ORT CPU match and so does PyTorch CPU + CoreML FP32. Also note that CoreML FP16 and ORT MPS match! This is a big insight into what is happening and why the metrics output differed before. Along with the round trip experiment this proves our model is being ran in FP16 when using the CoreML execution provider in ORT!</p>
<div>

<div id="callout-2">
<div>
<p>Floating points numbers are defined by three values:</p>
<ul>
<li><strong>Sign</strong>: 1 bit to define if the number is positive or negative</li>
<li><strong>Significand</strong>: Contains the numbers digits</li>
<li><strong>Exponent</strong>: This says where the decimal place should be placed relative to the beginning of the significand</li>
</ul>
<p>Floating point numbers are often expressed in scientific notation, e.g:</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/1c831a51-e1d1-478e-aef5-8f7917a5cc54-1-0a8652d6-7911-4b0c-bb00-525a245bff41.png"/></p>
<figcaption>Figure 8 - Table showing Significand, Exponent and scientific representation<a href="#6"><sup>6</sup></a></figcaption>
</figure>
</div>
<p>FP16 and FP32 specifically, have the following specification:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Format</th>
<th>Total bits</th>
<th>Significand bits</th>
<th>Exponent bits</th>
<th>Smallest number</th>
<th>Largest number</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single precision</td>
<td>32</td>
<td>23 + 1 sign</td>
<td>8</td>
<td><span>\(1.2 * 10^{-38}\)</span></td>
<td><span>\(3.4 * 10^{38}\)</span></td>
</tr>
<tr>
<td>Half precision</td>
<td>16</td>
<td>10 + 1 sign</td>
<td>5</td>
<td><span>\(5.96 * 10^{-8}\)</span></td>
<td><span>\(6.55 * 10^{4}\)</span></td>
</tr>
</tbody>
</table>
<p>So as FP16 is half the size it affords a couple benefits, firstly it requires half the memory to store and secondly it can be quicker to do computations with too. However, this comes at a cost of precision, FP16 cannot represent very small numbers and the distances between small numbers as accurately as FP32.</p>
<p>An example of FP16 vs FP32 - The Largest Number Below 1</p>
<ul>
<li>FP32 - 0.999999940395355225<a href="#4"><sup>4</sup></a></li>
<li>FP16 - 0.99951172<a href="#5"><sup>5</sup></a></li>
</ul>
<p>As you see FP32 can represent a value much closer to 1.</p>
<section id="the-link-to-the-onnx-issue">
<h4 data-anchor-id="the-link-to-the-onnx-issue">The Link to the ONNX Issue</h4>
<p>Having said all that, going back to the issue at hand we observe a ~<span>\(1.17*e^{-7}\)</span> error between PyTorch and CoreML FP32 which is typical of FP32. But, then ORT and CoreML when ran on MPS have a difference of ~<span>\(3.7*e{-4}\)</span> which is much more representative of FP16, this is what prompted the round trip experiment.</p>
</section>
</div>
</div>
</div>
<div>

<div id="callout-3">
<div>
<p>If you need a quick refresher on FP values, please expand the box above. If you already read that or you know enough about FP already let’s look at why some predictions flip.</p>
<p>In my model the base threshold for a 0 or 1 class is 0.5. Both FP16 and FP32 can represent 0.5 exactly:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fp_32_05 <span>=</span> np.array([<span>0.5</span>], dtype<span>=</span>np.float32)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>fp_16_05 <span>=</span> np.array([<span>0.5</span>], dtype<span>=</span>np.float16)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>fp_32_05.item(), fp_16_05.item()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>(<span>0.5</span>, <span>0.5</span>)</span></code></pre></div>
<p>But we know that FP representations cannot represent every single number, so there will be some values around 0.5 which cannot be represented and hence will get rounded either up or down. Let’s look into that and find the threshold, this will show why some predictions of the EyesOff model were flipped when changing the model to run in FP16. Also, note by flipped we mean they go from a negative (0) prediction to a positive (1) class prediction, the rounding means it’d have to be below 0.5 and then be rounded up to cross the threshold boundary. Any other scenario would keep the label the same, i.e if it’s above 0.5 and gets rounded to 0.5 that’s fine as the predicted class is still the same.</p>
<p>The first step is to find the next representable number below 0.5:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span># Show the representable values just below 0.5</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>fp32_below <span>=</span> np.nextafter(np.float32(<span>0.5</span>), np.float32(<span>0.0</span>))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>fp16_below <span>=</span> np.nextafter(np.float16(<span>0.5</span>), np.float16(<span>0.0</span>))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>fp32_gap <span>=</span> <span>0.5</span> <span>-</span> fp32_below</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>fp16_gap <span>=</span> <span>0.5</span> <span>-</span> fp16_below</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;</span><span>\n</span><span>Closest value BELOW 0.5:&#34;</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;FP32: </span><span>{</span>fp32_below<span>:.20f}</span><span>&#34;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;FP16: </span><span>{</span>fp16_below<span>:.20f}</span><span>&#34;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;</span><span>\n</span><span>Gap from threshold (0.5):&#34;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;FP32: </span><span>{</span>fp32_gap<span>:.2e}</span><span>&#34;</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;FP16: </span><span>{</span>fp16_gap<span>:.2e}</span><span>&#34;</span>)</span></code></pre></div>
<pre><code>Closest value BELOW 0.5:
FP32: 0.49999997019767761230
FP16: 0.49975585937500000000

Gap from threshold (0.5):
FP32: 2.98e-08
FP16: 2.44e-04</code></pre>
<p>Taking this gap between 0.5 and the next reprsentable number below 0.5 in FP16 we can calculate the threshold for values which will get rounded up to 0.5:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span># Given the gap is 2.44e-04, we need to divide it by 2 and calculate the midpoint between 0.499755859375 and 0.5. This midpoint determines whether the FP16 value will be rounded down if below it or up it equal to or greater than. </span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span># Convert to FP32 as the midpoint is not representable in FP16</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>fp_16_below_fp32 <span>=</span> np.float32(fp16_below)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span># Calculate the gap and midpoint</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>fp16_gap <span>=</span> <span>0.5</span> <span>-</span> fp16_below</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>midpoint <span>=</span> fp_16_below_fp32 <span>+</span> (fp16_gap <span>/</span> <span>2</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span>print</span>(<span>f&#34;  Midpoint (rounding boundary): </span><span>{</span>midpoint<span>:.15f}</span><span>&#34;</span>)</span></code></pre></div>
<pre><code>Midpoint: 0.499877929687500</code></pre>
<p>Finally let’s see some examples of numbers being rounded up to 0.5 if they are above the midpoint between the representable values of FP16:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span># Firstly, the midpoint itself is rounded up</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>np.float16(<span>0.499877929687500</span>).item() <span>-&gt;</span> <span>0.5</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>np.float16(<span>0.4999</span>).item() <span>-&gt;</span> <span>0.5</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span># For completeness here&#39;s a number slightly smaller than the midpoint which gets rounded down</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>np.float16(<span>0.4998779296874</span>).item() <span>-&gt;</span> <span>0.499755859375</span></span></code></pre></div>
<p>In short, any number between <span>\([0.4998779296875, 0.5)\)</span> will be rounded up to 0.5. This means, the predictions which were flipped were in this range.</p>
</div>
</div>
</div>
</section>
<section id="where-does-the-model-switch-to-fp16">
<h2 data-anchor-id="where-does-the-model-switch-to-fp16">Where Does the Model Switch to FP16?</h2>
<p>Now that we know what the issue is, it’s time to find out what caused it.</p>
<section id="a-bug-or-intended-behaviour---it-must-be-a-bug-right">
<h3 data-anchor-id="a-bug-or-intended-behaviour---it-must-be-a-bug-right">A Bug or Intended Behaviour - It Must be a Bug Right…?</h3>
<p>Originally I thought this behaviour was a bug with the ORT repo. Knowing the cast occured in the phase where ORT takes the ONNX model and converts it to a CoreML model my initial thinking was either ORT casts it to FP16 somewhere or calls CoreML with a hardcode FP16 flag or something similar.</p>
<p>Having little background in cpp, <a href="https://claude.ai">Claude</a> came in useful here. I gave it the structure of the repo and it told me where I ought to place breakpoints to debug the ORT package (turns out you can debug a cpp package from python, clone the repo, build from src and then link it to your python code using the PID). However, upon running the code the breakpoints weren’t being hit. I was puzzled for a bit, but then I realised why the code wasn’t being hit. It turns out CoreML has two model formats “NeuralNetwork” and “MLProgram”, I will call them NN and MLP formats respectively. The behaviour of the ORT repo changes depending on which you want, as does the behaviour of CoreML, with the default being the NN format. So, the breakpoints weren’t hit as the code was regarding the MLP format whereas I was not setting this so the code flowed through the default NN code. Knowing this I took a step back and began experimenting with NN vs MLP format.</p>
</section>
</section>
<section id="the-fix---neuralnetwork-vs-mlprogram-coreml-format">
<h2 data-anchor-id="the-fix---neuralnetwork-vs-mlprogram-coreml-format">The Fix - NeuralNetwork vs MLProgram CoreML Format</h2>
<p>So, CoreML has two model formats, these represent how the model is stored and ran with CoreML. The NeuralNetwork (NN) format is older and the MLProgram (MLP) format is newer. ORT specifies NN format by default, but it does allow you to pass a flag to use MLP format.</p>
<p>Testing the MLP format revealed it as the solution! See below in figure 6 the final output, which includes both ORT MLP and NN format ran on the GPU.</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/a3e7fdf8-e68c-4ae5-9b36-081b69574715-1-3f808def-21af-48d5-bf49-6c186467c94f.png"/></p>
<figcaption>Figure 6 - Running ORT with MLProgram format</figcaption>
</figure>
</div>
<p>So ORT on MPS with NN format has the same difference from the PyTorch CPU baseline as CoreML FP16, whereas ORT with MLP format matches - this is exactly what I wanted. Mystery solved! By setting the model format to be the newer MLProgram format no implicit cast to FP16 takes place.</p>
</section>
<section id="why-mlprogram-format-worked-and-neural-network-didnt">
<h2 data-anchor-id="why-mlprogram-format-worked-and-neural-network-didnt">Why MLProgram Format Worked and Neural Network Didnt?</h2>
<p>To understand the difference in behaviours of these two models formats we need to take a deep dive on the internals of CoreML, its goals and the two formats themselves. Let’s begin with CoreML.</p>
<section id="coreml">
<h3 data-anchor-id="coreml">CoreML</h3>
<p>ORT implements methods to convert the ONNX graph into CoreML model formats. CoreML has two types of model format, this defines how the model is represented in the CoreML framework, how it’s stored and how it’s ran. The older is the NeuralNetwork format and the newer one which solved our issue is the MLProgram format. The reason MLProgram keeps the model at FP32 when running on MPS is due to the differences in model representation in these two formats. Let’s take a look at both of them.</p>
</section>
<section id="neural-network-format">
<h3 data-anchor-id="neural-network-format">Neural Network Format</h3>
<p>As stated, the NN format is the older one, it came out in 2017. It stored models as a Directed Acyclic Graph (DAG). Each layer in the model is a node in the DAG, and they encode information on layer type, list of input names, output names and a collection of parameters specific to the layer type<a href="#7"><sup>7</sup></a>. We can observe the model which is created by ORT’s InferenceSession call with the following code:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span># First create the InferenceSession and run the model. This ensures the CoreML model files are added to a temp dir</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>ort <span>=</span> ort.InferenceSession(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    onnx_path, providers<span>=</span>[<span>&#34;CoreMLExecutionProvider&#34;</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>nn_output <span>=</span> ort.run(<span>None</span>, {<span>&#34;input&#34;</span>: numpy_input})[<span>0</span>]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>import</span> coremltools <span>as</span> ct</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>def</span> get_coreml_dtype_from_spec(path):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span>&#34;&#34;&#34;Extract model type and dtypes by reading the spec.&#34;&#34;&#34;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    model <span>=</span> ct.models.MLModel(<span>str</span>(path))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    spec <span>=</span> model.get_spec()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span>print</span>(<span>f&#34;</span><span>\n</span><span>Model Spec for </span><span>{</span>path<span>.</span>name<span>}</span><span>:</span><span>\n</span><span> </span><span>{</span>spec<span>}</span><span>\n</span><span>&#34;</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span># Find created models</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>temp_dir <span>=</span> Path(tempfile.gettempdir())</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span># NeuralNetwork models are .mlmodel files</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>nn_files <span>=</span> <span>list</span>(temp_dir.glob(<span>&#34;*.mlmodel&#34;</span>))</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span>for</span> model_path <span>in</span> nn_files:</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    info <span>=</span> get_coreml_dtype_from_spec(model_path)</span></code></pre></div>
<p>This outputs the following:</p>
<pre><code>Model Spec for onnxruntime-40975D85-7412-4309-A6F7-4E51CA3D2FE8-7682-0000BF11C24C3150.model.mlmodel:
 specificationVersion: 4
description {
  input {
    name: &#34;input&#34;
    type {
      multiArrayType {
        shape: 1
        shape: 4
        dataType: FLOAT32
      }
    }
  }
  output {
    name: &#34;output&#34;
    type {
      multiArrayType {
        shape: 1
        shape: 3
        dataType: FLOAT32
      }
    }
  }
}
neuralNetwork {
  layers {
    name: &#34;node_linear&#34;
    input: &#34;input&#34;
    output: &#34;output&#34;
    innerProduct {
      inputChannels: 4
      outputChannels: 3
      weights {
        floatValue: 0.0349225402
        floatValue: -0.301196814
        floatValue: 0.159211695
        floatValue: 0.156890273
        floatValue: -0.267238438
        floatValue: -0.0749385953
        floatValue: -0.292913973
        floatValue: 0.129736364
        floatValue: -0.134683847
        floatValue: 0.351268351
        floatValue: 0.354943156
        floatValue: 0.0509352088
      }
    }
  }
  arrayInputShapeMapping: EXACT_ARRAY_MAPPING
}</code></pre>
<p>NeuralNetwork format has typed input and output to the model, but the nodes themselves are not typed. This is why the model gets cast to FP16, in the NN format the default behaviour is to <b>run in FP16 on the MPS GPU</b>. This quirk of the NN format is what threw off my results<a href="#8"><sup>8</sup></a>. The CoreML runtime also specifies which parts of the model operators can run on which hardware<a href="#9"><sup>9</sup></a> and each hardware has different abilities in terms of what FP values it can handle with the NN format. Take a look at Figure 7 for Apple’s guide on the hardware and FP types they can handle:</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/9b283621-7ad0-43f5-a9ee-69123a4b968f-1-0ec943b6-511b-4627-a592-aa6c19340dea.png"/></p>
<figcaption>Figure 7 - The FP types Apple hardware will use when running the NN format</figcaption>
</figure>
</div>
<p>When running on CPU the NN format model will run in FP32, as we observed. However, on GPU it is implicitly cast to FP16 even though the input and output are specified to be FP32 as you see in the inspection code above. This is an inherent limitation of the NN format. The DAG structure of the model <b>does not store any information on the types of intermediate layers</b>. You can see this in the inspection output, the part beginning neuralNetwork stored info on the actual layer node, in our case a single linear layer. Observe that there is no information on the FP precision of the node itself, hence CoreML implicitly sets it to FP16.</p>
<section id="why-does-coreml-implicitly-use-fp16">
<h4 data-anchor-id="why-does-coreml-implicitly-use-fp16">Why Does CoreML Implicitly Use FP16</h4>
<p>From the typed execution docs for coremltools, the goal of CoreML is to run ML models in the most performant way and FP16 happens to be more performant than FP32 (which makes sense as it’s half the precision) on Apple GPUs. Also, they state that most of the time the reduced precision doesn’t matter for inference - this whole blog post shows why this is false and a pitfall of the NN format, <b>the user should choose which precision the model is ran in, it should never be implicit</b>.</p>
<section id="matmul-test---is-fp16-faster-on-apple-hardware">
<h5 data-anchor-id="matmul-test---is-fp16-faster-on-apple-hardware">MatMul Test - Is FP16 Faster on Apple Hardware?</h5>
<p>To test Apple’s claim that FP16 is more performant on Apple hardware I carried out a large matmul. Taking a 16384x16384 matrix and multiplying it with another 16384x16384 matrix should show us if FP16 is faster. The size is arbitrary I just wanted something large.</p>
<p>The matmul was ran 10 times, <b>in both FP32 and FP16 on the MPS hardware</b>, and we take the average:</p>
<pre><code>FP32 Average Time: 8.6521 seconds
FP16 Average Time: 6.7691 seconds

Speedup Factor: 1.28x faster</code></pre>
<p>So FP16 is quicker, which sheds a bit of light on why the NN format has implicit casting to FP16, on paper if you only care about speed then it’s the better option.</p>
<p>Final point on the NeuralNetwork format, it’s surprising as the weights themselves are stored as FP32 values (a roundtrip test verifies this) but it still executes that layer in FP16, once again showing the NN format doesn’t respect the FP precision of the layer but just casts it to FP16.</p>
<p>All that is to say this, this was <b>not a bug</b> but rather an explicit design choice, which funnily enough involves implicitly going against what the user wants. The NN format has its downsides, which is why Apple introduced the MLProgram format, let’s look into that.</p>
</section>
</section>
</section>
<section id="the-mlprogram-mlp-format">
<h3 data-anchor-id="the-mlprogram-mlp-format">The MLProgram (MLP) Format</h3>
<p>The MLP format is the newer and better model format in CoreML, released in 2021, the core thing we care about is that the intermediate tensors are typed, i.e. there is no implicit casting when using the MLP format - the user controls whether the model is ran in FP16 or FP32.</p>
<p>MLP format allows for this as it uses a different representation of ML models, instead of a DAG it uses a programmatic representation of the models. By representing the model as code, it allows for greater control over the operations.</p>
<p>Let’s see what this looks like in the stored model format and how it differs to the NN format inspection.</p>
<p>The code to do so is pretty similar:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span># First create the InferenceSession and run the model. This ensures the CoreML model files are added to a temp dir. Also</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span># this time we specify the ModelFormat to be MLProgram </span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>ort_mlp <span>=</span> ort.InferenceSession(</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    onnx_path, providers<span>=</span>[(<span>&#34;CoreMLExecutionProvider&#34;</span>, {<span>&#34;ModelFormat&#34;</span>: <span>&#34;MLProgram&#34;</span>})]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>mlp_output <span>=</span> ort_mlp.run(<span>None</span>, {<span>&#34;input&#34;</span>: numpy_input})[<span>0</span>]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span>import</span> coremltools <span>as</span> ct</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span>def</span> get_coreml_dtype_from_spec(path):</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span>&#34;&#34;&#34;Extract model type and dtypes by reading the spec.&#34;&#34;&#34;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    model <span>=</span> ct.models.MLModel(<span>str</span>(path))</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    spec <span>=</span> model.get_spec()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span>print</span>(<span>f&#34;</span><span>\n</span><span>Model Spec for </span><span>{</span>path<span>.</span>name<span>}</span><span>:</span><span>\n</span><span> </span><span>{</span>spec<span>}</span><span>\n</span><span>&#34;</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span># Find created models</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>temp_dir <span>=</span> Path(tempfile.gettempdir())</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span># MLProgram models are in onnxruntime-* directories (not .mlmodelc)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>mlp_dirs <span>=</span> [d <span>for</span> d <span>in</span> temp_dir.glob(<span>&#34;onnxruntime-*&#34;</span>)</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            <span>if</span> d.is_dir() <span>and</span> <span>not</span> <span>str</span>(d).endswith(<span>&#39;.mlmodelc&#39;</span>)]</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span>for</span> model_path <span>in</span> mlp_dirs:</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    info <span>=</span> get_coreml_dtype_from_spec(model_path)</span></code></pre></div>
<p>The output of this is the following:</p>
<pre><code>Model Spec for onnxruntime-752039B9-BA73-47E3-9ED4-AE029184DA69-9443-0000BF278CD8396E:
 specificationVersion: 8
description {
  input {
    name: &#34;input&#34;
    type {
      multiArrayType {
        shape: 1
        shape: 4
        dataType: FLOAT32
      }
    }
  }
  output {
    name: &#34;output&#34;
    type {
      multiArrayType {
        shape: 1
        shape: 3
        dataType: FLOAT32
      }
    }
  }
}
mlProgram {
  version: 1
  functions {
    key: &#34;main&#34;
    value {
      inputs {
        name: &#34;input&#34;
        type {
          tensorType {
            dataType: FLOAT32
            rank: 2
            dimensions {
              constant {
                size: 1
              }
            }
            dimensions {
              constant {
                size: 4
              }
            }
          }
        }
      }
      opset: &#34;CoreML7&#34;
      block_specializations {
        key: &#34;CoreML7&#34;
        value {
          outputs: &#34;output&#34;
          operations {
            type: &#34;const&#34;
            outputs {
              name: &#34;linear_weight&#34;
              type {
                tensorType {
                  dataType: FLOAT32
                  rank: 2
                  dimensions {
                    constant {
                      size: 3
                    }
                  }
                  dimensions {
                    constant {
                      size: 4
                    }
                  }
                }
              }
            }
            attributes {
              key: &#34;val&#34;
              value {
                type {
                  tensorType {
                    dataType: FLOAT32
                    rank: 2
                    dimensions {
                      constant {
                        size: 3
                      }
                    }
                    dimensions {
                      constant {
                        size: 4
                      }
                    }
                  }
                }
                blobFileValue {
                  fileName: &#34;@model_path/weights/weight.bin&#34;
                  offset: 64
                }
              }
            }
            attributes {
              key: &#34;name&#34;
              value {
                type {
                  tensorType {
                    dataType: STRING
                  }
                }
                immediateValue {
                  tensor {
                    strings {
                      values: &#34;linear_weight&#34;
                    }
                  }
                }
              }
            }
          }
          operations {
            type: &#34;linear&#34;
            inputs {
              key: &#34;x&#34;
              value {
                arguments {
                  name: &#34;input&#34;
                }
              }
            }
            inputs {
              key: &#34;weight&#34;
              value {
                arguments {
                  name: &#34;linear_weight&#34;
                }
              }
            }
            outputs {
              name: &#34;output&#34;
              type {
                tensorType {
                  dataType: FLOAT32
                  rank: 2
                  dimensions {
                    constant {
                      size: 1
                    }
                  }
                  dimensions {
                    constant {
                      size: 3
                    }
                  }
                }
              }
            }
            attributes {
              key: &#34;name&#34;
              value {
                type {
                  tensorType {
                    dataType: STRING
                  }
                }
                immediateValue {
                  tensor {
                    strings {
                      values: &#34;node_linear__0&#34;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
<p>Now you see in the inspection of the MLP format model the linear layer is <b>explicitly typed</b>. To make it a bit easier to see let’s bring back the NeuralNetwork format inspection and compare the <b>linear layer setup</b> in both:</p>
<section id="linear-layer-in-neuralnetwork-mlprogram-format">
<h4 data-anchor-id="linear-layer-in-neuralnetwork-mlprogram-format">Linear Layer in NeuralNetwork &amp; MLProgram Format</h4>
<table>
<tbody><tr>
<th>
NeuralNetwork Linear Layer
</th>
<th>
MLProgram Linear Layer
</th>
</tr>
<tr>
<td>
<pre>neuralNetwork {
  layers {
    name: &#34;node_linear&#34;
    input: &#34;input&#34;
    output: &#34;output&#34;
    innerProduct {
      inputChannels: 4
      outputChannels: 3
      weights {
        floatValue: 0.0349225402
        floatValue: -0.301196814
        floatValue: 0.159211695
        floatValue: 0.156890273
        floatValue: -0.267238438
        floatValue: -0.0749385953
        floatValue: -0.292913973
        floatValue: 0.129736364
        floatValue: -0.134683847
        floatValue: 0.351268351
        floatValue: 0.354943156
        floatValue: 0.0509352088
      }
    }
  }
</pre>
</td>
<td>
<pre>operations {
    type: &#34;linear&#34;
    inputs {
      key: &#34;x&#34;
      value {
        arguments {
          name: &#34;input&#34;
        }
      }
    }
    inputs {
      key: &#34;weight&#34;
      value {
        arguments {
          name: &#34;linear_weight&#34;
        }
      }
    }
    outputs {
      name: &#34;output&#34;
      type {
        tensorType {
          dataType: FLOAT32
          rank: 2
          dimensions {
            constant {
              size: 1
            }
          }
          dimensions {
            constant {
              size: 3
            }
          }
        }
      }
    }
</pre>
</td>
</tr>
</tbody></table>
<p>Observe in the NN format, there is no explicit mention of the input or output type also the model weights are stored with the layer. Now, in the MLProgram layer, the output is explicitly typed as FP32. No more pesky implicit casting to FP16! This is one the big changes in MLProgram vs NN format, secondly notice how the layer weights are not stored along with the spec, they’re stored elsewhere. This aspect also makes the MLP format more efficient as the actual model spec is lighter.</p>
</section>
</section>
</section>
<section id="but-why-does-mlprogram-have-typed-layers">
<h2 data-anchor-id="but-why-does-mlprogram-have-typed-layers">But Why Does MLProgram Have Typed Layers?</h2>
<p>So we’ve come to the end of the journey, we found that NeuralNetwork format lacks types in the intermediate layers of the model and MLProgram doesn’t. So, setting ORT to use MLProgram keeps the model at FP32 and our output predictions remain the same when running in PyTorch and ORT. But why, why does NeuralNetwork not include types? Answering this requires a look into how ML models have been represented in the past and how this has evolved over time.</p>
<section id="design-choices-design-choices---how-goals-of-ml-optimisation-evolved-over-time">
<h3 data-anchor-id="design-choices-design-choices---how-goals-of-ml-optimisation-evolved-over-time">Design Choices, Design Choices - How Goals of ML Optimisation Evolved Over Time</h3>
<p>When the NeuralNetwork format was released in 2017, it came into a much different environment than the one MLProgram was born into in 2021. The goal of NeuralNetwork was to act as a <b>configuration file to be ran by hardware</b>, as we saw above it defines the layers and the weights without much other info and lets the hardware figure out the rest. This is indicative of the trends in ML at the time, models were still being optimised so the added complexity wasn’t yet needed, the DAG representation worked well.</p>
<p>In essence, the NN format assumes that if the weights are stored in FP32, the input is FP32 and the output is too then the intermediate layers will also be FP32 - <b>but</b> as it doesn’t explicitly type these intermediate layers the hardware is free to choose and the Apple GPU chooses FP16 by default!</p>
<p>As time went on the demands in the ML world changed, these hardware based quirks became known, optimisations advanced and overall the industry moved away from the splintered (splintered in the sense that many frameworks implemented their own) config style DAGs and began to utilise learnings from the world of compilers</p>
</section>
<section id="changes-from-2017-to-2021-which-lead-to-greater-adoption-of-intermediate-representations">
<h3 data-anchor-id="changes-from-2017-to-2021-which-lead-to-greater-adoption-of-intermediate-representations">Changes From 2017 to 2021 Which Lead to Greater Adoption of Intermediate Representations</h3>
<p>Firstly, for Apple specifically the hardware available expanded, now you have the CPU, GPU and ANE chips - making it very difficult to assume any given piece of hardware will run a specific FP type. Also, the lack of typing leads to other issues namely the compiler cannot make some optimisations, as they depend on knowing the types before runtime. Furthermore, things like mixed FP training and quantization became a thing, once again highlighting the need for explicit typing.</p>
<p>Lastly, in 2017 DAGs and other forms of model compilers were very fragmented and modern times have seen a push towards standardisation<a href="#10"><sup>10</sup></a>, as the compiler community consolidated on tools like LLVM the ML community has too. Intermediate Representations(IR) began to be used in ML, an IR is a hardware agnostic specification of a program which a compiler can optimise. CoreML introduced their own IR, called MIL (Model Intermediate Language) and it implements the output we see in the stored MLProgram output.</p>
</section>
<section id="the-mil-approach">
<h3 data-anchor-id="the-mil-approach">The MIL Approach</h3>
<p>MIL and IRs in general afford a lot of benefits. They are inherently designed for optimisation and by providing a general framework you can extract maximal value as all optimisation engineers can work on a common goal. In MIL specifically, some of the changes we’ve discussed between NN and MLProgram format, are implemented by it. Namely, each variable within the model has an <b>explicit</b> dtype.</p>
<p>Note, the MLProgram serialises and stores the output of the MIL phase, we’ve already observed how it differs to the the NeuralNetwork model, with the biggest difference being in the explicit types.</p>
<section id="further-reading-on-ml-compilers">
<h4 data-anchor-id="further-reading-on-ml-compilers">Further Reading on ML Compilers</h4>
<p><a href="https://huyenchip.com/2021/09/07/a-friendly-introduction-to-machine-learning-compilers-and-optimizers.html">https://huyenchip.com/2021/09/07/a-friendly-introduction-to-machine-learning-compilers-and-optimizers.html</a></p>
</section>
</section>
</section>
<section id="takeaways">
<h2 data-anchor-id="takeaways">Takeaways</h2>
<section id="the-fix">
<h3 data-anchor-id="the-fix">The Fix</h3>
<p>The solution to all the issues we discussed today is, if you are using the <b>CoreMLExecutionProvider</b> in ORT then be sure to specify <b>ModelFormat is MLProgram</b>, this will ensure that whatever precision your model was trained it will be ran with that - which in my case was FP32 (whereas the default ModelFormat NeuralNetwork casts the model to FP16).</p>
<p>You can implement this as such:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ort_session <span>=</span> ort.InferenceSession(onnx_model_path, providers<span>=</span>[(<span>&#34;CoreMLExecutionProvider&#34;</span>, {<span>&#34;ModelFormat&#34;</span>: <span>&#34;MLProgram&#34;</span>})])</span></code></pre></div>
</section>
<section id="the-cause">
<h3 data-anchor-id="the-cause">The Cause</h3>
<p>The issue was the differing model formats employed by CoreML to represent ML models. The NeuralNetwork format utilised a more historic DAG based approach which was developed during a time in which types and precision wasn’t a huge concern in the ML community and hardware decisions were left to the hardware. Whereas the MLProgram format used a programmatic approach, in which types are explicit letting the software influence how the model is run on the hardware.</p>
</section>
<section id="lessons">
<h3 data-anchor-id="lessons">Lessons?</h3>
<p>This whole thing taught me the importance of being thorough, it’s not acceptable to test your model in one setup and deploy it in another. We really need to test our model runs across all the platforms we intend to deploy to. Secondly, implicit defaults can be particularly damaging, in my case it wasn’t a huge issue but it easily could have been. Implicit defaults in this case also killed reproducibility, which can be problematic.</p>
<p>Lastly, I leave you with this:</p>
<div>
<figure>
<p><img src="https://ym2132.github.io/ONNX_MLProgram_NN_exploration_files/figure-html/09ba20cf-1ae6-4e1b-875e-d0ca1e37e4b4-1-541e273a-258d-4878-b89b-73cbda03aa89.png"/></p>
<figcaption>Figure 9 - An Excerpt from https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference/</figcaption>
</figure>
</div>
<hr/>
<p><a id="1" href=""><sup>1</sup></a><a href="https://onnx.ai/onnx/intro/concepts.html">https://onnx.ai/onnx/intro/concepts.html</a></p>
<p><a id="2" href=""><sup>2</sup></a><a href="https://onnxruntime.ai">https://onnxruntime.ai</a></p>
<p><a id="3" href=""><sup>3</sup></a><a href="https://developer.apple.com/documentation/coreml">https://developer.apple.com/documentation/coreml</a></p>
<p><a id="4" href=""><sup>4</sup></a><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">https://en.wikipedia.org/wiki/Single-precision_floating-point_format</a></p>
<p><a id="5" href=""><sup>5</sup></a><a href=" https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a></p>
<p><a id="6" href=""><sup>6</sup></a><a href="https://floating-point-gui.de/formats/fp/">https://floating-point-gui.de/formats/fp/</a></p>
<p><a id="7" href=""><sup>7</sup></a><a href="https://apple.github.io/coremltools/mlmodel/Format/NeuralNetwork.html">https://apple.github.io/coremltools/mlmodel/Format/NeuralNetwork.html</a></p>
<p><a id="8" href=""><sup>8</sup></a><a href="https://apple.github.io/coremltools/docs-guides/source/typed-execution.html">https://apple.github.io/coremltools/docs-guides/source/typed-execution.html</a></p>
<p><a id="9" href=""><sup>9</sup></a><a href="https://github.com/microsoft/onnxruntime/issues/21271#issuecomment-3637845056">https://github.com/microsoft/onnxruntime/issues/21271#issuecomment-3637845056</a></p>
<p><a id="10" href=""><sup>10</sup></a><a href="https://www.modular.com/blog/democratizing-ai-compute-part-8-what-about-the-mlir-compiler-infrastructure">https://www.modular.com/blog/democratizing-ai-compute-part-8-what-about-the-mlir-compiler-infrastructure</a></p>
</section>
</section>

</main>
<!-- /main column -->

</div></div>
  </body>
</html>
