<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.artificialworlds.net/blog/2022/07/06/building-cross-platform-rust-for-web-android-and-ios-a-minimal-example/">Original</a>
    <h1>Building cross-platform Rust for Web, Android and iOS – a minimal example</h1>
    
    <div id="readability-page-1" class="page"><div>
					<p>Hi Andy,</p>
<p>Thanks for the great intro/reference. We’re currently looking at building a cross platform rust app targeting Android and Web. Being  new to Rust, we’re in the process of getting our heads around the idea that we must choose an async runtime to underpin async language features like futures. We don’t have a need for multi-threading, but DX-friendly concurrency abstractions like futures and event-based/reactive programming will help us a lot in our particular domain which is heavily async.</p>
<p>Do you have any recommendation for how to solve this cross platform? We’ve seen that WASM bindgen can convert futures code to promises, but this ultimately ends up in the JS layer. I guess what we’re looking for is the ability for our rust module to use things like futures and events internally, and expose related methods/events/callbacks externally to JavaScript or Java/Kotlin code.</p>
<p>A concrete example would be the ability for the rust code to schedule an HTTP request and await a response, where the making of request is delegated to fetch or OkHttp respectively, and the response returned.</p>
<p>Any help much appreciated!</p>
				</div></div>
  </body>
</html>
