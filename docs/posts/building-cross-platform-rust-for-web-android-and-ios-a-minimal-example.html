<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.artificialworlds.net/blog/2022/07/06/building-cross-platform-rust-for-web-android-and-ios-a-minimal-example/">Original</a>
    <h1>Building cross-platform Rust for Web, Android and iOS – a minimal example</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3426">
	
	<!-- .entry-header -->

	<!-- AJB social -->
	                                


	<div>
		<p>One of the advantages of writing code in <a href="https://www.rust-lang.org/">Rust</a> is that it can be re-used in other places. Both iOS and Android allow using native libraries within your apps, and Rust compiles to native. Web pages can now use <a href="https://webassembly.org/">WebAssembly</a> (WASM), and Rust can compile to WASM.</p>
<p>So, it should be easy, right?</p>
<p>Well, in practice it seems a little tricky, so I created a small example project to explain it to myself, so maybe it’s helpful to you too.</p>
<p>The full code is at <a href="https://gitlab.com/andybalaam/example-rust-bindings">gitlab.com/andybalaam/example-rust-bindings</a>, but here is the general idea:</p>
<ul>
<li><strong><tt>crates/example-rust-bindings</tt></strong> – the real Rust code</li>
<li><strong><tt>bindings/ffi</tt></strong> – uniffi code to build shared objects for Android and iOS</li>
<li><strong><tt>bindings/wasm</tt></strong> – wasm_bingen code to build WASM for Web</li>
<li><strong><tt>examples/example-android</tt></strong> – an Android app that generates a Kotlin wrapper, and runs the code in the shared object</li>
<li><strong><tt>examples/example-ios</tt></strong> – an iOS XCode project where we generate Swift bindings, so we can call the code in the shared object</li>
<li><strong><tt>examples/example-web</tt></strong> – a web page that imports the WASM and runs it</li>
</ul>
<h2>Steps for WASM</h2>
<p><img decoding="async" src="https://www.artificialworlds.net/blog/wp-content/uploads/wasm-firefox.png" alt="Proof that I did this on Web - Firefox showing &#34;This string is from Rust!&#34;" width="456" height="340" srcset="https://www.artificialworlds.net/blog/wp-content/uploads/wasm-firefox.png 456w, https://www.artificialworlds.net/blog/wp-content/uploads/wasm-firefox-300x224.png 300w" sizes="(max-width: 456px) 100vw, 456px"/></p>
<ul>
<li>Write normal Rust code e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/src/lib.rs">crates/example-rust-bindings/src/lib.rs</a> (and <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/Cargo.toml">Cargo.toml</a> etc. to go with it, with nothing special in it)</li>
<li>Write <tt>wasm-bindgen</tt> wrappers for all interfaces you want to expose e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/wasm/src/lib.rs">bindings/wasm/src/lib.rs</a> (and <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/wasm/Cargo.toml">Cargo.toml</a> to go with it, depending on <tt>wasm-bindgen</tt>). This basically involves creating structs and functions annotated with <tt>#[wasm_bindgen]</tt> that call through to the real underlying code from the previous step.</li>
<li>Write a <tt>package.json</tt> with a <tt>build</tt> step that calls <tt>wasm-pack</tt> e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/wasm/package.json#L31">bindings/wasm/package.json</a></li>
<li>Build the bindings with npm (see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/wasm/README.md">bindings/wasm/README.md</a>)</li>
<li>Copy the generated .js  and .wasm files into a web project</li>
<li>Include the generated .js file into an HTML file using an <tt>import</tt> statement in a module e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/examples/example-web/index.html">examples/example-web/index.html</a></li>
</ul>
<p>Variation: if you modify the <tt>build</tt> script in <tt>package.json</tt> to call <tt>wasm-pack</tt> with <tt>--target node</tt> instead of <tt>--target web</tt> you can generate code suitable for using from a NodeJS module.</p>
<h2>Steps for Android</h2>
<p><img decoding="async" loading="lazy" src="https://www.artificialworlds.net/blog/wp-content/uploads/native-android.png" alt="Proof that I did this on Android: Android emulator showing a label &#34;This string is from Rust!&#34;" width="241" height="507" srcset="https://www.artificialworlds.net/blog/wp-content/uploads/native-android.png 241w, https://www.artificialworlds.net/blog/wp-content/uploads/native-android-143x300.png 143w" sizes="(max-width: 241px) 100vw, 241px"/></p>
<ul>
<li>Write normal Rust code e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/src/lib.rs">crates/example-rust-bindings/src/lib.rs</a> (and <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/Cargo.toml">Cargo.toml</a> etc. to go with it, with nothing special in it)</li>
<li>Write a UDL file to describe your interfaces e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/src/my_rust_code.udl">bindings/ffi/src/my_rust_code.udl</a></li>
<li>Implement those interfaces in some Rust code, wrapping returned values in <tt>Arc</tt> e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/src/lib.rs">bindings/ffi/src/lib.rs</a>.</li>
<li>Write a <tt>Cargo.toml</tt> that builds the bindings e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/Cargo.toml">bindings/ffi/Cargo.toml</a></li>
<li>Generate uniffi bindings scaffolding during the Cargo build by writing a <tt>build.rs</tt> file e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/build.rs">bindings/ffi/build.rs</a></li>
<li>Get the Android NDK and set up Cargo’s config to use it to build – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Cross-compile for the Android platforms you need by adding the targets using <tt>rustup</tt> and then building using <tt>cargo build --target=blah</tt> – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Copy the built .so shared object files into your Android project under `jniLibs/INSERT_PLATFORM` – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>In your Android project, add a <tt>android.applicationVariants.all</tt> section to your <tt>app/build.gradle</tt> that generates Kotlin wrappers around the shared objects e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/examples/example-android/app/build.gradle">examples/example-android/app/build.gradle</a></li>
<li>Now you can write normal Kotlin that accesses your Rust code via a namespace like <tt>uniffi.my_rust_code</tt> e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/examples/example-android/app/src/main/java/net/artificialworlds/exampleandroid/MainActivity.kt">MainActivity.kt</a></li>
</ul>
<h2>Steps for iOS</h2>
<ul>
<li>Write normal Rust code e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/src/lib.rs">crates/example-rust-bindings/src/lib.rs</a> (and <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/crates/example-rust-bindings/Cargo.toml">Cargo.toml</a> etc. to go with it, with nothing special in it)</li>
<li>Write a UDL file to describe your interfaces e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/src/my_rust_code.udl">bindings/ffi/src/my_rust_code.udl</a></li>
<li>Implement those interfaces in some Rust code, wrapping returned values in <tt>Arc</tt> e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/src/lib.rs">bindings/ffi/src/lib.rs</a>.</li>
<li>Write a <tt>Cargo.toml</tt> that builds the bindings e.g. <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/Cargo.toml">bindings/ffi/Cargo.toml</a></li>
<li>Generate uniffi bindings – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md#ios-1">bindings/ffi/README.md</a></li>
<li>Cross-compile for the iOS platforms you need by adding the targets using <tt>rustup</tt> and then building using <tt>cargo build --target=blah</tt> – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Combine together the built libraries using <tt>lipo</tt> – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Copy the combined .a library file into your XCode project – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Generate an XCode project with <tt>xcodebuild</tt> – see <a href="https://gitlab.com/andybalaam/example-rust-bindings/-/blob/main/bindings/ffi/README.md">bindings/ffi/README.md</a></li>
<li>Now you can write normal Swift that accesses your Rust code [TODO: details]</li>
	</ul></div><!-- .entry-content -->

	<!-- AJB social -->
	                                


	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
