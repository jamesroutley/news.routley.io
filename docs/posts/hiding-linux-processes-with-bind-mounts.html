<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://righteousit.com/2024/07/24/hiding-linux-processes-with-bind-mounts/">Original</a>
    <h1>Hiding Linux Processes with Bind Mounts</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Lately I’ve been thinking about <a href="https://www.linkedin.com/in/stephan-berger-59575a20a/" target="_blank" rel="noreferrer noopener">Stephan Berger’s</a> recent blog post on <a href="https://dfir.ch/posts/slash-proc/">hiding Linux processes with bind mounts</a>. Bottom line here is that if you have an evil process you want to hide, use a bind mount to mount a different directory on top of the <kbd>/proc/<em>PID</em></kbd> directory for the evil process.</p>



<p>In the original article, Stephan uses a nearly empty directory to overlay the original <kbd>/proc/<em>PID</em></kbd> directory for the process he is hiding. I started thinking about how I could write a tool that would populate a more realistic looking spoofed directory. But after doing some prototypes and running into annoying complexities I realized there is a much easier approach.</p>



<p>Why try and make my own spoofed directory when I can simply use an existing <kbd>/proc/<em>PID</em></kbd> directory from some other process? If you look at typical Linux <kbd>ps </kbd>output, there are lots of process entries that would hide our evil process quite well:</p>



<pre><code><kbd>root@LAB:~# <strong>ps -ef</strong>
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Jul23 ?        00:00:12 /sbin/init
root           2       0  0 Jul23 ?        00:00:00 [kthreadd]
root           3       2  0 Jul23 ?        00:00:00 [rcu_gp]
root           4       2  0 Jul23 ?        00:00:00 [rcu_par_gp]
<em>[...]</em>
root          73       2  0 Jul23 ?        00:00:00 [irq/24-pciehp]
root          74       2  0 Jul23 ?        00:00:00 [irq/25-pciehp]
root          75       2  0 Jul23 ?        00:00:00 [irq/26-pciehp]
root          76       2  0 Jul23 ?        00:00:00 [irq/27-pciehp]
root          77       2  0 Jul23 ?        00:00:00 [irq/28-pciehp]
root          78       2  0 Jul23 ?        00:00:00 [irq/29-pciehp]
root          79       2  0 Jul23 ?        00:00:00 [irq/30-pciehp]</kbd></code></pre>



<p>These process entries with low PIDs and process names in square brackets (“<kbd>[<em>somename</em>]</kbd>“) are <em>spontaneous processes</em>. They aren’t running executables in the traditional sense– you won’t find a binary in your operating system called <kbd>kthreadd </kbd>for example. Instead, these are essentially kernel code dressed up to look like a process so administrators can monitor various subsystems using familiar tools like <kbd>ps</kbd>.</p>



<p>From our perspective, however, they’re a bunch of processes that administrators generally ignore and which have names that vary only slightly from one another. They’re perfect for hiding our evil processes:</p>



<pre><code><kbd>root@LAB:~# <strong>ps -ef | grep myevilprocess</strong>
root        4867       1  0 Jul23 pts/0    00:00:16 myevilprocess
root@LAB:~# <strong>mount -B /proc/78 /proc/4867</strong>
root@LAB:~# <strong>ps -ef | grep 4867</strong></kbd></code></pre>



<p>Our evil process is now completely hidden. If somebody were to look closely at the <kbd>ps </kbd>output, they would discover there are now two entries for PID 78:</p>



<pre><code><kbd>root@LAB:~# <strong>ps -ef | awk &#39;$2 == 78&#39;</strong>
root          78       2  0 Jul23 ?        00:00:00 [irq/29-pciehp]
root          78       2  0 Jul23 ?        00:00:00 [irq/29-pciehp]</kbd></code></pre>



<p>My guess is that nobody is going to notice this unless they are specifically looking for this technique. And if they are aware of this technique, there’s a much simpler way of detecting it which Stephan notes in his original article:</p>



<pre><code><kbd>root@LAB:~# <strong>cat /proc/mounts | grep /proc</strong>
proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime,fd=29,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=424 0 0
proc /proc/4867 proc rw,nosuid,nodev,noexec,relatime 0 0</kbd></code></pre>



<p>The last line above is a dead giveaway that something hinky is going on.</p>



<p>We can refine Stephan’s approach:</p>



<pre><code><kbd>root@LAB:~# <strong>cat /proc/*/mounts | awk &#39;$2 ~ /^\/proc\/[0-9]*($|\/)/ { print $2 }&#39; | sort -ur</strong>
/proc/4867</kbd></code></pre>



<p>Just to be thorough, I’m dumping the content of all <kbd>/proc/*/mount</kbd> entries (<kbd>/proc/mounts</kbd> is a link to <kbd>/proc/self/mounts</kbd>) and looking for ones where the mount point is a <kbd>/proc/</kbd><em><kbd>PID</kbd> </em>directory or one of its subdirectories. The “<kbd>sort -ur</kbd>” at the end gives us one instance of each unique mount point.</p>



<p>But why the “<kbd>-r</kbd>” option? I want to use my output to programmatically unmount the bind mounted directories. I was worried about somebody doing a bind mount on top of a bind mount:</p>



<pre><code><kbd>root@LAB:~# <strong>mount -B /proc/79/fd /proc/4867/fd</strong>
root@LAB:~# <strong>cat /proc/*/mounts | awk &#39;$2 ~ /^\/proc\/[0-9]*($|\/)/ { print $2 }&#39; | sort -ur</strong>
/proc/78/fd
/proc/4867/fd
/proc/4867
root@LAB:~# <strong>cat /proc/*/mounts | awk &#39;$2 ~ /^\/proc\/[0-9]*($|\/)/ { print $2 }&#39; | sort -ur | 
    while read dir; do umount $dir; done</strong>
umount: /proc/4867/fd: not mounted.
root@LAB:~# <strong>ps -ef | grep myevilprocess</strong>
root        4867       1  0 Jul23 pts/0    00:00:16 myevilprocess</kbd></code></pre>



<p>While I think this scenario is extremely unlikely, using “<kbd>sort -ur</kbd>” means that the mount points are returned in the proper order to be unmounted. And once the bind mounts are umounted, we can see the evil process again.</p>



<p>Note that we do get an error here. <kbd>/proc/78</kbd> is mounted on top of <kbd>/proc/4867</kbd>. So when we unmount <kbd>/proc/78/fd</kbd> we are also taking care of the spoofed path <kbd>/proc/4867/fd</kbd>. When our <kbd>while </kbd>loop gets to the entry for <kbd>/proc/4867/fd</kbd>, the <kbd>umount </kbd>command errors out.</p>



<p>Possible weird corner cases aside, let’s try and provide our analyst with some additional information:</p>



<pre><code><kbd>root@LAB:~# <strong>function procbindmounts {
  cat /proc/*/mounts | awk &#39;$2 ~ /^\/proc\/[0-9]*($|\/)/ { print $2 }&#39; | sort -ur | 
    while read dir; do 
        echo ===== POSSIBLE PROCESS HIDING $dir
        echo -ne Overlay:\\t
        cut -d&#39; &#39; -f1-7 $dir/stat
        umount $dir
        echo -ne Hidden:\\t\\t
        cut -d&#39; &#39; -f1-7 $dir/stat
    done
}</strong>
root@LAB:~# <strong>mount -B /proc/78 /proc/4867</strong>
root@LAB:~# <strong>procbindmounts</strong>
===== POSSIBLE PROCESS HIDING /proc/4867
Overlay:        78 (irq/29-pciehp) S 2 0 0 0
Hidden:         4867 (myevilprocess) S 1 4867 4759 34816</kbd></code></pre>



<p>Thanks Stephan for getting my creative juices flowing. This is a fun technique for all you red teamers out there, and a good trick for all you blue team analysts.</p>
			</div><div>
				<p><img alt="" src="https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=100&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D100" srcset="https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=100&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D100 1x, https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=150&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D150 1.5x, https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=200&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D200 2x, https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=300&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D300 3x, https://2.gravatar.com/avatar/2008f9e677214d2749a70f58812fdbad545d7e2ebb9fea0b733552e0f51c734b?s=400&amp;d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D400 4x" height="100" width="100" loading="lazy" decoding="async"/>		</p><!-- .author-avatar -->
		
		<!-- .author-heading -->

		<p>
			Independent Computer Forensics and Information Security consultant.  Expert Witness. Trainer.			<a href="https://righteousit.com/author/halpomeranz/" rel="author">
				View all posts by Hal Pomeranz			</a>
		</p><!-- .author-bio -->
	</div></div>
  </body>
</html>
