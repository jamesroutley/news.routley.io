<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.lenot.re/a/introduction">Original</a>
    <h1>Maestro: A Linux-compatible kernel in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
					
					<h6><span id="date-long">2024-01-02T15:00:00+00:00</span></h6>
					<p>
						Maestro is a Unix-like kernel and operating system written from scratch in Rust
					</p>
					<p><img src="https://blog.lenot.re/assets/article/neofetch.png"/>
				</p></div><div>
					<p>Thanks to the internet, I can learn how most things I am interested in work. However, something stayed a mystery to me for a long time: computers.</p>
<p>Computers are amongst the most complex tools that humanity has ever built. They are a marvel of engineering that we take for granted because we use them in our everyday lives.</p>
<p>I like to dig into complexity, and I like to learn by doing.
On top of that, I spend a lot of time on the computer. Wouldn’t it be cool if I had a system that I would know from A to Z and that I could customise as much as I wanted to fit my expectations?</p>
<p>This is why I decided to build <a href="https://github.com/llenotre/maestro" target="_blank">Maestro</a>. A Unix-like operating system that is meant to be lightweight and compatible-enough with Linux to be usable in everyday life.</p>
<h2>A bit of history</h2>
<p>The first commit of the kernel dates back to December 22nd, 2018, at 3:18 in the morning (the best time to write code, of course). It started as a school project.</p>
<p>It was originally implemented using the <strong>C language</strong> and continued to be for roughly a year and a half, until the codebase became too hard to keep clean.</p>
<p>At that moment, I decided to switch to <strong>Rust</strong> (my first project in this language), which represented several advantages:</p>
<ul>
<li>Restart the project from the beginning, using lessons learned from previous mistakes</li>
<li>Be a bit more innovative than just writing a Linux-like kernel in C. After all, just use Linux at that point</li>
<li>Use the safety of the Rust language to leverage some difficulty of kernel programming. Using Rust’s typing system allows to shift some responsibility over memory safety from the programmer to the compiler</li>
</ul>
<p>In kernel development, debugging is very hard for several reasons:</p>
<ul>
<li>Documentation is often hard to find, and BIOS implementations may be flawed (more often than you would think)</li>
<li>On boot, the kernel has full access to the memory and is allowed to write where it should not (its own code, for example)</li>
<li>Troubleshooting memory leaks is not easy. Tools such as <em>valgrind</em> cannot be used</li>
<li><em>gdb</em> can be used with <em>QEMU</em> and <em>VMWare</em>, but the kernel may have a different behaviour when running on a different emulator or virtual machine. Also, those emulators may not support gdb (example <em>VirtualBox</em>)</li>
<li>Some features in the support for gdb in QEMU or VMWare are missing (such as <em>Record and Replay</em>) and gdb might even crash sometimes</li>
</ul>
<p>All those issues are reasons for using a memory-safe language, to avoid them as much as possible.</p>
<p>Overall, the use of Rust in the kernel allowed for the implementation of a lot of safeguards. And I believe that it is, to this day, the best decision I have made for this project.</p>
<h3>Timelapse</h3>
<video controls="" width="100%" loading="lazy">
  <source src="https://blog.lenot.re/assets/article/gource.mp4" type="video/mp4"/>
</video>
<p>Created using <a href="https://gource.io/" target="_blank">Gource</a>. Music: <em>Many Moons of Saturn, Mike Cole</em></p>
<h2>The current state of the project</h2>
<p>Maestro is a monolithic kernel, supporting only the x86 (in 32 bits) architecture for now.</p>
<p>At the time of writing, <strong>135</strong> out of <strong>437</strong> Linux system calls (roughly 31%) are more or less implemented.
The project has <strong>48 800</strong> lines of code across <strong>615</strong> files (all repositories combined, counted using the <code>cloc</code> command).</p>
<p>The OS currently has the following components, aside from the kernel:</p>
<ul>
<li><a href="https://github.com/llenotre/solfege" target="_blank">Solfège</a>: a boot system and daemon manager (kind of similar to systemd, but lighter)</li>
<li><a href="https://github.com/llenotre/maestro-utils" target="_blank">maestro-utils</a>: system utility commands</li>
<li><a href="https://github.com/llenotre/blimp" target="_blank">blimp</a>: a package manager</li>
<li>And more components that are available on <a href="https://github.com/llenotre" target="_blank">my github</a></li>
</ul>
<p>So far, the following third-party software has been tested and is working on the OS:</p>
<ul>
<li>musl (C standard library)</li>
<li>bash</li>
<li>Some GNU coreutils commands such as <code>ls</code>, <code>cat</code>, <code>mkdir</code>, <code>rm</code>, <code>rmdir</code>, <code>uname</code>, <code>whoami</code>, etc…</li>
<li>neofetch (a patched version, since the original neofetch does not know about my OS)</li>
</ul>
<h2>Test it yourself!</h2>
<blockquote>
<p><strong>Disclaimer</strong>: It is important to note that the OS is still in a very early stage of development and is highly unstable. I discourage trying to install it on a machine with important data on it.</p>
<p>So far, it has been tested mostly on QEMU, VMWare and VirtualBox.</p>
</blockquote>
<p>There are two ways you can install the OS:</p>
<ul>
<li>Use a pre-built (compressed) .iso file that you can download <a href="https://blog.lenot.re/assets/article/maestro.iso.gz">here</a></li>
<li><a href="https://github.com/llenotre/maestro-install/" target="_blank">Build the ISO yourself</a></li>
</ul>
<p>The ISO provides an installer for the OS. You can use it on QEMU, VMWare or VirtualBox for example.</p>
<blockquote>
<p>You should run the ISO with sufficient RAM (<strong>1GB</strong> should be more than enough).</p>
<p>Such an amount of memory is required because packages to be installed are stored in RAM (on the initramsfs) instead of the disk. This is currently the best method since the OS is <em>not yet</em> able to read on a USB stick or CD-ROM by itself, so it relies on the bootloader for this.</p>
</blockquote>
<h2>What this blog is about</h2>
<p>The aim of this blog is <strong>not</strong> to write tutorials about how to create an OS. This is already well covered by other websites/blogs. I recommend in particular:</p>
<ul>
<li><a href="https://wiki.osdev.org/Expanded_Main_Page" target="_blank">osdev.org</a></li>
<li><a href="https://os.phil-opp.com/" target="_blank">Philipp Oppermann’s blog</a></li>
</ul>
<p>The goal is to explore more advanced subjects (since most people/blogs tend to stop at the basics), to push the subjects as far as I am able to, to write articles about problems I encounter and how I solve them, to discover how computers work underneath, but also operating systems, the internet, and much more… Plenty of things to talk about!</p>
<h2>What’s coming next?</h2>
<p>Cleaning of the codebase and performance optimisations are in order. Since the OS started as a school project, I had to cut corners in order to finish it on time. But now is the time to pay back the technical debt I accumulated.</p>
<p>Some memory leaks are also lying around and have to be fixed. Performance optimisations will probably be a subject for blog articles.</p>
<p>The next leap forward will be to have the package manager fully working on the OS. To do so, some features are required:</p>
<ul>
<li>Network support, which is currently under development. And will probably be the subject of numerous articles</li>
<li>Shared library support. This currently does not work because it requires mapping files directly into memory, which is not currently supported by the implementation of the <code>mmap</code> system call on the kernel</li>
</ul>
<p>After that, I will be able to install (without pain) and test programmes such as compilers (gcc/g++, clang, rustc), make, Git, Vim, etc… And then develop the kernel while using it!</p>
<p>The development of the kernel largely follows a simple procedure:</p>
<ul>
<li><strong>1</strong>: Run a programme on the kernel and see if it works correctly</li>
<li><strong>2</strong>: If it does not work, then:
<ul>
<li><strong>3</strong>: Run the programme while printing system calls and search for the first system call that is causing troubles (not implemented or buggy)</li>
<li><strong>4</strong>: Implement or fix the system call in question</li>
<li><strong>5</strong>: Go to step 1</li>
</ul>
</li>
<li><strong>6</strong>: Else: Yay!</li>
</ul>
<p>The more programmes running correctly on the kernel, the more stable and complete it becomes!</p>
<h2>How <em>you</em> can help</h2>
<p>You can leave a star ⭐ on the <a href="https://github.com/llenotre/maestro" target="_blank">Github repository of the kernel</a> ❤️</p>
<p>And stay in touch by:</p>
<ul>
<li>Subscribing to the newsletter on the <a href="https://blog.lenot.re/">main page</a></li>
<li>Watching the <a href="https://blog.lenot.re/rss">RSS feed</a></li>
</ul>
<p>Do not hesitate to join Discord! If you have feedback to make, advice to give, or questions to ask, I will be glad to answer!</p>

				</div></div>
  </body>
</html>
