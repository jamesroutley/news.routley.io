<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xeiaso.net/notes/cursorless-alien-magic/">Original</a>
    <h1>Cursorless is alien magic from the future</h1>
    
    <div id="readability-page-1" class="page"><div>
            



<article>
    
    <p>
        Published on 11/09/2023, 1396 words, 6 minutes to read
    </p>

    

    <p>Just in time for me to start a new job at a new place, my RSI has decided to flare up.</p>
<div><p><img alt="Cadey is coffee" loading="lazy" src="https://cdn.xeiaso.net/sticker/cadey/coffee/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#cadey"><b>Cadey</b></a>&gt; </p><p>For the record, I&#39;m fine, I&#39;ve known this has been coming for a while. The
flare-up is on its exit anyways. I&#39;ve gotten lucky and I&#39;m going to be fine.
But it&#39;s still a bit of a bummer.</p></div></div>
<p>The last time this happened, I was able to get by by doing mostly writing about technology things, but I think I&#39;m going to need to be able to program again. I know I&#39;m a bit of an emacs user, but for this I&#39;ve been using visual studio code because of one extension in particular: <a href="https://marketplace.visualstudio.com/items?itemName=pokey.cursorless">Cursorless</a>.</p>
<p>Cursorless is a plugin that integrates with voice control software to let you do AST level code editing with your voice. This is crazy alien magic from the future.</p>
<p>I&#39;ve talked about cursorless before on my blog, but I have decided to really get deep into it this time around. The last time I used it, I didn&#39;t actually use it for much more than moving around the screen, but this time I&#39;m going to try to use it for everything.</p>
<p>I wish I had this as an input method for slack and discord messages.</p>
<p>The most magic parts about this are the ideas of destinations and targets when it comes to cursorless inputs. Targets are individual anchors in a document and destinations are places relative to individual targets. Every single token in a document is given a hat over a letter with a color. These hats act as anchors that let you give commands based off of locations, destinations, and paths between them. Here&#39;s a simple example. Consider this code:</p>
<pre><code><span><span>function</span> <span>fetchBlog</span><span>(</span><span>)</span> <span>{</span>
</span><span>  <span>fetch</span><span>(</span><span>&#34;https://xeiaso.net/blog.json&#34;</span><span>)</span>
</span><span>    <span>.</span><span>then</span><span>(</span><span>(</span><span>response</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>      <span>if</span> <span>(</span><span>!</span>response<span>.</span><span>ok</span><span>)</span> <span>{</span>
</span><span>        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;Network response was not ok&#34;</span><span>)</span><span>;</span>
</span><span>      <span>}</span>
</span><span>      <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>}</span><span>)</span>
</span><span>    <span>.</span><span>then</span><span>(</span><span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span>data<span>)</span><span>)</span>
</span><span>    <span>.</span><span>catch</span><span>(</span><span>(</span><span>error</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>error</span><span>(</span><span>&#34;Error:&#34;</span><span>,</span> error<span>)</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>This is a fairly standard looking JavaScript function. But, cursorless puts a bunch of hats over all of the code so it may look something like this:</p>
<figure><a href="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.jpg"><picture><source type="image/avif" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.avif"/><source type="image/webp" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.webp"/><img loading="lazy" src="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.jpg"/></picture></a></figure>
<div><p><img alt="Aoi is wut" loading="lazy" src="https://cdn.xeiaso.net/sticker/aoi/wut/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#aoi"><b>Aoi</b></a>&gt; </p><p>So that&#39;s why your editor is full of random video artifacts?</p></div></div>
<div><p><img alt="Cadey is enby" loading="lazy" src="https://cdn.xeiaso.net/sticker/cadey/enby/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#cadey"><b>Cadey</b></a>&gt; </p><p>They&#39;re not artifacts, they&#39;re targets!</p></div></div>
<p>Take a good look at that picture again:</p>
<figure><a href="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.jpg"><picture><source type="image/avif" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.avif"/><source type="image/webp" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.webp"/><img loading="lazy" src="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-hats.jpg"/></picture></a></figure>
<p>The hats are color coded above individual letters. The position tells you the name and the color tells you how to disambiguate it. For example, That word <code>function</code> would be referred to as <code>green urge</code> because the hat is green over the letter u. If I wanted to delete that word for some reason or if I wanted to move it somewhere else, I could use <code>green urge</code> as the target for that action.</p>
<p>By itself, this gives you some pretty powerful actions and effectively lets you do spoken vim motions. But, that is only thinking in terms of simple actions that you can do with your editor. The real power of cursorless comes in from not only the idea of paths (such as <code>green urge past green bat</code> to select the <code>function fetchBlog</code> in that screenshot), but the fact that cursorless knows what the AST of the language is doing. This means that you can do things across the entire function, like deleting it or moving it somewhere else. As an example, here are the lambdas of this function visualized separately (with the &#34;visualize lambdas&#34; command):</p>
<figure><a href="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-lambda.jpg"><picture><source type="image/avif" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-lambda.avif"/><source type="image/webp" srcset="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-lambda.webp"/><img loading="lazy" src="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/cursorless-lambda.jpg"/></picture></a></figure>
<p>These AST units are also targets. This means that I can do things like select the body of a definition and then work off of that. So if I want to refactor this into an asynchronous function, the refactoring becomes trivial:</p>
<p><img src="https://cdn.xeiaso.net/file/christine-static/blog/2023/cl-note/async-refactor.gif" alt="a gif of doing the process of refactoring a synchronous function to an async function by writing it all using talon commands"/></p>
<div><p><img alt="Aoi is grin" loading="lazy" src="https://cdn.xeiaso.net/sticker/aoi/grin/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#aoi"><b>Aoi</b></a>&gt; </p><p>That&#39;s pretty cool, but I don&#39;t think I&#39;d be able to remember all of those
commands.</p></div></div>
<div><p><img alt="Cadey is enby" loading="lazy" src="https://cdn.xeiaso.net/sticker/cadey/enby/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#cadey"><b>Cadey</b></a>&gt; </p><p>After a while, they just become second nature like Vim commands do. I have
been forcing myself to use this over and over again for the past few days and
it&#39;s starting to become second nature. I&#39;m introducing individual commands at
one of the time and building up into bigger and better things.</p></div></div>
<p>The real magic comes when you start writing your own commands with the full power of Cursorless and Talon. In that example I just showed you, I have a action for inserting <code>&#34;async &#34;</code> before the function definition. Here is the code for that:</p>
<pre><code><span>[state] async &lt;user.cursorless_destination&gt;:
</span><span>    user.cursorless_insert(cursorless_destination, &#34;async&#34;)
</span></code></pre>
<p>You can break talon commands into two basic parts: patterns and captures. Patterns are the spoken words that you say and captures are the things that you want to extract out of what you say. In this case, the pattern is just the word <code>async</code> and the capture is the destination that you want to insert the word <code>async</code> before. The <code>&lt;user.cursorless_destination&gt;</code> capture is a special capture lets you specify if you want something before or after a target. Of course, this is just a very simple example and it can get way more intricate than this.</p>
<p>Here is the most complicated Talon rule I&#39;ve written so far:</p>
<pre><code><span>(method|meth) &lt;user.letter&gt; [&lt;user.go_pointer&gt;] [&lt;user.go_visibility&gt;] &lt;user.text&gt; [over] [&lt;user.go_visibility&gt;] named &lt;user.text&gt; [over]:
</span><span>    user.go_method(go_pointer or &#34;&#34;, letter, go_visibility_1 or &#34;public&#34;, text_1, go_visibility_2 or &#34;public&#34;, text_2)
</span></code></pre>
<div><p><img alt="Aoi is wut" loading="lazy" src="https://cdn.xeiaso.net/sticker/aoi/wut/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#aoi"><b>Aoi</b></a>&gt; </p><p>What the heck is going on there?</p></div></div>
<p>This looks like a lot, but it is actually really simple. This lets you declare a method in Go. In Go, a method looks like this:</p>
<pre><code><span><span>func</span> <span>(</span>reciever <span>*</span>Type<span>)</span> <span>MethodName</span><span>(</span><span>)</span> <span>{</span>
</span><span>    
</span><span><span>}</span>
</span></code></pre>
<p>Pedantically, Go doesn&#39;t have methods in the traditional sense, it just has functions that take structs as the receiver (read: a hidden first argument but in a way that is namespaced to that struct in particular). Without something to automate writing this for you, you would have to say something like this:</p>
<blockquote>
<p>state funk args word reciever space star hammer type over go right space hammer method name args go right brack enter</p>
</blockquote>
<p>That&#39;s a lot of words to say. But, with this talon rule, you can just say:</p>
<blockquote>
<p>meth r raised type named method name over</p>
</blockquote>
<div><p><img alt="Aoi is wut" loading="lazy" src="https://cdn.xeiaso.net/sticker/aoi/wut/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#aoi"><b>Aoi</b></a>&gt; </p><p>That&#39;s still a lot of words.</p></div></div>
<div><p><img alt="Cadey is enby" loading="lazy" src="https://cdn.xeiaso.net/sticker/cadey/enby/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#cadey"><b>Cadey</b></a>&gt; </p><p>Well, yes, you&#39;re not going to be able to get over that. But this is at least
more efficient and it makes more sense. I&#39;m not going to be able to get rid of
all of the words, but I can at least make it so that it&#39;s close to how I
conceptualize it in my head.</p></div></div>
<div><p><img alt="Aoi is wut" loading="lazy" src="https://cdn.xeiaso.net/sticker/aoi/wut/64"/></p><div><p>&lt;<a href="https://xeiaso.net/characters#aoi"><b>Aoi</b></a>&gt; </p><p>I guess that makes sense, but what do you mean by raised? I don&#39;t think go has
raised types I know it has pointers but not &#34;raising&#34;. What is raising?</p></div></div>
<p>I&#39;m glad you asked! This is something that I&#39;m experimenting with to try to find a different way to explain the concept of pointers in Go. I think that one of the oversights in the Go language is that pointers use C-style syntax. This specifically has you use an <code>*</code> to lower a value from a pointer value to a normal value and <code>&amp;</code> to raise the value from a normal value into a pointer value.</p>
<p>Since I&#39;m taking the opportunity to radically redesign the Talon bindings for Go, I want to try unifying the syntax of pointer values into the idea of raising and lowering to see how it makes it easier to understand Go programs. I don&#39;t know if this is a good idea, but you have to fuck around in order to find out.</p>
<p>Maybe some parts of our industry are actually good. I really hope that I get led into the <a href="https://githubnext.com/projects/copilot-voice/">GitHub copilot voice beta</a> soon, I want to compare how Talon does voice coding versus how copilot voice does it.</p>

    

    

    <p>Facts and circumstances may have changed since publication. Please contact me before jumping to conclusions if something seems wrong or unclear.</p>

    <p>Tags: cursorless, vscode</p>
</article>
        </div><div>
            <p>Copyright 2012-2023 Xe Iaso (Christine Dodrill). Any and all opinions listed here are my own and
                not representative of any of my employers, past, future, and/or present.</p>
            
            <p>Served by xesite v4 (/nix/store/hbfma2zzmqix0v1a78jl63s7i9vm98vc-xesite_v4-20231028/bin/xesite) with site version <a href="https://github.com/Xe/site/commit/78edfd198f62f1f37f91101c9c3cc91a301e9ff2">78edfd19</a>, source code available <a href="https://github.com/Xe/site">here</a>.</p>
        </div></div>
  </body>
</html>
