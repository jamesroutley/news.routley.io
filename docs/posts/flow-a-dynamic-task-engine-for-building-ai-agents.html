<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lmnr-ai/flow">Original</a>
    <h1>Show HN: Flow â€“ A dynamic task engine for building AI agents</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A lightweight task engine for building AI agents that prioritizes simplicity and flexibility.</p>

<p dir="auto">Unlike traditional node and edge-based workflows, Flow uses a dynamic task queue system built on three simple principles:</p>
<ol dir="auto">
<li><strong>Concurrent Execution</strong> - Tasks run in parallel automatically</li>
<li><strong>Dynamic Scheduling</strong> - Tasks can schedule new tasks at runtime</li>
<li><strong>Smart Dependencies</strong> - Tasks can await results from previous operations</li>
</ol>
<p dir="auto">Results of all tasks are stored in a thread-safe <code>Context</code>.</p>
<p dir="auto">This task-based architecture makes complex workflows surprisingly simple:</p>
<ul>
<li> Parallel task execution without explicit threading code</li>
<li> Self-modifying dynamic workflows and cycles</li>
<li> Conditional branching and control flow</li>
<li> Streaming of tasks execution</li>
<li> State management, load previous state and save current state</li>
<li> Start execution from a specific task</li>
<li> Dynamically push next tasks with specific inputs</li>
<li> Map Reduce, running the same task in parallel on multiple inputs and collecting results</li>
</ul>
<p dir="auto">By removing the need to predefine edges between nodes, and opting for a dynamic task scheduling architecture, Flow helps you write better and cleaner code by making it easier to reason about control flow and dependencies.</p>
<p dir="auto">Flow is lightweight, bloat-free, and has no external dependencies for the engine. It is designed to be simple, flexible and very powerful, and is maintained by the <a href="https://github.com/lmnr-ai/lmnr">Laminar</a> team.</p>

<p dir="auto">Flow comes with auto-instrumentation for tracing using <a href="https://github.com/lmnr-ai/lmnr">Laminar</a>. To enable OpenTelemetry-based tracing, initialize the Laminar SDK before using Flow.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from lmnr import Laminar
Laminar.initialize(project_api_key=&#34;...&#34;)"><pre><span>from</span> <span>lmnr</span> <span>import</span> <span>Laminar</span>
<span>Laminar</span>.<span>initialize</span>(<span>project_api_key</span><span>=</span><span>&#34;...&#34;</span>)</pre></div>
<blockquote>
<p dir="auto">Tracing is extremely useful for debugging and state reconstruction. When tracing is enabled, Flow will automatically capture the state at each step. During debugging, you can load the captured state and inspect the context. To learn more about tracing, see the <a href="https://docs.lmnr.ai" rel="nofollow">Laminar docs</a>.</p>
</blockquote>




<div dir="auto" data-snippet-clipboard-copy-content="from concurrent.futures import ThreadPoolExecutor
from lmnr_flow import Flow, TaskOutput, NextTask, Context, StreamChunk

# thread pool executor is optional, defaults to 4 workers
flow = Flow(thread_pool_executor=ThreadPoolExecutor(max_workers=4))

# Simple task that returns a result
def my_task(context: Context) -&gt; TaskOutput:
    return TaskOutput(output=&#34;Hello World!&#34;)

flow.add_task(&#34;greet&#34;, my_task)
result = flow.run(&#34;greet&#34;)  # Returns {&#34;greet&#34;: &#34;Hello World!&#34;}"><pre><span>from</span> <span>concurrent</span>.<span>futures</span> <span>import</span> <span>ThreadPoolExecutor</span>
<span>from</span> <span>lmnr_flow</span> <span>import</span> <span>Flow</span>, <span>TaskOutput</span>, <span>NextTask</span>, <span>Context</span>, <span>StreamChunk</span>

<span># thread pool executor is optional, defaults to 4 workers</span>
<span>flow</span> <span>=</span> <span>Flow</span>(<span>thread_pool_executor</span><span>=</span><span>ThreadPoolExecutor</span>(<span>max_workers</span><span>=</span><span>4</span>))

<span># Simple task that returns a result</span>
<span>def</span> <span>my_task</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;Hello World!&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;greet&#34;</span>, <span>my_task</span>)
<span>result</span> <span>=</span> <span>flow</span>.<span>run</span>(<span>&#34;greet&#34;</span>)  <span># Returns {&#34;greet&#34;: &#34;Hello World!&#34;}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Tasks can trigger other tasks
def task1(context: Context) -&gt; TaskOutput:
    return TaskOutput(output=&#34;result1&#34;, [NextTask(&#34;task2&#34;)])

def task2(context: Context) -&gt; TaskOutput:
    # Access results from previous tasks
    t1_result = context.get(&#34;task1&#34;)  # waits for task1 to complete
    return TaskOutput(output=&#34;result2&#34;)

flow.add_task(&#34;task1&#34;, task1)
flow.add_task(&#34;task2&#34;, task2)
flow.run(&#34;task1&#34;)  # Returns {&#34;task2&#34;: &#34;result2&#34;}"><pre><span># Tasks can trigger other tasks</span>
<span>def</span> <span>task1</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;result1&#34;</span>, [<span>NextTask</span>(<span>&#34;task2&#34;</span>)])

<span>def</span> <span>task2</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span># Access results from previous tasks</span>
    <span>t1_result</span> <span>=</span> <span>context</span>.<span>get</span>(<span>&#34;task1&#34;</span>)  <span># waits for task1 to complete</span>
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;result2&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;task1&#34;</span>, <span>task1</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;task2&#34;</span>, <span>task2</span>)
<span>flow</span>.<span>run</span>(<span>&#34;task1&#34;</span>)  <span># Returns {&#34;task2&#34;: &#34;result2&#34;}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def starter(context: Context) -&gt; TaskOutput:
    # Launch multiple tasks in parallel
    return TaskOutput(output=&#34;started&#34;, [NextTask(&#34;slow_task1&#34;), NextTask(&#34;slow_task2&#34;)])

def slow_task1(context: Context) -&gt; TaskOutput:
    time.sleep(1)
    return TaskOutput(output=&#34;result1&#34;)

def slow_task2(context: Context) -&gt; TaskOutput:
    time.sleep(1)
    return TaskOutput(output=&#34;result2&#34;)

# Both slow_tasks execute in parallel, taking ~1 second total
flow.add_task(&#34;starter&#34;, starter)
flow.add_task(&#34;slow_task1&#34;, slow_task1)
flow.add_task(&#34;slow_task2&#34;, slow_task2)
flow.run(&#34;starter&#34;)"><pre><span>def</span> <span>starter</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span># Launch multiple tasks in parallel</span>
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;started&#34;</span>, [<span>NextTask</span>(<span>&#34;slow_task1&#34;</span>), <span>NextTask</span>(<span>&#34;slow_task2&#34;</span>)])

<span>def</span> <span>slow_task1</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>time</span>.<span>sleep</span>(<span>1</span>)
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;result1&#34;</span>)

<span>def</span> <span>slow_task2</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>time</span>.<span>sleep</span>(<span>1</span>)
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;result2&#34;</span>)

<span># Both slow_tasks execute in parallel, taking ~1 second total</span>
<span>flow</span>.<span>add_task</span>(<span>&#34;starter&#34;</span>, <span>starter</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;slow_task1&#34;</span>, <span>slow_task1</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;slow_task2&#34;</span>, <span>slow_task2</span>)
<span>flow</span>.<span>run</span>(<span>&#34;starter&#34;</span>)</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def streaming_task(context: Context) -&gt; TaskOutput:
    # Stream intermediate results
    stream = context.get_stream()
    for i in range(3):
        # (task_id, chunk_value)
        stream.put(StreamChunk(&#34;streaming_task&#34;, f&#34;interim_{i}&#34;))
    return TaskOutput(output=&#34;final&#34;)

flow.add_task(&#34;streaming_task&#34;, streaming_task)

# Get results as they arrive
for task_id, output in flow.stream(&#34;streaming_task&#34;):
    print(f&#34;{task_id}: {output}&#34;)
    # Prints:
    # streaming_task: interim_0
    # streaming_task: interim_1
    # streaming_task: interim_2
    # streaming_task: final"><pre><span>def</span> <span>streaming_task</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span># Stream intermediate results</span>
    <span>stream</span> <span>=</span> <span>context</span>.<span>get_stream</span>()
    <span>for</span> <span>i</span> <span>in</span> <span>range</span>(<span>3</span>):
        <span># (task_id, chunk_value)</span>
        <span>stream</span>.<span>put</span>(<span>StreamChunk</span>(<span>&#34;streaming_task&#34;</span>, <span>f&#34;interim_<span><span>{</span><span>i</span><span>}</span></span>&#34;</span>))
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;final&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;streaming_task&#34;</span>, <span>streaming_task</span>)

<span># Get results as they arrive</span>
<span>for</span> <span>task_id</span>, <span>output</span> <span>in</span> <span>flow</span>.<span>stream</span>(<span>&#34;streaming_task&#34;</span>):
    <span>print</span>(<span>f&#34;<span><span>{</span><span>task_id</span><span>}</span></span>: <span><span>{</span><span>output</span><span>}</span></span>&#34;</span>)
    <span># Prints:</span>
    <span># streaming_task: interim_0</span>
    <span># streaming_task: interim_1</span>
    <span># streaming_task: interim_2</span>
    <span># streaming_task: final</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def conditional_task(context: Context) -&gt; TaskOutput:
    count = context.get(&#34;count&#34;, 0)
    
    if count &gt;= 3:
        return TaskOutput(output=&#34;done&#34;)
    
    context.set(&#34;count&#34;, count + 1)
    return TaskOutput(output=f&#34;iteration_{count}&#34;, [NextTask(&#34;conditional_task&#34;)])

# Task will loop 3 times before finishing
flow.add_task(&#34;conditional_task&#34;, conditional_task)
flow.add_task(&#34;finish&#34;, lambda ctx: TaskOutput(&#34;completed&#34;, None))
flow.run(&#34;conditional_task&#34;)"><pre><span>def</span> <span>conditional_task</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>count</span> <span>=</span> <span>context</span>.<span>get</span>(<span>&#34;count&#34;</span>, <span>0</span>)
    
    <span>if</span> <span>count</span> <span>&gt;=</span> <span>3</span>:
        <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;done&#34;</span>)
    
    <span>context</span>.<span>set</span>(<span>&#34;count&#34;</span>, <span>count</span> <span>+</span> <span>1</span>)
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>f&#34;iteration_<span><span>{</span><span>count</span><span>}</span></span>&#34;</span>, [<span>NextTask</span>(<span>&#34;conditional_task&#34;</span>)])

<span># Task will loop 3 times before finishing</span>
<span>flow</span>.<span>add_task</span>(<span>&#34;conditional_task&#34;</span>, <span>conditional_task</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;finish&#34;</span>, <span>lambda</span> <span>ctx</span>: <span>TaskOutput</span>(<span>&#34;completed&#34;</span>, <span>None</span>))
<span>flow</span>.<span>run</span>(<span>&#34;conditional_task&#34;</span>)</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def parameterized_task(context: Context) -&gt; TaskOutput:
    name = context.get(&#34;user_name&#34;)
    return TaskOutput(output=f&#34;Hello {name}!&#34;)

flow.add_task(&#34;greet&#34;, parameterized_task)
result = flow.run(&#34;greet&#34;, inputs={&#34;user_name&#34;: &#34;Alice&#34;})
# Returns {&#34;greet&#34;: &#34;Hello Alice!&#34;}"><pre><span>def</span> <span>parameterized_task</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>name</span> <span>=</span> <span>context</span>.<span>get</span>(<span>&#34;user_name&#34;</span>)
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>f&#34;Hello <span><span>{</span><span>name</span><span>}</span></span>!&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;greet&#34;</span>, <span>parameterized_task</span>)
<span>result</span> <span>=</span> <span>flow</span>.<span>run</span>(<span>&#34;greet&#34;</span>, <span>inputs</span><span>=</span>{<span>&#34;user_name&#34;</span>: <span>&#34;Alice&#34;</span>})
<span># Returns {&#34;greet&#34;: &#34;Hello Alice!&#34;}</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Push next task with inputs</h3><a id="user-content-push-next-task-with-inputs" aria-label="Permalink: Push next task with inputs" href="#push-next-task-with-inputs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="def task1(ctx):
    return TaskOutput(&#34;result1&#34;, [NextTask(&#34;task2&#34;, inputs={&#34;input1&#34;: &#34;value1&#34;})])

# task2 will be called with inputs={&#34;input1&#34;: &#34;value1&#34;}
def task2(ctx, inputs):
    assert inputs == {&#34;input1&#34;: &#34;value1&#34;}
    return TaskOutput(&#34;result2&#34;)

flow.add_task(&#34;task1&#34;, task1)
flow.add_task(&#34;task2&#34;, task2)
result = flow.run(&#34;task1&#34;)
# Returns {&#34;task2&#34;: &#34;result2&#34;}"><pre><span>def</span> <span>task1</span>(<span>ctx</span>):
    <span>return</span> <span>TaskOutput</span>(<span>&#34;result1&#34;</span>, [<span>NextTask</span>(<span>&#34;task2&#34;</span>, <span>inputs</span><span>=</span>{<span>&#34;input1&#34;</span>: <span>&#34;value1&#34;</span>})])

<span># task2 will be called with inputs={&#34;input1&#34;: &#34;value1&#34;}</span>
<span>def</span> <span>task2</span>(<span>ctx</span>, <span>inputs</span>):
    <span>assert</span> <span>inputs</span> <span>==</span> {<span>&#34;input1&#34;</span>: <span>&#34;value1&#34;</span>}
    <span>return</span> <span>TaskOutput</span>(<span>&#34;result2&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;task1&#34;</span>, <span>task1</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;task2&#34;</span>, <span>task2</span>)
<span>result</span> <span>=</span> <span>flow</span>.<span>run</span>(<span>&#34;task1&#34;</span>)
<span># Returns {&#34;task2&#34;: &#34;result2&#34;}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def router(context: Context) -&gt; TaskOutput:
    task_type = context.get(&#34;type&#34;)
    routes = {
        &#34;process&#34;: [NextTask(&#34;process_task&#34;)],
        &#34;analyze&#34;: [NextTask(&#34;analyze_task&#34;)],
        &#34;report&#34;: [NextTask(&#34;report_task&#34;)]
    }
    return TaskOutput(output=f&#34;routing to {task_type}&#34;, routes.get(task_type, []))

def process_task(context: Context) -&gt; TaskOutput:
    return TaskOutput(output=&#34;processed data&#34;)

flow.add_task(&#34;router&#34;, router)
flow.add_task(&#34;process_task&#34;, process_task)
result = flow.run(&#34;router&#34;, inputs={&#34;type&#34;: &#34;process&#34;})
# Returns {&#34;process_task&#34;: &#34;processed data&#34;}"><pre><span>def</span> <span>router</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>task_type</span> <span>=</span> <span>context</span>.<span>get</span>(<span>&#34;type&#34;</span>)
    <span>routes</span> <span>=</span> {
        <span>&#34;process&#34;</span>: [<span>NextTask</span>(<span>&#34;process_task&#34;</span>)],
        <span>&#34;analyze&#34;</span>: [<span>NextTask</span>(<span>&#34;analyze_task&#34;</span>)],
        <span>&#34;report&#34;</span>: [<span>NextTask</span>(<span>&#34;report_task&#34;</span>)]
    }
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>f&#34;routing to <span><span>{</span><span>task_type</span><span>}</span></span>&#34;</span>, <span>routes</span>.<span>get</span>(<span>task_type</span>, []))

<span>def</span> <span>process_task</span>(<span>context</span>: <span>Context</span>) <span>-&gt;</span> <span>TaskOutput</span>:
    <span>return</span> <span>TaskOutput</span>(<span>output</span><span>=</span><span>&#34;processed data&#34;</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;router&#34;</span>, <span>router</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;process_task&#34;</span>, <span>process_task</span>)
<span>result</span> <span>=</span> <span>flow</span>.<span>run</span>(<span>&#34;router&#34;</span>, <span>inputs</span><span>=</span>{<span>&#34;type&#34;</span>: <span>&#34;process&#34;</span>})
<span># Returns {&#34;process_task&#34;: &#34;processed data&#34;}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="context = Context()
context.from_dict({&#34;task1&#34;: &#34;result1&#34;})

flow = Flow(context=context)
flow.add_task(&#34;task2&#34;, lambda ctx: TaskOutput(&#34;result2&#34;))
flow.run(&#34;task2&#34;)

assert flow.context.get(&#34;task1&#34;) == &#34;result1&#34; # True, because it was set in the context
assert flow.context.get(&#34;task2&#34;) == &#34;result2&#34;


# Serialize the context to a dictionary
flow.get_context().to_dict()
# Returns {&#34;task1&#34;: &#34;result1&#34;, &#34;task2&#34;: &#34;result2&#34;}"><pre><span>context</span> <span>=</span> <span>Context</span>()
<span>context</span>.<span>from_dict</span>({<span>&#34;task1&#34;</span>: <span>&#34;result1&#34;</span>})

<span>flow</span> <span>=</span> <span>Flow</span>(<span>context</span><span>=</span><span>context</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;task2&#34;</span>, <span>lambda</span> <span>ctx</span>: <span>TaskOutput</span>(<span>&#34;result2&#34;</span>))
<span>flow</span>.<span>run</span>(<span>&#34;task2&#34;</span>)

<span>assert</span> <span>flow</span>.<span>context</span>.<span>get</span>(<span>&#34;task1&#34;</span>) <span>==</span> <span>&#34;result1&#34;</span> <span># True, because it was set in the context</span>
<span>assert</span> <span>flow</span>.<span>context</span>.<span>get</span>(<span>&#34;task2&#34;</span>) <span>==</span> <span>&#34;result2&#34;</span>


<span># Serialize the context to a dictionary</span>
<span>flow</span>.<span>get_context</span>().<span>to_dict</span>()
<span># Returns {&#34;task1&#34;: &#34;result1&#34;, &#34;task2&#34;: &#34;result2&#34;}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="def task1(ctx):
    ctx.set(&#34;collector&#34;, [])

    return TaskOutput(&#34;result1&#34;, [
        NextTask(&#34;task2&#34;, spawn_another=True),
        NextTask(&#34;task2&#34;, spawn_another=True),
        NextTask(&#34;task2&#34;, spawn_another=True)
    ])

def task2(ctx):
    collector = ctx.get(&#34;collector&#34;)
    collector.append(&#34;result2&#34;)
    ctx.set(&#34;collector&#34;, collector)

    return TaskOutput(&#34;&#34;, [NextTask(&#34;task3&#34;)])

def task3(ctx):
    collector = ctx.get(&#34;collector&#34;)
    return TaskOutput(collector)

flow.add_task(&#34;task1&#34;, task1)
flow.add_task(&#34;task2&#34;, task2)
flow.add_task(&#34;task3&#34;, task3)

result = flow.run(&#34;task1&#34;)
assert result == {&#34;task3&#34;: [&#34;result2&#34;, &#34;result2&#34;, &#34;result2&#34;]}"><pre><span>def</span> <span>task1</span>(<span>ctx</span>):
    <span>ctx</span>.<span>set</span>(<span>&#34;collector&#34;</span>, [])

    <span>return</span> <span>TaskOutput</span>(<span>&#34;result1&#34;</span>, [
        <span>NextTask</span>(<span>&#34;task2&#34;</span>, <span>spawn_another</span><span>=</span><span>True</span>),
        <span>NextTask</span>(<span>&#34;task2&#34;</span>, <span>spawn_another</span><span>=</span><span>True</span>),
        <span>NextTask</span>(<span>&#34;task2&#34;</span>, <span>spawn_another</span><span>=</span><span>True</span>)
    ])

<span>def</span> <span>task2</span>(<span>ctx</span>):
    <span>collector</span> <span>=</span> <span>ctx</span>.<span>get</span>(<span>&#34;collector&#34;</span>)
    <span>collector</span>.<span>append</span>(<span>&#34;result2&#34;</span>)
    <span>ctx</span>.<span>set</span>(<span>&#34;collector&#34;</span>, <span>collector</span>)

    <span>return</span> <span>TaskOutput</span>(<span>&#34;&#34;</span>, [<span>NextTask</span>(<span>&#34;task3&#34;</span>)])

<span>def</span> <span>task3</span>(<span>ctx</span>):
    <span>collector</span> <span>=</span> <span>ctx</span>.<span>get</span>(<span>&#34;collector&#34;</span>)
    <span>return</span> <span>TaskOutput</span>(<span>collector</span>)

<span>flow</span>.<span>add_task</span>(<span>&#34;task1&#34;</span>, <span>task1</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;task2&#34;</span>, <span>task2</span>)
<span>flow</span>.<span>add_task</span>(<span>&#34;task3&#34;</span>, <span>task3</span>)

<span>result</span> <span>=</span> <span>flow</span>.<span>run</span>(<span>&#34;task1&#34;</span>)
<span>assert</span> <span>result</span> <span>==</span> {<span>&#34;task3&#34;</span>: [<span>&#34;result2&#34;</span>, <span>&#34;result2&#34;</span>, <span>&#34;result2&#34;</span>]}</pre></div>

<ul dir="auto">
<li><strong>Context Sharing</strong>: All tasks share the same context, allowing for complex data flows</li>
<li><strong>Error Handling</strong>: Exceptions in tasks are properly propagated</li>
<li><strong>Thread Safety</strong>: All operations are thread-safe</li>
<li><strong>Minimal Dependencies</strong>: Core engine has zero external dependencies</li>
</ul>

<ul>
<li> Add async support</li>
<li> Serverless deployment</li>
</ul>
</article></div></div>
  </body>
</html>
