<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kmcd.dev/posts/grpc-the-ugly-parts/">Original</a>
    <h1>gRPC: The Ugly Parts</h1>
    
    <div id="readability-page-1" class="page"><div><p>gRPC has undeniably become a powerful tool in the world of microservices, offering efficiency and performance benefits, but gRPC also has an ugly side. As someone who’s spent a considerable amount of time with gRPC, I’d like to shed light on some of the uglier aspects of this technology. I’ve already talked about the <a href="https://kmcd.dev/posts/grpc-the-good-parts">good</a> and <a href="https://kmcd.dev/posts/grpc-the-bad-parts">bad</a> parts of gRPC, now let’s talk about the ugly.</p><h2 id="generated-code">Generated Code</h2><p>To get started, I have to talk about how ugly the code generated from protobuf definitions is. It has historically been verbose, complex, and difficult to navigate. Even though it’s not meant to be hand-edited, this can impact code readability and maintainability, especially when integrating gRPC into larger projects. This has actually improved a lot recently in most languages but even so, there are some rough edges.</p><h3 id="language-specific-quirks">Language-specific Quirks</h3><p>Protobuf and gRPC’s initial implementations often diverged from language-specific norms, especially in their HTTP handling. This stemmed partly from the decision to mandate HTTP/2 support, a decision that has since proven to limit gRPC’s reach into the web frontend. We know now from gRPC-Web that trailers aren’t a hard requirement for a protocol like gRPC. In the aftermath of this decision, we are now left with a need to evolve the language implementations of protobuf and gRPC to be more idiomatic for each language.</p><p>For Go, avoiding the <code>net/http</code> package is a rough decision because it makes it harder to use gRPC endpoints alongside other kinds of HTTP APIs and to re-use HTTP middleware. They eventually added a <a href="https://pkg.go.dev/google.golang.org/grpc#Server.ServeHTTP" rel="external"><code>ServeHTTP()</code></a> interface to grpc-go as an experimental way to use the HTTP server from the Go standard library but using that method results in <a href="https://kmcd.dev/posts/benchmarking-go-grpc/">a significant loss of performance</a>. Maybe they did it for performance reasons? If so, it’s definitely a tradeoff that has split gRPC from the rest of the Go ecosystem.</p><p>Sometimes language quirks actually impact how you design protobuf types. If you follow the style recommendations from <a href="https://buf.build/docs/best-practices/style-guide" rel="external">Buf</a>, the names of enums are expected to be prefixed an upper-snake-case version of the enum name, like so:</p><div><pre tabindex="0"><code data-lang="protobuf"><span><span><span>enum</span> FooBar <span>{</span><span>
</span></span></span><span><span><span></span>  FOO_BAR_UNSPECIFIED <span>=</span> <span>0</span><span>;</span><span>
</span></span></span><span><span><span></span>  FOO_BAR_FIRST_VALUE <span>=</span> <span>1</span><span>;</span><span>
</span></span></span><span><span><span></span>  FOO_BAR_SECOND_VALUE <span>=</span> <span>2</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This is described better in the <a href="https://buf.build/docs/lint/rules#enum_value_prefix" rel="external">buf lint rule description</a> for <code>ENUM_VALUE_PREFIX</code> but the style guide is like this because of C++ scoping rules with enums, which makes it impossible to have two enum values in the same package with the same enum value name. While this convention originated from C++ scoping rules, it affects how you should design all protobuf files. Why would scoping inside of the enum not be enough for the C++ compiler to generate unique names? Why is this flaw something that impacts the style guide and, in effect, all target languages? To me, this is kind of ugly, because quirks of some language implementations are bubbling up in unintuitive ways.</p><h3 id="the-generated-code-isnt-even-that-fast">The generated code isn’t even that fast</h3><p>One benefit of generated code is that you can generate code that no sane human would write in order to get some performance optimizations. However, if you look at some of the code generated from protobuf you’ll see runtime reflection used a lot. Why? In a way, I am saying the generated code <em>isn’t ugly enough</em>. Let’s look at a concrete example. Be warned that this will be a very Go-specific section because most of my experience with protobufs is in Go. However, the same strategy has been applied in most languages.</p><p>Let’s take a look at super a simple example in Go. Here’s the protobuf:</p><div><pre tabindex="0"><code data-lang="protobuf"><span><span><span>message</span> <span>Hello</span> <span>{</span><span>
</span></span></span><span><span><span></span>  <span>string</span> name <span>=</span> <span>1</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Here’s the type generated by protoc:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> Hello <span>struct</span> <span>{</span>
</span></span><span><span>	state         protoimpl<span>.</span>MessageState
</span></span><span><span>	sizeCache     protoimpl<span>.</span>SizeCache
</span></span><span><span>	unknownFields protoimpl<span>.</span>UnknownFields
</span></span><span><span>
</span></span><span><span>	Name <span>string</span> <span>`protobuf:&#34;bytes,1,opt,name=name,proto3&#34; json:&#34;name,omitempty&#34;`</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// With these methods, contents are stripped
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>*</span>Hello<span>)</span> <span>Reset</span><span>()</span>
</span></span><span><span><span>func</span> <span>(</span><span>*</span>Hello<span>)</span> <span>String</span><span>()</span> <span>string</span>
</span></span><span><span><span>func</span> <span>(</span><span>*</span>Hello<span>)</span> <span>ProtoMessage</span><span>()</span>
</span></span><span><span><span>func</span> <span>(</span><span>*</span>Hello<span>)</span> <span>ProtoReflect</span><span>()</span> protoreflect<span>.</span>Message
</span></span></code></pre></div><p>There’s actually no <code>Marshal()</code> or <code>Unmarshal()</code> functions defined specifically for this type. This means that runtime reflection is used to make serialization work. Reflection is generally seen as slower, because it <em>is</em> slower. I find it strange that optimized, type-specific serialization code isn’t being generated for Go. That said, you can actually get this by using a separate protoc plugin called <a href="https://github.com/planetscale/vtprotobuf" rel="external">vtprotobuf</a> that will generate specialized marshal and unmarshal functions for each protobuf type. It also allows for using type-specific memory pools, which can also help reduce allocations and improve performance. From my <a href="https://kmcd.dev/posts/benchmarking-go-grpc/">own testing</a> just adding <code>vtprotobuf</code> with zero code changes can improve performance by 2-4%. This is essentially a “free” 2-4%, so it’s super strange to me that this wouldn’t be part of the standard compiler. <a href="https://github.com/sudorandom/go-grpc-bench/blob/v0.0.1/gen/flex_vtproto.pb.go#L573" rel="external">You may not like it, but this is what peak performance looks like</a>. Anyway, this project needs more love and support.</p><p>Note that there are <a href="https://medium.com/@octopus.dev/gremlin-77af6fee4193" rel="external">other efforts which claim outrageous improvements</a> over what the standard protobuf library does. They do make tradeoffs to achieve these performance gains, but many times the extra complexity is worth it.</p><p>You might have read this section and thought “well, this would increase the amount of code being generated and increase binary or package sizes and in some environments, you might not want that. That’s true amd that’s why protobuf has an <code>optimize_for</code> option, so you can annotate one of the following:</p><ul><li><code>option optimize_for = SPEED;</code> - more verbose, faster code</li><li><code>option optimize_for = CODE_SIZE;</code> - smaller code</li><li><code>option optimize_for = LITE_RUNTIME;</code> - intended to run on a smaller runtime that omits features like descriptors and reflection.</li></ul><p>See the full description for optimize_for on the <a href="https://protobuf.dev/programming-guides/proto3/" rel="external">official protobuf documentation</a>. While these options exist, they aren’t actually used for most target languages. In the future I would totally like to see most of <code>vtprotobuf</code> be rolled into the standard protobuf compiler for Go and be used if <code>optimize_for = SPEED</code>. Integrating <code>vtprotobuf</code>-like optimizations into the standard protobuf compiler could offer significant performance gains for Go and there are potentially similar opportunities in other languages as well.</p><h2 id="required-fields">Required Fields</h2><p>The maintainers of protobuf learned some hard lessons with required fields. They felt like they misstepped so badly, that they made a new version of protobuf, proto3, just to remove required fields from the spec. Why? The author of the “Required considered harmful” manifesto talks about this in a <a href="https://news.ycombinator.com/item?id=18190005" rel="external">lengthy hacker news comment</a>, but the important bit is:</p><blockquote><p>Real-world practice has also shown that quite often, fields that originally seemed to be “required” turn out to be optional over time, hence the “required considered harmful” manifesto. In practice, you want to declare all fields optional to give yourself maximum flexibility for change.</p></blockquote><p>This is <a href="https://protobuf.dev/programming-guides/dos-donts/#add-required" rel="external">echoed by the official style guide of protobufs</a>, where they recommend adding a comment indicating that a field is required. If we’re talking about getting a message from A to B, I totally agree with this line of thinking. However, just because the fields that are considered “required” change over time doesn’t mean required fields don’t exist. There still needs to be code that enforces this requirement and I’d rather not write this code, to be honest. Therefore, I think the best way of handling required fields without writing a bunch of null checks everywhere is by using <a href="https://github.com/bufbuild/protovalidate" rel="external">protovalidate</a> or a similar library that has protobuf options that allow you to annotate which fields are required. Then there is code on the server and/or client that can enforce these requirements using a library. In my opinion, this has the best of both worlds: you can still declare required fields in a way that doesn’t completely break message integrity.</p><p>I don’t like this:</p><div><pre tabindex="0"><code data-lang="protobuf"><span><span><span>message</span> <span>User</span> <span>{</span><span>
</span></span></span><span><span><span></span>  <span>int32</span> age <span>=</span> <span>1</span><span>;</span> <span>// required.
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>I do like this:</p><div><pre tabindex="0"><code data-lang="protobuf"><span><span><span>message</span> <span>User</span> <span>{</span><span>
</span></span></span><span><span><span></span>  <span>int32</span> age <span>=</span> <span>1</span> <span>[(</span>buf.validate.field<span>)</span><span>.</span><span>required</span> <span>=</span> <span>true</span><span>];</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>I’m a big fan of <a href="https://github.com/bufbuild/protovalidate" rel="external">protovalidate</a> and I’ve used it a good amount and have contributed to it. Generally, I think <a href="https://protobuf.dev/programming-guides/proto3/#customoptions" rel="external">custom options</a> for protobuf fields is an untapped superpower of protobufs.</p><h2 id="failure-to-launch">Failure to Launch</h2><p>While gRPC has undeniable advantages, its learning curve can be steep. Getting started with protobuf, understanding the tooling, and setting up the necessary infrastructure can be intimidating for newcomers, making the initial adoption hurdle higher than with simpler JSON-based APIs. Why is it steep? Well, it introduces non-idiomatic tooling to most languages. There are some examples of language support that make protobuf generation seamless. <a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/basics" rel="external">Grpc.Tools</a> for .NET is one shining example, showing how protobuf tooling can be more integrated into standard language tooling. We need more of this.</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/learning-curve.png" width="600px"/></p><p>The steep learning curve doesn’t help when many people who use and rely on protobuf and gRPC actively don’t want gRPC to extend to the frontend and think that pushing in this direction will lead to uninformed people encroaching on the domain of the backend, where only they are smart enough to work. This is elitist gate-keeping and is unfortunately prevalent in this industry. I believe gRPC has as much of a place in web frontends as much as it does in microservices.</p><p>I’ve learned a lot by helping others work with protobuf. You may see me on <a href="https://buf.build/links/slack" rel="external">Buf’s slack channel</a> or on related discussions because I truly have gotten a lot out of it. Many article ideas have come directly from answering questions there. If I see a problem often enough, I may end up writing an article about it. I believe the protobuf and gRPC community needs more of this attitude.</p><p>I believe the steep learning curve (which can be helped with tooling), coupled with some resistance from backend developers (which can be helped by… having empathy?), has slowed its broader adoption in web development.</p><h2 id="grpc-has-a-history">gRPC Has a History</h2><p>gRPC’s initial focus on microservices and its close ties to HTTP/2 hindered its widespread adoption in web development. Even with the <a href="https://grpc.io/blog/state-of-grpc-web/" rel="external">advent of gRPC-Web</a>, there’s still a perception that it’s not a first-class citizen in the frontend ecosystem. The lack of robust integration with popular frontend libraries like <a href="https://tanstack.com/query/latest" rel="external">TanStack Query</a> further solidifies this notion to me.</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/bad-blood.png" width="800px"/></p><p>I think there’s a real chance to get more frontend developers excited about gRPC with improved tooling. There’s a giant industry-wide conversation happening right now around where the line between “frontend” and “backend” meet and I think no matter the outcome, we’re going to see more typescript code using gRPC.</p><h2 id="the-g-in-grpc">The “g” in gRPC</h2><p>While <a href="https://grpc.io/docs/what-is-grpc/faq/#what-does-grpc-stand-for" rel="external">the gRPC project claims</a> that the “g” in gRPC is a <a href="https://en.wikipedia.org/wiki/Backronym" rel="external">backronym</a> that stands for “gRPC”, it originally stood for Google, because it was Google who developed and released both protobuf and gRPC.</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/google.png" width="600px"/></p><p>There’s always a lingering question about Google’s long-term commitment to gRPC and protobuf. Will they continue to invest in these open-source projects, or could they pull the plug if priorities shift? Remember that Google has <a href="https://techcrunch.com/2024/05/01/google-lays-off-staff-from-flutter-dart-python-weeks-before-its-developer-conference/" rel="external">recently layed off much of the Flutter, Dart and Python teams</a>. The protobuf community is growing, but would it be self-sustaining enough to survive such a scenario?</p><h2 id="its-not-finished">It’s Not Finished</h2><p>Others have said that gRPC is immature, not because of its age but by how developed the ecosystem is. I tend to agree, because it’s missing features and tools that I would have expected from a mature ecosystem.</p><h3 id="the-missing-package-manager">The missing package manager</h3><p>Sharing protobuf definitions across multiple projects or repositories is a constant struggle without specialized tools. While solutions like <a href="https://bazel.build/reference/be/protocol-buffer" rel="external">Bazel</a>, <a href="https://www.pantsbuild.org/2.21/docs/go/integrations/protobuf" rel="external">Pants</a>, and <a href="https://buf.build/product/bsr" rel="external">Buf’s BSR</a> exist, my experience with protobuf “in the real world” is… mixed. There are prominent open source projects, some by Google, that have bash scripts scrapped together to download dependencies before evoking <code>protoc</code> manually. Just imagine a programming language with no solution for managing dependencies. That’s insane. I think both <a href="https://grpc.io/blog/bazel-rules-protobuf/" rel="external">Bazel</a> and <a href="https://buf.build/docs/ecosystem/cli-overview" rel="external">Buf tooling</a> solve this problem pretty well but I’m just frustrated that every repo I come across that uses protobuf solves the problem in the most bespoke way possible. The community needs to come together to improve this. There is an open-source repo called <a href="https://github.com/helsing-ai/buffrs" rel="external">Buffrs</a> that appears to be tackling this problem. I haven’t used it personally but it looks decent so far.</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/build.png" width="600px"/></p><p>Related to dependencies, I do want to call out that <a href="https://protobuf.dev/reference/protobuf/google.protobuf/" rel="external">Google’s “well-known” protobuf types</a> get special privilege of being built into protoc. While these types are incredibly useful and invaluable, their privilege makes it hard for other libraries of useful protobuf types to exist and thrive. Just building these protobuf definitions into protoc (and other tooling) is a cop out for not having a real and consistent story for dependency management.</p><h3 id="editor-support">Editor Support</h3><p>Editor integration for protobuf code generation leaves a lot to be desired. It would be immensely helpful if editors could intelligently link generated code back to its protobuf source. This would provide a more seamless experience, but the tooling just isn’t smart enough yet. Also, I think everyone needs to run with <a href="https://buf.build/docs/editor-integration" rel="external">Buf’s editor support</a>. Having a linter and autoformatter built into your editor is the expected from developers nowadays. And with protobuf, there are <a href="https://buf.build/docs/lint/rules" rel="external">extremely real reasons</a> to follow the advice of the linter.</p><p>Projects like <a href="https://trpc.io/" rel="external">tRPC</a> showcase the benefits of tight integration and opinionated design choices—something that protobuf, by its nature, can’t fully replicate. However, I remain hopeful that the protobuf ecosystem can evolve to offer a similarly streamlined developer experience.</p><h3 id="ugly-documentation">Ugly Documentation</h3><p>I’ve never seen documentation generated from protobuf that wasn’t super ugly. I think since gRPC has historically been a backend service, the backend devs never bothered to put any real effort into making pretty documentation output using a protoc plugin. I’ve solved this problem by <a href="https://github.com/sudorandom/protoc-gen-connect-openapi" rel="external">making a protoc plugin</a> that generates OpenAPI from given protobuf files. Then I use one of the many beautiful tools for displaying the OpenAPI spec. This was, by far, much easier than getting me to make a decent design. Another side benefit for generating OpenAPI from protobuf is the ability to tap into that ecosystem since there’s more to it than just documentation.</p><p>Let’s look at a real example. This is a document generated using one of the few tools for generating documentation from protobuf, <a href="https://github.com/pseudomuto/protoc-gen-doc" rel="external">protoc-gen-doc</a>:</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/protoc-gen-doc.png" width="600px"/></p><p>Compare it to some of the OpenAPI tooling. This was generated using <a href="https://github.com/stoplightio/elements" rel="external">Elements</a>, but there are many, many other alternatives that look equally as polished:</p><p><img src="https://kmcd.dev/posts/grpc-the-ugly-parts/elements.png" width="800px"/></p><p>It’s kind-of not fair to point at a single plugin and say that the default template doesn’t look as good as OpenAPI alternatives, because you actually do have more flexibility with protoc-gen-doc. It allows you to specify your own template so it could look as beautiful as you want. However, this does line up with my point: the tooling is more finished and polished in the REST world than gRPC. This is a fixable problem, but we need to get frontend devs and designers excited about gRPC or backend engineers need to start sharpening their design skills.</p><p>I also want to note that OpenAPI/Swagger interfaces often have a way to test endpoints directly from the documentation website. This is completely missing from equivalent tools in the gRPC world. Additionally, with most OpenAPI documentation tools you can clearly see which fields are required and will display constraints on fields that have them. So not only is it prettier, it’s more functional as well.</p><h2 id="conclusion">Conclusion</h2><p>gRPC, while a powerful tool in many ways, still has room to grow. The less-than-ideal aspects of generated code, coupled with the challenges of dependency management and evolving protobuf schemas, can create friction for developers. The lack of intuitive editor integration and the historical focus on backend services have also hindered its wider adoption in web development.</p><p>However, I think the future of gRPC is bright and can be far less ugly. The community is actively addressing these challenges, developing tools like <a href="https://buf.build/product/cli" rel="external">the buf CLI</a>, <a href="https://github.com/bufbuild/protovalidate" rel="external">protovalidate</a> and <a href="https://github.com/sudorandom/protoc-gen-connect-openapi" rel="external">protoc-gen-connect-openapi</a> to bridge the gaps and enhance the developer experience. As gRPC matures and <a href="https://trends.google.com/trends/explore?date=all&amp;q=%2Fm%2F04dzxdz,%2Fg%2F11cp5mklv8,RESTful&amp;hl=en" rel="external">its ecosystem expands</a>, we can anticipate improved tooling, better editor support, and a smoother integration into the frontend world.</p></div></div>
  </body>
</html>
