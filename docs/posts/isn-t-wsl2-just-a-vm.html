<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssg.dev/isnt-wsl2-just-a-vm/">Original</a>
    <h1>Isn&#39;t WSL2 just a VM?</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>&#34;Subsystem&#34; on Windows NT has a vague definition. It basically means an API set, but predominantly for supporting programs written for other operating systems mostly through lightweight call translations. Windows NT, formerly &#34;<a href="https://en.wikipedia.org/wiki/Windows_NT?ref=ssg.dev#:~:text=referred%20to%20as%20%22-,NT%20OS/2,-%22%20before%20receiving%20the" rel="noreferrer">NT OS/2</a>&#34;, used to have an OS/2 subsystem that supported running OS/2 applications just by translating API calls to NT. </p><p>Subsystems usually have a separate process for state bookkeeping. There used to be an OS/2 subsystem (<code>OS2SS.EXE</code>), but there were more. Even <em>Windows</em> is a subsystem on NT architecture. The enigmatic <code>CSRSS.EXE</code> is the Win32 API translation layer for Windows NT. You can see the pattern: the &#34;SS&#34; stands for &#34;subsystem&#34;. Because of its performance problems, some portions of CSRSS were ported to kernel mode and were called <code>WIN32K.SYS</code>. </p><p>There was also a long-lived, pretty much useless POSIX subsystem (<code>PSXSS.EXE</code>) on NT. It was mostly to sell NT to the government because they required operating systems to be at least POSIX.1 certified. It implemented the bare minimum POSIX API to get the certification, and nothing else.</p><p>POSIX subsystem was later replaced by a more complete Windows Services for Unix developed by Interix, based on OpenBSD API. Unlike other subsystems, it was not binary compatible with any Unix, but provided its own API set and tooling, so apps could be compiled for it.</p><h2 id="enter-wsl1">Enter WSL1</h2><p>WSL1 is the first incarnation of <em>Windows Subsystem for Linux</em>. I think the name is silly though because we all know that the actual Windows subsystem for Linux is <a href="https://www.winehq.org/?ref=ssg.dev" rel="noreferrer">Wine</a>. I wish Microsoft had kept its initial name: <a href="https://github.com/ionescu007/lxss?ref=ssg.dev" rel="noreferrer">LXSS</a>. Anyway, WSL1 is a thin translation layer like the subsystems I mentioned. When you run <code>bash</code> on WSL1,  it only allocates a few MBs of memory just what bash needs, and that&#39;s it. You could see and manage <code>bash</code> process in Task Manager along with other Windows processes:</p><figure><img src="https://ssg.dev/content/images/2025/10/image.png" alt="" loading="lazy" width="965" height="291" srcset="https://ssg.dev/content/images/size/w600/2025/10/image.png 600w, https://ssg.dev/content/images/2025/10/image.png 965w" sizes="(min-width: 720px) 720px"/><figcaption><span>Linux bash showing up next to ASUS bloatware on Windows 11</span></figcaption></figure><p>This is the full process list that shows up on <code>top</code>:</p><figure><img src="https://ssg.dev/content/images/2025/10/image-1.png" alt="" loading="lazy" width="1189" height="365" srcset="https://ssg.dev/content/images/size/w600/2025/10/image-1.png 600w, https://ssg.dev/content/images/size/w1000/2025/10/image-1.png 1000w, https://ssg.dev/content/images/2025/10/image-1.png 1189w" sizes="(min-width: 720px) 720px"/></figure><p>Okay. <code>bash</code> allocates only how much it would allocate on a Linux machine, but isn&#39;t there still a runtime cost somewhere? We see at least <code>init</code> here in the list. When we open up the process list in Sysinternals Process Explorer, it shows up in a process tree:</p><figure><img src="https://ssg.dev/content/images/2025/10/image-2.png" alt="" loading="lazy" width="615" height="174" srcset="https://ssg.dev/content/images/size/w600/2025/10/image-2.png 600w, https://ssg.dev/content/images/2025/10/image-2.png 615w"/></figure><p><code>init</code> is there but what else? When I search WSL in Task Manager a few services show up:</p><figure><img src="https://ssg.dev/content/images/2025/10/image-3.png" alt="" loading="lazy" width="765" height="141" srcset="https://ssg.dev/content/images/size/w600/2025/10/image-3.png 600w, https://ssg.dev/content/images/2025/10/image-3.png 765w" sizes="(min-width: 720px) 720px"/></figure><p>Is that it? If I&#39;m not missing anything, that&#39;s the overhead of having Linux on your system using WSL1. Only a few megabytes. </p><p>The root filesystem of WSL1 also resides on your NTFS partition. Every file exists on the disk separately. This means that the storage overhead could be minimal because adding new files wouldn&#39;t require to expand an image file.</p><figure><img src="https://ssg.dev/content/images/2025/10/image-4.png" alt="" loading="lazy" width="1462" height="882" srcset="https://ssg.dev/content/images/size/w600/2025/10/image-4.png 600w, https://ssg.dev/content/images/size/w1000/2025/10/image-4.png 1000w, https://ssg.dev/content/images/2025/10/image-4.png 1462w" sizes="(min-width: 720px) 720px"/><figcaption><span>WSL1 rootfs on my Windows disk</span></figcaption></figure><h2 id="downsides-of-wsl1">Downsides of WSL1</h2><p>WSL1 was a technical marvel, but it suffered serious performance problems on certain I/O heavy scenarios because Linux and Win32 filesystem APIs were too different, and translating them made some apps and some workflows seriously suffer.</p><p>There were other limitations with WSL1 too. It required you to install a third-party X Server on Windows to run GUI apps. I myself had used <a href="https://apps.microsoft.com/detail/9PM8LP83G3L3?ref=ssg.dev" rel="noreferrer">X410</a> for that purpose. WSL1 also lacked support for raw socket operations because Windows API had restricted them after the Blaster worm incident. So, even <code>traceroute</code> wouldn&#39;t run, let alone other raw packet tools like <code>nmap</code> or <code>tcpdump</code>.</p><h2 id="enter-wsl2">Enter WSL2</h2><p>People rightfully complained because they wanted to use Windows for workflows that needed similar performance characteristics as a native Linux system. So, Microsoft threw the towel and ended up creating a full-blown Linux VM on top of Hyper-V.</p><figure><img src="https://ssg.dev/content/images/2025/11/image-3-1.png" alt="" loading="lazy" width="401" height="300"/><figcaption><span>&#34;It&#39;s an older meme, sir, but it checks out&#34;</span></figcaption></figure><p>Because it&#39;s a VM and it works with a native Linux filesystem, the whole root filesystem of Linux stays in a single VHDX file. One of the great things about WSL is that you can convert your installations between WSL1 and WSL2 back and forth with a command like:</p><pre><code>wsl --set-version &#34;Ubuntu&#34; 2</code></pre><p>Conversion might take a while though as all your files from your root FS are moved from NTFS to a VHDX file or vice versa. Here&#39;s my installation after the conversion to WSL2:</p><figure><img src="https://ssg.dev/content/images/2025/11/image-1.png" alt="" loading="lazy" width="1365" height="158" srcset="https://ssg.dev/content/images/size/w600/2025/11/image-1.png 600w, https://ssg.dev/content/images/size/w1000/2025/11/image-1.png 1000w, https://ssg.dev/content/images/2025/11/image-1.png 1365w" sizes="(min-width: 720px) 720px"/></figure><p>You can also have multiple Ubuntu setups, one with WSL1 one with WSL2 and use them interchangeably depending on your needs. Both are supported with different tradeoffs.</p><p>WSL2 is faster in certain workflows but it&#39;s slower to start initially because of the whole booting up the VM thing. As a reward, you&#39;re running a real Linux kernel now:</p><pre><code>$ uname -a
Linux SSGHOME3 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>That kernel is provided by Microsoft with many options tuned for WSL2 environment. You can compile your own kernel and run it with WSL2 too if you want. I had to do that once <a href="https://bsky.app/profile/ssg.dev/post/3l5x5ifl2ly2w?ref=ssg.dev" rel="noreferrer">when I needed to access an SD card from my WSL2 setup</a>. They were disabled on default WSL2 kernel at the time.</p><p>WSL2 starts up fast enough though, like it takes maybe a second, but still a difference you experience after every reboot. After you start your initial WSL2 session, you now have a perpetually running VM on your system. Luckily though, it doesn&#39;t consume as much as memory when idle. This is what it looks like with a single <code>bash</code> prompt:</p><figure><img src="https://ssg.dev/content/images/2025/11/image-2.png" alt="" loading="lazy" width="1009" height="383" srcset="https://ssg.dev/content/images/size/w600/2025/11/image-2.png 600w, https://ssg.dev/content/images/size/w1000/2025/11/image-2.png 1000w, https://ssg.dev/content/images/2025/11/image-2.png 1009w" sizes="(min-width: 720px) 720px"/></figure><p>1.6GB on a 32GB system. Does that mean we only have a 1.6GB RAM VM? No. WSL is smart about this. It claims to allow half my physical memory, 16GB:</p><pre><code>$ cat /proc/meminfo
MemTotal:       16324732 kB
MemFree:        15077248 kB
MemAvailable:   15547632 kB</code></pre><p>So, I expect the memory usage of VmmemWSL process to grow when you run Linux apps with greater memory requirements. I assume that it probably shrinks back when it needs less memory. So, it&#39;s quite good. It&#39;s not even enough to <code>malloc</code> the memory, the processes need to commit to it. Otherwise, memory usage doesn&#39;t grow at all. Here is a test using the tool <code>stress</code>:</p><pre><code>$ stress --vm 16 --vm-bytes 1000000000
stress: info: [1793] dispatching hogs: 0 cpu, 0 io, 16 vm, 0 hdd</code></pre><p>That immediately maxes out the memory usage of WSL2, and eventually crashes because available memory is less than 16GB (more like 15GB):</p><figure><img src="https://ssg.dev/content/images/2025/11/image-4.png" alt="" loading="lazy" width="1015" height="116" srcset="https://ssg.dev/content/images/size/w600/2025/11/image-4.png 600w, https://ssg.dev/content/images/size/w1000/2025/11/image-4.png 1000w, https://ssg.dev/content/images/2025/11/image-4.png 1015w" sizes="(min-width: 720px) 720px"/></figure><p>When you kill the app it shrinks back to its original footprint in 10 seconds or so:</p><figure><img src="https://ssg.dev/content/images/2025/11/image-5.png" alt="" loading="lazy" width="1008" height="109" srcset="https://ssg.dev/content/images/size/w600/2025/11/image-5.png 600w, https://ssg.dev/content/images/size/w1000/2025/11/image-5.png 1000w, https://ssg.dev/content/images/2025/11/image-5.png 1008w" sizes="(min-width: 720px) 720px"/></figure><p>I think that&#39;s pretty much okay. What&#39;a a gigabyte to spare in these days anyway? Just assume that you&#39;re running your clock app under Electron. If you really need the full memory to yourself, you can always shutdown WSL2 from a Windows Command Prompt, and it will start automatically the next time you need it:</p><pre><code>  wsl --shutdown</code></pre><p>Not too bad. I think the RAM overhead of WSL2 is okay based on the benefits it provides.</p><h2 id="is-a-vm-really-an-nt-subsystem">Is a VM really an NT subsystem?</h2><p>First, Microsoft calls WSL2 a subsystem, so I guess it must be. But, based on our definition around API translation layers for ABI imitation, it isn&#39;t a subsystem. It&#39;s a VM.</p><p>32-bit Windows versions used to have an NTVDM (NT Virtual DOS Machine) layer to run DOS and 16-bit Windows applications. It basically worked pretty much similar to WSL2. It wasn&#39;t called a &#34;VDMSS.EXE&#34; or so at the time because it didn&#39;t fit the definition of a subsystem, but it acted more like a virtual machine, more like WSL2.</p><p>However, WSL2 isn&#39;t a stock VM either. As I mentioned before, it dynamically allocates memory and shrinks it as needed, it mounts your Windows drives, and lets you access your Linux drives as network shares using <code>\\wsl$\</code> path syntax, it integrates <em>almost seamlessly</em> with desktop using a layer called WSLg. I say &#34;almost&#34; because every Linux GUI app we&#39;re running is actually a Remote Desktop client streaming that app from Linux VM to our Windows machines. It&#39;s still great though, apart from not being aware of my desktop settings like text scaling, HiDPI, and whatever. You need to set those up from scratch on your Linux environment.</p><h2 id="downsides-of-wsl2">Downsides of WSL2</h2><p>My biggest issue with WSL2 is file management. Naturally, WSL2 feels at home when you do all your work on its <code>ext4</code> image, but your work stays in the image then. An approximately 16GB single file called <code>ext4.vhdx</code> hidden deep inside your hard drive. I don&#39;t even know what happens if you uninstall Ubuntu or decide to switch to a different distro. Do you move your files manually between two distros using <code>scp</code> or something like that? I don&#39;t like that kind of fragility about keeping your work inside a big disk image.</p><p>Okay, I checked it now, and if you run <code>wsl --uninstall Distro</code> your image remains, but if you run <code>wsl --unregister Distro</code> all your files, all that you&#39;ve worked on are gone in a second. Those two commands are dangerously and Levenshteinly close to each other.</p><p>You can use your Windows drives for your work of course. They&#39;re automatically mounted anyway, your drive C: is at <code>/mnt/c</code> for example. But, their performance is even worse than WSL1 on NTFS because now both VM overhead and syscall overhead take effect together.</p><p>I had been converting my WSL setup between WSL1 and WSL2 while writing this article. I noticed that WSL1 was using <code>drvfs</code> while WSL2 was using <code>9p</code> protocol, which is Plan9&#39;s remote file system protocol. I find the idea of a piece of <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs?ref=ssg.dev" rel="noreferrer">Plan9 from Bell Labs</a> running on my Windows box quite fantastic to be honest.</p><p>I think I found a bug with the conversion process though. When I converted WSL1 distro back to WSL2 again, <code>drvfs</code> mount entries stayed as is, and were not replaced with their <code>9p</code> counterparts. I got stuck with <code>drvfs</code>, I didn&#39;t want to bother with fixing it and just deleted and reinstalled Ubuntu. It&#39;s that easy. That&#39;s why it would make me uneasy to keep my work in a disk image.</p><p>All in all, unless I always remain synced with a remote repository or have backups in place, I&#39;d refrain from doing serious work on an WSL2 root partition. A good middle ground is to use a separate disk image for your work. You can create VHDX images directly from Windows settings:</p><figure><img src="https://ssg.dev/content/images/2025/11/image-10.png" alt="" loading="lazy" width="1563" height="404" srcset="https://ssg.dev/content/images/size/w600/2025/11/image-10.png 600w, https://ssg.dev/content/images/size/w1000/2025/11/image-10.png 1000w, https://ssg.dev/content/images/2025/11/image-10.png 1563w" sizes="(min-width: 720px) 720px"/></figure><p>And you can mount it with <code>wsl --mount --vhd</code>.  I strongly recommend that for any serious work. Unfortunately, you can&#39;t specify VHDX mounting options in <code>.wslconfig</code>, so you&#39;ll have to create wrapper scripts to launch WSL. I wish it were easier.</p><p>I might be biased as a former Windows engineer, but I love Windows NT&#39;s modular design. I love that I can load a binary-only device driver from 15 years ago on my system and use a legacy device easily on a modern system; a stable kernel ABI goes a long way (hence the saying &#34;Win32 is the only stable ABI for Linux&#34;). Having OS subsystems incorporated into the design from day one is just a cherry on top.</p><p>WSL1 has great advantages like extremely lightweight memory overhead if you can bear its limitations. But, WSL2 is no slouch either. It can dynamically grow and shrink back to a gigabyte if you have that to reserve. Or, you can always shut it down if you need more memory. </p><p>WSL2 spends good amount of effort to work around the problems of a VM such as heavy memory footprint or lack of integrations with the host OS. I think it would be fair to call it a subsystem, just to separate it from heavyweight VMs.</p>
        </section></div>
  </body>
</html>
