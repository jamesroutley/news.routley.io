<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2022/04/05/pipe/">Original</a>
    <h1>That simple script is still someone&#39;s bad day</h1>
    
    
<p>
Here&#39;s a bash shell scenario for people who like these things.  Let&#39;s 
say you have a script like this:
</p>
<pre class="terminal">#!/bin/bash
reader | writer
</pre>
<p>
... and &#34;reader&#34; fails and yields no data, and then &#34;writer&#34; runs and
writes a nice fat blank to the database system.  This then causes all 
kinds of fun times down the road.
</p>
<p>
So, this gets used as an opportunity to write one of those awful 
corporate outage bulletins which is more about hawking the company&#39;s 
wares than getting to the bottom of a problem.  And, in it, the key is 
&#34;we forgot pipefail&#34;.
</p>
<p>
It&#39;s like, you forgot more than that.  pipefail isn&#39;t going to stop the 
second thing from running.  Seriously.  It&#39;s still going to run.  Just 
look.
</p>
<p>
Let me introduce our cast of characters here.  First, we have &#34;writer&#34;:
</p>
<pre class="terminal">#!/bin/bash
echo &#34;writer is reading stdin&#34;
cat &gt; output
echo &#34;writer is done reading stdin&#34;
ls -l output
</pre>
<p>
It&#39;s simple and stupid: it says hello, inhales its data, and tells us 
what it got.  It simulates whatever &#34;read stdin until EOF&#34; you&#39;d have in 
this scenario.
</p>
<p>
Next up, here is &#34;reader-that-works&#34;:
</p>
<pre class="terminal">#!/bin/bash
echo &#34;here&#39;s some data.&#34;
</pre>
<p>
This one is nice and easy.
</p>
<p>
Now here&#39;s its buddy, the one that&#39;s going to fail (and exit 1), 
&#34;reader-that-fails&#34;:
</p>
<pre class="terminal">#!/bin/bash
exit 1
</pre>
<p>
No surprises there.  Now, we have the script that&#39;ll simulate the happy 
path called &#34;run-good&#34;:
</p>
<pre class="terminal">#!/bin/bash
set -o pipefail
./reader-that-works | ./writer
</pre>
<p>
And finally, the script that simulates the unhappy path called 
&#34;run-bad&#34;:
</p>
<pre class="terminal">#!/bin/bash
set -o pipefail
./reader-that-fails | ./writer
</pre>
<p>
Note that both of these runners have pipefail enabled already.
</p>
<p>
Let&#39;s run the happy path.
</p>
<pre class="terminal">/tmp/duh:$ ./run-good
writer is reading stdin
writer is done reading stdin
-rw-r--r-- 1 rkroll rkroll 18 Apr  5 13:51 output
/tmp/duh:$ cat output
here&#39;s some data.
/tmp/duh:$ 
</pre>
<p>
Okay, so, now the other one:
</p>
<pre class="terminal">/tmp/duh:$ ./run-bad
writer is reading stdin
writer is done reading stdin
-rw-r--r-- 1 rkroll rkroll 0 Apr  5 13:52 output
</pre>
<p>
What&#39;s this?  The second part of the pipeline still ran?  Of course it 
did.  It&#39;s *already running* at the point that the reader fails.  Its 
stdin is hooked to the stdout of the other thing, Unix-centipede style.  
It *has to be there running already*, or the reader couldn&#39;t run in all 
situations!  It would fill the pipe of its stdout and then it would 
block.
</p>
<p>
This isn&#39;t MS-DOS, where foo | bar involves running foo, sending the 
output to a temp file, then running bar and getting the input from that 
same temp file.  There&#39;s parallel execution here, and it&#39;s way too late 
to abort a pipeline if only two processes are involved.
</p>
<p>
This like is one of those &#34;interview questions&#34; people ask about &#34;being 
the shell&#34; and trying to understand how it does what it does.  One snag 
they throw at people in these interviews is why you don&#39;t want to have 
a shell command that greps for something in a file and then writes back 
to that same file at the same time.
</p>
<p>
That is, something like this (don&#39;t do this):
</p>
<pre class="terminal">grep -v noise my_file &gt; my_file
</pre>
<p>
You think &#34;that&#39;ll remove &#39;noise&#39; from the file.  And it&#39;s like... it 
will... sorta... by removing *everything* from the file!  The shell 
will happily open my_file for writing as part of setting up the 
execution environment for the subprocess and will clobber whatever&#39;s 
there.
</p>
<p>
...
</p>
<p>
And, you know what, the worst part about this is that none of this 
knowledge should even apply.  The fact we&#39;re talking about 
<a href="https://rachelbythebay.com/w/2013/08/01/script/">shell scripts</a>
for something critical means that the battle for reliability was lost a 
long time ago.
</p>

  </body>
</html>
