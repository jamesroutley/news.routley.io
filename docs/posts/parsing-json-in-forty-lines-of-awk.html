<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://akr.am/blog/posts/parsing-json-in-forty-lines-of-awk">Original</a>
    <h1>Parsing JSON in Forty Lines of Awk</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>JSON is not a friendly format to the Unix shell — it’s hierarchical, and
cannot be reasonably split on any character (other than the newline, which is
not very useful) as that character might be included in a string. There are
well-known tools such as <a href="https://jqlang.org">jq</a> that let you correctly parse
JSON documents in the shell, but all require an additional dependency. Another
option is to use Python, which is ubiquitous enough that it can be expected to
be installed on virtually every machine, and for new projects would be the
recommended option.</p>

<p>However, I already had a working POSIX shell script that now had a requirement
to read and parse JSON. It had previously extracted values from HTML which,
while also being hierarchical, can be reliably split on certain characters (the
angle brackets) for basic extraction of values. awk is the closest thing to a
real programming language that’s available in the POSIX shell, so I thought I’d
try to write a basic JSON parser in it. I had already written a full-blown
<a href="https://github.com/mohd-akram/jawk">one</a> before, so I knew it was doable, but
I needed something more concise.</p>

<p>First, there are some caveats. JSON is <a href="https://seriot.ch/projects/parsing_json.html">notoriously
tricky</a> to get completely right,
despite its simple grammar. The following code assumes that it will be fed
valid JSON. It has some basic validation as a function of the parsing and will
most likely throw an error if it encounters something strange, but there are no
guarantees beyond that. In my case, I’m reading JSON from a single, trusted
source, so this is an acceptable constraint.</p>

<p>The interface is simple, a single function that accepts a JSON document and a
dotted path to a key or array index, and returns the corresponding value. It
can be used like so:</p>

<div><div><pre><code><span>items</span> <span>=</span> <span>get_json_value</span><span>(</span><span>json</span><span>,</span> <span>&#34;payload.items&#34;</span><span>)</span>
<span>while</span> <span>((</span><span>item</span> <span>=</span> <span>get_json_value</span><span>(</span><span>items</span><span>,</span> <span>i</span><span>++</span><span>)))</span> <span>{</span>
	<span>type</span> <span>=</span> <span>decode_json_string</span><span>(</span><span>get_json_value</span><span>(</span><span>item</span><span>,</span> <span>&#34;type&#34;</span><span>))</span>
	<span>name</span> <span>=</span> <span>decode_json_string</span><span>(</span><span>get_json_value</span><span>(</span><span>item</span><span>,</span> <span>&#34;name&#34;</span><span>))</span>
<span>}</span>
</code></pre></div></div>

<p>To keep things simple, the same function handles both arrays and objects. In
JavaScript, arrays are roughly equivalent to objects with integer keys, and we
use the same approach here. This is the
<a href="https://gist.github.com/mohd-akram/1c0d4cb337b62e3cce0ab7e02e6281fd">implementation</a>,
expanded and annotated:</p>

<div><div><pre><code><span># The function takes two parameters, the JSON object/array and the desired key</span>
<span># The rest are local variables (awk only allows local variables in the form</span>
<span># of function parameters)</span>
<span>function</span> <span>get_json_value</span><span>(</span> <span>\</span>
	<span>s</span><span>,</span> <span>key</span><span>,</span>
	<span>type</span><span>,</span> <span>all</span><span>,</span> <span>rest</span><span>,</span> <span>isval</span><span>,</span> <span>i</span><span>,</span> <span>c</span><span>,</span> <span>j</span><span>,</span> <span>k</span> <span>\</span>
<span>)</span> <span>{</span>
	<span># Get the type of object by its first character</span>
	<span>type</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span>

	<span># If it&#39;s neither an object, nor an array, throw an error</span>
	<span>if</span> <span>(</span><span>type</span> <span>!=</span> <span>&#34;{&#34;</span> <span>&amp;&amp;</span> <span>type</span> <span>!=</span> <span>&#34;[&#34;</span><span>)</span> <span>error</span><span>(</span><span>&#34;invalid json array/object &#34;</span> <span>s</span><span>)</span>

	<span># This variable is needed for when we recursively call the function</span>
	<span># It will be true if the key argument is omitted, since undefined</span>
	<span># variables in awk can behave as either a string or a number</span>
	<span>all</span> <span>=</span> <span>key</span> <span>==</span> <span>&#34;&#34;</span> <span>&amp;&amp;</span> <span>key</span> <span>==</span> <span>0</span>

	<span># Get the first part of the key (which we will be looking for)</span>
	<span># if the path is dotted and save the rest for now</span>
	<span>if</span> <span>(</span><span>!</span><span>all</span> <span>&amp;&amp;</span> <span>(</span><span>j</span> <span>=</span> <span>index</span><span>(</span><span>key</span><span>,</span> <span>&#34;.&#34;</span><span>)))</span> <span>{</span>
		<span>rest</span> <span>=</span> <span>substr</span><span>(</span><span>key</span><span>,</span> <span>j</span><span>+</span><span>1</span><span>)</span>
		<span>key</span> <span>=</span> <span>substr</span><span>(</span><span>key</span><span>,</span> <span>1</span><span>,</span> <span>j</span><span>-</span><span>1</span><span>)</span>
	<span>}</span>

	<span># k is the current key</span>
	<span># If this is an array, it is the index, which starts at 0</span>
	<span>if</span> <span>(</span><span>type</span> <span>==</span> <span>&#34;[&#34;</span><span>)</span> <span>k</span> <span>=</span> <span>0</span>

	<span># isval keeps track of whether we are looking at a JSON key or value</span>
	<span># In an array, all items are values</span>
	<span>isval</span> <span>=</span> <span>type</span> <span>==</span> <span>&#34;[&#34;</span>

	<span># Loop over the characters in the provided JSON</span>
	<span># Skip the opening brace or bracket (to avoid infinite recursion) and</span>
	<span># increment the index by the length of the token</span>
	<span>for</span> <span>(</span><span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;</span> <span>length</span><span>(</span><span>s</span><span>);</span> <span>i</span> <span>+=</span> <span>length</span><span>(</span><span>c</span><span>))</span> <span>{</span>
		<span># Temporarily assign the first character to our token variable</span>
		<span># until we figure out its type</span>
		<span>c</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>,</span> <span>1</span><span>)</span>

		<span># If it&#39;s a double quote, then we expect a string</span>
		<span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#34;\&#34;&#34;</span><span>)</span> <span>{</span>
			<span># Get its length</span>
			<span>if</span> <span>(</span><span>!</span><span>match</span><span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>),</span> <span>/^&#34;</span><span>(\\</span><span>.|</span><span>[^\\</span><span>&#34;</span><span>])</span><span>*&#34;/</span><span>))</span>
				<span>error</span><span>(</span><span>&#34;invalid json string &#34;</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>))</span>
			<span># And extract the string</span>
			<span>c</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>,</span> <span>RLENGTH</span><span>)</span>
			<span># If we&#39;re not expecting a value, then it&#39;s a key, so</span>
			<span># trim the quotes and save it</span>
			<span>if</span> <span>(</span><span>!</span><span>isval</span><span>)</span> <span>k</span> <span>=</span> <span>substr</span><span>(</span><span>c</span><span>,</span> <span>2</span><span>,</span> <span>length</span><span>(</span><span>c</span><span>)</span><span>-</span><span>2</span><span>)</span>
		<span>}</span>

		<span># If it&#39;s an opening brace or bracket, then we expect an object</span>
		<span># or array</span>
		<span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#34;{&#34;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#34;[&#34;</span><span>)</span> <span>{</span>
			<span># If this is the object we&#39;re looking for and we need</span>
			<span># a nested value, pass the rest of the dotted key</span>
			<span># Otherwise, get the whole object</span>
			<span>c</span> <span>=</span> <span>(</span><span>!</span><span>all</span> <span>&amp;&amp;</span> <span>k</span> <span>==</span> <span>key</span> <span>&amp;&amp;</span> <span>!</span><span>(</span><span>rest</span> <span>==</span> <span>&#34;&#34;</span> <span>&amp;&amp;</span> <span>rest</span> <span>==</span> <span>0</span><span>))</span> <span>?</span> <span>\</span>
				<span>get_json_value</span><span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>),</span> <span>rest</span><span>)</span> <span>:</span> <span>\</span>
				<span>get_json_value</span><span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>))</span>
		<span>}</span>

		<span># If it&#39;s a closing brace or bracket, we&#39;ve reached the end of</span>
		<span># the object or array, so exit the loop</span>
		<span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#34;}&#34;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#34;]&#34;</span><span>)</span> <span>break</span>

		<span># If we find a comma in an object, the next item will be a key,</span>
		<span># so reset isval</span>
		<span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#34;,&#34;</span><span>)</span> <span>isval</span> <span>=</span> <span>type</span> <span>==</span> <span>&#34;[&#34;</span>

		<span># For the colon, isval needs to be set to true, but that is done</span>
		<span># later (see why below)</span>
		<span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#34;:&#34;</span><span>)</span> <span>;</span>

		<span># Ignore whitespace</span>
		<span>else</span> <span>if</span> <span>(</span><span>c</span> <span>~</span> <span>/</span><span>[</span><span>[:space:</span><span>]</span><span>]/</span><span>)</span> <span>continue</span>

		<span># Match anything else</span>
		<span>else</span> <span>{</span>
			<span># This will match numbers, booleans and null</span>
			<span># Find the next closing bracket, brace, comma or</span>
			<span># whitespace, as those terminate values</span>
			<span>if</span> <span>(</span><span>!</span><span>match</span><span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>),</span> <span>/</span><span>[]</span><span>},</span><span>[</span><span>:space:</span><span>]</span><span>]/</span><span>))</span>
				<span>error</span><span>(</span><span>&#34;invalid json value &#34;</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>))</span>
			<span># Extract the value</span>
			<span>c</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>,</span> <span>RSTART</span><span>-</span><span>1</span><span>)</span>
		<span>}</span>

		<span># If this is a value, and the key matches, we&#39;ve found our</span>
		<span># desired object, so return it</span>
		<span>if</span> <span>(</span><span>!</span><span>all</span> <span>&amp;&amp;</span> <span>isval</span> <span>&amp;&amp;</span> <span>k</span> <span>==</span> <span>key</span><span>)</span> <span>return</span> <span>c</span>

		<span># If we see a colon in an object, the next token is a value</span>
		<span># This needs to be after the previous statement to not capture</span>
		<span># the colon itself</span>
		<span>if</span> <span>(</span><span>type</span> <span>==</span> <span>&#34;{&#34;</span> <span>&amp;&amp;</span> <span>c</span> <span>==</span> <span>&#34;:&#34;</span><span>)</span> <span>isval</span> <span>=</span> <span>1</span>

		<span># If this is an array and we see a comma, increment the index</span>
		<span>if</span> <span>(</span><span>type</span> <span>==</span> <span>&#34;[&#34;</span> <span>&amp;&amp;</span> <span>c</span> <span>==</span> <span>&#34;,&#34;</span><span>)</span> <span>++</span><span>k</span>
	<span>}</span>

	<span># If we&#39;re here, it means we didn&#39;t find the value we&#39;re looking for</span>
	<span># so only return something if the whole array or object was requested</span>
	<span>if</span> <span>(</span><span>all</span><span>)</span> <span>return</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>1</span><span>,</span> <span>i</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>To make the parser more useful, you’ll also need a function to do some decoding
of JSON strings. This is a simple one, which handles everything except Unicode
escape sequences, but throws an error if it encounters one:</p>

<div><div><pre><code><span>function</span> <span>decode_json_string</span><span>(</span><span>s</span><span>,</span> <span>out</span><span>,</span> <span>esc</span><span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span> <span>!=</span> <span>&#34;\&#34;&#34;</span> <span>||</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>length</span><span>(</span><span>s</span><span>),</span> <span>1</span><span>)</span> <span>!=</span> <span>&#34;\&#34;&#34;</span><span>)</span>
		<span>error</span><span>(</span><span>&#34;invalid json string &#34;</span> <span>s</span><span>)</span>

	<span>s</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>2</span><span>,</span> <span>length</span><span>(</span><span>s</span><span>)</span><span>-</span><span>2</span><span>)</span>

	<span>esc</span><span>[</span><span>&#34;b&#34;</span><span>]</span> <span>=</span> <span>&#34;\b&#34;</span><span>;</span> <span>esc</span><span>[</span><span>&#34;f&#34;</span><span>]</span> <span>=</span> <span>&#34;\f&#34;</span><span>;</span> <span>esc</span><span>[</span><span>&#34;n&#34;</span><span>]</span> <span>=</span> <span>&#34;\n&#34;</span><span>;</span> <span>esc</span><span>[</span><span>&#34;\&#34;&#34;</span><span>]</span> <span>=</span> <span>&#34;\&#34;&#34;</span>
	<span>esc</span><span>[</span><span>&#34;r&#34;</span><span>]</span> <span>=</span> <span>&#34;\r&#34;</span><span>;</span> <span>esc</span><span>[</span><span>&#34;t&#34;</span><span>]</span> <span>=</span> <span>&#34;\t&#34;</span><span>;</span> <span>esc</span><span>[</span><span>&#34;/&#34;</span><span>]</span> <span>=</span> <span>&#34;/&#34;</span> <span>;</span> <span>esc</span><span>[</span><span>&#34;\\&#34;</span><span>]</span> <span>=</span> <span>&#34;\\&#34;</span>

	<span>while</span> <span>(</span><span>match</span><span>(</span><span>s</span><span>,</span> <span>/</span><span>\\</span><span>/</span><span>))</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span><span>(</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>RSTART</span><span>+</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>in</span> <span>esc</span><span>))</span>
			<span>error</span><span>(</span><span>&#34;unknown json escape &#34;</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>RSTART</span><span>,</span> <span>2</span><span>))</span>
		<span>out</span> <span>=</span> <span>out</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>1</span><span>,</span> <span>RSTART</span><span>-</span><span>1</span><span>)</span> <span>esc</span><span>[</span><span>substr</span><span>(</span><span>s</span><span>,</span> <span>RSTART</span><span>+</span><span>1</span><span>,</span> <span>1</span><span>)]</span>
		<span>s</span> <span>=</span> <span>substr</span><span>(</span><span>s</span><span>,</span> <span>RSTART</span><span>+</span><span>2</span><span>)</span>
	<span>}</span>

	<span>return</span> <span>out</span> <span>s</span>
<span>}</span>
</code></pre></div></div>

<p>And finally, since there is no built-in error function in awk, you can use
something like this:</p>

<div><div><pre><code><span>function</span> <span>error</span><span>(</span><span>msg</span><span>)</span> <span>{</span>
	<span>printf</span> <span>&#34;%s: %s\n&#34;</span><span>,</span> <span>ARGV</span><span>[</span><span>0</span><span>],</span> <span>msg</span> <span>&gt;</span> <span>&#34;/dev/stderr&#34;</span>
	<span>exit</span> <span>1</span>
<span>}</span>
</code></pre></div></div>

  </div></div>
  </body>
</html>
