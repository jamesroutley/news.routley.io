<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/">Original</a>
    <h1>I Believe Zig Has Function Colors</h1>
    
    <div id="readability-page-1" class="page"><div>
<h2 id="introduction">Introduction</h2><p>The title is the thesis: the Zig programming language has function colors. And
in the rest of this post, I will prove that and try to explain what it means for
programmers using Zig.</p><div>
<p>This post is not here to ascribe any intention to Zig proponents, especially the
leadership and employees of the Zig Software Foundation. I did that once, and I
regret it.</p><p>Instead, the post is meant to be as objective as possible, while letting the
chips fall where they may.</p></div><h2 id="review-of-function-colors">Review of Function Colors</h2><p>First, what <em>are</em> “function colors”?</p><p>They are a reference to a classic <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">blog post</a> by <a href="https://journal.stuffwithstuff.com/">Bob Nystrom</a>.</p><p>In it, he describes how, in programming languages that use <code>async</code> as the
concurrency model, <strong>some functions cannot be used without special work</strong>.</p><p>The bolded text is the key, but people lose that because of a list of five
things in Bob’s post. Thus, they think that function colors require that all
five traits be present.</p><p>This is false; the five things he listed were <em>traits of a “hypothetical”
(JavaScript) programming language</em>.</p><p>The five traits are (and I am quoting Bob Nystrom here):</p><blockquote>
<ol>
<li><strong>Every function has a color.</strong></li><li><strong>The way you call a function depends on its color.</strong></li><li><strong>You can only call a red function from within another red function.</strong></li><li><strong>Red functions are more painful to call.</strong></li><li><strong>Some core library functions are red.</strong></li></ol></blockquote><p>Some may complain that the definition of function colors I gave above does not
fall out of Bob Nystrom’s list, but I argue that it does.</p><p>First, in my definition, it is implicit that every function has a color. That’s
the “some functions” in the beginning, which implicitly says there’s a
difference between functions. This means my definition fulfills point 1.</p><p>Second, since “some functions” need “special work” to use, and because Bob
Nystrom was deliberately vague about what he meant by “painful,” we can call
those functions “red” functions, and my definition hits point 4, <em>if</em> we change
the word “call” to “use.”</p><p>Yes, there is a difference between <em>calling</em> a function and <em>using</em> a function.
I will explain the difference later.</p><p>Third, if you change the word “call” to “use” in point 2, I believe my
definition would fit it.</p><p>Third, point 5 is mostly about the standard library, so I don’t think my
definition needs to take it into account.</p><p>My definition, however, does not fit point 3. This is on purpose; from the first
time that I read Bob Nystrom’s post, I never believed that point 3 was a
<em>prerequisite</em> for function colors.</p><p>This difference of opinion is probably what caused most of the conflict I
alluded to earlier, so I thought that I would lay it out, then make my case for
it, along with the case that Zig has function colors <em>according to my
definition</em>.</p><h3 id="use-vs-call">“Use” vs. “Call”</h3><p>So why was I careful to say that if you change the word “call” to the word “use”
in points 2 and 4, my definition fits?</p><p>Because calling a function is only <em>part</em> of using a function.</p><p>First, calling a function is only one of several ways to use a function. You
can:</p><ul>
<li>assign it to a function pointer,</li><li>pass it, as a function pointer, to other functions,</li></ul><p>among other things.</p><p>But even if you just call the function, that is not all you need to do to <em>use</em>
it.</p><p>You need to <em>understand</em> it, and use it according to its preconditions and use
its results according to the postconditions.</p><p>It is this understanding step that can make functions “painful” to use, and as
we will see, Zig cannot make this step easy in some cases.</p><p>Though it does make it easy in most cases, and this is Zig’s innovation.</p><h2 id="why-i-believed-zig-has-function-colors">Why I Believed Zig Has Function Colors</h2><p>My belief that Zig has function colors stems from two things:</p><ul>
<li>A gut feeling based on everything I know about concurrency, structured
concurrency, and the <a href="https://en.wikipedia.org/wiki/Structured_program_theorem">structured programming theorem</a>.</li><li>The original <a href="https://kristoff.it/blog/zig-colorblind-async-await/">“What is Zig’s ‘Colorblind’ Async/Await?”</a> blog post.</li></ul><h3 id="my-gut-feeling">My Gut Feeling</h3><p>The first one, that gut feeling, is that <code>async</code>-based programming languages will
<em>always</em> have function colors <em>as I have defined them</em>.</p><p>This is why I defined them the way I did. I have always felt, quite consciously,
that programming languages did <em>not</em> need to have point 3, that the existence of
point 3 was purely from bad design.</p><p>I will emphasize: <em>I have no proof of this.</em> It’s only a hunch.</p><p>Though the hunch is based on the fact that “there is no such thing as a free
lunch.”</p><p>I also don’t think I have the mathematical chops to write a proof for it either.</p><p>But I have not needed to prove it because (as far as I know) only one
programming language that uses <code>async</code> as its concurrency model claims to not
have function colors.</p><p>Instead, since I’m a programmer, and I’m starting to learn cryptography through
the art of breaking things, I’m decided to prove Zig has function colors by
torturing it.</p><h3 id="colorblind-blog-post">Colorblind Blog Post</h3><p>But to prove it, I’ve got to understand Zig’s model.</p><p>When I first heard of Zig’s model, and with my hunch, I read the <a href="https://kristoff.it/blog/zig-colorblind-async-await/">blog post in
question</a>, which was written by Loris Cro, Vice President of Community for
the Zig Software Foundation.</p><p>In it, he describes through what you can do with Zig’s <code>async</code> model, showing
how Zig’s model is (mostly) colorblind.</p><p>I read the whole thing, and I admit that I was looking for weaknesses.</p><p>Loris Cro wrote one section called “Understanding the limits.” Naturally, I
looked there, and I found a weakness.</p><p>One of the FAQ’s in the section says this:</p><blockquote>
<p><strong>Q: SO I DON’T EVEN HAVE TO THINK ABOUT NORMAL FUNCTIONS VS COROUTINES IN MY
LIBRARY?</strong></p></blockquote><blockquote>
<p>No, occasionally you will have to. As an example, if you’re allowing your
users to pass to your library function pointers at runtime, you will need to
make sure to use the right calling convention based on whether the function is
async or not. You normally don’t have to think about it because the compiler
is able to do the work for you at compile-time, but that can’t happen for
runtime-known values.</p></blockquote><blockquote>
<p>The silver lining is that you have at your disposal all the tools to account
for all the possibilities in a simple and clear way. Once you get the details
right, the code will be no more complicated than it has to be, and your
library will be easy to use.</p></blockquote><p>Let me highlight one piece:</p><blockquote>
<p>if you’re allowing your users to pass to your library function pointers at
runtime, you will need to make sure to use the right <em>calling convention</em>
based on whether the function is async or not.</p></blockquote><p>(Emphasis added.)</p><p>“Calling convention” sounds <em>suspiciously</em> like the need to call functions in a
special way, which would fit Bob Nystrom’s point 2 <em>without</em> changing it to use
the word “use” instead.</p><h2 id="breaking-zig">Breaking Zig</h2><p>So that was my plan of attack: use Loris Cro’s own example of function pointers.</p><p>But I’m not a Zig user; I had never touched it before.</p><p>So I went to the <a href="https://ziglang.org/documentation/0.9.1/#Async-Functions">language reference</a>, started learning, and started writing
code.</p><p>All code was compiled by Zig version <code>0.9.1</code>, the version packaged by Gentoo, on
an up-to-date Gentoo <code>x86_64</code> system.</p><div>
<p>You can get a zip file of all 67(!) of these tests, as well as a Makefile to
build them, <a href="https://gavinhoward.com/uploads/zig_async.zip">here</a>.</p><p>The default target is the <code>clean</code> target, and to build individual tests, just
run <code>make &lt;test_name&gt;</code>, where <code>&lt;test_name&gt;</code> is the file name without the <code>.zig</code>
extension. For example, to build <code>test01.zig</code>, run <code>make test01</code>.</p></div><p>Originally, I ran all of these tests up to <code>test10*.zig</code>, with the exception of
<code>test01_1.zig</code>, on Zig version <code>0.9.0</code>, and reproduced the same results, but I
have checked that the same results happen on <code>0.9.1</code>.</p><h3 id="suspend-and-resume">Suspend and Resume</h3><p>The first items I found were <a href="https://ziglang.org/documentation/0.9.1/#Suspend-and-Resume"><code>suspend</code> and <code>resume</code></a>, so I tried those and
immediately hit pay dirt.</p><p>This was my code:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn red(millis: u64) void {
    suspend {}
    std.time.sleep(millis);
    ready = true;
}

fn blue(millis: u64) void {
    std.time.sleep(millis);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](millis);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><div>
<p>For those that don’t know Zig, this basically has two functions, one of which
has a <code>suspend</code>, and the other that doesn’t. Then, at runtime, a random number
generator is used to decide which one to call.</p><p>The random number generator is used to make sure the compiler can’t inline the
call.</p></div><p>Saved as <code>test01.zig</code> and compiled with <code>zig build-exe test01.zig</code>, it produced
a <code>test01</code> binary. Half the time, it would work perfectly as expected when
<code>blue()</code> is called. The other half, when <code>red</code> was called, it did not.</p><p>However, the problem was not caused by the <code>std.os.abort()</code>; it was a segfault
when <em>calling</em> <code>red()</code>. The output is below:</p><pre tabindex="0"><code>fn(u64) void@205d40, fn(u64) void@205e70
Calling red
Segmentation fault at address 0x42e
/home/gavin/Code/Tests/zig/zig_async/test01.zig:6:1: 0x205d69 in red (test01)
fn red(millis: u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test01.zig:42:14: 0x22d659 in main (test01)
    fns[func](millis);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226aba in std.start.callMain (test01)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2076ae in std.start.callMainWithArgs (test01)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206746 in std.start.posixCallMainAndExit (test01)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206552 in std.start._start (test01)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>I was blown away by how very easy it was to break the compiler.</p><p>But the crucial thing here is that the program segfaulted when calling <code>red()</code>.
This means that <code>red()</code> was expecting to be called in a certain way, and it was
not.</p><p>That is a perfect match to Bob Nystrom’s point 2, even without my change.</p><p>However, there were two snags.</p><p>First, Loris Cro said that having a <code>suspend</code> without a corresponding <code>resume</code>
was undefined behavior. I argue that it’s not, or that if it <em>technically</em> is,
it is well-behaved, and users are taught that it’s okay.</p><p>The reason is this: having a <code>suspend</code> without a <code>resume</code> is used several times
in the language reference itself. One example is <code>resume_from_suspend.zig</code>,
which uses the fact that there is actually one more <code>suspend</code> than <code>resume</code>. In
fact, if run, it supposedly passes the internal test.</p><p>Thus, even if it is <em>technically</em> UB, their own documentation implies otherwise
by using it in examples such as <code>suspend_no_resume.zig</code>.</p><p>But I fixed that (after the fact) by creating <code>test01_1.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;
var f: anyframe = undefined;

fn red(millis: u64) void {
    suspend {
        f = @frame();
    }
    std.time.sleep(millis);
    ready = true;
}

fn blue(millis: u64) void {
    std.time.sleep(millis);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](millis);

    if (!ready) {
        std.os.abort();
    }

    if (func == 0) {
        resume f;
    }
}
</code></pre><p>I get the same segfault:</p><pre tabindex="0"><code>fn(u64) void@205d40, fn(u64) void@205e80
Calling red
Segmentation fault at address 0x4d7
/home/gavin/Code/Tests/zig/zig_async/test01_1.zig:7:1: 0x205d6d in red (test01_1)
fn red(millis: u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test01_1.zig:45:14: 0x22d687 in main (test01_1)
    fns[func](millis);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226aca in std.start.callMain (test01_1)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2076be in std.start.callMainWithArgs (test01_1)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206756 in std.start.posixCallMainAndExit (test01_1)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206562 in std.start._start (test01_1)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>Second, Andrew Kelley said that I had found a bug in the compiler and claimed
that the compiler should have given this error:</p><pre tabindex="0"><code>./test.zig:40:14: error: function is not comptime-known; @asyncCall required fns[func](millis);
</code></pre><p>Okay, fair enough, so I made two programs to see if I could get the compiler to
give me the error.</p><p>The first, <code>test02.zig</code>, looks like this:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn red(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var bytes: [64]u8 align(@alignOf(@Frame(fns[func]))) = undefined;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});

    if (!ready) {
        std.os.abort();
    }

    resume f;
}
</code></pre><p>The output that the compiler gave was this:</p><pre tabindex="0"><code>zig build-exe test02.zig
./test02.zig:42:48: error: unable to evaluate constant expression
    var bytes: [64]u8 align(@alignOf(@Frame(fns[func]))) = undefined;
                                               ^
make: *** [Makefile:7: test02] Error 1
</code></pre><p>That was not the error I was looking for, so I cheesed it with <code>test03.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn red(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var bytes: [64]u8 align(@alignOf(@Frame(red))) = undefined;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});

    if (!ready) {
        std.os.abort();
    }

    resume f;
}
</code></pre><p>The compiler gave this output:</p><pre tabindex="0"><code>zig build-exe test03.zig
./test03.zig:43:41: error: expected async function, found &#39;fn(*u64) void&#39;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});
                                        ^
make: *** [Makefile:10: test03] Error 1
</code></pre><p>The compiler “expected [an] async function.” This is code for “I wanted a red
function, and you gave me a blue one.”</p><p>I tried to get it to accept it with this code from <code>test04.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn red(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn blue_ish(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
}

fn blue(millis: *u64) void {
    var bytes: [64]u8 align(@alignOf(@Frame(blue_ish))) = undefined;
    const f = @asyncCall(&amp;bytes, {}, blue_ish, .{millis});
    resume f;
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var bytes: [64]u8 align(@alignOf(@Frame(red))) = undefined;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});

    if (!ready) {
        std.os.abort();
    }

    resume f;
}
</code></pre><p>The compiler still complained:</p><pre tabindex="0"><code>zig build-exe test04.zig
./test04.zig:50:41: error: expected async function, found &#39;fn(*u64) void&#39;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});
                                        ^
make: *** [Makefile:13: test04] Error 1
</code></pre><p>I tried again with <code>test05.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn red(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn blue(millis: *u64) void {
    ready = true;
    suspend {}
    std.time.sleep(millis.*);
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var bytes: [64]u8 align(@alignOf(@Frame(red))) = undefined;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});

    if (!ready) {
        std.os.abort();
    }

    resume f;
}
</code></pre><p>No luck:</p><pre tabindex="0"><code>zig build-exe test05.zig
./test05.zig:44:41: error: expected async function, found &#39;fn(*u64) void&#39;
    const f = @asyncCall(&amp;bytes, {}, fns[func], .{&amp;millis});
                                        ^
make: *** [Makefile:16: test05] Error 1
</code></pre><p>But in all of these cases, I want to draw special attention to what I had to do
in order to be able to have a <code>resume</code>: I had to do a special <code>@asyncCall()</code>.
That certainly looks like it fits Bob Nystrom’s point 2 and point 4.</p><p>Thus, I argue that, when using <code>suspend</code> and <code>resume</code> with function pointers,
Zig has function colors.</p><p>But I was not finished yet.</p><h3 id="async-and-await">Async and Await</h3><p>Next, I wrote the following:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    const any_ptr: anyframe = ptr;
    await ptr;
    resume any_ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](&amp;millis);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p>In essence, it tries to call either <code>red()</code> or <code>blue()</code> normally, but this time,
<code>red()</code> has a helper that it calls. The helper uses <code>suspend</code>, and <code>red()</code>
awaits it and also resumes it.</p><p>On this point, the Zig language reference is confusing. It seems to say that an
<code>await</code> will unsuspend a suspended function, but I’m not sure. In any case,
I decided to massage my code into that form, specifically, the same form as
<code>async_await.zig</code>, which has a <code>suspend</code> function called, resumed, and waited on
by its caller.</p><p>The result is <code>test06a.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    const any_ptr: anyframe = ptr;
    resume any_ptr;
    await ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](&amp;millis);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p>And the result was this:</p><pre tabindex="0"><code>fn(*u64) void@2084e0, fn(*u64) void@208700
Calling red
thread 25887 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test06a.zig:14:1: 0x208617 in red (test06a)
fn red(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test06a.zig:52:14: 0x24bf68 in main (test06a)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25519d in std.event.loop.Loop.workerRun (test06a)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2398dd in std.event.loop.Loop.run (test06a)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b469 in std.start.callMainWithArgs (test06a)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209576 in std.start.posixCallMainAndExit (test06a)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x209382 in std.start._start (test06a)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>Even worse, the panic happens when <code>blue()</code> is called!</p><pre tabindex="0"><code>fn(*u64) void@2084e0, fn(*u64) void@208700
Calling blue
thread 34522 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test06a.zig:22:1: 0x2087c1 in blue (test06a)
fn blue(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test06a.zig:52:14: 0x24bf68 in main (test06a)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25519d in std.event.loop.Loop.workerRun (test06a)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2398dd in std.event.loop.Loop.run (test06a)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b469 in std.start.callMainWithArgs (test06a)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209576 in std.start.posixCallMainAndExit (test06a)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x209382 in std.start._start (test06a)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>The one thing I was not doing that the language reference’s <code>async_await.zig</code>
was doing was calling the function with <code>async</code>, so I did that in
<code>test06a_1.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    suspend {}
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    const any_ptr: anyframe = ptr;
    resume any_ptr;
    await ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var f = async fns[func](&amp;millis);

    const ptr: anyframe-&gt;void = &amp;f;
    await ptr;

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p>And it gave me a compile error:</p><pre tabindex="0"><code>zig build-exe test06a_1.zig
./test06a_1.zig:52:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:22: test06a_1] Error 1
</code></pre><p>This example shows that there is a difference between <code>async</code> and non-<code>async</code>
functions. I feel like it’s a good example because it directly imitates an
example in Zig’s own language reference, except for function pointers, and it
does not compile.</p><p>It is my opinion that it does not because of function colors.</p><p>I decided to change both to blocking mode, yielding <code>test06a_2.zig</code> and
<code>test06a_3.zig</code>, respectively.</p><p>The only change was changing the <code>pub const io_mode = .evented;</code> line to
<code>pub const io_mode = .blocking;</code>.</p><p><code>test06a_2.zig</code> compiled, and <code>blue()</code> even ran correctly. <code>red()</code> gave me this:</p><pre tabindex="0"><code>fn(*u64) void@205d90, fn(*u64) void@205fb0
Calling red
thread 46785 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test06a_2.zig:14:1: 0x205ec3 in red (test06a_2)
fn red(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test06a_2.zig:52:14: 0x22d799 in main (test06a_2)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226bfa in std.start.callMain (test06a_2)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2077ee in std.start.callMainWithArgs (test06a_2)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206886 in std.start.posixCallMainAndExit (test06a_2)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206692 in std.start._start (test06a_2)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>So it appears that the <code>async_await.zig</code> example in the language reference is
wrong.</p><p><code>test06a_3.zig</code> gave me a similar compiler error to <code>test06a_1.zig</code>.</p><p>But what happens if I reverse the <code>resume any_ptr;</code> and <code>await ptr;</code> lines in
all four? This produced <code>test06b{,_1,_2,_3}.zig</code>.</p><p>Same exact results.</p><p>Next, I removed the <code>await ptr;</code> line from all four, giving me
<code>test07{,_1,_2,_3}.zig</code>.</p><p><code>test07.zig</code> compiled, and <code>red()</code> ran correctly. <code>blue()</code> gave me this error:</p><pre tabindex="0"><code>fn(*u64) void@2084b0, fn(*u64) void@208540
Calling blue
thread 64161 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test07.zig:21:1: 0x208601 in blue (test07)
fn blue(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test07.zig:51:14: 0x24bda8 in main (test07)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x254fdd in std.event.loop.Loop.workerRun (test07)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x23971d in std.event.loop.Loop.run (test07)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b2a9 in std.start.callMainWithArgs (test07)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x2093b6 in std.start.posixCallMainAndExit (test07)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x2091c2 in std.start._start (test07)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p><code>test07_1.zig</code> refused to compile with this error:</p><pre tabindex="0"><code>zig build-exe test07_1.zig
./test07_1.zig:51:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:46: test07_1] Error 1
</code></pre><p><code>test07_2.zig</code> compiled, and both <code>red()</code> and <code>blue()</code> worked!</p><p><code>test07_3.zig</code> refused to compile with this error:</p><pre tabindex="0"><code>zig build-exe test07_3.zig
./test07_3.zig:51:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:52: test07_3] Error 1
</code></pre><p>Next, I took the <code>test06b</code> series, and turned them into the <code>test08</code> series,
with one change: I deleted the <code>suspend</code> in <code>async_ready()</code>.</p><p>They produced the exact same results as the <code>test06b</code> series.</p><p>Then I took the <code>test08</code> series and turned them into the <code>test09</code> series by
removing the <code>await ptr;</code> line.</p><p><code>test09.zig</code> compiled, but this time, it gave me two different errors for
<code>red()</code> and <code>blue()</code>.</p><p><code>red()</code> gave me this:</p><pre tabindex="0"><code>fn(*u64) void@208490, fn(*u64) void@208520
Calling red
thread 20057 panic: awaiting function resumed
/home/gavin/Code/Tests/zig/zig_async/test09.zig:9:19: 0x24cabc in async_ready (test09)
    std.time.sleep(millis.*);
                  ^
/home/gavin/Code/Tests/zig/zig_async/test09.zig:17:5: 0x208515 in red (test09)
    resume any_ptr;
    ^
/home/gavin/Code/Tests/zig/zig_async/test09.zig:50:14: 0x24bd88 in main (test09)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x254fad in std.event.loop.Loop.workerRun (test09)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2396fd in std.event.loop.Loop.run (test09)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b289 in std.start.callMainWithArgs (test09)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209396 in std.start.posixCallMainAndExit (test09)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x2091a2 in std.start._start (test09)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
thread 20072 panic: resumed a non-suspended function
/home/gavin/Code/Tests/zig/zig_async/test09.zig:8:1: 0x24ca94 in async_ready (test09)
fn async_ready(millis: *u64) void {
^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x254fad in std.event.loop.Loop.workerRun (test09)
                        resume handle;
                        ^
/usr/lib/zig/std/Thread.zig:359:13: 0x2630ff in std.Thread.callFn (test09)
            @call(.{}, f, args);
            ^
/usr/lib/zig/std/Thread.zig:875:30: 0x263086 in std.Thread.Instance.entryFn (test09)
                return callFn(f, self.fn_args);
                             ^
???:?:?: 0x265c6e in ??? (???)
Aborted
</code></pre><p><code>blue()</code> gave me this:</p><pre tabindex="0"><code>fn(*u64) void@208490, fn(*u64) void@208520
Calling blue
thread 20130 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test09.zig:20:1: 0x2085e1 in blue (test09)
fn blue(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test09.zig:50:14: 0x24bd88 in main (test09)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x254fad in std.event.loop.Loop.workerRun (test09)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2396fd in std.event.loop.Loop.run (test09)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b289 in std.start.callMainWithArgs (test09)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209396 in std.start.posixCallMainAndExit (test09)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x2091a2 in std.start._start (test09)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>So this time, <code>red()</code> gave the same error, as well as different error. I have no
idea what it means.</p><p><code>test09_1.zig</code> gave the familiar compiler error:</p><pre tabindex="0"><code>zig build-exe test09_1.zig
./test09_1.zig:48:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:70: test09_1] Error 1
</code></pre><p><code>test09_2.zig</code> broke up the nice pattern! It compiles, and <code>blue()</code> succeeds,
but <code>red()</code> segfaults!</p><pre tabindex="0"><code>fn(*u64) void@205c90, fn(*u64) void@205ce0
Calling red
Segmentation fault at address 0x7ffde698c4c8
???:?:?: 0x7ffde698c4c8 in ??? (???)
Aborted
</code></pre><p>Once again, somehow, a calling convention was violated. And if we look, there is
a <code>resume</code>! That was also there for the last segfault, so I presume <code>resume</code> is
one thing that marks a function as <code>async</code>.</p><p><code>test09_3.zig</code> gave me the familiar compiler error as well:</p><pre tabindex="0"><code>zig build-exe test09_3.zig
./test09_3.zig:50:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:76: test09_3] Error 1
</code></pre><p>For the <code>test10</code> series, I decided to do something slightly different, and more
devious.</p><p>This is <code>test10.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    await ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](&amp;millis);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p><code>blue()</code> is plain. <code>async_ready()</code> is plain, despite its name. (I was lazy.)
However, <code>red()</code> calls <code>async_ready()</code> with <code>async</code> and uses <code>await</code> on it.</p><p><code>test10.zig</code> compiles, and <code>blue()</code> and <code>red()</code> both give me the familiar error:</p><pre tabindex="0"><code>fn(*u64) void@205d90, fn(*u64) void@205f70
Calling red
thread 27175 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test10.zig:11:1: 0x205e7e in red (test10)
fn red(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test10.zig:47:14: 0x22d759 in main (test10)
    fns[func](&amp;millis);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226bba in std.start.callMain (test10)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2077ae in std.start.callMainWithArgs (test10)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206846 in std.start.posixCallMainAndExit (test10)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206652 in std.start._start (test10)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p><code>test10_1.zig</code> looks like this:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    await ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    var f = async fns[func](&amp;millis);

    const ptr: anyframe-&gt;void = &amp;f;
    await ptr;

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p>It gives the familiar compile error:</p><pre tabindex="0"><code>zig build-exe test10_1.zig
./test10_1.zig:49:22: error: expected async function, found &#39;fn(*u64) void&#39;
    var f = async fns[func](&amp;millis);
                     ^
make: *** [Makefile:82: test10_1] Error 1
</code></pre><p><code>test10_2.zig</code> looks like <code>test10.zig</code>, except it’s blocking:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .blocking;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64) void {
    var f = async async_ready(millis);
    const ptr: anyframe-&gt;void = &amp;f;
    await ptr;
}

fn blue(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
    }

    fns[func](&amp;millis);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p><code>test10_2.zig</code> compiled, and once again, <code>blue()</code> ran correctly, while <code>red()</code>
gave the familiar error.</p><p><code>test10_3.zig</code> looks like <code>test10_1.zig</code> except its blocking, and it also gives
the same compiler error.</p><p>For the <code>test11</code> series, I was even more devious.</p><p>Here is <code>test11.zig</code>:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
    _ = millis;
    const ptr: anyframe-&gt;void = f.?;
    await ptr;
}

fn blue(millis: *u64, f: ?*@Frame(async_ready)) void {
    _ = f;
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;
    var f: ?*@Frame(async_ready) = null;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
        f = null;
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
        var f2 = async async_ready(&amp;millis);
        f = &amp;f2;
    }

    fns[func](&amp;millis, f);

    if (!ready) {
        std.os.abort();
    }
}
</code></pre><p>This takes the <code>test10</code> series and flips <code>red()</code> on its head: instead of calling
<code>async_ready()</code> with <code>async</code>, the code calls <code>async_ready()</code> with <code>async</code>
<em>before</em> calling <code>red()</code> and passes in the pointer to the function to <code>await</code>
on, which is what <code>red()</code> does.</p><p><code>test11.zig</code> does compile, and as is usual, <code>red()</code> and <code>blue()</code> give the same
error:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@208600, fn(*u64, ?*@Frame(async_ready)) void@2087d0
Calling red
thread 24965 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test11.zig:13:1: 0x208690 in red (test11)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test11.zig:54:14: 0x24bfdd in main (test11)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x2552ad in std.event.loop.Loop.workerRun (test11)
                        resume handle;
                        ^
/usr/lib/zig/std/Thread.zig:359:13: 0x2633ff in std.Thread.callFn (test11)
            @call(.{}, f, args);
            ^
/usr/lib/zig/std/Thread.zig:875:30: 0x263386 in std.Thread.Instance.entryFn (test11)
                return callFn(f, self.fn_args);
                             ^
???:?:?: 0x265f6e in ??? (???)
Aborted
</code></pre><p><code>test11_1.zig</code> looks like this:</p><pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const RndGen = std.rand.DefaultPrng;

pub const io_mode = .evented;

var ready: bool = false;

fn async_ready(millis: *u64) void {
    std.time.sleep(millis.*);
    ready = true;
}

fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
    _ = millis;
    const ptr: anyframe-&gt;void = f.?;
    await ptr;
}

fn blue(millis: *u64, f: ?*@Frame(async_ready)) void {
    _ = f;
    std.time.sleep(millis.*);
    ready = true;
}

const fns = [2]@TypeOf(blue) { red, blue };

pub fn main() !void {

    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;{s}, {s}\n&#34;, .{red, blue});

    var rnd = RndGen.init(@bitCast(u64, std.time.milliTimestamp()));
    var rand = rnd.random();

    var millis = rand.uintAtMost(u64, 2000);
    while (millis &lt; 1000) {
        millis = rand.uintAtMost(u64, 2000);
    }

    var b = rand.boolean();
    var func: u32 = if (b) 1 else 0;
    var f: ?*@Frame(async_ready) = null;

    if (func == 1) {
        try stdout.print(&#34;Calling blue\n&#34;, .{});
        f = null;
    }
    else {
        try stdout.print(&#34;Calling red\n&#34;, .{});
        var f2 = async async_ready(&amp;millis);
        f = &amp;f2;
    }

    f = async fns[func](&amp;millis, f);

    if (!ready) {
        std.os.abort();
    }

    const ptr: anyframe-&gt;void = f.?;
    await ptr;
}
</code></pre><p>As you can see, the only change is that the function pointer is called with
<code>async</code>, as with all other <code>*_1.zig</code> tests.</p><p>This one gives the familiar compile error:</p><pre tabindex="0"><code>zig build-exe test11_1.zig
./test11_1.zig:54:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:94: test11_1] Error 1
</code></pre><p>I likewise made a <code>test11_2.zig</code> and <code>test11_3.zig</code>, which just changes from
<code>evented</code> to <code>blocking</code>.</p><p><code>test11_2.zig</code> compiles, <code>blue()</code> runs without error, and <code>red()</code> gives the same
error as usual:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@205db0, fn(*u64, ?*@Frame(async_ready)) void@205f80
Calling red
thread 29581 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test11_2.zig:13:1: 0x205e40 in red (test11_2)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test11_2.zig:54:14: 0x22d7c1 in main (test11_2)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226bca in std.start.callMain (test11_2)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2077be in std.start.callMainWithArgs (test11_2)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206856 in std.start.posixCallMainAndExit (test11_2)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206662 in std.start._start (test11_2)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p><code>test11_3.zig</code> gives the familiar compile error:</p><pre tabindex="0"><code>zig build-exe test11_3.zig
./test11_3.zig:54:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:100: test11_3] Error 1
</code></pre><h3 id="compiler-errors">Compiler Errors</h3><p>I want to take a second to talk about the pattern I have seen up to this point.</p><p>First, two of the four examples in every series starting with <code>test06a</code> <em>do not
compile!</em> And the error is always the same, that an <code>async</code> function was
expected.</p><p>It is my opinion that Zig was expecting red functions and found the type of a
blue function instead, which if true, means Zig has function colors.</p><p>But why was an <code>async</code> function required? In all of the cases, I called the
function pointer with the <code>async</code> keyword.</p><p>However, I think I have a trick up my sleeve to make the compiler errors go
away.</p><p>So I copied the <code>test10</code> series to make the <code>test12</code> series, and I copied the
<code>test11</code> series to make the <code>test13</code> series. In both new series, the only thing
I did was to change the <code>@TypeOf(blue)</code> to <code>@TypeOf(red)</code>.</p><p>I did this for a curious reason: the Zig language reference says:</p><blockquote>
<p>Zig infers that a function is <code>async</code> when it observes that the function
contains a suspension point.</p></blockquote><p>Yes, that is correct: the language reference admits that Zig has <code>async</code> and
non-<code>async</code> functions. Once I read that, I was sure that Zig actually has
function colors.</p><p>Also, it says that Zig “<em>infers</em>” when a function is <code>async</code>. When I first heard
about Zig’s model, this is what I assumed it did: it statically figured out
which functions were <code>async</code> (red), and which were non-<code>async</code> (blue), and if it
couldn’t, then it would have to fall back on exposing function colors.</p><p>But then it also says this:</p><blockquote>
<p><code>await</code> is a suspend point.</p></blockquote><p>So any function that uses the <code>await</code> keyword should be an <code>async</code> function,
right?</p><p>I figured this out after I initially made a mistake in <code>test11_2.zig</code>, where
after the <code>if (!ready)</code> statement and block, I had the following:</p><pre tabindex="0"><code>
    if (f != null) {
        const ptr: anyframe-&gt;void = f.?;
        await ptr;
    }
</code></pre><p>It gave me the following compiler error:</p><pre tabindex="0"><code>zig build-exe test11_2.zig
/usr/lib/zig/std/start.zig:473:1: error: function with calling convention &#39;Inline&#39; cannot be async
inline fn initEventLoopAndCallMain() u8 {
^
/usr/lib/zig/std/start.zig:495:12: note: async function call here
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:561:37: note: async function call here
            const result = root.main() catch |err| {
                                    ^
./test11_2.zig:62:9: note: await here is a suspend point
        await ptr;
        ^
make: *** [Makefile:97: test11_2] Error 1
</code></pre><p>That extra <code>await</code> made <code>main()</code> <code>async</code>!</p><p>So my goal was to make <code>red()</code> <code>async</code>.</p><p>That was why the <code>test11</code> series was crafted so that <code>red()</code> would not call a
function with <code>async</code> but it <em>would</em> <code>await</code> on one.</p><p>And yet, the results were the same. Why?</p><h3 id="speculation-and-opinion">Speculation and Opinion</h3><p>I am giving myself a little space to express a subjective opinion here.</p><p>Zig’s <code>async</code> model is confusing to me.</p><p>It appears that <code>eventing</code> turns a lot of stuff into <code>async</code>, but not everything
because I still get compiler errors. It also appears that, despite having
matching <code>async</code> and <code>await</code> in <code>test11_2.zig</code>, something is wrong with the
code.</p><p>Or there is a bug in the compiler. Andrew Kelley said I ran into one, so maybe I
ran into more?</p><p>What’s more, the language reference says that using <code>await</code> should make <code>red()</code>
an <code>async</code> function, but it’s not, for some reason, and I have no idea why.</p><p>Maybe it’s because I am much dumber than the Zig team, but if that’s the case, I
don’t think Zig is a good language because <em>everyone</em> is stupid at times. We can
all be tired, sick, rushed, or just simply misunderstand the documentation due
to a different starting mental model than the Zig team expected of the audience
reading the language reference.</p><p>The other thing I don’t understand is all of the “resumed an async function
which already returned” errors I am getting. They seem to happen when <em>calling</em>
<code>red()</code>.</p><p>The only thing I can think of is that <code>red()</code> <em>is</em> <code>async</code>, but the compiler
is giving compiler errors when it shouldn’t in some cases, and in others, it
generated code to <em>resume</em> <code>red()</code> rather than call it normally.</p><p>And then there’s the case of <code>async_ready()</code> which in many cases, is not
<code>async</code>, yet the compiler allows me to call it as though it is, with <code>async</code>.</p><p>But this is all speculation.</p><p>Back to the regularly scheduled mischief.</p><h3 id="async-async_ready"><code>async</code> <code>async_ready()</code></h3><p>My first thought about how to fix the problem was to make sure <code>async_ready()</code>
was actually <code>async</code>. According to the language reference, I can do that putting
in a suspension point.</p><p>So I took <code>test11</code> series and copied them into the <code>test14</code> series. I only made
one change, by adding the following code to <code>async_ready()</code> after the
<code>std.time.sleep(millis.*);</code> line:</p><pre tabindex="0"><code>    suspend {
        std.time.sleep(millis.*);
        resume @frame();
    }
</code></pre><p>With a suspend point, <code>async_ready()</code> should properly be <code>async</code> now. However, I
have a <code>resume</code> for it because the language reference says that <code>await</code>
“suspends until the target function completes.” Specifically, it does <em>not</em> say
that it <em>resumes</em> the target function; only that it suspends the parent <em>until</em>
the target completes.</p><p><code>test14.zig</code> compiled, but it gave me <em>two</em> errors when <code>red()</code> runs:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@208620, fn(*u64, ?*@Frame(async_ready)) void@2087f0
Calling red
thread 11620 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test14.zig:17:1: 0x2086b0 in red (test14)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test14.zig:58:14: 0x24bfc8 in main (test14)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25527d in std.event.loop.Loop.workerRun (test14)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2398ad in std.event.loop.Loop.run (test14)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b439 in std.start.callMainWithArgs (test14)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209546 in std.start.posixCallMainAndExit (test14)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x209352 in std.start._start (test14)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
thread 11635 panic: resumed a non-suspended function
/home/gavin/Code/Tests/zig/zig_async/test14.zig:8:1: 0x24ccb4 in async_ready (test14)
fn async_ready(millis: *u64) void {
^
/home/gavin/Code/Tests/zig/zig_async/test14.zig:12:9: 0x24cdc8 in async_ready (test14)
        resume @frame();
        ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25527d in std.event.loop.Loop.workerRun (test14)
                        resume handle;
                        ^
/usr/lib/zig/std/Thread.zig:359:13: 0x2633cf in std.Thread.callFn (test14)
            @call(.{}, f, args);
            ^
/usr/lib/zig/std/Thread.zig:875:30: 0x263356 in std.Thread.Instance.entryFn (test14)
                return callFn(f, self.fn_args);
                             ^
???:?:?: 0x265f3e in ??? (???)
Aborted
</code></pre><p>On the other hand, <code>blue()</code> produces only the familiar error:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@208620, fn(*u64, ?*@Frame(async_ready)) void@2087f0
Calling blue
thread 11694 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test14.zig:23:1: 0x2088b1 in blue (test14)
fn blue(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test14.zig:58:14: 0x24bfc8 in main (test14)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25527d in std.event.loop.Loop.workerRun (test14)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2398ad in std.event.loop.Loop.run (test14)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b439 in std.start.callMainWithArgs (test14)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209546 in std.start.posixCallMainAndExit (test14)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x209352 in std.start._start (test14)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p><code>test14_1.zig</code> gave me the same compile error as always:</p><pre tabindex="0"><code>zig build-exe test14_1.zig
./test14_1.zig:58:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:177: test14_1] Error 1
</code></pre><p><code>test14_2.zig</code> compiles, <code>blue()</code> runs fine, and <code>red()</code> gives the usual error:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@205db0, fn(*u64, ?*@Frame(async_ready)) void@205f80
Calling red
thread 61447 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test14_2.zig:17:1: 0x205e40 in red (test14_2)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test14_2.zig:58:14: 0x22d7f2 in main (test14_2)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226bca in std.start.callMain (test14_2)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2077be in std.start.callMainWithArgs (test14_2)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206856 in std.start.posixCallMainAndExit (test14_2)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206662 in std.start._start (test14_2)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>And <code>test14_3.zig</code> gave me the usual compiler error:</p><pre tabindex="0"><code>zig build-exe test14_3.zig
./test14_3.zig:58:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:183: test14_3] Error 1
</code></pre><p>So what if I remove the <code>resume @frame();</code> line from the <code>test14</code> series to make
the <code>test15</code> series?</p><p><code>test15.zig</code> compiles and gives the usual error for both <code>red()</code> and <code>blue()</code>:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@208620, fn(*u64, ?*@Frame(async_ready)) void@2087f0
Calling red
thread 56522 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test15.zig:16:1: 0x2086b0 in red (test15)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test15.zig:57:14: 0x24bfc8 in main (test15)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/event/loop.zig:1415:25: 0x25525d in std.event.loop.Loop.workerRun (test15)
                        resume handle;
                        ^
/usr/lib/zig/std/event/loop.zig:702:23: 0x2398ad in std.event.loop.Loop.run (test15)
        self.workerRun();
                      ^
/usr/lib/zig/std/start.zig:488:21: 0x20b439 in std.start.callMainWithArgs (test15)
            loop.run();
                    ^
/usr/lib/zig/std/start.zig:409:17: 0x209546 in std.start.posixCallMainAndExit (test15)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x209352 in std.start._start (test15)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p><code>test15_1.zig</code> gives the usual compiler error:</p><pre tabindex="0"><code>zig build-exe test15_1.zig
./test15_1.zig:57:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:193: test15_1] Error 1
</code></pre><p><code>test15_2.zig</code> compiles, and <code>blue()</code> runs fine, but <code>red()</code>, as usual, gives an
error:</p><pre tabindex="0"><code>fn(*u64, ?*@Frame(async_ready)) void@205db0, fn(*u64, ?*@Frame(async_ready)) void@205f80
Calling red
thread 65510 panic: resumed an async function which already returned
/home/gavin/Code/Tests/zig/zig_async/test15_2.zig:16:1: 0x205e40 in red (test15_2)
fn red(millis: *u64, f: ?*@Frame(async_ready)) void {
^
/home/gavin/Code/Tests/zig/zig_async/test15_2.zig:57:14: 0x22d7ef in main (test15_2)
    fns[func](&amp;millis, f);
             ^
/usr/lib/zig/std/start.zig:561:37: 0x226bca in std.start.callMain (test15_2)
            const result = root.main() catch |err| {
                                    ^
/usr/lib/zig/std/start.zig:495:12: 0x2077be in std.start.callMainWithArgs (test15_2)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/lib/zig/std/start.zig:409:17: 0x206856 in std.start.posixCallMainAndExit (test15_2)
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                ^
/usr/lib/zig/std/start.zig:322:5: 0x206662 in std.start._start (test15_2)
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    ^
Aborted
</code></pre><p>And obviously, <code>test15_3.zig</code> is unchanged:</p><pre tabindex="0"><code>zig build-exe test15_3.zig
./test15_3.zig:57:18: error: expected async function, found &#39;fn(*u64, ?*@Frame(async_ready)) void&#39;
    f = async fns[func](&amp;millis, f);
                 ^
make: *** [Makefile:199: test15_3] Error 1
</code></pre><p>What if I make the <code>test15</code> series into the <code>test16</code> series by making the
<code>suspend</code> block in <code>async_ready()</code> empty?</p><p>Same exact results as the <code>test15</code> series.</p><p>This doesn’t make sense to me because one of the examples in the language
reference, <code>suspend_no_resume.zig</code>, calls a function with <code>suspend</code> using
<code>async</code>, and it works.</p><p>And all of that does not answer the question why the <code>test*_1.zig</code> and the
<code>test*_3.zig</code> files won’t compile. Maybe it’s because they expect
<code>@TypeOf(blue)</code>, and <code>blue()</code> is not <code>async</code>?</p><p>So I copied the <code>test14</code> series to the <code>test17</code> series, the <code>test15</code> series to
the <code>test18</code> series, and the <code>test16</code> series to the <code>test19</code> series. In all
cases, the only change I made was to change <code>@TypeOf(blue)</code> to <code>@TypeOf(red)</code>.</p><p>I got the exact same results!</p><p>This <em>really</em> does not make sense to me because, per the “function with calling
convention ‘Inline’ cannot be async” compiler error I got with a mistake in
<code>test11_2.zig</code>. That error happened because the existence of an <code>await</code> made
<code>main()</code> an <code>async</code> function. <code>red()</code> has <code>await</code>, so it should be <code>async</code> and
its <em>type</em> should be <code>async</code>. Yet I still get the compiler errors.</p><p>Something must be wrong either with my brain, the code, or the compiler.</p><p>Opinion here: it’s probably all three. However, I’m failing to see what is wrong
with the code because as far as I know, not all of my tests have undefined
behavior.</p><p>But I have one last trick up my sleeve to make <code>async_ready()</code> <code>async</code>.</p><p>About the builtin function <code>@frame()</code>, the language reference says,</p><blockquote>
<p>This function does not mark a suspension point, but it does cause the function
in scope to become an async function.</p></blockquote><p>So I copied the <code>test19</code> series to the <code>test20</code> and <code>test21</code> series. I replaced
all instances of the <code>suspend{}</code> in <code>async_ready()</code> with <code>g_frame = @frame();</code>
(and added <code>g_frame</code> as a global frame variable), and in the <code>test20</code> series, I
changed <code>@TypeOf(red)</code> back to <code>@TypeOf(blue)</code>, just in case.</p><p>I got the same results as with the <code>test19</code> series.</p><p>And now, I am out of ideas. <code>async_ready()</code> and <code>red()</code> should be <code>async</code>, but
somehow, the compiler and runtime errors are still there.</p><h2 id="the-true-shape-of-zigs-async-model">The True Shape of Zig’s <code>async</code> Model</h2><p>With all of that said, what exactly does Zig’s <code>async</code> model look like?</p><p>This section is pure speculation, based on my tests, of course. But I am not a
Zig expert, and the results of these tests have left me with more questions than
answers.</p><p>First, I think the documentation is mostly correct, albeit unclear.</p><p>It says,</p><blockquote>
<p>Zig infers that a function is async when it observes that the function
contains a suspension point.</p></blockquote><p>This is a pretty clear definition of an <code>async</code> function, and I think this is
good because it focuses us on what we need: we need to know what creates a
suspension point.</p><p>So let’s look at all of the ways a function can have a suspension point:</p><ul>
<li>“A function call of an async function is a suspend point.”</li><li>Use of the <code>suspend</code> construct is obviously a suspension point.</li><li>“<code>await</code> is a suspend point.” (Hence, my trying to get <code>red()</code> to be <code>async</code>
with <code>await</code>.)</li><li>“[<code>@frame()</code>] does not mark a suspension point, but it does cause the function
in scope to become an <code>async</code> function.” (This appears to be the one exception
to the “suspension point” rule.)</li></ul><blockquote>
<p>Async functions can be called the same as normal functions.</p></blockquote><p>This is usually, but not always, the case.</p><p>However, before I continue, let me say a little bit of praise for Zig: this is
innovation. This is a piece of good work that, most of the time, <code>async</code>
functions can be called the same as normal functions.</p><p>But of course, beware once you move functions from compile-time to runtime
because there is where the conveniences of Zig’s <code>async</code> model cannot help you
(much).</p><p>In short, like with all concurrency models (including my favorite!), you still
need to understand the model fully before you can write correct code in that
model.</p><h2 id="possible-complaints">Possible Complaints</h2><p>In this section, I will try to preemptively address possible complaints.</p><h3 id="artificial-code">Artificial Code</h3><p>The first complaint I expect is that all of my examples are artificial code.</p><p>Well, yes. They were designed to tease out the reality of Zig’s <code>async</code> story
because the documentation was Greek to me.</p><p>But as every compiler engineer will tell you, they would prefer small examples
of code to trigger bugs or other conditions for testing.</p><p>I also believe that small examples can always be turned into actual, useful
code. In this case, imagine you are trying to use <a href="https://www.nmichaels.org/zig/interfaces.html">interfaces in Zig</a>. You
will use a lot of function pointers, and I’m sure that some situation could
cause you grief if you are unaware that Zig’s functions are colored.</p><h3 id="undefined-behavior">Undefined Behavior</h3><p>Another complaint is that most, or all, of my tests exhibit undefined behavior.</p><p>As I said before, I believe that is unfair because:</p><ul>
<li>The examples in the language reference would <em>also</em> have undefined behavior.</li><li>The “Async Functions” section in the language reference never says anything is
undefined behavior.</li></ul><p>In fact, the only time it says anything related to <code>async</code> is undefined behavior
(as far as I can tell) is passing a buffer that is too small to <code>@asyncCall()</code>.</p><h3 id="low-level">Low-Level</h3><p>Another possible complaint is that I only demonstrated function colors using
low-level constructs that most people won’t use.</p><p>For example, Loris Cro told me that <code>suspend</code> and <code>resume</code> are low-level
constructs. The language reference agrees:</p><blockquote>
<p>In general, <code>suspend</code> is lower level than <code>await</code>. Most application code will
use only <code>async</code> and <code>await</code>, but event loop implementations will make use of
<code>suspend</code> internally.</p></blockquote><p>So, it could be the case that only library writers need to care about function
colors in Zig, right?</p><p>I agree that, for the most part, only library writers need to care, but I
disagree that <em>only</em> library writers need to care.</p><p>First, if a non-library writer is using something like Zig interfaces and needs
to use an <code>async</code> function, they have to care.</p><p>This is a big reason I emphasize “use” rather than “call.”</p><p>Second, <code>await</code> makes functions <code>async</code>, and <code>await</code> is not low-level. The proof
that <code>await</code> makes functions <code>async</code> is above.</p><p>Third, <code>async</code> is, in fact, viral. The language reference says,</p><blockquote>
<p>Zig infers that a function is async when it observes that the function
contains a suspension point. Async functions can be called the same as normal
functions. <em>A function call of an async function is a suspend point.</em></p></blockquote><p>(Emphasis added.)</p><p>In other words, if you call an <code>async</code> function, your function gets a suspend
point, which means that your function becomes <code>async</code>.</p><p>In fact, if you look at Bob Nystrom’s point 3, “You can only call a red function
from within another red function,” this means that Zig fits point 3!</p><p>What Zig does differently than Bob Nystrom’s “hypothetical” language is that if
it sees you call a red function from a blue function, it shrugs its shoulders,
makes the blue function red, and does not tell you. This gives the appearance of
being able to call red functions from blue functions while still only allowing
red functions to call red functions.</p><div>
<p>With this in mind, Zig actually fits point 1 through 4; this means that it fits
all of the points that matter! (Point 5, of course, applies just to the standard
library.)</p><p>I argue that this means that Zig has function colors <em>even if</em> you do not accept
that my definition fits the points given by Bob Nystrom.</p></div><p>Fourth, Zig programmers may be under the false impression that Zig does not have
function colors.</p><p>Opinions incoming.</p><p>Loris Cro’s original post is titled “What is Zig’s ‘Colorblind’ Async/Await?” I
like that title because it is accurate: most of the time, Zig’s <code>async</code> <em>is</em>
colorblind because most of the time, <code>async</code> functions can be called the same as
normal functions.</p><p>But I think that Zig proponents may have gone too far. I don’t know how it
happened; perhaps it was just shorthand. But most of the references to Zig’s
<code>async</code> model that I have seen say things like:</p><ul>
<li><a href="https://lobste.rs/s/h7gkoe/why_static_languages_suffer_from#c_zyrttl">“Zig async functions do not suffer from function coloring.”</a></li><li><a href="https://news.ycombinator.com/item?id=28658791">“Zig’s functions are colorblind”</a>. Notice that there is no qualification
on this statement.</li><li><a href="https://news.ycombinator.com/item?id=26427726">“Zig has the same codebase that supports both evented I/O and blocking I/O
because of the <em>non-existence</em> of function coloring.”</a> (Emphasis added.)</li></ul><p>The way these claims are worded may lead some newcomers, or people who are not
language lawyers, to think that you don’t have to worry about function colors at
all in Zig.</p><p>I hope that this post has shown otherwise. I also hope that Zig proponents can
be careful to not (accidentally or otherwise) mislead programmers about Zig’s
<code>async</code> model.</p><h2 id="conclusion">Conclusion</h2><p>This post has been one of my longest, though that’s entirely down to the pages
of code, compiler errors, and runtime errors I shared verbatim.</p><p>So what did I learn?</p><p>First, that my gut feeling was (I think) correct.</p><p>Second, I now have more proof that structured concurrency is the right method
(at least for me) to create a concurrency model in a programming language. This
additional proof includes:</p><ul>
<li>The fact that structured concurrency does not have the function color problem.</li><li>The fact that Swift has <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md">implemented structured concurrency</a>.</li><li>Experience with <a href="https://git.yzena.com/Yzena/Yc">real code</a> demonstrating that structured concurrency
works and is easier to reason about (for me).
<ul>
<li>It even allows me to use a <a href="https://git.yzena.com/Yzena/Yc/src/branch/master/src/pool/stackpool.c">stack-based allocator</a> basically for free!</li><li>Which, in turn, allows me to safely implement exceptions and other error
handling in C, as well as many other niceties.</li></ul></li></ul><p>Third, I learned, yet again, that I should <em>always</em> let a cooler head prevail. I
am bad at it. I hope I got just a bit better with this post.</p></div></div>
  </body>
</html>
