<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hkalbasi.github.io/zngur/">Original</a>
    <h1>Zngur: A C&#43;&#43;/Rust interop tool</h1>
    
    <div id="readability-page-1" class="page">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            
            
        </nav>

        <!-- Track and set sidebar scroll position -->
        

        <div id="page-wrapper">

            <div class="page">
                                
                

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        
<p>Zngur (/zængɑr/) is a C++/Rust interop tool. It tries to expose arbitrary Rust types, methods, and functions while preserving its
semantics and ergonomics as much as possible. Using Zngur, you can use arbitrary Rust crate in your C++ code as easily as using it in
normal Rust code, and you can write idiomatic Rusty API for your C++ library inside C++.</p>
<h2 id="idea"><a href="#idea">Idea</a></h2>
<p>Rust and C++ are similar languages but with some important differences. Particularly:</p>
<ul>
<li>Rust is a memory-safe language with a strong boundary between <code>safe</code> and <code>unsafe</code> declared using the <code>unsafe</code> keyword, C++
is an unsafe language with no such difference and keyword.</li>
<li>C++ has macro-like templates, which support variadic, specialization and are checked
at instantiation time. Rust generics, on the other hand, are type-checked at definition
time using trait bounds.</li>
<li>Rust move is a <code>memcpy</code> with compiler support for not destructing the moved out of variable, but C++
move can execute arbitrary code.</li>
</ul>
<p>In all of these differences, C++ has more freedom relative to the Rust:</p>
<ul>
<li>Rust considers C++ functions as unsafe, but C++ will happily call Rust code (even unsafe) as there
is no difference between it and normal C++ code.</li>
<li>Every rust generic code is a valid C++ template, but not vice versa.</li>
<li>C++ can simulate Rust moves very easily (by doing an actual <code>memcpy</code> of data, and tracking the state of destruction in
a boolean flag) but Rust has difficulty with C++ moves. Specially, since Rust assumes that every type is
Rust-moveable, it can never store C++ objects by value, just over some indirection and <code>Pin</code>.</li>
</ul>
<p>So, Zngur allows you to use arbitrary Rust types in C++, store them by value in the C++ stack, and call arbitrary Rust methods and functions
on them. But it doesn&#39;t bridge any C++ type into Rust, since it is not possible with the same ergonomic. Instead, Zngur allows you to
write a rusty wrapper for your C++ library. It allows you to implement Rust traits for C++ types and cast them to
the <code>Box&lt;dyn Trait&gt;</code>, implement inherent methods on Rust types, implement Rust traits for Rust types, and expose bare functions
from C++ that operate on Rust types.</p>
<h2 id="demo"><a href="#demo">Demo</a></h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

#include &#34;./generated.h&#34;

// Rust values are available in the `::rust` namespace from their absolute path
// in Rust
template &lt;typename T&gt; using Vec = rust::std::vec::Vec&lt;T&gt;;
template &lt;typename T&gt; using Option = rust::std::option::Option&lt;T&gt;;
template &lt;typename T&gt; using BoxDyn = rust::Box&lt;rust::Dyn&lt;T&gt;&gt;;

// You can implement Rust traits for your classes
template &lt;typename T&gt;
class VectorIterator : public rust::std::iter::Iterator&lt;T&gt; {
  std::vector&lt;T&gt; vec;
  size_t pos;

public:
  VectorIterator(std::vector&lt;T&gt; &amp;&amp;v) : vec(v), pos(0) {}
  ~VectorIterator() {
    std::cout &lt;&lt; &#34;vector iterator has been destructed&#34; &lt;&lt; std::endl;
  }

  Option&lt;T&gt; next() override {
    if (pos &gt;= vec.size()) {
      return Option&lt;T&gt;::None();
    }
    T value = vec[pos++];
    // You can construct Rust enum with fields in C++
    return Option&lt;T&gt;::Some(value);
  }
};

int main() {
  // You can call Rust functions that return things by value, and store that
  // value in your stack.
  auto s = Vec&lt;int32_t&gt;::new_();
  s.push(2);
  Vec&lt;int32_t&gt;::push(s, 5);
  s.push(7);
  Vec&lt;int32_t&gt;::push(s, 3);
  // You can call Rust functions just like normal Rust.
  std::cout &lt;&lt; s.clone().into_iter().sum() &lt;&lt; std::endl;
  // You can catch Rust panics as C++ exceptions
  try {
    std::cout &lt;&lt; &#34;s[2] = &#34; &lt;&lt; *s.get(2).unwrap() &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;s[4] = &#34; &lt;&lt; *s.get(4).unwrap() &lt;&lt; std::endl;
  } catch (rust::Panic e) {
    std::cout &lt;&lt; &#34;Rust panic happened&#34; &lt;&lt; std::endl;
  }
  int state = 0;
  // You can convert a C++ lambda into a `Box&lt;dyn Fn&gt;` and friends.
  auto f = BoxDyn&lt;rust::Fn&lt;int32_t, int32_t&gt;&gt;::make_box([&amp;](int32_t x) {
    state += x;
    std::cout &lt;&lt; &#34;hello &#34; &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; state &lt;&lt; &#34;\n&#34;;
    return x * 2;
  });
  // And pass it to Rust functions that accept closures.
  auto x = s.into_iter().map(std::move(f)).sum();
  std::cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; state &lt;&lt; &#34;\n&#34;;
  std::vector&lt;int32_t&gt; vec{10, 20, 60};
  // You can convert a C++ type that implements `Trait` to a `Box&lt;dyn Trait&gt;`.
  // `make_box` is similar to the `make_unique`, it takes constructor arguments
  // and construct it inside the `Box` (instead of `unique_ptr`).
  auto vec_as_iter = BoxDyn&lt;rust::std::iter::Iterator&lt;int32_t&gt;&gt;::make_box&lt;
      VectorIterator&lt;int32_t&gt;&gt;(std::move(vec));
  // Then use it like a normal Rust value.
  auto t = vec_as_iter.collect();
  // Some utilities are also provided. For example, `zngur_dbg` is the
  // equivalent of `dbg!` macro.
  zngur_dbg(t);
}
</code></pre>
<p>Output:</p>
<pre><code>17
s[2] = 7
thread &#39;&lt;unnamed&gt;&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, examples/simple/src/generated.rs:186:39
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
s[4] = Rust panic happened
hello 2 2
hello 5 7
hello 7 14
hello 3 17
34 17
vector iterator has been destructed
[main.cpp:71] t = [
    10,
    20,
    60,
]
</code></pre>
<p>See the <a href="https://github.com/HKalbasi/zngur/blob/main/examples/simple"><code>examples/simple</code></a> if you want to build and run it.</p>

                    </main>

                    <nav aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next" href="https://hkalbasi.github.io/zngur/tutorial.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i></i>
                            </a>

                        
                    </nav>
                </div>
            </div>

            <nav aria-label="Page navigation">

                    <a rel="next" href="https://hkalbasi.github.io/zngur/tutorial.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i></i>
                    </a>
            </nav>

        </div>






        
        
        

        
        
        

        <!-- Custom JS scripts -->


    </div>
    

</div>
  </body>
</html>
