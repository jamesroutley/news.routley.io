<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/turbopape/scheje">Original</a>
    <h1>Scheme in Clojure</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="http://opensource.org/licenses/MIT" rel="nofollow"><img src="https://camo.githubusercontent.com/5fab2edf3816ef9fb3ebcaf6e613fa7b40ff7652ec69e5f6e7f695aa24bf5ce6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d626c75652e737667" alt="License MIT" data-canonical-src="https://img.shields.io/badge/License-MIT-blue.svg"/></a>
<a href="https://travis-ci.org/turbopape/scheje" rel="nofollow"><img src="https://camo.githubusercontent.com/a6cc19f74b2df47598c069f20134a147f736246aefa5ab0ea91c1f1c056aa4be/68747470733a2f2f7472617669732d63692e6f72672f747572626f706170652f736368656a652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/turbopape/scheje.svg?branch=master"/></a>
<a href="https://clojars.org/scheje" rel="nofollow"><img src="https://camo.githubusercontent.com/9e5560a9998f0abd6566e4b65d4f8741e6e58ceaf5059765759aadff989ee558/68747470733a2f2f696d672e736869656c64732e696f2f636c6f6a6172732f762f736368656a652e737667" alt="Clojars Project" data-canonical-src="https://img.shields.io/clojars/v/scheje.svg"/></a>
<a href="https://gratipay.com/scheje/" rel="nofollow"><img src="https://camo.githubusercontent.com/29fec679a7bf6e3f1191732fc9eb67937e11e30cfdf32a4091e3c642b0d7e72b/68747470733a2f2f696d672e736869656c64732e696f2f67726174697061792f7465616d2f736368656a652e737667" alt="Gratipay Team" data-canonical-src="https://img.shields.io/gratipay/team/scheje.svg"/></a>
<a href="https://scheje.slack.com" rel="nofollow"><img src="https://camo.githubusercontent.com/c4f967b3c5ee2d5dc82947d7df26dfcc4b89ae5ce331928f0e9c126e57d44a05/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636861742d2532332532307465616d2d79656c6c6f77677265656e2e737667" alt="Slack Team" data-canonical-src="https://img.shields.io/badge/chat-%23%20team-yellowgreen.svg"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/turbopape/scheje/blob/master/scheje-logo.jpg"><img src="https://github.com/turbopape/scheje/raw/master/scheje-logo.jpg" alt="Scheje Logo" title="The Scheje Logo"/></a></p>
<blockquote>
<p dir="auto">&#34;If you give someone Fortran, he has Fortran. If you give someone Lisp, he has any language he pleases.&#34;</p>
</blockquote>
<ul dir="auto">
<li>Guy L. Steele</li>
</ul>
<p dir="auto">Using the magnificent eval/apply dance (as in page 13 of the
Lisp 1.5 Manual), <em>scheje</em> is a tiny scheme implementation on Top of
Clojure.</p>
<p dir="auto"><em>Scheje</em> properly implements <em>define-syntax</em>, ellipsis is properly
expanded into relevant symbols, which can be respectively used in the
generated <em>syntax-rules</em> templates. In fact, even <em>let</em> is implemented in
terms of <em>define-syntax</em>.</p>
<p dir="auto">The two defining forms, <em>define</em> and <em>define-syntax</em> generate new
environments as per the bindings they introduce. Helper functions that
interpret these along with other evaluations will be discussed later.</p>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">You can play with scheje on-line with the <a href="http://turbopape.github.io/scheje/" rel="nofollow">Web REPL</a>.</p>
<p dir="auto">The main interpretation function is <em>form-eval</em> in the <em>interpreter</em>
namespace.</p>
<p dir="auto">You give it a form and an environment, and you get your evaluation:</p>
<div data-snippet-clipboard-copy-content="(form-eval &#39;(+ x y) &#39;{x 1 y 2})
;;=&gt; 3"><pre>(<span>form-eval</span> &#39;(+ x y) &#39;{x <span>1</span> y <span>2</span>})
<span><span>;</span>;=&gt; 3</span></pre></div>
<p dir="auto">The function <em>eval-prog</em>, evaluates a whole program. This function is
bootstrapped with a starting
environment, called the library (see <a href="https://github.com/turbopape/scheje/blob/master/src/scheje/library.cljc">library.cljc</a> for the contents of the library). When launched, eval-prog evaluates all the forms, only showing the value of the last one.</p>
<p dir="auto">Here are some examples:</p>
<div data-snippet-clipboard-copy-content="(eval-prog  &#39;((define-syntax let
                (syntax-rules ()
                              ((let ((var expr) ...) body ...)
                               ((lambda (var ...) body ...) expr ...))))
              (let ((x 1)(y 2)) (+ x y))))
;;=&gt;3"><pre>(<span>eval-prog</span>  &#39;((<span>define-syntax</span> <span>let</span>
                (<span>syntax-rules</span> ()
                              ((<span>let</span> ((<span>var</span> expr) ...) body ...)
                               ((<span>lambda</span> (<span>var</span> ...) body ...) expr ...))))
              (<span>let</span> ((<span>x</span> <span>1</span>)(<span>y</span> <span>2</span>)) (<span>+</span> x y))))
<span><span>;</span>;=&gt;3</span></pre></div>
<p dir="auto">This example shows what we did to introduce the let form, though it is
already implemented in the root environment used by scheje, so you
don&#39;t have to define it every time you use <em>eval-prog</em></p>
<p dir="auto">Analogous to <em>let</em>, here&#39;s how one can declare <em>and</em> using a recursive
<em>define-syntax</em>:</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;((define-syntax and
               (syntax-rules ()
                             ((and x) x)
                             ((and) true)
                             ((and x y ...) (if x (and y ...) false))))
             (and true true true  true true false)))
;;=&gt; false"><pre>(<span>eval-prog</span> &#39;((<span>define-syntax</span> <span>and</span>
               (<span>syntax-rules</span> ()
                             ((<span>and</span> x) x)
                             ((<span>and</span>) <span>true</span>)
                             ((<span>and</span> x y ...) (<span>if</span> x (<span>and</span> y ...) <span>false</span>))))
             (<span>and</span> <span>true</span> <span>true</span> <span>true</span>  <span>true</span> <span>true</span> <span>false</span>)))
<span><span>;</span>;=&gt; false</span></pre></div>
<p dir="auto">Same here, this is already defined in <em>root-env</em> so you don&#39;t have to
define it every time you use <em>eval-prog</em>. <em>or</em> is defined in the same
way:</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;((define-syntax or
               (syntax-rules ()
                             ((or x) x)
                             ((or) true)
                             ((or x y ...) (if x true (or y ...)))))
             (or false false false true false)))
;;=&gt; true"><pre>(<span>eval-prog</span> &#39;((<span>define-syntax</span> <span>or</span>
               (<span>syntax-rules</span> ()
                             ((<span>or</span> x) x)
                             ((<span>or</span>) <span>true</span>)
                             ((<span>or</span> x y ...) (<span>if</span> x <span>true</span> (<span>or</span> y ...)))))
             (<span>or</span> <span>false</span> <span>false</span> <span>false</span> <span>true</span> <span>false</span>)))
<span><span>;</span>;=&gt; true</span></pre></div>
<p dir="auto">Last but not least, here is the must-have <em>append</em> function, necessary for
every decent scheme implementation!</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;((define append
               (lambda (l1 l2)
                  (cond
                    ((null? l1) l2)
                    (else (cons (car l1) (append (cdr l1) l2))))))
             (append &#39;(1 2 3) &#39;(4 5 6))))
;;=&gt; &#39;(1 2 3 4 5 6)"><pre>(<span>eval-prog</span> &#39;((<span>define</span> <span>append</span>
               (<span>lambda</span> (<span>l1</span> l2)
                  (<span>cond</span>
                    ((<span>null?</span> l1) l2)
                    (<span>else</span> (<span>cons</span> (<span>car</span> l1) (<span>append</span> (<span>cdr</span> l1) l2))))))
             (<span>append</span> &#39;(<span>1</span> <span>2</span> <span>3</span>) &#39;(<span>4</span> <span>5</span> <span>6</span>))))
<span><span>;</span>;=&gt; &#39;(1 2 3 4 5 6)</span></pre></div>
<p dir="auto">Also, <em>quote</em>, <em>quasiquote</em>, <em>unquote</em> and <em>unquote-splicing</em> are
supported:</p>
<div data-snippet-clipboard-copy-content="(form-eval &#39;(quasiquote
             (1
              (+ 1 (unquote-splicing (cdr &#39;(1 2 3))))
              (unquote  (+ 1 a))))
           { &#39;a 5})
;;=&gt; (1 (+ 1 2 3) 6)"><pre>(<span>form-eval</span> &#39;(quasiquote
             (<span>1</span>
              (<span>+</span> <span>1</span> (<span>unquote-splicing</span> (<span>cdr</span> &#39;(<span>1</span> <span>2</span> <span>3</span>))))
              (<span>unquote</span>  (<span>+</span> <span>1</span> a))))
           { &#39;a <span>5</span>})
<span><span>;</span>;=&gt; (1 (+ 1 2 3) 6)</span></pre></div>
<p dir="auto">Also, named let, let*, and many more are available. Please refer to
the test files for the interpreter namespace to see possible uses.</p>
<h2 dir="auto"><a id="user-content-lexical-scoping-in-let-macros" aria-hidden="true" href="#lexical-scoping-in-let-macros"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lexical Scoping in <em>let</em> Macros</h2>
<p dir="auto">To prevent symbol capture when using the <em>let</em> macro, when expanded,
each <em>let</em> introduced expression&#39;s symbols are stored in its own
scope. This avoids name clash:</p>
<p dir="auto">In the following example, a is defined at the root-env, but &#34;inner&#34; a
is returned from the <em>let</em> macro:</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;((define a &#34;outer&#34;)
             (let ((x (and false false))
                   (a &#34;inner&#34;))
               (if x &#34;_&#34; a))))
;;=&gt; &#34;inner&#34;"><pre>(<span>eval-prog</span> &#39;((<span>define</span> <span>a</span> <span><span>&#34;</span>outer<span>&#34;</span></span>)
             (<span>let</span> ((<span>x</span> (<span>and</span> <span>false</span> <span>false</span>))
                   (<span>a</span> <span><span>&#34;</span>inner<span>&#34;</span></span>))
               (<span>if</span> x <span><span>&#34;</span>_<span>&#34;</span></span> a))))
<span><span>;</span>;=&gt; &#34;inner&#34;</span></pre></div>
<p dir="auto">If we access a symbol outside the macro, we get its root binding:</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;((define a &#34;outer&#34;)
             (let ((x (and false false))
                   (a &#34;inner&#34;))
               (if x &#34;_&#34; a))
             a))
;;=&gt; &#34;outer&#34;"><pre>(<span>eval-prog</span> &#39;((<span>define</span> <span>a</span> <span><span>&#34;</span>outer<span>&#34;</span></span>)
             (<span>let</span> ((<span>x</span> (<span>and</span> <span>false</span> <span>false</span>))
                   (<span>a</span> <span><span>&#34;</span>inner<span>&#34;</span></span>))
               (<span>if</span> x <span><span>&#34;</span>_<span>&#34;</span></span> a))
             a))
<span><span>;</span>;=&gt; &#34;outer&#34;</span></pre></div>
<h2 dir="auto"><a id="user-content-hygienic-macros" aria-hidden="true" href="#hygienic-macros"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hygienic Macros</h2>
<p dir="auto">Inspired by
<a href="http://web.cs.ucdavis.edu/~devanbu/teaching/260/kohlbecker.pdf" rel="nofollow">KFFD</a>
Algorithm. Now Scheje appends a timestamp with respect to the
iteration in which every form is being expanded, thus preventing it from
inadvertently capturing symbols across different expansion stages.
If some symbols have timestamps that cannot be evaluated, Scheje tries to
evaluate their &#34;root&#34; form, i.e, checks if their name, stripped out of the timestamps, isn&#39;t
bound in the execution environment. This &#39;sort of&#39; forces capture of such symbols,
as to see if they were intended to be passed as globals, for instance.</p>
<p dir="auto">For instance, these two examples work properly:</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;(
             (define-syntax or2
               (syntax-rules ()
                             ((or2 e1 e2) (let ((t e1)) (if t t e2) ))))
             (let ((t true)) (or2 false t ))))
;;=&gt; true"><pre>(<span>eval-prog</span> &#39;(
             (<span>define-syntax</span> <span>or2</span>
               (<span>syntax-rules</span> ()
                             ((<span>or2</span> e1 e2) (<span>let</span> ((<span>t</span> e1)) (<span>if</span> t t e2) ))))
             (<span>let</span> ((<span>t</span> <span>true</span>)) (<span>or2</span> <span>false</span> t ))))
<span><span>;</span>;=&gt; true</span></pre></div>
<p dir="auto">and</p>
<div data-snippet-clipboard-copy-content="(eval-prog &#39;(
             (let ((if (lambda(x y z) &#34;oops&#34;)))
              (let ((g false))
                    (if g g false)))))
;;=&gt; false"><pre>(<span>eval-prog</span> &#39;(
             (<span>let</span> ((<span>if</span> (<span>lambda(x</span> y z) <span><span>&#34;</span>oops<span>&#34;</span></span>)))
              (<span>let</span> ((<span>g</span> <span>false</span>))
                    (<span>if</span> g g <span>false</span>)))))
<span><span>;</span>;=&gt; false</span></pre></div>
<h3 dir="auto"><a id="user-content-clojurescript-support" aria-hidden="true" href="#clojurescript-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ClojureScript Support</h3>
<p dir="auto">Scheje is written using reader conditionals. The interpreter namespace
can be used in a clojurescript project right away, in the browser,
or in node.js if you want to use the file loading facilities.</p>
<h3 dir="auto"><a id="user-content-a-little-repl" aria-hidden="true" href="#a-little-repl"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A little REPL</h3>
<p dir="auto">Now a <strong>REPL</strong> namespace is shipped, exposing a little REPL permitting
to evaluating expressions and loading files.</p>
<p dir="auto">If you want to run it in Clojure/JVM, just clone the repo and launch</p>

<p dir="auto">You can also build a ClojureScript/Node.js REPL and enjoy the ultra fast startup compared to JVM&#39;s version. Simply
proceed like so:</p>
<div data-snippet-clipboard-copy-content="#install npm dependencies
npm install readline-sync
# then build the node app
lein cljsbuild once
# and enjoy scheje.js :)
node target/repl_out/scheje_repl.js"><pre><span><span>#</span>install npm dependencies</span>
npm install readline-sync
<span><span>#</span> then build the node app</span>
lein cljsbuild once
<span><span>#</span> and enjoy scheje.js :)</span>
node target/repl_out/scheje_repl.js</pre></div>
<h2 dir="auto"><a id="user-content-features" aria-hidden="true" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<p dir="auto">Please refer to the <a href="https://github.com/turbopape/scheje/blob/master/CHANGELOG.md">Changelog</a> and the <a href="https://github.com/turbopape/scheje/blob/master/test/scheje/interpreter_test.clj">interpreter_test.clj test file</a> to get a comprehensive list of the features and usage of <em>scheje</em>.</p>
<h2 dir="auto"><a id="user-content-contributors" aria-hidden="true" href="#contributors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributors</h2>
<p dir="auto">Thanks to these wonderful people who helped the development of Scheje:</p>
<ul dir="auto">
<li><a href="https://github.com/balajirrao">balajirrao</a></li>
</ul>
<p dir="auto">And to these awesome proof-readers:</p>
<ul dir="auto">
<li><a href="https://github.com/jaredestroud">jaredestroud</a></li>
<li><a href="https://github.com/yurimalheiros">yurimalheiros</a></li>
<li><a href="https://github.com/chasingSublimity">chasingSublimity</a></li>
<li><a href="https://github.com/rom1504">rom1504</a></li>
</ul>
<p dir="auto">Special thanks for the awesome logo go to:</p>
<ul dir="auto">
<li><a href="https://github.com/morachimo">morachimo</a></li>
</ul>
<h2 dir="auto"><a id="user-content-todos---wanna-contribute" aria-hidden="true" href="#todos---wanna-contribute"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TODOS - Wanna Contribute?</h2>
<p dir="auto">You can see how you can help by seeing the <a href="https://github.com/turbopape/scheje/issues">open issues</a></p>
<p dir="auto">Please note that this project is released with a <a href="https://github.com/turbopape/scheje/blob/master/CODE_OF_CONDUCT.md">Contributor Code of
Conduct.</a> By participating in this project you agree to abide by its
terms.</p>
<h2 dir="auto"><a id="user-content-credits" aria-hidden="true" href="#credits"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Credits</h2>
<p dir="auto">Scheje&#39;s Node.js REPL uses <a href="https://github.com/anseki/readline-sync">readLineSync</a> from @anseki, which is licensed under the MIT License.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Copyright © 2016 Rafik Naccache and Contributors.
Distributed under the terms of the MIT License.</p>
</article>
          </div></div>
  </body>
</html>
