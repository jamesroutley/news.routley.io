<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://morepablo.com/2022/09/so-you-re-using-a-weird-language.html">Original</a>
    <h1>So you&#39;re using a weird language</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <article>
        <header>
          
          <p>Tuesday, September 13, 2022 :: Tagged under: <a href="https://www.wildlondon.org.uk/tags/engineering.html">engineering</a>. ‚è∞ 10 minutes.</p>
          </header>
            
        <p><small>üéµ <em>The song for this post is <a href="https://www.youtube.com/watch?v=bt6RYf5ocfo">I, Don Quixote</a> from the musical <em>Man of La Mancha</em>, composed by Mitch Leigh and Joe Darion.</em> üéµ</small></p>
<div>
<p><img src="https://www.wildlondon.org.uk/img/2022/9/factor_help_THUMB.png" alt="Screenshot of the Factor help screen, next to its REPL."/></p><p>This is <a href="https://factorcode.org/">Factor</a>. IME you spend a lot more time on the window on the right than the one on the left.
<strong>Use the docs.</strong></p>
</div>
<p>Looking through <a href="https://discuss.ocaml.org/t/ocaml-at-first-glance/10396/8">Bozhidar Batsov notate his first impressions of OCaml</a> and
<a href="https://discuss.ocaml.org/t/whats-your-development-workflow/10358">him previously asking its users about their workflows</a> after finding its
REPL/interactivity story more limited than Clojure, I realised I have some
experience with the statement &#34;I&#39;m gonna write a program using a weird
language,&#34; I thought I&#39;d write a few narratives and strategies.</p>
<p>For context: programming languages was where I first went from computing being
a thing you could <em>do</em> to something you could <em>love.</em> When I stretched my
brain and rewrote a program from C++ into Scheme, I saw one class of bugs
disappear and a different class of them manifest (to say nothing of
performance changes, extensibility‚Ä¶). I also read <a href="http://www.paulgraham.com/avg.html">Beating the Averages</a> and
thought I could find that Special Language that would make programming feel as
natural as acting did (spoiler, <a href="https://xkcd.com/568/">it didn&#39;t,</a> but it was about the journey, man).</p>
<p>Examples of this skill are me doing Advent of Code twice with a different
language every day (<a href="https://github.com/pablo-meier/advent-of-code">2016</a>, <a href="https://git.sr.ht/~srpablo/advent_of_code_2021">2021</a>), writing <a href="https://github.com/pablo-meier/ghostlight">a web app in Erlang,</a>
a static site generator in OCaml (which powers this blog), a Scrabble solver in
<a href="https://git.sr.ht/~srpablo/ScrabbleCheat/tree/master/item/code/server/lib/bingad">C,</a> <a href="https://git.sr.ht/~srpablo/ScrabbleCheat/tree/master/item/code/server">Erlang,</a> and <a href="https://git.sr.ht/~srpablo/ScrabbleCheat/tree/master/item/code/clients/curses">Ruby,</a> <a href="https://github.com/pablo-meier/Ebooker">a Markov Twitter bot server in Go,</a>
and frankly too many shell and toy repos that I didn&#39;t bother to push up or list
here.</p>
<p>Anyway, if you want to try something new, here are some thoughts I&#39;ve got after
doing this for over a decade.</p>
<h2>First ‚Äî set clear intentions, be aware of limitations</h2>
<p><a href="https://www.wildlondon.org.uk/2013/11/blogging-solutions.html">When I gave suggestions on blogging software</a> nearly a decade ago, I said:</p>
<blockquote>
<p><a href="http://programmingisterrible.com/">tef</a> is one of many programmers to make
the observation that if a problem is 90% social and 10% technical, programmers
will spend most of their time trying to solve the technical portion of it.</p>
<p>Similarly, everything I&#39;m going to say doesn&#39;t change the fact that the core
challenge of blogging is writing consistently. At the end of the day, none of
what follows matters if you don&#39;t want to write something from time to time,
actually go on to write it, and stick with it. If you don&#39;t or won&#39;t enjoy
writing for what it is, none of the features of the products below will change
that.</p>
<p>Many of my friends have aspired to be novelists or screenwriters and formed
strong opinions on MS Word vs.
<a href="https://www.literatureandlatte.com/scrivener/overview">Scrivener</a> vs.
<a href="https://www.celtx.com/">CeltX</a> vs. <a href="https://www.finaldraft.com/">Final Draft</a>
vs. <a href="https://www.hogbaysoftware.com/products/writeroom/">WriteRoom,</a> but at
the end of the day, they didn&#39;t actually‚Ä¶ write much.</p>
</blockquote>
<p>Before you embark on your Project In A Weird Language, ask yourself:</p>
<ul>
<li>
<p>How much do I need this to actually ship or finish?</p>
</li>
<li>
<p>Am I sharing this codebase with others who aren&#39;t weird language perverts like
me, and just want to build/ship a thing?</p>
</li>
</ul>
<p>If the answers to those are &#34;a lot&#34; and &#34;yes,&#34; I strongly encourage you to pick
Java (or Python, or Ruby, or JavaScript‚Ä¶). It&#39;ll take a lot of emotional weight
off the project.</p>
<p>I&#39;m the last person on Earth to tell someone to be patient, but if you actually
want to ship a <em>company&#39;s</em> production code in <a href="https://gleam.run/">Gleam</a> or
<a href="https://crystal-lang.org/">Crystal,</a> I highly suggest you put up 2-4 small
projects first (the Elixir project <a href="https://engineering.ramp.com/elixir-at-ramp">I introduced at
Ramp</a> was my 3rd one, not including
my 4 major Erlang projects. Also, at this point, Elixir less weird than, like,
Scala or Clojure IMO). That&#39;ll give you some sense of what playing this game
<em>actually</em> looks like.</p>
<h2>Now, the strategies</h2>
<p>Okay, you&#39;re good? Psychologically comfortable? Ready to play? Here are some
thoughts.</p>
<h3>Browse less, search more</h3>
<p>This is a Hillel Wayne phrase, which <a href="https://buttondown.email/hillelwayne/archive/search-less-browse-more-7595/">he writes about here.</a> <em>Most common
langs have everything on Google and StackOverflow, most weird langs <strong>don&#39;t</strong>.</em>
Common questions won&#39;t have answers for you in byte-sized, copyable chunks.</p>
<p>However: almost every language has at least one hermit crazy enough to write
deep, extensive docs on it. <em>Read docs sequentially</em>. Take your time. Put on a
pot of coffee and spend an hour before getting right to the hacking. It feels
slower, but it&#39;s actually a more efficient use of your time.</p>
<p>Often this is <em>in the tool itself</em>: Factor, with a built-in Help browser. Or
Pharo, the same. Vim&#39;s documentation is <em>fabulous</em>, and nobody reads it.</p>
<p>Sometimes it&#39;s a great book! Deliberate reading of chapters from <a href="https://dev.realworldocaml.org/toc.html">Real World
OCaml</a> or <a href="https://learnyousomeerlang.com/content">Learn You Some Erlang</a> will do a lot more for you than trying
to search for something fast.</p>
<div>
<p><img src="https://www.wildlondon.org.uk/img/2022/9/pharo_help_THUMB.png" alt="Screenshot of Pharo with the mouse over the tutorial."/></p><p>Here&#39;s Pharo
now. <strong>Use the docs</strong>.</p>
</div>
<h3>Tolerance for weird errors</h3>
<p>Note if you&#39;re going into more weird languages, you&#39;ll run into types of errors
you almost certainly won&#39;t hit in the popular ones.</p>
<p>You&#39;ll get opaque error messages,
<em>especially</em> if the language has invariants that aren&#39;t common in other
environments (Rust&#39;s ownership checker is probably the most common example of
&#34;no analogue in a more common language,&#34; but this can also mean
<a href="https://www.mercurylang.org/information/doc-latest/mercury_ref/Determinism.html#Determinism-categories">Mercury&#39;s determinism
checks</a>,
or <a href="https://tutorial.ponylang.io/reference-capabilities/guarantees.html#rights-are-part-of-a-capability">Pony&#39;s &#34;reference
guarantees&#34;</a>).
To be clear: <em>these parts are exactly why learning a new language is fun!</em> This
is what it costs to reap the reward of Perlis langauges (a language that changes
how you think, from the quote: &#34;A language that doesn‚Äôt affect the way you think
about programming is not worth knowing.&#34;)</p>
<p>Additionally: you&#39;ll see segfaults from their compilers. You&#39;ll get errors as
stack traces in the interpreter&#39;s language (tef: &#34;DSLs are when you write code
in one language and debug in another&#34;). Your common tool of Googling the issue
<em>won&#39;t work for you here,</em> don&#39;t be afraid when you see them, have some more of
that coffee, dig into the source.</p>
<h3>Look for the forums, ask questions</h3>
<p>A large plurality of programmers learned most of what they know in isolation,
and so don&#39;t view programming as a very social activity (guilty). That said, you
can get much farther, much faster, if you leverage communities. <a href="https://discuss.ocaml.org/">OCaml has a
great Discourse instance</a> and <a href="https://discuss.ocaml.org/t/ocaml-discord-server/1884">Discord server</a>, Elixir&#39;s got
<a href="https://elixirforum.com/">ElixirForum</a>.</p>
<p>IMO, community is one place where Weird Langs <em>outperform</em> Big Langs. While there&#39;s
no shortage of resources and communities for Python or Java or JavaScript
programmers, it hardly feels cohesive; when people talk about &#34;the OCaml
community&#34; they really do mean something a lot more singular. Folks at
ElixirConf come back energized because you feel like you&#39;re part of a single
greater thing instead of a fish in a school of thousands.</p>
<p>Combined with browsing, you&#39;ll also learn some norms of the language and how its
community makes decisions. An example of this is Elm: for many people, this is
either their favorite <em>or least</em> favorite thing about the language.</p>
<h3>More than &#34;typing source&#34; ‚Äî build the workflow, a project</h3>
<p>I go over this in <a href="https://www.wildlondon.org.uk/2020/03/layton-tools-air-pollution.html">this post</a> (and IMO this is great to do even in common
langs): while you can start with &#34;open text editor, write hello world, run&#34;,
if your project has any life besides an Advent of Code problem, it&#39;s really
worth the hours (yes, <em>hours</em>) to set up a Makefile (or whatever that language&#39;s
build tool) that does some of the following:</p>
<ul>
<li>Builds incrementally</li>
<li>Run tests</li>
<li>Triggers a deploy, if applicable</li>
<li>Run typechecks (if using a language with a bolted-on typechecker, like
dialyzer, mypy, sorbet‚Ä¶)</li>
<li>Clean directory of build artifacts</li>
<li>Opens or reloads an interactive shell with the definitions loaded</li>
<li>Runs a formatter</li>
</ul>
<p>Additionally:</p>
<ul>
<li>Pick someone&#39;s project/directory structure if the language doesn&#39;t do this for
you already</li>
<li>Practice adding/removing external dependencies until you can do it easily</li>
<li>Practice cloning the project from scratch and being able to repro it with
minimal hassle</li>
</ul>
<p>And set up your IDE or text editor:</p>
<ul>
<li>Connect to a language server to find bugs while you type.</li>
<li>Autocomplete</li>
<li>Snippets if there&#39;s boilerplate in the language (e.g. <code>gen_server</code> modules, or
a shortcut for <code>if err != nil { return err }</code> for Go).</li>
<li>Practice using &#34;Jump to Definition/Jump to Declaration&#34;</li>
<li>Practice &#34;Find usages&#34;</li>
<li>Practice a safe rename/delete</li>
</ul>
<p>Now, <em>all of this may not be available for your Weird Language.</em> Part of the
agony and ecstasy of writing, idk, <a href="https://www.raku.org/">Raku</a> is realizing
how little of this is discovered or available. Still, most languages have at
least one weird nerd who has a vim plugin that&#39;s worth trying. Else, if you fall
in love, you can be that weird nerd!</p>
<h3>Culture of &#34;idk run it&#34; vs. &#34;It&#39;s just a monoid in the category of endofunctors, what&#39;s the problem?&#34;‚Ä¶</h3>
<p>This one&#39;s a little harder to articulate, but ‚Äî note that a lot of language
communities have very different cultures on what &#34;a good workflow&#34; is, or what
&#34;sufficient information&#34; looks like, try to detect it, and go with the grain
rather than against it.</p>
<p>Per the first, look at <a href="https://discuss.ocaml.org/t/whats-your-development-workflow/10358">the thread I linked at the top here of a Clojureist
trying OCaml</a>. Like the old joke &#34;you can program C in any language,&#34; if you
insist on a Clojure-like REPL experience in OCaml, you&#39;re gonna have a bad time.
The biggest shift for me when I moved from Java/C++ codebases to Python ones
professionally was was how much harder I had to test my code, since it was so
easy to ship code that &#34;looks right&#34; but barfs on a weird input. In Python, no
assumption is too small to be invalidated by weird shit happening at runtime. In
other languages, you can have <em>some</em> assurances that Up will be Up and Down will
be Down. This used to bother me and I got frustrated, now I just roll with it.
&#34;That&#39;s how Python does it,&#34; accept it and move on.</p>
<p>For my tastes, Python&#39;s libraries and documentation <em>do not</em> make up for this.
An example: look at the docs of the Python requests library and try to
answer the question &#34;where can I get the hostname of the URL of the response?&#34;
On one hand, request&#39;s docs make firing requests very easy: <a href="https://requests.readthedocs.io/en/latest/">the frontpage</a> has an
example you can copy, and the <a href="https://requests.readthedocs.io/en/latest/user/quickstart/">Quickstart</a> has a few more examples. But what
does the <a href="https://requests.readthedocs.io/en/latest/api/#requests.Response">Response object have?</a> Well you get a bunch of named fields, but no
insight into what the structure of those named fields are. What <em>exactly</em>
does <code>raw</code> return when it says &#34;file-like object&#34;, and what are <em>its</em>
properties? <code>next</code> returns a PreparedRequest, but the doc doesn&#39;t link to its
definitions. The <code>url</code> field, is that an object, or a string? Is it easy to get
the hostname from it? Does Response have a constructor or a factory if we need
to mock it, or make one manually? I don&#39;t see one.</p>
<p>In Python, these are <em>good docs</em>. In Java, you can Javadoc any codebase and get
richer, more actionable information. But it&#39;s just how these communities roll;
roll with it.</p>
<p>But at least it&#39;s easy to get started! Let&#39;s contrast this with &#34;I want to use
Unicode&#34; in OCaml (idk, emoji support). If you&#39;ve familiarized yourself with
<code>opam</code> (this‚Ä¶ is not easy) you can run <code>opam search unicode</code> and get this list
of options. Which do you install, and how do you use them?</p>
<pre><code>uucd              --          Unicode character database decoder for OCaml
uucp              --          Unicode character properties for OCaml
uunf              --          Unicode text normalization for OCaml
uuseg             --          Unicode text segmentation for OCaml
uutf              1.0.3       Non-blocking streaming Unicode codec for OCaml
uuuu              --          Mapper of ISO-8859-* to Unicode
</code></pre>
<p>Clear as day, right?! But this is how OCaml rolls. The <a href="https://discuss.ocaml.org/t/ocaml-at-first-glance/10396/12">author of many of those
libraries wants you to know &#34;it&#39;s simple, actually,&#34;</a> and links <a href="https://www.reddit.com/r/ocaml/comments/lqijgb/comment/goh75ob/?utm_source=share&amp;utm_medium=web2x&amp;context=3">this Reddit
comment:</a></p>
<blockquote>
<p>Decoding utf-8 encoded strings can be done with
<a href="https://erratique.ch/software/uutf">uutf.</a> If you need to segment
unicode text, you can use <a href="https://erratique.ch/software/uuseg">uuseg</a>. If you
need to normalize it, there is <a href="https://erratique.ch/software/uunf">uunf</a>. If
you need to inspect unicode properties (or uppercase or lowercase unicode
texts) there is <a href="https://erratique.ch/software/uucp">uucp</a>.</p>
</blockquote>
<p>Now I dare you to open all those pages in a new tab and click the Documentation
link in them. Do you feel ready to add Unicode to your project <em>this week</em>?
While I&#39;m sure this is a Very Smart And Correct way to break all this down and
that if I brewed several pots of coffee and read many, many docs, I&#39;d be on my
way.</p>
<p>And I will. Because that&#39;s just how this game is played in OCaml. Part of the
joy of this game if finding shit like this. Roll with it!</p>
<div>
<p><img src="https://www.wildlondon.org.uk/img/2022/9/racket_help_THUMB.png" alt="Screenshot of Racket REPL with the docs open on the right."/></p><p>Racket opens
it in a proper web browser, but note the URL: it&#39;s still local, serial, and
delicious. <strong>Read the docs.</strong></p>
</div>
<h3>‚Ä¶but ignore the language&#39;s culture wars.</h3>
<p>Pay attention to community, but when it slows you down, just do whatever you
want, man. If this is your 3rd or 4th major project in that language, then yes,
consider forming Hard Opinions on whatever their culture war is. But until then,
don&#39;t let Fun Narrative distract you from writing the program.</p>
<p>Examples:</p>
<ul>
<li>
<p>Haskellers will tell you not to use default Strings (or the default Prelude),
and/or any combination of their favorite language extensions. They&#39;re all
quite compelling, but just use strings if you want.</p>
</li>
<li>
<p>Scala had something of a holy war over
<a href="https://github.com/scalaz/scalaz">scalaz</a> vs.
<a href="https://typelevel.org/cats/">cats</a>. Honestly just ignore Scala entirely if
you don&#39;t like mess, but if you have to, pick cats and go on with your life.</p>
</li>
<li>
<p>OCaml has a split on how to do asynchronicity:
<a href="https://github.com/ocsigen/lwt">Lwt</a> or
<a href="https://opensource.janestreet.com/async/">Async</a>. Pick one, who
cares.</p>
</li>
<li>
<p>Elixir has several HTTP libraries:
<a href="https://hexdocs.pm/httpoison/HTTPoison.html">HTTPoison</a>,
<a href="https://github.com/elixir-tesla/tesla">Tesla</a>,
<a href="https://github.com/elixir-mint/mint">Mint</a>,
<a href="https://hexdocs.pm/finch/Finch.html">Finch</a>,
<a href="https://hexdocs.pm/mojito/Mojito.html">Mojito</a>,
<a href="https://github.com/benoitc/hackney">hackney</a>. Pick one, you&#39;re on the BEAM,
you&#39;ll be fine.</p>
</li>
</ul>
<h3>Get it in your fingers, suffer the little stuff</h3>
<p>In the spirit of &#34;do things that don&#39;t scale,&#34; don&#39;t be afraid to do <em>extremely
micro projects</em> (echo server) or toy programs that are absolutely, truly
useless. <a href="https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/">99 Problems</a>. <a href="https://adventofcode.com/">Advent of Code</a>, <a href="https://leetcode.com/">Leetcode</a>, <a href="https://projecteuler.net/">Project
Euler</a>‚Ä¶ none of these are anything but amusing, but a good way to get your
feet wet at the smallest level of granularity. Real Programs can come later.</p>
<h3>Awesome lists, koans, howistart</h3>
<p>Okay, that&#39;s all cute narrative. Here are some <em>actually practical tips</em>:</p>
<ul>
<li>
<p>Almost every language has an &#34;Awesome [x]&#34; repo that contains a ton of links
for popular libraries for all sorts of things. They fall out of date, but
they&#39;re often a great place to go for, like, a calendar library or image
processing. Here&#39;s an <a href="https://github.com/uhub/awesome-erlang">Awesome
Erlang</a>, for example.</p>
</li>
<li>
<p>Many language have &#34;koan&#34; or &#34;kata&#34; repos with exercises and Makefiles that
teach the various constructs gently. It&#39;s a great way to exercise the various
features of the language more interactively. Here&#39;s one I used for
<a href="https://github.com/cdarwin/go-koans">Go</a> several years ago, I&#39;m not sure if
it still works.</p>
</li>
<li>
<p><a href="https://rosettacode.org/wiki/Rosetta_Code">Rosetta Code</a> is a cute resource: it&#39;s got listing for how to do common
operations in all sorts of languages. Especially cool for things like Advent
of Code when you&#39;re like &#34;I just want to read a file.&#34; At the very least, you
can see examples of the language you&#39;re using.</p>
</li>
<li>
<p>While I think it&#39;s not really up-to-date anymore, <a href="https://howistart.org/">howistart</a> was a great
project, has old examples from previous languages and ecosystems, and is a
good way to think about how you want to think of how <em>you</em> start. I&#39;ve got a
little checklist for OCaml projects now.</p>
</li>
</ul>

        

        <section>
          <p><strong>Thanks for the read!</strong> Disagreed? <em>Violent agreement!?</em> Feel free to drop me a line at <span></span>, or leave a comment below! I&#39;d love to hear from you üòÑ</p>
          <!-- Obfuscate for 2006-era scrapers -->
          

          
          
        </section>
      </article>

    </div></div>
  </body>
</html>
