<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackdiary.com/heap-buffer-overflow-in-libwebp-cve-2023-5129/">Original</a>
    <h1>Google assigns a CVE for libwebp and gives it a 10.0 score</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
							
<p>In case you missed the news, there&#39;s a critical 0day in WebP (a heap buffer overflow in the <a href="https://github.com/webmproject/libwebp" target="_blank" rel="noreferrer noopener">libwepb</a> library) floating about, which was initially issued as <a href="https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/" target="_blank" rel="noreferrer noopener">CVE-2023-4863</a> and assigned <a href="https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html" target="_blank" rel="noreferrer noopener">specifically to Google Chrome</a>. At the time this happened, I wrote my blog post about it and vehemently tried to make it clear that it wasn&#39;t just Chrome that was affected, but any software that uses libwebp to render WebP images.</p>



<p><em>That story exploded. ðŸ¤¯</em></p>



<p>I&#39;ve just taken note that Google has issued a separate CVE, which is tracked under <a href="https://www.cve.org/CVERecord?id=CVE-2023-5129" target="_blank" rel="noreferrer noopener nofollow">CVE-2023-5129</a>,</p>



<p>With a specially crafted WebP lossless file, libwebp may write data out of bounds to the heap. The ReadHuffmanCodes() function allocates the HuffmanCode buffer with a size that comes from an array of precomputed sizes: kTableSize. The color_cache_bits value defines which size to use. The kTableSize array only takes into account sizes for 8-bit first-level table lookups but not second-level table lookups. libwebp allows codes that are up to 15-bit (MAX_ALLOWED_CODE_LENGTH). When BuildHuffmanTable() attempts to fill the second-level tables it may write data out-of-bounds. The OOB write to the undersized array happens in ReplicateValue.</p>



<p><em><strong>Important:</strong> If you&#39;re a news person or someone who isn&#39;t sure - this is not a new bug in libwebp; it&#39;s the same bug as previously, but now it has been correctly marked as a bug inside the WebP Codec and not just a &#34;bug inside Google Chrome&#34;.</em></p>



<p>And Google is not beating around the bush either; they&#39;ve straight up given it a 10.0 base score.</p>



<figure><img decoding="async" width="998" height="393" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20998%20393&#39;%3E%3C/svg%3E" alt="CVE-2023-5129 severity" data-lazy-srcset="https://stackdiary.com/wp-content/uploads/2023/09/CVE-2023-5129-severity.png 998w, https://stackdiary.com/wp-content/uploads/2023/09/CVE-2023-5129-severity-300x118.png 300w, https://stackdiary.com/wp-content/uploads/2023/09/CVE-2023-5129-severity-768x302.png 768w" data-lazy-sizes="(max-width: 998px) 100vw, 998px" data-lazy-src="https://stackdiary.com/wp-content/uploads/2023/09/CVE-2023-5129-severity.png"/><figcaption><em>The Impact score is 6.0, and the Exploitability score is 3.9.</em></figcaption></figure>



<p>And it&#39;s what they should have done in the first place.</p>



<h2>Who is and isn&#39;t affected?</h2>



<p>The versions affected by this bug are <strong>from 0.5.0 before 1.3.2</strong>. The type of software affected is pretty much any software that directly uses the WebP Codec to render images. Just in the last two weeks alone, outside of web browsers (most of which should be patched now) - I have seen Red Hat to Debian to software like Puppeteer and the .NET library for ImageMagick patching it. Honestly, I have no idea of the full scope of this, and it&#39;s not that easy to track who is or isn&#39;t actively patching it.</p>



<p>Ben Hawkes (former Project Zero manager) also <a href="https://blog.isosceles.com/the-webp-0day/" target="_blank" rel="noreferrer noopener">wrote about this 0day</a>, and he had this to say about it:</p>



<p>The bad news is that Android is still likely affected. Similar to Apple&#39;s ImageIO, Android has a facility called theÂ <a href="https://developer.android.com/reference/android/graphics/BitmapFactory?ref=blog.isosceles.com">BitmapFactory</a>Â that handles image decoding, and of course libwebp is supported. As of today, Android hasn&#39;t released a security bulletin that includes a fix for CVE-2023-4863 -- although the fix has been merged into AOSP. To put this in context: if this bug does affect Android, then it could potentially be turned into a remote exploit for apps like Signal and WhatsApp. I&#39;d expect it to be fixed in the October bulletin.</p>



<p>Ben&#39;s article also has a Proof of Concept example and other interesting notes; make sure to check it out.</p>



<p>But the real question is, why didn&#39;t Google tag it specifically for libwebp in the first place? I mean, it clearly was much broader than just Chrome (and many news editorials failed to pick this up initially), and now they&#39;ve gone ahead and assigned a separate CVE. </p>



<p>And it makes me wonder if the best thing wouldn&#39;t be to merge both CVEs to avoid any further confusion.</p>
							</div></div>
  </body>
</html>
