<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jesseduffield.com/Type-Keys/">Original</a>
    <h1>Code Smell of the Day: Type Keys (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em>Note: On the back of some feedback I’ve created a <a href="https://jesseduffield.com/Type-Keys-Revisited">follow-up</a> of this post where I refine the thesis. I’ve left this post as-is for the sake of comparison</em></p>

<p>Say we have a function which creates a user, and handles some specific setup depending on whether that user is an admin or a customer:</p>

<div><div><pre><code><span>const</span> <span>createUser</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>,</span> <span>userType</span><span>:</span> <span>&#39;</span><span>admin</span><span>&#39;</span> <span>|</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>)</span>

  <span>switch</span> <span>(</span><span>userType</span><span>)</span> <span>{</span>
    <span>case</span> <span>&#39;</span><span>admin</span><span>&#39;</span><span>:</span>
      <span>setupAdmin</span><span>(</span><span>user</span><span>)</span>
    <span>case</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>:</span>
      <span>setupCustomer</span><span>(</span><span>user</span><span>)</span>
  <span>}</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>()</span>

  <span>return</span> <span>user</span>
<span>}</span>

<span>...</span>
<span>// in some other file</span>
<span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createUser</span><span>(</span><span>attributes</span><span>,</span> <span>&#39;</span><span>admin</span><span>&#39;</span><span>)</span>
<span>}</span>

<span>...</span>
<span>// in yet another file</span>
<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createUser</span><span>(</span><span>attributes</span><span>,</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>What do you notice about the <code>userType</code> argument? There are four things to note:</p>

<ol>
  <li>its value is always known at compile time. We’re not receiving it as an parameter from an HTTP request or a value from the database.</li>
  <li>its expected to have one of a finite set of values i.e. it’s basically an enum.</li>
  <li>given that it’s basically an enum, its actual value is meaningless: it will never be written anywhere or compared to another variable’s value</li>
  <li>inside the function, the argument is only used in a switch-statement (if-statements count too) i.e. the value only affects the control flow of the function</li>
</ol>

<p>When you have these four ingredients, you have a type key. Not ‘type’ as in static vs dynamic typing, but ‘type’ as in variant. It’s called a type key because it suggests that your function really has different variants and you want to key-in to a specific variant to get the behaviour you want.</p>

<p>This is an code smell because the only time you have different types is to satisfy different use cases, and different use cases always change at different rates. Maybe the setup process for admins hasn’t changed in a year but the process for customers changes monthly. Whenever two pieces of code need to change for different reasons, or at different rates, you <em>must</em> separate those pieces and minimise the dependencies between them. Otherwise, in order to understand how a customer is created, you need to wade through a bunch of irrelevant admin-related code, making any single use case impossible to understand without understanding all the others.</p>

<p>Let’s refactor this into something cleaner:</p>

<h2 id="step-1">Step 1</h2>

<p>Split the function and pull the type key argument into the function as a constant</p>

<div><div><pre><code><span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>userType</span> <span>=</span> <span>&#39;</span><span>admin</span><span>&#39;</span><span>;</span>

  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>

  <span>switch</span> <span>(</span><span>userType</span><span>)</span> <span>{</span>
    <span>case</span> <span>&#39;</span><span>admin</span><span>&#39;</span><span>:</span>
      <span>setupAdmin</span><span>(</span><span>user</span><span>);</span>
    <span>case</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>:</span>
      <span>setupCustomer</span><span>(</span><span>user</span><span>);</span> <span>// this code path is never reached</span>
  <span>}</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>

<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>userType</span> <span>=</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>;</span>

  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>

  <span>switch</span> <span>(</span><span>userType</span><span>)</span> <span>{</span>
    <span>case</span> <span>&#39;</span><span>admin</span><span>&#39;</span><span>:</span>
      <span>setupAdmin</span><span>(</span><span>user</span><span>);</span> <span>// this code path is never reached</span>
    <span>case</span> <span>&#39;</span><span>customer</span><span>&#39;</span><span>:</span>
      <span>setupCustomer</span><span>(</span><span>user</span><span>);</span>
  <span>}</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h2 id="step-2">Step 2</h2>

<p>Clean up, removing any dead code paths</p>

<div><div><pre><code><span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>

  <span>setupAdmin</span><span>(</span><span>user</span><span>);</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>

<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>

  <span>setupCustomer</span><span>(</span><span>user</span><span>);</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h2 id="step-3">Step 3</h2>

<p>Factor out any remaining overlapping code.</p>

<h3 id="when-order-doesnt-matter">When Order Doesn’t Matter</h3>

<p>You may find that certain operations are completely independent meaning you can shuffle the order of function calls. Let’s say that in this case <code>setupNotifications()</code> can be called before <code>setupAdmin(user)</code> and <code>setupCustomer(user)</code>. Then we can group those together:</p>

<div><div><pre><code><span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>
  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>setupAdmin</span><span>(</span><span>user</span><span>);</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>

<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>
  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>setupCustomer</span><span>(</span><span>user</span><span>);</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>And then factor out:</p>

<div><div><pre><code><span>// this function could be inlined if desired</span>
<span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>createUserWithNotifications</span><span>(</span><span>attributes</span><span>);</span>

  <span>setupAdmin</span><span>(</span><span>user</span><span>);</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>

<span>// this function could be inlined if desired</span>
<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>createUserWithNotifications</span><span>(</span><span>attributes</span><span>);</span>

  <span>setupCustomer</span><span>(</span><span>user</span><span>);</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>

<span>const</span> <span>createUserWithNotifications</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>
  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<h3 id="when-order-does-matter">When Order Does Matter</h3>

<p>If the order <em>was</em> important, we could pass the in-between code as a callback:</p>

<div><div><pre><code><span>// this function could be inlined if desired</span>
<span>const</span> <span>createAdmin</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createUser</span><span>(</span><span>attributes</span><span>,</span> <span>setupAdmin</span><span>);</span>
<span>};</span>

<span>// this function could be inlined if desired</span>
<span>const</span> <span>createCustomer</span> <span>=</span> <span>(</span><span>attributes</span><span>:</span> <span>UserAttributes</span><span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createUser</span><span>(</span><span>attributes</span><span>,</span> <span>setupCustomer</span><span>);</span>
<span>};</span>

<span>const</span> <span>createUser</span> <span>=</span> <span>(</span>
  <span>attributes</span><span>:</span> <span>UserAttributes</span><span>,</span>
  <span>onCreate</span><span>:</span> <span>(</span><span>user</span><span>:</span> <span>User</span><span>)</span> <span>=&gt;</span> <span>void</span>
<span>):</span> <span>User</span> <span>=&gt;</span> <span>{</span>
  <span>user</span> <span>=</span> <span>User</span><span>.</span><span>create</span><span>(</span><span>attributes</span><span>);</span>

  <span>onCreate</span><span>(</span><span>user</span><span>);</span>

  <span>user</span><span>.</span><span>setupNotifications</span><span>();</span>

  <span>return</span> <span>user</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>And we’re done! We could go one step further by currying the result but for all intents and purposes this is pretty clean.</p>

<h2 id="why-is-this-solution-better">Why Is This Solution Better?</h2>

<p>Our type key has magically disappeared and we no longer need to maintain it anymore. But that’s not the main reason we did this refactor. This is really about dependencies. Let’s compare the dependencies before and after our refactor:</p>

<h3 id="before">Before:</h3>

<p><img src="https://jesseduffield.com/images/posts/typekeys/before.png" alt=""/></p>

<p>The red arrows represent a dependency from something <em>general</em> to something <em>specific</em>. These dependencies lead to bloated abstractions that are impossible to decipher. The mini-dependency arrows flowing from our <code>userType</code> type key are shrunken to represent the fact that a change in e.g. <code>setupAdmin</code> or <code>setupCustomer</code> may not require a change to <code>userType</code>, but adding/removing a user type <em>will</em>.</p>

<p>The little people represent reasons for change: perhaps all the changes to the <code>setupAdmin</code> function originate from feature requests from staff, but <code>setupCustomer</code>’s changes all originate from the product team. Whatever it is, the reasons for change are different.</p>

<h3 id="after">After:</h3>

<p><img src="https://jesseduffield.com/images/posts/typekeys/after.png" alt=""/></p>

<p>Isn’t this nicer? There are fewer arrows flying around thanks to having <code>userType</code> out of the picture, but the important thing is that our <code>createUser</code> function is not dependent on our specific use cases, meaning that when changing a use case or adding a new use case (e.g. adding a ‘vendor’ user type) we don’t need to touch our <code>createUser</code> function. This is the basis of the Open-Close Principle: entities should be open for extention but closed for modification. This principle can <em>only</em> be satisfied when specific entities depend on general entities, not the other way around.</p>

<p>Note that instead of using callbacks we could have subclassed User to AdminUser and RegularUser, with each overriding the <code>onCreate</code> function. Regardless of which approach you take, you’ll get an identical dependency diagram!</p>

<h2 id="is-it-always-so-simple">Is It Always So Simple?</h2>

<p>I originally titled this post <em>Anti-pattern of the Day: Type Keys</em> and asked readers to suggest counter-examples. As you can tell by the name change, some readers obliged! No matter how many heuristics and strategies you keep in your mental toolbox, there will always be situations that Just Suck for which there is no easy answer. Let’s take a look at one such example:</p>

<p>Flag arguments tacked onto the end of a function are a classic example of a type key (the only difference being that they’re capped to two possible values). Given their status as type keys, they should be eyed with suspicion, however Martin Fowler gives an <a href="https://martinfowler.com/bliki/FlagArgument.html">example</a> where there’s no obvious alternative:</p>

<div><div><pre><code><span>public</span> <span>Booking</span> <span>book</span> <span>(</span><span>Customer</span> <span>aCustomer</span><span>,</span> <span>boolean</span> <span>isPremium</span><span>)</span> <span>{</span>
  <span>lorem</span><span>().</span><span>ipsum</span><span>();</span>
  <span>dolor</span><span>();</span>

  <span>if</span><span>(</span><span>isPremium</span><span>)</span> <span>{</span>
    <span>sitAmet</span><span>();</span>
  <span>}</span>

  <span>consectetur</span><span>();</span>

  <span>if</span><span>(</span><span>isPremium</span><span>)</span> <span>{</span>
    <span>adipiscing</span><span>().</span><span>elit</span><span>();</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>aenean</span><span>();</span>
    <span>vitaeTortor</span><span>().</span><span>mauris</span><span>();</span>
  <span>}</span>

  <span>eu</span><span>.</span><span>adipiscing</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>Granted, this function contains gobbledygook but it reflects a real world phenomenon: we read the type key several times within a function. Recalling that our goal is to remove the dependency from our general code (the <code>book</code> function) to our specific code (the premium/non-premium use cases), we need to find a refactor which satisfies this goal. Assuming order matters, we could once again employ callbacks:</p>

<div><div><pre><code><span>// forgive the bastardised Java syntax</span>
<span>public</span> <span>Booking</span> <span>book</span> <span>(</span><span>Customer</span> <span>aCustomer</span><span>,</span> <span>afterDolor</span><span>,</span> <span>afterConsectetur</span><span>)</span> <span>{</span>
  <span>lorem</span><span>().</span><span>ipsum</span><span>();</span>
  <span>dolor</span><span>();</span>

  <span>afterDolor</span><span>()</span>

  <span>consectetur</span><span>();</span>

  <span>afterConsectetur</span><span>()</span>

  <span>eu</span><span>.</span><span>adipiscing</span><span>();</span>
<span>}</span>

<span>// equivalent of isPremium: true</span>
<span>booking</span> <span>=</span> <span>book</span><span>(</span><span>aCustomer</span><span>,</span> <span>sitAmet</span><span>,</span> <span>()</span> <span>=&gt;</span> <span>adipiscing</span><span>().</span><span>elit</span><span>())</span>

<span>// equivalent of isPremium: false</span>
<span>booking</span> <span>=</span> <span>book</span><span>(</span><span>aCustomer</span><span>,</span> <span>()</span> <span>=&gt;</span> <span>null</span><span>,</span> <span>()</span> <span>=&gt;</span> <span>{</span>
  <span>aenean</span><span>();</span>
  <span>vitaeTortor</span><span>().</span><span>mauris</span><span>();</span>
<span>})</span>
</code></pre></div></div>

<p>But the fact our two callbacks are named <code>afterDolor()</code> and <code>afterConsectetur()</code> should raise some eyebrows: we’re now requiring our specific code to know about the internal structure of our general code. This isn’t as bad as vice-versa, but note that the non-premium call to <code>book</code> needs to pass a no-op function for <code>afterDolor()</code> to satisfy the new interface, despite that callback only being relevant to the premium use-case. In effect we’ve swapped out an ugly mess of dependencies for an even uglier mess.</p>

<p>Subclassing <code>Booking</code> into <code>PremiumBooking</code> and <code>RegularBooking</code> would be just as bad: we’d still need <code>afterDolor()</code> and <code>afterConsectetur()</code> to be implemented by both subclasses.</p>

<p>Alternatively if we’re willing to tolerate some repetition we could split <code>book</code> in two like so:</p>

<div><div><pre><code><span>public</span> <span>Booking</span> <span>bookPremium</span> <span>(</span><span>Customer</span> <span>aCustomer</span><span>)</span> <span>{</span>
  <span>before</span><span>();</span>
  <span>sitAmet</span><span>();</span>
  <span>consectetur</span><span>();</span>
  <span>adipiscing</span><span>().</span><span>elit</span><span>();</span>
  <span>eu</span><span>.</span><span>adipiscing</span><span>();</span>
<span>}</span>

<span>public</span> <span>Booking</span> <span>bookRegular</span> <span>(</span><span>Customer</span> <span>aCustomer</span><span>)</span> <span>{</span>
  <span>before</span><span>();</span>
  <span>consectetur</span><span>();</span>
  <span>aenean</span><span>();</span>
  <span>vitaeTortor</span><span>().</span><span>mauris</span><span>();</span>
  <span>eu</span><span>.</span><span>adipiscing</span><span>();</span>
<span>}</span>

<span>public</span> <span>before</span><span>()</span> <span>{</span>
  <span>lorem</span><span>().</span><span>ipsum</span><span>();</span>
  <span>dolor</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>It would be easier to judge whether this was an improvement if the function names were in English, but it’s plain to see that no matter which approach we take, we’re sacrificing something, whether it’s DRYness, simplicity, or otherwise. When every option sucks in its own way, just pick the simplest and hide the weird stuff from the public API, as Fowler advises in the same article:</p>

<div><div><pre><code><span>public</span> <span>Booking</span> <span>regularBook</span><span>(</span><span>Customer</span> <span>aCustomer</span><span>)</span> <span>{</span>
  <span>return</span> <span>hiddenBookImpl</span><span>(</span><span>aCustomer</span><span>,</span> <span>false</span><span>);</span>
<span>}</span>
<span>public</span> <span>Booking</span> <span>premiumBook</span><span>(</span><span>Customer</span> <span>aCustomer</span><span>)</span> <span>{</span>
  <span>return</span> <span>hiddenBookImpl</span><span>(</span><span>aCustomer</span><span>,</span> <span>true</span><span>);</span>
<span>}</span>
<span>private</span> <span>Booking</span> <span>hiddenBookImpl</span><span>(</span><span>Customer</span> <span>aCustomer</span><span>,</span> <span>boolean</span> <span>isPremium</span><span>)</span> <span>{...}</span>
</code></pre></div></div>

<p>By encapsulating the type key, we ensure that future changes (for example adding a new booking type) won’t affect any client code.</p>

<h2 id="moral-of-the-story">Moral of the Story</h2>

<p>If you <em>can</em> get rid of type keys, you <em>should</em>. If you <em>can’t</em> (without harming the code in some other way) you should hide them from the public API. Type keys are guilty until proven innocent, so if you’re writing or reviewing code that introduces a type key, spend the time thinking through how to satisfy the requirements without it, because, unchecked, type keys will bloat out your code and slow your development speed to a crawl.</p>

<p>Until next time!</p>

  </div></div>
  </body>
</html>
