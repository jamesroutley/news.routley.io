<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/631631/">Original</a>
    <h1>How programs get run: ELF binaries (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
      The <a href="https://lwn.net/Articles/630727/">previous article</a>
      in this series described the general
      mechanisms that the Linux kernel has for executing programs as a result of a user-space call
      to <tt>execve()</tt>.  However, the particular format handlers described in that article each deferred the
      process of execution to an inner call to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1352"><tt>search_binary_handler()</tt></a>.  That
      recursion almost always ends with the invocation of an ELF binary program, which is the subject of this
      article.
    </p>


    <h4>The ELF format</h4>
    <p>
      The ELF (<a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a>)
      format is the main binary format in use on modern Linux systems, and support for it is implemented
      in the file <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c"><tt>fs/binfmt_elf.c</tt></a>.  It&#39;s also a slightly complicated format
      for the kernel to handle;
      the main <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L571"><tt>load_elf_binary()</tt></a> function spans over 400 lines,
      and the ELF support code is more than four times as big as the
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_aout.c">code that supports the old a.out format</a>.
    </p>
    <p>
      An ELF file for an executable program (rather than a shared library or an object file) must always contain
      a <a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html">program header table</a> near the
      start of the file, after the <a href="http://www.sco.com/developers/gabi/latest/ch4.eheader.html">ELF
      header</a>; each entry in this table provides information that is needed to run the program.
    </p>
    <p>
      The kernel only really cares about three types of program header
    entries.  The first type is the <tt>PT_LOAD</tt> segment,
      which describes areas of the new program&#39;s running memory.  This
    includes code and data sections that come from the
      executable file, together with the size of a <a href="http://en.wikipedia.org/wiki/.bss">BSS</a> section.  The BSS will
      be filled with zeroes (thus only its length needs to be stored in the executable file).  The second entry of
      interest is a <tt>PT_INTERP</tt> entry, which identifies the run-time linker needed to assemble the complete
      program; for the time being, we&#39;ll assume a statically linked ELF binary and return to dynamic linking later.
      Finally, the kernel also gets a single bit of information from a <tt>PT_GNU_STACK</tt> entry, if present,
      which indicates whether the program&#39;s stack should be made executable or not.
    </p>
    <p>
      (This article only focuses on what&#39;s needed to load an ELF program, rather than exploring all of the details of
      the format.  The interested reader can find much more information via the <a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format#References">references</a> linked from
      Wikipedia&#39;s ELF article or
      by exploring real binaries with the
      <a href="http://man7.org/linux/man-pages/man1/objdump.1.html"><tt>objdump</tt></a> tool.)
    </p>


    <h4>Processing ELF binaries</h4>
    <p>
      Loading an ELF binary is handled by the <tt>load_elf_binary()</tt> function, which starts by examining the ELF
      header to check that the file in question does indeed <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L603">look like a supported ELF format</a>.
      The handler needs the whole of the ELF program header, whether it is
    within the first 128 bytes read into <tt>buf</tt> in
    <tt>linux_binprm</tt> or not,
      so it needs to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L626">read it</a> into some scratch space.
    </p>
    <p>
      The code now loops over the program header entries, checking for an
    interpreter (<tt>PT_INTERP</tt>) and whether the program&#39;s stack should
   be executable (from the <tt>PT_GNU_STACK</tt> entry).  With this
      preparation done, the code needs to initialize those attributes of the new program that are not inherited from the
      old program;
      the <a href="http://en.wikipedia.org/wiki/Single_UNIX_Specification">Single
    UNIX Specification</a> version 3 (SUSv3) <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html"><tt>exec</tt></a>
      specification describes most of the required behavior
      (and table 28-4 of <a href="http://man7.org/tlpi/index.html"><i>The Linux Programming Interface</i></a>
      gives an excellent summary of the attributes involved).
    </p>
    <p>
      The process of setting up the new program starts with a <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L722">call</a> to
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1054"><tt>flush_old_exec()</tt></a>, which clears up state in the kernel that refers to the
      previous program.  Any <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L892">other threads</a> of the old program are killed so the new program
      starts with a single thread, and the signal-handling information for the process
      is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L995">unshared</a> so that it can be safely altered later.
      Any pending POSIX timers for the old program are <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L992">cleared</a>, and the location of
      the <a href="https://elixir.bootlin.com/linux/v3.18/source/kernel/fork.c#L672">executable file</a> for the program (visible
      at <tt>/proc/<i>pid</i>/exe</tt>) is updated.
      The <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L819">virtual memory mappings</a> for the old program are released, which also
      <a href="https://elixir.bootlin.com/linux/v3.18/source/kernel/fork.c#L655">kills any pending asynchronous I/O operations</a>
      and <a href="https://elixir.bootlin.com/linux/v3.18/source/kernel/fork.c#L654">frees</a> any <a href="https://lwn.net/Articles/499190/">uprobes</a>.
      Finally, the <a href="http://man7.org/linux/man-pages/man2/personality.2.html">personality</a> of the process
      is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1081">updated</a> to remove any features that could affect security, as previously recorded
      in the <tt>per_clear</tt> field in <tt>linux_binprm</tt>.
      The main handler code also <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L728">calls</a> the <tt>SET_PERSONALITY()</tt> macro to
      <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/kernel/process_64.c#L385">set the thread flags appropriately</a> for a new 64-bit
      program.
    </p>
    <p>
      A corresponding <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L735">call</a> to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1097"><tt>setup_new_exec()</tt></a> now sets up
      the kernel&#39;s internal state for the new program.  This function starts by <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1104">determining</a>
      whether the new program can generate a core dump (or have <tt>ptrace()</tt> attach to it); this
      is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L69">disabled by default</a> for setuid or setgid programs. Dumping is
      also <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1123">disabled</a> when the <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1090">program file isn&#39;t readable</a> under the
      current credentials.
      A call to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1045"><tt>__set_task_comm()</tt></a> sets the current
      task&#39;s <tt>comm</tt> field to the basename of the originally invoked filename; this value is used as
      a thread name, and is accessible to user space via the <tt>PR_GET_NAME</tt> and <tt>PR_SET_NAME</tt>
      <a href="http://man7.org/linux/man-pages/man2/prctl.2.html"><tt>prctl()</tt></a> operations.  A call
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/kernel/signal.c#L484"><tt>flush_signal_handlers()</tt></a> sets up the signal handlers for the
      new program; any signal handler that&#39;s not <tt>SIG_IGN</tt> gets set to the default <tt>SIG_DFL</tt> value (so any
      ignored signals are inherited by the new program).  Finally, a call
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/file.c#L596"><tt>do_close_on_exec()</tt></a> closes all of the old program&#39;s file descriptors
      that have the <tt>O_CLOEXEC</tt> flag set; other file descriptors will be inherited by the new program.
    </p>
    <p>
      The virtual memory for the new program also needs to be set up. To improve security (by helping protect against
<a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">stack
overflow attacks</a>), the highest address
      for the stack is typically moved <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L555">downward by a random offset</a>.
      An initial <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L739">call</a>
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L640"><tt>setup_arg_pages()</tt></a> then sets up the kernel&#39;s memory tracking
      structures, and <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L671">adjusts</a> for the <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L711">new location</a> of the stack.
      The code <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L746">loops</a> through all of the <tt>PT_LOAD</tt> segments in the program file and
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L816">maps</a>
    them into the process&#39;s address space, setting up the new program&#39;s
    memory layout. It then sets up zero-filled pages that
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L874">correspond to the program&#39;s BSS segment</a>. Also, additional special pages — such as
      the <a href="https://lwn.net/Articles/615809/">virtual dynamic shared object (vDSO)</a> pages — need to be mapped, which is taken care of by
      a <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L925">call</a>
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/vdso/vma.c#L202"><tt>arch_setup_additional_pages()</tt></a>.
    An empty page may
      also be <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L952">mapped
    at the zero address</a> in the program&#39;s address space for
    backward-compatibility reasons (old SVr4
      programs apparently assume that reading from a <tt>NULL</tt> pointer would return zeros rather
      than <tt>SIGSEGV</tt>).
    </p>
    <p>
      Next, the credentials for the new program are set up via a call
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1187"><tt>install_exec_creds()</tt></a>.
    This function lets any active Linux Security Module (LSM) know about the
      change in credentials (through the
      <a href="https://elixir.bootlin.com/linux/v3.18/source/include/linux/security.h#L223"><tt>bprm_committing_creds</tt></a> and
      <a href="https://elixir.bootlin.com/linux/v3.18/source/include/linux/security.h#L232"><tt>bprm_committed_creds</tt></a> LSM hooks), and the inner
      <a href="https://elixir.bootlin.com/linux/v3.18/source/kernel/cred.c#L414"><tt>commit_creds()</tt></a> function performs the assignment.
    </p>
    <p>
      The final preparation for running the new program is to set up the rest of its stack (in its new randomized
      location), by calling the <tt>create_elf_tables()</tt> function; this is described in a separate section below.
    </p>
    <p>
      All of the preparation has now been done, and the new program can be launched.
      An <a href="https://lwn.net/Articles/604287/">earlier article</a> explained how the kernel&#39;s <tt>system_call</tt>
      entry point pushes the user-space CPU registers to the kernel stack before entering the main kernel code, and these
      registers are correspondingly restored when the system call completes. The area of the stack that holds the saved
      registers is <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/processor.h#L928">cast to</a>
      a <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/ptrace.h#L33"><tt>pt_regs</tt></a> structure, and the saved user-space CPU registers can thus be <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L171">overwritten with</a>
      suitable values (zeroes) for the start of the new program. The <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L975">call</a> to the
      <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/kernel/process_64.c#L230"><tt>start_thread()</tt></a> function also sets the saved
      instruction pointer to the entry point of the program (or the dynamic linker), and the saved stack pointer to the
      current top of the stack (from the <tt>p</tt> field in <tt>linux_binprm</tt>).  The zero return code from the
      handler indicates success, and the <tt>execve()</tt> syscall returns to user space — but to a completely
      different user space, where the process&#39;s memory has been remapped, and the restored registers have values that
      start the execution of the new program.
    </p>


    <h4>Populating the stack: the auxiliary vector, environment and arguments</h4>
    <p>
      The <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L149"><tt>create_elf_tables()</tt></a> function adds more information to the
      new program&#39;s stack, below the argument and environment information added by the generic code, as two distinct
      chunks.  An initial <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L176">call</a> to <tt>arch_align_stack()</tt>
      <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/kernel/process.c#L459">rounds down</a> the existing stack position to a 16-byte
      boundary, and may also further randomize the stack position downward slightly.
    </p>
    <p>
      The first collection of information forms the ELF auxiliary vector, a collection of (id, value) pairs that
      describe useful information about the program being run and the environment it is running in, communicated
      from the kernel to user space.   To build this vector, the handler code first needs to push onto the stack
      any information that doesn&#39;t fit within a 64-bit value; for x86_64 this is a
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L178">platform capability description</a> (the
      string <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L237"><tt>&#34;x86_64&#34;</tt></a>) and
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L206">16
    bytes of random data</a> (to help seed user-space random number generators).
    </p>
    <p>
      Next, the code <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L233">assembles</a> the (id, value) pairs for the auxiliary
      vector in the <a href="https://elixir.bootlin.com/linux/v3.18/source/include/linux/mm_types.h#L387"><tt>saved_auxv</tt></a> space within
      the <tt>mm_struct</tt>.  An <a href="https://lwn.net/Articles/519085/">LWN article</a> from Michael Kerrisk describes
      the contents of this vector, so here we just mention a few interesting entries:
    </p>
    <ul>
      <li>The (architecture-specific) first entry in the vector is the <tt>AT_SYSINFO_EHDR</tt> value for x86_64; this indicates
        the location of the vDSO page, as referenced in an <a href="https://lwn.net/Articles/604515/#vdso">earlier article</a>.</li>
      <li>The <tt>AT_PLATFORM</tt> value is the location of the <tt>&#34;x86_64&#34;</tt> platform capability description pushed
        earlier.</li>
      <li>The <tt>AT_RANDOM</tt> value is the location of the random data pushed earlier.</li>
      <li>The <tt>AT_EXECFN</tt> value holds the location of the program filename that was pushed as the very first
        thing on the stack (and whose location was stored in the <tt>exec</tt> field of <tt>linux_binprm</tt>), above
        the arguments and environment values.</li>
      <li>The <tt>AT_ENTRY</tt> value holds the entry point for the text segment, i.e. where program execution should
        start.</li>
    </ul>
    <p>
      Once this auxiliary vector is created, the code now assembles the rest of the new program&#39;s stack.  The required
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L278">space is calculated</a>, and then the entries are inserted from low addresses
      to higher ones:
    </p>
    <ul>
      <li>The <tt>argc</tt> argument count is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L294">inserted</a> first.</li>
      <li>An array of argument pointers is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L301">inserted</a> next, ending with a
        NULL pointer.  This is where <tt>main()</tt>&#39;s <tt>argv</tt> will eventually point.</li>
      <li>An array of environment pointers is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L313">inserted</a> next, ending with
        a NULL pointer.  This is
        where <a href="http://man7.org/linux/man-pages/man7/environ.7.html"><tt>environ</tt></a> will point.</li>
      <li>The auxiliary vector is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L326">put at the highest address</a>, just below the
        additional values it references.</li>
    </ul>
    <p>
      Taken together, the top of the new program&#39;s address space will have contents like the following example
      (<a href="http://www.win.tue.nl/~aeb/linux/hh/stack-layout.html">this page</a> has a similar example):
    
</p><pre>    ------------------------------------------------------------- 0x7fff6c845000
     0x7fff6c844ff8: 0x0000000000000000
            _  4fec: &#39;./stackdump\0&#39;                      &lt;------+
      env  /   4fe2: &#39;ENVVAR2=2\0&#39;                               |    &lt;----+
           \_  4fd8: &#39;ENVVAR1=1\0&#39;                               |   &lt;---+ |
           /   4fd4: &#39;two\0&#39;                                     |       | |     &lt;----+
     args |    4fd0: &#39;one\0&#39;                                     |       | |    &lt;---+ |
           \_  4fcb: &#39;zero\0&#39;                                    |       | |   &lt;--+ | |
               3020: random gap padded to 16B boundary           |       | |      | | |
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|       | |      | | |
               3019: &#39;x86_64\0&#39;                        &lt;-+       |       | |      | | |
     auxv      3009: random data: ed99b6...2adcc7        | &lt;-+   |       | |      | | |
     data      3000: zero padding to align stack         |   |   |       | |      | | |
    . . . . . . . . . . . . . . . . . . . . . . . . . . .|. .|. .|       | |      | | |
               2ff0: AT_NULL(0)=0                        |   |   |       | |      | | |
               2fe0: AT_PLATFORM(15)=0x7fff6c843019    --+   |   |       | |      | | |
               2fd0: AT_EXECFN(31)=0x7fff6c844fec      ------|---+       | |      | | |
               2fc0: AT_RANDOM(25)=0x7fff6c843009      ------+           | |      | | |
      ELF      2fb0: AT_SECURE(23)=0                                     | |      | | |
    auxiliary  2fa0: AT_EGID(14)=1000                                    | |      | | |
     vector:   2f90: AT_GID(13)=1000                                     | |      | | |
    (id,val)   2f80: AT_EUID(12)=1000                                    | |      | | |
      pairs    2f70: AT_UID(11)=1000                                     | |      | | |
               2f60: AT_ENTRY(9)=0x4010c0                                | |      | | |
               2f50: AT_FLAGS(8)=0                                       | |      | | |
               2f40: AT_BASE(7)=0x7ff6c1122000                           | |      | | |
               2f30: AT_PHNUM(5)=9                                       | |      | | |
               2f20: AT_PHENT(4)=56                                      | |      | | |
               2f10: AT_PHDR(3)=0x400040                                 | |      | | |
               2f00: AT_CLKTCK(17)=100                                   | |      | | |
               2ef0: AT_PAGESZ(6)=4096                                   | |      | | |
               2ee0: AT_HWCAP(16)=0xbfebfbff                             | |      | | |
               2ed0: AT_SYSINFO_EHDR(33)=0x7fff6c86b000                  | |      | | |
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        | |      | | |
               2ec8: environ[2]=(nil)                                    | |      | | |
               2ec0: environ[1]=0x7fff6c844fe2         ------------------|-+      | | |
               2eb8: environ[0]=0x7fff6c844fd8         ------------------+        | | |
               2eb0: argv[3]=(nil)                                                | | |
               2ea8: argv[2]=0x7fff6c844fd4            ---------------------------|-|-+
               2ea0: argv[1]=0x7fff6c844fd0            ---------------------------|-+
               2e98: argv[0]=0x7fff6c844fcb            ---------------------------+
     0x7fff6c842e90: argc=3
</pre>

    <p>
      Note that although there are two randomizations in the stack layout (the position of the top of memory and the
      size of the gap between the argument values and the auxiliary
      vector), the newly running program can still figure
      out where all of the information on the stack is.  The SP register tells the program where the top of the stack is
      (i.e. the lowest address), and the command-line arguments are arranged upwards in memory from there, with a NULL
      pointer to mark where they end.  The environment values are found next, again with a NULL pointer to terminate,
      and the auxiliary vector is found at the next consecutive addresses, closing with an <tt>AT_NULL</tt> ID. The
      values found within all of this information give the addresses of the argument strings, environment strings, and
      auxiliary data values, so no explicit information about the size of the random gap is needed.
    </p>


    <h4>Dynamically linked programs</h4>
    <p>
      So far we&#39;ve assumed the program being executed is statically linked and skipped over steps that would be
      triggered by the presence of a <tt>PT_INTERP</tt> entry in the ELF program header.  However, most programs are
      dynamically linked, meaning that required <a href="http://lurklurk.org/linkers/linkers.html#sharedlibs">shared
      libraries</a> have to be located and linked at run-time.  This is performed by the <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">runtime linker</a> (typically
      something
      like <tt>/lib64/ld-linux-x86-64.so.2</tt>), and
      the identity of this linker is specified by the <tt>PT_INTERP</tt> program header entry.
    </p>
    <p>
      To cope with a runtime linker, the ELF handler first <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L660">reads the ELF interpreter file name</a>
      into scratch space, then <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L673">opens the executable file</a>
      with <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L786"><tt>open_exec()</tt></a>.  The first 128 bytes of the file are read into
      the <tt>bprm-&gt;buf</tt> scratch area, replacing the contents of the original program file and
      allowing <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L694">access</a> to the ELF header of the interpreter program — which
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L711">must</a> therefore be an ELF binary itself, rather than any other format.
    </p>
    <p>
      After the program code has been loaded into memory as described previously,
      the ELF handler also <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L890">loads the ELF interpreter program</a> into memory
      with <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L395"><tt>load_elf_interp()</tt></a>.  This process is similar to the process of loading the
      original program: the code <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L408">checks the format information in the ELF header</a>,
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L427">reads in the ELF program header</a>, <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L470">maps</a> all of
      the <tt>PT_LOAD</tt> segments from the file into the new program&#39;s memory, and <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L518">leaves room</a>
      for the interpreter&#39;s BSS segment.
    </p>
    <p>
      The execution start address for the program is also <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L900">set
    to be the entry point</a> of the
      interpreter, rather than that of the program itself.  When the <tt>execve()</tt> system call completes, execution
      then begins with the ELF interpreter, which takes care of satisfying the linkage requirements of the program from
      user space — finding and loading the shared libraries that the program depends on, and resolving the
      program&#39;s undefined symbols to the correct definitions in those libraries.  Once this linkage process is done (which
      relies on a much deeper understanding of the ELF format than the kernel has), the interpreter
      can start the execution of the new program itself,
      <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/dl-sysdep.c;h=65a90469c6bdd12cba03c5a21a283971db39868d;hb=c758a6861537815c759cba2018a3b1abb1943842#l129">at
      the address previously recorded</a> in the <tt>AT_ENTRY</tt> auxiliary value.
    </p>


    <h4>Compatibility with other architectures</h4>
    <p>
      As <a href="https://lwn.net/Articles/604515/#x86_32">described previously</a>, a modern 64-bit (x86_64) Linux
      system can also support running 32-bit binaries of two types: normal 32-bit binaries (x86_32),
      and <a href="http://en.wikipedia.org/wiki/X32_ABI">x32 ABI</a> programs (which can make use of additional
      x86_64 registers).  So how does the kernel support these binaries?
    </p>
    <p>
      The key file that provides support for these formats
      is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c"><tt>compat_binfmt_elf.c</tt></a>, which is included in the kernel when the
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/Kconfig.binfmt#L26"><tt>CONFIG_COMPAT_BINFMT_ELF</tt></a> config option is set.  This file
      didn&#39;t appear in our earlier list of places that register binary handlers, because the file contains almost no
      code of its own.  Instead, it <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L145">includes</a> the main <tt>binfmt_elf.c</tt> ELF handler
      code (using <tt>#include</tt>), and uses the preprocessor to redirect various internal functions and values to 32-bit compatibility
      versions.  Other than these changes, the format handler therefore behaves the same as the normal ELF handler
      described above.
    </p>
    <p>
      One set of changes <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L34">uses 32-bit versions</a> of the structures describing the layout of
      the ELF file;
      similarly, the appropriate <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L81">constant values</a> for 32-bit binaries are used, which ensures
      that the compatibility handler only claims support for the relevant ELF binary types.  In particular,
      the <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L609"><tt>elf_check_arch()</tt></a> call is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L79">replaced</a> with a
      <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L163"><tt>compat_elf_check_arch()</tt></a> version
      that checks for either x86_32 or (if configured) x32.
    </p>
    <p>
      The preprocessor changes also redirect some of the inner functionality of the ELF handler code.
      The <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L728">invocation</a> of the <tt>SET_PERSONALITY()</tt> macro is
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L116">redirected</a>
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/kernel/process_64.c#L405"><tt>set_personality_ia32()</tt></a>  so that
      the relevant thread flags for the 32-bit architecture are set and,
    similarly, 
      the <tt>arch_setup_additional_pages()</tt> function is <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L130">replaced</a> with
      a <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/vdso/vma.c#L211">version</a> that sets up a 32-bit vDSO.
      More significantly, the <tt>start_thread()</tt> function is
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L121">replaced</a> with <tt>compat_start_thread()</tt>,
      which <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L190">maps</a>
      to <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/kernel/process_64.c#L255"><tt>start_thread_ia32()</tt></a>.  This alters
      the arguments to the inner <tt>start_thread_common()</tt> function so that the saved segment registers are
      initialized differently than for x86_64 binaries (and
      the <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L186"><tt>ELF_PLAT_INIT()</tt></a> macro is also
      <a href="https://elixir.bootlin.com/linux/v3.18/source/fs/compat_binfmt_elf.c#L111">adjusted</a> to <a href="https://elixir.bootlin.com/linux/v3.18/source/arch/x86/include/asm/elf.h#L186">match</a>).
    </p>




    <h4>Epilogue</h4>
    <p>
      Every program that runs on a Linux system passes through the portal of <tt>execve()</tt>; as such it&#39;s a key
      piece of kernel functionality that&#39;s worth understanding in detail.  Although the kernel natively supports script
      and other machine-code format programs, program execution on a modern Linux system eventually involves running an
      ELF binary.  ELF is a complicated format, but fortunately the kernel can ignore most of that complexity — it
      only needs to understand just enough ELF to load segments into memory, and to invoke a user space run-time linker
      program to finish the job of assembling a complete running program.
    </p></div></div>
  </body>
</html>
