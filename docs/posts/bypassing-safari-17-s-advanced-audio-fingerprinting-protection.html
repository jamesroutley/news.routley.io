<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fingerprint.com/blog/bypassing-safari-17-audio-fingerprinting-protection/">Original</a>
    <h1>Bypassing Safari 17&#39;s advanced audio fingerprinting protection</h1>
    
    <div id="readability-page-1" class="page"><div><p>Did you know that browsers can produce audio files you can’t hear, and those audio files can be used to identify web visitors? Apple knows, and the company decided to fight the identification possibility in Safari 17, but their measures don’t fully work.</p>
<h2 id="identifying-with-audio"><a href="#identifying-with-audio" aria-label="identifying with audio permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Identifying with audio</h2>
<p>The technique is called audio fingerprinting, and you can learn how it works in our <a href="https://fingerprint.com/blog/audio-fingerprinting/" target="_blank" rel="noopener noreferrer">previous article</a>. In a nutshell, audio fingerprinting uses the browser’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener noreferrer">Audio API</a> to render an audio signal with <a href="https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext" target="_blank" rel="noopener noreferrer">OfflineAudioContext</a> interface, which then transforms into a single number by adding all audio signal samples together. The number is the fingerprint, also called “identifier”.</p>
<p>The audio identifier is stable, meaning it doesn’t change when you clear the cookies or go into incognito mode. This is the key feature of fingerprinting. However, the identifier is not very unique, and many users can have the same identifier.</p>
<p>Audio fingerprinting is a part of <a href="https://github.com/fingerprintjs/fingerprintjs" target="_blank" rel="noopener noreferrer">FingerprintJS</a>, our library with source code available on GitHub.</p>
<p>Fingerprinting is used to identify bad actors when they want to remain anonymous. For example, when they want to sign in to your account or use stolen credit card credentials. Fingerprinting can identify repeat bad actors, allowing you to prevent them from committing fraud. However, many people see it as a privacy violation and therefore don’t like it.</p>
<h2 id="how-safari-17-breaks-audio-fingerprinting"><a href="#how-safari-17-breaks-audio-fingerprinting" aria-label="how safari 17 breaks audio fingerprinting permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How Safari 17 breaks audio fingerprinting</h2>
<p>Apple <a href="https://www.apple.com/au/newsroom/2023/06/apple-announces-powerful-new-privacy-and-security-features/" target="_blank" rel="noopener noreferrer">introduced</a> advanced fingerprinting protection in Safari 17. Advanced fingerprinting protection aims to reduce fingerprinting accuracy by limiting available information or adding randomness.</p>
<p>By default, the advanced protection is enabled in private (incognito) mode and disabled in normal mode. It affects both desktop and mobile platforms. Advanced fingerprinting protection also affects <a href="https://developer.mozilla.org/en-US/docs/Web/API/Screen" target="_blank" rel="noopener noreferrer">Screen API</a> and <a href="https://developer.mozilla.org/en-US/docs/Glossary/Canvas" target="_blank" rel="noopener noreferrer">Canvas API</a>, but we’ll focus only on Audio API in this article.</p>
<p>An audio signal produced with the Audio API is an array of numbers representing the signal amplitude at each moment of time (also called “audio samples”). When fingerprinting protection is on, Safari adds a random noise to every sample individually. A noised sample lies between <code>sample*(1-magnitude)</code> and <code>sample*(1+magnitude)</code>, and the distribution is <a href="https://en.wikipedia.org/wiki/Continuous_uniform_distribution" target="_blank" rel="noopener noreferrer">uniform</a>. This is how it’s <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/platform/audio/AudioUtilities.cpp#L80" target="_blank" rel="noopener noreferrer">implemented in Safari</a>:</p>
<div data-language="cpp"><pre><code><span>void</span> <span>applyNoise</span><span>(</span><span>float</span><span>*</span> values<span>,</span> size_t numberOfElementsToProcess<span>,</span> <span>float</span> magnitude<span>)</span>
<span>{</span>
    WeakRandom generator<span>;</span>
    <span>for</span> <span>(</span>size_t i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numberOfElementsToProcess<span>;</span> <span>++</span>i<span>)</span>
        values<span>[</span>i<span>]</span> <span>*=</span> <span>1</span> <span>+</span> magnitude <span>*</span> <span>(</span><span>2</span> <span>*</span> generator<span>.</span><span>get</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p><em>Note: Safari is being developed actively, so this and the other facts may be outdated when you read the article.</em></p>
<p>All Audio API interfaces that allow reading the audio signal apply noise:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode" target="_blank" rel="noopener noreferrer">AudioWorkletNode</a> (magnitude 0.001, <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/AudioWorkletNode.cpp#L219" target="_blank" rel="noopener noreferrer">source code</a>)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer/getChannelData" target="_blank" rel="noopener noreferrer">AudioBuffer::getChannelData</a> (magnitude 0.001, <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/AudioBuffer.cpp#L167" target="_blank" rel="noopener noreferrer">source code</a>)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer/copyFromChannel" target="_blank" rel="noopener noreferrer">AudioBuffer::copyFromChannel</a> (magnitude 0.001, <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/AudioBuffer.cpp#L227" target="_blank" rel="noopener noreferrer">source code</a>)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getFloatFrequencyData" target="_blank" rel="noopener noreferrer">RealtimeAnalyser::getFloatFrequencyData</a> (magnitude 0.25, <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/RealtimeAnalyser.cpp#L181" target="_blank" rel="noopener noreferrer">source code</a>)</li>
</ul>
<p>The noise is different every time it’s applied. As a result, the whole audio fingerprint changes every time it’s calculated in private mode. These changes cause the fingerprint to mismatch in normal and private modes. This breaks the stability; therefore, the fingerprint can’t be used for identification.</p>
<p>The fingerprint fluctuates between <code>124.03516</code> and <code>124.04545</code> in Safari 17 on an M1 MacBook Air. The difference is about 0.008%. That may not sound like much, but further on, we’ll explain why this is a huge difference.</p>
<h2 id="how-we-bypass-safari-17s-advanced-fingerprinting-protection"><a href="#how-we-bypass-safari-17s-advanced-fingerprinting-protection" aria-label="how we bypass safari 17s advanced fingerprinting protection permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How we bypass Safari 17’s advanced fingerprinting protection</h2>
<p>The goal is to remove the noise added by Safari. To achieve this, we must improve <a href="https://github.com/fingerprintjs/fingerprintjs/blob/a555410e925e0d6a4d548aa555b6945bd713e9cd/src/sources/audio.ts#L41" target="_blank" rel="noopener noreferrer">our fingerprinting algorithm</a> in 3 steps:</p>
<ol>
<li>Reduce the dispersion of the noise.</li>
<li>Push browser identifier numbers farther apart.</li>
<li>Round the fingerprint to remove the remaining noise.</li>
</ol>
<p>We’ll call this improved algorithm “the new algorithm” throughout the article.</p>
<p>Steps 1 and 2 are necessary because Safari’s range of added noise is much bigger than the difference between fingerprints produced by various browsers. This table shows audio fingerprints produced by some browsers and the percent difference between them and the closest fingerprint from other browsers:</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Fingerprint</th>
<th>Difference from the closest browser</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacBook Air 2020, Safari 17.0</td>
<td>124.04345259929687</td>
<td>0.0000023%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Safari 16.6</td>
<td>124.04345808873768</td>
<td>0.0000044%</td>
</tr>
<tr>
<td>iPhone SE, Safari 13.1</td>
<td>35.10893253237009</td>
<td>1.8%</td>
</tr>
<tr>
<td>MacBook Air 2020, Chrome 116</td>
<td>124.04344968475198</td>
<td>0.0000023%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Chrome 116</td>
<td>124.04347657808103</td>
<td>0.000015%</td>
</tr>
<tr>
<td>Galaxy S23, Chrome 114</td>
<td>124.08072766105033</td>
<td>0.030%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Firefox 118</td>
<td>35.749968223273754</td>
<td>0.0000055%</td>
</tr>
<tr>
<td>MacBook Air 2020, Firefox 118</td>
<td>35.74996626004577</td>
<td>0.0000055%</td>
</tr>
<tr>
<td>BrowserStack Windows 8, Firefox 67</td>
<td>35.7383295930922</td>
<td>0.033%</td>
</tr>
</tbody>
</table>
<p>As you can see, the smallest difference is 0.0000023%, much smaller than the Safari noise range (0.008%). Eliminating the noise Safari adds requires rounding down by 1 decimal place, but we can’t round to fewer than 6 decimal places. Otherwise, some browsers from the above table will be indistinguishable. In other words, the fingerprint will have poor uniqueness.</p>
<h3 id="step-1-cutting-through-the-noise"><a href="#step-1-cutting-through-the-noise" aria-label="step 1 cutting through the noise permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 1: Cutting through the noise</h3>
<p>The base idea for noise reduction is combining many separate audio fingerprints together. Each fingerprint is collected using the same algorithm, so the only difference is the noise added by the browser.</p>
<p>First, let’s take a closer look at the <a href="https://github.com/fingerprintjs/fingerprintjs/blob/a555410e925e0d6a4d548aa555b6945bd713e9cd/src/sources/audio.ts#L41" target="_blank" rel="noopener noreferrer">fingerprinting algorithm</a>. A fingerprint is a sum of 500 audio samples, and each audio sample is added with a random number with a <a href="https://en.wikipedia.org/wiki/Continuous_uniform_distribution" target="_blank" rel="noopener noreferrer">uniform distribution</a>. Therefore, according to <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noopener noreferrer">the central limit theorem</a>, the fingerprint noise has a <a href="https://en.wikipedia.org/wiki/Normal_distribution" target="_blank" rel="noopener noreferrer">normal distribution</a>. The mean of the distribution is the un-noised fingerprint that we want to find.</p>
<p>The mean can be found using a large number of random samples (don’t confuse this with “audio samples”). This won’t be the true mean, but the more random samples there are, the more precise the result is. Uniform and normal distributions require different methods to find the mean:</p>
<ul>
<li>For a uniform distribution, the most precise formula is <code>(min+max)/2</code>, where <code>min</code> and <code>max</code> are the minimum and the maximum random samples</li>
<li>For a normal distribution, the most precise formula is the average of all the random samples</li>
</ul>
<p>Finding the mean of a uniform noise is much easier than a normally distributed noise. For a given precision, one needs much fewer samples in case of a uniform distribution to guess the mean. This JavaScript code proves the point in practice:</p>
<div data-language="jsx"><pre><code><span>const</span> sessionCount <span>=</span> <span>1000</span>
<span>const</span> desiredMaxError <span>=</span> <span>0.005</span>

<span>const</span> <span>uniformRandom</span> <span>=</span> <span>(</span><span>mean<span>,</span> variance</span><span>)</span> <span>=&gt;</span> <span>{</span>
  width <span>=</span> Math<span>.</span><span>sqrt</span><span>(</span><span>12</span> <span>*</span> variance<span>)</span>
  shift <span>=</span> mean <span>-</span> width <span>/</span> <span>2</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> width <span>+</span> shift
<span>}</span>
<span>const</span> <span>normalRandom</span> <span>=</span> <span>(</span><span>mean<span>,</span> variance</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// https://en.wikipedia.org/wiki/Box–Muller_transform</span>
  <span>const</span> pi2 <span>=</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span>
  <span>const</span> sigma <span>=</span> Math<span>.</span><span>sqrt</span><span>(</span>variance<span>)</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> Math<span>.</span><span>sqrt</span><span>(</span><span>-</span><span>2</span> <span>*</span> Math<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>*</span> Math<span>.</span><span>cos</span><span>(</span>pi2 <span>*</span> Math<span>.</span><span>random</span><span>(</span><span>)</span><span>)</span> <span>*</span> sigma <span>+</span> mean
<span>}</span>

<span>const</span> <span>averageMeanFind</span> <span>=</span> <span>samples</span> <span>=&gt;</span> samples<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=&gt;</span> a <span>+</span> b<span>)</span> <span>/</span> samples<span>.</span>length
<span>const</span> <span>midRangeMeanFind</span> <span>=</span> <span>samples</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> min <span>=</span> samples<span>[</span><span>0</span><span>]</span>
  <span>let</span> max <span>=</span> samples<span>[</span><span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> samples<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>samples<span>[</span>i<span>]</span> <span>&lt;</span> min<span>)</span> <span>{</span>
      min <span>=</span> samples<span>[</span>i<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>samples<span>[</span>i<span>]</span> <span>&gt;</span> max<span>)</span> <span>{</span>
      max <span>=</span> samples<span>[</span>i<span>]</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>(</span>min <span>+</span> max<span>)</span> <span>/</span> <span>2</span>
<span>}</span>

<span>const</span> <span>findAdequateSampleCount</span> <span>=</span> <span>(</span><span>makeRandom<span>,</span> findMean</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> mean <span>=</span> <span>0</span>
  <span>const</span> variance <span>=</span> <span>1</span>
  <span>const</span> random <span>=</span> <span>makeRandom</span><span>(</span>mean<span>,</span> variance<span>)</span>

  <span>sampleCountLoop</span><span>:</span>
  <span>for</span> <span>(</span><span>let</span> sampleCount <span>=</span> <span>2</span><span>;</span> sampleCount <span>&lt;</span> <span>1e7</span><span>;</span> sampleCount <span>*=</span> <span>2</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> session <span>=</span> <span>0</span><span>;</span> session <span>&lt;</span> sessionCount<span>;</span> <span>++</span>session<span>)</span> <span>{</span>
      <span>const</span> samples <span>=</span> <span>[</span><span>...</span><span>Array</span><span>(</span>sampleCount<span>)</span><span>]</span><span>.</span><span>map</span><span>(</span>random<span>)</span>
      <span>const</span> foundMean <span>=</span> <span>findMean</span><span>(</span>samples<span>)</span>
      <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>mean <span>-</span> foundMean<span>)</span> <span>&gt;</span> desiredMaxError<span>)</span> <span>{</span>
        <span>continue</span> sampleCountLoop
      <span>}</span>
    <span>}</span>
    <span>return</span> sampleCount
  <span>}</span>

  <span>return</span> <span>&#39;Too much time to compute&#39;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>&#39;Normal needs samples&#39;</span><span>,</span> <span>findAdequateSampleCount</span><span>(</span>normalRandom<span>,</span> averageMeanFind<span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>&#39;Uniform needs samples&#39;</span><span>,</span> <span>findAdequateSampleCount</span><span>(</span>uniformRandom<span>,</span> midRangeMeanFind<span>)</span><span>)</span>
<span>// Normal: 524288, uniform: 4096</span>
</code></pre></div>
<p>The old audio fingerprint is more computation-demanding and requires 100 times more fingerprint samples to reduce the noise. So, to reduce the noise in a reasonable time, we changed the fingerprinting algorithm to collect only one audio sample, which has a uniform noise distribution. The exact number of randomized samples needed depends on the rounding precision we need, which will be demonstrated later.</p>
<p>The algorithm change also means new fingerprints aren’t compatible with old fingerprints. Because of the rounding, the audio fingerprint will change, so sticking to the old fingerprint identifiers is useless. Note that you need to use <a href="https://github.com/fingerprintjs/fingerprintjs/blob/5ae80b7b946fcd824e35d033bc44e180334109f6/docs/version_policy.md#how-to-update-without-losing-the-identifiers" target="_blank" rel="noopener noreferrer">a special approach</a> to switch from the old fingerprint to the new one without losing the visitor identities.</p>
<h3 id="getting-many-noised-copies-of-the-same-audio-sample"><a href="#getting-many-noised-copies-of-the-same-audio-sample" aria-label="getting many noised copies of the same audio sample permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting many noised copies of the same audio sample</h3>
<p>One approach for getting multiple noised copies is <a href="https://github.com/fingerprintjs/fingerprintjs/blob/a555410e925e0d6a4d548aa555b6945bd713e9cd/src/sources/audio.ts#L77" target="_blank" rel="noopener noreferrer">calling</a> <code>getChannelData</code> on the <code>AudioBuffer</code> instance many times. Remember that <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer/getChannelData" target="_blank" rel="noopener noreferrer"><code>getChannelData</code></a> returns the audio samples that the fingerprint is calculated from. This approach doesn’t work because noise is <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/AudioBuffer.cpp#L336" target="_blank" rel="noopener noreferrer">applied once per</a> each <code>AudioBuffer</code> instance, and <code>getChannelData</code> returns the same signal.</p>
<p>This can be circumvented by creating many <code>AudioBuffer</code> instances by running the whole audio signal generation process many times. For 6,000 noised samples, the fastest time is 7 seconds on an M1 MacBook. For 60,000, Safari can’t even finish the process. This is way too long for a fingerprint. Therefore, this approach is not viable.</p>
<p>A better approach is to make an <code>AudioBuffer</code> instance with the same audio signal on repeat:</p>
<ol>
<li>Render an audio signal as usual, but don’t call <code>getChannelData</code>, because it will <a href="https://github.com/WebKit/WebKit/blob/167dc5118a3f6228a19df40e673ea0a6d03b9bec/Source/WebCore/Modules/webaudio/AudioBuffer.cpp#L167" target="_blank" rel="noopener noreferrer">add noise</a> to the signal.</li>
<li>Create another <code>OfflineAudioContext</code> instance, much longer than the original instance. Use the original signal as a source using an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode" target="_blank" rel="noopener noreferrer"><code>AudioBufferSourceNode</code></a>.</li>
<li>Make the <code>AudioBufferSourceNode</code> loop the needed piece of the original signal using <code>loop</code>, <code>loopStart</code>, and <code>loopEnd</code>. The piece can be as narrow as a single audio sample.</li>
<li>Render the second (looped) audio context and call <code>getChannelData</code>. The resulting audio signal will consist of the original signal followed by the piece repeating until the end. Safari adds a noise after the looping, so the repeating copy has the same audio samples with different noise applied.</li>
</ol>
<p>Here’s how to implement this approach:</p>
<div data-language="jsx"><pre><code><span>const</span> sampleRate <span>=</span> <span>44100</span>

<span>getClonedPieces</span><span>(</span><span>)</span>

<span>async</span> <span>function</span> <span>getClonedPieces</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> pieceLength <span>=</span> <span>500</span> <span>// Can be as little as 1</span>
  <span>const</span> cloneCount <span>=</span> <span>1000</span>

  <span>// Rendering the original audio signal</span>
  <span>const</span> baseSignal <span>=</span> <span>await</span> <span>getBaseSignal</span><span>(</span><span>)</span>
  <span>const</span> loopStart <span>=</span> baseSignal<span>.</span>length <span>-</span> pieceLength

  <span>// A new audio context that loops an ending part of the original audio signal</span>
  <span>const</span> context <span>=</span> <span>new</span> <span>OfflineAudioContext</span><span>(</span><span>1</span><span>,</span> loopStart <span>+</span> cloneCount <span>*</span> pieceLength<span>,</span> sampleRate<span>)</span>
  <span>const</span> sourceNode <span>=</span> context<span>.</span><span>createBufferSource</span><span>(</span><span>)</span>
  sourceNode<span>.</span>buffer <span>=</span> baseSignal
  sourceNode<span>.</span>loop <span>=</span> <span>true</span>
  sourceNode<span>.</span>loopStart <span>=</span> <span>(</span>baseSignal<span>.</span>length <span>-</span> pieceLength<span>)</span> <span>/</span> sampleRate
  sourceNode<span>.</span>loopEnd <span>=</span> baseSignal<span>.</span>length <span>/</span> sampleRate
  sourceNode<span>.</span><span>connect</span><span>(</span>context<span>.</span>destination<span>)</span>
  sourceNode<span>.</span><span>start</span><span>(</span><span>)</span>

  <span>// Rendering the new audio context and extracting the looped part</span>
  <span>const</span> signalBuffer <span>=</span> <span>await</span> <span>renderAudio</span><span>(</span>context<span>)</span>
  <span>const</span> clones <span>=</span> signalBuffer<span>.</span><span>getChannelData</span><span>(</span><span>0</span><span>)</span><span>.</span><span>subarray</span><span>(</span>loopStart<span>)</span>
  
  console<span>.</span><span>log</span><span>(</span>clones<span>)</span>
<span>}</span>

<span>async</span> <span>function</span> <span>getBaseSignal</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> context <span>=</span> <span>new</span> <span>OfflineAudioContext</span><span>(</span><span>1</span><span>,</span> <span>5000</span><span>,</span> sampleRate<span>)</span>

  <span>// Any audio signal...</span>

  <span>return</span> <span>await</span> <span>renderAudio</span><span>(</span>context<span>)</span>
<span>}</span>

<span>function</span> <span>renderAudio</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>// See the implementation at https://github.com/fingerprintjs/fingerprintjs/blob/c411aff111e5c79cdc37608d42632d4a66a8c1dc/src/sources/audio.ts#L147</span>
<span>}</span>
</code></pre></div>
<p>Any number of noised sample copies can be produced in 2 audio renderings.</p>
<p>The code below combines the methods to denoise a single selected audio sample:</p>
<div data-language="jsx"><pre><code><span>const</span> sampleRate <span>=</span> <span>44100</span>

console<span>.</span><span>log</span><span>(</span><span>denoiseAudioSample</span><span>(</span><span>10000</span><span>)</span><span>)</span>

<span>async</span> <span>function</span> <span>denoiseAudioSample</span><span>(</span><span>cloneCount</span><span>)</span> <span>{</span>
  <span>// Rendering the original audio signal</span>
  <span>const</span> baseSignal <span>=</span> <span>await</span> <span>getBaseSignal</span><span>(</span><span>)</span>

  <span>// A new audio context that loops an ending part of the original audio signal</span>
  <span>const</span> context <span>=</span> <span>new</span> <span>OfflineAudioContext</span><span>(</span><span>1</span><span>,</span> baseSignal<span>.</span>length <span>-</span> <span>1</span> <span>+</span> cloneCount<span>,</span> sampleRate<span>)</span>
  <span>const</span> sourceNode <span>=</span> context<span>.</span><span>createBufferSource</span><span>(</span><span>)</span>
  sourceNode<span>.</span>buffer <span>=</span> baseSignal
  sourceNode<span>.</span>loop <span>=</span> <span>true</span>
  sourceNode<span>.</span>loopStart <span>=</span> <span>(</span>baseSignal<span>.</span>length <span>-</span> pieceLength<span>)</span> <span>/</span> sampleRate
  sourceNode<span>.</span>loopEnd <span>=</span> baseSignal<span>.</span>length <span>/</span> sampleRate
  sourceNode<span>.</span><span>connect</span><span>(</span>context<span>.</span>destination<span>)</span>
  sourceNode<span>.</span><span>start</span><span>(</span><span>)</span>

  <span>// Rendering the new audio context</span>
  <span>const</span> signalBuffer <span>=</span> <span>await</span> <span>renderAudio</span><span>(</span>context<span>)</span>

  <span>// Restoring the mean (the audio sample before the noising)</span>
  <span>return</span> <span>getMiddle</span><span>(</span>signalBuffer<span>.</span><span>getChannelData</span><span>(</span><span>0</span><span>)</span><span>.</span><span>subarray</span><span>(</span>baseSignal<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>)</span>
<span>}</span>

<span>async</span> <span>function</span> <span>getBaseSignal</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> context <span>=</span> <span>new</span> <span>OfflineAudioContext</span><span>(</span><span>1</span><span>,</span> <span>5000</span><span>,</span> sampleRate<span>)</span>

  <span>// Any audio signal...</span>

  <span>return</span> <span>await</span> <span>renderAudio</span><span>(</span>context<span>)</span>
<span>}</span>

<span>function</span> <span>renderAudio</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>// See the implementation at https://github.com/fingerprintjs/fingerprintjs/blob/c411aff111e5c79cdc37608d42632d4a66a8c1dc/src/sources/audio.ts#L147</span>
<span>}</span>

<span>function</span> <span>getMiddle</span><span>(</span><span>samples</span><span>)</span> <span>{</span>
  <span>let</span> min <span>=</span> samples<span>[</span><span>0</span><span>]</span>
  <span>let</span> max <span>=</span> samples<span>[</span><span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> samples<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>samples<span>[</span>i<span>]</span> <span>&lt;</span> min<span>)</span> <span>{</span>
      min <span>=</span> samples<span>[</span>i<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>samples<span>[</span>i<span>]</span> <span>&gt;</span> max<span>)</span> <span>{</span>
      max <span>=</span> samples<span>[</span>i<span>]</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>(</span>min <span>+</span> max<span>)</span> <span>/</span> <span>2</span>
<span>}</span>
</code></pre></div>
<p>At this point, the noise is suppressed, not removed completely. The resulting number is still not stable, but the variance is smaller than that of a raw audio sample.</p>
<p>This table shows how the denoising precision and time in the above code snippet depend on the number of samples (<code>cloneCount</code>):</p>
<table>
<thead>
<tr>
<th>Number of copies</th>
<th>Result range: (max-min)/min in 100 runs</th>
<th>Time on an M1 MacBook</th>
</tr>
</thead>
<tbody>
<tr>
<td>2,048</td>
<td>0.194%</td>
<td>2.0ms</td>
</tr>
<tr>
<td>4,096</td>
<td>0.190%</td>
<td>2.3ms</td>
</tr>
<tr>
<td>8,192</td>
<td>0.000387%</td>
<td>2.6ms</td>
</tr>
<tr>
<td>16,384</td>
<td>0.0000988%</td>
<td>2.9ms</td>
</tr>
<tr>
<td>32,768</td>
<td>0.0000411%</td>
<td>4.0ms</td>
</tr>
<tr>
<td>65,536</td>
<td>0.0000123%</td>
<td>4.1ms</td>
</tr>
<tr>
<td>131,072</td>
<td>0.00000823%</td>
<td>5.2ms</td>
</tr>
<tr>
<td>262,144</td>
<td>0% (the ultimate precision)</td>
<td>7.5ms</td>
</tr>
<tr>
<td>524,288</td>
<td>0%</td>
<td>11.9ms</td>
</tr>
<tr>
<td>1,048,576</td>
<td>0%</td>
<td>20.5ms</td>
</tr>
</tbody>
</table>
<h3 id="step-2-push-browser-identifier-numbers-farther-apart"><a href="#step-2-push-browser-identifier-numbers-farther-apart" aria-label="step 2 push browser identifier numbers farther apart permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 2: Push browser identifier numbers farther apart</h3>
<p>The times shown in the previous table can be 100 times longer on low-end devices or heavy webpages. The performance of the fingerprinting is important, so the fewer copies there are, the better. However, fewer copies mean bigger result dispersion, so it’s necessary to increase the difference between the audio samples in browsers too. These differences can be achieved by changing the base signal.</p>
<h3 id="audio-nodes-with-heavy-distortion"><a href="#audio-nodes-with-heavy-distortion" aria-label="audio nodes with heavy distortion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Audio nodes with heavy distortion</h3>
<p>After hours of experimenting with all the built-in audio nodes, we found an audio signal generator that gives a much bigger audio sample variance between browsers. The generator is a chain of audio nodes:</p>
<ol>
<li>The initial signal is produced by a square <a href="https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode" target="_blank" rel="noopener noreferrer">OscillatorNode</a>.</li>
<li>Then, the signal goes through a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode" target="_blank" rel="noopener noreferrer">DynamicsCompressorNode</a>.</li>
<li>Finally, the signal is processed by a <a href="https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode" target="_blank" rel="noopener noreferrer">BiquadFilterNode</a> of type “allpass”.</li>
</ol>
<p>It is not necessary to know what the audio nodes do in detail. They can be treated as black boxes.</p>
<p>The audio sample number 3396 of the signal has the biggest difference between browsers. The number 3396 was found by simply comparing all samples of the audio signals in different browsers. This is how the signal is implemented in code:</p>
<div data-language="jsx"><pre><code><span>async</span> <span>function</span> <span>getBaseSignal</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> context <span>=</span> <span>new</span> <span>OfflineAudioContext</span><span>(</span><span>1</span><span>,</span> <span>3396</span><span>,</span> <span>44100</span><span>)</span>

  <span>const</span> oscillator <span>=</span> context<span>.</span><span>createOscillator</span><span>(</span><span>)</span>
  oscillator<span>.</span>type <span>=</span> <span>&#39;square&#39;</span>
  oscillator<span>.</span>frequency<span>.</span>value <span>=</span> <span>1000</span>

  <span>const</span> compressor <span>=</span> context<span>.</span><span>createDynamicsCompressor</span><span>(</span><span>)</span>
  compressor<span>.</span>threshold<span>.</span>value <span>=</span> <span>-</span><span>70</span>
  compressor<span>.</span>knee<span>.</span>value <span>=</span> <span>40</span>
  compressor<span>.</span>ratio<span>.</span>value <span>=</span> <span>12</span>
  compressor<span>.</span>attack<span>.</span>value <span>=</span> <span>0</span>
  compressor<span>.</span>release<span>.</span>value <span>=</span> <span>0.25</span>

  <span>const</span> filter <span>=</span> context<span>.</span><span>createBiquadFilter</span><span>(</span><span>)</span>
  filter<span>.</span>type <span>=</span> <span>&#39;allpass&#39;</span>
  filter<span>.</span>frequency<span>.</span>value <span>=</span> <span>5.239622852977861</span>
  filter<span>.</span><span>Q</span><span>.</span>value <span>=</span> <span>0.1</span>

  oscillator<span>.</span><span>connect</span><span>(</span>compressor<span>)</span>
  compressor<span>.</span><span>connect</span><span>(</span>filter<span>)</span>
  filter<span>.</span><span>connect</span><span>(</span>context<span>.</span>destination<span>)</span>
  oscillator<span>.</span><span>start</span><span>(</span><span>0</span><span>)</span>

  <span>return</span> <span>await</span> <span>renderAudio</span><span>(</span>context<span>)</span>
<span>}</span>

<span>function</span> <span>renderAudio</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>// See the implementation at https://github.com/fingerprintjs/fingerprintjs/blob/c411aff111e5c79cdc37608d42632d4a66a8c1dc/src/sources/audio.ts#L147</span>
<span>}</span>

<span>// The audio sample number 3396 (if counted from 1)</span>
<span>const</span> audioSample <span>=</span> <span>(</span><span>await</span> <span>getBaseSignal</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getChannelData</span><span>(</span><span>0</span><span>)</span><span>.</span><span>at</span><span>(</span><span>-</span><span>1</span><span>)</span></code></pre></div>
<p>The following table shows the resulting audio sample in different browsers:</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Audio sample</th>
<th>Difference from the closest browser</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacBook Air 2020, Safari 17.0</td>
<td>0.000059806101489812136</td>
<td>0.0014%</td>
</tr>
<tr>
<td>iPhone 13, Safari 15.4 (BrowserStack)</td>
<td>0.00005980528294458054</td>
<td>0.0014%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Safari 16.6</td>
<td>0.00006429151108022779</td>
<td>0.046%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Chrome 116</td>
<td>0.0000642621744191274</td>
<td>0.046%</td>
</tr>
<tr>
<td>MacBook Air 2020, Chrome 116</td>
<td>0.00006128742097644135</td>
<td>2.42%</td>
</tr>
<tr>
<td>Galaxy S23, Chrome 114</td>
<td>0.0000744499484426342</td>
<td>11.8%</td>
</tr>
<tr>
<td>Acer Chromebook 314, Chrome 117</td>
<td>0.00008321150380652398</td>
<td>10.53%</td>
</tr>
<tr>
<td>iPhone SE, Safari 13.1</td>
<td>0.00011335541057633236</td>
<td>26.6%</td>
</tr>
<tr>
<td>BrowserStack Windows 8, Firefox 67</td>
<td>0.00016917561879381537</td>
<td>0.0063%</td>
</tr>
<tr>
<td>MacBook Air 2020, Firefox 118</td>
<td>0.00016918622714001685</td>
<td>0.0040%</td>
</tr>
<tr>
<td>MacBook Pro 2015, Firefox 118</td>
<td>0.00016919305198825896</td>
<td>0.0040%</td>
</tr>
</tbody>
</table>
<p>Now the smallest difference is 0.0014%, which is much bigger than the original fingerprint (0.0000023%). It means that a much coarser denoising is possible.</p>
<h3 id="step-3-round-the-result"><a href="#step-3-round-the-result" aria-label="step 3 round the result permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 3: Round the result</h3>
<p>The final step is stabilizing the sample to be used as a fingerprint. The sample range is small but still unstable, which is not suitable for FingerprintJS, because even a tiny change to the sample causes the whole fingerprint to change.</p>
<p>Rounding is a way to stabilize the audio sample. Usually, rounding preserves a specific number of digits after the decimal point. This is not a good choice in this case because, as mentioned at the beginning, the noise is not absolute; it’s relative to the audio sample number. Therefore, some number of <em>significant</em> digits should be preserved during rounding. Significant digits are all digits after the beginning zeros. You can see a rounding implementation on <a href="https://github.com/fingerprintjs/fingerprintjs/blob/c411aff111e5c79cdc37608d42632d4a66a8c1dc/src/sources/audio.ts#L244" target="_blank" rel="noopener noreferrer">GitHub</a>.</p>
<p>The table above shows that 5 significant digits are enough to tell the selected browsers apart. But since we can’t check all browsers in the world and can’t predict how they will change in the future, we use a few more digits, just in case.</p>
<p>The table below shows the number of audio sample copies needed to make the denoising result stable in private mode of Safari 17 after rounding with the given precision:</p>
<table>
<thead>
<tr>
<th>Significant digits</th>
<th># of copies</th>
<th>Time in Safari 17 on an M1 MacBook (warm)</th>
<th>Time in Chrome 116 on an M1 MacBook (warm)</th>
<th>Time in Chrome 114 on Pixel 2 (warm)</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>15,000</td>
<td>3ms</td>
<td>4ms</td>
<td>13ms</td>
</tr>
<tr>
<td>7, but the last is the nearest multiple of 5</td>
<td>30,000</td>
<td>4ms</td>
<td>5ms</td>
<td>15ms</td>
</tr>
<tr>
<td>7, but the last is the nearest even digit</td>
<td>70,000</td>
<td>6ms</td>
<td>7ms</td>
<td>16ms</td>
</tr>
<tr>
<td>7 and more</td>
<td>400,000</td>
<td>12ms</td>
<td>13ms</td>
<td>34ms</td>
</tr>
</tbody>
</table>
<p><em>A ”warm” browser is a browser that has run the given code before. A browser becomes “cold” when it’s restarted. A warm browser produces more stable time measurements.</em></p>
<p>We chose “7, but the last is 0 or 5” as a good balance between the performance and uniqueness. We also increased the number of copies to 40,000 to increase stability.</p>
<p>The rounded number is the final new audio fingerprint that doesn’t change, even when Safari 17’s advanced fingerprinting protection is on. Uniqueness is an important property of fingerprinting. The new fingerprint has the same uniqueness as the old audio fingerprint.</p>
<h2 id="performance"><a href="#performance" aria-label="performance permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance</h2>
<p>The following table shows the fingerprinting time on a blank page in warm browsers:</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Old fingerprint</th>
<th>New fingerprint</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacBook Air 2020, Safari 17.3</td>
<td>2ms</td>
<td>4ms</td>
</tr>
<tr>
<td>MacBook Air 2020, Chrome 120</td>
<td>5ms</td>
<td>8ms</td>
</tr>
<tr>
<td>MacBook Air 2020, Firefox 121</td>
<td>6ms</td>
<td>8ms</td>
</tr>
<tr>
<td>MacBook Pro 2015, Safari 16.6</td>
<td>4ms</td>
<td>6ms</td>
</tr>
<tr>
<td>MacBook Pro 2015, Chrome 120</td>
<td>5ms</td>
<td>7ms</td>
</tr>
<tr>
<td>MacBook Pro 2015, Firefox 121</td>
<td>5ms</td>
<td>7ms</td>
</tr>
<tr>
<td>iPhone 13 mini, Safari 17.3</td>
<td>8ms</td>
<td>12ms</td>
</tr>
<tr>
<td>iPhone SE, Safari 13.1</td>
<td>9ms</td>
<td>17ms</td>
</tr>
<tr>
<td>Acer Chromebook 314, Chrome 120</td>
<td>7ms</td>
<td>13ms</td>
</tr>
<tr>
<td>Galaxy S23, Chrome 120</td>
<td>6ms</td>
<td>8ms</td>
</tr>
<tr>
<td>Galaxy J7 Prime, Chrome 120</td>
<td>33ms</td>
<td>45ms</td>
</tr>
<tr>
<td>Pixel 3, Chrome 120</td>
<td>8ms</td>
<td>15ms</td>
</tr>
<tr>
<td>BrowserStack Windows 11, Chrome 120</td>
<td>5ms</td>
<td>7ms</td>
</tr>
<tr>
<td>BrowserStack Windows 11, Firefox 121</td>
<td>10ms</td>
<td>18ms</td>
</tr>
</tbody>
</table>
<p>Compared to the old fingerprinting algorithm, the performance of the new one degrades 1.5–2 times. Even so, the new fingerprint algorithm takes little time to compute, even on low-end devices.</p>
<p>The browser delegates some work to the OfflineAudioRender thread, freeing the main thread. Therefore, the page stays responsive during most of the audio fingerprint calculation. Web Audio API is not available for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener noreferrer">web workers</a>, so we cannot calculate audio fingerprints there.</p>
<p>To improve the performance, the new fingerprint can be used only in Safari 17 while keeping the old algorithm in other browsers. Check whether the current browser is Safari 17 or newer using the user-agent string. Based on that, run either the old or the new fingerprinting algorithm.</p>
<h2 id="how-it-works-in-privacy-focused-browsers"><a href="#how-it-works-in-privacy-focused-browsers" aria-label="how it works in privacy focused browsers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How it Works in Privacy-Focused Browsers</h2>
<p>Privacy-focused browsers like Tor and Brave also make attempts to restrict audio fingerprinting. Web Audio API is completely disabled in Tor, so audio fingerprinting is <a href="https://gitlab.torproject.org/legacy/trac/-/issues/21984" target="_blank" rel="noopener noreferrer">impossible</a>. Brave, however, follows an approach like Safari 17 and adds noise to the audio signal. Our <a href="https://fingerprint.com/blog/audio-fingerprinting/#brave" target="_blank" rel="noopener noreferrer">previous article</a> explains more about Brave’s audio fingerprinting protection.</p>
<p>The Brave noise has an important difference. While Safari adds a random noise for each audio sample individually, Brave makes a random multiplier (called “fudge factor”) once and uses it for all audio samples. That is, all audio samples are multiplied by the same number. The fudge factor persists within a page. It changes only in a new regular or incognito session.</p>
<div data-language="jsx"><pre><code><span>// A pseudo-code to illustrate the difference</span>

<span>const</span> audioSignal <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>/* ... */</span><span>)</span>
<span>const</span> magnitude <span>=</span> <span>0.001</span>

<span>// Safari</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> audioSignal<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  audioSignal<span>[</span>i<span>]</span> <span>*=</span> <span>random</span><span>(</span><span>1</span> <span>-</span> magnitude<span>,</span> <span>1</span> <span>+</span> magnitude<span>)</span>
<span>}</span>

<span>// Brave</span>
<span>const</span> fudgeFactor <span>=</span> <span>random</span><span>(</span><span>1</span> <span>-</span> magnitude<span>,</span> <span>1</span> <span>+</span> magnitude<span>)</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> audioSignal<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  audioSignal<span>[</span>i<span>]</span> <span>*=</span> fudgeFactor
<span>}</span>
</code></pre></div>
<p>No matter how many audio sample copies we make, the noise addition will be the same in every copy. The copies won’t be dispersed around the true (before noising) audio sample. Therefore, <a href="#step-1-cutting-through-the-noise">the mathematical denoising method</a> doesn’t work.</p>
<p>Nevertheless, the Brave denoising method described in <a href="https://fingerprint.com/blog/audio-fingerprinting/#brave" target="_blank" rel="noopener noreferrer">the previous article</a> still works. <a href="#step-2-push-browser-identifier-numbers-farther-apart">The method for increasing the difference between fingerprints produced by browsers</a> can also increase the error tolerance.</p>
<h2 id="usage-in-fingerprintjs"><a href="#usage-in-fingerprintjs" aria-label="usage in fingerprintjs permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage in FingerprintJS</h2>
<p>The new audio fingerprinting algorithm replaced the old one in FingerprintJS. It was first published in version <a href="https://github.com/fingerprintjs/fingerprintjs/releases/tag/v4.2.0" target="_blank" rel="noopener noreferrer">4.2.0</a>. You can see the full code for the audio fingerprint implementation <a href="https://github.com/fingerprintjs/fingerprintjs/blob/c411aff111e5c79cdc37608d42632d4a66a8c1dc/src/sources/audio.ts" target="_blank" rel="noopener noreferrer">in our GitHub repository</a>.</p>
<p>Audio fingerprinting is one of the many signals our <a href="https://github.com/fingerprintjs/fingerprintjs" target="_blank" rel="noopener noreferrer">source-available library</a> uses to generate a browser fingerprint. However, we do not blindly incorporate every signal available in the browser. Instead, we analyze the stability and uniqueness of each signal separately to determine their impact on fingerprint accuracy.</p>
<p>For audio fingerprinting, we found that the signal contributes only slightly to uniqueness but is highly stable, resulting in a slight net increase in fingerprint accuracy.</p>
<p>If you want to learn more about Fingerprint join us on <a href="https://discord.gg/39EpE2neBg" target="_blank" rel="noopener noreferrer">Discord</a> or reach out to us at <a href="mailto:oss-support@fingerprint.com" target="_blank" rel="noopener noreferrer">oss-support@fingerprint.com</a> for support using FingerprintJS.</p></div></div>
  </body>
</html>
