<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/">Original</a>
    <h1>git rebase: what can go wrong?</h1>
    
    

<p>Hello! While talking with folks about Git, I&rsquo;ve been seeing a comment over and
over to the effect of &ldquo;I hate rebase&rdquo;. People seemed to feel pretty strongly
about this, and I was really surprised because I don&rsquo;t run into a lot of
problems with rebase and I use it all the time.</p>

<p>I&rsquo;ve found that if many people have a very strong opinion that&rsquo;s different from
mine, usually it&rsquo;s because they have different experiences around that thing
from me.</p>

<p>So I asked on <a href="https://social.jvns.ca/@b0rk/111342083852635579">Mastodon</a>:</p>

<blockquote>
<p>today I&rsquo;m thinking about the tradeoffs of using <code>git rebase</code> a bit. I think
the goal of rebase is to have a nice linear commit history, which is something
I like.</p>

<p>but what are the <em>costs</em> of using rebase? what problems has it caused for you
in practice? I&rsquo;m really only interested in specific bad experiences you&rsquo;ve had
here &ndash; not opinions or general statements like “rewriting history is bad”</p>
</blockquote>

<p>I got a huge number of incredible answers to this, and I&rsquo;m going to do my best
to summarize them here. I&rsquo;ll also mention solutions or workarounds to those
problems in cases where I know of a solution. Here&rsquo;s the list:</p>

<ul>
<li><a href="#fixing-the-same-conflict-repeatedly-is-annoying">fixing the same conflict repeatedly is annoying</a></li>
<li><a href="#undoing-a-rebase-is-hard">undoing a rebase is hard</a></li>
<li><a href="#force-pushing-to-shared-branches-can-cause-lost-work">force pushing to shared branches can cause lost work</a></li>
<li><a href="#force-pushing-makes-code-reviews-harder">force pushing makes code reviews harder</a></li>
<li><a href="#losing-commit-metadata">losing commit metadata</a></li>
<li><a href="#rebasing-can-break-intermediate-commits">rebasing can break intermediate commits</a></li>
<li><a href="#accidentally-running-git-commit-instead-of-git-rebase-continue">accidentally run git commit instead of git rebase &ndash;continue</a></li>
<li><a href="#splitting-commits-in-an-interactive-rebase-is-hard">splitting commits in an interactive rebase is hard</a></li>
<li><a href="#complex-rebases-are-hard">complex rebases are hard</a></li>
<li><a href="#rebasing-long-lived-branches-can-be-annoying">rebasing long lived branches can be annoying</a></li>
<li><a href="#miscellaneous-problems">miscellaneous problems</a></li>
<li><a href="#what-could-a-merge-only-workflow-look-like">what could a merge-only workflow look like?</a></li>
</ul>

<p>My goal with this isn&rsquo;t to convince anyone that rebase is bad and you shouldn&rsquo;t
use it (I&rsquo;m certainly going to keep using rebase!). But seeing all these
problems made me want to be more cautious about recommending rebase to
newcomers without explaining how to use it safely. It also makes me wonder if
there&rsquo;s an easier workflow for cleaning up your commit history that&rsquo;s harder to
accidentally mess up.</p>

<h3 id="my-git-workflow-assumptions">my git workflow assumptions</h3>

<p>First, I know that people use a lot of different Git workflows. I&rsquo;m going to be
talking about the workflow I&rsquo;m used to when working on a team, which is:</p>

<ul>
<li>the team uses a central Github/Gitlab repo to coordinate</li>
<li>there&rsquo;s one central <code>main</code> branch. It&rsquo;s protected from force pushes.</li>
<li>people write code in feature branches and make pull requests to <code>main</code></li>
<li>The web service is deployed from <code>main</code> every time a pull request is merged.</li>
<li>the only way to make a change to <code>main</code> is by making a pull request on Github/Gitlab and merging it</li>
</ul>

<p>This is not the only &ldquo;correct&rdquo; git workflow (it&rsquo;s a very &ldquo;we run a web service&rdquo;
workflow and open source project or desktop software with releases generally
use a slightly different workflow). But it&rsquo;s what I know so that&rsquo;s what I&rsquo;ll
talk about.</p>

<h3 id="two-kinds-of-rebase">two kinds of rebase</h3>

<p>Also before we start: one big thing I noticed is that there were 2 different kinds of rebase that kept coming up, and only one of them requires you to deal with merge conflicts.</p>

<ol>
<li><strong>rebasing on an ancestor</strong>, like <code>git rebase -i HEAD^^^^^^^</code> to squash many
small commits into one. As long as you&rsquo;re just squashing commits, you&rsquo;ll
never have to resolve a merge conflict while doing this.</li>
<li><strong>rebasing onto a branch that has diverged</strong>, like <code>git rebase main</code>. This can cause merge conflicts.</li>
</ol>

<p>I think it&rsquo;s useful to make this distinction because sometimes I&rsquo;m thinking
about rebase type 1 (which is a lot less likely to cause problems), but people
who are struggling with it are thinking about rebase type 2.</p>

<p>Now let&rsquo;s move on to all the problems!</p>

<h3 id="fixing-the-same-conflict-repeatedly-is-annoying">fixing the same conflict repeatedly is annoying</h3>

<p>If you make many tiny commits, sometimes you end up in a hellish loop where you
have to fix the same merge conflict 10 times.  You can also end up fixing merge
conflicts totally unnecessarily (like dealing with a merge conflict in code
that a future commit deletes).</p>

<p>There are a few ways to make this better:</p>

<ul>
<li>first do a <code>git rebase -i HEAD^^^^^^^^^^^</code> to squash all of the tiny commits
into 1 big commit and then a <code>git rebase main</code> to rebase onto a different
branch. Then you only have to fix the conflicts once.</li>
<li>use <code>git rerere</code> to automate resolving merge conflicts. I&rsquo;ve never tried this.</li>
</ul>

<p>Also if I find myself resolving merge conflicts more than once in a rebase,
I&rsquo;ll usually run <code>git rebase --abort</code> to stop it and then squash my commits into
one and try again.</p>

<h3 id="undoing-a-rebase-is-hard">undoing a rebase is hard</h3>

<p>I heard from several people that when they were new to rebase, they messed up a
rebase and permanently lost a week of work that they then had to redo.</p>

<p>The problem here is that undoing a rebase that went wrong is <strong>much</strong> more complicated
than undoing a merge that went wrong (you can undo a bad merge with something like <code>git reset --hard HEAD^</code>).
Many newcomers to rebase don&rsquo;t even realize that undoing a rebase is even
possible, and I think it&rsquo;s pretty easy to understand why.</p>

<p>That said, it is possible to undo a rebase that went wrong. Here&rsquo;s an example of how to undo a rebase using <code>git reflog</code>.</p>

<p><strong>step 1</strong>: Do a bad rebase (for example run <code>git rebase -I HEAD^^^^^</code> and just delete 3 commits)</p>

<p><strong>step 2</strong>:  Run <code>git reflog</code>. You should see something like this:</p>

<pre><code>ee244c4 (HEAD -&gt; main) HEAD@{0}: rebase (finish): returning to refs/heads/main
ee244c4 (HEAD -&gt; main) HEAD@{1}: rebase (pick): test
fdb8d73 HEAD@{2}: rebase (start): checkout HEAD^^^^^^^
ca7fe25 HEAD@{3}: commit: 16 bits by default
073bc72 HEAD@{4}: commit: only show tooltips on desktop
</code></pre>

<p><strong>step 3</strong>: Find the entry immediately before <code>rebase (start)</code>. In my case that&rsquo;s <code>ca7fe25</code></p>

<p><strong>step 4</strong>:  Run <code>git reset --hard ca7fe25</code></p>

<p>Another solution folks mentioned to &ldquo;undoing a rebase is hard&rdquo; that avoids having
to use the reflog is to make a &ldquo;backup branch&rdquo; with <code>git switch -c backup</code>
before rebasing, so you can easily get back to the old commit.</p>

<h3 id="force-pushing-to-shared-branches-can-cause-lost-work">force pushing to shared branches can cause lost work</h3>

<p>A few people mentioned the following situation:</p>

<ol>
<li>You&rsquo;re collaborating on a branch with someone</li>
<li>You push some changes</li>
<li>They rebase the branch and run <code>git push --force</code> (maybe by accident)</li>
<li>Now when you run <code>git pull</code>, it&rsquo;s a mess &ndash; you get the a <code>fatal: Need to specify how to reconcile divergent branches</code> error</li>
<li>While trying to deal with the fallout you might lose some commits, especially if some of the people are involved aren&rsquo;t very comfortable with git</li>
</ol>

<p>This is an even worse situation than the &ldquo;undoing a rebase is hard&rdquo; situation
because the missing commits might be split across many different people&rsquo;s and
the only worse thing than having to hunt through the reflog is multiple
different people having to hunt through the reflog.</p>

<p>This has never happened to me because the only branch I&rsquo;ve ever collaborated on
is <code>main</code>, and <code>main</code> has always been protected from force pushing (in my
experience the only way you can get something into <code>main</code> is through a pull
request). So I&rsquo;ve never even really been in a situation where this <em>could</em>
happen. But I can definitely see how this would cause problems.</p>

<p>The main tools I know to avoid this are:</p>

<ul>
<li>don&rsquo;t rebase on shared branches</li>
<li>use <code>--force-with-lease</code> when force pushing, to make sure that nobody else has pushed to the branch since you last push</li>
</ul>

<p>I was curious about why people would run <code>git push --force</code> on a shared branch. Some reasons people gave were:</p>

<ul>
<li>they&rsquo;re new to git, read some instructions online that suggested <code>git rebase</code> and <code>git push --force</code> as a solution, and followed them without understanding the consequences</li>
<li>they&rsquo;re used to doing <code>git push --force</code> on a personal branch and ran it on a shared branch by accident</li>
</ul>

<h3 id="force-pushing-makes-code-reviews-harder">force pushing makes code reviews harder</h3>

<p>The situation here is:</p>

<ul>
<li>You make a pull request on GitHub</li>
<li>People leave some comments</li>
<li>You update the code to address the comments, rebase to clean up your commits, and force push</li>
<li>Now when the reviewer comes back, it&rsquo;s hard for them to tell what you changed since the last time you saw it &ndash; all the commits show up as &ldquo;new&rdquo;.</li>
</ul>

<p>One way to avoid this is to push new commits addressing the review comments,
and then after the PR is approved do a rebase to reorganize everything.</p>

<p>I think some reviewers are more annoyed by this problem than others, it&rsquo;s kind
of a personal preference. Also this might be a Github-specific issue, other
code review tools might have better tools for managing this.</p>

<h3 id="losing-commit-metadata">losing commit metadata</h3>

<p>If you&rsquo;re rebasing to squash commits, you can lose important commit metadata
like <code>Co-Authored-By</code>. Also if you GPG sign your commits, rebase loses the
signatures.</p>

<p>There&rsquo;s probably other commit metadata that you can lose that I&rsquo;m not thinking of.</p>

<p>I haven&rsquo;t run into this one so I&rsquo;m not sure how to avoid it. I think GPG
signing commits isn&rsquo;t as popular as it used to be.</p>

<h3 id="rebasing-can-break-intermediate-commits">rebasing can break intermediate commits</h3>

<p>If you&rsquo;re trying to have a very clean commit history where the tests pass on
every commit (very admirable!), rebasing can result in some intermediate
commits that are broken and don&rsquo;t pass the tests, even if the final commit
passes the tests.</p>

<p>Apparently you can avoid this by using <code>git rebase -x</code> to run the test suite at
every step of the rebase and make sure that the tests are still passing. I&rsquo;ve
never done that though.</p>

<h3 id="accidentally-run-git-commit-instead-of-git-rebase-continue">accidentally run <code>git commit</code> instead of <code>git rebase --continue</code></h3>

<p>A couple of people mentioned issues with running <code>git commit</code> instead of <code>git rebase --continue</code> when resolving a conflict.</p>

<p>I think what goes wrong here is that you:</p>

<ul>
<li>Start a rebase</li>
<li>Run into a merge conflict</li>
<li>Resolve the merge conflict, and run <code>git add file.txt</code></li>
<li>Run <code>git commit</code> because that&rsquo;s what you&rsquo;re used to doing after you run <code>git add</code></li>
<li>But you were supposed to run <code>git rebase --continue</code>! Now you have a weird extra commit, and maybe it has the wrong commit message and/or author</li>
</ul>

<h3 id="splitting-commits-in-an-interactive-rebase-is-hard">splitting commits in an interactive rebase is hard</h3>

<p>The whole point of rebase is to clean up your commit history, and <strong>combining</strong>
commits with rebase is pretty easy. But what if you want to split up a commit into 2
smaller commits? It&rsquo;s not as easy, especially if the commit you want to split
is a few commits back! I actually don&rsquo;t really know how to do it even though I
feel very comfortable with rebase. I&rsquo;d probably just do <code>git reset HEAD^^^</code>  or
something and use <code>git add -p</code> to redo all my commits from scratch.</p>

<p>One person shared <a href="https://github.com/kimgr/git-rewrite-guide#split-a-commit">their workflow for splitting commits with rebase</a>.</p>

<h3 id="complex-rebases-are-hard">complex rebases are hard</h3>

<p>If you try to do too many things in a single <code>git rebase -i</code> (reorder commits
AND combine commits AND modify a commit), it can get really confusing.</p>

<p>To avoid this, I personally prefer to only do 1 thing per rebase, and if I want
to do 2 different things I&rsquo;ll do 2 rebases.</p>

<h3 id="rebasing-long-lived-branches-can-be-annoying">rebasing long lived branches can be annoying</h3>

<p>If your branch is long-lived (like for 1 month), having to rebase repeatedly
gets painful. It might be easier to just do 1 merge at the end and only resolve
the conflicts once.</p>

<p>The dream is to avoid this problem by not having long-lived branches but it
doesn&rsquo;t always work out that way in practice.</p>

<h3 id="miscellaneous-problems">miscellaneous problems</h3>

<p>A few more issues that I think are not that common:</p>

<ul>
<li><strong>Stopping a rebase wrong</strong>: If you try to abort a rebase that&rsquo;s going badly with
<code>git reset --hard</code> instead of <code>git rebase --abort</code>, things will behave
weirdly until you stop it properly</li>
<li><strong>Weird interactions with merge commits</strong>: A couple of quotes about this: &ldquo;If you
rebase your working copy to keep a clean history for a branch, but the
underlying project uses merges, the result can be ugly. If you do rebase -i
HEAD~4 and the fourth commit back is a merge, you can see dozens of commits
in the interactive editor.&ldquo;, &ldquo;I&rsquo;ve learned the hard way to <em>never</em> rebase if
I&rsquo;ve merged anything from another branch&rdquo;</li>
</ul>

<h3 id="what-could-a-merge-only-workflow-look-like">what could a merge-only workflow look like?</h3>

<p>Seeing all of these issues made me wonder if there was a way I could accomplish
all of my goals with rebase, but only using merges.</p>

<p>Personally my goals with rebase are:</p>

<ol>
<li>I like to commit very frequently with <code>git commit -am'wip'</code> and to clean up my commit history later</li>
<li>I need a way to resolve any merge conflicts with <code>main</code> in my own branch</li>
</ol>

<p>My usual rebase workflow is</p>

<ul>
<li>make a lot of ugly commits</li>
<li>periodically use <code>git rebase -i</code> to squash them</li>
<li>also periodically run <code>git rebase main</code> to make sure there aren&rsquo;t any merge conflicts with <code>main</code> (and fix them if so)</li>
</ul>

<p>I think an alternate workflow that avoids rebase could be:</p>

<ul>
<li>make commits</li>
<li>Run <code>git merge main</code> to merge main into my branch periodically</li>
<li>To look at the log of changes made on my branch, run <code>git diff main</code> or <code>git log main..mybranch</code>. That will look something like this:</li>
</ul>

<pre><code>$ git log main..mybranch
756d4af (HEAD -&gt; mybranch) Merge branch 'main' into mybranch
20106fd Merge branch 'main' into mybranch
d7da423 some commit on my branch
85a5d7d some other commit on my branch
</code></pre>

<ul>
<li>When I&rsquo;m done, use GitHub&rsquo;s &ldquo;squash and merge&rdquo; feature (which is the equivalent of
running <code>git checkout main; git merge --squash mybranch</code>) to squash all of my
changes into 1 commit. This gets rid of all the &ldquo;ugly&rdquo; merge commits.</li>
<li>If I really want to clean things up and fix my commit history, run <code>git merge
main</code>, then <code>git reset main</code> and <code>git add -p</code> to reconstruct the commit
history I want</li>
</ul>

<p>I think the main things you&rsquo;d lose with this merge-only workflow (relative to
using rebase) are:</p>

<ul>
<li>you have to look at some &ldquo;merge&rdquo; commits when you run <code>git log main..mybranch</code></li>
<li>you have to squash all your commits, so you can&rsquo;t have 2 separate commits</li>
<li>The &ldquo;clean up with <code>git reset</code>&rdquo; workflow is dangerous in a different way than using rebase</li>
</ul>

<p>I&rsquo;ve never tried this, this is just me thinking out loud. I&rsquo;d like to hear if
anyone uses a similar workflow in practice though.</p>

<h3 id="there-are-more-problems-than-i-expected">there are more problems than I expected</h3>

<p>I went into this really feeling like &ldquo;rebase is fine, what could go wrong?&rdquo; But
many of these problems actually have happened to me in the past, it&rsquo;s just that
over the years I&rsquo;ve learned how to avoid or fix all of them.</p>

<p>And I&rsquo;ve never really seen anyone share best practices for rebase, other than
&ldquo;never force push to a shared branch&rdquo;. All of these honestly make me a lot more
reluctant to recommend using rebase.</p>

<p>To recap, I think these are my personal rebase rules I follow:</p>

<ul>
<li>stop a rebase if it&rsquo;s going badly instead of letting it finish (with <code>git rebase --abort</code>)</li>
<li>know how to use <code>git reflog</code> to undo a bad rebase</li>
<li>don&rsquo;t rebase a million tiny commits (instead do it in 2 steps: <code>git rebase -i HEAD^^^^</code> and then <code>git rebase main</code>)</li>
<li>don&rsquo;t do more than one thing in a <code>git rebase -i</code>. Keep it simple.</li>
<li>never force push to a shared branch</li>
<li>never rebase commits that have already been pushed to <code>main</code></li>
</ul>

<p><small>
Thanks to Marco Rogers for encouraging me to think about the problems people
have with rebase, and to everyone on Mastodon who helped with this.
</small></p>

  </body>
</html>
