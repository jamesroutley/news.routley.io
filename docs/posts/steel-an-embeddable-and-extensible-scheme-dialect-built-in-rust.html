<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mattwparas/steel">Original</a>
    <h1>Steel – An embeddable and extensible scheme dialect built in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/mattwparas/steel/blob/master/images/styled.png"><img width="150px" src="https://github.com/mattwparas/steel/raw/master/images/styled.png"/></a>
</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-getting-started" aria-hidden="true" tabindex="-1" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting Started</h2>
<p dir="auto">This github repository contains a cli interpreter. To try it out on the online playground, go to the <a href="https://mattwparas.github.io/steel-playground/dev" rel="nofollow">Steel playground</a>. To get started using a repl with the crates, make sure you first have rust installed.</p>
<p dir="auto">Then, clone the repo and run the following command:</p>

<p dir="auto">This will launch a REPL instance that looks something like this:</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/mattwparas/steel/blob/master/images/repl.gif"><img src="https://github.com/mattwparas/steel/raw/master/images/repl.gif" width="100%" data-animated-image=""/></a>
</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-packages" aria-hidden="true" tabindex="-1" href="#packages"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Packages</h3>
<p dir="auto">If you would like to install and use packages, please set the <code>STEEL_HOME</code> environment variable. This will be the location that packages get installed to. Steel currently does not assume any default.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-about" aria-hidden="true" tabindex="-1" href="#about"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>About</h2>
<p dir="auto"><code>Steel</code> is an embeddable scheme interpreter, with a standalone cli included as well. Inspired largely by Racket, the language seeks to be ergonomic scheme variant helpful for embedding in applications, or to be used on its own with high performance functions implemented in Rust. The language implementation itself contains a fairly powerful macro system based on the <code>syntax-rules</code> style and a bytecode virtual machine. At the moment, it is not explicitly compliant with any individual scheme specification.</p>
<blockquote>
<p dir="auto"><strong>Warning</strong>
The API is unstable with no guarantees, and may change at any time while pre 1.0. There are undoubtedly bugs that exist, and any major bug reports will be addressed quickly. That being said, I do use it as a daily driver for many scripting tasks myself.</p>
</blockquote>
<h2 tabindex="-1" dir="auto"><a id="user-content-features" aria-hidden="true" tabindex="-1" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Limited <code>syntax-rules</code> style macros are supported</li>
<li>Easy integration with Rust functions and structs</li>
<li>Easily call a script from rust or via a separate file</li>
<li>Efficient - common functions and data structures are optimized for performance (<code>map</code>, <code>filter</code>, etc)</li>
<li>Higher order Contracts</li>
<li>Built in immutable data structures include:
<ul dir="auto">
<li>lists</li>
<li>vectors</li>
<li>hashmaps</li>
<li>hashsets</li>
</ul>
</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-contracts" aria-hidden="true" tabindex="-1" href="#contracts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contracts</h2>
<p dir="auto">Inspired by Racket&#39;s higher order contracts, <code>Steel</code> implements* higher order contracts to enable design by contract, made easy with a <code>define/contract</code> macro for easier ergonomics. Racket makes use of a concept known as <em>blame</em> which seeks to identify the violating party - <code>Steel</code> does not quite have fully fleshed out blame but that is a work in progress. Here are some examples:</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; Simple flat contracts
(define/contract (test x y)
    (-&gt;/c even? even? odd?)
    (+ x y 1))

(test 2 2) ;; =&gt; 5

(define/contract (test-violation x y)
    (-&gt;/c even? even? odd?)
    (+ x y 1))

(test-violation 1 2) ;; contract violation
"><pre><span><span>;</span>; Simple flat contracts</span>
(define/contract (test x y)
    (-&gt;/c <span>even?</span> <span>even?</span> odd?)
    (<span>+</span> x y <span>1</span>))

(test <span>2</span> <span>2</span>) <span><span>;</span>; =&gt; 5</span>

(define/contract (test-violation x y)
    (-&gt;/c <span>even?</span> <span>even?</span> odd?)
    (<span>+</span> x y <span>1</span>))

(test-violation <span>1</span> <span>2</span>) <span><span>;</span>; contract violation</span>
</pre></div>
<p dir="auto">Contracts are implemented as <em>values</em>, so they are bound to functions. This enables the use of contract checking on functions themselves since functions can be passed around:</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; Higher order contracts, check on application
(define/contract (higher-order func y)
    (-&gt;/c (-&gt;/c even? odd?) even? even?)
    (+ 1 (func y)))

(higher-order (lambda (x) (+ x 1)) 2) ;; =&gt; 4

(define/contract (higher-order-violation func y)
    (-&gt;/c (-&gt;/c even? odd?) even? even?)
    (+ 1 (func y)))

(higher-order-violation (lambda (x) (+ x 2)) 2) ;; contract violation"><pre><span><span>;</span>; Higher order contracts, check on application</span>
(define/contract (higher-order func y)
    (-&gt;/c (-&gt;/c <span>even?</span> odd?) <span>even?</span> even?)
    (<span>+</span> <span>1</span> (func y)))

(higher-order (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>)) <span>2</span>) <span><span>;</span>; =&gt; 4</span>

(define/contract (higher-order-violation func y)
    (-&gt;/c (-&gt;/c <span>even?</span> odd?) <span>even?</span> even?)
    (<span>+</span> <span>1</span> (func y)))

(higher-order-violation (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>2</span>)) <span>2</span>) <span><span>;</span>; contract violation</span></pre></div>
<p dir="auto">Contracts on functions do not get checked until they are applied, so a function returning a <em>contracted</em> function won&#39;t cause a violation until that function is actually used:</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; More higher order contracts, get checked on application
(define/contract (output)
    (-&gt;/c (-&gt;/c string? int?))
    (lambda (x) 10))

(define/contract (accept func)
    (-&gt;/c (-&gt;/c string? int?) string?)
    &#34;cool cool cool&#34;)

(accept (output)) ;; =&gt; &#34;cool cool cool&#34;

;; different contracts on the argument
(define/contract (accept-violation func)
    (-&gt;/c (-&gt;/c string? string?) string?)
    (func &#34;applesauce&#34;)
    &#34;cool cool cool&#34;)

(accept-violation (output)) ;; contract violation

;; generates a function
(define/contract (generate-closure)
    (-&gt;/c (-&gt;/c string? int?))
    (lambda (x) 10))

;; calls generate-closure which should result in a contract violation
(define/contract (accept-violation)
    (-&gt;/c (-&gt;/c string? string?))
    (generate-closure))

((accept-violation) &#34;test&#34;) ;; contract violation"><pre><span><span>;</span>; More higher order contracts, get checked on application</span>
(define/contract (output)
    (-&gt;/c (-&gt;/c <span>string?</span> int?))
    (<span>lambda</span> (<span>x</span>) 10))

(define/contract (accept func)
    (-&gt;/c (-&gt;/c <span>string?</span> int?) string?)
    <span><span>&#34;</span>cool cool cool<span>&#34;</span></span>)

(accept (output)) <span><span>;</span>; =&gt; &#34;cool cool cool&#34;</span>

<span><span>;</span>; different contracts on the argument</span>
(define/contract (accept-violation func)
    (-&gt;/c (-&gt;/c <span>string?</span> string?) string?)
    (func <span><span>&#34;</span>applesauce<span>&#34;</span></span>)
    <span><span>&#34;</span>cool cool cool<span>&#34;</span></span>)

(accept-violation (output)) <span><span>;</span>; contract violation</span>

<span><span>;</span>; generates a function</span>
(define/contract (generate-closure)
    (-&gt;/c (-&gt;/c <span>string?</span> int?))
    (<span>lambda</span> (<span>x</span>) 10))

<span><span>;</span>; calls generate-closure which should result in a contract violation</span>
(define/contract (accept-violation)
    (-&gt;/c (-&gt;/c <span>string?</span> string?))
    (generate-closure))

((accept-violation) <span><span>&#34;</span>test<span>&#34;</span></span>) <span><span>;</span>; contract violation</span></pre></div>
<p dir="auto">Perhaps a more nuanced case:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(define/contract (output)
    (-&gt;/c (-&gt;/c string? int?))
    (lambda (x) 10.2))

(define/contract (accept)
    (-&gt;/c (-&gt;/c string? number?))
    (output))


((accept) &#34;test&#34;) ;; contract violation 10.2 satisfies number? but _not_ int?"><pre>(define/contract (output)
    (-&gt;/c (-&gt;/c <span>string?</span> int?))
    (<span>lambda</span> (<span>x</span>) 10.2))

(define/contract (accept)
    (-&gt;/c (-&gt;/c <span>string?</span> number?))
    (output))


((accept) <span><span>&#34;</span>test<span>&#34;</span></span>) <span><span>;</span>; contract violation 10.2 satisfies number? but _not_ int?</span></pre></div>
<p dir="auto">* Very much a work in progress</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-transducers" aria-hidden="true" tabindex="-1" href="#transducers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Transducers</h2>
<p dir="auto">Inspired by clojure&#39;s transducers, <code>Steel</code> has a similar object that is somewhere half way in between transducers and iterators. Consider the following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="
(mapping (lambda (x) (+ x 1))) ;; =&gt; &lt;#iterator&gt;
(filtering even?) ;; =&gt; &lt;#iterator&gt;
(taking 15) ;; =&gt; &lt;#iterator&gt;

(compose 
    (mapping add1)
    (filtering odd?)
    (taking 15)) ;; =&gt; &lt;#iterator&gt;"><pre>(mapping (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>))) <span><span>;</span>; =&gt; &lt;#iterator&gt;</span>
(filtering even?) <span><span>;</span>; =&gt; &lt;#iterator&gt;</span>
(taking <span>15</span>) <span><span>;</span>; =&gt; &lt;#iterator&gt;</span>

(compose 
    (mapping add1)
    (filtering odd?)
    (taking <span>15</span>)) <span><span>;</span>; =&gt; &lt;#iterator&gt;</span></pre></div>
<p dir="auto">Each of these expressions emit an <code>&lt;#iterator&gt;</code> object, which means they&#39;re compatible with  <code>transduce</code>. <code>transduce</code> takes a transducer (i.e. <code>&lt;#iterator&gt;</code>) and a collection that can be iterated (<code>list</code>, <code>vector</code>, <code>stream</code>, <code>hashset</code>, <code>hashmap</code>, <code>string</code>, <code>struct</code>) and applies the transducer.</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; Accepts lists
(transduce (list 1 2 3 4 5) (mapping (lambda (x) (+ x 1))) (into-list)) ;; =&gt; &#39;(2 3 4 5 6)

;; Accepts vectors
(transduce (vector 1 2 3 4 5) (mapping (lambda (x) (+ x 1))) (into-vector)) ;; &#39;#(2 3 4 5 6)

;; Even accepts streams!
(define (integers n)
    (stream-cons n (lambda () (integers (+ 1 n)))))

(transduce (integers 0) (taking 5) (into-list)) ;; =&gt; &#39;(0 1 2 3 4)"><pre><span><span>;</span>; Accepts lists</span>
(transduce (<span>list</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>) (mapping (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>))) (into-list)) <span><span>;</span>; =&gt; &#39;(2 3 4 5 6)</span>

<span><span>;</span>; Accepts vectors</span>
(transduce (vector <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>) (mapping (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>))) (into-vector)) <span><span>;</span>; &#39;#(2 3 4 5 6)</span>

<span><span>;</span>; Even accepts streams!</span>
(<span>define</span> (<span>integers</span><span> n</span>)
    (stream-cons n (<span>lambda</span> () (integers (<span>+</span> <span>1</span> n)))))

(transduce (integers <span>0</span>) (taking <span>5</span>) (into-list)) <span><span>;</span>; =&gt; &#39;(0 1 2 3 4)</span></pre></div>
<p dir="auto">Transduce accepts a reducer function as well. Above we used <code>into-list</code> and <code>into-vector</code>, but below we can use any arbitrary reducer:</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; (-&gt; transducer reducing-function initial-value iterable)
(transduce (list 0 1 2 3) (mapping (lambda (x) (+ x 1))) (into-reducer + 0)) ;; =&gt; 10"><pre><span><span>;</span>; (-&gt; transducer reducing-function initial-value iterable)</span>
(transduce (<span>list</span> <span>0</span> <span>1</span> <span>2</span> <span>3</span>) (mapping (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>))) (into-reducer <span>+</span> <span>0</span>)) <span><span>;</span>; =&gt; 10</span></pre></div>
<p dir="auto">Compose just combines the iterator functions and lets us avoid intermediate allocation. The composition works left to right - it chains each value through the functions and then accumulates into the output type. See the following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(define xf 
    (compose 
        (mapping add1)
        (filtering odd?)
        (taking 5)))

(transduce (range 0 100) xf (into-list)) ;; =&gt; &#39;(1 3 5 7 9)"><pre>(<span>define</span> <span>xf</span> 
    (compose 
        (mapping add1)
        (filtering odd?)
        (taking <span>5</span>)))

(transduce (range <span>0</span> <span>100</span>) xf (into-list)) <span><span>;</span>; =&gt; &#39;(1 3 5 7 9)</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-syntax-choices" aria-hidden="true" tabindex="-1" href="#syntax-choices"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Syntax Choices</h2>
<p dir="auto"><code>Steel</code> is mildly opinionated in that there a few ways to define variables and functions. These choices are fairly arbitrary except for the shorthand function syntax, which I borrowed from Racket. <code>defn</code> and <code>fn</code> were really encouraged by me wanting to type less characters.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
;; All of the following are equivalent
(define (foo x) (+ x 1))
(define foo (lambda (x) (+ x 1)))
(defn (foo x) (+ x 1))
(defn foo (lambda (x) (+ x 1)))

;; All of the following are equivalent
(lambda (x) (+ x 1))
(λ (x) (+ x 1))
(fn (x) (+ x 1))"><pre><span><span>;</span>; All of the following are equivalent</span>
(<span>define</span> (<span>foo</span><span> x</span>) (<span>+</span> x <span>1</span>))
(<span>define</span> <span>foo</span> (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>)))
(defn (<span>foo</span> x) (<span>+</span> x <span>1</span>))
(defn <span>foo</span> (<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>)))

<span><span>;</span>; All of the following are equivalent</span>
(<span>lambda</span> (<span>x</span>) (<span>+</span> x <span>1</span>))
(λ (x) (<span>+</span> x <span>1</span>))
(fn (x) (<span>+</span> x <span>1</span>))</pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-modules" aria-hidden="true" tabindex="-1" href="#modules"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Modules</h2>
<p dir="auto">In order to support a growing codebase, Steel has module support for projects spanning multiple files. Steel files can <code>provide</code> values (with contracts attached) and <code>require</code> modules from other files:</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; main.scm
(require &#34;provide.scm&#34;)

(even-&gt;odd 10)


;; provide.scm
(provide 
    (contract/out even-&gt;odd (-&gt;/c even? odd?))
    no-contract
    flat-value)

(define (even-&gt;odd x) 
    (+ x 1))

(define (accept-number x) (+ x 10))

(define (no-contract) &#34;cool cool cool&#34;)
(define flat-value 15)

(displayln &#34;Calling even-&gt;odd with some bad inputs but its okay&#34;)
(displayln (even-&gt;odd 1))"><pre><span><span>;</span>; main.scm</span>
(require <span><span>&#34;</span>provide.scm<span>&#34;</span></span>)

(even-&gt;odd <span>10</span>)


<span><span>;</span>; provide.scm</span>
(provide 
    (contract/out even-&gt;odd (-&gt;/c <span>even?</span> odd?))
    no-contract
    flat-value)

(<span>define</span> (<span>even-&gt;odd</span><span> x</span>) 
    (<span>+</span> x <span>1</span>))

(<span>define</span> (<span>accept-number</span><span> x</span>) (<span>+</span> x <span>10</span>))

(<span>define</span> (<span>no-contract</span>) &#34;cool cool cool&#34;)
(<span>define</span> <span>flat-value</span> 15)

(displayln <span><span>&#34;</span>Calling even-&gt;odd with some bad inputs but its okay<span>&#34;</span></span>)
(displayln (even-&gt;odd <span>1</span>))</pre></div>
<p dir="auto">Here we can see if we were to run <code>main</code> that it would include the contents of <code>provide</code>, and only provided values would be accessible from <code>main</code>. The contract is attached at the contract boundary, so inside the <code>provide</code> module, you can violate the contract, but outside the module the contract will be applied.</p>
<p dir="auto">A few notes on modules:</p>
<ul dir="auto">
<li>Cyclical dependencies are not allowed</li>
<li>Modules will be only compiled once and used across multiple files. If <code>A</code> requires <code>B</code> and <code>C</code>, and <code>B</code> requires <code>C</code>, <code>C</code> will be compiled once and shared between <code>A</code> and <code>B</code>.</li>
<li>Modules will be recompiled when changed, and any dependent files will also be recompiled as necessary</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-performance" aria-hidden="true" tabindex="-1" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto">Preliminary benchmarks show the following on my machine:</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Steel</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>(fib 28)</td>
<td>63.383ms</td>
<td>65.10 ms</td>
</tr>
<tr>
<td>(ack 3 3)</td>
<td>0.303 ms</td>
<td>0.195 ms</td>
</tr>
</tbody>
</table>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples-of-embedding-rust-values-in-the-virtual-machine" aria-hidden="true" tabindex="-1" href="#examples-of-embedding-rust-values-in-the-virtual-machine"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples of embedding Rust values in the virtual machine</h2>
<p dir="auto">Rust values, types, and functions are easily embedded into Steel. Using the <code>register_fn</code> call, you can embed functions easily:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use steel_vm::engine::Engine;
use steel_vm::register_fn::RegisterFn;

fn external_function(arg1: usize, arg2: usize) -&gt; usize {
    arg1 + arg2
}

fn option_function(arg1: Option&lt;String&gt;) -&gt; Option&lt;String&gt; {
    arg1
}

fn result_function(arg1: Option&lt;String&gt;) -&gt; Result&lt;String, String&gt; {
    if let Some(inner) = arg1 {
        Ok(inner)
    } else {
        Err(&#34;Got a none&#34;.to_string())
    }
}

pub fn main() {
    let mut vm = Engine::new();

    // Here we can register functions
    // Any function can accept parameters that implement `FromSteelVal` and
    // return values that implement `IntoSteelVal`
    vm.register_fn(&#34;external-function&#34;, external_function);

    // See the docs for more information about `FromSteelVal` and `IntoSteelVal`
    // but we can see even functions that accept/return Option&lt;T&gt; or Result&lt;T,E&gt;
    // can be registered
    vm.register_fn(&#34;option-function&#34;, option_function);

    // Result values will map directly to errors in the VM and bubble back up
    vm.register_fn(&#34;result-function&#34;, result_function);

    vm.run(
        r#&#34;
        (define foo (external-function 10 25))
        (define bar (option-function &#34;applesauce&#34;))
        (define baz (result-function &#34;bananas&#34;))
    &#34;#,
    )
    .unwrap();

    let foo = vm.extract::&lt;usize&gt;(&#34;foo&#34;).unwrap();
    println!(&#34;foo: {}&#34;, foo);
    assert_eq!(35, foo);

    // Can also extract a value by specifying the type on the variable
    let bar: String = vm.extract(&#34;bar&#34;).unwrap();
    println!(&#34;bar: {}&#34;, bar);
    assert_eq!(&#34;applesauce&#34;.to_string(), bar);

    let baz: String = vm.extract(&#34;baz&#34;).unwrap();
    println!(&#34;baz: {}&#34;, baz);
    assert_eq!(&#34;bananas&#34;.to_string(), baz);
}"><pre><span>use</span> steel_vm<span>::</span>engine<span>::</span><span>Engine</span><span>;</span>
<span>use</span> steel_vm<span>::</span>register_fn<span>::</span><span>RegisterFn</span><span>;</span>

<span>fn</span> <span>external_function</span><span>(</span><span>arg1</span><span>:</span> <span>usize</span><span>,</span> <span>arg2</span><span>:</span> <span>usize</span><span>)</span> -&gt; <span>usize</span> <span>{</span>
    arg1 + arg2
<span>}</span>

<span>fn</span> <span>option_function</span><span>(</span><span>arg1</span><span>:</span> <span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span><span>)</span> -&gt; <span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>{</span>
    arg1
<span>}</span>

<span>fn</span> <span>result_function</span><span>(</span><span>arg1</span><span>:</span> <span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span><span>)</span> -&gt; <span>Result</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>&gt;</span> <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span><span>(</span>inner<span>)</span> = arg1 <span>{</span>
        <span>Ok</span><span>(</span>inner<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>Err</span><span>(</span><span>&#34;Got a none&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> vm = <span>Engine</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

    <span>// Here we can register functions</span>
    <span>// Any function can accept parameters that implement `FromSteelVal` and</span>
    <span>// return values that implement `IntoSteelVal`</span>
    vm<span>.</span><span>register_fn</span><span>(</span><span>&#34;external-function&#34;</span><span>,</span> external_function<span>)</span><span>;</span>

    <span>// See the docs for more information about `FromSteelVal` and `IntoSteelVal`</span>
    <span>// but we can see even functions that accept/return Option&lt;T&gt; or Result&lt;T,E&gt;</span>
    <span>// can be registered</span>
    vm<span>.</span><span>register_fn</span><span>(</span><span>&#34;option-function&#34;</span><span>,</span> option_function<span>)</span><span>;</span>

    <span>// Result values will map directly to errors in the VM and bubble back up</span>
    vm<span>.</span><span>register_fn</span><span>(</span><span>&#34;result-function&#34;</span><span>,</span> result_function<span>)</span><span>;</span>

    vm<span>.</span><span>run</span><span>(</span>
        <span>r#&#34;</span>
<span>        (define foo (external-function 10 25))</span>
<span>        (define bar (option-function &#34;applesauce&#34;))</span>
<span>        (define baz (result-function &#34;bananas&#34;))</span>
<span>    &#34;#</span><span>,</span>
    <span>)</span>
    <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>

    <span>let</span> foo = vm<span>.</span><span>extract</span><span>::</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>(</span><span>&#34;foo&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;foo: {}&#34;</span>, foo<span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span><span>35</span>, foo<span>)</span><span>;</span>

    <span>// Can also extract a value by specifying the type on the variable</span>
    <span>let</span> bar<span>:</span> <span>String</span> = vm<span>.</span><span>extract</span><span>(</span><span>&#34;bar&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;bar: {}&#34;</span>, bar<span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span><span>&#34;applesauce&#34;</span>.to_string<span>(</span><span>)</span>, bar<span>)</span><span>;</span>

    <span>let</span> baz<span>:</span> <span>String</span> = vm<span>.</span><span>extract</span><span>(</span><span>&#34;baz&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;baz: {}&#34;</span>, baz<span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span><span>&#34;bananas&#34;</span>.to_string<span>(</span><span>)</span>, baz<span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">We can also embed structs themselves:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use steel_vm::engine::Engine;
use steel_vm::register_fn::RegisterFn;

use steel_derive::Steel;

// In order to register a type with Steel,
// it must implement Clone, Debug, and Steel
#[derive(Clone, Debug, Steel, PartialEq)]
pub struct ExternalStruct {
    foo: usize,
    bar: String,
    baz: f64,
}

impl ExternalStruct {
    pub fn new(foo: usize, bar: String, baz: f64) -&gt; Self {
        ExternalStruct { foo, bar, baz }
    }

    // Embedding functions that take self by value
    pub fn method_by_value(self) -&gt; usize {
        self.foo
    }

    pub fn method_by_reference(&amp;self) -&gt; usize {
        self.foo
    }

    // Setters should update the value and return a new instance (functional set)
    pub fn set_foo(mut self, foo: usize) -&gt; Self {
        self.foo = foo;
        self
    }
}

pub fn main() {
    let mut vm = Engine::new();

    // Registering a type gives access to a predicate for the type
    vm.register_type::&lt;ExternalStruct&gt;(&#34;ExternalStruct?&#34;);

    // Structs in steel typically have a constructor that is the name of the struct
    vm.register_fn(&#34;ExternalStruct&#34;, ExternalStruct::new);

    // register_fn can be chained
    vm.register_fn(&#34;method-by-value&#34;, ExternalStruct::method_by_value)
        .register_fn(&#34;method-by-reference&#34;, ExternalStruct::method_by_reference)
        .register_fn(&#34;set-foo&#34;, ExternalStruct::set_foo);

    let external_struct = ExternalStruct::new(1, &#34;foo&#34;.to_string(), 12.4);

    // Registering an external value is fallible if the conversion fails for some reason
    // For instance, registering an Err(T) is fallible. However, most implementation outside of manual
    // ones should not fail
    vm.register_external_value(&#34;external-struct&#34;, external_struct)
        .unwrap();

    let output = vm
        .run(
            r#&#34;
            (define new-external-struct (set-foo external-struct 100))
            (define get-output (method-by-value external-struct))
            (define second-new-external-struct (ExternalStruct 50 &#34;bananas&#34; 72.6))
            &#34;last-result&#34;
        &#34;#,
        )
        .unwrap();

    let new_external_struct = vm.extract::&lt;ExternalStruct&gt;(&#34;new-external-struct&#34;).unwrap();
    println!(&#34;new_external_struct: {:?}&#34;, new_external_struct);
    assert_eq!(
        ExternalStruct::new(100, &#34;foo&#34;.to_string(), 12.4),
        new_external_struct
    );

    // Can also extract a value by specifying the type on the variable
    let get_output: usize = vm.extract(&#34;get-output&#34;).unwrap();
    println!(&#34;get_output: {}&#34;, get_output);
    assert_eq!(1, get_output);

    let second_new_external_struct: ExternalStruct =
        vm.extract(&#34;second-new-external-struct&#34;).unwrap();
    println!(
        &#34;second_new_external_struct: {:?}&#34;,
        second_new_external_struct
    );
    assert_eq!(
        ExternalStruct::new(50, &#34;bananas&#34;.to_string(), 72.6),
        second_new_external_struct
    );

    // We also get the output of the VM as the value of every expression run
    // we can inspect the results just by printing like so
    println!(&#34;{:?}&#34;, output);
}"><pre><span>use</span> steel_vm<span>::</span>engine<span>::</span><span>Engine</span><span>;</span>
<span>use</span> steel_vm<span>::</span>register_fn<span>::</span><span>RegisterFn</span><span>;</span>

<span>use</span> steel_derive<span>::</span><span>Steel</span><span>;</span>

<span>// In order to register a type with Steel,</span>
<span>// it must implement Clone, Debug, and Steel</span>
<span>#<span>[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Debug</span><span>,</span> <span>Steel</span><span>,</span> <span>PartialEq</span><span>)</span><span>]</span></span>
<span>pub</span> <span>struct</span> <span>ExternalStruct</span> <span>{</span>
    <span>foo</span><span>:</span> <span>usize</span><span>,</span>
    <span>bar</span><span>:</span> <span>String</span><span>,</span>
    <span>baz</span><span>:</span> <span>f64</span><span>,</span>
<span>}</span>

<span>impl</span> <span>ExternalStruct</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span><span>foo</span><span>:</span> <span>usize</span><span>,</span> <span>bar</span><span>:</span> <span>String</span><span>,</span> <span>baz</span><span>:</span> <span>f64</span><span>)</span> -&gt; <span>Self</span> <span>{</span>
        <span>ExternalStruct</span> <span>{</span> foo<span>,</span> bar<span>,</span> baz <span>}</span>
    <span>}</span>

    <span>// Embedding functions that take self by value</span>
    <span>pub</span> <span>fn</span> <span>method_by_value</span><span>(</span><span>self</span><span>)</span> -&gt; <span>usize</span> <span>{</span>
        <span>self</span><span>.</span><span>foo</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>method_by_reference</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>usize</span> <span>{</span>
        <span>self</span><span>.</span><span>foo</span>
    <span>}</span>

    <span>// Setters should update the value and return a new instance (functional set)</span>
    <span>pub</span> <span>fn</span> <span>set_foo</span><span>(</span><span>mut</span> <span>self</span><span>,</span> <span>foo</span><span>:</span> <span>usize</span><span>)</span> -&gt; <span>Self</span> <span>{</span>
        <span>self</span><span>.</span><span>foo</span> = foo<span>;</span>
        <span>self</span>
    <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> vm = <span>Engine</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

    <span>// Registering a type gives access to a predicate for the type</span>
    vm<span>.</span><span>register_type</span><span>::</span><span>&lt;</span><span>ExternalStruct</span><span>&gt;</span><span>(</span><span>&#34;ExternalStruct?&#34;</span><span>)</span><span>;</span>

    <span>// Structs in steel typically have a constructor that is the name of the struct</span>
    vm<span>.</span><span>register_fn</span><span>(</span><span>&#34;ExternalStruct&#34;</span><span>,</span> <span>ExternalStruct</span><span>::</span>new<span>)</span><span>;</span>

    <span>// register_fn can be chained</span>
    vm<span>.</span><span>register_fn</span><span>(</span><span>&#34;method-by-value&#34;</span><span>,</span> <span>ExternalStruct</span><span>::</span>method_by_value<span>)</span>
        <span>.</span><span>register_fn</span><span>(</span><span>&#34;method-by-reference&#34;</span><span>,</span> <span>ExternalStruct</span><span>::</span>method_by_reference<span>)</span>
        <span>.</span><span>register_fn</span><span>(</span><span>&#34;set-foo&#34;</span><span>,</span> <span>ExternalStruct</span><span>::</span>set_foo<span>)</span><span>;</span>

    <span>let</span> external_struct = <span>ExternalStruct</span><span>::</span><span>new</span><span>(</span><span>1</span><span>,</span> <span>&#34;foo&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>,</span> <span>12.4</span><span>)</span><span>;</span>

    <span>// Registering an external value is fallible if the conversion fails for some reason</span>
    <span>// For instance, registering an Err(T) is fallible. However, most implementation outside of manual</span>
    <span>// ones should not fail</span>
    vm<span>.</span><span>register_external_value</span><span>(</span><span>&#34;external-struct&#34;</span><span>,</span> external_struct<span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>

    <span>let</span> output = vm
        <span>.</span><span>run</span><span>(</span>
            <span>r#&#34;</span>
<span>            (define new-external-struct (set-foo external-struct 100))</span>
<span>            (define get-output (method-by-value external-struct))</span>
<span>            (define second-new-external-struct (ExternalStruct 50 &#34;bananas&#34; 72.6))</span>
<span>            &#34;last-result&#34;</span>
<span>        &#34;#</span><span>,</span>
        <span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>

    <span>let</span> new_external_struct = vm<span>.</span><span>extract</span><span>::</span><span>&lt;</span><span>ExternalStruct</span><span>&gt;</span><span>(</span><span>&#34;new-external-struct&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;new_external_struct: {:?}&#34;</span>, new_external_struct<span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span>
        <span>ExternalStruct</span>::new<span>(</span><span>100</span>, <span>&#34;foo&#34;</span>.to_string<span>(</span><span>)</span>, <span>12.4</span><span>)</span>,
        new_external_struct
    <span>)</span><span>;</span>

    <span>// Can also extract a value by specifying the type on the variable</span>
    <span>let</span> get_output<span>:</span> <span>usize</span> = vm<span>.</span><span>extract</span><span>(</span><span>&#34;get-output&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;get_output: {}&#34;</span>, get_output<span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span><span>1</span>, get_output<span>)</span><span>;</span>

    <span>let</span> second_new_external_struct<span>:</span> <span>ExternalStruct</span> =
        vm<span>.</span><span>extract</span><span>(</span><span>&#34;second-new-external-struct&#34;</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>println</span><span>!</span><span>(</span>
        <span>&#34;second_new_external_struct: {:?}&#34;</span>,
        second_new_external_struct
    <span>)</span><span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span>
        <span>ExternalStruct</span>::new<span>(</span><span>50</span>, <span>&#34;bananas&#34;</span>.to_string<span>(</span><span>)</span>, <span>72.6</span><span>)</span>,
        second_new_external_struct
    <span>)</span><span>;</span>

    <span>// We also get the output of the VM as the value of every expression run</span>
    <span>// we can inspect the results just by printing like so</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;{:?}&#34;</span>, output<span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">See the examples folder for more examples on embedding values and interacting with the outside world.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-license" aria-hidden="true" tabindex="-1" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License</h2>
<p dir="auto">Licensed under either of</p>
<ul dir="auto">
<li>Apache License, Version 2.0
(<a href="https://github.com/mattwparas/steel/blob/master/LICENSE-APACHE">LICENSE-APACHE</a> or <a href="http://www.apache.org/licenses/LICENSE-2.0" rel="nofollow">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license
(<a href="https://github.com/mattwparas/steel/blob/master/LICENSE-MIT">LICENSE-MIT</a> or <a href="http://opensource.org/licenses/MIT" rel="nofollow">http://opensource.org/licenses/MIT</a>)</li>
</ul>
<p dir="auto">at your option.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-contribution" aria-hidden="true" tabindex="-1" href="#contribution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contribution</h2>
<p dir="auto">Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.</p>
<p dir="auto">See [CONTRIBUTING.md].</p>
</article>
          </div></div>
  </body>
</html>
