<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.moderntreasury.com/journal/reconciliation-is-a-knapsack-problem">Original</a>
    <h1>Reconciliation is a Knapsack problem</h1>
    
    <div id="readability-page-1" class="page"><div><p>Certain workflows in transaction reconciliation are <a href="https://www.moderntreasury.com/journal/adding-ai-to-modern-treasury-reconciliation" tabindex="0">well-suited to AI</a>, while others are math problems well-suited to deterministic <a href="#c38d26b03013">engines.</a></p><p>Imagine we have 10 identical $1 payments that we need to reconcile. Typically, on a bank statement, we would see some of those batched together, and they would appear something like this:</p><div><div><table><tbody><tr><th>Transactions</th></tr><tr><td>$3</td></tr><tr><td>$2</td></tr><tr><td>$1</td></tr><tr><td>$1</td></tr><tr><td>$1</td></tr><tr><td>$1</td></tr><tr><td>$1</td></tr></tbody></table></div></div><p>This totals $10, which is what we were expecting. Now, we need to match our business payments to these transactions.</p><p>Imagine our payments are tagged A through K (omitting “I” for readability). So, one possible solution to our reconciliation problem is this:</p><div><div><table><tbody><tr><th>Transactions</th><th>Payment Tags</th></tr><tr><td>$3</td><td>ABC</td></tr><tr><td>$2</td><td>DE</td></tr><tr><td>$1</td><td>F</td></tr><tr><td>$1</td><td>G</td></tr><tr><td>$1</td><td>H</td></tr><tr><td>$1</td><td>J</td></tr><tr><td>$1</td><td>K</td></tr></tbody></table></div></div><p>The question is, <em>how many other possible solutions are there?</em> If we solve the batches individually, we are selecting from a list of 10 items to put three into our “solution,” which follows this formula:</p><div><figure><img alt="Formula for possible solutions" src="https://cdn.sanity.io/images/8nmbzj0x/production/e8f037f4591b8e1dc4910c8a809e92b515f9943c-816x325.svg" width="816" height="325" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>Formula for possible solutions</figcaption><p>And equals:</p><div><figure><img alt="applied formula" src="https://cdn.sanity.io/images/8nmbzj0x/production/5111d0c94ecf753f221934ce43408f6426fb42a8-816x325.svg" width="816" height="325" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>Applied formula for three of 10 $1 payments</figcaption><p>Once that’s solved, we do the same with the $2 batch.</p><div><figure><img alt="applied formula 2" src="https://cdn.sanity.io/images/8nmbzj0x/production/304e6a895e0c868fb832d00d1a373a13b2a55a15-816x325.svg" width="816" height="325" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>Applied formula for two of 10 $1 payments</figcaption><p>And finally, we have to match the remaining five transactions. That’s an easier problem to manage, since it’s one-to-one matching, so the number of possibilities is:</p><div><figure><img alt="applied formula 3" src="https://cdn.sanity.io/images/8nmbzj0x/production/639d2549ff55d24d98454771fe09c40e9b08009a-816x325.svg" width="816" height="325" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>Applied formula for the remaining $1 payments</figcaption><p>The total number of possibilities—if you’re trying to solve all of this at once, as we are—becomes:</p><div><figure><img alt="total possibilities" src="https://cdn.sanity.io/images/8nmbzj0x/production/be1d05eaca84424527d45e63c3652586437b1b10-816x325.svg" width="816" height="325" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>Total number of possible matches</figcaption><p>That’s a lot of possible solutions. In Computer Science terms, this type of problem is a specific variant of the <a href="https://developers.google.com/optimization/pack/knapsack" tabindex="0" target="_blank" rel="noreferrer">Knapsack problem</a>, where each item has the same weight. In the example I’ve been describing, the knapsacks are the bank statement transactions, and the items are the equally weighted $1 payments. It’s a combinatorial optimization problem for a computer.</p><p>This is why, in most cash reconciliation or audit environments, teams give up on 1:1 transaction matching and opt instead to ensure the totals are equal—because crunching 302,400 options just isn’t worth it.</p><p>But that’s what computers are good at! Reconciliation engines, like the one we’ve built at Modern Treasury, have seen a lot of transactions, and every time they see another, it adds to their ability to match. These engines are entirely deterministic, picking up on IDs and data en masse, allowing them to reconcile transactions with 100% confidence and repeatability. The consequence of picking the wrong match in finance is too high to use a probabilistic approach.</p><p>But of course, there are edge cases.</p><p>So imagine instead of 10 transactions, your business is processing one thousand $1 transactions per day, and you run those using a recon engine like Modern Treasury. Let’s say 99% of those payments reconcile automatically with software. But those pesky ten would still remain, and  though 10 out of 1000 doesn’t seem like that many, based on the math we just learned, it’s actually a lot. It’s a hard problem to solve.</p><p>This is where AI shines. Instead of trying to brute-force compute the way to a correct answer, you take in a bunch of real-world observations to train a model. It’s substituting abstract, mathematical determinism for a probabilistic model that is tuned to what our system is encountering in the real world at scale.</p><p>When you operate in money, the matches have to be 100% accurate. Therefore, the responsible way to use AI is to build it into workflows that humans oversee. It’s the combination of deterministic methods and AI that is a superpower against reconciliation as a knapsack problem. In our example, a deterministic reconciliation engine would operate in real-time for the 990 payments and near-real-time for the AI-suggested, human-approved 10 payments.</p><p>Interestingly, as we move into the new era of payments, where more money moves in real-time and settles instantly, the reconciliation challenge increases in multiple ways—first, speed. Teams running reconciliation processes need to find transaction matches, or knapsack objects, in real-time, whether that’s Sunday at 2am or the middle of Thursday afternoon.</p><p>Second, math. If, instead of showing up in a few batches, our payments arrive one by one, then we need to match this way:</p><div><div><table><tbody><tr><th>Non-batch transaction matching</th></tr><tr><td>1 - A</td></tr><tr><td>2 - B</td></tr><tr><td>3 - C</td></tr><tr><td>4 - D</td></tr><tr><td>5 - E</td></tr><tr><td>6 - F</td></tr><tr><td>7 - G</td></tr><tr><td>8 - H</td></tr><tr><td>9 - J</td></tr><tr><td>10 - K</td></tr></tbody></table></div></div><p>To which there are 10! answers, or 3,628,800 solutions. That’s too much to brute force. Luckily, these new payment rails, such as RTP and FedNow, include more remittance information to disambiguate payments as they come in. Companies will need to implement software to take advantage of these types of remittance information and not end up in a 3.6M solution quagmire.</p><p>Here’s an illustrative example. Imagine we are reconciling transactions for something related to real estate, where physical address is a regular component of the remittance information we receive in these real-time payments. If the physical address is 101 South State Street, it may show up in the text in multiple ways:</p><div><figure><img alt="State St Examples" src="https://cdn.sanity.io/images/8nmbzj0x/production/bd6536bae250324d84b5b07d2bff0c281a7f37a7-825x882.svg" width="825" height="882" decoding="async" data-nimg="1" loading="lazy"/></figure></div><figcaption>The possible ways the address can appear within the remittance information</figcaption><p>While it may be hard to deterministically model the three scenarios shown above, this is the type of thing that language models can do very easily.</p><p>Financial workflows are some of the best places to implement AI responsibly. The data is vast, and the solution space is even vaster, but the data is structured in a way that models can take advantage of.</p><p>If you have these kinds of high-volume reconciliation challenges,<a href="https://www.moderntreasury.com/talk-to-us" tabindex="0"> reach out to us</a>. Or send me a note if you want to nerd out on AI in money.</p></div></div>
  </body>
</html>
