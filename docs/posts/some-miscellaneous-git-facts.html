<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/10/20/some-miscellaneous-git-facts/">Original</a>
    <h1>Some miscellaneous git facts</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>I’ve been very slowly working on writing about how Git works. I thought I
already knew Git pretty well, but as usual when I try to explain something I’ve
been learning some new things.</p>

<p>None of these things feel super surprising in retrospect, but I hadn’t thought
about them clearly before.</p>

<p>The facts are:</p>

<ul>
<li><a href="#the-index-staging-area-and-cached-are-all-the-same-thing">the “index”, “staging area” and “–cached” are all the same thing</a></li>
<li><a href="#the-stash-is-a-bunch-of-commits">the stash is a bunch of commits</a></li>
<li><a href="#not-all-references-are-branches-or-tags">not all references are branches or tags</a></li>
<li><a href="#merge-commits-aren-t-empty">merge commits aren’t empty</a></li>
</ul>

<p>Let’s talk about them!</p>

<h3 id="the-index-staging-area-and-cached-are-all-the-same-thing">the “index”, “staging area” and “–cached” are all the same thing</h3>

<p>When you run <code>git add file.txt</code>, and then <code>git status</code>, you’ll see something like this:</p>

<pre><code>$ git add content/post/2023-10-20-some-miscellaneous-git-facts.markdown
$ git status
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
	new file:   content/post/2023-10-20-some-miscellaneous-git-facts.markdown
</code></pre>

<p>People usually call this “staging a file” or “adding a file to the staging area”.</p>

<p>When you stage a file with <code>git add</code>, behind the scenes git adds the file to its object
database (in <code>.git/objects</code>) and updates a file called <code>.git/index</code> to refer to
the newly added file.</p>

<p>This “staging area” actually gets referred to by 3 different names in Git. All
of these refer to the exact same thing (the file <code>.git/index</code>):</p>

<ul>
<li><code>git diff --cached</code></li>
<li><code>git diff --staged</code></li>
<li>the file <code>.git/index</code></li>
</ul>

<p>I felt like I should have realized this earlier, but I didn’t, so there it is.</p>

<h3 id="the-stash-is-a-bunch-of-commits">the stash is a bunch of commits</h3>

<p>When I run <code>git stash</code> to stash my changes, I’ve always been a bit confused
about where those changes actually went. It turns out that when you run <code>git
stash</code>, git makes some commits with your changes and labels them with a reference
called <code>stash</code> (in <code>.git/refs/stash</code>).</p>

<p>Let’s stash this blog post and look at the log of the <code>stash</code> reference:</p>

<pre><code>$ git log stash --oneline
6cb983fe (refs/stash) WIP on main: c6ee55ed wip
2ff2c273 index on main: c6ee55ed wip
... some more stuff
</code></pre>

<p>Now we can look at the commit <code>2ff2c273</code> to see what it contains:</p>

<pre><code>$ git show 2ff2c273  --stat
commit 2ff2c273357c94a0087104f776a8dd28ee467769
Author: Julia Evans &lt;julia@jvns.ca&gt;
Date:   Fri Oct 20 14:49:20 2023 -0400

    index on main: c6ee55ed wip

 content/post/2023-10-20-some-miscellaneous-git-facts.markdown | 40 ++++++++++++++++++++++++++++++++++++++++
</code></pre>

<p>Unsurprisingly, it contains this blog post. Makes sense!</p>

<p><code>git stash</code> actually creates 2 separate commits: one for the index, and one for
your changes that you haven’t staged yet. I found this kind of heartening
because I’ve been working on a tool to snapshot and restore the state of a git
repository (that I may or may not ever release) and I came up with a very
similar design, so that made me feel better about my choices.</p>

<p>Apparently older commits in the stash are stored in the reflog.</p>

<h3 id="not-all-references-are-branches-or-tags">not all references are branches or tags</h3>

<p>Git’s documentation often refers to “references” in a generic way that I find
a little confusing sometimes. Personally 99% of the time when I deal with
a “reference” in Git it’s a branch or <code>HEAD</code> and the other 1% of the time it’s a tag. I
actually didn’t know ANY examples of references that weren’t branches or tags or <code>HEAD</code>.</p>

<p>But now I know one example – the stash is a reference, and it’s not a branch
or tag! So that’s cool.</p>

<p>Here are all the references in my blog’s git repository (other than <code>HEAD</code>):</p>

<pre><code>$ find .git/refs -type f
.git/refs/heads/main
.git/refs/remotes/origin/HEAD
.git/refs/remotes/origin/main
.git/refs/stash
</code></pre>

<p>Some other references people mentioned in reponses to this post:</p>

<ul>
<li><code>refs/notes/*</code>, from  <a href="https://tylercipriani.com/blog/2022/11/19/git-notes-gits-coolest-most-unloved-feature/"><code>git notes</code></a></li>
<li><code>refs/pull/123/head</code>, and `<code>refs/pull/123/head</code> for GitHub pull requests  (which you can get with <code>git fetch origin refs/pull/123/merge</code>)</li>
<li><code>refs/bisect/*</code>, from <code>git bisect</code></li>
</ul>

<h3 id="merge-commits-aren-t-empty">merge commits aren’t empty</h3>

<p>Here’s a toy git repo where I created two branches <code>x</code> and <code>y</code>, each with 1
file (<code>x.txt</code> and <code>y.txt</code>) and merged them. Let’s look at the merge commit.</p>

<pre><code>$ git log --oneline
96a8afb (HEAD -&gt; y) Merge branch &#39;x&#39; into y
0931e45 y
1d8bd2d (x) x
</code></pre>

<p>If I run <code>git show 96a8afb</code>, the commit looks “empty”: there’s no diff!</p>

<pre><code>git show 96a8afb
commit 96a8afbf776c2cebccf8ec0dba7c6c765ea5d987 (HEAD -&gt; y)
Merge: 0931e45 1d8bd2d
Author: Julia Evans &lt;julia@jvns.ca&gt;
Date:   Fri Oct 20 14:07:00 2023 -0400

    Merge branch &#39;x&#39; into y
</code></pre>

<p>But if I diff the merge commit against each of its two parent commits
separately, you can see that of course there <strong>is</strong> a diff:</p>

<pre><code>$ git diff 0931e45 96a8afb   --stat
 x.txt | 1 +
 1 file changed, 1 insertion(+)
$ git diff 1d8bd2d 96a8afb   --stat
 y.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre>

<p>It seems kind of obvious in retrospect that merge commits aren’t actually “empty”
(they’re snapshots of the current state of the repo, just like any other
commit), but I’d never thought about why they appear to be empty.</p>

<p>Apparently the reason that these merge diffs are empty is that merge diffs only show <strong>conflicts</strong> – if I instead create a repo
with a merge conflict (one branch added <code>x</code> and another branch added <code>y</code> to the
same file), and show the merge commit where I resolved the conflict, it looks
like this:</p>

<pre><code>$ git show HEAD
commit 3bfe8311afa4da867426c0bf6343420217486594
Merge: 782b3d5 ac7046d
Author: Julia Evans &lt;julia@jvns.ca&gt;
Date:   Fri Oct 20 15:29:06 2023 -0400

    Merge branch &#39;x&#39; into y

diff --cc file.txt
index 975fbec,587be6b..b680253
--- a/file.txt
+++ b/file.txt
@@@ -1,1 -1,1 +1,1 @@@
- y
 -x
++z
</code></pre>

<p>It looks like this is trying to tell me that one branch added <code>x</code>, another
branch added <code>y</code>, and the merge commit resolved it by putting <code>z</code> instead.  But
in the earlier example, there was no conflict, so Git didn’t display a diff at all.</p>

<p><small>
(thanks to Jordi for telling me how merge diffs work)
</small></p>

<h3 id="that-s-all">that’s all!</h3>

<p>I’ll keep this post short, maybe I’ll write another blog post with more git
facts as I learn them.</p>

</div></div>
  </body>
</html>
