<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://biojulia.net/post/hardware/">Original</a>
    <h1>What scientists must know about hardware to write fast code (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p><strong>Find this notebook at <a href="https://github.com/jakobnissen/hardware_introduction">https://github.com/jakobnissen/hardware_introduction</a></strong></p>
<p>Programming is used in many fields of science today, where individual scientists often have to write custom code for their own projects. For most scientists, however, computer science is not their field of expertise; They have learned programming by necessity. I count myself as one of them. While we may be reasonably familiar with the <em>software</em> side of programming, we rarely have even a basic understanding of how computer <em>hardware</em> impacts code performance.</p>
<p>The aim of this tutorial is to give non-professional programmers a <em>brief</em> overview of the features of modern hardware that you must understand in order to write fast code. It will be a distillation of what have learned the last few years. This tutorial will use Julia because it allows these relatively low-level considerations to be demonstrated easily in a high-level, interactive language.</p>
<h3 id="this-is-not-a-guide-to-the-julia-programming-language">This is not a guide to the Julia programming language</h3>
<p>To write fast code, you must first understand your programming language and its idiosyncrasies. But this is <em>not</em> a guide to the Julia programming language. I recommend reading the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">performance tips section</a> of the Julia documentation.</p>
<h3 id="this-is-not-an-explanation-of-specific-datastructures-or-algorithms">This is not an explanation of specific datastructures or algorithms</h3>
<p>Besides knowing your language, you must also know your own code to make it fast. You must understand the idea behind big-O notation, why some algorithms are faster than others, and how different data structures work internally. Without knowing <em>what an <code>Array</code> is</em>, how could you possibly optimize code making use of arrays?</p>
<p>This too, is outside the scope of this paper. However, I would say that as a minimum, a programmer should have an understanding of:</p>
<ul>
<li>How a binary integer is represented in memory</li>
<li>How a floating point number is represented in memory (learning this is also necessary to understand computational inacurracies from floating point operations, which is a must when doing scientific programming)</li>
<li>The memory layout of a <code>String</code> including ASCII and UTF-8 encoding</li>
<li>The basics of how an <code>Array</code> is structured, and what the difference between a dense array of e.g. integers and an array of references to objects are</li>
<li>The principles behind how a <code>Dict</code> (i.e. hash table) and a <code>Set</code> works</li>
</ul>
<p>Furthermore, I would also recommend familiarizing yourself with:</p>
<ul>
<li>Heaps</li>
<li>Deques</li>
<li>Tuples</li>
</ul>
<h3 id="this-is-not-a-tutorial-on-benchmarking-your-code">This is not a tutorial on benchmarking your code</h3>
<p>To write fast code <em>in practice</em>, it is necessary to profile your code to find bottlenecks where your machine spends the majority of the time. One must benchmark different functions and approaches to find the fastest in practice. Julia (and other languages) have tools for exactly this purpose, but I will not cover them here.</p>
<h2 id="content">Content</h2>
<ul>
<li><a href="#disk">Minimize disk writes</a></li>
<li><a href="#cachemisses">CPU cache</a></li>
<li><a href="#alignment">Alignment</a></li>
<li><a href="#assembly">Inspect generated assembly</a></li>
<li><a href="#allocations">Minimize allocations</a></li>
<li><a href="#simd">Exploit SIMD vectorization</a></li>
<li><a href="#soa">Struct of arrays</a></li>
<li><a href="#instructions">Use specialized CPU instructions</a></li>
<li><a href="#inlining">Inline small functions</a></li>
<li><a href="#unrolling">Unroll tight loops</a></li>
<li><a href="#branches">Avoid unpredictable branches</a></li>
<li><a href="#multithreading">Multithreading</a></li>
<li><a href="#gpus">GPUs</a></li>
</ul>
<h2 id="before-you-begin-install-packages">Before you begin: Install packages</h2>
<pre><code># If you don&#39;t already have these packages installed, outcomment these lines and run it:
# using Pkg
# Pkg.add(&#34;BenchmarkTools&#34;)
# Pkg.add(&#34;StaticArrays&#34;)

using StaticArrays
using BenchmarkTools

&#34;Print median elapsed time of benchmark&#34;
function print_median(trial)
    println(&#34;Median time: &#34;, BenchmarkTools.prettytime(median(trial).time))
end;
</code></pre>
<h2 id="the-basic-structure-of-computer-hardware">The basic structure of computer hardware</h2>
<p>For now, we will work with a simplified mental model of a computer. Through this document, I will add more details to our model as they become relevant.</p>
</div></div>
  </body>
</html>
