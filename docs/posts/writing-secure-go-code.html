<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jarosz.dev/article/writing-secure-go-code/">Original</a>
    <h1>Writing secure Go code</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <div>
    

    <p><span>2024-11-02</span>
            
        

        

        
            <span>
                
                    
                    
                        <a href="https://jarosz.dev/categories/go/">Go</a>
                    
                
            </span>
        

        
    </p>

    
        

        <p>What does it mean to keep security in mind when writing Go code? Answering this question in one short article seems impossible. For this reason, we will narrow it down to a few specific practices.</p>
<p>They will lead to writing robust, secure and performant code when applied continuously.</p>
<ul>
<li>How do we stay informed about the Go security announcements?</li>
<li>How do we keep our Go code patched and up to date?</li>
<li>How do we test our Go code focusing on security and robustness?</li>
<li>What are CVEs, and where do we learn about the most common software vulnerabilities?</li>
</ul>
<h2 id="mailing-list">Mailing list</h2>
<p>Let’s start with the most obvious place - the Go mailing list. We need to subscribe to get all critical security information right from the source.
All releases that contain security fixes are announced to the <code><a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="7d1a12111c131a501c13131208131e183d1a12121a11181a0f12080d0e531e1210">[email protected]</a></code> list.
Once we subscribe to the list, we can be sure we won’t miss any important announcements.</p>
<h2 id="keeping-go-version-up-to-date">Keeping Go version up to date</h2>
<p>The second step is to keep the Go versions in our projects current. Even though we don’t use the latest and greatest language features, bumping the Go version gives us all security patches for discovered vulnerabilities. Also, the new Go version ensures compatibility with newer dependencies.
It protects our applications from potential integration issues.</p>
<p>The third step is to learn which security issues and CVEs are addressed in what Go releases. We can check it on the Go release history website and then update it to the latest version in the <code>go.mod</code> files in our projects.</p>
<p>After upgrading to new versions of Go, we should ensure that the operation does not introduce compatibility and dependency problems, especially with third-party packages. It can be more risky when we work on large projects with tens and sometimes hundreds of direct and indirect package dependencies.</p>
<p>The point is to maintain the risk by eliminating potential dependency problems. The problems may include an urgent need to refactor the existing code to make it work with a new dependency. Examples of such issues include changed packages, APIs or function signatures.</p>

<p>We can concentrate on the project source code after we know we will use the Go version without security issues. We can start assessing code quality and security by employing static code analysers.</p>
<h3 id="vet">vet</h3>
<p>Before installing and using third-party analysers, it’s a good idea to use the Go “native” <code>go vet</code> command.</p>
<p>We can use the <code>go vet</code> command to analyse our Go code. The <code>go vet</code> command without arguments runs the tool with all options allowed by default. The tool scans the source code and reports potential issues. The issues include code syntax errors and certain programming constructs that can cause problems during program executions.</p>
<p>Most common issues include goroutine mistakes, unused variables and unreachable areas of the codebase. The main advantage of using the <code>go vet</code> command is that it is a part of the Go toolbox.</p>
<p>In a separate article, we will dive deeper into the <code>vet</code> details. The extensive documentation and examples are on the <code>go vet</code> <a href="https://golang.google.cn/cmd/vet/">website</a>.</p>
<h3 id="staticcheck">staticcheck</h3>
<p>Staticcheck is another static code analyser. It’s a third-party linter that helps to find bugs and detects possible performance problems. It also enforces Go language styling. It offers code simplifications, explains discovered issues and suggests corrections with examples.</p>
<p>Besides running staticcheck in a CI pipeline, we can install <code>staticcheck</code> on our laptops as a standalone binary and scan the code locally. Let’s install the latest version:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>go install honnef.co/go/tools/cmd/staticcheck@latest
</span></span></code></pre></div><p>No errors on the terminal? If so, we are ready to run the scans. But first, let’s check the installed version to ensure everything looks good.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>staticcheck --version
</span></span><span><span>staticcheck 2024.1.1 <span>(</span>0.5.1<span>)</span>
</span></span></code></pre></div><p>Similarly to the <code>go vet</code>, running <code>staticcheck</code> without arguments invokes all code analysers by default. This approach plays nicely with the UNIX programming philosophy of using sensible defaults and not forcing users to do unnecessary paperwork.</p>
<p>Let’s see what the tool can find in the <a href="https://github.com/nginx/agent">NGINX Agent</a> GitHub repository. First, we need to clone it:</p>
<p>Then, we can run it from the root directory of the project:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  agent git:<span>(</span>main<span>)</span> ✗ staticcheck ./...
</span></span></code></pre></div><p>After a short moment, we are ready to check the scanning results. We can categorise the listed examples into three groups:</p>
<ul>
<li>packages, methods or functions that are deprecated, for example:</li>
</ul>
<div><pre tabindex="0"><code data-lang="shell"><span><span>...
</span></span><span><span>src/core/metrics/sources/cpu.go:111:9: times.Total is deprecated: Total returns the total number of seconds in a CPUTimesStat Please <span>do</span> not use this internal <span>function</span>. <span>(</span>SA1019<span>)</span>
</span></span><span><span>...
</span></span><span><span>test/component/nginx-app-protect/monitoring/monitoring_test.go:15:8: <span>&#34;github.com/golang/protobuf/jsonpb&#34;</span> is deprecated: Use the <span>&#34;google.golang.org/protobuf/encoding/protojson&#34;</span> package instead. <span>(</span>SA1019<span>)</span>
</span></span></code></pre></div><ul>
<li>unused variables and fields, for example:</li>
</ul>
<div><pre tabindex="0"><code data-lang="shell"><span><span>src/core/metrics/sources/nginx_plus.go:74:2: field endpoints is unused <span>(</span>U1000<span>)</span>
</span></span><span><span>src/core/metrics/sources/nginx_plus.go:75:2: field streamEndpoints is unused <span>(</span>U1000<span>)</span>
</span></span><span><span>src/core/metrics/sources/nginx_plus_test.go:94:2: var availableZones is unused <span>(</span>U1000<span>)</span>
</span></span></code></pre></div><ul>
<li>possible problems related to the quality of the code, for example:</li>
</ul>
<div><pre tabindex="0"><code data-lang="shell"><span><span>src/core/nginx.go:791:4: ineffective break statement. Did you mean to break out of the outer loop? <span>(</span>SA4011<span>)</span>
</span></span></code></pre></div><p>Now, we are ready to start analysing the highlighted issues. A detailed deep dive into the codebase is outside this introductory article’s scope. We will do deeper code analysis, show examples, and fix security and performance issues in upcoming articles.</p>
<p>For now, let’s take note of CWE websites that contain tons of information about listed weaknesses so we can study them at a later time:</p>
<ul>
<li>Unused variables <a href="https://cwe.mitre.org/data/definitions/563.html">CWE-563</a></li>
<li>Using deprecated constructs <a href="https://cwe.mitre.org/data/definitions/477.html">CWE-477</a></li>
</ul>
<h3 id="golangci-lint">golangci-lint</h3>
<p>The third code analyser we are going to employ is <code>golangci-lint</code>. As with all Go tools, we can install it in a variety of ways, including the <code>go install</code> command:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
</span></span></code></pre></div><p>Let’s verify if the installation went well and check the version:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>golangci-lint --version
</span></span><span><span>golangci-lint has version v1.61.0 built with go1.23.2
</span></span><span><span>...
</span></span></code></pre></div><p>Perfect! All looks good.</p>
<p>Following the same principle of the least surprise, <code>golangci-lint</code> runs all linters when we invoke it with no arguments.</p>
<blockquote>
<p>Rule of Least Surprise: In interface design, always do the least surprising thing.</p>
</blockquote>
<p>What happens when we check the cloned earlier <code>agent</code> repository? Will <code>golangci-lint</code> show us the same warnings and suggestions? Let’s find out.</p>
<p>As previously, we will start scanning the project from its root directory.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  agent git:<span>(</span>main<span>)</span> ✗ golangci-lint run ./...
</span></span></code></pre></div><p>Almost immediately, we noticed a list of suggestions for improving the code! For example:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>src/extensions/nginx-app-protect/monitoring/processor/nap_test.go:60:14: S1025: the argument is already a string, there<span>&#39;</span>s no need to use fmt.Sprintf <span>(</span>gosimple<span>)</span>
</span></span><span><span> logEntry: fmt.Sprintf<span>(</span><span>`</span>%s<span>`</span>, func<span>()</span> string <span>{</span>
</span></span><span><span> ^
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="shell"><span><span>src/plugins/common.go:85:5: S1009: should omit nil check; len<span>()</span> <span>for</span> <span>[]</span>string is defined as zero <span>(</span>gosimple<span>)</span>
</span></span><span><span> <span>if</span> loadedConfig.Extensions !<span>=</span> nil <span>&amp;&amp;</span> len<span>(</span>loadedConfig.Extensions<span>)</span> &gt; <span>0</span> <span>{</span>
</span></span><span><span>    ^
</span></span></code></pre></div><p>The linter points to exact files and lines that need our attention. Our job now is to assess the code, make changes, run the liner second time and run all unit tests. If the tests are green, we can commit updated code. Job done! Ok, we still need to push it to the remote.</p>
<h2 id="detecting-race-conditions">Detecting race conditions</h2>
<p>Race conditions in our programs and libraries can occur when multiple goroutines try to access a resource concurrently. These conditions
are detected when at least one goroutine tries to write (change) the resource. For example, the resource can be a global, package-level variable that acts as a counter.
This situation in a program can lead to subtle, very hard-to-diagnose and detect bugs.</p>
<p>Go has native support for testing such conditions. We run tests using the Go <code>test</code> tool with the argument <code>-race</code>.
This method will run the race detector and help identify problems in concurent programs.</p>
<p>There is one warning we need to remember. The detector can assess the executed code and will ignore code paths that are not executed. So, it’s crucial to run static code analysers first and make sure we do not have so-called dead code in our project.</p>
<p>When we tell Go: “Hey, run tests with the <code>-race</code> argument”, the Go compiler compiles the code with the race detector enabled. Then, tests are run, and possible race conditions are checked at runtime. When races are detected, the tool will print a detailed report. It will show what goroutines try to access which resources.</p>
<p>Another way to increase the chances of detecting concurrency issues is to run tests in parallel. To do so we need to inform the runner explicitly by adding <code>t.Parallel()</code> to our tests.</p>
<p>Two tests executed in parallel</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestParseDiskSpace</span>(<span>t</span> <span>*</span><span>testing</span>.<span>T</span>) {
</span></span><span><span>    <span>t</span>.<span>Parallel</span>()
</span></span><span><span>    <span>...</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestParseMemoryUsage</span>(<span>t</span> <span>*</span><span>testing</span>.<span>T</span>) {
</span></span><span><span>    <span>t</span>.<span>Parallel</span>()
</span></span><span><span>    <span>...</span>
</span></span></code></pre></div><p>Detecting race conditions and designing concurrent code is a vast and exciting topic that we will discuss in the future.</p>
<h2 id="scanning-source-code-for-vulnerabilities">Scanning source code for vulnerabilities</h2>
<h3 id="govulncheck">govulncheck</h3>
<p>We have a broad choice of tools that scan the codebase for known vulnerabilities listed in the <a href="https://www.cve.org">CVEs</a> database.</p>
<p>Our default tool for ensuring we develop and release safe code is <code>govulncheck</code>. We can install it locally on a developer’s machine and run scans locally before committing and pushing our code to a remote Git repository.</p>
<p>Optionally, we can integrate the scanning step with CI pipelines in GitHub or GitLab. Then, the scan can be invoked on each merge request to ensure we do not introduce vulnerabilities in the project.</p>
<p><code>govulncheck</code> is developed by the Go team. A dedicated database of Go vulnerabilities provides information for the scanner.
Let’s install <code>govulncheck</code> locally and try basic functionality.</p>
<p>To install the latest version, we need to run the following command:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>go install golang.org/x/vuln/cmd/govulncheck@latest
</span></span></code></pre></div><p>It’s time to check if the installation process went well:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>govulncheck -version
</span></span><span><span>Go: go1.23.2
</span></span><span><span>Scanner: <a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="95f2fae3e0f9fbf6fdf0f6fed5e3a4bba4bba6">[email protected]</a>
</span></span><span><span>DB: https://vuln.go.dev
</span></span><span><span>DB updated: 2024-10-17 15:37:30 +0000 UTC
</span></span><span><span>...
</span></span></code></pre></div><p>We are ready to run our first scan. Let’s clone the <a href="https://github.com/qba73/habit">habit</a> git repository. Then, navigate to its root directory and run the tool.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  habit git:<span>(</span>main<span>)</span> ✗ govulncheck
</span></span><span><span>No vulnerabilities found.
</span></span></code></pre></div><p>It looks promising! We did not find vulnerabilities in the source code. Are we done? Not really! We built the habit binary when the <code>go.mod</code> file defined the version of Go 1.18. The current version is v1.23.2.</p>
<p>Let’s scan the habit binary, not the source code.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  habit git:<span>(</span>main<span>)</span> ✗ govulncheck -mode binary -show verbose habit
</span></span></code></pre></div><p>We run <code>govulncheck</code> in the binary mode. It means that we can scan any Go binary we have access to! We do not need source code! Then, we run the scan in the verbose mode. It will show the complete report broken into multiple sections. The last argument is the name of the binary we want to scan.</p>
<p>Hmmm! This report does look different! What just happened?</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>Scanning your binary <span>for</span> known vulnerabilities...
</span></span><span><span>
</span></span><span><span>Fetching vulnerabilities from the database...
</span></span><span><span>
</span></span><span><span>Checking the binary against the vulnerabilities...
</span></span><span><span>
</span></span><span><span><span>===</span> Symbol Results <span>===</span>
</span></span><span><span>
</span></span><span><span>No vulnerabilities found.
</span></span><span><span>
</span></span><span><span><span>===</span> Package Results <span>===</span>
</span></span><span><span>
</span></span><span><span>Vulnerability <span>#1: GO-2023-2186</span>
</span></span><span><span>    Incorrect detection of reserved device names on Windows in path/filepath
</span></span><span><span>  More info: https://pkg.go.dev/vuln/GO-2023-2186
</span></span><span><span>  Standard library
</span></span><span><span>    Found in: path/<a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="4127282d243120352901262e706f73716f74">[email protected]</a>
</span></span><span><span>    Fixed in: path/<a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="badcd3d6dfcadbced2faddd58b94888a948b8b">[email protected]</a>
</span></span><span><span>
</span></span><span><span><span>===</span> Module Results <span>===</span>
</span></span><span><span>
</span></span><span><span>Vulnerability <span>#1: GO-2024-3107</span>
</span></span><span><span>    Stack exhaustion in Parse in go/build/constraint
</span></span><span><span>  More info: https://pkg.go.dev/vuln/GO-2024-3107
</span></span><span><span>  Standard library
</span></span><span><span>    Found in: <a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="493a3d2d25202b092e2678677b79677c">[email protected]</a>
</span></span><span><span>    Fixed in: <a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="265552424a4f44664149170814140811">[email protected]</a>
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span>Vulnerability <span>#18: GO-2023-1878</span>
</span></span><span><span>    Insufficient sanitisation of Host header in net/http
</span></span><span><span>  More info: https://pkg.go.dev/vuln/GO-2023-1878
</span></span><span><span>  Standard library
</span></span><span><span>    Found in: <a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="e4979080888d86a4838bd5cad6d4cad1">[email protected]</a>
</span></span><span><span>    Fixed in: <a href="https://jarosz.dev/cdn-cgi/l/email-protection" data-cfemail="710205151d181331161e405f43415f47">[email protected]</a>
</span></span><span><span>
</span></span><span><span>Your code is affected by <span>0</span> vulnerabilities.
</span></span><span><span>This scan also found <span>1</span> vulnerability in packages you import and <span>18</span>
</span></span><span><span>vulnerabilities in modules you require, but your code doesn<span>&#39;</span>t appear to call
</span></span><span><span>these vulnerabilities.
</span></span></code></pre></div><p>The first section contains the most important message: <strong>No vulnerabilities found</strong>.</p>
<p>The remaining sections contain information about other vulnerabilities discovered in standard Go libraries. Ok, but are we affected? Is our program not secure?</p>
<p>The final scan report tells us we should not worry. Our program <em>doesn’t appear to call
these vulnerabilities</em>! Happy days!</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>Your code is affected by <span>0</span> vulnerabilities.
</span></span><span><span>This scan also found <span>1</span> vulnerability in packages you import and <span>18</span>
</span></span><span><span>vulnerabilities in modules you require, but your code doesn<span>&#39;</span>t appear to call
</span></span><span><span>these vulnerabilities.
</span></span></code></pre></div><p>Let’s update the <code>go.mod</code> file and change the Go version to the latest <code>1.23</code>. Next, we need to run <code>go mod tidy</code> to get all dependencies up to date.
At this point, we are ready to build the binary again.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  habit git:<span>(</span>main<span>)</span> ✗ go build -o habit cmd/main.go
</span></span></code></pre></div><p>Let’s rerun the scan.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>➜  habit git:<span>(</span>main<span>)</span> ✗ govulncheck -mode binary -show verbose habit
</span></span><span><span>Scanning your binary <span>for</span> known vulnerabilities...
</span></span><span><span>
</span></span><span><span>Fetching vulnerabilities from the database...
</span></span><span><span>
</span></span><span><span>Checking the binary against the vulnerabilities...
</span></span><span><span>
</span></span><span><span>No vulnerabilities found.
</span></span></code></pre></div><p>That’s what we wanted! We upgraded the Go version, pulled dependencies and verified that our software and dependencies were free from CVEs.</p>
<h3 id="gosec">gosec</h3>
<p><a href="https://github.com/securego/gosec"><code>gosec</code></a> is a static code analyzer. It helps to find insecure code constructs.
We can install it locally on our laptops or run it as a GitHub Action in a CI pipeline. As described earlier, <code>golangci-lint</code> includes the <code>gosec</code> as a plugin and runs it as default on each code scan.</p>
<p>Let’s give it a try and install the scanner locally.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>go install github.com/securego/gosec/v2/cmd/gosec@latest
</span></span></code></pre></div><p>If we do not see errors, <code>gosec</code> is ready for action. Before running our first scan, let’s look at the menu:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>gosec -h
</span></span><span><span>
</span></span><span><span>gosec - Golang security checker
</span></span><span><span>
</span></span><span><span>gosec analyses Go source code to look <span>for</span> common programming mistakes that
</span></span><span><span>can lead to security problems.
</span></span><span><span>...
</span></span></code></pre></div><p>We can use a long list of options and rules to configure the scanner behaviour. Going into details of specific options is outside of the scope of this article. A detailed tutorial on configuring, running and benefiting from this SAST tool is coming soon! Stay tuned!</p>
<p>To try gosec, we need to clone a GitHub repository with the Go code we want to scan.</p>
<p>Let’s clone the <a href="https://github.com/CyberRoute/bruter">brutus</a> repository. It’s an open-source experimental <a href="https://en.wikipedia.org/wiki/Open-source_intelligence">OSINT</a> app for testing web server configuration.</p>
<p>Next, change our current directory to the project’s root directory and start scanning.</p>
<p>After a couple of seconds, <code>gosec</code> presents the scan report. What can we learn immediately? We see a list of potential issues sorted by severity and confidence.
We know what part of the code needs attention and what weakness classification the issue applies to. Perfect! What’s next?</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>...
</span></span><span><span>
</span></span><span><span><span>[</span>/.../bruter/pkg/fuzzer/randomua.go:69<span>]</span> - G404 <span>(</span>CWE-338<span>)</span>: Use of weak random number generator <span>(</span>math/rand or math/rand/v2 instead of crypto/rand<span>)</span> <span>(</span>Confidence: MEDIUM, Severity: HIGH<span>)</span>
</span></span><span><span>    68:
</span></span><span><span>  &gt; 69:  randomIndex :<span>=</span> rand.Intn<span>(</span>len<span>(</span>userAgents<span>))</span>
</span></span><span><span>    70:  <span>return</span> userAgents<span>[</span>randomIndex<span>]</span>
</span></span><span><span>
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span><span>[</span>/.../bruter/pkg/server/config.go:40<span>]</span> - G402 <span>(</span>CWE-295<span>)</span>: TLS InsecureSkipVerify set true. <span>(</span>Confidence: HIGH, Severity: HIGH<span>)</span>
</span></span><span><span>    39:  customTransport :<span>=</span> &amp;http.Transport<span>{</span>
</span></span><span><span>  &gt; 40:   TLSClientConfig: &amp;tls.Config<span>{</span>InsecureSkipVerify: true<span>}</span>,
</span></span><span><span>    41:  <span>}</span>
</span></span><span><span>
</span></span><span><span>...
</span></span></code></pre></div><p>At this stage of our investigation, we can check reported CWEs and learn about details of listed weaknesses. For example, the second listed issue brings us to the <a href="https://cwe.mitre.org/data/definitions/295.html">CWE-295</a> website, where we can learn more about vulnerability.</p>
<h2 id="fuzzing">Fuzzing</h2>
<p>The last method of checking code quality and discovering vulnerabilities is fuzz testing. Fuzzing is a special kind of automated testing. It uses code test coverage to manipulate randomly generated input data.</p>
<p>It’s extremely helpful in finding potential security flaws like buffer overflows, <a href="https://owasp.org/www-community/attacks/SQL_Injection">SQL injections</a>, <a href="https://owasp.org/www-community/attacks/Denial_of_Service">DoS attacks</a> and <a href="https://owasp.org/www-community/attacks/xss/">XSS attacks</a>. The most crucial attribute of fuzzing is that many input combinations are generated automatically! Developers don’t need to scratch their heads trying to figure out hundreds, if not thousands, of input data combinations! What a relief!</p>
<p>We will focus on fuzzing in more detail in upcoming tutorials.</p>
<p>Most of the methods and testing techniques we discussed today are encouraged by <a href="https://openssf.org/best-practices-badge/">OpenSSF</a> foundation. Open source projects that want to get the Best Practice Badge are required to meet <a href="https://www.bestpractices.dev/en/criteria/0">FLOSS criteria</a> in areas like licencing, change control, vulnerability reporting, quality, security and static and dynamic security code analysis.</p>
<p>Stay secure, free from CVEs and enjoy programming!</p>
<p>As <a href="https://bitfieldconsulting.com">John Arundel</a> says:</p>
<blockquote>
<p>“Programming is fun, and you should have fun!”</p>
</blockquote>
<p>Till next time!</p>
    
</div>



    

</article></div>
  </body>
</html>
