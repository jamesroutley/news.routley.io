<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arewestackefficientyet.com/">Original</a>
    <h1>Is Rust stack-efficient yet?</h1>
    
    <div id="readability-page-1" class="page"><div>
        <h2>Q&amp;A</h2>
        <h3>What is this?</h3>
        <p>
            This is a set of graphs that shows the fraction of <em>stack memory move</em> CPU
            instructions in a sample of Rust code and C++ code. Lower numbers are better.
        </p>

        <h3>What&#39;s a stack memory move?</h3>
        <p>
            A stack memory move is a pair of instructions that loads a value from memory and stores
            it to the CPU stack. A <em>stack-to-stack memory move</em> loads a value from the stack
            and stores it to the stack. An <em>non-stack-to-stack memory move</em> loads a value
            from some place other than the stack and stores it to the stack.
        </p>

        <h3>Why do we care about stack memory moves?</h3>
        <p>
            Memory moves to the stack frequently represent wasted computation. For the most part,
            they&#39;re CPU cycles that are spent shuffling data from one place to another instead of
            performing useful work. Stack-to-stack memory moves in particular are very likely to
            represent pure overhead; non-stack-to-stack memory moves are sometimes genuinely useful
            and necessary but frequently also represent waste.
        </p>

        <h3>How did you perform these measurements?</h3>
        <p>
            Using
            <a href="https://github.com/pcwalton/llvm-project/tree/stack-copy-stats">this branch</a>
            of LLVM. You can reproduce them for yourself by building this branch of LLVM, linking Clang
            and/or <code>rustc</code> against the resulting library, and building code with
            <code>LLVM_STACK_COPY_STATS=1</code>. CSV data will be dumped to <code>stderr</code> for you
            to aggregate as you like.
        </p>

        <h3>What workloads were tested?</h3>
        <p>
            The C++ code in question is LLVM and Clang. The Rust code in question is <code>rustc</code>.
            I chose these two because they were similar workloads by dint of being compilers. The CPU
            architecture is x86-64.
        </p>

        <h3>What versions of the compilers did you use?</h3>
        <p>
            Trunk Clang and nightly <code>rustc</code> as of the given date, both linking against trunk
            LLVM.
        </p>

        <h3>Does this mean Rust is slower than C++?</h3>
        <p>
            No. You can always write your Rust code carefully to avoid copies. Besides, all of this only
            comes out to a small percentage of the total instruction count. That being said, it&#39;s something
            we should fix, and which I&#39;m working on.
        </p>

        <h3>Can we add optimizations so that Rust can do better in the future?</h3>
        <p>
            Absolutely, and this page serves to track that progress.
        </p>

        <h3>How often is this page updated?</h3>
        <p>
            Manually, when I land changes that I think will improve things. Very few people are working
            in this area, so I don&#39;t think CI would be worth it right now.
        </p>

        <h3>Are there any caveats to these numbers?</h3>
        <p>
            Yes:
            </p><ul>
                <li>
                    I stopped measuring around 20 million instructions, because the statistics
                    gathering is very slow and it would take forever to measure all of LLVM and
                    Clang. I don&#39;t think measuring more than 20M instructions would be likely to
                    produce much of a change in the overall numbers.
                </li>
                <li>
                    I&#39;m not measuring <code>memcpy</code> or <code>memmove</code> calls yet, only loads
                    and stores.
                </li>
                <li>
                    The way flow sensitivity is handled is to consider multiple live-in registers to a
                    basic block as &#34;coming from the stack&#34; if <em>any</em> of them come from the stack.
                    This may result in overestimating the true number of stack-to-stack copies in some
                    cases.
                </li>
                <li>
                    I only count the number of stores, not the number of load-store pairs. Arguably this
                    means the true number of wasted instructions could be as much as twice the fractions
                    listed here.
                </li>
            </ul>
        
    </div></div>
  </body>
</html>
