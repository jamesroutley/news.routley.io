<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2023/09/22/GitHub-Actions-could-be-so-much-better">Original</a>
    <h1>GitHub Actions could be so much better</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://swe-to-mle.pages.dev/">Home</a></li>
    <li><a href="https://swe-to-mle.pages.dev/tags">Tags</a></li>
    <li><a href="https://swe-to-mle.pages.dev/series">Series</a></li>
    <li><a href="https://swe-to-mle.pages.dev/favorites">Favorites</a></li>
    <li><a href="https://swe-to-mle.pages.dev/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Sep 22, 2023</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://swe-to-mle.pages.dev/tags#programming">programming</a>,
        
          <a href="https://swe-to-mle.pages.dev/tags#rant">rant</a>,
        
          <a href="https://swe-to-mle.pages.dev/tags#workflow">workflow</a>
        
      </span>
    

       

    
  </p>
</h2>






<hr/>


<p>I <em>love</em> GitHub Actions: I’ve been a daily user of it since 2019 for both professional
and hobbyist projects, and have found it invaluable to both my overall productivity
and peace of mind. I’m <em>just</em> old enough to have used <a href="https://www.travis-ci.com/">Travis CI</a>
et al. professionally before moving to GitHub Actions, and I do not look back with joy<sup id="fnref:back" role="doc-noteref"><a href="#fn:back" rel="footnote">1</a></sup>.</p>

<p>By and large, GitHub Actions continues to delight me and grow new features that I
appreciate: <a href="https://github.blog/2021-11-29-github-actions-reusable-workflows-is-generally-available/">reusable workflows</a>, <a href="https://github.blog/changelog/2021-10-27-github-actions-secure-cloud-deployments-with-openid-connect/">OpenID connect</a>, <a href="https://github.blog/changelog/2022-05-09-github-actions-enhance-your-actions-with-job-summaries/">job summaries</a>, <a href="https://github.blog/changelog/2023-05-09-introducing-actions-on-the-repository-view-on-github-mobile/">integrations into GitHub Mobile</a>,
and so forth.</p>

<p>At the same time, GitHub Actions is a regular source of <em>profound</em> frustration and time loss<sup id="fnref:loss" role="doc-noteref"><a href="#fn:loss" rel="footnote">2</a></sup>
in my development processes. This post lists some of those frustrations, and how I think GitHub
could selfishly<sup id="fnref:selfishly" role="doc-noteref"><a href="#fn:selfishly" rel="footnote">3</a></sup> improve on them (or even fix them outright)<sup id="fnref:roadmap" role="doc-noteref"><a href="#fn:roadmap" rel="footnote">4</a></sup>.</p>

<hr/>

<h2 id="debugging-like-im-15-again">Debugging like I’m 15 again</h2>

<p>Here’s a pretty typical session of me trying to set up a release workflow on GitHub Actions:</p>

<p><img src="https://swe-to-mle.pages.dev/assets/github-actions-fails.png" alt=""/></p>

<p>In this particular case, it took me 4 separate commits (and 4 failed releases) to debug
the various small errors I made: not using <code>${{ ... }}</code><sup id="fnref:jekyll" role="doc-noteref"><a href="#fn:jekyll" rel="footnote">5</a></sup> where I needed to, forgetting
a <code>needs:</code> relationship, &amp;c.</p>

<p>Here’s another (this time of a PR-creating workflow), from a few weeks later:</p>

<p><img src="https://swe-to-mle.pages.dev/assets/github-actions-fails-2.png" alt=""/></p>

<p>I am not the world’s most incredible programmer; like many (most?), I program intuitively
and follow the error messages until they stop happening.</p>

<p>GitHub Actions is <strong>not</strong> responsible for catching every possible error I could make,
and ensuring that every workflow I write will run successfully on the first try.</p>

<p>At the same time, the current debugging cycle in GitHub Actions is <em>ridiculous</em>:
even the smallest change on the most trivial workflow is a 30+ second process
of tabbing out of my development environment (context switch #1), digging through
my browser for the right tab (context switch #2), clicking through the infernal
nest of actions summaries, statuses, &amp;c. (context switch #3), and impatiently
refreshing a buffered console log to figure out which error I need to fix next
(context switch #4). Rinse and repeat.</p>

<h3 id="fixing-this">Fixing this</h3>

<ul>
  <li>
    <p>Give us an interactive debugging shell, or (at least) let us re-run workflows
with small changes <em>without</em> having to go through a <code>git add; git commit; git push</code> cycle<sup id="fnref:breaks" role="doc-noteref"><a href="#fn:breaks" rel="footnote">6</a></sup>.</p>
  </li>
  <li>
    <p>Give us a repository setting to reject commits with obviously invalid workflows (things
like syntax that can’t possibly work, or references to jobs/steps that don’t exist).
It’s <em>infuriating</em> when I <code>git push</code> a workflow that silently fails because of invalid YAML;
<em>especially</em> when I then merge that workflow’s branch under the mistaken impression
that the workflow is <em>passing</em>, rather than not running at all.</p>
  </li>
</ul>

<h2 id="security-woes">Security woes</h2>

<p>Speaking from experience: it’s <em>shockingly</em> easy to wreck yourself with GitHub Actions. <em>Way</em> easier
than it should be.</p>

<p>Here is just a small handful of the ways in which I have <em>personally</em> written potentially vulnerable
workflows over the past few years:</p>

<ol>
  <li>
    <p>Using the <code>${{ ... }}</code> expansion syntax in a shell or other context where a
(potentially malicious) user controls the expansion’s contents. The following, for example, would
allow a user to inject code that could then exfiltrate <code>$MY_IMPORTANT_SECRET</code>:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>-</span> <span>name</span><span>:</span> <span>do something serious</span>
  <span>run</span><span>:</span> <span>|</span>
   <span>something-serious &#34;${{ inputs.frob }}&#34;</span>
  <span>env</span><span>:</span>
    <span>MY_IMPORTANT_SECRET</span><span>:</span> <span>${{ secrets.MY_IMPORTANT_SECRET }}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Some among you will observe that a ✨good✨ programmer would simply know
not to do this, and that a bad programmer would eventually learn their
(painful) lesson. This might be an acceptable position for a niche
piece of software to hold; it is <strong>not</strong> an acceptable position
for the CI/CD platform that, to a first approximation, hosts the entire
open source ecosystem.</p>
  </li>
  <li>
    <p>Using <code>pull_request_target</code>. As far as I can tell, it’s <em>practically</em>
impossible to use this event safely in a non-trivial workflow<sup id="fnref:trivial" role="doc-noteref"><a href="#fn:trivial" rel="footnote">7</a></sup>.</p>

    <p>This event appears to exist for an <em>extremely</em> narrow intended use case, i.e.
labeling or commenting on PRs that come from forks. I don’t understand
why GitHub Actions chooses to expose such a (relatively) simple operation
through as massive of a foot-gun as <code>pull_request_target</code>.</p>
  </li>
  <li>
    <p>Over-scoping my workflow and job-level permissions.</p>

    <p>The default access set for Actions’ ordinary <code>GITHUB_TOKEN</code> is
<a href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token"><em>very</em> permissive</a>:
the only thing it <em>doesn’t</em> provide access to are the workflow’s OpenID Connect token.</p>

    <p>This consistently bites me in two different ways:</p>

    <ol>
      <li>I consistently forget to down-scope the default token, especially when
working with repositories under my personal account (rather than under an org,
where the default scope can be reduced across all repositories).</li>
      <li>
        <p>I consistently <em>over-scope</em> my tokens because I don’t know exactly
how much access my workflow will need.</p>

        <p>This is further complicated by the messy ways in which GitHub’s permission
model gets shoehorned into a single permissions dimension of <code>read/write/none</code>:
why does <code>id-token: write</code> grant me the ability to <strong>read</strong> the workflow’s OpenID Connect
token? Why do
<a href="https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-repository-security-advisories">some <code>GET</code> operations</a>
on security advisories require <code>write</code>, while others only require <code>read</code>?</p>
      </li>
    </ol>
  </li>
</ol>

<p>There are also a few things that I <em>haven’t</em> done<sup id="fnref:donetome" role="doc-noteref"><a href="#fn:donetome" rel="footnote">8</a></sup>, but are scary enough that I think they’re worth
mentioning.</p>

<p>For example, can you see what’s wrong with this workflow step?</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>steps</span><span>:</span>
  <span>-</span> <span>uses</span><span>:</span> <span>actions/checkout@c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Despite all appearances, SHA ref
<a href="https://github.com/actions/checkout/commit/c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e"><code>c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e</code></a>
is <strong>not</strong> a commit on the <code>actions/checkout</code> repository! It’s actually a commit on a fork in
<code>actions/checkout</code>’s network which, thanks to GitHub’s use of
<a href="https://github.blog/2015-09-22-counting-objects/#your-very-own-fork-of-rails">alternates</a>,
<em>appears</em> to belong to the parent repository.</p>

<p><a href="https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd">Chainguard has an excellent post on this</a><sup id="fnref:stole" role="doc-noteref"><a href="#fn:stole" rel="footnote">9</a></sup>,
but to summarize:</p>

<ol>
  <li>SHA references from forks are visually indistinguishable from SHA references
in the intended target repository. The only way to tell the two apart is
to manually inspect each reference and confirm that it appears on the expected
repository, and not one of its forks.</li>
  <li>GitHub’s own REST API makes no distinction between SHA references in a repository
graph — <code>/repos/{user}/{repo}/commits/{ref}</code> returns a JSON response that <em>only</em> references
<code>{user}/{repo}</code>, even if <code>{ref}</code> is only on a fork.</li>
  <li>Because GitHub fails to distinguish between fork and non-fork SHA references, forks
can bypass security settings on GitHub Actions that would otherwise restrict
actions to only “trusted” sources (such as GitHub themselves or the repository’s
own organization).</li>
</ol>

<p>GitHub’s response to this (so far) has been to add
<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-shas">a little bit of additional language</a>
to their documentation, rather than to forbid misleading SHA references outright.</p>

<h3 id="fixing-this-1">Fixing this</h3>

<ul>
  <li>
    <p>Give us push-time rejection of obviously insecure workflows. In other words:
let us toggle<sup id="fnref:default" role="doc-noteref"><a href="#fn:default" rel="footnote">10</a></sup> a “paranoid workflow security” mode that, when enabled,
causes <code>git push</code> to fail with an explanation of what I’m doing wrong. Essentially
the same thing as the debugging request above, but for security!</p>
  </li>
  <li>
    <p>Give us runtime checks on our workflows, analogous to runtime instrumentation like
<a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>
in the world of compiled languages. There are <em>so many</em> things that could
be turned into hard failures for security wins without breaking 99.9% of legitimate
users, like failing any attempt to use <code>actions/checkout</code> on a <code>pull_request_target</code>
with a ref that isn’t from the targeted repository.</p>
  </li>
  <li>
    <p>Maybe just deprecate and remove <code>pull_request_target</code> entirely.
<a href="https://securitylab.github.com/research/github-actions-preventing-pwn-requests/">GitHub’s own Security Lab</a>
has been aware of how dangerous this event is for years; maybe it’s time to get rid of it
entirely.</p>
  </li>
  <li>
    <p>Allow us to set a more restrictive default token scope on our personal repositories,
similar to how organizations and enterprises can restrict their default
<code>GITHUB_TOKEN</code> scopes across all repositories at once.</p>
  </li>
  <li>
    <p>By default, reject any SHA-pinned action for which the SHA only appears
on a fork and not the referenced repository. It’s hard to imagine a
<em>legitimate</em> reason to ever need to do this!</p>
  </li>
</ul>

<h2 id="real-types-would-be-nice">Real types would be nice</h2>

<p>When writing a custom GitHub Action, you can specify the actions inputs
using a mapping under the <code>inputs:</code> key. For example, the following
defines a <code>frobulation-level</code> input with a description (used for tooltips
in many IDEs) and a default value:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>inputs</span><span>:</span>
  <span>frobulation-level</span><span>:</span>
    <span>description</span><span>:</span> <span>&#34;</span><span>the</span><span> </span><span>level</span><span> </span><span>to</span><span> </span><span>frobulate</span><span> </span><span>at&#34;</span>
    <span>default</span><span>:</span> <span>&#34;</span><span>1&#34;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Notably, this syntax does <strong>not</strong> allow for type enforcement; the following
<strong>does not work</strong>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>inputs</span><span>:</span>
  <span>frobulation-level</span><span>:</span>
    <span>description</span><span>:</span> <span>&#34;</span><span>the</span><span> </span><span>level</span><span> </span><span>to</span><span> </span><span>frobulate</span><span> </span><span>to&#34;</span>
    <span>default</span><span>:</span> <span>1</span>
    <span># NOTE: this SHOULD cause a workflow failure if the input</span>
    <span># isn&#39;t a valid number, but doesn&#39;t</span>
    <span>type</span><span>:</span> <span>number</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This absence is strange, but what makes it <em>bizarre</em> is that GitHub is <strong>inconsistent</strong>
about where types can appear in actions and workflows:</p>

<ul>
  <li><code>workflow_call</code> supports <code>type</code> with <code>boolean</code>, <code>number</code>, or <code>string</code></li>
  <li><code>workflow_dispatch</code> supports <code>type</code> with <code>boolean</code>, <code>choice</code>, <code>number</code>, or <code>string</code></li>
  <li>Action inputs: no types at all</li>
</ul>

<p>Unfortunately, this is only the first level: even inputs that <em>do</em> support
typing doesn’t support compounded data structures, like lists or objects.
For example, neither of the following works:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>-</span> <span>uses</span><span>:</span> <span>example/example</span>
  <span>with</span><span>:</span>
    <span># INVALID: can&#39;t use arrays as inputs</span>
    <span>paths</span><span>:</span> <span>[</span><span>foo</span><span>,</span> <span>bar</span><span>,</span> <span>baz</span><span>]</span>
    <span># INVALID: can&#39;t use objects as inputs</span>
    <span>headers</span><span>:</span>
      <span>foo</span><span>:</span> <span>bar</span>
      <span>baz</span><span>:</span> <span>quux</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…which means that action writers end up requiring users to do silly things like these:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>-</span> <span>uses</span><span>:</span> <span>example/example</span>
  <span>with</span><span>:</span>
    <span># SILLY: action does ad-hoc CSV-ish parsing</span>
    <span>paths</span><span>:</span> <span>foo,bar,baz</span>
    <span># SILLY: action forcefully flattens a natural hierarchy</span>
    <span>header-foo</span><span>:</span> <span>bar</span>
    <span>header-baz</span><span>:</span> <span>quux</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is bad for maintainability, and bad for security: maintainability
because actions must carefully manage a single flat namespace of inputs
(with no types!), and security because both action writer and workflow writer
are forced into <a href="https://langsec.org/occupy/">ad-hoc, unspecified languages</a>
for complex inputs.</p>

<h3 id="fixing-this-2">Fixing this</h3>

<ul>
  <li>
    <p>Let action and workflow writers use <code>type:</code> everywhere, and let
us use <code>choice</code> everywhere — not just in <code>workflow_dispatch</code>!</p>
  </li>
  <li>
    <p>Give us stricter type-checking. Where action and workflow types
can be inferred statically, detect errors and reject incorrectly typed
workflow changes at <code>push</code> time, rather than waiting for the workflow
to inevitably fail.</p>
  </li>
  <li>
    <p>Give us <code>type: object</code> and <code>type: array</code> types. These won’t be perfect
to start with (thanks to potentially heterogeneous interior types),
but they’ll be a significant improvement over the status quo. Implementation-wise,
forward these as JSON-serialized strings or something similar<sup id="fnref:json" role="doc-noteref"><a href="#fn:json" rel="footnote">11</a></sup> where
appropriate (such as in auto-created <code>INPUT_{WHATEVER}</code> environment variables).</p>
  </li>
</ul>

<h2 id="more-official-actions-would-be-nice">(More) official actions would be nice</h2>

<p>The third-party ecosystem on GitHub Actions is great: there are a <em>lot</em>
of high-quality, easy-to-use actions being maintained by open source contributors.
I maintain a <a href="https://github.com/pypa/gh-action-pip-audit">handful</a>
<a href="https://github.com/sigstore/gh-action-sigstore-python">of them</a>!</p>

<p>Beneath the surface of these excellent third-party actions is a substrate
of <em>official</em>, GitHub-maintained actions. These actions primarily address
three classes of fundamental CI/CD activities:</p>

<ol>
  <li>Core <code>git</code> operations: <code>actions/checkout</code></li>
  <li>Core GitHub operations and repository housekeeping: <code>actions/{upload,download}-artifact</code>,
<code>actions/cache</code>, <code>actions/stale</code></li>
  <li>General (but essential) configuration: <code>actions/setup-python</code>, <code>actions/setup-node</code></li>
</ol>

<p>These classes are somewhat distinct from “higher-level” workflows (like the kind
I write): because of their centrality and universal demand, they benefit from
singular, high-quality, <em>officially maintained</em> implementations.</p>

<p>And so, the question: <strong><em>why are there so few of them</em></strong>?</p>

<p>Here is just a smattering of the official actions that <em>don’t</em> exist:</p>

<ol>
  <li><em>Programmatically adding a pull request to a merge queue</em>. GitHub <em>has</em> the machinery to
support this: <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue?tool=cli"><code>gh pr merge</code> already exists</a>.
It just isn’t exposed as an action; users are (presumably) expected
to piece it together themselves.</li>
</ol>

<p>Even worse, there are actions that <em>did</em> exist but were deprecated (generally
for unclear reasons<sup id="fnref:time" role="doc-noteref"><a href="#fn:time" rel="footnote">12</a></sup>):</p>

<ol>
  <li><a href="https://github.com/actions/create-release"><code>actions/create-release</code></a>:
<a href="https://github.com/actions/create-release/issues/119">unmaintained as of March 2021</a>. Users
encouraged to switch to various community maintained workflows, most notably<sup id="fnref:notably" role="doc-noteref"><a href="#fn:notably" rel="footnote">13</a></sup>
<a href="https://github.com/softprops/action-gh-release"><code>softprops/action-gh-release</code></a>.</li>
  <li><a href="https://github.com/actions/upload-release-asset"><code>actions/upload-release-asset</code></a>: marked
as unmaintained at the same time as <code>actions/create-release</code>.</li>
  <li><a href="https://github.com/actions/setup-ruby"><code>actions/setup-ruby</code></a>:
<a href="https://github.com/actions/setup-ruby/issues/97">unmaintained as of February 2021</a>. Users
encouraged to switch to <a href="https://github.com/ruby/setup-ruby"><code>ruby/setup-ruby</code></a>.</li>
</ol>

<p>I’m sympathetic to the individual maintainers here and, in each case, the transition
to a “recommended” third-party action was relatively painless.</p>

<p>Still, the overall impression given here is unmistakable: that GitHub does not see <em>official</em>
actions for its own platform features (or key ecosystem users, like Ruby) as priorities,
and would rather have the community develop and choose unofficial favorites. This is
<strong>not unreasonable</strong> on a strategic level (it induces third-party development
in their ecosystem), but has a <em>deleterious effect</em> on trust in the platform. I’d like
to be able to write workflows and know that they’ll run (with minimal changes) 5 years from
now, and not worry that GitHub has abandoned core pieces underneath me!</p>

<p>Apart from imparting a general feeling of shabbiness, this compounds with GitHub Action’s
poor security story (<a href="#some-security-would-be-nice">per above</a>): not providing official high-quality actions for their own
API surfaces means that users will <em>continue</em> to make exploitable security mistakes in
their workflows. Nobody wins<sup id="fnref:pentesting" role="doc-noteref"><a href="#fn:pentesting" rel="footnote">14</a></sup>.</p>

<h3 id="fixing-this-3">Fixing this</h3>

<ul>
  <li>
    <p>Give us more official actions. As a <em>very</em> rough rule of thumb: if a thing
directly ties different pieces of GitHub infrastructure together <em>and</em> currently
needs to be done manually (with REST API calls, <code>gh</code> invocations, or whatever else),
it probably deserves a full official action!</p>
  </li>
  <li>
    <p>Give us more <em>pseudo-official</em> actions. Work with the biggest third-party actions<sup id="fnref:biggest" role="doc-noteref"><a href="#fn:biggest" rel="footnote">15</a></sup>
to form a <code>community-actions</code> (or whatever) org, with the expectation that actions homed under
that org have been reviewed (at some point) by GitHub, are forced to adhere to best practices
for repository security, receive semantically versioned updates, &amp;c &amp;c.</p>
  </li>
</ul>

<h2 id="wrap-up">Wrap-up</h2>

<p>This is a long and meandering post, and many parts are in conflict: security and stability
(in the form of more official actions that break less often), for example, are in eternal
conflict with each other.</p>

<p>I’m just one user, and I don’t expect my interests or frustrations to be overriding ones.
Still, I hope that the problems (and potential fixes) above aren’t unique to me, and that there are
engineers at GitHub who (again, selfishly!) share these concerns and would like to see
them fixed.</p>

<hr/>




<hr/>




  






</div>
  </body>
</html>
