<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://allvpv.org/haotic-journey-through-envvars/">Original</a>
    <h1>Environment variables are a legacy mess: Let&#39;s dive deep into them</h1>
    
    <div id="readability-page-1" class="page"><div>

  <meta property="og:url" content="https://allvpv.org/haotic-journey-through-envvars/"/>
  <meta property="og:site_name" content="allvpv‚Äôs space"/>
  <meta property="og:title" content="Environment variables are a legacy mess: Let&#39;s dive deep into them"/>
  <meta property="og:description" content="Programming languages have rapidly evolved in recent years. But in software development, the new often meets the old, and the scaffolding that OS gives for running new processes hasn‚Äôt changed much since Unix.
If you need to parametrize your application at runtime by passing a few ad-hoc variables (without special files or a custom solution involving IPC or networking), you‚Äôre doomed to a pretty awkward, outdated interface:"/>
  <meta property="og:locale" content="en_us"/>
  <meta property="og:type" content="article"/>
    <meta property="article:published_time" content="2025-10-13T15:00:00+02:00"/>
    <meta property="article:modified_time" content="2025-10-13T15:00:00+02:00"/>
    <meta property="og:image" content="https://allvpv.org/haotic-journey-through-envvars/pattern-rendered.png"/>

  <p><time datetime="2025-10-13">
    2025-10-13¬†
  </time>
  
</p>

  
  
  


  
  
  
  

  



<p>Programming languages have rapidly evolved in recent years. But in software
development, the new often meets the old, and the scaffolding that OS gives for
running new processes hasn‚Äôt changed much since Unix.</p>
<p>If you need to parametrize your application at runtime by passing a few ad-hoc
variables (without special files or a custom solution involving IPC or
networking), you‚Äôre doomed to a pretty awkward, outdated interface:</p>
<h2 id="environment-variables">Environment variables.</h2>
<p><code>export SECRET_API_KEY=2u845102348u234</code></p>
<p>There are no namespaces for them, no types. Just a flat, embarrassingly global
dictionary of strings.</p>
<p>But what exactly are these envvars? Is it some kind of special dictionary
inside the OS? If not, who owns them and how do they propagate?</p>
<h2 id="where-do-they-come-from">Where do they come from?</h2>
<p>In a nutshell: they‚Äôre passed from parent to child.</p>
<pre tabindex="0"><code>    841 ?        00:00:00 sshd
   1520 ?        00:00:00  \_ sshd-session
   1616 ?        00:00:00      \_ sshd-session
   5521 pts/0    00:00:00          \_ bash
   5545 pts/0    00:00:00              \_ nu
   5549 pts/0    00:00:00                  \_ bash
   5560 pts/0    00:00:00                      \_ ps
</code></pre><p>On Linux, a program must use the <code>execve</code> syscall to execute another program.
Whether you type <code>ls</code> in Bash, call <code>subprocess.run</code> in Python, or launch a
code editor, it ultimately comes down to <code>execve</code>, preceded by a
<code>clone</code>/<code>fork</code>. The <code>exec*</code> family of C functions also relies on <code>execve</code>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>SYSCALL_DEFINE3</span><span>(</span><span>execve</span><span>,</span>
</span></span><span><span>		<span>const</span> <span>char</span> <span>__user</span> <span>*</span><span>,</span> <span>filename</span><span>,</span>
</span></span><span><span>		<span>const</span> <span>char</span> <span>__user</span> <span>*</span><span>const</span> <span>__user</span> <span>*</span><span>,</span> <span>argv</span><span>,</span>
</span></span><span><span>		<span>const</span> <span>char</span> <span>__user</span> <span>*</span><span>const</span> <span>__user</span> <span>*</span><span>,</span> <span>envp</span><span>)</span>
</span></span></code></pre></div><p>This system call takes three arguments: <code>filename</code>, <code>argv</code>, <code>envp</code>.
For example, for an <code>ls -lah</code> invocation:</p>
<ol>
<li><code>/usr/bin/ls</code> is the <code>filename</code> (the executable path),</li>
<li><code>[&#39;ls&#39;, &#39;-lah&#39;]</code> is the <code>argv</code> array of command line arguments ‚Äì the
implicit first (‚Äúzero‚Äù) argument is usually the executable name,</li>
<li><code>[&#39;PATH=/bin:/usr/bin&#39;, &#39;USER=allvpv&#39;]</code> is the <code>envp</code> array of envvars
(typically much longer).</li>
</ol>
<p>By default, all envvars are passed from the parent to the child. However,
nothing prevents a parent process from passing a completely different or even
empty environment when calling <code>execve</code>! In practice, most tooling passes the
environment down: Bash, Python‚Äôs <code>subprocess.run</code>, the C library <code>execl</code>, and
so on.</p>
<p>And this is what you expect ‚Äì variables are inherited by child processes.
That‚Äôs the point ‚Äì to track the environment.</p>
<blockquote>
<p>Which tools do <em>not</em> pass the parent‚Äôs environment?
For example, the <code>login</code> executable, used when signing into a
system, sets up a fresh environment for its children.</p></blockquote>
<h2 id="where-do-they-go">Where do they go?</h2>
<p>After launching the new program, the kernel dumps the variables on the stack as
a sequence of null-terminated strings which contain the envvar definitions.
Here is a hex view:</p>
<pre tabindex="0"><code>    484f 4d45 3d2f 0069 6e69 743d 2f73 6269  HOME=/ init=/sbi
    6e2f 696e 6974 004e 4554 574f 524b 5f53  n/init NETWORK_S
    4b49 505f 454e 534c 4156 4544 3d00 5445  KIP_ENSLAVED= TE
    524d 3d6c 696e 7578 0042 4f4f 545f 494d  RM=linux BOOT_IM
    4147 453d 2f76 6d6c 696e 757a 2d36 2e31  AGE=/vmlinuz-6.1
    342e 302d 3333 2d67 656e 6572 6963 0064  4.0-33-generic.d
    726f 705f 6361 7073 3d00 5041 5448 3d2f  rop_caps= PATH=/
    7573 722f 6c6f 6361 6c2f 7362 696e 3a2f  usr/local/sbin:/
    7573 722f 6c6f 6361 6c2f 6269 6e3a 2f75  usr/local/bin:/u
    7372 2f73 6269 6e3a 2f75 7372 2f62 696e  sr/sbin:/usr/bin
    3a2f 7362 696e 3a2f 6269 6e00 5057 443d  :/sbin:/bin PWD=
    2f00 726f 6f74 6d6e 743d 2f72 6f6f 7400  / rootmnt=/root
</code></pre><p>This static layout can‚Äôt easily be modified or extended; the program must copy
those variables into its own data structure. Let‚Äôs look at how Bash, C, and
Python store envvars internally. I analyzed their source code and here is a
summary.</p>
<h3 id="bash">Bash</h3>
<p>It stores the variables in a <em><strong>hashmap</strong></em>. Or, more precisely, in a <em><strong>stack
of hashmaps</strong></em>.</p>
<p>When you spawn a new process using Bash, it traverses the stack of hashmaps to
find variables marked as exported and copies them into the environment array
passed to the child.</p>
<blockquote>
<p><em>Side note:</em> Why is traversing the stack needed?</p>
<p>Each function invocation in Bash creates a new local scope ‚Äì a new entry
on the stack. If you declare your variable with <code>local</code>, it ends up in this
locally-scoped hashmap.</p>
<p>What‚Äôs interesting is that you can export a <code>local</code> variable too!</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>function</span> locallyScoped<span>()</span> <span>{</span>
</span></span><span><span>    <span>local</span> <span>PATH</span><span>=</span><span>&#34;</span><span>$PATH</span><span>:/opt/secret/bin&#34;</span>
</span></span><span><span>    <span>export</span> PATH
</span></span><span><span>    env           <span># &lt;- sees the PATH with /opt/scecret/bin</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>locallyScoped
</span></span><span><span>env               <span># &lt;- sees the PATH without modification</span>
</span></span></code></pre></div><p>I wouldn‚Äôt have learned this without diving into Bash source. My intuitive
(wrong) assumption was that <code>export</code> <em>automatically makes the variable
global</em> ‚Äì like <code>declare -g</code>! Super interesting stuff.</p></blockquote>
<h3 id="the-default-c-library-on-linux-glibc">The default C library on Linux: <code>glibc</code></h3>
<p><code>glibc</code> exposes a dynamic <code>environ</code> array, managed via <code>putenv</code> and <code>getenv</code>
library functions. It uses an array, so the time complexity of <code>getenv</code> and
<code>putenv</code> is <em>linear</em> in the number of envvars. Remember ‚Äì envvars are not a
high-performance dictionary and you should not abuse them.</p>
<h3 id="python">Python</h3>
<p>Python couples its environment to the C library, which can cause surprising
inconsistencies.</p>
<p>If you‚Äôve programmed some Python, you‚Äôve probably used the <code>os.environ</code>
dictionary. On startup, <code>os.environ</code> is built from the C library‚Äôs <code>environ</code>
array.</p>
<p>But those dictionary values are <strong>NOT</strong> the ‚Äúground truth‚Äù for child processes.
Rather, each change to <code>os.environ</code> invokes the native <code>os.putenv</code> function,
which in turn calls the C library‚Äôs <code>putenv</code>.</p>
<blockquote>
<p>Note that the propagation is one-directional: modifying <code>os.environ</code> will call
<code>os.putenv</code>, but not the other way around. Call <code>os.putenv</code>, and <code>os.environ</code>
won‚Äôt be updated.</p></blockquote>
<h2 id="liberal-format">Liberal format</h2>
<p>The Linux kernel is very liberal about the format of environment variables, and
so is <code>glibc</code>.</p>
<p>For example, your C program can manipulate the environment ‚Äì the global
<code>environ</code> array ‚Äì such that several variables share the same name but have
different values. And when you execute a child process, it will inherit this
‚Äúbroken‚Äù setup.</p>
<p>You don‚Äôt even need an equals sign separating name from value! The usual entry
is <code>NAME=VALUE</code>, but nothing prevents you from adding <code>NONSENSE_WITH_EMOJI üòÄ</code>
to the array.</p>
<p>The kernel happily accepts any null-terminated string as an ‚Äúenvironment
variable‚Äù definition. It just imposes a <em>size</em> limitation:</p>
<ul>
<li>
<p><strong>Single variable</strong>: 128 KiB on a typical x64 Intel CPU. This is for the
whole definition ‚Äì name + equal sign + value. It‚Äôs computed as <a href="https://elixir.bootlin.com/linux/v2.6.24/source/include/linux/binfmts.h#L14"><code>PAGE_SIZE * 32</code></a>.
No modern hardware uses pages smaller than 4 KiB, so you can treat it as a
lower bound, unless you need to deal with some legacy embedded systems.</p>
</li>
<li>
<p><strong>Total</strong>: 2 MiB on a typical machine. This limit is shared by envvars and
the command line arguments. The calculation is a bit more complicated (see
the <code>execve(2)</code> man page):</p>
<pre><code>  max(32 * PAGE_SIZE,  min(MAX_STACK_SIZE / 4,  6 MB))
</code></pre>
<p>On a typical system, the limiting factor is the <code>MAX_STACK_SIZE</code>. Remember,
initially the envvars are dumped on the stack! To prevent unpredictable
crashes, the system allows only 1/4 of the stack for the envvars.</p>
</li>
</ul>
<h2 id="quirks">Quirks</h2>
<p>But the fact that you can do something does not mean that you should. For
example, if you start Bash with the ‚Äúbroken‚Äù environment ‚Äì duplicated names and
entries without <code>=</code> ‚Äì it deduplicates the variables and drops the nonsense.</p>
<p>One interesting edge case is a space inside the variable <em>name</em>. My beloved
shell ‚Äì <a href="https://www.nushell.sh/">Nushell</a> ‚Äì has no problem with the following
assignment:</p>
<pre><code>$env.&#34;Deployment Environment&#34; = &#34;prod&#34;
</code></pre>
<p>Python is fine with it, too. Bash, on the other hand, can‚Äôt reference it
because whitespace isn‚Äôt allowed in variable names. Fortunately, the variable
isn‚Äôt lost ‚Äì <a href="https://github.com/bminor/bash/blob/a8a1c2fac029404d3f42cd39f5a20f24b6e4fe4b/variables.c#L126">Bash keeps such entries in a special hashmap
called</a>
<code>invalid_env</code> and still passes them to child processes.</p>
<h2 id="the-standard-format">The standard format</h2>
<p>So what name and value can you <em>safely</em> use for your envvar? A popular
misconception, repeated on StackOverflow and by ChatGPT, is that
<a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> permits only <strong>uppercase</strong>
envvars, and everything else is undefined behavior.</p>
<p>But this is seriously <strong>NOT</strong>
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/">what the standard says</a>:</p>
<blockquote>
<p><em>These strings have the form name=value; names shall not contain the character
‚Äò=‚Äô. For values to be portable across systems conforming to POSIX.1-2017, the
value shall be composed of characters from the portable character set (except
NUL and as indicated below). There is no meaning associated with the order of
strings in the environment. If more than one string in an environment of a
process has the same name, the consequences are undefined.</em></p>
<p><em>Environment variable names used by the utilities in the Shell and Utilities
volume of POSIX.1-2017 consist solely of uppercase letters, digits, and the
&lt;underscore&gt; ( ‚Äò_‚Äô ) from the characters defined in Portable Character Set
and do not begin with a digit. Other characters may be permitted by an
implementation; applications shall tolerate the presence of such names.
Uppercase and lowercase letters shall retain their unique identities and
shall not be folded together. The name space of environment variable names
containing lowercase letters is reserved for applications. Applications can
define any environment variables with names from this name space without
modifying the behavior of the standard utilities.</em></p></blockquote>
<p>Yes, POSIX-specified utilities use uppercase envvars, but that‚Äôs not
<em>prescriptive</em> for your programs. Quite the contrary: you‚Äôre <em>encouraged</em> to
use lowercase for your envvars so they don‚Äôt collide with the standard tools.</p>
<p>The only strict rule is that a variable name cannot contain an equals sign.
POSIX requires compliant applications to preserve all variables that conform to
this rule.</p>
<p>But in reality, not many applications use lowercase. The <em>proper etiquette</em> in
software development is to use <code>ALL_UPPERCASE</code>.</p>
<h2 id="my-pragmatic-recommendation-is">My pragmatic recommendation is‚Ä¶</h2>
<p>‚Ä¶to use <code>^[A-Z_][A-Z0-9_]*$</code> for names, and UTF-8 for values. You shouldn‚Äôt
hit problems on Linux. If you want to be super safe: instead of UTF-8, use the
POSIX-mandated <a href="https://en.wikipedia.org/wiki/Portable_character_set">Portable Character Set
(PCS)</a> ‚Äì essentially
ASCII without control characters.</p>


<h2 id="wow-i-really-enjoyed-writing-this">Wow, I really enjoyed writing this‚Ä¶</h2>
<p>‚Ä¶and I hope it wasn‚Äôt a boring read.</p>


  
    
  

  </div></div>
  </body>
</html>
