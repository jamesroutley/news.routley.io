<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullderef.com/blog/rust-async-sync/">Original</a>
    <h1>The bane of my existence: Supporting both async and sync code in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><h2 id="_introduction">Introduction</h2><div><p>Imagine you want to create a new library in Rust. All it does is wrap up a
public API that you need for something else, like
<a href="https://developer.spotify.com/documentation/web-api/">the Spotify API</a> or maybe a
database like <a href="https://www.arangodb.com/">ArangoDB</a>. It’s not rocket science, you
aren’t inventing something new or dealing with complex algorithms, so you expect
it to be relatively straightforward.</p><p>You decide to implement the library with async. Most of the work in your library
has to do with performing HTTP requests, which are mostly I/O, so it makes sense
(that, and because it’s what the cool kids use in Rust nowadays). You start
coding and have the v0.1.0 release ready in a few days. “Neat”, you say, as
<code>cargo publish</code> finishes successfully and uploads your work to
<a href="https://crates.io">crates.io</a>.</p><p>A couple of days pass, and you get a new notification on GitHub. Someone opened
an issue:</p><div><blockquote><p><strong>How can I use this library synchronously?</strong></p><p>My project doesn’t use async because it’s overly complex for what I need. I
wanted to try your new library, but I’m not sure how to do it easily. I would
rather not fill my code with <code>block_on(endpoint())</code>. I’ve seen crates like <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a>
exporting a
<a href="https://docs.rs/reqwest/0.11.4/reqwest/blocking/index.html"><code>blocking</code> module</a>
with the exact same functionality, could you perhaps do that as well?</p></blockquote></div><p>Low-level wise, that sounds like a very complicated task. Having a common
interface for both async code — which requires a runtime like <a href="https://crates.io/crates/tokio"><code>tokio</code></a>
, awaiting futures, pinning, etc — and regular sync code? I mean, they asked
nicely, so maybe we can try. After all, the only difference in the code would be
the occurrences of the <code>async</code> and <code>await</code> keywords because you aren’t doing
anything fancy.</p><p>Well, this is <em>more or less</em> what happened with the crate <a href="https://crates.io/crates/rspotify"><code>rspotify</code></a>
, which I used to maintain along with its creator
<a href="https://github.com/ramsayleung/">Ramsay</a>. For those who don’t know, it’s a
wrapper for the Spotify Web API. To clarify, I did get this working in the end,
although not as cleanly as I was hoping; I’ll try to explain the situation in
this new article of the <a href="https://nullderef.com/series/rspotify">Rspotify series</a>.</p></div></div><div><h2 id="_the_first_approaches">The first approaches</h2><div><p>To give more context, here’s what Rspotify’s client looks like, roughly:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Spotify</span><span> </span><span>{</span><span> </span><span>/* ... */</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Spotify</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>some_endpoint</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>param</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>SpotifyResult</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>params</span><span> </span><span>=</span><span> </span><span>HashMap</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>params</span><span>.</span><span>insert</span><span>(</span><span>&#34;param&#34;</span><span>,</span><span> </span><span>param</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>http</span><span>.</span><span>get</span><span>(</span><span>&#34;/some-endpoint&#34;</span><span>,</span><span> </span><span>params</span><span>).</span><span>await</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre></div></div><p>Essentially, we would have to make <code>some_endpoint</code> available for both
asynchronous and blocking users. The important question here is, how do you do
this once you have dozens of endpoints? And how can you make it easy to switch
between async and sync for the user?</p><div><h3 id="_good_ol_copy_pasting">Good ol&#39; copy-pasting</h3><p>This is what was first implemented. It was quite simple and it worked. You just
need to copy the regular client code into a new
<a href="https://github.com/ramsayleung/rspotify/tree/v0.9/src/blocking"><code>blocking</code> module
in Rspotify</a>. <a href="https://docs.rs/reqwest"><code>reqwest</code></a> (our HTTP client) and
<a href="https://docs.rs/reqwest/latest/reqwest/blocking/index.html"><code>reqwest::blocking</code></a>
share the same interface, so we can manually remove keywords like <code>async</code> or
<code>.await</code> and import <code>reqwest::blocking</code> instead of <code>reqwest</code> in the new module.</p><p>Then, the Rspotify user just can just use <code>rspotify::blocking::Client</code> instead
of <code>rspotify::Client</code>, and voilà! Their code is now blocking. This will bloat
the binary size for async-only users, so we can just feature-gate it under the
name <code>blocking</code> and done.</p><p>The problem was much more clear later on, though. Half the crate’s code was
duplicated. Adding a new endpoint or modifying it meant writing or removing
everything twice.</p><p>There is no way to make sure both implementations are equivalent unless you test
absolutely everything. Which isn’t a bad idea either, but maybe you copy-pasted
the tests wrong! How about that? The poor reviewer would have to read through
the same code twice to make sure both sides look alright — which sounds
incredibly prone to human errors.</p><p>In our experience, it really slowed down the development of Rspotify, specially
for new contributors who weren’t used to this whole ordeal. As a new excited
maintainer of Rspotify, I began to
<a href="https://github.com/ramsayleung/rspotify/issues/112">investigate other possible
solutions</a>.</p></div><div><h3 id="_calling_block_on">Calling <code>block_on</code></h3><p><a href="https://github.com/ramsayleung/rspotify/pull/120">The second approach</a> consisted
on implementing everything on the async side. Then, you just make wrappers for
the blocking interface, which call
<a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html#method.block_on"><code>block_on</code></a>
internally. <code>block_on</code> will run the future until completion, basically
making it synchronous. You still need to copy the method <em>definitions</em>, but the
implementation is written once only:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>mod</span> <span>blocking</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>struct</span> <span>Spotify</span><span>(</span><span>super</span>::<span>Spotify</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>impl</span><span> </span><span>Spotify</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>fn</span> <span>endpoint</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>param</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>SpotifyResult</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>runtime</span><span>.</span><span>block_on</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>self</span><span>.</span><span>0.</span><span>endpoint</span><span>(</span><span>param</span><span>).</span><span>await</span><span>
</span></span></span><span><span><span>            </span><span>})</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre></div></div><p>Note that in order to call <code>block_on</code>, you first have to create some kind of
runtime in the endpoint method. For example, with <a href="https://crates.io/crates/tokio"><code>tokio</code></a>
:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span><span>runtime</span><span> </span><span>=</span><span> </span><span>tokio</span>::<span>runtime</span>::<span>Builder</span>::<span>new</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>basic_scheduler</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>enable_all</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>build</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>unwrap</span><span>();</span></span></span></code></pre></div></div><p>This raises the question: should we initialize the runtime in each call to the
endpoint, or is there a way to share it? We could keep it as a global (<em>ewwww</em>),
or perhaps better, we can save the runtime in the <code>Spotify</code> struct. But since it
takes a <em>mutable</em> reference to the runtime, you’d have to wrap it up with
<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, completely killing the concurrency in your client. The proper
way to do this is with Tokio’s
<a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Handle.html"><code>Handle</code></a>, which
looks like this:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>tokio</span>::<span>runtime</span>::<span>Runtime</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>lazy_static!</span><span> </span><span>{</span><span> </span><span>// You can also use `once_cell`
</span></span></span><span><span><span></span><span>    </span><span>static</span><span> </span><span>ref</span><span> </span><span>RT</span>: <span>Runtime</span><span> </span><span>=</span><span> </span><span>Runtime</span>::<span>new</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>endpoint</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>param</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>SpotifyResult</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>RT</span><span>.</span><span>handle</span><span>().</span><span>block_on</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>0.</span><span>endpoint</span><span>(</span><span>param</span><span>).</span><span>await</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre></div></div><p>While the handle does make our blocking client faster <a href="#block-on-perf">[1]</a>, there
is an even more performant way to do it. This is what <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a>
itself does, in case you’re interested. In short, it spawns a thread that calls
<code>block_on</code> waiting on a channel with jobs <a href="#block-on-channels">[2]</a>
<a href="#block-on-reqwest">[3]</a>.</p><p>Unfortunately, this solution still has quite the overhead. You pull in large
dependencies like <code>futures</code> or <code>tokio</code>, and include them in your binary. All of
that, in order to…​ actually end up writing blocking code. So not only is it a
cost at runtime, but also at compile time. It just feels wrong to me.</p><p>And you still have a good amount of duplicate code, even if it’s just
definitions, which can sum up. <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a>
is a huge project and can
probably afford this for their <code>blocking</code> module. But for a less popular crate
like <code>rspotify</code>, this is harder to pull off.</p></div><div><h3 id="_duplicating_the_crate">Duplicating the crate</h3><p>Another possible way to fix this is, as the features docs suggest, creating
separate crates. We’d have <code>rspotify-sync</code> and <code>rspotify-async</code>, and users would
just pick whichever crate they want as a dependency, even both if they need to.
The problem is — again — how exactly do we generate both versions of the
crate? <a href="https://github.com/ramsayleung/rspotify/pull/253">I was unable to do this
without copy-pasting the entire crate</a>, even with Cargo tricks like two
<code>Cargo.toml</code> files, one for each crate (which was quite inconvenient anyway).</p><p>With this idea we can’t even use procedural macros because you can’t just create
a new crate within a macro. We could define a file format to write templates of
Rust code in order to replace parts of the code like <code>async</code>/<code>.await</code>. But that
sounds completely out of scope.</p></div></div></div><div><h2 id="_what_ended_up_working_the_maybe_async_crate">What ended up “working”: the <code>maybe_async</code> crate</h2><div><p><a href="https://github.com/ramsayleung/rspotify/pull/129">The third attempt</a> is based on
a crate called <a href="https://crates.io/crates/maybe_async"><code>maybe_async</code></a>
. I remember foolishly thinking it was
the perfect solution back when I discovered it.</p><p>Anyway, the idea is that with this crate you can automatically remove the
<code>async</code> and <code>.await</code> occurrences in your code with a procedural macro,
essentially automating the copy-pasting approach. For example:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[maybe_async::maybe_async]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>endpoint</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff */</span><span> </span><span>}</span></span></span></code></pre></div></div><p>Generates the following code:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[cfg(not(feature = </span><span>&#34;is_sync&#34;</span><span>))]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>endpoint</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff */</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[cfg(feature = </span><span>&#34;is_sync&#34;</span><span>)]</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>endpoint</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff with `.await` removed */</span><span> </span><span>}</span></span></span></code></pre></div></div><p>You can configure whether you want asynchronous or blocking code by toggling the
<code>maybe_async/is_sync</code> feature when compiling the crate. The macro works for
functions, traits and <code>impl</code> blocks. If one conversion isn’t as easy as removing
<code>async</code> and <code>.await</code>, you can specify custom implementations with the
<code>async_impl</code> and <code>sync_impl</code> procedural macros. It does this wonderfully, and
we’ve already been using it for Rspotify for a while now.</p><p>In fact, it worked so well that I made Rspotify <em>http-client agnostic</em>, which is
even more flexible than being <em>async/sync agnostic</em>. This allows us to support
multiple HTTP clients like <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a>
and <a href="https://crates.io/crates/ureq"><code>ureq</code></a>
,
independently of whether the client is asynchronous or synchronous.</p><p>Being <em>http-client agnostic</em> is not that hard to implement if you have
<code>maybe_async</code> around. You just need to define a trait for the
<a href="https://github.com/ramsayleung/rspotify/blob/89b37219a2230cdcf08c4cfd2ebe46d64902f03d/rspotify-http/src/common.rs#L46">HTTP
client</a>, and then implement it for each of the clients you want to support:</p><div><p>A snippet of code is worth a thousand words. (<em>You can find the full source for Rspotify’s <a href="https://github.com/ramsayleung/rspotify/blob/master/rspotify-http/src/reqwest.rs#L97"><code>reqwest</code>&#39;s client here</a>, and <a href="https://github.com/ramsayleung/rspotify/blob/master/rspotify-http/src/ureq.rs#L56"><code>ureq</code>&#39;s here</a></em>)</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[maybe_async]</span><span>
</span></span></span><span><span><span></span><span>trait</span><span> </span><span>HttpClient</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>get</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[sync_impl]</span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>HttpClient</span><span> </span><span>for</span><span> </span><span>UreqClient</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>get</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span> </span><span>ureq</span>::<span>get</span><span>(</span><span>/* ... */</span><span>)</span><span> </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[async_impl]</span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>HttpClient</span><span> </span><span>for</span><span> </span><span>ReqwestClient</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>get</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span> </span><span>reqwest</span>::<span>get</span><span>(</span><span>/* ... */</span><span>).</span><span>await</span><span> </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>SpotifyClient</span><span>&lt;</span><span>Http</span>: <span>HttpClient</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>http</span>: <span>Http</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[maybe_async]</span><span>
</span></span></span><span><span><span></span><span>impl</span><span>&lt;</span><span>Http</span>: <span>HttpClient</span><span>&gt;</span><span> </span><span>SpotifyClient</span><span>&lt;</span><span>Http</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>endpoint</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>{</span><span> </span><span>self</span><span>.</span><span>http</span><span>.</span><span>get</span><span>(</span><span>/* ... */</span><span>)</span><span> </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre></div></div><p>Then, we could extend it so that whichever client they want to use can be
enabled with feature flags in their <code>Cargo.toml</code>. For example, if <code>client-ureq</code>
is enabled, since <code>ureq</code> is synchronous, it would enable <code>maybe_async/is_sync</code>.
In turn, this would remove the <code>async</code>/<code>.await</code> and the <code>#[async_impl]</code> blocks,
and the Rspotify client would use <code>ureq</code>&#39;s implementation internally.</p><p>This solution has none of the downsides I listed in previous attempts:</p><div><ul><li><p>No code duplication at all</p></li><li><p>No overhead neither at runtime nor at compile time. If the user wants a
blocking client, they can use <code>ureq</code>, which doesn’t pull <code>tokio</code> and friends</p></li><li><p>Quite easy to understand for the user; just configure a flag in you
<code>Cargo.toml</code></p></li></ul></div><p>However, stop reading for a couple of minutes and try to figure out why you
shouldn’t do this. In fact, I’ll give you 9 months, which is how long it took me
to do so…​</p><div><h3 id="_the_problem">The problem</h3><div><p><img src="https://nullderef.com/blog/rust-async-sync/preview.jpg" alt="preview" width="100%"/></p></div><p>Well, the thing is that features in Rust must be <strong>additive</strong>: “enabling a
feature should not disable functionality, and it should usually be safe to
enable any combination of features”. Cargo may merge features of a crate when
it’s duplicated in the dependency tree in order to avoid compiling the same
crate multiple times.
<a href="https://doc.rust-lang.org/cargo/reference/features.html#feature-unification">The
reference explains this quite well, if you want more details</a>.</p><p>This optimization means that mutually exclusive features may break a dependency
tree. In our case, <code>maybe_async/is_sync</code> is a <em>toggle</em> feature enabled by
<code>client-ureq</code>. So if you try to compile it with <code>client-reqwest</code> also enabled,
it will fail because <code>maybe_async</code> will be configured to generate synchronous
function signatures instead. It’s impossible to have a crate that depends on
both sync and async Rspotify either directly or indirectly, and the whole
concept of <code>maybe_async</code> is currently wrong according to the Cargo reference.</p></div><div><h3 id="_the_feature_resolver_v2">The feature resolver v2</h3><p>A common misconception is that this is fixed by the “feature resolver v2”,
which
<a href="https://doc.rust-lang.org/cargo/reference/features.html#feature-resolver-version-2">the
reference also explains quite well</a>. It has been enabled by default since the
2021 edition, but you can specify it inside your <code>Cargo.toml</code> in previous ones.
This new version, among other things, avoids unifying features in some special
cases, but not in ours:</p><div><blockquote><div><ul><li><p>Features enabled on platform-specific dependencies for targets not currently
being built are ignored.</p></li><li><p>Build-dependencies and proc-macros do not share features with normal
dependencies.</p></li><li><p>Dev-dependencies do not activate features unless building a target that needs
them (like tests or examples).</p></li></ul></div></blockquote></div><p>Just in case, I tried to reproduce this myself, and it did work as I expected.
<a href="https://github.com/marioortizmanero/resolver-v2-conflict">This repository</a> is an
example of conflicting features, which breaks with any feature resolver.</p></div><div><h3 id="_other_fails">Other fails</h3><p>There were a few crates that also had this problem:</p><div><ul><li><p><a href="https://crates.io/crates/arangors"><code>arangors</code></a>
and <a href="https://crates.io/crates/aragog"><code>aragog</code></a>
: wrappers for ArangoDB. Both
use <code>maybe_async</code> to switch between async and sync (<code>arangors</code>&#39;s author is
the same person, in fact) <a href="#arangors-error">[5]</a> <a href="#aragog-error">[6]</a>.</p></li><li><p><a href="https://crates.io/crates/inkwell"><code>inkwell</code></a>
: a wrapper for LLVM. It supports multiple versions of
LLVM, which are not compatible with eachother <a href="#inkwell-error">[7]</a>.</p></li><li><p><a href="https://crates.io/crates/k8s-openapi"><code>k8s-openapi</code></a>
: a wrapper for Kubernetes, with the same issue as
<code>inkwell</code> <a href="#k8s-error">[8]</a>.</p></li></ul></div></div><div><h3 id="_fixing_maybe_async">Fixing <code>maybe_async</code></h3><p>Once the crate started to gain popularity, this issue was opened in
<code>maybe_async</code>, which explains the situation and showcases a fix:</p><p><code>maybe_async</code> would now have two feature flags: <code>is_sync</code> and <code>is_async</code>. The
crate would generate the functions in the same way, but with a <code>_sync</code> or
<code>_async</code> suffix appended to the identifier so that they wouldn’t be conflicting.
For example:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[maybe_async::maybe_async]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>endpoint</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff */</span><span> </span><span>}</span></span></span></code></pre></div></div><p>Would now generate the following code:</p><div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[cfg(feature = </span><span>&#34;is_async&#34;</span><span>)]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>endpoint_async</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff */</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[cfg(feature = </span><span>&#34;is_sync&#34;</span><span>)]</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>endpoint_sync</span><span>()</span><span> </span><span>{</span><span> </span><span>/* stuff with `.await` removed */</span><span> </span><span>}</span></span></span></code></pre></div></div><p>However, these suffixes introduce noise, so I wondered if it would be possible
to do it in a more ergonomic way. I forked <code>maybe_async</code> and gave it a try,
about which you can read more
<a href="https://github.com/fMeow/maybe-async-rs/issues/6#issuecomment-880581551">in this
series of comments</a>. In summary, it was too complicated, and I ultimately gave
up.</p><p>The only way to fix this edge case would be to worsen the usability of Rspotify
for everyone. But I’d argue that someone who depends on both async and sync is
unlikely; we haven’t actually had anyone complaining yet. Unlike <code>reqwest</code>,
<code>rspotify</code> is a “high level” library, so it’s hard to imagine a scenario where
it appears more than once in a dependency tree in the first place.</p><p>Perhaps we could ask the Cargo devs for help?</p></div><div><h3 id="_official_support">Official Support</h3><p>Rspotify is far from being the first who has been through this problem, so it
might be interesting to read previous discussions about it:</p><div><ul><li><p><a href="https://github.com/rust-lang/rfcs/pull/2962">This now-closed RFC for the Rust
compiler</a> suggested adding the <code>oneof</code> configuration predicate (think
<code>#[cfg(any(…​))]</code> and similars) to support exclusive features. This only
makes it easier to have conflicting features for cases where there’s <em>no
choice</em>, but features should still be strictly additive.</p></li><li><p>The previous RFC started
<a href="https://internals.rust-lang.org/t/pre-rfc-cargo-mutually-exclusive-features/13182/27">some
discussion</a> in the context of allowing exclusive features in Cargo itself, and
although it has some interesting info, it didn’t go too far.</p></li><li><p><a href="https://github.com/rust-lang/cargo/issues/2980">This issue in Cargo</a> explains a
similar case with the Windows API. The discussion includes more examples and
solution ideas, but none have made it to Cargo yet.</p></li><li><p><a href="https://github.com/rust-lang/cargo/issues/4803">Another issue in Cargo</a> asks
for a way to test and build with combinations of flags easily. If features are
strictly additive, then <code>cargo test --all-features</code> will cover everything. But
in case it doesn’t, the user has to run the command with multiple combinations
of feature flags, which is quite cumbersome. This is already possible
unofficially thanks to <a href="https://github.com/taiki-e/cargo-hack"><code>cargo-hack</code></a>.</p></li><li><p>A completely different approach
<a href="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html">based
on the Keyword Generics Initiative</a>. It seems to be the most recent take on
solving this, but it’s in an “exploration” phase, and
<a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html#q-is-there-an-rfc-available-to-read">no
RFCs are available as of this writing</a>.</p></li></ul></div><p>According to
<a href="https://github.com/rust-lang/rfcs/pull/2962#issuecomment-664656377">this old
comment</a>, it’s not something the Rust team has already discarded; it’s still
being discussed.</p><p>Although unofficial, another interesting approach that could be explored further
in Rust is <a href="https://sans-io.readthedocs.io/">“Sans I/O”</a>. This is a Python
protocol that abstracts away the use of network protocols like HTTP in our case,
thus maximizing reusability. An existing example in Rust would be
<a href="https://github.com/EmbarkStudios/tame-oidc"><code>tame-oidc</code></a>.</p></div></div></div><div><h2 id="_conclusion">Conclusion</h2><div><p>We currently have a choice to make between:</p><div><ul><li><p>Ignoring the Cargo Reference. We could assume that noone is going to use both
sync and async for Rspotify at the same time.</p></li><li><p>Fixing <code>maybe_async</code> and adding <code>_async</code> and <code>_sync</code> suffixes to each endpoint
in our library.</p></li><li><p>Dropping support for both async and sync code. It’s kind of become a mess that
we don’t have the manpower to deal with and that
<a href="https://github.com/ramsayleung/rspotify/pull/224#issuecomment-909324671">affects
other parts of Rspotify</a>. The problem is that some crates that depend on
rspotify like <a href="https://github.com/hrkfdn/ncspot"><code>ncspot</code></a> or
<a href="https://github.com/Spotifyd/spotifyd"><code>spotifyd</code></a> are blocking, and others like
<a href="https://github.com/Rigellute/spotify-tui"><code>spotify-tui</code></a> use async, so I’m not
sure what they’d think.</p><p>I know this is a problem that I’ve imposed to myself. We could just say “No. We
only support async” or “No. We only support sync”. While there are users
interested in being able to use both, sometimes you just have to say no. If such
a feature becomes so complicated to deal with that your entire codebase becomes
a mess, and you don’t have the engineering power to maintain it, then it’s your
only choice. If someone cared enough, they could just fork the crate and convert
it to synchronous for their own usage.</p><p>After all, most API wrappers and the like only support either asynchronous or
blocking code. <a href="https://crates.io/crates/serenity"><code>serenity</code></a>
(Discord API), <a href="https://crates.io/crates/sqlx"><code>sqlx</code></a>
(SQL
toolkit) and <a href="https://crates.io/crates/teloxide"><code>teloxide</code></a>
(Telegram API) are async-only, for example,
and they’re quite popular.</p></li></ul></div><p>Even though it was quite frustrating at times, I don’t really regret spending so
much time walking in circles trying to get both async and sync to work. I was
contributing to Rspotify in the first place just to <em>learn</em>. I had no deadlines
and no stress, I just wanted to try to improve a library in Rust in my free
time. And I <em>have</em> learned a lot; hopefully you too, after reading this.</p><p>Perhaps the lesson today is that we should remember that Rust is a low level
language after all, and there are some things that aren’t possible without a lot
of complexity. Anyhow, I’m looking forward to how the Rust team fixes this in
the future.</p><p>So what do you think? What would you do if you were a maintainer of Rspotify?
You can leave a comment below if you like.</p></div></div></div></div>
  </body>
</html>
