<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ruby/ruby/pull/7448">Original</a>
    <h1>RJIT, a new JIT for Ruby</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <task-lists disabled="" sortable="">
    <div>
      <p dir="auto">full diff<sup><a href="#user-content-fn-1-5a840e8dc62a4dc9f8d4b02474443677" id="user-content-fnref-1-5a840e8dc62a4dc9f8d4b02474443677" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>: <a href="https://github.com/ruby/ruby/compare/55367b3bd7f40c57949be7f8e3c4fd621976b851...22d944c8b76be04dc437100c46626db5fe9dd7f0"><tt>55367b3...22d944c</tt></a></p>
<h2 dir="auto">Description</h2>
<p dir="auto">This PR replaces the current implementation of MJIT with a new JIT called &#34;RJIT&#34; <sup><a href="#user-content-fn-2-5a840e8dc62a4dc9f8d4b02474443677" id="user-content-fnref-2-5a840e8dc62a4dc9f8d4b02474443677" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>.</p>
<ul dir="auto">
<li>RJIT uses a pure-Ruby assembler to generate native code
<ul dir="auto">
<li>MJIT requires a C compiler at runtime. YJIT requires a Rust compiler at build time. RJIT doesn&#39;t require them.</li>
<li>This means that RJIT&#39;s warmup could be slower than YJIT, but it&#39;s still much faster than MJIT&#39;s.</li>
</ul>
</li>
<li>The code generated by RJIT looks very similar to YJIT
<ul dir="auto">
<li>In fact, many methods are direct translations of the Rust code into Ruby.</li>
<li>This allows us to simplify the Ruby VM by removing MJIT-specific implementations.</li>
<li>We could do some early experiments for YJIT in RJIT too if we want.</li>
</ul>
</li>
</ul>
<p dir="auto">See the ticket for motivation and further details: <a href="https://bugs.ruby-lang.org/issues/19420" rel="nofollow">[Feature #19420]</a></p>
<h2 dir="auto">Benchmark</h2>
<p dir="auto">I benchmarked the interpreter, YJIT, RJIT, and MJIT with <a href="https://github.com/shopify/yjit-bench">yjit-bench</a>.</p>
<h3 dir="auto">Headline</h3>
<p dir="auto">RJIT&#39;s performance is still nowhere near YJIT&#39;s, but notably RJIT outperforms MJIT in all headline benchmarks, which are considered the most real-world workloads. RJIT gives a small speedup on railsbench even with yjit-bench&#39;s short warmup.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/3138447/223297312-cc106c40-f0c2-44d4-97e1-d3d49a0839e4.png"><img src="https://user-images.githubusercontent.com/3138447/223297312-cc106c40-f0c2-44d4-97e1-d3d49a0839e4.png" alt="output_543"/></a></p>
<h3 dir="auto">Other</h3>
<p dir="auto">Sometimes MJIT is still better than RJIT. However, RJIT outperforms both YJIT and MJIT on Optcarrot, which was the benchmark used for <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/" rel="nofollow">the Ruby 3x3 milestone</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/3138447/223298983-5c58ec19-bcd6-42de-b421-5bbcdf04ea2d.png"><img src="https://user-images.githubusercontent.com/3138447/223298983-5c58ec19-bcd6-42de-b421-5bbcdf04ea2d.png" alt="output_542"/></a></p>
<h3 dir="auto">Micro</h3>
<p dir="auto">30k_ifelse and 30k_methods are the things that YJIT is very good at, but RJIT outperforms YJIT on them. This seems to be because YJIT chose to interleave inline code and outlined code for Code GC and arm64&#39;s performance whereas RJIT doesn&#39;t do that. This is a good reminder of the code layout&#39;s impact.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/3138447/223299006-d06c923b-74b1-431f-83ef-5a64cfd52e9b.png"><img src="https://user-images.githubusercontent.com/3138447/223299006-d06c923b-74b1-431f-83ef-5a64cfd52e9b.png" alt="output_544"/></a></p>
<section data-footnotes=""><h2 id="footnote-label" dir="auto">Footnotes</h2>
<ol dir="auto">
<li id="user-content-fn-1-5a840e8dc62a4dc9f8d4b02474443677">
<p dir="auto">I merged this branch in multiple batches because pushing hundreds of commits at once pressures our notification system a bit. However, an auto-format commit interrupted the operation, so I needed to resolve the conflict and this PR has only the diff after that commit. <a href="#user-content-fnref-1-5a840e8dc62a4dc9f8d4b02474443677" data-footnote-backref="" aria-label="Back to reference 1"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a></p>
</li>
<li id="user-content-fn-2-5a840e8dc62a4dc9f8d4b02474443677">
<p dir="auto">This PR doesn&#39;t rename the interface and internal names from MJIT to RJIT yet, but a separate PR will do that soon. <a href="#user-content-fnref-2-5a840e8dc62a4dc9f8d4b02474443677" data-footnote-backref="" aria-label="Back to reference 2"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a></p>
</li>
</ol>
</section>
    </div>
  </task-lists>
  
</div>

      </div></div>
  </body>
</html>
