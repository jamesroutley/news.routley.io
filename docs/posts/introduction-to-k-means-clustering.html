<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/k-means-clustering/">Original</a>
    <h1>Introduction to K-Means Clustering</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>With massive data volumes growing at exponential rates, we need to find scalable methods to process them and find insights. The world of data entered the Zettabyte era several years ago. What’s a Zettabyte? Well, it is <a href="https://www.pcmag.com/news/seagate-is-the-first-company-to-ship-3-zettabytes-of-hard-drive-storage">enough storage</a> for 30 billion 4K movies, or 60 billion video games, or 7.5 trillion MP3 songs.</p><p>Today, the total amount of data created, captured, copied, and consumed globally is in the order of 100 Zettabytes and just keeps growing.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/eaf839d8f202e209f7324a1a293e4ca8940d2580/dbc89/images/global-data-creation.png" alt="Global data creation"/>
<small>Through 2035, global data creation is projected to grow to more than 2,142 Zettabytes. From 2020, the growth was higher than previously expected caused by increased demand due to the COVID-19 pandemic, as more people worked and learned from home and used more home entertainment options. Source: <a href="https://www.statista.com">Statista</a></small></p><p>Although this might seem overwhelming, the good news is that we can turn to machines for help: There are many different Machine Learning algorithms to discover patterns in big data that lead to actionable insights.</p><p>Depending on the way the algorithm “learns” about data to make predictions, we classify them into two groups, each proving one different type of learning:</p><ul><li><p><strong>Supervised learning:</strong> existing data is already labeled and you know which behavior you want to predict in the new data you obtain.</p></li><li><p><strong>Unsupervised learning:</strong> there is no output variable to guide the learning process,and data is explored by algorithms to find patterns. Since the data has no labels, the algorithm identifies similarities on the data points and groups them into clusters.</p></li></ul><p>Under unsupervised learning, all the objects in the same group (cluster) should be more similar to each other than to those in other clusters; data points from different clusters should be as different as possible. Clustering allows you to find and organize data into groups that have been formed organically, rather than defining groups before looking at the data.</p><p>While this article will focus most closely on K-means, there are other powerful types of clustering that can be used as well. Let’s take a look at the main ones like hierarchical, density-based, and partitional clustering.</p><h2 id="hierarchical-clustering">Hierarchical Clustering</h2><p>Cluster assignments are determined by building a hierarchy. This is implemented by either a bottom-up or a top-down approach:</p><ul><li><p>The bottom-up approach is called <strong>agglomerative</strong> clustering and merges the two points that are the most similar until all points have been merged into a single cluster.</p></li><li><p>The top-down approach is <strong>divisive</strong> clustering and starts with all points as one cluster and splits the least similar clusters at each step until only single data points remain.</p></li></ul><p><img src="https://d33wubrfki0l68.cloudfront.net/3b0441de64ac06eccdce871c61453f50203fb616/91444/images/hierarchical-clustering.png" alt="Hierarchical clustering"/>
<small>The agglomerative case starts with every object being a cluster and, in the next steps, merges them with the two closest clusters. The process finishes with every object in one cluster. The divisive algorithm, contrastingly, starts with every object in one cluster and ends with every object in individual clusters. Source: <a href="https://quantdare.com/hierarchical-clustering/">QuantDare</a></small></p><p>These methods produce a tree-based hierarchy of points called a dendrogram. The number of clusters “k” is often predetermined by the user, and clusters are assigned by cutting the dendrogram at a specified depth that results in “k” groups of smaller dendrograms.</p><video autoplay="" loop="" muted="" playsinline="">
  <source src="https://d33wubrfki0l68.cloudfront.net/1e7845d2aa41a8e3654a37a877bc9f0fd391cd00/ceb7f/images/hierarchical-clustering-dendrogram.mp4" type="video/mp4"/></video><p><small>Hierarchical Clustering returns an output (typically as a dendrogram like the right figure) from which the user can decide the appropriate number of clusters (either manually or algorithmically). If done manually, the user may cut the dendrogram where the merged clusters are too far apart (represented by long lines in the dendrogram). Alternatively, the user can just return a specific number of clusters. Source: <a href="https://dashee87.github.io/data%20science/general/Clustering-with-Scikit-with-GIFs/">Dashee87</a></small></p><p>Unlike other clustering techniques, hierarchical clustering is a <strong>deterministic process</strong>, which means that assignments won’t change when you run an algorithm multiple times on the same input data. Hierarchical clustering methods often reveal the finer details about the relationships between data objects and provide interpretable dendrograms. On the other hand, they’re computationally expensive with respect to algorithm complexity and sensitive to noise and outliers.</p><h2 id="density-based-clustering">Density-Based Clustering</h2><p>Under this category, cluster assignments are determined based on the density of data points in a region and assigned where there are high densities of data points separated by low-density regions.</p><p>Unlike other clustering categories, this approach doesn’t require the user to specify the number of clusters. Instead, there is a distance-based parameter that acts as a tunable threshold and determines how close points must be to be considered a cluster member.</p><video autoplay="" loop="" muted="" playsinline="">
  <source src="https://d33wubrfki0l68.cloudfront.net/2a3bddd54a374d0b22d07f52a5773eccec018237/fc9be/images/density-based-clustering-algorithm.mp4" type="video/mp4"/></video><p><small>Density-Based Clustering algorithms like DBSCAN don’t require a preset number of clusters. It also identifies outliers as noises unlike others that simply throws them into a cluster even if the data point is very different. Additionally, it is able to find arbitrarily sized and arbitrarily shaped clusters quite well. Source: <a href="http://primo.ai/index.php?title=Density-Based_Spatial_Clustering_of_Applications_with_Noise_(DBSCAN)">Primo.ai</a></small></p><p>Density-based clustering methods excel at identifying clusters of nonspherical shapes, and they are resistant to outliers. Nevertheless, they aren’t well suited for clustering in high-dimensional spaces (since <a href="https://scialert.net/fulltext/?doi=itj.2011.1092.1105">density of data points is very low</a> in those spaces), and they are not able to produce <a href="http://vigir.missouri.edu/~gdesouza/Research/Conference_CDs/IEEE_SSCI_2016/pdf/SSCI16_paper_256.pdf">clusters of differing density</a>.</p><h2 id="partitional-clustering">Partitional clustering</h2><p>With this method, data objects are divided into non-overlapping groups: No object can be a member of more than one cluster, and every cluster must have at least one object.</p><p>Like in hierarchical clustering, the user needs to define the number of clusters “k”, which ultimately produces <strong>non-deterministic</strong> results: Partitional clustering produces different results from two or more separate runs even if the runs were based on the same input.</p><p>This clustering method works very well when clusters have a spherical shape (due to its <a href="https://academic.oup.com/bioinformatics/article/21/9/1927/408943">fixed distance norm</a>), and they’re scalable with respect to algorithm complexity. However, they’re not well suited for clusters with complex shapes and different sizes, and they break down when used with clusters of different densities, since it doesn’t employ density parameters.</p><video autoplay="" loop="" muted="" playsinline="">
  <source src="https://d33wubrfki0l68.cloudfront.net/7414c7d54f415a99c315464ea4a1ff61157f44f6/ec40d/images/partitional-clustering-algorithm.mp4" type="video/mp4"/></video><p><small>Partitional clustering algorithms deal with the data space and focus on creating a certain number of divisions of the space. Source: <a href="https://www.whatmatrix.com/portal/clustering-algorithms-from-start-to-state-of-the-art-2/">What Matrix</a></small></p><p><strong>K-means</strong> is an example of a partitional clustering algorithm. Once the algorithm has been run and the groups are defined, any new data can be easily assigned to the existing groups. K-means is an extremely popular clustering algorithm, widely used in tasks like behavioral segmentation, inventory categorization, sorting sensor measurements, and detecting bots or anomalies.</p><h2 id="k-means-clustering">K-means clustering</h2><p>From the universe of unsupervised learning algorithms, K-means is probably the most recognized one. This algorithm has a clear objective: partition the data space in such a way so that data points within the same cluster are as similar as possible (intra-class similarity), while data points from different clusters are as dissimilar as possible (inter-class similarity).</p><p><img src="https://d33wubrfki0l68.cloudfront.net/c56af9d4f9f663c62c03666a4542ab96cd29112f/45e9e/images/intercluster-intracluster-distance.png" alt="Intercluster and intracluster distance"/>
<small>An illustration of inter-cluster and intra-cluster distance. Source: <a href="https://dinhanhthi.com/">dinhanhthi.com</a></small></p><p>In K-means, each cluster is represented by its center (called a “centroid”), which corresponds to the arithmetic mean of data points assigned to the cluster. A <strong>centroid</strong> is a data point that represents the center of the cluster (the mean), and it might not necessarily be a member of the dataset. This way, the algorithm works through an iterative process until each data point is closer to its own cluster’s centroid than to other clusters’ centroids, minimizing intra-cluster distance at each step. But how?</p><p>K-means searches for a predetermined number of clusters within an unlabelled dataset by using an iterative method to produce a final clustering based on the number of clusters defined by the user (represented by the variable K). For example, by setting “k” equal to 2, your dataset will be grouped in 2 clusters, while if you set “k” equal to 4 you will group the data in 4 clusters.</p><p>K-means triggers its process with arbitrarily chosen data points as proposed centroids of the groups and iteratively recalculates new centroids in order to converge to a final clustering of the data points. Specifically, the process works as follows:</p><ol><li><p>The algorithm randomly chooses a centroid for each cluster. For example, if we choose a “k” of 3, the algorithm randomly picks 3 centroids.</p></li><li><p>K-means assigns every data point in the dataset to the nearest centroid, meaning that a data point is considered to be in a particular cluster if it is closer to that cluster’s centroid than any other centroid.</p></li><li><p>For every cluster, the algorithm recomputes the centroid by taking the average of all points in the cluster, reducing the total intra-cluster variance in relation to the previous step. Since the centroids change, the algorithm re-assigns the points to the closest centroid.</p></li><li><p>The algorithm repeats the calculation of centroids and assignment of points until the sum of distances between the data points and their corresponding centroid is minimized, a maximum number of iterations is reached, or no changes in centroids value are produced.</p></li></ol><video autoplay="" loop="" muted="" playsinline="">
  <source src="https://d33wubrfki0l68.cloudfront.net/b82636e08b20444293722bf5c949663ba65ec170/9f17a/images/k-means-algorithm.mp4" type="video/mp4"/></video><p><small>The figure shows the centroids updating through the first five iterations from two different runs of the K-means algorithm on the same dataset. The purpose of this figure is to show that the initialization of the centroids is an important step. Source: <a href="https://realpython.com/k-means-clustering-python/">Real Python</a></small></p><h3 id="finding-the-value-of-k">Finding the value of K</h3><p>How do you choose the right value of “k”? When you define “k” you are telling the algorithm how many centroids you want, but how do you know how many clusters to produce?</p><p>One popular approach is testing different numbers of clusters and measuring the resulting Sum of Squared Errors (SSE), choosing the “k” value at which an increase will cause a very small decrease in the error sum, while a decrease will sharply increase the error sum. This point that defines the optimal number of clusters is known as the “elbow point”.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/08d06d22a2d385a02385a4bb91edb46c70f85408/77749/images/sum-squared-errors.png" alt="Sum of squared errors"/>
<small>As the number of clusters increases, the Sum of Squared Errors within clusters will start to decrease. The error value is largest when “k” = 1. We can see that the graph will rapidly change at a point,thus creating an elbow shape. From this point, the graph starts to move almost parallel to the X-axis. The “k” value corresponding to this point is the optimal number of clusters. Source: <a href="https://www.analyticsvidhya.com/blog/2021/01/in-depth-intuition-of-k-means-clustering-algorithm-in-machine-learning/">Analytics Vidhya</a></small></p><p>Another alternative is to use the Silhouette Coefficient metric. This coefficient is a measure of cluster cohesion and separation, frequently used in unsupervised learning problems. It quantifies how well a data point fits into its assigned cluster based on two factors:</p><ul><li>How close the data point is to other points in the cluster</li><li>How far away the data point is from points in other clusters</li></ul><p>Silhouette coefficient values range between -1 and 1, meaning that well-defined clusters result in positive values of this coefficient, while incorrect clusters will result in negative values.</p><p>We can use a Silhouette plot to display a <a href="https://neptune.ai/blog/k-means-clustering">measure of how close each point in one cluster is to a point in the neighboring clusters</a> and thus provide a way to assess parameters like the number of clusters visually.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/5bd05cf2f5c3634d65cf2c3ee22e8ff626c8735c/6bb24/images/silhouette-analysis.png" alt="Silhouette analysis"/>
<small>Using the above Silhouette analysis, we can choose an optimal k value as 3 because the average silhouette score is higher and indicates that the data points are optimally positioned. Source: <a href="https://neptune.ai/blog/k-means-clustering">Neptune Blog</a></small></p><h2 id="when-to-use-k-means-clustering">When to Use K-Means Clustering</h2><p>K-means presents huge <a href="https://developers.google.com/machine-learning/clustering/algorithm/advantages-disadvantages">advantages</a>, since it scales to large data sets, is relatively simple to implement, guarantees convergence, can warm-start the positions of centroids, it easily adapts to new examples, and generalizes to clusters of different shapes and sizes, such as elliptical clusters.</p><p>But as any other Machine Learning method, it also presents downsides. The most obvious one is that you need to define the number of clusters manually, and, although we showed some ways to find the optimal “k”, this is a decision that will deeply affect the results.</p><p>Also, K-means is highly dependent on initial values. For low values of “k”, you can mitigate this dependence by running K-means several times with different initial values and picking the best result. As “k” increases, you need <a href="https://developers.google.com/machine-learning/clustering/algorithm/advantages-disadvantages">advanced versions of K-means</a> to pick better values of the initial centroids (called K-means seeding). K-means produces clusters with uniform sizes (in terms of density and quantity of observations), even though the underlying data might behave in a very different way. Finally, K-means is very sensitive to outliers, since centroids can be dragged in the presence of noisy data.</p><p>K-means is highly flexible and can be used to cluster data in lots of different domains. It also can be modified to adapt it to specific challenges, making it extremely powerful. Whether you’re dealing with structured data, <a href="https://www.pinecone.io/learn/vector-embeddings/">embeddings</a>, or any other data type, you should definitely consider using K-means.</p></div></div></div></div>
  </body>
</html>
