<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w4d5-types-tests-that-you-get-for-free">Original</a>
    <h1>RC W4D5 - Types: tests that you get for free?</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1952812">
    
      <div><p>if you search for “there is more than one way to do it”, the link that comes up top on Google is this <a href="http://wiki.c2.com/?ThereIsMoreThanOneWayToDoIt">one</a> from WikiWikiWeb (which I learned is <a href="https://wiki.c2.com/?WikiIsNotWikipedia">different</a> from Wikipedia). It’s an expansive take on the expressiveness vs interpretability <a href="https://payments.posthaven.com/rc-w4d1-expressiveness-vs-interpretability-in-programming-languages">discussion</a>. I suppose you could write ‘fast’ vs ‘quick’ vs ’swift’ and the meaning would be more apt in different contexts, which was my take away from this excerpt.</p><blockquote><p>Its inventor, LarryWall, is trained as a linguist. He has this crazy notion that sometimes phrasing a sentence differently might make its meaning clearer…</p></blockquote><p>Next I learned from the Python vs Ruby <a href="http://wiki.c2.com/?PythonVsRuby">page</a> that Ruby inherits from Smalltalk and Perl, believing that &#39;everything is an object&#39; and ’there is more than one way to do it’, whereas Python inherits from the Algol family. I didn’t have Smalltalk and Algol in my <a href="https://payments.posthaven.com/rc-w4d3-getting-chatgpt-to-categorize-programming-languages">categorization</a>, and ChatGPT added them to the respective groups as expected.</p><p>Re: last week, working through Idris was not easy. I signed up to present as a way to force myself to talk about a distinctive facet of the language. I managed to weave a thread around types as &#39;tests that you get for free&#39; (detailed below), but I might need a proper project or use case as motivation to overcome the pain points and get deeper into the (experimental) language. Naturally it doesn&#39;t help that Idris as a language is not the easiest to look up on Google.</p><p>In the remaining pockets of time, I watched more Graham Hutton on Haskell, Bartosz Milewski on category theory, and Andrej Karpathy on generative models. I also spend a bit of time reading up (and later writing on) <a href="https://payments.posthaven.com/rc-w4d4-exploring-effect-systems">effect systems</a> for the functional programming study group.</p><p>The Friday presentation was titled &#39;Types: tests that you get for free?’. I started by talking about my last role where the main codebase was in TypeScript, the data stack that I mainly worked on was in Python, and my initial changes to the main codebase was one-off or piecemeal. I learned a lot about TypeScript when I later ported a section of the codebase into Python, and picked up a number of things on Python types too!</p><p>Python is dynamically-typed, but you can optionally type-annotate your code. For example, you can represent a list of ints as `List[int]`, and running mypy will tell you if your code type-checks OK. If you represent your list as a `Sequence[int]`, however, mypy will complain when you try to make changes to the list (say by mutating an existing value or appending to the list) since `Sequence` is read-only.</p><p>At RC I’ve had the chance to go from Python to Haskell to (a little bit of) Idris. Suppose you’re trying to append an int to a list of strings. While mypy will complain when you run the type-check, the code will run successfully as Python is weakly typed. In strongly-typed Haskell, compilation will fail when you try to do the same thing.</p><p>With Idris you can go even further. The canonical example introduces a `Vect` type, which is like a list but has the length of the list in its definition. This means you can create a function that concatenates two `Vect`, the first on length n and the second m, and returns a `Vect` of length n + m. Suppose there was a typo and the first `Vect` is concatenated to itself, the compilation will fail because the lengths don’t add up.</p><p>In fact you can go even further with Idris in writing proofs. Idris&#39; powerful type checker is able to, for example, run proofs by <a href="https://docs.idris-lang.org/en/latest/proofs/inductive.html">induction</a>. I briefly mentioned proofs but didn&#39;t include type-driven development, which is like test-driven development but with types in addition to getting the type checker to explore the shape of the program (analogous to denotation design) and &#39;write the code for you&#39;.</p><p>What’s also interesting is instead of types describing values, in Idris types are first class and exist in the same namespace as values. Running `if True then Int else String` will succeed in Idris.</p><p>To circle back to the title, I quoted Edwin Brady (the creator of Idris) from the book Type-Driven Development.</p><blockquote><p>The difference is that, unlike tests, which can usually only be used to show the presence of errors, types (used appropriately) can show the absence of errors. But although types reduce the need for tests, they rarely eliminate it entirely.</p></blockquote><p>The idea here is that when you write tests, you need to have a sense what errors you’re trying to guard against. With types, you’re ‘constraining’ the space of what’s possible. In the example of List vs Sequence in Python, these guardrails can even be more ergonomic (hence more likely to be added). That being said, neither tests or types provide fail-safe guardrails in all cases.</p></div>
    
  </div></div>
  </body>
</html>
