<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/simple-router/">Original</a>
    <h1>New Library: Simple Router</h1>
    
    
<p>Simple story, really. I wanted an HTTP router for Clojure that</p>
<ol start="1">
  <li>is order-independent</li>
  <li>and allows for overlapping routes.</li>
</ol>
<p>I didn’t find one, so I had to write my own.</p>
<h1 id="order-independence">Order-Independence</h1>
<p>If your app is any big, it probably has modules. Each module defines its own routes. So how do you bring them together?</p>
<p>In traditional Compojure model, the order in which you define your routes matters. This:</p>
<pre><code>(GET &quot;/user/create&quot; [] ...)
(GET &quot;/user/*&quot; [] ...)</code></pre>
<p>would work just fine, while in this case:</p>
<pre><code>(GET &quot;/user/*&quot; [] ...)
(GET &quot;/user/create&quot; [] ...)</code></pre>
<p>second route will never trigger.</p>
<p>When you bring your routes from multiple modules, the order in which you import and merge them still matters, but dependencies become opaque and implicit:</p>
<pre><code>(routes
  finance-routes
  billing-routes
  api-routes)</code></pre>
<p>I don’t like it! In an app with hundrets of routes, it’s too easy to forget about something and make a mistake. I simply don’t want to think about it, the same way I don’t have think about the order in which I define Java classes (sorry, Clojure, I can’t make an example out of you here).</p>
<h1 id="overlapping-routes">Overlapping routes</h1>
<p>Basically, I want to do this:</p>
<pre><code>(GET &quot;/user/*&quot; [] ...)
(GET &quot;/user/create&quot; [] ...)</code></pre>
<p>Pedestal allows for map syntax (order-independence), but then forbids cases like this. Reitit makes those a special case that requires exceptional handling.</p>
<p>But I don’t think there’s anything is wrong with it or that it’s dangerous. It’s a pretty common case, really. Yes, you can’t create a user named <code>&quot;create&quot;</code>, but so what?</p>
<h1 id="small-details">Small details</h1>
<p>I also wanted my route to be simple to use and work with. Routes are just maps. Keys are plain strings (not even vectors!):</p>
<pre><code>(def user-routes
  {&quot;GET /article/*&quot;       (fn [req] ...)
   &quot;GET /article/create&quot;&quot; (fn [req] ...)})</code></pre>
<p>I don’t think complex stuff like regexp validation or coercing should be solved in the router:</p>
<pre><code>(GET [&quot;/user/:id&quot; :id #&quot;[0-9]+&quot;] [id :&lt;&lt; as-int]
   ...)</code></pre>
<p>It makes router a much more complex tool while saving almost nothing—same thing could be done by normal Clojure code immediately after declaration.</p>
<p>Do one thing well, you know. Ken Thompson’s philosophy.</p>
<p>Also, personally, I don’t like how many times <code>:id</code> is repeated in the previous example. Yes, it allows you to match <code>/:x/:y</code> to <code>[y x]</code>, but why would anyone want that?</p>
<p>In my router, you specify bindings only once:</p>
<pre><code>(router/routes
  &quot;GET /article/*/*&quot; [x y] ...)</code></pre>
<h1 id="thats-it">That’s it!</h1>
<p>That’s about everything you need to know. As the name implies, simple. </p>
<p>Next time you’re writing a web app and need a router, something super-basic and well-made, give it a shot.</p>
<p>Link here:</p>
<figure>
<a href="https://github.com/tonsky/clj-simple-router"><img src="https://tonsky.me/blog/simple-router/banner@2x.webp"></a></figure>


  </body>
</html>
