<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html">Original</a>
    <h1>Abstraction: Not What You Think It Is</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p><span>
</span>
<span></span>
<time itemprop="datePublished">March 28, 2022</time>
</p>
<blockquote>“Interfaces are abstractions”
</blockquote>

<blockquote>“Interfaces are not abstractions”

</blockquote>

<blockquote>“Abstraction in programming is the process of identifying common patterns that have systematic variations; an abstraction represents the common pattern and provides a means for specifying which variation to use”

</blockquote>
  
<blockquote>“[...] windshield wipers [...] abstract away the weather”

</blockquote>

<p>Of all the concepts debated in software engineering, abstraction is at the top. I found two separate debates about it on Twitter from the past week.</p>

<p>As the quoted writers show, people do not even agree what abstraction means. Abstraction seems to stand for a hodgepodge of different concepts involving generality, vagueness, or just plain code reuse. These engineering debates — debates about whether duplications are better than the wrong abstraction or about whether abstraction makes code harder to read — trickle down into heated discussions over code. But this confusion over abstraction&#39;s basic meaning makes all such debates doomed.</p>

<p>This situation is particularly sad for me as someone with a background in PL theory. There are a lot of topics in software engineering that are the result of accumulated intuition over decades. But we&#39;ve had a pretty good definition of abstraction since 1977, originally in the context of program analysis, and — I claim — it actually translates quite well into a precise definition of “abstraction” in engineering.</p>

<p>Abstraction in general is usually said to be something which helps readers understand code without delving into the details. Yet, for many of the concrete code examples programmers actually call “abstraction,” they can be (and are) used in ways which add details and hinder understanding. In opposition, I take the position that software engineers will benefit from studying the mathematics of PL-theoretic abstraction, understanding how it explains things they already do, and letting this coherent definition rule their use of the term &#34;abstraction.&#34;</p>

<p>My initial goal in this post is a smaller enabling step: to give you names for the other concepts that are often combined under the name &#34;abstraction&#34; that they may be referenced, used, and critiqued specifically, and to help you move away from the vague and contradictory <a href="https://www.pathsensitive.com/2018/12/my-strange-loop-talk-you-are-program.html">citrus advice</a> that arises from using the same name for different things. From there, I will proceed to provide the rigorous definition of abstraction as it pertains to software, followed by concrete examples, presented in both code and math.</p>

<p>But the story does not end after separating true abstractions from their impostors. The endless debates over what is and isn&#39;t an abstraction shall be resolved in an unsatisfying way: almost anything can be viewed as an abstraction, and most abstractions are useless. Yet once you learn how to actually write down an abstraction mapping, you gain the ability to look beyond the binary and explain the exact benefit that a given abstraction does or does not provide a reasoner, and in doing so rearrange the discordant intuition around abstraction into harmonic lines of precise, actionable advice.</p>



<p>There are at least five other things that go under the name abstraction.</p>

<h2>Functions</h2>

<p>One contender for the oldest programming language is the lambda calculus, where Alonso Church showed us that, by copying symbols on pen-and-paper using a single rule, one could compute anything.</p>

<p>In the lambda calculus, making a new function is called “lambda abstraction,” and often just “abstraction.”</p>

<p>I don&#39;t mean that it&#39;s the process of looking at two similar terms like <span>sin(x)<sup>2</sup>+1</span> and<span> 2*x+1</span>, and deciding to make a function<span> λx.x+1</span>. That&#39;s anti-unification, described below. It is quite literally the process of taking <span>x+1</span> and changing it to <span>λx.x+1</span>.</p>

<p>And “abstraction” also refers to the output of this process, i.e.: any lambda/function whatsoever.<a href="#1" name="top1"><sup>1</sup></a></p>

<p><a href="https://cs.stackexchange.com/questions/93006/why-is-abstraction-in-lambda-calculus-called-abstraction">It&#39;s been noted</a> that this use of the word &#34;abstraction&#34; is quite different from other uses. Unfortunately, this has polluted broader discussion. Even though the lambda calculus usage is akin to adding an opening and closing brace to a block of code, this usage leaks out into discussion of &#34;abstracting things into functions&#34; and from there into extolling the benefits of being able to ignore details and other things that closing braces really don&#39;t let you do.</p>

<p>So functions are abstractions — just in a very limited meaning of the word with little relation to everything else under that label. Moving on...</p>

<h2>Anti-unification</h2>

<p>&#34;<a href="https://en.wikipedia.org/wiki/Anti-unification_(computer_science)">Anti-unification</a>&#34; is a fancy term for the process of taking two things that are mostly similar, and replacing the different parts with variables. If you substitute those variables one way, you get the first thing back; else you get the second.  If you see <span>x*x</span> and <span>(a-b)*(a-b)</span> near each other in a codebase and extract out a square function, then you&#39;ve just done an anti-unification (getting the pattern <span>A*A</span> with the two substitutions <span>[A ↦ x]</span> and <span>[A ↦ a*b]</span>).</p>

<p>(Its opposite is <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">unification</a>, which is comparatively never used in programming. Unless you&#39;re writing Prolog, in which case, it&#39;s literally on every single line.)</p>

<p>This probably looks familiar: virtually all of what goes under the Don&#39;t Repeat Yourself label is an example of anti-unification. Perhaps you would describe the above as &#34;abstracting out the square function&#34; (different from the previous definition, where &#34;abstracting&#34; is just adding curly braces after the variables are already in place).</p>

<p>In fact, Eric Elliott, author of <u>Composing Software</u> and <u>Programming JavaScript Applications</u> <a href="https://ericelliottjs.com/premium-content/abstraction-and-composition">goes as far as to say</a> “abstraction is the process of simplifying code by finding similarities between different parts of the code and extracting shared logic into a named component (such as a function, module, etc...)” — i.e.: that abstraction is anti-unification. He then <a href="https://medium.com/javascript-scene/the-secret-of-simple-code-a2cacd8004dd
">goes on to claim</a> &#34;The secret to being 10x more productive is to gain a mastery of abstraction.&#34; That sounds pretty impressive for a process which was <a href="https://homepages.inf.ed.ac.uk/gdp/publications/MI5_note_ind_gen.pdf">first automated in 1970</a>.<a href="#2" name="top2"><sup>2</sup></a></p>

<h2>Boxing</h2>

<p>&#34;Boxing&#34; is what happens when you do too much anti-unification: a bunch of places with syntactically-similar code turns into one big function with lots of conditionals and too many parameters. &#34;Boxing&#34; is a term of my own invention, though I can&#39;t truly claim credit, as the &#34;stuffing a mess into a box&#34; metaphor predates me. Preventing this is exactly the concern expressed in the line &#34;<a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">duplication is better than the wrong abstraction</a>,&#34; as <a href="https://www.codewithjason.com/duplication-cheaper-wrong-abstraction/">clarified</a> by a critic.</p>

<p>There&#39;s a surefire sign that boxing has occurred. Sandi Metz describes it nicely:</p>

<blockquote>Programmer B feels honor-bound to retain the existing abstraction, but since [it] isn&#39;t exactly the same for every case, they alter the code to take a parameter, and then add logic to conditionally do the right thing based on the value of that parameter.</blockquote>

<p>I&#39;ve <a href="https://www.pathsensitive.com/2018/01/the-design-of-software-is-thing-apart.html">written</a> and <a href="https://corecursive.com/036-jimmy-koppel-advanced-software-design/">spoken</a> against this kind of naive de-duplication before. One of the first exercises in my course is to give two examples of code that have the same implementation but a different spec (and should therefore evolve differently). Having identical code is not a foolproof measure that two blocks do the same thing, and it&#39;s helpful to have different terminology for merging similar things that do and do not go together.</p>

<p>But, particularly, if we want abstraction to have something to do with being able to ignore details, we have to stop calling this scenario &#34;abstraction.&#34;</p>

<h2>Indirection</h2>

<p>Though not precisely defined, indirection typically means &#34;any time you need to jump to another file or function to see what&#39;s going on.&#34; It&#39;s commonly associated with Enterprise Java, thanks to books such as Fowler&#39;s Patterns of Enterprise Application Architecture, and is exemplified by the Spring framework and parodied by <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">FizzBuzz: Enterprise Edition</a>. This is where you get people complaining about &#34;layers&#34; of abstraction. It commonly takes the form of long chains of single-line functions calling each other or class definitions split into a hierarchy across 7 files.</p>

<p>Fowler&#39;s examples include abstracting</p>

<div><pre><span>contract</span><span>.</span><span>calculateRevenueRecognition</span><span>()</span>
</pre></div>


<p>into the Service Layer Abstraction™</p>

<!--HTML generated using hilite.me--><div><pre><span>calculateRevenueRecognition</span><span>(</span><span>Contract</span><span>)</span>
</pre></div>

<p>If you were to describe the former, you&#39;d probably say &#34;It calculates the recognized revenue for the contract.&#34; If you were to describe the latter, you&#39;d probably say &#34;It calculates the recognized revenue for the contract.&#34; We&#39;ve been spared no details.</p>

<h2>Interfaces, Typeclasses, and Parametric Polymorphism</h2>

<p>All three of these are mechanisms for grouping multiple function implementations so that a single invocation may dispatch to any of them. Most programmers will be familiar with interfaces, which are a language feature in Java and TypeScript and a common pattern in Python. Typeclasses, a.k.a. “traits,” are essentially interfaces not attached to objects. Parametric polymorphism, a.k.a. “generics,” are a little different in that they combine functions which differ in nothing but their type signature.</p>

<p>Parametric polymorphism is essentially just adding an extra parameter to a function, except that this extra parameter is a type. It&#39;s not abstraction in the same way that anti-unification isn&#39;t.</p>

<p>Interfaces and typeclasses do tend to be associated with abstractions in the sense about to be introduced. But there&#39;s a banal reason they do not satisfy the goal of an abstraction definition: there&#39;s nothing mandating that the many implementations have anything to do with each other. For example, in my installation of the Julia language, the <span>getindex</span> function is actually an interface with 188 implementations, dispatched based on the runtime type of its arguments. Most of these implementations do lookups into array-like structures, but a few do the exact opposite and create an array.</p>

<p>Sometimes, when calling a function behind a polymorphic typeclass interface, the programmer knows only one implementation is relevant, so the shared name is just to save some typing. Other than that, in order to make use of any of these, one must be able to explain the operation of multiple functions in some common language. It is not the language feature that allows one to program liberated from details, but rather this common language and its correspondence with each of the implementations. Which brings us to...</p>



<p>In programming language theory and formal methods, there are several definitions of &#34;abstraction&#34; in different contexts, but they are all quite similar: abstractions are mappings between a complex concrete world and a simple idealized one. For concrete data types, an abstraction maps a complicated data structure to the basic data it represents. For systems, an abstraction relates the tiny state changes from every line implementing a TCP stack with the information found in the actual protocol diagram. These abstractions become useful when one can define interesting operations purely on the abstract form, thus achieving the dictum of Dijkstra, that &#34;The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.&#34;</p>

<p>You&#39;ve probably used one such abstraction today: the number 42 can be represented in many forms, such as with bits, tally marks, and even (as is actually done in mathematics) <a href="https://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers">as a set</a>. Addition has correspondingly many implementations, yet you need not think of any of them when using a calculator. And they can be composed: there is an abstraction to the mathematical integers from their binary implementation, and another abstraction to binary from the actual voltages. In good abstractions, you&#39;ll never think that it&#39;s even an abstraction.</p>

<p>So, what do abstractions actually look like in code?</p>

<p>They don&#39;t.</p>

<h2>Where are the abstractions?</h2>

<p>A running joke in my software design course is that, whenever I show some code and ask whether it has some design property, the answer is always &#34;maybe.&#34; And so it is whenever you ask &#34;Is Y an abstraction of X?&#34;</p>

<p>First, a quick digression. In PL theory and formal methods, there are many definitions of abstraction in different contexts, though they are all far more similar to each other than to any of the not-abstractions in previous sections. The one I am about to present is based on the theory of <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">abstract interpretation</a>. Abstract interpretation is usually taught as a (very popular) approach to static analysis, where it&#39;s used to write tools that can, say, prove a program never has an array-out-of-bounds access. But it can also be applied to more interesting properties, though usually in a less automated fashion. I&#39;ll be presenting it from the perspective of understanding programs rather than building tools, and explaining it without math symbols and Greek letters. I&#39;ll be in particular focusing on abstracting program state. I&#39;ll occasionally gesture at abstracting steps in a program, though the actual definitions are more complicated. (Google “simulation relation” and “bisimulation” to learn the technical machinery.)</p>

<p>So:</p>

<p>Abstractions are mappings. An abstraction is a pattern we impose on the world, not the entities it relates, which are called the abstract domain and concrete domain. Strictly adhering to this definition, the well-formed question would be &#34;Is there an abstraction from X to Y?&#34; followed by “Is that abstraction good?”</p>

<p>Let&#39;s return to the example of numbers. There is a great abstraction from voltages in hardware to strings of 0&#39;s and 1&#39;s, from strings of 0&#39;s and 1&#39;s to mathematical numbers, and also from tally marks to numbers. These abstractions on numbers induce abstracted versions of each operation on the base representations, such as the very-simple operation of adding 1 to a number. Already, we can see that the abstractions live outside the system; computers function just fine without a device that reads an exact value for the voltage in each transistor and then prints out the represented number. Yet in spite of living outside the system, this mapping is perfectly concrete.</p>

<p><img src="https://lh3.googleusercontent.com/MVRvsHVyVjUFXZX2SWVhCwbqe8ECO7KzIP6vMni2DOt4_R9RrQfwiBHGruMUgJUyFy9TqGnePuxW80csY6-pcjkzTbJ4_dV0h0Lg5hfsm0467MgjtQOl3eLFgyqK9gYOReNek3dZ"/></p>

<h2>Evaluating abstractions</h2>

<p>The three example abstractions above have two properties that make them useful. The first is <i>soundness</i>.  The picture above is what&#39;s called a “commutative diagram” in that any path through the diagram obtains the same result: given an input set of voltages, it would be equivalent to either (a) run a circuit for adding one and then convert the resulting voltages to a number, or (b) convert the voltages to a number and then add 1 with pen-and-paper. The second is <i>precision</i>: Adding 1 to a number produces exactly one result, even though it corresponds to a diverse set of output voltages.</p>

<p>Precision is what makes finding good abstractions nontrivial. The eagle-eyed reader might notice that any function to the integers yields a sound abstraction. For example, there is an abstraction from  your TV screen to integers: the serial number. However, you&#39;d be hard pressed to find any operations on TVs that can be sanely expressed on integers. Turning the TV on or changing the channel leaves it with exactly the same serial number, while replacing the TV with one slightly larger is barely distinguishable from randomly scrambling the serial number. Indeed, one would likely implement the “slightly larger TV” function on the abstract domain of serial numbers  by mapping each serial number to the set of all other serial numbers. This is sound — getting a larger TV and then taking its serial number is certainly contained in the result of looking at your current TV&#39;s serial number then applying this operation — but maximally imprecise.</p>

<p>A consequence of this: if we translate every question “is X an abstraction of Y” to “is there an abstraction which maps X to Y,” the answer is always “yes.” Instead, we can ask <i>which operations</i> can be <i>tracked precisely </i>with reference only to the abstract domain. The abstraction from voltages to numbers is perfectly precise for all operations on numbers, but not for determining whether a certain transistor in the adder circuit contains 2.1 or 2.2 volts. The abstraction from TVs to serial numbers is perfectly imprecise for every operation except checking whether two TV&#39;s are the same (and maybe also getting their manufacturer and model).</p>

<p>To the property of soundness and the measurement of precision, we add a third dimension on which to evaluate abstractions: the size (in bits) of an abstract state. The good abstractions are then the sound abstractions which are small in bits, yet precise enough to track many useful operations.</p>

<p>So consider a website for booking tables at restaurants, where the concrete domain is the actual state of bookings per table <span>{table1BookedFrom: [(5-6 PM, “Alice”), (7-8 PM, “Bob”)], ..., table10BookedFrom: [...]}</span>. The abstract domain shall be a list of timeslots. For each user, it is possible to abstract a concrete state down to the abstract state listing the booked timeslots for that user, i.e.: for Bob, <span>[7-8 PM]</span>. What makes this an abstraction, as opposed to just an operation on the restaurant state, is that we shall then proceed to describe the effect of every other operation on this value. So consider the actual booking function, which might have this signature:</p>

<div><pre><span>void</span> <span>bookTable</span><span>(</span><span>User</span> <span>u</span><span>,</span> <span>TimeInterval</span> <span>t</span><span>)</span>
</pre></div>

<p>Below I give 4 specifications for this function. For the example of booking a table for Carol from 7 to 8 PM, these specifications give:</p>

<ol>
<li>The actual behavior of this implementation, say, trying to assign Carol to the lowest-numbered table.</li>

<li>All allowed behaviors on the concrete states, i.e.: finding any table open at the given time and assigning it to Carol, or doing nothing if there is none</li>

<li>The allowed outputs on the abstract domain of Carol&#39;s bookings, namely (assuming Carol does not already have a reservation) either <span>[7-8 PM]</span> or <span>[]</span>.</li>

<li>The allowed outputs on the abstract domain for Bob or any other user, i.e.: the exact same as the input.</li>
</ol>
  
<p>From this one example, we can derive quite a few lessons, including:</p>

<ul>
<li><b>All of these specifications are useful</b> in that you might use each of them when mentally stepping through the code. Perhaps you&#39;d think “This line shouldn&#39;t have affected any of Bob&#39;s bookings” (using specification 4, corresponding to the “Bob&#39;s bookings” abstraction) or “When I click this button, either table 5, 6, or 7 will be booked” (using specification 2).</li>

<li><b>Abstractions are separate from the code, and even from the abstract domain.</b> It does not make sense to say that the <span>bookTable</span> function or anything else in this file “is” the abstraction, because, as we have just seen, we can use many different abstractions when describing its behavior. More striking, we see that, even for a specific pairing of concrete and abstract domains, there can be many abstractions between them.</li>

<li><b>Instead, code is <i>associated</i> with abstractions.</b> Note the plural. We&#39;ve seen that bookTable can be associated with several abstractions of the behavior — infinitely many in fact, including many useful ones not previously discussed, like mapping the restaurant state to the list of timeslots with available tables.</li>

<li><b>No code change is needed to reason using an abstraction. </b>We could extend the mapping from relating abstract/concrete states to relating steps between them, and then say the <span>bookTable</span> function “abstracts” the set of intermediate steps the program takes for each line in the function, but we could do this almost as easily if the <span>bookTable</span> implementation was actually a blob in a much larger function.</li>

<li><b>Different abstractions tend not to be more or less precise than each other, just differently precise.</b> Compare the abstractions from the restaurant state to Bob&#39;s bookings, Carol&#39;s bookings, and the set of open timeslots. All of them can be used to answer different questions.</li>
</ul>
  
  
<p>Continuing, we can also evaluate what makes the “Carol&#39;s bookings” abstraction a good one. The corresponding specification, Specification 3, is quite close to deterministic, yielding only two possible output states. The corresponding abstract states contain much less information than the concrete ones. And an entity (human or tool) reading the code tracking only this abstract state will still be able to perfectly predict the result of several other operations, such as checking whether Carol has a table. This is the <b>new semantic layer on which one can be absolutely precise</b> that Dijkstra speaks of!</p>

<p>Of course, it is cumbersome to say “there is a sound and precise abstraction mapping voltages on hardware to mathematical numbers”  or “there is a good abstraction from the specific details of when tables are booked to just the available times.” It is quite convenient shorthand to use the more conventional phrasing “numbers abstract the hardware” or “bookTable abstracts all the details of reservations;” you can say “abstraction mapping” if you want to clearly refer to abstractions as defined in this blog post. Yet this shorthand invites multiple interpretations, and can spiral into an argument about whether booking tables should actually be the same abstraction as booking hotel rooms. Feel free to call numbers an abstraction of the hardware, but be prepared to switch to this precise terminology when there&#39;s tension on the horizon.</p>



<p>Programmers correctly intuit that it is desirable to have some way to reason about code while ignoring details. In their 1977 paper, Patrick and Radhia Cousot first taught us the precise definition of abstraction that makes this possible. The other attempts fail to see the incorporeal nature of abstractions and instead fixate on something in the code. But there must be some connection.</p>

<p>Yes, functions are not abstractions. But for every function, there is an abstraction, not necessarily a good one, collapsing the many intermediate steps of the function into an atomic operation. There may also be abstractions which admit a simple description of the relation between the inputs and outputs.</p>

<p>Anti-unification is not abstraction. Yet two code snippets that could be fruitfully semantically modeled with similar abstract states will often be amenable to syntactic anti-unification.  As disparate operations are combined, ever more information must be added into the abstract state to maintain precision. The result is boxing.</p>

<p>Indirection is hella not abstraction, though similarly-named functions may suggest slightly-different abstract domains associated with them. Many changes that make abstractions more explicit come with indirection, but we&#39;ve seen it&#39;s possible for readers to impose abstractions on code without any changes at all.</p>

<p>Typeclasses and interfaces are not abstraction, but a good interface will be associated with at least one good abstract domain precise enough to make each of the interface&#39;s operations nearly deterministic (or at least simple to specify), and each implementation will come with a sound abstraction mapping its concrete states into that abstract domain.</p>

<p>Your car&#39;s windshield wipers and roof do not abstract away the rain, as claims Spolsky, but they do mean that, to predict your happiness after running your brain&#39;s <span>DriveToStore()</span> function, you can use an abstract state that does not include the weather.</p>

<p>Abstractions offer the dream of using simple thoughts to conjure programs with rich behavior. But fulfilling this promise lies beyond the power of any language feature, be it functions or interfaces. We must think more deeply and identify exactly how the messy world is being transformed into a clean ideal. We must look beyond the binary of whether something is or is not an abstraction, and discover the new semantic level on which we can be absolutely precise.</p>



<p>Abelson and Sussman&#39;s Structure and Interpretation of Computer Programs is a sure candidate for the title of “Bible of computer programming” (sometimes <a href="https://kingjamesprogramming.tumblr.com/">mixed with the actual Bible</a>), and it&#39;s full of instruction on abstraction, beginning with chapter 1 “Building Abstractions with Procedures.” I expect at least one reader wants beat me over the head with a copy of the book saying I&#39;m getting it wrong. I don&#39;t really want that (it&#39;s 900 pages), so I walked down 2 flights of stairs from my MIT office to Gerry Sussman&#39;s office and asked him. I&#39;ll represent his ideas below.</p>

<p>Sussman explained that he believes abstraction is a “suitcase term” which means too many different things, though he only sees two main uses relevant to software. The first definition is: giving names to things produced by the second definition. That second definition, he explained, has to do with the<a href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"> fundamental theorem of homomorphisms</a> and its <a href="https://en.wikipedia.org/wiki/Isomorphism_theorems#Theorem_A_(universal_algebra)">generalization</a>. And then he pulled an abstract algebra book off the shelf.</p>

<p><img src="https://lh6.googleusercontent.com/lEoNguG79olT0g-0D8FTgSEMxv-Qadb4jA0lmoXJj3rt_0uCG_U2ZWMzzUKJl0jug_da2sD0klWeyur4X0u7E4UCwBiK9QRXXju0yMZuB2TBoK2ZVflQTSOScfJ0zoicxR25gwdV"/></p>

<p>I&#39;ll try to explain this as best I can with minimal math jargon while still being precise. I&#39;ll explain the definition simultaneously with Sussman&#39;s two examples, multivariate polynomials, and (physical) resistors in electric circuits.</p>

<p>In this picture, G can be seen as the set of all data in all forms and f is some operation on G. So G can be the set of all polynomials in all representations, or the set of all resistors. f then can be the operation of plotting the polynomial on all values, or computing the current through a resistor across a range of voltages.</p>

<p>Now, there are many different values in G on which f does the same thing.  G contains both sparse and dense representations of the same polynomial; these have the same plot. There are different resistors with the same resistance; assuming they perfectly follow Ohm&#39;s Law, they have the same current at the same voltage. One can write down the list of lists of which values of G are treated the same by f; that&#39;s φ, the kernel of f. So for polynomials, φ would be the list of distinct polynomials, each of which contains the list of all representations of that polynomial.</p>

<p>Now, finally, on can use φ to quotient or “smush” together the like elements of G. All the different representations of the same polynomial get mapped to something representing that polynomial independent of representation. All the different resistors of resistance R get mapped to the idea of a resistor with resistance R. This is G/K in the picture.</p>

<p>The theorem is then that G/K behaves the same (is isomorphic to) H, e.g.: that that the set of different representations of polynomials can be manipulated in the same way as their plot. But I believe Sussman was gesturing less at this theorem and more at G/K itself, i.e.: at the idea of merging together different representations that behave the same under some operations.</p>

<p>I like this idea because it gives a way to unify into a single mapping the relation between many different implementations and their shared abstract domain. For the different representations of polynomials, a typical formulation with abstract interpretation would provide a different mapping from each kind of implementation into the shared abstract domain. On the whole though, the operative idea in the “homomorphism theorem” theory of abstraction seems to be that of merging together concrete values that can be treated similarly by certain operations. This idea is already present in abstract interpretation; indeed, φ can be directly taken to be an abstraction mapping, with G and G/K the concrete and abstract domains. On the whole, while I find the connection to abstract algebra cute, I&#39;m not sure that the “homomorphism theory of abstraction” offers any insight that the theory of abstract interpretation does not.</p>

<p>So that&#39;s the main item in Sussman&#39;s suitcase of meanings of abstraction in software. It looks superficially different from any of the variations of abstract interpretation, but is actually quite compatible.</p>

<p>Is there anything else in that suitcase? Any other (good) uses of the word “abstraction” not captured by the previous definitions?</p>

<p>Maybe. I can say that there are is something I&#39;d like to be able to do with something called “abstraction,” but that I can&#39;t do with abstract interpretation: dealing with inaccuracy.</p>

<p>You see, the orthodox definition of a sound abstraction would rule out a technique that predicts the concrete output perfectly 99.99% of the time and is otherwise slightly off, and instead prefers a function that says “It could be anything” 100% of the time. I know there is work extending abstract interpretation to some kinds of error, namely for numeric approximations of physical quantities, but, overall, I just don&#39;t know a good approach to abstraction that allows for reasonable error.</p>

<p>On a related note, sometimes AI researchers also talk about abstraction. I know that the <a href="https://www.cs.cmu.edu/~noamb/papers/17-IJCAI-Libratus.pdf">best poker AIs</a> “abstract” the state space of the game, say by rounding all bet sizes to multiple of $5, and that human pros exploit it by using weird bet sizes and letting the rounding error wipe out its edge. But I am not aware of a general theory backing this beyond just “make some approximations and hope the end result is good,” and am not even sure “abstraction” is a good term for this.</p>

<p><b>Acknowledgments</b></p>

<p><span>Thanks to Nate McNamara, Benoît Fleury, Nils Eriksson, Daniel Jackson, and Gerry Sussman for feedback and discussion on earlier drafts of this blog post.</span></p>

<hr/>

<p>
  <span><a href="#top" name="1">1</a> Daniel Jackson credits Turing Laureate Barbara Liskov with promulgating this usage. Her influential CLU language uses “abstraction” to mean any unit of functionality (type, procedure, or iterator).
</span></p>
<p>
  <span><a href="#top2" name="2">2</a>  Technically, it’s only first-order anti-unification, equivalent to extracting named constants, that Gordon Plotkin developed in 1970. Work on higher-order anti-unification, which corresponds to extracting (higher-order) functions, began in 1990; Feng and Muggleton’s “Towards Inductive Generalisation in Higher order Logic&#34; (1992) provides an early discussion. While Elliott is quite explicit that any anti-unification is abstraction, it is true that there are a vast number of anti-unifications of a given set of programs, and choosing the best is very difficult. <a href="https://arxiv.org/abs/2006.08381">DreamCoder</a> is a recent notable work based on doing so.
</span></p></div>
</div></div>
  </body>
</html>
