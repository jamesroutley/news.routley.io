<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hachibu.net/posts/2021/traversing-trees-with-generators/">Original</a>
    <h1>Traversing Trees with Generators</h1>
    
    <div id="readability-page-1" class="page"><div>
<figure><img src="https://hachibu.net/posts/2021/traversing-trees-with-generators/images/featured.png"/>
</figure>

<h4 id="introduction">Introduction</h4>
<p>Earlier this year, I was interviewing for frontend engineering positions and
tree questions were very popular. After repetitively solving tree recursion
problems and trying to improve my tactics, I came across a novel JavaScript
feature – <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#generators">Generators</a> –
that makes tree recursion as easy as array iteration.</p>
<h4 id="what-are-generators">What Are Generators?</h4>
<p>Why do we even need Generators? To put it bluntly, implementing the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration protocols</a>
for an object or a class is a PITA. With generators, we get a concise syntax
that makes it easy to implement the Iteration protocols – which we’ll leverage
later on to simplify tree recursion into iteration.</p>
<p>A complete explanation of Generators is beyond the scope of this article but
it’s important to understand a few basics of the syntax to understand the
following exercises.</p>
<ol>
<li>A Generator is a special type of function that can <code>yield</code> multiple values
whereas a regular function can only return a single value.</li>
<li>The <code>function*</code> syntax allows us to define a function that will return a
Generator, and the <code>yield</code> syntax allows us to return the next value from
inside of a Generator.</li>
<li>Generators implement the Iteration protocols so we can leverage <code>for...of</code> loops.</li>
</ol>
<p>For example, here’s a function that returns a Generator for and infinite series
of numbers. Notice that this function will never terminate but by wrapping it in
a Generator we can pause and restart it whenever we want.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span>function</span><span>*</span> <span>numbers</span><span>()</span> <span>{</span>
  <span>let</span> <span>n</span> <span>=</span> <span>1</span><span>;</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>yield</span> <span>n</span><span>++</span>
<span>}</span>

<span>const</span> <span>gen</span> <span>=</span> <span>numbers</span><span>();</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>gen</span><span>.</span><span>next</span><span>());</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>gen</span><span>.</span><span>next</span><span>());</span>
</code></pre></td></tr></tbody></table>
</div>
</div>
<div>
<header>
<span>
<i></i>
<i></i>
<i></i>
</span>
</header>
<main>
<pre><code></code></pre>
<pre><code>&gt;&gt; Object { value: 1, done: false }</code></pre>
<pre><code>&gt;&gt; Object { value: 2, done: false }</code></pre>
<pre><code></code></pre>
</main>
</div>
<h4 id="exercises">Exercises</h4>
<figure><img src="https://hachibu.net/posts/2021/traversing-trees-with-generators/images/tree.png"/>
</figure>
<p>For all of the exercises below, we’ll be using the tree above to illustrate each
type of traversal. The tree above was created by using a helper function called
<code>createTreeNode</code> which accepts a single value and an array of children.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>createTreeNode</span><span>(</span><span>value</span><span>,</span> <span>children</span> <span>=</span> <span>[])</span> <span>{</span>
  <span>const</span> <span>node</span> <span>=</span> <span>{</span>
    <span>value</span><span>,</span>
    <span>children</span>
  <span>};</span>
  <span>// Create references to the parent node.
</span><span></span>  <span>for</span> <span>(</span><span>let</span> <span>child</span> <span>of</span> <span>node</span><span>.</span><span>children</span><span>)</span> <span>{</span>
    <span>child</span><span>.</span><span>parent</span> <span>=</span> <span>node</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>node</span><span>;</span>
<span>};</span>

<span>const</span> <span>tree</span> <span>=</span> <span>createTreeNode</span><span>(</span><span>1</span><span>,</span> <span>[</span>
  <span>createTreeNode</span><span>(</span><span>2</span><span>,</span> <span>[</span>
    <span>createTreeNode</span><span>(</span><span>3</span><span>),</span>
    <span>createTreeNode</span><span>(</span><span>4</span><span>),</span>
  <span>]),</span>
  <span>createTreeNode</span><span>(</span><span>5</span><span>,</span> <span>[</span>
    <span>createTreeNode</span><span>(</span><span>6</span><span>),</span>
  <span>]),</span>
<span>]);</span>
</code></pre></td></tr></tbody></table>
</div>
</div><h5 id="depth-first-traversal">Depth-first Traversal</h5>
<figure><img src="https://hachibu.net/posts/2021/traversing-trees-with-generators/images/tree-depth-first.png"/>
</figure>
<p>Every single tree question that I was given involved depth-first traversal.
For example, flatten an array of trees, search the DOM for elements with a
specific class name, or build a recursive React component.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span>function</span><span>*</span> <span>traverseTree</span><span>(</span><span>node</span><span>)</span> <span>{</span>
  <span>yield</span> <span>node</span><span>;</span>

  <span>for</span> <span>(</span><span>let</span> <span>child</span> <span>of</span> <span>node</span><span>.</span><span>children</span><span>)</span> <span>{</span>
    <span>yield</span><span>*</span> <span>traverseTree</span><span>(</span><span>child</span><span>);</span>
  <span>}</span>
<span>}</span>

<span>for</span> <span>(</span><span>let</span> <span>node</span> <span>of</span> <span>traverseTree</span><span>(</span><span>tree</span><span>))</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>node</span><span>.</span><span>value</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div>

<hr/>
<h5 id="breadth-first-traversal">Breadth-first Traversal</h5>
<figure><img src="https://hachibu.net/posts/2021/traversing-trees-with-generators/images/tree-breadth-first.png"/>
</figure>
<p>I was never asked any questions that required breadth-first traversal but I’m
including this exercise because it shows the versatility of this technique. For
example, print the values of a tree in row order.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span>function</span><span>*</span> <span>traverseTreeBreadthFirst</span><span>(</span><span>node</span><span>)</span> <span>{</span>
  <span>let</span> <span>queue</span> <span>=</span> <span>[</span><span>node</span><span>]</span>

  <span>while</span> <span>(</span><span>queue</span><span>.</span><span>length</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>let</span> <span>curr</span> <span>=</span> <span>queue</span><span>.</span><span>shift</span><span>()</span>

    <span>for</span> <span>(</span><span>let</span> <span>child</span> <span>of</span> <span>curr</span><span>.</span><span>children</span><span>)</span> <span>{</span>
      <span>queue</span><span>.</span><span>push</span><span>(</span><span>child</span><span>);</span>
    <span>}</span>

    <span>yield</span> <span>curr</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>for</span> <span>(</span><span>let</span> <span>node</span> <span>of</span> <span>traverseTreeBreadthFirst</span><span>(</span><span>leaf</span><span>))</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>node</span><span>.</span><span>value</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div>

<hr/>
<h5 id="backtracking">Backtracking</h5>
<figure><img src="https://hachibu.net/posts/2021/traversing-trees-with-generators/images/tree-backtracking.png"/>
</figure>
<p>I encountered backtracking once as an extension to a depth-first tree traversal
question. For example, search the DOM for leaf elements with a specific
hierarchy of class names.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span>function</span><span>*</span> <span>backtrackTree</span><span>(</span><span>node</span><span>)</span> <span>{</span>
  <span>let</span> <span>curr</span> <span>=</span> <span>node</span>

  <span>while</span> <span>(</span><span>curr</span><span>)</span> <span>{</span>
    <span>yield</span> <span>curr</span>

    <span>curr</span> <span>=</span> <span>curr</span><span>.</span><span>parent</span>
  <span>}</span>
<span>}</span>

<span>// Find the rightmost tree leaf node.
</span><span></span><span>const</span> <span>leafNode</span> <span>=</span> <span>[...</span><span>traverseTree</span><span>(</span><span>tree</span><span>)].</span><span>pop</span><span>();</span>

<span>for</span> <span>(</span><span>let</span> <span>node</span> <span>of</span> <span>backtrackTree</span><span>(</span><span>leafNode</span><span>))</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>node</span><span>.</span><span>value</span><span>);</span>
<span>}</span>
</code></pre></td></tr></tbody></table>
</div>
</div>

<hr/>
<h5 id="further-exercises">Further Exercises</h5>
<ul>
<li>Can you flatten an array of trees?</li>
<li>Can you implement map, filter and reduce for trees?</li>
<li>Can you implement iteration for another data structure?</li>
</ul>
<h4 id="conclusion">Conclusion</h4>
<p>Hopefully, I’ve made a strong case that tree recursion can be as easy as array
iteration by using JavaScript Generators. All of the source code for this blog
post is available on <a href="https://github.com/hachibu/traversing-trees-with-generators">GitHub</a>.</p>

</div></div>
  </body>
</html>
