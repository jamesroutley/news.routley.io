<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tinyhack.com/2025/03/13/decrypting-encrypted-files-from-akira-ransomware-linux-esxi-variant-2024-using-a-bunch-of-gpus/">Original</a>
    <h1>Decrypting encrypted files from Akira ransomware using a bunch of GPUs</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>I recently helped a company recover their data from the Akira ransomware without paying the ransom. I’m sharing how I did it, along with the full source code.</p>



<p>The code is here: <a href="https://github.com/yohanes/akira-bruteforce">https://github.com/yohanes/akira-bruteforce</a></p>



<p>To clarify, multiple ransomware variants have been named Akira over the years, and several versions are currently circulating. The variant I encountered has been active from late 2023 to the present (the company was breached this year).</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/akira-scaled.jpg"><img fetchpriority="high" decoding="async" width="1024" height="768" src="https://tinyhack.com/wp-content/uploads/2025/03/akira-1024x768.jpg" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/akira-1024x768.jpg 1024w, https://tinyhack.com/wp-content/uploads/2025/03/akira-300x225.jpg 300w, https://tinyhack.com/wp-content/uploads/2025/03/akira-768x576.jpg 768w, https://tinyhack.com/wp-content/uploads/2025/03/akira-1536x1152.jpg 1536w, https://tinyhack.com/wp-content/uploads/2025/03/akira-2048x1536.jpg 2048w, https://tinyhack.com/wp-content/uploads/2025/03/akira-1200x900.jpg 1200w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a></figure>



<p>There was an earlier version (before mid-2023) that contained a bug, allowing Avast to create a decryptor. However, once this was published, the attackers updated their encryption. I expect they will change their encryption again after I publish this.</p>



<figure><div>
<blockquote data-secret="DJc7ayJPce"><a href="https://decoded.avast.io/threatresearch/decrypted-akira-ransomware/">Decrypted: Akira Ransomware</a></blockquote>
</div></figure>



<p>You can find various Akira malware sample hashes at the following URL:</p>



<p><a href="https://github.com/rivitna/Malware/blob/main/Akira/Akira_samples.txt">https://github.com/rivitna/Malware/blob/main/Akira/Akira_samples.txt</a></p>



<p>The sample that matches my client’s case is:</p>



<p><code>bcae978c17bcddc0bf6419ae978e3471197801c36f73cff2fc88cecbe3d88d1a</code></p>



<p>It is listed under the version: <strong>Linux V3</strong>. The sample can be found on <a href="https://virus.exchange">virus.exchange</a> (just paste the hash to search).</p>



<p>Note that the ransom message and the private/public keys will differ.</p>



<h2>We do this not because it is easy, but because we thought it would be easy</h2>



<p>I usually decline requests to assist with ransomware cases. However, when my friend showed me this particular case, a quick check made me think it was solvable.</p>



<p>From my initial analysis, I observed the following:</p>



<ul>
<li>The ransomware uses the current time (in nanoseconds) as a seed.</li>



<li>On my Linux machine, file modification times have nanosecond resolution.</li>



<li>They provided a screenshot of a partial log (<code>shell.log</code>), showing when the ransomware was executed, with millisecond resolution.</li>
</ul>



<p>Based on this, my initial thought was: <em>“This should be easy—just brute-force it by looking at the file timestamps. How hard can it be?”</em></p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-7.png"><img decoding="async" width="523" height="440" src="https://tinyhack.com/wp-content/uploads/2025/03/image-7.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-7.png 523w, https://tinyhack.com/wp-content/uploads/2025/03/image-7-300x252.png 300w" sizes="(max-width: 523px) 85vw, 523px"/></a></figure>



<p>I’ll explain in more detail, but it turned out to be more complicated than expected:</p>



<ul>
<li>The malware doesn’t rely on a single moment in time but uses <strong>four moments</strong>, each with <strong>nanosecond resolution</strong>. The fist two and last two are related, so we can’t just bruteforce the time one by one. Key generation is complex, involving <strong>1,500 rounds of SHA-256</strong> for each timestamp. Each file ends up with a unique key.</li>



<li>The <strong>VMware VMFS filesystem</strong> only records file modification times with <strong>second-level precision</strong>.</li>



<li>Not all <strong>ESXi hosts</strong> have millisecond resolution in their log files, some only log with second-level precision. I am still unsure what configuration file causes this different behavior</li>



<li>The malware uses <strong>multiple threads</strong> during execution.</li>



<li>The file modification time reflects <strong>when the file is closed</strong>, not when it is opened for writing.</li>
</ul>



<h2>Reverse Engineering</h2>



<p>The code is written in <strong>C++</strong>, which is notoriously difficult to read, but fortunately, it wasn’t obfuscated. The binary is statically linked (a bit harder to analyze), but all strings are in cleartext. The error messages indicate that the <strong><a href="https://github.com/deepin-community/nettle/">Nettle</a></strong> library is used, which made understanding the code much easier.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-13.png"><img loading="lazy" decoding="async" width="1024" height="363" src="https://tinyhack.com/wp-content/uploads/2025/03/image-13-1024x363.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-13-1024x363.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/image-13-300x106.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-13-768x273.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/image-13.png 1051w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a><figcaption>The existence of error strings really helps</figcaption></figure>



<p>The code to generate random is like this (the actual code is in 0x455f40 in the binary)</p>


<div><pre title="">void generate_random(char *buffer, int size)
{
    uint64_t t = get_current_time_nanosecond();
    char seed[32];
 //in the real code, it uses C++ code to convert int to string
    snprintf(seed, sizeof(seed), &#34;%lld&#34;, t);
    struct yarrow256_ctx ctx;
    yarrow256_init(&amp;ctx, 0, NULL);
    yarrow256_seed(&amp;ctx, strlen(seed), seed);
    yarrow256_random(&amp;ctx, size, buffer);   
}

</pre></div>


<p>The random generator is implemented in <code><a href="https://github.com/deepin-community/nettle/blob/master/yarrow256.c">yarrow256.c</a></code>. Here is the relevant code, with unnecessary parts removed. As noted in the comments:</p>



<blockquote>
<p>The number of iterations when reseeding, P_t in the yarrow paper. Should be chosen so that reseeding takes on the order of 0.1-1 seconds.</p>
</blockquote>


<div><pre title="">void
yarrow256_seed(struct yarrow256_ctx *ctx,
	       size_t length,
	       const uint8_t *seed_file)
{
  sha256_update(&amp;ctx-&gt;pools[YARROW_FAST], length, seed_file);
  yarrow256_fast_reseed(ctx);
}

void
yarrow256_fast_reseed(struct yarrow256_ctx *ctx)
{
  uint8_t digest[SHA256_DIGEST_SIZE];
  unsigned i;   
  sha256_digest(&amp;ctx-&gt;pools[YARROW_FAST], sizeof(digest), digest);
  /* Iterate */
  yarrow_iterate(digest);
  aes256_set_encrypt_key(&amp;ctx-&gt;key, digest);
  /* Derive new counter value */
  memset(ctx-&gt;counter, 0, sizeof(ctx-&gt;counter));
  aes256_encrypt(&amp;ctx-&gt;key, sizeof(ctx-&gt;counter), ctx-&gt;counter, ctx-&gt;counter); 
}

/* The number of iterations when reseeding, P_t in the yarrow paper.
 * Should be chosen so that reseeding takes on the order of 0.1-1
 * seconds. */
#define YARROW_RESEED_ITERATIONS 1500


static void
yarrow_iterate(uint8_t *digest)
{
  uint8_t v0[SHA256_DIGEST_SIZE];
  unsigned i;
  
  memcpy(v0, digest, SHA256_DIGEST_SIZE);
  
  /* When hashed inside the loop, i should run from 1 to
   * YARROW_RESEED_ITERATIONS */
  for (i = 0; ++i &lt; YARROW_RESEED_ITERATIONS; )
    {
      uint8_t count[4];
      struct sha256_ctx hash;
  
      sha256_init(&amp;hash);

      /* Hash v_i | v_0 | i */
      WRITE_UINT32(count, i);
      sha256_update(&amp;hash, SHA256_DIGEST_SIZE, digest);
      sha256_update(&amp;hash, sizeof(v0), v0);
      sha256_update(&amp;hash, sizeof(count), count);

      sha256_digest(&amp;hash, SHA256_DIGEST_SIZE, digest);
    }
}
</pre></div>


<h3>Seed and encryption</h3>



<p>The ransomware calls the random generator four times:</p>


<div><pre title="">generate_random(chacha8_key 32);
generate_random(chacha8_nonce, 16);
generate_random(kcipher2_key, 16);
generate_random(kcipher2_key, 16);
</pre></div>


<p>Each <code>generate_random</code> call uses the current nanosecond timestamp as a seed. Therefore, there are <strong>four unique timestamps</strong> that need to be identified. The ransomware generates <strong>different keys for each file</strong>.<br/></p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image.png"><img loading="lazy" decoding="async" width="784" height="391" src="https://tinyhack.com/wp-content/uploads/2025/03/image.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image.png 784w, https://tinyhack.com/wp-content/uploads/2025/03/image-300x150.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-768x383.png 768w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a></figure>



<p>These keys are then saved at the <strong>end of the file as a trailer</strong>, encrypted with <strong>RSA-4096</strong> and padded using <strong>PKCS#11 padding</strong>.</p>



<p>The files are divided into <strong>N blocks</strong>, and a percentage of each block is encrypted. This percentage is defined by the ransomware’s <code>-n</code> parameter. For each block:</p>



<ul>
<li>The first <strong>0xFFFF bytes</strong> are encrypted using <strong>KCipher2</strong>.</li>



<li>The remaining bytes are encrypted using <strong>Chacha8</strong>..</li>
</ul>



<p>The following picture shows how a file is split. Note that, for very small files, knowing the Chacha8 key and IV isn’t necessary..</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-1.png"><img loading="lazy" decoding="async" width="359" height="870" src="https://tinyhack.com/wp-content/uploads/2025/03/image-1.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-1.png 359w, https://tinyhack.com/wp-content/uploads/2025/03/image-1-124x300.png 124w" sizes="auto, (max-width: 359px) 85vw, 359px"/></a></figure>



<p>After studying various VMware filetypes (I will go deeper into this later), I am convinced that the most important files (flat VMDK and sesparse files) has a fixed header, and I can use that to attack the  encryption.</p>



<h3>Other details</h3>



<p>At this point, I didn’t analyze deeper. But I am sure that I can reverse engineer the rest of the algorithms later, specifically:</p>



<ul>
<li>How to split the file into blocks</li>



<li>How is the encryption performed across blocks, does it continue the stream?</li>
</ul>



<p>These details will be important later. However, for now, if we can’t successfully brute-force the timestamps, none of the other steps will matter.</p>



<h2>Bruteforce feasibility</h2>



<p>The approach is as follows:</p>



<ol>
<li><strong>Generate two timestamps</strong> (<code>t3</code> and <code>t4</code>).</li>



<li>Convert these timestamps into seeds and generate random bytes.</li>



<li>Use these bytes as the <strong>KCipher2 key and IV</strong>.</li>



<li>Encrypt known plaintext and compare the result with the known ciphertext from the encrypted file.</li>
</ol>



<p>Lets make a plan:</p>



<ul>
<li><strong>Check feasibility</strong>: Determine if brute-forcing is fast enough to be practical.</li>



<li><strong>Identify the plaintext</strong>: Known plaintext is required for brute-forcing. </li>



<li><strong>Estimate the seed initialization time</strong>: We need to know when the encryption seed was initialized, at least with <strong>second-level precision</strong>. This knowledge can reduce the brute-force scope to about <strong>1 billion values</strong>.</li>
</ul>



<p>The simplest (but inefficient) way is to try all possible timestamp pairs where <code>T4 &gt; T3</code>. The number of possible pairs is calculated as: N×(N−1)/2</p>



<p>With <code>N = 1 billion</code>, that results in <strong>500 quadrillion</strong> possible pairs.</p>



<p>We need to optimize this. First we need to convert all the nanoseconds in a one-to random values:</p>



<ul>
<li>On my <strong>mini PC CPU</strong>, I estimated a processing speed of 100,000 timestamp to random bytes calculations per second (utilizing all cores).</li>



<li>This means it would take about <strong>10,000 seconds</strong> (under <strong>3 hours</strong>) to convert all timestamps to seed values.</li>



<li>Once converted, these values can be saved for reuse.</li>



<li>Later, I optimized the process using a <strong>GPU</strong>, reducing the conversion time from <strong>3 hours to under 6 minutes</strong>.</li>
</ul>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-11.png"><img loading="lazy" decoding="async" width="384" height="709" src="https://tinyhack.com/wp-content/uploads/2025/03/image-11.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-11.png 384w, https://tinyhack.com/wp-content/uploads/2025/03/image-11-162x300.png 162w" sizes="auto, (max-width: 384px) 85vw, 384px"/></a></figure>



<p>If we have a completely deterministic machine, without any interruption, we can run the malware, measure it, know the exact time between T3 and T4. But unfortunately we don’t have this:</p>



<ul>
<li>The malware uses multiple threads,</li>



<li>It runs on a machine that is not idle, the distance between T3 and T4 varies based on the scheduler and how busy the system at that time. </li>



<li>The code also calls a lot of C++ libraries, which allocates and deallocates objects and makes the execution time more unpredictable.</li>
</ul>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-4.png"><img loading="lazy" decoding="async" width="752" height="338" src="https://tinyhack.com/wp-content/uploads/2025/03/image-4.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-4.png 752w, https://tinyhack.com/wp-content/uploads/2025/03/image-4-300x135.png 300w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a></figure>



<p>To be clear:</p>



<ul>
<li>we need to enumerate t3 (1 billion values for each second)</li>



<li>we dont start at t3 + 1, but at t3 + start offset, since we know that seeding the value takes time (at least a million nanosecond on my machine), this is the “<strong>start offset</strong>“</li>



<li>we assume that it will only take a few million nanosecond to until the next code is executed (remember: there can be interruptions because of the CPU scheduler, and there are several millions instructions executed). This is the “<strong>offset range</strong>” value</li>
</ul>



<p>What we can do is to try to run the exact same code as the malware, collect timing data, and try to find a range that statistically makes sense. Using the same <a href="https://tinyhack.com/2024/11/18/patching-so-files-of-an-installed-android-app/">technique that I use on my previous post</a>, instead of recreating the algorithm and running it, I just modified the malware and tested on several local machines that I have. The runtime varies quite a lot between machines.</p>



<p>My friend <a href="https://github.com/huhnscheibe">Deny</a> went to the datacenter and did the test on the real hardware that was infected. The result is: the time range varies, and sometimes quite a lot. The normal range of the offset is around 2-4 million nanoseconds (so the offset range is 2 million), but the value varies from 1.5 – 5 million (total offset range is  4.5 million). </p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-2.png"><img loading="lazy" decoding="async" width="520" height="208" src="https://tinyhack.com/wp-content/uploads/2025/03/image-2.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-2.png 520w, https://tinyhack.com/wp-content/uploads/2025/03/image-2-300x120.png 300w" sizes="auto, (max-width: 520px) 85vw, 520px"/></a></figure>



<p>We still need to enumerate 4.5 quadrillion pairs, but this appears to be doable. If we have a system capable of running 50 million encryptions per second, the process would take a few hundred days. However, with 16 such systems, we could complete it in a few months on a CPU. By renting additional machines, we could speed up the process even further. Later, I optimized this using a GPU, achieving a significant speed improvement.</p>



<p>I wasn’t sure about how fast we can do Kicpher2, but a quick comparison with chacha, and some quick benchmarking shows that using CPU ony, I should be able to do at least millions of Kichper operations per second on my machine.</p>



<p>As explained before,  if <strong>t3</strong> and <strong>t4</strong> are correct, we will be able to decrypt the <strong>first 8 bytes</strong> of the file, and it will decrypt to a known plaintext.</p>



<p>Next lets check the feasibility of obtaining plaintext from different VMware files</p>



<h3>VMWare File Types</h3>



<p>For each file, we need a plaintext sample: the first 8 bytes of the file for KCipher2 (offset 0) and another 8 bytes starting from offset 65,535 (only for large files). Since each block of KCipher2 is 8 bytes, we should use an 8-byte plaintext. It is possible to use fewer bytes (by using bit masking), but this could increase the risk of false positives.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-6.png"><img loading="lazy" decoding="async" width="375" height="438" src="https://tinyhack.com/wp-content/uploads/2025/03/image-6.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-6.png 375w, https://tinyhack.com/wp-content/uploads/2025/03/image-6-257x300.png 257w" sizes="auto, (max-width: 375px) 85vw, 375px"/></a></figure>



<h4>Flat-VMDK</h4>



<p>This is a raw disk file. If you’re lucky, this might be the only file you need to recover. However, if snapshots were made (as in this client’s case), the new data would be written to sesparse files.</p>



<p>To obtain the first 8 bytes of the flat VMDK, you’ll need to install the same OS that was used on the original VM. There are several variations of bootloaders used by different OS versions.</p>



<p>To determine which OS was used, check the corresponding VMX file. It should contain partially readable plaintext, allowing you to inspect the configuration for “guestOS”. You might find something like: guestOS=”ubuntu”. However, ideally, you already have documentation regarding which OS was used for each VM, so you don’t have to rely on this method.</p>



<p>For the bytes at position 65,535 (plaintext for Chacha8), it is almost always guaranteed to be zero, since the partition typically starts at a later sector.</p>



<h4>Sesparse</h4>



<p>If you create snapshots for your VM, there will be a SESPARSE file for each snapshots. We can see the file format from the QEMU source code.</p>



<p><a href="https://github.com/qemu/qemu/blob/master/block/vmdk.c">https://github.com/qemu/qemu/blob/master/block/vmdk.c</a></p>



<p>The file header is <code>0x00000000cafebabe</code>, and at position 65,535, it should be 0x0 (at least, that’s what I observed in my analysis).</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29.png"><img loading="lazy" decoding="async" width="1024" height="133" src="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-1024x133.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-1024x133.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-300x39.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-768x99.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-1536x199.png 1536w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29-1200x155.png 1200w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-21-13-24-29.png 1854w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a></figure>



<h4>Other files</h4>



<p>Other files are not critical for restoring a working VM, but for initial testing, understanding the time distribution can be helpful. If there are many small files with the same timestamp, it’s useful to know if they cluster within a specific timestamp range.</p>



<p>Here are some common file signatures to identify plaintexts:</p>



<ul>
<li>NVRAM files start with: 4d 52 56 4e 01 00 00 00</li>



<li>VMDK files (disk descriptor) start with the string: <code># Disk Descriptor</code></li>



<li>.VMX files start with: <code>.encoding</code></li>



<li>VMware log files have lines starting with the format: <code>YYYY-MM-DD</code></li>
</ul>



<p>By identifying plaintexts in these files, the next step is to narrow down the timestamp for accurate brute-forcing.</p>



<h3>Encryption timestamp</h3>



<p>Now that we know brute-forcing is feasible and we have both plaintext and ciphertext, the next step is to determine when the encryption occurred for each file (since each file will have different keys).</p>



<h4>ESXI log</h4>



<p>The command used to run the malware is recorded in the shell.log file (including the setting for n, which defines how much of the file should be encrypted).</p>



<p>Some ESXi hosts provide millisecond resolution in their logs, while others only offer second-level precision. This log gives us the initial timestamp for when the malware started.</p>



<p>For example, if the log shows that the malware started at 10:00:01.500, we can safely ignore the first 500 million nanoseconds when brute-forcing, which helps narrow down the search range.</p>



<h4>Filesystem timestamp and modification time</h4>



<p>Unfortunately, ESXi file systems do not support nanosecond precision.</p>



<p>Another challenge is that the file modification time is recorded only when the file is closed. This means the recorded timestamp might not exactly reflect the moment when the encryption process started but rather when it ended.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-12.png"><img loading="lazy" decoding="async" width="1024" height="287" src="https://tinyhack.com/wp-content/uploads/2025/03/image-12-1024x287.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-12-1024x287.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/image-12-300x84.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-12-768x215.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/image-12.png 1057w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a><figcaption>In Linux (using most filesystems), timestamp accuracy is nanosecond</figcaption></figure>



<p>For small files, encryption typically takes only a few milliseconds, so the timestamp will most likely reflect the exact second when the file was encrypted. The next step is to determine the encryption time for larger files, where the process takes longer and the timestamps may be less precise.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15.png"><img loading="lazy" decoding="async" width="1024" height="417" src="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15-1024x417.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15-1024x417.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15-300x122.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15-768x313.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/Screenshot-from-2025-02-15-22-04-15.png 1152w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a><figcaption>in VMFS, accuracy is second</figcaption></figure>



<h4>Multithreaded  Encryption</h4>



<p>The malware uses multithreading, where each file is processed in a new thread, with a pool of workers limited by the number of CPU cores. This has both advantages and disadvantages.</p>



<p>If the malware targets a single directory and the number of files is less than the number of CPU cores, the process is straightforward—each file will have a timestamp that is very close to the others. On an ESXi machine, it’s common to have CPUs with a large number of cores (in this case, the server has 64 cores).</p>



<p>When checking for timestamps using:</p>


<div><pre title="">find /vmfs/volumes -exec stat {} \;
</pre></div>


<p>we should be able to identify small files that were encrypted first. During brute-forcing, we can then check multiple files simultaneously for that specific moment in time.</p>



<p>Files processed first will have similar timestamps, but things become more complex for files processed later. For larger files, encryption can take seconds to minutes, and the modification time will reflect when the file was closed, which is significantly later than when the encryption key was actually generated.</p>



<p>The malware uses <strong><code>boost::filesystem</code></strong> for traversing directories and files. The iterator in <strong><code>boost::filesystem</code></strong> follows the order returned by <strong><code>readdir</code></strong>, which is the same order observed when using commands like <code>ls -f</code> or <code>find .</code>.</p>



<p>Let’s consider an example where we have 4 CPU cores and 8 files. If the files are tiny (less than 1 KB, such as VMDK descriptor files), their processing is almost instantaneous (within milliseconds). Here’s how the processing might look:</p>



<ul>
<li><strong>Threads A, B, and C</strong> each find and process <strong>small files</strong> (<code>file_a</code>, <code>file_b</code>, <code>file_c</code>), while <strong>Thread D</strong> finds a <strong>large file</strong> (<code>file_d</code>). All four files are processed <strong>immediately</strong>. </li>



<li>Once <strong>Threads A, B, and C</strong> complete, they begin processing the <strong>next set of files</strong> (<code>file_e</code>, <code>file_f</code>, <code>file_g</code>). However, these files are <strong>larger</strong> and require <strong>more processing time</strong>. </li>



<li>While the other three threads are still working,  <strong>Thread D</strong> finishes processing the large <code>file_d</code> and starts working on the <strong>final file</strong> (<code>file_h</code>). As a result, the <strong>starting timestamp</strong> of <code>file_h</code> will align with the <strong>completion time</strong> of <code>file_d</code>.</li>
</ul>



<p>Now, imagine having hundreds of files—it becomes difficult to determine the exact processing order. However, one consistent observation is that the encryption start time for a file is likely to be the same or very close to the modification time of another file.</p>



<p>This is because, once a thread finishes processing and closes a file (thereby recording its modification time), it will immediately start processing the next available file. This creates a sequence where the encryption start time of one file is closely linked to the modification time of the previous file.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-8.png"><img loading="lazy" decoding="async" width="1024" height="465" src="https://tinyhack.com/wp-content/uploads/2025/03/image-8-1024x465.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-8-1024x465.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/image-8-300x136.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-8-768x349.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/image-8.png 1041w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a></figure>



<p>So given few hundred files and plenty of CPU cores, we may only have a list of a few seconds where the malware will start to generate the random keys. </p>



<p>So now we have the final part of the puzzle: we know <strong>when</strong> the encryption was performed.</p>



<h4>Network Filesystem</h4>



<p>While reviewing the client’s logs, I noticed some entries mentioning the use of NFS. However, after clarification, it was confirmed that NFS was used only for backups and was not affected. All relevant files were stored on local disks on the server.</p>



<p>If a network filesystem had been used, it would have complicated the process. If the network time between systems wasn’t perfectly synchronized, the timestamps might have been inaccurate or unreliable, further complicating the brute-force process.</p>



<h2>Creating the bruteforcer</h2>



<p>The plan seemed solid, so the next step was to implement the code. I needed to confirm whether the encryption process worked exactly like the malware.</p>



<p>To test this, I patched the malware code to make the gettime function return a constant value of 0, ensuring predictable and consistent results during testing.</p>



<h3>KCipher2</h3>



<p>I focused on KCipher2 because not all files use the Chacha8 key, particularly small files. Although KCipher2 is a standard encryption algorithm, it’s not widely known, and I couldn’t find an optimized implementation for it.</p>



<p>During experimentation, I noticed that my results didn’t match the standard KCipher2 implementations available online. It turned out that the malware included a slight modification in the initialization vector and the encryption process, specifically involving endian swapping.</p>



<h3>CUDA</h3>



<p>I’m not an expert in CUDA programming. About 10 years ago, I briefly experimented with it but couldn’t find a practical use case for the company I worked for at the time.</p>



<p>To accelerate development, I asked ChatGPT (o1) to port the code to CUDA. The code compiled successfully but produced incorrect results. It turned out that ChatGPT had slightly modified the numbers in the constant tables. After manually correcting these values, the code began to work.</p>



<p>Although the implementation ran, I suspected it was suboptimal, but I wasn’t able to get further optimization suggestions from ChatGPT (o1). At that point, I had two options: spend more time optimizing the code or proceed with the predicted offset range and refine the code along the way. I chose to start testing immediately and optimize as needed. Unfortunately, this approach turned out to be a waste of money, as it didn’t yield any successful results.</p>



<p>At the start of the project, I only had two RTX 3060 GPUs. One was dedicated to my Windows machine, so I could only use one GPU on my Mini PC (connected externally via Oculink). To improve performance, I decided to purchase an RTX 3090. The price in Thailand was still reasonable compared to the 4090 or higher models.</p>



<p>I tested the implementation by reading the key and IV from memory, encrypting zero blocks, and writing the results back to memory. The performance was disappointing, achieving only around 60 million encryptions per second. At this rate, the entire process would take about 10 years, clearly too slow for practical recovery.</p>



<h4>Manual Optimization</h4>



<p>I performed some manual optimizations by removing unnecessary code to improve performance:</p>



<ul>
<li>Only the first block is needed for brute force, so there was no need to handle additional blocks.</li>



<li>The code was simplified to only encrypt blocks of zeroes, reducing unnecessary processing.</li>



<li>Since only the first 8 bytes of the result were required, the rest of the output was ignored to minimize computation.</li>
</ul>



<h4>Shared Memory</h4>



<p>After researching CUDA optimizations for AES, I discovered that using shared memory significantly improves performance, contrary to what ChatGPT suggested. Surprisingly, the extra steps involved in copying constant memory data to shared memory were negligible in terms of overhead but resulted in the code running several times faster.</p>



<h4>Avoiding Memory Writes</h4>



<p>Initially, I performed encryption on the GPU and matching on the host (CPU). However, this approach was slow, even when executed in parallel:</p>



<ul>
<li>generate encryption on GPU</li>



<li>copy result to CPU</li>



<li>Perform matching in a new thread and submit the next batch of work to the GPU.</li>
</ul>



<p>I found it much faster to avoid writing to memory altogether. Instead, the matching process is handled directly on the GPU, and no data is written to memory unless a match is found. This approach significantly reduced processing time and improved efficiency.</p>



<h4>Multiple files matching</h4>



<p>For each t3 and t4 combination, a match can occur for any file that shares the same second-level timestamp (but with different nanoseconds).</p>



<p>To improve efficiency, we can attempt to match multiple files simultaneously. However, if there are too many files to match, the process can slow down significantly. Currently, the number of files processed in parallel is hardcoded to 32 to maintain a balance between performance and efficiency.</p>



<h4>The Loop</h4>



<p>I considered and implemented two ways to do the loop. For every t3 value, we could start a GPU kernel to check all offset ranges. However, this method is inefficient, as it would require launching the kernel a billion times, resulting in significant overhead..</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-9.png"><img loading="lazy" decoding="async" width="1024" height="142" src="https://tinyhack.com/wp-content/uploads/2025/03/image-9-1024x142.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-9-1024x142.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/image-9-300x42.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-9-768x106.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/image-9-1536x213.png 1536w, https://tinyhack.com/wp-content/uploads/2025/03/image-9-1200x166.png 1200w, https://tinyhack.com/wp-content/uploads/2025/03/image-9.png 1587w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a></figure>



<p>Alternatively, we can launch a GPU kernel for each offset. Each kernel would then perform the necessary checks. This approach is much faster because it reduces the number of submissions to just the “offset range”, which is around 2 to 4.5 million jobs.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-10.png"><img loading="lazy" decoding="async" width="1024" height="132" src="https://tinyhack.com/wp-content/uploads/2025/03/image-10-1024x132.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-10-1024x132.png 1024w, https://tinyhack.com/wp-content/uploads/2025/03/image-10-300x39.png 300w, https://tinyhack.com/wp-content/uploads/2025/03/image-10-768x99.png 768w, https://tinyhack.com/wp-content/uploads/2025/03/image-10-1536x198.png 1536w, https://tinyhack.com/wp-content/uploads/2025/03/image-10-1200x155.png 1200w, https://tinyhack.com/wp-content/uploads/2025/03/image-10.png 1677w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 1362px) 62vw, 840px"/></a></figure>



<h4>Batch Checking</h4>



<p>Initially, my approach was to submit a task to the GPU, wait for the result using <code>cudaDeviceSynchronize()</code>, and then submit the next batch of work. However, this method proved to be slow.</p>



<ul>
<li>Submit work to the GPU, and if a match is found, simply mark it using a found flag.</li>



<li>Only call <code>cudaDeviceSynchronize()</code> to check results every 100 steps. If a match is found, the flag is reset to zero before proceeding.</li>
</ul>



<p>While this method significantly improved performance, there’s a slight possibility that if two offsets are very close (less than 100 steps apart), the code might miss one of them. Although this issue never occurred during my tests, I added an optional mode of loop. In this mode, the program reads a list of  offsets and ensures that nearby offsets are also checked manually to avoid missing any potential matches.</p>



<h4>Final Speed</h4>



<p>I believe that GPU experts could still find ways to further optimize my code. Currently, I’m achieving around 1.5 billion encryptions per second for KCipher2 on my RTX 3090.</p>



<ul>
<li>For testing 1 billion values with a single offset, it takes about 0.7 seconds, including the time to check for matches (with a maximum of 32 matches per batch).</li>



<li>Testing 2 million offsets would require approximately 16 days on a single GPU, or just 1 day using 16 GPUs.</li>
</ul>



<p>I also conducted tests using <a href="https://runpod.io?ref=uoolmxxd">Runpod</a>, and the RTX 4090 turned out to be the ideal option. Although it’s about 60% more expensive than the 3090, it’s also 2.3 times faster.</p>



<ul>
<li>With a 4090, the same process would take around 7 days on a single GPU.</li>



<li>Using 16 GPUs, the process could be completed in just over 10 hours.</li>
</ul>



<h2>Running the brute force</h2>



<p>From a cost perspective, the RTX 4090 is an excellent choice for this task due to several factors:</p>



<ul>
<li>Large memory is not required.</li>



<li>Floating-point operations are not needed.</li>



<li>The RTX 4090 offers a high number of CUDA cores, enhancing processing speed.</li>



<li>The rental price for an RTX 4090 is relatively low compared to other high-end GPUs.</li>
</ul>



<p>If the 4090 is unavailable, the 3090 is also a good alternative considering its price-to-performance ratio.</p>



<p>Initially, my client considered using Google Cloud Platform (GCP) machines and seeking a discount for a month-long rental. However, this option proved to be extremely expensive (costing tens of thousands of USD).</p>



<p>After some research, I found more cost-effective alternatives: Runpod and Vast.ai.</p>



<h3>Runpod</h3>



<p>To brute force 1 second (1 billion nanosecond), with offset range of 2 million, it  will take 7 days. The cost for a RTX 4090 (at the time of this writing) is 0.69 USD/hour. It will cost around 116 USD to brute force a single second.  Renting 16 GPUs will have the work finished in around 10 hours, same cost, but faster.</p>



<p>Brute forcing with the range of 4.5 million (which is the range that we need) costs 261 USD. Depending on the number of encrypted files, you might need to brute force 10 or more seconds. If you have a lot of files to recover, weekly or monthly rent will be cheaper.</p>



<p>Note: These costs assume everything is executed perfectly. Any mistakes or the need to repeat processes can significantly increase costs.</p>



<h3>Vast.ai</h3>



<p>Unlike runpod, when using vast.ai, you are renting a machine from some random person brokered by vast.ai. When doing the bruteforce, no sensitive data is sent, so privacy should not be a concern.</p>



<p>Using vast AI, the bruteforce cost  can be reduced to half, but this depends on your luck in obtaining the machine. The first few machines that I tested didn’t work (network timeout after around 10 minutes of waiting). I also had problem with pulling docker images from docker.io (I had to select another template from another docker repository).</p>



<h2>The rest of the work</h2>



<p>Now that I found the value of t3 and t4, I can try to find the value for t1 and t2. The value of t1 must be less than t3, and the time offset is less than 10 million nanoseconds. This can be found quickly in minutes using a single GPU.</p>



<h3>Block split algorithm</h3>



<p>Here is the algorithm used to split the file into parts:</p>



<ul>
<li>enc_block_size: for every parts/blocks, this is how many bytes to encrypt. The first 0xFFFFF will be encrypted using KCipher2, and the rest using Chacha8</li>



<li>part_size: the size of the block</li>



<li>encrypted_parts: how many blocks to encrypt</li>
</ul>


<div><pre title="">void compute_blocks(uint64_t filesize, 
    uint8_t percent,
    uint64_t *enc_block_size,
    uint64_t *part_size,
    uint64_t *encrypted_parts)
{
    int parts = 3;
    if ( percent &gt; 49u )
        parts = 5;
    uint64_t enc_size = filesize * (uint64_t)percent / 100;
    *enc_block_size = enc_size / parts;
    *encrypted_parts = parts - 1;
    *part_size = (filesize - *enc_block_size * (*encrypted_parts)) / parts;  
}
</pre></div>


<h3>Encryption Detail</h3>



<p>The malware uses the 8 rounds variant of Chacha called chacha8, not Chacha20 as many sites reported.</p>



<ul>
<li>For kcipher2, we will encrypt the first 65535 bytes (yes, not 65536). It means that one byte will remain from the first block, and this needs to be used for the next block</li>



<li>For cacha20, we just throw away the rest of the encryption stream block when starting a new block</li>
</ul>



<h2>Recovery Steps</h2>



<p>To recover your files without paying, it is not as straightforward as running a generic decryptor. You will need to:</p>



<ul>
<li>obtain timestamps of your files</li>



<li>obtain ciphertext and plaintext for your files</li>



<li>rent GPUs</li>
</ul>



<h3>Note about the code</h3>



<p>To be honest, I originally wrote this code for one-time use, specifically for this particular client. The shared code is filled with experimental logic, quick hacks, and lacks proper testing.</p>



<p>I don’t have the motivation to clean it up further, apart from removing some client-specific test cases and comments. It’s functional for the intended purpose.</p>



<figure><a href="https://tinyhack.com/wp-content/uploads/2025/03/image-14.png"><img loading="lazy" decoding="async" width="612" height="1024" src="https://tinyhack.com/wp-content/uploads/2025/03/image-14-612x1024.png" alt="" srcset="https://tinyhack.com/wp-content/uploads/2025/03/image-14-612x1024.png 612w, https://tinyhack.com/wp-content/uploads/2025/03/image-14-179x300.png 179w, https://tinyhack.com/wp-content/uploads/2025/03/image-14.png 765w" sizes="auto, (max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a></figure>



<p>The software I provided includes only the main brute-force and decryption components, intended to be used once you have the necessary timestamps.</p>



<p>I don’t have a dedicated system to manage multiple GPUs. Instead, I rely on basic shell scripting and a custom script that sends a Telegram message when a match is found. The code is “good enough for me” and simply “works for me.”</p>



<p>In essence, you’ll need a capable system administrator who understands the process and knows how to manage and troubleshoot the system effectively.</p>



<h3>Building the code</h3>



<p>See README.md in the repository, it also has a sample config file to test that it works. Sample encrypted files and configuration files are also provided.</p>



<h3>Obtain timestamps</h3>



<p>I hope you haven’t touched the files, because all hope of recovery will be gone if the timestamps are unknown. Use <code>stat filename</code> to get the modification timestamp. Use <code>find /vmfs/volumes -exec stat {} \; &gt; /tmp/stats.txt</code> to get the timestamp of everything.</p>



<p>The file <code>shell.log</code> can help to figure out the minimum timestamp to use.</p>



<h3>Obtain ciphertexts</h3>



<p>Obtain the ciphertext, as explained above:</p>



<ul>
<li>For flat-vmdk, you need to extract this from the exact OS that you use (including the exact instalation method, e.g: using BIOS/UEFI)</li>



<li>For sesparse file, use the header <code>0x00000000cafebabe</code></li>



<li>For other files, see what I wrote above</li>
</ul>



<h3>Measure server speed</h3>



<p>You can always just use an offset range of 1.5-5 million, but this may not be the correct range if your hardware is too fast or too slow. You can measure this by checking out the <code>timing-patch-1</code> folder and <code>timing-patch-2</code> folder on my github repository.</p>



<p>The first one only measures time ranges by calling the function directly. The second one is used to encrypt a directory, but it is patched so that it will write down the exact time when the timestamp is used as the seed to <code>/tmp/log.bin</code>.</p>



<h3>Divide the work</h3>



<p>Create config files based on the ciphertext/plaintext and timestamp. You can create/split this manually, or use a script to generate it. My code doesn’t do any error checking, make sure the timestamp is in nanosecond format, make sure all plaintext and ciphertext values are correct.</p>



<h3>Rent GPUs</h3>



<p>If you want a very quick and easy setup, use runpod or other service. If you want to be cheap, use vast.ai, or run it on your own hardware (~ 1K USD for one RTX 3090, which you can resell later).</p>



<h3>Run Kcipher2 bruteforce</h3>



<p>The first brute force is to find t3 and t4 for Kcipher. </p>



<p><code>./akira-bruteforce run2 config.json</code></p>



<p>Append GPU index if you have multiple GPUs</p>



<p><code>./akira-bruteforce run2 config.json 1</code></p>



<p>I suggest running it inside tmux, so you will be fine in the event of network disconnect.</p>



<p>If we are lucky, output.txt will be generated for each t3/t4 found.</p>



<h3>Run chacha8 bruteforce</h3>



<p>This is not necessary for small files, but it is neede for big files. For each offset found, generate a config with the t3 found in the previous step. On my target machine, the distance between t1 and t3 is less than 10 million, and the t1 to t2 is  around 1.5 – 5 million. The brute force should only take around 10 minutes.</p>



<h3>Decrypt the files</h3>



<p>Note that the decryptor has the percentage hardcoded to 15 percent, so please change this before running the decryptor in case the attacker uses different value.</p>



<p>Once we have obtained the t1, t2, t3, and t4, run the decryptor:</p>



<p><code>./decrypt filename.vmdk &lt;t1&gt; &lt;t2&gt; &lt;t3&gt; &lt;t4&gt;</code></p>



<p>The decryption process is not optimized, so it will take a while to decrypt.</p>



<h3>Run the cracking process</h3>



<p>To run the bruteforce:</p>



<p>./anti-akira run config.json &lt;gpuindex&gt;</p>



<p>As explained above: this may take days, so please make sure:</p>



<ul>
<li>all the config files are good</li>



<li>You are using the correct GPU index</li>



<li>make sure everything is running</li>



<li>check with nvidia-smi (with runpod, we can also view the GPU status using the web)</li>



<li>make a notification system to alert you if output.txt is created/updated</li>
</ul>







<p>Probably 99.9% of the time when you get a ransomware, it won’t be recoverable without the key. But if you are lucky, sometimes it is possible to find a solution. It took me much longer than I anticipated to solve this, I thought that it would take a week, but it took me almost three weeks until we recover an entire set of VM files.</p>



<p>I also would like to add that I found a reddit thread about <a href="https://www.reddit.com/r/sysadmin/comments/1crmt10/we_are_the_team_behind_the_decryption_of_the/">akira ransomware</a> , I wasn’t sure that the ransomware strain that I have is the same as theirs, and that is the reason why I just continue my own research and to open source it. I hope that my experience and code will be useful for someone else. </p>



<p>Everytime I wrote something about ransomware (in my Indonesian blog), many people will ask for ransomware help. Many people can’t even find the ransomware executable (just the encrypted file, which is not useful). Just checking if the ransomware is recoverable or not may take several hours with a lot of efforts (e.g: if the malware is obfuscated/protected). So please don’t ask me to do that for free. </p>
	</div></div>
  </body>
</html>
