<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmer.io/posts/py2wasm-a-python-to-wasm-compiler">Original</a>
    <h1>Py2wasm ‚Äì A Python to WASM Compiler</h1>
    
    <div id="readability-page-1" class="page"><div><p>Since starting Wasmer five years ago we&#39;ve been obsessed with empowering more languages to target the web and beyond through Webassembly.</p>
<p>One of the most popular languages out there is Python, and while it is certainly possible to run Python programs in WebAssembly, the performance is not ideal to say the least. <em>*benchmark below</em></p>
<p>Today we are incredibly happy to announce <code>py2wasm</code>: a Python to WebAssembly compiler that transforms your Python programs to WebAssembly (thanks to <a href="https://nuitka.net/">Nuitka</a>!) avoiding the interpreter overhead, allowing it to run <strong>3 times faster</strong> than with the baseline interpreter!</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fpy2wasm_benchmark.original.png&amp;w=1920&amp;q=75" alt="Native CPython vs Wasm CPython vs py2wasm"/></p>
<p>Here is how you can use it:</p>
<pre><code>$ pip install py2wasm
$ py2wasm myprogram.py -o myprogram.wasm
$ wasmer run myprogram.wasm
</code></pre>
<blockquote>
<p>Note: py2wasm needs to run in a Python 3.11 environment. You can use <a href="https://github.com/pyenv/pyenv">pyenv</a> to set Python 3.11 easily in your system: <code>pyenv install 3.11 &amp;&amp; pyenv global 3.11</code>.</p>
</blockquote>
<h3>Benchmarking</h3>
<p>Lets try to get the famous <code>pystone.py</code> benchmark running to compare native Python, regular WebAssembly and  py2wasm.</p>
<p><em>Note: you can check the code used to benchmark in <a href="https://gist.github.com/syrusakbary/b318c97aaa8de6e8040fdd5d3995cb7c">https://gist.github.com/syrusakbary/b318c97aaa8de6e8040fdd5d3995cb7c</a></em></p>
<p>When executing Python natively (387k pystones/second):</p>
<pre><code>$ python pystone.py
Pystone(1.1) time for 50000 passes = 0.129016
This machine benchmarks at 387549 pystones/second
</code></pre>
<p>When executing the CPython interpreter inside of WebAssembly (89k pystones/second):</p>
<pre><code>$ wasmer run python/python --mapdir=/app:. /app/pystone.py
Pystone(1.1) time for 50000 passes = 0.557239
This machine benchmarks at 89728.1 pystones/second
</code></pre>
<p>When using py2wasm via Nuitka (235k pystones/second):</p>
<pre><code>$ py2wasm pystone.py -o pystone.wasm
$ wasmer run pystone.wasm
Pystone(1.1) time for 50000 passes = 0.21263
This machine benchmarks at 235150 pystones/second
</code></pre>
<p>In a nutshell: using py2wasm gets about 70% of the Native Python speed‚Ä¶ and is about 2.5~3x faster than the baseline!</p>
<p>So, how does this black magic work?</p>
<p>Let&#39;s first analyze all the possible strategies that we can think of to optimize Python workloads in WebAssembly.</p>

<p>There are many ways to optimize runtime speed:</p>
<ul>
<li>Use a <strong>Python subset</strong> that can be compiled into performant code</li>
<li>Use <strong>JIT</strong> inside of Python</li>
<li>Use <strong>Static Analysis</strong> to optimize the generated code</li>
</ul>
<p>It&#39;s time to analyze each!</p>
<h2>Compile a Python subset to Wasm</h2>
<p>Instead of supporting the full Python feature set, we may want to only target a subset of it that can be optimized much further since not all features need to be supported and we can afford to do some shortcuts:</p>
<ul>
<li>‚úÖ¬†Can generate incredibly performant code</li>
<li>‚ùå Doesn‚Äôt support the full syntax or modules</li>
</ul>
<p>The most popular choices using this strategy are: CPython, RPython (PyPy) and Codon.</p>
<h3>Cython</h3>
<p><a href="https://cython.readthedocs.io/">Cython</a> has been around for many years, and is probably the oldest method to accelerate Python modules. CPython is not strictly a subset, since it supports a syntax closer to C. The main goal of Cython is to create performant modules that run next to your Python codebase. However, we want to allow creating completely standalone WebAssembly binaries from our programs.</p>
<p>So unfortunately Cython will not work for speeding up Python executables in Wasm.</p>
<h3>RPython</h3>
<p><a href="https://rpython.readthedocs.io/">RPython</a> transforms the typed code into C, and then compiles it with a normal C compiler.</p>
<p><a href="https://pypy.org/">PyPy</a> itself is compiled with RPython, which is able to do all the black magic under the hood.</p>
<pre><code>def entry_point(argv):
    print &#34;Hello, World!&#34;
    return 0
    
def target(*args):
    return entry_point
</code></pre>
<p><code>$ rpython hello_world.py</code> (‚Üí <code>hello-world-c.c</code> ) ‚Üí <code>hello-world</code> (assembly binary)</p>
<pre><code>$ rpython helloworld.py
$ ./hello-world
&#34;Hello, World!&#34;
</code></pre>
<p>However, RPython has many restrictions when running Python. For example, dictionaries need to be fully typed, and this severly limits the programs that we can use it for.</p>
<h3>Codon</h3>
<p><a href="https://github.com/exaloop/codon">Codon</a> transforms a subset of Python code into LLVM IR.</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fpy2wasm_codon.original.png&amp;w=1920&amp;q=75" alt="Codon structure"/></p>
<p>While Codon is one of the most promising alternatives and the one that offers the most speedup (from 10 to 100x faster), the subset of Python they support still has many missing features, which prevents using it for most Python code.</p>
<h2>Python JITs</h2>
<p>Another strategy is to use a JIT inside of Python, so the hot paths of execution are compiled to WebAssembly.</p>
<ul>
<li>‚úÖ Really fast speeds</li>
<li>‚ùå Needs to warm up</li>
<li>‚ùå Not trivial to support with Webassembly (but possible)</li>
</ul>
<p>One of the most popular ways (if not the most popular) is PyPy.</p>
<h3>PyPy</h3>
<p><a href="https://pypy.org/">PyPy</a> is a Python interpreter that can execute your Python programs at faster speed than the standard CPython interpreter. It speeds up the execution with a Just In Time (JIT) compiler that kicks in when doing complex computation.</p>
<p>Running a JIT in WebAssembly is not trivial, but is possible.</p>
<p>About five years ago, the project <a href="http://pypyjs.org">pypyjs.org</a> showcased this possibility by creating a new backend for PyPy that targeted Javascript/Asm.js (instead of x86_64 or arm64/aarch64).</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fpy2wasm_pypyjs.original.png&amp;w=1920&amp;q=75" alt="PyPy JS website"/></p>
<blockquote>
<p>You can check the PyPy Asm.js backend implementation here: <a href="https://github.com/pypyjs/pypy/tree/pypyjs/rpython/jit/backend/asmjs">https://github.com/pypyjs/pypy/tree/pypyjs/rpython/jit/backend/asmjs</a></p>
</blockquote>
<p>For our case, we would need to adapt this backend from outputting Javascript code to Webassembly instead.</p>
<p>It should be totally possible to implement a Wasm backend in PyPy as Pypy.js demonstrated, but unfortunately is not trivial to do so (it may take from a few weeks to a month of work).</p>
<h2>Static Analysis</h2>
<p>There‚Äôs one last strategy that we can try to speed up Python execution speed inside of WebAssembly: static analysis. Thanks to static analysis, we can analyze/autodetect the typings of our program ahead of time, so the code can be transpiled into more performant specializations (usually through Python to C transpilation).</p>
<ul>
<li>‚úÖ Mostly compatible with any Python code and applications</li>
<li>‚ùå Only 1.5-3x faster</li>
<li>‚ùå Complex to get right (from the static analyzer perspective, many quircks)</li>
<li>‚ùå Larger binaries</li>
</ul>
<h3>mypy &amp; mypy-c</h3>
<p><a href="https://mypy-lang.org/">Mypy</a> is probably the most popular static analyzer for Python.</p>
<p>The Mypy team also created a <a href="https://mypyc.readthedocs.io/en/latest/">mypy-c</a> , which gets all the typing information from Mypy and then transforms the Python code into equivalent C code that runs more performantly.</p>
<p>mypy-c is currently specialized on targeting Python modules that can run inside native Python. In our case, we want to allow creating new standalone WebAssembly binaries from our programs, so unfortunately it seems that mypy-c couldn‚Äôt work for our use case.</p>
<h3>Nuitka</h3>
<p><a href="https://wasmer.io/posts/github.com/Nuitka/Nuitka">Nuitka</a> works by transpiling the Python calls that the programs does into C, using the inner CPython API calls. It supports most Python programs, as it <strong>transpiles</strong> Python code into the corresponding CPython calls.</p>
<p>It can even work as a <strong>code obfuscator</strong> (no one will be able to decompile your program!)</p>
<hr/>
<p>After a deep analysis of all the options we realized that probably the fastest option to get Python running performantly in WebAssembly was using Nuitka.</p>

<p>Nuitka seemed like the easiest option to speed up to Python in WebAssembly contexts, mainly because most of the hard work was already done to transpile Python Code into the underlying CPython interpreter calls, so we could probably do some tweaks to get it working to compile to WebAssembly.</p>
<p>Nuitka doesn&#39;t work (<a href="https://github.com/Nuitka/Nuitka/issues/2433">yet</a>) with Python 3.12, so we had to recompile Python to 3.11 to WASI and use the generated <code>libpython.a</code> archive, so Nuitka could use this library when targeting WebAssembly and WASI to create the executable.</p>
<p>And things started working... kind of. Once we tried to run the generated Wasm file we realized another issue: because the Nuitka transpiler is executing in a 64 bit architecture, but the generated code is running in a 32 bit architecture (WebAssembly), things were not properly working. Nuitka uses a serialization/deserialization layer to cache the values of certain constants (and accelerate the startup), and while the code was being serialized in 64 bits, the deserialization was done in 32 bits, so there was a bit of mismatch.</p>
<p>Once we fixed this two issues, the prototype was fully working! Hurray! üéâ</p>
<p>We have created a PR to upstream the changes into Nuitka, feel free to take a look here:
<a href="https://github.com/Nuitka/Nuitka/pull/2814">https://github.com/Nuitka/Nuitka/pull/2814</a></p>
<blockquote>
<p>‚ÑπÔ∏è Right now py2wasm is using a fork of Nuitka, but once changes are integrated upstream we aim to make py2wasm a thin layer on top of Nuitka.</p>
</blockquote>
<hr/>
<p>We worked on <code>py2wasm</code> to fulfill our own needs first, as we want to accelerate Python execution to the maximum, so we can move our Python Django backend from Google Cloud into <a href="https://wasmer.io/products/edge">Wasmer Edge</a>.</p>
<p><code>py2wasm</code> brings us (and hopefully many others) one step closer to running Python backend apps on Edge at an incredible performance providing a much cheaper alternative for hosting these apps than the current cloud providers.</p>
<h3>Future Roadmap</h3>
<p>In the future, we would like to publish <code>py2wasm</code> as a Wasmer package, so you can just simply execute the following command to get it running. Stay tuned!</p>
<pre><code>wasmer run py2wasm --dir=. -- myfile.py -o myfile.wasm
</code></pre>
<p>We hope you enjoyed the article showcasing <code>py2wasm</code> and we can‚Äôt wait to hear your feedback on Hacker News and Github!</p>
<blockquote>
<p>This article is based on the work I presented in the Wasm I/O conference on March 15th, 2024. You can view the slides in <a href="https://speakerdeck.com/syrusakbary/compile-python-to-webassembly-with-py2wasm">SpeakerDeck</a>, or watch the presentation in Youtube: <a href="https://www.youtube.com/watch?v=_Gq273qvNMg">https://www.youtube.com/watch?v=_Gq273qvNMg</a></p>
</blockquote></div></div>
  </body>
</html>
