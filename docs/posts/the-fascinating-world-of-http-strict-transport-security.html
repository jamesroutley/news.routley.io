<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ergomake.dev/blog/hsts-introduction/">Original</a>
    <h1>The Fascinating World of HTTP Strict-Transport-Security</h1>
    
    <div id="readability-page-1" class="page"><article><p>At <a href="https://ergomake.dev">Ergomake</a>, we generate previews for every type of application whenever someone opens a pull request. After we spin up these previews, we send users a GitHub comment with links to preview their applications.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/preview-comment.png" alt=""/></p>
<p>Last week, everything was working, and we were smiling. That is, until one of our users had to set up an HTTP preview.</p>
<p>This user&#39;s preview didn&#39;t work, and that puzzled us. In this post, we&#39;ll explain how <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content">mixed content</a> broke this user&#39;s preview, how <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Strict-Transport-Security">HSTS (HTTP Strict-Transport-Security)</a> headers could&#39;ve saved us, and how Google&#39;s defaults &#34;forced&#34; us to buy yet another domain.</p>
<h2>Content-security policies, mixed content, and how they broke this preview</h2>
<p>The problem with this preview was that we served it through HTTPS, but it fetched data from an HTTP back-end outside our infrastructure.</p>
<p>By default, most browsers do not allow pages served via HTTPS to load content from HTTP origins.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/preview-error.png" alt=""/></p>
<h3>Why were HTTP requests blocked from this HTTPS preview?</h3>
<p>Assume this preview was a page that displayed comments. In that case, someone malicious could submit a comment containing the string <code>&lt;script src= &#34;https://hacker.com/exploit.js&#34;&gt;&lt;/script&gt;</code>.</p>
<p>Then, that comment&#39;s content could be interpreted as an actual HTML <code>script</code> tag if the website doesn&#39;t sanitize comments. That injected <code>script</code> tag would cause further visitors to load <code>hacker.com/exploit.js</code>, which could steal their credentials or monitor their activity.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/xss-example.png" alt=""/></p>
<p>These types of attacks are known as <a href="https://owasp.org/www-community/attacks/xss/">cross-site scripting (XSS)</a>.</p>
<p>To prevent them, in addition to sanitizing the user&#39;s inputs, engineers can set <code>Content-Security-Policy</code> headers when serving their pages.</p>
<p>These content security policies, or CSPs, are a set of rules that a website can implement to help keep visitors safe.</p>
<p>Think of it like setting up rules for a party at your house. For example, you might say that people can only come in if they&#39;re invited, can&#39;t bring any dangerous items, and have to leave by a certain time.</p>
<p>Similarly, a website&#39;s CSP sets up rules for what content can be loaded on a webpage and what these pieces of content can do.</p>
<p>For example, you can use a CSP header to say that your client can only load scripts from <code>https://example.com</code>. In that case, the user&#39;s browser will not load scripts from other sources, like <code>https://hacker.com</code>.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/xss-prevented.png" alt=""/></p>
<p>That way, malicious agents could not load scripts from origins other than the ones you&#39;ve allowed. Furthermore, setting a CSP header also prevents inline scripts from running. Consequently, attackers can&#39;t embed code as an inline <code>script</code> tag either.</p>
<p>Now, imagine that this preview website uses a script from a third party called <code>terrible-analytics.com</code>, only available via HTTP. In that case, Mr. Hacker could still inject code into your page, even if your CSP only allows scripts from <code>comments.com</code> and <code>terrible-analytics.com</code>.</p>
<p>That&#39;s because Mr. Hacker could impersonate <code>terrible-analytics.com</code>, given it doesn&#39;t use HTTPS. Then, they&#39;d be able to serve malicious scripts, which get injected into your page and executed by the user&#39;s browser.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/xss-on-path.png" alt=""/></p>
<p>These types of attacks are called <a href="https://www.cloudflare.com/en-gb/learning/security/threats/on-path-attack/">&#34;on-path attacks&#34;</a>. They happen when an attacker can place themselves between two devices. In the example above, the on-path attacker used a malicious DNS server to direct users to their servers, which delivered malware disguised as the <code>analytics.js</code> script the client expected.</p>
<p><strong>To prevent these on-path attacks, browsers disable loading &#34;mixed content,&#34; which is content served via HTTP to a page loaded via HTTPS.</strong> That way, every page loaded via HTTPS can only load content from other secure sources whose authority is &#34;certified.&#34;</p>
<p><img src="https://ergomake.dev/images/blog/hsts/xss-on-path-prevented.png" alt=""/></p>
<p>If you stop and think about it, it makes sense to block mixed content by default because it defeats HTTPS&#39;s purpose.</p>
<p>Serving an HTTPS website that loads HTTP content is kind of pointless. If you do that, attackers can still serve malicious scripts that steal credentials and track everything users are doing.</p>
<h3>Can&#39;t you just allow users to access their previews via HTTP?</h3>
<p>By now, perspicacious readers have probably concluded that we could simply avoid upgrading all HTTP requests to HTTPS.</p>
<p>That way, we could avoid the below situation illustrated, in which a user requests an HTTP website and gets redirected to its HTTPS version, failing to load data from an HTTP source.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/upgrading-http-to-https.png" alt=""/></p>
<p>By avoiding this upgrade, the user&#39;s preview would work fine because they&#39;d be loading HTTP content from a page served via HTTP.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/not-upgrading-http-to-https.png" alt=""/></p>
<p>Although serving HTTP content is not ideal, we probably shouldn&#39;t really stay in the way of our users if that&#39;s what they want to do.</p>
<p>We then went on to disable our Nginx settings which redirected HTTP requests on port <code>80</code> to HTTPS requests on port <code>443</code>. For that, we simply added the <code>nginx.ingress.kubernetes.io/ssl-redirect: &#34;false&#34;</code> annotation to the preview&#39;s ingress resource.</p>
<p>After we did that, we noticed previews were still being automatically redirected from HTTP to HTTPS, this time with a <code>307</code> status code.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/redirect-307-screenshot.png" alt=""/></p>
<p>After seeing that redirect, we looked into our HTTP Strict-Transport-Security (HSTS) settings. That&#39;s because when the <code>Strict-Transport-Security</code> header is set, it converts all future HTTP access attempts to HTTPS for the duration specified in the header&#39;s content.</p>
<p><em>As a note, HSTS headers are only respected after the first HTTPS visit. That&#39;s because on-path attackers can manipulate headers if you use an HTTP connection.</em></p>
<p><img src="https://ergomake.dev/images/blog/hsts/hsts-redirect.png" alt=""/></p>
<p>For example, the header below will convert all future HTTP access attempts to HTTPS for the next 31536000 seconds (1 year), including requests to any subdomains.</p>

<p>We thought we had forgotten to disable HSTS for our previews, so we confirmed our <code>nginx.org/hsts</code> setting was set to <code>false</code>. Then, we cleared our browser&#39;s HSTS cache and tried again.</p>
<p>No luck. We still received a 307.</p>
<p>At this point, we were puzzled, especially because <code>cURL&#39;ing the same URL yielded a </code>200<code>response, not a</code>307` redirect.</p>

<h2>Why don&#39;t these <code>force-ssl</code> and HSTS settings work?</h2>
<p>Once we saw that <code>cURL</code>&#39;s response differed from the browser&#39;s, we thought there could only be one culprit: Google.</p>
<p>After some research, we found <a href="https://ma.ttias.be/chrome-force-dev-domains-https-via-preloaded-hsts/">this blog post by Mattias Geniar</a>, which explained how Google was forcing <code>.dev</code> domains to be served via HTTPS through a preloaded HSTS setting in their Chrome browsers — which Firefox later adopted too.</p>
<p>Thanks to those preloaded settings, anyone accessing environments at <code>my-preview-name.env.ergomake.dev</code> would automatically attempt to load the preview via HTTPS, regardless of what we did.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/preloaded-hsts.png" alt=""/></p>
<p>At first, we thought we could opt out of HSTS preload, but it doesn&#39;t seem like that&#39;d be possible. Even if you access your Chrome&#39;s HSTS settings via <code>chrome://net-internals/#hsts</code>, you&#39;ll see Google doesn&#39;t allow you to remove preloaded HSTS entries.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/cant-delete-hsts.png" alt=""/></p>
<h2>Solving the problem by buying another domain</h2>
<p>There&#39;s no way to escape Google&#39;s will. If they want all <code>.dev</code> websites to be served via HTTPS, who are we to disagree?</p>
<p>We then went on to buy another domain: <code>ergomake.link</code>. From now on, we&#39;ll serve all Ergomake preview environments using that domain.</p>
<p><img src="https://ergomake.dev/images/blog/hsts/dot-link-comment.png" alt=""/></p>
<p>That&#39;s because <code>.link</code> domains won&#39;t enter browsers&#39; HSTS preload lists unless their owners explicitly want to include them.</p>
<p>To include their websites in the HSTS preload list, users can submit their websites to <a href="https://hstspreload.org">hstspreload.org</a>, a service maintained by Google.</p>
<p>Including your website in that list will protect users even before they load your site via HTTPS the first time. Then, browsers will transform all HTTP access into HTTPS regardless of whether the site has been accessed before.</p>
<p>One funny thing about hstspreload.org is that it&#39;s not in <a href="https://www.rfc-editor.org/rfc/rfc6797.html">the HSTS spec</a> at all, even though all major browsers use it.</p>
<blockquote>
<p>Google maintains an HSTS preload service. By following the guidelines and successfully submitting your domain, you can ensure that browsers will connect to your domain only via secure connections. While the service is hosted by Google, all browsers are using this preload list. However, it is not part of the HSTS specification and should not be treated as official — <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security">MDN docs for HSTS</a>.</p>
</blockquote>
<p>It&#39;s worth noticing that even the <code>preload</code> directive is non-standard, even though it&#39;s used as part of this entire &#34;preload infrastructure&#34; all across the web.</p>

<h2>Ensuring our users know HTTP previews are far from ideal</h2>
<p>We didn&#39;t just want our users to start creating HTTP previews without being aware of the security implications that come with it.</p>
<p>To prevent that, we decided to add a special label to users&#39; compose files so that they could acknowledge they&#39;re aware that HTTP previous can be dangerous.</p>
<p>Similarly to <a href="https://legacy.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml">what React does with <code>dangerouslySetInnerHtml</code></a>, we decided to create a configuration flag that would make it obvious that HTTP previews are a bad idea.</p>
<p>From now on, users who wish to set up HTTP previews must use the <code>dev.ergomake.preview.dangerously-enable-insecure-http</code> flag.</p>

<p>If that sounds scary, I&#39;m glad. We want to ensure people know setting up HTTP previews is a bad idea.</p>
<p>Even though having HTTP previews is not as bad as having an actual HTTP application running somewhere on the web, you probably still don&#39;t want people eavesdropping on whatever you write into these preview environments.</p>
<h2>Wanna chat?</h2>
<p>We&#39;re a two people startup solving the difficult technical challenge of creating isomorphic ephemeral environments for previews and development environments.</p>
<p>I&#39;d love to chat if you&#39;re interested in what we&#39;re doing or just want to talk about related subjects. <strong>Please, book a slot with me <a href="https://calendly.com/lucasfcosta/1-1-lucas-ergomake-blog">here</a></strong>.</p>
<p>Alternatively, you can send me a tweet or DM <a href="https://twitter.com/thewizardlucas">@thewizardlucas</a> or an email at lucas.costa@getergomake.com.</p>
</article></div>
  </body>
</html>
