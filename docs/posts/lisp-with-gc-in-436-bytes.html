<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/sectorlisp2/">Original</a>
    <h1>Show HN: Lisp with GC in 436 Bytes</h1>
    
    <div id="readability-page-1" class="page"><p>
December 18<sup>th</sup>, 2021 @ <a href="https://thewitchofendor.com/2021/12/18/"> justine&#39;s web page</a>

</p>

<p>
<a href="https://github.com/jart/sectorlisp">SectorLISP</a> now supports
garbage collection. This is the first time that a high-level garbage
collected programming language has been optimized to fit inside the
512-byte boot sector of a floppy disk. Since we only needed 436 bytes,
that means LISP has now outdistanced
<a href="https://github.com/cesarblum/sectorforth">FORTH</a> and
<a href="https://github.com/nanochess/bootBASIC">BASIC</a> to be
the tiniest programming language in the world.

</p><p>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/footprint2.png"><img src="https://storage.googleapis.com/justine/sectorlisp2/footprint2.png" width="850" height="636" alt="[Binary Footprint Comparison]"/></a>

</p><p>
SectorLISP consists of 223 lines of assembly. It provides a LISP system
that&#39;s powerful enough to let you write your own LISP interpreter in
just 40 lines of LISP. It&#39;s compatible with all PC models dating back to
1981 which have at least 64kb of RAM. This isn&#39;t a toy because
<a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/proof.html">SectorLISP can run the proof assistant</a> that was
included in LISP 1.5. We achieved the small file size thanks to 20/20
hindsight and an unbiased approach of <em>maximum austerity</em>. The
goal of this project has been to have fun building a kit that optimizes
for file size at the expense of everything else, which means SectorLISP
has more in common with a game
like <a href="https://www.decisionproblem.com/paperclips/">Universal
Paperclips</a> than a talking paperclip like
<a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/clippy.png">Clippy</a>.

</p><p>
This is a follow-up to a previous announcement made in October
that <a href="https://justine.lol/sectorlisp/">SectorLISP now fits in
one sector</a>. There&#39;s been many changes over the past few months that
made it possible to shave away another hundred bytes from the i8086
assembly implementation. It left plenty of room to add a 40 byte garbage
collector. This blog post will tell the story of how our low-level
<a href="#listing">assembly listing</a> evolved, using a plain and
simple C / JavaScript / Thompson Shell polyglot.

</p><h2 class="page" id="binaries">
  <a href="#binaries">Binaries</a>
   
  <img src="https://storage.googleapis.com/justine/redbean/linux.png" title="Linux" alt="[Linux]" width="28" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/windows10.png" title="Windows" alt="[Windows]" width="32" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/msdos60.png" title="MS-DOS" alt="[DOS]" width="29" height="30"/>
  <img src="https://storage.googleapis.com/justine/redbean/macos.png" title="MacOS" alt="[MacOS]" width="26" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/freebsd64.png" title="FreeBSD" alt="[FreeBSD]" width="29" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/openbsd.png" title="OpenBSD" alt="[OpenBSD]" width="34" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/netbsd2.png" title="NetBSD" alt="[NetBSD]" width="32" height="32"/>
</h2>



<p>
The .bin floppy disk boot sectors can be emulated using
<a href="https://thewitchofendor.com/2021/12/18/blinkenlights/">Blinkenlights</a> or QEMU, or you can watch
the video below.

</p><pre>curl --compressed https://justine.lol/sectorlisp2/blinkenlights.com &gt;blinkenlights.com
curl https://justine.lol/sectorlisp2/sectorlisp-friendly.bin &gt;sectorlisp-friendly.bin
chmod +x blinkenlights.com
./blinkenlights.com -rt sectorlisp-friendly.bin  <span># then press &#39;c&#39;</span>
qemu-system-i386 -nographic -fda sectorlisp-friendly.bin
</pre>

<p>
The .com file is slightly larger but it runs on seven operating systems.
It&#39;s the same as the JS simulator below.

</p><pre>curl https://justine.lol/sectorlisp2/lisp.com &gt;lisp.com
chmod +x lisp.com
./lisp.com
</pre>

<h2 id="sources">
  <a href="#sources">Sources</a>
   
  <img src="https://storage.googleapis.com/justine/redbean/linux.png" title="Linux" alt="[Linux]" width="28" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/macos.png" title="MacOS" alt="[MacOS]" width="26" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/freebsd64.png" title="FreeBSD" alt="[FreeBSD]" width="29" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/openbsd.png" title="OpenBSD" alt="[OpenBSD]" width="34" height="32"/>
  <img src="https://storage.googleapis.com/justine/redbean/netbsd2.png" title="NetBSD" alt="[NetBSD]" width="32" height="32"/>
</h2>

<p>
See the <a href="#listing">assembly listing</a> listing section. You can
build the simulator on your UNIX system if <code>cc</code> is installed:

</p><pre>curl https://justine.lol/sectorlisp2/lisp.js &gt;lisp.js
chmod +x lisp.js
./lisp.js
</pre>

<p>
Building from source means you get a better command line interface. The
shell script above will curl a GNU Readline replacement we wrote called
<a href="https://github.com/jart/bestline">Bestline</a> from this same
domain (justine.lol) to make sure you have the latest copy, because
we&#39;ve been slowly but steadily recreating support for Emacs&#39; famous
Paredit-style editing features.

</p><div>

<h2 id="simulation"><a href="#simulation">Simulation</a></h2>

<p>
You can use SectorLISP from the comfort of your browser. The C /
JavaScript source code is intended to roughly model the behavior of
SectorLISP on bare metal. Since maximum austerity leaves a bad
impression for developers getting started, this simulator is from the
<a href="https://github.com/jart/sectorlisp/tree/friendly">friendly
branch</a> which uses an extended 509 byte implementation that&#39;ll be a
much better friend for you, since it prints errors on undefined behavior
and lets you <code>DEFINE</code> persistent bindings.

</p>








<!--[if lte IE 8]>
<script src="lispie.js"></script>
<![endif]-->

</div> <!-- noprint -->

<h2 class="page" id="hardware"><a href="#hardware">Original Hardware</a></h2>

<!-- <p class="image"> -->
<!--   <a href="oldskool.jpg" -->
<!--      ><img src="//storage.googleapis.com/justine/sectorlisp2/oldskool.jpg" -->
<!--            width="960" height="506" alt="[Photo of SectorLISP REPL running on IBM PC"></a> -->

<p>
  Jim Leonard was able to confirm for us that SectorLISP does in fact
  run on the original hardware, or more specifically, the IBM PC model
  5150. That was quite thrilling to learn, since SectorLISP was largely
  written <em>a priori</em> using a emulator on Linux that we created.

</p><p>
  <iframe width="960" height="540" src="https://www.youtube-nocookie.com/embed/xD14SLU2u2k" title="YouTube video player" frameborder="0" allow="accelerometer;
  autoplay; clipboard-write; encrypted-media; gyroscope;
  picture-in-picture" allowfullscreen=""></iframe>

</p><p>
  His video provides more background on what boot sectors are. He talks
  about similar projects that have been created in the past, such as
  Oscar Toledo&#39;s pioneering work. Then, towards the end of the video,
  you get to watch SectorLISP actually running on one of the finest
  computers ever sold, which has been preserved in perfect quality.

</p><p>
  For example, you can hear the thunk of the power switch on the IBM PC.
  It&#39;s about as pleasing to hear as the thud sound an expensive German
  car like a Mercedes makes when you close the door. But the most
  pleasing of all is the vintage Model F mechanical keyboard, which to
  this day remains quite possibly the greatest and most respected
  mechanical keyboard of all time. No keyboard exists in the world
  that&#39;s superior in quality to those sold with the original IBM PC,
  except for the tenkeyless version of the
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/modelf-apl.jpg">Model F with APL legends</a> on the keycaps,
  or better yet, the <a href="https://youtu.be/hNRH1ULmbNA">IBM 3278
  Beam Spring</a> keyboard for which the Model F was intended to be a
  more economical replacement.

</p><h2 id="emulation"><a href="#emulation">Emulation</a></h2>

<p>
Here&#39;s a demo of SectorLISP v2 booting from BIOS in
<a href="https://thewitchofendor.com/2021/12/18/blinkenlights/">Blinkenlights</a> and running the
metacircular evaluator, i.e. LISP written in LISP. If you compare
video to the one from the
<a href="https://justine.lol/sectorlisp/">previous blog post</a>
you&#39;ll see how the new garbage collector has dramatically changed the
personality of the software, in terms of how it uses physical memory.
The WRITE memory panel in particular dances more, and shows how its
heap allocations behave very similar to a stack. You can also use
SectorLISP v1.o in PC browser emulator by visiting
<a href="https://copy.sh/v86/?profile=sectorlisp">copy.sh/v86/</a>.

</p>

<p>
If you&#39;re looking for something more modern, the multiplatform lisp.com
executable also runs on bare metal. Here&#39;s a Blinkenlights demo of it
booting from BIOS in 16-bit real mode. It then bootstraps itself into
32-bit mode so it can load itself off disk into memory. The final stage
of bootstrapping <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/inverted.jpg">inverts the physical memory</a>,
in a similar manner to the Linux Kernel, which enables it to run in
64-bit long mode. Once it&#39;s reached the zenith of computing modernity,
it displays a LISP REPL via the serial port.

</p>

<p>
Keep in mind that the LISP operating system above that&#39;s fast-forwarding
its way through history, is actually just the
<a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/lisp.js">JavaScript source code</a> built with
<a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a>.
Although we tuned it in <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/lisp.c">lisp.c</a> for a slight
performance nudge when compiled with GCC.

</p><h2 class="page" id="memory"><a href="#memory">Memory Model</a></h2>

<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 369 673.313969172556" width="369" height="673.313969172556">
  <rect x="0" y="0" width="369" height="673.313969172556" fill="#ffffff"></rect>
  <g stroke-linecap="round" transform="translate(85 390.9329460505396) rotate(0 33 50.5)">
    <path d="M-0.19 1.6 C22.9 1.68, 45.98 1.47, 64.65 -0.29 M0.75 -0.12 C23.43 0.97, 46.77 0.9, 66.58 0.89 M65.03 -0.9 C67.17 26.23, 64.47 56.58, 65.08 101.58 M65.14 0.39 C65.62 37.9, 66.38 77.49, 65.68 101.79 M65.94 101.07 C50.52 103.11, 37.24 100.75, -1.51 100.66 M65.38 100.12 C42.54 102.01, 19.47 101.61, 0.52 101.94 M0.64 99.88 C-0.27 75.29, -0.23 46.58, 1.51 -0.95 M0.86 101.88 C-0.55 76.43, 0.29 51.69, -0.41 -0.09" stroke="#000000" stroke-width="1" fill="none"></path>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(83.00000000000006 438.9329460505396) rotate(0 32.03804439074361 0.9568098504189493)">
      <path d="M0.41 0.94 C11.3 0.77, 54.31 0.41, 64.9 0.15 M-0.83 0.39 C9.93 0.94, 52.71 1.77, 63.91 1.76" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(75 32.93294605053961) rotate(0 0.4640451064053934 294.22133129469114)">
      <path d="M0.26 0.95 C0.43 98.81, -0.27 488.9, -0.12 586.86 M-1.07 0.4 C-0.44 98.44, 1.74 490.28, 2 588.04" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(65.00778360359374 380.2074013938382) rotate(0 59.41861720049749 -0.5235800787620235)">
      <path d="M0.96 -0.93 C20.92 -1.39, 99.35 -2.29, 118.83 -2.25 M0 1.2 C19.93 0.85, 98.64 -0.41, 118.11 -1.03" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(10 366.9329460505396) rotate(0 25.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">NULL</text>
  </g>
  <g stroke-linecap="round" transform="translate(87.5 267.4329460505396) rotate(0 33 50.5)">
    <path d="M-1.67 -1.57 C23.74 0.94, 47.56 -1.83, 64.6 -1.48 M-0.26 0.16 C25.57 -0.6, 51.31 -0.5, 65.21 -0.64 M67.1 1.34 C65.82 20.27, 63.24 40.61, 65 102.48 M65.59 0.35 C66.98 29.86, 66.29 61.22, 66.37 100.89 M67.98 102.95 C42.05 99.38, 22.75 99.43, -0.99 100.98 M65.68 100.38 C50.66 101.72, 36.31 100.79, 0.42 100.59 M-1.55 99.57 C1.94 72.76, 0.48 45.1, 1.53 -1.43 M0.89 100.18 C-0.33 75.81, -0.53 52.35, 0.9 -0.35" stroke="#000000" stroke-width="1" fill="none"></path>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(86.49999999999994 315.4329460505396) rotate(0 32.0556822832674 0.1150616115890557)">
      <path d="M-1 -0.94 C10.01 -0.94, 54.07 0.81, 65.11 0.82 M0.67 1.17 C11.63 0.78, 53.56 -0.68, 64.22 -0.87" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round" transform="translate(87.49999999999989 151.4329460505396) rotate(0 33 50.5)">
    <path d="M-0.84 0.73 C12.05 0.66, 28.34 -2.48, 65.61 -0.6 M0.85 -0.51 C15.03 0.33, 31.08 -0.88, 66.79 -0.37 M67.39 0.44 C65.72 24.71, 66.6 47.36, 66.95 100.88 M66.48 0.5 C66.34 23.13, 65.69 45.85, 65.13 101.4 M66.79 100.87 C41.05 99.71, 15.98 99.88, 1.54 101.38 M65.86 100.84 C48.34 99.75, 32.76 100.11, 0.18 101.34 M-1.44 99.36 C-1.84 61.79, 0.87 21.1, -0.69 1.38 M-0.4 101.53 C-1.8 72.28, -0.49 43.1, -0.91 -0.77" stroke="#000000" stroke-width="1" fill="none"></path>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(86.49999999999989 199.4329460505396) rotate(0 32.99198132163849 -0.15993509662112615)">
      <path d="M-0.51 0.44 C10.08 0.41, 53.13 0.96, 64.2 0.68 M1.43 -0.37 C12.34 -0.83, 55.78 -1.06, 66.49 -1.08" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round" transform="translate(89.5 36.43294605053961) rotate(0 33 50.5)">
    <path d="M0.04 1.6 C21.03 1.05, 41.11 -0.73, 65.48 0.92 M-0.97 -0.03 C15.02 -1.29, 31.51 -0.68, 65.15 0.28 M64.16 -0.15 C64.22 36.56, 65.17 68.62, 65.28 102.19 M66.15 -0.43 C65.42 24.57, 66.78 49.2, 65.16 100.06 M67.74 101.85 C48.02 102.06, 26.93 100.01, 1.77 100.36 M65.58 101.77 C42.43 101.64, 16.7 101.28, -0.12 100.83 M-1.88 100.79 C-0.16 73.63, 0.79 46.08, -1.02 -0.21 M-0.11 100.66 C0.21 70.52, -0.24 41.1, 0.41 -0.53" stroke="#000000" stroke-width="1" fill="none"></path>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(88.5 84.43294605053961) rotate(0 31.90113814926707 -0.0029065704580375495)">
      <path d="M0.02 0.96 C10.94 1.02, 54.42 0.96, 65.23 0.74 M-1.42 0.41 C9.38 0.11, 53.48 -1.05, 64.4 -0.99" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(33 330.9329460505396) rotate(0 13 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+0</text>
  </g>
  <g transform="translate(39 205.9329460505396) rotate(0 13.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+2</text>
  </g>
  <g transform="translate(38 98.93294605053961) rotate(0 12.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+4</text>
  </g>
  <g transform="translate(103 330.9329460505396) rotate(0 12 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">&#39;N&#39;</text>
  </g>
  <g transform="translate(111 281.9329460505396) rotate(0 7 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">2</text>
  </g>
  <g transform="translate(109.49999999999989 213.4329460505396) rotate(0 11 12.5)">
    <text x="11" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="middle" style="white-space: pre;" direction="ltr">&#39;I&#39;</text>
  </g>
  <g transform="translate(114 163.9329460505396) rotate(0 6.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">4</text>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(116 276.9329460505396) rotate(0 0.6710511664115302 -12.149146151002498)">
      <path d="M0.48 -0.97 C0.47 -4.97, -0.08 -19.73, -0.08 -23.55 M-0.73 1.14 C-0.38 -3.27, 2.03 -21.5, 2.07 -25.44" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(116 276.9329460505396) rotate(0 0.6710511664115302 -12.149146151002498)">
      <path d="M4.26 -14.93 C4.68 -17.79, 3.41 -19.61, 2.98 -26.57 M5.42 -13.62 C3.71 -17.21, 3.03 -20.84, 2.06 -25.44" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(116 276.9329460505396) rotate(0 0.6710511664115302 -12.149146151002498)">
      <path d="M-3.93 -15.61 C-1.05 -18.3, 0.13 -19.92, 2.98 -26.57 M-2.76 -14.31 C-1.79 -17.71, 0.2 -21.12, 2.06 -25.44" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(120 155.9329460505396) rotate(0 1.5069843376334688 -10.94142711094581)">
      <path d="M0.7 0.55 C1.46 -2.93, 3.16 -17.09, 3.4 -20.55 M-0.39 -0.21 C0.34 -4.09, 1.83 -18.78, 2.67 -22.43" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(120 155.9329460505396) rotate(0 1.5069843376334688 -10.94142711094581)">
      <path d="M5.19 -11.66 C4.66 -14.88, 4.56 -16.41, 3.67 -22.45 M4.6 -12.39 C4.28 -14.81, 3.17 -17.89, 2.59 -21.91" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(120 155.9329460505396) rotate(0 1.5069843376334688 -10.94142711094581)">
      <path d="M-1.98 -12.79 C-1.03 -15.82, 0.35 -17.11, 3.67 -22.45 M-2.57 -13.52 C-0.73 -15.55, 0.31 -18.29, 2.59 -21.91" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(116 44.93294605053961) rotate(0 7 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">0</text>
  </g>
  <g transform="translate(108 95.43294605053961) rotate(0 11.5 12.5)">
    <text x="11.5" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="middle" style="white-space: pre;" direction="ltr">&#39;L&#39;</text>
  </g>
  <g transform="translate(37 454.9329460505396) rotate(0 11 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-2</text>
  </g>
  <g transform="translate(182 209.9329460505396) rotate(0 42.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+2 is IL</text>
  </g>
  <g transform="translate(178 89.93294605053961) rotate(0 36.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+4 is L</text>
  </g>
  <g transform="translate(188 345.9329460505396) rotate(0 48.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">+0 is NIL</text>
  </g>
  <g transform="translate(187.5 377.4329460505396) rotate(0 36 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-0 is ()</text>
  </g>
  <g stroke-linecap="round" transform="translate(85 504.4329460505396) rotate(0 33 50.5)">
    <path d="M-0.46 1.91 C19.44 -2.04, 35.59 0.1, 66.46 0.1 M0 0.37 C13.75 -0.25, 27.32 -0.56, 66.2 0.64 M67.52 -0.17 C65.28 37.15, 65.25 72.04, 65.09 99.8 M66.38 -0.91 C65.77 24.65, 66.82 49.45, 66.98 101.19 M64.84 101.23 C41.58 101.52, 11.97 101.53, -0.83 100.71 M65.65 100.43 C50.98 101.13, 35.94 100.51, 0.01 101.55 M-0.11 102.22 C-0.31 80.03, 1.56 59.93, -0.86 -1.29 M1 100.36 C0.09 68.86, -0.56 36.75, -0.66 -0.83" stroke="#000000" stroke-width="1" fill="none"></path>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(83 552.4329460505396) rotate(0 32.604885220900144 0.11449807249010746)">
      <path d="M-0.27 1.15 C10.6 0.84, 54.77 -0.79, 65.48 -0.92 M1.78 0.71 C12.52 0.44, 54.03 0.55, 64.79 0.14" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(102.5 565.4329460505396) rotate(0 13.5 12.5)">
    <text x="13.5" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="middle" style="white-space: pre;" direction="ltr">+2</text>
  </g>
  <g transform="translate(109 514.9329460505396) rotate(0 11 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-2</text>
  </g>
  <g transform="translate(41 566.9329460505396) rotate(0 10.5 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-4</text>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(117 508.9329460505396) rotate(0 0.011100908609250837 -12.399317967360844)">
      <path d="M0.64 -0.53 C0.54 -4.87, 0.38 -22.41, 0.39 -26.6 M-0.48 1.8 C-0.79 -2.34, -0.48 -20.44, -0.35 -25.38" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(117 508.9329460505396) rotate(0 0.011100908609250837 -12.399317967360844)">
      <path d="M3.27 -12.65 C1.65 -16.97, 1.07 -21.76, 0.77 -26.37 M4.45 -12.92 C2.94 -16.27, 1.82 -19.09, -0.51 -25.49" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(117 508.9329460505396) rotate(0 0.011100908609250837 -12.399317967360844)">
      <path d="M-5.62 -12.83 C-3.84 -17.13, -1.02 -21.85, 0.77 -26.37 M-4.44 -13.1 C-3.71 -16.43, -2.59 -19.2, -0.51 -25.49" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(101.5 450.9329460505396) rotate(0 12.5 12.5)">
    <text x="12.5" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="middle" style="white-space: pre;" direction="ltr">+4</text>
  </g>
  <g transform="translate(105 402.9329460505396) rotate(0 11 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-0</text>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(76 617.9329460505396) rotate(0 -0.609066907381191 21.98771685624496)">
      <path d="M0.19 -0.24 C-0.08 7.18, -0.44 36.72, -0.46 44.24 M-1.16 -1.41 C-1.65 6.16, -1.3 37.46, -1.13 45.38" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(76 617.9329460505396) rotate(0 -0.609066907381191 21.98771685624496)">
      <path d="M-9.52 25.24 C-7.24 34.52, -2.98 42.81, -1.59 45.54 M-9.15 24.69 C-6.19 32.44, -3.94 39.25, -1.83 45.31" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(76 617.9329460505396) rotate(0 -0.609066907381191 21.98771685624496)">
      <path d="M5.87 25.02 C2.01 34.41, 0.11 42.79, -1.59 45.54 M6.24 24.46 C3.51 32.16, 0.05 39.05, -1.83 45.31" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(75 37.93294605053961) rotate(0 0.5062149748858076 -14.155110592022538)">
      <path d="M0.47 -0.38 C0.69 -5.11, 1.6 -23.4, 1.75 -27.93 M-0.74 -1.62 C-0.75 -6.28, 0.51 -22.73, 0.67 -26.89" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(75 37.93294605053961) rotate(0 0.5062149748858076 -14.155110592022538)">
      <path d="M4.12 -14.19 C2.12 -19.02, 1.2 -23.07, 1.91 -26.26 M5.11 -14.26 C3.09 -18.3, 2.52 -21.1, 1.08 -26.92" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(75 37.93294605053961) rotate(0 0.5062149748858076 -14.155110592022538)">
      <path d="M-5.13 -14.74 C-3.98 -19.42, -1.77 -23.28, 1.91 -26.26 M-4.14 -14.81 C-3.4 -18.76, -1.22 -21.4, 1.08 -26.92" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g transform="translate(174 445.9329460505396) rotate(0 84 25)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-2 is (L)</text>
    <text x="0" y="43" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">   or (cons &#39;L ())</text>
  </g>
  <g transform="translate(173 557.9329460505396) rotate(0 93 37.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">-4 is (IL L)</text>
    <text x="0" y="43" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">   or (cons &#39;IL</text>
    <text x="0" y="68" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">       (cons &#39;L ()))</text>
  </g>
</svg>

<p>
The most important trick to implementing LISP is to redefine
<code>NULL</code>.

</p><pre><span>function</span> Set(i, x) {
  M[Null + i] = x;
}

<span>function</span> Get(i) {
  <span>return</span> M[Null + i];
}
</pre>

<p>
LISP has two types of memory: atoms and cons cells. We store them in two
adjacent stacks that grow outward from <code>NULL</code>.

</p><p>
  Positive addresses are used to intern strings. Interning is good for
  storing symbols (which LISP calls atoms) since it lets us test string
  equality by comparing unique addresses. First among atoms
  is <code>NIL</code> which the assembly encodes as
  a <code>NUL</code>-terminated string residing at the
  <code>NULL</code> address.

</p><p>
  Negative addresses are used to store <code>Pair&lt;int&gt;</code>
  tuples, which LISP calls cons cells. These are used to chain atoms
  together into data structures such as lists and binary trees. First
  among cons cells is the empty list <code>()</code> which is stored at
  negative <code>NULL</code> and therefore equal to <code>NIL</code>.
  This multifacted nature of <code>NIL</code> serves as evidence of how
  LISP&#39;s design lends itself to symmetrical partitioning of memory, even
  if the underlying machine arithmetic doesn&#39;t support signed zero.
  Negative memory then grows down as <code>CONS</code> is called, which
  returns tuples indexed by <code>CAR</code> and <code>CDR</code>.

</p><table>
<tbody><tr><td>
<pre><span>function</span> Cons(car, cdr) {
  Set(--cx, cdr);
  Set(--cx, car);
  <span>return</span> cx;
}
</pre>
</td><td>
<pre><span>function</span> Car(x) {
  <span>return</span> Get(x);
}

<span>function</span> Cdr(x) {
  <span>return</span> Get(x + 1);
}
</pre>
</td></tr></tbody></table>

<p>
The assembly version does things the same way with the slight difference
that cons cells grow up from <code>INT_MIN</code> rather than growing
down from zero. Doing that made the code smaller, but it also lets us
make the claim that it runs on the stock configuration of the first IBM
PC, which shipped with 64kb of RAM. It&#39;s because
rebasing <code>NULL</code> on the boot address <code>0x7c00</code> gives
negative memory a legal range of <code>-0x8000</code>
to <code>-0x7c00</code> since only <code>0x10000</code> bytes of linear
memory exist. Working within the constraints of an old computer like
i8086 that required us to confront unfamiliar concepts like negative
memory is what helped the most elegant approach for C and JavaScript to
become clear.

</p><table class="page">
<tbody><tr><td>
<pre><span>function</span> ReadList() {
  <span>var</span> x = Read();
  <span>if</span> (x &gt; 0 &amp;&amp; Get(t) == Ord(<span>&#39;)&#39;</span>)) {
    <span>return</span> -0;
  } <span>else</span> {
    <span>return</span> Cons(x, ReadList(t));
  }
}
</pre>
</td><td>
<pre><span>function</span> Print(x) {
  <span>if</span> (1./x &lt; 0) {
    PrintList(x);
  } <span>else</span> {
    PrintAtom(x);
  }
}
</pre>
</td></tr></tbody></table>

<p>
One advantage of JavaScript is that it uses a sign-magnitude encoding
similar to the IBM 704 computer for which LISP was designed. That means
we can tell <code>()</code> apart from <code>NIL</code> in
our <code>Read</code> and <code>Print</code> code, even
though <code>Eval</code> doesn&#39;t care about signed zeroes. The divide by
zero hack can test for cons cells including <code>()</code>
because <code>1/-0 = -Infinity</code> and <code>-Infinity &lt; 0</code>.
C environments with integral two&#39;s complement arithmetic will simply
normalize <code>()</code> to <code>NIL</code> and the floating point
operations can be optimized away automatically
using <code>-ffast-math</code>.

</p><h2 class="page" id="evaluation"><a href="#evaluation">Evaluation</a></h2>

<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 301 178" width="301" height="178">
  <rect x="0" y="0" width="301" height="178" fill="#ffffff"></rect>
  <g transform="translate(10 76) rotate(0 140.5 17.5)">
    <text x="0" y="25" font-family="Virgil, Segoe UI Emoji" font-size="28px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">f = (lambda (X Y) Y)</text>
  </g>
  <g transform="translate(51 10) rotate(0 101 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">(car (cdr f)) = (X Y)</text>
  </g>
  <g transform="translate(42 143) rotate(0 110 12.5)">
    <text x="0" y="18" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr">(car (cdr (cdr f))) = Y</text>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(250 32) rotate(0 -9.432453009466371 21.156257541878148)">
      <path d="M0.76 -0.78 C-2.41 6.17, -15.6 34.6, -19.25 42.05 M-0.31 1.43 C-3.51 8.47, -16.56 36.31, -19.62 43.09" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(250 32) rotate(0 -9.432453009466371 21.156257541878148)">
      <path d="M-18.94 21.22 C-19.71 24.66, -17.08 31.45, -21.51 42.38 M-17.56 19.16 C-17.99 24.11, -17.85 29.59, -19.26 42.19" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(250 32) rotate(0 -9.432453009466371 21.156257541878148)">
      <path d="M-4.17 28.03 C-9.08 29.67, -10.56 34.55, -21.51 42.38 M-2.78 25.97 C-6.73 29.17, -10.09 33.04, -19.26 42.19" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
  <g stroke-linecap="round">
    <g transform="translate(260.8773927463486 136.88211610599382) rotate(357.15353075926396 4.978936633354863 -10.382116105993845)">
      <path d="M0 0 C1.66 -3.46, 8.3 -17.3, 9.96 -20.76 M0 0 C1.66 -3.46, 8.3 -17.3, 9.96 -20.76" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(260.8773927463486 136.88211610599382) rotate(357.15353075926396 4.978936633354863 -10.382116105993845)">
      <path d="M8.83 -9.31 C9.16 -12.65, 9.49 -15.99, 9.96 -20.76 M8.83 -9.31 C9.08 -11.83, 9.33 -14.36, 9.96 -20.76" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
    <g transform="translate(260.8773927463486 136.88211610599382) rotate(357.15353075926396 4.978936633354863 -10.382116105993845)">
      <path d="M1.73 -12.71 C4.13 -15.06, 6.53 -17.41, 9.96 -20.76 M1.73 -12.71 C3.54 -14.49, 5.36 -16.26, 9.96 -20.76" stroke="#000000" stroke-width="1" fill="none"></path>
    </g>
  </g>
</svg>

<p>
LISP evaluation works by recursively calling <code>Apply</code> to
transform the first element of a list into a lambda. It zips the
arguments with their parameters into the environment variables, and runs
the code contained in the function.

</p><pre>Eval(code=(SECOND ARG1 ARG2),
     vars={SECOND=(LAMBDA (X Y) Y), ARG1=FOO, ARG2=BAR}) →
  Apply(code=((LAMBDA (X Y) Y) FOO BAR),
        vars={SECOND=(LAMBDA (X Y) Y), ARG1=FOO, ARG2=BAR}) →
    Eval(code=Y,
         vars={X=FOO, Y=BAR, SECOND=(LAMBDA (X Y) Y), ARG1=FOO, ARG2=BAR}) →
BAR
</pre>

<p>
John McCarthy discovered an elegant self-defining way to compute the
above steps, more commonly known as the metacircular evaluator. Alan Kay
once described this code as the &#34;Maxwell&#39;s equations of software&#34;.
Here are those equations as implemented by SectorLISP:

</p><div class="page">

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="383pt" height="188pt" viewBox="0.00 0.00 382.55 188.00">
  <g id="graph0" transform="scale(1 1) rotate(0) translate(4 184)">
    <title>G</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 378.5458,-184 378.5458,4 -4,4"></polygon>
    <!-- ASSOC -->
    <g id="node1">
      <title>ASSOC</title>
      <ellipse fill="none" stroke="#000000" cx="42.156" cy="-18" rx="42.3126" ry="18"></ellipse>
      <text text-anchor="middle" x="42.156" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">ASSOC</text>
    </g>
    <!-- ASSOC->ASSOC -->
    <g id="edge1">
      <title>ASSOC-&gt;ASSOC</title>
      <path fill="none" stroke="#000000" d="M71.5588,-30.8993C87.6102,-33.1982 102.312,-28.8984 102.312,-18 102.312,-9.4856 93.3387,-4.9987 81.759,-4.5393"></path>
      <polygon fill="#000000" stroke="#000000" points="81.3513,-1.0563 71.5588,-5.1007 81.736,-8.0458 81.3513,-1.0563"></polygon>
    </g>
    <!-- EVAL -->
    <g id="node2">
      <title>EVAL</title>
      <ellipse fill="none" stroke="#000000" cx="141.156" cy="-162" rx="36.5575" ry="18"></ellipse>
      <text text-anchor="middle" x="141.156" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">EVAL</text>
    </g>
    <!-- EVAL->ASSOC -->
    <g id="edge2">
      <title>EVAL-&gt;ASSOC</title>
      <path fill="none" stroke="#000000" d="M106.3892,-155.8316C79.6431,-149.064 44.4296,-135.2957 27.156,-108 15.254,-89.1924 20.9357,-63.9181 28.4846,-44.9415"></path>
      <polygon fill="#000000" stroke="#000000" points="31.7426,-46.2259 32.5192,-35.6595 25.3229,-43.4354 31.7426,-46.2259"></polygon>
    </g>
    <!-- EVCON -->
    <g id="node3">
      <title>EVCON</title>
      <ellipse fill="none" stroke="#000000" cx="80.156" cy="-90" rx="44.0814" ry="18"></ellipse>
      <text text-anchor="middle" x="80.156" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">EVCON</text>
    </g>
    <!-- EVAL->EVCON -->
    <g id="edge4">
      <title>EVAL-&gt;EVCON</title>
      <path fill="none" stroke="#000000" d="M120.4999,-137.619C114.263,-130.2575 107.411,-122.1699 101.1523,-114.7825"></path>
      <polygon fill="#000000" stroke="#000000" points="117.8734,-139.9334 127.0081,-145.3008 123.2143,-135.4084 117.8734,-139.9334"></polygon>
      <polygon fill="#000000" stroke="#000000" points="103.7855,-112.476 94.6508,-107.1086 98.4446,-117.001 103.7855,-112.476"></polygon>
    </g>
    <!-- APPLY -->
    <g id="node5">
      <title>APPLY</title>
      <ellipse fill="none" stroke="#000000" cx="202.156" cy="-90" rx="41.7308" ry="18"></ellipse>
      <text text-anchor="middle" x="202.156" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">APPLY</text>
    </g>
    <!-- EVAL->APPLY -->
    <g id="edge11">
      <title>EVAL-&gt;APPLY</title>
      <path fill="none" stroke="#000000" d="M161.8121,-137.619C168.049,-130.2575 174.901,-122.1699 181.1598,-114.7825"></path>
      <polygon fill="#000000" stroke="#000000" points="159.0977,-135.4084 155.304,-145.3008 164.4386,-139.9334 159.0977,-135.4084"></polygon>
      <polygon fill="#000000" stroke="#000000" points="183.8674,-117.001 187.6612,-107.1086 178.5265,-112.476 183.8674,-117.001"></polygon>
    </g>
    <!-- EVLIS -->
    <g id="node6">
      <title>EVLIS</title>
      <ellipse fill="none" stroke="#000000" cx="318.156" cy="-90" rx="38.2799" ry="18"></ellipse>
      <text text-anchor="middle" x="318.156" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">EVLIS</text>
    </g>
    <!-- EVAL->EVLIS -->
    <g id="edge9">
      <title>EVAL-&gt;EVLIS</title>
      <path fill="none" stroke="#000000" d="M178.8906,-146.6503C208.5673,-134.5784 249.7513,-117.8257 279.6301,-105.6716"></path>
      <polygon fill="#000000" stroke="#000000" points="177.5383,-143.4219 169.5941,-150.432 180.1759,-149.9059 177.5383,-143.4219"></polygon>
      <polygon fill="#000000" stroke="#000000" points="280.9607,-108.9089 288.9048,-101.8988 278.323,-102.4248 280.9607,-108.9089"></polygon>
    </g>
    <!-- EVCON->EVCON -->
    <g id="edge3">
      <title>EVCON-&gt;EVCON</title>
      <path fill="none" stroke="#000000" d="M111.2446,-102.985C127.6131,-105.0862 142.4462,-100.7578 142.4462,-90 142.4462,-81.5114 133.2108,-77.0259 121.273,-76.5436"></path>
      <polygon fill="#000000" stroke="#000000" points="121.0692,-73.0492 111.2446,-77.015 121.3979,-80.0415 121.0692,-73.0492"></polygon>
    </g>
    <!-- PAIRLIS -->
    <g id="node4">
      <title>PAIRLIS</title>
      <ellipse fill="none" stroke="#000000" cx="202.156" cy="-18" rx="47.5274" ry="18"></ellipse>
      <text text-anchor="middle" x="202.156" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">PAIRLIS</text>
    </g>
    <!-- PAIRLIS->PAIRLIS -->
    <g id="edge5">
      <title>PAIRLIS-&gt;PAIRLIS</title>
      <path fill="none" stroke="#000000" d="M235.1908,-31.0254C252.2723,-33.0293 267.6697,-28.6875 267.6697,-18 267.6697,-9.4834 257.8922,-4.9964 245.2764,-4.5389"></path>
      <polygon fill="#000000" stroke="#000000" points="245.0304,-1.0462 235.1908,-4.9746 245.3325,-8.0397 245.0304,-1.0462"></polygon>
    </g>
    <!-- APPLY->ASSOC -->
    <g id="edge7">
      <title>APPLY-&gt;ASSOC</title>
      <path fill="none" stroke="#000000" d="M173.1812,-76.9613C147.2098,-65.2742 108.9247,-48.0459 80.4382,-35.227"></path>
      <polygon fill="#000000" stroke="#000000" points="81.7407,-31.9751 71.1851,-31.0631 78.8681,-38.3585 81.7407,-31.9751"></polygon>
    </g>
    <!-- APPLY->PAIRLIS -->
    <g id="edge6">
      <title>APPLY-&gt;PAIRLIS</title>
      <path fill="none" stroke="#000000" d="M202.156,-71.8314C202.156,-64.131 202.156,-54.9743 202.156,-46.4166"></path>
      <polygon fill="#000000" stroke="#000000" points="205.6561,-46.4132 202.156,-36.4133 198.6561,-46.4133 205.6561,-46.4132"></polygon>
    </g>
    <!-- APPLY->APPLY -->
    <g id="edge10">
      <title>APPLY-&gt;APPLY</title>
      <path fill="none" stroke="#000000" d="M231.2945,-102.8993C247.2016,-105.1982 261.7712,-100.8984 261.7712,-90 261.7712,-81.4856 252.8786,-76.9987 241.403,-76.5393"></path>
      <polygon fill="#000000" stroke="#000000" points="241.085,-73.0515 231.2945,-77.1007 241.4732,-80.0407 241.085,-73.0515"></polygon>
    </g>
    <!-- EVLIS->EVLIS -->
    <g id="edge8">
      <title>EVLIS-&gt;EVLIS</title>
      <path fill="none" stroke="#000000" d="M345.1349,-102.807C360.4065,-105.3081 374.5458,-101.0391 374.5458,-90 374.5458,-81.462 366.0876,-76.9738 355.1892,-76.5356"></path>
      <polygon fill="#000000" stroke="#000000" points="354.8852,-73.0479 345.1349,-77.193 355.342,-80.033 354.8852,-73.0479"></polygon>
    </g>
  </g>
</svg>

<pre><span>//¶</span><span>`
#define var int
#define function
//`</span>

<span>function</span> Evcon(c, a) {
  <span>if</span> (Eval(Car(Car(c)), a)) {
    <span>return</span> Eval(Car(Cdr(Car(c))), a);
  } <span>else</span> {
    <span>return</span> Evcon(Cdr(c), a);
  }
}

<span>function</span> Evlis(m, a) {
  <span>return</span> m ? Cons(Eval(Car(m), a),
                  Evlis(Cdr(m), a)) : m;
}

<span>function</span> Assoc(x, y) {
  <span>if</span> (x == Car(Car(y))) <span>return</span> Cdr(Car(y));
  <span>return</span> Assoc(x, Cdr(y));
}

<span>function</span> Pairlis(x, y, a) {
  <span>return</span> x ? Cons(Cons(Car(x), Car(y)),
                  Pairlis(Cdr(x), Cdr(y), a)) : a;
}

<span>function</span> Eval(e, a) {
  <span>var</span> A = cx;
  <span>if</span> (!e) <span>return</span> e;
  <span>if</span> (e &gt; 0) <span>return</span> Assoc(e, a);
  <span>if</span> (Car(e) == kQuote) <span>return</span> Car(Cdr(e));
  <span>if</span> (Car(e) == kCond) <span>return</span> Evcon(Cdr(e), a);
  <span>return</span> Gc(A, Apply(Car(e), Evlis(Cdr(e), a), a));
}

<span>function</span> Apply(f, x, a) {
  <span>if</span> (f &lt; 0)      <span>return</span> Eval(Car(Cdr(Cdr(f))), Pairlis(Car(Cdr(f)), x, a));
  <span>if</span> (f == kEq)   <span>return</span> Car(x) == Car(Cdr(x));
  <span>if</span> (f == kCons) <span>return</span> Cons(Car(x), Car(Cdr(x)));
  <span>if</span> (f == kAtom) <span>return</span> Car(x) &gt;= 0;
  <span>if</span> (f == kCar)  <span>return</span> Car(Car(x));
  <span>if</span> (f == kCdr)  <span>return</span> Cdr(Car(x));
  <span>return</span> Apply(Assoc(f, a), x, a);
}
</pre>

</div> <!-- page -->

<p>
The code above is from <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/lisp.js">lisp.js</a>. What makes our
Rosetta Stone possible is that C was designed to use <code>int</code> as
an implicit default type, and compilers maintained backwards
compatibility ever since. Traditional C may as well be Sanskrit since it
can&#39;t be a coincidence that the languages with the most gravitas seem to
share this as their common subset. It&#39;s unfortunate the C standards
committee intends to remove support for K&amp;R syntax, because it
implements LISP so well. Let&#39;s compare the code above to John McCarthy&#39;s
original 1950&#39;s paper which used M-expression notation:

</p><pre class="page">eval[e; a] = [
  atom[e] → assoc[e; a];
  atom[car[e]] → [
    eq[car[e]; QUOTE] → cadr[e];
    eq[car[e]; ATOM]  → atom[eval[cadr[e]; a]];
    eq[car[e]; EQ]    → [eval[cadr[e]; a] = eval[caddr[e]; a]];
    eq[car[e]; COND]  → evcon[cdr[e]; a];
    eq[car[e]; CAR]   → car[eval[cadr[e]; a]];
    eq[car[e]; CDR]   → cdr[eval[cadr[e]; a]];
    eq[car[e]; CONS]  → cons[eval[cadr[e]; a]; eval[caddr[e]; a]];
    T                 → eval[cons[assoc[car[e]; a]; evlis[cdr[e]; a]]; a]
  ];
  eq[caar[e]; LAMBDA] →
    eval[caddar[e]; append[pair[cadar[e]; evlis[cdr[e]; a]; a]]]
]
</pre>

<p>
It&#39;s a good thing that C wasn&#39;t designed until the 1970&#39;s since
otherwise JMC might never have discovered LISP. Or maybe the semicolons,
equals sign, and brackets that behave
like <code>switch</code>, <code>PROGN</code>, and <code>COND</code>
suggest the existence of a lost language that both Ritchie and JMC were
fortunate enough to use. It&#39;s unlikely, but it&#39;d explain why he felt so
unhappy working with IBM on FORTRAN since it would be like asking a Rust
developer to fix Visual Basic 6. IBM likely knew he was uniquely
qualified to help them, but they didn&#39;t accept any of his proposals,
rejecting his asks for features like recursion as unnecessary. LISP
happened as a result. It was a big opportunity loss for both the IBM PC
and JMC himself, since he could have been Bill Gates if the two had
found a way to work together.

</p><h2 class="page" id="garbage"><a href="#garbage">Garbage Collection</a></h2>

<p>
SectorLISP uses what we call an ABC garbage collector and it took only
40 bytes of assembly. It works by saving the position of the cons stack
before and after evaluation. Those values are called A and B. It then
decreases the cx cons stack pointer further by recursively copying the
<code>Eval</code> result. The new stack position is called C. The memory
between B and C is then copied up to A. Once that happens, the new cons
stack position becomes A - B + C. The purpose of this operation is to
discard all the cons cells that got created which aren&#39;t part of the
result, because we know for certain they can&#39;t be accessed anymore
(assuming functions aren&#39;t added which mutate cells).

</p><table>
<tbody><tr><td>
<pre><span>function</span> Copy(x, m, k) {
  <span>return</span> x &lt; m ? Cons(Copy(Car(x), m, k),
                      Copy(Cdr(x), m, k)) + k : x;
}

<span>function</span> Gc(A, x) {
  <span>var</span> C, B = cx;
  x = Copy(x, A, A - B), C = cx;
  <span>while</span> (C &lt; B) Set(--A, Get(--B));
  <span>return</span> cx = A, x;
}
</pre>
</td><td>
<pre><span>Copy</span>:	<span><acronym title="cmp">cmp</acronym></span>	<span>%dx</span>,<span>%di</span>
	<span><acronym title="jb">jb</acronym></span>	1<span>f</span>
	<span><acronym title="sp-=2 and *(sp+ss*16)=*(bx+di+ds*16)">push</acronym></span>	(<span>%bx</span>,<span>%di</span>)
	<span><acronym title="di = *(di+ds*16)">mov</acronym></span>	(<span>%di</span>),<span>%di</span>
	<span><acronym title="call">call</acronym></span>	Copy
	<span><acronym title="di = *(short *)(sp+ss*16) and sp+=2">pop</acronym></span>	<span>%di</span>
	<span><acronym title="sp-=2 and *(sp+ss*16)=ax">push</acronym></span>	<span>%ax</span>
	<span><acronym title="call">call</acronym></span>	Copy
	<span><acronym title="di = *(short *)(sp+ss*16) and sp+=2">pop</acronym></span>	<span>%di</span>
	<span><acronym title="call">call</acronym></span>	Cons
	<span><acronym title="sub">sub</acronym></span>	<span>%si</span>,<span>%ax</span>
	<span><acronym title="add">add</acronym></span>	<span>%dx</span>,<span>%ax</span>
	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
<span>1</span>:	<span><acronym title="xchg">xchg</acronym></span>	<span>%di</span>,<span>%ax</span>
	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td></tr></tbody></table>

<p>
Fast immediate garbage collection with zero memory overhead and perfect
heap defragmentation is as easy as ABC when your language guarantees
data structures are acyclic. The trick is to not copy anything above A,
since that memory space consists of cons cells owned by calling
functions as well as interned atoms, which should be ignored. That way
overlaps aren&#39;t possible. Thus a GC cycle can&#39;t increase memory usage.

</p><h2 class="page" id="initialization"><a href="#initialization">Initialization</a></h2>

<p>
In order to bootstrap LISP one must first bootstrap its builtin atoms.
In C you might do that using a for loop which copies chars from a string
to the memory array. However the assembly implementation doesn&#39;t need to
do anything.

</p><pre>NIL T Ω, └• QUOTE COND ATOM CAR CDR CONS EQ ╝ Ç♫▼♫•♫↨╗☻ ëßΦ◄ ΦT 
ΦA☺ûΦC ░♪Φr δΩë╧ê╨&lt; v☻¬ûΦ_ &lt; v±&lt;)v♣Ç·)wΦê=û├░(λ0ï4Φ↕ ░ ^à÷x≥t♣░∙
Φ♦ ░)δ7Φ4 à÷x▐¼ä└u⌠├&lt;(tPQë²)═E1λ^VëΘë°8=t♀≤ªt◙O1└«u²δΩ≤ñY├1└═▬┤♫
═►&lt;♪u♦░◙δ⌠Æ├àλt▬λ1ï♣Φ¡ _PΦ≡λ_ç∙ë♪ë☺ìM♦ù├Φcλ&lt;)t_ΦóλPΦ≥λδΣ9╫rΩλ1ï=
Φ⌡λ_PΦ≡λ_Φ╤λ)≡☺╨├VΦo ^à└y↔ùï9Wï=àλt╲¡λ1ï=ï4Φ»λùÆΦ¬λÆ_δΘ=) w╒ï&lt;&lt;∟
t+&lt; t&amp;&lt;↨u•àλy♫1└├&lt;$ï0¡tà1°u≥░♦├ë╓ï&lt;ï0»u∙÷ï9&lt;»ï♣├ï9Wï5¡Φ♂ _à└t≥λ5
_Φσλà└t+y╒û¡=♀ ï&lt;t┌=↕ t┌RQPΦ.λûXΦsλZë╬ùΦNλë╫)±≤ñë∙Z├╬╬╬╬╬╬╬╬╬╬╬╬
╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬ SECTORLISP v2 U¬
</pre>

<p>
x86 processors have a feature that lets us literally
redefine <code>NULL</code> to be the address to which our program is
loaded by the BIOS. It&#39;s a privilege that&#39;s normally reserved only for
operating systems. The trick we use here for is to treat the program
image itself as a set of entries in the interned strings table.

</p><p>
One problem that arises is that the BIOS asks the CPU to execute the
ASCII strings at the beginning of the image. By sheer luck we learned
<code>NIL</code> and <code>T</code> could be safely decoded without
side-effects. Had that not been the case, we&#39;d&#39;ve needed to choose a
different terminator than <code>NUL</code> which would have made the
program file larger.

</p><pre><span>&#34;N&#34;</span>	<span>dec</span>	<span>%si</span>
<span>&#34;I&#34;</span>	<span>dec</span>	<span>%cx</span>
<span>&#34;L&#34;</span>	<span>dec</span>	<span>%sp</span>
<span>&#34;\0T\0&#34;</span> <span>add</span>	<span>%dl</span>,(<span>%si</span>)  <span># and we know for certain %dl is 0</span>
	<span>ljmp</span>	<span>$0x7c00&gt;&gt;4</span>,<span>$begin</span>
</pre>

<p>
One thing you may be wondering about the above sector, is what&#39;s the
point of making it smaller than 512 bytes if you have to pad it to 512
bytes anyway to include the U¬ (AA55h) boot signature? The answer is
that we simply learned more about LISP by doing it. But it&#39;s also
because that signature wasn&#39;t part of the original PC design. It was
actually added by Microsoft to later models, similar to the more
recently introduced requirements that the Linux Kernel be distributed as
a Windows executable. The IBM PC XT will happily load and run the 436
byte version and it&#39;s a nice design.

</p><h2 class="page" id="overlapping"><a href="#overlapping">Overlapping Functions</a></h2>

<p>
If high-level programming languages like C are the Ice Hotel and
assembly is the tip of the iceberg, then the hidden dimension of
complexity lurking beneath would be Intel&#39;s variable length encoding.
This is where boot sectors get esoteric real fast, since tools can&#39;t
easily visualize it. for example, consider the following:

</p><table>
<tbody><tr><td>
<pre><span>/	%ip is 0</span>
	<span><acronym title="ax = (ax &amp; 0xff00) | 244">mov</acronym></span>	<span>$0xf4</span>,<span>%al</span>
	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td><td>
<pre><span>/	%ip is 1</span>
	<span>.byte</span>	0xb0
<span>wut</span>:	<span><acronym title="man 2 pause">hlt</acronym></span> <span># and catch fire</span>
	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td></tr></tbody></table>

<p>
Similar to how a Chess game may unfold very differently if a piece is
moved to an unintended adjacent square, an x86 program can take on an
entirely different meaning if the instruction pointer becomes off by
one. We were able to use this to our advantage, since that lets us code
functions in such a way that they overlap with one another.

</p><table>
<tbody><tr><td>
<pre><span>/	SectorLISP code.</span>
<span>89 D6</span> <span>Assoc</span>:	<span><acronym title="si = dx">mov</acronym></span>	<span>%dx</span>,<span>%si</span>
<span>8B 3C</span> <span>1</span>:	<span><acronym title="di = *(si+ds*16)">mov</acronym></span>	(<span>%si</span>),<span>%di</span>
<span>8B 30</span> 	<span><acronym title="si = *(bx+si+ds*16)">mov</acronym></span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>
<span>AF   </span> 	<span><acronym title="zf = (ax == *(di+es*16)) and di += 2">scasw</acronym></span>
<span>75 F9</span> 	<span><acronym title="jump back to label 1 if zf==0">jne</acronym></span>	1<span>b</span>
<span>F6   </span> 	<span>.byte</span>	0xF6
<span>8B 39</span> <span>Cadr</span>:	<span><acronym title="di = *(bx+di+ds*16)">mov</acronym></span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>
<span>3C   </span> 	<span>.byte</span>	0x3C
<span>AF   </span> <span>Cdr</span>:	<span><acronym title="di += 2">scasw</acronym></span>
<span>8B 05</span> <span>Car</span>:	<span><acronym title="mov">mov</acronym></span>	(<span>%di</span>),<span>%ax</span>
<span>C3   </span> 	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td><td>
<pre><span>89 D6         </span> <span>Assoc</span>:	<span><acronym title="si = dx">mov</acronym></span>	<span>%dx</span>,<span>%si</span>
<span>8B 3C         </span> <span>1</span>:	<span><acronym title="di = si">mov</acronym></span>	(<span>%si</span>),<span>%di</span>
<span>8B 30         </span> 	<span><acronym title="si = *(bx+si+ds*16)">mov</acronym></span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>
<span>AF            </span> 	<span><acronym title="zf = (ax == *(di+es*16)) and di += 2">scasw</acronym></span>
<span>75 F9         </span> 	<span><acronym title="jump back to label 1 if zf==0">jne</acronym></span>	1<span>b</span>
<span>F6 8B 39 3C AF</span> 	<span><acronym title="nop">testw</acronym></span>	<span>$0xaf</span>,0x3c39(<span>%bp</span>,<span>%di</span>)
<span>8B 05         </span> 	<span><acronym title="ax = *(short *)(di+ds*16)">mov</acronym></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>

<span>8B 39         </span> <span>Cadr</span>:	<span><acronym title="di = *(bx+di+ds*16)">mov</acronym></span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>
<span>3C AF         </span> 	<span><acronym title="nop">cmp</acronym></span>	<span>$0xaf</span>,<span>%al</span>
<span>8B 05         </span> 	<span><acronym title="ax = *(short *)(di+ds*16)">mov</acronym></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>

<span>AF            </span> <span>Cdr</span>:	<span><acronym title="di += 2">scasw</acronym></span>
<span>8B 05         </span> 	<span><acronym title="ax = *(short *)(di+ds*16)">mov</acronym></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>

<span>8B 05         </span> <span>Car</span>:	<span><acronym title="ax = *(short *)(di+ds*16)">mov</acronym></span>	(<span>%di</span>),<span>%ax</span>
<span>C3            </span> 	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td></tr></tbody></table>

Note that you can hover over the instruction names above to see a
tooltip explaining what they do. For further details, please see the
<a href="https://justine.lol/blinkenlights/8086.html">Blinkenlights&#39;
i8086 ISA encoding rundown</a> and
<a href="https://www.felixcloutier.com/x86/">Intel&#39;s manual</a>.

<h2 class="page" id="performance"><a href="#performance">Performance</a></h2>

<p>
It takes about 10 milliseconds on a 4.77mhz IBM PC to run to run a LISP
program wrapped inside John McCarthy&#39;s metacircular evaluator. However
an obvious bottleneck exists with the interning algorithm which takes
upwards of 50 milliseconds during the <code>Read</code> operation. Even
on a forty year old computer, fifty milliseconds of latency is quite
sluggish in terms of performance; so let&#39;s fix that.

</p><p>
Tinier solutions are usually better ones, but that&#39;s not always the
case. The assembly version of our <code>Intern</code> function has an
obvious scalability bottleneck since it saves space by using a
double-nul-terminated list. The simplest way to improve that is to
redefine positive memory to be a hash table containing linked lists of
characters.

</p><table>
<tbody><tr><td>
<pre><span>function</span> Probe(h, p) {
  <span>return</span> (h + p * p) &amp; (Null / 2 - 1);
}

<span>function</span> Hash(h, x) {
  <span>return</span> (((h + x) * 3083 + 3191) &gt;&gt; 4) &amp; (Null / 2 - 1);
}

<span>function</span> Intern(x, y, h, p) {
  <span>if</span> (x == Get(h) &amp;&amp; y == Get(h + Null / 2)) <span>return</span> h;
  <span>if</span> (Get(h)) <span>return</span> Intern(x, y, Probe(h, p), p + 1);
  Set(h, x);
  Set(h + Null/2, y);
  <span>return</span> h;
}

<span>function</span> ReadAtom() {
  <span>var</span> x, y;
  ax = y = 0;
  <span>do</span> x = ReadChar();
  <span>while</span> (x &lt;= Ord(<span>&#39; &#39;</span>));
  <span>if</span> (x &gt; Ord(<span>&#39;)&#39;</span>) &amp;&amp; dx &gt; Ord(<span>&#39;)&#39;</span>)) y = ReadAtom();
  <span>return</span> Intern(x, y, (ax = Hash(x, ax)), 1);
}
</pre>
</td><td>
<pre><span>/	this is slow</span>
<span>Intern</span>:	<span>push</span>	<span>%cx</span>
	<span><acronym title="bp=di">mov</acronym></span>	<span>%di</span>,<span>%bp</span>
	<span><acronym title="bp-=cx">sub</acronym></span>	<span>%cx</span>,<span>%bp</span>
	<span><acronym title="++bp">inc</acronym></span>	<span>%bp</span>
	<span><acronym title="di=0">xor</acronym></span>	<span>%di</span>,<span>%di</span>
<span>1</span>:	<span><acronym title="si = *(short *)(sp+ss*16) and sp+=2">pop</acronym></span>	<span>%si</span>
	<span><acronym title="sp-=2 and *(short *)(sp+ss*16)=si">push</acronym></span>	<span>%si</span>
	<span><acronym title="cx=bp">mov</acronym></span>	<span>%bp</span>,<span>%cx</span>
	<span><acronym title="ax=di">mov</acronym></span>	<span>%di</span>,<span>%ax</span>
	<span><acronym title="zf = !(*(char *)(di+ds*16)-((bx&amp;0xff00)&gt;&gt;8))">cmp</acronym></span>	<span>%bh</span>,(<span>%di</span>)
	<span><acronym title="jump forward to label 8 if zf==1">je</acronym></span>	8<span>f</span>
	<span><acronym title="memcmp(di+es*16,si+ds*16,cx)">rep cmpsb</acronym></span>
	<span><acronym title="je">je</acronym></span>	9<span>f</span>
	<span><acronym title="ax = 0">xor</acronym></span>	<span>%ax</span>,<span>%ax</span>
	<span>dec</span>	<span>%di</span>
<span>2</span>:	<span><acronym title="zf = !(*(char *)(di+ds*16)-(ax&amp;255))">scasb</acronym></span>
	<span><acronym title="jump backward to label 2 if zf==0">jne</acronym></span>	2<span>b</span>
	<span><acronym title="jump back to label 1">jmp</acronym></span>	1<span>b</span>
<span>8</span>:	<span><acronym title="memcpy(di+es*16, si+ds*16, cx)">rep movsb</acronym></span>
<span>9</span>:	<span><acronym title="cx = *(short *)(sp+ss*16) and sp+=2">pop</acronym></span>	<span>%cx</span>
	<span><acronym title="jump to *(short *)(sp+ss*16)+cs*16 and sp+=2">ret</acronym></span>
</pre>
</td></tr></tbody></table>

<p>
The trick here is to find a hash function so that <code>NIL</code>
interns at the <code>NULL</code> position and <code>T</code> interns at
1. That&#39;s what lets our <code>Apply</code> code be more elegant. In the
above example, the magic numbers (3083, 3191, 4) were chosen under the
assumption that Null is 040000. If it were a different two-power like
0400000, then the magnums would be (60611, 20485, 0). If you wish to
dive deeper then take a look at
<a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/lisp.js">lisp.js</a>, <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/hash.c">hash.c</a>, and
<a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/hash.com">hash.com</a>.

</p><table>
<tbody><tr>
<td>
<pre>(<span>DEFINE</span> REVERSE .
  (<span>LAMBDA</span> (X Y)
    (<span>COND</span> (X (REVERSE (<span>CDR</span> X)
                (<span>CONS</span> (<span>CAR</span> X) Y)))
          ((<span>QUOTE</span> T) Y))))
</pre>
</td><td>
<pre>(REVERSE (<span>QUOTE</span> (A B C D)) ())
</pre>
</td></tr></tbody></table>

<p>
One of the known issues with recursive functions is that they have
suboptimal performance without the aid of a tail call optimizer that can
do copy elision. This can have a negative impact on the performance of
the ABC Garbage Collector in list building functions such as the one
above. Blinkenlights is good at spotting scalability problems early.

</p><div>

<p>
  <video id="quadratic2" width="960" height="540" controls="" muted="" loop="" preload="none">
    <source src="//storage.googleapis.com/justine/sectorlisp2/quadratic2.mp4" type="video/mp4"/>
    [Screencast of Das Blinkenlights visualizing i8086 execution of <code>
     (REVERSE (QUOTE (A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)))</code>]
  </video>
</p>

</div> <!-- noprint -->

<p class="page">
The canonical workaround to this kind of problem is to use binary trees
instead of lists for big data, since binary trees will reduce the the
call stack depth from being linear to logarithmic.

</p><table>
<tbody><tr>
<td>
<pre>(<span>DEFINE</span> REVERSE .
  (<span>LAMBDA</span> (X)
    (<span>COND</span> ((<span>ATOM</span> X) X)
          ((<span>QUOTE</span> T)
           (<span>CONS</span> (REVERSE (<span>CDR</span> X))
                 (REVERSE (<span>CAR</span> X)))))))
</pre>
</td><td>
<pre>(REVERSE
 (<span>QUOTE</span>
  (((((A . B) . C) .
     ((D . E) . F)) .
    (((G . H) . I) .
     ((J . K) .
      (L . M)))) .
   ((((N . O) . P) .
     ((Q . R) . S)) .
    (((T . U) . V) .
     ((W . X) .
      (Y . Z)))))))
</pre>
</td></tr></tbody></table>

<div>
<p>
  <video id="logarithmic2" width="960" height="540" controls="" muted="" loop="" preload="none">
    <source src="//storage.googleapis.com/justine/sectorlisp2/logarithmic2.mp4" type="video/mp4"/>
    [Screencast of Das Blinkenlights visualizing i8086 execution of <code>
     (REVERSE (QUOTE (((((A . B) . C) . ((D . E) . F)) . (((G . H) . I) . ((J . K) . (L . M)))) . ((((N . O) . P) . ((Q . R) . S)) . (((T . U) . V) . ((W . X) . (Y . Z)))))))</code>]
  </video>
  
</p>
</div> <!-- noprint -->

<p>
One thing profiling reveals is that LISP spends most of its time inside
<code>Assoc</code> looking up variables, because recursive functions
repeatedly append the same variables to the dynamically-scoped
<code>a</code> list. One low-hanging fruit optimization that&#39;s much
easier than implementing a tail-call optimizer is simply tuning
<code>Pairlis</code> to peel away repeated variables.

</p><pre><span>function</span> Peel(x, a) {
  <span>return</span> a &amp;&amp; x == Car(Car(a)) ? Cdr(a) : a;
}

<span>function</span> Pairlis(x, y, a) {
  <span>return</span> x ? Cons(Cons(Car(x), Car(y)),
                  Pairlis(Cdr(x), Cdr(y),
                          Peel(Car(x), a))) : a;
}
</pre>

<p>
The above optimization allows SectorLISP to outperform Emacs, based on a
benchmark of the &#34;Triple LISP&#34; example available under the Simulator
Load button. See <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/eval4.lisp">eval4.lisp</a> for the Emacs Lisp
translation. Emacs takes 2,187µs to run that, whereas SectorLISP takes
1580µs. This hack also helped reduce JavaScript latency from ~30ms to
~15ms.

</p><h2 class="page" id="garbage"><a href="#garbage">Logic Model</a></h2>

<table>
  <tbody><tr>
    <td>
      <blockquote>
        <p>
          Now summon cunning soul, frauds, and deceits</p><p>
          —
          Lucius Annaeus Seneca</p></blockquote>
    </td><td>
      <blockquote>
        <p>
          <span lang="la" aria-label="NUNC ADVOCA ASTUS ANIME">NVNC ADVOCA ASTVS ANIME</span></p></blockquote>
</td></tr></tbody></table>

<p>
The meaning of truth is underspecified by John McCarthy&#39;s original
paper; however, if you read the LISP 1.5 source code, one of the first
things you&#39;ll see is this charming comment, which attempts to provide a
definition:

</p><pre>                              <span>* PROP LISTS FOR ATOMS NIL &amp; VERITAS-NUMQUAM-PERIT</span>
                              <span>* THE ZERO AND THE BINARY TRUTH ATOMS RESPECTIVELY</span>
                              <span>*</span>
                       77640         <span>ORG</span>     COMMON-18
<span>      77640</span>  0 00137 0 07335  NILSXX         <span>$PNAME</span>,,-*-1
<span>      77641</span>  0 00000 0 00136                 -*-1
<span>      77642</span> -0 00000 0 00135         <span>MZE</span>     -*-1
<span>      77643</span> -053143777777            <span>OCT</span>     453143777777      <span>NIL</span>
<span>      77644</span>  0 00000 0 00370  NILLOC         <span>$ZERO</span>
                              <span>*</span>
<span>      77645</span>  0 00132 0 10742   STS           <span>$APVAL</span>,,-*-1
<span>      77646</span> -0 00130 0 00131         <span>MZE</span>     -*-1,,-*-2
<span>      77647</span>  0 00000 0 00001                 1                 <span>IS A CONSTANT ,,1 FOR APPLY</span>
<span>      77650</span>  0 00127 0 07335                 <span>$PNAME</span>,,-*-1
<span>      77651</span>  0 00000 0 00126                 -*-1
<span>      77652</span> -0 00000 0 00125         <span>MZE</span>     -*-1
<span>      77653</span>  546351642554            <span>BCI</span>     1,<span>*TRUE*</span>
</pre>

<p>
LISP 1.5 is a real trickster compared to modern LISP implementations
because it clandestinely maps <code>T</code> to <code>*TRUE*</code> the
latter of which is the true truth, since it&#39;s what builtin predicates
like <code>ATOM</code> and <code>EQ</code> actually return. It figures
they would quote someone who was tormenting Hector&#39;s widow since that
design probably tormented many MIT students. LISP 1.5 also jealously
guards its definition of truth, and will throw a constant error if you
try to change it.

</p><p>
A Latin phrase that better describes SectorLISP is <span lang="la" aria-label="NIHIL NUMQUAM PERIT"> NIHIL NVMQVAM PERIT</span>
or in English <em>what is dead may never die</em>. What it means is
that <code>NIL</code> is the only atom SectorLISP won&#39;t let you
redefine. You can however define <code>T</code> to have any meaning you
wish, or use it as a variable name, since it&#39;s just an atom, and
anything that isn&#39;t <code>NIL</code> is considered true by
<code>EVCON</code>. From a programming perspective, this means you&#39;d
need to use something like <code>(QUOTE T)</code> rather
than <code>T</code> in the default clauses of your <code>COND</code>
statements, unless you map <code>T</code> to <code>T</code>.

</p><p>
We chose this model simply because it&#39;s what made the file size tinier.
So it actually can be a good idea to have a less permissive design which
prevents <code>T</code> from perishing, because making that a builtin
feature of <code>Eval</code> alone can improve the performance of the
arithmetic code below by ten percent.

</p><h2 class="page" id="arithmetic"><a href="#arithmetic">Arithmetic</a></h2>

<p>
SectorLISP doesn&#39;t support numbers; but that&#39;s OK, since Arabic numerals
are after all just a sequence of digits, and digits are symbols. Since
SectorLISP does support sequences and symbols, you can use LISP&#39;s
preschool math to implement elementary maths like arithmetic. All you
need is a few lines of code. The simplest way we could model unsigned
integers is by using lists and then switching the Arabic right-to-left
ordering to be left-to-right instead (i.e. little endian). We&#39;ll then
define
<code>NIL</code> as 0, and anything that isn&#39;t
<code>NIL</code> shall be 1. For example, a number such as ten
(or <code>0b1010</code> in binary) could then be encoded as <code>(NIL T
NIL T)</code>. Now that we&#39;ve defined how our LISP numbers look, we can
implement recursive functions that operate on them.

</p><table>
<tbody><tr><td>
<pre>(<span>DEFINE</span> T . T)
(<span>DEFINE</span> NOT  . (<span>LAMBDA</span> (X) (<span>COND</span> (X NIL) (T T))))
(<span>DEFINE</span> OR   . (<span>LAMBDA</span> (X Y) (<span>COND</span> (X T) (T Y))))
(<span>DEFINE</span> AND  . (<span>LAMBDA</span> (X Y) (<span>COND</span> (X Y) (T NIL))))
(<span>DEFINE</span> XOR  . (<span>LAMBDA</span> (X Y) (<span>COND</span> (X (NOT Y)) (T Y))))
(<span>DEFINE</span> HEAD . (<span>LAMBDA</span> (X) (<span>COND</span> (X (<span>CAR</span> X)) (T NIL))))
(<span>DEFINE</span> TAIL . (<span>LAMBDA</span> (X) (<span>COND</span> (X (<span>CDR</span> X)) (T ()))))

(<span>DEFINE</span> + .
  (<span>LAMBDA</span> (A B)
    (ADD A B NIL)))

(<span>DEFINE</span> ADD .
  (<span>LAMBDA</span> (A B C)
    (<span>COND</span> ((OR A B)
           (<span>CONS</span> (XOR (XOR (HEAD A) (HEAD B)) C)
                 (ADD (TAIL A) (TAIL B)
                      (OR (AND (XOR (HEAD A) (HEAD B)) C)
                          (AND (HEAD A) (HEAD B))))))
          (C (<span>CONS</span> C ()))
          (T ()))))
</pre>
</td><td>
<pre>(<span>DEFINE</span> EQUAL .
  (<span>LAMBDA</span> (X Y)
    (<span>COND</span> ((<span>ATOM</span> X) (<span>EQ</span> X Y))
          ((<span>ATOM</span> Y) (<span>EQ</span> X Y))
          ((EQUAL (<span>CAR</span> X) (<span>CAR</span> Y))
           (EQUAL (<span>CDR</span> X) (<span>CDR</span> Y)))
          ((<span>QUOTE</span> T) NIL))))

<span>(DEFINE COMMENT 0 + 0 = 0)</span>
(EQUAL (+ ()
          ())
       ())

<span>(DEFINE COMMENT 1 + 1 = 2)</span>
(EQUAL (+ (<span>QUOTE</span> (T))
          (<span>QUOTE</span> (T)))
       (<span>QUOTE</span> (NIL T)))

<span>(DEFINE COMMENT 1 + 2 = 3)</span>
(EQUAL (+ (<span>QUOTE</span> (T))
          (<span>QUOTE</span> (NIL T)))
       (<span>QUOTE</span> (T T)))

<span>(DEFINE COMMENT 2 + 2 = 4)</span>
(EQUAL (+ (<span>QUOTE</span> (NIL T))
          (<span>QUOTE</span> (NIL T)))
       (<span>QUOTE</span> (NIL NIL T)))

<span>(DEFINE COMMENT 10 + 10 = 20)</span>
(EQUAL (+ (<span>QUOTE</span> (NIL T NIL T))
          (<span>QUOTE</span> (NIL T NIL T)))
       (<span>QUOTE</span> (NIL NIL T NIL T)))
</pre>
</td></tr></tbody></table>

<p>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/FullAdder.png"><img src="https://storage.googleapis.com/justine/sectorlisp2/FullAdder.png" width="275" height="175" alt="[Full Adder Circuit Schematic]"/></a>

</p><p>
The above code iterates over two lists of bits and then applies the full
adder schematic. The nice thing about this code is it supports arbitrary
precision. The Googlepedia solution to this kind of problem is to use
Church numerals; but since Church encoding requires an amount of memory
equal to the numbers themselves, that means we wouldn&#39;t be able to have
numbers larger than 8192 on the IBM PC XT. That might be fine for
proving theorems, but how would you like to own a 13-bit computer?
SectorLISP instead unleashes your oldskool 16-bit CPU, enabling it to
perform 64-bit and even 128-bit computations.

</p><p class="page">
Since microoptimizations are very highly prized in arithmetic, one way
we might do that with SectorLISP by using builtins more and taking
advantage of friendly branch features, such as dot cons literals which
let us remove a <code>CAR</code> call. The friendly branch also defines
<code>CAR</code> and <code>CDR</code> the modern way which means we
don&#39;t need to define <code>HEAD</code> and <code>TAIL</code> plus it
obfuscates the need for a wrapper. If we combine those techniques with a
builtin tautology atom then this new definition should triple addition
performance with a nice raw quality that self-documents the truth table.

</p><pre>(<span>DEFINE</span> + .
  (<span>LAMBDA</span> (A B C)
    (<span>COND</span> ((<span>COND</span> (A T)
                 (T B))
           ((<span>LAMBDA</span> (S)
              (<span>CONS</span> (<span>CAR</span> S)
                    (+ (<span>CDR</span> A)
                       (<span>CDR</span> B)
                       (<span>CDR</span> S))))
            (<span>COND</span> ((<span>CAR</span> A) (<span>COND</span> ((<span>CAR</span> B) (<span>COND</span> (C (<span>QUOTE</span> (T   . T  )))
                                                (T (<span>QUOTE</span> (NIL . T  )))))
                                       (T (<span>COND</span> (C (<span>QUOTE</span> (NIL . T  )))
                                                (T (<span>QUOTE</span> (T   . NIL)))))))
                        (T (<span>COND</span> ((<span>CAR</span> B) (<span>COND</span> (C (<span>QUOTE</span> (NIL . T  )))
                                                (T (<span>QUOTE</span> (T   . NIL)))))
                                       (T (<span>COND</span> (C (<span>QUOTE</span> (T   . NIL)))
                                                (T (<span>QUOTE</span> (NIL . NIL))))))))))
          (C (<span>CONS</span> C ()))
          (T ()))))
</pre>

<p>
Another interesting thing about our arithmetic model is how the loose
typing of truthiness means that S-expressions in general could be seen
as having numeric values, almost like Hebrew numerals. We haven&#39;t
imagined a use case for it yet, but let us know if you do, since that
could be very cool.

</p><h2 class="page" id="calculus"><a href="#calculus">Calculus</a></h2>

<p>
Arithmetic in SectorLISP is very elegant, but unfortunately the numbers
themselves aren&#39;t that readable unless you write a radix converter and
reverse the lists. So calculus and algebra are usually better use cases
for LISP since their inputs and outputs are already symbolic sequences
and LISP is a symbolic language. John McCarthy gives a nice example in
one of his memos on how you can use SectorLISP as a difference engine
using functional programming.

</p><pre>(<span>DEFINE</span> T . T)

(<span>DEFINE</span> MAP .
  (<span>LAMBDA</span> (L F)
    (<span>COND</span> (L (<span>CONS</span> (F (<span>CAR</span> L))
                   (MAP (<span>CDR</span> L) F)))
          (T ()))))

(<span>DEFINE</span> DIFF .
  (<span>LAMBDA</span> (X WRT)
    (<span>COND</span> ((<span>ATOM</span> X)
           (<span>COND</span> ((<span>EQ</span> X WRT) (<span>QUOTE</span> ONE))
                 (T (<span>QUOTE</span> ZERO))))
          ((<span>EQ</span> (<span>CAR</span> X) (<span>QUOTE</span> PLUS))
           (<span>CONS</span> (<span>QUOTE</span> PLUS)
                 (MAP (<span>CDR</span> X)
                      (<span>QUOTE</span>
                       (<span>LAMBDA</span> (Z)
                         (DIFF Z WRT))))))
          ((<span>EQ</span> (<span>CAR</span> X) (<span>QUOTE</span> TIMES))
           (<span>CONS</span> (<span>QUOTE</span> PLUS)
                 (MAP (<span>CDR</span> X)
                      (<span>QUOTE</span>
                       (<span>LAMBDA</span> (Z)
                         (<span>CONS</span> (<span>QUOTE</span> TIMES)
                               (MAP (<span>CDR</span> X)
                                    (<span>QUOTE</span>
                                     (<span>LAMBDA</span> (W)
                                       (<span>COND</span> ((EQ Z W)
                                              (DIFF W WRT))
                                             (T W))))))))))))))

<span>(DEFINE COMMENT DIFF X * (X + A) * Y WRT X)</span>
<span>(DEFINE COMMENT    = (1 * (X + A) * Y) + (X * (1 + 0) * Y) + (X * (X + A) * 0))</span>
<span>(DEFINE COMMENT    = ((X + A) * Y) + (X * Y))</span>
<span>(DEFINE COMMENT    = Y * (A + 2 * X))</span>
(EQUAL (DIFF (<span>QUOTE</span> (TIMES X (PLUS X A) Y))
             (<span>QUOTE</span> X))
       (<span>QUOTE</span> (PLUS (TIMES ONE (PLUS X A) Y)
                    (TIMES X (PLUS ONE ZERO) Y)
                    (TIMES X (PLUS X A) ZERO))))
</pre>

<p>
Since we skipped from arithmetic to calculus, it should be noted that
LISP is also really good at writing programs that simplify algebraic
expressions. For that reason, it&#39;s always been popular as a language
among compiler authors, and GCC actually uses a dialect of LISP
internally for exactly this purpose. So even if your experience has been
focused on writing C and C++ in Vim, you&#39;ve still been using LISP this
whole time without realizing.

</p><h2 class="page" id="universality"><a href="#universality">Universality</a></h2>

<p>
The strangest thing that became apparent in our quest to demo a language
that&#39;s based on lambda calculus is that the lambda keyword itself is
superfluous. That&#39;s not to imply LISP doesn&#39;t have lambdas, but rather
that it&#39;s such a powerful concept that it needn&#39;t be named.
<code>Apply</code> is able to check for lambdas
using <code>f&lt;0</code> and then ignores <code>Car(f)</code>. We could
have saved 2 bytes by dropping the <code>LAMBDA</code> keyword
(e.g. <code>(((X) X) (QUOTE ARG))</code> instead of <code>((LAMBDA (X)
X) (QUOTE ARG))</code>) but we left things alone, since it&#39;s an obvious
focal point for language revision schemes. It also makes SectorLISP
itself more flexible in terms of syntax. For example, you could
say <code>((FUNCTION (X) X) (QUOTE ARG))</code> or <code>((LOL (X) X)
(QUOTE ARG))</code> and it would mean the same thing. In the friendly
branch, you can also say <code>(DEFINE IDENTITY AS (X) X)</code> rather
than <code>(DEFINE IDENTITY . (LAMBDA (X) X))</code>.

</p><p>
The same concept also applies to <code>COND</code> which can be removed
if we treat the <code>LAMBDA</code> body as an
implicit <code>COND</code>. But it&#39;d only save us 11 bytes. That&#39;s too
big a tradeoff for the glory of 425 bytes, which can be viewed in the
<a href="https://github.com/jart/sectorlisp/commit/2a00af296b3e8aff8092652b0350451c4f0be316">reform
branch</a>. Reforming the LISP language has never been our goal, because
it should be your goal. For example, here&#39;s how LISP could be defined
using only six builtins, which we&#39;ll call
<code>LINK</code>, <code>HEAD</code>, <code>TAIL</code>, 
<code>EQ</code>, <code>ATOM</code>, and <code>Q</code>.

</p><table class="page">
<tbody><tr><td>
<pre>(EVAL
 (<span>QUOTE</span>
  (EVAL (<span>Q</span> (FF X))
        (<span>Q</span> ((FF ((X)
             ((<span>ATOM</span> X) X)
             (FF (<span>HEAD</span> X))))
            (X ((A) B C))))))
 (<span>QUOTE</span>
  ((NULL ((X)
    (<span>EQ</span> X ())))
   (LIST ((X Y)
    (<span>LINK</span> X (<span>LINK</span> Y ()))))
   (ASSOC ((X Y)
    ((NULL Y) (LIST (Q ?) X))
    ((<span>EQ</span> X (<span>HEAD</span> (<span>HEAD</span> Y)))
     (<span>HEAD</span> (<span>TAIL</span> (<span>HEAD</span> Y))))
    (ASSOC X (<span>TAIL</span> Y))))
   (EVLAM ((C A)
    ((NULL (<span>TAIL</span> C))
     (EVAL (<span>HEAD</span> C) A))
    ((EVAL (<span>HEAD</span> (<span>HEAD</span> C)) A)
     (EVLAM (<span>TAIL</span> (<span>HEAD</span> C)) A))
    (EVLAM (<span>TAIL</span> C) A)))
   (ZIP ((X Y A)
    ((NULL X) A)
    (<span>LINK</span> (LIST (<span>HEAD</span> X) (<span>HEAD</span> Y))
          (ZIP (<span>TAIL</span> X) (<span>TAIL</span> Y) A))))
   (EVLIS ((M A)
    ((NULL M) M)
    (<span>LINK</span> (EVAL (<span>HEAD</span> M) A)
          (EVLIS (<span>TAIL</span> M) A))))
   (APPLY ((FN X A)
    ((<span>ATOM</span> FN)
     ((<span>EQ</span> FN (<span>Q</span> <span>HEAD</span>)) (<span>HEAD</span> (<span>HEAD</span> X)))
     ((<span>EQ</span> FN (<span>Q</span> <span>TAIL</span>)) (<span>TAIL</span> (<span>HEAD</span> X)))
     ((<span>EQ</span> FN (<span>Q</span> <span>ATOM</span>)) (<span>ATOM</span> (<span>HEAD</span> X)))
     ((<span>EQ</span> FN (<span>Q</span> <span>LINK</span>))
      (<span>LINK</span> (<span>HEAD</span> X) (<span>HEAD</span> (<span>TAIL</span> X))))
     ((<span>EQ</span> FN (<span>Q</span> <span>EQ</span>))
      (<span>EQ</span> (<span>HEAD</span> X) (<span>HEAD</span> (<span>TAIL</span> X))))
     (APPLY (EVAL FN A) X A))
    (EVLAM (<span>TAIL</span> FN) (ZIP (<span>HEAD</span> FN) X A))))
   (EVAL ((E A)
    ((NULL E) E)
    ((<span>ATOM</span> E) (ASSOC E A))
    ((<span>ATOM</span> (<span>HEAD</span> E))
     ((<span>EQ</span> (<span>HEAD</span> E) (<span>Q</span> <span>Q</span>)) (<span>HEAD</span> (<span>TAIL</span> E)))
     (APPLY (<span>HEAD</span> E) (EVLIS (<span>TAIL</span> E) A) A))
    (APPLY (<span>HEAD</span> E) (EVLIS (<span>TAIL</span> E) A) A))))))
</pre>
</td><td>
<pre>(<span>DEFINE</span> ASSOC .
  (<span>LAMBDA</span> (X Y)
    (<span>COND</span> ((<span>EQ</span> X (<span>CAR</span> (<span>CAR</span> Y)))
           (<span>CAR</span> (<span>CDR</span> (<span>CAR</span> Y))))
          ((<span>QUOTE</span> T)
           (ASSOC X (<span>CDR</span> Y))))))

(<span>DEFINE</span> EVLIS .
  (<span>LAMBDA</span> (M A)
    (<span>COND</span> (M (<span>CONS</span> (EVAL (<span>CAR</span> M) A)
                   (EVLIS (<span>CDR</span> M) A)))
          ((<span>QUOTE</span> T) ()))))

(<span>DEFINE</span> EVLAM .
  (<span>LAMBDA</span> (C A)
    (<span>COND</span> ((<span>EQ</span> (<span>CDR</span> C) ())
           (EVAL (<span>CAR</span> C) A))
          ((EVAL (<span>CAR</span> (<span>CAR</span> C)) A)
           (EVLAM (<span>CDR</span> (<span>CAR</span> C)) A))
          ((<span>QUOTE</span> T)
           (EVLAM (<span>CDR</span> C) A)))))

(<span>DEFINE</span> ZIP .
  (<span>LAMBDA</span> (X Y A)
    (<span>COND</span> (X (<span>CONS</span> (<span>CONS</span> (<span>CAR</span> X) (<span>CONS</span> (<span>CAR</span> Y) ()))
                   (ZIP (<span>CDR</span> X) (<span>CDR</span> Y) A)))
          ((<span>QUOTE</span> T) A))))

(<span>DEFINE</span> APPLY .
  (<span>LAMBDA</span> (FN X A)
    (<span>COND</span>
      ((<span>ATOM</span> FN)
       (<span>COND</span> ((<span>EQ</span> FN (<span>QUOTE</span> HEAD))
              (<span>COND</span> ((<span>CAR</span> X) (<span>CAR</span> (<span>CAR</span> X))) (T ())))
             ((<span>EQ</span> FN (<span>QUOTE</span> TAIL))
              (<span>COND</span> ((<span>CAR</span> X) (<span>CDR</span> (<span>CAR</span> X))) (T ())))
             ((<span>EQ</span> FN (<span>QUOTE</span> <span>ATOM</span>))
              (<span>ATOM</span> (<span>CAR</span> X)))
             ((<span>EQ</span> FN (<span>QUOTE</span> LINK))
              (<span>CONS</span> (<span>CAR</span> X) (<span>CAR</span> (<span>CDR</span> X))))
             ((<span>EQ</span> FN (<span>QUOTE</span> <span>EQ</span>))
              (<span>EQ</span> (<span>CAR</span> X) (<span>CAR</span> (<span>CDR</span> X))))
             ((<span>QUOTE</span> T)
              (APPLY (EVAL FN A) X A))))
      ((<span>QUOTE</span> T)
       (EVLAM (<span>CDR</span> FN) (ZIP (<span>CAR</span> FN) X A))))))

(<span>DEFINE</span> EVAL .
  (<span>LAMBDA</span> (E A)
    (<span>COND</span> ((<span>EQ</span> E ()) ())
          ((<span>ATOM</span> E) (ASSOC E A))
          ((<span>ATOM</span> (<span>CAR</span> E))
           (<span>COND</span> ((<span>EQ</span> (<span>CAR</span> E) (<span>QUOTE</span> Q)) (<span>CAR</span> (<span>CDR</span> E)))
                 ((<span>QUOTE</span> T)
                  (APPLY (<span>CAR</span> E) (EVLIS (<span>CDR</span> E) A) A))))
          ((<span>QUOTE</span> T)
           (APPLY (<span>CAR</span> E) (EVLIS (<span>CDR</span> E) A) A)))))
</pre>
</td></tr></tbody></table>

<p>
The code above is a LISP within a LISP within a LISP: three levels. You
can use this technique to implement missing features like macros. It
also becomes clear that LISP is a king of kings among programming
languages, since if a language can succinctly implement itself, then it
can also let you easily build any other domain-specific language too (so
long as they also use parenthesis notation). One such DSL we could build
is for a Turing machine, which in this case has been configured to
compute <code>popcount(r) % 2 == 1</code>.

</p><pre>(<span>DEFINE</span> SCANNED-SYMBOL  . 0)
(<span>DEFINE</span> LEFT-HAND-TAPE  . (1 0 1 B B))
(<span>DEFINE</span> RIGHT-HAND-TAPE . (1 1 0 B))  <span>;; we&#39;re computing parity of 0b011</span>
(TURING (<span>QUOTE</span> (0 B (0 0 B R 0)   <span>;; if (state==0 &amp;&amp; input==0) print(B), move(Right), state=0</span>
                    (0 1 B R 1)   <span>;; if (state==0 &amp;&amp; input==1) print(B), move(Right), state=1</span>
                    (0 B 0 R 2)   <span>;; if (state==0 &amp;&amp; input==B) print(0), move(Right), state=2</span>
                    (1 0 B R 1)   <span>;; if (state==1 &amp;&amp; input==0) print(B), move(Right), state=1</span>
                    (1 1 B R 0)   <span>;; if (state==1 &amp;&amp; input==1) print(B), move(Right), state=0</span>
                    (1 B 1 R 2))) <span>;; if (state==1 &amp;&amp; input==B) print(1), move(Right), state=2</span>
        (LIST-3 SCANNED-SYMBOL
                LEFT-HAND-TAPE
                RIGHT-HAND-TAPE))
</pre>

<p>
You can view the full Turing machine example by clicking the simulator&#39;s
Load button above. For further details on how the DSL is defined, please
see <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/aimemo8.txt">AI Memo No. 8</a>.

<!-- <h2 class="page" id="comparisons"><a class="anchor" href="#comparisons">Comparisons</a></h2> -->

<!-- <p> -->
<!-- LISP and Scheme were both designed with the explicit stated goal of -->
<!-- being simple. Let's perform a first impression simplicity analysis, from -->
<!-- a systems perspective, of SectorLISP versus the modern flagship -->
<!-- implementations. -->

<!-- <p> -->
<!-- Racket v7.2 (PLT Scheme) has a binary footprint of 8.5 -->
<!-- megabytes<sup><a href="#footnote8">8</a></sup> (the install size is ~500 -->
<!-- megs) and it takes 450,510µs wall time to run a <code>(quote -->
<!-- hello-world)</code> program. While doing so, Racket needs 76,520 -->
<!-- kibibytes of peak resident memory<sup><a href="#footnote9">9</a></sup>. -->
<!-- It's likely the poor startup time is due to electric fence style memory -->
<!-- management because Racket hello world segfaults 1,585 -->
<!-- times<sup><a href="#footnote10">10</a></sup> which might be something -->
<!-- that amortizes into an advantage over a longer time interval. Racket -->
<!-- requires glibc 2.14+ i.e. RHEL6+ c. 2011 which probably puts it in the -->
<!-- top 1% of Linux binary portability, although its release binaries will -->
<!-- not run on many distros such as Alpine. Racket requires that different -->
<!-- binaries be downloaded in order to run on different operating systems. -->

<!-- <p> -->
<!-- Steel Bank Common LISP v2.1.11 has a larger binary footprint of 38 -->
<!-- megabytes (the install size is ~40 megs) and it takes 25,620µs to run -->
<!-- hello world while consuming 21,640 kibibytes of peak resident -->
<!-- memory<sup><a href="#footnote11">11</a></sup> since it neatly packs -->
<!-- assets and makes impressive use of virtual memory. SBCL requires glibc -->
<!-- 2.28+ i.e. RHEL8+ c. 2019 and their release binaries will not run on -->
<!-- Linux distros such as Alpine. SBCL requires that different binaries be -->
<!-- downloaded in order to run on different operating systems. -->

<!-- <p> -->
<!-- SectorLISP v2 on Linux has a binary footprint of 20 kilobytes (the -->
<!-- install size is 20kb). It takes 620µs wall time to run hello world, -->
<!-- consuming 104 kibibytes of peak resident memory. The lisp.com release -->
<!-- binary requires Linux 2.6.18+ e.g. RHEL5+ c. 2007, or Windows Vista+ c. -->
<!-- 2006, or Apple XNU 15.6+ c. 2018, or FreeBSD 12+ c. 2018+, or OpenBSD -->
<!-- 6.4+ c. 2018, or NetBSD 9.1+ c. 2020, or Personal Computer BIOS c. -->
<!-- 2006+. -->

<!-- <p> -->
<!-- These numbers were measured on a 3ghz 24-core AMD Ryzen Threadripper -->
<!-- machine with SSDs inside a Debian 10 VM due to SBCL and Racket having a -->
<!-- glibc requirement. -->

<!-- <p> -->
<!-- The canonical sectorlisp.bin boot sector has a binary footprint of 436 -->
<!-- bytes (install size is 436 bytes or 512 bytes depending on the PC -->
<!-- model). It takes 628µs to run hello world on a 4.77mhz i8086 CPU because -->
<!-- it executes 2,165 instructions which if adjusted for -->
<!-- the <code>rep</code> prefixed ones should place cycles in the ballpark -->
<!-- of ~3,000. It requires Personal Computer BIOS c. 1981+. -->

</p><h2 class="page" id="polyglots"><a href="#polyglots">Polyglots</a></h2>

<p>
While knowledge of the technique existed, no one&#39;s published software
before that polyglots C and JavaScript, so it&#39;s worth going into further
detail on how that works. Language polyglots are similar in spirit to
how a lady or gentleman might choose a communications style that focuses
on a subset of rhetoric all groups feel comfortable hearing. The code
examples in this blog post operate by that same principle, since they&#39;re
designed to run in the most popular programming environments. It&#39;s the
same technique that was used for <a href="https://thewitchofendor.com/2021/12/18/ape.html">Actually Portable
Executable</a> which lets us build binaries that run on seven operating
systems.

</p><p>
There&#39;s nothing extraordinary about having a coding style that focuses
on what different programmers share in common. It&#39;s the initial process
of determining what that software consensus is that&#39;s difficult, since
it requires one to not only understand of the requirements of modern
systems, but also undergo an archaeological voyage reading tomes of
legacy code like a librarian in order to understand their phylogenesis.
The results end up being very easy:

</p><pre><span>// plain simple executable code that</span>
<span>// helps c / js communities use lisp</span>
<span>function</span> Apply(f, x, a) {
  <span>if</span> (f &lt; 0)      <span>return</span> Eval(Car(Cdr(Cdr(f))), Pairlis(Car(Cdr(f)), x, a));
  <span>if</span> (f == kEq)   <span>return</span> Car(x) == Car(Cdr(x));
  <span>if</span> (f == kCons) <span>return</span> Cons(Car(x), Car(Cdr(x)));
  <span>if</span> (f == kAtom) <span>return</span> Car(x) &gt;= 0;
  <span>if</span> (f == kCar)  <span>return</span> Car(Car(x));
  <span>if</span> (f == kCdr)  <span>return</span> Cdr(Car(x));
  <span>return</span> Apply(Assoc(f, a), x, a);
}
</pre>

<p>
But not every line of code can be made a good citizen of multiple
languages. We need workarounds for code that&#39;s platform specific.
Ulysses (the person the LISP 1.5 source code quoted earlier) is most
famous for his Trojan Horse trick that let Greece defeat Troy. His guile
inspired another recent paper called
<a href="https://trojansource.codes/">Trojan Source</a>. The trick
SectorLISP uses which is similar in spirit (but not intent) is the
PARAGRAPH SEPARATOR (u2029) which
<a href="https://262.ecma-international.org/12.0/#sec-line-terminators">ECMA-262
2021 §12.3</a> defines as a line terminator, whereas ANSI C and nearly
everything else does not.

</p><pre><p>javascript syntax highlighting</p><span>//¶</span><span>`
<em>... C only code goes here ...</em>
//`</span>
</pre>

<p>
It works by sneaking multiline JavaScript strings into C comments, to
serve as a cross-language <code>#ifdef</code> statement. That lets us
ask JavaScript to ignore small portions of code that are only meant for
C compilers. If we wish to ask C to ignore code that&#39;s intended only for
JavaScript, then the technique can be used as follows:

</p><pre><p>c syntax highlighting</p><span>//¶`</span>
<span>#if</span> 0
<span>//`</span>
<em>... JavaScript only code goes here ...</em>
<span>//¶`</span>
<span>#endif</span>
<span>//`</span>
</pre>

<p>
It should be a requirement for C projects that call themselves portable.
Codebases like Zlib / InfoZIP use a notorious number
of <code>#ifdef</code> statements to bring the benefits of support for
the DEFLATE algorithm to platforms like VAX, QDOS, Amiga, IBM
System/360, and possibly even those IBM Series/1 minicomputers. If we go
to great lengths using ifdefs to maintain rare platforms, then why
shouldn&#39;t we use polyglot ifdefs to support the most popular platform
too? There&#39;s wisdom in a LISP that&#39;s fits on floppy disks if we consider
that a U.S. nuclear weapons agency got hacked immediately after they
stopped using them<sup><a href="#footnote6">6</a></sup>. They should
have considered LISP instead since it has all the qualities of the old
technologies while continuing to be ahead of its time, even after all
these years.

</p><p>
Please note the PARAGRAPH SEPARATOR (u2029) is normally invisible so
it&#39;s been typeset above as PILCROW SIGN (u00b6). Since creative uses of
technology have a tendency to reveal bugs, it should be noted that,
thanks to the limitless configurability of LISP, you&#39;ll always have a
safer space for programming since you can tune your Emacs editor as
follows:

</p><pre>(<span>or</span> standard-display-table
    (<span>setq</span> standard-display-table
          (make-display-table)))
(<span>aset</span> standard-display-table #x2028 [?↵]) <span>;; LINE SEPARATOR</span>
(<span>aset</span> standard-display-table #x2029 [?¶]) <span>;; PARAGRAPH SEPARATOR</span>
(<span>aset</span> standard-display-table #x202A [?⟫]) <span>;; LEFT-TO-RIGHT EMBEDDING</span>
(<span>aset</span> standard-display-table #x202B [?⟪]) <span>;; RIGHT-TO-LEFT EMBEDDING</span>
(<span>aset</span> standard-display-table #x202D [?❯]) <span>;; LEFT-TO-RIGHT OVERRIDE</span>
(<span>aset</span> standard-display-table #x202E [?❮]) <span>;; RIGHT-TO-LEFT OVERRIDE</span>
(<span>aset</span> standard-display-table #x2066 [?⟩]) <span>;; LEFT-TO-RIGHT ISOLATE</span>
(<span>aset</span> standard-display-table #x2067 [?⟨]) <span>;; RIGHT-TO-LEFT ISOLATE</span>
(<span>aset</span> standard-display-table #x2068 [?⧽]) <span>;; FIRST STRONG ISOLATE</span>
(<span>aset</span> standard-display-table #x202C [?⇮]) <span>;; POP DIRECTIONAL FORMATTING</span>
(<span>aset</span> standard-display-table #x2069 [?⇯]) <span>;; POP DIRECTIONAL ISOLATE</span>
</pre>

<h2 class="page" id="alternatives"><a href="#alternatives">Alternatives</a></h2>

<p>
SectorLISP is non-revisionist because if we&#39;d gone down the path of
changing the definition of LISP, then it&#39;d&#39;ve taken us to a place where
lists become tape and then you&#39;ve got an ASCII Turing machine like
Brainfuck, which can be implemented with only
<a href="https://github.com/jart/sectorlisp/blob/friendly/brainfuck.S">99
bytes</a>. It may be capable of computing everything that&#39;s computable,
but can we really call gibberish a programming language?

</p><pre><span>Hello World in Brainf*#k</span>
++++++++[&gt;++++
 [&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]
 &gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]
&gt;&gt;.        &gt;---.   +++++++..
+++.       &gt;&gt;.     &lt;-.
&lt;.         +++.    ------.
--------.  &gt;&gt;+.    &gt;++.
</pre>

<p>
If that were the goal, we&#39;d be better served by simply not having an
abstraction layer at all. For example, it&#39;s possible in 23 bytes to have
a universal language on x86 simply by exposing the x86 machine language.
If you compile the program below and load it into Blinkenlights then you
can copy and paste the gibberish string for Hello World and it&#39;ll print
&#34;hello world&#34;. If you can chord then you can type the binary into your
IBM PC with the Model F keyboard too.

</p><table>
<tbody><tr><td>
<pre><span>/	twenty three byte loader</span>
<span>_start</span>:	<span>ljmp</span>	<span>$0x600&gt;&gt;4</span>,<span>$_begin</span>
<span>_begin</span>:	<span>push</span>	<span>%cs</span>
	<span>pop</span>	<span>%ds</span>
	<span>push</span>	<span>%cs</span>
	<span>pop</span>	<span>%es</span>
<span>0</span>:	<span>call</span>	1<span>f</span>
<span>1</span>:	<span>push</span>	<span>%di</span>
<span>2</span>:	<span>xor</span>	<span>%ax</span>,<span>%ax</span>
	<span>int</span>	<span>$0x16</span>
	<span>stosb</span>
	<span>cmp</span>	<span>$206</span>,<span>%al</span>
	<span>jne</span>	2<span>b</span>
	<span>ret</span>
</pre>
</td><td>
<pre><span>/	example program with loader</span>
<span>/	put string in blinkenlights</span>
<span>/	j♪^┤♫¼═►&lt;◙u∙├hello world♪◙╬</span>
	<span>push</span>	<span>$13</span>
	<span>pop</span>	<span>%si</span>
	<span>mov</span>	<span>$0x0e</span>,%ah
<span>0</span>:	<span>lodsb</span>
	<span>int</span>	<span>$0x10</span>
	<span>cmp</span>	<span>$10</span>,<span>%al</span>
	<span>jnz</span>	0<span>b</span>
	<span>ret</span>
	<span>.ascii</span>	<span>&#34;hello world\r\n&#34;</span>
	<span>into</span>
</pre>
</td></tr></tbody></table>

<p>
Languages like Brainfuck were known in JMC&#39;s time, but it was the human
quality of his research that made LISP so attractive. Universal
languages are common enough that one of the biggest challenges in
securing protocols and file formats is demonstrating that they&#39;re not
accidentally a Turing machine. For example, the UNICODE stack machine
characters above flirt dangerously close with Turing&#39;s thesis. Even
Conway&#39;s <a href="https://thewitchofendor.com/2021/12/18/apelife/">Game of Life</a> was proven to be Turing
complete. On the other hand, LISP is a tool that people want to use.
It&#39;s always commanded respect and some companies have built veritable
empires using it. That&#39;s why it&#39;s such a great find that, thanks to the
simplicity and generality of its original formulas, we were able to
implement LISP in nearly the same number of bytes as Brainfuck.

</p><p>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/tneary_Thesis.pdf"><img src="https://storage.googleapis.com/justine/sectorlisp2/tinyturing.png" width="563" height="482" alt="[Curve of tiniest Turing machines based on x states and y symbols]"/></a>

</p><p>
It might be possible to create something even smaller than Brainfuck.
Computer science provides some clues as to what the tiniest esoteric
boot sector language might be. For example, Marvin Minsky discovered a
7-state 4-symbol universal Turing machine in 1962. The chart above is
from Turlough Neary&#39;s PhD thesis which shows a tradeoff between
minimizing symbols and states. If we could find some way to get the
rules for one of these tiny Turing machines to neatly map onto a bitwise
arithmetic hack, similar to the <code>(B11 | r0) &amp; r1 &amp;
~r2</code> <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/LifeInTheFastLane.pdf">trick</a> that Browne and
Tavener discovered for Conway&#39;s Game of Life, like a NAND gate, then we
might create an esoteric boot sector language so tiny in scale and
austere in its definition that its parsimoniousness would never be
challenged.

</p><h2 class="page" id="why"><a href="#why">Why It Matters</a></h2>

<table>
  <tbody><tr>
    <td>
      <blockquote>
        <p>
          Simplicity is the sign of truth.
        </p><p>
          —
          Herman Boerhaave
      </p></blockquote>
    </td><td>
      <blockquote>
        <p>
          <span lang="la" aria-label="SIMPLEX SIGILLUM VERI">SIMPLEX SIGILLVM VERI</span>
      </p></blockquote>
</td></tr></tbody></table>

<p>
Tiny code contests have historically focused on the source code. What
makes that problematic is how it incentivizes obfuscation. On the other
hand, optimizing for binary size usually results in the source code
becoming more elegant. In order to make program files tinier, one must
choose data structures and design patterns that are harmonious with the
way computers work. Doing that requires us to better understand the
nature of the problem.

</p><p>
Is it better to help maintain the largest piece of software in the world
when you can create the tiniest one instead? There&#39;s more combinations
in a 512-byte boot sector than there are Go games. The fact that people
are still publicly developing new boot sector programs for a forty year
old computer should speak for itself. Demoscene is a relative newcomer
compared to Go and Chess, but it could potentially be a more enjoyable
competitive mind sport since Kolmogorov complexity is AI-hard.

</p><p>
While code golfing is fun, the goal of any technology is to help us
better understand nature and to improve upon the human condition. The
way tinier software conventionally does this is by letting us have more
instances of it at scale. The same is true of nature where the tiniest
creatures are the most predominant. They&#39;re called phages and there&#39;s
10,000,000,000,000,000,000,000,000,000,000 of these guys on earth. The
tiniest phage in the world that&#39;s listed in the European Nucleotide
Archive goes by the name Leuconostoc Phage L5 and it has a complete
genome size of 631 bytes. So by the standards of our game, we could say
that LISP has now outdistanced nature too. This of course isn&#39;t meant to
imply that smaller is necessarily better. For example, ring tailed
lemurs have a binary footprint of 537
megs<sup><a href="#footnote12">12</a></sup> similar to Racket&#39;s 500mb
install size. They&#39;re both quite adorable, but certainly not simple.

</p><pre>&gt; L06183: Leuconostoc Phage L5 complete genome cp437 le-bin acgt
Z6♫τ♫▼≡2É&lt;ÅΣ&lt; 2âÖ⌂δ╧δ♦♫ü◘&amp;☼G~C ≥♥Fî` ÉO²æ⌡f1▬←°ⁿ&lt;7¿√•▼╠♫&amp;μ»↕_░»≡
ä ╗≤↔?☼@v¿ ○☻ r┤ⁿ░≥▼.λ┐¢ⁿ∩&amp;╗↓≡╗╔λo■ⁿ÷∩o╛■Bj♂X»ô┤∙â☺☺`7s╨ƒ•3b♪l§►
→ü♫╓╠‼μ▀X√╛←╝∩♠&lt;┐∩⌂≡≈λc±∩≡£ ‼²∙²•o♥|╧φ/C▀╟♪;╛♥⌂λ╟♀♀═tλî;/┴D4α╬╝3
⌂╚$á┬╠á▒☼ °└,╚å‼A λ├≥τ` ╩╕û├↨F♦○B$34l?└┘‼LÇy♣(Mⁿây┐╧♂↕╝C2NKÇαá╞⌂
╦┴♥?│├Çä☼├Ç£ ån&lt;0⌡╧∙╦■║♀╙Ç|&lt;é╜3☼Ü&gt;♀pé²76+┘▓╧≈▬“∩∩A│3 6 NO║oƒ&lt;n@~
╕┐M)@&gt; 8e☼∙ò£ê≤├♥▒♫╠◙l⌂F╛≥┤λ♦░⌂λ▬╛▲☼↑ ↨♀═‘/≡♠ñ•¶╒λ≈↨╪/Ç√ô♀├ ♂≤∩∟
0N╚ñ ♂αCé╘#┘ú»⌠♫0•♀[9=¢2╬☻♦ï▼δ£ä6 ¼±¡÷n↑♦ìp(ⁿMX≤æ°∩¬á┴╧&lt;+☼↓&lt;ç÷O╦
{ÅƒÄ=•â┬∟¼╨╠╠▀ôⁿ≤╖┴=≡∩▼l♥►5♂t%/█∩o╝4┼↨ç≡•ε·H&lt;∩╦♀ε«╣╠■ëO♥Ä¼¡═•│m♂
ÉN&lt;  G≡23â≈⌠├°6∩²┌?│α·α&gt;┘°▲L±@=7░íⁿ0▀╨≤C2&gt;√?▼█≥┴♂♥?ó├?`♀ êyC┴â▬Æ
²├╧╧╧╧ƒ¢║a╦♂a┌@c∩÷A‼╓┐╪╢L←ç╝╪┐π¢▬
</pre>

<p>
John McCarthy may have lost out on the opportunity to be the father of
the personal computing software revolution, but there&#39;s still a chance
for his ideas to lead the second. The tools for natural engineering
became cheap and open source in recent years. Many people are scrambling
to be the next Monsanto, but what we actually want is the next Linux,
Apple, and Microsoft. We need a tool that can abstract genetics and
proteins in the smallest way possible, similar to how SectorLISP
currently offers the service of abstracting gritty assembly in the
fewest commands. For example one might edit a tiny symbiotic bacteria
like Candidatus Carsonella Ruddii (40,000 bytes) to be a platform for
running LISP programs that would be delivered by printed phages. In
fact, someone might have even figured it out already. It&#39;s been public
knowledge for fifty years people can build recombinant organisms, like
the gap between iPhone and SIGSALY. Crispr can be programmed in XML. If
it can be done with LISP instead then we must use it.

</p><h2 class="page" id="listing"><a class="anchor" href="#listing">Listing</a></h2>

<p>
  Here&#39;s the full i8086 assembly listing for SectorLISP v2.<!-- <p> -->
<!--   <iframe src="sectorlisp.lst.html" -->
<!--           title="GAS Listing for SectorLISP"></iframe> -->
</p><pre class="page"><strong>GAS LISTING sectorlisp.S 			page 1</strong>


 GNU assembler version 2.34 (x86_64-alpine-linux-musl)
	 using BFD version (GNU Binutils) 2.34.
 options passed	: -aghlms=sectorlisp.lst -g 
 input file    	: sectorlisp.S
 output file   	: sectorlisp.o
 target        	: x86_64-alpine-linux-musl
 time stamp    	: 2021-12-11T00:49:38.000-0800

<p><strong>GAS LISTING sectorlisp.S 			page 2</strong></p>


<span>   1</span>              	<span>/*-*- mode:unix-assembly; indent-tabs-mode:t; tab-width:8; coding:utf-8     -*-│</span>
<span>   2</span>              	<span>│vi: set et ft=asm ts=8 tw=8 fenc=utf-8                                     :vi│</span>
<span>   3</span>              	<span>╞══════════════════════════════════════════════════════════════════════════════╡</span>
<span>   4</span>              	<span>│ Copyright 2020 Justine Alexandra Roberts Tunney                              │</span>
<span>   5</span>              	<span>│ Copyright 2021 Alain Greppin                                                 │</span>
<span>   6</span>              	<span>│ Some size optimisations by Peter Ferrie                                      │</span>
<span>   6</span>              	<span>│                                                                              │</span>
<span>   7</span>              	<span>│ Permission to use, copy, modify, and/or distribute this software for         │</span>
<span>   8</span>              	<span>│ any purpose with or without fee is hereby granted, provided that the         │</span>
<span>   9</span>              	<span>│ above copyright notice and this permission notice appear in all copies.      │</span>
<span>  10</span>              	<span>│                                                                              │</span>
<span>  11</span>              	<span>│ THE SOFTWARE IS PROVIDED &#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL                │</span>
<span>  12</span>              	<span>│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │</span>
<span>  13</span>              	<span>│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │</span>
<span>  14</span>              	<span>│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │</span>
<span>  15</span>              	<span>│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │</span>
<span>  16</span>              	<span>│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │</span>
<span>  17</span>              	<span>│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │</span>
<span>  18</span>              	<span>│ PERFORMANCE OF THIS SOFTWARE.                                                │</span>
<span>  19</span>              	<span>╚─────────────────────────────────────────────────────────────────────────────*/</span>
<span>  21</span>              	
<span>  22</span>              	<span>// LISP meta-circular evaluator in a MBR</span>
<span>  23</span>              	<span>// Compatible with the original hardware</span>
<span>  24</span>              	
<span>  25</span>              		<span>.code16</span>
<span>  26</span>              		<span>.globl</span>	_start
<span>  27</span> 0000 4E494C00 	<span>_start</span>:	<span>.asciz</span>	<span>&#34;NIL&#34;</span>				<span># dec %si ; dec %cx ; dec %sp</span>
<span>  28</span> 0004 5400     	<span>kT</span>:	<span>.asciz</span>	<span>&#34;T&#34;</span>				<span># add %dl,(%si) boot A:\ DL=0</span>
<span>  29</span> 0006 EA0000C0 	<span>start</span>:	<span>ljmp</span>	<span>$0x7c00&gt;&gt;4</span>,<span>$begin</span>		<span># cs = 0x7c00 is boot address</span>
<span>  29</span>      07
<span>  30</span> 000b 00       		<span>.asciz</span>	<span>&#34;&#34;</span>
<span>  31</span> 000c 51554F54 	<span>kQuote</span>:	<span>.asciz</span>	<span>&#34;QUOTE&#34;</span>
<span>  31</span>      4500
<span>  32</span> 0012 434F4E44 	<span>kCond</span>:	<span>.asciz</span>	<span>&#34;COND&#34;</span>
<span>  32</span>      00
<span>  33</span> 0017 41544F4D 	<span>kAtom</span>:	<span>.asciz</span>	<span>&#34;ATOM&#34;</span>				<span># ordering matters</span>
<span>  33</span>      00
<span>  34</span> 001c 43415200 	<span>kCar</span>:	<span>.asciz</span>	<span>&#34;CAR&#34;</span>				<span># ordering matters</span>
<span>  35</span> 0020 43445200 	<span>kCdr</span>:	<span>.asciz</span>	<span>&#34;CDR&#34;</span>				<span># ordering matters</span>
<span>  36</span> 0024 434F4E53 	<span>kCons</span>:	<span>.asciz</span>	<span>&#34;CONS&#34;</span>				<span># ordering matters</span>
<span>  36</span>      00
<span>  37</span> 0029 455100   	<span>kEq</span>:	<span>.asciz</span>	<span>&#34;EQ&#34;</span>				<span># needs to be last</span>
<span>  38</span>              	
<span>  39</span> 002c BC0080   	<span>begin</span>:	<span>mov</span>	<span>$0x8000</span>,<span>%sp</span>			<span># uses higher address as stack</span>
<span>  40</span>              							<span># and set independently of SS!</span>
<span>  41</span>              							<span># 8088 doesn&#39;t stop interrupts</span>
<span>  42</span>              							<span># after SS is set, and PC BIOS</span>
<span>  43</span>              							<span># sets SP to a value that will</span>
<span>  44</span>              							<span># damage our code if int fires</span>
<span>  45</span>              							<span># between it setting SS and SP</span>
<span>  46</span> 002f 0E       		<span>push</span>	<span>%cs</span>				<span># that means ss = ds = es = cs</span>
<span>  47</span> 0030 1F       		<span>pop</span>	<span>%ds</span>				<span># noting ljmp set cs to 0x7c00</span>
<span>  48</span> 0031 0E       		<span>push</span>	<span>%cs</span>				<span># that&#39;s the bios load address</span>
<span>  49</span> 0032 07       		<span>pop</span>	<span>%es</span>				<span># therefore NULL points to NUL</span>
<span>  50</span> 0033 0E       		<span>push</span>	<span>%cs</span>				<span># terminated NIL string above!</span>
<span>  51</span> 0034 17       		<span>pop</span>	<span>%ss</span>				<span># errata exists but don&#39;t care</span>
<span>  52</span> 0035 BB0200   		<span>mov</span>	<span>$2</span>,<span>%bx</span>
<p><strong>GAS LISTING sectorlisp.S 			page 3</strong></p>


<span>  53</span> 0038 89E1     	<span>main</span>:	<span>mov</span>	<span>%sp</span>,<span>%cx</span>
<span>  54</span> 003a E81100   		<span>call</span>	GetToken
<span>  55</span> 003d E85400   		<span>call</span>	GetObject
<span>  56</span> 0040 E84101   		<span>call</span>	Eval
<span>  57</span> 0043 96       		<span>xchg</span>	<span>%ax</span>,<span>%si</span>
<span>  58</span> 0044 E84300   		<span>call</span>	PrintObject
<span>  59</span> 0047 B00D     		<span>mov</span>	<span>$&#39;\r&#39;</span>,<span>%al</span>
<span>  60</span> 0049 E87200   		<span>call</span>	PutChar
<span>  61</span> 004c EBEA     		<span>jmp</span>	main
<span>  62</span>              	
<span>  63</span>              	<span>GetToken</span>:					<span># GetToken():al, dl is g_look</span>
<span>  64</span> 004e 89CF     		<span>mov</span>	<span>%cx</span>,<span>%di</span>
<span>  65</span> 0050 88D0     	<span>1</span>:	<span>mov</span>	<span>%dl</span>,<span>%al</span>
<span>  66</span> 0052 3C20     		<span>cmp</span>	<span>$&#39; &#39;</span>,<span>%al</span>
<span>  67</span> 0054 7602     		<span>jbe</span>	2f
<span>  68</span> 0056 AA       		<span>stosb</span>
<span>  69</span> 0057 96       		<span>xchg</span>	<span>%ax</span>,<span>%si</span>
<span>  70</span> 0058 E85F00   	<span>2</span>:	<span>call</span>	GetChar				<span># exchanges dx and ax</span>
<span>  71</span> 005b 3C20     		<span>cmp</span>	<span>$&#39; &#39;</span>,<span>%al</span>
<span>  72</span> 005d 76F1     		<span>jbe</span>	1b
<span>  73</span> 005f 3C29     		<span>cmp</span>	<span>$&#39;)&#39;</span>,<span>%al</span>
<span>  74</span> 0061 7605     		<span>jbe</span>	3f
<span>  75</span> 0063 80FA29   		<span>cmp</span>	<span>$&#39;)&#39;</span>,<span>%dl</span>			<span># dl = g_look</span>
<span>  76</span> 0066 77E8     		<span>ja</span>	1b
<span>  77</span> 0068 883D     	<span>3</span>:	<span>mov</span>	<span>%bh</span>,(<span>%di</span>)			<span># bh is zero</span>
<span>  78</span> 006a 96       		<span>xchg</span>	<span>%si</span>,<span>%ax</span>
<span>  79</span> 006b C3       		<span>ret</span>
<span>  80</span>              	
<span>  81</span>              	<span>.PrintList</span>:
<span>  82</span> 006c B028     		<span>mov</span>	<span>$&#39;(&#39;</span>,<span>%al</span>
<span>  83</span> 006e FF30     	<span>2</span>:	<span>push</span>	(<span>%bx</span>,<span>%si</span>)
<span>  84</span> 0070 8B34     		<span>mov</span>	(<span>%si</span>),<span>%si</span>
<span>  85</span> 0072 E81200   		<span>call</span>	.PutObject
<span>  86</span> 0075 B020     		<span>mov</span>	<span>$&#39; &#39;</span>,<span>%al</span>
<span>  87</span> 0077 5E       		<span>pop</span>	<span>%si</span>				<span># restore 1</span>
<span>  88</span> 0078 85F6     		<span>test</span>	<span>%si</span>,<span>%si</span>
<span>  89</span> 007a 78F2     		<span>js</span>	2b				<span># jump if cons</span>
<span>  90</span> 007c 7405     		<span>jz</span>	4f				<span># jump if nil</span>
<span>  91</span> 007e B0F9     		<span>mov</span>	<span>$249</span>,<span>%al</span>			<span># bullet (A∙B)</span>
<span>  92</span> 0080 E80400   		<span>call</span>	.PutObject
<span>  93</span> 0083 B029     	<span>4</span>:	<span>mov</span>	<span>$&#39;)&#39;</span>,<span>%al</span>
<span>  94</span> 0085 EB37     		<span>jmp</span>	PutChar
<span>  95</span>              	
<span>  96</span>              	<span>.PutObject</span>:					<span># .PutObject(c:al,x:si)</span>
<span>  97</span>              	<span>.PrintString</span>:					<span># nul-terminated in si</span>
<span>  98</span> 0087 E83400   		<span>call</span>	PutChar				<span># preserves si</span>
<span>  99</span>              	<span>PrintObject</span>:					<span># PrintObject(x:si)</span>
<span> 100</span> 008a 85F6     		<span>test</span>	<span>%si</span>,<span>%si</span>				<span># set sf=1 if cons</span>
<span> 101</span> 008c 78DE     		<span>js</span>	.PrintList			<span># jump if not cons</span>
<span> 102</span>              	<span>.PrintAtom</span>:
<span> 103</span> 008e AC       		<span>lodsb</span>
<span> 104</span> 008f 84C0     		<span>test</span>	<span>%al</span>,<span>%al</span>				<span># test for nul terminator</span>
<span> 105</span> 0091 75F4     		<span>jnz</span>	.PrintString			<span># -&gt; ret</span>
<span> 106</span> 0093 C3       		<span>ret</span>
<span> 107</span>              	
<span> 108</span>              	<span>GetObject</span>:					<span># called just after GetToken</span>
<span> 109</span> 0094 3C28     		<span>cmp</span>	<span>$&#39;(&#39;</span>,<span>%al</span>
<p><strong>GAS LISTING sectorlisp.S 			page 4</strong></p>


<span> 110</span> 0096 7450     		<span>je</span>	GetList
<span> 111</span>              	<span>#	jmp	Intern</span>
<span> 112</span>              	
<span> 113</span> 0098 51       	<span>Intern</span>:	<span>push</span>	<span>%cx</span>				<span># Intern(cx,di): ax</span>
<span> 114</span> 0099 89FD     		<span>mov</span>	<span>%di</span>,<span>%bp</span>
<span> 115</span> 009b 29CD     		<span>sub</span>	<span>%cx</span>,<span>%bp</span>
<span> 116</span> 009d 45       		<span>inc</span>	<span>%bp</span>
<span> 117</span> 009e 31FF     		<span>xor</span>	<span>%di</span>,<span>%di</span>
<span> 118</span> 00a0 5E       	<span>1</span>:	<span>pop</span>	<span>%si</span>
<span> 119</span> 00a1 56       		<span>push</span>	<span>%si</span>
<span> 120</span> 00a2 89E9     		<span>mov</span>	<span>%bp</span>,<span>%cx</span>
<span> 121</span> 00a4 89F8     		<span>mov</span>	<span>%di</span>,<span>%ax</span>
<span> 122</span> 00a6 383D     		<span>cmp</span>	<span>%bh</span>,(<span>%di</span>)
<span> 123</span> 00a8 740C     		<span>je</span>	8f
<span> 124</span> 00aa F3A6     		<span>rep cmpsb</span>				<span># memcmp(di,si,cx)</span>
<span> 125</span> 00ac 740A     		<span>je</span>	9f
<span> 126</span> 00ae 4F       		<span>dec</span>	<span>%di</span>
<span> 127</span> 00af 31C0     		<span>xor</span>	<span>%ax</span>,<span>%ax</span>
<span> 128</span> 00b1 AE       	<span>2</span>:	<span>scasb</span>					<span># memchr(di,al,cx)</span>
<span> 129</span> 00b2 75FD     		<span>jne</span>	2b
<span> 130</span> 00b4 EBEA     		<span>jmp</span>	1b
<span> 131</span> 00b6 F3A4     	<span>8</span>:	<span>rep movsb</span>				<span># memcpy(di,si,cx)</span>
<span> 132</span> 00b8 59       	<span>9</span>:	<span>pop</span>	<span>%cx</span>
<span> 133</span> 00b9 C3       		<span>ret</span>
<span> 134</span>              	
<span> 135</span> 00ba 31C0     	<span>GetChar</span>:<span>xor</span>	<span>%ax</span>,<span>%ax</span>				<span># GetChar→al:dl</span>
<span> 136</span> 00bc CD16     		<span>int</span>	<span>$0x16</span>				<span># get keystroke</span>
<span> 137</span> 00be B40E     	<span>PutChar</span>:<span>mov</span>	<span>$0x0e</span>,<span>%ah</span>			<span># prints CP-437</span>
<span> 138</span> 00c0 CD10     		<span>int</span>	<span>$0x10</span>				<span># vidya service</span>
<span> 139</span> 00c2 3C0D     		<span>cmp</span>	<span>$&#39;\r&#39;</span>,<span>%al</span>			<span># don&#39;t clobber</span>
<span> 140</span> 00c4 7504     		<span>jne</span>	1f				<span># look xchg ret</span>
<span> 141</span> 00c6 B00A     		<span>mov</span>	<span>$&#39;\n&#39;</span>,<span>%al</span>
<span> 142</span> 00c8 EBF4     		<span>jmp</span>	PutChar
<span> 143</span> 00ca 92       	<span>1</span>:	<span>xchg</span>	<span>%dx</span>,<span>%ax</span>
<span> 144</span> 00cb C3       		<span>ret</span>
<span> 145</span>              	
<span> 146</span>              	<span>////////////////////////////////////////////////////////////////////////////////</span>
<span> 147</span>              	
<span> 148</span> 00cc 85FF     	<span>Evlis</span>:	<span>test</span>	<span>%di</span>,<span>%di</span>				<span># Evlis(m:di,a:dx):ax</span>
<span> 149</span> 00ce 7416     		<span>jz</span>	1f				<span># jump if nil</span>
<span> 150</span> 00d0 FF31     		<span>push</span>	(<span>%bx</span>,<span>%di</span>)			<span># save 1 Cdr(m)</span>
<span> 151</span> 00d2 8B05     		<span>mov</span>	(<span>%di</span>),<span>%ax</span>
<span> 152</span> 00d4 E8AD00   		<span>call</span>	Eval
<span> 153</span> 00d7 5F       		<span>pop</span>	<span>%di</span>				<span># restore 1</span>
<span> 154</span> 00d8 50       		<span>push</span>	<span>%ax</span>				<span># save 2</span>
<span> 155</span> 00d9 E8F0FF   		<span>call</span>	Evlis
<span> 156</span>              	<span>#	jmp	xCons</span>
<span> 157</span>              	
<span> 158</span> 00dc 5F       	<span>xCons</span>:	<span>pop</span>	<span>%di</span>				<span># restore 2</span>
<span> 159</span> 00dd 87F9     	<span>Cons</span>:	<span>xchg</span>	<span>%di</span>,<span>%cx</span>				<span># Cons(m:di,a:ax):ax</span>
<span> 160</span> 00df 890D     		<span>mov</span>	<span>%cx</span>,(<span>%di</span>)			<span># must preserve si</span>
<span> 161</span> 00e1 8901     		<span>mov</span>	<span>%ax</span>,(<span>%bx</span>,<span>%di</span>)
<span> 162</span> 00e3 8D4D04   		<span>lea</span>	4(<span>%di</span>),<span>%cx</span>
<span> 163</span> 00e6 97       	<span>1</span>:	<span>xchg</span>	<span>%di</span>,<span>%ax</span>
<span> 164</span> 00e7 C3       		<span>ret</span>
<span> 165</span>              	
<span> 166</span> 00e8 E863FF   	<span>GetList</span>:call	GetToken
<p><strong>GAS LISTING sectorlisp.S 			page 5</strong></p>


<span> 167</span> 00eb 3C29     		<span>cmp</span>	<span>$&#39;)&#39;</span>,<span>%al</span>
<span> 168</span> 00ed 745F     		<span>je</span>	.retF
<span> 169</span> 00ef E8A2FF   		<span>call</span>	GetObject
<span> 170</span> 00f2 50       		<span>push</span>	<span>%ax</span>				<span># popped by xCons</span>
<span> 171</span> 00f3 E8F2FF   		<span>call</span>	GetList
<span> 172</span> 00f6 EBE4     		<span>jmp</span>	xCons
<span> 173</span>              	
<span> 174</span> 00f8 39D7     	<span>Gc</span>:	<span>cmp</span>	<span>%dx</span>,<span>%di</span>				<span># Gc(x:di,A:dx,B:si):ax</span>
<span> 175</span> 00fa 72EA     		<span>jb</span>	1b				<span># we assume immutable cells</span>
<span> 176</span> 00fc FF31     		<span>push</span>	(<span>%bx</span>,<span>%di</span>)			<span># mark prevents negative gc</span>
<span> 177</span> 00fe 8B3D     		<span>mov</span>	(<span>%di</span>),<span>%di</span>
<span> 178</span> 0100 E8F5FF   		<span>call</span>	Gc
<span> 179</span> 0103 5F       		<span>pop</span>	<span>%di</span>
<span> 180</span> 0104 50       		<span>push</span>	<span>%ax</span>
<span> 181</span> 0105 E8F0FF   		<span>call</span>	Gc
<span> 182</span> 0108 5F       		<span>pop</span>	<span>%di</span>
<span> 183</span> 0109 E8D1FF   		<span>call</span>	Cons
<span> 184</span> 010c 29F0     		<span>sub</span>	<span>%si</span>,<span>%ax</span>				<span># ax -= C - B</span>
<span> 185</span> 010e 01D0     		<span>add</span>	<span>%dx</span>,<span>%ax</span>
<span> 186</span> 0110 C3       		<span>ret</span>
<span> 187</span>              	
<span> 188</span> 0111 56       	<span>.dflt1</span>:	<span>push</span>	<span>%si</span>				<span># save x</span>
<span> 189</span> 0112 E86F00   		<span>call</span>	Eval
<span> 190</span> 0115 5E       		<span>pop</span>	<span>%si</span>				<span># restore x</span>
<span> 191</span>              	<span>#	jmp	Apply</span>
<span> 192</span>              	
<span> 193</span> 0116 85C0     	<span>Apply</span>:	<span>test</span>	<span>%ax</span>,<span>%ax</span>				<span># Apply(fn:ax,x:si:a:dx):ax</span>
<span> 194</span> 0118 791D     		<span>jns</span>	.switch				<span># jump if atom</span>
<span> 195</span> 011a 97       		<span>xchg</span>	<span>%ax</span>,<span>%di</span>				<span># di = fn</span>
<span> 196</span> 011b 8B39     	<span>.lambda</span>:<span>mov</span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>			<span># di = Cdr(fn)</span>
<span> 197</span> 011d 57       		<span>push</span>	<span>%di</span>				<span># for .EvCadr</span>
<span> 198</span> 011e 8B3D     		<span>mov</span>	(<span>%di</span>),<span>%di</span>			<span># di = Cadr(fn)</span>
<span> 199</span> 0120 85FF     	<span>Pairlis</span>:<span>test</span>	<span>%di</span>,<span>%di</span>				<span># Pairlis(x:di,y:si,a:dx):dx</span>
<span> 200</span> 0122 745C     		<span>jz</span>	.EvCadr				<span># return if x is nil</span>
<span> 201</span> 0124 AD       		<span>lodsw</span>					<span># ax = Car(y)</span>
<span> 202</span> 0125 FF31     		<span>push</span>	(<span>%bx</span>,<span>%di</span>)			<span># push Cdr(x)</span>
<span> 203</span> 0127 8B3D     		<span>mov</span>	(<span>%di</span>),<span>%di</span>			<span># di = Car(x)</span>
<span> 204</span> 0129 8B34     		<span>mov</span>	(<span>%si</span>),<span>%si</span>			<span># si = Cdr(y)</span>
<span> 205</span> 012b E8AFFF   		<span>call</span>	Cons				<span># Cons(Car(x),Car(y))</span>
<span> 206</span> 012e 97       		<span>xchg</span>	<span>%ax</span>,<span>%di</span>
<span> 207</span> 012f 92       		<span>xchg</span>	<span>%dx</span>,<span>%ax</span>
<span> 208</span> 0130 E8AAFF   		<span>call</span>	Cons				<span># Cons(Cons(Car(x),Car(y)),a)</span>
<span> 209</span> 0133 92       		<span>xchg</span>	<span>%ax</span>,<span>%dx</span>				<span># a = new list</span>
<span> 210</span> 0134 5F       		<span>pop</span>	<span>%di</span>				<span># grab Cdr(x)</span>
<span> 211</span> 0135 EBE9     		<span>jmp</span>	Pairlis
<span> 212</span> 0137 3D0000   	<span>.switch</span>:<span>cmp</span>	<span>$kEq</span>,<span>%ax</span>			<span># eq is last builtin atom</span>
<span> 213</span> 013a 77D5     		<span>ja</span>	.dflt1				<span># ah is zero if not above</span>
<span> 214</span> 013c 8B3C     		<span>mov</span>	(<span>%si</span>),<span>%di</span>			<span># di = Car(x)</span>
<span> 215</span> 013e 3C00     	<span>.ifCar</span>:	<span>cmp</span>	<span>$kCar</span>,<span>%al</span>
<span> 216</span> 0140 742B     		<span>je</span>	Car
<span> 217</span> 0142 3C00     	<span>.ifCdr</span>:	<span>cmp</span>	<span>$kCdr</span>,<span>%al</span>
<span> 218</span> 0144 7426     		<span>je</span>	Cdr
<span> 219</span> 0146 3C00     	<span>.ifAtom</span>:<span>cmp</span>	<span>$kAtom</span>,<span>%al</span>
<span> 220</span> 0148 7507     		<span>jne</span>	.ifCons
<span> 221</span> 014a 85FF     		<span>test</span>	<span>%di</span>,<span>%di</span>				<span># test if atom</span>
<span> 222</span> 014c 790E     		<span>jns</span>	.retT
<span> 223</span> 014e 31C0     	<span>.retF</span>:	<span>xor</span>	<span>%ax</span>,<span>%ax</span>				<span># ax = nil</span>
<p><strong>GAS LISTING sectorlisp.S 			page 6</strong></p>


<span> 224</span> 0150 C3       		<span>ret</span>
<span> 225</span> 0151 3C00     	<span>.ifCons</span>:<span>cmp</span>	<span>$kCons</span>,<span>%al</span>
<span> 226</span> 0153 8B30     		<span>mov</span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>			<span># si = Cdr(x)</span>
<span> 227</span> 0155 AD       		<span>lodsw</span>					<span># si = Cadr(x)</span>
<span> 228</span> 0156 7485     		<span>je</span>	Cons
<span> 229</span> 0158 31F8     	<span>.isEq</span>:	<span>xor</span>	<span>%di</span>,<span>%ax</span>				<span># we know for certain it&#39;s eq</span>
<span> 230</span> 015a 75F2     		<span>jne</span>	.retF
<span> 231</span> 015c B000     	<span>.retT</span>:	<span>mov</span>	<span>$kT</span>,<span>%al</span>
<span> 232</span> 015e C3       		<span>ret</span>
<span> 233</span>              	
<span> 234</span> 015f 89D6     	<span>Assoc</span>:	<span>mov</span>	<span>%dx</span>,<span>%si</span>				<span># Assoc(x:ax,y:dx):ax</span>
<span> 235</span> 0161 8B3C     	<span>1</span>:	<span>mov</span>	(<span>%si</span>),<span>%di</span>
<span> 236</span> 0163 8B30     		<span>mov</span>	(<span>%bx</span>,<span>%si</span>),<span>%si</span>
<span> 237</span> 0165 AF       		<span>scasw</span>
<span> 238</span> 0166 75F9     		<span>jne</span>	1b
<span> 239</span> 0168 F6       		<span>.byte</span>	0xF6				<span># testb §i8,i16(<span>%bp</span>,<span>%di</span>) jmp Car</span>
<span> 240</span> 0169 8B39     	<span>Cadr</span>:	<span>mov</span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>			<span># contents of decrement register</span>
<span> 241</span> 016b 3C       		<span>.byte</span>	0x3C				<span># cmp §scasw,<span>%al</span> (nop next byte)</span>
<span> 242</span> 016c AF       	<span>Cdr</span>:	<span>scasw</span>					<span># increments our data index by 2</span>
<span> 243</span> 016d 8B05     	<span>Car</span>:	<span>mov</span>	(<span>%di</span>),<span>%ax</span>			<span># contents of address register!!</span>
<span> 244</span> 016f C3       	<span>2</span>:	<span>ret</span>
<span> 245</span>              	
<span> 246</span> 0170 8B39     	<span>1</span>:	<span>mov</span>	(<span>%bx</span>,<span>%di</span>),<span>%di</span>			<span># di = Cdr(c)</span>
<span> 247</span> 0172 57       	<span>Evcon</span>:	<span>push</span>	<span>%di</span>				<span># save c</span>
<span> 248</span> 0173 8B35     		<span>mov</span>	(<span>%di</span>),<span>%si</span>			<span># di = Car(c)</span>
<span> 249</span> 0175 AD       		<span>lodsw</span>					<span># ax = Caar(c)</span>
<span> 250</span> 0176 E80B00   		<span>call</span>	Eval
<span> 251</span> 0179 5F       		<span>pop</span>	<span>%di</span>				<span># restore c</span>
<span> 252</span> 017a 85C0     		<span>test</span>	<span>%ax</span>,<span>%ax</span>				<span># nil test</span>
<span> 253</span> 017c 74F2     		<span>jz</span>	1b
<span> 254</span> 017e FF35     		<span>push</span>	(<span>%di</span>)				<span># push Car(c)</span>
<span> 255</span> 0180 5F       	<span>.EvCadr</span>:<span>pop</span>	<span>%di</span>
<span> 256</span> 0181 E8E5FF   		<span>call</span>	Cadr				<span># ax = Cadar(c)</span>
<span> 257</span>              	<span>#	jmp	Eval</span>
<span> 258</span>              	
<span> 259</span> 0184 85C0     	<span>Eval</span>:	<span>test</span>	<span>%ax</span>,<span>%ax</span>				<span># Eval(e:ax,a:dx):ax</span>
<span> 260</span> 0186 742B     		<span>jz</span>	1f
<span> 261</span> 0188 79D5     		<span>jns</span>	Assoc				<span># lookup val if atom</span>
<span> 262</span> 018a 96       		<span>xchg</span>	<span>%ax</span>,<span>%si</span>				<span># di = e</span>
<span> 263</span> 018b AD       		<span>lodsw</span>					<span># ax = Car(e)</span>
<span> 264</span> 018c 3D0000   		<span>cmp</span>	<span>$kQuote</span>,<span>%ax</span>			<span># maybe CONS</span>
<span> 265</span> 018f 8B3C     		<span>mov</span>	(<span>%si</span>),<span>%di</span>			<span># di = Cdr(e)</span>
<span> 266</span> 0191 74DA     		<span>je</span>	Car
<span> 267</span> 0193 3D0000   		<span>cmp</span>	<span>$kCond</span>,<span>%ax</span>
<span> 268</span> 0196 74DA     		<span>je</span>	Evcon				<span># ABC Garbage Collector</span>
<span> 269</span> 0198 52       		<span>push</span>	<span>%dx</span>				<span># save a</span>
<span> 270</span> 0199 51       		<span>push</span>	<span>%cx</span>				<span># save A</span>
<span> 271</span> 019a 50       		<span>push</span>	<span>%ax</span>
<span> 272</span> 019b E82EFF   		<span>call</span>	Evlis
<span> 273</span> 019e 96       		<span>xchg</span>	<span>%ax</span>,<span>%si</span>
<span> 274</span> 019f 58       		<span>pop</span>	<span>%ax</span>
<span> 275</span> 01a0 E873FF   		<span>call</span>	Apply
<span> 276</span> 01a3 5A       		<span>pop</span>	<span>%dx</span>				<span># restore A</span>
<span> 277</span> 01a4 89CE     		<span>mov</span>	<span>%cx</span>,<span>%si</span>				<span># si = B</span>
<span> 278</span> 01a6 97       		<span>xchg</span>	<span>%ax</span>,<span>%di</span>
<span> 279</span> 01a7 E84EFF   		<span>call</span>	Gc
<span> 280</span> 01aa 89D7     		<span>mov</span>	<span>%dx</span>,<span>%di</span>				<span># di = A</span>
<p><strong>GAS LISTING sectorlisp.S 			page 7</strong></p>


<span> 281</span> 01ac 29F1     		<span>sub</span>	<span>%si</span>,<span>%cx</span>				<span># cx = C - B</span>
<span> 282</span> 01ae F3A4     		<span>rep movsb</span>
<span> 283</span> 01b0 89F9     		<span>mov</span>	<span>%di</span>,<span>%cx</span>				<span># cx = A + (C - B)</span>
<span> 284</span> 01b2 5A       		<span>pop</span>	<span>%dx</span>				<span># restore a</span>
<span> 285</span> 01b3 C3       	<span>1</span>:	<span>ret</span>
<span> 286</span>              	
<span> 287</span> 01b4 CECECECE 	<span>.sig</span>:	<span>.fill</span>	512 - (2f - 1f) - (. - _start), 1, 0xce
<span> 287</span>      CECECECE 
<span> 287</span>      CECECECE 
<span> 287</span>      CECECECE 
<span> 287</span>      CECECECE 
<span> 288</span> 01ef 20534543 	<span>1</span>:	<span>.ascii</span>	<span>&#34; SECTORLISP v2 &#34;</span>
<span> 288</span>      544F524C 
<span> 288</span>      49535020 
<span> 288</span>      763220
<span> 289</span> 01fe 55AA     		<span>.word</span>	0xAA55
<span> 290</span>              	<span>2</span>:	<span>.type</span>	.sig,<span>@object</span>
<span> 291</span>              		<span>.type</span>	kQuote,<span>@object</span>
<span> 292</span>              		<span>.type</span>	kCond,<span>@object</span>
<span> 293</span>              		<span>.type</span>	kAtom,<span>@object</span>
<span> 294</span>              		<span>.type</span>	kCar,<span>@object</span>
<span> 295</span>              		<span>.type</span>	kCdr,<span>@object</span>
<span> 296</span>              		<span>.type</span>	kCons,<span>@object</span>
<span> 297</span>              		<span>.type</span>	kEq,<span>@object</span>
</pre>

<h2 class="page" id="credits"><a class="anchor" href="#credits">Credits</a></h2>

<p>
SectorLISP started as an experiment in the
<a href="https://github.com/jart/cosmopolitan">Cosmopolitan</a> repo where
<a href="https://github.com/jart">Justine Tunney</a> used sed to get
code built by a Linux x86_64 compiler to run in 16-bit mode. Its
original size was 948 bytes, which was gradually reduced with help
from <a href="https://github.com/ilyakurdyukov">Ilya Kurdyukov</a> at
BaseALT and <a href="https://github.com/swolchok">Scott Wolchok</a> at
Facebook. <a href="https://github.com/agreppin">Alain Greppin</a> did a
rewrite after having the brilliant insight of using Steve Russel&#39;s
coding techinques from the LISP 1.5 manual which finally let us fit
SectorLISP in one sector.
<a href="https://github.com/peterferrie">Peter Ferrie</a> at Amazon and
Justine reduced SectorLISP further, by another 110 bytes. The ABC
garbage collector was designed and implemented by Justine. The 99 byte
Brainfuck implementation was written by Peter and Justine. The musical
track is an instrumental recording of Das Model by Kraftwerk from 1978.
Credit for the UNICODE paragraph separator
<a href="https://twitter.com/randomdude999_/status/1464166889643552768">trick
for C / JS polyglots</a> goes to a code golfer from Estonia
named <a href="https://r9.pm/">randomdude999</a>.
You&#39;re invited to come hang out with the SectorLISP team. Use the
following link to join our Discord chatroom:
<a href="https://discord.gg/kKZxkgKk">https://discord.gg/kKZxkgKk</a>

</p><h2 class="page" id="mentions"><a class="anchor" href="#mentions">Mentions</a></h2>

<p>
Marc Feeley and Samuel Yvon recently wrote a paper on
a <a href="https://dl.acm.org/doi/pdf/10.1145/3486606.3486783">Small
Scheme VM, Compiler, and REPL</a> which cites SectorLISP. Rather than
targeting the legacy sector size of 512 bytes, they targeted the modern
4096-byte page size. That enabled them to offer a great deal more value
in a comparatively tiny size, such as a bytecode compiler, which helps
illuminates Gosling&#39;s original intentions for Java.

<!-- Something like this -->
<!-- could be a better teaching tool in some cases than Racket, because -->
<!-- Scheme was intended to be simple, and Racket isn't simple; see  -->
<!-- <a href="#comparisons">Comparisons</a> above. -->

</p><h2 class="page" id="funding"><a class="anchor" href="#funding">Funding</a></h2>

<p>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/lemuria.png"><img src="https://storage.googleapis.com/justine/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/></a>

</p><p>
Funding for this blog post was crowdsourced from Justine Tunney&#39;s
<a href="https://github.com/sponsors/jart">GitHub sponsors</a>
and <a href="https://www.patreon.com/jart">Patreon subscribers</a>. Your
support is what makes projects like SectorLISP possible. Thank you.

</p><h2 class="page" id="seealso"><a href="#seealso">See Also</a></h2>

<ol>
<li id="footnote1">
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/aimemo8.txt">Artificial Intelligence Memo No. 8</a> by John McCarthy

</li><li>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/JohnMcCarthyBasisForComputation.pdf">A Basis for a Mathematical Theory of Computation</a> by John McCarthy

</li><li>
  <a href="https://thewitchofendor.com/2021/12/18/sectorlisp/lisp.pdf">Recursive Functions of Symbolic Expressions and their Computation by Machine</a> by John McCarthy

</li><li>
  <a href="https://thewitchofendor.com/2021/12/18/sectorlisp/lisp-history.pdf">History of Lisp</a> by John McCarthy

</li><li>
  <a href="https://thewitchofendor.com/2021/12/18/sectorlisp/jmc.pdf">The Roots of Lisp</a> by Paul Graham

</li><li id="footnote6">
  The announcement that the U.S. nuclear arsenal no longer relies on
  floppy disks was made in the New York Times on October
  24<sup>th</sup>, 2019
  (see <a href="https://archive.md/lvkmn">archive.md/lvkmnThe</a>
  and <a href="https://www.nytimes.com/2019/10/24/us/nuclear-weapons-floppy-disks.html">www.nytimes.com/2019/10/24/us/nuclear-weapons-floppy-disks.html</a>).
  The U.S. National Nuclear Security Administration is believed to have
  been breached by the transitive property because they granted a vendor
  named SolarWinds the ability to remotely manage their systems and
  SolarWinds got hacked, according to Natasha Bertrand and Eric Wolff at
  Politico on December 17<sup>th</sup>, 2020
  (see <a href="https://archive.md/ZTPOP#selection-1147.160-1147.288">archive.md/ZTPOP</a>
  and <a href="https://www.politico.com/news/2020/12/17/nuclear-agency-hacked-officials-inform-congress-447855">www.politico.com/news/2020/12/17/nuclear-agency-hacked-officials-inform-congress-447855</a>).
  The first evidence that artifacts distributed by SolarWinds had been
  tampered with dates back to October 2019 according to Tomislav Peričin
  at <span aria-title="Reversing Labs">ЯeversingLabs</span>
  (see <a href="https://archive.md/HbzUC#selection-1081.0-1081.231">archive.md/HbzUC</a>
  and
  <a href="https://blog.reversinglabs.com/blog/sunburst-the-next-level-of-stealth">blog.reversinglabs.com/blog/sunburst-the-next-level-of-stealth</a>).

</li><li id="footnote7">
  The IBM 7090 didn&#39;t have the concept of bytes so the 32kB binary
  footprint was tallied based on instructions in
  the <a href="https://thewitchofendor.com/2021/12/18/sectorlisp/lisp.lst.html">LISP 1.5 listing file</a>
  and then rounded up to include possible essential data, which was
  later reconciled with the 27kB code size estimate provided by the LISP
  1.5 manual.
  See <a href="https://www.reddit.com/r/lisp/comments/qomw8r/sectorlisp_binary_footprint_comparaison/hkiinob/">reddit.com/r/lisp/comments/qomw8r</a>

<!-- <li id="footnote8"> -->
<!--   <code class="small">racket &<br>grep r.xp /proc/$(ps aux | grep [r]acket | awk '{print $2}')/maps |<br>  sed -n 's@[^/]*\(/.*\)@\1@p' |<br>  sort -u |<br>  xargs ls -al |<br>  awk '{x+=$5}END{print(x)}'</code> -->

<!-- <li id="footnote9"> -->
<!--   <code class="small">sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'<br>rusage.com<br>echo '(quote hello-world)' |<br>  rusage.com racket -q</code> -->

<!-- <li id="footnote10"> -->
<!--   <code class="small">echo '(quote hello-world)' |<br>  strace racket -q 2>&1 |<br>  grep SIGSEGV |<br>  wc -l</code> -->

<!-- <li id="footnote11"> -->
<!--   <code class="small">sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'<br>rusage.com<br>echo '(quote hello-world)' |<br>  rusage.com sbcl --no-sysinit --no-userinit</code> -->

<!-- <li id="footnote12"> -->
<!--   <a href="https://www.ncbi.nlm.nih.gov/genome/366">Lemur catta genome</a> -->

</li><li>
  <a href="https://thewitchofendor.com/2021/12/18/web3-and-the-future-of-routing/troades.html">Troades</a> by Seneca

</li></ol>


</div>
  </body>
</html>
