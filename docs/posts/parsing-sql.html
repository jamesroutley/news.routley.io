<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomassetti.me/parsing-sql/">Original</a>
    <h1>Parsing SQL</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><em>The code for this tutorial is on GitHub: <a href="https://github.com/gabriele-tomassetti/parsing-sql">parsing-sql</a></em></p>
<p>SQL is a language to handle data in a relational database. If you worked with data you have probably worked with SQL. We will talk about parsing SQL.</p>
<p>It is in the same league of HTML: maybe you never learned it formally but you kinda know how to use it. That is great because <strong>if you know SQL, you know how to handle data</strong>. However, it has limitations and when you hit them your only course of action might be to work with a traditional programming language. This does not necessarily mean migrating away from SQL. You might need to move from one SQL dialect to another one or to analyze the SQL code you use. And to do that, you need to parse SQL, and that is what this article is about.</p>
<p>What are the limits of SQL? After a while you learn of a couple of issues:</p>
<ul><li><strong>there is not one SQL</strong>, but many variations of it. The SQLs implemented in SQLite, MySQL, PostgreSQL, etc. are all a bit different</li><li><strong>you cannot do everything related to data in SQL</strong>. In some cases, you need a traditional programming language to work with the data</li></ul>
<p>These issues became real problems when you need to make big changes. For instance, if you need to change the database used by a large application. It can also be a problem when you need to make transformations that SQL and your database cannot handle them. In that case, you have some transformations done in SQL (and run on the database) and some other in your source code. So you spend a lot of time working on glue code and around the limitations of SQL.</p>
<p>SQL can also be a constraint, simply for what it lacks: unit testing integrated with your source code and all the other tools that you can use with Java, C#, etc. SQL is an old language and not designed for large scale programming, it is not a language that developers will love. Even worse, they will not be very productive with it. And what happens if your application requires you to verify that something gets executed in a certain way, or to offer some guarantees? It can be a business need or a regulatory requirement. Then you need to parse SQL or to find a way to move from SQL world to your programming language world.</p>
<p>That is what this article is about: parsing SQL. We are going to see <strong>ready-to-use libraries and tools to parse SQL</strong>, and an example project in which <strong>we will build our own SQL parser</strong>.</p>
<div><div>
<h2>What is SQL</h2>
<p><strong>SQL (Structured Query Language) is a domain-specific language designed to handle data in relational database</strong>. It is a declarative language, so you describe what you want to achieve (e.g., <em>get me a row of data with id=5</em>) and not how to achieve it (e.g. <em>loop through the rows until id=5</em>). It has a formal mathematical foundation in relational algebra and calculus. The language is an ISO/IEC standard that is periodically updated, the latest version is <a href="https://en.wikipedia.org/wiki/SQL:2016">SQL2016</a>. This means that there is a very formal and clear description of the language if you need it.</p>
<p>SQL is designed to handle many aspects of the life cycle of working with data: yes, you can query data, but you can also create the format of data (i.e., the schema of a table) and regulate access control to the data.</p>
<h3>SQL Procedural Extensions</h3>
<p>Actual SQL implementations come with procedural extensions that implement some form of procedural programming. These are even more varied from database engine to database engine. They were added to perform complex elaborations on the data directly on the database, so they can be as powerful as traditional programming languages. And this can also be an additional headache if you try to parse SQL. See, for instance, this is a PL/SQL (the procedural SQL from Oracle databases) example from Wikipedia.</p>
<pre data-enlighter-language="sql" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">DECLARE
    var NUMBER;
BEGIN
     /*N.B. for loop variables in pl/sql are new declarations, with scope only inside the loop */
     FOR var IN 0 .. 10 LOOP
          DBMS_OUTPUT.PUT_LINE(var);
     END LOOP;

     IF (var IS NULL) THEN
          DBMS_OUTPUT.PUT_LINE(&#39;var is null&#39;);
     ELSE
          DBMS_OUTPUT.PUT_LINE(&#39;var is not null&#39;);
     END IF;
END;</pre>
</div></div>
<div><div>
<h2>Resources</h2>
<p>As we have seen, handling SQL can be a daunting task, so let’s see a few resources to help you. They range from grammars to kick start your parsing efforts, to ready-to-use tools.</p>
<h3>Knowledge</h3>
<h4>Official Sources</h4>
<p>The latest official SQL standard is formally known as ISO/IEC 9075 SQL:2016. You can find every information you need about it in the official sources either the <a href="https://www.iso.org/standard/63555.html">ISO</a> or <a href="https://webstore.iec.ch/publication/59678">IEC</a> websites. However, keep in mind that there are several documents describing the standard and you have to pay for each of them. This means, depending on the exchange rate, the total cost could be more than 2,000 USD.</p>
<h4>Official References from Database Documentation</h4>
<p>Other than the official SQL standard, you can look up the official documentation of the database producers, which contains a reference for their SQL implementation. Here is a list of the few major ones:</p>
<ul><li><a href="https://www.oracle.com/database/technologies/appdev/plsql.html">Oracle PL/SQL Documentation</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html">MySQL 8 SQL Reference</a></li><li><a href="https://docs.microsoft.com/it-it/sql/t-sql/language-reference?view=sql-server-ver15">Microsoft Transact-SQL Reference</a></li><li><a href="https://www.postgresql.org/docs/12/sql.html">PostgreSQL 12 SQL Language</a></li><li><a href="https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/c0004100.html">IBM DB2 SQL</a></li><li><a href="https://www.sqlite.org/lang.html">SQL as understood by SQLite</a></li></ul>
<h4>Grammars</h4>
<p>There are a few (usually partial) grammars available in different formats. They can be a good starting point for getting where you need.</p>
<ul><li><a href="https://github.com/ronsavage/SQL">BNF Grammars for SQL-92, SQL-99 and SQL-2003 </a></li><li>Partial <a href="https://github.com/cmedved/Teradata-SQL-Parser">Teradata SQL grammar for ANTLR4</a></li><li>The <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">ANTLR</a> v4 Grammars repository contains grammars for <a href="https://github.com/antlr/grammars-v4/tree/master/sql">MySQL, PL/SQL, T-SQL and SQLite</a>. In our <a href="https://tomassetti.me/antlr-course/">ANTLR Course</a> we analyze the SQLite grammar to explain its structure and how you can parse a declarative language like SQL.</li></ul>
<h3>Libraries</h3>
<p>There are many libraries to parse SQL in different languages. Some support different databases and different programming languages. Here it is a list of the most used ones. Unless otherwise noted, the libraries are released under an opensource license.</p>
<h4>Multi-lingual and/or multi-databases</h4>
<ul><li><strong><a href="http://www.sqlparser.com/index.php">General SQL Parser</a></strong> is a commercial library that supports many databases (DB2, Greenplum, Hana, Hive, Impala, Informix, MySQL, Netezza, Oracle, PostgreSQL, Redshift SQL Server, Sybase, and Teradata) and languages (<strong>C#, VB.NET, Java, C/C++, Delphi, VB</strong>). It can validate SQL syntax, format SQL and work with the parse tree</li><li><em><a href="https://github.com/JSQLParser/JSqlParser">JSqlParser</a> parses an SQL statement and translates it into a hierarchy of <strong>Java</strong> classes</em>. It is opensource, with a double LGPL and Apache license, and supports many databases: Oracle, SqlServer, MySQL, PostgreSQL, etc.</li></ul>
<h4>MySQL parsers</h4>
<ul><li><a href="https://github.com/pingcap/parser">Pingcap parser</a> is a MySQL parser in <strong>Go</strong>.</li><li><a href="https://github.com/xwb1989/sqlparser">xwb1989/sqlparser</a> is a MySQL parser for <strong>Go</strong>. This parser has been extracted from <a href="https://github.com/vitessio/vitess">Vitess</a>, a database clustering system for horizontal scaling of MySQL.</li><li><a href="https://github.com/greenlion/PHP-SQL-Parser">PHP SQL Parser</a> is a (mainly) MySQL (non-validating) parser written in <strong>PHP</strong>. It can parse other SQL dialects with some modifications. It fully supports parsing the <a href="https://github.com/greenlion/PHP-SQL-Parser#full-support-for-the-mysql-dialect-for-the-following-statement-types">most used SQL statements</a>, but it just returns some information on other statements.</li><li>The <a href="https://github.com/phpmyadmin/sql-parser">SQL Parser of <strong>phpmyadmin</strong></a> is <em>a validating SQL lexer and parser with a focus on MySQL dialect</em>. Given its use in PHPMyAdmin, it is certainly well tested.</li><li><strong><a href="https://github.com/JavaScriptor/js-sql-parser">js-sql-parser</a></strong> is SQL (only select) parser for JavaScript that parses the MySQL 5.7 version of SQL into an AST.</li></ul>
<h4>SQLite Parsers</h4>
<ul><li><a href="https://github.com/codeschool/sqlite-parser">sqlite-parser</a> is a parser for SQLite v3 written in <strong>JavaScript</strong> that generates ASTs.</li></ul>
<h4>SQL Parsers</h4>
<ul><li><a href="https://github.com/forward/sql-parser">sql-parser</a> is a parser for SQL written in pure <strong>JavaScript</strong>. It is not maintained anymore and it only supports some SELECT queries, but it is probably better than starting from scratch if you need to use JavaScript.</li><li><a href="https://github.com/hyrise/sql-parser">hyrise/sql-parser</a> is a SQL parser for <strong>C++</strong>. It parses the given SQL query into C++ objects. It is developed together with Hyrise, an in-memory database, but it can be used on its own.</li><li><a href="https://github.com/andialbrecht/sqlparse">andialbrecht/<em>sqlparse</em></a><em> is a non-validating SQL parser for <strong>Python</strong>. It provides support for parsing, splitting and formatting SQL statements. </em></li><li><em><a href="https://github.com/K2InformaticsGmbH/sqlparse">K2InformaticsGmbH/sqlparse</a> is a production-ready SQL parser written in pure Erlang</em>. It targets the Oracle PL/SQL dialect.</li><li><strong><a href="https://github.com/andygrove/sqlparser-rs">sqlparser-rs</a></strong> is SQL parser written in <strong>Rust</strong>. It supports the SQL-92, plus some addition for MS-SQL, PostgreSQL, and SQL:2011. The developers say: <em>if you are assessing whether this project will be suitable for your needs, you’ll likely need to experimentally verify whether it supports the subset of SQL that you need</em>.</li><li><strong><a href="https://github.com/mozilla/moz-sql-parser">moz-sql-parser</a></strong> is a peculiar SQL parser in <strong>Python</strong> written by Mozilla. <em>The primary objective of this library is to convert some subset of SQL-92 queries to JSON-izable parse trees</em>.</li><li><a href="https://github.com/uber/queryparser">queryparser</a> is a parser written in <strong>Haskell</strong> for <em>parsing and analysis of <strong>Vertica, Hive, and Presto SQL</strong></em>.</li></ul>
<h3>Tools</h3>
<h4>From SQL to a Programming Language or another SQL</h4>
<ul><li><a href="http://www.io64.com/plsql-to-java-migration/">IO64</a> offers a tool to convert PL/SQL to Java. We have also seen this tool in our previous article <a href="https://tomassetti.me/convert-pl-sql-code-to-java/">Convert PL/SQL code to Java</a></li><li><a href="https://www.ispirer.com/">Ispirer</a> is a company that provides a tool to perform database migration from different SQL dialects to another SQL dialect or a programming language: Ispirer MnMTK. We have seen it in our previous article <a href="https://tomassetti.me/convert-pl-sql-code-to-java/">Convert PL/SQL code to Java</a></li><li><a href="http://SQLines SQL Converter">SQLines SQL Converter</a> is an open-source tool to convert a SQL dialect to a different SQL dialect. It is written in C++ and implements its own SQL parser.</li></ul>
</div></div>
<h2>How Hard Could it be to Parse a Declarative Language?</h2>
<p>Declarative languages tend to have simpler structures than your average programming language. For instance, you do not see many nested lambdas used inside declarative languages. A program in a declarative language is usually a long list of simple statements. <strong>The issue is that any single statement can be fairly complicated in some cases</strong>. And that is what happens in SQL.</p>
<p>Furthermore, there are actually several versions of SQL. This is true both in the sense that each database can implement it differently, and that there are <a href="https://en.wikipedia.org/wiki/ISO/IEC_9075">many versions of the SQL standard</a> because the language is evolving.</p>
<p>As an example, you are certainly familiar with a SELECT statement. In its basic format, like <code>SELECT name FROM customers WHERE id = 1</code> it is quite easy to parse. However, the complete statement can be fairly complex. This image represents the SELECT statement as implemented in SQLite.</p>
<figure><img loading="lazy" width="623" height="881" src="https://tomassetti.me/wp-content/uploads/2020/03/SQLite_select.png" alt="" srcset="https://tomassetti.me/wp-content/uploads/2020/03/SQLite_select.png 623w, https://tomassetti.me/wp-content/uploads/2020/03/SQLite_select-212x300.png 212w, https://tomassetti.me/wp-content/uploads/2020/03/SQLite_select-499x705.png 499w, https://tomassetti.me/wp-content/uploads/2020/03/SQLite_select-450x636.png 450w" sizes="(max-width: 623px) 100vw, 623px"/></figure>
<p>So, to implement support for parsing the general case will certainly take some time.</p>
<h2>Try to Parse for Your Application</h2>
<p><strong>The reality is that to implement support for parsing the whole SQL requires a lot of effort</strong>, probably as much as parsing any average programming language. Even more, if you need to parse many different SQL dialects. Then, if you need to parse SQL and cannot rely on a ready-to-use library, you should start with an analysis of your needs. You should try to understand first exactly what you need to parse and then try to parse in light of your application. This means both to parse just what you need and to structure the grammar in a way that makes your life easier.</p>
<p>For instance, if you just need to translate a series of SQL files just once, it may be acceptable to just ignore 40 complex statements. Maybe translating them manually would take less time than creating a large grammar to do it automatically. This does not work if you either have a lot of code or you need to do the translation repeatedly, not just once.</p>
<p>In this tutorial we are going to use this pragmatic approach: we are going to create a SQL grammar from scratch to parse just what we need and to ignore the rest.</p>
<h2>Writing a (Very Partial) Grammar</h2>
<p>In our example, we will parse a simple SQL file (an exported database) to generate classes that could represent that database. We are going to ignore everything else, even any exported data present in the file. That’s it. The advantage of dealing with SQL files is that we do not need to interact with a database. In fact, the database might not even exist anymore.</p>
<h3>Designing a Partial Grammar</h3>
<p>To do that we are going to start with a grammar. We are going to write a very simple one, but there are a couple of things to keep in mind:</p>
<ul><li>SQL is not case-sensitive, while <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">ANTLR grammars</a> by default are</li><li>Our input (the SQL files) will contain some data that we do not care about. We still need to parse the file successfully while ignoring the extraneous input</li></ul>
<p>These are notable issues that are specific to SQL and to our approach; probably they would not appear with other languages or if we wanted to create a complete grammar.</p>
<p>Before starting, just to give you an idea of what we have to deal with, this is a sample SQL file.</p>
<pre data-enlighter-language="sql" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">--
-- Table structure for table actor
--
--DROP TABLE actor;

CREATE TABLE actor (
  actor_id numeric NOT NULL ,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  last_update TIMESTAMP NOT NULL,
  PRIMARY KEY  (actor_id)
  )
  ;

CREATE  INDEX idx_actor_last_name ON actor(last_name)
;
 
CREATE TRIGGER actor_trigger_ai AFTER INSERT ON actor
 BEGIN
  UPDATE actor SET last_update = DATETIME(&#39;NOW&#39;)  WHERE rowid = new.rowid;
 END
;</pre>
<p>As you can see at a first glance, we need to parse CREATE TABLE statements and ignore the other ones. We also need to ignore some parts of the CREATE TABLE statements, because they do not contain any information we care about for our task.</p>
<h3>How to Ignore Stuff</h3>
<p><strong>The key to design a partial grammar is understanding how to ignore everything except for what we care about</strong>. This is not trivial because we have two conflicting needs: to ignore or drop most information and to keep all the necessary context to parse what we need. The more we ignore, the harder is to parse what we need. This is tricky particularly for lexing since the lexer has less information available to make a decision.</p>
<p>For instance, we cannot just say ignore anything until we find a <code>CREATE</code> token. That is because the lexer would still find tokens for the elements in row definition, like the ones for naming the columns (e.g. <code>last_name</code>) in INSERT statements or CREATE INDEX. One possible way to deal with this would be lexical modes. These are a way to include multiple sets of lexer rules and switch between them. See our <a href="https://tomassetti.me/antlr-mega-tutorial/#lexical-modes">ANTLR Mega Tutorial</a>, if you need to know more.</p>
<p>Essentially we would treat SQL as if it were a markup language: bits of structured information in a sea of free text that we could ignore. This could work in our case because SQL has a regular structure and we are just interested in CREATE TABLE statements. For regular structure, we mean that a SQL file is just a list of statements, each of them ends with a semicolon. So, we could just make a <code>CREATE TABLE</code> token to start the special lexical mode and use the <code>semicolon</code> to end the special lexical mode. However, it is not flexible, so it would be risky in case we need to use our grammar for something else.</p>
<h4>The Cognizant Way of Ignoring Stuff</h4>
<p>Our preferred approach is more flexible, and can also be used for regular programming languages.</p>
<p>On the lexer side, we just put as the last lexer rule this ANY rule.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">ANY             : . -&gt; skip;</pre>
<p>We skip every character, that was not already recognized by some previous token.</p>
<p>On the parser side, these would be our main rules.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">statements          : (statement | ignore)+ EOF
                    ;

statement           : createStmt
                    ;

ignore              : .*? SEMICOLON
                    | COMMENT
                    ;</pre>
<p>The main rule is <code>statements</code>, which captures both the stuff we care about and the stuff to ignore. This approach allows us to start using our grammar while we build it. For this example, we only need to parse CREATE TABLE statements, but you could slowly add support for parsing more statements with this structure.</p>
<p>We need the <code>ignore</code> rule to maintain an understanding of the structure of the SQL file. <strong>Without this rule, we would not be able to recognize and parse the statements we are interested in</strong>. The negative side-effect is that it will clutter our parse tree with <em>ignore</em> nodes. For instance, this is a graphical representation of a sample parse tree made with <code>grun</code>, the ANTLR testing utility.</p>
<figure><img loading="lazy" width="1030" height="772" src="https://mk0tuzolorusfnc7thxk.kinstacdn.com/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-1030x772.png" alt="Sample parse tree with a partial SQL grammar" srcset="https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-1030x772.png 1030w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-300x225.png 300w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-768x576.png 768w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-1536x1151.png 1536w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-1500x1124.png 1500w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-705x528.png 705w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-450x337.png 450w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar-205x155.png 205w, https://tomassetti.me/wp-content/uploads/2020/04/sample_parse_tree_sql_partial_grammar.png 1628w" sizes="(max-width: 1030px) 100vw, 1030px"/></figure>
<h3>Parsing Create Statements</h3>
<p>We use a similar approach to parsing the CREATE TABLE statements.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">createStmt          : CREATE TABLE (IF NOT EXISTS)? tableName=name
                        LPAREN element (COMMA element)* RPAREN?
                        SEMICOLON
                    ;

element             : definition
                    | ignorable
                    ;

ignorable           : (PRIMARY? KEY | CONSTRAINT | SPECIAL_FEATURES | FULLTEXT) .*? (COMMA|RPAREN)                    
                    ;

definition          : name type defaultValue? nullability? attributes*;</pre>
<p>The statement includes both definitions of columns, that we need, and settings for the table, that we could ignore. So, our <code>element</code> rule can accept both the definition for a row and the information about primary keys, constraints, etc. Later, in our code, we will simply ignore both the nodes <code>ignore</code> and <code>ignorable</code>.</p>
<p>The rules themselves are fairly easy to understand and should be obvious for everybody that has seen SQL. There is only a dirty trick that needs to be explained. You can see that the closing parenthesis (<code>RPAREN</code>) that should be at the end of the list of column definitions is optional. Technically this is not correct, it should always be there. However, we use this to fix an issue regarding the <code>ignorable</code> rule.</p>
<h4>Getting Around the Need to Actually Parse Settings</h4>
<p>The issue is that the <code>ignorable</code> rule is only a partial implementation of the parsing of these settings that you will find in a SQL file. In fact, this is the bare minimum necessary to parse correctly a bunch of sample SQL files we encountered. It is not a good design, but this is a very realistic implementation. Look at this example and see if you can spot our problem.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">CREATE TABLE city (
  city_id int NOT NULL,
  city VARCHAR(50) NOT NULL,
  country_id SMALLINT NOT NULL,
  last_update TIMESTAMP NOT NULL,
  PRIMARY KEY  (city_id),
  CONSTRAINT fk_city_country FOREIGN KEY (country_id) REFERENCES country (country_id) ON DELETE NO ACTION ON UPDATE CASCADE
);</pre>
<p><strong>This partial implementation has the issue that it does not parse well enough to understand when it found the end of a setting</strong>. So, it uses as a clue the comma (i.e., the start of a new setting) or the final closing parenthesis (i.e., the end of the list of elements) for the final setting.</p>
<p>Now, how safe is it to use this dirty trick? In this case, it is safe because SQL files are not written by humans, they are exported with tools. This means that there will not be missing parenthesis that will mess up the recognition of subsequent statements. So, we actually can be sure that every CREATE TABLE will end with a closing parenthesis and a semicolon. This may vary with different languages, different sources of SQL statements or different databases.</p>
<p>When you need to only partially implement a grammar these sorts of tricks can be quite helpful to speed up development and get your task done quicker. You have to be careful and aware of the risks, but they can be useful.</p>
<h3>The Rest of the Grammar</h3>
<p>The rest of the grammar is also fairly simple to understand. We just mention a couple of things.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">name                : QUOTE? NAME QUOTE? ;</pre>
<p>The rule <code>name</code> is a parser rule instead of a lexer rule. That is because some tools wrap the name of the column with quotation marks (these are also used as apostrophes in some languages) like <code>`</code> or <code>&#39;</code>. With this definition, later in our code, we can easily extract the real name of the column without any check for quotation marks.</p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">type                : (INTEGER | INT) UNSIGNED?                                                   #integerType
                    | (TINYINT | SMALLINT) UNSIGNED?                                              #smallIntegerType
                    | TEXT                                                                        #textType
                    | BLOB (SUBTYPE type)?                                                        #blobType
                    | (VARCHAR|CHARVAR) LPAREN NUMBER RPAREN                                      #varcharType
                    | CHAR LPAREN NUMBER RPAREN                                                   #charType
                    | YEAR                                                                        #yearType
                    | DATETIME                                                                    #datetimeType
                    | TIMESTAMP TIMEZONE?                                                         #timestampType
                    | (NUMERIC | DECIMAL) (LPAREN precision=NUMBER (COMMA scale=NUMBER)? RPAREN)? #decimalType
                    ;</pre>
<p>The rule to parse the type of the column includes rule labels. We designed this way to simplify our job later in the code, where we use the parser. This is also the reason because the VARCHAR rule is separated from the CHAR rule. Structurally the rules are obviously identical, but they mean something different. <strong>Remember: you should parse for your application, to make the parse effective for your needs.</strong></p>
<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">fragment A      : [aA];
fragment B      : [bB];
fragment C      : [cC];
fragment D      : [dD];
fragment E      : [eE];
// etc.</pre>
<p>Since SQL is case-insensitive we use fragments for letters everywhere we need, to ensure that we parse everything correctly.</p>
<p>You can see the rest of the grammar on the companion repository.</p>
<h2>Creating the C# project</h2>
<p>We can finally see some code. We are going to create a C# project from the command line since we are using VS Code as our editor. These are the instructions to create the project and to add the <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">ANTLR library</a>.</p>
<pre data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// create a new directory somewhere
// to create a new C# project
dotnet new console -lang C#
// to install the standard ANTLR 4 Runtime
dotnet add package Antlr4.Runtime.Standard</pre>
<p>These are the instructions to generate the parser and to run the program.</p>
<pre data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// to generate the parser
antlr4 SQL.g4 -Dlanguage=CSharp -o generated -encoding UTF-8
// to run the program
dotnet run</pre>
<p>Even our main source code file is fairly standard.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">static void Main(string[] args)
{
    // standard ANTLR code
    // we get the input
    ICharStream chars = CharStreams.fromPath(args[0]);
    // we set up the lexer
    SQLLexer lexer = new SQLLexer(chars);            
    // we use the lexer
    CommonTokenStream stream = new CommonTokenStream(lexer);
    // we set up the parser
    SQLParser parser = new SQLParser(stream);

    // we find the root node of our parse tree             
    var tree = parser.statements();                                    
    
    // we create our visitor
    CreateVisitor createVisitor = new CreateVisitor();   
    List&lt;ClassDescriptor&gt; classes = createVisitor.VisitStatements(tree);

    // we choose our code generator...
    ICodeGenerator generator;

    // ...depending on the command line argument
    if(args.Count() &gt; 1 &amp;&amp; args[1] == &#34;kotlin&#34;)
        generator = new KotlinCodeGenerator();
    else
        generator = new CSharpCodeGenerator();
    
    Console.WriteLine(generator.ToSourceCode(&#34;SQLDataTypes&#34;, classes));
}</pre>
<p>The comments are self-explanatory. After our standard code to setup <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">ANTLR </a>and parse the input, we employ our <code>CreateVisitor</code>. We use the visitor to create table statements and to generate an internal representation of them. Then we use this representation to generate a source code file in our chosen language. In our example we choose to generate either in Kotlin or C#, to show how easy it can be to work with our SQL data once you parse it.</p>
<p>This is the simple overall structure; we can now move on the individual parts.</p>
<h2>Visiting the Statements</h2>
<p>Let’s start by looking at the general organization of our visitor.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class CreateVisitor
{
    public  List&lt;ClassDescriptor&gt; VisitStatements(StatementsContext context)    
    {
        List&lt;ClassDescriptor&gt; tables = new List&lt;ClassDescriptor&gt;();
        
        foreach(var statement in context.statement())
        {
            tables.Add(VisitStmt(statement));
        }

        return tables;
    }

    public ClassDescriptor VisitStmt(StatementContext context)
    {                      
        return VisitCreateStmt(context.createStmt());
    }

    public ClassDescriptor VisitCreateStmt(CreateStmtContext context)
    {
        ClassDescriptor table = new ClassDescriptor();

        table.Name = context.tableName.NAME().GetText();
        table.Fields = new List&lt;FieldDescriptor&gt;();

        foreach (var el in context.element())
        {
            if(el.definition() != null)
            {
                table.Fields.Add(VisitDefinition(el.definition()));
            }                 
        }        

        return table;
    }
	
    [..]</pre>
<p>The first thing we notice is that we do not need to use the standard base visitor that can be created for us by ANTLR. Our visitor uses just our code. We do not need to use the base visitor, because of the structure of a SQL file and because we know exactly what we need to visit. We can completely ignore everything that is not a create statement because every statement in our SQL files is a top-level element. It is not like statements in your average programming language, that can be nested inside a code block, function definitions, etc. Also, the structure of create statements is simple, so we can visit everything ourselves.</p>
<p>In short, all we need to do is:</p>
<ul><li>to visit the <code>statements</code> node</li><li>then to visit each <code>statement</code> node (we ignore the <code>ignore</code> nodes) and to select the <code>createStmt</code> node</li><li>visiting the <code>createStmt</code> nodes, we pick only the <code>definition</code> nodes (we ignore the <code>ignorable</code> nodes) to get all the columns definition</li></ul>
<h2>Translating Types from SQL to Your Language</h2>
<p>Inside the <code>VisitDefinition</code> method we deal with the only real complication of this visitor: handling types.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="37,38" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">        public FieldDescriptor VisitDefinition(DefinitionContext context)
	{
		string name = context.name().NAME().GetText();
		TypeDescriptor type;
		
		switch(context.type().GetType().Name)
		{
			case &#34;IntegerTypeContext&#34;:
				type = VisitIntegerType(context.type() as IntegerTypeContext);
				break;
			case &#34;SmallIntegerTypeContext&#34;:
				type = VisitSmallIntegerType(context.type() as SmallIntegerTypeContext);
				break;
			case &#34;VarcharTypeContext&#34;:
				type = VisitVarcharType(context.type() as VarcharTypeContext);
				break;
			case &#34;TimestampTypeContext&#34;:
				type = VisitTimestampType(context.type() as TimestampTypeContext);
				break;
			case &#34;TextTypeContext&#34;:
				type = VisitTextType(context.type() as TextTypeContext);
				break;               
			case &#34;DecimalTypeContext&#34;:
				type = VisitDecimalType(context.type() as DecimalTypeContext);
				break;  
			case &#34;CharTypeContext&#34;:
				type = VisitCharType(context.type() as CharTypeContext);
				break; 
			case &#34;BlobTypeContext&#34;:
				type = VisitBlobType(context.type() as BlobTypeContext);
				break; 
			default:
				type = null;
				break;
		}
		
		if(context.nullability() != null &amp;&amp; context.nullability().NOT() != null)
			type.Nullability = false;
	
		return new FieldDescriptor(name, type);
	}</pre>
<p>The issue is that we need to identify each type and then translate it in a way that is compatible with a programming language. In fact, SQL data types and programming language data types can be different. For example, SQL has types for variable and fixed size char array, this is less relevant in programming languages.</p>
<p>We already have done the work to easily identify each type by creating a label for each option of the <code>type</code> grammar rule. Now, we just need to use a different method to visit each node correctly.</p>
<p>Before seeing the examples of <code>VisitIntegerType</code> and <code>VisitSmallIntegerType</code>, let’s notice a couple of things. First, we deal with nullability of types only once, on lines 37-38. Second, we are only dealing with some types, the ones used in our example SQL files.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">        private TypeDescriptor VisitSmallIntegerType(SmallIntegerTypeContext context)
        {
           if(context.UNSIGNED() != null)
                return new IntegerTypeDescriptor(2, true);
            else
                return new IntegerTypeDescriptor(2);
        }

        private TypeDescriptor VisitIntegerType(IntegerTypeContext context)
        {
            if(context.UNSIGNED() != null)
                return new IntegerTypeDescriptor(4, true);
            else
                return new IntegerTypeDescriptor(4);
        }</pre>
<p>These two methods are representative of the little effort we have to do. Each method returns a <code>TypeDescriptor</code> specific for each type.</p>
<p>The methods are simple, but different because each type is different. In the case of integer types we need to check whether the type is unsigned or not. We use only one <code>IntegerTypeDescriptor</code> for all integer types. This is simply because they can be described in the same way: from our point of view, the only difference between integer types is the number of bytes they need.</p>
<p>The <code>TypeDescriptor</code> classes themselves are also fairly trivial. They just are a series of classes that contain specific information for each type.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public enum BaseType
{
    Integer,
    Floating,    
    Decimal,           
    Text,
    Binary,
    ArrayCharacters,        
    Year,
    DateTime
}

public class TypeDescriptor
{
    public BaseType Type { get; protected set; }
    public bool Nullability { get; set; } = true;
}

public class IntegerTypeDescriptor : TypeDescriptor
{
    public int Bytes { get; private set; }
    public bool Unsigned { get; private set;  }

    public IntegerTypeDescriptor(int bytes, bool unsigned = false)
    {
        Type = BaseType.Integer;
        Bytes = bytes;
        Unsigned = unsigned;
    }
}</pre>
<p>You can see the rest on the companion repository.</p>
<h2>Generating Code</h2>
<p>We have a custom representation of our original SQL code: a description of all the tables suited for our needs. Now we can generate the corresponding source code. We are going to generate the code in multiple languages: C# and Kotlin. We do this to show how easy it is to do anything once we get the information out of SQL and because there are different limitations in the two languages.</p>
<h3>Generating Code in C#</h3>
<p>Let’s start with seeing C#. We have only one public method: <code>ToSourceCode</code>, which accepts a namespace and a series of classes/tables definition.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="23-24, 32-33" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class CSharpCodeGenerator : ICodeGenerator
{
    public string ToSourceCode(string idNamespace, List&lt;ClassDescriptor&gt; classes)
    {
        StringBuilder sourceCode = new StringBuilder();

        // opening namespace
        sourceCode.AppendLine($&#34;namespace {idNamespace}&#34;);
        sourceCode.AppendLine(&#34;{&#34;);
        
        foreach(var c in classes)
        {
            sourceCode.AppendLine($&#34;tpublic class {c.Name}&#34;);
            sourceCode.AppendLine(&#34;\t{&#34;);
            
            foreach(var f in c.Fields)
            {
                switch(f.Type.Type)
                {
                    case BaseType.Integer:
                        sourceCode.AppendLine($&#34;\t\tpublic {GenerateInt(f.Type as IntegerTypeDescriptor)} {f.Name} {{ get; set; }}&#34;);
                        break;
                    case BaseType.Text:
                        sourceCode.AppendLine($&#34;\t\tpublic string {f.Name} {{ get; set; }}&#34;);
                        break;
                    case BaseType.ArrayCharacters:
                        sourceCode.AppendLine($&#34;\t\tpublic {GenerateCharArray(f.Name, f.Type as CharArrayTypeDescriptor)}&#34;);
                        break;
                    case BaseType.DateTime:
                        sourceCode.AppendLine($&#34;\t\tpublic DateTime {f.Name} {{ get; set; }}&#34;);
                        break;                            
                    case BaseType.Decimal:                        
                        sourceCode.AppendLine($&#34;\t\tpublic decimal {f.Name} {{ get; set; }}&#34;);
                        break;
                    case BaseType.Binary:
                        sourceCode.AppendLine($&#34;\t\tpublic bytes[] {f.Name} {{ get; set; }}&#34;);
                        break;
                }
            }
            
            sourceCode.AppendLine(&#34;\t}&#34;);
            sourceCode.AppendLine();
        }

        // closing namespace            
        sourceCode.AppendLine(&#34;}&#34;);

        return sourceCode.ToString();
    }

    [..]</pre>
<p>This method takes care of generating the whole new source code file. It handles the enclosing namespace (necessary for C# files) and the whole class.</p>
<p>We transform columns into properties. These are the obvious choice because it is easy to anticipate that we would need to transform any data coming from SQL in a different format to handle it in our programming language. For example, dates would be different. We would also need to enforce fixed-size arrays in some way. That is because programming languages usually do not have a well-defined way to handle an input too large or too small. Instead databases can automatically do things like padding an input that is too short with spaces.</p>
<p>There are generally three cases:</p>
<ul><li>the type has a perfect correspondence (e.g. lines 23-24 <code>TEXT</code> becomes a <code>String</code>). So we just write the property directly.</li><li>the type has only a partial, but unambiguous, correspondence (e.g. lines 32-33 DECIMAL becomes <code>Decimal</code>, but the SQL and C# type behave differently). For example, a SQL decimal allows us to specify a precision, to set just how many digits it can hold. In C# you cannot do that. Normally we would need to take care of this difference, in our example, we just ignore the issue</li><li>the type has multiple correspondences (e.g., lines 20-21 <code>INT</code>, <code>SMALLINT</code> become <code>int</code>, <code>short</code>), so we handle them with a method</li></ul>
<p>For the third case, we are going to see the integer example.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">        private string GenerateInt(IntegerTypeDescriptor descriptor)
        {
            StringBuilder intType = new StringBuilder();

            // we ignore nullability, because it is not well supported for all C# types
            if(descriptor.Unsigned == true)
                intType.Append(&#34;u&#34;);

            switch(descriptor.Bytes)
            {
                case 2:
                    intType.Append(&#34;short&#34;);
                    break;
                case 4:
                    intType.Append(&#34;int&#34;);
                    break;
                case 8:
                    intType.Append(&#34;long&#34;);
                    break;
            }
           
            return intType.ToString();
        }</pre>
<p>We can find a perfect correspondence between each integer type in SQL and C#. Since integer types are all represented internally the same way, it all depends on the number of bytes used for each of them. Depending on how many bytes are stored in our instance of <code>IntegerTypeDescriptor</code>, we generate the proper C# type.</p>
<p>The only issue is with C# itself: it does not have perfect support for nullability. Until <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#nullable-reference-types">C# 8.0</a> reference types could be nullable by default, so it would be fairly inconsistent to work with nullable types both in our code and any third-party code.</p>
<p>On the other hand, we can easily deal with unsigned integers, we just need to prepend a <code>u</code>, to use unsigned types.</p>
<h3>Generating Code in Kotlin</h3>
<p>Generating the code for Kotlin is very similar.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class KotlinCodeGenerator : ICodeGenerator
{
        public string ToSourceCode(string idNamespace, List&lt;ClassDescriptor&gt; classes)
        {
            StringBuilder sourceCode = new StringBuilder();

            // declaring package
            if(!String.IsNullOrEmpty(idNamespace))
                sourceCode.AppendLine($&#34;package {idNamespace}&#34;);   

            // adding imports
            sourceCode.AppendLine();
            sourceCode.AppendLine(&#34;import java.time.LocalDateTime&#34;);
            sourceCode.AppendLine(&#34;import java.math.BigDecimal&#34;);            
            sourceCode.AppendLine();
            
            foreach(var c in classes)
            {
                sourceCode.Append($&#34;data class {c.Name}(&#34;);
                
                foreach(var f in c.Fields)
                {
                    switch(f.Type.Type)
                    {
                        case BaseType.Integer:
                            sourceCode.Append($&#34;var {f.Name}: {GenerateInt(f.Type as IntegerTypeDescriptor)}&#34;);
                            break;
                        case BaseType.Text:
                            sourceCode.Append($&#34;var {f.Name}: String&#34;);
                            break;
                        case BaseType.ArrayCharacters:
                            sourceCode.Append($&#34;var {f.Name}: {GenerateCharArray(f.Type as CharArrayTypeDescriptor)}&#34;);
                            break;
                        case BaseType.DateTime:
                            sourceCode.Append($&#34;var {f.Name}: LocalDateTime&#34;);
                            break;                            
                        case BaseType.Decimal:                        
                            sourceCode.Append($&#34;var {f.Name}: BigDecimal&#34;);
                            break;
                        case BaseType.Binary:
                            sourceCode.Append($&#34;var {f.Name}: ByteArray&#34;);
                            break;
                    }                    
                    
                    if(f != c.Fields.Last())
                        sourceCode.Append(&#34;, &#34;);
                }
                
                sourceCode.AppendLine(&#34;)&#34;);
                sourceCode.AppendLine(&#34;&#34;);
            }

            return sourceCode.ToString();
        }</pre>
<p>There are no structural differences. The only variations depend on the differences between the languages themselves. For instance, the equivalent of a namespace, i.e., packages are not required in Kotlin. We can also use the special <a href="https://superkotlin.com/kotlin-mega-tutorial/#data-classes">data classes</a> in Kotlin to quickly define a class with its properties directly in the default constructor.</p>
<p>On the other hand, we need to import some Java packages, because Kotlin does not directly have classes for DateTime types. Since Kotlin can run in different environments (i.e. JVM with Java support, JavaScript, native with C++ support), we should probably find a way to support all of these environments. In a normal situation, we would probably create a runtime in pure Kotlin with these custom types (i.e., KotlinDateTime) and then add support for each platform in separate files. This way we could just generate one Kotlin file for all environments. This would be overkill for this example, so we just consider Kotlin when run on the JVM.</p>
<pre data-enlighter-language="csharp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">	private string GenerateInt(IntegerTypeDescriptor descriptor)
        {
            StringBuilder intType = new StringBuilder();            

            switch(descriptor.Bytes)
            {
                case 2:
                    intType.Append(&#34;Short&#34;);
                    break;
                case 4:
                    intType.Append(&#34;Int&#34;);
                    break;
                case 8:
                    intType.Append(&#34;Long&#34;);
                    break;
            }

            // we ignore unsigned, because it is not well supported in C#
            if(descriptor.Nullability == true)
                intType.Append(&#34;?&#34;);
           
            return intType.ToString();
        }</pre>
<p>We can also see that the methods to generate integral types are very similar in both C# and Kotlin. The difference is that with Kotlin nullability has always been supported, while support for unsigned integer is still experimental for the current version.</p>
<h2>Conclusions</h2>
<p>In this article, we have seen how to parse SQL. In general, our advice is to:</p>
<ol><li>Consider if you can use existing tools or libraries to process SQL code. Some of them even support multiple SQL-dialects or multiple programming languages. If you can use any of them for your needs they should be your first option</li><li>If you want to build a solution in-house you may consider starting from the few <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">ANTLR grammars</a> available for the major SQL databases. They can really help you get started in parsing SQL</li><li>If you are stuck with a less common SQL database you might be in trouble. Parsing SQL from scratch it is going to be hard work: the language has a fairly simple structure, but it is large, it has many variations and in some cases even procedural extensions. In this article, we have seen a few tricks to start parsing even with a partial grammar. This can be a good way if you need to parse only small parts of the language</li></ol>
<p>If none of these options work for you, and you need some commercial option supporting you in building a solution for your needs, we at <a href="https://strumenta.com/">Strumenta</a> may be able to help. For example, through our commercial <a href="https://strumenta.com/pl-sql-parser">PL/SQL parser</a>.</p>
<h2>Read more: </h2>
<p>If you want to understand how to use ANTLR you can read our article <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank" rel="noreferrer noopener">The ANTLR Mega Tutorial</a>.</p>

<div>
<div>
<h3>Parsing: Tools and Libraries</h3>
<div>
<p><span>
<img src="https://convertkit.s3.amazonaws.com/subscription_forms/images/005/053/473/standard/Parsing_-_Tools_and_Libraries_-_Cover.png?1500822509"/>
</span></p><p>Receive the guide to your inbox to read it on all your devices when you have time. Learn about parsing in Java, Python, C#, and JavaScript</p>
</div>
</div>
<div>


<form id="ck_subscribe_form" action="https://api.convertkit.com/landing_pages/241646/subscribe" data-remote="true">



<div>

</div>
<p><label for="ck_firstNameField">First Name</label>

</p>
<p><label for="ck_emailField">Email Address</label>

</p>
<p><label for="ck_captcha2_h">We use this field to detect spam bots. If you fill this in, you will be marked as a spammer.</label>

</p>


<span>
We won&#39;t send you spam. Unsubscribe at any time.
<a href="https://convertkit.com/features/forms?utm_campaign=poweredby&amp;utm_content=form&amp;utm_medium=referral&amp;utm_source=dynamic">Powered by ConvertKit</a>
</span>
</form>
</div>
</div>

</div></div>
  </body>
</html>
