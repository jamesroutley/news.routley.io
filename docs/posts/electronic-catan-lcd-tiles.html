<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://coliniuliano.ca/projects/catan-tiles/">Original</a>
    <h1>Electronic Catan LCD Tiles</h1>
    
    <div id="readability-page-1" class="page"><div><header>
  <img src="https://coliniuliano.ca/assets/headshot.jpg" alt="This guyyyy"/>
  
  <hr/>
  
</header>

      <main>
          <article class="page">
            
            <span>Completed</span>
            <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/four-tiles.png" alt="Electronic Catan LCD Tiles"/>
            <p>A collection of hexagon tiles that magnetically snap together to create a Settlers of Catan board of any shape or size. Each tile features a large round LCD and a custom magnetic pogo connector on each edge. Linking up a bunch of tiles creates a position-aware partial mesh network.
            </p>
            

<h2 id="features">Features</h2>

<ul>
  <li>RP2040 microcontroller streams scanlines from flash with no framebuffer</li>
  <li>2.1” 480x480 16-bit RGB round LCD with ST7701S driver (not SPI, only RGB)</li>
  <li>Tiles snap together with custom bidirectional magnetic pogo pin connectors</li>
  <li>Custom hexagon PCB using EasyEDA</li>
  <li>Hexagon enclosure 3D printed in 8000 resin</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This is a project I’ve had in a sketch book for many years, but until recently, round LCDs were too expensive in an appropriate size for a Catan tile. In late 2021 I was looking through some old notes and the inspriation stuck again. I searched around and surprisingly didn’t see anything quite like this, so I decided to build it myself as a fun covid project. I sourced some round LCDs for a decent price but they required an RGB driver and didn’t have a framebuffer. With the chip shortage of 2021-22, the only microcontroller that could drive the RGB interface fast enough for under $5 was the RP2040, so the design requirements of this project practically wrote themselves. The tiles need to know which side their neighbouring tiles are on, so each edge needs to be individually addressed instead of just using a giant mesh network. Between the LCD’s 16-bit interface + control signals, and the 6 edges for networking, this project uses every pin of the RP2040 and both cores to stream images from flash on-the-fly.</p>

<h2 id="hardware">Hardware</h2>

<p>There is no schematic for this project since there were very few components and it was easy enough to just draw a PCB.</p>

<p><a href="https://coliniuliano.ca/assets/catan-tiles/breadboard-proto.jpg" data-lightbox="catan-tiles" data-title="First LCD experiments on the breadboard">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/breadboard-proto.jpg"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/tile-pcb.jpg" data-lightbox="catan-tiles" data-title="An assembled hex PCB">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/tile-pcb.jpg"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/programming-jig.jpg" data-lightbox="catan-tiles" data-title="Pogo pin programming jig with Picoprobe">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/programming-jig.jpg"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/programming.jpg" data-lightbox="catan-tiles" data-title="Initial firmware drawing from flash">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/programming.jpg"/>
  </a>
</p>

<h3 id="host-device">Host Device</h3>

<p>A host device injects power and controls the mesh network of tiles. It identifies the shape of the board by communicating with each tile independently through a broadcast mechanism, then generates a board in memory and broadcasts to each tile what resource and number it needs to become. I’ve experimented with using an ESP32 as the host so that it can include Wifi and Bluetooth as a way of configuring board parameters. In the interest of time, I didn’t go down the rabbit hole of properly generating a legal game board, so the host randomly assigns a resource and number to each tile for this prototype.</p>

<h3 id="magnetic-pogo-connector">Magnetic Pogo Connector</h3>

<p>While there are magnetic pogo pin connectors all over AliExpress, nothing really fit the bill for this project. Each tile needs six connectors, and a game needs at least 19 tiles, so cost is definitely a factor here. Each tile has six edges that need to distribute power, ground, and at least one data signal. There are no master or slave tiles, so the connectors need to be bidirectional so that a male pogo pin can mate with a female pin receiver. This leads to having two symmetrical sets of 3 pins per edge with power on the outer two, data in the next two, and ground in the center two pins.</p>

<p><a href="https://coliniuliano.ca/assets/catan-tiles/pogo-closeup.jpg" data-lightbox="catan-tiles" data-title="Connectors have a set of pogo pins and a set of female pins">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/pogo-closeup.jpg"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/pogo-snap-empty.jpg" data-lightbox="catan-tiles" data-title="Bidirectional connectors create a mesh of hexagon tiles">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/pogo-snap-empty.jpg"/>
  </a>
</p>

<h2 id="firmware">Firmware</h2>

<h3 id="scanline-video">Scanline Video</h3>

<p>The video scanline generation is very heavily based on the pico-playground <a href="https://github.com/raspberrypi/pico-playground/tree/master/scanvideo/flash_stream">flash-stream example</a>. Since the RP2040 does not have enough memory for a frame buffer, one whole core is used to generate scanlines on the fly. The renderer draws a background, then an alpha blended center marker, then the tile number on top.</p>

<h2 id="networking">Networking</h2>

<p>One of the most difficult parts of this project was the pseudo-mesh network protocol. In the game of Catan, two tiles that touch can not both have a “high” number like 6 or 8. In a normal mesh network, there is no way to determine the location of a node or its neighbours - there is just a single shared communication line and devices negotiate how they can access it. In order to generate a proper game board, there must be a way to determine the location of tiles relative to each other. To enable a host to determine the location of a tile and the overall board shape, rather than having one shared communication line, each side of each tile is separately addressable - so rather than one giant mesh network, a pseudo-mesh network is formed by a whole bunch of individual one-to-one connections. This way, each tile is able to detect its neighbours positionally and relay that information back to the host.</p>

<h3 id="onewire">OneWire</h3>

<p>At the lowest level, the tiles communicate over a single data line using a modified OneWire protocol. Due to pin restrictions on the RP2040, with each tile edge requriing a separate data line, the communication between each pair of tiles is half-duplex. Rather than include external pull-up resistors for the communication lines, the protocol is just slowed down so that the internal resistors have a long enough time to return the line to its idle state.</p>

<h3 id="pseudo-mesh-protocol">Pseudo-Mesh Protocol</h3>

<p>There are many considerations when designing a network. For simplicity and reliability, data is relayed through a <a href="https://en.wikipedia.org/wiki/Flooding_(computer_networking)">flooding broadcast mechanism</a> where each tile has a unique address. The unique address comes from the flash chip itself so there will never be any possible contention. Using a broadcast mechanism (as opposed to a routing mechanism) allows traffic to flow through the network of tiles without any consideration for whether there is an optimal or broken path between tiles. If a tile is abruptly disconnected for example, it should have no impact on the overall network and messages will continue to flow. A broadcast mechanism has its own downfalls too, like <a href="https://en.wikipedia.org/wiki/Broadcast_storm">broadcast storms</a>.</p>

<p>There are two types of message that can be sent through the network: a direct message does not include an address and is meant for the tile that receives it; and a broadcast message which is meant for the tile with a matching address. Tiles receiving a broadcast message will listen for a matching address, and if the address does not match, it will then begin to proxy the message on its other interfaces, creating a mesh network of sorts.</p>

<p>The basic protocol works as follows:</p>
<ul>
  <li>The host device receives a trigger to probe/configure the board (typically a button press)</li>
  <li>The host device (H) sends a direct message to the tile it is attached to (T1), asking for that tile’s ID</li>
  <li>T1 responds directly to the host H with its tile ID</li>
  <li>Host H is now aware of T1 by its ID</li>
  <li>Host H broadcasts a message to T1 to perform a “neighbour check”</li>
  <li>T1 sends a direct message to each of its 5 remaining interfaces (T2-T6), asking for those tiles’ IDs</li>
  <li>T2-T6 respond directly to T1 with their tile IDs</li>
  <li>T1 is now aware of the tiles that surround it and which interface (side) they are physically on</li>
  <li>T1 broadcasts a response to H describing the tiles surrounding it</li>
  <li>H is now aware of T2-T6 and their position relative to T1</li>
  <li>The cycle continues, host H broadcasts a message to T2 to perform a “neighbour check”</li>
  <li>Once the host H has identified all the tiles, it generates a board</li>
  <li>Once a board is configured, host H broadcasts a message to each tile and tells it what resource and number to display</li>
</ul>

<h2 id="results">Results</h2>

<p>This project went surprisingly smooth! There were many learning opportunities and struggles but the project was generally fun from start to “finish”. The tiles work really well and the communication is fairly reliable. I need to work on the mesh networking aspect before the tiles can generate a proper game board, but that’s a task for another time since I’ve accomplished as much as I care to for now.</p>

<p><a href="https://coliniuliano.ca/assets/catan-tiles/single-tile.jpg" data-lightbox="catan-tiles" data-title="A completed tile without a vinyl cover sticker">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/single-tile.jpg"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/four-tiles.png" data-lightbox="catan-tiles" data-title="Four tiles forming a random board">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/four-tiles.png"/>
  </a>
  <a href="https://coliniuliano.ca/assets/catan-tiles/final.jpg" data-lightbox="catan-tiles" data-title="The final product in all its glory">
    <img src="https://coliniuliano.ca/assets/catan-tiles/thumbs/final.jpg"/>
  </a>
</p>

<h3 id="version-2">Version 2</h3>

<p>I likely won’t bother with a version two since this was just for fun, but heres a list of some things I’d like to mess with if I do:</p>
<ul>
  <li>Mesh network protocol: the communication is fairly reliable, but the code is sloppy and clobbers interfaces during broadcasts (ex: doesn’t care if an interface is receiving/does not own the bus, it will try to broadcast anyway)</li>
  <li>Board generation: the tiles are just randomly generated right now; configuring a board with options like water, gold, etc is important</li>
  <li>Animated tile art: with a 16MB flash, it should be possible to store many images and rendering one per couple frames is trivial</li>
  <li>Compression: since the tiles are circular, the 480x480 background textures could be optimized to take up less space since many pixels are never drawn</li>
  <li>Dynamic refresh rate: some lines like the very center take longer to draw since there are more pixels to alpha blend, which reduces the frame rate; since the LCD hardware uses a DE pin for framing, a fixed frame rate is not necessary scanlines could take as long as they need</li>
  <li>Sprites, layers, optimizations: the center marker is crudely alpha blended and has a crude transparent drawing over top, both of which are very wasteful of cycles; another PIO can be used to draw sprites or the center marker, and there are certainly optimizations to be made</li>
</ul>

          </article>
      </main>
    </div></div>
  </body>
</html>
