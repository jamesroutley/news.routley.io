<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/WerWolv/ImHex">Original</a>
    <h1>ImHex – A Hex Editor</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Hello! The other day we talked about <a href="https://jvns.ca/blog/2022/07/20/pseudoterminals/">what happened when you press a key in your terminal</a>.</p>
<p>As a followup, I thought it might be fun to implement a program that’s like a
tiny ssh server, but without the security. You can find it <a href="https://github.com/jvns/tiny-remote-login/blob/main/server.go">on github here</a>, and I’ll explain how it works in this blog post.</p>
<h3 id="the-goal-ssh-to-a-remote-computer">the goal: “ssh” to a remote computer</h3>
<p>Our goal is to be able to login to a remote computer and run commands, like you
do with SSH or telnet.</p>
<p>The biggest difference between this program and SSH is that there’s literally
no security (not even a password) – anyone who can make a TCP connection to
the server can get a shell and run commands.</p>
<p>Obviously this is not a useful program in real life, but our goal is to learn a
little more about how terminals works, not to write a useful program.</p>
<p>(I will run a version of it on the public internet for the next week though,
you can see how to connect to it at the end of this blog post)</p>
<h3 id="let-s-start-with-the-server">let’s start with the server!</h3>
<p>We’re also going to write a client, but the server is the interesting part, so
let’s start there. We’re going to write a server that listens on a TCP port (I
picked 7777) and creates remote terminals for any client that connects to it to
use.</p>
<p>When the server receives a new connection it needs to:</p>
<ol>
<li>create a pseudoterminal for the client to use</li>
<li>start a <code>bash</code> shell process for the client to use</li>
<li>connect <code>bash</code> to the pseudoterminal</li>
<li>continuously copy information back and forth between the TCP connection and
the pseudoterminal</li>
</ol>
<p>I just said the word “pseudoterminal” a lot, so let’s talk about what that
means.</p>
<h3 id="what-s-a-pseudoterminal">what’s a pseudoterminal?</h3>
<p>Okay, what the heck is a pseudoterminal?</p>
<p>A pseudoterminal is a lot like a bidirectional pipe or a socket – you have two
ends, and they can both send and receive information. You can read more about
the information being sent and received in <a href="https://jvns.ca/blog/2022/07/20/pseudoterminals/">what happens if you press a key in your terminal</a></p>
<p>Basically the idea is that on one end, we have a TCP connection, and on the
other end, we have a <code>bash</code> shell. So we need to hook one part of the
pseudoterminal up to the TCP connection and the other end to bash.</p>
<p>The two parts of the pseudoterminal are called:</p>
<ul>
<li>the “pseudoterminal master”. This is the end we’re going to hook up to the TCP connection.</li>
<li>the “slave pseudoterminal device”. We’re going to set our bash shell’s <code>stdout</code>, <code>stderr</code>, and <code>stdin</code> to this.</li>
</ul>
<p>Once they’re conected, we can communicate with <code>bash</code> over our TCP connection
and we’ll have a remote shell!</p>
<h3 id="why-do-we-need-this-pseudoterminal-thing-anyway">why do we need this “pseudoterminal” thing anyway?</h3>
<p>You might be wondering – Julia, if a pseudoterminal is kind of like a socket,
why can’t we just set our bash shell’s <code>stdout</code> / <code>stderr</code> / <code>stdin</code> to the TCP
socket?</p>
<p>And you can! We could write a TCP connection handler like this that does exactly that, it’s not a lot of code (<a href="https://github.com/jvns/tiny-remote-login/blob/main/server-notty.go">server-notty.go</a>).</p>
<pre><code>
func handle(conn net.Conn) {
	tty, _ := conn.(*net.TCPConn).File()
	// start bash with tcp connection as stdin/stdout/stderr
	cmd := exec.Command(&#34;bash&#34;)
	cmd.Stdin = tty
	cmd.Stdout = tty
	cmd.Stderr = tty
	cmd.Start()
}

</code></pre>
<p>It even kind of works – if we connect to it with <code>nc localhost 7778</code>, we can
run commands and look at their output.</p>
<p>But there are a few problems. I’m not going to list all of them, just two.</p>
<p><strong>problem 1: Ctrl + C doesn’t work</strong></p>
<p>The way Ctrl + C works in a remote login session is</p>
<ul>
<li>you press ctrl + c</li>
<li>That gets translated to <code>0x03</code> and sent through the TCP connection</li>
<li>The terminal receives it</li>
<li>the Linux kernel on the other end notes “hey, that was a Ctrl + C!”</li>
<li>Linux sends a <code>SIGINT</code> to the appropriate process (more on what the “appropriate process” is exactly later)</li>
</ul>
<p>If the “terminal” is just a TCP connection, this doesn’t work, because when you
send <code>0x04</code> to a TCP connection, Linux won’t magically send <code>SIGINT</code> to any
process.</p>
<p><strong>problem 2: <code>top</code> doesn’t work</strong></p>
<p>When I try to run <code>top</code> in this shell, I get the error message <code>top: failed tty get</code>. If we strace it, we see this system call:</p>
<pre><code>ioctl(2, TCGETS, 0x7ffec4e68d60)        = -1 ENOTTY (Inappropriate ioctl for device)
</code></pre>
<p>So <code>top</code> is running an <code>ioctl</code> on its output file descriptor (2) to get some
information about the terminal. But Linux is like “hey, this isn’t a terminal!”
and returns an error.</p>
<p>There are a bunch of other things that go wrong, but hopefully at this point
you’re convinced that we actually need to set bash’s stdout/stderr to be a
terminal, not some other thing like a socket.</p>
<p>So let’s start looking at the server code and see what creating a
pseudoterminal actually looks like.</p>
<h3 id="step-1-create-a-pseudoterminal">step 1: create a pseudoterminal</h3>
<p>Here’s some Go code to create a pseudoterminal on Linux. This is copied from <a href="https://github.com/creack/pty/blob/7de28cee0d53510e719c1aeb1850af0fa647c343/pty_linux.go">github.com/creack/pty</a>,
but I removed some of the error handling to make the logic a bit easier to follow:</p>
<pre><code>pty, _ := os.OpenFile(&#34;/dev/ptmx&#34;, os.O_RDWR, 0)
sname := ptsname(p)
unlockpt(p)
tty, _ := os.OpenFile(sname, os.O_RDWR|syscall.O_NOCTTY, 0)
</code></pre>
<p>In English, what we’re doing is:</p>
<ul>
<li>open <code>/dev/ptmx</code> to get the “pseudoterminal master” Again, that’s the part we’re going to hook up to the TCP connection</li>
<li>get the filename of the “slave pseudoterminal device”, which is going to be <code>/dev/pts/13</code> or something.</li>
<li>“unlock” the pseudoterminal so that we can use it. I have no idea what the point of this is (why is it locked to begin with?) but you have to do it for some reason</li>
<li>open <code>/dev/pts/13</code> (or whatever number we got from <code>ptsname</code>) to get the “slave pseudoterminal device”</li>
</ul>
<p>What do those <code>ptsname</code> and <code>unlockpt</code> functions do? They just make some
<code>ioctl</code> system calls to the Linux kernel. All of the communication with the
Linux kernel about terminals seems to be through various <code>ioctl</code> system calls.</p>
<p>Here’s the code, it’s pretty short: (again, I just copied it from <a href="https://github.com/creack/pty/blob/7de28cee0d53510e719c1aeb1850af0fa647c343/pty_linux.go#L41-L54">creack/pty</a>)</p>
<pre><code>func ptsname(f *os.File) string {
	var n uint32
	ioctl(f.Fd(), syscall.TIOCGPTN, uintptr(unsafe.Pointer(&amp;n)))
	return &#34;/dev/pts/&#34; + strconv.Itoa(int(n))
}

func unlockpt(f *os.File) {
	var u int32
	// use TIOCSPTLCK with a pointer to zero to clear the lock
	ioctl(f.Fd(), syscall.TIOCSPTLCK, uintptr(unsafe.Pointer(&amp;u)))
}
</code></pre>
<h3 id="step-2-hook-the-pseudoterminal-up-to-bash">step 2: hook the pseudoterminal up to <code>bash</code></h3>
<p>The next thing we have to do is connect the pseudoterminal to <code>bash</code>. Luckily,
that’s really easy – here’s the Go code for it! We just need to start a new
process and set the stdin, stdout, and stderr to <code>tty</code>.</p>
<pre><code>cmd := exec.Command(&#34;bash&#34;)
cmd.Stdin = tty
cmd.Stdout = tty
cmd.Stderr = tty
cmd.SysProcAttr = &amp;syscall.SysProcAttr{
  Setsid: true,
}
cmd.Start()
</code></pre>
<p>Easy! Though – why do we need this <code>Setsid: true</code> thing, you might ask? Well,
I tried commenting out that code to see what went wrong. It turns out that what
goes wrong is – Ctrl + C doesn’t work anymore!</p>
<p><code>Setsid: true</code> creates a new <strong>session</strong> for the new bash process. But why does
that make <code>Ctrl + C</code> work? How does Linux know which process to send <code>SIGINT</code>
to when you press <code>Ctrl + C</code>, and what does that have to do with sessions?</p>
<h3 id="how-does-linux-know-which-process-to-send-ctrl-c-to">how does Linux know which process to send Ctrl + C to?</h3>
<p>I found this pretty confusing, so I reached for my favourite book for learning
about this kind of thing: <a href="https://man7.org/tlpi/">the linux programming interface</a>, specifically chapter 34 on process groups
and sessions.</p>
<p>That chapter contains a few key facts: (#3, #4, and #5 are direct quotes from the book)</p>
<ol>
<li>Every process has a <strong>session id</strong> and a <strong>process group id</strong> (which may or may not be the same as its PID)</li>
<li>A session is made up of multiple process groups</li>
<li>All of the processes in a session share a single controlling terminal.</li>
<li>A terminal may be the controlling terminal of at most one session.</li>
<li>At any point in time, one of the process groups in a session is the
<strong>foreground process group</strong> for the terminal, and the others are background
process groups.</li>
<li>When you press <code>Ctrl+C</code> in a terminal, SIGINT gets sent to all the processes in the foreground process group</li>
</ol>
<p>What’s a process group? Well, my understanding is that:</p>
<ul>
<li>processes in the same pipe <code>x | y | z</code> are in the same process group</li>
<li>processes you start on the same shell line (<code>x &amp;&amp; y &amp;&amp; z</code>) are in the same process group</li>
<li>child processes are by default in the same process group, unless you explicitly decide otherwise</li>
</ul>
<p>I didn’t know most of this (I had no idea processes had a session ID!) so this
was kind of a lot to absorb. I tried to draw a sketchy ASCII art diagram of the
situation</p>
<pre><code>(maybe)  terminal --- session --- process group --- process
                               |                 |- process
                               |                 |- process
                               |- process group 
                               |
                               |- process group 
</code></pre>
<p>So when we press Ctrl+C in a terminal, here’s what I think happens:</p>
<ul>
<li><code>\x04</code> gets written to the “pseudotermimal master” of a terminal</li>
<li>Linux finds the <strong>session</strong> for that terminal (if it exists)</li>
<li>Linux find the <strong>foreground process group</strong> for that session</li>
<li>Linux sends <code>SIGINT</code></li>
</ul>
<p>If we don’t create a new session for our new bash process, our new pseudoterminal
actually won’t have <strong>any</strong> session associated with it, so nothing happens when
we press <code>Ctrl+C</code>. But if we do create a new session, then the new
pseudoterminal will have the new session associated with it.</p>
<h3 id="how-to-get-a-list-of-all-your-sessions">how to get a list of all your sessions</h3>
<p>As a quick aside, if you want to get a list of all the sessions on your Linux
machine, grouped by session, you can run:</p>
<pre><code>$ ps -eo user,pid,pgid,sess,cmd | sort -k3
</code></pre>
<p>This includes the PID, process gruoup ID, and session ID. As an example of the output, here are the two processes in the pipeline:</p>
<pre><code>bork       58080   58080   57922 ps -eo user,pid,pgid,sess,cmd
bork       58081   58080   57922 sort -k3
</code></pre>
<p>You can see that they share the same process group ID and session ID, but of
course they have different PIDs.</p>
<p>That was kind of a lot but that’s all we’re going to say about sessions and
process groups in this post. Let’s keep going!</p>
<h3 id="step-3-set-the-window-size">step 3: set the window size</h3>
<p>We need to tell the terminal how big to be!</p>
<p>Again, I just copied this from <code>creack/pty</code>. I decided to hardcode the size to 80x24.</p>
<pre><code>Setsize(tty, &amp;Winsize{
		Cols: 80,
		Rows: 24,
	})
</code></pre>
<p>Like with getting the terminal’s pts filename and unlocking it, setting the
size is just one <code>ioctl</code> system call:</p>
<pre><code>func Setsize(t *os.File, ws *Winsize) {
	ioctl(t.Fd(), syscall.TIOCSWINSZ, uintptr(unsafe.Pointer(ws)))
}
</code></pre>
<p>Pretty simple! We could do something smarter and get the real window size, but
I’m too lazy.</p>
<h3 id="step-4-copy-information-between-the-tcp-connection-and-the-pseudoterminal">step 4: copy information between the TCP connection and the pseudoterminal</h3>
<p>As a reminder, our rough steps to set up this remote login server were:</p>
<ol>
<li>create a pseudoterminal for the client to use</li>
<li>start a <code>bash</code> shell process</li>
<li>connect <code>bash</code> to the pseudoterminal</li>
<li>continuously copy information back and forth between the TCP connection and
the pseudoterminal</li>
</ol>
<p>We’ve done 1, 2, and 3, now we just need to ferry information between the TCP
connection and the pseudoterminal.</p>
<p>There are two <code>io.Copy</code> calls, one to copy the input <em>from</em> the tcp connection, and one to copy the output <em>to</em> the TCP connection. Here’s what the code looks like:</p>
<pre><code>	go func() {
			io.Copy(pty, conn)
	}()
  io.Copy(conn, pty)
</code></pre>
<p>The first one is in a goroutine just so they can both run in parallel.</p>
<p>Pretty simple!</p>
<h3 id="step-5-exit-when-we-re-done">step 5: exit when we’re done</h3>
<p>I also added a little bit of code to close the TCP connection when the command exits</p>
<pre><code>go func() {
  cmd.Wait()
  conn.Close()
}()

</code></pre>
<p>And that’s it for the server! You can see all of the Go code here: <a href="https://github.com/jvns/tiny-remote-login/blob/main/server.go">server.go</a>.</p>
<h3 id="next-write-a-client">next: write a client</h3>
<p>Next, we have to write a client. This is a lot than the server because we don’t need to do quite as much terminal setup. there are just 3 steps:</p>
<ol>
<li>Put the terminal into raw mode</li>
<li>copy stdin/stdout to the TCP connection</li>
<li>reset the terminal</li>
</ol>
<h3 id="client-step-1-put-the-terminal-into-raw-mode">client step 1: put the terminal into “raw” mode</h3>
<p>We need to put the client terminal into “raw” mode so that every time you press
a key, it gets sent to the TCP connection immediately. If we don’t do this,
everything will only get sent when you press enter.</p>
<p>“Raw mode” isn’t actually a single thing, it’s a bunch of flags that you want
to turn off. There’s a good tutorial explaining all the flags we have to turn
off called <a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">Entering raw mode</a>.</p>
<p>Like everything else with terminals, this requires <code>ioctl</code> system calls. In
this case we get the terminal’s current settings, modify them, and save the old
settings so that we can restore them later.</p>
<p>I figured out how to do this in Go by going to <a href="https://grep.app">https://grep.app</a> and typing in
<code>syscall.TCSETS</code> to find some other Go code that was doing the same thing.</p>
<pre><code>func MakeRaw(fd uintptr) syscall.Termios {
	// from https://github.com/getlantern/lantern/blob/devel/archive/src/golang.org/x/crypto/ssh/terminal/util.go
	var oldState syscall.Termios
	ioctl(fd, syscall.TCGETS, uintptr(unsafe.Pointer(&amp;oldState)))

	newState := oldState
	newState.Iflag &amp;^= syscall.ISTRIP | syscall.INLCR | syscall.ICRNL | syscall.IGNCR | syscall.IXON | syscall.IXOFF
	newState.Lflag &amp;^= syscall.ECHO | syscall.ICANON | syscall.ISIG
	ioctl(fd, syscall.TCSETS, uintptr(unsafe.Pointer(&amp;newState)))
	return oldState
}
</code></pre>
<h3 id="client-step-2-copy-stdin-stdout-to-the-tcp-connection">client step 2: copy stdin/stdout to the TCP connection</h3>
<p>This is exactly like what we did with the server. It’s very little code:</p>
<pre><code>go func() {
		io.Copy(conn, os.Stdin)
	}()
	io.Copy(os.Stdout, conn)
</code></pre>
<h3 id="client-step-3-restore-the-terminal-s-state">client step 3: restore the terminal’s state</h3>
<p>We can put the terminal back into the mode it started in like this (another <code>ioctl</code>!):</p>
<pre><code>func Restore(fd uintptr, oldState syscall.Termios) {
	ioctl(fd, syscall.TCSETS, uintptr(unsafe.Pointer(&amp;oldState)))
}
</code></pre>
<h3 id="we-did-it">we did it!</h3>
<p>We have written a tiny remote login server that lets anyone log in! Hooray!</p>
<p>Obviously this has zero security so I’m not going to talk about that aspect.</p>
<h3 id="it-s-running-on-the-public-internet-you-can-try-it-out">it’s running on the public internet! you can try it out!</h3>
<p>For the next week or so I’m going to run a demo of this on the internet at
<code>tetris.jvns.ca</code>. It runs tetris instead of a shell because I wanted to avoid
abuse, but if you want to try it with a shell you can run it on your own
computer :).</p>
<p>If you want to try it out, you can use <code>netcat</code> as a client instead of the
custom Go client program we wrote, because copying information to/from a TCP
connection is what netcat does. Here’s how:</p>
<pre><code>stty raw -echo &amp;&amp; nc tetris.jvns.ca 7777 &amp;&amp; stty sane
</code></pre>
<p>This will let you play a terminal tetris game called <code>tint</code>.</p>
<p>You can also use the <a href="https://github.com/jvns/tiny-remote-login/blob/main/client.go">client.go program</a> and run <code>go run client.go tetris.jvns.ca 7777</code>.</p>
<h3 id="this-is-not-a-good-protocol">this is not a good protocol</h3>
<p>This protocol where we just copy bytes from the TCP connection to the terminal
and nothing else is not good because it doesn’t allow us to send over
information information like the terminal or the actual window size of the
terminal.</p>
<p>I thought about implementing telnet’s protocol so that we could use telnet as a
client, but I didn’t feel like figuring out how telnet works so I didn’t. (the
server 30% works with telnet as is, but a lot of things are broken, I don’t
quite know why, and I didn’t feel like figuring it out)</p>
<h3 id="it-ll-mess-up-your-terminal-a-bit">it’ll mess up your terminal a bit</h3>
<p>As a warning: using this server to play tetris will probably mess up your
terminal a bit because it sets the window size to 80x24. To fix that I just
closed the terminal tab after running that command.</p>
<p>If we wanted to fix this for real, we’d need to restore the window size after
we’re done, but then we’d need a slightly more real protocol than “just
blindly copy bytes back and forth with TCP” and I didn’t feel like doing that.</p>
<p>Also it sometimes takes a second to disconnect after the program exits for some
reason, I’m not sure why that is.</p>
<h3 id="other-tiny-projects">other tiny projects</h3>
<p>That’s all! There are a couple of other similar toy implementations of programs
I’ve written here:</p>
<ul>
<li><a href="https://jvns.ca/blog/2022/03/23/a-toy-version-of-tls/">toy tls 1.3 implementation</a></li>
<li><a href="https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/">toy dns resolver</a></li>
</ul>
</div></div>
  </body>
</html>
