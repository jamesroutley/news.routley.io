<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stitcher.io/blog/new-in-php-82">Original</a>
    <h1>Whats New in PHP 8.2</h1>
    
    <div id="readability-page-1" class="page"><p>
        Scout APM helps PHP developers pinpoint N+1 queries, memory leaks &amp; more so you
        can troubleshoot fast &amp; get back to coding faster. <a href="https://ter.li/yvaix5" target="_blank" rel="noopener noreferrer sponsored">Start your free 14-day trial today</a>.
    </p><article>
        

                    
        
        
        <p>PHP 8.2 will probably be released at the end of 2022, but there&#39;s no date set yet. In this post, we&#39;ll go through all features, performance improvements, changes and deprecations one by one.</p>
<h3 id="null-and-false-as-standalone-types-rfc"><a href="#null-and-false-as-standalone-types-rfc">#</a> <code><span>null</span></code> and <code><span>false</span></code> as standalone types <small><a target="_blank" href="https://wiki.php.net/rfc/null-false-standalone-types">RFC</a></small></h3>
<p>We&#39;ll avoid going down the rabbit hole of <a href="https://donnywinston.com/blog/liskov-and-type-safety">type safety</a> in this post, but technically <code><span>null</span></code> and <code><span>false</span></code> could be considered valid types on their own. Common examples are PHP&#39;s built-in functions, where <code><span>false</span></code> is used as the return type for when an error occurs. For example in <code><span>file_get_contents</span></code>:</p>
<pre><code data-lang="php"><span>file_get_contents</span>(): <span>string|<span>false</span></span></code></pre>
<p>Note that using <code><span>false</span></code> in a union type was already possible; but in PHP 8.2, it can be used as a standalone type as well:</p>
<pre><code data-lang="php"><span><span>function</span> <span>alwaysFalse</span><span>()</span>: <span><span>false</span></span>
</span>{
    <span>return</span> <span>false</span>;
}</code></pre>
<p>Many developers, including myself, are a bit wary looking at this RFC. It doesn&#39;t support <code><span>true</span></code> as a standalone type, and shouldn&#39;t types represent categories instead of individual values? It turns out there is a concept called <a target="_blank" href="https://en.wikipedia.org/wiki/Unit_type">a unit type</a> in type systems, which are types that only allow one value. But is it really useful, and does it encourage clean software design? Maybe, maybe not.</p>
<p>A standalone <code><span>null</span></code> type makes a bit more sense: as <code><span>null</span></code> can be considered a category on itself and not just a value within a category. Imagine the null object pattern:</p>
<pre><code data-lang="php"><span><span>class</span> <span>Post</span> 
</span>{
    <span>public</span> <span><span>function</span> <span>getAuthor</span><span>()</span>: ?<span>string</span> </span>{  }
}

<span><span>class</span> <span>NullPost</span> <span>extends</span> <span>Post</span>
</span>{
    <span>public</span> <span><span>function</span> <span>getAuthor</span><span>()</span>: <span>null</span> </span>{  }
}</code></pre>
<p>It makes sense for <code><span>NullPost</span>::<span>getAuthor</span>()</code> to be able to say it will only ever return <code><span>null</span></code>, instead of <code><span>null</span></code> or <code><span>string</span></code>, which previously wasn&#39;t possible to do.</p>
<p>Personally, I&#39;d stay away from using <code><span>false</span></code> as a standalone type for conveying error state â€” I think there are better solutions to solving such problems. I can see some use cases for <code><span>null</span></code> as a standalone type and I&#39;ll probably use it sporadically.</p>
<hr/>
<h3 id="deprecate-dynamic-properties-rfc"><a href="#deprecate-dynamic-properties-rfc">#</a> Deprecate dynamic properties <small><a target="_blank" href="https://wiki.php.net/rfc/deprecate_dynamic_properties">RFC</a></small></h3>
<p>I&#39;d say this is a change for the better, but it will hurt a little bit. Dynamic properties are deprecated in PHP 8.2, and will throw an <code><span>ErrorException</span></code> in PHP 9.0. What are dynamic properties, you ask? Those are properties that aren&#39;t present on an object, but are set or get nevertheless:</p>
<pre><code data-lang="php"><span><span>class</span> <span>Post</span>
</span>{
    <span>public</span> <span>string</span> <span>$title</span>;
}



$post-&gt;<span>name</span> = <span>&#39;Name&#39;</span>;</code></pre>
<p>Keep in mind that classes implementing <code><span>__get</span></code> and <code><span>__set</span></code> will still work as intended:</p>
<pre><code data-lang="php"><span><span>class</span> <span>Post</span>
</span>{
    <span>private</span> <span><span>array</span></span> <span>$properties</span> = [];
    
    <span>public</span> <span><span>function</span> <span>__set</span><span>(<span>string</span> $name, <span>mixed</span> $value)</span>: <span>void</span>
    </span>{
        <span>$this</span>-&gt;<span>properties</span>[$name] = $value;
    }
}



$post-&gt;<span>name</span> = <span>&#39;Name&#39;</span>;</code></pre>
<p>PHP used to be a very dynamic language, but has been moving away from that mindset for a while now. Personally I think it&#39;s a good thing to embrace stricter rules and rely on static analysis wherever possible, as I think it allows developers to write better code.</p>
<p>Still, I can imagine developers who relied on dynamic properties not being happy with this change; maybe it would help to a deeper look into the benefits of static analysis? You can check out my <a href="https://road-to-php.com/static">Road to PHP: Static Analysis</a> series if you want to learn more!</p>
<p>And <em>just in case</em> you don&#39;t want these warnings when upgrading to PHP 8.2 (I wouldn&#39;t recommend doing that, since you&#39;ll get in trouble with PHP 9.0); here&#39;s how you disable deprecation warnings in PHP:</p>
<pre><code data-lang="php"><span>error_reporting</span>(<span>E_ALL</span> ^ <span>E_DEPRECATED</span>);</code></pre>
<div>
    <p>
       My latest video: I&#39;ve built <a href="https://aggregate.stitcher.io/">a hobby project</a> with Laravel and deployed it to production in 5 hours.
    </p>

    
</div>

<h3 id="redact-parameters-in-back-traces-rfc"><a href="#redact-parameters-in-back-traces-rfc">#</a> Redact parameters in back traces <small><a target="_blank" href="https://wiki.php.net/rfc/redact_parameters_in_back_traces">RFC</a></small></h3>
<p>A common practice in any codebase is to send production errors to a service that keeps track of them, and will notify developers when something goes wrong. This practice often involves sending stack traces over the wire to a third party service. There are case however where those stack traces can include sensitive information such as environment variables, passwords or usernames.</p>
<p>PHP 8.2 allows you to mark such &#34;sensitive parameters&#34; with an attribute, so that you don&#39;t need to worry about them being listed in your stack traces when something goes wrong.
Here&#39;s an example from the RFC:</p>
<pre><code data-lang="php"><span><span>function</span> <span>test</span><span>(
    $foo,
    #[<span>SensitiveParameter</span>] $bar,
    $baz
)</span> </span>{
    <span>throw</span> <span>new</span> <span><span>Exception</span></span>(<span>&#39;Error&#39;</span>);
}
 
<span>test</span>(<span>&#39;foo&#39;</span>, <span>&#39;bar&#39;</span>, <span>&#39;baz&#39;</span>);
 
<span>Fatal error: Uncaught <span>Exception</span>: Error in test.php:<span>8</span>
Stack trace:


  thrown in test.php on line <span>8</span></span></code></pre>
<hr/>
<h3 id="deprecate-partially-supported-callables-rfc"><a href="#deprecate-partially-supported-callables-rfc">#</a> Deprecate partially supported callables <small><a target="_blank" href="https://wiki.php.net/rfc/deprecate_partially_supported_callables">RFC</a></small></h3>
<p>Another change, although one with a slightly smaller impact, is that partially supported callables are now deprecated as well. Partially supported callables are callables which can be called using <code><span>call_user_func</span>($callable)</code>, but not by calling <code>$callable()</code> directly. The list of these kinds of callables is rather short, by the way:</p>
<pre><code data-lang="php"><span>&#34;self::method&#34;</span>
<span>&#34;parent::method&#34;</span>
<span>&#34;static::method&#34;</span>
[<span>&#34;self&#34;</span>, <span>&#34;method&#34;</span>]
[<span>&#34;parent&#34;</span>, <span>&#34;method&#34;</span>]
[<span>&#34;static&#34;</span>, <span>&#34;method&#34;</span>]
[<span>&#34;Foo&#34;</span>, <span>&#34;Bar::method&#34;</span>]
[<span><span>new</span></span> <span>Foo</span>, <span>&#34;Bar::method&#34;</span>]</code></pre>
<p>The reason for doing this? It&#39;s a step in the right direction towards being able to use <code><span>callable</span></code> for typed properties. Nikita explains it very well in the RFC:</p>
<blockquote>
<p>all of these callables are context-dependent. The method that &#34;self::method&#34; refers to depends on which class the call or callability check is performed from. In practice, this usually also holds for the last two cases, when used in the form of [new Foo, &#34;parent::method&#34;].</p>
<p>Reducing the context-dependence of callables is the secondary goal of this RFC. After this RFC, the only scope-dependence still left is method visibility: &#34;Foo::bar&#34; may be visible in one scope, but not another. If callables were to be limited to public methods in the future (while private methods would have to use first-class callables or Closure::fromCallable() to be made scope-independent), then the callable type would become well-defined and could be used as a property type. However, changes to visibility handling are not proposed as part of this RFC.</p>
</blockquote>
<hr/>
<h3 id="locale-independent-case-conversion-rfc"><a href="#locale-independent-case-conversion-rfc">#</a> Locale-independent case conversion <small><a target="_blank" href="https://wiki.php.net/rfc/strtolower-ascii">RFC</a></small></h3>
<p>Some changes to how case-conversion works, now not depending on locale anymore.</p>
<hr/>
<p>That&#39;s all there is for now, I&#39;ll keep this list updated throughout the year. You can subscribe to <a href="https://donnywinston.com/mail">my newsletter</a> if you want to receive occasional updates!</p>
<div><p>
    Noticed a tpyo? You can <a href="https://github.com/brendt/stitcher.io" target="_blank" rel="noopener noreferrer">submit a PR</a> to fix it.

    If you want to stay up to date about what&#39;s happening on this blog, you can follow me
    on <a href="https://mobile.twitter.com/brendt_gd" target="_blank" rel="noopener noreferrer">Twitter</a> or subscribe to my newsletter:

    </p>
</div>



                    
        
                    
            </article></div>
  </body>
</html>
