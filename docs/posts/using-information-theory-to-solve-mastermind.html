<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.goranssongaspar.com/mastermind">Original</a>
    <h1>Using information theory to solve Mastermind</h1>
    
    <div id="readability-page-1" class="page"><div>
  <section>
    

<p>Mastermind is a game all about information. The Code Master selects one of \( 6^4 = 1\,296 \) secret codes. Each incorrect guess gives us information by eliminating some of these; the more codes that are ruled out, the more information that guess has provided. Let&#39;s quantify this insight! Suppose a guess gets some response that reduces the number of possible keys from some number \(n\) to a smaller \(n&#39;&lt;n\). The convention in <em>information theory</em>, a branch of mathematics and computer science dealing with just this type of question, is to define the <em>information</em> \(I\) provided by this guess and response as
\[
I := \log_2 \frac{n}{n&#39;}. 
\]
The unit of information (with respect to the base-2 logarithm; other bases can be used) is called <em>bits</em>. One bit of information corresponds to reducing the number of possible keys by half; a guess-response pair providing two bits of information reduces it by \( (1/2)^2 = 1/4 \). There are good theoretical reasons for adopting this admittedly unintuitive apparatus. For our purposes it is enough to note that information is additive. If a first guess provides one bit of information, and a second two bits, the number of possible codes has been reduced by \( 1/2 \times 1/4 = 1/8\); in total the two guesses have provided \( 1 + 2 = 3\) bits of information!</p>

<p>We can now come up with a simple strategy for playing Mastermind: always make that guess which provides the most information. But we don&#39;t know the information of a guess in advance, since it depends on which response the Code Master will give us, and therefore on what the true secret code is. Let&#39;s suppose that the Code Master selects a secret code uniformly at random, with no code being more likely than any other; this is in fact what the program does under the hood. We then want to make the guess which provides the most information <em>on average</em>. </p>

<p>The probability of getting a certain response to a guess is \( n&#39; / n \), since this is exactly the proportion of all possible codes which would give that response if it was the true secret. Let&#39;s call this probability \(p\); we can then rewrite the above expression for the information of this guess-response pair as 
\[ 
I = \log_2 \frac{1}{p}.
\]</p>

<p>Our strategy should be to make the guess with the highest expected value of information over all possible responses; this expected information is called the <em>entropy</em> of the guess and is denoted by \( H \). (If you&#39;re familiar with entropy from thermodynamics, the connection is mostly historical; it is probably unhelpful to look for a conceptual connection.) Let \(p_i = n&#39;_i / n\) be the probability of a guess getting response \(i\), where \(n&#39;_i \) is  the corresponding number of then possible secret codes. The entropy of a guess is defined as</p>

<p>\[
H := \sum_{\text{response } i} p_i \log_2 \frac{1}{p_i},
\]</p>

<p>which again has the unit of bits. We have now landed on our final strategy: start by figuring out the number of possible secret codes \(n\). For each guess, calculate the number \(n_i&#39;\) of codes that will still be viable if the Code Master gives response \(i\) in return. Do this for all possible responses. Finally, calculate the entropy of each guess; pick the one with the highest. Surprise, surprise — this is exactly what is done above! The number in bits listed under <em>Best Guesses</em> is the guess&#39; entropy. </p>

<!-- **Optimal Opening** It is natural to wonder what the best opening guess is. As one would expect, all guesses with four different colors have the same maximum entropy at the start of the game. This becomes obvious when you notice that the second peg of some color can only provide you with information about location in the secret code, not which colors it contains. -->

<p>So how well does this strategy perform? On average over all 1 296 secret codes, it beats the Code Master in 4.47 guesses (with a standard deviation of 0.75). Take the last significant digit with a grain of salt; there are usually many guesses with equal entropy, of which the program chooses one arbitrarily. Is this performance any good? For starters, the amount of information needed to narrow all \(n\) possible codes down to one is \(\log_2 n\) bits; this is displayed next to the number of possible moves. If you play around for a while, you&#39;ll notice that the best guess usually has an entropy of two to three bits. We would then expect it to take around four guesses to get the \(\log_2 1\,296 = 10.3\) bits of information needed at the start of a new game.</p>

<p>This performance is also in line with other Mastermind algorithms. To the best of my knowledge, Donald Knuth published the first analysis of the game with his 1976 <a href="https://ia804602.us.archive.org/10/items/pdfy-4zbExU0jr9Y81AAs/knuth-mastermind_text.pdf" target="_blank"><em>The Computer as Mastermind</em>.</a> In the following decades, many other strategies have been suggested, all achieving an expected number of guesses of around 4.4. (See e.g. <a href="https://www.academia.edu/download/72491977/bf0191714720211014-1785-uh11fd.pdf" target="_blank">Neuwirth, <em>Some Strategies for Mastermind</em>, 1982.</a>) It is not surprising that maximizing entropy is a successful strategy; it solves the game with brute force. Calculating the number \(n&#39;\) of still possible codes after a guess-response turns out to be expensive; in fact, it is NP-complete. <a href="https://arxiv.org/abs/cs/0512049" target="_blank">(Stuckman &amp; Zhang, <em>Mastermind is NP-Complete</em>, 2005.)</a> The necessary lookup table quickly becomes unmanageable as the length of the code and the number of colors grow. At the end of the day, a bit more than four guesses seem to be as good as you can do on average. You simply don&#39;t get enough information to narrow down the options quicker. This argument, of course, is informal; if anyone knows of a more rigorous one, please be in touch!</p>

<p><em>The idea of making the guess with the highest entropy is taken wholesale from <a href="https://youtu.be/v68zYyaEmEA?si=-Z3hjRb2QirelBF2" target="_blank">3Blue1Brown&#39;s excellent video on Wordle.</a> Worlde is of course a variant of Mastermind, albeit more engaging. All code I have written for this project, including for this webpage is <a href="https://github.com/ErikGoranssonGaspar/OptimalMastermind" target="_blank">available on GitHub.</a> Published on June 11, 2025.</em></p>

  </section>
</div></div>
  </body>
</html>
