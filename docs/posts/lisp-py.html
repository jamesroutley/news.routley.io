<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://khamidou.com/compilers/lisp.py/">Original</a>
    <h1>Lisp.py</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
    
    
    <ul>
        
          <li id="title">
              
          </li>
        
        
        
        <li id="section-1">
            <div>
              
              
              <p>A few years ago, I tried to work my way through <a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a>. It’s one of these books every Lisp person will tell you to read. You can actually tell it’s a classic because almost no one read it all the way through.</p>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div>
              
              
              <p>One thing that stuck with me is the concept of the metacircular evaluator. A metacircular evaluator is a fancy way to call how a Lisp interpreter that evaluates a Lisp expression recursively. There’s a lot of <a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/chapter-4/figs/eval-apply.gif">abstruse schemas</a> on the Internet to explain it but for some reason I could never wrap my head around it.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div>
              
              
              <p>The other day I stumbled upon Peter Norvig’s <a href="http://norvig.com/lispy.html">How to write a Lisp in Python</a>, which took me a few years back. This time, I would figure it out! So, after a bit of Googling and some light reading on Lisp, I started working on a very simple evaluator, in Python.</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div>
              
              
              <p>Python is a great language for trying things out because it gets out of the way and gives us a lot of things out of the box, like memory management – having to write a garbage collector just to implement a basic Lisp doesn’t sound fun!</p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div>
              
              
              <p>This is the source for this Lisp interpreter. It’s split in three parts:</p>
<ol>
<li>Utility functions and data structures</li>
<li>Parser</li>
<li>Interpreter</li>
</ol>

            </div>
            
            <div><div><pre><span>import</span> re
<span>import</span> sys
<span>import</span> operator
<span>import</span> pprint <span>as</span> pretty_print</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div>
              
              
              <h2 id="utility-functions-and-data-structures">Utility functions and data structures</h2>

            </div>
            
            <div><div><pre>pprint = <span>lambda</span> obj: pretty_print.PrettyPrinter(indent=<span>4</span>).pprint(obj)

<span><span>def</span> <span>fail</span><span>(s)</span>:</span>
    <span>print</span> s
    sys.exit(<span>-1</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div>
              
              
              <p>These classes are mostly containers for our interpreter. They make the code
a little clearer to write.</p>

            </div>
            
            <div><div><pre><span><span>class</span> <span>InterpreterObject</span><span>(object)</span>:</span>
    <span><span>def</span> <span>__init__</span><span>(self, value)</span>:</span>
        self.value = value

    <span><span>def</span> <span>__repr__</span><span>(self)</span>:</span>
        <span>return</span> self.value

<span><span>class</span> <span>Symbol</span><span>(InterpreterObject)</span>:</span>
    <span>pass</span>

<span><span>class</span> <span>String</span><span>(InterpreterObject)</span>:</span>
    <span>pass</span>

<span><span>class</span> <span>Lambda</span><span>(InterpreterObject)</span>:</span>
    <span><span>def</span> <span>__init__</span><span>(self, arguments, code)</span>:</span>
        self.arguments = arguments
        self.code = code

    <span><span>def</span> <span>__repr__</span><span>(self)</span>:</span>
        <span>return</span> <span>&#34;(lambda (%s) (%s)&#34;</span> % (self.arguments, self.code)</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div>
              
              
              <h2 id="parser">Parser</h2>
<p>The parser is pretty simple because lisp has an extremely simple grammar.</p>

            </div>
            
            <div><div><pre><span><span>def</span> <span>tokenize</span><span>(s)</span>:</span>
    ret = []
    in_string = <span>False</span>
    current_word = <span>&#39;&#39;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div>
              
              
              <p>The algorithm is simple: we scan the string char by char and look
if we’re at a word, string or s-expr boundary. Depending on the
case, we either add a new char to the current word, create a new
word or a new sublist.
The algorithm is complicated by the fact that we have several delimiters:
spaces, simple quotes and braces, which makes it some sort of weird
state machine.</p>

            </div>
            
            <div><div><pre>    <span>for</span> i, char <span>in</span> enumerate(s):
        <span>if</span> char == <span>&#34;&#39;&#34;</span>:
            <span>if</span> in_string <span>is</span> <span>False</span>:
                in_string = <span>True</span>
                current_word += char
            <span>else</span>:
                in_string = <span>False</span>
                current_word += char
                ret.append(current_word)
                current_word = <span>&#39;&#39;</span>

        <span>elif</span> in_string <span>is</span> <span>True</span>:
            current_word += char

        <span>elif</span> char <span>in</span> [<span>&#39;\t&#39;</span>, <span>&#39;\n&#39;</span>, <span>&#39; &#39;</span>]:
            <span>continue</span>

        <span>elif</span> char <span>in</span> [<span>&#39;(&#39;</span>, <span>&#39;)&#39;</span>]:
            ret.append(char)

        <span>else</span>:
            current_word += char
            <span>if</span> i &lt; len(s) - <span>1</span> <span>and</span> s[i+<span>1</span>] <span>in</span> [<span>&#39;(&#39;</span>, <span>&#39;)&#39;</span>, <span>&#39; &#39;</span>, <span>&#39;\n&#39;</span>, <span>&#39;\t&#39;</span>]:
                ret.append(current_word)
                current_word = <span>&#39;&#39;</span>

    <span>return</span> ret</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div>
              
              
              <p>Next are a handful of utility functions that will help us
convert tokens to their actual values.</p>

            </div>
            
            <div><div><pre><span><span>def</span> <span>is_integer</span><span>(s)</span>:</span>
    <span>try</span>:
        int(s)
        <span>return</span> <span>True</span>
    <span>except</span> ValueError:
        <span>return</span> <span>False</span>

<span><span>def</span> <span>is_float</span><span>(s)</span>:</span>
    <span>try</span>:
        float(s)
        <span>return</span> <span>True</span>
    <span>except</span> ValueError:
        <span>return</span> <span>False</span>


<span><span>def</span> <span>is_string</span><span>(s)</span>:</span>
    <span>if</span> s[<span>0</span>] == <span>&#34;&#39;&#34;</span> <span>and</span> s[<span>-1</span>] == <span>&#34;&#39;&#34;</span>:
        <span>return</span> <span>True</span>

    <span>return</span> <span>False</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div>
              
              
              <p>The <code>parse</code> function is actually a wrapper for <code>do_parse</code> – I wanted
to pass an iterator around because it felt a lot nicer than passing
raw array indices around.</p>

            </div>
            
            <div><div><pre><span><span>def</span> <span>parse</span><span>(tokens)</span>:</span>
    itert = iter(tokens)
    token = itert.next()

    <span>if</span> token != <span>&#39;(&#39;</span>:
        fail(<span>&#34;Unexpected token {}&#34;</span>.format(token))

    <span>return</span> do_parse(itert)


<span><span>def</span> <span>do_parse</span><span>(tokens)</span>:</span>
    ret = []

    current_sexpr = <span>None</span>
    in_sexp = <span>False</span>

    <span>for</span> token <span>in</span> tokens:
        <span>if</span> token == <span>&#39;(&#39;</span>:
            ret.append(do_parse(tokens))
        <span>elif</span> token == <span>&#39;)&#39;</span>:
            <span>return</span> ret
        <span>elif</span> is_integer(token):
            ret.append(int(token))
        <span>elif</span> is_float(token):
            ret.append(float(token))
        <span>elif</span> is_string(token):
            ret.append(String(token[<span>1</span>:][<span>0</span>:<span>-1</span>]))
        <span>else</span>:
            ret.append(Symbol(token))</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div>
              
              
              <h2 id="interpreter">Interpreter</h2>
<p>The interpreter is broken into two functions, <code>eval</code> and <code>apply</code>. Both take an s-expression (<code>expr</code>) and a dictionary of variables in scope (<code>environment</code>) as parameters.</p>
<p><code>eval</code>‘s role is to take an expression and return its value. For example, if you pass a symbol to <code>eval</code>, it will look up its value in the symbol table and return it.</p>
<p><code>apply</code> is reserved for evaluating functions. It takes as parameters a function (written in Lisp or Python), a list of arguments and calls the function. How does it do that? It simply updates the <code>environment</code> to define the function’s parameters as local variables, and then calls <code>eval</code>!</p>

            </div>
            
            <div><div><pre><span><span>def</span> <span>eval</span><span>(expr, environment)</span>:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div>
              
              
              <p>First, let’s define how to evaluate numbers, strings and Symbols.</p>

            </div>
            
            <div><div><pre>    <span>if</span> isinstance(expr, int):
        <span>return</span> expr
    <span>elif</span> isinstance(expr, str):
        <span>return</span> expr
    <span>elif</span> isinstance(expr, float):
        <span>return</span> expr
    <span>elif</span> isinstance(expr, String):
        <span>return</span> expr.value
    <span>elif</span> isinstance(expr, Symbol):
        <span>if</span> expr.value <span>not</span> <span>in</span> environment:
            fail(<span>&#34;Couldn&#39;t find symbol {}&#34;</span>.format(expr.value))
        <span>return</span> environment[expr.value]
    <span>elif</span> isinstance(expr, list):</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div>
              
              
              <p>Most of the language’s built-ins are defined as Python code
but we need to handle some language constructs like <code>lambda</code> or <code>if</code> directly
in the interpreter, because they require a specific evaluation order.</p>
<p>For example if we defined <code>if</code> as a function,
this expression <code>(if (= 3 2) (print &#39;3 = 2&#39;) (print &#39;3 = 3&#39;))</code> would print both
3 = 2 and 3 = 3, because the eval function evaluates its arguments in order.</p>

            </div>
            
            <div><div><pre>        <span>if</span> isinstance(expr[<span>0</span>], Symbol):
            <span>if</span> expr[<span>0</span>].value == <span>&#39;lambda&#39;</span>:
                arg_names = expr[<span>1</span>]
                code = expr[<span>2</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div>
              
              
              <p><code>Lambda</code> is simply an object that holds <code>arguments</code> (a list of arguments with their names) and <code>code</code> (a list of Lisp instructions to execute).</p>

            </div>
            
            <div><div><pre>                <span>return</span> Lambda(arg_names, code)

            <span>elif</span> expr[<span>0</span>].value == <span>&#39;if&#39;</span>:
                condition = expr[<span>1</span>]
                then = expr[<span>2</span>]
                _else = <span>None</span>
                <span>if</span> len(expr) == <span>4</span>:
                    _else = expr[<span>3</span>]

                <span>if</span> eval(condition, environment) != <span>False</span>:
                    <span>return</span> eval(then, environment)
                <span>elif</span> _else <span>is</span> <span>not</span> <span>None</span>:
                    <span>return</span> eval(_else, environment)

            <span>elif</span> expr[<span>0</span>].value == <span>&#39;define&#39;</span>:
                name = expr[<span>1</span>].value
                value = eval(expr[<span>2</span>], environment)
                environment[name] = value

            <span>elif</span> expr[<span>0</span>].value == <span>&#39;begin&#39;</span>:
                <span>for</span> ex <span>in</span> expr[<span>1</span>:]:
                    eval(ex, environment)

            <span>else</span>:
                fn = eval(expr[<span>0</span>], environment)
                args = [eval(arg, environment) <span>for</span> arg <span>in</span> expr[<span>1</span>:]]
                <span>return</span> apply(fn, args, environment)</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div>
              
              
              <p>Apply is pretty simple too. It checks if a function is an interpreter
built-in or not.</p>

            </div>
            
            <div><div><pre><span><span>def</span> <span>apply</span><span>(fn, args, environment)</span>:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div>
              
              
              <p>If it is, it simply passes the arguments to the built-in.</p>

            </div>
            
            <div><div><pre>    <span>if</span> callable(fn):
        <span>return</span> fn(*args)</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div>
              
              
              <p>Otherwise we have to actually evaluate the function.</p>

            </div>
            
            <div><div><pre>    <span>if</span> isinstance(fn, Lambda):
        new_env = dict(environment)
        <span>if</span> len(args) != len(fn.arguments):
            fail(<span>&#34;Mismatched number of arguments to lambda&#34;</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div>
              
              
              <p>To do this we bind the values of the arguments to the environment.</p>

            </div>
            
            <div><div><pre>        <span>for</span> i <span>in</span> range(len(fn.arguments)):
            new_env[fn.arguments[i].value] = args[i]</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div>
              
              
              <p>And we call eval on the function body. That’s it!</p>

            </div>
            
            <div><div><pre>        <span>return</span> eval(fn.code, new_env)</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div>
              
              
              <p>Finally we define a handful of system built-ins.</p>

            </div>
            
            <div><div><pre>base_environment = {
    <span>&#39;+&#39;</span>: operator.add,
    <span>&#39;-&#39;</span>: operator.sub,
    <span>&#39;*&#39;</span>: operator.mul,
    <span>&#39;/&#39;</span>: operator.div,
    <span>&#39;&gt;&#39;</span>: operator.gt,
    <span>&#39;&gt;=&#39;</span>: operator.ge,
    <span>&#39;&lt;&#39;</span>: operator.lt,
    <span>&#39;&lt;=&#39;</span>: operator.le,
    <span>&#39;=&#39;</span>: operator.eq,
    <span>&#39;!=&#39;</span>: operator.ne,
    <span>&#39;nil&#39;</span>: <span>None</span>,
    <span>&#39;print&#39;</span>: <span>lambda</span> x: sys.stdout.write(str(x) + <span>&#39;\n&#39;</span>),
}


<span><span>def</span> <span>main</span><span>()</span>:</span>
    <span>if</span> len(sys.argv) != <span>2</span>:
        <span>print</span> <span>&#34;usage: python {} &lt;file&gt;&#34;</span>.format(sys.argv[<span>0</span>])
        sys.exit(<span>-1</span>)

    <span>with</span> open(sys.argv[<span>1</span>]) <span>as</span> fd:
        contents = fd.read()
        parsed = parse(tokenize(contents))
        eval(parsed, base_environment)


<span>if</span> __name__ == <span>&#39;__main__&#39;</span>:
    main()</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div>
              
              
              <h2 id="parting-words">Parting words</h2>
<p>As you can see, it turns out its pretty easy to make your own interpreter! As a general rule, when you find yourself stumped by a weird concept, the easiest way to figure out how it works is to implement a  basic prototype using it.</p>
<p>If you have questions, don’t hesitate to send me an email to “hello” @ this website’s domain name.</p>

            </div>
            
        </li>
        
    </ul>
  </div></div>
  </body>
</html>
