<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://inventwithpython.com/blog/lost-av-chapter.html">Original</a>
    <h1>Lost Chapter of Automate the Boring Stuff: Audio, Video, and Webcams in Python</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text articleBody">
	<p>The <a href="https://automatetheboringstuff.com">third edition of Automate the Boring Stuff with Python is now available for purchase or to read for free online</a>. It has updated content and several new chapters, but one chapter that was left on the cutting room floor was <em>&#34;Working with Audio, Video, and Webcams&#34;</em>. I present the 26-page rough draft chapter in this blog, where you can learn how to write Python code that records and plays multimedia content.</p>
<h2>Working with Audio, Video, and Webcams</h2>
<p>These days a smartphone is a portable film studio that fits in your pocket. The ability to not just readily view but also produce video has led to an explosion of video content easily accessible over the internet. There’s plenty of video and audio editing software available for users of all levels of sophistication. But if you have, say, a thousand video files that you need to automate reducing their volume by 50% and then extract thumbnail images, you don’t want to have to edit each of those files individually yourself. Similarly, you may want to record video, audio, or photos from a laptop’s webcam for some automated process too specialized for off-the-shelf software. Or maybe you’d just like your program to play a funny sound effect. In this chapter, you’ll learn how to control your computer’s microphone, webcam, and speaker hardware from Python and play multimedia files.</p>
<p>This chapter assumes you have already read Chapter 21 to learn the basics about how programs work with image data. Since video is just a series of images, many of the same concepts apply.</p>
<h2>Audio and Video Data</h2>
<p>First, you should have a reliable way to open and view video and audio files. Since its release over twenty years ago, the open source VLC Media Player application has been free of charge and the gold standard for multimedia players. Install the VLC Media Player from <a href="https://www.videolan.org/vlc/">https://www.videolan.org/vlc/</a>, which runs on Windows, macOS, and Linux. Mobile versions for Android and iOS are also freely available. VLC is far superior to any multimedia application that came with your computer.</p>
<p>While you may be familiar with audio and video files by their file extension such as <em>.mp3</em> or <em>.webm</em>, audio and video formats are split into container formats and codecs. A container format is a wrapper that contains metadata and the encoded video or audio data. MP4, AVI, MKV, and MOV are popular container formats. A codec (or encoding) is the compression algorithm used for the video or audio data. MP3, H.264, VP9, and AAC are common video or audio codecs. Not all applications and devices support all codecs.</p>
<p>The audio file formats we’ll be using in this chapter are:</p>
<ul>
<li><em>.wav</em> files - an uncompressed format that are widely supported by apps and libraries but tend to have large file sizes so they are often used for short sound effects.</li>
<li><em>.mp3</em> files - a popular compressed format often used for music and other lengthy audio.</li>
<li><em>.ogg</em> files - an open standard, compressed format that is less popular than <em>.mp3</em> but provides better compression and quality.</li>
</ul>
<p>The video file formats we’ll be using in this chapter are:</p>
<ul>
<li><em>.avi</em> files - an older format that tends to have larger file sizes.</li>
<li><em>.mp4</em> files - a popular format that is widely supported by different software</li>
<li><em>.mkv</em> files - an open format that has many features but isn’t as widely supported as <em>.mp4</em>.</li>
<li><em>.webm</em> files - a more recent format based on <em>.mkv</em> that offers better compression and quality.</li>
</ul>
<h3>Common Video Sizes and Aspect Ratios</h3>
<p>The aspect ratio is the relative size of a video or screen’s width to its height, often written as <em>width:height</em>. For example, 4:3 (4 pixels of width for every 3 pixels of height) was a common aspect ratio for 20th century computer monitors and standard-definition televisions in the broadcast TV era. Today, 16:9 is common for most laptop screens and high-definition televisions. More recently, the wider 19.5:9 aspect ratio is becoming common for smart phones. An aspect ratio that is wider than it is tall has a <em>landscape orientation</em>, while an upright aspect ratio that is taller than it is wide is called a <em>portrait orientation</em>.</p>
<p><em>Screen resolution</em> is the number of columns and rows of pixels that a laptop or mobile screen displays. It’s often written as <em>width</em> x <em>height</em>, such as 1280 x 720 or 1920 x 1080 (also written as 720p and 1080p, respectively). Your laptop’s screen often supports multiple resolutions that can be configured in your operating system’s settings. Videos have one size, though they can be scaled larger or smaller to fit a display or app window. While videos can have any size, they often match common screen resolutions so they can be viewed in <em>fullscreen mode</em> without disproportionate scaling.</p>
<h2>Recording from Webcams and Microphones</h2>
<p>The webcam and microphone you use for video chats can be accessed by Python scripts through the OpenCV, sounddevice, and wavio Python packages. OpenCV, the open computer vision library, is an advanced open source imaging library. To use it you must first you must install the mathematics and data science package NumPy by running <code>pip install numpy</code> on Windows and macOS or <code>sudo apt install python3-numpy</code> on Ubuntu Linux. Then you can install OpenCV with <code>pip install opencv-python</code> from the terminal. See Appendix A for full instructions. The sounddevice and wavio packages are installed with <code>pip install sounddevice</code> and <code>pip install wavio</code>, respectively.</p>
<p>The following programs have been kept to a minimum so that you can easily insert their code into your own Python programs that record audio and video.</p>
<h3>Taking a Photo from a Webcam</h3>
<p>You can use your laptop’s webcam to take photos or record videos through a Python script. This has a few advantages over using a regular camera or photo app. Your Python script could:</p>
<ul>
<li>
<p>Automatically take photos in response to certain events such as receiving emails.</p>
</li>
<li>
<p>Take time lapse photos over a long period of time at various intervals.</p>
</li>
<li>
<p>Add a photo booth feature to your program, using the Pillow module to edit the photos.</p>
</li>
<li>
<p>Scan QR codes.</p>
</li>
</ul>
<p>OpenCV list your computer’s webcams with integer indexes that begin with <code>0</code>. A laptop could easily have multiple webcams. For example, it could have a built-in camera at the top of the screen (perhaps at index <code>0</code> in OpenCV) along with a separate USB webcam (perhaps at index 1). The following <em>webcamPreview.py</em> program has a `list_webcam_indexes()`` function check which OpenCV webcam indexes exist on your computer. The program then takes repeated photos from the webcam to display in a preview window. When the user presses the space key, it saves the latest photo as <em>photo.png</em> (though you can change the filename to <em>photo.jpg</em> or any other image format.) Or the user can press the Esc key to quit without saving.</p>
<div><pre><span></span><code><span>import</span><span> </span><span>cv2</span>

<span>def</span><span> </span><span>list_webcam_indexes</span><span>():</span>
<span>    </span><span>detected_webcam_indexes</span><span> </span><span>=</span><span> </span><span>[]</span>
<span>    </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>):</span><span>  </span><span># Test for up to 10 possible webcams.</span>
<span>        </span><span>webcam</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoCapture</span><span>(</span><span>i</span><span>)</span><span>  </span><span># Connect to webcam.</span>
<span>        </span><span>status</span><span>,</span><span> </span><span>frame</span><span> </span><span>=</span><span> </span><span>webcam</span><span>.</span><span>read</span><span>()</span>
<span>        </span><span>if</span><span> </span><span>status</span><span>:</span>
<span>            </span><span># A webcam exists at this index:</span>
<span>            </span><span>detected_webcam_indexes</span><span>.</span><span>append</span><span>(</span><span>i</span><span>)</span>
<span>        </span><span>webcam</span><span>.</span><span>release</span><span>()</span><span>  </span><span># Disconnect from webcam.</span>
<span>    </span><span>return</span><span> </span><span>detected_webcam_indexes</span><span>  </span><span># Returns a list of integer webcam indexes.</span>

<span>first_available_index</span><span> </span><span>=</span><span> </span><span>list_webcam_indexes</span><span>()[</span><span>0</span><span>]</span><span>  </span><span># Fails if there are no webcams.</span>
<span>webcam</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoCapture</span><span>(</span><span>first_available_index</span><span>)</span><span>  </span><span># (1) Connect to webcam.</span>

<span>print</span><span>(</span><span>&#39;index:&#39;</span><span>,</span><span> </span><span>first_available_index</span><span>)</span>
<span>print</span><span>(</span><span>&#39;width:&#39;</span><span>,</span><span> </span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FRAME_WIDTH</span><span>))</span>
<span>print</span><span>(</span><span>&#39;height:&#39;</span><span>,</span><span> </span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FRAME_HEIGHT</span><span>))</span>
<span>print</span><span>(</span><span>&#39;fps:&#39;</span><span>,</span><span> </span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FPS</span><span>))</span>

<span>while</span><span> </span><span>True</span><span>:</span><span>  </span><span># (2)</span>
<span>    </span><span>success</span><span>,</span><span> </span><span>frame</span><span> </span><span>=</span><span> </span><span>webcam</span><span>.</span><span>read</span><span>()</span><span>  </span><span># (3)</span>
<span>    </span><span>if</span><span> </span><span>not</span><span> </span><span>success</span><span>:</span>
<span>        </span><span>print</span><span>(</span><span>&#39;Could not capture frame.&#39;</span><span>)</span>
<span>        </span><span>break</span>

<span>    </span><span># Show the frame in a preview window:</span>
<span>    </span><span>cv2</span><span>.</span><span>imshow</span><span>(</span><span>&#39;Press space to save photo or Esc to exit&#39;</span><span>,</span><span> </span><span>frame</span><span>)</span><span>  </span><span># (4)</span>

<span>    </span><span>pressed_key_code</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>waitKey</span><span>(</span><span>1</span><span>)</span><span>  </span><span># (5)</span>
<span>    </span><span>if</span><span> </span><span>pressed_key_code</span><span> </span><span>==</span><span> </span><span>32</span><span>:</span><span>  </span><span># (6) 32 is the space key code.</span>
<span>        </span><span>cv2</span><span>.</span><span>imwrite</span><span>(</span><span>&#34;photo.png&#34;</span><span>,</span><span> </span><span>frame</span><span>)</span><span>  </span><span># Save photo.</span>
<span>        </span><span>break</span>
<span>    </span><span>elif</span><span> </span><span>pressed_key_code</span><span> </span><span>==</span><span> </span><span>27</span><span>:</span><span>  </span><span># (7) 27 is the Esc key code.</span>
<span>        </span><span>break</span><span>  </span><span># Exit without saving photo.</span>

<span>webcam</span><span>.</span><span>release</span><span>()</span><span>  </span><span># (8) Disconnect from webcam.</span>
<span>cv2</span><span>.</span><span>destroyAllWindows</span><span>()</span><span>  </span><span># Close preview window.</span>
</code></pre></div>

<p>On my laptop, this program makes a window with a live preview from the built-in webcam and outputs the following text:</p>
<div><pre><span></span><code><span>index</span><span>:</span><span> </span><span>0</span>
<span>width</span><span>:</span><span> </span><span>640.0</span>
<span>height</span><span>:</span><span> </span><span>480.0</span>
<span>fps</span><span>:</span><span> </span><span>30.0</span>
</code></pre></div>

<p>From this output we can tell that the webcam produces 640 x 480 sized images and can record video up to 30 frames per second. The preview window closes when the user presses the space bar or Esc key. The live preview window looks like Figure 24-1.</p>
<p><img src="https://interjectedfuture.com/blogstatic/lost-av-webcam-preview.webp"/></p>
<p><em>The live preview window from webcamPreview.py.</em></p>
<p>The <code>VideoCapture</code> object that gets stored in the <code>webcam</code> variable (1) represents the connected camera. The <code>webcam.read()</code> method (2) returns a <code>numpy.ndarray</code> data structure with all the photo pixel data in it. (NumPy is beyond the scope of this book, but an <code>ndarray</code> is similar to a Python list.) This can be passed to the <code>cv2.imshow()`` function (3) to create a window with the webcam photo data. The</code>while` loop runs fast enough to make the series of still photos look like live video in the preview window 4.</p>
<p>The <code>cv2.waitKey()</code> function (5) returns an integer key code of the keyboard key the user pressed while the preview window is focused. The integer argument passed to <code>cv2.waitKey()</code> is how many milliseconds the function waits for the user to press a key, with <code>cv2.waitKey(0)</code> meaning that it should wait forever. We call <code>cv2.waitKey(1)</code> because the function should wait just 1 millisecond before returning so our program can continue to fetch new images from the webcam. If the user hasn’t pressed a key, <code>cv2.waitKey()</code> returns <code>-1</code>. The program checks if the key code is <code>32</code> (for the space key) (6) and <code>27</code> (for the Esc key) (7) lets the user choose whether to save a photo or not. Afterwards, the <code>VideoCapture</code> object in <code>webcam</code> is released (8) and the live preview window is closed so that the program can exit.</p>
<p>To find other keyboard key codes, pass a single-character string to Python’s <code>ord()</code> function. For example, <code>ord(&#39;q&#39;)</code> returns the integer <code>113</code>, and <code>113</code> is the key code for the Q key.</p>
<h3>Take a Photo without the Preview Window</h3>
<p>If you want a program that simply saves a picture from the first available webcam as soon as possible, you can use this much simpler webcamPhoto.py program:</p>
<div><pre><span></span><code><span>import</span><span> </span><span>cv2</span><span>,</span><span> </span><span>sys</span>
<span>camera</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoCapture</span><span>(</span><span>0</span><span>)</span><span>  </span><span># 0 is the index of the webcam to use.</span>
<span>success</span><span>,</span><span> </span><span>frame</span><span> </span><span>=</span><span> </span><span>camera</span><span>.</span><span>read</span><span>()</span>
<span>if</span><span> </span><span>not</span><span> </span><span>success</span><span>:</span>
<span>    </span><span>sys</span><span>.</span><span>exit</span><span>(</span><span>&#39;Invalid webcam index.&#39;</span><span>)</span>
<span>cv2</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;photo.png&#39;</span><span>,</span><span> </span><span>frame</span><span>)</span>
</code></pre></div>

<p>You can incorporate this code into your own program that needs to take a photo from the webcam (though you may also wish to include the <code>list_webcam_indexes()</code> from <em>webcamPreview.py</em> instead of assuming index <code>0</code> is correct.)</p>
<p>You can also use the Pygame library to take photos from a webcam. While Pygame is designed for making 2D video games, it has several useful multimedia features as well. You can install it by running <code>pip install pygame</code>. Appendix A has full instructions. The following <em>webcamPhotoPygame.py</em> program takes a photo with the webcam and saves it as photo.png:</p>
<div><pre><span></span><code><span>import</span><span> </span><span>pygame.camera</span><span>,</span><span> </span><span>pygame.image</span><span>,</span><span> </span><span>time</span>
<span>pygame</span><span>.</span><span>camera</span><span>.</span><span>init</span><span>()</span>

<span>all_webcams</span><span> </span><span>=</span><span> </span><span>pygame</span><span>.</span><span>camera</span><span>.</span><span>list_cameras</span><span>()</span><span>  </span><span># (1)</span>
<span>webcam</span><span> </span><span>=</span><span> </span><span>pygame</span><span>.</span><span>camera</span><span>.</span><span>Camera</span><span>(</span><span>all_webcams</span><span>[</span><span>0</span><span>])</span><span>  </span><span># (2) Use the first found webcam.</span>
<span>webcam</span><span>.</span><span>start</span><span>()</span><span>  </span><span># (3) Initialize the webcam.</span>

<span>time</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>  </span><span># (4) Wait for the camera to get ready.</span>
<span>photo</span><span> </span><span>=</span><span> </span><span>webcam</span><span>.</span><span>get_image</span><span>()</span><span>  </span><span># (5) Take a photo from the webcam.</span>

<span>pygame</span><span>.</span><span>image</span><span>.</span><span>save</span><span>(</span><span>photo</span><span>,</span><span> </span><span>&#34;photo.png&#34;</span><span>)</span><span>  </span><span># (6) You can also use .jpg or .bmp.</span>
<span>pygame</span><span>.</span><span>camera</span><span>.</span><span>quit</span><span>()</span>
</code></pre></div>

<p>After importing the <code>pygame.camera</code> and <code>pygame.image</code> modules and initializing the <code>pygame.camera</code> module by calling <code>pygame.camera.init()</code>, you can obtain a list of the webcams connected to your computer by calling <code>pygame.camera.list_cameras()</code> (1). For example, on my computer, this function call returned the list <code>[&#39;HD Pro Webcam C920&#39;, &#39;Integrated Camera&#39;]</code> which represents an external USB webcam and the built-in webcam at the top of my laptop’s screen. You can then pass one of these strings to <code>pygame.camera.Camera()</code> to obtain a new <code>Camera</code> object to take pictures with.</p>
<p>This <code>Camera</code> object, which this program stores in a variable named <code>webcam</code> (2), must also be initialized by calling its <code>start()</code> method (3). You can take a picture by calling the <code>get_image()</code> method (5), which returns a <code>Surface</code> object that holds the image data.</p>
<p>Unfortunately, the <code>start()</code> method can take up to a full second before it’s ready to take photos. If you call <code>get_image()</code> before it’s ready, you will get a blank, black image. In my testing, it only takes 0.6 or 0.7 seconds for the webcam to get ready, so a full second delay by calling <code>time.sleep(1)</code> should be more than enough of a wait before calling <code>get_image()</code> for any modern computer. Test this on your computer and increase the delay if you are getting an all-black image.</p>
<p>After this, you can save the image to a file by passing the <code>Surface</code> object and image filename to <code>pygame.image.save()</code> (6). The file extension in your filename can either be <em>.bmp</em>, <em>.jpg</em>, or <em>.png</em>. When your program is done using the webcam, it can call <code>pygame.camera.quit()</code>.</p>
<h2>Recording Video from a Webcam</h2>
<p>OpenCV can also record video files. Open a new file editor window and enter the following code, saving it as <em>webcamVideo.py</em>. This program begins recording immediately while showing a preview window of the video it’s recording to the file <em>video.avi</em>. When the user presses the Esc key, the program stops recording.</p>
<div><pre><span></span><code><span>import</span><span> </span><span>cv2</span>

<span># NOTE: Using webcam index 0 by default:</span>
<span>webcam</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoCapture</span><span>(</span><span>0</span><span>)</span><span>  </span><span># (1) Connect to webcam.</span>

<span># Define the codec using VideoWriter_fourcc and create a VideoWriter object</span>
<span>fourcc</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoWriter_fourcc</span><span>(</span><span>*</span><span>&#39;XVID&#39;</span><span>)</span><span>  </span><span># (2)</span>
<span>fps</span><span> </span><span>=</span><span> </span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FPS</span><span>)</span>
<span>width</span><span> </span><span>=</span><span> </span><span>int</span><span>(</span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FRAME_WIDTH</span><span>))</span>
<span>height</span><span> </span><span>=</span><span> </span><span>int</span><span>(</span><span>webcam</span><span>.</span><span>get</span><span>(</span><span>cv2</span><span>.</span><span>CAP_PROP_FRAME_HEIGHT</span><span>))</span>

<span>video_file</span><span> </span><span>=</span><span> </span><span>cv2</span><span>.</span><span>VideoWriter</span><span>(</span><span>&#39;video.avi&#39;</span><span>,</span><span> </span><span>fourcc</span><span>,</span><span> </span><span>fps</span><span>,</span><span> </span><span>(</span><span>width</span><span>,</span><span> </span><span>height</span><span>))</span><span>  </span><span># (3)</span>

<span>while</span><span> </span><span>True</span><span>:</span>
<span>    </span><span>success</span><span>,</span><span> </span><span>frame</span><span> </span><span>=</span><span> </span><span>webcam</span><span>.</span><span>read</span><span>()</span><span>  </span><span># (4)</span>
<span>    </span><span>if</span><span> </span><span>not</span><span> </span><span>success</span><span>:</span>
<span>        </span><span>print</span><span>(</span><span>&#39;Could not capture frame.&#39;</span><span>)</span>
<span>        </span><span>break</span>

<span>    </span><span>cv2</span><span>.</span><span>imshow</span><span>(</span><span>&#39;Recording... (press Esc to stop)&#39;</span><span>,</span><span> </span><span>frame</span><span>)</span>
<span>    </span><span>video_file</span><span>.</span><span>write</span><span>(</span><span>frame</span><span>)</span><span>  </span><span># (5)</span>

<span>    </span><span>if</span><span> </span><span>cv2</span><span>.</span><span>waitKey</span><span>(</span><span>1</span><span>)</span><span> </span><span>==</span><span> </span><span>27</span><span>:</span><span>  </span><span># (6) 27 is the Esc key code.</span>
<span>        </span><span>break</span><span>  </span><span># Stop recording.</span>

<span>webcam</span><span>.</span><span>release</span><span>()</span><span>  </span><span># Disconnect from webcam.</span>
<span>video_file</span><span>.</span><span>release</span><span>()</span><span>  </span><span># Disconnect from output video file.</span>
<span>cv2</span><span>.</span><span>destroyAllWindows</span><span>()</span><span>  </span><span># Close preview window.</span>
</code></pre></div>

<p>While the <code>VideoCapture</code> object stored in the <code>webcam</code> variable (1) represents the camera hardware, the <code>VideoWriter</code> object stored in the <code>video_file</code> variable (3) represents the video file. The <code>VideoWriter_fourcc</code> object (2) we create represents the <em>four-character code</em> that identifies the video encoding. In our case, the four-character code is <code>&#39;XVID&#39;</code> for the Xvid codec. The width, height, and frames per second settings are also passed to <code>cv2.VideoWriter()</code>. Each frame of video from the <code>webcam.read()</code> method call (4) is added to the video file by calling <code>video_file.write()</code> (5) until the user presses the Esc key (6).</p>
<p>Note that OpenCV can record video but not audio. We’ll use the sounddevice module in the next section to record audio, but unfortunately recording videos that include synced audio is complicated and beyond the scope of this book.</p>
<h2>Recording Audio from a Webcam or Microphone</h2>
<p>The sounddevice and wavio third-party modules can use your computer’s or external webcam’s microphones to record audio. These modules have several audio-related features, but the following <em>micRecord.py</em> program has been stripped down to the basics. Still, you may want to review multithreaded programming in Chapter 19 to understand how the <code>record_audio_stream()</code> function runs in the background while the rest of the Python program continues executing.</p>
<div><pre><span></span><code><span>import</span><span> </span><span>sounddevice</span><span>,</span><span> </span><span>wavio</span><span>,</span><span> </span><span>threading</span><span>,</span><span> </span><span>time</span>

<span>1</span><span>def</span><span> </span><span>list_microphone_devices</span><span>():</span>
<span>    </span><span># Return a list of microphone indexes and names.</span>
<span>    </span><span>microphones</span><span> </span><span>=</span><span> </span><span>[]</span>
<span>    </span><span>for</span><span> </span><span>i</span><span>,</span><span> </span><span>device</span><span> </span><span>in</span><span> </span><span>enumerate</span><span>(</span><span>sounddevice</span><span>.</span><span>query_devices</span><span>()):</span>
<span>        </span><span># Check if the microphone has max input channels:</span>
<span>        </span><span>if</span><span> </span><span>device</span><span>[</span><span>&#39;max_input_channels&#39;</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>:</span><span>  </span><span># (2)</span>
<span>            </span><span># Append i (the device id) and mic name:</span>
<span>            </span><span>microphones</span><span>.</span><span>append</span><span>((</span><span>i</span><span>,</span><span> </span><span>device</span><span>[</span><span>&#39;name&#39;</span><span>]))</span>
<span>    </span><span>return</span><span> </span><span>microphones</span>

<span>def</span><span> </span><span>record_audio_stream</span><span>(</span><span>filename</span><span>,</span><span> </span><span>device</span><span>=</span><span>None</span><span>,</span><span> </span><span>rate</span><span>=</span><span>44100</span><span>,</span><span> </span><span>channels</span><span>=</span><span>2</span><span>):</span>
<span>    </span><span># Create a list to store the audio data:</span>
<span>    </span><span>recorded_data</span><span> </span><span>=</span><span> </span><span>[]</span>

<span>    </span><span>with</span><span> </span><span>sounddevice</span><span>.</span><span>InputStream</span><span>(</span><span>samplerate</span><span>=</span><span>rate</span><span>,</span><span> </span><span>channels</span><span>=</span><span>channels</span><span>,</span><span> </span><span>device</span><span>=</span><span>device</span><span>)</span><span> </span><span>as</span><span> </span><span>stream</span><span>:</span><span>  </span><span># (3)</span>
<span>        </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>            </span><span># Record audio in chunks and add it the recorded_data list:</span>
<span>            </span><span>audio_chunk</span><span>,</span><span> </span><span>overflowed</span><span> </span><span>=</span><span> </span><span>stream</span><span>.</span><span>read</span><span>(</span><span>rate</span><span>)</span>
<span>            </span><span>recorded_data</span><span>.</span><span>extend</span><span>(</span><span>audio_chunk</span><span>.</span><span>tolist</span><span>())</span>

<span>            </span><span>if</span><span> </span><span>stop_recording_signal</span><span>.</span><span>is_set</span><span>():</span>
<span>                </span><span>break</span>

<span>    </span><span># Save the recorded data to a WAV file</span>
<span>    </span><span>wavio</span><span>.</span><span>write</span><span>(</span><span>filename</span><span>,</span><span> </span><span>recorded_data</span><span>,</span><span> </span><span>rate</span><span>,</span><span> </span><span>sampwidth</span><span>=</span><span>2</span><span>)</span><span>  </span><span># (4)</span>

<span># Display information about audio/visual recording devices:</span>
<span>print</span><span>(</span><span>&#39;Devices on this computer:&#39;</span><span>)</span>
<span>5</span><span>print</span><span>(</span><span>sounddevice</span><span>.</span><span>query_devices</span><span>())</span>
<span>print</span><span>()</span>

<span>print</span><span>(</span><span>&#39;Microphones connected to this computer:&#39;</span><span>)</span>
<span>print</span><span>(</span><span>list_microphone_devices</span><span>())</span>
<span>print</span><span>()</span>

<span># Create an event to signal the other thread to stop:</span>
<span>stop_recording_signal</span><span> </span><span>=</span><span> </span><span>threading</span><span>.</span><span>Event</span><span>()</span>

<span>input</span><span>(</span><span>&#39;Ready. Press Enter to start recording.&#39;</span><span>)</span>
<span># Start recording in a separate thread:</span>
<span>recording_thread</span><span> </span><span>=</span><span> </span><span>threading</span><span>.</span><span>Thread</span><span>(</span><span>target</span><span>=</span><span>record_audio_stream</span><span>,</span><span> </span><span>args</span><span>=</span><span>(</span><span>&#39;output.wav&#39;</span><span>,))</span><span>  </span><span># (6)</span>
<span>recording_thread</span><span>.</span><span>start</span><span>()</span>

<span># Wait for user to press Enter:</span>
<span>input</span><span>(</span><span>&#39;Now recording. Press Enter to stop.&#39;</span><span>)</span><span>  </span><span># (7)</span>

<span># Replace the previous input() call with this code to record for a set time:</span>
<span>#time.sleep(1.0)  # Record for 1 second.</span>

<span># Signal the recording thread to stop and wait for it to finish:</span>
<span>stop_recording_signal</span><span>.</span><span>set</span><span>()</span><span>  </span><span># (8)</span>
<span>recording_thread</span><span>.</span><span>join</span><span>()</span><span>  </span><span># (9) Block until the other thread has stopped.</span>
<span>print</span><span>(</span><span>&#39;Recording saved.&#39;</span><span>)</span>
</code></pre></div>

<p>There are several parts to this program aside from the actual recording of audio, so let’s explore those first. The <code>sounddevice.query_devices()</code> function (5) returns an object that, when printed, displays a numbered list of multimedia input and output devices on the computer, such as the following:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>sounddevice</span>
<span>&gt;&gt;&gt;</span><span> </span><span>print</span><span>(</span><span>sounddevice</span><span>.</span><span>query_devices</span><span>())</span>
<span>   </span><span>0</span><span> </span><span>Microsoft</span><span> </span><span>Sound</span><span> </span><span>Mapper</span><span> </span><span>-</span><span> </span><span>Input</span><span>,</span><span> </span><span>MME</span><span> </span><span>(</span><span>2</span><span> </span><span>in</span><span>,</span><span> </span><span>0</span><span> </span><span>out</span><span>)</span>
<span>&gt;</span><span>  </span><span>1</span><span> </span><span>Microphone</span><span> </span><span>Array</span><span> </span><span>(</span><span>Realtek</span><span> </span><span>High</span><span> </span><span>,</span><span> </span><span>MME</span><span> </span><span>(</span><span>2</span><span> </span><span>in</span><span>,</span><span> </span><span>0</span><span> </span><span>out</span><span>)</span>
<span>   </span><span>2</span><span> </span><span>Microsoft</span><span> </span><span>Sound</span><span> </span><span>Mapper</span><span> </span><span>-</span><span> </span><span>Output</span><span>,</span><span> </span><span>MME</span><span> </span><span>(</span><span>0</span><span> </span><span>in</span><span>,</span><span> </span><span>2</span><span> </span><span>out</span><span>)</span>
<span>&lt;</span><span>  </span><span>3</span><span> </span><span>Speaker</span><span>/</span><span>HP</span><span> </span><span>(</span><span>Realtek</span><span> </span><span>High</span><span> </span><span>Defini</span><span>,</span><span> </span><span>MME</span><span> </span><span>(</span><span>0</span><span> </span><span>in</span><span>,</span><span> </span><span>2</span><span> </span><span>out</span><span>)</span>
<span>   </span><span>4</span><span> </span><span>Primary</span><span> </span><span>Sound</span><span> </span><span>Capture</span><span> </span><span>Driver</span><span>,</span><span> </span><span>Windows</span><span> </span><span>DirectSound</span><span> </span><span>(</span><span>2</span><span> </span><span>in</span><span>,</span><span> </span><span>0</span><span> </span><span>out</span><span>)</span>
<span>   </span><span>5</span><span> </span><span>Microphone</span><span> </span><span>Array</span><span> </span><span>(</span><span>Realtek</span><span> </span><span>High</span><span> </span><span>Definition</span><span> </span><span>Audio</span><span>),</span><span> </span><span>Windows</span><span> </span><span>DirectSound</span><span> </span><span>(</span><span>2</span><span> </span><span>in</span><span>,</span><span> </span><span>0</span><span> </span><span>out</span><span>)</span>
<span>--</span><span>snip</span><span>--</span>
</code></pre></div>

<p>This lists the various microphone input and speaker output devices on your computer, along with their integer <code>sounddevice</code> index. The <code>&gt;</code> angle bracket marks the default input device and the <code>&lt;</code> angle bracket marks the default output device. This program also has a <code>list_microphone_devices()</code> function (1) that calls <code>sounddevice.query_devices()</code> and filters for only the microphone devices (which will have a <code>max_input_channels</code> key with a value greater than <code>0</code> (2)) to make it easy to find microphones. The <code>list_microphone_devices()</code> returns a list of tuples, with each tuple having the device index and string description, like:</p>
<div><pre><span></span><code>[(0, &#39;Microsoft Sound Mapper - Input&#39;), (1, &#39;Microphone Array (Realtek High &#39;), --snip—
</code></pre></div>

<p>The program also has a <code>record_audio_stream()</code> function, with the following parameters:</p>
<ul>
<li><code>filename</code>, a string of the filename (which should end with .wav) to save the audio.</li>
<li><code>device</code>, the integer <code>sounddevice</code> index of the microphone to use to record the audio (the default value None indicates that the default input device should be used.)</li>
<li><code>rate</code>, the number of samples to take per second. Higher sample rates provide higher quality audio, and 44.1k (or the integer <code>44100</code>) is a standard sample rate for most microphones.</li>
<li><code>channels</code>, the number of channels to use. The default stereo audio uses 2 channels and mono audio uses 1.</li>
</ul>
<p>These parameters are used to create the <code>InputStream</code> object (3) that represents the recording from the given microphone. The <code>while</code> loop that follows constantly reads audio data in from the <code>read()</code> method call, which is a list of audio sample data that is added to the <code>recorded_data</code> list. The recording stops and breaks out of the <code>while</code> loop when the <code>stop_recorded_signal</code> thread event is set (explained later). Then the <code>wavio.write()</code> function (4) saves it to a <em>.wav</em> audio file.</p>
<p>We use a separate thread of execution to have our program run the code inside the <code>record_audio_stream()</code> function while the rest of the code continues to also run. Multithreaded programming was explained in Chapter 19. First we create a <code>Thread</code> object set with the <code>record_audio_stream</code> (without the parentheses, since we want to refer to the function itself rather than call it) and the function arguments <code>&#39;output.wav&#39;</code> for its filename parameter. For the sake of this explanation, we’ll call this the “recording thread” and the program’s original thread that continues in the main part of the program the “main thread.”</p>
<p>Next, we don’t want to call <code>record_audio_stream()</code> directly. Instead, we call the <code>start()</code> method on this <code>Thread</code> object so the recording thread runs the code inside <code>record_audio_stream()</code> (6) while the main thread continues on to <code>input(&#39;Now recording. Press Enter to stop.&#39;)</code> (7). This way, the user can choose when to stop the recording by pressing Enter. (Alternatively, we can replace the call to <code>input()</code> with a call to <code>time.sleep()</code> to record a set number of seconds instead of however long until the user presses Enter.) The user input thread then calls <code>stop_recording_signal.set()</code> (8). The recording thread will notice this when <code>stop_recording_signal.is_set()</code> returns <code>True</code>, causing it to break out of the <code>while</code> loop that continuously calls <code>stream.read()</code>.</p>
<p>Finally, the user input thread calls <code>recording_thread.join()</code> (9), making it pause until the recording thread has returned from the <code>record_audio_stream()</code> function. Now there will be only the user input thread running, which then calls <code>print(&#39;Recording saved.&#39;)</code> and exits the program.</p>
<p>This program is rather complicated, but that’s because it has to handle so many small details: selecting which of possibly multiple microphones to record from, the sample rate and number of audio channels to use for the recording, and constantly gathering the audio data until the user directs the program to stop. The <code>sounddevice</code> and <code>wavio</code> modules themselves offer even more features, and you can find their full documentation at <a href="https://python-sounddevice.readthedocs.io/">https://python-sounddevice.readthedocs.io/</a> and <a href="https://github.com/WarrenWeckesser/wavio">https://github.com/WarrenWeckesser/wavio</a>.</p>
<h2>Playing Audio Files</h2>
<p>If you just need to play a simple audio file, you can use the <code>playsound</code> module. First, install it from the terminal by running <code>pip install playsound</code>. See Appendix A for full instructions. Once installed, you can play an audio file by calling the <code>playsound</code> module’s <code>playsound()</code> function and passing the filename of the audio file. Download the <em>hello.mp3</em> file from <a href="https://autbor.com/hello.mp3">https://autbor.com/hello.mp3</a> (or use your own .mp3 file) and enter the following into the interactive shell:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>playsound</span>
<span>&gt;&gt;&gt;</span><span> </span><span>playsound</span><span>.</span><span>playsound</span><span>(</span><span>&#39;hello.mp3&#39;</span><span>)</span>
</code></pre></div>

<p>The <code>playsound()</code> function won’t return until the audio file has finished playing, that is, the function blocks until the audio has finished. Keep in mind that this will halt your program for a while if you give it a long audio file to play. The <code>playsound</code> module can play MP3 and WAV files. If you cannot hear the sound, make sure your computer is unmuted. If <code>playsound()</code> raises exceptions (which happens if the filename contains odd characters such as an equal sign), try passing a <code>Path</code> object of the audio file instead of a string, as in the following example:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>playsound</span>
<span>&gt;&gt;&gt;</span><span> </span><span>from</span><span> </span><span>pathlib</span><span> </span><span>import</span><span> </span><span>Path</span>
<span>&gt;&gt;&gt;</span><span> </span><span>audio_file</span><span> </span><span>=</span><span> </span><span>Path</span><span>(</span><span>r</span><span>&#39;C:\Users\Al\Desktop\hello.mp3&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>playsound</span><span>.</span><span>playsound</span><span>(</span><span>audio_file</span><span>)</span>
</code></pre></div>

<p>The <code>playsound</code> module is best if you just need to play a simple sound effect and you want your program to block until the sound has finished. If you need to have better control over playback, such as changing volume, pausing and unpausing the audio file, seeking to a specific time in the audio, and other features, use the Pygame’s <code>mixer</code> module.</p>
<p>For example, to play <em>hello.mp3</em> with Pygame, enter the following into the interactive shell:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>pygame.mixer</span>
<span>&gt;&gt;&gt;</span><span> </span><span>pygame</span><span>.</span><span>mixer</span><span>.</span><span>init</span><span>()</span>
<span>&gt;&gt;&gt;</span><span> </span><span>pygame</span><span>.</span><span>mixer</span><span>.</span><span>music</span><span>.</span><span>load</span><span>(</span><span>&#39;hello.mp3&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>pygame</span><span>.</span><span>mixer</span><span>.</span><span>music</span><span>.</span><span>play</span><span>()</span>
</code></pre></div>

<p>With Pygame, you must call the <code>pygame.mixer.init()</code> function once after importing the <code>pygame.mixer</code> module in order to play any audio files. Then load the audio file by calling <code>pygame.mixer.music.load()</code> and pass either a string or <code>Path</code> object of the audio file’s filename. Calling <code>pygame.mixer.music.play()</code> starts playing the loaded audio file from the beginning. The <code>play()</code> function doesn’t block; it returns immediately and the audio continues to play in the background while your Python program runs other lines of code.</p>
<p>You can continue to affect the playing of the music with the other functions in the <code>pygame.mixer.music</code> module. All of these functions are non-blocking and return immediately:</p>
<ul>
<li><code>pygame.mixer.music.stop()</code> stops playing the music immediately.</li>
<li><code>pygame.mixer.music.pause()</code> stops playing the music, but will resume where it left off when unpaused.</li>
<li><code>pygame.mixer.music.unpause()</code> resumes playing paused music.</li>
<li><code>pygame.mixer.music.fadeout(milliseconds)</code> fades the volume of the music down to silence over the next <em><code>milliseconds</code></em> milliseconds. For example, passing <code>2000</code> will fade out the music over the next 2 seconds after the function call.</li>
<li><code>pygame.mixer.music.get_volume()</code> returns a float of the volume level for the <code>pygame.mixer</code> music, with <code>1.0</code> for full volume and <code>0.0</code> for muted volume.</li>
<li><code>pygame.mixer.music.set_volume(level)</code> lets you set the volume by passing a float between <code>1.0</code> and <code>0.0</code>.</li>
<li><code>pygame.mixer.music.get_busy()</code> returns <code>True</code> if music is currently playing and False if the music has finished, stopped, or paused.</li>
<li><code>pygame.mixer.music.get_pos()</code> returns the position in the audio file Pygame&#39;s mixer module is playing it (or, if paused, would play it) in milliseconds. For example, returning 0 means the position is at the very start of the audio file and returning <code>5000</code> means the position is 5 seconds into the audio file.</li>
<li><code>pygame.mixer.music.set_pos(position)</code> sets the position in the audio file to play. The position parameter is a float or int for the number of seconds into the audio. The audio must currently be playing to call set_pos().</li>
<li><code>pygame.mixer.music.queue(audio_filename)</code> lets you set another audio file to begin playing as soon as the current one has finished. The audio_filename parameter is either a string or a Path object of the audio file to queue.</li>
</ul>
<p>Pygame also has other audio features such as playing multiple sound files at the same time. The full documentation is at <a href="https://www.pygame.org/docs/">https://www.pygame.org/docs/</a>.</p>
<h2>Working with Video Files</h2>
<p>The programs you create from this book have text-based input and output with the <code>input()</code> and <code>print()</code> commands, so displaying images and videos in a conventional graphical user interface (GUI) is beyond the scope of this book. However, your Python programs can still download videos from the internet without a GUI and control the playback of the video in VLC Media Player, as you’ll learn in this section.</p>
<h3>Downloading Videos from YouTube</h3>
<p>The main limitation of YouTube and other video sites is that you can only view the videos in a browser while online. You can’t edit the videos to extract clips or make adjustments. The yt-dlp tool is a fork of the youtube-dl project, and can download videos as files from YouTube, Vimeo, Facebook, TikTok, Instagram, and hundreds of other video websites. You can install it by running <code>pip install yt-dlp</code> from the terminal. Appendix A has full instructions.</p>
<p>The yt-dlp project is both a terminal command and a Python module. We’ll focus on the terminal command first but also explore how to incorporate it in your Python programs. Both youtube-dl and yt-dlp are written in Python. Because video websites change their layout from time to time, you’ll need to always run the latest version of yt-dlp. You can make yt-dlp update itself by running <code>yt-dlp -U</code>. The yt-dlp command uses <em>calver</em> or <em>calendar versioning</em>, so the version number is always the date of that version’s release. For example, version 2023.07.06 was released on July 6, 2023.</p>
<p>To download a video, run the <code>yt-dlp</code> command from a terminal with the video’s URL as the command-line argument:</p>
<div><pre><span></span><code><span>C</span><span>:</span><span>\</span><span>Users</span><span>\</span><span>Al</span><span>\</span><span>Desktop</span><span>&gt;</span><span>yt</span><span>-</span><span>dlp</span><span> </span><span>https</span><span>:</span><span>//</span><span>youtu</span><span>.</span><span>be</span><span>/</span><span>mDNa10gQTJA</span>
<span>[</span><span>youtube</span><span>]</span><span> </span><span>Extracting</span><span> </span><span>URL</span><span>:</span><span> </span><span>https</span><span>:</span><span>//</span><span>youtu</span><span>.</span><span>be</span><span>/</span><span>mDNa10gQTJA</span>
<span>[</span><span>youtube</span><span>]</span><span> </span><span>mDNa10gQTJA</span><span>:</span><span> </span><span>Downloading</span><span> </span><span>webpage</span>
<span>--snip--</span>
</code></pre></div>

<p>If the URL contains characters such as an ampersand or spaces, you may have to enclose them in double quotes. The filename is automatically made from the video description. To specify your own filename for the downloaded video file, pass the <code>-o</code> argument:</p>
<div><pre><span></span><code>C:\Users\Al\Desktop&gt;yt-dlp -o catvideo.webm https://youtu.be/mDNa10gQTJA
</code></pre></div>

<p>If the video is a music video and you only want the audio data, pass the <code>-x</code> argument to extract the audio:</p>
<div><pre><span></span><code>C:\Users\Al\Desktop&gt;yt-dlp -x https://youtu.be/9RHFFeQ2tu4
</code></pre></div>

<p>Depending on the video and video website, the audio format may be an <em>.mp3</em>, <em>.ogg</em>, or <em>.webm</em> file. You can convert it to another audio format with ffmpeg, explained later in this chapter.</p>
<p>If a video requires that you must be logged in to view it, log into the site in your browser and then run yt-dlp with the <code>--cookies-from-browser</code> argument followed by the name of the browser (either <code>Firefox</code>, <code>Chrome</code>, <code>Edge</code>, or <code>Safari</code>). This makes yt-dlp examine your browser’s cookies to reuse the login session information there:</p>
<div><pre><span></span><code>C:\Users\Al\Desktop&gt;yt-dlp --cookies-from-browser Firefox https://youtu.be/mDNa10gQTJA
</code></pre></div>

<p>You can also specify the username and password of the account with the <code>-u</code> and <code>-p</code> command line arguments. You can leave out the <code>-p</code> argument to have yt-dlp ask you to enter the password at the keyboard.</p>
<div><pre><span></span><code>C:\Users\Al\Desktop&gt;yt-dlp -u my_username -p secret_passw0rd https://youtu.be/9RHFFeQ2tu4
</code></pre></div>

<p>There are many features for downloading videos with yt-dlp, such as downloading entire playlists, using a VPN proxy, downloading subtitles, and others. To view all of them, run <code>yt-dlp --help</code>.</p>
<h3>Running yt-dlp from Python</h3>
<p>You can also download videos using yt-dlp using Python code. The module name is <code>yt_dlp</code>, which lets you create <code>YoutubeDL</code> objects. Despite the name, the <code>YoutubeDL</code> object can download videos from any video website that yt-dlp supports. Open a new file and add the following code for a minimal program that downloads videos with the `yt_dlp module. Name it <em>videoDownloader.py</em>:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>yt_dlp</span><span> </span><span>import</span><span> </span><span>YoutubeDL</span>
<span>URLs</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;https://www.youtube.com/watch?v=BaW_jenozKc&#39;</span><span>]</span><span>  </span><span># Add video URLs here.</span>
<span>with</span><span> </span><span>YoutubeDL</span><span>()</span><span> </span><span>as</span><span> </span><span>ydl</span><span>:</span>
<span>    </span><span>ydl</span><span>.</span><span>download</span><span>(</span><span>URLs</span><span>)</span>
</code></pre></div>

<p>The yt-dlp documentation at <a href="https://pypi.org/project/yt-dlp/">https://pypi.org/project/yt-dlp/</a> has more information on supplying the download() function with more options.</p>
<p>Alternatively, you can run the yt-dlp terminal command from a Python script using the <code>subprocess.run()</code> function:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>subprocess</span>
<span>&gt;&gt;&gt;</span><span> </span><span>subprocess</span><span>.</span><span>run</span><span>([</span><span>&#39;yt-dlp&#39;</span><span>,</span><span> </span><span>&#39;https://www.youtube.com/watch?v=BaW_jenozKc&#39;</span><span>])</span>
</code></pre></div>

<p>If you want the video’s metadata, such as duration, number of views, or description, you can download this as JSON data using the <code>-J</code> argument. Chapter 19 covers using the <code>subprocess</code> module to run terminal commands from a Python program and capture their output as strings. Chapter 18 covers the <code>json</code> module and how to work with JSON data. Let’s look at the following example of parsing a video’s metadata as JSON from Python code:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>json</span><span>,</span><span> </span><span>subprocess</span>
<span>&gt;&gt;&gt;</span><span> </span><span>proc</span><span> </span><span>=</span><span> </span><span>subprocess</span><span>.</span><span>run</span><span>([</span><span>&#39;yt-dlp&#39;</span><span>,</span><span> </span><span>&#39;-J&#39;</span><span>,</span><span> </span><span>&#39;https://youtu.be/mDNa10gQTJA&#39;</span><span>],</span><span> </span><span>capture_output</span><span>=</span><span>True</span><span>,</span><span> </span><span>text</span><span>=</span><span>True</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>json_text</span><span> </span><span>=</span><span> </span><span>proc</span><span>.</span><span>stdout</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span> </span><span>=</span><span> </span><span>json</span><span>.</span><span>loads</span><span>(</span><span>json_text</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>list</span><span>(</span><span>python_data</span><span>.</span><span>keys</span><span>())</span>
<span>[</span><span>&#39;id&#39;</span><span>,</span><span> </span><span>&#39;title&#39;</span><span>,</span><span> </span><span>&#39;formats&#39;</span><span>,</span><span> </span><span>&#39;thumbnails&#39;</span><span>,</span><span> </span><span>&#39;thumbnail&#39;</span><span>,</span><span> </span><span>&#39;description&#39;</span><span>,</span><span> </span><span>&#39;channel_id&#39;</span><span>,</span><span> </span><span>&#39;channel_url&#39;</span><span>,</span><span> </span><span>&#39;duration&#39;</span><span>,</span><span> </span><span>&#39;view_count&#39;</span><span>,</span><span> </span><span>--</span><span>snip</span><span>--</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span>[</span><span>&#39;title&#39;</span><span>]</span>
<span>&#39;Sister cats Grace, Mercy, and Patience love each other very much.&#39;</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span>[</span><span>&#39;description&#39;</span><span>]</span>
<span>&#34;These were kittens I rescued from a backyard cat colony in Houston in October 2021. Grace (gray), Mercy (brown tabby), and Patience (tortoiseshell) probably aren&#39;t actually sisters, but they grew up together in my house and are the same age and--snip--</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span>[</span><span>&#39;duration&#39;</span><span>]</span><span>  </span><span># In seconds.</span>
<span>116</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span>[</span><span>&#39;view_count&#39;</span><span>]</span>
<span>1797</span>
<span>&gt;&gt;&gt;</span><span> </span><span>python_data</span><span>[</span><span>&#39;upload_date&#39;</span><span>]</span><span>  </span><span># In YYYYMMDD format.</span>
<span>&#39;20220903&#39;</span>
</code></pre></div>

<p>Every video website returns different metadata, so the <code>list(python_data.keys())</code> part of our example can show you the dictionary keys that are available.</p>
<h2>Play a Video File</h2>
<p>Playing a video file from your Python program is complicated. For the most part, this book covers Python programs that don’t use a graphical user interface. However, if you just need a video to play somewhere on your screen, you can install VLC Media Player and then use the third-party python-vlc library to display videos in their own window. After installing VLC Media Player, run pip install python-vlc to install the module that lets you control VLC from your Python programs. See Appendix A for full instructions.</p>
<p>Once installed, you can then use the vlc module to create an Instance, MediaPlayer, and Media object. Just replace the &#39;video.mp4&#39; string with the filename of the video file you want to play. Enter the following into the interactive shell with a video file named video.mp4 in the current working directory:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>vlc</span>
<span>&gt;&gt;&gt;</span><span> </span><span>instance</span><span> </span><span>=</span><span> </span><span>vlc</span><span>.</span><span>Instance</span><span>(</span><span>&#39;--no-xlib&#39;</span><span>,</span><span> </span><span>&#39;--quiet&#39;</span><span>)</span><span>  </span><span># These arguments stop debug output.</span>
<span>&gt;&gt;&gt;</span><span> </span><span>player</span><span> </span><span>=</span><span> </span><span>instance</span><span>.</span><span>media_player_new</span><span>()</span>
<span>&gt;&gt;&gt;</span><span> </span><span>media</span><span> </span><span>=</span><span> </span><span>instance</span><span>.</span><span>media_new</span><span>(</span><span>&#39;video.mp4&#39;</span><span>)</span><span>  </span><span># Replace with your filename.</span>
<span>&gt;&gt;&gt;</span><span> </span><span>player</span><span>.</span><span>set_media</span><span>(</span><span>media</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>player</span><span>.</span><span>play</span><span>()</span>
</code></pre></div>

<p>The <code>play()</code> method call causes the video to appear in a new window and start playing until it has finished. This method immediately returns; it doesn’t block until the video has finished playing. You can also call other <code>MediaPlayer</code> methods:</p>
<ul>
<li><code>pause()</code> will pause the video, and unpauses when play() is called again.</li>
<li><code>stop()</code> will immediately stop the video and close the video’s window.</li>
<li><code>is_playing()</code> returns 1 if the video is currently playing and returns 0 if the video is paused, stopped, or has finished. (In Python, True is equal to 1 and False is equal to 0.)</li>
<li><code>get_length()</code> returns an integer of the video length in milliseconds.</li>
<li><code>get_fps()</code> returns the frame rate of the video in frames per second.</li>
<li><code>get_time()</code> returns the position currently playing in the video, in milliseconds. Returns -1 if the video is stopped.</li>
<li><code>set_time(seek)</code> sets the position of the video to seek milliseconds. This can only be called while the video is playing or is paused.</li>
<li><code>toggle_fullscreen()</code> switches the video window between windowed and fullscreen mode.</li>
<li><code>audio_get_volume()</code> returns an integer of the MediaPlayer object’s volume: 100 is full volume and 0 is muted.</li>
<li><code>audio_set_volume(volume)</code> sets the MediaPlayer object’s volume to the volume integer, which can be greater than 100.</li>
<li><code>video_get_size()</code> returns a tuple of two integers of the width and height of the video in pixels.</li>
<li><code>video_take_snapshot(0, &#39;.&#39;, 0, 0)</code> takes a snapshot of the current frame. The first <code>0</code> argument is for the “video output number” which is usually zero, the <code>&#39;.&#39;</code> argument tells VLC to save the snapshot image file in the current working directory, and the third and fourth arguments are the width and height of the snapshot (with the <code>0</code> arguments meaning “use the original video’s width and height”). The snapshot image filename will be “vlcsnap” followed by a timestamp, such as <em>vlcsnap-2025-08-21-15h21m32s719.png</em>. The method returns <code>0</code> if the snapshot was successful and <code>-1</code> if it failed for some reason.</li>
</ul>
<p>While the <code>vlc</code> module doesn’t provide much in the way a graphical user interface, the popup video window is enough for your basic Python programs to display a video clip as needed.</p>
<h2>Editing Video and Audio with ffmpeg</h2>
<p>One of the most powerful tools for editing video and audio content is the <code>ffmpeg</code> command. While ffmpeg has no user-friendly graphical user interface like other apps (though ffmpeg GUI extensions have been separately made), it does have an extensive set of command line arguments. This makes it easy to automate from Python programs which is invaluable if you have a large number of multimedia files to process.</p>
<h3>Downloading and Installing ffmpeg</h3>
<p>The ffmpeg command is available for Windows, macOS, and Linux. You can download it from <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a>. The ffmpeg website also has an ffplay and ffprobe programs available for download. The ffplay is a terminal command that plays video and audio files in a barebones window while the ffprobe command extracts information about video and audio files. There is no installer for these commands. Instead, just place the ffmpeg, ffplay, and ffprobe executable files into a folder on your system PATH. (On Ubuntu Linux, you may be able to install them with the <code>sudo apt install ffmpeg</code> command.) See Chapter 12 for an explanation of the PATH environment variable and working on the terminal command-line in general.</p>
<p>On macOS, the ffmpeg, ffprobe, and ffplay programs might not run from the terminal since they don’t have a digital signature. Double-click on these commands in the Finder, and in the warning window about “unidentified developer,” click the Open button. This tells macOS that you consider these programs safe to run. You’ll only have to do this once for each program. </p>
<h3>ffmpeg Recipes</h3>
<p>The ffmpeg program’s set of command line arguments is far too complicated to cover in this book. Instead, this chapter features specific recipes for carrying out common editing tasks.</p>
<p>The ffmpeg program produces a lot of output. You can hide all of this by passing the <code>-loglevel</code> warning command-line arguments, which suppresses all logging output except for warnings and errors. For example, instead of running <code>ffmpeg -i input.mp4 output.avi</code> to show you all the information associated with converting an <em>.mp4</em> video file to an <em>.avi</em> file, you can run <code>ffmpeg -loglevel warning -i input.mp4 output.avi</code> to do the conversion with no output.</p>
<p>In all of the ffmpeg recipes, the input file follows the <code>-i</code> command line argument and the output file is placed at the very end of the command after all the other command line arguments.</p>
<p>If a file already exists with the output filename you passed to ffmpeg, then ffmpeg pauses and asks for confirmation to overwrite this file by asking the user to press <code>y</code> and Enter on the keyboard. This pause can interrupt your programs, so the <code>-y</code> argument you see in the ffmpeg recipes causes ffmpeg to skip this confirmation step.</p>
<p>You can run the ffmpeg command from your Python scripts using the <code>subprocess.run()</code> function, as covered in Chapter 19. Remember to run <code>import subprocess</code> first before calling <code>subprocess.run()</code>.</p>
<p>You can transform the audio or video of your files with ffmpeg’s many filters. The recipes here explain some, but you can view the full list by running <code>ffmpeg -filters</code> and then get help information about a specific filter by running <code>ffmpeg -h filter=</code><em><code>filter_name</code></em>.</p>
<p>The ffmpeg command has a vast set of command line arguments for doing almost any kind of editing you’d like from a terminal window or Python script. If you don’t have the time to read through its documentation, you can ask an AI large language model such as ChatGPT for the command. For example, you could give it the prompt: “What is the ffmpeg command for converting a video to black and white?” and receive the command along with an explanation of each command-line argument. Be sure to test the information the AI gives you, as it often makes mistakes.</p>
<p>Alternatively, the website <a href="https://ffmpeg.app/">https://ffmpeg.app/</a> features an interactive prompt system that reliably guides you to an ffmpeg command with arguments to carry out your intended actions. The website looks like Figure 24-2:</p>
<p><img src="https://interjectedfuture.com/blogstatic/lost-av-ffmpeg1.webp"/></p>
<p><img src="https://interjectedfuture.com/blogstatic/lost-av-ffmpeg2.webp"/></p>
<p><em>The website <a href="https://ffmpeg.app">https://ffmpeg.app</a> helps you find command line arguments.</em></p>
<p>Keep in mind that ffmpeg can not only edit video and audio, it can also edit image files as well. Instead of specifying a video file with <code>-i input.mp4</code> or <code>output.mp4</code> command line arguments, for images you can use <code>-i input.png</code> or <code>output.webp</code> If ffmpeg gives you an error message about how the output filename “does not contain an image sequence pattern” you can include the <code>-update 1</code> argument. See the <em>Extract Frames from a Video</em> section for more information about sequence patterns and the <code>-update</code> argument.</p>
<h4>View Video and Audio File Metadata with ffprobe</h4>
<p>The ffprobe command (which comes with ffmpeg) can give you a large amount of information about a video or audio file. Its basic usage looks like this:</p>


<p>This command produces a large amount of text output with details about the <em>input.mp4</em> file:</p>
<div><pre><span></span><code><span>ffprobe</span><span> </span><span>version</span><span> </span><span>N</span><span>-</span><span>109948</span><span>-</span><span>ge026e29460</span><span>-</span><span>20230301</span><span> </span><span>Copyright</span><span> </span><span>(</span><span>c</span><span>)</span><span> </span><span>2007</span><span>-</span><span>2023</span><span> </span><span>the</span><span> </span><span>FFmpeg</span><span> </span><span>developers</span>
<span>  </span><span>built</span><span> </span><span>with</span><span> </span><span>gcc</span><span> </span><span>12.2</span><span>.</span><span>0</span><span> </span><span>(</span><span>crosstool</span><span>-</span><span>NG</span><span> </span><span>1.25</span><span>.</span><span>0.90</span><span>_cf9beb1</span><span>)</span>
<span>--</span><span>snip</span><span>--</span>
<span>  </span><span>Stream</span><span> </span><span>#0:0[0x1](eng): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 191 kb/s (default)</span>
<span>--</span><span>snip</span><span>--</span>
<span>  </span><span>Stream</span><span> </span><span>#0:1[0x2](eng): Video: h264 (High) (avc1 / 0x31637661), yuvj420p(pc, smpte170m/bt470bg/smpte170m, progressive), 1920x1080, 22582 kb/s, SAR 1:1 DAR 16:9, 30.01 fps, 30 tbr, 90k tbn (default)</span>
<span>--</span><span>snip</span><span>--</span>
</code></pre></div>

<p>You can also run this command from the following Python instruction, which saves the output as a string in <code>proc.stderr</code>:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>subprocess</span>
<span>&gt;&gt;&gt;</span><span> </span><span>proc</span><span> </span><span>=</span><span> </span><span>subprocess</span><span>.</span><span>run</span><span>([</span><span>&#39;ffprobe&#39;</span><span>,</span><span> </span><span>&#39;input.mp4&#39;</span><span>],</span><span> </span><span>capture_output</span><span>=</span><span>True</span><span>,</span><span> </span><span>text</span><span>=</span><span>True</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>print</span><span>(</span><span>proc</span><span>.</span><span>stderr</span><span>)</span>
<span>ffprobe</span><span> </span><span>version</span><span> </span><span>N</span><span>-</span><span>109948</span><span>-</span><span>ge026e29460</span><span>-</span><span>20230301</span><span> </span><span>Copyright</span><span> </span><span>(</span><span>c</span><span>)</span><span> </span><span>2007</span><span>-</span><span>2023</span><span> </span><span>the</span><span> </span><span>FFmpeg</span><span> </span><span>developers</span>
<span>--</span><span>snip</span><span>--</span>
</code></pre></div>

<p>Video and audio files contain streams of encoded video and audio data. For example, a movie video file may have a stream of video data and multiple audio streams for English, Spanish, and French dubs. The ffprobe command can show you these streams and their associated information. For example, this <em>input.mp4</em> file has audio encoded with the AAC codec and video that has 30.01 frames per second (fps) and a size of 1920x1080. If you want your program to extract this information, you’ll likely need to use regular expressions (covered in Chapter 9).</p>
<p>For example, you can enter this code into the interactive shell to use regular expressions to find the 1920 x 1080 width and height dimensions of an <em>input.mp4</em> video file:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> </span><span>subprocess</span><span>,</span><span> </span><span>re</span>
<span>&gt;&gt;&gt;</span><span> </span><span>proc</span><span> </span><span>=</span><span> </span><span>subprocess</span><span>.</span><span>run</span><span>([</span><span>&#39;ffprobe&#39;</span><span>,</span><span> </span><span>&#39;input.mp4&#39;</span><span>],</span><span> </span><span>capture_output</span><span>=</span><span>True</span><span>,</span><span> </span><span>text</span><span>=</span><span>True</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>mo</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>search</span><span>(</span><span>&#39;Video.*, (\d+)x(\d+),&#39;</span><span>,</span><span> </span><span>proc</span><span>.</span><span>stderr</span><span>)</span>
<span>&gt;&gt;&gt;</span><span> </span><span>int</span><span>(</span><span>mo</span><span>.</span><span>group</span><span>(</span><span>1</span><span>))</span>
<span>1920</span>
<span>&gt;&gt;&gt;</span><span> </span><span>int</span><span>(</span><span>mo</span><span>.</span><span>group</span><span>(</span><span>2</span><span>))</span>
<span>1080</span>
</code></pre></div>

<p>Using code like this, you could then find the dimensions of, say, each video file in a folder. This is similar to the <code>video_get_size()</code> method in the <code>vlc</code> module, though ffprobe can read far more detail than just video size.</p>
<p>You can run <code>ffprobe --help</code> to view the command-line options, but the output is over 2,400 lines long! It may be useful to ask a large language model AI for specific command line arguments to pass to ffprobe for a given task if you are overwhelmed by the documentation.</p>
<p>The next several sections cover individual ffmpeg commands along with their command line arguments for performing a number of common video-related tasks. We’ll be using example filenames such as <em>input.mp4</em> and <em>output.mp4</em>, and keep in mind that ffmpeg won’t modify the input video and audio files; it only produces a new video or audio file with the changes as the output. You can download some short example files to practice with from <a href="https://autbor.com/input_ffmpeg.zip">https://autbor.com/input_ffmpeg.zip</a>.</p>
<h4>Convert Video and Audio File Formats</h4>
<p>You can convert video and audio files from one format to another with this terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 output.avi

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;output.avi&#39;])
</code></pre></div>

<p>The <code>-i</code> option indicates that the <code>input.mp4</code> file is the input file, which is then converted to an <em>.avi</em> file named <em>output.avi</em>. You can specify any video file formats you want, including <em>.gif</em> for an animated GIF. Remember that ffmpeg works with image files as well, so you can convert a <em>.png</em> to a <em>.webp</em> or any other format.</p>
<h4>Extract Audio from a Video</h4>
<p>You can extract the audio from a video file with this terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 output.mp3

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;output.mp3&#39;])
</code></pre></div>

<p>This is the same set of arguments as converting formats. The ffmpeg command can understand that if the output file is an <em>.mp3</em> audio file (or any other audio file format), the video data is dropped and only the audio data is used.</p>
<h4>Mute or Change Volume in a Video File</h4>
<p>You can increase, decrease, or mute the volume in a video file with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -af volume=2.0 output.mp4

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-af&#39;, &#39;volume=2.0&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-af</code> argument specifies an audio filter named volume to change the volume by a factor of 2.0, or double the volume of the <code>input.mp4</code> file. The video with the new volume is in <code>output.mp4</code>. If you wanted to halve the volume, you could pass <code>volume=0.5</code> instead. You could also change the volume by a number of decibels. For example, passing <code>volume=5dB</code> increases the volume of the input file by 5 decibels. You could also pass <code>volume=-5dB</code> to decrease the volume by 5 decibels.</p>
<p>If you want to simply mute the volume by removing the audio data completely, pass the <code>-an</code> argument:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -c:v copy -an output.mp4

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-c:v&#39;, &#39;copy&#39;, &#39;-an&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-c:v</code> copy argument means that ffmpeg will copy the video stream data from <code>input.mp4</code> directly to <code>output.mp4</code> without re-encoding it. The <code>-an</code> argument removes the audio stream data altogether. Keep in mind that once you completely mute the volume on a video, you won’t be able to increase the volume later.</p>
<h4>Combine a Video and Audio File</h4>
<p>You can add an audio file to a silent video with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input_video.mp4 -i input_audio.mp3 -c copy output.mp4

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input_video.mp4&#39;, &#39;-i&#39;, &#39;input_audio.mp3&#39;, &#39;-c&#39;, &#39;copy&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-c copy</code> arguments copy the video and audio stream data without re-encoding, respectively. If the audio has some problems because the video format doesn’t support it, try replacing <code>-c copy</code> with <code>-c:v copy -c:a aac</code> to copy the video but re-encode the audio with the widely-supported AAC audio codec.</p>
<p>If the video already has audio, but you want to replace it with the audio in a separate audio file, run the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i video.mp4 -i audio.mp3 -c copy -map 0:v:0 -map 1:a:0 output.mp4

&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;video.mp4&#39;, &#39;-i&#39;, &#39;audio.mp3&#39;, &#39;-c&#39;, &#39;copy&#39;, &#39;-map&#39;, &#39;0:v:0&#39;, &#39;-map&#39;, &#39;1:a:0&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-map 0:v:0 -map 1:a:0</code> arguments direct ffmpeg to use the video stream from the first input, <code>video.mp4</code>, and the audio from the second input, <code>audio.mp3</code>, when creating the <code>output.mp4</code> file. The original audio stream data in <code>video.mp4</code> is dropped.</p>
<h4>Resize a Video</h4>
<p>You can resize a video with this terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf scale=1280:720 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;scale=1280:720&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-vf</code> indicates you are using a video filter, in this case a filter named <code>scale</code> that scales the size of the video to 1280 x 720 resolution and outputs it to a video file named <code>output.mp4</code>. You can change the resolution to any dimensions you want.</p>
<h4>Extract a Video or Audio Segment</h4>
<p>You can extract a segment from a video or audio file with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -ss 00:01:30 -to 00:01:45 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-ss&#39;, &#39;00:01:30&#39;, &#39;-to&#39;, &#39;00:01:45&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-ss</code> argument and <code>-to</code> arguments mark the starting and ending times of the segment to extract, given in an <em>HH:MM:SS</em> format. So <code>-ss 00:01:30 -to 00:01:45</code> means extract the video or audio content from 1 minute, 30 seconds to 1 minute, 45 seconds from <code>input.mp4</code> file. This will result in a 15 second segment placed in a file named <code>output.mp4</code>. You can change the starting and ending timestamps as needed.
To extract an audio segment from an audio file, use the audio filenames for the input and output file. The rest of the command remains the same. You can use an ffprobe recipe described later in this chapter to find out the length of the video or audio content in a file.</p>
<h4>Extract Frames from a Video</h4>
<p>You can extract a single frame from a video with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -ss 00:00:15 -vframes 12 output%04d.jpg
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-ss&#39;, &#39;00:00:15&#39;, &#39;-vframes&#39;, &#39;12&#39;, &#39;output%04d.jpg&#39;])
</code></pre></div>

<p>The <code>-vframes 12</code> and <code>-ss 00:00:15</code> arguments mean that 12 frames are extracted from the video starting at 15 seconds into the video is extracted and placed into an image file named <em>output0001.jpg</em>. The <code>%04d</code> in the <code>output%04d.jpg</code> output name is a sequence pattern that means the 12 frames are saved to files with 4-digit numbers with leading zeros: <em>output0001.jpg</em>, <em>output0002.jpg</em>, <em>output0003.jpg</em>, and so on up to <em>output0012.jpg</em>. Also, you can use a wide range of image formats in addition to <em>.jpg</em>, including <em>.png</em>, <em>.bmp</em>, or <em>.webp</em>.</p>
<p>If you only want to extract a single frame from the video and don’t want to use a sequence pattern in the output filenames, use <code>-vframe 1</code> and add the additional <code>-update 1</code> argument:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -ss 00:00:15 -vframes 1 -update 1 output.jpg
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-ss&#39;, &#39;00:00:15&#39;, &#39;-vframes&#39;, &#39;1&#39;, &#39;-update&#39;, &#39;1&#39;, &#39;output.jpg&#39;])
</code></pre></div>

<p>If you want to extract every frame from a video, you can run a much simpler terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 output%04d.jpg
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;output%04d.jpg&#39;])
</code></pre></div>

<p>Many videos are about 30 frames per second, so a single minute of video will produce about 1,800 image files.</p>
<h4>Concatenate Multiple Video or Audio Files</h4>
<p>You can concatenate a video or audio file to the end of another video or audio file with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -f concat -i videolist.txt -c copy output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-f&#39;, &#39;concat&#39;, &#39;-i&#39;, &#39;mylist.txt&#39;, &#39;-c&#39;, &#39;copy&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>This command concatenates all the videos listed in the <code>videolist.txt</code> text file together into a single video in a file named <code>output.mp4</code>. The <code>videolist.txt</code> file has the following format:</p>
<div><pre><span></span><code>file &#39;input_spam.mp4&#39;
file &#39;input_eggs.mp4&#39;
file &#39;input_bacon.mp4&#39;
</code></pre></div>

<p>This command only works if the videos have the same codecs and size, otherwise you’ll need to consult the ffmpeg documentation for mixing videos of different formats.</p>
<h4>Add Watermark or Overlay to a Video</h4>
<p>You can add a watermark or overlay image to a video with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -i logo.png -filter_complex overlay=10:50 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-i&#39;, &#39;logo.png&#39;, &#39;-filter_complex&#39;, &#39;overlay=10:50&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-i logo.png</code> means that the logo.png file is also an input, and the <code>-filter_complex overlay=10:50</code> means that it will be placed on top of the <code>input.mp4</code> input video, 10 pixels from the left edge and 50 pixels from the top edge.</p>
<p>You can also use a video as the overlay instead of a still image if you want a picture-in-picture effect.</p>
<h4>Rotate a Video</h4>
<p>If you have videos that are incorrectly rotated, you can correct this with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf transpose=1 -c:a copy output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;transpose=1&#39;, &#39;-c:a&#39;, &#39;copy&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-vf</code> argument means ffmpeg will apply a video filter, and the specific video filter is <code>transpose=1</code>. The number <code>1</code> means the video is rotated 90 degrees clockwise. You can also use any of the following numbers:</p>
<ul>
<li><code>0</code>: Rotate by 90 degrees counterclockwise and flip vertically.</li>
<li><code>1</code>: Rotate by 90 degrees clockwise.</li>
<li><code>2</code>: Rotate by 90 degrees counterclockwise.</li>
<li><code>3</code>: Rotate by 90 degrees clockwise and flip vertically.</li>
</ul>
<p>If you would like to rotate the video 180 degrees clockwise, then apply the transpose video filter twice with the <code>-vf transpose=1,transpose=1</code> arguments.</p>
<h4>Normalizing audio in a video file</h4>
<p>If you have audio with wild fluctuations in volume, you can normalize it with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -af dynaudnorm output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-af&#39;, &#39;dynaudnorm&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>dynaudnorm</code> audio filter performs dynamic audio normalization and is good for evening out volume for, say, conversations where people speak at different volumes. There’s also the <code>loudnorm</code> audio filter, which sets specific loudness standards commonly used in broadcast media:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -af loudnorm output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-af&#39;, &#39;dynaudnorm&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The default settings for these filters should work well, but you can run <code>ffmpeg -h filter=dynaudnorm</code> and <code>ffmpeg -h filter=loudnorm</code> to view the help information for their various settings.</p>
<h4>Compress a Video or Audio File</h4>
<p>Video files, especially high-quality videos, can be quite large. You can re-encode a video with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vcodec libx265 -crf 28 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vcodec&#39;, &#39;libx265&#39;, &#39;-crf&#39;, &#39;28&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>This command compresses a video file by re-encoding its video stream data with the H.265 (HEVC) codec and setting a higher CRF (Constant Rate Factor) value. This may slightly reduce the quality of the video, but it also reduces its disk size.</p>
<p>The bitrate of an audio file is how many bits are used per unit of time. For example, 128kbps uses 128 kilobits (or 16 kilobytes) per second of audio, so a 60 second MP3 file at 128kbps would take up about 1.1 megabytes of disk space. In general, a higher bitrate produces higher quality audio.</p>
<p>You can re-encode an audio file with a lower bitrate with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp3 -b:a 32k output.mp3
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp3&#39;, &#39;-b:a&#39;, &#39;32k&#39;, &#39;output.mp3&#39;])
</code></pre></div>

<p>For MP3s, 32kbps is low quality while 256kbps is high quality and 320kbps is almost indistinguishable from a music CD. (CDs, or compact discs, were an audio storage media used by ancient civilizations.)</p>
<p>While you can create smaller files by re-encoding a high quality audio file to a lower bitrate audio file, re-encoding a low bitrate audio file to a higher bitrate won’t magically improve the audio quality.</p>
<h4>Video Fade In and Out</h4>
<p>You can add a fade in from or fade out to black effect at the start or end of your video with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf fade=in:0:30 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;fade=in:0:30&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>This recipe uses a video filter name <code>fade</code>. The <code>-vf fade=in:0:30</code> argument means that the fade in starts at frame 0 (the very start of the video) and ends at frame 30. For a video that is 30 frames per second, this creates a 1-second fade in at the start of the video. You can also have a fade out with this terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf fade=in:0:30,fade=out:150:60 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;fade=in:0:30,fade=out:300:15&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The fade out starts at frame 150 (5 seconds into the video) and finishes in 60 frames, or two seconds.</p>
<h4>Decrease Saturation or Convert to Black and White</h4>
<p>You can decrease the saturation (how colorful the video is) with the following terminal commands or Python instructions:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf eq=saturation=0.5 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;eq=saturation=0.5&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The -vf argument applies a video filter, specifically the <code>eq=saturation=0.5</code> video filter, which reduces the saturation by one half. To make the video completely black and white (that is, grayscale), use <code>eq=saturation=0.0</code>. You can also increase the saturation to give the video a colorful, almost cartoon look by doubling the saturation with <code>eq=saturation=2.0</code>.</p>
<h4>Adjust Video Brightness and Contrast</h4>
<p>You can increase the brightness of a video by 6% with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf eq=brightness=0.06 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;eq=brightness=0.06&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>The <code>-vf</code> argument means you want to apply a video filter, specifically the <code>eq=brightness=0.06</code> filter that increases brightness by 6%. Using <code>eq=brightness=0.5</code> would increase brightness by 50%, while using <code>eq=brightness=-0.5</code> would decrease brightness by 50%.</p>
<p>On the other hand, the value for the contrast filter ranges from 0.0 (no contrast) to 1.0 (normal contrast) and up. You can set the contrast 30% higher than normal with the following terminal command or Python instruction:</p>
<div><pre><span></span><code>ffmpeg -y -i input.mp4 -vf eq=contrast=1.3 output.mp4
&gt;&gt;&gt; subprocess.run([&#39;ffmpeg&#39;, &#39;-y&#39;, &#39;-i&#39;, &#39;input.mp4&#39;, &#39;-vf&#39;, &#39;eq=contrast=1.3&#39;, &#39;output.mp4&#39;])
</code></pre></div>

<p>Alternatively, you can make the contrast 30% lower than normal by using <code>eq=contrast=0.7</code>.</p>
<h2>Summary</h2>
<p>Audio and video data make up a large part of how we interact with computers whether it’s podcasts, dance videos, security camera footage, or sound effects. Python has several third-party modules for downloading, playing, and editing audio and video data, and this chapter provides small code examples you can embed in your own programs.</p>
<p>Python has are several multimedia libraries installable through pip. The OpenCV computer vision library can access your webcam to take photos and videos. The Pygame library, while designed for making video games, can record images from webcams as well as play sound files. The sounddevice and wavio modules for Python can record audio from your computer’s microphone.</p>
<p>There are also several free, open source applications for dealing with multimedia data: yt-dlp for downloading videos, VLC Media Player for viewing videos, and ffmpeg for applying a wide range of filters and conversions to video and audio files.</p>
<p>The topics touched on here could easily fill a book of their own, but this chapter provides a wide introduction and sample code for getting started. Python is much more than a programming language; it’s also a popular development community that has created many free third-party modules to bring new features to your programs.</p>
<h2>Practice Questions</h2>
<ol>
<li>Divide the following into audio or video file format: <em>.ogg</em>, <em>.mp3</em>, <em>.mp4</em>, <em>.wav</em>, <em>.avi</em></li>
<li>Can the OpenCV library record audio for the video files it creates?</li>
<li>Between the sounddevice and pygame modules, which would you use to play an audio file and block the execution of the Python program until the audio finishes playing? Which would you use to start playing an audio file and immediately continue with the rest of the Python program?</li>
<li>What yt-dlp command line argument extracts the audio from a downloaded video file?</li>
<li>How do you specify the input file for the ffmpeg command?</li>
<li>How much does the VLC Media Player application cost?</li>
<li>What does the ffprobe command do?</li>
</ol>
<h2>Practice Projects</h2>
<p>For practice, write programs that do the following.</p>
<h3>Take Time Lapse Photos</h3>
<p>Write a program that uses either OpenCV to take photos using a webcam once every 5 seconds, and then after a preset number of photos, assembles them into a time lapse video. Since time lapse videos can take hours to create, for testing purposes, it may help to find a lava lamp video online to play while the webcam on top of your screen is pointed at a mirror to view the video.</p>
<h3>Add Fade In and Fade Out</h3>
<p>Write a program that uses ffmpeg to add a two second fade in and fade out effect to every video file in a given folder. For testing purposes, you can make multiple copies of the same short video file. The program should also check the video length and offer a warning if the video is shorter than four seconds.</p>
<h3>Brightness Preview</h3>
<p>Write a program that uses ffmpeg to get a preview of various brightness changes. It can take quite a while to adjust the brightness of an entire video, and you may want to reprocess the video multiple times at varying brightness levels until you find one you like. It’s much faster to have ffmpeg change the brightness of a single image than an entire video.
To keep from having to re-run ffmpeg, your program should extract a frame from an input video, then run ffmpeg again on that frame image to produce other images at varying brightness levels. For example, in a loop you can pass ffmpeg the argument eq=brightness=0.01, eq=brightness=0.02, eq=brightness=0.03 and so on up to, say, eq=brightness=0.50. Be sure to give the output image files different names, such as brightness0.01.png, brightness0.02.png, and so on.
Then user will be free to view the different preview images and pick the brightness setting they’d like to later apply to the entire video.</p>
  </div></div>
  </body>
</html>
