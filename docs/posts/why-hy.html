<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.hylang.org/en/alpha/whyhy.html">Original</a>
    <h1>Why Hy?</h1>
    
    <div id="readability-page-1" class="page"><div role="main" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="why-hy">

<p>Hy is a multi-paradigm general-purpose programming language in the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp family</a>. It’s implemented
as a kind of alternative syntax for Python. Compared to Python, Hy offers a
variety of extra features, generalizations, and syntactic simplifications, as
would be expected of a Lisp. Compared to other Lisps, Hy provides direct access
to Python’s built-ins and third-party Python libraries, while allowing you to
freely mix imperative, functional, and object-oriented styles of programming.</p>
<section id="hy-versus-python">
<h2>Hy versus Python<a href="#hy-versus-python" title="Permalink to this headline">¶</a></h2>
<p>The first thing a Python programmer will notice about Hy is that it has Lisp’s
traditional parenthesis-heavy prefix syntax in place of Python’s C-like infix
syntax. For example, <code><span>print(&#34;The</span> <span>answer</span> <span>is&#34;,</span> <span>2</span> <span>+</span> <span>object.method(arg))</span></code> could
be written <code><span>(print</span> <span>&#34;The</span> <span>answer</span> <span>is&#34;</span> <span>(+</span> <span>2</span> <span>(.method</span> <span>object</span> <span>arg)))</span></code> in Hy.
Consequently, Hy is free-form: structure is indicated by parentheses rather
than whitespace, making it convenient for command-line use.</p>
<p>As in other Lisps, the value of a simplistic syntax is that it facilitates
Lisp’s signature feature: <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> through macros, which are
functions that manipulate code objects at compile time to produce new code
objects, which are then executed as if they had been part of the original code.
In fact, Hy allows arbitrary computation at compile-time. For example, here’s a
simple macro that implements a C-style do-while loop, which executes its body
for as long as the condition is true, but at least once.</p>
<div id="do-while"><div><pre><span></span><span>(</span><span>defmacro </span><span>do-while</span> <span>[</span><span>condition</span> <span>#</span><span>* </span><span>body</span><span>]</span>
  <span>`</span><span>(</span><span>do</span>
    <span>~</span><span>body</span>
    <span>(</span><span>while</span> <span>~</span><span>condition</span>
      <span>~</span><span>body</span><span>)))</span>

<span>(</span><span>setv</span> <span>x</span> <span>0</span><span>)</span>
<span>(</span><span>do-while</span> <span>x</span>
  <span>(</span><span>print </span><span>&#34;This line is executed once.&#34;</span><span>))</span>
</pre></div>
</div>
<p>Hy also removes Python’s restrictions on mixing expressions and statements,
allowing for more direct and functional code. For example, Python doesn’t allow
<a href="https://docs.python.org/3/reference/compound_stmts.html#with" title="(in Python v3.10)"><span>with</span></a> blocks, which close a resource once you’re done using it,
to return values. They can only execute a set of statements:</p>
<div><div><pre><span></span><span>with</span> <span>open</span><span>(</span><span>&#34;foo&#34;</span><span>)</span> <span>as</span> <span>o</span><span>:</span>
   <span>f1</span> <span>=</span> <span>o</span><span>.</span><span>read</span><span>()</span>
<span>with</span> <span>open</span><span>(</span><span>&#34;bar&#34;</span><span>)</span> <span>as</span> <span>o</span><span>:</span>
   <span>f2</span> <span>=</span> <span>o</span><span>.</span><span>read</span><span>()</span>
<span>print</span><span>(</span><span>len</span><span>(</span><span>f1</span><span>)</span> <span>+</span> <span>len</span><span>(</span><span>f2</span><span>))</span>
</pre></div>
</div>
<p>In Hy, <a href="https://docs.python.org/3.10/reference/compound_stmts.html#with" title="(in Python v3.10)"><span>The with statement</span></a> returns the value of its last body form, so you can use it
like an ordinary function call:</p>
<div><div><pre><span></span><span>(</span><span>print </span><span>(</span><span>+</span>
  <span>(</span><span>len</span> <span>(</span><span>with</span> <span>[</span><span>o</span> <span>(</span><span>open</span> <span>&#34;foo&#34;</span><span>)]</span> <span>(</span><span>.read</span> <span>o</span><span>)))</span>
  <span>(</span><span>len</span> <span>(</span><span>with</span> <span>[</span><span>o</span> <span>(</span><span>open</span> <span>&#34;bar&#34;</span><span>)]</span> <span>(</span><span>.read</span> <span>o</span><span>)))))</span>
</pre></div>
</div>
<p>To be even more concise, you can put a <code><span>with</span></code> form in a <a href="https://docs.hylang.org/en/alpha/api.html#gfor" title="gfor"><code><span>gfor</span></code></a>:</p>
<div><div><pre><span></span><span>(</span><span>print </span><span>(</span><span>sum</span> <span>(</span><span>gfor</span>
  <span>filename</span> <span>[</span><span>&#34;foo&#34;</span> <span>&#34;bar&#34;</span><span>]</span>
  <span>(</span><span>len</span> <span>(</span><span>with</span> <span>[</span><span>o</span> <span>(</span><span>open</span> <span>filename</span><span>)]</span> <span>(</span><span>.read</span> <span>o</span><span>))))))</span>
</pre></div>
</div>
<p>Finally, Hy offers several generalizations to Python’s binary operators.
Operators can be given more than two arguments (e.g., <code><span>(+</span> <span>1</span> <span>2</span> <span>3)</span></code>), including
augmented assignment operators (e.g., <code><span>(+=</span> <span>x</span> <span>1</span> <span>2</span> <span>3)</span></code>). They are also provided
as ordinary first-class functions of the same name, allowing them to be passed
to higher-order functions: <code><span>(sum</span> <span>xs)</span></code> could be written <code><span>(reduce</span> <span>+</span> <span>xs)</span></code>,
after importing the function <code><span>+</span></code> from the module <code><span>hy.pyops</span></code>.</p>
<p>The Hy compiler works by reading Hy source code into Hy model objects and
compiling the Hy model objects into Python abstract syntax tree (<a href="https://docs.python.org/3.10/library/ast.html#module-ast" title="(in Python v3.10)"><code><span>ast</span></code></a>)
objects. Python AST objects can then be compiled and run by Python itself,
byte-compiled for faster execution later, or rendered into Python source code.
You can even <a href="https://docs.hylang.org/en/alpha/language/interop.html#interop"><span>mix Python and Hy code in the same project, or even the same
file,</span></a> which can be a good way to get your feet wet in Hy.</p>
</section>
<section id="hy-versus-other-lisps">
<h2>Hy versus other Lisps<a href="#hy-versus-other-lisps" title="Permalink to this headline">¶</a></h2>
<p>At run-time, Hy is essentially Python code. Thus, while Hy’s design owes a lot
to <a href="https://clojure.org">Clojure</a>, it is more tightly coupled to Python than
Clojure is to Java; a better analogy is <a href="https://coffeescript.org">CoffeeScript’s</a> relationship to JavaScript. Python’s built-in
<a href="https://docs.python.org/3/library/functions.html#built-in-funcs" title="(in Python v3.10)"><span>functions</span></a> and <a href="https://docs.python.org/3/library/stdtypes.html#bltin-types" title="(in Python v3.10)"><span>data structures</span></a> are directly available:</p>
<div><div><pre><span></span><span>(</span><span>print </span><span>(</span><span>int </span><span>&#34;deadbeef&#34;</span> <span>:base</span> <span>16</span><span>))</span>  <span>; 3735928559</span>
<span>(</span><span>print </span><span>(</span><span>len</span> <span>[</span><span>1</span> <span>10</span> <span>100</span><span>]))</span>           <span>; 3</span>
</pre></div>
</div>
<p>The same goes for third-party Python libraries from <a href="https://pypi.org">PyPI</a>
and elsewhere. Here’s a tiny <a href="https://cherrypy.org">CherryPy</a> web application
in Hy:</p>
<div><div><pre><span></span><span>(</span><span>import </span><span>cherrypy</span><span>)</span>

<span>(</span><span>defclass</span> <span>HelloWorld</span> <span>[]</span>
  <span>#@</span><span>(</span><span>cherrypy.expose</span> <span>(</span><span>defn </span><span>index </span><span>[</span><span>self</span><span>]</span>
    <span>&#34;Hello World!&#34;</span><span>)))</span>

<span>(</span><span>cherrypy.quickstart</span> <span>(</span><span>HelloWorld</span><span>))</span>
</pre></div>
</div>
<p>You can even run Hy on <a href="https://pypy.org">PyPy</a> for a particularly speedy
Lisp.</p>
<p>Like all Lisps, Hy is <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a>. Its syntax is represented not
with cons cells or with Python’s basic data structures, but with simple
subclasses of Python’s basic data structures called <a href="https://docs.hylang.org/en/alpha/language/internals.html#models"><span>models</span></a>.
Using models in place of plain <code><span>list</span></code>s, <code><span>set</span></code>s, and so on has two
purposes: models can keep track of their line and column numbers for the
benefit of error messages, and models can represent syntactic features that the
corresponding primitive type can’t, such as the order in which elements appear
in a set literal. However, models can be concatenated and indexed just like
plain lists, and you can return ordinary Python types from a macro or give them
to <code><span>hy.eval</span></code> and Hy will automatically promote them to models.</p>
<p>Hy takes much of its semantics from Python. For example, Hy is a Lisp-1 because
Python functions use the same namespace as objects that aren’t functions. In
general, any Python code should be possible to literally translate to Hy. At
the same time, Hy goes to some lengths to allow you to do typical Lisp things
that aren’t straightforward in Python. For example, Hy provides the
aforementioned mixing of statements and expressions, <a href="https://docs.hylang.org/en/alpha/language/syntax.html#mangling"><span>name mangling</span></a> that transparently converts symbols with names like <code><span>valid?</span></code> to
Python-legal identifiers, and a <a href="https://docs.hylang.org/en/alpha/api.html#let" title="let"><code><span>let</span></code></a> macro to provide block-level scoping
in place of Python’s usual function-level scoping.</p>
<p>Overall, Hy, like Common Lisp, is intended to be an unopinionated big-tent
language that lets you do what you want. If you’re interested in a more
small-and-beautiful approach to Lisp, in the style of Scheme, check out
<a href="https://github.com/gilch/hissp">Hissp</a>, another Lisp embedded in Python
that was created by a Hy developer.</p>
</section>
</section>


           </div>
           
          </div></div>
  </body>
</html>
