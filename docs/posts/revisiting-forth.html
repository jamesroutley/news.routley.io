<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0049-revisiting-forth/">Original</a>
    <h1>Revisiting Forth</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2025-06-03</p>

<p>When I was at Recurse I briefly explored Forth. I&#39;ve been looking into it again lately. To be specific, I have been trying to understand  <a href="http://git.annexia.org/?p=jonesforth.git;a=tree">Jonesforth</a> by rewriting <a href="https://github.com/jacobvosmaer/yaforth">my own Forth</a> to more closely resemble it.</p>

<h2>Trying to understand Forth</h2>

<p>I don&#39;t know how useful it is but trying to understand Forth is an interesting intellectual challenge for me. It&#39;s a low level language that you can write high level code in, but only if you&#39;re willing and able to dive into the low level details when needed. It&#39;s an odd combination.</p>

<p>When I played <a href="https://microcorruption.com/map">Microcorruption</a> I learned about how you can use buffer overflows and other bugs to corrupt the control flow of other people&#39;s C programs. In Forth you are allowed and sometimes required to corrupt the control flow of <em>your own</em> program.</p>

<h2>Forth taxonomy</h2>

<p>Below, when I say &#34;Forth&#34;, I often mean &#34;Jonesforth&#34;. I think Jonesforth follows a lot of Forth conventions but I don&#39;t know enough about it to say when it&#39;s being more &#34;Jones&#34; than &#34;Forth&#34; so I won&#39;t bother to make the distinction.</p>

<p>The basic building blocks of Forth are called &#34;words&#34;. You can think of these as functions. There are two kinds of words: code words and colon words. A &#34;code word&#34; is a word defined in something other than Forth. In the case of Jonesforth this is assembler, in my own Forth it&#39;s C. A &#34;colon word&#34; is implemented as an array of Forth words. They are named after the Forth <code>:</code> (colon) operator which you can use to define them.</p>

<p>Colon words behave like function calls in a language like C. Their call behavior is a tree structure with code words as the leaves. To implement colon words in the interpreter you need (something like) a return stack. Forth has two stacks; one for parameters (the &#34;parameter stack&#34; or &#34;data stack&#34;) and one for return addresses (the &#34;return stack&#34;).</p>

<p>Code words do not use the return stack. They (or rather pointers to them) are arranged sequentially in memory. Most of the time, code words end in a macro called <code>NEXT</code> which jumps to the next code word in the list.</p>

<p>I don&#39;t know what to call this &#34;end in <code>NEXT</code>&#34; control flow. It&#39;s certainly not a function call, because there is no return. Code words just jump to the next word and somehow it all works out.</p>

<h2>Memory management</h2>

<p>Like C, you could say   Forth has a notion of &#34;stack memory&#34; and &#34;heap memory&#34;. In C, &#34;stack memory&#34; means local variables. In Forth, &#34;stack memory&#34; would be the parameter stack and sometimes, if you can get away with it, also the return stack.</p>

<p>In C, &#34;heap memory&#34; means <code>malloc</code>: the thing you make arbitrary sized long-lived allocations with at run time. In Forth, there is also something like &#34;heap memory&#34; except it is not organized as a heap. Heap memory means that you can free bits of memory in between other bits that are still in use. In C,  any memory allocated with <code>malloc</code> can be freed with <code>free</code> at any time. Forth only has a simple bump allocator. You can reset its state to a previous point but that means you can only free memory the most recently allocated memory.</p>

<p>The bump allocator uses a pointer named <code>HERE</code>. Working with long lived allocations usually means storing data at <code>HERE</code> and post-incrementing it. The Forth word <code>,</code> (&#34;comma&#34;) pulls an integer from the stack and stores it at <code>HERE</code>. In C this would be <code>*HERE++ = x;</code>.</p>

<h2>Interpreter state</h2>

<p>The Forth interpreter can be in one of two states: immediate or compiling. In &#34;immediate mode&#34; it reads Forth words from standard input one at a time executing each in turn. In &#34;compiling mode&#34;, it also reads words, but instead of executing them it writes pointers to each successive word at the <code>HERE</code> pointer.</p>

<p>How do you transition between these two states? Going from immediate to compiling is straightforward: code words can change the internal state of the compiler. But once it is compiling how does the compiler ever stop? While compiling it doesn&#39;t execute words, it only stores pointers to their definitions. To break out of this, Forth words can be marked as being an &#34;immediate word&#34;. Immediate words get executed immediately even if the compiler is in compile mode.</p>

<p>To give an example, consider this code. First we define a colon word called <code>HELLO</code> that prints <code>Hello world!</code> to stdout, then we call it.</p>

<pre><code>: HELLO .&#34; Hello world!&#34; CR ;
HELLO</code></pre>

<p>Without going into the specifics of how this works, note that <code>:</code> is a word that the interpreter sees while in immediate mode, and which (among other things) transitions the interpreter state to compiling mode. And <code>;</code> is an <em>immediate word</em>, read while in compiling mode, which sends the interpreter back into immediate mode. Then when the interpreter sees the second <code>HELLO</code> it looks it up in the dictionary and executes the definition we compiled into memory just one line above.</p>

<h2>Conclusion</h2>

<p>I&#39;ll wrap up this blog post for now because I could keep going on for a long time.</p>

<p>Forth outwardly appears to use nested function calls like many other programming languages but some of its words are executed sequentially with hard to follow jumps. It has two stacks which allow it to get away with letting local variables be anonymous and implicit. Long lived allocations are made sequentially using the <code>HERE</code> pointer. The interpreter alternates between two states that govern how it treats input words, but some words get to override the &#34;compiling&#34; state and run immediately anyway.</p>
<p>Tags:  <a href="https://blog.jacobvosmaer.nl/tags/forth.html">forth</a></p>
<p><a href="https://blog.jacobvosmaer.nl/">Index</a> â€” <a href="mailto:contact@jacobvosmaer.nl">Contact</a></p></div></div>
  </body>
</html>
