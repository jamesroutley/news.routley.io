<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alwaysprocessing.blog/2022/02/20/size-matters">Original</a>
    <h1>Size Matters: An Exploration of Virtual Memory on iOS</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
<div id="preamble">
<div>
<p>I ran into an odd out-of-memory problem the other day when attempting to debug an iOS app on device. The app consistently crashed shortly after launch, preventing me from investigating the bug. To unblock myself, I learned a lot about the iOS virtual memory implementation and journaled my findings (including a fix!) here.</p>
</div>
</div>
<div>
<h2 id="background">Background</h2>
<div>
<p>The term <a href="https://en.wikipedia.org/wiki/Virtual_memory"><em>virtual memory</em></a> describes an abstraction between a process (executable, app, etc.) and the computer’s physical memory (RAM). This is a feature provided by an operating system in conjunction with the computer’s CPU (specifically its <a href="https://en.wikipedia.org/wiki/Memory_management_unit"><em>memory management unit</em></a>, or MMU).</p>
<p>In a system with virtual memory, each process has its own <a href="https://en.wikipedia.org/wiki/Address_space"><em>memory address space</em></a> that defines its valid logical (née virtual) memory addresses. When a process reads from or writes to a logical memory address, the logical memory address is translated by the MMU into a physical address. This is why the term <em>virtual</em> is used—​a process’s memory address is not intrinsically related to any physical address on the machine.</p>
<p>A corollary of this abstraction is that two processes may have a pointer with the same value (a logical memory address), but each pointer may map to a different physical address. Similarly, two processes may have pointers with different values, but each maps to the same physical address (e.g. a shared library).</p>
<p>Virtual memory is divided into units called a <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)"><em>page</em></a>. A page is a contiguous address range, and each page has the same, fixed size. The size of a page varies by operating system and hardware. 4 KiB is common on 32-bit hardware and common sizes on 64-bit hardware include 4 KiB, 16 KiB, and 64 KiB.</p>
<p>Not all addresses in a virtual memory address space need map to a physical address. If a process accesses an address in an unmapped page, the MMU raises a <a href="https://en.wikipedia.org/wiki/Page_fault"><em>page fault exception</em></a>.</p>
<p>The page fault exception may be used by the operating system to implement <a href="https://en.wikipedia.org/wiki/Memory_paging"><em>paging</em></a>, or the movement of data from disk into main memory (typically called a <em>page in</em>, or reading a <em>page</em> from disk <em>into</em> RAM). This technique enables operating systems and applications to use more memory than is physically available on the machine by leveraging the disk to store pages that the operating system wants to evict from RAM (typically called <em>page out</em>, or moving a <em>page</em> from RAM <em>out</em> to disk). The process of transferring data between RAM and disk is also known as <em>swapping</em>.</p>
<p>The operating system may also handle a page fault by terminating the process (i.e. a crash). On 32-bit Apple platforms, the first page (addresses <code>[0x0000, 0x0FFF]</code>) is not accessible by the process, which is why a <code>NULL</code> pointer deference (an access of address <code>0</code>) crashes. On 64-bit Apple platforms, the entire 4 GiB 32-bit address space (addresses <code>[0x00000000, 0xFFFFFFFF]</code>) is not accessible by the process, which catches both <code>NULL</code> pointer dereference bugs and 64-bit to 32-bit pointer truncation bugs.</p>
</div>
</div>
<div>
<h2 id="virtual-memory-on-ios">Virtual Memory on iOS</h2>
<div>
<p>In many respects, iOS virtual memory is similar to virtual memory in many other operating systems, but there are a few notable unique aspects of the iOS implementation.</p>
<div>
<h3 id="no-page-outs">No Page Outs</h3>
<p>Unlike macOS (and most operating systems with virtual memory), <a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html">iOS does not page out</a> <a href="https://en.wikipedia.org/wiki/Dirty_bit"><em>dirty</em></a> memory to disk. (The term <em>dirty</em> refers to memory that has been written to by the process.) iOS only discards read-only pages of a <a href="https://en.wikipedia.org/wiki/Memory-mapped_file"><em>memory-mapped file</em></a>, which can be paged in again as necessary. The main executable, shared libraries, and some types of resources are typically memory-mapped into the process address space and are therefore candidates for eviction from RAM if the system is low on physical memory.</p>
</div>
<div>
<h3 id="64-bit-virtual-address-space">64-bit Virtual Address Space</h3>
<p>A surprising aspect (to me at least!) of the iOS 64-bit virtual memory system is that the size of the virtual address space depends on the amount of physical memory installed on the device. Consider the following excerpts from <strong>xnu-7195.141.2</strong> (the operating system kernel):</p>
<div>
<p><code>osfmk/mach/shared_region.h</code> lines <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-7195.141.2/osfmk/mach/shared_region.h#L86-L87">86-87</a>:</p>
<div>
<pre><code data-lang="c"><span></span><span>#define SHARED_REGION_BASE_ARM64                0x180000000ULL</span>
<span>#define SHARED_REGION_SIZE_ARM64                0x100000000ULL</span></code></pre>
</div>
</div>
<div>

<div>
<pre><code data-lang="c"><span></span><span>#define ARM64_MIN_MAX_ADDRESS (SHARED_REGION_BASE_ARM64 + SHARED_REGION_SIZE_ARM64 + 0x20000000) </span><span>// end of shared region + 512MB for various purposes</span>
<span>const</span> <span>vm_map_offset_t</span> <span>min_max_offset</span> <span>=</span> <span>ARM64_MIN_MAX_ADDRESS</span><span>;</span> <span>// end of shared region + 512MB for various purposes</span>

<span>if</span> <span>(</span><span>arm64_pmap_max_offset_default</span><span>)</span> <span>{</span>
	<span>max_offset_ret</span> <span>=</span> <span>arm64_pmap_max_offset_default</span><span>;</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>max_mem</span> <span>&gt;</span> <span>0xC0000000</span><span>)</span> <span>{</span>
	<span>max_offset_ret</span> <span>=</span> <span>min_max_offset</span> <span>+</span> <span>0x138000000</span><span>;</span> <span>// Max offset is 13.375GB for devices with &gt; 3GB of memory</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>max_mem</span> <span>&gt;</span> <span>0x40000000</span><span>)</span> <span>{</span>
	<span>max_offset_ret</span> <span>=</span> <span>min_max_offset</span> <span>+</span> <span>0x38000000</span><span>;</span>  <span>// Max offset is 9.375GB for devices with &gt; 1GB and &lt;= 3GB of memory</span>
<span>}</span> <span>else</span> <span>{</span>
	<span>max_offset_ret</span> <span>=</span> <span>min_max_offset</span><span>;</span>
<span>}</span></code></pre>
</div>
</div>
<p>Using the above information, we can calculate the size of the virtual memory address space for various iOS devices running iOS 12 or later. (Subtract 3 GiB for iOS 11 and earlier.)</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>RAM</th>
<th>Address Space</th>
<th>Devices</th>
</tr>
</thead>
<tbody>
<tr>
<td><div><pre> &gt; 3 GiB</pre></div></td>
<td><div><pre>15.375 GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone XS – iPhone 13</p>
</li>
<li>
<p>iPad Air (4th generation)</p>
</li>
<li>
<p>iPad Pro (12.9-inch), (10.5-inch), (11-inch)</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td><div><pre> &gt; 1 GiB</pre></div></td>
<td><div><pre>11.375 GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone 6s – X, SE, XR</p>
</li>
<li>
<p>iPad (5th generation) – iPad (8th generation)</p>
</li>
<li>
<p>iPad Air 2, iPad Air (3rd generation)</p>
</li>
<li>
<p>iPad mini 4, iPad mini (5th generation)</p>
</li>
<li>
<p>iPad Pro (9.7-inch)</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td><div><pre>&lt;= 1 GiB</pre></div></td>
<td><div><pre>10.5   GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone 5s, iPhone 6</p>
</li>
<li>
<p>iPad Air</p>
</li>
<li>
<p>iPad mini 2, iPad mini 3</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div>
<h3 id="available-address-space">Available Address Space</h3>
<p>8 GiB of the virtual address space is not available for use by the process. As mentioned earlier:</p>
<div>
<ul>
<li>
<p>The first 4 GiB of the 64-bit virtual address space (which is also the entire 32-bit address space!) cannot be read from, written to, or executed by the process. The Mach-O executable file format designates this area as <code>PAGE_ZERO</code>, and the kernel <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-7195.141.2/bsd/kern/mach_loader.c#L622-L630">requires <code>PAGE_ZERO</code> for arm64 processes</a>.</p>
</li>
<li>
<p>The size of the <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-7195.141.2/osfmk/vm/vm_shared_region.c#L30-L76">shared region</a>, for use by the system, is <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-7195.141.2/osfmk/mach/shared_region.h#L87">fixed to 4 GiB</a>.</p>
</li>
</ul>
</div>
<p>With this information, we can update the table to include the size of the virtual address space that’s usable by a process.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>RAM</th>
<th>Address Space</th>
<th>Usable</th>
<th>Devices</th>
</tr>
</thead>
<tbody>
<tr>
<td><div><pre> &gt; 3 GiB</pre></div></td>
<td><div><pre>15.375 GiB</pre></div></td>
<td><div><pre>7.375 GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone XS – iPhone 13</p>
</li>
<li>
<p>iPad Air (4th generation)</p>
</li>
<li>
<p>iPad Pro (12.9-inch), (10.5-inch), (11-inch)</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td><div><pre> &gt; 1 GiB</pre></div></td>
<td><div><pre>11.375 GiB</pre></div></td>
<td><div><pre>3.375 GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone 6s – X, SE, XR</p>
</li>
<li>
<p>iPad (5th generation) – iPad (8th generation)</p>
</li>
<li>
<p>iPad Air 2, iPad Air (3rd generation)</p>
</li>
<li>
<p>iPad mini 4, iPad mini (5th generation)</p>
</li>
<li>
<p>iPad Pro (9.7-inch)</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td><div><pre>&lt;= 1 GiB</pre></div></td>
<td><div><pre>10.5   GiB</pre></div></td>
<td><div><pre>2.5   GiB</pre></div></td>
<td><div><div>
<ul>
<li>
<p>iPhone 5s, iPhone 6</p>
</li>
<li>
<p>iPad Air</p>
</li>
<li>
<p>iPad mini 2, iPad mini 3</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div>
<h3 id="considerations-for-development">Considerations for Development</h3>
<p>Generally speaking, when a Mach-O file is loaded into a process, the entire file is mapped into the process’s address space. This is particularly interesting for debug builds, which typically contain a considerable amount of debug information embedded into the executable binary.</p>
<p>And finally, we circle back to the origin of this post! 🤣 I was attempting to debug a large app on an iPhone X, but it would crash shortly after launch with this rather cryptic error message:</p>
<div>
<div>
<pre> can&#39;t allocate region
 :*** mach_vm_map(size=1048576, flags: 100) failed (error code=3)
 MyApp(1234,0x2d580000) malloc: *** set a breakpoint in malloc_error_break to debug
 warning: could not execute support code to read Objective-C class data in the process. This may reduce the quality of type information available.</pre>
</div>
</div>
<p>Using Instruments, I observed the application executable and its libraries totaled over 3 GiB in size, leaving less than 370 MiB of address space for the heap and thread stacks. <strong>I couldn’t debug the app on device because the debug information used so much of the address space there was literally no address space available for use by the allocator!</strong></p>
</div>
<div>
<h3 id="extended-virtual-addressing">Extended Virtual Addressing</h3>
<p>New in iOS 14 is the <em>Extended Virtual Addressing</em> entitlement, whose plist key is <code>com.apple.developer.kernel.extended-virtual-addressing</code>. If a process has this entitlement, the <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-7195.141.2//bsd/kern/kern_exec.c#L2930-L2932">kernel enables jumbo mode</a>, which provides the process with access to the full 64-bit address space.</p>
<div>

<div>
<pre><code data-lang="c"><span></span><span>}</span> <span>else</span> <span>if</span> <span>(</span><span>option</span> <span>==</span> <span>ARM_PMAP_MAX_OFFSET_JUMBO</span><span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>arm64_pmap_max_offset_default</span><span>)</span> <span>{</span>
		<span>// Allow the boot-arg to override jumbo size</span>
		<span>max_offset_ret</span> <span>=</span> <span>arm64_pmap_max_offset_default</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>max_offset_ret</span> <span>=</span> <span>MACH_VM_MAX_ADDRESS</span><span>;</span>     <span>// Max offset is 64GB for pmaps with special &#34;jumbo&#34; blessing</span>
	<span>}</span></code></pre>
</div>
</div>
<p>Because this entitlement only increases the size of the virtual address space, it’s primarily useful for applications that map in a large amount of read-only data.</p>
<p>Mapping in a lot of read-only data is exactly what my large debug build is doing, so I added the entitlement to the app’s entitlements file for development builds. The entitlement resolved the out-of-memory crash after launch when debugging on device! 🚀 🎉 🎊 With that out of the way, I was able investigate the bug that brought me down this fascinating detour.</p>
</div>
</div>
</div>

</div></div>
  </body>
</html>
