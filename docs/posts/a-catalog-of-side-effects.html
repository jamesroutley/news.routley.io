<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/compiler-effects/?utm_source=rss">Original</a>
    <h1>A catalog of side effects</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Optimizing compilers like to keep track of each IR instruction’s <em>effects</em>. An
instruction’s effects vary wildly from having no effects at all, to writing a
specific variable, to completely unknown (writing all state).</p>

<p>This post can be thought of as a continuation of <a href="https://solar.lowtechmagazine.com/blog/irs/">What I talk about when I talk
about IRs</a>, specifically the section talking about asking the right
questions. When we talk about effects, we should ask the right questions: not
<em>what opcode is this?</em> but instead <em>what effects does this opcode have?</em></p>

<p>Different compilers represent and track these effects differently. I’ve been
thinking about how to represent these effects all year, so I have been doing
some reading. In this post I will give some summaries of the landscape of
approaches. Please feel free to suggest more.</p>

<h2 id="some-background">Some background</h2>

<p>Internal IR effect tracking is similar to the programming language notion of
algebraic effects in type systems, but internally, compilers keep track of
finer-grained effects. Effects such as “writes to a local variable”, “writes to
a list”, or “reads from the stack” indicate what instructions can be
re-ordered, duplicated, or removed entirely.</p>

<p>For example, consider the following pseodocode for some made-up language that
stands in for a snippet of compiler IR:</p>

<div><div><pre><code><span># ...
</span><span>v</span> <span>=</span> <span>some_var</span><span>[</span><span>0</span><span>]</span>
<span>another_var</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>5</span>
<span># ...
</span></code></pre></div></div>

<p>The goal of effects is to communicate to the compiler if, for example, these two IR
instructions can be re-ordered. The second instruction <em>might</em> write to a
location that the first one reads. But it also might not! This is about knowing
if <code>some_var</code> and <code>another_var</code> <em>alias</em>—if they are different names that
refer to the same object.</p>

<p>We can sometimes answer that question directly, but often it’s cheaper to
compute an approximate answer: <em>could</em> they even alias? It’s possible that
<code>some_var</code> and <code>another_var</code> have different types, meaning that (as long as you
have strict aliasing) the <code>Load</code> and <code>Store</code> operations that implement these
reads and writes by definition touch different locations. And if they look
at disjoint locations, there need not be any explicit order enforced.</p>

<p>Different compilers keep track of this information differently. The null effect
analysis gives up and says “every instruction is maximally effectful” and
therefore “we can’t re-order or delete any instructions”. That’s probably fine
for a first stab at a compiler, where you will get a big speed up purely based
on strength reductions. Over-approximations of effects should always be
valid.</p>

<p>But at some point you start wanting to do dead code elimination (DCE), or
common subexpression elimination (CSE), or loads/store elimination, or move
instructions around, and you start wondering how to represent effects. That’s
where I am right now. So here’s a catalog of different compilers I have looked
at recently.</p>

<p>There are two main ways I have seen to represent effects: bitsets and heap
range lists. We’ll look at one example compiler for each, talk a bit about
tradeoffs, then give a bunch of references to other major compilers.</p>

<p>We’ll start with <a href="https://github.com/facebookincubator/cinder">Cinder</a>, a Python JIT, because that’s what I used to
work on.</p>

<h2 id="cinder">Cinder</h2>

<p><a href="https://github.com/facebookincubator/cinder">Cinder</a> tracks heap effects for its high-level IR (HIR) in
<a href="https://github.com/facebookincubator/cinderx/blob/8bf5af94e2792d3fd386ab25b1aeedae27276d50/cinderx/Jit/hir/instr_effects.h">instr_effects.h</a>. Pretty much everything happens in
the <code>memoryEffects(const Instr&amp; instr)</code> function, which is expected to know
everything about what effects the given instruction might have.</p>

<p>The data representation is a bitset representation of a lattice called an
<code>AliasClass</code> and that is defined in <a href="https://github.com/facebookincubator/cinderx/blob/8bf5af94e2792d3fd386ab25b1aeedae27276d50/cinderx/Jit/hir/alias_class.h">alias_class.h</a>. Each
bit in the bitset represents a distinct location in the heap: reads from and
writes to each of these locations are guaranteed not to affect any of the other
locations.</p>

<p>Here is the X-macro that defines it:</p>

<div><div><pre><code><span>#define HIR_BASIC_ACLS(X) \
  X(ArrayItem)            \
  X(CellItem)             \
  X(DictItem)             \
  X(FuncArgs)             \
  X(FuncAttr)             \
  X(Global)               \
  X(InObjectAttr)         \
  X(ListItem)             \
  X(Other)                \
  X(TupleItem)            \
  X(TypeAttrCache)        \
  X(TypeMethodCache)
</span>
<span>enum</span> <span>BitIndexes</span> <span>{</span>
<span>#define ACLS(name) k##name##Bit,
</span>    <span>HIR_BASIC_ACLS</span><span>(</span><span>ACLS</span><span>)</span>
<span>#undef ACLS
</span><span>};</span>
</code></pre></div></div>

<p>Note that each bit implicitly represents a set: <code>ListItem</code> does not refer to a
<em>specific</em> list index, but the infinite set of all possible list indices. It’s
<em>any</em> list index. Still, every list index is completely disjoint from, say, every
entry in a global variable table.</p>

<p>(And, to be clear, an object in a list might be the same as an object in a
global variable table. The objects themselves can alias. But the thing being
written to or read from, the thing <em>being side effected</em>, is the container.)</p>

<p>Like other bitset lattices, it’s possible to union the sets by or-ing the bits.
It’s possible to query for overlap by and-ing the bits.</p>

<div><div><pre><code><span>class</span> <span>AliasClass</span> <span>{</span>
  <span>// The union of two AliasClass</span>
  <span>AliasClass</span> <span>operator</span><span>|</span><span>(</span><span>AliasClass</span> <span>other</span><span>)</span> <span>const</span> <span>{</span>
    <span>return</span> <span>AliasClass</span><span>{</span><span>bits_</span> <span>|</span> <span>other</span><span>.</span><span>bits_</span><span>};</span>
  <span>}</span>

  <span>// The intersection (overlap) of two AliasClass</span>
  <span>AliasClass</span> <span>operator</span><span>&amp;</span><span>(</span><span>AliasClass</span> <span>other</span><span>)</span> <span>const</span> <span>{</span>
    <span>return</span> <span>AliasClass</span><span>{</span><span>bits_</span> <span>&amp;</span> <span>other</span><span>.</span><span>bits_</span><span>};</span>
  <span>}</span>
<span>};</span>
</code></pre></div></div>

<p>If this sounds familiar, it’s because (as the repo notes) it’s a similar idea
to Cinder’s <a href="https://solar.lowtechmagazine.com/blog/lattice-bitset/">type lattice representation</a>.</p>

<p>Like other lattices, there is both a bottom element (no effects) and a top
element (all possible effects):</p>

<div><div><pre><code><span>#define HIR_OR_BITS(name) | k##name
</span>
<span>#define HIR_UNION_ACLS(X)                           \
  </span><span>/* Bottom union */</span><span>                                \
  X(Empty, 0)                                       \
  </span><span>/* Top union */</span><span>                                   \
  X(Any, 0 HIR_BASIC_ACLS(HIR_OR_BITS))             \
  </span><span>/* Memory locations accessible by managed code */</span><span> \
  X(ManagedHeapAny, kAny &amp; ~kFuncArgs)
</span></code></pre></div></div>

<p>Union operations naturally hit a fixpoint at <code>Any</code> and intersection operations
naturally hit a fixpoint at <code>Empty</code>.</p>

<p>All of this together lets the optimizer ask and answer questions such as:</p>

<ul>
  <li>where might this instruction write?</li>
  <li>(because CPython is reference counted and incref implies ownership) where
does this instruction borrow its input from?</li>
  <li>do these two instructions’ write destinations overlap?</li>
</ul>

<p>and more.</p>

<p>Let’s take a look at an (imaginary) IR version of the code snippet in the intro
and see what analyzing it might look like in the optimizer. Here is the fake
IR:</p>

<div><div><pre><code>v0: Tuple = ...
v1: List = ...
v2: Int[5] = ...
# v = some_var[0]
v3: Object = LoadTupleItem v0, 0
# another_var[0] = 5
StoreListItem v1, 0, v2
</code></pre></div></div>

<p>You can imagine that <code>LoadTupleItem</code> declares that it reads from the
<code>TupleItem</code> heap and <code>StoreListItem</code> declares that it writes to the <code>ListItem</code>
heap. Because tuple and list pointers cannot be casted into one another and
therefore cannot alias, these are
disjoint heaps in our bitset. Therefore <code>ListItem &amp; TupleItem == 0</code>, therefore
these memory operations can never interfere! They can (for example) be
re-ordered arbitrarily.</p>

<p>In Cinder, these memory effects could in the future be used for instruction
re-ordering, but they are today mostly used in two places: the refcount
insertion pass and DCE.</p>

<p>DCE involves first finding the set of instructions that need to be kept around
because they are useful/important/have effects. So here is what the Cinder DCE
<code>isUseful</code> looks like:</p>

<div><div><pre><code><span>bool</span> <span>isUseful</span><span>(</span><span>Instr</span><span>&amp;</span> <span>instr</span><span>)</span> <span>{</span>
  <span>return</span> <span>instr</span><span>.</span><span>IsTerminator</span><span>()</span> <span>||</span> <span>instr</span><span>.</span><span>IsSnapshot</span><span>()</span> <span>||</span>
      <span>(</span><span>instr</span><span>.</span><span>asDeoptBase</span><span>()</span> <span>!=</span> <span>nullptr</span> <span>&amp;&amp;</span> <span>!</span><span>instr</span><span>.</span><span>IsPrimitiveBox</span><span>())</span> <span>||</span>
      <span>(</span><span>!</span><span>instr</span><span>.</span><span>IsPhi</span><span>()</span> <span>&amp;&amp;</span> <span>memoryEffects</span><span>(</span><span>instr</span><span>).</span><span>may_store</span> <span>!=</span> <span>AEmpty</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>There are some other checks in there but <code>memoryEffects</code> is right there at the
core of it!</p>

<p>Now that we have seen the bitset representation of effects and an
implementation in Cinder, let’s take a look at a different representation and
and an implementation in JavaScriptCore.</p>

<h2 id="javascriptcore">JavaScriptCore</h2>

<p>I keep coming back to <a href="https://gist.github.com/pizlonator/cf1e72b8600b1437dda8153ea3fdb963">How I implement SSA form</a> by <a href="http://www.filpizlo.com/">Fil
Pizlo</a>, one of the significant contributors to JavaScriptCore (JSC). In
particular, I keep coming back to the <a href="https://gist.github.com/pizlonator/cf1e72b8600b1437dda8153ea3fdb963#uniform-effect-representation">Uniform Effect
Representation</a> section. This notion of “abstract heaps” felt
very… well, abstract. Somehow more abstract than the bitset representation.
The pre-order and post-order integer pair as a way to represent nested heap
effects just did not click.</p>

<p>It didn’t make any sense until I actually went spelunking in JavaScriptCore and
found one of several implementations—because, you know, JSC is six compilers
in a trenchcoat<sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed"><i>citation needed</i></a>]</sup>.</p>

<p>DFG, B3, DOMJIT, and probably others all have their own abstract heap
implementations. We’ll look at DOMJIT mostly because it’s a smaller example and
also illustrates something else that’s interesting: builtins. We’ll come back
to builtins in a minute.</p>

<p>Let’s take a lookat how DOMJIT structures its <a href="https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/WebCore/domjit/DOMJITAbstractHeapRepository.yaml">abstract
heaps</a>: a YAML file.</p>

<div><div><pre><code><span>DOM</span><span>:</span>
    <span>Tree</span><span>:</span>
        <span>Node</span><span>:</span>
            <span>-</span> <span>Node_firstChild</span>
            <span>-</span> <span>Node_lastChild</span>
            <span>-</span> <span>Node_parentNode</span>
            <span>-</span> <span>Node_nextSibling</span>
            <span>-</span> <span>Node_previousSibling</span>
            <span>-</span> <span>Node_ownerDocument</span>
        <span>Document</span><span>:</span>
            <span>-</span> <span>Document_documentElement</span>
            <span>-</span> <span>Document_body</span>
</code></pre></div></div>

<p>It’s a hierarchy. <code>Node_firstChild</code> is a subheap of <code>Node</code> is a subheap of…
and so on. A write to any <code>Node_nextSibling</code> is a write to <code>Node</code> is a write to
… Sibling heaps are unrelated: <code>Node_firstChild</code> and <code>Node_lastChild</code>, for
example, are disjoint.</p>

<p>To get a feel for this, I wired up a <a href="https://github.com/tekknolagi/tekknolagi.github.com/tree/main/assets/code/gen_bitset.rb">simplified version</a> of
ZJIT’s bitset generator (for <em>types!</em>) to read a YAML document and generate a
bitset. It generated the following Rust code:</p>

<div><div><pre><code><span>mod</span> <span>bits</span> <span>{</span>
  <span>pub</span> <span>const</span> <span>Empty</span><span>:</span> <span>u64</span> <span>=</span> <span>0u64</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Document_body</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>0</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Document_documentElement</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>1</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Document</span><span>:</span> <span>u64</span> <span>=</span> <span>Document_body</span> <span>|</span> <span>Document_documentElement</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_firstChild</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>2</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_lastChild</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>3</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_nextSibling</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_ownerDocument</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>5</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_parentNode</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>6</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node_previousSibling</span><span>:</span> <span>u64</span> <span>=</span> <span>1u64</span> <span>&lt;&lt;</span> <span>7</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Node</span><span>:</span> <span>u64</span> <span>=</span> <span>Node_firstChild</span> <span>|</span> <span>Node_lastChild</span> <span>|</span> <span>Node_nextSibling</span> <span>|</span> <span>Node_ownerDocument</span> <span>|</span> <span>Node_parentNode</span> <span>|</span> <span>Node_previousSibling</span><span>;</span>
  <span>pub</span> <span>const</span> <span>Tree</span><span>:</span> <span>u64</span> <span>=</span> <span>Document</span> <span>|</span> <span>Node</span><span>;</span>
  <span>pub</span> <span>const</span> <span>DOM</span><span>:</span> <span>u64</span> <span>=</span> <span>Tree</span><span>;</span>
  <span>pub</span> <span>const</span> <span>NumTypeBits</span><span>:</span> <span>u64</span> <span>=</span> <span>8</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It’s not a fancy X-macro, but it’s a short and flexible Ruby script.</p>

<p>Then I took the <a href="https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/WebCore/domjit/generate-abstract-heap.rb">DOMJIT abstract heap
generator</a>—also funnily enough a short Ruby
script—modified the output format slightly, and had it generate its int
pairs:</p>

<div><div><pre><code><span>mod</span> <span>bits</span> <span>{</span>
  <span>/* DOMJIT Abstract Heap Tree.
  DOM&lt;0,8&gt;:
      Tree&lt;0,8&gt;:
          Node&lt;0,6&gt;:
              Node_firstChild&lt;0,1&gt;
              Node_lastChild&lt;1,2&gt;
              Node_parentNode&lt;2,3&gt;
              Node_nextSibling&lt;3,4&gt;
              Node_previousSibling&lt;4,5&gt;
              Node_ownerDocument&lt;5,6&gt;
          Document&lt;6,8&gt;:
              Document_documentElement&lt;6,7&gt;
              Document_body&lt;7,8&gt;
  */</span>
  <span>pub</span> <span>const</span> <span>DOM</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>0</span><span>,</span> <span>end</span><span>:</span> <span>8</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Tree</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>0</span><span>,</span> <span>end</span><span>:</span> <span>8</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>0</span><span>,</span> <span>end</span><span>:</span> <span>6</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_firstChild</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>0</span><span>,</span> <span>end</span><span>:</span> <span>1</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_lastChild</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>1</span><span>,</span> <span>end</span><span>:</span> <span>2</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_parentNode</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>2</span><span>,</span> <span>end</span><span>:</span> <span>3</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_nextSibling</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>3</span><span>,</span> <span>end</span><span>:</span> <span>4</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_previousSibling</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>4</span><span>,</span> <span>end</span><span>:</span> <span>5</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Node_ownerDocument</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>5</span><span>,</span> <span>end</span><span>:</span> <span>6</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Document</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>6</span><span>,</span> <span>end</span><span>:</span> <span>8</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Document_documentElement</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>6</span><span>,</span> <span>end</span><span>:</span> <span>7</span> <span>};</span>
  <span>pub</span> <span>const</span> <span>Document_body</span><span>:</span> <span>HeapRange</span> <span>=</span> <span>HeapRange</span> <span>{</span> <span>start</span><span>:</span> <span>7</span><span>,</span> <span>end</span><span>:</span> <span>8</span> <span>};</span>
<span>}</span>
</code></pre></div></div>

<p>It already comes with a little diagram, which is super helpful for readability.</p>

<p>Any empty range(s) represent empty heap effects: if the start and end are the
same number, there are no effects. There is no one <code>Empty</code> value, but any empty
range could be normalized to <code>HeapRange { start: 0, end: 0 }</code>.</p>

<p>Maybe this was obvious to you, dear reader, but this pre-order/post-order thing
is about nested ranges! Seeing the output of the generator laid out clearly
like this made it make a lot more sense for me.</p>

<!--
So how do we compute subtyping relationships with `HeapRange`s? We check range
overlap! Here is [DOMJIT's C++ implementation][domjit-is-subtype-of]:

[domjit-is-subtype-of]: https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/JavaScriptCore/domjit/DOMJITHeapRange.h#L99

```c++
class HeapRange {
    constexpr explicit operator bool() const {
        return m_begin != m_end;
    }

    bool isStrictSubtypeOf(const HeapRange& other) const {
        if (!*this || !other)
            return false;
        if (*this == other)
            return false;
        return other.m_begin <= m_begin && m_end <= other.m_end;
    }

    bool isSubtypeOf(const HeapRange& other) const {
        if (!*this || !other)
            return false;
        if (*this == other)
            return true;
        return isStrictSubtypeOf(other);
    }
```

This is represented by the `operator bool()`
and implicit boolean conversions. To reinforce the whole nested heap ranges
thing, `isSubtypeOf` is asking if one `HeapRange` contains another.
-->

<p>What about checking overlap? Here is the <a href="https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/JavaScriptCore/domjit/DOMJITHeapRange.h#L108">implementation in
JSC</a>:</p>

<div><div><pre><code><span>namespace</span> <span>WTF</span> <span>{</span>
<span>// Check if two ranges overlap assuming that neither range is empty.</span>
<span>template</span><span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
<span>constexpr</span> <span>bool</span> <span>nonEmptyRangesOverlap</span><span>(</span><span>T</span> <span>leftMin</span><span>,</span> <span>T</span> <span>leftMax</span><span>,</span> <span>T</span> <span>rightMin</span><span>,</span> <span>T</span> <span>rightMax</span><span>)</span>
<span>{</span>
    <span>ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span>(</span><span>leftMin</span> <span>&lt;</span> <span>leftMax</span><span>);</span>
    <span>ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span>(</span><span>rightMin</span> <span>&lt;</span> <span>rightMax</span><span>);</span>

    <span>return</span> <span>leftMax</span> <span>&gt;</span> <span>rightMin</span> <span>&amp;&amp;</span> <span>rightMax</span> <span>&gt;</span> <span>leftMin</span><span>;</span>
<span>}</span>

<span>// Pass ranges with the min being inclusive and the max being exclusive.</span>
<span>template</span><span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
<span>constexpr</span> <span>bool</span> <span>rangesOverlap</span><span>(</span><span>T</span> <span>leftMin</span><span>,</span> <span>T</span> <span>leftMax</span><span>,</span> <span>T</span> <span>rightMin</span><span>,</span> <span>T</span> <span>rightMax</span><span>)</span> <span>{</span>
    <span>ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span>(</span><span>leftMin</span> <span>&lt;=</span> <span>leftMax</span><span>);</span>
    <span>ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span>(</span><span>rightMin</span> <span>&lt;=</span> <span>rightMax</span><span>);</span>

    <span>// Empty ranges interfere with nothing.</span>
    <span>if</span> <span>(</span><span>leftMin</span> <span>==</span> <span>leftMax</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span><span>rightMin</span> <span>==</span> <span>rightMax</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>

    <span>return</span> <span>nonEmptyRangesOverlap</span><span>(</span><span>leftMin</span><span>,</span> <span>leftMax</span><span>,</span> <span>rightMin</span><span>,</span> <span>rightMax</span><span>);</span>
<span>}</span>
<span>}</span>

<span>class</span> <span>HeapRange</span> <span>{</span>
    <span>bool</span> <span>overlaps</span><span>(</span><span>const</span> <span>HeapRange</span><span>&amp;</span> <span>other</span><span>)</span> <span>const</span> <span>{</span>
        <span>return</span> <span>WTF</span><span>::</span><span>rangesOverlap</span><span>(</span><span>m_begin</span><span>,</span> <span>m_end</span><span>,</span> <span>other</span><span>.</span><span>m_begin</span><span>,</span> <span>other</span><span>.</span><span>m_end</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>(See also <a href="https://zayenz.se/blog/post/how-to-check-for-overlapping-intervals/">How to check for overlapping intervals</a> and
<a href="https://nedbatchelder.com/blog/201310/range_overlap_in_two_compares.html">Range overlap in two compares</a> for more fun.)</p>

<p>While bitsets are a dense representation (you have to hold every bit), they are
very compact and they are very precise. You can hold any number of combinations
of 64 or 128 bits in a single register. The union and intersection operations
are very cheap.</p>

<p>With int ranges, it’s a little more complicated. An imprecise union of <code>a</code> and
<code>b</code> can take the maximal range that covers both <code>a</code> and <code>b</code>. To get a more
precise union, you have to keep track of both. In the worst case, if you want
efficient arbitrary queries, you need to store your int ranges in an interval
tree. So what gives?</p>

<p>I asked Fil if both bitsets and int ranges answer the same question, why use
int ranges? He said that it’s more flexible long-term: bitsets get expensive as
soon as you need over 128 bits (you might need to heap allocate them!) whereas
ranges have no such ceiling. But doesn’t holding sequences of ranges require
heap allocation? Well, despite Fil writing this in his SSA post:</p>

<blockquote>
  <p>The purpose of the effect representation baked into the IR is to provide a
precise always-available baseline for alias information that is super easy to
work with. […] you can have instructions report that they read/write
multiple heaps […] you can have a utility function that produces such lists
on demand.</p>
</blockquote>

<p>It’s important to note that this doesn’t actually involve any allocation of
lists. JSC does this very clever thing where they have “functors” that they
pass in as arguments that compress/summarize what they want to out of an
instruction’s effects.</p>

<p>Let’s take a look at how the DFG (for example) uses these heap ranges in
analysis. The DFG is structured in such a way that it can make use of the
DOMJIT heap ranges directly, which is neat.</p>

<p>Note that <code>AbstractHeap</code> in the example below is a thin wrapper over the DFG
compiler’s own <code>DOMJIT::HeapRange</code> equivalent:</p>

<div><div><pre><code><span>class</span> <span>AbstractHeapOverlaps</span> <span>{</span>
<span>public:</span>
    <span>AbstractHeapOverlaps</span><span>(</span><span>AbstractHeap</span> <span>heap</span><span>)</span>
        <span>:</span> <span>m_heap</span><span>(</span><span>heap</span><span>)</span>
        <span>,</span> <span>m_result</span><span>(</span><span>false</span><span>)</span>
    <span>{</span>
    <span>}</span>

    <span>void</span> <span>operator</span><span>()(</span><span>AbstractHeap</span> <span>otherHeap</span><span>)</span> <span>const</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>m_result</span><span>)</span>
            <span>return</span><span>;</span>
        <span>m_result</span> <span>=</span> <span>m_heap</span><span>.</span><span>overlaps</span><span>(</span><span>otherHeap</span><span>);</span>
    <span>}</span>

    <span>bool</span> <span>result</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>m_result</span><span>;</span> <span>}</span>

<span>private:</span>
    <span>AbstractHeap</span> <span>m_heap</span><span>;</span>
    <span>mutable</span> <span>bool</span> <span>m_result</span><span>;</span>
<span>};</span>

<span>bool</span> <span>writesOverlap</span><span>(</span><span>Graph</span><span>&amp;</span> <span>graph</span><span>,</span> <span>Node</span><span>*</span> <span>node</span><span>,</span> <span>AbstractHeap</span> <span>heap</span><span>)</span>
<span>{</span>
    <span>NoOpClobberize</span> <span>noOp</span><span>;</span>
    <span>AbstractHeapOverlaps</span> <span>addWrite</span><span>(</span><span>heap</span><span>);</span>
    <span>clobberize</span><span>(</span><span>graph</span><span>,</span> <span>node</span><span>,</span> <span>noOp</span><span>,</span> <span>addWrite</span><span>,</span> <span>noOp</span><span>);</span>
    <span>return</span> <span>addWrite</span><span>.</span><span>result</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p><code>clobberize</code> is the function that calls these functors (<code>noOp</code> or <code>addWrite</code> in
this case) for each effect that the given IR instruction <code>node</code> declares.</p>

<p>I’ve pulled some relevant snippets of <code>clobberize</code>, which is quite long, that I
think are interesting.</p>

<p>First, some instructions (constants, here) have no effects. There’s some
utility in the <code>def(PureValue(...))</code> call but I didn’t understand fully.</p>

<p>Then there are some instructions that conditionally have effects depending on
the use types of their operands.<sup id="fnref:dfg-use-type" role="doc-noteref"><a href="#fn:dfg-use-type" rel="footnote">1</a></sup> Taking the absolute value of an
Int32 or a Double is effect-free but otherwise looks like it can run arbitrary
code.</p>

<p>Some run-time IR guards that might cause side exits are annotated as
such—they write to the <code>SideState</code> heap.</p>

<p>Local variable instructions read <em>specific</em> heaps indexed by what looks like
the local index but I’m not sure. This means accessing two different locals
won’t alias!</p>

<p>Instructions that allocate can’t be re-ordered, it looks like; they both read
and write the <code>HeapObjectCount</code>. This probably limits the amount of allocation
sinking that can be done.</p>

<p>Then there’s <code>CallDOM</code>, which is the builtins stuff I was talking about. We’ll
come back to that after the code block.</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>ReadFunctor</span><span>,</span> <span>typename</span> <span>WriteFunctor</span><span>,</span> <span>typename</span> <span>DefFunctor</span><span>,</span> <span>typename</span> <span>ClobberTopFunctor</span><span>&gt;</span>
<span>void</span> <span>clobberize</span><span>(</span><span>Graph</span><span>&amp;</span> <span>graph</span><span>,</span> <span>Node</span><span>*</span> <span>node</span><span>,</span> <span>const</span> <span>ReadFunctor</span><span>&amp;</span> <span>read</span><span>,</span> <span>const</span> <span>WriteFunctor</span><span>&amp;</span> <span>write</span><span>,</span> <span>const</span> <span>DefFunctor</span><span>&amp;</span> <span>def</span><span>)</span>
<span>{</span>
    <span>// ...</span>

    <span>switch</span> <span>(</span><span>node</span><span>-&gt;</span><span>op</span><span>())</span> <span>{</span>
    <span>case</span> <span>JSConstant</span><span>:</span>
    <span>case</span> <span>DoubleConstant</span><span>:</span>
    <span>case</span> <span>Int52Constant</span><span>:</span>
        <span>def</span><span>(</span><span>PureValue</span><span>(</span><span>node</span><span>,</span> <span>node</span><span>-&gt;</span><span>constant</span><span>()));</span>
        <span>return</span><span>;</span>

    <span>case</span> <span>ArithAbs</span><span>:</span>
        <span>if</span> <span>(</span><span>node</span><span>-&gt;</span><span>child1</span><span>().</span><span>useKind</span><span>()</span> <span>==</span> <span>Int32Use</span> <span>||</span> <span>node</span><span>-&gt;</span><span>child1</span><span>().</span><span>useKind</span><span>()</span> <span>==</span> <span>DoubleRepUse</span><span>)</span>
            <span>def</span><span>(</span><span>PureValue</span><span>(</span><span>node</span><span>,</span> <span>node</span><span>-&gt;</span><span>arithMode</span><span>()));</span>
        <span>else</span>
            <span>clobberTop</span><span>();</span>
        <span>return</span><span>;</span>

    <span>case</span> <span>AssertInBounds</span><span>:</span>
    <span>case</span> <span>AssertNotEmpty</span><span>:</span>
        <span>write</span><span>(</span><span>SideState</span><span>);</span>
        <span>return</span><span>;</span>

    <span>case</span> <span>GetLocal</span><span>:</span>
        <span>read</span><span>(</span><span>AbstractHeap</span><span>(</span><span>Stack</span><span>,</span> <span>node</span><span>-&gt;</span><span>operand</span><span>()));</span>
        <span>def</span><span>(</span><span>HeapLocation</span><span>(</span><span>StackLoc</span><span>,</span> <span>AbstractHeap</span><span>(</span><span>Stack</span><span>,</span> <span>node</span><span>-&gt;</span><span>operand</span><span>())),</span> <span>LazyNode</span><span>(</span><span>node</span><span>));</span>
        <span>return</span><span>;</span>

    <span>case</span> <span>NewArrayWithSize</span><span>:</span>
    <span>case</span> <span>NewArrayWithSizeAndStructure</span><span>:</span>
        <span>read</span><span>(</span><span>HeapObjectCount</span><span>);</span>
        <span>write</span><span>(</span><span>HeapObjectCount</span><span>);</span>
        <span>return</span><span>;</span>

    <span>case</span> <span>CallDOM</span><span>:</span> <span>{</span>
        <span>const</span> <span>DOMJIT</span><span>::</span><span>Signature</span><span>*</span> <span>signature</span> <span>=</span> <span>node</span><span>-&gt;</span><span>signature</span><span>();</span>
        <span>DOMJIT</span><span>::</span><span>Effect</span> <span>effect</span> <span>=</span> <span>signature</span><span>-&gt;</span><span>effect</span><span>;</span>
        <span>if</span> <span>(</span><span>effect</span><span>.</span><span>reads</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>effect</span><span>.</span><span>reads</span> <span>==</span> <span>DOMJIT</span><span>::</span><span>HeapRange</span><span>::</span><span>top</span><span>())</span>
                <span>read</span><span>(</span><span>World</span><span>);</span>
            <span>else</span>
                <span>read</span><span>(</span><span>AbstractHeap</span><span>(</span><span>DOMState</span><span>,</span> <span>effect</span><span>.</span><span>reads</span><span>.</span><span>rawRepresentation</span><span>()));</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>effect</span><span>.</span><span>writes</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>effect</span><span>.</span><span>writes</span> <span>==</span> <span>DOMJIT</span><span>::</span><span>HeapRange</span><span>::</span><span>top</span><span>())</span> <span>{</span>
                <span>if</span> <span>(</span><span>Options</span><span>::</span><span>validateDFGClobberize</span><span>())</span>
                    <span>clobberTopFunctor</span><span>();</span>
                <span>write</span><span>(</span><span>Heap</span><span>);</span>
            <span>}</span> <span>else</span>
                <span>write</span><span>(</span><span>AbstractHeap</span><span>(</span><span>DOMState</span><span>,</span> <span>effect</span><span>.</span><span>writes</span><span>.</span><span>rawRepresentation</span><span>()));</span>
        <span>}</span>
        <span>ASSERT_WITH_MESSAGE</span><span>(</span><span>effect</span><span>.</span><span>def</span> <span>==</span> <span>DOMJIT</span><span>::</span><span>HeapRange</span><span>::</span><span>top</span><span>(),</span> <span>&#34;Currently, we do not accept any def for CallDOM.&#34;</span><span>);</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>(Remember that these <code>AbstractHeap</code> operations are very similar to DOMJIT’s
<code>HeapRange</code> with a couple more details—and in some cases even contain DOMJIT
<code>HeapRange</code>s!)</p>

<p>This <code>CallDOM</code> node is the way for the DOM APIs in the browser—a significant
chunk of the builtins, which are written in C++—to communicate what they do
to the optimizing compiler. Without any annotations, the JIT has to assume that
a call into C++ could do anything to the JIT state. Bummer!</p>

<p>But because, for example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/firstChild"><code>Node.firstChild</code></a> <a href="https://github.com/WebKit/WebKit/blob/32bda1b1d73527ba1d05ccba0aa8e463ddeac56d/Source/WebCore/domjit/JSNodeDOMJIT.cpp#L86">annotates what
memory it reads from</a> and what it <em>doesn’t</em> write to,
the JIT can optimize around it better—or even remove the access completely.
It means the JIT can reason about calls to known builtins <em>the same way</em> that
it reasons about normal JIT opcodes.</p>

<p>(Incidentally it looks like it doesn’t even make a C call, but instead is
inlined as a little memory read snippet using a JIT builder API. Neat.)</p>

<!-- TODO tie it back to the original example -->

<!--
B3 from JSC
https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/b3/B3Effects.h
https://github.com/WebKit/WebKit/blob/5811a5ad27100acab51f1d5ba4518eed86bbf00b/Source/JavaScriptCore/b3/B3AbstractHeapRepository.h

DOMJIT from JSC
https://github.com/WebKit/WebKit/blob/main/Source/WebCore/domjit/generate-abstract-heap.rb
generates from https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/WebCore/domjit/DOMJITAbstractHeapRepository.yaml#L4

DFG from JSC
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGAbstractHeap.h
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.h
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.cpp
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.h
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.cpp
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.h
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberSet.h
https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.h
-->

<p>Last, we’ll look at Simple, which has a slightly different take on all of this.</p>

<h2 id="simple">Simple</h2>

<p><a href="https://github.com/seaofnodes/simple">Simple</a> is Cliff Click’s pet Sea of
Nodes (SoN) project to try and showcase the idea to the world—outside of a
HotSpot C2 context.</p>

<p>This one is a little harder for me to understand but it looks like each
translation unit has a <a href="https://github.com/SeaOfNodes/Simple/blob/1426384fc7d0e9947e38ad6d523a5e53c324d710/chapter10/src/main/java/com/seaofnodes/simple/node/StartNode.java#L33"><code>StartNode</code></a> that doles out
different classes of memory nodes for each alias class. Each IR node then takes
data dependencies on whatever effect nodes it might uses.</p>

<p>Alias classes are split up based on the paper <a href="https://solar.lowtechmagazine.com/assets/img/tbaa.pdf">Type-Based Alias Analysis</a>
(PDF): “Our approach is a form of TBAA similar to the ‘FieldTypeDecl’ algorithm
described in the paper.”</p>

<!--

Cliff Click says:

All effects are represented as edges in the graph, the same edges as normal value flows, and all edges in Simple/C2 are simple pointers (and hence are unlabeled).

StartNode produces all effects and StopNode consumes them; same for Call and CallEnd.
Effects, being just another form of value, can be merged in PhiNodes.
Effects are generally split into smaller disjoint pieces, and recombined before Stop/Call.  Splitting into disjoint pieces allows more precision in the IR, and so more optimizations.
The common first split is the Memory effect from all other effects.  Other effects are generally some form of abstract i/o (all file system operations, reading/writing device controller memory, all external calls to disjoint address spaces, etc), or control.  Control is Just Another Edge denoting normal control flow, and e.g. data ops that depend on a prior control op use it to guard for safety.  Things like div-by-0, or null-ptr-check, or array-index-OOB are all done with a control edge to the guarding test.

Memory effects are further split into disjoint aliases; operations in one alias class can never overlap with another (this is a Y/N choice, not a may/must choice).  These aliases are equivalence classes; all mem ops belong in exactly one class, and the set of classes exactly partitions all of memory.  Common splits are fields in a struct (no 'f' field ever overlaps with any 'g' field), or kinds of arrays (no int[] overlaps with a flt[]).

In this example a = l[0]; l[0] = 5, we might have as IR:

a = Load(ctrl-for-AIOOB, mem-for-int[], offset);
mem-for-int[] = Store(ctrl-for-AIOOB, mem-for-int[], offset, 5)



Note that the Load and Store are not ordered here.  This Store IS ordered against all other int[] Stores.
The serializing algo Global Code Motion will add an anti-dep as needed, and then order the Load & Store.

Splitting is basically by having a "narrow" user read from a "fat memory".  Narrow, because its using a single alias and is one of the memops (e.g. Loads and Stores).  A "fat memory" always comes from Start & CallEnd.  A MemMerge can merge a bunch of narrow aliases (and one fat) and make a fat memory.  Basically its all done lazily by "doing nothing", and requiring the graph builder not produce a junk graph.

Splitting happens when the Parser decides you are manipulating a slice.
THere are some peephole's for widening the split region over a larger area, allowing more memory optimizations in the larger wider area.
Load & Stores have a peep to move "up past" a MemMerge on the correct alias edge.
-->

<p>The Simple project is structured into sequential implementation stages and
alias classes come into the picture in <a href="https://github.com/SeaOfNodes/Simple/tree/main/chapter10">Chapter 10</a>.</p>

<p>Because I spent a while spelunking through other implementations to see how
other projects did this, here is a list of the projects I looked at. Mostly,
they use bitsets.</p>

<h2 id="other-implementations">Other implementations</h2>

<h3 id="hhvm">HHVM</h3>

<p><a href="https://github.com/facebook/hhvm">HHVM</a>, a JIT for the
<a href="https://hacklang.org/">Hack</a> language, also uses a bitset for its memory
effects. See for example: <a href="https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/alias-class.h">alias-class.h</a> and
<a href="https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/memory-effects.h">memory-effects.h</a>.</p>

<p>HHVM has a couple places that use this information, such as <a href="https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/def-sink.cpp">a
definition-sinking pass</a>, <a href="https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/alias-analysis.h">alias
analysis</a>, <a href="https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/dce.cpp">DCE</a>, <a href="https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/store-elim.cpp">store
elimination</a>, <a href="https://github.com/facebook/hhvm/blob/1f9eda80656b79634b6956084481ed5a43d8bc2e/hphp/runtime/vm/jit/refcount-opts.cpp">refcount opts</a>, and
more.</p>

<p>If you are wondering why the HHVM representation looks similar to the Cinder
representation, it’s because some former HHVM engineers such as Brett Simmers
also worked on Cinder!</p>

<h3 id="android-art">Android ART</h3>

<p>(note that I am linking an ART fork on GitHub as a reference, but the upstream
code is <a href="https://android.googlesource.com/platform/art/+/refs/heads/main/compiler/optimizing/nodes.h">hosted on googlesource</a>)</p>

<p>Android’s <a href="https://source.android.com/docs/core/runtime">ART Java runtime</a> also
uses a bitset for its effect representation. It’s a very compact class called
<code>SideEffects</code> in <a href="https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/nodes.h#L1602">nodes.h</a>.</p>

<p>The side effects are used in <a href="https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/licm.cc#L104">loop-invariant code motion</a>, <a href="https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/gvn.cc#L204">global
value numbering</a>, <a href="https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/write_barrier_elimination.cc#L45">write barrier
elimination</a>, <a href="https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/scheduler.cc#L55">scheduling</a>,
and more.</p>

<h3 id="netcoreclr">.NET/CoreCLR</h3>

<p>CoreCLR mostly <a href="https://github.com/dotnet/runtime/blob/a0878687d02b42034f4ea433ddd7a72b741510b8/src/coreclr/jit/sideeffects.h#L169">uses a bitset</a> for its <code>SideEffectSet</code>
class. This one is interesting though because it also splits out effects
specifically to include sets of local variables (<code>LclVarSet</code>).</p>

<h3 id="v8">V8</h3>

<p>V8 is also about six completely different compilers in a trenchcoat.</p>

<p>Turboshaft uses a struct in <a href="https://github.com/v8/v8/blob/e817fdf31a2947b2105bd665067d92282e4b4d59/src/compiler/turboshaft/operations.h#L577">operations.h</a> called
<code>OpEffects</code> which is two bitsets for reads/writes of effects. This is used in
<a href="https://github.com/v8/v8/blob/42f5ff65d12f0ef9294fa7d3875feba938a81904/src/compiler/turboshaft/value-numbering-reducer.h#L164">value numbering</a> as well a bunch of
other small optimization passes they call “reducers”.</p>

<p>Maglev also has this thing called <code>NodeT::kProperties</code> in <a href="https://github.com/v8/v8/blob/42f5ff65d12f0ef9294fa7d3875feba938a81904/src/maglev/maglev-ir.h">their IR
nodes</a> that also looks like a bitset and is used in their various
reducers. It has effect query methods on it such as <code>can_eager_deopt</code> and
<code>can_write</code>.</p>

<p>Until recently, V8 also used Sea of Nodes as its IR representation, which also
tracks side effects more explicitly in the structure of the IR itself.</p>

<h2 id="guile">Guile</h2>

<p><a href="https://www.gnu.org/software/guile/">Guile Scheme</a> looks like it has a <a href="https://wingolog.org/archives/2014/05/18/effects-analysis-in-guile">custom tagging
scheme</a> type thing.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Both bitsets and int ranges are perfectly cromulent ways of representing heap
effects for your IR. The Sea of Nodes approach is also probably okay since it
powers HotSpot C2 and (for a time) V8.</p>

<p>Remember to ask <em>the right questions</em> of your IR when doing analysis.</p>

<h2 id="thank-you">Thank you</h2>

<p>Thank you to <a href="http://www.filpizlo.com/">Fil Pizlo</a> for writing his initial
GitHub Gist and sending me on this journey and thank you to <a href="https://www.chrisgregory.me/">Chris
Gregory</a>, Brett Simmers, and <a href="https://ufuk.dev/">Ufuk
Kayserilioglu</a> for feedback on making some of the
explanations more helpful.</p>

<!--

TODO Dart
https://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/constants_riscv.h#L968
https://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/compiler/backend/redundancy_elimination.cc#L758
https://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/compiler/backend/redundancy_elimination.cc#L1096

ChakraCore
https://github.com/chakra-core/ChakraCore/blob/2dba810c925eb366e44a1f7d7a5b2e289e2f8510/lib/Runtime/Types/RecyclableObject.h#L172

SpiderMonkey
https://github.com/servo/mozjs/blob/77645ed41f588297fd8d7edaee71500f4c83d070/mozjs-sys/mozjs/js/src/jit/MIR.h#L935
https://github.com/servo/mozjs/blob/77645ed41f588297fd8d7edaee71500f4c83d070/mozjs-sys/mozjs/js/src/jit/MIR.h#L9658

Cinder LIR
https://github.com/facebookincubator/cinderx/blob/main/cinderx/Jit/lir/instruction.h

HotSpot C1

HotSpot C2

PyPy
https://github.com/pypy/pypy/blob/main/rpython/jit/codewriter/effectinfo.py
https://github.com/pypy/pypy/blob/main/rpython/jit/metainterp/optimizeopt/heap.py#L59

LLVM
https://llvm.org/docs/LangRef.html#tbaa-metadata

LLVM MemorySSA
https://llvm.org/docs/MemorySSA.html

MLIR
https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/

MEMOIR
https://conf.researchr.org/details/cgo-2024/cgo-2024-main-conference/31/Representing-Data-Collections-in-an-SSA-Form

Scala LMS graph IR
https://2023.splashcon.org/details/splash-2023-oopsla/46/Graph-IRs-for-Impure-Higher-Order-Languages-Making-Aggressive-Optimizations-Affordab

MIR and borrow checker
https://rustc-dev-guide.rust-lang.org/part-3-intro.html#source-code-representation

> "Fabrice Rastello, Florent Bouchez Tichadou (2022) SSA-based Compiler Design"--most (all?) chapters in Part III, Extensions, are pretty much motivated by doing alias analysis in some way

Intermediate Representations in Imperative Compilers: A Survey
http://kameken.clique.jp/Lectures/Lectures2013/Compiler2013/a26-stanier.pdf

Partitioned Lattice per Variable (PLV) -- that's in Chapter 13 on SSI

TODO maybe lattice in ascent

-->


        </div></div>
  </body>
</html>
