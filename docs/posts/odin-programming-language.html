<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://odin-lang.org/">Original</a>
    <h1>Odin Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>

<section id="example">
<div>
<div>
<div>
<h2>Programming Done Right</h2>
<p>
Odin is a general-purpose programming language with distinct typing built for high performance, modern systems and data-oriented programming.
</p>
<p>
Odin is the C alternative for the Joy of Programming.
</p>
<p><a href="https://odin-lang.org/docs">
Read the Docs
</a>
<a href="https://github.com/odin-lang/Odin/blob/master/examples/demo/demo.odin">
See the Full Demo
</a>
</p></div>
<div>
<div>
<div id="example-1-code" role="option" aria-labelledby="example-1-code">
<pre><code>package main

import &#34;core:fmt&#34;

main :: proc() {
	program := &#34;+ + * ðŸ˜ƒ - /&#34;
	accumulator := 0

	for token in program {
		switch token {
		case &#39;+&#39;: accumulator += 1
		case &#39;-&#39;: accumulator -= 1
		case &#39;*&#39;: accumulator *= 2
		case &#39;/&#39;: accumulator /= 2
		case &#39;ðŸ˜ƒ&#39;: accumulator *= accumulator
		case: // Ignore everything else
		}
	}

	fmt.printf(&#34;The program \&#34;%s\&#34; calculates the value %d\n&#34;,
	           program, accumulator)
}</code></pre>
</div>
<div id="example-2-code" role="option" aria-labelledby="example-2-code">
<pre><code>package main

import &#34;core:fmt&#34;

main :: proc() {
	{
		a := [3]f32{1, 2, 3}
		b := [3]f32{5, 6, 7}
		c := a * b
		d := a + b
		e := 1 +  (c - d) / 2
		fmt.printf(&#34;%.1f\n&#34;, e) // [0.5, 3.0, 6.5]
	}

	{
		a := [3]f32{1, 2, 3}
		b := swizzle(a, 2, 1, 0)
		assert(b == [3]f32{3, 2, 1})

		c := a.xx
		assert(c == [2]f32{1, 1})
		assert(c == 1)

		d := swizzle(a, 0, 0)
		assert(d == [2]f32{1, 1})
		assert(d == 1)
	}

	{
		Vector3 :: distinct [3]f32
		a := Vector3{1, 2, 3}
		b := Vector3{5, 6, 7}
		c := (a * b)/2 + 1
		d := c.x + c.y + c.z
		fmt.printf(&#34;%.1f\n&#34;, d) // 22.0

		cross :: proc(a, b: Vector3) -&gt; Vector3 {
			i := a.yzx * b.zxy
			j := a.zxy * b.yzx
			return i - j
		}

		cross_explicit :: proc(a, b: Vector3) -&gt; Vector3 {
			i := swizzle(a, 1, 2, 0) * swizzle(b, 2, 0, 1)
			j := swizzle(a, 2, 0, 1) * swizzle(b, 1, 2, 0)
			return i - j
		}

		blah :: proc(a: Vector3) -&gt; f32 {
			return a.x + a.y + a.z
		}

		x := cross(a, b)
		fmt.println(x)
		fmt.println(blah(x))
	}
}</code></pre>
</div>
<div id="example-3-code" role="option" aria-labelledby="example-3-code">
<pre><code>package main

import &#34;core:fmt&#34;

main :: proc() {
	{
		Vector3 :: struct {x, y, z: f32}

		N :: 2
		v_aos: [N]Vector3
		v_aos[0].x = 1
		v_aos[0].y = 4
		v_aos[0].z = 9

		fmt.println(len(v_aos))
		fmt.println(v_aos[0])
		fmt.println(v_aos[0].x)
		fmt.println(&amp;v_aos[0].x)

		v_aos[1] = {0, 3, 4}
		v_aos[1].x = 2
		fmt.println(v_aos[1])
		fmt.println(v_aos)

		v_soa: #soa[N]Vector3

		v_soa[0].x = 1
		v_soa[0].y = 4
		v_soa[0].z = 9


		// Same syntax as AOS and treat as if it was an array
		fmt.println(len(v_soa))
		fmt.println(v_soa[0])
		fmt.println(v_soa[0].x)
		fmt.println(&amp;v_soa[0].x)
		v_soa[1] = {0, 3, 4}
		v_soa[1].x = 2
		fmt.println(v_soa[1])

		// Can use SOA syntax if necessary
		v_soa.x[0] = 1
		v_soa.y[0] = 4
		v_soa.z[0] = 9
		fmt.println(v_soa.x[0])

		// Same pointer addresses with both syntaxes
		assert(&amp;v_soa[0].x == &amp;v_soa.x[0])


		// Same fmt printing
		fmt.println(v_aos)
		fmt.println(v_soa)
	}
	{
		// Works with arrays of length &lt;= 4 which have the implicit fields xyzw/rgba
		Vector3 :: distinct [3]f32

		N :: 2
		v_aos: [N]Vector3
		v_aos[0].x = 1
		v_aos[0].y = 4
		v_aos[0].z = 9

		v_soa: #soa[N]Vector3

		v_soa[0].x = 1
		v_soa[0].y = 4
		v_soa[0].z = 9
	}
	{
		// SOA Slices
		// Vector3 :: struct {x, y, z: f32}
		Vector3 :: struct {x: i8, y: i16, z: f32}

		N :: 3
		v: #soa[N]Vector3
		v[0].x = 1
		v[0].y = 4
		v[0].z = 9

		s: #soa[]Vector3
		s = v[:]
		assert(len(s) == N)
		fmt.println(s)
		fmt.println(s[0].x)

		a := s[1:2]
		assert(len(a) == 1)
		fmt.println(a)

		d: #soa[dynamic]Vector3

		append_soa(&amp;d, Vector3{1, 2, 3}, Vector3{4, 5, 9}, Vector3{-4, -4, 3})
		fmt.println(d)
		fmt.println(len(d))
		fmt.println(cap(d))
		fmt.println(d[:])
	}
	{ // soa_zip and soa_unzip
		fmt.println(&#34;\nsoa_zip and soa_unzip&#34;)

		x := []i32{1, 3, 9}
		y := []f32{2, 4, 16}
		z := []b32{true, false, true}

		// produce an #soa slice the normal slices passed
		s := soa_zip(a=x, b=y, c=z)

		// iterate over the #soa slice
		for v, i in s {
			fmt.println(v, i) // exactly the same as s[i]
			// NOTE: &#39;v&#39; is NOT a temporary value but has a specialized addressing mode
			// which means that when accessing v.a etc, it does the correct transformation
			// internally:
			//         s[i].a === s.a[i]
			fmt.println(v.a, v.b, v.c)
		}

		// Recover the slices from the #soa slice
		a, b, c := soa_unzip(s)
		fmt.println(a, b, c)
	}
}</code></pre>
</div>
<div id="example-4-code" role="option" aria-labelledby="example-4-code">
<pre><code>package main

import &#34;core:mem&#34;

main :: proc() {
	// In each scope, there is an implicit value named context. This
	// context variable is local to each scope and is implicitly passed
	// by pointer to any procedure call in that scope (if the procedure
	// has the Odin calling convention).

	// The main purpose of the implicit context system is for the ability
	// to intercept third-party code and libraries and modify their
	// functionality. One such case is modifying how a library allocates
	// something or logs something. In C, this was usually achieved with
	// the library defining macros which could be overridden so that the
	// user could define what he wanted. However, not many libraries
	// supported this in many languages by default which meant intercepting
	// third-party code to see what it does and to change how it does it is
	// not possible.

	c := context // copy the current scope&#39;s context

	context.user_index = 456
	{
		context.allocator = my_custom_allocator()
		context.user_index = 123
		what_a_fool_believes() // the `context` for this scope is implicitly passed to `what_a_fool_believes`
	}

	// `context` value is local to the scope it is in
	assert(context.user_index == 456)

	what_a_fool_believes :: proc() {
		c := context // this `context` is the same as the parent procedure that it was called from
		// From this example, context.user_index == 123
		// An context.allocator is assigned to the return value of `my_custom_allocator()`
		assert(context.user_index == 123)

		// The memory management procedure use the `context.allocator` by
		// default unless explicitly specified otherwise
		china_grove := new(int)
		free(china_grove)

		_ = c
	}

	my_custom_allocator :: mem.nil_allocator
	_ = c

	// By default, the context value has default values for its parameters which is
	// decided in the package runtime. What the defaults are are compiler specific.

	// To see what the implicit context value contains, please see the following
	// definition in package runtime.
}</code></pre>
</div>
<div id="example-5-code" role="option" aria-labelledby="example-5-code">
<pre><code>package main

import &#34;core:fmt&#34;
import &#34;core:reflect&#34;

main :: proc() {
	Foo :: struct {
		x: int    `tag1`,
		y: string `json:&#34;y_field&#34;`,
		z: bool, // no tag
	}

	id := typeid_of(Foo)
	names := reflect.struct_field_names(id)
	types := reflect.struct_field_types(id)
	tags  := reflect.struct_field_tags(id)

	assert(len(names) == len(types) &amp;&amp; len(names) == len(tags))

	fmt.println(&#34;Foo :: struct {&#34;)
	for tag, i in tags {
		name, type := names[i], types[i]
		if tag != &#34;&#34; {
			fmt.printf(&#34;\t%s: %T `%s`,\n&#34;, name, type, tag)
		} else {
			fmt.printf(&#34;\t%s: %T,\n&#34;, name, type)
		}
	}
	fmt.println(&#34;}&#34;)

	for tag, i in tags {
		if val, ok := reflect.struct_tag_lookup(tag, &#34;json&#34;) ok {
			fmt.printf(&#34;json: %s -&gt; %s\n&#34;, names[i], val)
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section>
<div>
<div>
<p>
<h2>Join the Odin community on Discord.</h2>
</p>

</div>
</div>
</section>
<section id="principles">
<div>
<h2>The Odin Principles</h2>
<div>
<div>
<h3>Simplicity</h3>
<p>
Odin has been designed for readability, scalability, and <a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">orthogonality</a> of concepts. Simplicity is complicated to get right, clear is better than clever.
</p>
</div>
<div>
<h3>High Performance</h3>
<p>
Odin allows for the highest performance through low-level control over the memory layout, <a href="https://odin-lang.org/docs/overview/#implicit-context-system">memory management</a> and custom <a href="https://odin-lang.org/docs/overview/#allocators">allocators</a> and so much more.
</p>
</div>
<div>
<h3>For Modern Systems</h3>
<p>
Odin is designed from the bottom up for the modern computer, with built-in support for <a href="https://odin-lang.org/docs/overview/#soa-data-types">SOA data types</a>, <a href="https://odin-lang.org/docs/overview/#fixed-arrays">array programming</a>, and other features.
</p>
</div>
<div>
<h3>Joy of Programming</h3>
<p>
We go into programming because we love to solve problems. Why shouldn&#39;t our tools bring us joy whilst doing it? Enjoy programming again, with Odin!
</p>
</div>
</div>

</div>
</section>
<section id="users">
<div>
<h2>Odin in Production</h2>
<div>
<div>
<p>
<a href="https://jangafx.com/" target="_blank">JangaFX</a> are the creators of the 3D animation software <a href="https://jangafx.com/software/embergen/" target="_blank">EmberGen</a> written <i>fully</i> in Odin.
</p>
<p>
<a href="https://jangafx.com/software/embergen/" target="_blank">EmberGen</a> is a real-time volumetric fluid simulator that can instantly simulate, render, and export flipbooks, image sequences, and VDB volumes. With EmberGen, you can create anything from fire and smoke, to explosions and magic wisps. EmberGen gives you the creative freedom to iterate on your simulations in a few milliseconds instead of hours.
</p>
<p>
Through EmberGen, Odin runs in production among the giants of the games and film industries: Bethesda, CAPCOM, Codemasters, THQNordic, Warner Bros, Weta Digital, and many others.
</p>

</div>
<div>
<div>
<p>
<iframe src="https://www.youtube-nocookie.com/embed/EJgA0LLq5TM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</p>
</div>
</div>
</div>
<div id="jangafx-companies">
<p>
Companies who use EmberGen
</p>
<p><img src="https://odin-lang.org/jangafx/companies/jangafx_logos_cluster.png" alt="JangaFX Customers"/></p><p>
All product names, logos, and brands are property of their respective owners.
</p>
</div>

</div>
</section>
<section id="batteries-included">
<div>
<div>
<div>
<h2>Batteries Included</h2>
<div>
<p>
Odin comes with high quality packages out of the box in its <a href="https://github.com/odin-lang/Odin/tree/master/core" target="_blank"><code>core</code></a> library.
</p>
<p>
Odin provides official libraries for all major graphics APIs: <a href="https://pkg.odin-lang.org/vendor/OpenGL" target="_blank">OpenGL</a>, <a href="https://pkg.odin-lang.org/vendor/vulkan" target="_blank">Vulkan</a>, <a href="https://pkg.odin-lang.org/vendor/directx/d3d11" target="_blank">Direct3D11</a>, <a href="https://pkg.odin-lang.org/vendor/directx/d3d12" target="_blank">Direct3D12</a>, <a href="https://pkg.odin-lang.org/vendor/darwin/Metal" target="_blank">Metal</a>, and <a href="https://github.com/odin-lang/Odin/tree/master/vendor/wasm/WebGL" target="_blank">WebGL 1 &amp; 2</a>.
</p>
<p>
Odin additionally brings you officially maintained bindings for popular libraries such as <a href="https://pkg.odin-lang.org/vendor/sdl2" target="_blank">SDL2</a>, <a href="https://pkg.odin-lang.org/vendor/glfw" target="_blank">GLFW</a>, <a href="https://pkg.odin-lang.org/vendor/raylib" target="_blank">raylib</a>, <a href="https://pkg.odin-lang.org/vendor/microui" target="_blank">microui</a>, <a href="https://pkg.odin-lang.org/vendor/miniaudio" target="_blank">miniaudio</a> and much more, in its <a href="https://pkg.odin-lang.org/vendor" target="_blank"><code>vendor</code></a> library!
</p>
</div>

</div>

</div>
</div>
</section>

</div></div>
  </body>
</html>
