<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sampruden.github.io/posts/godot-is-not-the-new-unity/">Original</a>
    <h1>Godot is not the new Unity – The anatomy of a Godot API call</h1>
    
    <div id="readability-page-1" class="page"><div><p>Like many people, I’ve spent the last few days looking for the new Unity. Godot has some potential, especially if it can take advantage of an influx of dev talent to drive rapid improvement. Open source is cool like that. However, one major issue holds it back - the binding layer between engine code and gameplay code is structurally built to be slow in ways which are very hard to fix without tearing everything down and rebuilding the entire API from scratch.</p><p>Godot has been used to create some successful games, so clearly this isn’t always a blocker. However Unity has spent the last five years working on speeding up their scripting with crazy projects such as building two custom compilers, SIMD maths libraries, custom collections and allocators, and of course the giant (and very much unfinished) ECS project. It’s been their CTO’s primary focus since 2018. Clearly Unity believed that scripting performance mattered to a significant part of their userbase. Switching to Godot isn’t only like going back five years in Unity - it’s so much worse.</p><p>I started <a href="https://reddit.com/r/godot/comments/16j345n/is_the_c_raycasting_api_as_poor_as_it_first/">a controversial but productive discussion</a> about this on the Godot subreddit a few days ago. This article is a more detailed continuation of my thoughts in that post now that I have a <strong>little</strong> more understanding of how Godot works. <strong>Let’s be clear here: I’m still a Godot newb, and this article <em>will</em> contain mistakes and misconceptions.</strong></p><p><em>Note: The following contains criticisms of the Godot engine’s design and engineering. Although I occasionally use some emotive language to describe my feelings about these things, the Godot developers have put in lots of hard work for the FOSS community and built something that’s loved by many people, and my intent is not to offend or come across as rude to any individuals.</em></p><h2 id="deepdive-into-performing-a-raycast-from-c"><span>Deepdive into performing a raycast from C#</span><a href="#deepdive-into-performing-a-raycast-from-c"><i></i></a></h2><p>We’re going to take a deep dive into how Godot achieves the equivalent of Unity’s <code>Physics2D.Raycast</code>, and what happens under the hood when we use it. To make this a little more concrete, let’s start by implementing a trivial function in Unity.</p><h3 id="unity"><span>Unity</span><a href="#unity"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>// Simple raycast in Unity</span>
<span>bool</span> <span>GetRaycastDistanceAndNormal</span><span>(</span><span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>out</span> <span>float</span> <span>distance</span><span>,</span> <span>out</span> <span>Vector2</span> <span>normal</span><span>)</span> <span>{</span>
    <span>RaycastHit2D</span> <span>hit</span> <span>=</span> <span>Physics2D</span><span>.</span><span>Raycast</span><span>(</span><span>origin</span><span>,</span> <span>direction</span><span>);</span>
    <span>distance</span> <span>=</span> <span>hit</span><span>.</span><span>distance</span><span>;</span>
    <span>normal</span> <span>=</span> <span>hit</span><span>.</span><span>normal</span><span>;</span>
    <span>return</span> <span>(</span><span>bool</span><span>)</span><span>hit</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Let’s have a quick look at how this is implemented by following the calls.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td><pre><span>public</span> <span>static</span> <span>RaycastHit2D</span> <span>Raycast</span><span>(</span><span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>)</span>
 <span>=&gt;</span> <span>defaultPhysicsScene</span><span>.</span><span>Raycast</span><span>(</span><span>origin</span><span>,</span> <span>direction</span><span>,</span> <span>float</span><span>.</span><span>PositiveInfinity</span><span>);</span>

<span>public</span> <span>RaycastHit2D</span> <span>Raycast</span><span>(</span><span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>float</span> <span>distance</span><span>,</span> <span>[</span><span>DefaultValue</span><span>(</span><span>&#34;Physics2D.DefaultRaycastLayers&#34;</span><span>)]</span> <span>int</span> <span>layerMask</span> <span>=</span> <span>-</span><span>5</span><span>)</span>
<span>{</span>
    <span>ContactFilter2D</span> <span>contactFilter</span> <span>=</span> <span>ContactFilter2D</span><span>.</span><span>CreateLegacyFilter</span><span>(</span><span>layerMask</span><span>,</span> <span>float</span><span>.</span><span>NegativeInfinity</span><span>,</span> <span>float</span><span>.</span><span>PositiveInfinity</span><span>);</span>
    <span>return</span> <span>Raycast_Internal</span><span>(</span><span>this</span><span>,</span> <span>origin</span><span>,</span> <span>direction</span><span>,</span> <span>distance</span><span>,</span> <span>contactFilter</span><span>);</span>
<span>}</span>

<span>[</span><span>NativeMethod</span><span>(</span><span>&#34;Raycast_Binding&#34;</span><span>)]</span>
<span>[</span><span>StaticAccessor</span><span>(</span><span>&#34;PhysicsQuery2D&#34;</span><span>,</span> <span>StaticAccessorType</span><span>.</span><span>DoubleColon</span><span>)]</span>
<span>private</span> <span>static</span> <span>RaycastHit2D</span> <span>Raycast_Internal</span><span>(</span><span>PhysicsScene2D</span> <span>physicsScene</span><span>,</span> <span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>float</span> <span>distance</span><span>,</span> <span>ContactFilter2D</span> <span>contactFilter</span><span>)</span>
<span>{</span>
    <span>Raycast_Internal_Injected</span><span>(</span><span>ref</span> <span>physicsScene</span><span>,</span> <span>ref</span> <span>origin</span><span>,</span> <span>ref</span> <span>direction</span><span>,</span> <span>distance</span><span>,</span> <span>ref</span> <span>contactFilter</span><span>,</span> <span>out</span> <span>var</span> <span>ret</span><span>);</span>
    <span>return</span> <span>ret</span><span>;</span>
<span>}</span>

<span>[</span><span>MethodImpl</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>InternalCall</span><span>)]</span>
<span>private</span> <span>static</span> <span>extern</span> <span>void</span> <span>Raycast_Internal_Injected</span><span>(</span>
    <span>ref</span> <span>PhysicsScene2D</span> <span>physicsScene</span><span>,</span> <span>ref</span> <span>Vector2</span> <span>origin</span><span>,</span> <span>ref</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>float</span> <span>distance</span><span>,</span>
    <span>ref</span> <span>ContactFilter2D</span> <span>contactFilter</span><span>,</span> <span>out</span> <span>RaycastHit2D</span> <span>ret</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>Okay, so it does a tiny amount of work and efficiently shunts the call off to the unmanaged engine core via the extern mechanism. That makes sense, I’m sure Godot will do something similar. Foreshadowing.</p><h3 id="godot"><span>Godot</span><a href="#godot"><i></i></a></h3><p>Let’s do the same thing in Godot, <a href="https://docs.godotengine.org/en/stable/tutorials/physics/ray-casting.html#raycast-query">exactly as the tutorial recommends</a>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td><pre><span>// Equivalent raycast in Godot</span>
<span>bool</span> <span>GetRaycastDistanceAndNormal</span><span>(</span><span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>out</span> <span>float</span> <span>distance</span><span>,</span> <span>out</span> <span>Vector2</span> <span>normal</span><span>)</span>
<span>{</span>
    <span>World2D</span> <span>world</span> <span>=</span> <span>GetWorld2D</span><span>();</span>
    <span>PhysicsDirectSpaceState2D</span> <span>spaceState</span> <span>=</span> <span>world</span><span>.</span><span>DirectSpaceState</span><span>;</span>
    <span>PhysicsRayQueryParameters2D</span> <span>queryParams</span> <span>=</span> <span>PhysicsRayQueryParameters2D</span><span>.</span><span>Create</span><span>(</span><span>origin</span><span>,</span> <span>origin</span> <span>+</span> <span>direction</span><span>);</span>
    <span>Godot</span><span>.</span><span>Collections</span><span>.</span><span>Dictionary</span> <span>hitDictionary</span> <span>=</span> <span>spaceState</span><span>.</span><span>IntersectRay</span><span>(</span><span>queryParams</span><span>);</span>

    <span>if</span> <span>(</span><span>hitDictionary</span><span>.</span><span>Count</span> <span>!=</span> <span>0</span><span>)</span>
    <span>{</span>
        <span>Variant</span> <span>hitPositionVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;position&#34;</span><span>];</span>
        <span>Vector2</span> <span>hitPosition</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitPositionVariant</span><span>;</span>
        <span>Variant</span> <span>hitNormalVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;normal&#34;</span><span>];</span>
        <span>Vector2</span> <span>hitNormal</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitNormalVariant</span><span>;</span>
        
        <span>distance</span> <span>=</span> <span>(</span><span>hitPosition</span> <span>-</span> <span>origin</span><span>).</span><span>Length</span><span>();</span>
        <span>normal</span> <span>=</span> <span>hitNormal</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>distance</span> <span>=</span> <span>default</span><span>;</span>
    <span>normal</span> <span>=</span> <span>default</span><span>;</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The first thing that we notice is that this is longer. That is not the focus of my criticism, and is partly due to the fact that I’ve formatted this code verbosely in order to make it easier for us to break it down line by line. So let’s do that, what’s actually happening here?</p><p>We start by calling <code>GetWorld2D()</code>. In Godot, physics queries are all performed in the context of a world, and this function gets the world our code is running in. Although this <code>World2D</code> is a managed class type, this function doesn’t do anything crazy like allocate every time we run it. None of these functions are going to do anything crazy like that for a simple raycast, right? Foreshadowing.</p><p>If we look inside these API calls we’ll see that even ostensibly simple ones like this are implemented through some rather convoluted machinery which will have at least a little performance overhead. Let’s dive into <code>GetWorld2D</code> as an example of that by unravelling some of its calls through C#. This is roughly what all the calls that return managed types look like. I’ve added some comments to explain what’s going on.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td><pre><span>// This is the function we&#39;re diving into.</span>
<span>public</span> <span>World2D</span> <span>GetWorld2D</span><span>()</span>
<span>{</span>
    <span>// MethodBind64 is a pointer to the function we&#39;re calling in C++.</span>
    <span>// MethodBind64 is stored in a static variable, so we have to do a memory lookup to retrieve it.</span>
    <span>return</span> <span>(</span><span>World2D</span><span>)</span><span>NativeCalls</span><span>.</span><span>godot_icall_0_51</span><span>(</span><span>MethodBind64</span><span>,</span> <span>GodotObject</span><span>.</span><span>GetPtr</span><span>(</span><span>this</span><span>));</span>
<span>}</span>

<span>// We call into these functions which mediate API calls.</span>
<span>internal</span> <span>unsafe</span> <span>static</span> <span>GodotObject</span> <span>godot_icall_0_51</span><span>(</span><span>IntPtr</span> <span>method</span><span>,</span> <span>IntPtr</span> <span>ptr</span><span>)</span>
<span>{</span>
    <span>godot_ref</span> <span>godot_ref</span> <span>=</span> <span>default</span><span>(</span><span>godot_ref</span><span>);</span>

    <span>// The try/finally machinery is not free. This introduces a state machine.</span>
    <span>// It can also block JIT optimisations.</span>
    <span>try</span>
    <span>{</span>
        <span>// Validation check, even though everything here is internal and should be trusted.</span>
        <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>throw</span> <span>new</span> <span>ArgumentNullException</span><span>(</span><span>&#34;ptr&#34;</span><span>);</span>

        <span>// This calls into another function which performs the actual function pointer call</span>
        <span>// and puts the unmanaged result in godot_ref via a pointer.</span>
        <span>NativeFuncs</span><span>.</span><span>godotsharp_method_bind_ptrcall</span><span>(</span><span>method</span><span>,</span> <span>ptr</span><span>,</span> <span>null</span><span>,</span> <span>&amp;</span><span>godot_ref</span><span>);</span>
        
        <span>// This is some machinery for moving references to managed objects over the C#/C++ boundary.</span>
        <span>return</span> <span>InteropUtils</span><span>.</span><span>UnmanagedGetManaged</span><span>(</span><span>godot_ref</span><span>.</span><span>Reference</span><span>);</span>
    <span>}</span>
    <span>finally</span>
    <span>{</span>
        <span>godot_ref</span><span>.</span><span>Dispose</span><span>();</span>
    <span>}</span>
<span>}</span>

<span>// The function which actually calls the function pointer.</span>
<span>[</span><span>global</span><span>::</span><span>System</span><span>.</span><span>Runtime</span><span>.</span><span>CompilerServices</span><span>.</span><span>MethodImpl</span><span>(</span><span>global</span><span>::</span><span>System</span><span>.</span><span>Runtime</span><span>.</span><span>CompilerServices</span><span>.</span><span>MethodImplOptions</span><span>.</span><span>AggressiveInlining</span><span>)]</span>
<span>public</span> <span>static</span> <span>partial</span> <span>void</span> <span>godotsharp_method_bind_ptrcall</span><span>(</span> <span>global</span><span>::</span><span>System</span><span>.</span><span>IntPtr</span> <span>p_method_bind</span><span>,</span>  <span>global</span><span>::</span><span>System</span><span>.</span><span>IntPtr</span> <span>p_instance</span><span>,</span>  <span>void</span><span>**</span> <span>p_args</span><span>,</span>  <span>void</span><span>*</span> <span>p_ret</span><span>)</span>
<span>{</span>
    <span>// But wait! </span>
    <span>// _unmanagedCallbacks.godotsharp_method_bind_ptrcall is actually another</span>
    <span>// static variable access to retrieve another function pointer.</span>
    <span>_unmanagedCallbacks</span><span>.</span><span>godotsharp_method_bind_ptrcall</span><span>(</span><span>p_method_bind</span><span>,</span> <span>p_instance</span><span>,</span> <span>p_args</span><span>,</span> <span>p_ret</span><span>);</span>
<span>}</span>

<span>// To be honest, I haven&#39;t studied this well enough to know exactly what&#39;s happening here.</span>
<span>// The basic idea is straightforward - this takes a pointer to an unmanaged GodotObject,</span>
<span>// brings it into .Net, notifies the garbage collector of it so that it can be tracked,</span>
<span>// and casts it to the GodotObject type.</span>
<span>// Fortunately, this doesn&#39;t appear to do any allocations. Foreshadowing.</span>
<span>public</span> <span>static</span> <span>GodotObject</span> <span>UnmanagedGetManaged</span><span>(</span><span>IntPtr</span> <span>unmanaged</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>unmanaged</span> <span>==</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>return</span> <span>null</span><span>;</span>

    <span>IntPtr</span> <span>intPtr</span> <span>=</span> <span>NativeFuncs</span><span>.</span><span>godotsharp_internal_unmanaged_get_script_instance_managed</span><span>(</span><span>unmanaged</span><span>,</span> <span>out</span> <span>var</span> <span>r_has_cs_script_instance</span><span>);</span>
    <span>if</span> <span>(</span><span>intPtr</span> <span>!=</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>return</span> <span>(</span><span>GodotObject</span><span>)</span><span>GCHandle</span><span>.</span><span>FromIntPtr</span><span>(</span><span>intPtr</span><span>).</span><span>Target</span><span>;</span>
    <span>if</span> <span>(</span><span>r_has_cs_script_instance</span><span>.</span><span>ToBool</span><span>())</span> <span>return</span> <span>null</span><span>;</span>

    <span>intPtr</span> <span>=</span> <span>NativeFuncs</span><span>.</span><span>godotsharp_internal_unmanaged_get_instance_binding_managed</span><span>(</span><span>unmanaged</span><span>);</span>
    <span>object</span> <span>obj</span> <span>=</span> <span>((</span><span>intPtr</span> <span>!=</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>?</span> <span>GCHandle</span><span>.</span><span>FromIntPtr</span><span>(</span><span>intPtr</span><span>).</span><span>Target</span> <span>:</span> <span>null</span><span>);</span>
    <span>if</span> <span>(</span><span>obj</span> <span>!=</span> <span>null</span><span>)</span> <span>return</span> <span>(</span><span>GodotObject</span><span>)</span><span>obj</span><span>;</span>

    <span>intPtr</span> <span>=</span> <span>NativeFuncs</span><span>.</span><span>godotsharp_internal_unmanaged_instance_binding_create_managed</span><span>(</span><span>unmanaged</span><span>,</span> <span>intPtr</span><span>);</span>
    <span>if</span> <span>(!(</span><span>intPtr</span> <span>!=</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>))</span> <span>return</span> <span>null</span><span>;</span>

    <span>return</span> <span>(</span><span>GodotObject</span><span>)</span><span>GCHandle</span><span>.</span><span>FromIntPtr</span><span>(</span><span>intPtr</span><span>).</span><span>Target</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>This is actually a substantial amount of overhead. We have a number of layers of pointer chasing indirection between our code and C++. Each of those is a memory lookup, and on top of that we do a bit of work with the validation, <code>try</code> <code>finally</code>, and interpreting the returned pointer. These may sound like tiny inconsequential things, but when every single call into the core and every property/field access on a Godot object does this whole journey, it starts to add up.</p><p>If we look at the next line which accesses the <code>world.DirectSpaceState</code> property we’ll find it does pretty much the same thing. The <code>PhysicsDirectSpaceState2D</code> is once again retrieved from C++ land via this machinery. Don’t worry, I won’t bore you with the details!</p><p>The line after that is the first thing I saw here that really boggled my bonnet.</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>PhysicsRayQueryParameters2D</span> <span>queryParams</span> <span>=</span> <span>PhysicsRayQueryParameters2D</span><span>.</span><span>Create</span><span>(</span><span>origin</span><span>,</span> <span>origin</span> <span>+</span> <span>direction</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>What’s the big deal, that’s just a little struct packing some raycast parameters, right? <strong>Wrong</strong>. <code>PhysicsRayQueryParameters2D</code> is a managed class, and this is a full GC garbage generating allocation. That’s a pretty crazy thing to have in a performance sensitive hot path! I’m sure it’s just the one allocation though, right? Let’s have a look inside.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>// Summary:</span>
<span>//     Returns a new, pre-configured Godot.PhysicsRayQueryParameters2D object. Use it</span>
<span>//     to quickly create query parameters using the most common options.</span>
<span>//     var query = PhysicsRayQueryParameters2D.create(global_position, global_position</span>
<span>//     + Vector2(0, 100))</span>
<span>//     var collision = get_world_2d().direct_space_state.intersect_ray(query)</span>
<span>public</span> <span>unsafe</span> <span>static</span> <span>PhysicsRayQueryParameters2D</span> <span>Create</span><span>(</span><span>Vector2</span> <span>from</span><span>,</span> <span>Vector2</span> <span>to</span><span>,</span> <span>uint</span> <span>collisionMask</span> <span>=</span> <span>uint</span><span>.</span><span>MaxValue</span><span>,</span> <span>Array</span><span>&lt;</span><span>Rid</span><span>&gt;</span> <span>exclude</span> <span>=</span> <span>null</span><span>)</span>
<span>{</span>
    <span>// Yes, this goes through all of the same machinery discussed above.</span>
    <span>return</span> <span>(</span><span>PhysicsRayQueryParameters2D</span><span>)</span><span>NativeCalls</span><span>.</span><span>godot_icall_4_731</span><span>(</span>
        <span>MethodBind0</span><span>,</span>
        <span>&amp;</span><span>from</span><span>,</span> <span>&amp;</span><span>to</span><span>,</span> <span>collisionMask</span><span>,</span>
        <span>(</span><span>godot_array</span><span>)(</span><span>exclude</span> <span>??</span> <span>new</span> <span>Array</span><span>&lt;</span><span>Rid</span><span>&gt;()).</span><span>NativeValue</span>
    <span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Uh oh. Have you spotted it yet?</p><p>That <code>Array&lt;Rid&gt;</code> is a <code>Godot.Collections.Array</code>. That’s another managed class type. Look what happens when we pass in a <code>null</code> value.</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>(</span><span>godot_array</span><span>)(</span><span>exclude</span> <span>??</span> <span>new</span> <span>Array</span><span>&lt;</span><span>Rid</span><span>&gt;()).</span><span>NativeValue</span>
</pre></td></tr></tbody></table></code></p></div><p>That’s right, even if we don’t pass an <code>exclude</code> array, it goes ahead and allocates a whole array on the C# heap for us anyway, just so that it can immediately convert it back into a native value representing an empty array.</p><p>In order to pass two simple <code>Vector2</code> values (16 bytes) to a raycast function, we’ve now done two separate garbage creating heap allocations totalling 632 bytes!</p><p>As you’ll see later, we can mitigate this by caching a <code>PhysicsRayQueryParameters2D</code>. However, as you can see from the doc comment I included above, the API clearly expects and recommends creating fresh instances for each raycast.</p><p>Let’s move onto the next line. It can’t get any crazier, right? Foreshadowing.</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>Godot</span><span>.</span><span>Collections</span><span>.</span><span>Dictionary</span> <span>hitDictionary</span> <span>=</span> <span>spaceState</span><span>.</span><span>IntersectRay</span><span>(</span><span>queryParams</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>Whelp. That shadowing wasn’t very fore.</p><p>That’s right, our raycast is returning an untyped dictionary. And yes, it creates garbage by allocating in on the managed heap, another 96 bytes. You have my permission to do a bemused and upset type of face now. “Oh, well maybe it at least returns null if it doesn’t hit anything?” you may be thinking. No. If it doesn’t hit anything, it allocates and returns an empty dictionary.</p><p>Let’s jump straight into the C++ implementation here.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td><pre><span>Dictionary</span> <span>PhysicsDirectSpaceState2D</span><span>::</span><span>_intersect_ray</span><span>(</span><span>const</span> <span>Ref</span><span>&lt;</span><span>PhysicsRayQueryParameters2D</span><span>&gt;</span> <span>&amp;</span><span>p_ray_query</span><span>)</span> <span>{</span>
    <span>ERR_FAIL_COND_V</span><span>(</span><span>!</span><span>p_ray_query</span><span>.</span><span>is_valid</span><span>(),</span> <span>Dictionary</span><span>());</span>

    <span>RayResult</span> <span>result</span><span>;</span>
    <span>bool</span> <span>res</span> <span>=</span> <span>intersect_ray</span><span>(</span><span>p_ray_query</span><span>-&gt;</span><span>get_parameters</span><span>(),</span> <span>result</span><span>);</span>

    <span>if</span> <span>(</span><span>!</span><span>res</span><span>)</span> <span>{</span>
        <span>return</span> <span>Dictionary</span><span>();</span>
    <span>}</span>

    <span>Dictionary</span> <span>d</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;position&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>position</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;normal&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>normal</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;collider_id&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>collider_id</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;collider&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>collider</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;shape&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>shape</span><span>;</span>
    <span>d</span><span>[</span><span>&#34;rid&#34;</span><span>]</span> <span>=</span> <span>result</span><span>.</span><span>rid</span><span>;</span>

    <span>return</span> <span>d</span><span>;</span>
<span>}</span>

<span>// This is the params struct that the inernal intersect_ray takes in.</span>
<span>// Nothing too crazy here (although exclude could probably be improved).</span>
<span>struct</span> <span>RayParameters</span> <span>{</span>
    <span>Vector2</span> <span>from</span><span>;</span>
    <span>Vector2</span> <span>to</span><span>;</span>
    <span>HashSet</span><span>&lt;</span><span>RID</span><span>&gt;</span> <span>exclude</span><span>;</span>
    <span>uint32_t</span> <span>collision_mask</span> <span>=</span> <span>UINT32_MAX</span><span>;</span>
    <span>bool</span> <span>collide_with_bodies</span> <span>=</span> <span>true</span><span>;</span>
    <span>bool</span> <span>collide_with_areas</span> <span>=</span> <span>false</span><span>;</span>
    <span>bool</span> <span>hit_from_inside</span> <span>=</span> <span>false</span><span>;</span>
<span>};</span>

<span>// And this is the output. A perfectly reasonable return value for a raycast.</span>
<span>struct</span> <span>RayResult</span> <span>{</span>
    <span>Vector2</span> <span>position</span><span>;</span>
    <span>Vector2</span> <span>normal</span><span>;</span>
    <span>RID</span> <span>rid</span><span>;</span>
    <span>ObjectID</span> <span>collider_id</span><span>;</span>
    <span>Object</span> <span>*</span><span>collider</span> <span>=</span> <span>nullptr</span><span>;</span>
    <span>int</span> <span>shape</span> <span>=</span> <span>0</span><span>;</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>As we can see, this is wrapping some perfectly reasonable raycast function in ungodly slow craziness. That internal <code>intersect_ray</code> is the function that should be in the API!</p><p>This C++ code allocates an untyped dictionary on the unmanaged heap. If we dig down into this dictionary, we find a hashmap as expected. It performs six hashmap lookups to initialize this dictionary (some of them may even do additional allocations, but I haven’t dug that deep). But wait, this is an untyped dictionary. How does that work? Well the internal hashmap maps <code>Variant</code> to <code>Variant</code>.</p><p>Sigh. What’s a <code>Variant</code>? Well the implementation is <a href="https://github.com/godotengine/godot/blob/master/core/variant/variant.cpp">quite complicated</a>, but in simple terms it’s a big tagged union type encompassing all possible types the dictionary can hold. We can think of it as being the dynamic untyped type. What we care about is its size, which is 20 bytes.</p><p>Okay, so each of those “fields” we’ve written into the dictionary is now 20 bytes large. Oh, and so are the keys. Those 8 byte <code>Vector2</code> values? 20 bytes each now. That <code>int</code>? 20 bytes. You get the picture.</p><p>If we sum the sizes of the fields in <code>RayResult</code>, we’re looking at 44 bytes (assuming 8 byte pointers). If we sum the sizes of the <code>Variant</code> keys and values of the dictionary, that’s 2 * 6 * 20 = 240 bytes! But wait, it’s a hashmap. Hashmaps don’t store their data compactly, so the true size of that dictionary on the heap is at least 6x larger than the data we want to return, probably much more.</p><p>Okay, let’s go back to C# and see what happens when we return this thing.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td><pre><span>// The function we&#39;re calling.</span>
<span>public</span> <span>Dictionary</span> <span>IntersectRay</span><span>(</span><span>PhysicsRayQueryParameters2D</span> <span>parameters</span><span>)</span>
<span>{</span>
    <span>return</span> <span>NativeCalls</span><span>.</span><span>godot_icall_1_729</span><span>(</span><span>MethodBind1</span><span>,</span> <span>GodotObject</span><span>.</span><span>GetPtr</span><span>(</span><span>this</span><span>),</span> <span>GodotObject</span><span>.</span><span>GetPtr</span><span>(</span><span>parameters</span><span>));</span>
<span>}</span>

<span>internal</span> <span>unsafe</span> <span>static</span> <span>Dictionary</span> <span>godot_icall_1_729</span><span>(</span><span>IntPtr</span> <span>method</span><span>,</span> <span>IntPtr</span> <span>ptr</span><span>,</span> <span>IntPtr</span> <span>arg1</span><span>)</span>
<span>{</span>
    <span>godot_dictionary</span> <span>nativeValueToOwn</span> <span>=</span> <span>default</span><span>(</span><span>godot_dictionary</span><span>);</span>
    <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>throw</span> <span>new</span> <span>ArgumentNullException</span><span>(</span><span>&#34;ptr&#34;</span><span>);</span>

    <span>void</span><span>**</span> <span>intPtr</span> <span>=</span> <span>stackalloc</span> <span>void</span><span>*[</span><span>1</span><span>];</span>
    <span>*</span><span>intPtr</span> <span>=</span> <span>&amp;</span><span>arg1</span><span>;</span>
    <span>void</span><span>**</span> <span>p_args</span> <span>=</span> <span>intPtr</span><span>;</span>
    <span>NativeFuncs</span><span>.</span><span>godotsharp_method_bind_ptrcall</span><span>(</span><span>method</span><span>,</span> <span>ptr</span><span>,</span> <span>p_args</span><span>,</span> <span>&amp;</span><span>nativeValueToOwn</span><span>);</span>
    <span>return</span> <span>Dictionary</span><span>.</span><span>CreateTakingOwnershipOfDisposableValue</span><span>(</span><span>nativeValueToOwn</span><span>);</span>
<span>}</span>

<span>internal</span> <span>static</span> <span>Dictionary</span> <span>CreateTakingOwnershipOfDisposableValue</span><span>(</span><span>godot_dictionary</span> <span>nativeValueToOwn</span><span>)</span>
<span>{</span>
    <span>return</span> <span>new</span> <span>Dictionary</span><span>(</span><span>nativeValueToOwn</span><span>);</span>
<span>}</span>

<span>private</span> <span>Dictionary</span><span>(</span><span>godot_dictionary</span> <span>nativeValueToOwn</span><span>)</span>
<span>{</span>
    <span>godot_dictionary</span> <span>value</span> <span>=</span> <span>(</span><span>nativeValueToOwn</span><span>.</span><span>IsAllocated</span> <span>?</span> <span>nativeValueToOwn</span> <span>:</span> <span>NativeFuncs</span><span>.</span><span>godotsharp_dictionary_new</span><span>());</span>
    <span>NativeValue</span> <span>=</span> <span>(</span><span>godot_dictionary</span><span>.</span><span>movable</span><span>)</span><span>value</span><span>;</span>
    <span>_weakReferenceToSelf</span> <span>=</span> <span>DisposablesTracker</span><span>.</span><span>RegisterDisposable</span><span>(</span><span>this</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The main things to notice here are that we’re allocating a new managed (garbage creating, yada yada) dictionary in C#, and that it holds a pointer into the one created on the heap in C++. Hey, at least we’re not copying the dictionary contents over! I’ll take wins where I can get them at this point.</p><p>Okay, so what next?</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>if</span> <span>(</span><span>hitDictionary</span><span>.</span><span>Count</span> <span>!=</span> <span>0</span><span>)</span>
<span>{</span>
    <span>// The cast from string to Variant can be implicit - I&#39;ve made it explicit here for clarity</span>
    <span>Variant</span> <span>hitPositionVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;position&#34;</span><span>];</span>
    <span>Vector2</span> <span>hitPosition</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitPositionVariant</span><span>;</span>
    <span>Variant</span> <span>hitNormalVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;normal&#34;</span><span>];</span>
    <span>Vector2</span> <span>hitNormal</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitNormalVariant</span><span>;</span>
    
    <span>distance</span> <span>=</span> <span>(</span><span>hitPosition</span> <span>-</span> <span>origin</span><span>).</span><span>Length</span><span>();</span>
    <span>normal</span> <span>=</span> <span>hitNormal</span><span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Hopefully we can all follow what’s happening here at this point.</p><p>If our ray didn’t hit anything an empty dictionary is returned, so we check for hits by checking the count.</p><p>If we hit something, for each field we want to read we:</p><ol><li>Cast <code>string</code> keys to C# <code>Variant</code> structs (This also does a call into C++)</li><li>Chase some more function pointers to call into C++ in the way we’ve come to expect by now</li><li>Perform a hashmap lookup to get the <code>Variant</code> holding our value (via function pointer chasing, of course)</li><li>Copy those 20 bytes back into C# world (yes, even though we’re reading <code>Vector2</code> values which are only 8 bytes)</li><li>Extract the <code>Vector2</code> value from the <code>Variant</code> (Yes, it also chases pointers all the way back into C++ to do this conversion)</li></ol><p>Well that’s a lot work for returning a 44 byte struct and reading a couple of fields.</p><h3 id="can-we-do-better"><span>Can we do better?</span><a href="#can-we-do-better"><i></i></a></h3><h4 id="caching-query-parameters"><span>Caching query parameters</span><a href="#caching-query-parameters"><i></i></a></h4><p>If you can remember as far back as <code>PhysicsRayQueryParameters2D</code>, we had the opportunity to avoid some allocations by caching, so let’s do that quickly.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td><pre><span>readonly</span> <span>struct</span> <span>CachingRayCaster</span>
<span>{</span>
    <span>private</span> <span>readonly</span> <span>PhysicsDirectSpaceState2D</span> <span>spaceState</span><span>;</span>
    <span>private</span> <span>readonly</span> <span>PhysicsRayQueryParameters2D</span> <span>queryParams</span><span>;</span>

    <span>public</span> <span>CachingRayCaster</span><span>(</span><span>PhysicsDirectSpaceState2D</span> <span>spaceState</span><span>)</span>
    <span>{</span>
        <span>this</span><span>.</span><span>spaceState</span> <span>=</span> <span>spaceState</span><span>;</span>
        <span>this</span><span>.</span><span>queryParams</span> <span>=</span> <span>PhysicsRayQueryParameters2D</span><span>.</span><span>Create</span><span>(</span><span>Vector2</span><span>.</span><span>Zero</span><span>,</span> <span>Vector2</span><span>.</span><span>Zero</span><span>);</span>
    <span>}</span>

    <span>public</span> <span>bool</span> <span>GetDistanceAndNormal</span><span>(</span><span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>out</span> <span>float</span> <span>distance</span><span>,</span> <span>out</span> <span>Vector2</span> <span>normal</span><span>)</span>
    <span>{</span>
        <span>Godot</span><span>.</span><span>Collections</span><span>.</span><span>Dictionary</span> <span>hitDictionary</span> <span>=</span> <span>this</span><span>.</span><span>spaceState</span><span>.</span><span>IntersectRay</span><span>(</span><span>this</span><span>.</span><span>queryParams</span><span>);</span>

        <span>if</span> <span>(</span><span>hitDictionary</span><span>.</span><span>Count</span> <span>!=</span> <span>0</span><span>)</span>
        <span>{</span>
            <span>Variant</span> <span>hitPositionVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;position&#34;</span><span>];</span>
            <span>Vector2</span> <span>hitPosition</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitPositionVariant</span><span>;</span>
            <span>Variant</span> <span>hitNormalVariant</span> <span>=</span> <span>hitDictionary</span><span>[(</span><span>Variant</span><span>)</span><span>&#34;normal&#34;</span><span>];</span>
            <span>Vector2</span> <span>hitNormal</span> <span>=</span> <span>(</span><span>Vector2</span><span>)</span><span>hitNormalVariant</span><span>;</span>
            <span>distance</span> <span>=</span> <span>(</span><span>hitPosition</span> <span>-</span> <span>origin</span><span>).</span><span>Length</span><span>();</span>
            <span>normal</span> <span>=</span> <span>hitNormal</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>distance</span> <span>=</span> <span>default</span><span>;</span>
        <span>normal</span> <span>=</span> <span>default</span><span>;</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>After the first ray, this removes 2/3rds of our per ray C#/GC allocations by count, and 632/738 of our C#/GC allocations by bytes. It’s still not a good situation, but it’s an improvement.</p><h4 id="what-about-gdextension"><span>What about GDExtension?</span><a href="#what-about-gdextension"><i></i></a></h4><p>As you may have heard, Godot also gives us a C++ (or Rust, or other native language) API to allow us to write high performance code. That will come to the rescue here, right? Right?</p><p>Well…</p><p>So it turns out GDExtension exposes the exact same API. Yeah. You can write fast C++ code, but you still only get an API that returns an untyped dictionary of bloated <code>Variant</code> values. It’s a little better because there’s no GC to worry about, but… Yeah. I recommend making another sad face right about now.</p><h4 id="a-whole-different-approach----the-raycast2d-node"><span>A whole different approach - the <code>RayCast2D</code> node</span><a href="#a-whole-different-approach----the-raycast2d-node"><i></i></a></h4><p>But wait! We can take a whole different approach.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>bool</span> <span>GetRaycastDistanceAndNormalWithNode</span><span>(</span><span>RayCast2D</span> <span>raycastNode</span><span>,</span> <span>Vector2</span> <span>origin</span><span>,</span> <span>Vector2</span> <span>direction</span><span>,</span> <span>out</span> <span>float</span> <span>distance</span><span>,</span> <span>out</span> <span>Vector2</span> <span>normal</span><span>)</span>
<span>{</span>
    <span>raycastNode</span><span>.</span><span>Position</span> <span>=</span> <span>origin</span><span>;</span>
    <span>raycastNode</span><span>.</span><span>TargetPosition</span> <span>=</span> <span>origin</span> <span>+</span> <span>direction</span><span>;</span>
    <span>raycastNode</span><span>.</span><span>ForceRaycastUpdate</span><span>();</span>

    <span>distance</span> <span>=</span> <span>(</span><span>raycastNode</span><span>.</span><span>GetCollisionPoint</span><span>()</span> <span>-</span> <span>origin</span><span>).</span><span>Length</span><span>();</span>
    <span>normal</span> <span>=</span> <span>raycastNode</span><span>.</span><span>GetCollisionNormal</span><span>();</span>
    <span>return</span> <span>raycastNode</span><span>.</span><span>IsColliding</span><span>();</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Here we have a function which takes a reference to a <code>RayCast2D</code> node in the scene. As the name suggests, this is a scene node that performs raycasts. It’s implemented in C++, and it doesn’t go through the same API with all of the dictionary overhead. This is a pretty clunky way to do raycasts as we need a reference to a node in the scene which we’re happy to mutate, and we have to reposition the node in the scene in order to do a query, but let’s take a look inside.</p><p>First we need to note that, as we’ve come to expect, each of these properties that we’re accessing does a full pointer chasing journey into C++ land.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>public</span> <span>Vector2</span> <span>Position</span>
<span>{</span>
    <span>get</span> <span>=&gt;</span> <span>GetPosition</span><span>()</span>
    <span>set</span> <span>=&gt;</span> <span>SetPosition</span><span>(</span><span>value</span><span>);</span>
<span>}</span>

<span>internal</span> <span>unsafe</span> <span>void</span> <span>SetPosition</span><span>(</span><span>Vector2</span> <span>position</span><span>)</span>
<span>{</span>
    <span>NativeCalls</span><span>.</span><span>godot_icall_1_31</span><span>(</span><span>MethodBind0</span><span>,</span> <span>GodotObject</span><span>.</span><span>GetPtr</span><span>(</span><span>this</span><span>),</span> <span>&amp;</span><span>position</span><span>);</span>
<span>}</span>

<span>internal</span> <span>unsafe</span> <span>static</span> <span>void</span> <span>godot_icall_1_31</span><span>(</span><span>IntPtr</span> <span>method</span><span>,</span> <span>IntPtr</span> <span>ptr</span><span>,</span> <span>Vector2</span><span>*</span> <span>arg1</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>IntPtr</span><span>.</span><span>Zero</span><span>)</span> <span>throw</span> <span>new</span> <span>ArgumentNullException</span><span>(</span><span>&#34;ptr&#34;</span><span>);</span>

    <span>void</span><span>**</span> <span>intPtr</span> <span>=</span> <span>stackalloc</span> <span>void</span><span>*[</span><span>1</span><span>];</span>
    <span>*</span><span>intPtr</span> <span>=</span> <span>arg1</span><span>;</span>
    <span>void</span><span>**</span> <span>p_args</span> <span>=</span> <span>intPtr</span><span>;</span>
    <span>NativeFuncs</span><span>.</span><span>godotsharp_method_bind_ptrcall</span><span>(</span><span>method</span><span>,</span> <span>ptr</span><span>,</span> <span>p_args</span><span>,</span> <span>null</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Now let’s look at what <code>ForceRaycastUpdate()</code> actually does. I’m sure you can guess the C# by now, so let’s dive straight into the C++.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td><pre><span>void</span> <span>RayCast2D</span><span>::</span><span>force_raycast_update</span><span>()</span> <span>{</span>
    <span>_update_raycast_state</span><span>();</span>
<span>}</span>

<span>void</span> <span>RayCast2D</span><span>::</span><span>_update_raycast_state</span><span>()</span> <span>{</span>
    <span>Ref</span><span>&lt;</span><span>World2D</span><span>&gt;</span> <span>w2d</span> <span>=</span> <span>get_world_2d</span><span>();</span>
    <span>ERR_FAIL_COND</span><span>(</span><span>w2d</span><span>.</span><span>is_null</span><span>());</span>

    <span>PhysicsDirectSpaceState2D</span> <span>*</span><span>dss</span> <span>=</span> <span>PhysicsServer2D</span><span>::</span><span>get_singleton</span><span>()</span><span>-&gt;</span><span>space_get_direct_state</span><span>(</span><span>w2d</span><span>-&gt;</span><span>get_space</span><span>());</span>
    <span>ERR_FAIL_NULL</span><span>(</span><span>dss</span><span>);</span>

    <span>Transform2D</span> <span>gt</span> <span>=</span> <span>get_global_transform</span><span>();</span>

    <span>Vector2</span> <span>to</span> <span>=</span> <span>target_position</span><span>;</span>
    <span>if</span> <span>(</span><span>to</span> <span>==</span> <span>Vector2</span><span>())</span> <span>{</span>
        <span>to</span> <span>=</span> <span>Vector2</span><span>(</span><span>0</span><span>,</span> <span>0.01</span><span>);</span>
    <span>}</span>

    <span>PhysicsDirectSpaceState2D</span><span>::</span><span>RayResult</span> <span>rr</span><span>;</span>
    <span>bool</span> <span>prev_collision_state</span> <span>=</span> <span>collided</span><span>;</span>

    <span>PhysicsDirectSpaceState2D</span><span>::</span><span>RayParameters</span> <span>ray_params</span><span>;</span>
    <span>ray_params</span><span>.</span><span>from</span> <span>=</span> <span>gt</span><span>.</span><span>get_origin</span><span>();</span>
    <span>ray_params</span><span>.</span><span>to</span> <span>=</span> <span>gt</span><span>.</span><span>xform</span><span>(</span><span>to</span><span>);</span>
    <span>ray_params</span><span>.</span><span>exclude</span> <span>=</span> <span>exclude</span><span>;</span>
    <span>ray_params</span><span>.</span><span>collision_mask</span> <span>=</span> <span>collision_mask</span><span>;</span>
    <span>ray_params</span><span>.</span><span>collide_with_bodies</span> <span>=</span> <span>collide_with_bodies</span><span>;</span>
    <span>ray_params</span><span>.</span><span>collide_with_areas</span> <span>=</span> <span>collide_with_areas</span><span>;</span>
    <span>ray_params</span><span>.</span><span>hit_from_inside</span> <span>=</span> <span>hit_from_inside</span><span>;</span>

    <span>if</span> <span>(</span><span>dss</span><span>-&gt;</span><span>intersect_ray</span><span>(</span><span>ray_params</span><span>,</span> <span>rr</span><span>))</span> <span>{</span>
        <span>collided</span> <span>=</span> <span>true</span><span>;</span>
        <span>against</span> <span>=</span> <span>rr</span><span>.</span><span>collider_id</span><span>;</span>
        <span>against_rid</span> <span>=</span> <span>rr</span><span>.</span><span>rid</span><span>;</span>
        <span>collision_point</span> <span>=</span> <span>rr</span><span>.</span><span>position</span><span>;</span>
        <span>collision_normal</span> <span>=</span> <span>rr</span><span>.</span><span>normal</span><span>;</span>
        <span>against_shape</span> <span>=</span> <span>rr</span><span>.</span><span>shape</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>collided</span> <span>=</span> <span>false</span><span>;</span>
        <span>against</span> <span>=</span> <span>ObjectID</span><span>();</span>
        <span>against_rid</span> <span>=</span> <span>RID</span><span>();</span>
        <span>against_shape</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>prev_collision_state</span> <span>!=</span> <span>collided</span><span>)</span> <span>{</span>
        <span>queue_redraw</span><span>();</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>It looks like there’s a lot going on here, but it’s actually quite simple. If we look carefully we can see that the structure is pretty much the same as our first <code>GetRaycastDistanceAndNormal</code> C# function. It gets the world, gets the state, builds the parameters, calls <code>intersect_ray</code> to do the actual work, then writes the result out to the properties.</p><p>But look! No heap allocations, no <code>Dictionary</code>, and no <code>Variant</code>. This is more like it! We can predict that this will be a lot faster.</p><h3 id="timing-it"><span>Timing it</span><a href="#timing-it"><i></i></a></h3><p>Okay, I’ve made a lot of allusions to all of this overhead being dramatically problematic and we can easily see that it should be, but let’s put some actual numbers to this with benchmarks.</p><p>As we’ve seen above, <code>RayCast2D.ForceRaycastUpdate()</code> is pretty close to a minimalist call to the physics engine’s <code>intersect_ray</code>, so we can use this as a baseline. Remember that even this has some overhead from the pointer chasing function call. I’ve also benchmarked each of the versions of the code we’ve discussed. Each benchmark runs 10,000 iterations of the function under test, with warmup and outlier filtering. I disabled GC collection during the tests. I like to run my game benchmarks on weaker hardware so you may get better results if you repro, but it’s the relative numbers that we care about.</p><p>Our setup is a simple scene containing a single circle collider that our ray always hits. We’re interested in measuring binding overhead, not the performance of the physics engine itself. We’re dealing with timings for individual rays measured in nanoseconds, so these numbers may look inconsequentially small. To better illustrate their significance, I also report “calls per frame” giving the number of times the functions could be called in in a single frame at 60fps and 120fps if the game did nothing but trivial raycasts.</p><div><table><thead><tr><th>Method</th><th>Time (μs)</th><th>Baseline multiple</th><th>Per frame (60fps)</th><th>Per frame (120fps)</th><th>GC alloc (bytes)</th></tr></thead><tbody><tr><td><code>ForceRaycastUpdate</code> (raw engine speed, not useful)</td><td>0.49</td><td>1.00</td><td>34,000</td><td>17,000</td><td>0</td></tr><tr><td><code>GetRaycastDistanceAndNormalWithNode</code></td><td>0.97</td><td>1.98</td><td>17,200</td><td>8,600</td><td>0</td></tr><tr><td><code>CachingRayCaster.GetDistanceAndNormal</code></td><td>7.71</td><td>15.73</td><td>2,200</td><td>1,100</td><td>96</td></tr><tr><td><code>GetRaycastDistanceAndNormal</code></td><td>24.23</td><td>49.45</td><td>688</td><td>344</td><td>728</td></tr></tbody></table></div><p>Those are some significant differences!</p><p>We might expect that the fastest way to do a raycast in a reasonable engine/API is to use the function exposed for doing exactly that, <a href="https://docs.godotengine.org/en/stable/tutorials/physics/ray-casting.html#raycast-query">which is taught as the canonical way in the documentation</a>. As we can see, if we do that, the binding/API overhead makes this 50X slower than the raw physics engine speed. Ouch!</p><p>Using that same API but being sensible (if awkward) about caching, we can get that down to only 16X overhead. This is better, but still awful.</p><p>If our aim here is to get practical performance, we have to sidestep the proper/canonical/advertised API completely, and instead clunkily manipulate scene objects to exploit them to do our query for us. In a sensible world moving objects around in the scene and asking them to do raycasts for us would be slower than calling the raw physics API, but in fact it’s 8X faster.</p><p>Even the node approach is 2X slower than the raw speed of the engine (which we’re actually underestimating). This means that half of the time in that function is being spent on setting two properties and reading three properties. The binding overhead is large enough that five property accesses takes as long as a raycast. Let that sink in. <em>Let’s not even think about the fact that in the real world we may well want to set and read even more properties, such as setting the layer mask and reading the hit collider</em>.</p><p>At the lower end, those numbers are actually very limiting. My current project needs more than 344 raycasts per frame, and of course it does a lot more than just raycasting. This test is a trivial scene with a single collider, if we were making the raycast do actual work in a more complex scene these numbers would be even lower! The documentation’s standard way of doing raycasts would grind my whole game to a halt.</p><p>We also can’t forget about the garbage creating allocations that happen in C#. I usually write games with a zero garbage per frame policy.</p><p><em>Just for fun, I also benchmarked Unity. It does a full useful raycast, with parameter setting and result retrieval, in about 0.52μs. Before Godot’s binding overhead, the core physics engines have comparable speed.</em></p><h2 id="have-i-cherrypicked"><span>Have I cherrypicked?</span><a href="#have-i-cherrypicked"><i></i></a></h2><p>When I posted the reddit thread, a number of people said that the physics API is uniquely bad and that it isn’t representative of the whole engine. I certainly didn’t intentionally cherrypick it - it just so happens that raycasting was the very first thing I attempted when checking out Godot. However, perhaps I’m being a little unfair, so let’s examine that.</p><p>If I had wanted to cherrypick a worse method, I wouldn’t have had to look far. Right next to <code>IntersectRay</code> are <code>IntersectPoint</code> and <code>IntersectShape</code>, both of which share all of the same problems as <code>IntersectRay</code> with the additional craziness that they can have multiple results, so they return a heap allocated managed <code>Godot.Collections.Array&lt;Dictionary&gt;</code>! Oh by the way, that <code>Array&lt;T&gt;</code> is actually a typed wrapper around <code>Godot.Collections.Array</code>, so every 8 byte reference to a dictionary is actually stored as a 20 byte <code>Variant</code>. Clearly I haven’t picked the very worst method in the API!</p><p>If we scan the whole Godot API (via C# reflection) we luckily find that there aren’t that many things which return <code>Dictionary</code>. There’s an eclectic list including the <code>AnimationNode._GetChildNodes</code> method, the <code>Bitmap.Data</code> property, the <code>Curve2D._Data</code> property (and 3D), some things in <code>GLTFSkin</code>, some <code>TextServer</code> stuff, some <code>NavigationAgent2D</code> pieces, etc. None of those are great places to have slow heap allocated dictionaries, but none of them are as bad as the physics API.</p><p>However, in my experience, very few engine APIs get as much use as physics. If I look at the engine API calls in my gameplay code, they’re probably 80% physics and transforms.</p><p>Let’s also remember that <code>Dictionary</code> is only part of the problem. If we look a little wider for things returning <code>Godot.Collections.Array&lt;T&gt;</code> (remember: heap allocated, contents as <code>Variant</code>) we find lots from physics, mesh &amp; geometry manipulation, navigation, tilemaps, rendering, and more.</p><p>Physics may be a particularly bad (but essential) area of the API, but the heap allocated type problems, as well as the general slowness of the pointer chasing, are deeply rooted throughout.</p><h2 id="so-why-are-we-waiting-for-godot"><span>So why are we waiting for Godot?</span><a href="#so-why-are-we-waiting-for-godot"><i></i></a></h2><p>Godot’s primary scripting language is GDScript, a dynamically typed interpreted language where almost all non primitives are heap allocated, i.e. it doesn’t have a struct analogue. That sentence should have set off a cacophony of performance alarms in your head. I’ll give you a moment for your ears to stop ringing.</p><p>If we look at how Godot’s C++ core exposes its API we’ll see something interesting.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>void</span> <span>PhysicsDirectSpaceState3D</span><span>::</span><span>_bind_methods</span><span>()</span> <span>{</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;intersect_point&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>,</span> <span>&#34;max_results&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_intersect_point</span><span>,</span> <span>DEFVAL</span><span>(</span><span>32</span><span>));</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;intersect_ray&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_intersect_ray</span><span>);</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;intersect_shape&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>,</span> <span>&#34;max_results&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_intersect_shape</span><span>,</span> <span>DEFVAL</span><span>(</span><span>32</span><span>));</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;cast_motion&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_cast_motion</span><span>);</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;collide_shape&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>,</span> <span>&#34;max_results&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_collide_shape</span><span>,</span> <span>DEFVAL</span><span>(</span><span>32</span><span>));</span>
    <span>ClassDB</span><span>::</span><span>bind_method</span><span>(</span><span>D_METHOD</span><span>(</span><span>&#34;get_rest_info&#34;</span><span>,</span> <span>&#34;parameters&#34;</span><span>),</span> <span>&amp;</span><span>PhysicsDirectSpaceState3D</span><span>::</span><span>_get_rest_info</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>This one shared mechanism is used to generate the bindings for all three scripting interfaces; GDSCript, C#, and GDExtensions. <code>ClassDB</code> collects function pointers and metadata about each of the API functions, which is then piped through various code generation systems to create the bindings for each language.</p><p>This means that every API function is designed primarily to serve the limitations of GDScript. <code>IntersectRay</code> returns an untyped dynamic <code>Dictionary</code> because GDScript doesn’t have structs. Our C# and even our GDExtensions C++ code has to pay the catastrophic price for that.</p><p>This way of handling binding via function pointers also leads to significant overhead, as we’ve seen from simple property accesses being slow. Remember, each call first does a memory lookup to find the function pointer it wants to call, then it does another lookup to find the function pointer of a secondary function which is actually responsible for calling the function, then it calls the secondary function passing it the pointer to the primary function. All along that journey there’s extra validation code, branching, and type conversions. C# (and obviously C++) has a fast mechanism for calling into native code via P/Invoke, but Godot simply doesn’t use it.</p><p><strong>Godot has made a philosophical decision to be slow.</strong> The only practical way to interact with the engine is via this binding layer, and its core design prevents it from ever being fast. No amount of optimising the implementation of <code>Dictionary</code> or speeding up the physics engine is going to get around the fact we’re passing large heap allocated values around when we should be dealing with tiny structs. While C# and GDScript APIs remain synchronised, this will always hold the engine back.</p><h2 id="okay-lets-fix-it-then"><span>Okay, let’s fix it then!</span><a href="#okay-lets-fix-it-then"><i></i></a></h2><h3 id="what-can-we-do-without-deviating-from-the-existing-binding-layer"><span>What can we do without deviating from the existing binding layer?</span><a href="#what-can-we-do-without-deviating-from-the-existing-binding-layer"><i></i></a></h3><p>If we assume that we still need to keep all of our APIs GDScript compatible, there are a few areas where we can probably improve things, although it won’t be pretty. Let’s go back to our <code>IntsersectRay</code> example.</p><ul><li><code>GetWorld2D().DirectStateSpace</code> could be compressed to one call instead of two by introducing <code>GetWorld2DStateSpace()</code>.</li><li>The <code>PhysicsRayQueryParameters2D</code> issues could be removed by adding an overload which takes all of the fields as parameters. This would bring us roughly inline with the <code>CachedRayCaster</code> performance (16X baseline) without having to do caching.</li><li>The <code>Dictionary</code> allocation could be removed by allowing us to pass in a cached/pooled dictionary to write into. This is ugly and clumsy compared to a struct, but it would remove the allocation.</li><li>The dictionary lookup process is still ridiculously slow. We might be able to improve on that by instead returning a class with the expected properties. The allocation here could be eliminated with the cached/pooled approach the same way it could with <code>Dictionary</code>.</li></ul><p>These options aren’t pretty or ergonomic for the user, but if we’re in the business of doing ugly patches to get things running, they would probably work. This would fix the allocations but we’d still probably only be about 4X the baseline because of all of the pointer chasing across the boundary and managing of cached values.</p><p>It may also be possible to improve the generated code for all of the pointer chasing shenanigans. I haven’t studied this in detail yet, but if there are wins to find there then they’d apply to the whole API across the board, which would be cool! We could probably at least get away with removing the validation and the <code>try</code> <code>finally</code> in release builds.</p><h3 id="what-if-were-allowed-to-add-additional-apis-for-c-and-gdextensions-which-arent-gdscript-compatible"><span>What if we’re allowed to add additional APIs for C# and GDExtensions which aren’t GDScript compatible?</span><a href="#what-if-were-allowed-to-add-additional-apis-for-c-and-gdextensions-which-arent-gdscript-compatible"><i></i></a></h3><p>Now we’re talking! If we open up this possibility* then in theory we could augment the <code>ClassDB</code> bindings with better ones that deal directly in structs and go through the proper P/Invoke mechanisms. This is the path to viable performance.</p><p>Unfortunately, duplicating the entire API with better versions like this would create quite a mess. There might be ways through this by marking things <code>[Deprecated]</code> and trying to guide the user in the right direction, but issues such as naming clashes would get ugly.</p><p>* Maybe this is already possible, but I haven’t found it yet. Let me know!</p><h3 id="what-if-we-tear-it-all-down-and-start-again"><span>What if we tear it all down and start again?</span><a href="#what-if-we-tear-it-all-down-and-start-again"><i></i></a></h3><p>This option obviously has a lot of short term pain. Godot 4.0 has only recently happened, and now I’m talking about a backcompat breaking complete API redux like a Godot 5.0. However, if I’m honest with myself, I see this as the only viable path to the engine being in a good place in three years time. Mixing fast and slow APIs as discussed above would leave us with headaches for decades - a trap I expect the engine will probably fall into.</p><p><del>In my opinion, if Godot were to go down this route, GDScript should probably be dropped entirely. I don’t really see the point of it when C# exists, and supporting it causes so much hassle. I’m clearly completely at odds with the lead Godot devs and the project philosophy on this point, so I have no expectation that this will happen. Who knows though - Unity eventually dropped UnityScript for full C#, maybe Godot will one day take the same step. Foreshadowing?</del></p><p>Edit: I’m taking the above out for now. I don’t personally care about GDScript, but other people do and I don’t want to take it away from them. I have no objection to C# and GDScript sitting beside each other with different APIs each optimised for the respective language’s needs.</p><h2 id="was-the-title-of-this-article-melodramatic-clickbait"><span>Was the title of this article melodramatic clickbait?</span><a href="#was-the-title-of-this-article-melodramatic-clickbait"><i></i></a></h2><p>Maybe a little. Not a lot.</p><p>There will be people who were making games in Unity who can make those same games in Godot without these issues mattering too much. Godot may be able to capture the lower end of Unity’s market. However, Unity’s recent focus on performance is a good indicator that there’s demand for it. I know that I certainly care about it. Godot’s performance is not just worse than Unity’s, it’s dramatically and systematically worse.</p><p>In some projects 95% of the CPU load is in an algorithm which never touches the engine APIs. In that case, none of this matters. (The GC always matters, but we can use GDExtensions to avoid that.) For many others, good programmatic interaction with physics/collisions and manually modifying the properties of large numbers of objects are essential to the project.</p><p>For many others, it’s important to know that they can do these things if they need to. Maybe you get two years into your project thinking it will barely need raycasts at all, then you make a late game decision to add some custom CPU particles that need to be able to check collisions. It’s a small aesthetic change, but suddenly you need an engine API and you’re in trouble. There’s a lot of talk right now about the importance of being able to trust that your engine will have your back in the future. Unity has that problem with their scummy business practices, Godot has that problem with performance.</p><p>If Godot wants to be able to capture the general Unity market (I don’t actually know that it does want that) it will need to make some rapid and fundamental changes. Many of the things discussed in this article will simply not be acceptable to Unity devs.</p><h2 id="discussion"><span>Discussion</span><a href="#discussion"><i></i></a></h2><p>I <a href="https://old.reddit.com/r/godot/comments/16lti15/godot_is_not_the_new_unity_the_anatomy_of_a_godot/">posted this article on the r/Godot subreddit</a> and there’s quite an active discussion there. If you’ve arrived here from somewhere else and would like to give feedback or be pseudonymously rude to me on the internet, that’s the place to do it.</p><h2 id="acknowledgements"><span>Acknowledgements</span><a href="#acknowledgements"><i></i></a></h2><ul><li>_Mario_Boss on reddit for being the first to bring my attention to the <code>Raycast2D</code> node trick.</li><li>John Riccitiello, for finally giving me a reason to do more research on other engines.</li><li>Mike Bithell, for letting me steal his foreshadowing joke. I didn’t actually ask permission, but he seems too nice to find me and hit me.</li><li>Freya Holmér, because nothing has kept me more entertained while writing this than seeing her complaining about Unreal doing physics in centimetres, and waiting until the moment she shares my horror upon discovering Godot has units like <code>kg pixels^2</code>.</li><li>Clainkey on reddit for pointing out that I mistakenly had nanoseconds where I should have had microseconds.</li></ul></div></div>
  </body>
</html>
