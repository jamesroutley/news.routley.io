<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianyepan.github.io/posts/emacs-ide/">Original</a>
    <h1>Building an Intelligent Emacs</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote><p>This post introduces the combination of Emacs and LSP, and how you can make your own editor “smarter” by using the same idea of communications between an editor client and multiple language servers.</p></blockquote><h2 id="background">Background</h2><p>When compared with modern editors and IDEs (such as IntelliJ IDEA, PyCharm, and Visual Studio Code), old-school editors like Emacs or Vim fail to provide intelligent actions such as “auto-complete (Intellisense)”, “go to definition/references”, and “on-the-fly error checking” <strong>out-of-the-box</strong>. After all, this requires a deep understanding of both the programming language and the code, which is the main reason why IDEs are created in the first place.</p><h2 id="language-server-protocol-lsp">Language Server Protocol (LSP)</h2><p>That said, everything changed when Microsoft released its development of the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>. In short, LSP decouples the tooling into servers and clients, with the former powering all the intelligent activities, and the latter being integrated into any development tool of your choice. If you’d like to read more about the inner workings, consider <a href="https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/">this post</a>.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/images/emacs-ide1.png" alt="Emacs1" width="90%"/> <em>Emacs showing language-aware auto-completion powered by the clangd language server. Company and company-box are used to provide the auto-completion UI.</em></p><p>All of a sudden, as long as you have a client in your editor that can communicate with the language servers, which are separately downloaded, any tool can become as intelligent and feature-rich as the popular IDEs and smart editors. In other words, if my “primitive” editor has a thin layer of a client that can communicate with, say, the Java language server of the Eclipse IDE, my editor can obtain all the smart features that are exposed by the server and instantly be on par with Eclipse. Similarly, if I install the same language server that powers the sweet code actions for TypeScript/JavaScript in VSCode and hooks it to my editor’s client, I wouldn’t lose anything by not using VSCode.</p><h2 id="clients-for-lsp">Clients for LSP</h2><p>In the Vim/Neovim world, the main players are <a href="https://github.com/neoclide/coc.nvim">CoC</a> and the <a href="https://github.com/neovim/nvim-lspconfig">native LSP client</a> of Neovim. In the Emacs community, the equivalent would be <a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> and <a href="https://github.com/joaotavora/eglot">eglot</a>. As an Emacs user, I have tried out both lsp-mode and eglot, and found the former more configurable, feature-rich, and easy to wrap my head about. In the rest of this post, I will be using lsp-mode as my client to demonstrate the configurations of making Emacs an intelligent editor.</p><p>To install lsp-mode from MELPA for Emacs, you can use the following use-package declaration. If you need help setting up use-package, I also <a href="https://ianyepan.github.io/posts/setting-up-use-package">wrote a post</a> on this topic.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-mode</span>
  <span>:hook</span> <span>((</span><span>X-mode</span> <span>Y-mode</span> <span>Z-mode</span><span>)</span> <span>.</span> <span>lsp-deferred</span><span>)</span> <span>; XYZ are to be replaced by python, c++, etc.</span>
  <span>:commands</span> <span>lsp</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>If we want to enable LSP for C++, Python, Java, and JavaScript, we would write:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-mode</span>
  <span>:hook</span> <span>((</span><span>c++-mode</span> <span>python-mode</span> <span>java-mode</span> <span>js-mode</span><span>)</span> <span>.</span> <span>lsp-deferred</span><span>)</span>
  <span>:commands</span> <span>lsp</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>To enable extra information on the sideline (fixes, suggestions, documentation), lsp-mode has an extra companion package called lsp-ui. To enable it, simply do:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-ui</span>
  <span>:commands</span> <span>lsp-ui-mode</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>I’ve tweaked some settings to enable features that are not set by default, and disabled those that I don’t find helpful:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-ui</span>
  <span>:commands</span> <span>lsp-ui-mode</span>
  <span>:config</span>
  <span>(</span><span>setq</span> <span>lsp-ui-doc-enable</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-ui-doc-header</span> <span>t</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-ui-doc-include-signature</span> <span>t</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-ui-doc-border</span> <span>(</span><span>face-foreground</span> <span>&#39;default</span><span>))</span>
  <span>(</span><span>setq</span> <span>lsp-ui-sideline-show-code-actions</span> <span>t</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-ui-sideline-delay</span> <span>0.05</span><span>))</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="servers-for-lsp">Servers for LSP</h2><p>Now that we have the client installed and initialized, we need to provide Emacs with the respective language servers so lsp-mode can pick up the channels of communication. We’ll continue to use C++, Python, Java, and JavaScript as examples since they seem to be the most popular languages.</p><h3 id="setting-up-c">Setting up C++</h3><p>By default, lsp-mode will look for the “clangd” executable on the path. “Clangd” is a language server developed by LLVM (which also develops the clang compilers) and can be downloaded with <code>brew install llvm</code> on macOS, or <code>pacman -S clang</code> on Arch.</p><p>Clangd is my choice of language server for both C and C++. If for some reason you don’t like LLVM’s implementation, you can try out <a href="https://github.com/MaskRay/ccls">ccls</a>, an alternative language server for C/C++/ObjC. For lsp-mode to prioritize ccls over clangd, you need to install and set up <a href="https://github.com/emacs-lsp/emacs-ccls">this extra client</a> that leverages lsp-mode.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/images/emacs-ide2.png" alt="Emacs2" width="90%"/> <em>Emacs detecting typos and suggesting fixes, powered by LSP.</em></p><h3 id="setting-up-python">Setting up Python</h3><p>LSP-mode supports 5 different Python language servers, namely <a href="https://github.com/python-lsp/python-lsp-server">Spyder IDE’s python-lsp-server</a>, the <a href="https://github.com/pappasam/jedi-language-server">Jedi language server</a>, <a href="https://github.com/palantir/python-language-server">Palantir’s pyls</a>, <a href="https://github.com/microsoft/pyright">Microsoft’s Pyright language server</a>, and <a href="https://github.com/Microsoft/python-language-server">Microsoft’s Python language server</a>.</p><p>Pyright is my choice of language server for Python. I’ve heard good things about Sypder IDE’s server but I have yet to try it.</p><p>You can install pyright globally with <code>pip</code>, <code>npm</code>, or your system’s package manager. For instance, <code>pacman -S pyright</code>.</p><p>We will need a thin layer of extra client, <a href="https://emacs-lsp.github.io/lsp-pyright/">lsp-pyright</a>, to sit atop lsp-mode and leverage pyright’s features. The following is the snippet to automatically download the client and set it up. Note that I am using the command <code>python3</code> as the executable command, in case both Python 2 and 3 are installed on the system.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-pyright</span>
  <span>:hook</span> <span>(</span><span>python-mode</span> <span>.</span> <span>(</span><span>lambda</span> <span>()</span> <span>(</span><span>require</span> <span>&#39;lsp-pyright</span><span>)))</span>
  <span>:init</span> <span>(</span><span>when</span> <span>(</span><span>executable-find</span> <span>&#34;python3&#34;</span><span>)</span>
          <span>(</span><span>setq</span> <span>lsp-pyright-python-executable-cmd</span> <span>&#34;python3&#34;</span><span>)))</span>
</pre></td></tr></tbody></table></code></p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/images/emacs-ide3.png" alt="Emacs3" width="90%"/> <em>Fuzzy match auto-completion in Emacs, powered by lsp-pyright.</em></p><h3 id="setting-up-java">Setting up Java</h3><p>The go-to language server for Java is <a href="https://projects.eclipse.org/projects/eclipse.jdt.ls">Eclipse’s JDT Language Server</a>. We need yet another thin layer of a client called <a href="https://emacs-lsp.github.io/lsp-java/">lsp-java</a> to help leverage lsp-mode and the JDT server. The good news is once you have lsp-java installed in Emacs through use-package, the client will “automatically detect whether the server is missing and download Eclipse JDT Language Server before the first startup”!</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-java</span>
  <span>:after</span> <span>lsp</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="setting-up-javascript">Setting up JavaScript</h3><p>Finally, let’s set up JavaScript for development in Emacs. The recommended language server for JavaScript (and TypeScript) is the conveniently-named <a href="https://github.com/typescript-language-server/typescript-language-server">typescript-language-server</a> (or ts-ls for short), which is a wrapper around Visual Studio Code’s tsserver.</p><p>Since lsp-mode has ts-ls support integrated by default, there’s no need to install an additional thin layer of client on top of lsp-mode. However, we do need to install the language server on our system. We can install it globally with <code>npm</code>:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>npm install -g typescript-language-server
</pre></td></tr></tbody></table></code></p></div><p>In my opinion, lsp-mode aggressively enables too many features by default, which may result in visual clutter and a slow-down in performance. The following is some of my extra configuration for the lsp-mode client. Whenever you see a pattern of <code>(setq ... nil)</code>, it means I’m disabling that feature. Towards the bottom of the list, I am also bumping up the chunk-processing threshold to allow for a smoother Emacs experience.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td><pre><span>(</span><span>use-package</span> <span>lsp-mode</span>
  <span>:hook</span> <span>((</span><span>c-mode</span>          <span>; clangd</span>
          <span>c++-mode</span>        <span>; clangd</span>
          <span>c-or-c++-mode</span>   <span>; clangd</span>
          <span>java-mode</span>       <span>; eclipse-jdtls</span>
          <span>js-mode</span>         <span>; ts-ls (tsserver wrapper)</span>
          <span>js-jsx-mode</span>     <span>; ts-ls (tsserver wrapper)</span>
          <span>typescript-mode</span> <span>; ts-ls (tsserver wrapper)</span>
          <span>python-mode</span>     <span>; pyright</span>
          <span>web-mode</span>        <span>; ts-ls/HTML/CSS</span>
          <span>haskell-mode</span>    <span>; haskell-language-server</span>
          <span>)</span> <span>.</span> <span>lsp-deferred</span><span>)</span>
  <span>:commands</span> <span>lsp</span>
  <span>:config</span>
  <span>(</span><span>setq</span> <span>lsp-auto-guess-root</span> <span>t</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-log-io</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-restart</span> <span>&#39;auto-restart</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-enable-symbol-highlighting</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-enable-on-type-formatting</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-signature-auto-activate</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-signature-render-documentation</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-eldoc-hook</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-modeline-code-actions-enable</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-modeline-diagnostics-enable</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-headerline-breadcrumb-enable</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-semantic-tokens-enable</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-enable-folding</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-enable-imenu</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>lsp-enable-snippet</span> <span>nil</span><span>)</span>
  <span>(</span><span>setq</span> <span>read-process-output-max</span> <span>(</span><span>*</span> <span>1024</span> <span>1024</span><span>))</span> <span>;; 1MB</span>
  <span>(</span><span>setq</span> <span>lsp-idle-delay</span> <span>0.5</span><span>))</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="conclusion">Conclusion</h2><p>Hopefully, this post gives you a good head-start in making Emacs a modern and intelligent IDE. I enjoy the experience of fine-tuning my development environment, even down to hand-picking my own back-end for editor behaviors. I find it extremely satisfying to be putting these pieces together and eventually see them work, as if I’m developing a unique editor configuration that is different from any tool other people use. Of course, this “hobby” isn’t for everybody and if you prefer an out-of-the-box experience to be able to jump straight into the work, then feel free to use any IDE that suits your liking.</p><p>Either way, I’m glad you stumbled upon my post. That’s all for today, cheers!</p></div></div>
  </body>
</html>
