<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pngquant.org/rust.html">Original</a>
    <h1>Rewriting Libimagequant in Rust for Portability</h1>
    
    <div id="readability-page-1" class="page">
<p><a href="https://github.com/ImageOptim/libimagequant">libimagequant</a> is a library for generating high-quality palettes, useful for compression of <a href="https://pngquant.org/">transparent PNG images</a> (~75% smaller!) and making <a href="https://gif.ski">nice GIF animations</a>.</p>

<p>libimagequant is now a pure Rust library. The new version is a drop-in replacement (ABI-compatible), so C projects can continue using it. The C version will be supported for a while to give library users and distros time to switch.</p>

<h2>Why?</h2>

<p>In short: There&#39;s no standard for <em>building</em> C programs. It&#39;s a non-portable mess, and a time sink. Cross-compilation of OpenMP was the last straw. Rust/Cargo is much more dependable, and enables me to support more features on more platforms.</p>

<p>I didn&#39;t plan to rewrite the library yet. The <a href="https://github.com/ImageOptim/libimagequant/tree/2.x">C codebase</a> is stable and gets the job done. However, I&#39;ve switched to an M1 Mac, and this made x86-64 a cross-compilation target for me. Building of redistributable executables with OpenMP was already an annoyance, but cross-compilation added a whole another level of brokenness to deal with. It felt silly to get a new fast CPU only to emulate an old one, or rely on someone else&#39;s CPU in the cloud instead. Over the holiday break I tested whether it would be easier to rewrite the library in Rust instead, and indeed it was.</p>

<h3>Why not just drop multi-threading, or OpenMP?</h3>

<p>That&#39;s what I used to do: OpenMP was optional, but being limited to 1/8th or 1/16th of a CPU sucked. I use libimagequant in <a href="https://gif.ski">gif.ski</a>, which for sad GIFfy reasons is CPU-intensive, with quantization is in its hot path, so it really matters.</p>

<p>OpenMP was actually quite nice for basic <code>for</code> loops â€” when it worked. Unfortunately, OpenMP is not a library, but a compiler extension, so it&#39;s at mercy of built-in compiler support. It can be outdated, incomplete, or completely absent.</p>

<p>I could have kept the library in C and replaced OpenMP with some other solution instead, but I wasn&#39;t keen on reinventing this wheel. Even basic things like spawning a thread run into C&#39;s portability woes. The platonic ideal portable C exists only as a hypothetical construct in the C standard. The C that exists in the real world is whatever Microsoft, Apple, and others have shipped. <em>That</em> C is a mess of vendor-specific toolchains, each with its own way of doing things, missing features, broken headers, and leaky abstractions. Shouting &#34;it&#39;s not C&#39;s fault, screw &lt;insert vendor name&gt;!&#34; doesn&#39;t solve the problem, but switching to <a href="https://www.rust-lang.org">Rust</a> does.</p>

<h2>How?</h2>

<p>Some parts were simply rewritten from scratch. Some parts were converted with <a href="https://gitlab.com/citrus-rs/citrus">Citrus</a>, which is my C-to-Rust &#34;transpiler&#34;. Unlike <a href="https://c2rust.com/">c2rust</a>, it&#39;s not semantically accurate, but it generates readable Rust source code that is easier to clean up. I did the first quick&#39;n&#39;dirty (but fully functional) conversion at a rate of about 1000 lines per day. Later rewriting, refactoring and polishing took the average down to under 200 lines per day. <code>rust-analyzer</code>, <code>cargo clippy</code>, and <code>cargo fix</code> have been very helpful.</p>

<h2>Results</h2>

<p>I&#39;m quite happy with the result. 3425 lines of mostly C have been replaced with <a href="https://github.com/ImageOptim/libimagequant/tree/main/src">3413 lines of Rust</a>. The new version exports the same ABI, so for C programs and FFI users (Python, Java, etc.) it&#39;s a drop-in replacement. The new code uses the same algorithm, but there are minor differences from adaptation to Rust&#39;s idioms.</p>

<p>It&#39;s a coincidence that the number of lines ended up being so close, because different parts of code translated to significantly different amount of lines. For example, I was able to delete pngquant&#39;s entire DIY hash table implementation, and use one from Rust&#39;s standard library instead. OTOH I&#39;ve written an abstraction for iterating over images, which has replaced a few lines of pointer arithmetic with a bunch of objects, methods, and interfaces.</p>

<h3>Executable size</h3>

<p>The Rust executable statically links with the Rust&#39;s standard library (unlike C executables that usually use OS&#39;s libc) and this costs ~260KB of executable size. I&#39;m not happy about this, but fortunately it&#39;s only a one-time cost that doesn&#39;t grow with code size. Rust&#39;s standard library <a href="https://os.phil-opp.com/freestanding-rust-binary/">can be disabled</a>, so I have an option of trimming it down if necessary, but I&#39;m not <em>that</em> bothered by it.</p>

<p>I&#39;ve compared sizes of executables (aarch64, with LTO, panic=abort, and stripped). Apart from the libstd overhead, byte size of the single-threaded Rust version of the library has grown by about 11% compared to the C version without OpenMP. Rust version using <code>rayon</code> was actually <em>4% smaller</em> than with OpenMP linked statically. I&#39;ve liberally used high-level Rust abstractions, generic libstd containers, and a few dependencies, so I&#39;m very happy that the Rust version turned out to be reasonably small. <a href="https://lib.rs/crates/rayon"><code>rayon</code></a> is a substantial library with thread pools, work-stealing queues, parallel iterators, and many generic interfaces. It being smaller than the &#34;compiler-native&#34; OpenMP was a nice surprise too.</p>

<h3>Performance</h3>

<p>Performance of the Rust version is similar, with a couple of things noticeably <em>faster</em>:</p>

<ul>
<li><p>The hash table implementation in Rust&#39;s standard library uses <a href="https://github.com/rust-lang/hashbrown#readme">a state-of-the art algorithm</a>, and my C didn&#39;t. In theory, nothing stopped me from using the same algorithm in C. In practice, lack of a useful standard library, lack of templates/generics, and the dreadful state of C dependency management did.</p></li>
<li><p>The median cut algorithm used to represent ranges as <code>int start, length;</code> and indexed with them into a shared array. Equivalent int-indexing code in Rust had similar performance. However, when I changed them to <code>&amp;mut []</code> slices, it got a speed boost! Could it be thanks to the mythical no-alias guarantee of slices?</p></li>
</ul>

<p>Rust has also added a bunch tiny <a href="https://kornel.ski/rust-c-speed">overheads all over the place</a>, like glue code for panics and destructors, extra bounds checks, use of 64-bit <code>usize</code> instead of 32-bit <code>int</code>, but these things did not show up in profiling, and other wins outweigh them.</p>

<p>I think it&#39;s an interesting comparison, because it wasn&#39;t a rewrite of an old legacy codebase with a shiny new design. The C code was as good as I could make it, and the Rust version uses the same algorithm (with different bugs ;)</p>

<h3>Nice things</h3>

<p>I&#39;ve tried to be careful about implicit numeric type conversions in C (including mixing of <code>float</code> and <code>double</code>), but there were a few that I&#39;ve missed. They became clear after conversion to Rust. Rust is strict about numeric types to the point of being annoying, but at least I know the only type conversions are the ones that I wrote.</p>

<p>Rust&#39;s <a href="https://tonyarcieri.com/a-quick-tour-of-rusts-type-system-part-1-sum-types-a-k-a-tagged-unions"><code>enum</code>s</a> worked well. The library has various ways of representing images in memory (e.g. they can be dynamically streamed without buffering). In C this needed a few inter-dependent nullable pointers and boolean flags, which were hard to keep track of. In Rust it translated nicely to different sets of <code>enum</code> fields.</p>

<p>Lifetime annotations helped me catch a bug. There&#39;s an image convolution pass that needs to look at pixels from the current, previous, and next line at the same time. However, the statefully-complex image may have had only a 1-line buffer, so all three line reads would end up overwriting each other in that buffer. In Rust such loop didn&#39;t compile due to a borrow checking error (can&#39;t mutably borrow the internal temp buffer more than once).</p>

<p>When users pass invalid pointers to the library (freed memory or other garbage) it makes <em>my</em> code to crash. Users report it to me as my bug, and I end up debugging <em>their</em> bugs. The good news is that it doesn&#39;t happen in Rust, but I still expose a C API, so I&#39;ve ported my defence from C: I first dereference all user-supplied C pointers in a specific function named <code>its_your_fault_not_mine</code> (or a more professional version of it). This triggers the crashes immediately, right there, rather than sometime later deep in my code, so the crash stacktrace gets a built-in disclaimer. In C, there&#39;s no standard feature for preventing a function from being inlined or optimized out. There&#39;s no standard for making a &#34;useless&#34; memory read happen without causing a compiler warning. In Rust, there are explicit features for all of this. BTW, <code>volatile</code> in Rust is a <em><a href="https://doc.rust-lang.org/std/ptr/fn.read_volatile.html">function call</a></em>. That makes so much more sense!</p>

<p>Rust has x86 SIMD intrinsics and CPU detection built-in, so I was able to port my SSE code easily. When I first considered a Rust rewrite a few years ago they weren&#39;t there yet, so that&#39;s a reminder that Rust is <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">improving</a>.</p>

<h3>Corners cut</h3>

<p>The C API had support for custom allocators. I&#39;ve dropped it. Rust has its own mechanism for configuring a global allocator which is hopefully enough. Custom allocators per object are possible, but I don&#39;t think it&#39;s worth the hassle.</p>

<p>In C I&#39;ve used a &#34;flexible array member&#34; trick to allocate structs with a head and variable-length data in one <code>malloc</code>. The same technique is doable in Rust with some gymnastics, but also turned out to be entirely unnecessary. Rust prefers to return objects &#34;by value&#34;, but with calling convention magic or inlining avoid actually copying them. This usually eliminates heap allocations of structs entirely, or at least makes structs with variable-length data still cost one heap allocation, not two. It was a microoptimization anyway.</p>

<p>The C library used its own memory pool to avoid small allocations. It was probably an overkill even for C, and didn&#39;t improve performance in Rust (I&#39;ve tested it), so I&#39;ve dropped it.</p>

<h3>Quirks</h3>

<p>The C API promised to hold image data allocated with <code>malloc</code>, and even dynamically toggle whether it should <code>free</code> it or not. From idiomatic Rust perspective that&#39;s weird and sloppy. I&#39;ve managed to fully reimplement it, but it was 130 lines of not-so-pretty code that shouldn&#39;t need to exist in a Rust library.</p>

<p>Neither C nor Rust do a good job of autovectorizing my code that uses <code>4xf32</code> pixels. I&#39;ve tried giving them a 16-byte alignment, reordering operations to be as close to SSE instructions as possible, enabled <code>arch=native</code>, and so on, but it&#39;s a quartet of single-data instructions every time, in both languages.</p>

<p>Rust isn&#39;t really an object-oriented language, but it has enough syntax sugar to look like one. Trying to make the library more object-oriented exposed a &#34;drum-stick&#34; design issue: does <code>play(drum, stick)</code> translate to <code>drum.play(stick)</code> or <code>stick.hit(drum)</code>? The C library only had global functions, and all fields of all structs were public to the library (opaque structs in C are for the public API/ABI, not the internals), so &#34;where does this code belong&#34; was never a question. The Rust-OO conversion ended up with a few odd functions that don&#39;t fit anywhere, and more crate-public fields than I&#39;d like.</p>

<p>By default Rust assumes that any structure containing a C pointer is not thread-safe, but I&#39;ve inherited an API that is full of C pointers! I&#39;ve been forced to manually override it with &#34;trust me, it&#39;s thread-safe&#34; in a few places. Usually it&#39;s Rust telling me whether my code is thread-safe or not, so I&#39;m uneasy about the overrides. <a href="https://github.com/rust-lang/miri#readme"><code>miri test</code></a> passes.</p>

<h3>Parallelism</h3>

<p>Rust <code>rayon</code> is conceptually similar to OpenMP, but instead of <code>#pragma omp for</code> there&#39;s <a href="https://rust-lang-nursery.github.io/rust-cookbook/concurrency/parallel.html"><code>par_iter()</code></a>. It has delivered the same linear speedups where possible.</p>

<p>The C version used <code>buffers[omp_get_thread_num()]</code> to have exclusive per-thread buffers. This was basically a DIY thread-local storage, so I&#39;ve used thread-local storage in Rust too. For summing-up results from multiple threads Rayon supports parallel <code>fold</code>/<code>reduce</code>, but my data is simple enough that summing it up serially at the end is slightly faster (parallel <code>reduce</code> adds intermediate steps that didn&#39;t pay off here).</p>

<p>I&#39;ve parallelized all the simple cases. I&#39;d like to tackle more, but the rest requires bigger architectural and algorithmic changes, which is too much for the first release. Rayon is easy to safely experiment with, and Rust is very nice to refactor, so I hope to do more later.</p>

<h2>Conclusion</h2>

<p>I&#39;m ecstatic that I can now support all platforms from Android to Windows, with the same <code>cargo build</code> command. I won&#39;t have to worry again about the <code>___aarch64_cas8_acq_rel</code> symbol, <code>vcomp.dll</code>, compiler-private lib dirs, ignored <code>#pragma</code>s, or <code>#ifdef</code>s for vendor-specific bugs/features. The next <a href="https://gif.ski">gif.ski</a> will be 2.2 times faster.</p>

<h3>Where/when to get it?</h3>

<p>I&#39;ve <a href="https://lib.rs/imagequant">released the Rust library as a beta</a> on <a href="https://crates.io/crates/imagequant/4.0.0-beta.2">crates.io</a>. The source is on <a href="https://github.com/ImageOptim/libimagequant">GitHub</a>. I haven&#39;t published it in <a href="https://pngquant.org">pngquant.org</a> tarballs yet, because I still have some things to finish in <code>pngquant</code> exe, update all build/release processes, packages, documentation, etc.</p>

<hr/>

<p>Jan 2022, by <a href="https://github.com/kornelski/">Kornel</a>.</p>

<p><a href="https://pngquant.org/" rel="up">Return to home page</a>.</p></div>
  </body>
</html>
