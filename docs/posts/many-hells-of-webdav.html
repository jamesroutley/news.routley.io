<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://candid.dev/blog/many-hells-of-webdav">Original</a>
    <h1>Many hells of WebDAV</h1>
    
    <div id="readability-page-1" class="page"><div><p>Standards are great, until they aren’t</p><p>Implementing a WebDAV/CalDAV client and server should be easy! It’s a well documented spec, standardized in the early 00s, and somewhat widely supported. At least, that’s the naive assumption we started from when creating one for Homechart.</p><h2 id="existing-go-implementations">Existing Go Implementations</h2><p>Now before you mention NIH syndrome, yes, we looked at the existing Go implementation, <a href="https://github.com/emersion/go-webdav">go-webdav</a>. This library was lacking some key features we needed, like server-side collection synchronization, and the interfaces didn’t really align with our data model. This is also going to be a key feature of our product, so we should have some level of ownership for what gets implemented.</p><p>To start creating our client and server, we should read the RFCs, right? Well, where do you start?</p><p>How about the original, <a href="https://datatracker.ietf.org/doc/html/rfc2518">RFC 2518</a>? Ah, looks like it was somewhat superseded by <a href="https://datatracker.ietf.org/doc/html/rfc4918">RFC 4918</a>, but we’re not going to tell you which parts! How about those extension RFCs? There’s only 7 of them…</p><p>Reading through the RFCs, all that our implementation cares about is CRUD for Calendar events. After spending almost a month trying to implement the full RFC spec, we threw in the towel, there’s just to much legacy cruft that we didn’t need.</p><h2 id="reverse-engineering">Reverse Engineering</h2><p>With a decent understanding of the RFC in hand, we instead looked into reverse engineering existing clients and servers by inspecting their requests and responses. This process was MUCH faster, and we quickly had the API mapped out and what kind of requests/responses we needed to support.</p><p>We started by identifying the clients/servers we wanted to support:</p><p><strong>Clients</strong>:</p><ul><li>Apple Calendar</li><li>DavX</li><li>Thunderbird</li></ul><p><strong>Servers</strong>:</p><ul><li>Apple iCloud</li><li>Google Calendar</li><li>Radicale</li></ul><p>And then ran HTTP proxies or Wireshark to capture the HTTP requests. Because WebDAV is so obtuse, you not only need to inspect the HTTP body, but also the headers!</p><h2 id="xml-in-go">XML in Go</h2><p>As an aside, we spent quite a bit of time trying to make XML work well in Go. The default Go XML library is truly terrible, and we decided to create a wrapper around it for managing XML nodes similar to how JavaScript manages HTML nodes:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span><span> </span><span>davDisplayName</span><span> </span><span>=</span><span> </span><span>xmel</span><span>.</span><span>Element</span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>Name</span><span>:</span><span>  </span><span>&#34;displayname&#34;</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>Space</span><span>:</span><span> </span><span>davNS</span><span>,</span><span>
</span></span></span><span><span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>davDisplayName</span><span>.</span><span>SetValue</span><span>(</span><span>&#34;name&#34;</span><span>)</span><span>
</span></span></span><span><span><span>n</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>davResponse</span><span>.</span><span>Find</span><span>(</span><span>davCollectionType</span><span>)</span><span>
</span></span></span><span><span><span>davOwner</span><span> </span><span>=</span><span> </span><span>davOwner</span><span>.</span><span>AddChild</span><span>(</span><span>davHref</span><span>.</span><span>SetValue</span><span>(</span><span>&#34;http://example.com&#34;</span><span>))</span><span>
</span></span></span></code></pre></div><p>With WebDAV having such an…“unstructured” schema to a lot of the requests/responses, this library was key in helping us marshal/unmarshal things without writing a bunch of “best case” structs.</p><h2 id="standards-are-just-suggestions">Standards are Just Suggestions</h2><p>When we finally had our MVP built out, we put it to the test: validating our client and server against the existing implementations! For the most part, it worked as expected, but as always, things drift from the RFC.</p><p>Apple and Google, for instance, don’t implement half of the RFCs, and basically provide a MVP for other clients to use. They don’t really document what they support/don’t support, as WebDAV is supposed to do it via HTTP responses advertising capabilities, but both seem to provide generic responses advertising capabilities they don’t have a lot of the time.</p><p>The clients were another story. CalDAV clients are all over the place with what they support and how they will request it. Most clients <strong>should</strong> prefer to support <code>sync-collection</code> as it’s very efficient, but Apple Calendar doesn’t, and uses ctags and etags instead.</p><p>As a little fish in a big pond, it’s frustrating dealing with situations where big providers can skirt around some standards or add quirks for their implementations, but I’m required to follow them to the T because I don’t have their inertia. I can’t file a bug, or a lawsuit, against them claiming nonconformance, they’ll tell me to get bent. And you see this in other open source libraries too, where they’re littered with comments about workarounds for Google’s specific implementation or whatever.</p><p>I wouldn’t recommend anyone who values their sanity to pursue creating a WebDAV/CalDAV library.</p></div></div>
  </body>
</html>
