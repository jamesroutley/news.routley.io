<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/08/24/an-introduction-to-ractors-in-ruby.html">Original</a>
    <h1>An Introduction to Ractors in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In this post, we&#39;ll dive into ractors in Ruby, exploring how to build a ractor. You&#39;ll send and receive messages in ractors, and learn about shareable and unshareable objects.</p><p>But first, let&#39;s define the actor model and ractors, and consider when you should use ractors.</p><div><h2>What is the Actor Model?</h2><p>In computer science, the object-oriented model is very popular, and in the Ruby community, many people are used to the term &#39;everything is an object&#39;.</p><p>Similarly, let me introduce you to the actor model, within which &#39;everything is an actor&#39;. The actor model is a mathematical model of concurrent computation in which the universal primitive/fundamental agent of computation is an <strong>actor</strong>. An actor is capable of the following:</p><ul><li>Receiving messages and responding to the sender</li><li>Sending messages to other actors</li><li>Determining how to respond to the next message received</li><li>Creating several other actors</li><li>Making local decisions</li><li>Performing actions (e.g., mutating data in a database)</li></ul><p>Actors communicate via messages, process one message at a time, and maintain their own private state. However, they can modify this state via messages received, eliminating the need for a lock or mutex.</p><p>Received messages are processed one message at a time in the order of FIFO (first in, first out). The message sender is decoupled (isolated) from the sent communication, enabling asynchronous communication.</p><p>A few examples of the actor model implementation are akka, elixir, pulsar, celluloid, and <strong>ractors</strong>. A few examples of concurrency models include threads, processes, and futures.</p></div><div><h2>What Are Ractors in Ruby?</h2><p>Ractor is an actor-model abstraction that provides a parallel execution feature without <a href="https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/">thread-safety concerns</a>.</p><p>Just like threads, ractors provide true parallelism. However, unlike threads, they do not share everything. Most objects are unshareable, and when they are made shareable, are protected by an interpreter or locking mechanism.</p><p>Ractors are also unable to access any objects through variables not defined within their scope. This means that we can be free of the possibility of <a href="https://www.techtarget.com/searchstorage/definition/race-condition">race conditions</a>.</p><p>In 2015, when Ruby 3.0.0 was released, these were the <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">words of Matz</a>:</p><blockquote><p>It’s multi-core age today. Concurrency is very important. With Ractor, along with Async Fiber, Ruby will be a real concurrent language.</p></blockquote><p>Ractors do not claim to have solved all thread-safety problems. In the <a href="https://docs.ruby-lang.org/en/3.0/ractor_md.html">Ractor documentation</a>, the following is clearly stated:</p><blockquote><p>There are several blocking operations (waiting send, waiting yield, and waiting take) so you
can make a program which has dead-lock and live-lock issues.</p></blockquote><blockquote><p>Some kind of shareable objects can introduce transactions (STM, for example). However,
misusing transactions will generate inconsistent state.</p></blockquote><p>Without ractors, you need to trace all state mutations to debug thread-safety issues. However, the beauty of ractors is that we can concentrate our efforts on suspicious shared code.</p></div><div><h2>When and Why Should I Use Ractors in Ruby?</h2><p>When you create a ractor for the first time, you&#39;ll get a warning like this one:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="shell" data-theme="default"><span><span>&lt;internal:ractor&gt;:267: warning: Ractor is experimental, and the behavior may change </span><span>in</span><span> future versions of Ruby! Also there are many implementation issues.</span></span></code></pre></div><p>However, that does not mean that you should avoid using ractors. Due to parallel execution, ractors can complete processes way faster than when processes are carried out synchronously.</p><p>In the Ruby 3.0.0 release notes, you&#39;ll find this benchmark example of the <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Tak function</a>, where it is executed sequentially four times, and four times in parallel with ractors:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>def</span><span> </span><span>tarai</span><span>(</span><span>x</span><span>, </span><span>y</span><span>, </span><span>z</span><span>) </span><span>=</span></span>
<span><span>  x </span><span>&lt;=</span><span> y </span><span>?</span><span> y : tarai(tarai(x</span><span>-</span><span>1</span><span>, y, z),</span></span>
<span><span>                     tarai(y</span><span>-</span><span>1</span><span>, z, x),</span></span>
<span><span>                     tarai(z</span><span>-</span><span>1</span><span>, x, y))</span></span>
<span><span>require </span><span>&#39;benchmark&#39;</span></span>
<span><span>Benchmark</span><span>.bm </span><span>do</span><span> |</span><span>x</span><span>|</span></span>
<span><span>  </span><span># sequential version</span></span>
<span><span>  x.report(</span><span>&#39;seq&#39;</span><span>){ </span><span>4</span><span>.times{ tarai(</span><span>14</span><span>, </span><span>7</span><span>, </span><span>0</span><span>) } }</span></span>
<span> </span>
<span><span>  </span><span># parallel version with ractors</span></span>
<span><span>  x.report(</span><span>&#39;par&#39;</span><span>){</span></span>
<span><span>    </span><span>4</span><span>.times.map </span><span>do</span></span>
<span><span>      </span><span>Ractor</span><span>.</span><span>new</span><span> { tarai(</span><span>14</span><span>, </span><span>7</span><span>, </span><span>0</span><span>) }</span></span>
<span><span>    </span><span>end</span><span>.each(</span><span>&amp;</span><span>:</span><span>take</span><span>)</span></span>
<span><span>  }</span></span>
<span><span>end</span></span></code></pre></div><p>The results are as follows:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="shell" data-theme="default"><span><span>Benchmark result:</span></span>
<span><span>          user     system      total        real</span></span>
<span><span>seq  64.560736   0.001101  64.561837 ( 64.562194)</span></span>
<span><span>par  66.422010   0.015999  66.438009 ( 16.685797)</span></span></code></pre></div><p>The <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby 3.0.0 release notes</a> state:</p><blockquote><p>The result was measured on Ubuntu 20.04, Intel(R) Core(TM) i7-6700 (4 cores, 8 hardware threads). It shows that the parallel version is 3.87 times faster than the sequential version.</p></blockquote><p>So if you need a faster process execution time that can run in parallel on machines with multiple cores, ractors are not a bad idea at all.</p><p>Modifying class/module objects on multi-ractor programs can introduce race conditions and should be avoided as much as possible. However, most objects are unshareable, so the need to implement locks to prevent race conditions becomes obsolete. If objects are shareable, they are protected by an interpreter or locking mechanism.</p></div><div><h2>Creating Your First Ractor in Ruby</h2><p>Creating a ractor is as easy as creating any class instance. Call <code>Ractor.new</code> with a block — <code>Ractor.new { block }</code>. This block is run in parallel with every other ractor.</p><p><em>It is important to note that every example shown from this point onwards was performed in Ruby 3.1.2.</em></p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> { </span><span>puts</span><span> </span><span>&#34;This is my first ractor&#34;</span><span> }</span></span>
<span><span># This is my first ractor</span></span>
<span> </span>
<span><span># create a ractor with a name</span></span>
<span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>name</span><span>:</span><span> </span><span>&#39;second_ractor&#39;</span><span> </span><span>do</span></span>
<span><span>  </span><span>puts</span><span> </span><span>&#34;This is my second ractor&#34;</span></span>
<span><span>end</span></span>
<span><span># This is my second ractor</span></span>
<span> </span>
<span><span>r.name</span></span>
<span><span># =&gt; &#34;second_ractor&#34;</span></span></code></pre></div><p>Arguments can also be passed to <code>Ractor.new</code>, and these arguments become parameters for the ractor block.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>my_array </span><span>=</span><span> [</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span></span>
<span><span>Ractor</span><span>.</span><span>new</span><span> my_array </span><span>do</span><span> |</span><span>arr</span><span>|</span></span>
<span><span>  </span><span>puts</span><span> arr.each(</span><span>&amp;</span><span>:</span><span>to_s</span><span>)</span></span>
<span><span>end</span></span>
<span><span># 4</span></span>
<span><span># 5</span></span>
<span><span># 6</span></span></code></pre></div><p>Recall how we talked about ractors being unable to access objects defined outside their scope? Let&#39;s see an example of that:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>outer_scope_object </span><span>=</span><span> </span><span>&#34;I am an outer scope object&#34;</span></span>
<span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>puts</span><span> outer_scope_object</span></span>
<span><span>end</span></span>
<span><span># &lt;internal:ractor&gt;:267:in `new&#39;: can not isolate a Proc because it accesses outer variables (outer_scope_object). (ArgumentError)</span></span></code></pre></div><p>We get an error on the invocation of <code>.new</code>, related to a <code>Proc</code> not being isolated. This is because <code>Proc#isolate</code> is called at a ractor&#39;s creation to prevent sharing unshareable objects. However, objects can be passed to and from ractors via messages.</p></div><div><h2>Sending and Receiving Messages in Ractors</h2><p>Ractors send messages via an <em>outgoing port</em> and receive messages via an <em>incoming port</em>. The incoming port can hold an infinite number of messages and runs on the FIFO principle.</p><p>The <code>.send</code> method works the same way a mailman delivers a message in the mail. The mailman takes the message and drops it at the door (incoming port) of the ractor.</p><p>However, dropping a message at a person&#39;s door is not enough to get them to open it. <code>.receive</code> is then available for the ractor to open the door and receive whatever message has been dropped.</p><p>The ractor might want to do some computation with that message and return a response, so how do we get it? We ask the mailman to <code>.take</code> the response.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>tripple_number_ractor </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>puts</span><span> </span><span>&#34;I will receive a message soon&#34;</span></span>
<span><span>  msg </span><span>=</span><span> </span><span>Ractor</span><span>.receive</span></span>
<span><span>  </span><span>puts</span><span> </span><span>&#34;I will return a tripple of what I receive&#34;</span></span>
<span><span>  msg </span><span>*</span><span> </span><span>3</span></span>
<span><span>end</span></span>
<span><span># I will receive a message soon</span></span>
<span><span>tripple_number_ractor.send(</span><span>15</span><span>) </span><span># mailman takes message to the door</span></span>
<span><span># I will return a tripple of what I receive</span></span>
<span><span>tripple_number_ractor.take </span><span># mailman takes the response</span></span>
<span><span># =&gt; 45</span></span></code></pre></div><p>As seen above, the return value of a ractor is also a sent message and can be received via <code>.take</code>. Since this is an outgoing message, it goes to the outgoing port.</p><p>Here&#39;s a simple example:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>5</span><span>**</span><span>2</span></span>
<span><span>end</span></span>
<span><span>r.take </span><span># =&gt; 25</span></span></code></pre></div><p>Besides returning a message, a ractor can also send a message to its outgoing port via <code>.yield</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  squared </span><span>=</span><span> </span><span>5</span><span>**</span><span>2</span></span>
<span><span>  </span><span>Ractor</span><span>.yield squared</span><span>*</span><span>2</span></span>
<span><span>  </span><span>puts</span><span> </span><span>&#34;I just sent a message out&#34;</span></span>
<span><span>  squared</span><span>*</span><span>3</span></span>
<span><span>end</span></span>
<span><span>r.take</span></span>
<span><span># =&gt; 50</span></span>
<span><span>r.take</span></span>
<span><span># =&gt; 75</span></span></code></pre></div><p>The first message sent to the outgoing port is <code>squared*2</code>, and the next message is <code>squared*3</code>. Therefore, when we call <code>.take</code>, we get <code>50</code> first. We have to call <code>.take</code> a second time to get <code>75</code> as two messages are sent to the outgoing port.</p><p>Let&#39;s put this all together in one example of customers sending their orders to a supermarket and receiving the fulfilled orders:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>supermarket </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>loop</span><span> </span><span>do</span></span>
<span><span>    order </span><span>=</span><span> </span><span>Ractor</span><span>.receive</span></span>
<span><span>    </span><span>puts</span><span> </span><span>&#34;The supermarket is preparing </span><span>#{</span><span>order</span><span>}</span><span>&#34;</span></span>
<span><span>    </span><span>Ractor</span><span>.yield </span><span>&#34;This is </span><span>#{</span><span>order</span><span>}</span><span>&#34;</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span>
<span> </span>
<span><span>customers </span><span>=</span><span> </span><span>5</span><span>.times.map{ |</span><span>i</span><span>|</span></span>
<span><span>  </span><span>Ractor</span><span>.</span><span>new</span><span> supermarket, i </span><span>do</span><span> |</span><span>supermarket</span><span>, </span><span>i</span><span>|</span></span>
<span><span>    supermarket.send(</span><span>&#34;a pack of sugar for customer </span><span>#{</span><span>i</span><span>}</span><span>&#34;</span><span>)</span></span>
<span><span>    fulfilled_order </span><span>=</span><span> supermarket.take</span></span>
<span><span>    </span><span>puts</span><span> </span><span>&#34;</span><span>#{</span><span>fulfilled_order</span><span>}</span><span> received by customer </span><span>#{</span><span>i</span><span>}</span><span>&#34;</span></span>
<span><span>  </span><span>end</span></span>
<span><span>}</span></span></code></pre></div><p>The output is as follows:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="shell" data-theme="default"><span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 3</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 2</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 3 received by customer 3</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 1</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 2 received by customer 2</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 0</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 1 received by customer 1</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 0 received by customer 0</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 4</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 4 received by customer 4</span></span></code></pre></div><p>Running it a second time yields:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="shell" data-theme="default"><span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 0</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 0 received by customer 0</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 4</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 4 received by customer 4</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 1</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 1 received by customer 1</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 3</span></span>
<span><span>The supermarket is preparing a pack of sugar </span><span>for</span><span> customer 2</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 3 received by customer 3</span></span>
<span><span>This is a pack of sugar </span><span>for</span><span> customer 2 received by customer 2</span></span></code></pre></div><p>The output can most definitely be in a different order every time we run this (because ractors run concurrently, as we have established).</p><p><strong>A few things to note about sending and receiving messages:</strong></p><ul><li>Messages can also be sent using <code>&lt;&lt; msg</code>, instead of <code>.send(msg)</code>.</li><li>You can add a condition to a <code>.receive</code> using <code>receive_if</code>.</li><li>When <code>.send</code> is called on a ractor that is already terminated (not running), you get a <code>Ractor::ClosedError</code>.</li><li>A ractor&#39;s outgoing port closes after <code>.take</code> is called on it if it runs just once (not in a loop).</li></ul><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>Ractor</span><span>.receive</span></span>
<span><span>end</span></span>
<span><span># =&gt; #&lt;Ractor:#61 (irb):120 running&gt;</span></span>
<span><span>r </span><span>&lt;&lt;</span><span> </span><span>5</span></span>
<span><span># =&gt; #&lt;Ractor:#61 (irb):120 terminated&gt;</span></span>
<span><span>r.take</span></span>
<span><span># =&gt; 5</span></span>
<span><span>r </span><span>&lt;&lt;</span><span> </span><span>9</span></span>
<span><span># &lt;internal:ractor&gt;:583:in `send&#39;: The incoming-port is already closed (Ractor::ClosedError)</span></span>
<span><span>r.take</span></span>
<span><span># &lt;internal:ractor&gt;:694:in `take&#39;: The outgoing-port is already closed (Ractor::ClosedError)</span></span></code></pre></div><ul><li>Objects can be moved to a destination ractor via <code>.send(obj, move: true)</code> or <code>.yield(obj, move: true)</code>. These objects become inaccessible at the previous destination, raising a <code>Ractor::MovedError</code> when you try to call any other methods on the moved objects.</li></ul><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>Ractor</span><span>.receive</span></span>
<span><span>end</span></span>
<span><span>outer_object </span><span>=</span><span> </span><span>&#34;outer&#34;</span></span>
<span><span>r.send(outer_object, </span><span>move</span><span>:</span><span> </span><span>true</span><span>)</span></span>
<span><span># =&gt; #&lt;Ractor:#3 (irb):7 terminated&gt;</span></span>
<span><span>outer_object </span><span>+</span><span> </span><span>&#34;moved&#34;</span></span>
<span><span># `method_missing&#39;: can not send any methods to a moved object (Ractor::MovedError)</span></span></code></pre></div><ul><li>Threads cannot be sent as messages using <code>.send</code> and <code>.yield</code>. Doing this results in a <code>TypeError</code>.</li></ul><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>Ractor</span><span>.yield(</span><span>Thread</span><span>.</span><span>new</span><span>{})</span></span>
<span><span>end</span></span>
<span><span># &lt;internal:ractor&gt;:627:in `yield&#39;: allocator undefined for Thread (TypeError)</span></span></code></pre></div></div><div><h2>Shareable and Unshareable Objects</h2><p>Shareable objects are objects that can be sent to and from a ractor without compromising thread safety. An immutable object is a good example because once created, it cannot be changed — e.g., numbers and booleans.</p><p>You can check the shareability of an object via <code>Ractor.shareable?</code> and make an object shareable via <code>Ractor.make_shareable</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>Ractor</span><span>.shareable?(</span><span>5</span><span>)</span></span>
<span><span># =&gt; true</span></span>
<span><span>Ractor</span><span>.shareable?(</span><span>true</span><span>)</span></span>
<span><span># =&gt; true</span></span>
<span><span>Ractor</span><span>.shareable?([</span><span>4</span><span>])</span></span>
<span><span># =&gt; false</span></span>
<span><span>Ractor</span><span>.shareable?(</span><span>&#39;string&#39;</span><span>)</span></span>
<span><span># =&gt; false</span></span></code></pre></div><p>As seen above, immutable objects are shareable and mutable ones aren&#39;t. In Ruby, we usually call the <code>.freeze</code> method on a string to make it immutable. This is the same method ractors apply to make an object shareable.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>str </span><span>=</span><span> </span><span>&#39;string&#39;</span></span>
<span><span>Ractor</span><span>.shareable?(str)</span></span>
<span><span># =&gt; false</span></span>
<span><span>Ractor</span><span>.shareable?(str.freeze)</span></span>
<span><span># =&gt; true</span></span>
<span><span>arr </span><span>=</span><span> [</span><span>4</span><span>]</span></span>
<span><span>arr.frozen?</span></span>
<span><span># =&gt; false</span></span>
<span><span>Ractor</span><span>.make_shareable(arr)</span></span>
<span><span># =&gt; [4]</span></span>
<span><span>arr.frozen?</span></span>
<span><span># =&gt; true</span></span></code></pre></div><p>Messages sent via ractors can either be shareable or unshareable. When shareable, the same object is passed around. However, when unshareable, ractors perform a full copy of the object by default and send the full copy instead.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>SHAREABLE</span><span> </span><span>=</span><span> </span><span>&#39;share&#39;</span><span>.freeze</span></span>
<span><span># =&gt; &#34;share&#34;</span></span>
<span><span>SHAREABLE</span><span>.object_id</span></span>
<span><span># =&gt; 350840</span></span>
<span><span>r </span><span>=</span><span> </span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>do</span></span>
<span><span>  </span><span>loop</span><span> </span><span>do</span></span>
<span><span>    msg </span><span>=</span><span> </span><span>Ractor</span><span>.receive</span></span>
<span><span>    </span><span>puts</span><span> msg.object_id</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span>
<span><span>r.send(</span><span>SHAREABLE</span><span>)</span></span>
<span><span># 350840</span></span>
<span><span>NON_SHAREABLE</span><span> </span><span>=</span><span> </span><span>&#39;can not share me&#39;</span></span>
<span><span>NON_SHAREABLE</span><span>.object_id</span></span>
<span><span># =&gt; 572460</span></span>
<span><span>r.send(</span><span>NON_SHAREABLE</span><span>)</span></span>
<span><span># 610420</span></span></code></pre></div><p>As seen above, the shareable object is the same within and outside the ractor. However, the unshareable one isn&#39;t because the ractor has a different object, just identical to it.</p><p>Another method to send an exact object when it is unshareable is the previously discussed <code>move: true</code>. This moves an object to a destination without needing to perform a copy.</p><p><strong>A few things to note about sharing objects in ractors:</strong></p><ul><li>Ractor objects are also shareable objects.</li><li>Constants that are shareable, but defined outside the scope of a ractor, can be accessed by a ractor. Recall our <code>outer_scope_object</code> example? Give it another try, defined as <code>OUTER_SCOPE_OBJECT = &#34;I am an outer scope object&#34;.freeze</code>.</li><li>Class and module objects are shareable, but instance variables or constants defined within them are not if assigned to unshareable values.</li></ul><div data-rehype-pretty-code-fragment=""><pre><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>C</span></span>
<span><span>  </span><span>CONST</span><span> </span><span>=</span><span> </span><span>5</span></span>
<span><span>  </span><span>@share_me</span><span> </span><span>=</span><span> </span><span>&#39;share me&#39;</span><span>.freeze</span></span>
<span><span>  </span><span>@keep_me</span><span> </span><span>=</span><span> </span><span>&#39;unaccessible&#39;</span></span>
<span><span>  </span><span>def</span><span> </span><span>bark</span></span>
<span><span>   </span><span>&#39;barked&#39;</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span>
<span> </span>
<span><span>Ractor</span><span>.</span><span>new</span><span> </span><span>C</span><span> </span><span>do</span><span> |</span><span>c</span><span>|</span></span>
<span><span>  </span><span>puts</span><span> c::</span><span>CONST</span></span>
<span><span>  </span><span>puts</span><span> c.</span><span>new</span><span>.bark</span></span>
<span><span>  </span><span>puts</span><span> c.instance_variable_get(</span><span>:</span><span>@share_me</span><span>)</span></span>
<span><span>  </span><span>puts</span><span> c.instance_variable_get(</span><span>:</span><span>@keep_me</span><span>)</span></span>
<span><span>end</span></span>
<span><span># 5</span></span>
<span><span># barked</span></span>
<span><span># share me</span></span>
<span><span># (irb):161:in `instance_variable_get&#39;: can not get unshareable values from instance variables of classes/modules from non-main Ractors (Ractor::IsolationError)</span></span></code></pre></div><ul><li>An incoming port or outgoing port can be closed using <code>Ractor#close_incoming</code> and <code>Ractor#close_outgoing</code>, respectively.</li></ul></div><div><h2>Wrap Up and Further Reading on Ractors</h2><p>In this article, we introduced the concept of ractors, including when and why to use them and how to get started. We also looked at how they communicate with one another, what objects are shareable and unshareable, and how to make objects shareable.</p><p>Ractors go deeper than this. Many other public methods can be called on ractors, like <code>select</code> to wait for the success of take, yield and receive, <code>count</code>, <code>current</code>, etc.</p><p>To expand your knowledge about ractors, check out the <a href="https://docs.ruby-lang.org/en/3.0/ractor_md.html">ractor documentation</a>. <a href="https://gist.github.com/Kukunin/960ccef0d3c0a2c4b28ff5345911c2a5">This GitHub gist</a> might also interest you if you&#39;d like to experimentally compare ractors with threads.</p><p>Ractors are indeed experimental, but they certainly look like they have a bright future in Ruby&#39;s evolution.</p><p>Happy coding!</p><p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div></div>
  </body>
</html>
