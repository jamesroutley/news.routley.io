<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/micro/lffs-002/">Original</a>
    <h1>LFFS: Simplicity vs Efficiency</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, December 26, 2024</em></p><p>I knew it was gonna happen, just knew it: I finally hit the first part of writing <a href="https://bytes.zone/projects/local-first-from-scratch/">the book</a> where I have to make a choice between something being easy to describe and understand up front vs long-term efficiency or flexibility.</p><p>Let me explain.</p><span id="continue-reading"></span><p>When you have a state-based CRDT, you have a <code>merge</code> operation. The details don&#39;t <em>really</em> matter for this explanation, but basically if <code>merge</code> is commutative, idempotent, and associative, you can make use it for a CRDT and syncing state is as simple as:</p><ol><li>Exchanging states with a peer.</li><li>Both sides call <code>merge</code> to get the final state.</li></ol><p>With a few more supporting details, that&#39;s easy to understand and explain! (Even easier because in the book the only peer is a sync server.)</p><p>However this sync protocol gives up efficiency for that simplicity: you have to send all the data back and forth over the network. <em>Most</em> of the time, you&#39;re gonna be sending a bunch of duplicate data with a few changes, which means you&#39;re actually sending all the data <em>twice</em>.</p><p>You can improve efficiency by sending only the things that changed: if I&#39;ve got a grow-only set, and I add <code>1</code> to it, I only send <code>1</code> to my peer. In fact, you can keep track of all the tiny pieces of data as separate instances of the CRDT, and only send the ones you care about. For example, the set <code>{1, 2, 3}</code> and the sets <code>{1}</code>, <code>{2}</code>, and <code>{3}</code> (when merged) represent the same data.</p><p>This implies that <code>merge</code> can be inverted. We&#39;ll call that operation <code>split</code>. Like <code>merge</code>, it needs to have a couple of properties:</p><ol><li><code>split</code> should produce irreducible CRDTs.</li><li><code>merge</code>ing the results of <code>split</code> should give you the original state.</li></ol><p>The literature I&#39;ve read claims that you can <code>split</code> all CRDTs, and I haven&#39;t found any counterexamples yet!</p><p>That lets us be even more efficient. Our sync protocol can look like this:</p><ol><li>Keep track of the changes you make but haven&#39;t sent to each peer, either as a single instance of the CRDT or as a list of <code>split</code> results.</li><li>Send only those changes during sync. (But <code>merge</code> them before sending, because that usually reduces the total byte size.)</li><li>When you receive changes, <code>split</code> what you get and remove any parts that you already knew about.</li><li>Add any new parts to the list of changes you send on to other peers (but not the peer you got them from.)</li></ol><p><a href="https://vitorenes.org/post/2019/04/efficient-sync/">Vitor Enes et al have a paper and blog post on this sync protocol if you want more details</a>.</p><p>Anyway, it seems like these protocols would be pretty easy to build up to (since <code>split</code> is just exposing a specific way of thinking about <code>merge</code>.) I&#39;m having a hard time, though, because I need a way to store the CRDT bits earlier than I want to put the syncing details. Although, I suppose I could:</p><ol><li>Store the whole replica state as a JSON blob locally.</li><li>Introduce the sync server and introduce <code>split</code> to deal with storage in Postgres there.</li><li>Implement the first sync protocol as a full state sync.</li><li>Improve to delta-state sync from there.</li></ol><p>Might work, might not. I guess we&#39;ll see!</p></article></div>
  </body>
</html>
