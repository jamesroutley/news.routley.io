<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rc-week-9-recap/">Original</a>
    <h1>RC Week 9: Parallels of Proofs and Programs</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Saturday, November 19, 2022</strong></p>

    <p>I have three weeks left at Recurse Center.
This last week was significantly less productive for me than usual, because I&#39;ve been pretty fatigued and just recovered from a cold.
But I still got some work done that I&#39;m proud of.
More than that, I&#39;m excited for the coming three weeks!</p>
<p>This week I was mostly fatigued all week, so I didn&#39;t do very much coding.
In spite of that, I made some really good progress on <a href="https://sr.ht/%7Entietz/isabella-db/">IsabellaDB</a> through some pairing sessions!
A friend reminded me that a few years ago I was <em>deeply</em> skeptical of pair programming (I knew it worked for some people, but I was convinced I was not one of those people).
This week cemented what I learned earlier in batch:
Pair programming is a highly effective tool for getting work done.
It&#39;s not an all-the-time thing for me, and it&#39;s highly dependent on having the right pair for the right problem, but it&#39;s a great time.</p>
<p>Through pairing this week, I was able to finish out both a basic move explorer (show the list of legal moves, click one to make that move) and finish out my sparse bitmap implementation.
This lays the groundwork for the more interesting features I am building with IsabellaDB.
Next up is <strong>displaying win/loss/draw percents</strong> in an opening tree so you can explore openings.
After that, building some <strong>filters</strong> to explore openings for a certain subset of games (played in the last 12 months, etc.).
And then after that, I&#39;ll generalize it to be a <strong>query engine over all the games</strong> so you can do things like search for sequences of positions (want to see how often the Caro-Kann transposes into a French Defense?) or features of positions/games (want to find all the <a href="https://www.chess.com/terms/botez-gambit-chess">Botez Gambits</a>?).</p>
<p>When I wasn&#39;t feeling up to coding this week, I dove into exploring Coq (a proof assistant) and Idris (a functional language with dependent types) more.
Right now, I&#39;m getting a lot of energy from exploring this more mathematical side of programming.
I&#39;m not sure it&#39;ll be sustained energy, but it&#39;s really exciting and fun to explore!
In particular, doing theorem proving with Coq is just kind of a fun puzzle game and it&#39;s addictive once you get the hang of it and the difficulty is at the right level.
If the proofs are too hard, you can&#39;t really get going in a flow sort of way.
But if they&#39;re <em>just</em> hard enough to be engaging but feasible, then it&#39;s so delightful and pulls me in.</p>
<p>These two activities—systems programming and theorem proving—came together in a very nice way this week.
Last week and this week, working through proofs, there were a few occasions where proofs got pretty difficult.
To get through them, there are two general techniques I&#39;ve been using:</p>
<ul>
<li><strong>Break the problem into subparts recursively.</strong> For a proof, this typically is one of a few things. For a particular statement, you may break it down into its cases (a boolean can be true or false, so consider each of those independently). And for a longer proof, you can find an intermediate lemma which you can prove to make the later work easier.</li>
<li><strong>Update definitions to support your proofs.</strong> Sometimes, a definition is wrong, and clearly needs to be reworked in order for a proof to be possible. I ran into this where I had an edge case that didn&#39;t matter until the Final Boss proof; when I fixed my definition, the proof was possible, where before it was not. In other cases, there are equivalent definitions where one will make the proof significantly easier. Usually this lets you avoid intermediate lemmas, and if the proof requires fewer steps from end-to-end it&#39;s usually easier to get from the start to the finish, so it makes it a lot easier!</li>
</ul>
<p>Both of these techniques came into play when I was working on my sparse bitmap implementation, as well.</p>
<p>The first thing I realized was that the way I defined it was not ideal for combining multiple bitmaps.
The definition worked and felt elegant, but it was very awkward and hard to reason about when iterating over two bitmaps in parallel.
In a pairing session, we changed the definition to an equivalent (but simpler) implementation.
This required changing most of the methods implemented on the bitmaps, too, since they rely on the underlying details.
But at the end of the day, it was worth it:
The implementation of the bitwise operators became so much <strong>easier to reason about and therefore more likely to be correct</strong>.</p>
<p>Recursively breaking down problems also came into play with the bitmaps.
This is a common technique in programming in general, so what I&#39;m talking about here isn&#39;t shocking.
The surprising thing to me, though, was how much <strong>writing my program felt like writing my proofs</strong>.
I think it&#39;s because it gives me a sense of formalism about how to reason about my code and a mental structure to it.
At any rate, exploring proof assistants has made writing programs much easier.
That&#39;s a win.</p>
<p>There&#39;s a strong parallel between the activities of writing proofs and of writing programs.
The <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a> tells us that programs and proofs are directly related.
I don&#39;t understand the details of that yet, but will work toward that through our exploration of Coq.
What I do know right now is these activities <strong>are extremely similar</strong> in how I think through things and how I approach them.</p>
<p>Another Recurser presented yesterday on how doing <a href="https://en.wikipedia.org/wiki/Study_%28art%29">studies</a> (in the art sense where you work through some small pieces in isolation before doing the broader composition) can be a highly effective technique for programming as well.
This makes a lot of sense and is a technique I want to try out more deliberately in the future.
In a sense, I think I&#39;m already doing it.
What is this, if not breaking problems down recursively?
(There&#39;s a small difference of the study being something you don&#39;t intend to reuse directly.)
Is there an art equivalent of updating your definitions to support the proof?</p>
<p>It&#39;s sort of fascinating the parallels between fields that I think of as typically unrelated.
Sure, proofs and programs, we&#39;ve been exposed to that before.
But I&#39;m a little bit mind-blown that there&#39;s also a parallel between <em>art</em> and programming in form of techniques.
This makes me excited to explore other domains and learn how people in other domains work!</p>
<p>See you next week!
It&#39;ll be a short one, because of Thanksgiving.</p>

  </article><p>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
