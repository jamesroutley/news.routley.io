<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/linux-vm-without-vm-software-user-mode/">Original</a>
    <h1>Linux VM without VM software – User Mode Linux</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p><a href="https://twitter.com/popovicu94?ref_src=twsrc%5Etfw" data-show-count="false">Follow @popovicu94</a></p>
<p>If you carefully read the Linux kernel docs, you will find an interesting statement:</p>
<blockquote>
<p>Linux has also been ported to itself. You can now run the kernel as a userspace application - this is called UserMode Linux (UML).</p>
</blockquote>
<p>Today, we’ll explore how you can start an unconventional VM by running a Linux kernel <strong>as a process within the Linux kernel itself</strong>. This approach doesn’t require installing virtualization software like QEMU, nor does it need root privileges, which opens up some intriguing possibilities.</p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li><a href="#kernels-hardware-abstraction">Kernel’s Hardware Abstraction</a></li>
<li><a href="#uml---kernel-in-a-userspace-process">UML - Kernel in a Userspace Process</a></li>
<li><a href="#building-a-uml-kernel">Building a UML Kernel</a></li>
<li><a href="#building-userspace">Building Userspace</a></li>
<li><a href="#running-the-nested-kernel">Running the Nested Kernel</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</details>
<h2 id="kernels-hardware-abstraction">Kernel’s Hardware Abstraction</h2>
<p>A fundamental responsibility of the kernel is to abstract hardware and offer a consistent interface to userspace. This includes managing shared resources like the CPU and memory for multiple tasks. The kernel determines the underlying hardware (e.g., through a device tree on some platforms, which lists system components) and connects the appropriate drivers.</p>
<p>This hardware can also be entirely virtual. In a QEMU virtual machine, for instance, resources like memory and attached disks are virtualized by the QEMU userspace application, incurring a certain performance overhead. The CPU presents an interesting case, as it too can be virtualized in userspace, particularly when emulating a different architecture.</p>
<p>A fascinating aspect of drivers for virtualized hardware is that they can be <em>enlightened</em> — or, more formally, <em>paravirtualized</em>. This means the drivers are aware they’re running on virtualized hardware and can leverage this by communicating with the hardware in specialized ways. While the specifics are complex, one can imagine drivers interacting with virtual hardware in ways not feasible with physical counterparts. Online sources suggest that paravirtualization can achieve performance levels close to those of physical devices using traditional drivers.</p>
<h2 id="uml---kernel-in-a-userspace-process">UML - Kernel in a Userspace Process</h2>
<p>Personally, I view UML as a paravirtualized kernel configuration. Instead of running directly on bare metal, the UML kernel operates atop an existing kernel instance, leveraging some of its userspace functionalities. For instance, rather than linking the console driver to a physical UART, it can utilize standard userspace input/output. Similarly, a block device driver can target a file on the host’s filesystem instead of a physical disk.</p>
<p>In this setup, UML is essentially a userspace process that cleverly employs concepts like files and sockets to launch a new Linux kernel instance capable of running its own processes. The exact mapping of these processes to the host — specifically, how the CPU is virtualized — is something I’m not entirely clear on, and I’d welcome insights in the comments. One could envision an implementation where guest threads and processes map to host counterparts but with restricted system visibility, akin to containers, yet still operating within a nested Linux kernel.</p>
<p><a href="https://www.kernel.org/doc/html/v5.7/virt/uml/user_mode_linux.html">This page</a> from the kernel’s documentation has a pretty good illustration of what this looks like:</p>
<pre is:raw="" tabindex="0"><code><span><span>            +----------------+</span></span>
<span><span>            | Process 2 | ...|</span></span>
<span><span>+-----------+----------------+</span></span>
<span><span>| Process 1 | User-Mode Linux|</span></span>
<span><span>+----------------------------+</span></span>
<span><span>|       Linux Kernel         |</span></span>
<span><span>+----------------------------+</span></span>
<span><span>|         Hardware           |</span></span>
<span><span>+----------------------------+</span></span></code></pre>
<p>I highly recommend checking out that page for more detailed documentation, particularly for the compelling reasons listed for its usefulness. The final point is especially appealing:</p>
<blockquote>
<ol start="9">
<li>It’s extremely fun.</li>
</ol>
</blockquote>
<p>And that’s precisely why we’re diving into it today!</p>
<h2 id="building-a-uml-kernel">Building a UML Kernel</h2>
<p>First things first: it’s crucial to understand that a UML kernel can run <strong>only on x86</strong> platforms. You can layer an x86 UML kernel on top of an existing x86 kernel; as far as I know, no other configurations are supported.</p>
<p>Next, we’ll build the UML binary. The configuration process starts with:</p>
<pre is:raw="" tabindex="0"><code><span><span>ARCH=um make menuconfig</span></span></code></pre>
<p>You can configure the kernel much like you normally would. You’ll immediately notice several UML-specific options on the initial configuration page. I tend to think of these as “enlightened” drivers, designed to use the host’s userspace facilities as virtual hardware.</p>
<p>For this demonstration, I specifically enabled the <code>BLK_DEV_UBD</code> option. The documentation explains:</p>
<blockquote>
<p>The User-Mode Linux port includes a driver called UBD which will let you access arbitrary files on the host computer as block devices. Unless you know that you do not need such virtual block devices, say Y here.</p>
</blockquote>
<p>This option wasn’t enabled by default (which surprised me a bit), so I recommend setting it to <code>Y</code>. Once you’ve finalized your configuration, building is straightforward:</p>
<pre is:raw="" tabindex="0"><code><span><span>ARCH=um make -j16</span></span></code></pre>
<p>And this produces a <code>linux</code> binary right there!</p>
<pre is:raw="" tabindex="0"><code><span><span>$ file linux</span></span>
<span><span>linux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=742d088d46f7c762b29257e4c44042f321dc4ad5, with debug_info, not stripped</span></span></code></pre>
<p>Interestingly, it’s dynamically linked to the C standard library:</p>
<pre is:raw="" tabindex="0"><code><span><span>$ ldd linux</span></span>
<span><span>        linux-vdso.so.1 (0x00007ffc0a3ce000)</span></span>
<span><span>        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3490409000)</span></span>
<span><span>        /lib64/ld-linux-x86-64.so.2 (0x00007f3490601000)</span></span></code></pre>
<h2 id="building-userspace">Building Userspace</h2>
<p>To do anything meaningful within our nested kernel, we need a userspace. For simplicity, I chose to download the latest <a href="https://buildroot.org/">Buildroot</a> and build it for x86/64.</p>
<p>If you’re feeling adventurous and want to try building a minimal userspace from scratch but aren’t sure where to begin, pairing this with the <a href="https://popovicu.com/posts/making-a-micro-linux-distro">micro Linux distro exercise</a> could be a lot of fun.</p>
<h2 id="running-the-nested-kernel">Running the Nested Kernel</h2>
<p>To make things interesting, I decided to provide a block device to the nested kernel, write some data to it, and then verify that data from the host system.</p>
<p>First, let’s create the disk image:</p>
<pre is:raw="" tabindex="0"><code><span><span>$ dd if=/dev/urandom of=./disk.ext4 bs=1M count=100</span></span></code></pre>
<p>Next, we’ll format it with ext4:</p>
<pre is:raw="" tabindex="0"><code><span><span>$ sudo mkfs.ext4 ./disk.ext4</span></span></code></pre>
<p>Now, it’s time to fire up the kernel in userspace. I’ll use the Buildroot image (an <code>ext2</code> file provided by Buildroot) as the root filesystem:</p>
<pre is:raw="" tabindex="0"><code><span><span>./linux ubd0=/tmp/uml/rootfs.ext2 ubd1=/tmp/uml/disk.ext4 root=/dev/ubda</span></span></code></pre>
<p>And just like that, we’re greeted by a very familiar kernel boot sequence!</p>
<pre is:raw="" tabindex="0"><code><span><span>Core dump limits :</span></span>
<span><span>        soft - 0</span></span>
<span><span>        hard - NONE</span></span>
<span><span>Checking that ptrace can change system call numbers...OK</span></span>
<span><span>Checking syscall emulation for ptrace...OK</span></span>
<span><span>Checking environment variables for a tempdir...none found</span></span>
<span><span>Checking if /dev/shm is on tmpfs...OK</span></span>
<span><span>Checking PROT_EXEC mmap in /dev/shm...OK</span></span>
<span><span>Linux version 6.14.7 (uros@debian-home) (gcc (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40) #6 Mon May 19 16:27:13 PDT 2025</span></span>
<span><span>Zone ranges:</span></span>
<span><span>  Normal   [mem 0x0000000000000000-0x0000000063ffffff]</span></span>
<span><span>Movable zone start for each node</span></span>
<span><span>Early memory node ranges</span></span>
<span><span>  node   0: [mem 0x0000000000000000-0x0000000003ffffff]</span></span>
<span><span>Initmem setup node 0 [mem 0x0000000000000000-0x0000000003ffffff]</span></span>
<span><span>random: crng init done</span></span>
<span><span>Kernel command line: ubd0=/tmp/uml/rootfs.ext2 ubd1=/tmp/uml/disk.ext4 root=/dev/ubda console=tty0</span></span>
<span><span>printk: log buffer data + meta data: 16384 + 57344 = 73728 bytes</span></span>
<span><span>Dentry cache hash table entries: 8192 (order: 4, 65536 bytes, linear)</span></span>
<span><span>Inode-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)</span></span>
<span><span>Sorting __ex_table...</span></span>
<span><span>Built 1 zonelists, mobility grouping on.  Total pages: 16384</span></span>
<span><span>mem auto-init: stack:all(zero), heap alloc:off, heap free:off</span></span>
<span><span>SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span></span>
<span><span>NR_IRQS: 64</span></span>
<span><span>clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns</span></span>
<span><span>Calibrating delay loop... 8931.73 BogoMIPS (lpj=44658688)</span></span>
<span><span>Checking that host ptys support output SIGIO...Yes</span></span>
<span><span>pid_max: default: 32768 minimum: 301</span></span>
<span><span>Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>Memory: 57488K/65536K available (3562K kernel code, 944K rwdata, 1244K rodata, 165K init, 246K bss, 7348K reserved, 0K cma-reserved)</span></span>
<span><span>...</span></span></code></pre>
<p>and at the end, we have the Buildroot login:</p>
<pre is:raw="" tabindex="0"><code><span><span>Run /sbin/init as init process</span></span>
<span><span>EXT4-fs (ubda): warning: mounting unchecked fs, running e2fsck is recommended</span></span>
<span><span>EXT4-fs (ubda): re-mounted 23cafb4d-e18f-4af4-829d-f0dc7303e6c4 r/w. Quota mode: none.</span></span>
<span><span>EXT4-fs error (device ubda): ext4_mb_generate_buddy:1217: group 1, block bitmap and bg descriptor inconsistent: 7466 vs 7467 free clusters</span></span>
<span><span>Seeding 256 bits and crediting</span></span>
<span><span>Saving 256 bits of creditable seed for next boot</span></span>
<span><span>Starting syslogd: OK</span></span>
<span><span>Starting klogd: OK</span></span>
<span><span>Running sysctl: OK</span></span>
<span><span>Starting network: OK</span></span>
<span><span>Starting crond: OK</span></span>
<span><span></span></span>
<span><span>Welcome to Buildroot</span></span>
<span><span>buildroot login:</span></span></code></pre>
<p>The boot process was surprisingly quick.</p>
<p>Now, let’s create a mountpoint for our disk within the UML instance:</p>
<pre is:raw="" tabindex="0"><code><span><span># mkdir /mnt/disk</span></span></code></pre>
<p>Then, we mount the second UBD device (<code>ubdb</code>) to this mountpoint:</p>
<pre is:raw="" tabindex="0"><code><span><span># mount /dev/ubdb /mnt/disk/</span></span></code></pre>
<p>With the disk mounted, we can write a test file:</p>
<pre is:raw="" tabindex="0"><code><span><span># echo &#34;This is a UML test!&#34; &gt; /mnt/disk/foo.txt</span></span>
<span><span># cat /mnt/disk/foo.txt</span></span>
<span><span>This is a UML test!</span></span></code></pre>
<p>I can now shut down the UML VM:</p>
<pre is:raw="" tabindex="0"><code><span><span># poweroff</span></span></code></pre>
<p>which gives</p>
<pre is:raw="" tabindex="0"><code><span><span># Stopping crond: stopped /usr/sbin/crond (pid 64)</span></span>
<span><span>OK</span></span>
<span><span>Stopping network: OK</span></span>
<span><span>Stopping klogd: OK</span></span>
<span><span>Stopping syslogd: stopped /sbin/syslogd (pid 40)</span></span>
<span><span>OK</span></span>
<span><span>Seeding 256 bits and crediting</span></span>
<span><span>Saving 256 bits of creditable seed for next boot</span></span>
<span><span>EXT4-fs (ubdb): unmounting filesystem e950822b-09f7-49c2-bb25-9755a249cfa1.</span></span>
<span><span>umount: devtmpfs busy - remounted read-only</span></span>
<span><span>EXT4-fs (ubda): re-mounted 23cafb4d-e18f-4af4-829d-f0dc7303e6c4 ro. Quota mode: none.</span></span>
<span><span>The system is going down NOW!</span></span>
<span><span>Sent SIGTERM to all processes</span></span>
<span><span>Sent SIGKILL to all processes</span></span>
<span><span>Requesting system poweroff</span></span>
<span><span>reboot: Power down</span></span></code></pre>
<p>On my host system:</p>
<pre is:raw="" tabindex="0"><code><span><span>$ sudo mount ./disk.ext4 ./img</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>$ cat ./img/foo.txt</span></span>
<span><span>This is a UML test!</span></span></code></pre>
<p>This little experiment confirms that we successfully ran a VM using UML, wrote data to a block device within it, and those changes persisted, accessible from the host system.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Throughout this article, I’ve referred to UML as a VM, and you’d be right to raise an eyebrow. On one hand, it embodies the idea of hardware virtualization via host userspace facilities, and the environment gets its own distinct kernel. On the other hand, this guest kernel is intrinsically linked to the host’s kernel. While it aims for isolation, it doesn’t achieve the same level you’d expect from a QEMU VM powered by KVM.</p>
<p>What’s the real-world utility here? Is UML suitable for running isolated workloads? My educated guess is: probably not for most production scenarios. I believe UML’s primary strength lies in kernel debugging, rather than serving as a full-fledged, production-ready virtualization stack. For robust VM needs, KVM virtualization (operating at a different architectural layer) is far more battle-tested. Of course, containers offer another alternative if sharing the host kernel is acceptable for your workloads. UML carves out an interesting niche between these two: offering a separate kernel instance while still maintaining a unique connection to the host kernel. It’s a fascinating concept.</p>
<p>Perhaps in the future, this intriguing technology will garner more attention and see wider adoption. For now, though, it’s a fantastic tool for experimentation and, at the very least, a lot of fun to play with!</p>
<p>Happy hacking!</p>
<p>For updates, please consider following me on <a href="https://twitter.com/popovicu94">Twitter/X</a> and <a href="https://www.linkedin.com/in/upopovic/">LinkedIn</a>.</p>
    </article></div>
  </body>
</html>
