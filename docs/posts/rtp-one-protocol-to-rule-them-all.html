<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paper.wf/binarycat/rtp">Original</a>
    <h1>RTP: One protocol to rule them all?</h1>
    
    <div id="readability-page-1" class="page"><div><p>refining the ideas behind HTTP, BitTorrent, Gemini, and 9p to create a simple protocol for reliably transferring large immutable files.</p>

<p>(this document is a first draft, and is not intended to be implemented in its current form)</p>


<ol><li>as simple as possible without sacrificing our other goals (less complex than http)</li>
<li>performs well under poor network conditions, even when payloads are large (unlike gemini)</li>
<li>performs well under high latency (unlike 9p)</li>
<li>good single-source performance (unlike BitTorrent)</li></ol>


<ol><li>content negotiation (http Accept headers)</li>
<li>mutable identifiers</li>
<li>version negotiation</li></ol>

<p>all of these can be trivially handled via an outer protocol (eg. mutable identifiers can be handled with gemini cross-protocol redirects)</p>



<p>a stateful request/response protocol similar to 9p, but with hash-identified urls similar to magnet links (these encode length and content hash)</p>

<p>streams are encoded over tcp, tcp/tls, or quic to ensure reliable delivery.</p>



<p>each request has a number of fields.  each field is marked either as a fixed number of bits, or as a “string” field.</p>

<p>“string” fields consist of a 64 bit length value, followed by that many bytes.</p>

<p>“string” fields do not have to be valid utf-8 unless specified.</p>

<p>all integers are little-endian.  note that tokens are <em>not</em> integers, they are opaque client chosen identifiers with a length of 63 bits (followed by a 1 bit flag, which takes the place of the LSB of the final bytes).  servers must take to mask the correct bit.</p>



<p>there are 2 request types:
* OPEN
* READ</p>

<p>there are 2 response types:
* OK
* ERROR</p>

<p>each request has the following structure:
* (63 bits) <code>new_token</code>: a token identifying the results of the request
* (1 bit) <code>request_type</code>: integer representing type of request
* (n bits) type-dependent fields</p>

<p>each response has the following structure:
* (63 bits) <code>request_token</code>: the client-chosen token found in the request that generated this responce
* (1 bit) <code>is_error</code>: set if the corresponding request generated an error (such as the server being unable to find the requested resource)
* (string) <code>payload</code>: if <code>is_error</code> is set, then a human and machine readable UTF-8 string representing an error.  otherwise, its interpretation depends on the type of the request.</p>

<h2 id="open-request" id="open-request">OPEN request</h2>

<p>open requests one extra “string” field:
* (string) <code>uri</code>: this field represents the uri of the resource to be downloaded.  what schemes are supported depends on the server, but it is recommended to support at least <code>urn:sha256:*</code> uris.</p>

<p>the <code>payload</code> of non-error responses to OPEN requests is ignored, and SHOULD be empty.</p>

<h2 id="read-request" id="read-request">READ request</h2>

<p>read requests have two extra fields:
* (64 bits) offset: at what point to begin reading
* (64 bits) length: the maximum number of payload bytes the server is allowed respond with.</p>

<p>the <code>payload</code> of non-error responses to <code>READ</code> requests MUST be the empty string if and only if <code>offset</code> is greater than or equal to the total number of bytes in the resource, or if <code>length</code> is 0.  if neither of these conditions are met, the <code>payload</code> MUST NOT be the empty string.</p>

<p>when the server generates an error in response to a token, all further <code>READ</code> requests targeted at that token are canceled.  this allows a client to begin sending READ requests before it has received a response to the OPEN request.</p>

<h2 id="url-schemes" id="url-schemes">URL schemes</h2>

<h2 id="rtp" id="rtp"><code>rtp</code></h2>

<p>much like the <code>magnet</code> url scheme, the <code>rtp</code> scheme consists entirly of predefined query parameters:</p>
<ul><li>(one or more) <code>u</code>: the uri/urn of the underlying resource.  can be specified multiple times to specify multiple hashes for the resource (the client is expected to verify the hash, so specifying multiple <code>u</code> allows slowly migrating to a new hash algo).  if multiple values are specified, they must correspond to the same resource.</li>
<li>(up to one) <code>l</code>: the length of the resource</li>
<li>(one or more) <code>s</code>: the server(s) that the resource can be retrieved from.  if specified multiple times, the client may choose one, or perform a swarm download from several at once.  these servers take the form of <code>proto!addr!port</code>, for example, <code>tcp!example.com!7777</code>.  (this is based off of plan9 dial strings, since it seems to be the only well-specified way of specifying a method of transport)</li>
<li>(zero or more) <code>t</code>: list of mime types that the resource may be interpreted as.  clients MAY ignore values other than the first.</li>
<li>(up to one) <code>v</code>: protocol version.  if not specified, it defaults to version <code>1</code>, which is the version specified in this document.  clients MUST reject urls with an unrecognized version.</li></ul>

<p>it is RECOMMENDED that every value of <code>u</code> is recognized by every server <code>s</code>.  if a client encounters an error when downloading from one server, it SHOULD try downloading from another server.</p>

<p>clients SHOULD NOT use <code>rtp</code> urls in <code>OPEN</code> requests, instead they should choose a value listed in <code>u</code>.</p>

<p>unrecognized fields SHOULD be ignored.</p>

<h2 id="gemini-rtp" id="gemini-rtp"><code>gemini+rtp</code></h2>

<p>use the <a href="https://geminiprotocol.net/" rel="nofollow">Gemini Protocol</a> in order to implement mutable identifiers.</p>

<p>gemini is used in “proxy mode”, that is, the sent url has a scheme of <code>gemini+rtp</code> and not <code>gemini</code>.  the gemini server then uses a cross-protocol redirect to return an <code>rtp</code> url.</p>

<h2 id="rationale" id="rationale">Rationale</h2>

<p><code>READ.length</code> is defined as a maximum so that clients that do not know the length of the resource they are downloading can use a value of <code>2^64 - 1</code> to request as much of the rest of the resource as the server is able to provide.</p>

<p><code>READ.offset</code> exists both so that downloads can be resumed, and also to allow seeking within complex formats (eg. allowing you do download just one file out of a zip archive).  It also allows doing swarm downloads from multiple equally trusted sources.</p>



<p>an error string consists of a machine readable string representing the kind of error, optionally followed by a colon, and then a human-readable string further clarifying the error.</p>

<p>the following predefined error strings:
* <code>error</code>: a generic error kind usable when nothing else is applicaple
* <code>not found</code>: no resource with the given uri is known to the server.
* <code>unsupported scheme</code>: the given uri or urn scheme is not supported</p>


<ol><li><code>READ</code> needs an additional field, <code>open_token</code>, which corresponds to the the <code>request_token</code> of an <code>OPEN</code> request.</li>
<li><code>RTP</code> is commonly used as an abbreviation for the Real-time Transport Protocol, and is not descriptive enough.</li>
<li>this is a protocol for reliably downloading large files.  it is not designed to be a drop in replacement for http or BitTorrent.</li></ol>

<p>I am currently drafting a successor proposal that addresses these issues.</p>

<hr/>

<p><a href="https://paper.wf/binarycat/tag:networking" rel="nofollow"><span>#</span><span>networking</span></a> <a href="https://paper.wf/binarycat/tag:programming" rel="nofollow"><span>#</span><span>programming</span></a></p>
</div></div>
  </body>
</html>
