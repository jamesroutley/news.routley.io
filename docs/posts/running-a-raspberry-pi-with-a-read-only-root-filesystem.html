<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dzombak.com/blog/2024/03/Running-a-Raspberry-Pi-with-a-read-only-root-filesystem.html">Original</a>
    <h1>Running a Raspberry Pi with a read-only root filesystem</h1>
    
    <div id="readability-page-1" class="page"><article><header><span> <time pubdate="" datetime="2024-03-29T17:16:16-04:00"> <span>March</span> <span>29,</span> <span>2024</span> </time> • <span>Tagged:</span> <a href="https://www.dzombak.com/blog/tag/series%3Api-reliability/">series:pi-reliability</a> <a href="https://www.dzombak.com/blog/tag/raspberry-pi/">raspberry-pi</a> <a href="https://www.dzombak.com/blog/tag/linux/">linux</a> </span></header><p>Many applications that run on Raspberry Pis and similar single-board computers — for example, environmental data loggers that report to a central database server — don’t really need to store any state locally on the Pi’s SD card. This means you can run the Pi with a read-only root filesystem, which will dramatically increase the SD card’s lifetime.</p><p>Keep in mind that, with a read-only filesystem, logs won’t be persisted on the Pi after a reboot or power loss, so <a href="https://www.dzombak.com/blog/2023/12/Remote-logging-for-easier-Raspberry-Pi-debugging.html">remote logging</a> is very helpful for troubleshooting.</p><p>The information in this post is, to the best of my knowledge, current as of March 2024. It <em>should</em> work on Raspberry Pi OS <a href="https://en.wikipedia.org/wiki/Raspberry_Pi_OS#Releases">versions</a> 11 (Bullseye) and 12 (Bookworm), at least, but I make no promises.</p><p>These changes are risky; <strong>following these steps, even if everything goes well, could render your Pi unbootable,</strong> requiring you to connect a keyboard and monitor to fix it. (<a href="https://www.dzombak.com/blog/2023/12/Consider-the-risks-before-making-any-dramatic-changes-to-your-Raspberry-Pi-setup.html">See my Pi Reliability post on risk vs. benefits.</a>)</p><h2 id="microsd-card-choice"> microSD card choice <a href="#microsd-card-choice"></a></h2><p>For this use case, using the smallest SD card possible is fine; a high-endurance card is ideal but not strictly necessary, since the whole point is to (almost) never write to it.</p><h2 id="plan-overview"> Plan overview <a href="#plan-overview"></a></h2><p>The overall idea here is to:</p><ul><li>Remove unneeded software &amp; disable unneeded services</li><li>Be sure the Pi is not using its SD card for swap space</li><li>Implement various workarounds and hacks for certain services that expect to be able to write to disk</li><li>Provide <a href="https://en.wikipedia.org/wiki/Tmpfs"><code>tmpfs</code></a> filesystems for paths that must be writable and store transient data</li><li>Configure the system to mount the root filesystem as read-only</li><li>Add some systemwide shell shortcuts to ease system maintenance</li></ul><h2 id="disable-unneeded-software-and-sd-card-swap"> Disable unneeded software and SD card swap <a href="#disable-unneeded-software-and-sd-card-swap"></a></h2><p>Some read-only Pi guides recommend removing <code>logrotate</code> and using <code>busybox-syslogd</code> instead; I want to keep using <code>journalctl</code> and friends as I’m used to, so I don’t do that.</p><p><a href="https://www.dzombak.com/blog/2023/12/Disable-or-remove-unneeded-services-and-software-to-help-keep-your-Raspberry-Pi-online.html">Look at the services running on the Pi and disable anything you don’t need</a> and <a href="https://www.dzombak.com/blog/2023/12/Stop-using-the-Raspberry-Pi-s-SD-card-for-swap.html">be sure your Pi isn’t using the SD card for swap space</a>.</p><h2 id="run-an-update-and-reboot"> Run an update and reboot <a href="#run-an-update-and-reboot"></a></h2><p>Not strictly necessary, but I like to make sure the system is up to date before freezing it in place:</p><div><div><pre><code><span>sudo </span>apt update <span>&amp;&amp;</span> <span>sudo </span>apt upgrade
<span>sudo </span>apt autoremove <span>--purge</span>
<span>sudo </span>reboot now
</code></pre></div></div><h2 id="in-bootcmdlinetxt-disable-swap-and-filesystem-checks"> In <code>/boot/cmdline.txt</code>, disable swap and filesystem checks <a href="#in-bootcmdlinetxt-disable-swap-and-filesystem-checks"></a></h2><ol><li>Edit this file via <code>sudo nano /boot/cmdline.txt</code></li><li>Append the following: <code>fsck.mode=skip noswap</code> (unless you plan to use an external drive as swap, in which case, omit <code>noswap</code> here)</li></ol><p>The resulting line will look something like this (copied from an Pi Zero W):</p><div><div><pre><code>console=serial0,115200 console=tty1 root=PARTUUID=76b4450a-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait fsck.mode=skip noswap
</code></pre></div></div><p>Older guides recommend you add <code>fastboot</code> to this line. This has been replaced by <code>fsck.mode=skip</code>.</p><h2 id="migrate-to-ntp-instead-of-systemd-timesyncd"> Migrate to <code>ntp</code> instead of <code>systemd-timesyncd</code> <a href="#migrate-to-ntp-instead-of-systemd-timesyncd"></a></h2><p>According to The Internet, <code>systemd-timesyncd</code> won’t work with a read-only filesystem, but we can get <code>ntp</code> to with a few workarounds. We’ll also allow <a href="https://packages.debian.org/unstable/main/fake-hwclock"><code>fake-hwclock</code></a> to write to the filesystem, which isn’t ideal, but the clock resetting back to 1970 on each boot will cause problems.</p><p>This is also a good opportunity to use <code>sudo raspi-config</code> to be sure your timezone is set correctly.</p><p>We’ll migrate from <code>systemd-timesyncd</code> to <code>ntp</code>:</p><div><div><pre><code><span>sudo </span>systemctl disable systemd-timesyncd.service
<span>sudo </span>apt <span>install </span>ntp
</code></pre></div></div><p>We have a few <code>ntp</code> settings to adjust. First, edit <code>/etc/ntp.conf</code>. Change the <code>driftfile</code> setting to store this state in <code>/var/tmp</code> (which we’ll put in a <code>tmpfs</code> later). The file will then start something like this:</p><div><div><pre><code>$ head -n 4 /etc/ntp.conf
# /etc/ntp.conf, configuration for ntpd; see ntp.conf(5) for help

driftfile /tmp/ntp.drift

</code></pre></div></div><p>Then, enable <code>ntp</code>, via <code>sudo systemctl enable ntp</code>.</p><p>Next, we need to edit the <code>ntp</code> systemd unit file to avoid using a systemd feature (<code>PrivateTmp</code>) that won’t work on a read-only filesystem. Run <code>sudo systemctl edit ntp</code>, and paste the following lines:</p><div><div><pre><code>[Service]
PrivateTmp=false
</code></pre></div></div><p>Those will be the only lines in that file.</p><p>Edit <code>/etc/cron.hourly/fake-hwclock</code>, a script which saves the current clock periodically in case of power failure. This is the one thing that we’re going to allow to write to the SD card. Add the two <code>mount ...</code> lines you see below, so the resulting file looks like this:</p><div><div><pre><code><span>#!/bin/sh</span>
<span>#</span>
<span># Simple cron script - save the current clock periodically in case of</span>
<span># a power failure or other crash</span>

<span>if</span> <span>(</span><span>command</span> <span>-v</span> fake-hwclock <span>&gt;</span>/dev/null 2&gt;&amp;1<span>)</span> <span>;</span> <span>then
  </span>mount <span>-o</span> remount,rw /
  fake-hwclock save
  mount <span>-o</span> remount,ro /
<span>fi</span>
</code></pre></div></div><h2 id="networkmanager"> NetworkManager <a href="#networkmanager"></a></h2><p>These instructions are for Raspberry Pi OS versions 11 (Bullseye), 12 (Bookworm), and newer. For older distributions (10/Buster or older) see <a href="https://www.dzombak.com/blog/2021/11/Reducing-SD-Card-Wear-on-a-Raspberry-Pi-or-Armbian-Device.html#dhcp--dhcpcd5">the DHCP/DHCPD5 section of my earlier blog post</a>.</p><p>We’ll shuffle some networking files around, remove some that we don’t strictly need to persist, and create symlinks from their original locations to <code>/var/run</code>, which is already a <code>tmpfs</code>:</p><div><div><pre><code><span>sudo mv</span> /etc/resolv.conf /var/run/resolv.conf <span>&amp;&amp;</span> <span>sudo ln</span> <span>-s</span> /var/run/resolv.conf /etc/resolv.conf
<span>sudo rm</span> <span>-rf</span> /var/lib/dhcp <span>&amp;&amp;</span> <span>sudo ln</span> <span>-s</span> /var/run /var/lib/dhcp
<span>sudo rm</span> <span>-rf</span> /var/lib/NetworkManager <span>&amp;&amp;</span> <span>sudo ln</span> <span>-s</span> /var/run /var/lib/NetworkManager
</code></pre></div></div><p>I won’t lie: I was nervous when I first ran that, but everything seemed fine afterward. As with everything in this guide, YMMV.</p><h2 id="move-the-random-seed-file-to-a-writable-location"> Move the <code>random-seed</code> file to a writable location <a href="#move-the-random-seed-file-to-a-writable-location"></a></h2><p>We’ll move the existing <a href="https://www.freedesktop.org/software/systemd/man/systemd-random-seed.service.html">systemd <code>random-seed</code> file</a> to a path we’ll put on a <code>tmpfs</code>, and link to it from the original location:</p><div><div><pre><code><span>sudo mv</span> /var/lib/systemd/random-seed /tmp/systemd-random-seed <span>&amp;&amp;</span> <span>sudo ln</span> <span>-s</span> /tmp/systemd-random-seed /var/lib/systemd/random-seed
</code></pre></div></div><p>To create this file in the <code>/tmp</code> folder at boot before starting the <code>random-seed</code> service, edit the file service file to add an <a href="https://askubuntu.com/a/879071"><code>ExecStartPre</code></a> command. Run <code>sudo systemctl edit systemd-random-seed.service</code>, and paste these lines in:</p><div><div><pre><code>[Service]
ExecStartPre=/bin/echo &#34;&#34; &gt;/tmp/systemd-random-seed
</code></pre></div></div><h2 id="note-snapd"> Note: <code>snapd</code> <a href="#note-snapd"></a></h2><p>I don’t have much experience yet with how snaps behave on a read-only filesystem. So far, this is the behavior I’ve noticed:</p><ol><li>Programs installed via snap still seem to run.</li><li>There are messages in the journal like <code>cannot run daemon: fatal: error opening lock file: open /var/lib/snapd/state.lock: read-only file system</code>, but I think these can be safely ignored: there’s no need to hold that lock if <code>snapd</code> can’t write to <code>state.json</code>.</li><li>Programs that snap had refreshed recently, but which I hadn’t run in a long time, print a warning when I run them: <code>2024/03/29 16:44:24.831251 cmd_run.go:1046: WARNING: cannot create user data directory: cannot update the &#39;current&#39; symlink of &#34;/home/cdzombak/snap/go/current&#34;: remove /home/cdzombak/snap/go/current: read-only file system</code>. But they still seem to run as expected.</li></ol><p>To solve that last annoyance, you can do this before making the filesystem read-only:</p><ol><li>Update snaps via <code>sudo snap refresh</code></li><li>For each snap listed in <code>~/snap</code>, run the relevant program. On this particular system, this just meant running <code>go</code> and <code>golangci-lint</code>.</li></ol><p>If all the snap names in <code>~/snap</code> are equivalent to binary names, you could do this via the bash one-liner <code>for n in ~/snap/*; do [ -x /snap/bin/&#34;$(basename $n)&#34; ] &amp;&amp; /snap/bin/&#34;$(basename $n)&#34;; done</code>.</p><p>I reserve the right to update this advice as I learn more, of course!</p><h2 id="disable-systemd-rfkill"> Disable <code>systemd-rfkill</code> <a href="#disable-systemd-rfkill"></a></h2><p>I can’t find much straightforward discussion on this service and its relationship to the <code>rfkill</code> tool. But, assuming your wireless devices (WiFi, Bluetooth) are currently working as desired, it seems safe to disable this service.</p><div><div><pre><code><span>sudo </span>systemctl disable systemd-rfkill.service
<span>sudo </span>systemctl mask systemd-rfkill.socket
</code></pre></div></div><p>This <em>may</em> break something if you’ve used the <code>rfkill</code> tool on your Pi to explicitly disable/enable a wireless device before. In that case, you know more about <code>rfkill</code> than I do, so you should be able to figure out what’s best for your use case.</p><h2 id="disable-daily-apt-and-mandb-tasks"> Disable daily <code>apt</code> and <code>mandb</code> tasks <a href="#disable-daily-apt-and-mandb-tasks"></a></h2><p>Both of these expect to be able to make filesystem writes that persist across reboots. We don’t need them on a system whose software is frozen in place:</p><div><div><pre><code><span>sudo </span>systemctl mask man-db.timer
</code></pre></div></div><div><div><pre><code><span>sudo </span>systemctl mask apt-daily.timer
<span>sudo </span>systemctl mask apt-daily-upgrade.timer
</code></pre></div></div><h2 id="move-temporary-folders-to-tmpfs"> Move temporary folders to <code>tmpfs</code> <a href="#move-temporary-folders-to-tmpfs"></a></h2><p>Finally, we get to the point that we’re adding <code>tmpfs</code> entries to our <code>fstab</code>.</p><p>Edit <code>/etc/fstab</code> to include these lines:</p><div><div><pre><code>tmpfs  /tmp      tmpfs  defaults,noatime,nosuid,nodev   0  0
tmpfs  /var/tmp  tmpfs  defaults,noatime,nosuid,nodev   0  0
</code></pre></div></div><h2 id="move-some-spool-folders-to-tmpfs"> Move some spool folders to <code>tmpfs</code> <a href="#move-some-spool-folders-to-tmpfs"></a></h2><p>Edit <code>/etc/fstab</code> to include these lines:</p><div><div><pre><code>tmpfs  /var/spool/mail  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=25m  0  0
tmpfs  /var/spool/rsyslog  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=25m  0  0
</code></pre></div></div><p>(Note that if you followed <a href="https://www.dzombak.com/blog/2023/12/Remote-logging-for-easier-Raspberry-Pi-debugging.html#configuring-rsyslog-to-minimize-sd-card-wear">my guide to setting up rsyslog on a Pi</a>, there should already be an entry placing <code>/var/spool/rsyslog</code> in a <code>tmpfs</code>.)</p><h2 id="deal-with-varlog"> Deal with <code>/var/log</code> <a href="#deal-with-varlog"></a></h2><p>We’ll add another <code>tmpfs</code> to <code>/etc/fstab</code> for the <code>/var/log</code> folder:</p><div><div><pre><code>tmpfs  /var/log  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=50m  0  0
</code></pre></div></div><p>When storing <code>/var/log</code> in RAM, unless you’ve disabled <code>journald</code>, you need to limit the amount of space <code>journald</code> is allowed to use. To do that, edit <code>/etc/systemd/journald.conf</code>. Uncomment the <code>SystemMaxUse=...</code> line (if necessary), and set it to half of your <code>/var/log</code> <code>tmpfs</code> size, or maybe a little less:</p><div><div><pre><code>#  This file is part of systemd.
# &lt;output snipped by cdzombak&gt;
# See journald.conf(5) for details.

[Journal]
# &lt;output snipped by cdzombak&gt;
SystemMaxUse=49M
# &lt;output snipped by cdzombak&gt;
</code></pre></div></div><h2 id="optional-completely-disable-journald-persistence"> Optional: Completely disable <code>journald</code> persistence <a href="#optional-completely-disable-journald-persistence"></a></h2><p>Instead of moving <code>/var/log</code> to a <code>tmpfs</code>, you might want to configure your system not to write to logs to disk <em>or</em> RAM, particularly if you’ll send logs to a remote syslog server.</p><p>To do that, edit <code>/etc/systemd/journald.conf</code>. Uncomment the <code>Storage=...</code> line (if necessary), and change it to <code>Storage=none</code>:</p><div><div><pre><code>#  This file is part of systemd.
# &lt;output snipped by cdzombak&gt;
# See journald.conf(5) for details.

[Journal]
Storage=none
# &lt;output snipped by cdzombak&gt;
</code></pre></div></div><h2 id="move-logrotate-state-to-tmpfs"> Move <code>logrotate</code> state to <code>tmpfs</code> <a href="#move-logrotate-state-to-tmpfs"></a></h2><p><code>logrotate</code> stores some state in <code>/var/lib/logrotate</code> and may not work if it can’t update that folder. Again, add this line to <code>/etc/fstab</code>:</p><div><div><pre><code>tmpfs  /var/lib/logrotate  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=1m,mode=0755  0  0
</code></pre></div></div><h2 id="move-sudo-state-to-tmpfs"> Move <code>sudo</code> state to <code>tmpfs</code> <a href="#move-sudo-state-to-tmpfs"></a></h2><p><code>sudo</code> stores some state in <code>/var/lib/sudo</code>, which should be writable. Add this line to <code>/etc/fstab</code>:</p><div><div><pre><code>tmpfs  /var/lib/sudo  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=1m,mode=0700  0  0
</code></pre></div></div><h2 id="add-ro-to-the-end-of-your-bootcmdlinetxt-line"> Add <code>ro</code> to the end of your <code>/boot/cmdline.txt</code> line <a href="#add-ro-to-the-end-of-your-bootcmdlinetxt-line"></a></h2><p>(Almost there!)</p><p>Edit <code>/boot/cmdline.txt</code> again, and append ` ro` to the line.</p><h2 id="modify-fstab-options-to-set-filesystems-as-read-only"> Modify <code>fstab</code> options to set filesystems as read-only <a href="#modify-fstab-options-to-set-filesystems-as-read-only"></a></h2><p>Edit <code>/etc/fstab</code> again. This time, change the lines that refer to your SD card. In column 4, after the word <code>defaults</code> (without adding any whitespace):</p><ul><li>Add the <code>,ro</code> flag to both SD card mounts</li><li>If it’s not there already, add the <code>,noatime</code> option to the <code>/</code> mount</li></ul><h2 id="sample-files-at-this-point"> Sample files at this point <a href="#sample-files-at-this-point"></a></h2><p><code>/etc/fstab</code>:</p><div><div><pre><code>proc            /proc           proc    defaults          0       0

PARTUUID=76b4450a-01  /boot           vfat    defaults,ro          0       2
PARTUUID=76b4450a-02  /               ext4    defaults,noatime,ro  0       1

tmpfs  /tmp      tmpfs  defaults,noatime,nosuid,nodev   0  0
tmpfs  /var/tmp  tmpfs  defaults,noatime,nosuid,nodev   0  0
tmpfs  /var/log  tmpfs  defaults,noatime,nosuid,nodev,noexec  0  0
tmpfs  /var/spool/mail  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=25m  0  0
tmpfs  /var/spool/rsyslog  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=25m  0  0
tmpfs  /var/lib/logrotate  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=1m,mode=0755  0  0
tmpfs  /var/lib/sudo  tmpfs  defaults,noatime,nosuid,nodev,noexec,size=1m,mode=0700  0  0
</code></pre></div></div><p><code>/boot/cmdline.txt</code>:</p><div><div><pre><code>console=serial0,115200 console=tty1 root=PARTUUID=76b4450a-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait fsck.mode=skip noswap ro
</code></pre></div></div><h2 id="add-systemwide-bash-integration"> Add systemwide bash integration <a href="#add-systemwide-bash-integration"></a></h2><p>Add the following lines to the end of <code>/etc/bash.bashrc</code>:</p><div><div><pre><code>set_bash_prompt<span>(){</span>
    <span>fs_mode</span><span>=</span><span>$(</span>mount | <span>sed</span> <span>-n</span> <span>-e</span> <span>&#34;s/^</span><span>\/</span><span>dev</span><span>\/</span><span>.* on </span><span>\/</span><span> .*(</span><span>\(</span><span>r[w|o]</span><span>\)</span><span>.*/</span><span>\1</span><span>/p&#34;</span><span>)</span>
    <span>PS1</span><span>=</span><span>&#39;\[\033[01;32m\]\u@\h${fs_mode:+($fs_mode)}\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;</span>
<span>}</span>
<span>PROMPT_COMMAND</span><span>=</span>set_bash_prompt

<span>alias </span><span>ro</span><span>=</span><span>&#39;sudo mount -o remount,ro / ; sudo mount -o remount,ro /boot&#39;</span>
<span>alias </span><span>rw</span><span>=</span><span>&#39;sudo mount -o remount,rw / ; sudo mount -o remount,rw /boot&#39;</span>
</code></pre></div></div><p>This gives you the following features:</p><ul><li>A prompt indicating whether you’re in read-only or read-write mode</li><li>The commands <code>rw</code> to switch to read-write mode, and <code>ro</code> to switch back to read-only mode</li></ul><h3 id="use-bash_logout-to-switch-to-read-only-mode-when-you-log-out"> Use <code>bash_logout</code> to switch to read-only mode when you log out <a href="#use-bash_logout-to-switch-to-read-only-mode-when-you-log-out"></a></h3><p>Edit this file via <code>sudo nano /etc/bash.bash_logout</code>. It may not exist yet, in which case saving this file from <code>nano</code> will create it. The file should contain this line:</p><div><div><pre><code><span>sudo </span>mount <span>-o</span> remount,ro / <span>;</span> <span>sudo </span>mount <span>-o</span> remount,ro /boot
</code></pre></div></div><h2 id="reboot-verify-with-mount-check-journalctl-for-issues"> Reboot, Verify with <code>mount</code>, Check <code>journalctl</code> for issues <a href="#reboot-verify-with-mount-check-journalctl-for-issues"></a></h2><div><div><pre><code><span>sudo </span>reboot now
<span># and then wait; SSH back in when the system comes back up</span>

mount
<span># verify that SD card partitions are mounted `ro`</span>

<span>sudo </span>journalctl <span>-b</span> 0
<span># scroll through and look for any issues</span>
</code></pre></div></div><p>When looking for issues, you’ll undoubtedly see some errors from various processes. You’ll want to investigate those.</p><p>Start by checking “is this actually broken?”. Often there will be messages from e.g. <code>avahi-daemon</code> or <code>snapd</code> that are unhappy they can’t go about their business normally on a read-only filesystem. But as long as that software is still working for your purposes, you can safely ignore their complaints.</p><h2 id="references-and-acknowledgements"> References and Acknowledgements <a href="#references-and-acknowledgements"></a></h2><p>See <a href="https://www.dzombak.com/blog/2021/11/Reducing-SD-Card-Wear-on-a-Raspberry-Pi-or-Armbian-Device.html#references-read-only-filesystem">the notes on my earlier post</a>.</p><hr/><p><strong>See Also:</strong> <a href="https://www.dzombak.com/blog/2023/12/Considerations-for-a-long-running-Raspberry-Pi.html">Considerations for a long-running Raspberry Pi</a>.</p></article></div>
  </body>
</html>
