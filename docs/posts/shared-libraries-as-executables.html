<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stoppels.ch/2022/08/20/executable-shared-libraries.html">Original</a>
    <h1>Shared Libraries as Executables</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
<section>

<p><em>Aug 20th, 2022</em></p>
<p>Typically you either have an executable or a shared library, but can you have an executable shared library too?</p>
<p>The ELF file header has a tag for the object type, which includes <code>ET_EXEC</code> or <code>ET_DYN</code>. That suggests an ELF file is either an executable or a shared library. However, in practice many executables are in fact <code>ET_DYN</code> objects:</p>
<pre>$ cat hello.c
#include &lt;stdio.h&gt;
void hello() { puts(&#34;hello&#34;); }
int main() { hello(); hello(); }

$ gcc -o hello hello.c

$ ./hello
hello
hello

$ file hello
hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bec6318280e1ed6d7d271d870a7d22f589c233f2, for GNU/Linux 3.2.0, not stripped
</pre>
<p>Notice that <code>file</code> outputs <em>shared object</em> which means the executable is an <code>ET_DYN</code> object.</p>
<p>The reason for this is that my GCC is configured to enable <code>-fpie</code> by default.</p>
<h2>Trying to link against <code>hello</code></h2>
<p>However, the <code>hello</code> executable is not particularly useful as a shared library, since it does not export the <code>hello</code> symbol:</p>
<pre>$ nm --dynamic --defined-only hello
$ # nothing here.
</pre>
<p>If we compile it with <code>-shared</code> both symbols get exposed</p>
<pre>$ gcc -o hello -shared hello.c

$ nm --dynamic --defined-only hello
0000000000001139 T hello
0000000000001150 T main
</pre>
<p>The <code>main</code> symbol in a shared library certainly looks odd, but the linker does not complain:</p>
<pre>$ cat main.c 
void hello();
int main(){ hello(); }

$ gcc -o main main.c -L. -l:hello -Wl,-rpath,.

$ ./main
hello
</pre>
<p>However, by specifying <code>-shared</code> we lost the ability to meaningfully execute <code>hello</code>:</p>
<pre>$ ./hello 
Segmentation fault (core dumped)
</pre>
<h2>Giving the shared library a program interpreter</h2>
<p>One effect of specifying <code>-shared</code> is that the linker will not add a <code>PT_INTERP</code> type program header to the binary. This program header specifies an absolute path to the interpreter, which is typically the dynamic linker. When executing an ELF file, the kernel parses the ELF file and looks for the interpreter. When it finds it, it effectively executes the interpreter instead and gives it a file descriptor of the ELF file, so the dynamic linker can continue to parse the ELF file, mapping the relevant sections of it and its dependencies into memory before executing the entry point.</p>
<p>So, to create a shared executable, we will need to manually create a <code>PT_INTERP</code> section. In my case the dynamic linker lives in <code>/lib64/ld-linux-x86-64.so.2</code>. Registering it goes as follows:</p> 
<pre>$ cat hello.c
#include &lt;stdio.h&gt;
const char interp[] __attribute__ ((section(&#34;.interp&#34;))) = PT_INTERP;
void hello() { puts(&#34;hello&#34;); }
int main() { hello(); hello(); }

$ gcc -shared -o hello hello.c -D &#39;PT_INTERP=&#34;/lib64/ld-linux-x86-64.so.2&#34;&#39;

$ file hello
hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=492b8f47d786a0d3d7152e131fd2c096135f1e53, not stripped
</pre>
<p>So, we now have a shared library with an interpreter. Unfortunately it&#39;s not quite enough:</p>
<pre>$ ./hello 
Segmentation fault (core dumped)
</pre>

<h2>Setting the entrypoint</h2>
<p>To fix the segfault, we need to inform the linker what symbol to use as entrypoint of execution:</p>
<pre>$ gcc -shared -o hello -Wl,--entry,main hello.c

$ ./hello
hello
hello
Segmentation fault (core dumped)
</pre>
<p>So, it almost works, except for a segfault on exit. The reason is we&#39;re missing an <code>exit</code> call:</p>
<pre>$ cat hello.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
const char interp[] __attribute__ ((section(&#34;.interp&#34;))) = PT_INTERP;
void hello() { puts(&#34;hello&#34;); }
int main() { hello(); hello(); exit(EXIT_SUCCESS); }

$ gcc -shared -o hello -Wl,--entry,main hello.c -D &#39;PT_INTERP=&#34;/lib64/ld-linux-x86-64.so.2&#34;&#39;

$ ./hello
hello
hello
</pre>

<h2>Linking an executable against <code>hello</code> again</h2>
<p>Finally, let&#39;s verify our <code>main</code> executable can be linked against the <code>hello</code> executable:</p>
<pre>$ gcc -o main main.c -L. -l:hello -Wl,-rpath,.

$ ldd main | grep hello
	hello =&gt; ./hello (0x00007fd419bb6000)

$ ./main
hello
</pre>
<p>Success!</p>
<h2>Examples in the wild</h2>
<p>So far I&#39;ve seen two cases where shared libraries are used as executables.</p>
<p>The first and most obvious example is the dynamic linker itself. For example <code>glibc</code>&#39;s dynamic linker allows you to run an executable as follows:
</p><pre>$ /lib64/ld-linux-x86-64.so.2 ./main
hello
</pre>
<p>The use case is that you can run existing executables under a new glibc version without the need to modify the <code>PT_INTERP</code> in the executable.</p>
<p>Another neat use case is truly relocatable and self-contained software. If you want to ship your software with all its dependencies up to <code>glibc</code> to another system, you immediately hit a Linux issue where <code>PT_INTERP</code> can only be an absolute path, so you can&#39;t make it point to your own <code>glibc</code>, and you&#39;ll end up using the possibly incompatible system <code>glibc</code> (if it is even available...). This can be worked around by replacing your executables with a script that invokes the dynamic linker directly, since the dynamic linker itself does not specify an interpreter.</p>
<p>The second example is <code>libQt5Core.so</code>, which dumps version info when executing it. Sounds useful!</p>
<pre>$ ./libQt5Core.so.5
This is the QtCore library version Qt 5.15.2
...
</pre>
</section>
</div></div>
  </body>
</html>
