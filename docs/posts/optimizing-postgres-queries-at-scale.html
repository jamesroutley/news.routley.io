<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/">Original</a>
    <h1>Optimizing Postgres Queries at Scale</h1>
    
    <div id="readability-page-1" class="page"><article><hr/>
<p><strong><em>Note: This post was originally published on <a href="https://heap.io/blog/optimizing-postgres-queries-at-scale" target="_blank">heap’s blog</a></em></strong></p>
<hr/>
<p>Heap is a product analytics tool that automatically captures web and mobile behavior like page views, clicks, and taps. We’re operating at a scale of billions of events per day, which we store across a distributed Postgres cluster.</p>
<p>Heap’s thousands of customers can build queries in the Heap UI to answer almost any question about how users are using their product. Optimizing all of these queries across all our customers presents special challenges you wouldn’t typically encounter if you were optimizing the performance of a small set of queries within a typical app.</p>
<p>This post is about why this scale requires us to conduct performance experiments to optimize our SQL, and it details how we conduct those experiments.</p>
<h2 id="why-its-hard-to-optimize-heap-queries">Why it’s hard to optimize Heap queries</h2>
<p>We want the querying experience within Heap to feel interactive, so we need most queries to return in just a few seconds. There are multiple reasons why this is particularly difficult to do with Heap queries, but the most important one is that Heap’s query builder allows customers to issue a wide variety of queries:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/query-builder.png" alt="heap&amp;rsquo;s query builder"/></p>
<p>As you can see, we support filters, group bys, and comparing different groups of users and time periods. While using these features may only result in a small change to the SQL, it can have a big impact on performance.</p>
<p>Here’s a recent example of this.</p>
<p>One of our customers created a query that typically hits one of <a href="https://www.philosophicalhacker.com/blog/running-10-million-postgresql-indexes-in-production">the millions of indexes we have across our cluster</a>. More specifically, the query resulted in an index-only scan, a special kind of (speedy!) operation in which the database can satisfy a query with <em>just</em> the information that’s in the index, without having to read the table’s actual rows.</p>
<p>Then the user made a slight modification to their query by changing a simple value in a dropdown:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/change_dropdown.gif" alt="changing dropdown value"/></p>
<p>This change resulted in <a href="https://www.philosophicalhacker.com/blog/when-the-postgres-planner-is-not-very-smart">SQL that could not use an index-only scan</a>, which made the query take much longer to execute.</p>
<p>Because of the wide variety of questions customers want to ask about their data, we have many examples like this. This means that when we’re assessing the performance of a set of queries that support a new feature within Heap, we can’t simply tweak some SQL, look at a few query plans from <code>EXPLAIN ANALYZE</code>, and call it a day. There may be a small, but common tweak to the query we’ve optimized that could tank the overall performance of the query. (This has happened to us multiple times.)</p>
<p>Here’s a histogram of some of our queries that helps show the variability of performance:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/query-perf-variability.png" alt="histogram showing distribution of query performance"/></p>
<h2 id="experiments-to-optimize-sql">Experiments to optimize SQL</h2>
<p>One of the things we do to combat this variability issue is to construct 95% confidence intervals around our estimates of performance. These confidence intervals help us identify the range of plausible values our p90 may take once we launch a new Heap query for all of our customers. This range takes into account the variability we introduce into our query performance by supporting a wide variety of ways customers can tweak and/or slice and dice their data.</p>
<p>We typically visualize new Heap query performance like this:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/confidence-interval.png" alt="confidence interval for p90, p70, and p50 for new query"/></p>
<p>The width of the confidence bounds helps us see how much query performance could vary across all our customers and across all the various tweaks they make to their queries.</p>
<p>To test if a SQL change makes a query faster, we first generate experimental and control SQL for a few hundred Heap queries, which are stored as JSON. Then, for each JSON query, we generate the control SQL and the experimental SQL that we hope will improve performance.</p>
<p>Next, we run the queries in counterbalanced order, alternating which SQL statement gets run first for a particular JSON query. For example, given JSON queries A and B, we’d run our queries in the following order:</p>
<ol>
<li>Control SQL for Query A</li>
<li>Experimental SQL for Query A</li>
<li>Experimental SQL for Query B</li>
<li>Control SQL for Query B</li>
</ol>
<p>We do this control for the effect of caching. If experimental SQL is always run after the control SQL for all queries, the experimental SQL may look faster merely because those queries benefit from caching.</p>
<p>Why run experimental and control SQL on the same queries instead of a true experiment where we randomly assign queries to experimental and control groups? Because of the variability of query performance, a randomized experiment would require us to have a large sample of queries, which slows down the speed with which we can conduct experiments and puts additional load on our systems.</p>
<p>Once we’ve executed these queries, we plot the performance estimates with confidence intervals of the experimental and control queries.</p>
<p>The plot looks like this:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/experimental-query-perf.png" alt="experimental vs. control query performance"/></p>
<p>If the confidence intervals of the queries don’t overlap (as in the above picture), we can have some confidence that we’ve actually improved performance with our tweak.</p>
<p>Here’s a recap of the above process as a sequence diagram:</p>
<p><img src="https://www.philosophicalhacker.com/post/optimizing-postgres-queries-at-scale/perf-rig-sequence-diag.png" alt="sequence diagram recap"/></p>
<p>If you like nerding out about Postgres performance, @-me on Twitter <a href="https://twitter.com/philosohacker" target="_blank">@philosohacker</a>, and if you like working on large data systems, we’re hiring! Check out <a href="https://www.philosophicalhacker.com/careers/departments/engineering-product-and-design/team">our team</a> and <a href="https://www.philosophicalhacker.com/careers/departments/engineering-product-and-design?team=engineering">open roles</a>.</p>
<p><em>I’d like to thank John Krauss for his help with reviewing early drafts of this post.</em></p>
</article></div>
  </body>
</html>
