<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://memgraph.com/blog/how-to-build-a-graph-visualization-engine-and-why-you-shouldnt">Original</a>
    <h1>How to build a graph visualization engine</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>Building something from scratch is rarely a good idea. Especially in the rich world of web technologies full of solutions for problems we didn’t even know existed. In our first iteration of Memgraph Lab, we did just that - we used Vis.js for our graph visualization engine. But that solution turned into a nightmare because the library was deprecated and didn’t allow multithreading. User experience (UX) was a disaster since rendering a large graph would block the entire application. You can read about our troubles <a href="https://memgraph.com/blog/you-want-a-fast-easy-to-use-and-popular-graph-visualization-tool">here</a>. So this time around, in our pursuit to create the go-to interactive graph development environment, we made the difficult decision to create our own library - Orb. Let us take you on the journey of how we did it, along with the challenges that we faced.</p>
<p>First, we’ll cover the general architecture of the library - how Orb handles data structures and different views, and how we organized our developer API through events and callbacks.</p>
<p>Then, we’ll take a deeper dive into the simulator engine - how the resulting graph layout calculations are performed using <code>d3-force</code> in parallel through WebWorkers.</p>
<p>After that, we’ll touch upon the HTML5 Canvas rendering engine - how to optimize it and how we structured it so you can easily add your own views.</p>
<p>And finally, how to neatly package everything together using TypeScript and Webpack.</p>
<h2>Orb structure</h2>
<p>In the image below you can see the high-level architecture of the Orb. There are three main parts that we’ll dig deeper into - Data (modal), View, and Events.</p>
<p><img src="https://assets.website-files.com/6141c89a3874c3702674a1c0/6322dc47a63de56cbf206b62_memgraph-orb-architecture-visual.png" alt="image alt"/></p>
<h3><strong>Orb Data</strong></h3>
<p>Orb Data is actually an in-memory graph data structure defined by nodes and edges connecting those nodes. It contains all the information about each node and edge:</p>
<ul>
<li>User-defined information upon node/edge creation: Any property node/edge has is available in other Orb components (views, events).</li>
<li>Style information: Size, color, width, background image, and so on. You can define a default style for the whole graph and set up specific style properties for each node/edge.</li>
<li>Graph context information: Each edge will link to the start and end node it connects, and each node will link to inbound and outbound edges as well as adjacent nodes.</li>
<li>State information: Indicates if a node/edge is selected, hovered, or none of those.</li>
<li>Graph topology information: Depending on how many edges there are between two nodes, each edge will be specified with an edge line type to avoid overlapping: straight, curved, or circular line (connecting the same node).
Check the example below to see how edge line type changes depending on the number of edges between the nodes:</li>
</ul>
<p><img src="https://assets.website-files.com/6141c89a3874c3702674a1c0/6322dc47a63de5a631206b61_orb-edge-topology.png" alt="image alt"/></p>
<p>The example below first initializes a graph with three nodes and two edges. Then an additional edge is merged into the existing graph. Lastly, a node is removed from the graph by its unique ID:</p>
<pre><code><span>const</span> nodes = [
  { <span>id</span>: <span>1</span>, <span>label</span>: <span>&#39;Orb&#39;</span> },
  { <span>id</span>: <span>2</span>, <span>label</span>: <span>&#39;Graph&#39;</span> },
  { <span>id</span>: <span>3</span>, <span>label</span>: <span>&#39;Canvas&#39;</span> },
];
<span>const</span> edges = [
  { <span>id</span>: <span>1</span>, <span>start</span>: <span>1</span>, <span>end</span>: <span>2</span>, <span>label</span>: <span>&#39;DRAWS&#39;</span> },
  { <span>id</span>: <span>2</span>, <span>start</span>: <span>2</span>, <span>end</span>: <span>3</span>, <span>label</span>: <span>&#39;ON&#39;</span> },
];

orb.data.setup({ nodes, edges });

<span>const</span> newEdges = [
  { <span>id</span>: <span>3</span>, <span>start</span>: <span>1</span>, <span>end</span>: <span>2</span>, <span>label</span>: <span>&#39;HANDLES&#39;</span> },
];

orb.data.merge({ <span>edges</span>: newEdges });


orb.data.remove({ <span>nodeIds</span>: [<span>3</span>] });
</code></pre>
<h3><strong>Orb View</strong></h3>
<p>Orb View is what makes a graph visible and intractable in the defined HTML container. The main purpose of the View is to do two things:</p>
<ul>
<li>Layout and position the graph - done by the <code>Simulator</code>, which uses a <a href="https://github.com/d3/d3-force">d3-force</a> library to simulate physical forces on particles. It supports the main thread simulation and offloaded simulation using WebWorkers for a performance boost.</li>
<li>Render the graph - done by the <code>Renderer</code>, which takes the graph model, and graph positions (defined by a <code>Simulator</code>) and renders the graph within the <code>&lt;canvas&gt;</code> HTML element. Currently, Orb only uses <code>CanvasRenderingContext2D</code> <code>Renderer</code>, but there is a plan to add support for the <code>WebGL</code> <code>Renderer</code> too.</li>
</ul>
<p>In the image below, you can see a snippet of the <a href="https://playground.memgraph.com/sandbox/pandora-papers">Pandora Papers dataset</a> rendered with the default Orb’s view:</p>
<p><img src="https://assets.website-files.com/6141c89a3874c3702674a1c0/6322dc47a63de522f5206b63_orb-view-example.png" alt="image alt"/></p>
<h3><strong>Orb Events</strong></h3>
<p>Orb Events is an implementation of the in-browser <code>EventEmitter</code> that offers several events (e.g. node/edge clicked, render started/ended, node dragged, etc.). You can subscribe to those events and do any action on top of them. A full list of events that the Orb emits can be found <a href="https://github.com/memgraph/orb/blob/main/docs/events.md">here</a>.</p>
<p>The example below shows how to subscribe to a node click event. If a node is clicked on, a message is printed out in the console and the node’s title is expanded by the string “- Clicked!”:</p>
<pre><code>orb.events.on(<span>&#39;node-click&#39;</span>, (event) =&gt; {
  <span>console</span>.log(<span>&#39;Node is clicked: &#39;</span>, event.node);
  node.data.title = <span>`<span>${node.data.title}</span> - Clicked!`</span>
});
</code></pre>
<h2>Offloading graph position computation with WebWorkers</h2>
<p>One of the key requirements of the library is that the computation of positions is done in a separate thread. Otherwise, the computationally expensive operations would block the main thread and severely impact the user experience.</p>
<p>For WebWorkers to actually work, it’s critical that the most computationally expensive operations do not depend on the DOM (Document Object Model). This is a limitation of WebWorkers, as they do not have access to the browser <code>window</code> reference, so any library with that dependency will not work with WebWorkers.</p>
<p>In our scenario, the expensive operations are physics simulations - algorithms that stabilize the graph to produce the final layout. The rendering part is done relatively quickly. From an architectural point of view, it’s important that the simulation library is separate from the rendering library.</p>
<p>This is why we chose the <code>d3-force</code> library, which is a part of the D3.js. In the Benchmarking blog post we explained our decision-making process in detail.</p>
<h3>WebWorkers</h3>
<p>We won’t go in-depth on how to use WebWorkers, since there are <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">a ton of articles</a> explaining it far better than we ever could. It’s important to us that WebWorks rely on an isolated JavaScript file to execute operations in a separate thread. This thread then communicates with the main browser thread via events and messages. We use WebWorkers to offload the computationally expensive physics simulations from <code>d3-force</code> to calculate the final graph layout. These operations are pure JavaScript that don’t depend on the browser <code>window</code> reference.</p>
<p>But what happens when, for whatever reason, WebWorkers aren’t available in the host environment? In that case, we also provided a fallback implementation which is done completely in the main browser thread.</p>
<h3>Combining two words - parallel and main thread</h3>
<p>So we have 2 main contexts for our simulations - the parallel background thread context and the main thread context. In the image below, you can see how we organized the two to use the same engine to avoid code duplication and difficult maintenance.</p>
<p>First, we separated all the engine functionality into a separate entity called <code>D3SimulatorEngine</code>. This class actually implements all of the data and simulation logic using <code>d3-force</code>.</p>
<p>Then we created two classes: <code>MainThreadSimulator</code> and <code>WebWorkerSimulator</code>. Both of these classes implement a common interface called <code>ISimulator</code>. They essentially serve as a wrapper for the <code>D3SimulatorEngine</code>, which does the actual computation through <code>d3-force</code>.</p>
<p>We then expose a factory that tries to return a <code>WebWorkerSimulator</code> if possible, otherwise, it falls back to the <code>MainThreadSimulator</code>. We then communicate with the simulator through an event emitter with callbacks.</p>
<p><img src="https://assets.website-files.com/6141c89a3874c3702674a1c0/6322dc47a63de50a8e206b60_memgraph-orb-simulator-visual.png" alt="image alt"/></p>
<h2>Challenges of the canvas rendering</h2>
<p>On Orb initialization, you need to provide a container, HTML element, where Orb will create all necessary HTML elements to render various elements such as background, foreground, graph structure, shadows, etc.</p>
<p>One of the key created HTML elements is the <code>&lt;canvas&gt;</code> element. <code>Renderer</code> class creates <code>CanvasRenderingContext2D</code> which is used for <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">drawing shapes, text, images, and other objects</a>. As we used <a href="https://visjs.org/">vis.js</a> before creating Orb, credit for some of the drawing logic in Orb (shapes, arrows, curved lines) goes to the developers who created it. They did a great job, and we didn’t want to reinvent the wheel. Canvas API with <code>CanvasRenderingContext2D</code> is easy to use and offers a lot of API methods to work with, but there are a few items that we still need to optimize in the Orb, especially for rendering large graphs:</p>
<ul>
<li>Redraw only the visible section of the graph - currently, the whole graph is rerendered.</li>
<li>Group nodes and edges with equal style properties to draw them in batches with an efficient canvas pipeline (draw blue nodes first, then red nodes, etc.) - currently there is only a rule to draw selected or hovered nodes/edges last because of the transparency of other nodes/edges.</li>
<li>Add strategies in drawing text and shadows as they degrade performance considerably.</li>
<li>Add offscreen canvas to pre-render similar or repeating objects.</li>
<li>Add support for WebGL rendering.</li>
</ul>
<p>All of these are solvable to some extent. You can read more about the canvas rendering optimizations on <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas">MDN web docs</a>.</p>
<h2>Creating new custom views</h2>
<p>Currently, Orb comes with two different views to use: <code>DefaultView</code> and <code>MapView</code>. <code>DefaultView</code> is, as the name suggests, a default view where the graph is rendered on a blank canvas. <code>MapView</code>, on the other hand, renders a graph on top of the map background where each node needs to have a geo position (<code>latitude</code> and <code>longitude</code>). <code>MapView</code> uses <a href="https://leafletjs.com/">Leaflet</a> which is the leading open-source JavaScript library for interactive maps.</p>
<p>This is what it looks like to change the view to <code>MapView</code> in Orb:</p>
<pre><code>orb.setView(<span>(<span>context</span>) =&gt;</span> <span>new</span> MapView(context, {
  <span>getGeoPosition</span>: <span>(<span>node</span>) =&gt;</span> ({
    <span>lat</span>: node.data.latitude,
    <span>lng</span>: node.data.longitude,
  }),
}));
</code></pre>
<p>In the image below, you can see the result of Orb’s MapView where the graph model of capital cities is rendered on top of the map background provided by MapBox.</p>
<p><img src="https://assets.website-files.com/6141c89a3874c3702674a1c0/6322dc48a63de51b9b206b9a_orb-view-map.png" alt="image alt"/></p>
<p>The whole idea behind Orb’s views is to allow custom views. Orb is not at that stage yet, but our plan is to enable an <code>AbstractView</code> with all the Orb engines like <code>Simulator</code>, and <code>Renderer</code> where you can implement your own logic on how and where to render a graph model, e.g. rendering a graph with fixed <code>x</code> and <code>y</code> coordinates on a custom background image.</p>
<h2>Packaging</h2>
<p>Of course, none of this would matter if people weren’t able to use our library easily. We spent a great deal of time configuring Webpack and figuring out how to properly set up the package so it can be consumed in a browser context as well as in other TypeScript and JavaScript projects.</p>
<p>There are two main ways of using Orb. If you are using it in a browser environment by importing a script form <a href="https://unpkg.com/@memgraph/orb/dist/browser/orb.js">here</a>, you won’t have WebWorker support because it’s not a local script. If you’re using Orb in your JavaScript/TypeScript project through <code>npm install</code>, then you have full access to WebWorkers.</p>
<h2>Conclusion</h2>
<p>Visualizing graphs is difficult and we’ve spent a great deal of time trying to properly structure a library that can handle such a task seamlessly. Orb uses <code>d3-force</code> in the background to calculate graph layouts and does so by conveniently juggling between WebWorkers and the browser main thread behind the scenes.</p>
<p>Orb offers a flexible graph styling mechanism that allows you to decorate your graphs any way you want to. Besides the default graph layout view, Orb includes a map view, which uses Leaflet to position your nodes on a map by providing latitudes and longitudes. And if that doesn’t fit your needs, feel free to contribute and create your own custom views - it’s as easy as extending an existing one or implementing the provided interface.</p>
<p>The HTML5 Canvas rendering engine is partly derived from Vis, but we’ve left space to introduce other rendering engines such as a WebGL-based implementation in the future.</p>
<p>Feel free to check out Orb on <a href="https://github.com/memgraph/orb">GitHub</a>, give us a star, experiment, play or contribute to it! If you want to see more examples and how Orb can be used, check the blog post: <a href="https://memgraph.com/blog/visualize-graphs-in-the-browser-with-just-a-few-lines-of-the-new-orb-code">How to use Orb</a>.</p>
</div></div>
  </body>
</html>
