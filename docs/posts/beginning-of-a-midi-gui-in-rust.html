<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/beginning-rust-midi-gui/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Beginning of a MIDI GUI in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>A project I&#39;m working on (which is <em>definitely</em> not my SIGBOVIK submission for this year, and <em>definitely</em> not about computer ergonomics) requires me to use MIDI.
And to do custom handling of it.
So I need something that receives those MIDI events and handles them.</p>
<p>But... I&#39;m going to make mistakes along the way, and a terminal program isn&#39;t very interesting for a presentation.
So of course, this program <em>also</em> needs a UI.</p>
<p>This should be simple, right?
Just a little UI to show things as they come in, should be easy, yeah?</p>
<p>Hahahaha. Haha. Ha. Ha. Whoops.</p>

<p>Who am I kidding?</p>
<p>There was no plan.
I sat down with <a href="https://docs.rs/egui/latest/egui/">egui&#39;s docs</a> open in a tab and started just writing a UI.</p>
<p>After a few false starts with this—it turns out, sitting down without a plan is a recipe for not doing anything at all—I finally asked some friends to talk through it.
I had two short meetings with two different friends.
Talking it through with them forced me to figure out ahead of time <em>what</em> I wanted, which made the problems much clearer.</p>

<p>Our goal here is twofold: to provide a debug UI to show MIDI messages and connected devices, and to serve as scaffolding for future MIDI shenanigans.
A few requirements fall out of this:</p>
<ul>
<li>Display each incoming MIDI message in a list in the UI</li>
<li>Display each connected MIDI device in a list in the UI</li>
<li>Allow filtering of MIDI messages by type in the UI</li>
<li>Provide a convenient hook to add subscribers, unrelated to the UI, which receive all MIDI messages</li>
<li>Allow the subscribers to choose which device categories they receive messages from (these categories are things like &#34;piano,&#34; &#34;drums&#34;, or &#34;wind synth&#34;)</li>
<li>Dynamically detect MIDI devices, handling the attachment or removal of devices</li>
<li>Minimize duplication of responsibility (cloning data is fine, but I want one source of truth for incoming data, not multiple)</li>
</ul>
<p>Now that we have some requirements, we can think about how this would be implemented.
We&#39;ll need some sort of routing system.
And the UI will need state, which I think should be <em>separate</em> from the state of the core application which handles the routing.
That is, I want to make it so that the UI is a subscriber just like all the other subscribers are.</p>
<p>Jumping ahead a bit, here&#39;s what it looks like when two of my MIDI devices are connected, after playing a few notes.</p>
<p><img src="https://ntietz.com/images/midi-ui-1.png" alt=""/></p>

<p>The architecture has three main components: the MIDI daemon, the message subscribers, and the GUI.</p>
<p>The <em>MIDI daemon</em> is the core that handles detecting MIDI devices and sets up message routing.
This daemon owns the connections for each port, and periodically checks if devices are still connected or not.
When it detects a new device, it maps it onto a type of device (is this a piano? a drum pad? a wind synth?)
Each new device gets a listener, which will take every message and send it into the global routing.</p>
<p>The message routing and device connection handling are done in the same loop, which is <em>fine</em>—originally I was separating them, but then I measured the timing and each refresh takes under 250 microseconds.
That&#39;s more than fast enough for my purposes, and probably well within the latency requirements of most MIDI systems.</p>
<p>The next piece is <em>message subscribers</em>.
Each subscriber can specify which type of messages it wants to get, and then their logic is applied to all incoming messages.
Right now there&#39;s just the GUI subscriber and some debug subscribers, but there&#39;ll eventually be a better debug subscriber and there&#39;ll be the core handlers that this whole project is written around.
(Is this GUI part of a giant yak shave? Maaaaybeeeee.)</p>
<p>The subscribers look pretty simple.
Here&#39;s one that echoes every message it receives (where <code>dbg_recv</code> is its queue).
You just receive from the queue, then do whatever you want with that information!</p>
<pre data-lang="rust"><code data-lang="rust"><span>std::thread::spawn(</span><span>move </span><span>|| </span><span>loop </span><span>{
</span><span>    </span><span>match</span><span> dbg_recv.</span><span>recv</span><span>() {
</span><span>        </span><span>Ok</span><span>(m) </span><span>=&gt; </span><span>println!</span><span>(</span><span>&#34;debug: </span><span>{m:?}</span><span>&#34;</span><span>),
</span><span>        </span><span>Err</span><span>(err) </span><span>=&gt; </span><span>println!</span><span>(</span><span>&#34;err: </span><span>{err:?}</span><span>&#34;</span><span>),
</span><span>    }
</span><span>});
</span></code></pre>
<p>Finally we reach <em>the GUI</em>, which has its own receiver (marginally more complicated than the debug print one, but not much).
The GUI has a background thread which handles message receiving, and stores these messages into state which the GUI uses.
This is all separated out so we won&#39;t block a frame render if a message takes some time to handle.
The GUI also contains state, in two pieces: the ports and MIDI messages are shared with the background thread, so they&#39;re in an <code>Arc&lt;Mutex&gt;</code>.
And there is also the pure GUI state, like which fields are selected, which is <em>not</em> shared and is just used inside the GUI logic.</p>
<p>I think there&#39;s a rule that you can&#39;t bandy around the word &#34;architecture&#34; without drawing at least one diagram, so here&#39;s one diagram.
This is the flow of messages through the system.
Messages come in from each device, go into the daemon, then get routed to where they belong.
Ultimately, they end up stored in the GUI state for updates (by the daemon) and display (by the GUI).</p>
<p><img src="https://ntietz.com/images/midi-ui-2.png" alt=""/></p>

<p>This one&#39;s not <em>quite</em> ready to be used, but the <a href="https://git.kittencollective.com/nicole/midi-keys">code is available</a>.
In particular, the full GUI code can be found in <a href="https://git.kittencollective.com/nicole/midi-keys/src/branch/main/src/ui.rs">src/ui.rs</a>.
Here are the highlights!</p>
<p>First let&#39;s look at some of the state handling.
Here&#39;s the state for the daemon.
<code>CTM</code> is a tuple of the connection id, timestamp, and message; I abbreviate it since it&#39;s just littered all over the place.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub struct </span><span>State </span><span>{
</span><span>    </span><span>midi</span><span>: MidiInput,
</span><span>    </span><span>ports</span><span>: </span><span>Vec</span><span>&lt;MidiInputPort&gt;,
</span><span>    </span><span>connections</span><span>: HashMap&lt;</span><span>String</span><span>, MidiInputConnection&lt;(ConnectionId, Sender&lt;CTM&gt;)&gt;&gt;,
</span><span>    </span><span>conn_mapping</span><span>: HashMap&lt;ConnectionId, Category&gt;,
</span><span>
</span><span>    </span><span>message_receive</span><span>: Receiver&lt;CTM&gt;,
</span><span>    </span><span>message_send</span><span>: Sender&lt;CTM&gt;,
</span><span>
</span><span>    </span><span>ports_receive</span><span>: Receiver&lt;</span><span>Vec</span><span>&lt;MidiInputPort&gt;&gt;,
</span><span>    </span><span>ports_send</span><span>: Sender&lt;</span><span>Vec</span><span>&lt;MidiInputPort&gt;&gt;,
</span><span>}
</span></code></pre>
<p>And here&#39;s the state for the GUI.
Data that&#39;s written once or only by the GUI is in the struct directly, and anything which is shared is inside an <code>Arc&lt;Mutex&gt;</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span>/// State used to display the UI. It&#39;s intended to be shared between the
</span><span>/// renderer and the daemon which updates the state.
</span><span>#[</span><span>derive</span><span>(Clone)]
</span><span>pub struct </span><span>DisplayState </span><span>{
</span><span>    </span><span>pub </span><span>midi_input_ports</span><span>: Arc&lt;Mutex&lt;</span><span>Vec</span><span>&lt;MidiInputPort&gt;&gt;&gt;,
</span><span>    </span><span>pub </span><span>midi_messages</span><span>: Arc&lt;Mutex&lt;VecDeque&lt;CTM&gt;&gt;&gt;,
</span><span>    </span><span>pub </span><span>selected_ports</span><span>: HashMap&lt;</span><span>String</span><span>, </span><span>bool</span><span>&gt;,
</span><span>    </span><span>pub </span><span>max_messages</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>pub </span><span>only_note_on_off</span><span>: Arc&lt;AtomicBool&gt;,
</span><span>}
</span></code></pre>
<p>I&#39;m using <a href="https://github.com/emilk/egui">egui</a>, which is an immediate-mode GUI library.
That means we do things a little differently, and we build what is to be rendered on each frame instead of retaining it between frames.
It&#39;s a model which is different from things like Qt and GTK, but feels pretty intuitive to me, since it&#39;s just imperative code!</p>
<p>This comes through really clearly in the menu handling.
Here&#39;s the code for the top menu bar.
We show the top panel, and inside it we create a menu bar.
Inside that menu bar, we create menu buttons, which have an <code>if</code> statement for the click hander.</p>
<pre data-lang="rust"><code data-lang="rust"><span>egui::TopBottomPanel::top(</span><span>&#34;menu_bar_panel&#34;</span><span>).</span><span>show</span><span>(ctx, |</span><span>ui</span><span>| {
</span><span>    egui::menu::bar(ui, |</span><span>ui</span><span>| {
</span><span>        ui.</span><span>menu_button</span><span>(</span><span>&#34;File&#34;</span><span>, |</span><span>ui</span><span>| {
</span><span>            </span><span>if</span><span> ui.</span><span>button</span><span>(</span><span>&#34;Quit&#34;</span><span>).</span><span>clicked</span><span>() {
</span><span>                ctx.</span><span>send_viewport_cmd</span><span>(egui::ViewportCommand::Close);
</span><span>            }
</span><span>        });
</span><span>        ui.</span><span>menu_button</span><span>(</span><span>&#34;Help&#34;</span><span>, |</span><span>ui</span><span>| {
</span><span>            </span><span>if</span><span> ui.</span><span>button</span><span>(</span><span>&#34;About&#34;</span><span>).</span><span>clicked</span><span>() {
</span><span>                </span><span>// TODO: implement something
</span><span>            }
</span><span>        });
</span><span>    });
</span><span>});
</span></code></pre>
<p>Notice how we handle clicks on buttons.
We don&#39;t give it a callback—we just check if it&#39;s <em>currently clicked</em> and then take action from there.
This is run each frame, and it just... works.</p>
<p>After the top menu panel, we can add our left panel.</p>
<pre data-lang="rust"><code data-lang="rust"><span>egui::SidePanel::left(</span><span>&#34;instrument_panel&#34;</span><span>).</span><span>show</span><span>(ctx, |</span><span>ui</span><span>| {
</span><span>    ui.</span><span>heading</span><span>(</span><span>&#34;Connections&#34;</span><span>);
</span><span>
</span><span>    </span><span>for</span><span> port </span><span>in</span><span> ports.</span><span>iter</span><span>() {
</span><span>        </span><span>let</span><span> port_name </span><span>= </span><span>// ...snip!
</span><span>        </span><span>let</span><span> conn_id </span><span>=</span><span> port.</span><span>id</span><span>();
</span><span>
</span><span>        </span><span>let</span><span> selected </span><span>= </span><span>self</span><span>.state.selected_ports.</span><span>get</span><span>(</span><span>&amp;</span><span>conn_id).</span><span>unwrap_or</span><span>(</span><span>&amp;</span><span>false</span><span>);
</span><span>
</span><span>        </span><span>if</span><span> ui
</span><span>            .</span><span>add</span><span>(SelectableLabel::new(</span><span>*</span><span>selected, </span><span>&amp;</span><span>port_name))
</span><span>            .</span><span>clicked</span><span>()
</span><span>        {
</span><span>            </span><span>self</span><span>.state.selected_ports.</span><span>insert</span><span>(conn_id, </span><span>!</span><span>selected);
</span><span>        }
</span><span>    }
</span><span>});
</span></code></pre>
<p>Once again, we see pretty readable code—though very unfamiliar, if you&#39;re not used to immediate mode.
We add a heading inside the panel, then we iterate over the ports and for each one we render its label.
If it&#39;s selected it&#39;ll show up in a different color, and if we click on it, the state should toggle.</p>
<p>The code for displaying the messages is largely the same, and you can check it out in the repo.
It&#39;s longer, but only in tedious ways, so I&#39;m omitting it here.</p>

<p>Coming up, I&#39;m going to focus on what I set out to in the first place and <em>write the handlers</em>.
I have some fun logic to do for different MIDI messages!</p>
<p>I&#39;m also going to build another tab in this UI to show the state of those handlers.
Their logic will be... interesting... and I want to have a visual representation of it.
Both for presentation reasons, and also for debugging, so I can see what state they&#39;re in while I try to use those handlers.</p>
<p>I think the next step is... encoding bytes in base 3 or base 4, then making my handlers interpret those.
And also base 7 or 11.</p>
<p>And <em>then</em> I&#39;ll be able to learn how to use this weird program I&#39;m building.</p>
<p>Sooo this has been fun, but back to work!</p>
<hr/>
<p>Thank you to <a href="https://annahope.me/">Anya</a> and Mary for helping me think through some of the problems here, and especially Anya for all the pair programming!</p>
<hr/>





</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://ntietz.com/newsletter/">newsletter</a>. There is also an <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
