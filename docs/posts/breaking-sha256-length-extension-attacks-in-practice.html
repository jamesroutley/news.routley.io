<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kerkour.com/sha256-length-extension-attacks">Original</a>
    <h1>Breaking SHA256: length extension attacks in practice</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><a href="https://kerkour.com/fast-hashing-algorithms">Last week, we saw why SHA256 is the best hashing algorithm</a> that you can use today if you want to securely check the integrity of some data.</p>
<p>As explained, <code>SHA256</code> is preimage resistant: it&#39;s virtually impossible to find the original message <code>Message</code> for a given <code>H</code> where <code>H = SHA256(Message)</code> (given that <code>Message</code> can&#39;t be brute-forced).</p>
<p>Knowing that, you may want to implement signatures where a known message <code>Message</code> and a secret key <code>SecretKey</code> are used to compute the Signature (hash) <code>S = SHA256(SecretKey || Message)</code>, allowing only parties who know <code>SecretKey</code> to generate a valid <code>S</code>.</p>
<blockquote>
<p>|| denotes concatenation</p>
</blockquote>
<p>Hold-on!</p>
<p>Today we are going to see the major drawback of <code>SHA256</code>: its vulnerability to length extensions attacks and how to break <code>SHA256</code> based signatures in the real world.</p>
<h2 id="insecure-web-token">Insecure Web Token</h2>
<p>Let&#39;s say that you want to build your own token mechanism for your new shiny web application. Let&#39;s call this scheme <em>Insecure Web Tokens</em>, <em>IWToken</em>.</p>
<p>The protocol is simple: your web server knows a 256 bits secret key <code>SecretKey</code> that is never sent anywhere.</p>
<p>The server issues stateless <em>IWTokens</em> containing data like <code>user_id</code>, <code>role</code> (admin | user) and so on... separated by the <code>&amp;</code> character. The <code>data</code> is signed with <code>SecretKey</code> to produce the signature <code>S</code> such as <code>S = SHA256(SecretKey || data)</code>. The signature is then appended to the data, spearated by a <code>|</code> to form the <em>IWToken</em><code>IWToken = data|SHA256(SecretKey || data)</code>.</p>
<p>In practice, an <em>IWToken</em> looks like this:</p>
<pre><code>user_id=1&amp;role=user|006f9c2877a9ab19c14f103d19d9881cc41e387fa04fd7e028d9c53278c34bc2
</code></pre>
<p>The <em>IWToken</em> is sent to the clients of your web application so they can authenticate by transmitting the <em>IWToken</em> in each request, in the <code>Authorization</code> HTTP header.</p>
<p>When receiving such a request, the server checks that the <em>IWToken</em> is valid by computing <code>S2 = SHA256(SecretKey || data)</code> and verifying that <code>S2 == S</code> which avoids a database call to authenticate the request. If the signature is valid, it means that the data should have been legitimately issued by the server and can be trusted.</p>
<h2 id="attacking-sha256-signatures">Attacking SHA256 Signatures</h2>
<p>Unfortunately, <code>SHA256</code> is vulnerable to length extension attacks.</p>
<p>For a given message <code>M1</code> with its valid signature <code>S1 = SHA256(SecretKey || M1)</code>, we can generate a valid signature roughly equal to <code>S2 = SHA256(SecretKey || M1 || M2)</code> (more on that later) where <code>M2</code> is malicious data appended to <code>M1</code>, <strong>without knowing <code>SecretKey</code></strong>, only it&#39;s size.</p>
<p>In our example, we will use a 32 byte (256 bit) <code>SecretKey</code>: <code>secretsecretsecretsecretsecretse</code>. In real life, it should be generated using <code>crypto.Rand</code>.</p>
<p>In our example, for the data <code>user_id=1&amp;role=user</code> we can create an <em>IWToken</em> like <code>user_id=1&amp;role=user&amp;something=true&amp;role=admin</code> and generate a valid signature, even without knowing <code>SecretKey</code>, leading the server to accept forged data.</p>
<p>Enough for the theory. Let&#39;s dig into the code.</p>
<blockquote>
<p>All the code examples are in Go as it&#39;s certainly the easiest language to understand and provides a rich standard library with built-in cryptographic functions</p>
</blockquote>
<p>First, let&#39;s generate our legitimate signature:</p>
<pre><code>S = SHA256(secretKey || data)
SHA256(&#34;secretsecretsecretsecretsecretse&#34; || &#34;user_id=1&amp;role=user&#34;) = 5b0b4b2472778fea87faac08a72a47d24538bff9d7f19a3a85d069893e2b08ab
</code></pre>
<p>Which can be computed with the following code:</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>sign</span>(<span>secretKey</span> []<span>byte</span>, <span>data</span> []<span>byte</span>) (<span>signature</span> []<span>byte</span>) {
</span></span><span><span>	<span>hasher</span> <span>:=</span> <span>sha256</span>.<span>New</span>()
</span></span><span><span>
</span></span><span><span>	<span>hasher</span>.<span>Write</span>(<span>secretKey</span>)
</span></span><span><span>	<span>hasher</span>.<span>Write</span>(<span>data</span>)
</span></span><span><span>	<span>hash</span> <span>:=</span> <span>hasher</span>.<span>Sum</span>(<span>nil</span>)
</span></span><span><span>	<span>signature</span> = <span>hash</span>[:]
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><p><code>SHA256</code> works on blocks of 512 bits. Thus, some padding is internally needed to fill the blocks if the size of message is not an exact multiple of 512 bits.</p>
<p>As defined in <a href="https://www.rfc-editor.org/rfc/rfc6234#page-8">RFC 6234</a>, <code>SHA256</code>&#39;s padding is computed as follow:</p>
<pre><code>a. &#34;1&#34; is appended.  Example: if the original message is &#34;01010000&#34;,
      this is padded to &#34;010100001&#34;.

b. K &#34;0&#34;s are appended where K is the smallest, non-negative solution
      to the equation

         ( L + 1 + K ) mod 512 = 448

 c. Then append the 64-bit block that is L in binary representation.
      After appending this block, the length of the message will be a
      multiple of 512 bits.
</code></pre>
<p>So, if our message <code>SecretKey || Data = &#34;secretsecretsecretsecretsecretse&#34; || &#34;user_id=1&amp;role=user&#34;</code> is <code>32 + 19 = 51</code> bytes long, we need to:</p>
<p>After all these steps, the initial block looks like this:</p>
<pre><code>00000000  73 65 63 72 65 74 73 65  63 72 65 74 73 65 63 72  |secretsecretsecr|
00000010  65 74 73 65 63 72 65 74  73 65 63 72 65 74 73 65  |etsecretsecretse|
00000020  75 73 65 72 5f 69 64 3d  31 26 72 6f 6c 65 3d 75  |user_id=1&amp;role=u|
00000030  73 65 72 80 00 00 00 00  00 00 00 00 00 00 01 98  |ser.............|
</code></pre>
<p>Or in binary:</p>
<pre><code>01110011 01100101 01100011 01110010 01100101 01110100 01110011 01100101
01100011 01110010 01100101 01110100 01110011 01100101 01100011 01110010
01100101 01110100 01110011 01100101 01100011 01110010 01100101 01110100
01110011 01100101 01100011 01110010 01100101 01110100 01110011 01100101
01110101 01110011 01100101 01110010 01011111 01101001 01100100 00111101
00110001 00100110 01110010 01101111 01101100 01100101 00111101 01110101
01110011 01100101 01110010 10000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000001 10011000
</code></pre>
<p>You can play with <code>SHA256</code>&#39;s internal state at <a href="https://sha256algorithm.com">sha256algorithm.com</a></p>
<p>Why does it matters?</p>
<p>In order to create a forged signature, we will need to generate some padding so that our malicious data <code>&amp;something=true&amp;role=admin</code> is appended after this padding. Remember, our malicious message should have the form: <code>legitimateData || padding || maliciousData</code>.</p>
<p>Translating the specification above to code gives us:</p>
<pre tabindex="0"><code><span><span><span>// generatePadding generates the required padding to fill SHA256 blocks of 512 bits (64 bytes)
</span></span></span><span><span><span>// with (secretKey || data || padding)
</span></span></span><span><span><span>// The padding format is defined in RFC6234: https://www.rfc-editor.org/rfc/rfc6234#page-8
</span></span></span><span><span><span></span><span>func</span> <span>generatePadding</span>(<span>secretKeyLength</span> <span>uint64</span>, <span>legitimateDataLength</span> <span>uint64</span>) (<span>padding</span> []<span>byte</span>) {
</span></span><span><span>	<span>messageLength</span> <span>:=</span> <span>secretKeyLength</span> <span>+</span> <span>legitimateDataLength</span>
</span></span><span><span>	<span>zerosLength</span> <span>:=</span> int(<span>64</span> <span>-</span> <span>8</span> <span>-</span> <span>1</span> <span>-</span> (<span>messageLength</span> <span>%</span> <span>64</span>))
</span></span><span><span>
</span></span><span><span>	<span>padding</span> = make([]<span>byte</span>, <span>1</span><span>+</span><span>zerosLength</span><span>+</span><span>8</span>)
</span></span><span><span>
</span></span><span><span>	<span>padding</span>[<span>0</span>] = <span>0x1</span> <span>&lt;&lt;</span> <span>7</span>
</span></span><span><span>	<span>binary</span>.<span>BigEndian</span>.<span>PutUint64</span>(<span>padding</span>[<span>1</span><span>+</span><span>zerosLength</span>:], <span>messageLength</span><span>*</span><span>8</span>)
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><p>Then we can write the code to generate <code>MaliciousMessage = legitimateData || padding(secretKeyLength, legitimateDataLength) || maliciousData</code> :</p>
<pre tabindex="0"><code><span><span><span>// generateMaliciousMessage generates the malicious message used to forge a signature without knowing the
</span></span></span><span><span><span>// secretKey. The message has the following format: (legitimateData || padding || maliciousData)
</span></span></span><span><span><span></span><span>func</span> <span>generateMaliciousMessage</span>(<span>secretKeyLength</span> <span>uint64</span>, <span>legitimateData</span> []<span>byte</span>, <span>maliciousData</span> []<span>byte</span>) (<span>message</span> []<span>byte</span>) {
</span></span><span><span>	<span>padding</span> <span>:=</span> <span>generatePadding</span>(<span>secretKeyLength</span>, uint64(len(<span>legitimateData</span>)))
</span></span><span><span>	<span>message</span> = make([]<span>byte</span>, <span>0</span>, len(<span>legitimateData</span>)<span>+</span>len(<span>padding</span>)<span>+</span>len(<span>maliciousData</span>))
</span></span><span><span>
</span></span><span><span>	<span>message</span> = append(<span>message</span>, <span>legitimateData</span><span>...</span>)
</span></span><span><span>	<span>message</span> = append(<span>message</span>, <span>padding</span><span>...</span>)
</span></span><span><span>	<span>message</span> = append(<span>message</span>, <span>maliciousData</span><span>...</span>)
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><pre tabindex="0"><code><span><span><span>maliciousMessage</span> <span>:=</span> <span>generateMaliciousMessage</span>(uint64(len(<span>secretKey</span>)), <span>legitimateData</span>, <span>maliciousData</span>)
</span></span></code></pre><p>Then, we need to load <code>SHA256</code>&#39;s final state after it has computed the legitimate signature. How to find this state? It&#39;s simple, it&#39;s the actual signature  (hash): <code>5b0b4b2472778fea87faac08a72a47d24538bff9d7f19a3a85d069893e2b08ab</code>.</p>
<p>Go does not expose <code>SHA256</code>&#39;s internal state, so we need to copy the files <a href="https://github.com/golang/go/blob/master/src/crypto/sha256/sha256.go"><code>sha256.go</code></a> and <a href="https://github.com/golang/go/blob/master/src/crypto/sha256/sha256block.go"><code>sha256block.go</code></a> into our project in order to access the private struct: <code>digest</code>. You will need to modify <code>sha256.go</code> to remove the references to the internal package <code>crypto/internal/boring</code> which can&#39;t be imported, as I did here: <a href="https://github.com/skerkour/kerkour.com/blob/main/blog/2023/sha256_length_extension_attacks/sha256.go"><code>sha256.go</code></a>.</p>
<p>We can load the internal state of the hashing function with the following code which is a slightly modified version of <a href="https://github.com/golang/go/blob/master/src/crypto/sha256/sha256.go">`diget.UnmarshalBinary</a> that allow us to load the internal state from a hash:</p>
<pre tabindex="0"><code><span><span><span>// loadSha256 is a slightly modified version of digest.UnmarshalBinary in order to load the state from a
</span></span></span><span><span><span>// normal SHA256 hash instead of the &#34;proprietary version&#34; generated by digest.MarshalBinary
</span></span></span><span><span><span></span><span>func</span> <span>loadSha256</span>(<span>hashBytes</span> []<span>byte</span>, <span>secretKeyAndDataLength</span> <span>uint64</span>) (<span>hash</span> <span>*</span><span>digest</span>) {
</span></span><span><span>	<span>if</span> len(<span>hashBytes</span>) <span>!=</span> <span>sha256</span>.<span>Size</span> {
</span></span><span><span>		panic(<span>&#34;loadSha256: not a valid SHA256 hash&#34;</span>)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>hash</span> = new(<span>digest</span>)
</span></span><span><span>	<span>hash</span>.<span>Reset</span>()
</span></span><span><span>
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>0</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>1</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>2</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>3</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>4</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>5</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>hashBytes</span>, <span>hash</span>.<span>h</span>[<span>6</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>_</span>, <span>hash</span>.<span>h</span>[<span>7</span>] = <span>consumeUint32</span>(<span>hashBytes</span>)
</span></span><span><span>	<span>// hash.len is the nearest upper multiple of 64 of the length of the hashed data: len(secretKey || Data)
</span></span></span><span><span><span></span>	<span>hash</span>.<span>len</span> = <span>secretKeyAndDataLength</span> <span>+</span> <span>64</span> <span>-</span> (<span>secretKeyAndDataLength</span> <span>%</span> <span>64</span>)
</span></span><span><span>	<span>hash</span>.<span>nx</span> = int(<span>hash</span>.<span>len</span> <span>%</span> <span>chunk</span>)
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><p>Finally, we can generate a forged signature with our malicious data <code>&amp;something=true&amp;role=admin</code>:</p>
<pre tabindex="0"><code><span><span><span>hasher</span> <span>:=</span> <span>loadSha256State</span>(<span>legitimateSignature</span>)
</span></span><span><span><span>hasher</span>.<span>Write</span>(<span>maliciousData</span>)
</span></span><span><span><span>forgedSignature</span> = <span>hasher</span>.<span>Sum</span>()
</span></span></code></pre><p>Or, in code:</p>
<pre tabindex="0"><code><span><span><span>// forgeSignature performs a length extension attack by loading a SHA256 hash from the legitimate signature
</span></span></span><span><span><span>// and appending the malicious data.
</span></span></span><span><span><span></span><span>func</span> <span>forgeSignature</span>(<span>legitimateSignature</span> []<span>byte</span>, <span>maliciousData</span> []<span>byte</span>, <span>secretKeyAndDataLength</span> <span>uint64</span>) (<span>forgedSignature</span> []<span>byte</span>) {
</span></span><span><span>	<span>digest</span> <span>:=</span> <span>loadSha256</span>(<span>legitimateSignature</span>, <span>secretKeyAndDataLength</span>)
</span></span><span><span>
</span></span><span><span>	<span>digest</span>.<span>Write</span>(<span>maliciousData</span>)
</span></span><span><span>	<span>hash</span> <span>:=</span> <span>digest</span>.<span>Sum</span>(<span>nil</span>)
</span></span><span><span>	<span>forgedSignature</span> = <span>hash</span>[:]
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><pre tabindex="0"><code><span><span><span>maliciousSignature</span> <span>:=</span> <span>forgeSignature</span>(<span>legitimateSignature</span>, <span>maliciousData</span>, uint64(len(<span>secretKey</span>)<span>+</span>len(<span>legitimateData</span>)))
</span></span></code></pre><p>We can verify that the forged signature is valid with:</p>
<pre tabindex="0"><code><span><span><span>// verifySignature verifies that Signature == SHA256(secretKey || data)
</span></span></span><span><span><span></span><span>func</span> <span>verifySignature</span>(<span>secretKey</span> []<span>byte</span>, <span>signatureToVerify</span> []<span>byte</span>, <span>data</span> []<span>byte</span>) (<span>isValid</span> <span>bool</span>) {
</span></span><span><span>	<span>isValid</span> = <span>false</span>
</span></span><span><span>	<span>signature</span> <span>:=</span> <span>sign</span>(<span>secretKey</span>, <span>data</span>)
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>subtle</span>.<span>ConstantTimeCompare</span>(<span>signature</span>, <span>signatureToVerify</span>) <span>==</span> <span>1</span> {
</span></span><span><span>		<span>isValid</span> = <span>true</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span>
</span></span><span><span>}
</span></span></code></pre><pre tabindex="0"><code><span><span><span>fmt</span>.<span>Printf</span>(<span>&#34;Verify MaliciousSignature(LegitimateSignature, MaliciousData) == SHA256(SecretKey, MaliciousMessage): %v\n&#34;</span>, <span>verifySignature</span>(<span>secretKey</span>, <span>maliciousSignature</span>, <span>maliciousMessage</span>))
</span></span></code></pre><pre><code>Verify MaliciousSignature(LegitimateSignature, MaliciousData) == SHA256(SecretKey, MaliciousMessage): true
</code></pre>
<p>Putting it all together:</p>
<ol>
<li>We generated a malicious message <code>MaliciousMessage = LegitimateData || padding(SecretKeyLength, LegitimateDataLength) || MaliciousData</code></li>
<li>Loaded the legitimate signature&#39;s state <code>SHA256(SecretKey || LegitimateData)</code> and appended our <code>MaliciousData</code></li>
<li>Which allowed us to generate a <code>MaliciousSignature</code> that will return <code>true</code> for <code>MaliciousSignature(LegitimateSignature, MaliciousData) == SHA256(SecretKey, MaliciousMessage)</code>.</li>
</ol>
<p>You can run <a href="https://github.com/skerkour/kerkour.com/tree/main/blog/2023/sha256_length_extension_attacks">the code</a>:</p>
<pre><code>$ go run ./
SecretKey: 7365637265747365637265747365637265747365637265747365637265747365
Legitimate Data: user_id=1&amp;role=user
Legitimate Signature SHA256(SecretKey || LegitimateData): 5b0b4b2472778fea87faac08a72a47d24538bff9d7f19a3a85d069893e2b08ab
Verify LegitimateSignature == SHA256(SecretKey || LegitimateData): true

---------------------------------------------------------------------------------------------------

Malicious Data: &amp;something=true&amp;role=admin
Malicious Message (LegitimateData || padding || MaliciousData):
00000000  75 73 65 72 5f 69 64 3d  31 26 72 6f 6c 65 3d 75  |user_id=1&amp;role=u|
00000010  73 65 72 80 00 00 00 00  00 00 00 00 00 00 01 98  |ser.............|
00000020  26 73 6f 6d 65 74 68 69  6e 67 3d 74 72 75 65 26  |&amp;something=true&amp;|
00000030  72 6f 6c 65 3d 61 64 6d  69 6e                    |role=admin|

Malicious Signature: 8c37e11e8397b39cba72fa0e4769716c69a7ba9e29cfaf00d4601e086e85dd8f
Verify MaliciousSignature == SHA256(SecretKey, MaliciousMessage): true
</code></pre>
<p>In other words, the <em>IWToken</em> <code>user_id=1&amp;role=user\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x98&amp;something=true&amp;role=admin|8c37e11e8397b39cba72fa0e4769716c69a7ba9e29cfaf00d4601e086e85dd8f</code> is verified as valid by the server.</p>
<h2 id="some-closing-thoughts">Some Closing Thoughts</h2>
<p>You should NEVER use <code>SHA256</code> (or <code>SHA1</code> or <code>SHA512</code> which are also vulnerable) as a MAC to authenticate a message such as <code>Signature = (secret || message)</code>. <code>Signature = (message || secret)</code> may be safe in certain circumstances, but you should also AVOID IT!</p>
<p>Instead you should use the <code>HMAC-SHA256</code> construction which is secure and widely used like in the <a href="https://signal.org/docs/specifications/doubleratchet/">Signal Protocol</a> or in <a href="https://jwt.io">JSON Web Tokens</a>.</p>
<p>As always, you can find the code on GitHub: <a href="https://github.com/skerkour/kerkour.com/tree/main/blog/2023/sha256_length_extension_attacks">github.com/skerkour/kerkour.com</a> (please don&#39;t forget to star the repo 🙏).</p>
<p>As an exercise, you can modify the code to bruteforce the length of the secret instead of having it hardcoded (hint: it&#39;s only a matter of finding the right padding size).</p>

  </div></div>
  </body>
</html>
