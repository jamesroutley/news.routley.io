<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/Dev-Notes/LeetCode-Journal/Valid-Parentheses">Original</a>
    <h1>Valid Parentheses</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p><a href="https://leetcode.com/problems/valid-parentheses/">Valid parantheses challenge<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>// identify opening brackets</span></span>
<span data-line=""><span>// let opening = &#39;[{(&#39;</span></span>
<span data-line=""><span>// save them in an ordered list</span></span>
<span data-line=""><span>// identify closing brackets</span></span>
<span data-line=""><span>// let = &#39;)}]&#39;</span></span>
<span data-line=""><span>// As closing brackets come up, check if the last item in the opening brackets list matches</span></span>
<span data-line=""><span>// if it doesn&#39;t (provided we add opening brackets to list before closing brackets), return false</span></span>
<span data-line=""><span>// if it does, remove that opening from the list, we&#39;re good.</span></span>
<span data-line=""><span>// so for like, &#39;[[}]&#39;, if we do that process, we 1) add a [ to openings, add another [ to openings, check if } is the last item in openings,</span></span>
<span data-line=""><span>// And find it ISN&#39;T, so we exit. Nice.</span></span>
<span data-line=""><span>// Let&#39;s try {[]{}}. We add { to the openings array, [ too, then check if ] type bracket is the --</span></span>
<span data-line=""><span>// Okay so little detail here, we need a mapping of openings &#39;]&#39;:&#39;[&#39;, etc. We use that to check, I didn&#39;t mention that.</span></span>
<span data-line=""><span>// So given that, we check if &#39;]&#39;&#39;s mapping is the last item int he opening list, and we find it is, we can maybe pop it off</span></span>
<span data-line=""><span>// For brevity, next character we have &#39;{&#39;, that&#39;s an opening, so we add it to openings, then we have &#39;}&#39;, we check the mapping of &#39;}&#39;, which is &#39;{&#39; against</span></span>
<span data-line=""><span>// The last opening,</span></span>
<span data-line=""><span>// It&#39;s be 33% of the alloted time, I think we&#39;re good</span></span>
<span data-line=""><span>// And we find that they correspond, same shit, we remove that last opening from the list. We should be left with an opening list of just { now, which gets resolved with the last process.</span></span>
<span data-line=""><span>// Okay I feel great about that.</span></span>
<span data-line=""><span>// I am gonna go back and just reread the problem and see if I have all the requirements correct.</span></span>
<span data-line=""><span>// Okay sweet, looks like s consists only of paren characters, no characters etc.</span></span>
<span data-line=""><span>// I think I addressed it, but the trickiest rule is that &#34;open brackets must be closed in the correct order&#34;</span></span>
<span data-line=""><span>// Yeah, I think that&#39;s working. Let me just spam some edge cases over the next minute before I get started</span></span>
<span data-line=""><span>// &#34;[[[[[[[[[]]]]]]]]]&#34;, &#34;}&#34;</span></span>
<span data-line=""><span>// Ooh there&#39;s one - what if we START with an open bracket?</span></span>
<span data-line=""><span>// So like, yeah, I just need to make sure I handle that -</span></span>
<span data-line=""><span>// If I try to check the &#34;openings&#34; and it&#39;s empty, we&#39;re done - I have to return false</span></span>
<span data-line=""><span>// Okay that was fruitful. Let me try a few more &#39;]}]&#39; isn&#39;t really different</span></span>
<span data-line=""><span>// &#39;{[{[&#39; okay so this has no closings. I ALSO need to make sure THIS returns false,</span></span>
<span data-line=""><span>// And I think I truly may have missed this case</span></span>
<span data-line=""><span>// I guess it was implied that I have a hanging return true at the end, but what I really have to do is check to make sure that the &#34;openings&#34; array gets completely emptied</span></span>
<span data-line=""><span>// And only return true if it does.</span></span>
<span data-line=""><span>// Okay crap, 50% done with time. Let&#39;s give this a shot</span></span>
<span data-line=""><span>  // One more weird case - what about an empty string? I don&#39;t have to worry about it because the string has at least one character</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// oh my godddddd</span></span>
<span data-line=""><span>// okay ten minutes to go. I got this.</span></span></code></pre></figure>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValid</span><span>(</span><span>str</span><span>){</span></span>
<span data-line=""><span>  if</span><span> (str.</span><span>length</span><span> &lt;</span><span> 1</span><span>){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>&#34;based on my understanding of requirements, this should not have happened: case A&#34;</span><span>)</span></span>
<span data-line=""><span>     return</span><span> false</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  let</span><span> openChars </span><span>=</span><span> &#39;[{(&#39;</span></span>
<span data-line=""><span>  let</span><span> closeChars </span><span>=</span><span> &#39;]})&#39;</span></span>
<span data-line=""><span>  let</span><span> openings </span><span>=</span><span> []</span></span>
<span data-line=""><span>  let</span><span> key </span><span>=</span><span> {</span></span>
<span data-line=""><span>    &#39;}&#39;</span><span>: </span><span>&#39;{&#39;</span><span>,</span></span>
<span data-line=""><span>    &#39;]&#39;</span><span>: </span><span>&#39;[&#39;</span><span>,</span></span>
<span data-line=""><span>    &#39;)&#39;</span><span>: </span><span>&#39;(&#39;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> str){</span></span>
<span data-line=""><span>    if</span><span> (openChars.</span><span>includes</span><span>(char) ){</span></span>
<span data-line=""><span>      openings.</span><span>push</span><span>(char)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (closeChars.</span><span>includes</span><span>(char)){</span></span>
<span data-line=""><span>      let</span><span> lastOpen </span><span>=</span><span> openings[openings.</span><span>length</span><span> -</span><span> 1</span><span>]</span></span>
<span data-line=""><span>      if</span><span> (lastOpen </span><span>!==</span><span> key[char]) </span><span>return</span><span> false</span></span>
<span data-line=""><span>      openings.</span><span>pop</span><span>() </span><span>// lastOpen DOES === the current char, so we can get rid of that opener and continue</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(openings)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  if</span><span> (openings.</span><span>length</span><span>){</span></span>
<span data-line=""><span>      return</span><span> false</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> true</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>

<p>I finished with 2.5 minutes to go and got a function that worked first try, which I feel really good about! I think that spending 15 minutes to calmly work through edge cases worked really really well. Normally I just start coding as think, and maybe this is more efficient in some ways —</p>
<p>I guess to be fair, I DID code some things as I went, which I think is a good idea.</p>
<p>Something I didn’t do is have a section in my leetcode that was actionable notes, which might have helped with organization.</p>
<p>I also think I did a good job of going with an available working solution instead of an eloquent solution. 30 minutes <em>really</em> isn’t much time.</p>

<p>I asked Claude how I could have improved things, and he suggested using Sets instead of strings, and using Maps instead of normal js objects. Those make sense and would be a great way to flex my understanding of these data sets (dishonestly, as I don’t use these too often at the moment), but don’t really seem that important.</p>
<p>What I did like was checking for even or odd numbered inputs for early returns.</p>
<p>He also suggested checking for closing brackets first…dont’ totally understand this approach:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> s){</span></span>
<span data-line=""><span>	if</span><span> (bracketMap.</span><span>has</span><span>(char)){</span></span>
<span data-line=""><span>		if</span><span> (openings.</span><span>pop</span><span>() </span><span>!==</span><span> bracketMap.</span><span>get</span><span>(char)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""><span>	} </span><span>else</span><span> {</span></span>
<span data-line=""><span>		openings.</span><span>push</span><span>(char);</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>This switch statement suggestion is really interesting though:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> s){</span></span>
<span data-line=""><span>	switch</span><span>(char)</span></span>
<span data-line=""><span>		{ </span><span>case</span><span> &#39;(&#39;</span><span>: </span><span>case</span><span> &#39;{&#39;</span><span>: </span><span>case</span><span> &#39;[&#39;</span><span>:</span></span>
<span data-line=""><span>			openings.</span><span>push</span><span>(char);</span></span>
<span data-line=""><span>			break</span><span>;</span></span>
<span data-line=""><span>		case</span><span> &#39;)&#39;</span><span>: </span><span>case</span><span> &#39;}&#39;</span><span>: </span><span>case</span><span> &#39;]&#39;</span><span>:</span></span>
<span data-line=""><span>			if</span><span> (openings.</span><span>pop</span><span>() </span><span>!==</span><span> bracketMap.</span><span>get</span><span>(char)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""><span>			break</span><span>;</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""><span>}</span></span></code></pre></figure></article><hr/></div></div></div>
  </body>
</html>
