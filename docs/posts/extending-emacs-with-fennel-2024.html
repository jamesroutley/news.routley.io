<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreyor.st/posts/2024-12-20-extending-emacs-with-fennel/">Original</a>
    <h1>Extending Emacs with Fennel (2024)</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>After watching this year’s EmacsConf and seeing Guile Emacs being resurrected I thought to myself - why limit ourselves to Guile?
Sure, Guile isn’t just a Scheme implementation, thanks to its compiler-tower-based design.
Other languages exist for Guile VM, such as Emacs Lisp, and Guile manual lists the following languages with various stages of completeness:</p>
<ul>
<li>ECMAScript</li>
<li>Brainfuck</li>
<li>Lua</li>
<li>Ruby</li>
<li>Python</li>
</ul>
<p>Sure, it would be nice, if Emacs could natively run all of these, but we have to understand, that Guile Lua is not PUC Lua.
Even LuaJIT has difficulties maintaining full compatibility with modern releases of Lua, having us stuck in the realm somewhere between Lua 5.1 and 5.2, while PUC Lua is already 5.4.
Future releases would bring more differences, making PUC Lua and Luajit diverge even more.</p>
<p>And Lua is a <em>simple</em> language, unlike something like JS, Ruby, or Python.
So I wouldn’t bet on the fact that Guile Ruby would be exactly the same as Ruby.
Maybe it will, but it’ll probably take years.</p>
<p>So I thought, why not just use Lua as is?
The only thing we can’t do is to run Fennel functions from Emacs Lisp.
There were <a href="https://github.com/edrx/emlua" target="_blank">attempts at bringing Lua VM into Emacs</a>, running in the same process, however, as I know, it isn’t stable enough.</p>
<p>However, Emacs can connect to a Fennel REPL, like it does for many other languages, such as Common Lisp or Clojure.
Sure, the language is running in a separate process, and this comes with a lot of nuances, but it’s still a possible route.</p>
<p>So I made a small package: <a href="https://github.com/andreyorst/require-fennel.el" target="_blank">require-fennel.el</a>.
It’s capable of loading Fennel (or Lua) modules, and defining a set of functions on the Emacs side for every Fennel function in the module.</p>
<h2 id="running-fennel-from-emacs-lisp">Running Fennel from Emacs Lisp</h2>
<p>For example, we can load Fennel itself into Emacs like this:</p>
<p>Now we have all sorts of functions available, for example, here’s <code>fennel.eval</code>:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>fennel.eval</span> <span>&#34;(fcollect [i 1 10] (* i i))&#34;</span>)
</span></span><span><span><span>;; =&gt; [1 4 9 16 25 36 49 64 81 100]</span>
</span></span></code></pre></div><p>Or, we can create a file <code>greet.fnl</code>:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>greet</span> [<span>name</span>]
</span></span><span><span>  <span>&#34;Greets NAME with a message.&#34;</span>
</span></span><span><span>  (<span>print </span>(<span>.. </span><span>&#34;Hello, &#34;</span> <span>name</span> <span>&#34; from Fennel!&#34;</span>)))
</span></span></code></pre></div><p>and load it:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require-fennel</span> <span>greet</span>)
</span></span><span><span>
</span></span><span><span>(<span>greet</span> <span>&#34;Andrey&#34;</span>)
</span></span><span><span>(<span>require-fennel</span> <span>foo</span>)
</span></span><span><span>(<span>require-fennel</span> <span>vec-add</span>)
</span></span></code></pre></div><p><span>Code Snippet 1:</span>
  &#34;Hello, Andrey from Fennel!&#34; will be displayed in the echo area of Emacs
</p>
<p>Let’s ask Emacs to describe the <code>greet</code> function:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>greet is a interpreted-function.
</span></span><span><span>
</span></span><span><span>(greet NAME)
</span></span><span><span>
</span></span><span><span>Greets NAME with a message.
</span></span></code></pre></div><p>As can be seen, Emacs can show us the function signature and its documentation string obtained from Fennel.</p>
<p>Unlike Emacs Lisp, Fennel functions support destructuring with special syntax based on how data literals are written in Fennel.
For example, let’s create a function that accepts a map, and destructures its keys:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>foo</span> [{<span>:x</span> <span>x</span> <span>:y</span> <span>y</span>}]
</span></span><span><span>  <span>&#34;Accepts a map with the X and Y keys, and adds them together.&#34;</span>
</span></span><span><span>  (<span>+ </span><span>x</span> <span>y</span>))
</span></span></code></pre></div><p>After loading it in Emacs we’ll see the following documentation:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>foo is a interpreted-function.
</span></span><span><span>
</span></span><span><span>(foo ((:y . y) (:x . x)))
</span></span><span><span>
</span></span><span><span>Accepts a map with the X and Y keys, and adds them together.
</span></span></code></pre></div><p>I took some creative liberties and made it so Fennel hash tables are represented as association lists in Emacs Lisp.
So the <code>((:x . 1) (:y . 2))</code> in Elisp is equal to <code>{:x 1 :y 2}</code> in Fennel.
The argument list on the Emacs Lisp side is a bit unconventional, but I think that’s OK.</p>
<p>The same goes for vector destructuring:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>vec-add</span> [[<span>x0</span> <span>y0</span>] [<span>x1</span> <span>y1</span>]]
</span></span><span><span>  <span>&#34;Adds two 2D vectors.&#34;</span>
</span></span><span><span>  [(<span>+ </span><span>x0</span> <span>x1</span>) (<span>+ </span><span>y0</span> <span>y1</span>)])
</span></span></code></pre></div><p>Emacs’ documentation uses lists:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>vec-add is a interpreted-function.
</span></span><span><span>
</span></span><span><span>(vec-add (X0 y0) (X1 y1))
</span></span><span><span>
</span></span><span><span>Adds two 2D vectors.
</span></span></code></pre></div><p>I couldn’t make it work with vectors for some reason, and as can be seen, Emacs tries to upcase parameters, but it doesn’t recognize that <code>y0</code> is also a parameter.
Probably fine, as such documentation would never be generated for Emacs Lisp functions.</p>
<p>We can call such a function with both vectors and lists:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>vec-add</span> [1 2] [1 2])   <span>;=&gt; [2 4]</span>
</span></span><span><span>(<span>vec-add</span> &#39;(1 2) &#39;(1 2)) <span>;=&gt; [2 4]</span>
</span></span></code></pre></div><p>That’s because Fennel doesn’t have a list datatype, it only has associative and sequential tables.
Thus I’m using Elisp vectors as the result type.</p>
<h3 id="data-conversion">Data conversion</h3>
<p>Here’s how conversion table when passing data from Elisp to Fennel:</p>
<table>
<thead>
<tr>
<th>Elisp</th>
<th>Fennel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[1 2 3]</code></td>
<td><code>[1 2 3]</code></td>
</tr>
<tr>
<td><code>(1 2 3)</code></td>
<td><code>[1 2 3]</code></td>
</tr>
<tr>
<td><code>((:foo . 1) (:bar . 2))</code></td>
<td><code>{:foo 1 :bar 2}</code></td>
</tr>
<tr>
<td><code>#s(hash-table test equal data (&#34;foo&#34; 1 &#34;bar&#34; 2))</code></td>
<td><code>{:foo 1 :bar 2}</code></td>
</tr>
<tr>
<td><code>:foo</code></td>
<td><code>&#34;foo&#34;</code></td>
</tr>
<tr>
<td><code>&#39;false</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>&#34;foo&#34;</code></td>
<td><code>&#34;foo&#34;</code></td>
</tr>
</tbody>
</table>
<p>And here’s the conversion table when receiving data from Fennel in Emacs:</p>
<table>
<thead>
<tr>
<th>Fennel</th>
<th>Elisp</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[1 2 3]</code></td>
<td><code>[1 2 3]</code></td>
</tr>
<tr>
<td><code>{:foo 1 :bar 2}</code></td>
<td><code>((:foo . 1) (:bar . 2))</code></td>
</tr>
<tr>
<td><code>(values 1 2 3)</code></td>
<td><code>(1 2 3)</code></td>
</tr>
<tr>
<td><code>(fn [])</code></td>
<td><code>(lambda (&amp;rest args) ...)</code></td>
</tr>
<tr>
<td><code>userdata</code></td>
<td><code>#&lt;udata: 0x55b66bd6ac28&gt;</code></td>
</tr>
<tr>
<td><code>true</code></td>
<td><code>t</code></td>
</tr>
<tr>
<td><code>nil</code>, <code>false</code></td>
<td><code>nil</code></td>
</tr>
</tbody>
</table>
<p>A small note about hash tables and multiple value returns.
As can be seen, both are returned as lists.
I specifically chose the cons notation for association lists, i.e. <code>(a . b)</code> because this way we can tell apart hash tables and mustivalues.
There are no cons cells in Fennel, so no other data structure will be represented like that.</p>
<p>Because multiple values are returned as lists, we have to call apply, if we wish to compose two Fennel functions.
In other words, in Fennel we can do this:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>rest</span> [<span>_</span> <span>...</span>] <span>...</span>)
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>first</span> [<span>x</span> <span>_</span>] <span>x</span>)
</span></span><span><span>
</span></span><span><span>(<span>first</span> (<span>rest</span> 1 2 3)) <span>;=&gt; 2</span>
</span></span><span><span>
</span></span><span><span>{<span>: </span><span>first</span> <span>: </span><span>rest</span>}
</span></span></code></pre></div><p><span>Code Snippet 2:</span>
  <code>fr.fnl</code>
</p>
<p>In Elisp, however, we would have to do:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require-fennel</span> <span>fr</span>)
</span></span><span><span>
</span></span><span><span>(<span>apply</span> <span>#&#39;</span><span>fr.first</span> (<span>fr.rest</span> 1 2 3)) <span>;=&gt; 2</span>
</span></span></code></pre></div><p>If we were to call it as <code>(fr.first (fr.rest 1 2 3))</code> the result would be <code>[2 3]</code>, because <code>fr.rest</code> returned a list of return values, and lists are converted to vectors or hash maps depending on their structure.</p>
<p>That’s the basic gist of this package.</p>
<h3 id="more-examples">More examples</h3>
<p>After implementing it I was like a kid in a toy store.
With a childish grin, I started loading all my crazy Fennel libraries that I made over the years.</p>
<p>For example, here’s <code>cljlib</code>:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require-fennel</span> <span>cljlib</span>)
</span></span><span><span>
</span></span><span><span>(<span>cljlib.conj</span> [1] 2) <span>;=&gt; [1 2]</span>
</span></span></code></pre></div><p>Or, here’s a JSON parser I made:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require</span> <span>fennel</span> <span>json</span>)
</span></span><span><span>
</span></span><span><span>(<span>json.decode</span> <span>&#34;{\&#34;foo\&#34;: [1, 2, 3]}&#34;</span>)
</span></span><span><span><span>;; ((&#34;foo&#34; . [1 2 3]))</span>
</span></span><span><span>
</span></span><span><span>(<span>json.encode</span> &#39;((<span>&#34;foo&#34;</span> . [1 2 3])))
</span></span><span><span><span>;; &#34;{\&#34;foo\&#34;: [1, 2, 3]}&#34;</span>
</span></span></code></pre></div><p>Here’s a crazy one - I’m loading my Fennel port of a Clojure library clj-http into Emacs, and calling it from Elisp:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>require-fennel</span> <span>io.gitlab.andreyorst.fnl-http</span>)
</span></span><span><span>(<span>require-fennel</span> <span>io.gitlab.andreyorst.fnl-http.client</span> <span>:as</span> <span>client</span>) <span>; nested module</span>
</span></span><span><span>
</span></span><span><span>(<span>client.get</span> <span>&#34;http://httpbin.org/get&#34;</span> &#39;((<span>:as</span> . <span>:json</span>)))
</span></span><span><span>
</span></span><span><span><span>;; =&gt; ((&#34;headers&#34; . ((&#34;Content-Length&#34; . &#34;198&#34;)</span>
</span></span><span><span><span>;;                   (&#34;Access-Control-Allow-Credentials&#34; . t)</span>
</span></span><span><span><span>;;                   (&#34;Access-Control-Allow-Origin&#34; . &#34;*&#34;)</span>
</span></span><span><span><span>;;                   (&#34;Content-Type&#34; . &#34;application/json&#34;)</span>
</span></span><span><span><span>;;                   (&#34;Connection&#34; . &#34;keep-alive&#34;)</span>
</span></span><span><span><span>;;                   (&#34;Server&#34; . &#34;gunicorn/19.9.0&#34;)</span>
</span></span><span><span><span>;;                   (&#34;Date&#34; . &#34;Mon, 16 Dec 2024 22:56:35 GMT&#34;)))</span>
</span></span><span><span><span>;;     (&#34;reason-phrase&#34; . &#34;OK&#34;)</span>
</span></span><span><span><span>;;     (&#34;length&#34; . 198)</span>
</span></span><span><span><span>;;     (&#34;protocol-version&#34; . ((&#34;name&#34; . &#34;HTTP&#34;)</span>
</span></span><span><span><span>;;                            (&#34;minor&#34; . 1)</span>
</span></span><span><span><span>;;                            (&#34;major&#34; . 1)))</span>
</span></span><span><span><span>;;     (&#34;request-time&#34; . 214)</span>
</span></span><span><span><span>;;     (&#34;trace-redirects&#34; . [])</span>
</span></span><span><span><span>;;     (&#34;status&#34; . 200)</span>
</span></span><span><span><span>;;     (&#34;body&#34; . ((&#34;args&#34; . [])</span>
</span></span><span><span><span>;;                (&#34;headers&#34; . ((&#34;Host&#34; . &#34;httpbin.org&#34;)</span>
</span></span><span><span><span>;;                              (&#34;X-Amzn-Trace-Id&#34; . &#34;Root=1-6760b023-39ca8e413573df5d14d09486&#34;)))</span>
</span></span><span><span><span>;;                (&#34;url&#34; . &#34;http://httpbin.org/get&#34;))))</span>
</span></span></code></pre></div><p><span>Code Snippet 3:</span>
  I&#39;ve formatted nested alists to use dot notation for better reading clarity. In other words changed <code>(a (b . c) (d . e))</code> into <code>(a . ((b . c) (d . e)))</code> which are the same thing.
</p>
<p>The client made an HTTP request from the Fennel side and passed the response back to Emacs.
The response body was in JSON, but specifying <code>((:as . :json))</code> as options map forced parsing the response body into Fennel tables.
Which, upon arriving in Emacs Lisp were converted into association lists.</p>
<p>So now we can call Fennel from Elisp.
But why stop there?
Let’s call Emacs Lisp from Fennel!</p>
<h2 id="running-elisp-from-fennel-dot-dot">Running ELisp from Fennel?..</h2>
<p>Since this package uses the <a href="https://andreyor.st/posts/2023-03-25-implementing-a-protocol-based-fennel-repl-and-emacs-client/">Fennel Proto REPL</a>, which is a custom protocol that can be extended at runtime, we can create a set of functions that will allow us to call back to Elisp.
Here’s how we extend the protocol:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>let </span>[<span>format-elisp</span> <span>_G.___repl___.pp</span>]
</span></span><span><span>  (<span>protocol.env-set!</span>
</span></span><span><span>   <span>:emacs</span> {<span>:call</span> (<span>-&gt;&gt; </span>{<span>:__index</span>
</span></span><span><span>                       (<span>fn </span>[<span>_</span> <span>k</span>]
</span></span><span><span>                         (<span>fn </span>[<span>...</span>]
</span></span><span><span>                           (<span>protocol.message</span>
</span></span><span><span>                            [[<span>:id</span> {<span>:sym</span> <span>protocol.id</span>}]
</span></span><span><span>                             [<span>:op</span> {<span>:string</span> <span>:require-fennel/call</span>}]
</span></span><span><span>                             [<span>:fun</span> {<span>:sym</span> <span>k</span>}]
</span></span><span><span>                             [<span>:arguments</span> {<span>:list</span> (<span>fcollect</span> [<span>n</span> 1 (<span>select </span><span>&#34;#&#34;</span> <span>...</span>)]
</span></span><span><span>                                                  (<span>format-elisp</span> (<span>pick-values </span>1 (<span>select </span><span>n</span> <span>...</span>))))}]])
</span></span><span><span>                           (<span>. </span>(<span>protocol.receive</span>) <span>:data</span>)))}
</span></span><span><span>                      (<span>setmetatable </span>{}))
</span></span><span><span>           <span>:var</span> (<span>-&gt;&gt; </span>{<span>:__index</span>
</span></span><span><span>                      (<span>fn </span>[<span>_</span> <span>k</span>]
</span></span><span><span>                        (<span>protocol.message</span> [[<span>:id</span> {<span>:sym</span> <span>protocol.id</span>}]
</span></span><span><span>                                           [<span>:op</span> {<span>:string</span> <span>:require-fennel/var</span>}]
</span></span><span><span>                                           [<span>:var</span> {<span>:sym</span> <span>k</span>}]])
</span></span><span><span>                        (<span>. </span>(<span>protocol.receive</span>) <span>:data</span>))}
</span></span><span><span>                     (<span>setmetatable </span>{}))
</span></span><span><span>           <span>:eval</span> (<span>fn </span>[<span>expr</span>]
</span></span><span><span>                   (<span>protocol.message</span> [[<span>:id</span> {<span>:sym</span> <span>protocol.id</span>}]
</span></span><span><span>                                      [<span>:op</span> {<span>:string</span> <span>:require-fennel/eval</span>}]
</span></span><span><span>                                      [<span>:expr</span> {<span>:sym</span> <span>expr</span>}]])
</span></span><span><span>                   (<span>. </span>(<span>protocol.receive</span>) <span>:data</span>))})
</span></span><span><span>  {<span>:id</span> 1000 <span>:nop</span> <span>&#34;&#34;</span>})
</span></span></code></pre></div><p>I had to update the protocol core a bit, adding the <code>protocol.env-set!</code> and <code>protocol.receive</code> functions.
The <code>env-set!</code> allows us to create user-visible definitions.
So we add the <code>emacs</code> table that holds three fields.</p>
<p>The <code>call</code> field is a table with some metatable trickery.
Since it’s an empty table, any key would trigger the <code>__index</code> metamethod.
This metamethod can be another table or a function - in our case, it is the latter.
This function returns a handler that calls into <code>protocol.message</code> that sends a custom OP <code>require-fennel/call</code> that we can handle in our package.</p>
<p>The same goes for the <code>var</code> field, except it doesn’t return a function, it just returns a value.</p>
<p>The last field, <code>eval</code>, is a combination of both, kinda.
It is a function, not a table, and it accepts one argument - an expression to evaluate in Emacs.</p>
<p>However, we can’t use these just yet.
The second part of the trick comes from the new ability to extend the main protocol handler with custom handlers:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>cl-defgeneric</span> <span>fennel-proto-repl-handle-custom-op</span> (<span>_op</span> <span>_message</span> <span>_callbacks</span>)
</span></span><span><span>  <span>&#34;Handler for a custom protocol OP.
</span></span></span><span><span><span>The first argument OP is used for dispatching.  Accepts the whole
</span></span></span><span><span><span>MESSAGE, and its CALLBACKS.  The default implementation of unknown OP is
</span></span></span><span><span><span>a nop.&#34;</span>
</span></span><span><span>  <span>nil</span>)
</span></span></code></pre></div><p>With this generic function, we can define new handlers in separate packages.
These are the methods I’ve added in <code>require-fennel.el</code>:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span>(<span>cl-defmethod</span> <span>fennel-proto-repl-handle-custom-op</span> ((<span>op</span> (<span>eql</span> <span>:require-fennel/call</span>)) <span>message</span> <span>callbacks</span>)
</span></span><span><span>  <span>&#34;Custom handler for the require-fennel/call OP.
</span></span></span><span><span><span>Accepts a MESSAGE and its CALLBACKS.
</span></span></span><span><span><span>The MESSAGE contains a function to evaluate and its arguments.&#34;</span>
</span></span><span><span>  (<span>fennel-proto-repl-send-message</span>
</span></span><span><span>   <span>nil</span>
</span></span><span><span>   (<span>format</span> <span>&#34;{:id %s :data %s}&#34;</span>
</span></span><span><span>           (<span>plist-get</span> <span>message</span> <span>:id</span>)
</span></span><span><span>           (<span>apply</span> (<span>plist-get</span> <span>message</span> <span>:fun</span>) (<span>plist-get</span> <span>message</span> <span>:arguments</span>)))
</span></span><span><span>   <span>nil</span>))
</span></span><span><span>
</span></span><span><span>(<span>cl-defmethod</span> <span>fennel-proto-repl-handle-custom-op</span> ((<span>op</span> (<span>eql</span> <span>:require-fennel/var</span>)) <span>message</span> <span>callbacks</span>)
</span></span><span><span>  <span>&#34;Custom handler for the require-fennel/var OP.
</span></span></span><span><span><span>Accepts a MESSAGE and its CALLBACKS.
</span></span></span><span><span><span>The MESSAGE contains a var which value is then returned to Fennel.&#34;</span>
</span></span><span><span>  (<span>fennel-proto-repl-send-message</span>
</span></span><span><span>   <span>nil</span>
</span></span><span><span>   (<span>format</span> <span>&#34;{:id %s :data %s}&#34;</span>
</span></span><span><span>           (<span>plist-get</span> <span>message</span> <span>:id</span>)
</span></span><span><span>           (<span>require-fennel--elisp-to-fennel</span> (<span>eval</span> (<span>plist-get</span> <span>message</span> <span>:var</span>))))
</span></span><span><span>   <span>nil</span>))
</span></span><span><span>
</span></span><span><span>(<span>cl-defmethod</span> <span>fennel-proto-repl-handle-custom-op</span> ((<span>op</span> (<span>eql</span> <span>:require-fennel/eval</span>)) <span>message</span> <span>callbacks</span>)
</span></span><span><span>  <span>&#34;Custom handler for the require-fennel/var OP.
</span></span></span><span><span><span>Accepts a MESSAGE and its CALLBACKS.
</span></span></span><span><span><span>The MESSAGE contains an expression which is evaluated and its result is returned to Fennel.&#34;</span>
</span></span><span><span>  (<span>fennel-proto-repl-send-message</span>
</span></span><span><span>   <span>nil</span>
</span></span><span><span>   (<span>format</span> <span>&#34;{:id %s :data %s}&#34;</span>
</span></span><span><span>           (<span>plist-get</span> <span>message</span> <span>:id</span>)
</span></span><span><span>           (<span>require-fennel--elisp-to-fennel</span> (<span>eval</span> (<span>plist-get</span> <span>message</span> <span>:expr</span>))))
</span></span><span><span>   <span>nil</span>))
</span></span></code></pre></div><p>These three fields and methods allow us to do anything with Emacs, and it happens in the same process, so we can access the full Emacs state.
For example:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; Welcome to Fennel Proto REPL 0.6.0</span>
</span></span><span><span><span>;; Fennel version: 1.5.1-dev</span>
</span></span><span><span><span>;; Lua version: PUC Lua 5.4</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>emacs.call.emacs-uptime</span>)
</span></span><span><span><span>&#34;19 minutes, 17 seconds&#34;</span>
</span></span><span><span><span>&gt;&gt;</span> <span>emacs.var.emacs-version</span>
</span></span><span><span><span>&#34;31.0.50&#34;</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>emacs.eval</span> <span>&#34;(with-current-buffer \&#34; *fennel-elisp*\&#34; (buffer-substring-no-properties (point-min) (point-max)))&#34;</span>)
</span></span><span><span><span>&#34;;; Welcome to Fennel Proto REPL 0.6.0
</span></span></span><span><span><span>;; Fennel version: 1.5.1-dev
</span></span></span><span><span><span>;; Lua version: PUC Lua 5.4
</span></span></span><span><span><span>&gt;&gt; (emacs.call.emacs-uptime)
</span></span></span><span><span><span>\&#34;19 minutes, 17 seconds\&#34;
</span></span></span><span><span><span>&gt;&gt; emacs.var.emacs-version
</span></span></span><span><span><span>\&#34;31.0.50\&#34;
</span></span></span><span><span><span>&gt;&gt; (emacs.eval \&#34;(with-current-buffer \\\&#34; *fennel-elisp*\\\&#34; (buffer-substring-no-properties (point-min) (point-max)))\&#34;)
</span></span></span><span><span><span>&gt;&gt; &#34;</span>
</span></span><span><span><span>&gt;&gt;</span>
</span></span></code></pre></div><p>Crazy!</p>
<h2 id="fennelmacs">Fennelmacs</h2>
<p>So now we can write Fennel scripts that can obtain data from Emacs, process it, and pass back the results.
Thus, our goal is achieved - we’ve added a second language to Emacs!</p>
<p>Of course, it’s not the same as what Guile Emacs does.
We’re still running code in a separate process, adding communication between the two via some protocol.
It’s a neat trick, nothing more.
Guile Emacs, if it ever becomes the thing, will be more powerful, as we would be able to leverage all these different languages in the same process, possibly sharing the memory, calling functions interchangeably, etc.
Some may even write Emacs packages in Brainfuck, who knows.</p>
<p>Still, this is really cool, in my opinion, and shows the power of Emacs pretty well.
If you’re into Fennel, like me, I hope you’ll enjoy using this package as I enjoyed making it.
See you at <a href="https://conf.fennel-lang.org/2024" target="_blank">Fennel Conf</a>!</p>

  </article></div>
  </body>
</html>
