<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/a-terminal-case-of-linux">Original</a>
    <h1>A terminal case of Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  
    
      
    
  

  <p>Has this ever happened to <em>you</em>?</p>
<p>You want to look at a JSON file in your terminal, so you pipe it into
<a href="https://stedolan.github.io/jq/">jq</a> so you can look at it with colors and
stuff.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/cat-jq.eb4a6ea757f8c916.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/cat-jq.d257aa1a44603b3e.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/cat-jq.75e9bcfb326911fb.jpg" title="" alt=""/>
            </picture>
            
<p>...oh hey cool bear. No warm-up today huh.</p>
<p>Sure, fine, okay, I&#39;ll read the darn man page for <code>jq</code>... okay it takes
a &#34;filter&#34; and then some files. And the filter we want is.. <code>.</code> which, just
like files, means &#34;the current thing&#34;:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-without-cat.4ec808fb6a810c58.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-without-cat.8862e03c9c7a773c.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/jq-without-cat.f4305d7594c44b12.jpg" title="" alt=""/>
            </picture>
            
<p>There! Now you have pretty colors! But say your JSON file is actually quite
large, and it doesn&#39;t fit in your terminal window, so you want to use a pager,
maybe something like <a href="https://manpage.me/?q=less">less</a>.</p>
<p>Well, showing a <code>less</code> invocation is actually quite annoying, so instead we&#39;ll
just use <code>cat</code> instead.</p>

<p>Yes, bear, again. I know how you feel about cats, in fact you&#39;re <a href="https://www.quora.com/From-an-evolutionary-perspective-are-bears-closer-to-dogs-or-cats">closer to
dogs</a>,
but please bea... please let me continue.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-cat.5f9d90033f520919.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-cat.7bb81dd87734c9cc.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/jq-cat.4e17ac0cd22dac97.jpg" title="" alt=""/>
            </picture>
            
<p>Now the pretty colors are all gone!</p>
<p>Of course, we can force <code>jq</code> to output colors anyway, with <code>-C</code> (short for
<code>--color-output</code>):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-color-cat.055cf958f8cdf599.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/jq-color-cat.3c3b257a2a026c9c.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/jq-color-cat.94da5821dac6842d.jpg" title="" alt=""/>
            </picture>
            
<p>But something is afoot.</p>
<p>And it&#39;s not just <code>jq</code>! <code>ls</code> even starts separating items with newlines:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/ls.68cbeeeba40db508.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/ls.febea9213e47c4c5.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/ls.677b14d1fc8edc1b.jpg" title="" alt=""/>
            </picture>
            
<p>We can &#34;fix&#34; it with <code>--color=always</code>, but yeah. There&#39;s definitely some
detection going on there too.</p>
<p>Also, if we pipe <code>ls --color=always</code> to <code>less</code>, we see strange markings!</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/strange-markings.92dbfaf1b10225a8.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/strange-markings.5698feca12a6376c.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/strange-markings.bc6b928dc1bff4f5.jpg" title="" alt=""/>
            </picture>
            
<p>If we want to see color in <code>less</code>, we need to use the <code>-R</code> (short for
<code>--RAW-CONTROL-CHARS</code> — yes, really).</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/less-raw.d817f621d1acebdf.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/less-raw.2c180f125d0be773.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/less-raw.f73b8d4167bb5174.jpg" title="" alt=""/>
            </picture>
            
<p>In fact... let me try something:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/save-colors-to-file.b39409ddb6ab8856.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/save-colors-to-file.6765cbf66c99852f.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/save-colors-to-file.041cc50ddfa893e8.jpg" title="" alt=""/>
            </picture>
            
<p>AhAH! We can save colors to a file and print them later - and our friend
<a href="https://manpage.me/?q=xxd">xxd</a> the hex dumper shows us that the colors are
really part of the output. </p>
<div>

<p>So far, we know three things. On Linux,</p>
<ul>
<li>Colors are part of the output, they&#39;re <a href="https://en.wikipedia.org/wiki/Out-of-band_data">in-band</a></li>
<li>Some programs stop outputting color when their output is redirected</li>
<li>There&#39;s usually a way to force them to output color anyway, but
it&#39;s a per-program setting (there&#39;s <a href="https://unix.stackexchange.com/questions/5949/is-there-any-env-variable-to-turn-color-and-the-like-on-for-all-commands">no standard</a>)</li>
</ul>
</div>

                        <h2>
                            <a id="but-enough-about-shells" href="#but-enough-about-shells">
                                But enough about shells
                            </a>
                        </h2>
                        
<p>So far we&#39;ve been running commands from
<a href="https://en.wikipedia.org/wiki/Z_shell">zsh</a>, because that&#39;s the shell I dislike
the least right now.</p>
<p>But what if we execute commands from another program? Like, a Rust program?</p>
<p>Let&#39;s try doing that:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo new terminus
     Created binary (application) `terminus` package
$ cd terminus/
</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>
<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> process<i>::</i>Command<i>}</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> out = <i>{</i>
        <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i>
            <i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i>
            <i>.</i><i>output</i><i>(</i><i>)</i>
            <i>.</i><i>map</i><i>(</i>|s| <i>String</i><i>::</i><i>from_utf8</i><i>(</i>s<i>.</i><i>stdout</i><i>)</i><i>)</i>??
    <i>}</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, out<i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div>

<p>What, no fancy crates today?</p>
</div>

<p>Now, if we run this, we can see...</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/rust-nocolor.719c036fc98ce8e0.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/rust-nocolor.698a74a4cb78d047.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/rust-nocolor.8999699fb00d4e2f.jpg" title="" alt=""/>
            </picture>
            
<p>No colors.</p>

<div>

<p>That&#39;s just cargo&#39;s output — we could suppress it with <code>--quiet</code> (or <code>-q</code> for
short) .</p>
</div>
<div>

<p>Ahhh, the output of <em>ls</em> doesn&#39;t have colors. And it should have like,
blue for <code>src</code> and <code>target</code>, given that they&#39;re directories.</p>
</div>

<p>So! <code>ls</code> knows its output is being redirected somewhere, and it doesn&#39;t print
colors. Even when we execute it from a Rust program.</p>
<p>But how? We could look at the source code for <code>ls</code>. That would be fun — I&#39;ve
never done that!</p>
<p>Luckily, there&#39;s a <a href="https://github.com/coreutils/coreutils">GitHub mirror for
coreutils</a>, so it&#39;s not too hard to
find.</p>
<p>In <code>ls.c</code>, in the the <code>decode_switches</code> function, we can find a switch inside
of a <code>while(true)</code> loop, that seems to process command-line arguments.</p>
<p>Here for example, it enables &#34;human-friendly output&#34;:</p>
<div translate="no"><p>C code</p><pre data-lang="c"><i>// in `coreutils/src/ls.c`</i>
        <i>case</i> &#39;h&#39;:
          <i>file_human_output_opts</i> <i>=</i> <i>human_output_opts</i> <i>=</i>
            <i>human_autoscale</i> | <i>human_SI</i> | <i>human_base_1024</i>;
          <i>file_output_block_size</i> <i>=</i> <i>output_block_size</i> <i>=</i> 1;
          <i>break</i>;
</pre></div>
<p>And.. here&#39;s the <code>--color</code> switch:</p>
<div translate="no"><p>C code</p><pre data-lang="c"><i>// in `coreutils/src/ls.c`</i>
       <i>case</i> <i>COLOR_OPTION</i>:
          {
            <i>int</i> <i>i</i>;
            <i>if</i> (<i>optarg</i>)
              <i>i</i> <i>=</i> <i>XARGMATCH</i> (<i>&#34;--color&#34;</i>, <i>optarg</i>, <i>when_args</i>, <i>when_types</i>);
            <i>else</i>
              <i>/* Using --color with no argument is equivalent to using
                 --color=always.  */</i>
              <i>i</i> <i>=</i> <i>when_always</i>;

            <i>print_with_color</i> <i>=</i> (<i>i</i> <i>==</i> <i>when_always</i>
                                <i>||</i> (<i>i</i> <i>==</i> <i>when_if_tty</i> <i>&amp;&amp;</i> <i>stdout_isatty</i> ()));
            <i>break</i>;
          }
</pre></div>
<p>Ah! <code>print_with_color</code> is set to a truthy value if:</p>
<ul>
<li><code>--color=always</code> is passed (we knew that), or</li>
<li><code>--color=auto</code> is passed <em>and</em> <code>stdout_isatty()</code> returns true</li>
</ul>
<p>And here&#39;s the code for <code>stdout_isatty()</code>:</p>
<div translate="no"><p>C code</p><pre data-lang="c"><i>// in `coreutils/src/ls.c`</i>

<i>/* Return true if standard output is a tty, caching the result.  */</i>

<i>static</i> <i>bool</i>
<i>stdout_isatty</i> (<i>void</i>)
{
  <i>static</i> <i>signed <i>char</i></i> <i>out_tty</i> <i>=</i> -1;
  <i>if</i> (<i>out_tty</i> <i>&lt;</i> 0)
    <i>out_tty</i> <i>=</i> <i>isatty</i> (<i>STDOUT_FILENO</i>);
  <i>assume</i> (<i>out_tty</i> <i>==</i> 0 <i>||</i> <i>out_tty</i> <i>==</i> 1);
  <i>return</i> <i>out_tty</i>;
}
</pre></div><div>

<p>Look at that, it&#39;s even doing <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>!</p>
<p>Initially, the value of <code>out_tty</code> is -1, but it persists across function calls
(because it&#39;s <code>static</code>), so after the first call returns, it&#39;ll be <code>0</code> or <code>1</code>,
depending what <code>isatty</code> returns.</p>
</div>
<p>Mhh, <code>isatty</code>, we can probably call that from Rust, right?</p>
<p>Feels like a <code>libc</code> function... ah yep here&#39;s a <a href="https://manpage.me/?q=isatty">man page</a>:</p>
<blockquote>
<h3>DESCRIPTION</h3>
<p>These functions operate on file descriptors for terminal type devices.</p>
<p>The <code>isatty()</code> function determines if the file descriptor fd refers to a
valid terminal type device.</p>
<p>The <code>ttyname()</code> function gets the related device name of a file descriptor
for which isatty() is true.</p>
<p>The <code>ttyname()</code> function returns the name stored in a static buffer which
will be overwritten on subsequent calls. The <code>ttyname_r()</code> function takes
a buffer and length as arguments to avoid this problem.</p>
</blockquote>
<p>Okay okay, how do we call libc functions... uhh well we know the Rust standard
library relies on libc for a bunch of things, so surely we already link against
it...</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ ldd ./target/debug/terminus
        linux-vdso.so.1 (0x00007ffd7cf69000)
        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f4e15280000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4e1525d000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4e15257000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4e15065000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f4e15302000)
</pre></div>
<p>Yes we do! That&#39;s <code>libc.so.6</code> in the list, which should have <code>isatty</code>... </p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep -E &#39;isatty|ttyname&#39;
00000000001324d0 T __ttyname_r_chk
0000000000112cc0 W isatty
0000000000112580 T ttyname
0000000000112900 W ttyname_r
</pre></div>
<p>Yes! Although, uh, <code>isatty</code> is a <a href="https://en.wikipedia.org/wiki/Weak_symbol">weak symbol</a>.</p>
<p>Anyway. If we define <code>isatty</code> in an <code>extern &#34;C&#34;</code> block, we <em>should</em> be able to
call it.</p>
<div>

<p>Call it but... with what?</p>
</div>
<div>

<div>
<p>Well it takes an <code>int fd</code>, which is a file descriptor. Typically, we have:</p>
<ul>
<li>0 for stdin (standard input)</li>
<li>1 for stdout (standard output)</li>
<li>2 for stderr (standard error)</li>
</ul>
</div>
</div>

<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> os<i>::</i>raw<i>::</i>c_int<i>}</i><i>;</i>

<i>extern</i> <i>&#34;C&#34;</i> <i>{</i>
    <i>fn</i> <i>isatty</i><i>(</i><i>fd</i><i>:</i> <i>c_int</i><i>)</i> -&gt; <i>c_int</i><i>;</i>
<i>}</i>

<i>const</i> STDOUT<i>:</i> <i>c_int</i> = <i>1</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> stdout_is_tty = <i>unsafe</i> <i>{</i> <i>isatty</i><i>(</i>STDOUT<i>)</i> <i>}</i> == <i>1</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>stdout_is_tty<i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build --quiet
$ ./target/debug/terminus
[src/main.rs:11] stdout_is_tty = true
$ ./target/debug/terminus | cat
[src/main.rs:11] stdout_is_tty = false
</pre></div>
<p>So <em>that&#39;s</em> how they do it!</p>
<p>Okay so there&#39;s two ways we can go from here: we can go lower-level, or we can
go higher-level.</p>

                        <h2>
                            <a id="a-little-assembly-as-a-treat" href="#a-little-assembly-as-a-treat">
                                A little assembly, as a treat
                            </a>
                        </h2>
                        
<p>Let&#39;s first dig down: <em>how does isatty even work</em>. We give it a file descriptor,
literally just &#34;the integer value one&#34;, and it tells us if it&#39;s a terminal or
not.</p>
<p>But libc is just, you know, a big flaming ball of C code. There&#39;s no reason for
it to have any extra powers — there&#39;s programs that don&#39;t use libc at all, and
they&#39;re still able to tell whether or not a file descriptor is a terminal.</p>
<p>Which is to say, <em>libc is not in charge of file descriptors</em>. The kernel is.</p>
<p>And we know one way userland applications (like ours) can talk to the Linux
kernel is by <a href="https://dave.is/series/reading-files-the-hard-way/part-2">performing a syscall</a>.</p>
<p>So... is it making a syscall? Let&#39;s ask our friend
<a href="https://en.wikipedia.org/wiki/Strace">strace</a> the... ostrich? (No, for real,
click that link).</p>
<p>We&#39;ll change our <code>main</code> function to look like this:</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;calling isatty...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stdout_is_tty = <i>unsafe</i> <i>{</i> <i>isatty</i><i>(</i>STDOUT<i>)</i> <i>}</i> == <i>1</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;calling isatty... done!&#34;</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>stdout_is_tty<i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div>
<p>...just so it&#39;s easier to pinpoint the moment we call <code>isatty</code>:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build --quiet
$ strace -o /tmp/strace.log -- ./target/debug/terminus
calling isatty...
calling isatty... done!
[src/main.rs:13] stdout_is_tty = true

$ cat /tmp/strace.log | grep &#39;calling isatty... done&#39; -B 2
write(1, &#34;calling isatty...\n&#34;, 18)     = 18
ioctl(1, TCGETS, {B38400 opost isig icanon echo ...}) = 0
write(1, &#34;calling isatty... done!\n&#34;, 24) = 24
</pre></div><div>

<p>That&#39;s another useless use of cat!</p>
</div>

<div translate="no"><p>Shell session</p><pre data-lang="shell">$ grep &#39;calling isatty... done&#39; -B 2 /tmp/strace.log
write(1, &#34;calling isatty...\n&#34;, 18)     = 18
ioctl(1, TCGETS, {B38400 opost isig icanon echo ...}) = 0
write(1, &#34;calling isatty... done!\n&#34;, 24) = 24
</pre></div>
<p>The original output is a <em>lot</em> so I used a well-placed <code>grep</code> to whittle it down
to something reasonable. </p>
<p>Okay, so it <em>is</em> making a syscall. Our <code>println!</code> and <code>dbg!</code> macros end up being
<code>write</code> syscalls, which take three arguments: the file descriptor, the data, and
the length.</p>
<div>

<p>Oooh it&#39;s writing to file descriptor 1! That&#39;s the standard output!</p>
</div>

<p>And it&#39;s doing a syscall to <code>ioctl</code>! Also passing file descriptor 1.</p>
<p>Which returns... 0. That&#39;s kernel for <a href="https://en.wikipedia.org/wiki/Borat">great success!</a></p>
<p>However, if we redirect <code>terminus</code>&#39;s output:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ strace -o /tmp/strace.log -- ./target/debug/terminus &gt; /dev/null
[src/main.rs:13] stdout_is_tty = false

$ grep &#39;calling isatty... done&#39; -B 2 /tmp/strace.log
write(1, &#34;calling isatty...\n&#34;, 18)     = 18
ioctl(1, TCGETS, 0x7ffe0d358c30)        = -1 ENOTTY (Inappropriate ioctl for device)
write(1, &#34;calling isatty... done!\n&#34;, 24) = 24
</pre></div>
<p>Then it returns <code>-1</code>, which strace helpfully translates to <code>ENOTTY</code>, ie. &#34;error
not a TTY&#34;.</p>
<p>So that means... we can make that syscall ourselves!</p>
<div>

<p>Yeah! Who needs libc? Not us!</p>
</div>
<p>We will, however, need the unstable <a href="https://doc.rust-lang.org/beta/unstable-book/library-features/asm.html#guide-level-explanation">asm
feature</a>.</p>
<p>No problem! We can switch to the nightly channel:</p>
<div translate="no"><p>TOML markup</p><pre data-lang="toml"><i># in `terminus/rust-toolchain.toml`</i>
<i>[</i><i>toolchain</i><i>]</i>
<i>channel</i> <i>=</i> <i>&#34;nightly-2021-09-23&#34;</i>
</pre></div>
<p>If you&#39;re using <a href="https://rustup.rs/">rustup</a> to manage Rust versions, now, all
cargo commands in the <code>terminus/</code> folder should use that nightly version. Neat!</p>
<div>

<p>Why pin to a specific nightly instead of just doing <code>channel = &#34;nightly&#34;</code> (which
would install the latest nightly)?</p>
<p>Well, in nightly Rust <em>anything can change</em>. And in case you&#39;re reading this
article from The Future, it&#39;s very possible that your nightly will behave
differently.</p>
<p>So, for this article, we&#39;re using that specific nightly. Upgrade at your own
risk.</p>
</div>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>#!<i>[</i>feature<i>(</i>asm<i>)</i><i>]</i></i>

<i>use</i> std<i>::</i>error<i>::</i>Error<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>// on Linux x86_64, everything is an `u64`.</i>
    <i>const</i> STDOUT<i>:</i> <i>u64</i> = <i>1</i><i>;</i>

    <i>// found in linux/source/include/uapi/asm-generic/ioctls.h</i>
    <i>const</i> TCGETS<i>:</i> <i>u64</i> = <i>0x5401</i><i>;</i>

    <i>// let&#39;s go ahead and guess that whatever &#34;TCGETS&#34; is getting</i>
    <i>// doesn&#39;t take more than 32KiB.</i>
    <i>const</i> GENEROUS_BUFFER_SIZE<i>:</i> <i>usize</i> = <i>32</i> <i>*</i> <i>1024</i><i>;</i>
    <i>let</i> <i>mut</i> mysterious_buffer = <i>vec</i><i>!</i><i>[</i><i>0u8</i>; GENEROUS_BUFFER_SIZE<i>]</i><i>;</i>

    <i>// okay, here we gooo</i>
    <i>let</i> ret = <i>unsafe</i> <i>{</i> <i>ioctl</i><i>(</i>STDOUT<i>,</i> TCGETS<i>,</i> mysterious_buffer<i>.</i><i>as_mut_ptr</i><i>(</i><i>)</i><i>)</i> <i>}</i><i>;</i>

    <i>// phew, we made it.</i>
    <i>dbg</i><i>!</i><i>(</i>ret<i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>

<i>unsafe</i> <i>fn</i> <i>ioctl</i><i>(</i><i>fd</i><i>:</i> <i>u64</i><i>,</i> <i>cmd</i><i>:</i> <i>u64</i><i>,</i> <i>arg</i><i>:</i> <i>*</i><i>mut</i> <i>u8</i><i>)</i> -&gt; <i>i64</i> <i>{</i>
    <i>let</i> syscall_number<i>:</i> <i>u64</i> = <i>16</i><i>;</i>
    <i>let</i> ret<i>:</i> <i>u64</i><i>;</i>
    <i>asm</i><i>!</i><i>(</i>
        <i>&#34;syscall&#34;</i>,
        inout<i>(</i><i>&#34;rax&#34;</i><i>)</i> syscall_number =&gt; ret,
        in<i>(</i><i>&#34;rdi&#34;</i><i>)</i> fd,
        in<i>(</i><i>&#34;rsi&#34;</i><i>)</i> cmd,
        in<i>(</i><i>&#34;rdx&#34;</i><i>)</i> arg,
        <i>// those aren&#39;t used, but they may be clobbered by</i>
        <i>// the syscall, so we need to let LLVM know.</i>
        lateout<i>(</i><i>&#34;rcx&#34;</i><i>)</i> _, lateout<i>(</i><i>&#34;r11&#34;</i><i>)</i> _,
        options<i>(</i>nostack<i>)</i>
    <i>)</i><i>;</i>
    <i>// errors are negative, so this is actually an i64</i>
    ret <i>as</i> <i>i64</i>
<i>}</i>
</pre></div>
<p>Let&#39;s give it a shot!</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
[src/main.rs:21] ret = 0

$ cargo run --quiet | cat
[src/main.rs:21] ret = -25
</pre></div>
<p>And error <code>25</code> is...</p>
<div translate="no"><p>C code</p><pre data-lang="c"><i>// in `linux/source/include/uapi/asm-generic/errno-base.h`</i>
<i>#define</i>	<i>ENOTTY</i> 25	/* Not a typewriter */
</pre></div>
<p>Hurray!</p>

<div>

<div>
<p>Well I mean... we still depend on, like...</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ nm ./target/debug/terminus | grep &#34;U &#34; | grep GLIBC | wc -l
56
</pre></div>
<p>...at <em>least</em> fifty-six functions from libc.</p>
</div>
</div>
<div>

<p>Well okay sure but we made our own <code>isatty</code>! Go us!</p>
</div>
<p>And thus concludes our ride down into the lower level of abstractions.</p>
<p>Now we know!</p>
<div>

<p>If you really, really don&#39;t want to use libc, you don&#39;t have to.</p>
<p>Linux kernel syscall numbers are stable (here&#39;s a <a href="https://filippo.io/linux-syscall-table/">nice table of
them</a>) and so are the constants,
so you don&#39;t <em>have</em> to go through libc.</p>
<p>The situation is different on other mainstream OSes. For example, Go used to do
&#34;raw system calls&#34; on macOS, but Go programs often broke with new kernel versions. As of
Go 1.16, they&#39;ve <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/Go116OpenBSDUsesLibc">switched to
libc</a>.</p>
</div>

                        <h2>
                            <a id="moving-on-up" href="#moving-on-up">
                                Moving on up
                            </a>
                        </h2>
                        
<p>Let&#39;s return to a place where we don&#39;t actually need to make our own syscalls,
shall we? There&#39;s a couple others I&#39;d like to try out.</p>
<p>So let&#39;s switch back to stable:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ rm rust-toolchain.toml
</pre></div>
<p>And then just use the <code>libc</code> crate!</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add libc
    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
      Adding libc v0.2.102 to dependencies

</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>
<i>use</i> libc<i>::</i><i>{</i>isatty<i>,</i> STDOUT_FILENO<i>}</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
    <i>let</i> stdout_is_tty = <i>unsafe</i> <i>{</i> <i>isatty</i><i>(</i>STDOUT_FILENO<i>)</i> <i>}</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>stdout_is_tty<i>)</i><i>;</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -q
[src/main.rs:5] stdout_is_tty = 1

$ cargo run -q | cat
[src/main.rs:5] stdout_is_tty = 0
</pre></div>
<p>There, street cred be damned.</p>
<p>Since we&#39;re on Linux, it&#39;s mountains of C all the way down anyway.</p>

<p>Now, where were we? Ah right! The man page for <code>isatty</code> also mentioned
<code>ttyname</code>, which looked interesting, because, between you and me, I still don&#39;t
have the faintest idea what a &#34;TTY&#34; actually is.</p>
<p>Fair enough, let&#39;s try it.</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>use</i> libc<i>::</i><i>{</i>isatty<i>,</i> ttyname<i>,</i> STDOUT_FILENO<i>}</i><i>;</i>
<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> ffi<i>::</i>CStr<i>}</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> stdout_is_tty = <i>unsafe</i> <i>{</i> <i>isatty</i><i>(</i>STDOUT_FILENO<i>)</i> <i>}</i> == <i>1</i><i>;</i>
    <i>if</i> stdout_is_tty <i>{</i>
        <i>let</i> tty_name = <i>unsafe</i> <i>{</i> <i>ttyname</i><i>(</i>STDOUT_FILENO<i>)</i> <i>}</i><i>;</i>
        <i>assert</i><i>!</i><i>(</i>!tty_name.is_null<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>let</i> tty_name = <i>unsafe</i> <i>{</i> <i>CStr</i><i>::</i><i>from_ptr</i><i>(</i>tty_name<i>)</i> <i>}</i><i>;</i>
        <i>let</i> tty_name = tty_name<i>.</i><i>to_str</i><i>(</i><i>)</i>?<i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;stdout is a TTY: {}&#34;</i>, tty_name<i>)</i><i>;</i>
    <i>}</i> <i>else</i> <i>{</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;stdout is not a TTY&#34;</i><i>)</i><i>;</i>
    <i>}</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -q
stdout is a TTY: /dev/pts/11

$ cargo run -q | cat
stdout is not a TTY
</pre></div>
<p>Ahah! A TTY is... a file?</p>
<p>What can we do with that file? Can we write to it?</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/the-other-side.1af39732b1964331.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/the-other-side.54aee2d59e86c157.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/the-other-side.48442c5b1dadc645.jpg" title="" alt=""/>
            </picture>
            
<p>Oh my. Yes. Yes we can.</p>
<p>(I didn&#39;t type in the upper pane — it was printed when I ran echo in the lower
pane.)</p>
<p>Can we read from it?</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/and-now-i-cant.d6a56cdf2498b2da.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/and-now-i-cant.d94f04420059a47d.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/and-now-i-cant.db9df70566a0ed54.jpg" title="" alt=""/>
            </picture>
            
<p>Uhhhhhhh sorta kinda yes. It looks like it&#39;s a free-for-all: whoever reads first
gets the.. worm. If I type really slowly &#34;cat&#34; wins the race.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/slower-now.884c8f868a84e6f9.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/slower-now.40f81d2f5e402dd2.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/slower-now.453b26bca03c6a88.jpg" title="" alt=""/>
            </picture>
            <div>

<div>
<p>Wait, you&#39;re doing all of this from inside <a href="https://en.wikipedia.org/wiki/Tmux">tmux</a> right?</p>
<p>That&#39;s how you can have several panes like that?</p>
</div>
</div>

<div>

<p>So does that mean... does each pane have its own TTY?</p>
</div>
<p>That <em>seems</em> like it makes sense, but let&#39;s check:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/two-ttys.0a73d4ec63ce8500.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/two-ttys.bda0cd28a1732ea4.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/two-ttys.40b8c9caa14a1764.jpg" title="" alt=""/>
            </picture>
            
<p>Right! They certainly each have their own terminals. How many terminals am I
even on right now? Assuming they pop in and out of <code>/dev/pts</code>, we should be
able to just list them like so:</p>
<div translate="no"><pre data-lang="">$ ls -lhA /dev/pts
total 0
crw--w---- 1 root tty  136,  0 Sep 23 11:57 0
crw--w---- 1 amos tty  136,  1 Sep 23 11:57 1
crw--w---- 1 amos tty  136, 10 Sep 24 18:23 10
crw--w---- 1 amos tty  136, 11 Sep 24 18:23 11
crw--w---- 1 amos tty  136, 12 Sep 24 18:15 12
crw--w---- 1 amos tty  136, 13 Sep 24 18:23 13
crw--w---- 1 amos tty  136,  2 Sep 24 18:23 2
crw--w---- 1 amos tty  136,  3 Sep 24 12:46 3
crw--w---- 1 amos tty  136,  4 Sep 24 18:22 4
crw--w---- 1 amos tty  136,  5 Sep 24 13:09 5
crw--w---- 1 amos tty  136,  6 Sep 24 12:50 6
crw--w---- 1 amos tty  136,  7 Sep 24 12:47 7
crw--w---- 1 amos tty  136,  8 Sep 24 13:00 8
crw--w---- 1 amos tty  136,  9 Sep 24 18:22 9
c--------- 1 root root   5,  2 Sep 23 11:57 ptmx
</pre></div>
<p>Ah! Fourteen (counting from zero). Some even date from yesterday. How do we know
who they belong to?</p>
<div>

<p>Well... they&#39;re just files, right?</p>
</div>
<div>

<p>Right.. so if some process has them open... we should have corresponding file
descriptors.</p>
</div>
<div>

<p>Oooh and the kernel keeps track of file descriptors!</p>
</div>
<div>

<p>Right! And <code>lsof</code> (list open files) can let us know which process are holding
which file descriptors.</p>
</div>
<p>Let&#39;s try it for the current TTY:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -q
stdout is a TTY: /dev/pts/13

$ lsof /dev/pts/13
COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
zsh       10614 amos    0u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10614 amos    1u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10614 amos    2u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10614 amos   10u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10661 amos   15u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10661 amos   16u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10661 amos   17u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10667 amos   15u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10667 amos   16u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10667 amos   17u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10669 amos   15u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10669 amos   16u   CHR 136,13      0t0   16 /dev/pts/13
zsh       10669 amos   17u   CHR 136,13      0t0   16 /dev/pts/13
gitstatus 10670 amos   15u   CHR 136,13      0t0   16 /dev/pts/13
gitstatus 10670 amos   16u   CHR 136,13      0t0   16 /dev/pts/13
gitstatus 10670 amos   17u   CHR 136,13      0t0   16 /dev/pts/13
lsof      14867 amos    0u   CHR 136,13      0t0   16 /dev/pts/13
lsof      14867 amos    1u   CHR 136,13      0t0   16 /dev/pts/13
lsof      14867 amos    2u   CHR 136,13      0t0   16 /dev/pts/13
</pre></div>
<p>Ha! That&#39;s a lot of processes. I guess they all just coordinate together to make
that fancy prompt happen. (It&#39;s
<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>, by the way).</p>
<p>Oh and <code>lsof</code> even found itself!</p>
<div>

<p>Mhh I wonder how <code>lsof</code> works... is it using a fancy kernel interface?</p>
</div>

<div translate="no"><p>Shell session</p><pre data-lang="shell">$ strace -o strace.log -- lsof /dev/pts/10 &amp;&gt; /dev/null

$ grep -E &#39;openat.*/proc&#39; strace.log | head
openat(AT_FDCWD, &#34;/proc/filesystems&#34;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &#34;/proc/mounts&#34;, O_RDONLY) = 3
openat(AT_FDCWD, &#34;/proc/16057/fdinfo/3&#34;, O_RDONLY) = 6
openat(AT_FDCWD, &#34;/proc/locks&#34;, O_RDONLY) = 3
openat(AT_FDCWD, &#34;/proc&#34;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
openat(AT_FDCWD, &#34;/proc/1/stat&#34;, O_RDONLY) = 6
openat(AT_FDCWD, &#34;/proc/1/maps&#34;, O_RDONLY) = -1 EACCES (Permission denied)
openat(AT_FDCWD, &#34;/proc/1/fd&#34;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = -1 EACCES (Permission denied)
openat(AT_FDCWD, &#34;/proc/45/stat&#34;, O_RDONLY) = 6
openat(AT_FDCWD, &#34;/proc/45/maps&#34;, O_RDONLY) = -1 EACCES (Permission denied)
</pre></div>
<p>Oh. Uh oh.</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ grep -E &#39;openat.*/proc&#39; strace.log | wc -l
1267
</pre></div>
<p>Oh. Ooooooh okay. It&#39;s just going through
<a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>, looking for <em>all open file
descriptors</em> of <em>all processes</em>.</p>
<p>Well then.</p>
<div>

<p>At least inside of tmux, our TTYs (terminals, née teletype) are PTYs
(pseudo-terminals).</p>
<p>Pseudo-terminals live under <code>/dev/pts/</code> and apparently, anyone can just go ahead
and open them. I mean, there&#39;s Unix permissions and stuff but still, uh, feels
a little unsettling.</p>
</div>

                        <h2>
                            <a id="something-doesn-t-add-up" href="#something-doesn-t-add-up">
                                Something doesn&#39;t add up
                            </a>
                        </h2>
                        
<p>Okay. OKAY. That&#39;s all well and good. I feel like we&#39;re making tangible progress
here, but there&#39;s something that puzzles me.</p>
<div>

<p>Yeah! Something doesn&#39;t add up!</p>
</div>
<div>

<p>You think so too? What thing, exactly?</p>
</div>
<div>

<p>Well the... we&#39;ve got one end of the.. when we open a pseudo-terminal, what
we have is... and we can write into it... but then how-</p>
</div>
<div>

<p>So you don&#39;t know. You just thought you&#39;d jump in.</p>
</div>

<p>Aaaaaanyway.</p>
<p>Yes, bear. Yes, we&#39;re only holding half of it.</p>
<p>Because as you may have noticed, when we rudely echoed something into
<code>/dev/pts/N</code>, it showed up in the other pane, but zsh didn&#39;t try to execute it.</p>
<div>

<p>Yes, that! Why didn&#39;t it try to execute it?</p>
</div>
<p>Well, let&#39;s think for a second.</p>
<p>When we type into a terminal, who gets the input?</p>
<div>

<p>Well... in this case it&#39;s zsh?</p>
</div>
<p>Wrong! It absolutely is not zsh. First, it&#39;s my Logitech K120 keyboard, which I
keep trying to replace but is the only thing that has worked for me for the past
decade, that&#39;s right mechanical keyboard nerds, your resident deep dive writer
is using second-rate office supplies.</p>
<p>And then, well, something something USB-A, a hub, USB-C, presumably some Intel
piece of hardware inside my MacBookPro, the driver for the USB host controller,
eventually the Windows kernel, and then... the input chain? Who knows how many
layers that&#39;s got — but eventually we get a &#34;key event&#34;, whatever form it takes.</p>
<p>Then it goes through <a href="https://en.wikipedia.org/wiki/Windows_Terminal">Windows
Terminal</a> which, honestly if
you&#39;re still using <code>cmd.exe</code> well — what are you waiting to switch over?</p>
<p>Of course that&#39;s because I have a weird
<a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux#WSL_2">WSL2</a> setup
going on. I tried using Linux as my main OS, I <a href="https://twitter.com/fasterthanlime/status/1303738588883046405">really did</a>.</p>
<p>But my point is: it&#39;s not <code>zsh</code> that gets the input. It&#39;s Windows Terminal. If I
was on Linux, it&#39;d be <a href="https://lib.rs/crates/alacritty">alacritty</a> or
<code>xfce4-terminal</code> or something.</p>
<div>

<p>Mhhh. Okay, fair, but surely it then just forwards that input to zsh, right?</p>
</div>
<p>Wrong! Because <em>that would not be a TTY</em>. If zsh&#39;s standard input was merely a
pipe that Windows Terminal wrote to (let&#39;s forget there&#39;s two different OSes
in action for a minute), <code>isatty</code> would definitely return false.</p>
<p>And besides... watch this:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/small-resolv.a7d98523f5bea038.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/small-resolv.da86c645f8c9da9f.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/small-resolv.30501abc72a19413.jpg" title="" alt=""/>
            </picture>
            
<p>And now this:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/big-resolv.5b6eb7127cb9c5cb.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/big-resolv.409ee4099c677438.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/big-resolv.abd5d5cd545f458e.jpg" title="" alt=""/>
            </picture>
            <div>

<p>Yeah, the output of <a href="https://lib.rs/crates/bat">bat</a> scales depending on the
size of the terminal, so what?</p>
</div>
<p>Well, how do you do that with a pipe, huh bear? HOW INDEED?</p>
<div>

<p>Ohhhhhhhhh.. with... with...</p>
</div>
<p>THAT&#39;S RIGHT. With an <code>ioctl</code> syscall. Which we did above.</p>
<p>But the ioctls we want to perform <em>don&#39;t work unless the file descriptor is a TTY</em>.</p>

<p>Then we&#39;re back to square one, yes.</p>
<p>And you know what&#39;s worse? All that information, like the terminal&#39;s size and
whatnot, it&#39;s out-of-band!</p>

<p>Yeah! It&#39;s not like colors which are like &#34;ooh here&#39;s a funny byte and then
ASCII numbers and punctuation I guess, 420 shipit&#34; — these are kernel operations
on file descriptors, they&#39;re not in the stream at all.</p>
<div>

<p>But then how do you know wh-</p>
</div>
<p>When a terminal is resized? Well HERE COMES THE FUN BIT! It&#39;s not via ioctls!
Not at all! Because those are a &#34;pull&#34; interface, you just ask for the info when
you need it — and you don&#39;t want to be constantly requesting it.</p>
<p>(It&#39;s presumably &#34;costly&#34;, otherwise <code>ls</code> wouldn&#39;t memoize/cache it. At the very
least it crosses the kernel boundary, because it&#39;s a syscall).</p>
<p>So you know how you know? That a terminal is resized?</p>
<div>

<p>No, that&#39;s what I was just ask-</p>
</div>
<p>WELL YOU GET A SIGNAL</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/sigwinch.0b2b55b77da4963b.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/sigwinch.fde959854334cf86.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/sigwinch.735067c875865f3f.jpg" title="" alt=""/>
            </picture>
            
<p>THAT&#39;S RIGHT. A SIGNAL. Just like when a process is killed or stopped.</p>
<p>So between in-band information (like <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape
codes</a>) and out-of-band
information (like signals and ioctls), GOOD LUCK WRITING A TERMINAL EMULATOR.</p>
<p>&#34;EVERYTHING IS A FILE&#34; MY LILY-WHITE BUTT.</p>
<div>

<p>Amos please, there&#39;s childr-</p>
</div>
<p>WELL THEY HAD TO FIND OUT ONE DAY.</p>

                        <h2>
                            <a id="getting-past-denial-and-anger" href="#getting-past-denial-and-anger">
                                Getting past denial and anger
                            </a>
                        </h2>
                        
<p>Okay, okay, let&#39;s take a breather. We actually don&#39;t need to care about signals,
thankfully. We&#39;ll just never ever resize our terminals. That&#39;s fine. It&#39;s fine.
It&#39;s okay. We&#39;re okay.</p>
<p>I don&#39;t really think we need to care about ioctls either, if all we want to do
is just pretend we&#39;re a terminal - we don&#39;t need to get the terminal info, our
child process does... just like zsh requests the terminal info set by Windows
Terminal.</p>
<div>

<p>But don&#39;t we need to... set it?</p>
</div>
<div>

<p>Bear, I don&#39;t even know how we <em>make</em> a pseudo-terminal.</p>
</div>
<div>

<p>No don&#39;t... don&#39;t cr- here, I&#39;m looking it up right now. If we look for libc
functions that have &#34;pty&#34; in them, surely we&#39;ll find something...</p>
</div>

<div>

<p>THERE! There&#39;s a thing called &#34;openpty&#34;.</p>
</div>

<div>

<p>Yeahhhh! It looks great! It takes a pointer to a master file descriptor, and
to a, oh.</p>
</div>

<div>

<p>Nothing haha. I was saying: it takes a pointer to a primary file descriptor,
and a secondary file descriptor, also a name, a &#34;termp&#34; and a &#34;winp&#34;.</p>
</div>
<div>

<p>Please tell me most of these can be null.</p>
</div>
<div>

<p><em>looks closer</em> yeah I mean we can try.</p>
</div>
<p>Okay. Sure. We&#39;ll try.</p>
<p>Let&#39;s look at that function closer... gonna be paraphrasing that man page to
modernize it a little bit.</p>
<blockquote>
<p>The function <code>openpty()</code> attempts to obtain the next available pseudo-
terminal from the system (see <code>pty(4)</code>).</p>
</blockquote>
<p>Okay...</p>
<blockquote>
<p>If it successfully finds one, it subsequently changes the ownership of the secondary
device to the real UID of the current process, the group membership to the group
&#34;tty&#34; (if such a group exists in the system), the access permissions for reading
and writing by the owner, and for writing by the group, and invalidates any
current use of the line by calling revoke(2).</p>
</blockquote>
<p>Okay, sure, permissions, why not.</p>
<blockquote>
<p>If the argument <code>name</code> is not NULL, <code>openpty()</code> copies the pathname of the
secondary pty to this area.  The caller is responsible for allocating the
required space in this array.</p>
</blockquote>
<p>Oh HELL no, we&#39;re not letting libc write past the end of a buffer. Not today.
That&#39;ll be null, thank you very much.</p>
<blockquote>
<p>If the arguments termp or winp are not NULL, openpty() initializes the
termios and window size settings from the structures these arguments
point to, respectively.</p>
</blockquote>
<p>Ah! Those <em>can</em> be null.</p>
<blockquote>
<p>Upon return, the open file descriptors for the primary and secondary side of
the pty are returned in the locations pointed to by aprimary and asecondary,
respectively.</p>
</blockquote>
<p>Very well, let&#39;s see what happens then.</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>use</i> libc<i>::</i><i>{</i>isatty<i>,</i> ttyname<i>}</i><i>;</i>
<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> ffi<i>::</i>CStr<i>}</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>mut</i> primary_fd<i>:</i> <i>i32</i> = <i>0</i><i>;</i>
    <i>let</i> <i>mut</i> secondary_fd<i>:</i> <i>i32</i> = <i>0</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;Opening pty...&#34;</i><i>)</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        <i>let</i> ret = libc<i>::</i><i>openpty</i><i>(</i>
            <i>&amp;</i><i>mut</i> primary_fd<i>,</i>
            <i>&amp;</i><i>mut</i> secondary_fd<i>,</i>
            std<i>::</i>ptr<i>::</i><i>null_mut</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
        <i>)</i><i>;</i>
        <i>if</i> ret != <i>0</i> <i>{</i>
            <i>panic</i><i>!</i><i>(</i><i>&#34;Failed to openpty!&#34;</i><i>)</i><i>;</i>
        <i>}</i>
    <i>}</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> is_tty = <i>unsafe</i> <i>{</i> <i>isatty</i><i>(</i>secondary_fd<i>)</i> <i>}</i> == <i>1</i><i>;</i>
    <i>if</i> is_tty <i>{</i>
        <i>let</i> tty_name = <i>unsafe</i> <i>{</i> <i>ttyname</i><i>(</i>secondary_fd<i>)</i> <i>}</i><i>;</i>
        <i>assert</i><i>!</i><i>(</i>!tty_name.is_null<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>let</i> tty_name = <i>unsafe</i> <i>{</i> <i>CStr</i><i>::</i><i>from_ptr</i><i>(</i>tty_name<i>)</i> <i>}</i><i>;</i>
        <i>let</i> tty_name = tty_name<i>.</i><i>to_str</i><i>(</i><i>)</i>?<i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;secondary is a TTY: {}&#34;</i>, tty_name<i>)</i><i>;</i>
    <i>}</i> <i>else</i> <i>{</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;secondary is not a TTY&#34;</i><i>)</i><i>;</i>
    <i>}</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
Opening pty...
[src/main.rs:20] primary_fd = 3
[src/main.rs:20] secondary_fd = 4
secondary is a TTY: /dev/pts/9
</pre></div>
<p>Yes.</p>
<p>YES.</p>
<p>WE HAVE A PSEUDO-TERMINAL. AHHHHH</p>
<div>

<p>And I guess we hold the primary and the secondary is what our child process
gets?</p>
</div>


<p>Yes yes how do we get another process to use said pseudo-terminal. Well, you&#39;d
think you could just pass the file descriptor as stdin/stdout/stderr, right?</p>
<p>Wrong!</p>
<p>Because see, Linux processes have, like, &#34;sessions&#34;, and those sessions have
&#34;leaders&#34; and also they have a &#34;controlling terminal&#34; and there&#39;s definitely a
call to &#34;allocate a new session&#34; but the way you change the &#34;controlling
terminal&#34; is much much funnier.</p>
<p>Let&#39;s look at the code for <code>login_tty</code>, which does both:</p>
<div translate="no"><p>C code</p><pre data-lang="c"><i>// in `glibc/login/login_tty.c`</i>

<i>int</i>
<i>__login_tty</i> (<i>int</i> <i>fd</i>)
{
    <i>__setsid</i>();
<i>#ifdef</i> <i>TIOCSCTTY</i>
    <i>if</i> (<i>__ioctl</i>(<i>fd</i>, <i>TIOCSCTTY</i>, <i>NULL</i>) <i>==</i> -1)
        <i>return</i> (-1);
<i>#else</i>
    {
      <i>/* This might work.  */</i>
      <i>char</i> <i>*</i><i>fdname</i> <i>=</i> <i>ttyname</i> (<i>fd</i>);
      <i>int</i> <i>newfd</i>;
      <i>if</i> (<i>fdname</i>)
        {
          <i>if</i> (<i>fd</i> <i>!=</i> 0)
        <i>_close</i> (0);
          <i>if</i> (<i>fd</i> <i>!=</i> 1)
        <i>__close</i> (1);
          <i>if</i> (<i>fd</i> <i>!=</i> 2)
        <i>__close</i> (2);
          <i>newfd</i> <i>=</i> <i>__open64</i> (<i>fdname</i>, <i>O_RDWR</i>);
          <i>__close</i> (<i>newfd</i>);
        }
    }
<i>#endif</i>
    <i>while</i> (<i>__dup2</i>(<i>fd</i>, 0) <i>==</i> -1 <i>&amp;&amp;</i> <i>errno</i> <i>==</i> <i>EBUSY</i>)
      ;
    <i>while</i> (<i>__dup2</i>(<i>fd</i>, 1) <i>==</i> -1 <i>&amp;&amp;</i> <i>errno</i> <i>==</i> <i>EBUSY</i>)
      ;
    <i>while</i> (<i>__dup2</i>(<i>fd</i>, 2) <i>==</i> -1 <i>&amp;&amp;</i> <i>errno</i> <i>==</i> <i>EBUSY</i>)
      ;
    <i>if</i> (<i>fd</i> <i>&gt;</i> 2)
        <i>__close</i>(<i>fd</i>);
    <i>return</i> (0);
}
</pre></div>
<p>I... I don&#39;t know where to start. On platforms that don&#39;t support the
<code>TIOCSCTTY</code> ioctl, it <em>closes standard input, output and error</em> and opens
the secondary side of the TTY.</p>
<p>Because that makes it the controlling terminal. Because of course.</p>
<p>And then uhh those <code>while</code> loops look horrifying to me but I guess they&#39;re
extremely standard *nix stuff and I&#39;m really just showing my lack of experience
there.</p>
<p>Regardless: yuck.</p>
<p>But you know... as long as it works...</p>
<p>The real question is... when do we do that? When do we call <code>login_tty</code>?</p>
<div>

<p>If we didn&#39;t insist on using Rust&#39;s
<a href="https://doc.rust-lang.org/stable/std/process/struct.Command.html">Command</a>
abstraction, we <em>could</em> just use <a href="https://manpage.me/?q=forkpty">forkpty</a>, which
does <code>fork</code> <em>and</em> <code>login_tty</code>.</p>
<p>But we do insist. And it&#39;s more fun to peek into what&#39;s &#34;actually&#34; going on,
for some value of &#34;actually&#34;.</p>
</div>
<p>When we executed a program from Rust, we did something like this:</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust">        <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i>
            <i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i>
            <i>.</i><i>output</i><i>(</i><i>)</i>
            <i>.</i><i>map</i><i>(</i>|s| <i>String</i><i>::</i><i>from_utf8</i><i>(</i>s<i>.</i><i>stdout</i><i>)</i><i>)</i>??<i></i>
</pre></div>
<p>But that nice, high-level API is hiding the <em>terrible truth</em>.</p>
<p>A great number of cursed things happen when spawning a process on Linux.</p>
<p>Well, unless you use <a href="https://manpage.me/?q=posix_spawn">posix_spawn</a>. That&#39;s
the good one.</p>
<p>But the <em>traditional</em> way, which we&#39;ll have no choice but to use here, has two
important steps.</p>
<p>First, we <em>fork</em>. This creates an &#34;exact&#34; copy of the calling process, except
for like, twenty different things (like having a different PID (process ID), a
different PPID (parent process ID), etc.)</p>
<p>What&#39;s fun about fork is that we&#39;re splitting the space-time continuum —
technically, it returns <em>twice</em>. Once in the parent process, and once in the
child process.</p>
<p>In the child process, it returns <code>0</code>, and that&#39;s how you know it&#39;s the child
process because, well, since it&#39;s an &#34;exact&#34; copy, they&#39;re still executing the
same code at this point. So you compare against <code>0</code>, and things diverge from
there.</p>
<p>And usually, at that point, you want to move on to <code>exec</code>, which asks the kernel
to <em>violently</em> replace the current process (the child process we just fashioned
from <del>the ribs of Adam</del> the memory space of the calling process) with
whichever ELF file we said to use.</p>
<p>Which is the way you normally run programs. Unless you <a href="https://dave.is/series/making-our-own-executable-packer">really have too much
time on your hands</a>.</p>
<p>So let&#39;s think! We have <code>login_tty</code>, which makes the calling process the leader
of a new session, and sets its controlling terminal to whichever file descriptor
we passed.</p>
<p>Well. If we call it before <code>fork</code> it&#39;s going to mess with our parent process,
which is almost definitely not what we want. We don&#39;t want to become the leader
of our session. We don&#39;t want to change our own controlling terminal.</p>
<p>We only want, say, <code>ls</code> to have as controlling terminal, the pseudo-terminal we
just created (with <code>openpty</code>).</p>
<p>If we call it after <code>exec</code>, well... well we can&#39;t call anything after <code>exec</code>.</p>
<p>Any code from the parent process, that was &#34;copied into&#34; (really, just mapped)
the child process, stops existing the second we call <code>exec</code>.</p>
<p><code>exec</code> never returns, much like <a href="https://en.wikipedia.org/wiki/The_Crazy_Nastyass_Honey_Badger#Spin_offs">honey badger don&#39;t
care</a>.</p>
<p>So really, that only leaves us one choice.. we must execute <code>login_tty</code> between
<code>fork</code> and <code>exec</code>.</p>
<p>Which means we can&#39;t use <code>posix_spawn</code>.</p>
<p>So we&#39;ll just look into our Rust code where we can do that and...</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust">        <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i>
            <i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i>
            <i>.</i><i>output</i><i>(</i><i>)</i>
            <i>.</i><i>map</i><i>(</i>|s| <i>String</i><i>::</i><i>from_utf8</i><i>(</i>s<i>.</i><i>stdout</i><i>)</i><i>)</i>??<i></i>
</pre></div>

<div>

<p>I don&#39;t see <code>fork</code>. Or <code>exec</code>. Or <code>posix_spawn</code>.</p>
</div>
<p>Ahhh yes, they&#39;re well hidden, in Terrible Truth Land, also known as <a href="https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library/std/src/sys/unix/process/process_unix.rs#L393">the Rust
standard library</a>.</p>
<p>See, there&#39;s a <code>posix_spawn</code> fn there, and...</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `library/std/src/sys/unix/process_unix.rs`</i>

    <i>fn</i> <i>posix_spawn</i><i>(</i>
        <i>&amp;</i><i>mut</i> <i>self</i><i>,</i>
        <i>stdio</i><i>:</i> <i>&amp;</i><i>ChildPipes</i><i>,</i>
        <i>envp</i><i>:</i> <i>Option</i><i>&lt;</i><i>&amp;</i><i>CStringArray</i><i>&gt;</i><i>,</i>
    <i>)</i> -&gt; io<i>::</i><i>Result</i><i>&lt;</i><i>Option</i><i>&lt;</i><i>Process</i><i>&gt;</i><i>&gt;</i> <i>{</i>
        <i>use</i> <i>crate</i><i>::</i>mem<i>::</i>MaybeUninit<i>;</i>
        <i>use</i> <i>crate</i><i>::</i>sys<i>::</i><i>{</i><i>self</i><i>,</i> cvt_nz<i>}</i><i>;</i>

        <i>if</i> <i>self</i><i>.</i><i>get_gid</i><i>(</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i>
            || <i>self</i><i>.</i><i>get_uid</i><i>(</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i>
            || <i>(</i><i>self</i><i>.</i><i>env_saw_path</i><i>(</i><i>)</i> &amp;&amp; !<i>self</i><i>.</i><i>program_is_path</i><i>(</i><i>)</i><i>)</i>
            || !<i>self</i><i>.</i><i>get_closures</i><i>(</i><i>)</i><i>.</i><i>is_empty</i><i>(</i><i>)</i>
            || <i>self</i><i>.</i><i>get_groups</i><i>(</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i>
            || <i>self</i><i>.</i><i>get_create_pidfd</i><i>(</i><i>)</i>
        <i>{</i>
            <i>return</i> Ok<i>(</i>None<i>)</i><i>;</i>
        <i>}</i>

        <i>// ...</i>
    <i>}</i>
</pre></div>
<p>...and the first thing it does is check if we&#39;re doing something funky! And if we
are, it doesn&#39;t actually use <code>posix_spawn</code>.</p>
<p>Funky things like, I don&#39;t know, setting a different UID (user ID) or GID (group
ID), or... hey, what&#39;s that about <code>closures</code>?</p>
<div>

<p><em>furiously going through std</em> So if that&#39;s set here then.. THERE! I got it!</p>
</div>
<p>What? <code>Command::pre_exec</code>? Good job bear! Now we can fina-</p>
<div>

<p>Wait, it&#39;s unsafe. Why is it unsafe.</p>
</div>
<p>It&#39;s uns- ah. Yes. Well, let&#39;s review the docs.</p>
<blockquote>
<h3>Notes and Safety</h3>
<p>This closure will be run in the context of the child process after a <code>fork</code>.
This primarily means that any modifications made to memory on behalf of this
closure will <strong>not</strong> be visible to the parent process. This is often a very
constrained environment where normal operations like <code>malloc</code>, accessing
environment variables through <code>std::env</code> or acquiring a mutex are not guaranteed
to work (due to other threads perhaps still running when the fork was run).</p>
</blockquote>
<p>Ooooh boy. Okay so we won&#39;t allocate anyth-</p>
<blockquote>
<p>This also means that all resources such as file descriptors and memory-mapped
regions got duplicated. It is your responsibility to make sure that the closure
does not violate library invariants by making invalid use of these duplicates.</p>
</blockquote>
<p>Ah uh</p>
<blockquote>
<p>Panicking in the closure is safe only if all the format arguments for the
panic message can be safely formatted; this is because although <code>Command</code> calls
<code>std::panic::always_abort</code> before calling the pre_exec hook, panic will still try
to format the panic message.</p>
</blockquote>
<p>Well I-</p>
<blockquote>
<p>When this closure is run, aspects such as the stdio file descriptors and
working directory have successfully been changed, so output to these locations
may not appear where intended.</p>
</blockquote>
<p>Okay, okay I got it — stuff gets <em>real weird</em> in there.</p>
<p>We&#39;ll just <code>login_tty</code> and get out of here as fast as we can.</p>
<p>Leeeeeeeeeeeet&#39;s go:</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> os<i>::</i>unix<i>::</i>prelude<i>::</i>CommandExt<i>,</i> process<i>::</i>Command<i>}</i><i>;</i>

<i>fn</i> <i>openpty</i><i>(</i><i>)</i> -&gt; <i>(</i><i>i32</i><i>,</i> <i>i32</i><i>)</i> <i>{</i>
    <i>let</i> <i>mut</i> primary_fd<i>:</i> <i>i32</i> = -<i>1</i><i>;</i>
    <i>let</i> <i>mut</i> secondary_fd<i>:</i> <i>i32</i> = -<i>1</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        <i>let</i> ret = libc<i>::</i><i>openpty</i><i>(</i>
            <i>&amp;</i><i>mut</i> primary_fd<i>,</i>
            <i>&amp;</i><i>mut</i> secondary_fd<i>,</i>
            std<i>::</i>ptr<i>::</i><i>null_mut</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
        <i>)</i><i>;</i>
        <i>if</i> ret != <i>0</i> <i>{</i>
            <i>panic</i><i>!</i><i>(</i><i>&#34;Failed to openpty!&#34;</i><i>)</i><i>;</i>
        <i>}</i>
    <i>}</i><i>;</i>
    <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i>
<i>}</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i> = <i>openpty</i><i>(</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> cmd = <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i><i>;</i>
    cmd<i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        cmd<i>.</i><i>pre_exec</i><i>(</i><i>move</i> || <i>{</i>
            <i>if</i> libc<i>::</i><i>login_tty</i><i>(</i>secondary_fd<i>)</i> != <i>0</i> <i>{</i>
                <i>panic</i><i>!</i><i>(</i><i>&#34;couldn&#39;t set the controlling terminal or something&#34;</i><i>)</i><i>;</i>
            <i>}</i>
            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
        <i>}</i><i>)</i>
    <i>}</i><i>;</i>
    <i>let</i> output = cmd<i>.</i><i>output</i><i>(</i><i>)</i><i>.</i><i>map</i><i>(</i>|out| <i>String</i><i>::</i><i>from_utf8</i><i>(</i>out<i>.</i><i>stdout</i><i>)</i><i>)</i>??<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, output<i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
Opening pty...
[src/main.rs:19] primary_fd = 3
[src/main.rs:19] secondary_fd = 4


</pre></div>
<p>Oh that&#39;s.</p>
<p>That&#39;s perhaps a little <em>too</em> quiet.</p>
<p>What the heck happened here...</p>
<div>

<p>Wait wait wait, we&#39;re calling <code>output()</code>.</p>
</div>

<div>

<p>How do you think <code>output()</code> works?</p>
</div>
<div>

<p>Well... it probably has to redirect stdout and stderr to pip-</p>
</div>
<div>

<p>To pipes, yes precisely. And <em>then</em> it runs the pre-exec closures,
one of which calls <code>login_tty</code>, which..</p>
</div>
<div>

<p>Oh yeahhh! That would definitely override whatever <code>output()</code> is doing.</p>
</div>
<p>But then.. then how do we get the output from <code>/bin/ls</code>?</p>
<p>If it&#39;s holding the secondary... and we&#39;re holding the primary... we need to..
read from it? Potentially maybe?</p>
<p>Okay fine let&#39;s try:</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i><i>{</i>
    error<i>::</i>Error<i>,</i>
    fs<i>::</i>File<i>,</i>
    io<i>::</i>Read<i>,</i>
    os<i>::</i>unix<i>::</i>prelude<i>::</i><i>{</i>CommandExt<i>,</i> FromRawFd<i>}</i><i>,</i>
    process<i>::</i>Command<i>,</i>
<i>}</i><i>;</i>

<i>// omitted: fn openpty()</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i> = <i>openpty</i><i>(</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> cmd = <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i><i>;</i>
    cmd<i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        cmd<i>.</i><i>pre_exec</i><i>(</i><i>move</i> || <i>{</i>
            <i>if</i> libc<i>::</i><i>login_tty</i><i>(</i>secondary_fd<i>)</i> != <i>0</i> <i>{</i>
                <i>panic</i><i>!</i><i>(</i><i>&#34;couldn&#39;t set the controlling terminal or something&#34;</i><i>)</i><i>;</i>
            <i>}</i>
            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
        <i>}</i><i>)</i>
    <i>}</i><i>;</i>
    <i>let</i> <i>mut</i> child = cmd<i>.</i><i>spawn</i><i>(</i><i>)</i>?<i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;Opening primary...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> primary = <i>unsafe</i> <i>{</i> <i>File</i><i>::</i><i>from_raw_fd</i><i>(</i>primary_fd<i>)</i> <i>}</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;Reading from primary...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> buffer = <i>String</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    primary<i>.</i><i>read_to_string</i><i>(</i><i>&amp;</i><i>mut</i> buffer<i>)</i>?<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;All done!&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, buffer<i>)</i><i>;</i>

    child<i>.</i><i>wait</i><i>(</i><i>)</i>?<i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
[src/main.rs:29] primary_fd = 3
[src/main.rs:29] secondary_fd = 4
Opening primary...
Reading from primary...
^C

</pre></div>
<p>Okay that just gets stuck forever. Mh.</p>
<div>

<p>Uhhh maybe the terminal... remains open?? What does <code>strace</code> say?</p>
</div>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build --quiet
$ strace ./target/debug/terminus
(cut)
write(1, &#34;Opening primary...\n&#34;, 19Opening primary...
)    = 19
write(1, &#34;Reading from primary...\n&#34;, 24Reading from primary...
) = 24
read(3, &#34;Cargo.lock  Cargo.toml  \33[0m\33[01&#34;, 32) = 32
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=31500, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
read(3, &#34;;34msrc\33[0m  strace.log  \33[01;34&#34;, 32) = 32
read(3, &#34;mtarget\33[0m\r\n&#34;, 64)        = 13
read(3, ^C0x56265b70c23d, 51)             = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
strace: Process 31499 detached
</pre></div>
<p>Ohhh. OHHH. Yeah! It does! And <code>read_to_string</code> reads until EOF, which never
happens.</p>
<div>

<p>As noted by many, <code>openpty</code> returns an open file descriptor to the primary and
the secondary. We passed a copy of the secondary to the child process but didn&#39;t
close the parent process&#39;s copy of it.</p>
<p>If we did close the parent process&#39;s copy, then we would see EOF from the
primary as soon as the child process exits, and everything past this point in
this article would be unnecessary.</p>
<p>However, amos has a use case where he wants to re-use the terminal for spawning
several processes in sequence, yet needs to tell apart the output from each
individual process, so it makes sense for him. In most other cases though, you
can just close the parent&#39;s secondary fd and be done with it!</p>
</div>
<p>So we need to...</p>
<div>

<p>..read from the primary only until the child process exits?</p>
</div>
<p>Yeah, that!</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i> = <i>openpty</i><i>(</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> cmd = <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/ls&#34;</i><i>)</i><i>;</i>
    cmd<i>.</i><i>arg</i><i>(</i><i>&#34;--color=auto&#34;</i><i>)</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        cmd<i>.</i><i>pre_exec</i><i>(</i><i>move</i> || <i>{</i>
            <i>if</i> libc<i>::</i><i>login_tty</i><i>(</i>secondary_fd<i>)</i> != <i>0</i> <i>{</i>
                <i>panic</i><i>!</i><i>(</i><i>&#34;couldn&#39;t set the controlling terminal or something&#34;</i><i>)</i><i>;</i>
            <i>}</i>
            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
        <i>}</i><i>)</i>
    <i>}</i><i>;</i>
    <i>let</i> <i>mut</i> child = cmd<i>.</i><i>spawn</i><i>(</i><i>)</i>?<i>;</i>

    <i>let</i> <i>mut</i> primary = <i>unsafe</i> <i>{</i> <i>File</i><i>::</i><i>from_raw_fd</i><i>(</i>primary_fd<i>)</i> <i>}</i><i>;</i>

    <i>let</i> <i>mut</i> out = <i>vec</i><i>!</i><i>[</i><i>]</i><i>;</i>
    <i>let</i> <i>mut</i> buffer = <i>vec</i><i>!</i><i>[</i><i>0u8</i>; <i>1024</i><i>]</i><i>;</i>

    <i>loop</i> <i>{</i>
        <i>let</i> n = primary<i>.</i><i>read</i><i>(</i><i>&amp;</i><i>mut</i> buffer<i>)</i>?<i>;</i>
        out<i>.</i><i>extend_from_slice</i><i>(</i><i>&amp;</i>buffer<i>[</i>..n<i>]</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} bytes...&#34;</i>, n<i>)</i><i>;</i>

        <i>if</i> child<i>.</i><i>try_wait</i><i>(</i><i>)</i>?<i>.</i><i>is_some</i><i>(</i><i>)</i> <i>{</i>
            <i>break</i><i>;</i>
        <i>}</i>
    <i>}</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;Child exited!&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, String::from_utf8<i>(</i>out<i>)</i>?<i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div>
<p>And, lo and behold:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
[src/main.rs:29] primary_fd = 3
[src/main.rs:29] secondary_fd = 4
Read 77 bytes...
Child exited!
Cargo.lock  Cargo.toml  src  strace.log  target

</pre></div>
<p>We have colors.</p>

<p>Oh! Of course.</p>
<p>And lo and behold, we have colors:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/we-have-colors.391572fa6b44df74.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/we-have-colors.b781f544f38fed25.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/we-have-colors.3675c0b20e3ae149.jpg" title="" alt=""/>
            </picture>
            
<p>We also have: a race condition.</p>
<p>If the child exits between our call to <code>try_wait</code> and the next <code>read</code>, we&#39;ll be
stuck forever trying to read.</p>
<p>How could we possibly resolve this?</p>

                        <h2>
                            <a id="oh-good-channels" href="#oh-good-channels">
                                Oh good, channels.
                            </a>
                        </h2>
                        
<p>Okay so, it won&#39;t be pretty, but it won&#39;t race.</p>
<div>

<p>Those both sound like negatives.</p>
</div>
<p>We&#39;ll even run something fancier than <code>ls</code>, like, <code>cargo check</code> three times in a
row, sleeping 1 second between each.</p>
<div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>


<i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i> = <i>openpty</i><i>(</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> cmd = <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/bash&#34;</i><i>)</i><i>;</i>
    cmd<i>.</i><i>arg</i><i>(</i><i>&#34;-c&#34;</i><i>)</i>
        <i>.</i><i>arg</i><i>(</i><i>&#34;for i in $(seq 1 3); do cargo check; sleep 1; done&#34;</i><i>)</i><i>;</i>

    <i>unsafe</i> <i>{</i>
        cmd<i>.</i><i>pre_exec</i><i>(</i><i>move</i> || <i>{</i>
            <i>if</i> libc<i>::</i><i>login_tty</i><i>(</i>secondary_fd<i>)</i> != <i>0</i> <i>{</i>
                <i>panic</i><i>!</i><i>(</i><i>&#34;couldn&#39;t set the controlling terminal or something&#34;</i><i>)</i><i>;</i>
            <i>}</i>
            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
        <i>}</i><i>)</i>
    <i>}</i><i>;</i>
    <i>let</i> <i>mut</i> child = cmd<i>.</i><i>spawn</i><i>(</i><i>)</i>?<i>;</i>

    <i>enum</i> <i>Msg</i> <i>{</i>
        Output<i>(</i><i>Vec</i><i>&lt;</i><i>u8</i><i>&gt;</i><i>)</i><i>,</i>
        Exit<i>,</i>
    <i>}</i>

    <i>let</i> <i>(</i>tx<i>,</i> rx<i>)</i> = std<i>::</i>sync<i>::</i>mpsc<i>::</i><i>channel</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> read_tx = tx<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>{</i>
        <i>let</i> <i>mut</i> primary = <i>unsafe</i> <i>{</i> <i>File</i><i>::</i><i>from_raw_fd</i><i>(</i>primary_fd<i>)</i> <i>}</i><i>;</i>
        <i>let</i> <i>mut</i> buffer = <i>vec</i><i>!</i><i>[</i><i>0u8</i>; <i>1024</i><i>]</i><i>;</i>

        <i>loop</i> <i>{</i>
            <i>let</i> n = primary<i>.</i><i>read</i><i>(</i><i>&amp;</i><i>mut</i> buffer<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            <i>println</i><i>!</i><i>(</i><i>&#34;Read {} bytes...&#34;</i>, n<i>)</i><i>;</i>
            <i>let</i> slice = <i>&amp;</i>buffer<i>[</i>..n<i>]</i><i>;</i>
            read_tx<i>.</i><i>send</i><i>(</i><i>Msg</i><i>::</i>Output<i>(</i>slice<i>.</i><i>to_vec</i><i>(</i><i>)</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>}</i>
    <i>}</i><i>)</i><i>;</i>

    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>{</i>
        child<i>.</i><i>wait</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        tx<i>.</i><i>send</i><i>(</i><i>Msg</i><i>::</i>Exit<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>}</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> out = <i>vec</i><i>!</i><i>[</i><i>]</i><i>;</i>

    <i>loop</i> <i>{</i>
        <i>let</i> msg = rx<i>.</i><i>recv</i><i>(</i><i>)</i>?<i>;</i>
        <i>match</i> msg <i>{</i>
            <i>Msg</i><i>::</i>Output<i>(</i>buffer<i>)</i> =&gt; out<i>.</i><i>extend_from_slice</i><i>(</i><i>&amp;</i>buffer<i>[</i>..<i>]</i><i>)</i><i>,</i>
            <i>Msg</i><i>::</i>Exit =&gt; <i>break</i><i>,</i>
        <i>}</i>
    <i>}</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;Child exited!&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, String::from_utf8<i>(</i>out<i>)</i>?<i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div>
            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/cargo-check.88a4185185481df8.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/cargo-check.330e1b887f3be18d.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/cargo-check.c45291ba35c3ce06.jpg" title="" alt=""/>
            </picture>
            <div>

<p>Mhhhh. If only there was some Rust feature... that lets you deal with problems
like these...</p>
</div>


<div>

<p>Oh dear. You really think we should?</p>
</div>
<div>

<p>Only one way to find out...</p>
</div>

                        <h2>
                            <a id="don-t-make-me-wait" href="#don-t-make-me-wait">
                                Don&#39;t Make Me Wait
                            </a>
                        </h2>
                        
<p>What time is it? It&#39;s <a href="https://lib.rs/crates/tokio">tokio</a> time!</p>
<p>Channels be damned, we&#39;re bringing a whole darn executor with us. Because what
is an executor? A miserable pile of <del>secrets</del> interests and tasks.</p>
<p>And we&#39;re <strong>interest</strong>ed in knowing when the child exits, and also when we can
read from our pseudo-terminal primary.</p>
<div>

<p>Do you know what you&#39;re doing?</p>
</div>

<p>So, uhhh let&#39;s go:</p>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add tokio@1.12.0 --features full
    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
      Adding tokio v1.12.0 to dependencies with features: [&#34;full&#34;]
</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `terminus/src/main.rs`</i>

<i>use</i> std<i>::</i><i>{</i>error<i>::</i>Error<i>,</i> os<i>::</i>unix<i>::</i>prelude<i>::</i>FromRawFd<i>}</i><i>;</i>
<i>use</i> tokio<i>::</i><i>{</i>fs<i>::</i>File<i>,</i> io<i>::</i>AsyncReadExt<i>,</i> process<i>::</i>Command<i>}</i><i>;</i>

<i>fn</i> <i>openpty</i><i>(</i><i>)</i> -&gt; <i>(</i><i>i32</i><i>,</i> <i>i32</i><i>)</i> <i>{</i>
    <i>let</i> <i>mut</i> primary_fd<i>:</i> <i>i32</i> = -<i>1</i><i>;</i>
    <i>let</i> <i>mut</i> secondary_fd<i>:</i> <i>i32</i> = -<i>1</i><i>;</i>
    <i>unsafe</i> <i>{</i>
        <i>let</i> ret = libc<i>::</i><i>openpty</i><i>(</i>
            <i>&amp;</i><i>mut</i> primary_fd<i>,</i>
            <i>&amp;</i><i>mut</i> secondary_fd<i>,</i>
            std<i>::</i>ptr<i>::</i><i>null_mut</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
            std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>,</i>
        <i>)</i><i>;</i>
        <i>if</i> ret != <i>0</i> <i>{</i>
            <i>panic</i><i>!</i><i>(</i><i>&#34;Failed to openpty!&#34;</i><i>)</i><i>;</i>
        <i>}</i>
    <i>}</i><i>;</i>
    <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i>
<i>}</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
<i>async</i> <i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>,</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>Error</i><i>&gt;</i><i>&gt;</i> <i>{</i>
    <i>let</i> <i>(</i>primary_fd<i>,</i> secondary_fd<i>)</i> = <i>openpty</i><i>(</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>primary_fd, secondary_fd<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> cmd = <i>Command</i><i>::</i><i>new</i><i>(</i><i>&#34;/bin/bash&#34;</i><i>)</i><i>;</i>
    cmd<i>.</i><i>arg</i><i>(</i><i>&#34;-c&#34;</i><i>)</i>
        <i>.</i><i>arg</i><i>(</i><i>&#34;for i in $(seq 1 3); do cargo check; sleep 0.2; done&#34;</i><i>)</i><i>;</i>

    <i>unsafe</i> <i>{</i>
        cmd<i>.</i><i>pre_exec</i><i>(</i><i>move</i> || <i>{</i>
            <i>if</i> libc<i>::</i><i>login_tty</i><i>(</i>secondary_fd<i>)</i> != <i>0</i> <i>{</i>
                <i>panic</i><i>!</i><i>(</i><i>&#34;couldn&#39;t set the controlling terminal or something&#34;</i><i>)</i><i>;</i>
            <i>}</i>
            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
        <i>}</i><i>)</i>
    <i>}</i><i>;</i>
    <i>let</i> <i>mut</i> child = cmd<i>.</i><i>spawn</i><i>(</i><i>)</i>?<i>;</i>

    <i>let</i> <i>mut</i> out = <i>vec</i><i>!</i><i>[</i><i>]</i><i>;</i>
    <i>let</i> <i>mut</i> buf = <i>vec</i><i>!</i><i>[</i><i>0u8</i>; <i>1024</i><i>]</i><i>;</i>
    <i>let</i> <i>mut</i> primary = <i>unsafe</i> <i>{</i> <i>File</i><i>::</i><i>from_raw_fd</i><i>(</i>primary_fd<i>)</i> <i>}</i><i>;</i>

    <i>&#39;</i>weee<i>:</i> <i>loop</i> <i>{</i>
        tokio<i>::</i>select! <i>{</i>
            n = primary.read<i>(</i>&amp;<i>mut</i> buf<i>)</i> =&gt; <i>{</i>
                <i>let</i> n = n?;
                println!<i>(</i><i>&#34;Read {} bytes&#34;</i>, n<i>)</i>;
                out.extend_from_slice<i>(</i>&amp;buf<i>[</i>..n<i>]</i><i>)</i>;
            <i>}</i>,

            status = child.wait<i>(</i><i>)</i> =&gt; <i>{</i>
                status?;
                println!<i>(</i><i>&#34;Child exited!&#34;</i><i>)</i>;
                <i>break</i> <i>&#39;</i>weee
            <i>}</i>,
        <i>}</i>
    <i>}</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, String::from_utf8<i>(</i>out<i>)</i>?<i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;Ok we&#39;re gonna return now&#34;</i><i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
<i>}</i>
</pre></div>
            <picture>
                <source type="image/avif" srcset="/content/articles/a-terminal-case-of-linux/assets/tokio.e4ce4cea7292a773.avif"/>
                <source type="image/webp" srcset="/content/articles/a-terminal-case-of-linux/assets/tokio.9a7aef13dc40a2b3.webp"/>
                <img loading="lazy" src="https://dave.is/content/articles/a-terminal-case-of-linux/assets/tokio.f1800728c40eefa2.jpg" title="" alt=""/>
            </picture>
            
<p>Works like a charm. No channels or explicit threads involved. (tokio&#39;s worker
threads don&#39;t count, this <em>probably</em> would work on the single-threaded runtime
as well).</p>
<div>

<p>Nice, nice... but what&#39;s this <code>^C</code> at the end?</p>
</div>


<div>

<p>IT&#39;S NOTHING. It&#39;s an exercise left to the reader.</p>
</div>
<div>

<p>But doesn&#39;t that mean we-</p>
</div>
<div>

<p>So the program hangs at the end of main. Big deal. We could just call
<code>std::process::exit</code>! That would definitely cut things short.</p>
</div>
<p>Speaking of cutting things short, that&#39;s all I have for you today. As always,
if you&#39;ve liked this video and would like to see more like i- I mean, uhh, I hope
you enjoyed the article, and until next time — take care!</p>

                        <h2>
                            <a id="updates-and-follow-ups" href="#updates-and-follow-ups">
                                Updates and follow-ups
                            </a>
                        </h2>
                        
<p>At this point in time, my audience is large enough and varied enough that every
time I write about something, folks will jump in with an extra dose of cursed
knowledge. And this time was no exception!</p>
<p>First, <a href="https://twitter.com/NieDzejkob/status/1441550915027173376">Jakub
Kądziołka</a> actually
did the exercise left to the reader and figured out why the async/tokio version
was hanging at the end of &#34;main&#34;. It is a very interesting read, and it showcases
the new and still-experimental <a href="https://github.com/tokio-rs/console">tokio
console</a>.</p>
<p>Go read it: <a href="https://niedzejkob.p4.team/amos-nerdsniped-me/">Terminating the terminal case of Linux</a></p>
<p>Second, a whole bunch of folks mentioned that there <em>are</em> ways other than ioctls
to, for example, tell terminal size.
<a href="https://twitter.com/13erbse/status/1441498557819801601">Apparently</a> you can
move the cursor to the bottom right corned, write <code>\e[6n</code> to stdout and it will
reply with the cursor position. For <a href="https://twitter.com/AutumnWalking/status/1441722884423028738">xterm-compatible
terminals</a>, you
can send <code>\e[18t</code> and they&#39;ll reply with <code>\e[8;{rows};{cols}t</code>, and you don&#39;t
even have to move the cursor!</p>
<p>So there <em>are</em> ways to do these in-band, which comes in real handy when all you
have is the stream itself, for <a href="https://twitter.com/13erbse/status/1441499418004541442">reverse shells over the network or virtual character
devices for virtual machines</a>.</p>
<p>Also, <a href="https://twitter.com/Random832/status/1441609795522506756">vim uses that
trick</a> to determine
whether a terminal is in East Asian font mode.</p>
<p>Re: zsh not executing the commands we <code>echo</code> into its pseudo-terminal,
<a href="https://twitter.com/Random832/status/1441612047016345605">apparently</a> there&#39;s
an <code>ioctl</code> named <code>TIOCSTI</code> that <a href="https://marc.info/?l=openbsd-tech&amp;m=149866235528186">lets you simulate terminal input</a>, and thus, inject commands. Fun!</p>
<p>Thanks to y&#39;all for sharing additional cursedness — old systems are <a href="https://www.youtube.com/watch?v=YHIiVsFybLA">always
entertaining</a> to look at.</p>

</div></div>
  </body>
</html>
