<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eugeneyan.com/writing/uncommon-python/">Original</a>
    <h1>Uncommon Uses of Python in Commonly Used Libraries</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>To learn how to build more maintainable and usable Python libraries, I’ve been reading some of the most widely used Python packages. Along the way, I learned some things about Python that are off the beaten path. Here are a few things I didn’t know before.</p>
<h2 id="using-super-in-base-classes">Using <code>super()</code> in base classes</h2>
<p>Python’s <code>super()</code> lets us inherit base classes (aka super or parent classes) without having to explicitly refer to the base class. It’s usually used in the <code>__init__</code> method. While this might be simply a nice-to-have in single inheritance, multiple inheritance is almost impossible without <code>super()</code>.</p>
<p>However, one interesting use of <code>super()</code> is calling it in the <em>base</em> class. I find noticed this in requests’ <a href="https://github.com/psf/requests/blob/main/requests/adapters.py#L71">BaseAdapter</a>.</p>
<div><div><pre><code><span>class</span> <span>BaseAdapter</span><span>:</span>
    <span>&#34;&#34;&#34;The Base Transport Adapter&#34;&#34;&#34;</span>

    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>()</span>

    <span>def</span> <span>send</span><span>(</span><span>self</span><span>,</span> <span>request</span><span>,</span> <span>stream</span><span>=</span><span>False</span><span>,</span> <span>timeout</span><span>=</span><span>None</span><span>,</span> <span>verify</span><span>=</span><span>True</span><span>,</span> <span>cert</span><span>=</span><span>None</span><span>,</span> <span>proxies</span><span>=</span><span>None</span><span>):</span>
</code></pre></div></div>
<p>Given that the base class doesn’t inherit from anything, why call <code>super()</code> in it?</p>
<p>After a bit of digging, here’s what I learned: Using <code>super()</code> in the base class allows for cooperative multiple inheritance. Without it, the <code>__init__</code> calls of parent classes—after a non-supered class—are skipped. Here’s an example with a base class (BaseEstimator) and mixin (ServingMixin), both of which will be inherited by our DecisionTree class.</p>
<p>First, we have a BaseEstimator that doesn’t call <code>super()</code> in its <code>__init__</code> method. It has a basic <code>__repr__</code> method to print attributes.</p>
<div><div><pre><code><span>class</span> <span>BaseEstimator</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        
    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#39;, &#39;</span><span>.</span><span>join</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>k</span><span>}</span><span>: </span><span>{</span><span>v</span><span>}</span><span>&#39;</span> <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>vars</span><span>(</span><span>self</span><span>).</span><span>items</span><span>())</span>
</code></pre></div></div>
<p>Next, we inherit BaseEstimator via the DecisionTree subclass. Everything works fine—printing the DecisionTree instance shows the attributes of BaseEstimator and DecisionTree.</p>
<div><div><pre><code><span>class</span> <span>DecisionTree</span><span>(</span><span>BaseEstimator</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>depth</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>depth</span> <span>=</span> <span>depth</span>

<span>dt</span> <span>=</span> <span>DecisionTree</span><span>(</span><span>name</span><span>=</span><span>&#39;DT&#39;</span><span>,</span> <span>depth</span><span>=</span><span>1</span><span>)</span>
<span>print</span><span>(</span><span>dt</span><span>)</span>
<span>&gt;</span> <span>name</span><span>:</span> <span>DT</span><span>,</span> <span>depth</span><span>:</span> <span>1</span>
</code></pre></div></div>
<p>Now, let’s also inherit ServingMixin and create an instance of DecisionTree.</p>
<div><div><pre><code><span>class</span> <span>ServingMixin</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>mode</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>mode</span> <span>=</span> <span>mode</span>

<span>class</span> <span>DecisionTree</span><span>(</span><span>BaseEstimator</span><span>,</span> <span>ServingMixin</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>depth</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>depth</span> <span>=</span> <span>depth</span>

<span>dt</span> <span>=</span> <span>DecisionTree</span><span>(</span><span>name</span><span>=</span><span>&#39;Request Time DT&#39;</span><span>,</span> <span>depth</span><span>=</span><span>1</span><span>,</span> <span>mode</span><span>=</span><span>&#39;online&#39;</span><span>)</span>
<span>print</span><span>(</span><span>dt</span><span>)</span>
<span>&gt;</span> <span>name</span><span>:</span> <span>Request</span> <span>Time</span> <span>DT</span><span>,</span> <span>depth</span><span>:</span> <span>1</span>

<span>dt</span><span>.</span><span>mode</span>
<span>&gt;</span> <span>AttributeError</span><span>:</span> <span>&#39;DecisionTree&#39;</span> <span>object</span> <span>has</span> <span>no</span> <span>attribute</span> <span>&#39;mode&#39;</span>
</code></pre></div></div>
<p>You’ll notice that ServingMixin isn’t inherited properly: The ServingMixin attribute (mode) doesn’t show when we print our decision tree instance and if we try to access the mode attribute, it doesn’t exist.</p>
<p>This is because, without <code>super()</code> on the BaseEstimator, DecisionTree doesn’t call the next parent class in the <a href="https://realpython.com/python-super/#method-resolution-order">method resolution order</a>.</p>
<p>We can fix this by calling <code>super()</code> in the BaseEstimator and DecisionTree works as expected.</p>
<div><div><pre><code><span>class</span> <span>BaseEstimator</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        
    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#39;, &#39;</span><span>.</span><span>join</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>k</span><span>}</span><span>: </span><span>{</span><span>v</span><span>}</span><span>&#39;</span> <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>vars</span><span>(</span><span>self</span><span>).</span><span>items</span><span>())</span>

<span>class</span> <span>ServingMixin</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>mode</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>mode</span> <span>=</span> <span>mode</span>

<span>class</span> <span>DecisionTree</span><span>(</span><span>BaseEstimator</span><span>,</span> <span>ServingMixin</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>depth</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>().</span><span>__init__</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>depth</span> <span>=</span> <span>depth</span>

<span>dt</span> <span>=</span> <span>DecisionTree</span><span>(</span><span>name</span><span>=</span><span>&#39;Request Time DT&#39;</span><span>,</span> <span>depth</span><span>=</span><span>1</span><span>,</span> <span>mode</span><span>=</span><span>&#39;online&#39;</span><span>)</span>
<span>print</span><span>(</span><span>dt</span><span>)</span>
<span>&gt;</span> <span>name</span><span>:</span> <span>Request</span> <span>Time</span> <span>DT</span><span>,</span> <span>mode</span><span>:</span> <span>online</span><span>,</span> <span>depth</span><span>:</span> <span>1</span>

<span>dt</span><span>.</span><span>mode</span>
<span>&gt;</span> <span>&#39;online&#39;</span>
</code></pre></div></div>
<p>And that’s why we might want to call <code>super()</code> in a base class.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://stackoverflow.com/a/47660836">Calling <code>super()</code> in parent class</a></li>
<li><a href="https://stackoverflow.com/a/27134600">Understanding Python super() with <strong>init</strong>() methods</a></li>
<li><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Python’s super() considered super!</a></li>
</ul>
<h2 id="when-to-use-a-mixin">When to use a Mixin</h2>
<p>A mixin is a class that provides method implementations for reuse by multiple child classes. It is a limited form of multiple inheritance, and is a parent class that simply provides functionality for subclasses, does not contain state, and is not intended to be instantiated. Scikit-learn uses mixins liberally where they have <a href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/base.py#L600">ClassifierMixin</a>, <a href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/base.py#L801">TransformerMixin</a>, <a href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/base.py#L916">OutlierMixin</a>, etc.</p>
<p>When should we use mixins? They are appropriate when we want to (i) provide a lot of optional features for a class and (ii) when we want to use a particular feature in a lot of different classes. Here’s an example of the former. We start with creating a basic request object in werkzeug.</p>
<div><div><pre><code><span>from</span> <span>werkzeug</span> <span>import</span> <span>BaseRequest</span>

<span>class</span> <span>Request</span><span>(</span><span>BaseRequest</span><span>):</span>
    <span>pass</span>
</code></pre></div></div>
<p>If we want to add accept header support, we would update it as follows.</p>
<div><div><pre><code><span>from</span> <span>werkzeug</span> <span>import</span> <span>BaseRequest</span><span>,</span> <span>AcceptMixin</span>

<span>class</span> <span>Request</span><span>(</span><span>AcceptMixin</span><span>,</span> <span>BaseRequest</span><span>):</span>
    <span>pass</span>
</code></pre></div></div>
<p>Need support for user agent, authentication, etc? No problem, just add the mixins.</p>
<div><div><pre><code><span>from</span> <span>werkzeug</span> <span>import</span> <span>BaseRequest</span><span>,</span> <span>AcceptMixin</span><span>,</span> <span>UserAgentMixin</span><span>,</span> <span>AuthenticationMixin</span>

<span>class</span> <span>Request</span><span>(</span><span>AcceptMixin</span><span>,</span> <span>UserAgentMixin</span><span>,</span> <span>AuthenticationMixin</span><span>,</span> <span>BaseRequest</span><span>):</span>
    <span>pass</span>
</code></pre></div></div>
<p>By having these features modularized as mixins—instead of adding them to the base class—we prevent our base class from getting bloated with features that only a few subclasses may use. In addition, these mixins can now be reused by other child classes (that may not inherit from BaseRequest).</p>
<p>Further reading:</p>
<ul>
<li><a href="https://www.pythontutorial.net/python-oop/python-mixin/">Python Mixins</a></li>
<li><a href="https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-is-it-useful">What is a mixin and why is it useful?</a></li>
</ul>
<h2 id="using-relative-imports-almost-all-the-time">Using relative imports (almost all the time)</h2>
<p>Relative imports ensure we search the <em>current</em> package (and import from it) before searching the rest of the <code>PYTHONPATH</code>. We use it by adding <code>.</code> before the package imported. Here’s an example from sklearn’s <a href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/base.py#L21"><code>base.py</code></a>.</p>
<div><div><pre><code><span>from</span> <span>.utils.validation</span> <span>import</span> <span>check_X_y</span>
<span>from</span> <span>.utils.validation</span> <span>import</span> <span>check_array</span>
</code></pre></div></div>
<p>What happens if <code>base.py</code> doesn’t use relative imports? If we have a package named utils in our script’s directory, during import, Python will search <em>our</em> utils package instead of sklearn’s utils package, thus breaking sklearn. The <code>.</code> ensures sklearn’s <code>base.py</code> searches its own <code>utils</code> first.</p>
<p>(That said, is there a reason not to use relative imports? Please comment below!)</p>
<p>Further reading</p>
<ul>
<li><a href="https://peps.python.org/pep-0328/#guido-s-decision">Guido’s Decision on Relative Imports</a></li>
<li><a href="https://stackoverflow.com/questions/22511792/python-from-dotpackage-import-syntax">Python “from [dot]package import …” syntax</a></li>
</ul>
<h2 id="when-to-add-to-__init__py">When to add to <code>__init__.py</code></h2>
<p><code>__init__.py</code> marks directories as Python package directories. The common practice is to leave them empty. Nonetheless, many libraries I read had non-empty and sometimes long <code>__init__.py</code> files. This led me to dig into why we might add to <code>__init__.py</code>.</p>
<p>First, we might add imports to <code>__init__.py</code> when we want to refactor code that has grown into multiple modules <em>without</em> introducing breaking changes to existing users. Say we have a single module (<code>models.py</code>) that contains implementation for <code>DecisionTree</code> and <code>Bandit</code>. Over time, that single module grows into a models package with modules for <code>tree</code> and <code>bandit</code>. To ensure a consistent API for existing users, we might add the following to the <code>__init__.py</code> in the models package.</p>
<div><div><pre><code><span>from</span> <span>.tree</span> <span>import</span> <span>DecisionTree</span><span>,</span> <span>RandomForest</span>
<span>from</span> <span>.bandit</span> <span>import</span> <span>Bandit</span><span>,</span> <span>TSBandit</span>
</code></pre></div></div>
<p>This ensures existing users can continue to import via <code>from models import DecisionTree</code> instead of <code>from models.tree import DecisionTree</code>. To them, there’s no change in API and existing code doesn’t break.</p>
<p>This brings us to another reason why we might add to <code>__init__.py</code>—to provide a simplified API so users don’t have to dig into implementation details. Consider the example package below.</p>
<div><div><pre><code>app
  __init__.py
  model_implementation.py
  data_implementation.py
</code></pre></div></div>
<p>Instead of having users figure out what to import from <code>model_implementation</code> and <code>data_implementation</code>, we can simplify by adding to app’s <code>__init__.py</code> below.</p>
<div><div><pre><code><span>from</span> <span>.model_implementation</span> <span>import</span> <span>SimpleModel</span>
<span>from</span> <span>.data_implementation</span> <span>import</span> <span>SimpleDataLoader</span>
</code></pre></div></div>
<p>This states that SimpleModel and SimpleDataLoader are the only parts of app that users should use, streamlining how they use the app package (i.e., <code>from app import SimpleModel, SimpleDataLoader</code>). And if they know what they’re doing and want to import directly from <code>model_implementation</code>, that’s doable too.</p>
<p>Libraries that do this include <a href="https://github.com/pandas-dev/pandas/blob/main/pandas/__init__.py#L48">Pandas</a>, where datatypes, readers, and the reshape API are imported in <code>__init__.py</code>, and Hugging Face’s <a href="https://github.com/huggingface/accelerate/blob/main/src/accelerate/__init__.py#L7">Accelerate</a>.</p>
<p>Other than what’s mentioned above, we might also want to (i) <a href="https://stackoverflow.com/questions/15727420/using-logging-in-multiple-modules/15729700#15729700">initialize a logger</a> in the main package’s <code>__init__.py</code> for use across multiple modules and (ii) perform <a href="https://github.com/psf/requests/blob/main/requests/__init__.py#L58">compatibility checks</a>.</p>
<p>Further reading</p>
<ul>
<li><a href="https://stackoverflow.com/a/18979314"> What is <code>__init__.py</code> for? </a></li>
<li><a href="https://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/">What’s your opinion on what to include in <code>__init__.py</code>?</a></li>
<li><a href="https://www.reddit.com/r/learnpython/comments/lgbxry/what_do_you_have_in_your_init_py_files/">What do you have in your <code>__init__.py</code> files?</a></li>
</ul>
<h2 id="when-to-use-instance-class-and-static-methods">When to use instance, class, and static methods</h2>
<p>A quick recap of the various methods we can implement for a class:</p>
<ul>
<li>Instance methods need a class instance and can access the instance through <code>self</code></li>
<li>Class methods don’t need an instance. Thus, they can’t access the instance (<code>self</code>) but have access to the class (<code>cls</code>)</li>
<li>Static methods don’t have access to <code>self</code> or <code>cls</code>. They work like regular functions but belong to the class namespace.</li>
</ul>
<p>When should we use class or static methods? Here are some basic guidelines I found.</p>
<p>We use class methods when we want to call it without creating an instance of the class. This is usually when we don’t need instance information but need class information (i.e., its other class or static methods). We might also use class methods as a <a href="https://realpython.com/instance-class-and-static-methods-demystified/#delicious-pizza-factories-with-classmethod">constructor</a>. The benefit of class methods is that we don’t have to hardcode the class, thus allowing subclasses to use the methods too.</p>
<p>We use static methods when we don’t need class or instance arguments, but the method is related to the class and it is convenient for the method to be in the class’s namespace. For example, utility methods specific to the class. By decorating a method as a static method, we improve readability and understanding by telling others that the method doesn’t depend on the class or instance.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://www.pythontutorial.net/python-oop/python-class-methods/">Python Class Methods</a> and <a href="https://www.pythontutorial.net/python-oop/python-static-methods/">Python Static Methods</a></li>
<li><a href="https://stackoverflow.com/a/5738586">What’s an example use case for a Python classmethod?</a></li>
<li><a href="https://stackoverflow.com/a/12179752">Meaning of @classmethod and @staticmethod for beginners?</a></li>
<li><a href="https://stackoverflow.com/a/23508293">Why do we use @staticmethod?</a></li>
<li><a href="https://realpython.com/instance-class-and-static-methods-demystified/">Python’s Instance, Class, and Static Methods Demystified</a></li>
</ul>

<p>The common use of <code>conftest.py</code> is to <a href="https://docs.pytest.org/en/6.2.x/fixture.html#conftest-py-sharing-fixtures-across-multiple-files">provide fixtures for the entire directory</a>. By defining fixtures in <code>conftest.py</code>, they can be used by any test in the package without having to import them. Beyond that, it’s also used to <a href="https://pytest.org/en/latest/how-to/plugins.html#requiring-loading-plugins-in-a-test-module-or-conftest-file">load external plugins</a> and <a href="https://docs.pytest.org/en/6.2.x/reference.html#hooks">define hooks</a> such as setup and teardown methods.</p>
<p>However, while browsing sklearn, I came across an <a href="https://github.com/scikit-learn/scikit-learn/blob/main/conftest.py">empty <code>conftest.py</code></a> which had this interesting comment.</p>
<div><div><pre><code><span># Even if empty this file is useful so that when running from the root folder
# ./sklearn is added to sys.path by pytest. See
# https://docs.pytest.org/en/latest/explanation/pythonpath.html for more
# details. For example, this allows to build extensions in place and run pytest
# doc/modules/clustering.rst and use sklearn from the local folder rather than
# the one from site-packages.
</span></code></pre></div></div>
<p>It turns out that sklearn was taking advantage of a lesser-known feature of <code>conftest.py</code>: By having it in the root path, it ensures that pytest recognizes the modules without having to specify the <code>PYTHONPATH</code>. In the background, pytest modifies the <code>sys.path</code> by including all submodules found in the root path.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://docs.pytest.org/en/latest/explanation/pythonpath.html">pytest import mechanisms and sys.path/PYTHONPATH</a></li>
<li><a href="https://stackoverflow.com/a/34520971">In pytest, what is the use of conftest.py files?</a></li>
</ul>
<h2 id="papers-that-explain-a-librarys-design-principles">Papers that explain a library’s design principles</h2>
<p>Other than reading code, we can also learn by reading papers explaining a library. Let’s focus on the design principles of each library.</p>
<p>Scikit-learn’s <a href="https://arxiv.org/abs/1309.0238">design principles</a> include (i) consistency, where all objects share a consistent interface composed of a limited set of methods, and (ii) composition where objects are implemented via existing building blocks wherever feasible.</p>
<p>As a result, most machine learning models and data transformers have a <code>fit()</code> method. In addition, machine learning models have a <code>predict()</code> method and data transformers have a <code>transform()</code> method. This consistency and simplicity contributes to sklearn’s ease of use. The principle of composition also explains why sklearn is built on multiple inheritance of base classes and mixins.</p>
<p>Another example is fastai which uses a <a href="https://www.mdpi.com/2078-2489/11/2/108/htm">layered approach</a>. It provides a high-level API that provides ready-to-use functionality to train models for various applications. The high-level API is built on a hierarchy of lower-level APIs which provide composable building blocks. This layered approach enables one to quickly build a prototype before customizing by tweaking the middle-layer APIs.</p>
<p><img src="https://eugeneyan.com/assets/fastapi-layers.jpg" loading="lazy" title="Image" alt="Image"/></p>
<p>PyTorch also shared its <a href="https://arxiv.org/abs/1912.01703">design principles</a> such as (i) provide pragmatic performance and (ii) <a href="https://dreamsongs.com/RiseOfWorseIsBetter.html">worse is better</a>. The former states that, to be useful, a library needs to deliver compelling performance but not at the expense of ease of use. Thus, PyTorch is willing to trade off 10% speed, but not 100% speed, for a significantly simpler to use library. The latter states that it’s better to have a simple but slightly incomplete solution than a comprehensive but hard-to-maintain design.</p>
<p>• • •</p>
<p>Those are some of the uncommon usages of Python I’ve learned while reading several libraries such as <a href="https://github.com/psf/requests">requests</a>, <a href="https://github.com/pallets/flask">flask</a>, <a href="https://github.com/tiangolo/fastapi">fastapi</a>, <a href="https://github.com/scikit-learn/scikit-learn">scikit-learn</a>, <a href="https://github.com/pytorch/pytorch">pytorch</a>, <a href="https://github.com/fastai/fastai">fastai</a>, <a href="https://github.com/samuelcolvin/pydantic">pydantic</a>, and <a href="https://github.com/django/django">django</a>. I’m sure I only scratched the surface—did I miss anything? Please comment below!</p>


</div></div>
  </body>
</html>
