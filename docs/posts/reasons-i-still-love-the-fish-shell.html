<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2024/09/12/reasons-i--still--love-fish/">Original</a>
    <h1>Reasons I still love the fish shell</h1>
    
    

<p>I wrote about how much I love fish in <a href="https://jvns.ca/blog/2017/04/23/the-fish-shell-is-awesome/">this blog post from 2017</a> and, 7 years
of using it every day later, I&rsquo;ve found even more reasons to love it. So I
thought I&rsquo;d write a new post with both the old reasons I loved it and some
reasons.</p>

<p>This came up today because I was trying to figure out why my terminal doesn&rsquo;t
break anymore when I cat a binary to my terminal, the answer was &ldquo;fish fixes
the terminal!&ldquo;, and I just thought that was really nice.</p>

<h3 id="1-no-configuration">1. no configuration</h3>

<p>In 10 years of using fish I have never found a single thing I wanted to configure. It just works the way I want. My fish config file just has:</p>

<ul>
<li>environment variables</li>
<li>aliases (<code>alias ls eza</code>, <code>alias vim nvim</code>, etc)</li>
<li>the occasional <code>direnv hook fish | source</code> to integrate a tool like direnv</li>
<li>a script I run to set up my <a href="https://github.com/chriskempson/base16-shell/blob/588691ba71b47e75793ed9edfcfaa058326a6f41/scripts/base16-solarized-light.sh">terminal colours</a></li>
</ul>

<h3 id="2-autosuggestions-from-my-shell-history">2. autosuggestions from my shell history</h3>

<p>My absolute favourite thing about fish is that I type, it’ll automatically
suggest (in light grey) a matching command that I ran recently. I can press the
right arrow key to accept the completion, or keep typing to ignore it.</p>

<p>Here’s what that looks like. In this example I just typed the “v” key and it
guessed that I want to run the previous vim command again.</p>

<p><img src="https://jvns.ca/images/fish-2024.png"></p>

<h3 id="2-5-smart-shell-autosuggestions">2.5 &ldquo;smart&rdquo; shell autosuggestions</h3>

<p>One of my favourite subtle autocomplete features is how fish handles autocompleting commands that contain paths in them. For example, if I run:</p>

<pre><code>$ ls blah.txt
</code></pre>

<p>that command will only be autocompleted in directories that contain <code>blah.txt</code> &ndash; it won&rsquo;t show up in a different directory. (here&rsquo;s <a href="https://github.com/fish-shell/fish-shell/issues/120#issuecomment-6376019">a short comment about how it works</a>)</p>

<p>As an example, if in this directory I type <code>bash scripts/</code>, it&rsquo;ll only suggest
history commands including files that <em>actually exist</em> in my blog&rsquo;s scripts
folder, and not the dozens of other irrelevant <code>scripts/</code> commands I&rsquo;ve run in
other folders.</p>

<p>I didn&rsquo;t understand exactly how this worked until last week, it just felt like fish was
magically able to suggest the right commands. It still feels a little like magic and I love it.</p>

<h3 id="3-pasting-multiline-commands">3. pasting multiline commands</h3>

<p>If I copy and paste multiple lines, bash will run them all, like this:</p>

<pre><code>[bork@grapefruit linux-playground (main)]$ echo hi
hi
[bork@grapefruit linux-playground (main)]$ touch blah
[bork@grapefruit linux-playground (main)]$ echo hi
hi
</code></pre>

<p>This is a bit alarming &ndash; what if I didn&rsquo;t actually <em>want</em> to run all those
commands?</p>

<p>Fish will paste them all at a single prompt, so that I can press Enter if I
actually want to run them. Much less scary.</p>

<pre><code>bork@grapefruit ~/work/&gt; echo hi

                         touch blah
                         echo hi
</code></pre>

<h3 id="4-nice-tab-completion">4. nice tab completion</h3>

<p>If I run <code>ls</code> and press tab, it&rsquo;ll display all the filenames in a nice grid. I can use either Tab, Shift+Tab, or the arrow keys to navigate the grid.</p>

<p>Also, I can tab complete from the <strong>middle</strong> of a filename &ndash; if the filename
starts with a weird character (or if it&rsquo;s just not very unique), I can type
some characters from the middle and press tab.</p>

<p>Here&rsquo;s what the tab completion looks like:</p>

<pre><code>bork@grapefruit ~/work/&gt; ls 
api/  blah.py     fly.toml   README.md
blah  Dockerfile  frontend/  test_websocket.sh
</code></pre>

<p>I honestly don&rsquo;t complete things other than filenames very much so I can&rsquo;t
speak to that, but I&rsquo;ve found the experience of tab completing filenames to be
very good.</p>

<h3 id="5-nice-default-prompt-including-git-integration">5. nice default prompt (including git integration)</h3>

<p>Fish&rsquo;s default prompt includes everything I want:</p>

<ul>
<li>username</li>
<li>hostname</li>
<li>current folder</li>
<li>git integration</li>
<li>status of last command exit (if the last command failed)</li>
</ul>

<p>Here&rsquo;s a screenshot with a few different variations on the default prompt,
including if the last command was interrupted (the <code>SIGINT</code>) or failed.</p>

<p><img src="https://jvns.ca/images/fish-prompt-2024.png"></p>

<h3 id="6-nice-history-defaults">6. nice history defaults</h3>

<p>In bash, the maximum history size is 500 by default, presumably because
computers used to be slow and not have a lot of disk space. Also, by default,
commands don&rsquo;t get added to your history until you end your session. So if your
computer crashes, you lose some history.</p>

<p>In fish:</p>

<ol>
<li>the default history size is 256,000 commands. I don&rsquo;t see any reason I&rsquo;d ever need more.</li>
<li>if you open a new tab, everything you&rsquo;ve ever run (including commands in
open sessions) is immediately available to you</li>
<li>in an existing session, the history search will only include commands from
the current session, plus everything that was in history at the time that
you started the shell</li>
</ol>

<p>I&rsquo;m not sure how clearly I&rsquo;m explaining how fish&rsquo;s history system works here,
but it feels really good to me in practice. My impression is that the way it&rsquo;s
implemented is the commands are continually added to the history file, but fish
only loads the history file once, on startup.</p>

<p>I&rsquo;ll mention here that if you want to have a fancier history system in another
shell it might be worth checking out <a href="https://github.com/atuinsh/atuin">atuin</a> or <a href="https://github.com/junegunn/fzf">fzf</a>.</p>

<h3 id="7-press-up-arrow-to-search-history">7. press up arrow to search history</h3>

<p>I also like fish&rsquo;s interface for searching history: for example if I want to
edit my fish config file, I can just type:</p>

<pre><code>$ config.fish
</code></pre>

<p>and then press the up arrow to go back the last command that included <code>config.fish</code>. That&rsquo;ll complete to:</p>

<pre><code>$ vim ~/.config/fish/config.fish
</code></pre>

<p>and I&rsquo;m done. This isn&rsquo;t <em>so</em> different from using <code>Ctrl+R</code> in bash to search
your history but I think I like it a little better over all, maybe because
<code>Ctrl+R</code> has some behaviours that I find confusing (for example you can
end up accidentally editing your history which I don&rsquo;t like).</p>

<h3 id="8-the-terminal-doesn-t-break">8. the terminal doesn&rsquo;t break</h3>

<p>I used to run into issues with bash where I&rsquo;d accidentally <code>cat</code> a binary to
the terminal, and it would break the terminal.</p>

<p>Every time fish displays a prompt, it&rsquo;ll try to fix up your terminal so that
you don&rsquo;t end up in weird situations like this. I think <a href="https://github.com/fish-shell/fish-shell/blob/a979b6341d7fc4c466b3992f25da3209e0808aaa/src/reader.rs#L3601-L3623">this is some of the
code in fish to prevent broken terminals</a>.</p>

<p>Some things that it does are:</p>

<ul>
<li>turn on <code>echo</code> so that you can see the characters you type</li>
<li>make sure that newlines work properly so that you don&rsquo;t get that weird staircase effect</li>
<li>reset your terminal background colour, etc</li>
</ul>

<p>I don&rsquo;t think I&rsquo;ve run into any of these &ldquo;my terminal is broken&rdquo; issues in a
very long time, and I actually didn&rsquo;t even realize that this was because of
fish &ndash; I thought that things somehow magically just got better, or maybe I
wasn&rsquo;t making as many mistakes. But I think it was mostly fish saving me from
myself, and I really appreciate that.</p>

<h3 id="9-ctrl-s-is-disabled">9. Ctrl+S is disabled</h3>

<p>Also related to terminals breaking: fish disables Ctrl+S (which freezes your
terminal and then you need to remember to press Ctrl+Q to unfreeze it). It&rsquo;s a
feature that I&rsquo;ve never wanted and I&rsquo;m happy to not have it.</p>

<p>Apparently you can disable <code>Ctrl+S</code> in other shells with <code>stty -ixon</code>.</p>

<h3 id="10-fish-add-path">10. <code>fish_add_path</code></h3>

<p>I have mixed feelings about this one, but in Fish you can use <code>fish_add_path
/opt/whatever/bin</code> to add a path to your PATH, globally, permanently, across
all open shell sessions. This can get a bit confusing if you forget where
those PATH entries are configured but overall I think I appreciate it.</p>

<h3 id="11-nice-syntax-highlighting">11. nice syntax highlighting</h3>

<p>By default commands that don&rsquo;t exist are highlighted in red, like this.</p>

<p><img src="https://jvns.ca/images/fish-syntax-2024.png"></p>

<h3 id="12-easier-loops">12. easier loops</h3>

<p>I find the loop syntax in fish a lot easier to type than the bash syntax. It looks like this:</p>

<pre><code>for i in *.yaml
  echo $i
end
</code></pre>

<p>Also it&rsquo;ll add indentation in your loops which is nice.</p>

<h3 id="13-easier-multiline-editing">13. easier multiline editing</h3>

<p>Related to loops: you can edit multiline commands much more easily than in bash
(just use the arrow keys to navigate the multiline command!). Also when you use
the up arrow to get a multiline command from your history, it&rsquo;ll show you the
whole command the exact same way you typed it instead of squishing it all onto
one line like bash does:</p>

<pre><code>$ bash
$ for i in *.png
&gt; do
&gt; echo $i
&gt; done
$ # press up arrow
$ for i in *.png; do echo $i; done ink
</code></pre>

<h3 id="14-ctrl-left-arrow">14. Ctrl+left arrow</h3>

<p>This might just be me, but I really appreciate that fish has the <code>Ctrl+left
arrow</code> / <code>Ctrl+right arrow</code> keyboard shortcut for moving between
words when writing a command.</p>

<p>I&rsquo;m honestly a bit confused about where this keyboard shortcut is coming from
(the only documented keyboard shortcut for this I can find in fish is <code>Alt+left
arrow</code> / <code>Alt + right arrow</code> which seems to do the same thing), but I&rsquo;m pretty
sure this is a fish shortcut.</p>

<p>A couple of notes about getting this shortcut to work:</p>

<ul>
<li>one person said they needed to switch their terminal emulator from the &ldquo;Linux
console&rdquo; keybindings to &ldquo;Default (XFree 4)&rdquo; to get it to work</li>
<li>on Mac OS, <code>Ctrl+left arrow</code> switches workspaces by default, so I had to turn
that off.</li>
</ul>

<h3 id="a-downside-not-everything-has-a-fish-integration">a downside: not everything has a fish integration</h3>

<p>Sometimes tools don&rsquo;t have instructions for integrating them with fish. That&rsquo;s annoying, but:</p>

<ul>
<li>I&rsquo;ve found this has gotten better over the last 10 years as fish has gotten
more popular. For example Python&rsquo;s virtualenv has had a fish integration for
a long time now.</li>
<li>If I need to run a POSIX shell command real quick, I can always just run <code>bash</code> or <code>zsh</code></li>
<li>I&rsquo;ve gotten much better over the years at translating simple commands to fish syntax when I need to</li>
</ul>

<p>My biggest day-to-day to annoyance is probably that for whatever reason I&rsquo;m
still not  used to fish&rsquo;s syntax for setting environment variables, I get confused
about <code>set</code> vs <code>set -x</code>.</p>

<h3 id="on-posix-compatibility">on POSIX compatibility</h3>

<p>When I started using fish, you couldn&rsquo;t do things like <code>cmd1 &amp;&amp; cmd2</code> &ndash; it
would complain &ldquo;no, you need to run <code>cmd1; and cmd2</code>&rdquo; instead.</p>

<p>It seems like over the years fish has started accepting a little more POSIX-style syntax than it used to, like:</p>

<ul>
<li><code>cmd1 &amp;&amp; cmd2</code></li>
<li><code>export a=b</code> to set an environment variable (though this seems a bit limited, you can&rsquo;t do <code>export PATH=$PATH:/whatever</code> so I think it&rsquo;s probably better to learn <code>set</code> instead)</li>
</ul>

<h3 id="on-fish-as-a-default-shell">on fish as a default shell</h3>

<p>Changing my default shell to fish is always a little annoying, I occasionally get myself into a situation where</p>

<ol>
<li>I install fish somewhere like maybe <code>/home/bork/.nix-stuff/bin/fish</code></li>
<li>I add the new fish location to <code>/etc/shells</code> as an allowed shell</li>
<li>I change my shell with <code>chsh</code></li>
<li>at some point months/years later I reinstall fish in a different location for some reason and remove the old one</li>
<li>oh no!!! I have no valid shell! I can&rsquo;t open a new terminal tab anymore!</li>
</ol>

<p>This has never been a major issue because I always have a terminal open
somewhere where I can fix the problem and rescue myself, but it&rsquo;s a bit
alarming.</p>

<p>If you don&rsquo;t want to use <code>chsh</code> to change your shell to fish (which is very reasonable,
maybe I shouldn&rsquo;t be doing that), the <a href="https://wiki.archlinux.org/title/Fish">Arch wiki page</a> has a couple of good suggestions &ndash;
either configure your terminal emulator to run fish or add an <code>exec fish</code> to
your <code>.bashrc</code>.</p>

<h3 id="i-ve-never-really-learned-the-scripting-language">I&rsquo;ve never really learned the scripting language</h3>

<p>Other than occasionally writing a for loop interactively on the command line,
I&rsquo;ve never really learned the fish scripting language. I still do all of my
shell scripting in bash.</p>

<p>I don&rsquo;t think I&rsquo;ve ever written a fish function or <code>if</code> statement.</p>

<h3 id="who-might-fish-be-right-for">who might fish be right for?</h3>

<p>Fish definitely isn&rsquo;t for everyone. I think I like it because:</p>

<ol>
<li>I really dislike configuring my shell (and honestly my dev environment in general), I want things to &ldquo;just work&rdquo; with the default settings</li>
<li>fish&rsquo;s defaults feel good to me</li>
<li>I don&rsquo;t spend that much time logged into random servers using other shells
so there&rsquo;s not too much context switching</li>
<li>I liked its features so much that I was willing to relearn how to do a few
&ldquo;basic&rdquo; shell things, like using parentheses <code>(seq 1 10)</code> to run a command
instead of backticks or using <code>set</code> instead of <code>export</code></li>
</ol>

<p>Maybe you&rsquo;re also a person who would like fish! I hope a few more of the people
who fish is for can find it, because I spend so much of my time in the terminal
and it&rsquo;s made that time much more pleasant.</p>

  </body>
</html>
