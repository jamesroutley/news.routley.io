<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2021/02/a-one-bit-processor-explained-reverse.html">Original</a>
    <h1>A one-bit processor explained: reverse-engineering the vintage MC14500B</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6326583098618894629" itemprop="description articleBody">


<p>The Motorola MC14500B<span id="fnref:suffix"><a href="#fn:suffix">1</a></span> is a 1-bit processor introduced in 1976.
While a 1-bit processor might seem almost useless,<span id="fnref:bitslice"><a href="#fn:bitslice">2</a></span>
it was marketed as an Industrial Control Unit for applications that made simple decisions based on Boolean logic,
for example, air conditioning, motor control, or traffic lights.
<!--
This processor could also modernize control systems that used relay-based <a href="https://en.wikipedia.org/wiki/Relay_logic#Ladder_logic">ladder logic</a>.
--></p>
<p>The die photo below shows the processor under a microscope. This silicon appears greenish, while the white lines on top are the
metal layer that wires the transistors together. The 16 black spots around the edges are the bond wires that connect the chip to
its 16 external pins.
The MC14500B has roughly 500 transistors, very few for a microprocessor.
In comparison, the popular 8-bit Z-80 microprocessor, also released in 1976, had 8500 transistors.
Even the <a href="https://spectrum.ieee.org/tech-history/silicon-revolution/the-surprising-story-of-the-first-microprocessors">first microprocessor</a>, the 4-bit Intel 4004 (1971), contained 2250 transistors.
<!--
The MC14500B used CMOS circuitry, which reduced its density, but the CMOS <a href="https://spectrum.ieee.org/semiconductors/processors/chip-hall-of-fame-rca-cdp-1802">RCA COSMAC 1802</a> microprocessor (also released in 1976) used 8 bits with about 5000 transistors.
Thus, other processors at the time were much more advanced than the MC14500B, so its simple 1-bit construction wasn't due to technological limitations.
--></p>
<p><a href="https://static.righto.com/images/mc14500b/die-labeled.jpg"><img alt="The die of the MC14500B with functional blocks labeled. The pins are labeled around the outside. Die photo from
siliconpr0n
(CC BY 4.0)." height="490" src="https://static.righto.com/images/mc14500b/die-labeled-w600.jpg" title="The die of the MC14500B with functional blocks labeled. The pins are labeled around the outside. Die photo from
siliconpr0n
(CC BY 4.0)." width="600"/></a></p><p>The die of the MC14500B with functional blocks labeled. The pins are labeled around the outside. Die photo from
<a href="https://siliconpr0n.org/archive/doku.php?id=mcmaster:motorola:mc14500">siliconpr0n</a>
(<a href="https://creativecommons.org/licenses/by/4.0/deed.en">CC BY 4.0</a>).</p>
<p>You might think that a 1-bit processor would only support two instructions, making it impractical.
However, like many processors, the MC14500B uses different sizes for data and instructions. Although it used one bit for data,
its instructions were 4 bits, giving it a small but usable instruction set of 16 instructions.<span id="fnref:instructions"><a href="#fn:instructions">3</a></span></p>
<p>The MC14500B has an unusual architecture, making it more of a building block than a complete microprocessor.
In particular, the chip doesn&#39;t include any support for memory or addresses; it didn&#39;t even have a program counter.
The program counter, instruction fetches, jumps, subroutine calls, and I/O needed to be implemented with external circuitry.<span id="fnref:extensions"><a href="#fn:extensions">4</a></span>
This is a key reason that the chip was so simple. (The other reason, of course, was that it only supported one bit.)</p>
<p>Since the MC14500B was designed for industrial control applications, you&#39;d expect it to be a microcontroller,
but it&#39;s the opposite of a microcontroller in many ways.
A typical microcontroller is a computer-on-a-chip including RAM and ROM, with strong I/O support, providing a single-chip solution.
The MC14500B, however, requires multiple external chips to make it usable.</p>
<p><a href="https://static.righto.com/images/mc14500b/mc14500b-package.jpg"><img alt="The MC14500B comes in a 16-pin DIP integrated circuit, much smaller than the 40-pin packages commonly used for microprocessors at the time. The &#34;CP&#34; suffix indicates a plastic package. Photo from siliconpr0n
(CC BY 4.0)." height="180" src="https://static.righto.com/images/mc14500b/mc14500b-package-w350.jpg" title="The MC14500B comes in a 16-pin DIP integrated circuit, much smaller than the 40-pin packages commonly used for microprocessors at the time. The &#34;CP&#34; suffix indicates a plastic package. Photo from siliconpr0n
(CC BY 4.0)." width="350"/></a></p><p>The MC14500B comes in a 16-pin DIP integrated circuit, much smaller than the 40-pin packages commonly used for microprocessors at the time. The &#34;CP&#34; suffix indicates a plastic package. Photo from siliconpr0n
(CC BY 4.0).</p>
<p>The block diagram below shows the internal structure of the chip.
The <em>Data</em> pin in the upper left provides the single-bit I/O line.
It feeds into the <em>Logical Unit</em> (LU), which implements 1-bit Boolean logic functions such as AND and OR.
The result is stored in the <em>Result Register</em> (RR), the chip&#39;s main storage register.
The chip has an on-board oscillator <em>OSC</em> that uses an external resistor to control the clock speed.
(The chip runs at up to 1 megahertz, faster than I expected.)
The <em>Instruction Register</em> stores the 4-bit instruction; the circuitry to decode an instruction occupies the majority of the chip.
The <em>JMP</em>, <em>RTN</em>, <em>FLAG O</em>, and <em>FLAG F</em> pins are activated by the corresponding instructions, but the functionality must be
implemented externally. Note the lack of a program counter or address pins.</p>
<p><a href="https://static.righto.com/images/mc14500b/block-diagram.jpg"><img alt="Block diagram of the MC14500B. From the datasheet." height="384" src="https://static.righto.com/images/mc14500b/block-diagram-w600.jpg" title="Block diagram of the MC14500B. From the datasheet." width="600"/></a></p><p>Block diagram of the MC14500B. From the <a href="http://www.bitsavers.org/components/motorola/14500/MC14500B_Rev3.pdf">datasheet</a>.</p>
<p>The motivation for making such a stripped-down processor was to provide a low-cost alternative for applications that
didn&#39;t require a full microprocessor.
In 1977, the MC14500B cost $7.58 in quantities of 100 ($32 in current dollars), which seems expensive.
<!-- https://www.google.com/search?q=mc14500+cost -->
However, <a href="https://archive.org/details/byte-magazine-1977-09/page/n215/mode/2up?q=8080">at the time</a>,
an 8080A CPU cost $20 and a Z80 cost $50 ($85 and $215 in current dollars) so there was a significant cost saving to the MC14500B.<span id="fnref:nanoprocessor"><a href="#fn:nanoprocessor">5</a></span>
However, the steady fall of processor prices soon made the MC14500B <a href="https://books.google.com/ngrams/graph?content=TMS1000%2CMC14500B&amp;year_start=1970&amp;year_end=1990&amp;corpus=26&amp;smoothing=0&amp;">less attractive</a>.</p>
<h2>How CMOS logic is implemented</h2>
<p>The chip was one of the first processors built from CMOS circuitry,<span id="fnref:cmos"><a href="#fn:cmos">6</a></span> a low-power logic family now used in almost all processors.
CMOS (complementary MOS) circuitry uses two types of transistors, NMOS and PMOS, working together.
The diagram below shows how a PMOS transistor is constructed.
The transistor can be considered a switch between the source and drain, controlled by the gate.
The source and drain (green) consist of regions of silicon doped with impurities to change its semiconductor properties and
called P+ silicon.
The gate consists of an aluminum layer, separated from the silicon by a very thin insulating oxide layer.<span id="fnref:metal-gate"><a href="#fn:metal-gate">7</a></span>
(These three layers—Metal, Oxide, Semiconductor—give the MOS transistor its name.)
The PMOS transistor turns on when the gate is pulled low.</p>
<p><a href="https://static.righto.com/images/mc14500b/mosfet.jpg"><img alt="Structure of a PMOS transistor. An NMOS transistor has the same structure, but with N-type and P-type silicon reversed." height="232" src="https://static.righto.com/images/mc14500b/mosfet-w400.jpg" title="Structure of a PMOS transistor. An NMOS transistor has the same structure, but with N-type and P-type silicon reversed." width="400"/></a></p><p>Structure of a PMOS transistor. An NMOS transistor has the same structure, but with N-type and P-type silicon reversed.</p>
<p>An NMOS transistor has the opposite construction from PMOS: the source and drain consist of N+ silicon embedded in P silicon.
The operation of an NMOS transistor is also opposite from the PMOS transistor: it turns on when the gate is pulled high.
Typically PMOS transistors pull the drain (output) high, while NMOS transistors pull the drain low.
In CMOS, the transistors act in complementary fashion, pulling the output high or low as needed.</p>
<p>Because the NMOS transistor is built in P silicon, but the silicon die itself is N silicon, the NMOS transistors are surrounded by
a tub or well of P silicon. The cross-section diagram below shows how the NMOS transistor on the right is embedded in the well of P-type silicon.
The NMOS and PMOS transistors both require a bias voltage connection to the underlying silicon substrate to block signals from
escaping from the transistors.<span id="fnref:bias"><a href="#fn:bias">8</a></span> These bias connections can be seen scattered across the chip.</p>
<p><a href="https://static.righto.com/images/mc14500b/cmos-cross-section.jpg"><img alt="Cross-section of CMOS transistors." height="214" src="https://static.righto.com/images/mc14500b/cmos-cross-section-w500.jpg" title="Cross-section of CMOS transistors." width="500"/></a></p><p>Cross-section of CMOS transistors.</p>
<p>The basic CMOS gate is an inverter, shown below. It is constructed from a PMOS transistor and an NMOS transistor acting in opposite (i.e. complementary) fashion.
When the input is low, the PMOS transistor (top) turns on, pulling the output high.
When the input is high, the NMOS transistor (bottom) turns on, pulling the output low.</p>
<p><a href="https://static.righto.com/images/mc14500b/inverter-schematic.jpg"><img alt="A CMOS inverter is constructed from a PMOS transistor (top) and an NMOS transistor (bottom)." height="335" src="https://static.righto.com/images/mc14500b/inverter-schematic-w200.jpg" title="A CMOS inverter is constructed from a PMOS transistor (top) and an NMOS transistor (bottom)." width="200"/></a></p><p>A CMOS inverter is constructed from a PMOS transistor (top) and an NMOS transistor (bottom).</p>
<p>The diagram below shows how an inverter, outlined in red, appears on the die.
Note that a single inverter takes a visible part of the die.
The next image zooms in on the inverter; the metal wiring is visible as the white lines, while the silicon is mostly obscured.
The third image shows the silicon layer after removing the metal with acid.
Note how the metal gate lines up with silicon underneath. The circular contacts or vias connect the metal layer to the silicon.</p>
<p><a href="https://static.righto.com/images/mc14500b/inverter-magnified.jpg"><img alt="How an inverter appears on the die. The middle image shows the metal layer. The metal was removed for the last image to show the underlying silicon." height="306" src="https://static.righto.com/images/mc14500b/inverter-magnified-w650.jpg" title="How an inverter appears on the die. The middle image shows the metal layer. The metal was removed for the last image to show the underlying silicon." width="650"/></a></p><p>How an inverter appears on the die. The middle image shows the metal layer. The metal was removed for the last image to show the underlying silicon.</p>
<p>The inverter consists of a PMOS transistor on top and an NMOS transistor below, connected together as described in the schematic earlier.
In the diagram below, the silicon regions have been colored to show how they form transistors.
Note that the source and drain aren&#39;t necessarily discrete, but can merge with neighboring transistors.</p>
<p><a href="https://static.righto.com/images/mc14500b/inverter-die-labeled.jpg"><img alt="The inverter consists of silicon regions doped to form PMOS and NMOS transistors." height="361" src="https://static.righto.com/images/mc14500b/inverter-die-labeled-w250.jpg" title="The inverter consists of silicon regions doped to form PMOS and NMOS transistors." width="250"/></a></p><p>The inverter consists of silicon regions doped to form PMOS and NMOS transistors.</p>
<p>Other logic gates are constructed using the same concepts as the inverter, but with additional transistors.
In a NAND gate, the PMOS transistors on top are in parallel, so the output will be pulled high if either input is 0.
The NMOS transistors on the bottom are in series, so the output will be pulled low if both inputs are 1.
Thus, the circuit implements the NAND function.
(Note how the PMOS and NMOS transistors act in complementary fashion.)
The NOR gate is implemented similarly, swapping the series and parallel transistors. The chip also uses more complex gates, discussed in the footnote.<span id="fnref:complex"><a href="#fn:complex">9</a></span></p>
<p><a href="https://static.righto.com/images/mc14500b/and-or.jpg"><img alt="A NAND gate and a NOR gate are constructed in CMOS by putting transistors in series and parallel." height="426" src="https://static.righto.com/images/mc14500b/and-or-w600.jpg" title="A NAND gate and a NOR gate are constructed in CMOS by putting transistors in series and parallel." width="600"/></a></p><p>A NAND gate and a NOR gate are constructed in CMOS by putting transistors in series and parallel.</p>
<h2>Transmission gate</h2>
<p>Another key circuit in the processor is the <em>transmission gate</em>. This acts as a switch, either passing a signal through or blocking it.
The schematic below shows how a transmission gate is constructed from two transistors, an NMOS transistor and a PMOS transistor.
If the enable line is high, both transistors turn on, passing the input signal to the output.
If the enable line is low, both transistors turn off, blocking the input signal.
The schematic symbol for a transmission gate is shown on the right.</p>
<p><a href="https://static.righto.com/images/mc14500b/transmission-schematic.jpg"><img alt="A transmission gate is constructed from two transistors. The transistors and their gates are indicated. The schematic symbol is on the right." height="202" src="https://static.righto.com/images/mc14500b/transmission-schematic-w400.jpg" title="A transmission gate is constructed from two transistors. The transistors and their gates are indicated. The schematic symbol is on the right." width="400"/></a></p><p>A transmission gate is constructed from two transistors. The transistors and their gates are indicated. The schematic symbol is on the right.</p>
<p>The photo below shows how a transmission gate appears on the die.
This photo shows the metal layer, so the underlying silicon is difficult to see.
The two transistors are outlined.
Note that an inverter has the same input to both gates, so one transistor turns on at a time.
In the transmission gate, however, the gates have opposite inputs, so the transistors turn on or off together.</p>
<p><a href="https://static.righto.com/images/mc14500b/transmission-gate-die.jpg"><img alt="A transmission gate as it appears on the die." height="252" src="https://static.righto.com/images/mc14500b/transmission-gate-die-w500.jpg" title="A transmission gate as it appears on the die." width="500"/></a></p><p>A transmission gate as it appears on the die.</p>
<h2>Flip-flop</h2>
<p>By combining inverters and transmission gates, an important circuit called the flip-flop is constructed.
A flip-flop stores one bit, controlled by a clock signal.
The flip-flops have a key role in the chip as they keep the processor synchronized to the clock.</p>
<p>A flip-flop is based on a latch built from two inverters, below
By connecting two inverters in a loop, the circuit can store either a 0 or a 1. If the input to an inverter is a 1, it outputs a 0;
this causes the other inverter to output a 1, feeding back to the first inverter.
Thus, the circuit is stable in either the 0 or 1 state.</p>
<p><a href="https://static.righto.com/images/mc14500b/inverters.jpg"><img alt="Two cross-coupled inverters can store a 0 or a 1." height="161" src="https://static.righto.com/images/mc14500b/inverters-w350.jpg" title="Two cross-coupled inverters can store a 0 or a 1." width="350"/></a></p><p>Two cross-coupled inverters can store a 0 or a 1.</p>
<p>The circuit above requires two changes to form a useful flip-flop.
First, it requires a way of storing a value in the latch. This is solved in a brute-force way.
One of the inverters uses a weak, low-current transistor.<span id="fnref:weak"><a href="#fn:weak">10</a></span> An input signal can override this signal, forcing the inverters into the
desired state. This input is controlled by a transmission gate: when the gate is active, the input signal is stored in the inverter latch.
When the transmission gate is inactive, the inverter latch loop holds the value.</p>
<p><a href="https://static.righto.com/images/mc14500b/latch-schematic.jpg"><img alt="A flip-flop is constructed from two latches separated by transmission gates." height="325" src="https://static.righto.com/images/mc14500b/latch-schematic-w600.jpg" title="A flip-flop is constructed from two latches separated by transmission gates." width="600"/></a></p><p>A flip-flop is constructed from two latches separated by transmission gates.</p>
<p>The second change is that two inverter latches are used. The first is controlled by the clock, while the second is controlled by the inverted clock. While the clock is high, the input value passes into the first inverter latch.
But when the clock goes low, the transmission gates switch state: the first transmission gate blocks any additional changes, while the second
transmission gate passes the value from the first inverter latch to the second latch and thus the output.
In effect, the flip-flop grabs the input value when the clock switches low, and holds this output until the next time the clock switches low.</p>
<p>The diagram below shows one of the flip-flops in detail (specifically the instruction register bit I3).
It consists of four inverters and two transmission gates, as described earlier but arranged top-to-bottom.
The left half consists of the well of P-type silicon for the NMOS transistors, while the right half holds the NMOS transistors.
As a result, the inverters and transmission gates have one transistor on each side.
This forces some of the gates to have their two transistors widely separated, as seen below.</p>
<p><a href="https://static.righto.com/images/mc14500b/latch-die.jpg"><img alt="Implementation of a flip-flop, as seen on the die. This photo shows the metal layer." height="373" src="https://static.righto.com/images/mc14500b/latch-die-w600.jpg" title="Implementation of a flip-flop, as seen on the die. This photo shows the metal layer." width="600"/></a></p><p>Implementation of a flip-flop, as seen on the die. This photo shows the metal layer.</p>
<p>The diagram below shows the locations of the chip&#39;s flip-flops. 
Each flip-flop takes up a substantial part of the chip, despite being the simple circuit described above. 
This should give you an idea of the small amount of circuitry in the chip.
On the left, the 4-bit instruction register consists of four flip-flops.
The IEN and OEN registers, as well as two flip-flops to control write operations are on the right.
At the bottom, six flip-flops hold the values for the Flag O, RTN, Flag F, and JMP pins, as well as buffering the data mux and
holding the instruction skip state.
The Result Register (RR) in the lower right is a more complex latch; it has circuitry to hold its existing value as well as a reset circuit.</p>
<p><a href="https://static.righto.com/images/mc14500b/flip-flops.jpg"><img alt="Locations of the flip-flops on the die." height="453" src="https://static.righto.com/images/mc14500b/flip-flops-w500.jpg" title="Locations of the flip-flops on the die." width="500"/></a></p><p>Locations of the flip-flops on the die.</p>
<h2>The logic unit</h2>
<p>The logic unit (LU) performs 1-bit operations.<span id="fnref:alu"><a href="#fn:alu">11</a></span> It takes a bit from the data pin, a bit from the RR register, and stores the result in the RR.
It implements seven functions: load a bit into the RR, load the complement into the RR, logical AND, logical AND complement, logical OR,
logical OR complement, and exclusive NOR.
The table below summarizes these operations. Each column shows the results of an operation, for the four possible input combinations.</p>
<p><a href="https://static.righto.com/images/mc14500b/alu-table.jpg"><img alt="The logic unit implements seven different operations, using the RR bit and data pin bit as inputs." height="185" src="https://static.righto.com/images/mc14500b/alu-table-w400.jpg" title="The logic unit implements seven different operations, using the RR bit and data pin bit as inputs." width="400"/></a></p><p>The logic unit implements seven different operations, using the RR bit and data pin bit as inputs.</p>
<p>The colored rectangles indicate how the logic unit is implemented internally.
A green rectangle indicates the data value is copied to the output.
An orange rectangle indicates the complement of the data value is copied to the output.
A blue rectangle indicates that the RR register is OR&#39;d into the result.</p>
<p>The diagram below shows the three complex logic gates that implement this table.
(These are AND-OR-INVERT and OR-AND-INVERT gates, but I&#39;ve removed the inverters to simplify the explanation.)
The appropriate inputs (i.e. colors) are selected based on the instruction and the value of the RR register.
The upper-left gate is active for the combinations of instruction and RR value that use the inverted <em>data</em> value (i.e. orange).
The lower-left gate is active for the combinations that use <em>data</em> (i.e. green).
The right gate selects inverted <em>data</em>, RR, and <em>data</em> as appropriate, and ORs them together to form the final result, stored in the RR register.</p>
<p><a href="https://static.righto.com/images/mc14500b/alu-diagram.jpg"><img alt="The implementation of the logic unit. Note that the colors are associated with conceptual paths, not separate gates." height="359" src="https://static.righto.com/images/mc14500b/alu-diagram-w600.jpg" title="The implementation of the logic unit. Note that the colors are associated with conceptual paths, not separate gates." width="600"/></a></p><p>The implementation of the logic unit. Note that the colors are associated with conceptual paths, not separate gates.</p>
<p>I&#39;ve looked at a lot of Arithmetic-Logic Units (ALUs) before, and this implementation is rather unusual.
The main factor is that it doesn&#39;t perform arithmetic operations, so it&#39;s not dealing with sums, differences, carry-in, and carry-out.
It&#39;s also one bit wide, rather than 8 or 16 bits.
Due to these factors, it&#39;s implemented with the gates shown above, rather than a more typical combination of adders.
Another interesting thing about the implementation is that the logic unit&#39;s circuitry is mixed in with the instruction decoding circuitry,
rather than physically separating the two, as in most processors. (See the die photo at the top of the article.)</p>
<h2>Instruction decoding</h2>
<p>Much of the chip is devoted to instruction decoding, converting a 4-bit opcode into an instruction signal.
Although many microprocessors, such as the 6502, use a Programmable Logic Array (PLA) for instruction decoding,
the MC14500B doesn&#39;t use anything structured like that.
Instead, it just has a bunch of gates. First, it decodes pairs of instruction bits (bit 0 with bit 1, and bit 2 with bit 3) into their
combinations. Then it combines these signals for the full decoding.</p>
<p>For instance, one signal is generated if instruction bits I3 and I2 are high, by NOR of I3&#39; and I2&#39;. Another signal is generated if I1 is high and I0 is low, by NOR of I1&#39; and I0.
Combining these two signals with a NAND gate generates a signal that is low for the SKZ (skip on zero) instruction which has the opcode 1110.
This signal is fed into the instruction skip circuitry to implement the instruction.
The other instructions are decoded by similar combinations of gates.</p>
<h2>Control flow</h2>
<p>The MC14500B uses several techniques to provide control flow in programs.
Its conditional instruction is <code>SKZ</code>, which skips the next instruction if the RR register is zero.
The chip implements the skip instruction by setting a flip-flop if the next instruction should be skipped.
If so, the next instruction is overridden by the opcode 0000 through some gates on the instruction pins.
This opcode corresponds to the <code>NOP O</code> instruction. This instruction normally energizes the O pin, but the skip circuit suppresses this too.
The result is that the skip circuit suppresses the next instruction, and then execution continues.</p>
<p>The chip has opcodes for jump (<code>JMP</code>) and return from subroutine (<code>RTN</code>). These instructions don&#39;t do much other than energizing
the JMP or RTN pins.<span id="fnref:rtn"><a href="#fn:rtn">12</a></span> These operations must be implemented by external circuitry if desired.</p>
<p>The chip provides an unusual technique for implementing larger conditional code blocks.
Write operations are controlled by the OEN (Output ENable) flip-flop.
To suppress a block of code, the OEN flip-flop can be cleared. The code will still be executed, but it won&#39;t have any effect since the
output is disabled, so it acts like an IF-THEN block.
Similarly, the IEN (Input Enable) instruction will disable the input.
These instructions provide conditional execution even if the hardware isn&#39;t implemented for the jump instruction.</p>
<p>Finally, a recommended implementation is to wire the F pin to the program counter&#39;s reset line. <!-- page 39 of handbook -->
Then, the NOP F instruction will cause the program counter to return to the start of the code.
This permits a processing loop to be implemented very simply.</p>
<h2>Conclusion</h2>
<p>The MC14500B processor is simple enough that its circuitry can be reverse-engineered and understood.
To summarize the chip&#39;s operations, it takes a 4-bit instruction, which is stored in the instruction register (four flip-flops) and then decoded (using a large number of gates).
A logic instruction takes a value from the RR register and the <em>data</em> pin.
The &#34;Logic Unit&#34; uses three complex gates in a clever arrangement to perform the selected Boolean operation, and the result is stored
back in the RR register.
The processor has other flip-flops to handle write operations and other instructions.
Execution is controlled by the on-chip clock.</p>
<!--
Since every instruction takes one cycle, the chip doesn't have the control and sequencing circuitry required by most processors.
Because the program counter and address handling are outside the chip, its circuitry is much simpler than other processors.
Despite its simplicity, the MC14500B isn't a toy processor, but a useful industrial controller.
-->

<p>The MC14500B is an unusual processor, handling just one bit of data, while off-loading functionality such as the program counter.
Although a one-bit processor might seem like a joke at first, it had genuine uses for implementing logic-based industrial controllers.
It seems like an evolutionary dead-end, though. Larger 4-bit and 8-bit microcontrollers were very popular, while the MC14500B
was a niche product.</p>
<p>Thanks to David of <a href="https://www.youtube.com/channel/UCE4xstUnu0YmkG-W9_PyYrQ">Usagi Electric</a> for driving the MC14500B analysis project
and thanks to John McMaster for decapping the chips and creating the <a href="https://siliconpr0n.org/archive/doku.php?id=mcmaster:motorola:mc14500">MC14500B images</a>
(<a href="https://creativecommons.org/licenses/by/4.0/deed.en">CC BY 4.0</a>).
I first heard about the MC14500B from <a href="https://news.ycombinator.com/item?id=5125112">jonsen</a> back in 2013.
I announce my latest blog posts on Twitter, so follow me <a href="https://twitter.com/kenshirriff">@kenshirriff</a>. I also have an <a href="http://www.righto.com/feeds/posts/default">RSS feed</a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
