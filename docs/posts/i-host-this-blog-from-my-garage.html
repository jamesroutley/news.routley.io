<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eevans.co/blog/garage/">Original</a>
    <h1>I Host This Blog from My Garage</h1>
    
    <div id="readability-page-1" class="page"><div>
<nav>
<section>
<a href="https://eevans.co/">
Home
</a>


<ul>
<li>
<a href="https://eevans.co/blog/">Blog</a>
</li>
<li>
<a href="https://eevans.co/about/">About Me</a>
</li>
<li>
<a href="https://eevans.co/contact/">Contact</a>
</li>
</ul>
</section>
</nav>
<div>
<section>
<article>
<header>


</header>
<div>
<p>
Over the past few years I&#39;ve been running some servers in my garage as a
Kubernetes <a href="https://www.reddit.com/r/homelab/">homelab</a>. I really like homelabbing—having my own hardware lying
around is great for tinkering with the latest and greatest &#34;cloud native&#34;
technologies, and it just makes me feel kind of warm and fuzzy to host some of
my own tools instead of relying on external services. (For instance, I use <a href="https://gitea.com/">Gitea</a>
to host all of my private git repositories.)</p>
<p>
My homelab has gone through a number of iterations and has gotten increasingly
complex and &#34;enterprisey&#34; as I&#39;ve piled on software I want to try but definitely
don&#39;t need. But I&#39;ve always been extremely hesitant to publicly expose anything
to the internet. It&#39;s one thing to run a <a href="https://jellyfin.org/">media server</a> that can be accessed over
<a href="https://www.wireguard.com/">WireGuard</a>, but it&#39;s another thing entirely to open up HTTP ports on a home
firewall—a few misconfigurations and your home network could be open to DDoS,
hacking, or worse!</p>
<p>
A few weeks ago I decided to finally take the plunge and try hosting this blog
from my garage. If you&#39;re reading this, it either means that it&#39;s working or
that I&#39;ve chickened out!</p>
<figure>
<a href="https://eevans.co/blog/garage/badserver.jpg"><img src="https://eevans.co/blog/garage/badserver.jpg" alt="badserver.jpg"/></a><figcaption>
An old homelab iteration—it doesn&#39;t look quite this bad nowadays
</figcaption>
</figure>
<div id="outline-container-headline-1">
<h2 id="headline-1">
The Cluster
</h2>
<div id="outline-text-headline-1">
<p>My homelab cluster has three fairly low-powered x86 servers running <a href="https://www.flatcar-linux.org/">Flatcar
Linux</a>, which is &#34;just enough operating system&#34; to get Kubernetes running on bare
metal. All three servers run the Kubernetes control plane with <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/">high availability</a>
along with all my other &#34;normal&#34; workloads. (If I had a bunch more servers I&#39;d
try to separate out the Kubernetes control plane, but it seems to be working
fine as is.)</p>
<p>
A general tendency with homelabs is to run more &#34;infrastructure-level&#34; software
than actual applications, and mine is no exception. Here&#39;s an incomplete list of
things I&#39;m running to keep everything running:</p>
<ul>
<li>
<p><a href="https://cilium.io/">Cilium</a> for cluster networking—this gives me a &#34;supercharged&#34; network plugin
that does nifty things like encrypt all the traffic between nodes and provide
<a href="https://docs.cilium.io/en/v1.10/policy/language/#layer-7-examples">layer 7 firewall rules</a> (more on that later).</p>
</li>
<li>
<p><a href="https://metallb.org/">MetalLB</a> for load balancing—this provides Kubernetes <code>LoadBalancer</code> services in
non-&#34;cloudy&#34; environments (like my garage).</p>
</li>
<li>
<p><a href="https://kubernetes.github.io/ingress-nginx/">nginx</a> for ingress—every once in a while I think about trying a <a href="https://docs.google.com/spreadsheets/d/191WWNpjJ2za6-nbG4ZoUMXMpUK8KlCIosvQB0f-oq3k/edit#gid=907731238">different
ingress controller</a>, but none of the free ones have been compelling enough to
lure me away from nginx.</p>
</li>
<li>
<p><a href="https://rook.io/">Rook</a> for clustered storage—this gives me <a href="https://ceph.com/en/">Ceph</a>-backed storage that can be
accessed through Kubernetes <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a>. The volumes stay available
even when a server is down, and you can access the data in a few different
ways (including S3-style object storage). I&#39;ve been extremely impressed with
Rook and Ceph, and it hasn&#39;t been as hard to keep running as I feared it might
be.</p>
</li>
<li>
<p><a href="https://prometheus.io/">Prometheus</a>/<a href="https://grafana.com/">Grafana</a> for monitoring and alerting—this is basically table stakes
for Kubernetes clusters these days, but it&#39;s a pretty great stack.</p>
</li>
<li>
<p><a href="https://grafana.com/oss/loki/">Loki</a> for log aggregation—I switched to Loki recently after trying for ages to
figure out a decent ElasticSearch setup, and it&#39;s just so much better. Loki is
pretty easy to get running, and you access your logs through Grafana along
with your metrics (I didn&#39;t realize what a good idea this is until I tried
it).</p>
</li>
<li>
<p><a href="https://goharbor.io/">Harbor</a> as a private container registry—I&#39;ve had some trouble with this one but
it works well enough.</p>
</li>
<li>
<p><a href="https://fluxcd.io/">Flux</a> for deploying everything with <a href="https://www.gitops.tech/">GitOps</a> (I have somewhat mixed feelings
about GitOps in general, but Flux is refreshingly simple and does the job).</p>
</li>
</ul>
<p>To stave off the inevitable haters: <strong>I know this is over-engineered</strong>. That&#39;s
kind of the point! By trying out &#34;flashy&#34; software in a low-stakes environment,
I can have some idea of how it will work in production-critical ones, which
helps me make better choices. (As an example, my attempts to run Istio in a
homelab setting have convinced me that it should be avoided in most
circumstances.)</p>
<p>
But I&#39;m getting sidetracked, back to how I host the blog.</p>
</div>
</div>
<div id="outline-container-headline-2">
<h2 id="headline-2">
Making Some Stuff Public
</h2>
<div id="outline-text-headline-2">
<p>Until a few weeks ago this all existed in my happy self-contained local network,
free from the terrors of the public internet. But I&#39;ve thought for a while that
it&#39;s silly to have all this infrastructure sitting around and still pay for
cloud hosting. (Well, if I&#39;m being honest, the blog was only costing me a few
dollars a month on <a href="https://cloud.google.com/storage/">GCS</a>, but it&#39;s the principle dammit!)</p>
<p>
If I were a less paranoid person, I would set up my home firewall to forward
ports 80 and 443 to my cluster ingress IP address, add some public DNS records,
and call it a day. But that would have two problems:</p>
<ul>
<li>
<p>My home internet connection doesn&#39;t have a static IP address, so there&#39;d be
<a href="https://en.wikipedia.org/wiki/Dynamic_DNS">dynamic DNS</a> futzing involved (never fun, but not a deal breaker if occasional
downtime is OK).</p>
</li>
<li>
<p>More importantly: if I didn&#39;t do everything exactly right I could have ended
up exposing all my private services to the internet, which would be a
disaster! (I try to run all my self-hosted apps with proper auth and
encryption, but you never know…) And even if I did do everything right,
there&#39;s always <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">DDoS</a> to worry about.</p>
</li>
</ul>
<p>I considered a few options (including some exotic ones like using a Raspberry Pi
as a kind of <a href="https://www.barracuda.com/glossary/dmz-network">DMZ</a>), but the solution I landed on is to use a <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps">Cloudflare Tunnel</a> (I
guess formerly known as Argo Tunnel? Cloudflare&#39;s branding confuses me
sometimes). Which is kind of like an industrial-grade version of <a href="https://ngrok.com/">ngrok</a>: you run
a local daemon called <code>cloudflared</code> that connects to Cloudflare&#39;s
infrastructure, and then you get a &#34;magic URL&#34; that forwards connections from
the internet through the daemon to your local network.</p>
<p>
This approach solves a lot of problems at once: there&#39;s no need to open up any
inbound firewall ports (hooray!); I don&#39;t need to set up dynamic DNS records for
my home IP address (which would, among other things, have some bad privacy
implications); and I get Cloudflare&#39;s DDoS protection and CDN features (which I
would have wanted anyways for the blog). And crazily enough, it&#39;s all free!</p>
<p>
Deploying <code>cloudflared</code> on Kubernetes is pretty straightforward: I just use a
standard Kubernetes <code>Deployment</code> with the <a href="https://hub.docker.com/r/cloudflare/cloudflared">cloudflared Docker image</a> and two
replicas for redundancy. The <code>cloudflared</code> pods have a basic configuration that
forwards all traffic to an ingress controller.</p>
<figure>
<img src="https://eevans.co/blog/garage/traffic.svg" alt="traffic.svg" title="traffic.svg"/><figcaption>
The convoluted path your packets are following to get this content
</figcaption>
</figure>
</div>
</div>
<div id="outline-container-headline-3">
<h2 id="headline-3">
Adding a Healthy Sprinkle of Paranoia
</h2>
<div id="outline-text-headline-3">
<p>Using a Cloudflare Tunnel solved the big issue of exposing my home network to
the internet, but it wasn&#39;t quite enough to assuage my fears. I took a few steps
to lock things down even more.</p>
<div id="outline-container-headline-4">
<h3 id="headline-4">
Deploying a Separate Ingress Controller
</h3>
<div id="outline-text-headline-4">
<p>I don&#39;t want traffic for the blog getting mixed up with traffic for my internal
apps, so I deployed a <a href="https://kubernetes.github.io/ingress-nginx/user-guide/multiple-ingress/">separate instance of ingress-nginx</a> in a new
namespace. This is pretty easy to manage thanks to Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-class">ingress classes</a>:
for public apps, I can create <code>Ingress</code> resources with <code>ingressClassName:
nginx-public</code> and everything works out OK.</p>
<p>
Nothing earth-shattering here, but worth mentioning since it&#39;s a good idea for
any Kubernetes cluster that handles both private and public traffic.</p>
</div>
</div>
<div id="outline-container-headline-5">
<h3 id="headline-5">
Locking Down Pods
</h3>
<div id="outline-text-headline-5">
<p>Again somewhat boring, but I try to follow all the standard &#34;security best
practices&#34; for pods that could get public traffic, like making sure they all
have <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">resource requests/limits</a> and adding a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">security context</a> like:</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span>securityContext</span>:
  <span>capabilities</span>:
    <span>drop</span>:
      - ALL
  <span>readOnlyRootFilesystem</span>: <span>true</span>
  <span>runAsNonRoot</span>: <span>true</span>
  <span>allowPrivilegeEscalation</span>: <span>false</span></code></pre></div>
</div>
<p>
I don&#39;t really know much difference these things make (they&#39;re basically handed
down from on high by The Security People), but I&#39;m not a security expert so who
am I to argue.</p>
</div>
</div>
<div id="outline-container-headline-6">
<h3 id="headline-6">
Locking Down Traffic
</h3>
<div id="outline-text-headline-6">
<p>What I <em>actually</em> care about from a security perspective is making sure that no
traffic from the internet can <em>ever</em> reach anything private on my
network. Kubernetes has a tool for solving these sorts of problems: <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">network
policies</a> (which basically specify firewall rules for pods). The rules I wanted
for my &#34;public&#34; traffic flow were something like:</p>
<ul>
<li>
<p><code>cloudflared</code> is allowed to talk to Cloudflare and the nginx ingress
controller, but that&#39;s it (since it&#39;s more or less &#34;untrusted&#34;).</p>
</li>
<li>
<p><code>ingress-nginx</code> is allowed to talk to:</p>
<ul>
<li>
<p>The Kubernetes API (necessary since it&#39;s an ingress controller).</p>
</li>
<li>
<p>Any pods in the cluster with a special <code>public</code> label, but no other pods
(that way even if I misconfigure an <code>Ingress</code>, the public ingress controller
won&#39;t be able to reach private pods).</p>
</li>
</ul>
</li>
</ul>
<p>Kubernetes network policies are pretty &#34;dumb&#34;: they allow you to filter traffic
based on IP addresses and pod/namespace labels. That was a problem for the
<code>cloudflared</code> rules: I really wanted to allow access to DNS addresses (like
<code>api.cloudflare.com</code>) instead of IP addresses (in network-speak: I wanted a
layer 7 policy instead of layer 4).</p>
<p>
Cilium actually makes that possible through <a href="https://docs.cilium.io/en/v1.10/concepts/kubernetes/policy/#ciliumnetworkpolicy"><code>CliumNetworkPolicy</code></a>s, which are
supercharged network policies that allow layer 7 filtering. Here&#39;s what the
<code>cloudflared</code> policy ended up looking like (slightly shortened):</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span>apiVersion</span>: cilium.io/v2
<span>kind</span>: CiliumNetworkPolicy
<span>metadata</span>:
  <span>name</span>: cloudflared-egress
  <span>namespace</span>: ingress-public
<span>spec</span>:
  <span>endpointSelector</span>:
    <span>matchLabels</span>:
      <span>app.kubernetes.io/instance</span>: cloudflared
  <span>egress</span>:
    <span># ...</span>
    <span># Allow tunnel connections to Cloudflare</span>
    - <span>toFQDNs</span>:
        - <span>matchPattern</span>: <span>&#34;*.argotunnel.com&#34;</span>
      <span>toPorts</span>:
        - <span>ports</span>:
            - <span>port</span>: <span>&#34;7844&#34;</span>
    <span># Allow traffic to the Cloudflare API</span>
    - <span>toFQDNs</span>:
        - <span>matchName</span>: api.cloudflare.com
      <span>toPorts</span>:
        - <span>ports</span>:
            - <span>port</span>: <span>&#34;443&#34;</span>
    <span># Allow traffic to the ingress controller</span>
    - <span>toEndpoints</span>:
        - <span>matchLabels</span>:
            <span>app.kubernetes.io/instance</span>: ingress-public
      <span>toPorts</span>:
        - <span>ports</span>:
            - <span>port</span>: <span>&#34;443&#34;</span>
        - <span>ports</span>:
            - <span>port</span>: <span>&#34;80&#34;</span></code></pre></div>
</div>
<p>
(There are similar policies for the ingress controller pods, but I don&#39;t want to
inundate you with YAML so I&#39;ll leave them out.) The policy files are a bit
verbose, but Cilium has a cool <a href="https://editor.cilium.io/">GUI policy editor</a> that makes them easier to
generate.</p>
<figure>
<img src="https://eevans.co/blog/garage/policy.png" alt="policy.png" title="policy.png"/><figcaption>
A visual representation of the <code>cloudflared</code> network policy
</figcaption>
</figure>
<p>
The upshot is that even if a <code>cloudflared</code> pod were to be compromised somehow,
it would have very few opportunities to wreak havoc in my local network (at
least that&#39;s what I&#39;m hoping 🤞).</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7">
<h2 id="headline-7">
The Actual Content
</h2>
<div id="outline-text-headline-7">
<p>What about the actual website content? Here I ended up with a pretty boring
solution:</p>
<ul>
<li>
<p>Static HTML/CSS/etc. is generated with <a href="https://gohugo.io/">Hugo</a> (which I was already using).</p>
</li>
<li>
<p>I build an extremely simple Docker image based on an <a href="https://hub.docker.com/r/nginxinc/nginx-unprivileged/">nginx image</a> with all the
static content copied in (along with a basic nginx configuration file).</p>
</li>
<li>
<p>I deploy the blog image with a standard Kubernetes <code>Deployment</code>.</p>
</li>
</ul>
<p>So I use oodles of the latest and greatest in Cloud Native technologies
configured with thousands of lines of YAML to ultimately serve static HTML in a
way not too different from how any self-respecting webmaster would have done it
in the 90s. Hooray for technological progress.</p>
<p>
At least performance seems pretty decent (round trip requests are about 50ms
uncached for me).</p>
</div>
</div>
<div id="outline-container-headline-8">
<h2 id="headline-8">
Maybe Try This At Home
</h2>
<div id="outline-text-headline-8">
<p>Well, hosting a blog from home is probably not a great idea from a practical
perspective. (I&#39;ll see how this experiment works out…) But self hosting and
homelabbing in general can be a rewarding way to hone your DevOps/sysadmin
skills and maybe even get more control of your data, if you&#39;re into that sort of
thing.</p>
<p>
If you haven&#39;t given homelabbing a try and you&#39;re curious, here are some
resources that I&#39;ve found helpful:</p>
<ul>
<li>
<p>The <a href="https://www.reddit.com/r/homelab/">homelab</a> and <a href="https://www.reddit.com/r/selfhosted/">SelfHosted</a> subreddits</p>
</li>
<li>
<p>The <a href="https://selfhosted.show/">Self Hosted</a> podcast</p>
</li>
<li>
<p><a href="https://www.youtube.com/c/JeffGeerling">Jeff Geerling&#39;s YouTube channel</a> (especially for Raspberry Pi craziness—if I
were starting over from scratch I&#39;d probably go with Raspberry Pis to keep
power usage down)</p>
</li>
</ul>
<p>If you like this stuff, <a href="https://twitter.com/EmanuelMEvans">let me know</a> and I might do some more posts on homelab
adventures.</p>
</div>
</div>
</div>

</article>
</section>
</div>

</div></div>
  </body>
</html>
