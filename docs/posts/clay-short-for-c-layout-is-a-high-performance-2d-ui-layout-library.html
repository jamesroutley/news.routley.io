<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/nicbarker/clay">Original</a>
    <h1>Clay (short for C Layout) is a high performance 2D UI layout library</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong><em>Clay</em></strong> (short for <strong>C Layout</strong>) is a high performance 2D UI layout library.</p>

<ul dir="auto">
<li>Microsecond layout performance</li>
<li>Flex-box like layout model for complex, responsive layouts including text wrapping, scrolling containers and aspect ratio scaling</li>
<li>Single ~2k LOC <strong>clay.h</strong> file with <strong>zero</strong> dependencies (including no standard library)</li>
<li>Wasm support: compile with clang to a 15kb uncompressed <strong>.wasm</strong> file for use in the browser</li>
<li>Static arena based memory use with no malloc / free, and low total memory overhead (e.g. ~3.5mb for 8192 layout elements).</li>
<li>React-like nested declarative syntax</li>
<li>Renderer agnostic: outputs a sorted list of rendering primitives that can be easily composited in any 3D engine, and even compiled to HTML (examples provided)</li>
</ul>
<p dir="auto">Take a look at the <a href="https://nicbarker.com/clay" rel="nofollow">clay website</a> for an example of clay compiled to wasm and running in the browser, or others in the <a href="https://github.com/nicbarker/clay/tree/main/examples">examples directory</a>.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/356993468-9986149a-ee0f-449a-a83e-64a392267e3d.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM1Njk5MzQ2OC05OTg2MTQ5YS1lZTBmLTQ0OWEtYTgzZS02NGEzOTIyNjdlM2QucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NjAzYjJhN2M4NThkMDE2MTc5Yjk2MmU0MmJkNjZiNTk3YWNjNDgyNjVjYzRiNmVkM2Q5MzQ1ODUzNmQxNTEyMiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.iaflHqZM5chxoX2boAjapsn3TnmcSynCChovIzits1o"><img width="1394" alt="A screenshot of a code IDE with lots of visual and textual elements" src="https://private-user-images.githubusercontent.com/2264338/356993468-9986149a-ee0f-449a-a83e-64a392267e3d.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM1Njk5MzQ2OC05OTg2MTQ5YS1lZTBmLTQ0OWEtYTgzZS02NGEzOTIyNjdlM2QucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NjAzYjJhN2M4NThkMDE2MTc5Yjk2MmU0MmJkNjZiNTk3YWNjNDgyNjVjYzRiNmVkM2Q5MzQ1ODUzNmQxNTEyMiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.iaflHqZM5chxoX2boAjapsn3TnmcSynCChovIzits1o"/></a>
<p dir="auto"><em>An example GUI application built with clay</em></p>

<ol dir="auto">
<li>Download or clone clay.h and include it.</li>
</ol>

<ol start="2" dir="auto">
<li>Ask clay for how much static memory it needs using <a href="#clay_minmemorysize">Clay_MinMemorySize()</a>, create an Arena for it to use with <a href="#clay_createarenawithcapacityandmemory">Clay_CreateArenaWithCapacityAndMemory(size, void *memory)</a>, and initialize it with <a href="#clay_initialize">Clay_Initialize(arena)</a>.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="// Note: malloc is only used here as an example, any allocator that provides
// a pointer to addressable memory of at least totalMemorySize will work
uint64_t totalMemorySize = Clay_MinMemorySize();
Clay_Arena arena = Clay_CreateArenaWithCapacityAndMemory(totalMemorySize, malloc(totalMemorySize));
Clay_Initialize(arena);"><pre><span>// Note: malloc is only used here as an example, any allocator that provides</span>
<span>// a pointer to addressable memory of at least totalMemorySize will work</span>
<span>uint64_t</span> <span>totalMemorySize</span> <span>=</span> <span>Clay_MinMemorySize</span>();
<span>Clay_Arena</span> <span>arena</span> <span>=</span> <span>Clay_CreateArenaWithCapacityAndMemory</span>(<span>totalMemorySize</span>, <span>malloc</span>(<span>totalMemorySize</span>));
<span>Clay_Initialize</span>(<span>arena</span>);</pre></div>
<ol start="3" dir="auto">
<li>Provide a <code>MeasureText(text, config)</code> function pointer with <a href="#clay_setmeasuretextfunction">Clay_SetMeasureTextFunction(function)</a> so that clay can measure and wrap text.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="// Example measure text function
static inline Clay_Dimensions MeasureText(Clay_String *text, Clay_TextElementConfig *config) {
    // Clay_TextElementConfig contains members such as fontId, fontSize, letterSpacing etc
    // Note: Clay_String-&gt;chars is not guaranteed to be null terminated
}

// Tell clay how to measure text
Clay_SetMeasureTextFunction(MeasureText);"><pre><span>// Example measure text function</span>
<span>static</span> <span>inline</span> <span>Clay_Dimensions</span> <span>MeasureText</span>(<span>Clay_String</span> <span>*</span><span>text</span>, <span>Clay_TextElementConfig</span> <span>*</span><span>config</span>) {
    <span>// Clay_TextElementConfig contains members such as fontId, fontSize, letterSpacing etc</span>
    <span>// Note: Clay_String-&gt;chars is not guaranteed to be null terminated</span>
}

<span>// Tell clay how to measure text</span>
<span>Clay_SetMeasureTextFunction</span>(<span>MeasureText</span>);</pre></div>
<ol start="4" dir="auto">
<li><strong>Optional</strong> - Call <a href="#clay_setpointerposition">Clay_SetPointerPosition(pointerPosition)</a> if you want to use mouse interactions.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="// Update internal pointer position for handling mouseover / click / touch events
Clay_SetPointerPosition((Clay_Vector2) { mousePositionX, mousePositionY });"><pre><span>// Update internal pointer position for handling mouseover / click / touch events</span>
<span>Clay_SetPointerPosition</span>((<span>Clay_Vector2</span>) { <span>mousePositionX</span>, <span>mousePositionY</span> });</pre></div>
<ol start="5" dir="auto">
<li>Call <a href="#clay_beginlayout">Clay_BeginLayout(screenWidth, screenHeight)</a> and declare your layout using the provided macros.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="const Clay_Color COLOR_LIGHT = (Clay_Color) {224, 215, 210, 255};
const Clay_Color COLOR_RED = (Clay_Color) {168, 66, 28, 255};
const Clay_Color COLOR_ORANGE = (Clay_Color) {225, 138, 50, 255};

// Layout config is just a struct that can be declared statically, or inline
Clay_LayoutConfig sidebarItemLayout = (Clay_LayoutConfig) {
    .sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_FIXED(50) },
};

// Re-useable components are just normal functions
void SidebarItemComponent(int index) {
    CLAY_RECTANGLE(CLAY_IDI(&#34;SidebarBlob&#34;, index), sidebarItemLayout, CLAY_RECTANGLE_CONFIG(.color = COLOR_ORANGE), {});
}

// An example function to begin the &#34;root&#34; of your layout tree
Clay_RenderCommandArray CreateLayout() {
    Clay_BeginLayout(windowWidth, windowHeight);

    // An example of laying out a UI with a fixed width sidebar and flexible width main content
    CLAY_RECTANGLE(CLAY_ID(&#34;OuterContainer&#34;), CLAY_LAYOUT(.sizing = {CLAY_SIZING_GROW(), CLAY_SIZING_GROW()}, .padding = {16, 16}, .childGap = 16), CLAY_RECTANGLE_CONFIG(.color = {250,250,255,255}) {
        CLAY_RECTANGLE(CLAY_ID(&#34;SideBar&#34;), CLAY_LAYOUT(.layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16), CLAY_RECTANGLE_CONFIG(.color = COLOR_LIGHT), {
            CLAY_RECTANGLE(CLAY_ID(&#34;ProfilePictureOuter&#34;), CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER }), CLAY_RECTANGLE_CONFIG(.color = COLOR_RED), {
                CLAY_IMAGE(CLAY_ID(&#34;ProfilePicture&#34;), CLAY_LAYOUT( .sizing = { .width = CLAY_SIZING_FIXED(60), .height = CLAY_SIZING_FIXED(60) }), CLAY_IMAGE_CONFIG(.imageData = &amp;profilePicture, .height = 60, .width = 60), {});
                CLAY_TEXT(CLAY_ID(&#34;ProfileTitle&#34;), CLAY_STRING(&#34;Clay - UI Library&#34;), CLAY_TEXT_CONFIG(.fontSize = 24, .textColor = {255, 255, 255, 255}));
            });

            // Standard C code like loops etc work inside components
            for (int i = 0; i &lt; 5; i++) {
                SidebarItemComponent(i);
            }
        });

        CLAY_RECTANGLE(CLAY_ID(&#34;MainContent&#34;), CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_GROW() }), CLAY_RECTANGLE_CONFIG(.color = COLOR_LIGHT), {});
    });
    // ...
});"><pre><span>const</span> <span>Clay_Color</span> <span>COLOR_LIGHT</span> <span>=</span> (<span>Clay_Color</span>) {<span>224</span>, <span>215</span>, <span>210</span>, <span>255</span>};
<span>const</span> <span>Clay_Color</span> <span>COLOR_RED</span> <span>=</span> (<span>Clay_Color</span>) {<span>168</span>, <span>66</span>, <span>28</span>, <span>255</span>};
<span>const</span> <span>Clay_Color</span> <span>COLOR_ORANGE</span> <span>=</span> (<span>Clay_Color</span>) {<span>225</span>, <span>138</span>, <span>50</span>, <span>255</span>};

<span>// Layout config is just a struct that can be declared statically, or inline</span>
<span>Clay_LayoutConfig</span> <span>sidebarItemLayout</span> <span>=</span> (<span>Clay_LayoutConfig</span>) {
    .<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>(), .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>50</span>) },
};

<span>// Re-useable components are just normal functions</span>
<span>void</span> <span>SidebarItemComponent</span>(<span>int</span> <span>index</span>) {
    <span>CLAY_RECTANGLE</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarBlob&#34;</span>, <span>index</span>), <span>sidebarItemLayout</span>, <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_ORANGE</span>), {});
}

<span>// An example function to begin the &#34;root&#34; of your layout tree</span>
<span>Clay_RenderCommandArray</span> <span>CreateLayout</span>() {
    <span>Clay_BeginLayout</span>(<span>windowWidth</span>, <span>windowHeight</span>);

    <span>// An example of laying out a UI with a fixed width sidebar and flexible width main content</span>
    <span>CLAY_RECTANGLE</span>(<span>CLAY_ID</span>(<span>&#34;OuterContainer&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> {<span>CLAY_SIZING_GROW</span>(), <span>CLAY_SIZING_GROW</span>()}, .<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}, .<span>childGap</span> <span>=</span> <span>16</span>), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> {<span>250</span>,<span>250</span>,<span>255</span>,<span>255</span>}) {
        <span>CLAY_RECTANGLE</span>(<span>CLAY_ID</span>(<span>&#34;SideBar&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>layoutDirection</span> <span>=</span> <span>CLAY_TOP_TO_BOTTOM</span>, .<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>300</span>), .<span>height</span> <span>=</span> <span>CLAY_SIZING_GROW</span>() }, .<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}, .<span>childGap</span> <span>=</span> <span>16</span>), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_LIGHT</span>), {
            <span>CLAY_RECTANGLE</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePictureOuter&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>() }, .<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}, .<span>childGap</span> <span>=</span> <span>16</span>, .<span>childAlignment</span> <span>=</span> { .<span>y</span> <span>=</span> <span>CLAY_ALIGN_Y_CENTER</span> }), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_RED</span>), {
                <span>CLAY_IMAGE</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePicture&#34;</span>), <span>CLAY_LAYOUT</span>( .<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>60</span>), .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>60</span>) }), <span>CLAY_IMAGE_CONFIG</span>(.<span>imageData</span> <span>=</span> <span>&amp;</span><span>profilePicture</span>, .<span>height</span> <span>=</span> <span>60</span>, .<span>width</span> <span>=</span> <span>60</span>), {});
                <span>CLAY_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;ProfileTitle&#34;</span>), <span>CLAY_STRING</span>(<span>&#34;Clay - UI Library&#34;</span>), <span>CLAY_TEXT_CONFIG</span>(.<span>fontSize</span> <span>=</span> <span>24</span>, .<span>textColor</span> <span>=</span> {<span>255</span>, <span>255</span>, <span>255</span>, <span>255</span>}));
            });

            <span>// Standard C code like loops etc work inside components</span>
            <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>5</span>; <span>i</span><span>++</span>) {
                <span>SidebarItemComponent</span>(<span>i</span>);
            }
        });

        <span>CLAY_RECTANGLE</span>(<span>CLAY_ID</span>(<span>&#34;MainContent&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>(), .<span>height</span> <span>=</span> <span>CLAY_SIZING_GROW</span>() }), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_LIGHT</span>), {});
    });
    <span>// ...</span>
});</pre></div>
<ol start="6" dir="auto">
<li>Call <a href="#clay_endlayout">Clay_EndLayout(screenWidth, screenHeight)</a> and process the resulting <a href="#clay_rendercommandarray">Clay_RenderCommandArray</a> in your choice of renderer.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="Clay_RenderCommandArray renderCommands = Clay_EndLayout(windowWidth, windowHeight);

for (int i = 0; i &lt; renderCommands.length; i++) {
    Clay_RenderCommand *renderCommand = &amp;renderCommands.internalArray[i];
    
    switch (renderCommand-&gt;commandType) {
        case CLAY_RENDER_COMMAND_TYPE_RECTANGLE: {
            DrawRectangle(
                renderCommand-&gt;boundingBox,
                renderCommand-&gt;config.rectangleElementConfig-&gt;color);
        }
        // ... Implement handling of other command types
    }
}"><pre><span>Clay_RenderCommandArray</span> <span>renderCommands</span> <span>=</span> <span>Clay_EndLayout</span>(<span>windowWidth</span>, <span>windowHeight</span>);

<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>renderCommands</span>.<span>length</span>; <span>i</span><span>++</span>) {
    <span>Clay_RenderCommand</span> <span>*</span><span>renderCommand</span> <span>=</span> <span>&amp;</span><span>renderCommands</span>.<span>internalArray</span>[<span>i</span>];
    
    <span>switch</span> (<span>renderCommand</span><span>-&gt;</span><span>commandType</span>) {
        <span>case</span> <span>CLAY_RENDER_COMMAND_TYPE_RECTANGLE</span>: {
            <span>DrawRectangle</span>(
                <span>renderCommand</span><span>-&gt;</span><span>boundingBox</span>,
                <span>renderCommand</span><span>-&gt;</span><span>config</span>.<span>rectangleElementConfig</span><span>-&gt;</span><span>color</span>);
        }
        <span>// ... Implement handling of other command types</span>
    }
}</pre></div>
<p dir="auto">The above example, rendered correctly will look something like the following:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/356939250-1928c6d4-ada9-4a4c-a3d1-44fe9b23b3bd.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM1NjkzOTI1MC0xOTI4YzZkNC1hZGE5LTRhNGMtYTNkMS00NGZlOWIyM2IzYmQucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9OTQ0ZDBkN2FjZGU5NTM0MTFmNzYzMWU5NDUyMWVkYjAxYjQ0NWE5OTQzN2FjZjQwZmZjMjI2MjY1MzkyYTI0OCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.Z800o3IJFZJZcP6HHGWFjlLKDvy3bjNR8zVCcyIVDWQ"><img src="https://private-user-images.githubusercontent.com/2264338/356939250-1928c6d4-ada9-4a4c-a3d1-44fe9b23b3bd.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM1NjkzOTI1MC0xOTI4YzZkNC1hZGE5LTRhNGMtYTNkMS00NGZlOWIyM2IzYmQucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9OTQ0ZDBkN2FjZGU5NTM0MTFmNzYzMWU5NDUyMWVkYjAxYjQ0NWE5OTQzN2FjZjQwZmZjMjI2MjY1MzkyYTI0OCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.Z800o3IJFZJZcP6HHGWFjlLKDvy3bjNR8zVCcyIVDWQ" alt="Clay Example"/></a></p>
<p dir="auto">In summary, the general order of steps is:</p>
<ol dir="auto">
<li><a href="#clay_setpointerposition">Clay_SetPointerPosition(pointerPosition)</a></li>
<li><a href="#clay_updatescrollcontainers">Clay_UpdateScrollContainers(isPointerActive, scrollDelta, deltaTime)</a></li>
<li><a href="#clay_beginlayout">Clay_BeginLayout(screenWidth, screenHeight)</a></li>
<li>Declare your layout with the provided <a href="#element-macros">Element Macros</a></li>
<li><a href="#clay_endlayout">Clay_EndLayout(screenWidth, screenHeight)</a></li>
<li>Render the results using the outputted <a href="#clay_rendercommandarray">Clay_RenderCommandArray</a></li>
</ol>


<p dir="auto">Clay UI hierarchies are built using C macros that allow <em>nested</em> declarations, similar to other declarative UI systems like HTML.</p>
<p dir="auto">This means that child elements are declared <em>inside</em> their parent elements. The common way to do this with clay element macros is to pass a block: <code>{}</code> as the <code>children</code> argument, and define child components inside the braces.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Parent element
CLAY_CONTAINER(id, layout, {
    // Child element 1
    CLAY_TEXT(id, text, config);
    // Child element 2
    CLAY_RECTANGLE(id, layout, config, {
        // etc
    });
});"><pre><span>// Parent element</span>
<span>CLAY_CONTAINER</span>(<span>id</span>, <span>layout</span>, {
    <span>// Child element 1</span>
    <span>CLAY_TEXT</span>(<span>id</span>, <span>text</span>, <span>config</span>);
    <span>// Child element 2</span>
    <span>CLAY_RECTANGLE</span>(<span>id</span>, <span>layout</span>, <span>config</span>, {
        <span>// etc</span>
    });
});</pre></div>
<p dir="auto">However, unlike HTML and other declarative DSLs, these macros are just C. As a result, you can use arbitrary C code such as loops, functions and conditions inside your layout declaration code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Re-usable &#34;components&#34; are just functions that declare more UI
void ButtonComponent(Clay_String buttonText) {
    CLAY_RECTANGLE(id, layout, config, {
        CLAY_TEXT(id, buttonText, config);
    });
}

// Parent element
CLAY_CONTAINER(id, layout, {
    // Render a bunch of text elements
    for (int i = 0; i &lt; textArray.length; i++) {
        CLAY_TEXT(id, textArray.elements[i], config);
    }
    // Only render this element if we&#39;re on a mobile screen
    if (isMobileScreen) {
        CLAY_CONTAINER(id, layout, {
            // etc
        });
    }
    // Re-usable components
    ButtonComponent(CLAY_STRING(&#34;Click me!&#34;));
    ButtonComponent(CLAY_STRING(&#34;No, click me!&#34;));
});"><pre><span>// Re-usable &#34;components&#34; are just functions that declare more UI</span>
<span>void</span> <span>ButtonComponent</span>(<span>Clay_String</span> <span>buttonText</span>) {
    <span>CLAY_RECTANGLE</span>(<span>id</span>, <span>layout</span>, <span>config</span>, {
        <span>CLAY_TEXT</span>(<span>id</span>, <span>buttonText</span>, <span>config</span>);
    });
}

<span>// Parent element</span>
<span>CLAY_CONTAINER</span>(<span>id</span>, <span>layout</span>, {
    <span>// Render a bunch of text elements</span>
    <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>textArray</span>.<span>length</span>; <span>i</span><span>++</span>) {
        <span>CLAY_TEXT</span>(<span>id</span>, <span>textArray</span>.<span>elements</span>[<span>i</span>], <span>config</span>);
    }
    <span>// Only render this element if we&#39;re on a mobile screen</span>
    <span>if</span> (<span>isMobileScreen</span>) {
        <span>CLAY_CONTAINER</span>(<span>id</span>, <span>layout</span>, {
            <span>// etc</span>
        });
    }
    <span>// Re-usable components</span>
    <span>ButtonComponent</span>(<span>CLAY_STRING</span>(<span>&#34;Click me!&#34;</span>));
    <span>ButtonComponent</span>(<span>CLAY_STRING</span>(<span>&#34;No, click me!&#34;</span>));
});</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Configuring Layout and Styling UI Elements</h3><a id="user-content-configuring-layout-and-styling-ui-elements" aria-label="Permalink: Configuring Layout and Styling UI Elements" href="#configuring-layout-and-styling-ui-elements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Many of the element macros in Clay take a <code>Clay_LayoutConfig</code> as the second argument. Clay provides a convenience macro, <a href="#clay_layout">CLAY_LAYOUT()</a> for easy construction of element styles.</p>
<div dir="auto" data-snippet-clipboard-copy-content="CLAY_CONTAINER(id, CLAY_LAYOUT(.padding = {.x = 8, .y = 8}, .backgroundColor = {120, 120, 120, 255}), {
    // ...
});"><pre><span>CLAY_CONTAINER</span>(<span>id</span>, <span>CLAY_LAYOUT</span>(.<span>padding</span> <span>=</span> {.<span>x</span> <span>=</span> <span>8</span>, .<span>y</span> <span>=</span> <span>8</span>}, .<span>backgroundColor</span> <span>=</span> {<span>120</span>, <span>120</span>, <span>120</span>, <span>255</span>}), {
    <span>// ...</span>
});</pre></div>
<p dir="auto">This macro isn&#39;t magic - all it&#39;s doing is wrapping the standard designated initializer syntax and adding the result to an internal array. e.g. <code>(Clay_LayoutConfig) { .padding = { .x = 8, .y = 8 } ...</code>.</p>
<p dir="auto">See the <a href="#clay_layout">Clay_LayoutConfig</a> API for the full list of options.</p>
<p dir="auto">A <code>Clay_LayoutConfig</code> struct can be defined in file scope or elsewhere, as long as the lifetime ends after <code>EndLayout</code> is called.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Define a style in the global / file scope
Clay_LayoutConfig reusableStyle = (Clay_LayoutConfig) {.backgroundColor = {120, 120, 120, 255}};

CLAY_CONTAINER(id, &amp;reusableStyle, {
    // ...
});"><pre><span>// Define a style in the global / file scope</span>
<span>Clay_LayoutConfig</span> <span>reusableStyle</span> <span>=</span> (<span>Clay_LayoutConfig</span>) {.<span>backgroundColor</span> <span>=</span> {<span>120</span>, <span>120</span>, <span>120</span>, <span>255</span>}};

<span>CLAY_CONTAINER</span>(<span>id</span>, <span>&amp;</span><span>reusableStyle</span>, {
    <span>// ...</span>
});</pre></div>
<p dir="auto">Some of the other element macros, such as <a href="#clay_text">CLAY_TEXT()</a> and <a href="#clay_rectangle">CLAY_RECTANGLE()</a> take an element-specific config object as their 3rd argument. These config objects also have convenience macros for constructing them, generally of the form <a href="#clay_text_config">CLAY_TEXT_CONFIG()</a> or <a href="#clay_rectangle_config">CLAY_RECTANGLE_CONFIG()</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="CLAY_TEXT(id, CLAY_STRING(&#34;button text&#34;), CLAY_TEXT_CONFIG(.fontSize = 24, .fontId = FONT_ID_LATO, .textColor = {255, 255, 255, 255}));"><pre><span>CLAY_TEXT</span>(<span>id</span>, <span>CLAY_STRING</span>(<span>&#34;button text&#34;</span>), <span>CLAY_TEXT_CONFIG</span>(.<span>fontSize</span> <span>=</span> <span>24</span>, .<span>fontId</span> <span>=</span> <span>FONT_ID_LATO</span>, .<span>textColor</span> <span>=</span> {<span>255</span>, <span>255</span>, <span>255</span>, <span>255</span>}));</pre></div>
<p dir="auto">See the <a href="#api">Full API</a> for details on the specific config macros.</p>

<p dir="auto">All element macros take a <code>uint32_t</code> ID as their first argument. Clay provides the <a href="#clay_id">CLAY_ID()</a> macro to generate these IDs as string hashes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Will always produce the same ID from the same input string
CLAY_CONTAINER(CLAY_ID(&#34;OuterContainer&#34;), style, {});"><pre><span>// Will always produce the same ID from the same input string</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OuterContainer&#34;</span>), <span>style</span>, {});</pre></div>
<p dir="auto">To avoid having to construct dynamic strings at runtime to differentiate ids, clay provides the <a href="#clay_idi">CLAY_IDI(string, index)</a> macro to generate different ids from a single input string. Think of IDI as &#34;<strong>ID</strong> + <strong>I</strong>ndex&#34;</p>
<div dir="auto" data-snippet-clipboard-copy-content="// This is the equivalent of calling CLAY_ID(&#34;Item0&#34;), CLAY_ID(&#34;Item1&#34;) etc
for (int index = 0; index &lt; items.length; index++) {
    CLAY_CONTAINER(CLAY_IDI(&#34;Item&#34;, index), style, {});
}"><pre><span>// This is the equivalent of calling CLAY_ID(&#34;Item0&#34;), CLAY_ID(&#34;Item1&#34;) etc</span>
<span>for</span> (<span>int</span> <span>index</span> <span>=</span> <span>0</span>; <span>index</span> <span>&lt;</span> <span>items</span>.<span>length</span>; <span>index</span><span>++</span>) {
    <span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;Item&#34;</span>, <span>index</span>), <span>style</span>, {});
}</pre></div>
<p dir="auto"><strong><em>Generally, you should try to keep IDs unique if possible.</em></strong></p>
<p dir="auto">This ID is used for querying mouse / pointer events, and will be forwarded to the final <code>Clay_RenderCommandArray</code> for use in retained mode UIs. Using duplicate IDs may cause some functionality to misbehave (i.e. if you&#39;re trying to attach a floating container to a specific element with ID that is duplicated, it may not attach to the one you expect)</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Mouse, Touch and Pointer Interactions</h3><a id="user-content-mouse-touch-and-pointer-interactions" aria-label="Permalink: Mouse, Touch and Pointer Interactions" href="#mouse-touch-and-pointer-interactions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Clay provides a very simple unified API for handling mouse and pointer interactions, with specific handling left to user code.</p>
<p dir="auto">All pointer interactions depend on the function <code>void Clay_SetPointerPosition(Clay_Vector2 position)</code> being called after each mouse position update and before any other clay functions.</p>
<p dir="auto">The function <code>bool Clay_PointerOver(uint32_t id)</code> takes an element id that was used during layout creation and returns a bool representing whether the current pointer position is within its bounding box.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Reminder: Clay_SetPointerPosition must be called before functions that rely on pointer position otherwise it will have no effect
Clay_Vector2 mousePosition = { x, y };
Clay_SetPointerPosition(mousePosition);
// ...
// If profile picture was clicked
if (mouseButtonDown(0) &amp;&amp; Clay_PointerOver(CLAY_ID(&#34;ProfilePicture&#34;))) {
    // Handle profile picture clicked
}"><pre><span>// Reminder: Clay_SetPointerPosition must be called before functions that rely on pointer position otherwise it will have no effect</span>
<span>Clay_Vector2</span> <span>mousePosition</span> <span>=</span> { <span>x</span>, <span>y</span> };
<span>Clay_SetPointerPosition</span>(<span>mousePosition</span>);
<span>// ...</span>
<span>// If profile picture was clicked</span>
<span>if</span> (<span>mouseButtonDown</span>(<span>0</span>) <span>&amp;&amp;</span> <span>Clay_PointerOver</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePicture&#34;</span>))) {
    <span>// Handle profile picture clicked</span>
}</pre></div>
<p dir="auto">Querying <code>Clay_PointerOver</code> also works <em>during</em> layout construction, and can be used as a convenient way for applying &#34;hover&#34; states, for example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Reminder: Clay_SetPointerPosition must be called before functions that rely on pointer position otherwise it will have no effect
Clay_Vector2 mousePosition = { x, y };
Clay_SetPointerPosition(mousePosition);
// ...
uint32_t buttonId = CLAY_ID(&#34;HeaderButton&#34;);
// An orange button that turns blue when hovered
CLAY_CONTAINER(buttonId, CLAY_LAYOUT(.backgroundColor = Clay_PointerOver(buttonId) ? COLOR_BLUE : COLOR_ORANGE), {
    CLAY_TEXT(CLAY_IDI(&#34;Button&#34;, index), text, &amp;headerTextConfig);
});"><pre><span>// Reminder: Clay_SetPointerPosition must be called before functions that rely on pointer position otherwise it will have no effect</span>
<span>Clay_Vector2</span> <span>mousePosition</span> <span>=</span> { <span>x</span>, <span>y</span> };
<span>Clay_SetPointerPosition</span>(<span>mousePosition</span>);
<span>// ...</span>
<span>uint32_t</span> <span>buttonId</span> <span>=</span> <span>CLAY_ID</span>(<span>&#34;HeaderButton&#34;</span>);
<span>// An orange button that turns blue when hovered</span>
<span>CLAY_CONTAINER</span>(<span>buttonId</span>, <span>CLAY_LAYOUT</span>(.<span>backgroundColor</span> <span>=</span> <span>Clay_PointerOver</span>(<span>buttonId</span>) ? <span>COLOR_BLUE</span> : <span>COLOR_ORANGE</span>), {
    <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;Button&#34;</span>, <span>index</span>), <span>text</span>, <span>&amp;</span><span>headerTextConfig</span>);
});</pre></div>
<p dir="auto">Note that the bounding box queried by <code>Clay_PointerOver</code> is from the last frame. This shouldn&#39;t make a difference except in the case of animations that move at high speed.
If this is an issue for you, performing layout twice per frame with the same data will give you the correct interaction the second time.</p>

<p dir="auto">Scrolling containers are defined with the <code>CLAY_SCROLL_CONTAINER</code> element macro and function just like normal containers, however to make scroll containers respond to mouse wheel and scroll events, two functions need to be called:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Reminder: Clay_SetPointerPosition must be called before Clay_UpdateScrollContainers otherwise it will have no effect
Clay_Vector2 mousePosition = { x, y };
Clay_SetPointerPosition(mousePosition);
// Clay_UpdateScrollContainers needs to be called before Clay_BeginLayout for the position to avoid a 1 frame delay
Clay_UpdateScrollContainers(
    true, // Did the mouse click or touch occur this frame?
    scrollDelta, // Clay_Vector2 scrollwheel / trackpad scroll x and y delta this frame
    float deltaTime, // Time since last frame in seconds as a float e.g. 8ms is 0.008f
);
// ..."><pre><span>// Reminder: Clay_SetPointerPosition must be called before Clay_UpdateScrollContainers otherwise it will have no effect</span>
<span>Clay_Vector2</span> <span>mousePosition</span> <span>=</span> { <span>x</span>, <span>y</span> };
<span>Clay_SetPointerPosition</span>(<span>mousePosition</span>);
<span>// Clay_UpdateScrollContainers needs to be called before Clay_BeginLayout for the position to avoid a 1 frame delay</span>
<span>Clay_UpdateScrollContainers</span>(
    true, <span>// Did the mouse click or touch occur this frame?</span>
    <span>scrollDelta</span>, <span>// Clay_Vector2 scrollwheel / trackpad scroll x and y delta this frame</span>
    <span>float</span> <span>deltaTime</span>, <span>// Time since last frame in seconds as a float e.g. 8ms is 0.008f</span><span></span>
);
<span>// ...</span></pre></div>
<p dir="auto">More specific details can be found in the full <a href="#clay_scroll_container">Scroll Container API</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Floating Containers (&#34;Absolute&#34; Positioning)</h3><a id="user-content-floating-containers-absolute-positioning" aria-label="Permalink: Floating Containers (&#34;Absolute&#34; Positioning)" href="#floating-containers-absolute-positioning"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">All standard elements in clay are laid out on top of, and <em>within</em> their parent, positioned according to their parent&#39;s layout rules, and affect the positioning and sizing of siblings.</p>
<p dir="auto"><strong>&#34;Floating&#34;</strong> elements are defined with the <code>CLAY_FLOATING_CONTAINER</code> element macro and don&#39;t affect the parent they are defined in, or the position of their siblings.
They also have a <strong>z-index</strong>, and as a result can intersect and render over the top of other elements.
Aside from positioning, <code>CLAY_FLOATING_CONTAINER</code> elements function like standard <code>CLAY_CONTAINER</code> elements.</p>
<p dir="auto">A classic example use case for floating elements is tooltips and modals.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// The two text elements will be laid out top to bottom, and the floating container
// will be attached to &#34;Outer&#34;
CLAY_CONTAINER(CLAY_ID(&#34;Outer&#34;), CLAY_LAYOUT(.layoutDirection = TOP_TO_BOTTOM), {
    CLAY_TEXT(CLAY_ID(&#34;Button&#34;), text, &amp;headerTextConfig);
    CLAY_FLOATING_TEXT(CLAY_ID(&#34;Tooltip&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING_CONFIG);
    CLAY_TEXT(CLAY_ID(&#34;Button&#34;), text, &amp;headerTextConfig);
});"><pre><span>// The two text elements will be laid out top to bottom, and the floating container</span>
<span>// will be attached to &#34;Outer&#34;</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;Outer&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>layoutDirection</span> <span>=</span> <span>TOP_TO_BOTTOM</span>), {
    <span>CLAY_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;Button&#34;</span>), <span>text</span>, <span>&amp;</span><span>headerTextConfig</span>);
    <span>CLAY_FLOATING_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;Tooltip&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_FLOATING_CONFIG</span>);
    <span>CLAY_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;Button&#34;</span>), <span>text</span>, <span>&amp;</span><span>headerTextConfig</span>);
});</pre></div>
<p dir="auto">More specific details can be found in the full <a href="#clay_floating_container">Floating Container API</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Laying Out Your Own Custom Elements</h3><a id="user-content-laying-out-your-own-custom-elements" aria-label="Permalink: Laying Out Your Own Custom Elements" href="#laying-out-your-own-custom-elements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Clay only supports a simple set of UI element primitives, such as rectangles, text and images. Clay provides a simple, singular API for layout out custom elements:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data
#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;
// Extensions need to happen _before_ the clay include
#include &#34;clay.h&#34;

// A rough example of how you could handle laying out 3d models in your UI
typedef struct t_CustomElementData {
    CustomElementType type;
    union {
        Model model;
        Video video;
        // ...
    };
} CustomElementData;

Model myModel = Load3DModel(filePath);
CustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }
// ...
CLAY_CONTAINER(id, style, {
    // This config is type safe and contains the CustomElementData struct
    CLAY_CUSTOM_ELEMENT(id, style, CLAY_CUSTOM_ELEMENT_CONFIG(.customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }))
});

// Later during your rendering
switch (renderCommand-&gt;commandType) {
    // ...
    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {
        // Your extended struct is passed through
        CustomElementData *data = renderCommand-&gt;elementConfig.customElementConfig-&gt;customData;
        if (!customElement) continue;
        switch (customElement-&gt;type) {
            case CUSTOM_ELEMENT_TYPE_MODEL: {
                // Render your 3d model here
                break;
            }
            case CUSTOM_ELEMENT_TYPE_VIDEO: {
                // Render your video here
                break;
            }
            // ...
        }
        break;
    }
}"><pre><span>// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data</span>
<span>#define</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span> struct t_CustomElementData customData;
<span>// Extensions need to happen _before_ the clay include</span>
<span>#include</span> <span>&#34;clay.h&#34;</span>

<span>// A rough example of how you could handle laying out 3d models in your UI</span>
<span>typedef</span> <span>struct</span> <span>t_CustomElementData</span> {
    <span>CustomElementType</span> <span>type</span>;
    <span>union</span> {
        <span>Model</span> <span>model</span>;
        <span>Video</span> <span>video</span>;
        <span>// ...</span>
    };
} <span>CustomElementData</span>;

<span>Model</span> <span>myModel</span> <span>=</span> <span>Load3DModel</span>(<span>filePath</span>);
<span>CustomElement</span> <span>modelElement</span> <span>=</span> (<span>CustomElement</span>) { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }
<span>// ...</span>
<span>CLAY_CONTAINER</span>(<span>id</span>, <span>style</span>, {
    <span>// This config is type safe and contains the CustomElementData struct</span>
    <span>CLAY_CUSTOM_ELEMENT</span>(<span>id</span>, <span>style</span>, <span>CLAY_CUSTOM_ELEMENT_CONFIG</span>(.<span>customData</span> <span>=</span> { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }))
});

<span>// Later during your rendering</span>
<span>switch</span> (<span>renderCommand</span><span>-&gt;</span><span>commandType</span>) {
    <span>// ...</span>
    <span>case</span> <span>CLAY_RENDER_COMMAND_TYPE_CUSTOM</span>: {
        <span>// Your extended struct is passed through</span>
        <span>CustomElementData</span> <span>*</span><span>data</span> <span>=</span> <span>renderCommand</span><span>-&gt;</span><span>elementConfig</span>.<span>customElementConfig</span><span>-&gt;</span><span>customData</span>;
        <span>if</span> (!<span>customElement</span>) <span>continue</span>;
        <span>switch</span> (<span>customElement</span><span>-&gt;</span><span>type</span>) {
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>: {
                <span>// Render your 3d model here</span>
                <span>break</span>;
            }
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_VIDEO</span>: {
                <span>// Render your video here</span>
                <span>break</span>;
            }
            <span>// ...</span>
        }
        <span>break</span>;
    }
}</pre></div>
<p dir="auto">More specific details can be found in the full <a href="#clay_custom_element">Custom Container API</a>.</p>

<p dir="auto">Clay was originally designed for <a href="https://www.youtube.com/watch?v=Z1qyvQsjK5Y" rel="nofollow">Immediate Mode</a> rendering - where the entire UI is redrawn every frame. This may not be possible with your platform, renderer design or performance constraints.</p>
<p dir="auto">There are some general techniques that can be used to integrate clay into a retained mode rendering system:</p>
<ul dir="auto">
<li><code>Clay_RenderCommand</code> includes the <code>uint32_t id</code> that was used to declare the element. If unique ids are used, these can be mapped to persistent graphics objects across multiple frames / layouts.</li>
<li>Render commands are culled automatically to only currently visible elements, and <code>Clay_RenderCommand</code> is a small enough struct that you can simply compare the memory of two render commands with matching IDs to determine if the element is &#34;dirty&#34; and needs to be re-rendered or updated.</li>
</ul>
<p dir="auto">For a worked example, see the provided <a href="https://github.com/nicbarker/clay/blob/main/renderers/web/html/clay-html-renderer.html">HTML renderer</a>. This renderer converts clay layouts into persistent HTML documents with minimal changes per frame.</p>

<p dir="auto">Clay provides a built-in visibility-culling mechanism that is <strong>enabled by default</strong>. It will only output render commands for elements that are visible - that is, <strong>at least one pixel of their bounding box is inside the viewport.</strong></p>
<p dir="auto">This culling mechanism can be disabled via the use of the <code>#define CLAY_DISABLE_CULLING</code> directive. See <a href="#preprocessor-directives">Preprocessor Directives</a> for more information.</p>

<p dir="auto">Clay supports C preprocessor directives to modulate functionality at compile time. These can be set either in code using <code>#define CLAY_DISABLE_CULLING</code> or on the command line when compiling using the appropriate compiler specific arguments, e.g. <code>clang -DCLAY_DISABLE_CULLING main.c ...</code></p>
<p dir="auto">The supported directives are:</p>
<ul dir="auto">
<li><code>CLAY_MAX_ELEMENT_COUNT</code> - Controls the maximum number of clay elements that memory is pre-allocated for. Defaults to <strong>8192</strong>, which should be more than enough for the majority of use cases. Napkin math is ~450 bytes of memory overhead per element (8192 elements is ~3.5mb of memory)</li>
<li><code>CLAY_DISABLE_CULLING</code> - Disables <a href="#visibility-culling">Visibility Culling</a> of render commands.</li>
<li><code>CLAY_WASM</code> - Required when targeting Web Assembly.</li>
<li><code>CLAY_OVERFLOW_TRAP</code> - By default, clay will continue to allow function calls without crashing even when it exhausts all its available pre-allocated memory.  This can produce erroneous layout results that are difficult to interpret. If <code>CLAY_OVERFLOW_TRAP</code> is defined, clay will raise a <code>SIGTRAP</code> signal that will be caught by your debugger. Relies on <code>signal.h</code> being available in your environment.</li>
<li><code>CLAY_DEBUG</code> - Used for debugging clay&#39;s internal implementation. Useful if you want to modify or debug clay, or learn how things work. It enables a number of debug features such as preserving source strings for has IDs to make debugging easier.</li>
<li><code>CLAY_EXTEND_CONFIG_RECTANGLE</code> - Provide additional struct members to <code>CLAY_RECTANGLE_CONFIG</code> that will be passed through with output render commands.</li>
<li><code>CLAY_EXTEND_CONFIG_TEXT</code> - Provide additional struct members to <code>CLAY_TEXT_CONFIG</code> that will be passed through with output render commands.</li>
<li><code>CLAY_EXTEND_CONFIG_IMAGE</code> - Provide additional struct members to <code>CLAY_IMAGE_CONFIG</code> that will be passed through with output render commands.</li>
<li><code>CLAY_EXTEND_CONFIG_CUSTOM</code> - Provide additional struct members to <code>CLAY_IMAGE_CONFIG</code> that will be passed through with output render commands.</li>
</ul>


<ul dir="auto">
<li>&#34;<strong>CAPITAL_LETTERS()</strong>&#34; are used for macros.</li>
<li>&#34;<strong>Clay__</strong>&#34; (&#34;Clay&#34; followed by <strong>double</strong> underscore) is used for internal functions that are not intended for use and are subject to change.</li>
<li>&#34;<strong>Clay_</strong>&#34; (&#34;Clay&#34; followed by <strong>single</strong> underscore) is used for external functions that can be called by the user.</li>
</ul>

<div dir="auto"><h3 tabindex="-1" dir="auto">Lifecycle for public functions</h3><a id="user-content-lifecycle-for-public-functions" aria-label="Permalink: Lifecycle for public functions" href="#lifecycle-for-public-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>At startup / initialization time, run once</strong>
<code>Clay_MinMemorySize</code> -&gt; <code>Clay_CreateArenaWithCapacityAndMemory</code> -&gt; <code>Clay_SetMeasureTextFunction</code> -&gt; <code>Clay_Initialize</code></p>
<p dir="auto"><strong>Each Frame</strong>
<code>Clay_SetPointerPosition</code> -&gt; <code>Clay_UpdateScrollContainers</code> -&gt; <code>Clay_BeginLayout</code> -&gt; <code>CLAY_CONTAINER() etc...</code> -&gt; <code>Clay_EndLayout</code></p>

<p dir="auto"><code>uint32_t Clay_MinMemorySize()</code></p>
<p dir="auto">Returns the minimum amount of memory <strong>in bytes</strong> that clay needs to accomodate the current <a href="#preprocessor-directives">CLAY_MAX_ELEMENT_COUNT</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Clay_CreateArenaWithCapacityAndMemory</h3><a id="user-content-clay_createarenawithcapacityandmemory" aria-label="Permalink: Clay_CreateArenaWithCapacityAndMemory" href="#clay_createarenawithcapacityandmemory"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>Clay_Arena Clay_CreateArenaWithCapacityAndMemory(uint32_t capacity, void *offset)</code></p>
<p dir="auto">Creates a <code>Clay_Arena</code> struct with the given capacity and base memory pointer, which can be passed to <a href="#clay_initialize">Clay_Initialize</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Clay_SetMeasureTextFunction</h3><a id="user-content-clay_setmeasuretextfunction" aria-label="Permalink: Clay_SetMeasureTextFunction" href="#clay_setmeasuretextfunction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>void Clay_SetMeasureTextFunction(Clay_Dimensions (*measureTextFunction)(Clay_String *text, Clay_TextElementConfig *config))</code></p>
<p dir="auto">Takes a pointer to a function that can be used to measure the <code>width, height</code> dimensions of a string. Used by clay during layout to determine <a href="#clay_text">CLAY_TEXT</a> element sizing and wrapping.</p>
<p dir="auto"><strong>Note 1: This string is not guaranteed to be null terminated.</strong> Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support <strong>ptr, length</strong> style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.</p>
<p dir="auto"><strong>Note 2: It is essential that this function is as fast as possible.</strong> For text heavy use-cases this function is called many times, and despite the fact that clay caches text measurements internally, it can easily become the dominant overall layout cost if the provided function is slow. <strong>This is on the hot path!</strong></p>

<p dir="auto"><code>void Clay_Initialize(Clay_Arena arena)</code></p>
<p dir="auto">Takes a <code>Clay_Arena</code> and initializes the internal memory mapping.</p>

<p dir="auto"><code>void Clay_SetPointerPosition(Clay_Vector2 position)</code></p>
<p dir="auto">Sets the internal pointer position (i.e. current mouse / touch position) and recalculates overlap info, which is used for mouseover / click calculation (via <a href="#clay_pointerover">Clay_PointerOver</a> and updating scroll containers with <a href="#clay_updatescrollcontainers">Clay_UpdateScrollContainers</a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Clay_UpdateScrollContainers</h3><a id="user-content-clay_updatescrollcontainers" aria-label="Permalink: Clay_UpdateScrollContainers" href="#clay_updatescrollcontainers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>void Clay_UpdateScrollContainers(bool isPointerActive, Clay_Vector2 scrollDelta, float deltaTime)</code></p>
<p dir="auto">This function handles scrolling of containers. It responds to both <code>scrollDelta</code>, which represents mouse wheel or trackpad scrolling this frame, as well as &#34;touch scrolling&#34; on mobile devices.</p>
<p dir="auto">Touch scrolling only occurs if the <code>isPointerActive</code> parameter is <code>true</code>, <strong>and</strong> <a href="#clay_setpointerposition">Clay_SetPointerPosition</a> has been called this frame. As a result, you can simply always call it with <code>false</code> as the first argument if you want to disable touch scrolling.</p>
<p dir="auto"><code>deltaTime</code> is the time <strong>in seconds</strong> since the last frame (e.g. 0.016 is <strong>16 milliseconds</strong>), and is used to normalize &amp; smooth scrolling across different refresh rates.</p>

<p dir="auto"><code>void Clay_BeginLayout(int screenWidth, int screenHeight)</code></p>
<p dir="auto">Prepares clay to calculate a new layout. Called each frame / layout <strong>before</strong> any of the <a href="#element-macros">Element Macros</a>. <code>screenWidth</code> and <code>screenHeight</code> don&#39;t neccessarily have to be the screen or window height - you can use clay to lay out an arbitrary sub-section of a window.</p>

<p dir="auto"><code>Clay_RenderCommandArray Clay_EndLayout(int screenWidth, int screenHeight)</code></p>
<p dir="auto">Ends declaration of element macros and calculates the results of the currrent layout. Renders a <a href="#clay_rendercommandarrray">Clay_RenderCommandArray</a> containing the results of the layout calculation.</p>

<p dir="auto"><code>bool Clay_PointerOver(uint32_t id)</code></p>
<p dir="auto">Returns <code>true</code> if the pointer position previously set with <code>Clay_SetPointerPosition</code> is inside the bounding box of the layout element with the provided <code>id</code>. Note: this is based on the element&#39;s position from the <strong>last</strong> frame. If frame-accurate pointer overlap detection is required, perhaps in the case of significant change in UI layout between frames, you can simply run your layout code twice that frame. The second call to <code>Clay_PointerOver</code> will be frame-accurate.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Clay_GetScrollContainerData</h3><a id="user-content-clay_getscrollcontainerdata" aria-label="Permalink: Clay_GetScrollContainerData" href="#clay_getscrollcontainerdata"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>Clay_ScrollContainerData Clay_GetScrollContainerData(uint32_t id)</code></p>
<p dir="auto">Returns <a href="#clay_scrollcontainerdata">Clay_ScrollContainerData</a> for the scroll container matching the provided ID. This function allows imperative manipulation of scroll position, allowing you to build things such as scroll bars, buttons that &#34;jump&#34; to somewhere in a scroll container, etc.</p>


<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_CONTAINER(uint32_t id, Clay_LayoutConfig *layoutConfig, children);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_CONTAINER()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>CONTAINER</strong> is a generic rectangular container that supports child elements. It uses a <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Define a container with 16px of x and y padding
CLAY_CONTAINER(CLAY_ID(&#34;SideBar&#34;), CLAY_LAYOUT(.padding = {16, 16}), {
    // A nested child container
    CLAY_CONTAINER(CLAY_ID(&#34;SideBar&#34;), CLAY_LAYOUT(.layoutDirection = CLAY_TOP_TO_BOTTOM, .childGap = 16), {
        // Children laid out top to bottom
    });
});"><pre><span>// Define a container with 16px of x and y padding</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;SideBar&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}), {
    <span>// A nested child container</span>
    <span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;SideBar&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>layoutDirection</span> <span>=</span> <span>CLAY_TOP_TO_BOTTOM</span>, .<span>childGap</span> <span>=</span> <span>16</span>), {
        <span>// Children laid out top to bottom</span>
    });
});</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto"><code>CLAY_CONTAINER</code> elements will not generate any render commands.</p>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_TEXT(uint32_t id, Clay_String textContents, Clay_TextElementConfig *textConfig);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_TEXT()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>TEXT</strong> is a measured, auto-wrapped text element. It uses <a href="#clay_text_config">Clay_TextElementConfig</a> to configure text specific options.</p>
<p dir="auto">Note that <code>Clay_TextElementConfig</code> uses <code>uint32_t fontId</code>. Font ID to font asset mapping is managed in user code and passed to render commands.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Define a font somewhere in your code
const uint32_t FONT_ID_LATO = 3;
// ..
CLAY_TEXT(CLAY_ID(&#34;Username&#34;), CLAY_STRING(&#34;John Smith&#34;), CLAY_TEXT_CONFIG(.fontId = FONT_ID_LATO, .fontSize = 24, .textColor = {255, 0, 0, 255}));
// Rendering example
Font fontToUse = LoadedFonts[renderCommand-&gt;elementConfig.textElementConfig-&gt;fontId];"><pre><span>// Define a font somewhere in your code</span>
<span>const</span> <span>uint32_t</span> <span>FONT_ID_LATO</span> <span>=</span> <span>3</span>;
<span>// ..</span>
<span>CLAY_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;Username&#34;</span>), <span>CLAY_STRING</span>(<span>&#34;John Smith&#34;</span>), <span>CLAY_TEXT_CONFIG</span>(.<span>fontId</span> <span>=</span> <span>FONT_ID_LATO</span>, .<span>fontSize</span> <span>=</span> <span>24</span>, .<span>textColor</span> <span>=</span> {<span>255</span>, <span>0</span>, <span>0</span>, <span>255</span>}));
<span>// Rendering example</span>
<span>Font</span> <span>fontToUse</span> <span>=</span> <span>LoadedFonts</span>[<span>renderCommand</span><span>-&gt;</span><span>elementConfig</span>.<span>textElementConfig</span><span>-&gt;</span><span>fontId</span>];</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto">Element is subject to <a href="#visibility-culling">culling</a>. Otherwise, multiple <code>Clay_RenderCommand</code>s with <code>commandType = CLAY_RENDER_COMMAND_TYPE_TEXT</code> may be created, one for each wrapped line of text.</p>
<p dir="auto"><code>Clay_RenderCommand.textContent</code> will be populated with a <code>Clay_String</code> <em>slice</em> of the original string passed in (i.e. wrapping doesn&#39;t reallocate, it just returns a <code>Clay_String</code> pointing to the start of the new line with a <code>length</code>)</p>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_IMAGE(id, layoutConfig, imageConfig, children);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_IMAGE()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>IMAGE_CONTAINER</strong> is a used to layout images, and can optionally have children.It uses <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout, and <a href="#clay_image_config">Clay_ImageElementConfig</a> to configure image specific options.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Load an image somewhere in your code
Image profilePicture = LoadImage(&#34;profilePicture.png&#34;);
// ..
CLAY_IMAGE(CLAY_ID(&#34;ProfilePicture&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_IMAGE_CONFIG(.imageData = &amp;profilePicture, .height = 60, .width = 60), {});
// Rendering example
Image *imageToRender = renderCommand-&gt;elementConfig.imageElementConfig-&gt;imageData;"><pre><span>// Load an image somewhere in your code</span>
<span>Image</span> <span>profilePicture</span> <span>=</span> <span>LoadImage</span>(<span>&#34;profilePicture.png&#34;</span>);
<span>// ..</span>
<span>CLAY_IMAGE</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePicture&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_IMAGE_CONFIG</span>(.<span>imageData</span> <span>=</span> <span>&amp;</span><span>profilePicture</span>, .<span>height</span> <span>=</span> <span>60</span>, .<span>width</span> <span>=</span> <span>60</span>), {});
<span>// Rendering example</span>
<span>Image</span> <span>*</span><span>imageToRender</span> <span>=</span> <span>renderCommand</span><span>-&gt;</span><span>elementConfig</span>.<span>imageElementConfig</span><span>-&gt;</span><span>imageData</span>;</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto">Element is subject to <a href="#visibility-culling">culling</a>. Otherwise, a single <code>Clay_RenderCommand</code>s with <code>commandType = CLAY_RENDER_COMMAND_TYPE_IMAGE</code> will be created. The user will need to access <code>renderCommand-&gt;elementConfig.imageElementConfig-&gt;imageData</code> to retrieve image data referenced during layout creation. It&#39;s also up to the user to decide how / if they wish to blend <code>renderCommand-&gt;color</code> with the image.</p>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_SCROLL_CONTAINER(id, layoutConfig, scrollConfig, children);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_SetPointerPosition()</code> -&gt; <code>Clay_UpdateScrollContainers()</code> -&gt; <code>Clay_BeginLayout()</code> -&gt; <code>CLAY_SCROLL_CONTAINER()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>SCROLL_CONTAINER</strong> creates a masked container that allows layout of children to extend beyond its boundaries. It uses <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout, and <a href="#clay_scroll_config">Clay_ScrollElementConfig</a> to configure scroll specific options.</p>
<p dir="auto">Note: In order to process scrolling based on pointer position and mouse wheel or touch interactions, you must call <code>Clay_SetPointerPosition()</code> and <code>Clay_UpdateScrollContainers()</code> <em>before</em> calling <code>BeginLayout</code>.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="CLAY_SCROLL_CONTAINER(CLAY_ID(&#34;MainContent&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_SCROLL_CONFIG(.vertical = true), {
    // Create child content with a fixed height of 5000
    CLAY_CONTAINER(CLAY_ID(&#34;ScrollInner&#34;), CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_FIXED(5000) }), {});
});"><pre><span>CLAY_SCROLL_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;MainContent&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_SCROLL_CONFIG</span>(.<span>vertical</span> <span>=</span> true), {
    <span>// Create child content with a fixed height of 5000</span>
    <span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;ScrollInner&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>(), .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>5000</span>) }), {});
});</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto">Scroll containers will result in two render commands:</p>
<ul dir="auto">
<li><code>commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_START</code>, which should create a rectangle mask with its <code>boundingBox</code> and is <strong>not</strong> subject to <a href="#visibility-culling">culling</a></li>
<li><code>commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_END</code>, which disables the previous rectangle mask and is <strong>not</strong> subject to <a href="#visibility-culling">culling</a></li>
</ul>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_BORDER_CONTAINER(id, layoutConfig, borderConfig, children);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_BORDER_CONTAINER()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>BORDER_CONTAINER</strong> is functionally identical to <strong>CONTAINER</strong> but also allows configuration of a border around the element. It uses <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout, and <a href="#clay_border_config">Clay_BorderElementConfig</a> to configure border specific options.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// 300x300 container with a 1px red border around all the edges
CLAY_BORDER_CONTAINER(CLAY_ID(&#34;OuterBorder&#34;), CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_FIXED(300)}), CLAY_BORDER_CONFIG_OUTSIDE(.color = COLOR_RED, .width = 1), {
    // ...
});

// Container with a 3px yellow bottom border
CLAY_BORDER_CONTAINER(CLAY_ID(&#34;OuterBorder&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_BORDER_CONFIG(.bottom = { .color = COLOR_YELLOW, .width = 3 }), {
    // ...
});

// Container with a 5px curved border around the edges, and a 5px blue border between all children laid out top to bottom
CLAY_BORDER_CONTAINER(CLAY_ID(&#34;OuterBorder&#34;), CLAY_LAYOUT(.layoutDirection = CLAY_TOP_TO_BOTTOM), CLAY_BORDER_CONFIG_ALL_RADIUS({ .color = COLOR_BLUE, .width = 5 }), {
    // Child
    // -- border will be here --
    // Child
});"><pre><span>// 300x300 container with a 1px red border around all the edges</span>
<span>CLAY_BORDER_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OuterBorder&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>300</span>), .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>300</span>)}), <span>CLAY_BORDER_CONFIG_OUTSIDE</span>(.<span>color</span> <span>=</span> <span>COLOR_RED</span>, .<span>width</span> <span>=</span> <span>1</span>), {
    <span>// ...</span>
});

<span>// Container with a 3px yellow bottom border</span>
<span>CLAY_BORDER_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OuterBorder&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_BORDER_CONFIG</span>(.<span>bottom</span> <span>=</span> { .<span>color</span> <span>=</span> <span>COLOR_YELLOW</span>, .<span>width</span> <span>=</span> <span>3</span> }), {
    <span>// ...</span>
});

<span>// Container with a 5px curved border around the edges, and a 5px blue border between all children laid out top to bottom</span>
<span>CLAY_BORDER_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OuterBorder&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>layoutDirection</span> <span>=</span> <span>CLAY_TOP_TO_BOTTOM</span>), <span>CLAY_BORDER_CONFIG_ALL_RADIUS</span>({ .<span>color</span> <span>=</span> <span>COLOR_BLUE</span>, .<span>width</span> <span>=</span> <span>5</span> }), {
    <span>// Child</span>
    <span>// -- border will be here --</span>
    <span>// Child</span>
});</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto">Element is subject to <a href="#visibility-culling">culling</a>. Otherwise, a single <code>Clay_RenderCommand</code> with <code>commandType = CLAY_RENDER_COMMAND_TYPE_BORDER</code> representing the container will be created.
Rendering of borders and rounded corners is left up to the user. See the provided <a href="https://github.com/nicbarker/clay/tree/main/renderers/raylib">Raylib Renderer</a> for examples of how to draw borders using line and curve primitives.</p>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_FLOATING_CONTAINER(id, layoutConfig, floatingConfig, children)</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_FLOATING_CONTAINER()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>FLOATING_CONTAINER</strong> defines an element that &#34;floats&#34; above other content. Typical use-cases include tooltips and modals.</p>
<p dir="auto">Floating containers:</p>
<ul dir="auto">
<li>With the <a href="#clay_floating_config">default configuration</a>, attach to the top left corner of their &#34;parent&#34;</li>
<li>Don&#39;t affect the width and height of their parent</li>
<li>Don&#39;t affect the positioning of sibling elements</li>
<li>Depending on their z-index can appear above or below other elements, partially or completely occluding them</li>
<li>Apart from positioning, function just like standard <code>CLAY_CONTAINER</code> elements - including expanding to fit their children, etc.</li>
</ul>
<p dir="auto">The easiest mental model to use when thinking about floating containers is that they are a completely separate UI hierarchy, attached to a specific x,y point on their &#34;parent&#34;.</p>
<p dir="auto">Floating elements use <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout, and <a href="#clay_floating_config">Clay_FloatingElementConfig</a> to configure specific options.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Horizontal container with three option buttons
CLAY_CONTAINER(CLAY_ID(&#34;OptionsList&#34;), CLAY_LAYOUT(.childGap = 16), {
    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 1), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE_CONFIG(.color = COLOR_BLUE), {
        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 1), CLAY_STRING(&#34;Option 1&#34;), CLAY_TEXT_CONFIG());
    });
    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 2), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE_CONFIG(.color = COLOR_BLUE), {
        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 2), CLAY_STRING(&#34;Option 2&#34;), CLAY_TEXT_CONFIG());
        // Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements
        CLAY_FLOATING_CONTAINER(CLAY_ID(&#34;OptionTooltip&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING_CONFIG(.zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_CENTER_TOP }), {
            CLAY_TEXT(CLAY_IDI(&#34;OptionTooltipText&#34;, 1), CLAY_STRING(&#34;Most popular!&#34;), CLAY_TEXT_CONFIG());
        });
    });
    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 3), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE_CONFIG(.color = COLOR_BLUE), {
        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 3), CLAY_STRING(&#34;Option 3&#34;), CLAY_TEXT_CONFIG());
    });
});

// Floating containers can also be declared elsewhere in a layout, to avoid branching or polluting other UI
for (int i = 0; i &lt; 1000; i++) {
    CLAY_CONTAINER(CLAY_IDI(&#34;Option&#34;, i + 1), &amp;CLAY_LAYOUT_DEFAULT, {}) {
        // ...
    }
}
// Note the use of &#34;parentId&#34;.
// Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements
CLAY_FLOATING_CONTAINER(CLAY_ID(&#34;OptionTooltip&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING_CONFIG(.parentId = CLAY_IDI(&#34;Option&#34;, 2) .zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_TOP_CENTER }), {
    CLAY_TEXT(CLAY_IDI(&#34;OptionTooltipText&#34;, 1), CLAY_STRING(&#34;Most popular!&#34;), CLAY_TEXT_CONFIG());
});"><pre><span>// Horizontal container with three option buttons</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OptionsList&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>childGap</span> <span>=</span> <span>16</span>), {
    <span>CLAY_RECTANGLE</span>(<span>CLAY_IDI</span>(<span>&#34;Option&#34;</span>, <span>1</span>), <span>CLAY_LAYOUT</span>(.<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_BLUE</span>), {
        <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;OptionText&#34;</span>, <span>1</span>), <span>CLAY_STRING</span>(<span>&#34;Option 1&#34;</span>), <span>CLAY_TEXT_CONFIG</span>());
    });
    <span>CLAY_RECTANGLE</span>(<span>CLAY_IDI</span>(<span>&#34;Option&#34;</span>, <span>2</span>), <span>CLAY_LAYOUT</span>(.<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_BLUE</span>), {
        <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;OptionText&#34;</span>, <span>2</span>), <span>CLAY_STRING</span>(<span>&#34;Option 2&#34;</span>), <span>CLAY_TEXT_CONFIG</span>());
        <span>// Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements</span>
        <span>CLAY_FLOATING_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OptionTooltip&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_FLOATING_CONFIG</span>(.<span>zIndex</span> <span>=</span> <span>1</span>, .<span>attachment</span> <span>=</span> { .<span>element</span> <span>=</span> <span>CLAY_ATTACH_POINT_CENTER_BOTTOM</span>, .<span>parent</span> <span>=</span> <span>CLAY_ATTACH_POINT_CENTER_TOP</span> }), {
            <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;OptionTooltipText&#34;</span>, <span>1</span>), <span>CLAY_STRING</span>(<span>&#34;Most popular!&#34;</span>), <span>CLAY_TEXT_CONFIG</span>());
        });
    });
    <span>CLAY_RECTANGLE</span>(<span>CLAY_IDI</span>(<span>&#34;Option&#34;</span>, <span>3</span>), <span>CLAY_LAYOUT</span>(.<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}), <span>CLAY_RECTANGLE_CONFIG</span>(.<span>color</span> <span>=</span> <span>COLOR_BLUE</span>), {
        <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;OptionText&#34;</span>, <span>3</span>), <span>CLAY_STRING</span>(<span>&#34;Option 3&#34;</span>), <span>CLAY_TEXT_CONFIG</span>());
    });
});

<span>// Floating containers can also be declared elsewhere in a layout, to avoid branching or polluting other UI</span>
<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>1000</span>; <span>i</span><span>++</span>) {
    <span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;Option&#34;</span>, <span>i</span> <span>+</span> <span>1</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {}) {
        <span>// ...</span>
    }
}
<span>// Note the use of &#34;parentId&#34;.</span>
<span>// Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements</span>
<span>CLAY_FLOATING_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OptionTooltip&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_FLOATING_CONFIG</span>(.<span>parentId</span> <span>=</span> <span>CLAY_IDI</span>(<span>&#34;Option&#34;</span>, <span>2</span>) .<span>zIndex</span> <span>=</span> <span>1</span>, .<span>attachment</span> <span>=</span> { .<span>element</span> <span>=</span> <span>CLAY_ATTACH_POINT_CENTER_BOTTOM</span>, .<span>parent</span> <span>=</span> <span>CLAY_ATTACH_POINT_TOP_CENTER</span> }), {
    <span>CLAY_TEXT</span>(<span>CLAY_IDI</span>(<span>&#34;OptionTooltipText&#34;</span>, <span>1</span>), <span>CLAY_STRING</span>(<span>&#34;Most popular!&#34;</span>), <span>CLAY_TEXT_CONFIG</span>());
});</pre></div>
<p dir="auto">When using <code>.parentId</code>, the floating container can be declared anywhere after <code>BeginLayout</code> and before <code>EndLayout</code>. The target element matching the <code>.parentId</code> doesn&#39;t need to exist when <code>CLAY_FLOATING_CONTAINER</code> is called.</p>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto"><code>CLAY_FLOATING_CONTAINER</code> elements will not generate any render commands.</p>

<p dir="auto"><strong>Usage</strong></p>
<p dir="auto"><code>CLAY_CUSTOM_ELEMENT(uint32_t id, Clay_LayoutConfig *layoutConfig, Clay_CustomElementConfig *customElementConfig);</code></p>
<p dir="auto"><strong>Lifecycle</strong></p>
<p dir="auto"><code>Clay_BeginLayout()</code> -&gt; <code>CLAY_CUSTOM_ELEMENT()</code> -&gt; <code>Clay_EndLayout()</code></p>
<p dir="auto"><strong>Notes</strong></p>
<p dir="auto"><strong>CUSTOM_ELEMENT</strong> uses <a href="#clay_layout">Clay_LayoutConfig</a> for styling and layout, but has no children and allows the user to pass custom data to the renderer.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data
#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;
// Extensions need to happen _before_ the clay include
#include &#34;clay.h&#34;

// A rough example of how you could handle laying out 3d models in your UI
typedef struct t_CustomElementData {
    CustomElementType type;
    union {
        Model model;
        Video video;
        // ...
    };
} CustomElementData;

Model myModel = Load3DModel(filePath);
CustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }
// ...
CLAY_CONTAINER(id, style, {
    // This config is type safe and contains the CustomElementData struct
    CLAY_CUSTOM_ELEMENT(id, style, CLAY_CUSTOM_ELEMENT_CONFIG(.customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }))
});

// Later during your rendering
switch (renderCommand-&gt;commandType) {
    // ...
    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {
        // Your extended struct is passed through
        CustomElementData *data = renderCommand-&gt;elementConfig.customElementConfig-&gt;customData;
        if (!customElement) continue;
        switch (customElement-&gt;type) {
            case CUSTOM_ELEMENT_TYPE_MODEL: {
                // Render your 3d model here
                break;
            }
            case CUSTOM_ELEMENT_TYPE_VIDEO: {
                // Render your video here
                break;
            }
            // ...
        }
        break;
    }
}"><pre><span>// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data</span>
<span>#define</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span> struct t_CustomElementData customData;
<span>// Extensions need to happen _before_ the clay include</span>
<span>#include</span> <span>&#34;clay.h&#34;</span>

<span>// A rough example of how you could handle laying out 3d models in your UI</span>
<span>typedef</span> <span>struct</span> <span>t_CustomElementData</span> {
    <span>CustomElementType</span> <span>type</span>;
    <span>union</span> {
        <span>Model</span> <span>model</span>;
        <span>Video</span> <span>video</span>;
        <span>// ...</span>
    };
} <span>CustomElementData</span>;

<span>Model</span> <span>myModel</span> <span>=</span> <span>Load3DModel</span>(<span>filePath</span>);
<span>CustomElement</span> <span>modelElement</span> <span>=</span> (<span>CustomElement</span>) { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }
<span>// ...</span>
<span>CLAY_CONTAINER</span>(<span>id</span>, <span>style</span>, {
    <span>// This config is type safe and contains the CustomElementData struct</span>
    <span>CLAY_CUSTOM_ELEMENT</span>(<span>id</span>, <span>style</span>, <span>CLAY_CUSTOM_ELEMENT_CONFIG</span>(.<span>customData</span> <span>=</span> { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }))
});

<span>// Later during your rendering</span>
<span>switch</span> (<span>renderCommand</span><span>-&gt;</span><span>commandType</span>) {
    <span>// ...</span>
    <span>case</span> <span>CLAY_RENDER_COMMAND_TYPE_CUSTOM</span>: {
        <span>// Your extended struct is passed through</span>
        <span>CustomElementData</span> <span>*</span><span>data</span> <span>=</span> <span>renderCommand</span><span>-&gt;</span><span>elementConfig</span>.<span>customElementConfig</span><span>-&gt;</span><span>customData</span>;
        <span>if</span> (!<span>customElement</span>) <span>continue</span>;
        <span>switch</span> (<span>customElement</span><span>-&gt;</span><span>type</span>) {
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>: {
                <span>// Render your 3d model here</span>
                <span>break</span>;
            }
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_VIDEO</span>: {
                <span>// Render your video here</span>
                <span>break</span>;
            }
            <span>// ...</span>
        }
        <span>break</span>;
    }
}</pre></div>
<p dir="auto"><strong>Rendering</strong></p>
<p dir="auto">Element is subject to <a href="#visibility-culling">culling</a>. Otherwise, a single <code>Clay_RenderCommand</code> with <code>commandType = CLAY_RENDER_COMMAND_TYPE_CUSTOM</code> will be created.
The user will need to access <a href="#clay_custom_element_config">Clay_CustomElementConfig</a> to retrieve custom data referenced during layout creation.</p>

<p dir="auto">A number of clay element macros take element-specific <strong>config</strong> structs.</p>

<p dir="auto"><strong>CLAY_LAYOUT()</strong> is used for configuring layout for most clay elements.</p>
<p dir="auto"><strong>Struct API (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// CLAY_LAYOUT(.member = value) supports these options
Clay_LayoutConfig {
    Clay_LayoutDirection layoutDirection = CLAY_LEFT_TO_RIGHT (default) | CLAY_TOP_TO_BOTTOM;
    Clay_Padding padding {
        float x; float y; 
    };
    uint16_t childGap;
    Clay_ChildAlignment childAlignment {
        .x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;
        .y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;
    };
    Clay_Sizing sizing { // Recommended to use the provided macros here - see #sizing for more in depth explanation
        .width = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(width) | CLAY_SIZING_PERCENT(float percent)
        .height = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(height) | CLAY_SIZING_PERCENT(float percent)
    }; // See CLAY_SIZING_GROW() etc for more details
};"><pre><span>// CLAY_LAYOUT(.member = value) supports these options</span>
<span>Clay_LayoutConfig</span> {
    <span>Clay_LayoutDirection</span> <span>layoutDirection</span> <span>=</span> <span>CLAY_LEFT_TO_RIGHT</span> (<span>default</span>) | <span>CLAY_TOP_TO_BOTTOM</span>;
    <span>Clay_Padding</span> <span>padding</span> {
        <span>float</span> <span>x</span>; <span>float</span> <span>y</span>; 
    };
    <span>uint16_t</span> <span>childGap</span>;
    <span>Clay_ChildAlignment</span> <span>childAlignment</span> {
        .<span>x</span> <span>=</span> <span>CLAY_ALIGN_X_LEFT</span> (<span>default</span>) | <span>CLAY_ALIGN_X_CENTER</span> | <span>CLAY_ALIGN_X_RIGHT</span>;
        .<span>y</span> <span>=</span> <span>CLAY_ALIGN_Y_TOP</span> (<span>default</span>) | <span>CLAY_ALIGN_Y_CENTER</span> | <span>CLAY_ALIGN_Y_BOTTOM</span>;
    };
    <span>Clay_Sizing</span> <span>sizing</span> { <span>// Recommended to use the provided macros here - see #sizing for more in depth explanation</span>
        .<span>width</span> <span>=</span> <span>CLAY_SIZING_FIT</span>(<span>float</span> <span>min</span>, <span>float</span> <span>max</span>) (<span>default</span>) | <span>CLAY_SIZING_GROW</span>(<span>float</span> <span>min</span>, <span>float</span> <span>max</span>) | <span>CLAY_SIZING_FIXED</span>(<span>width</span>) | <span>CLAY_SIZING_PERCENT</span>(<span>float</span> <span>percent</span>)
        .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIT</span>(<span>float</span> <span>min</span>, <span>float</span> <span>max</span>) (<span>default</span>) | <span>CLAY_SIZING_GROW</span>(<span>float</span> <span>min</span>, <span>float</span> <span>max</span>) | <span>CLAY_SIZING_FIXED</span>(<span>height</span>) | <span>CLAY_SIZING_PERCENT</span>(<span>float</span> <span>percent</span>)
    }; <span>// See CLAY_SIZING_GROW() etc for more details</span>
};</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_LAYOUT()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.layoutDirection</code></strong> - <code>Clay_LayoutDirection</code></p>
<p dir="auto"><code>CLAY_LAYOUT(.layoutDirection = CLAY_TOP_TO_BOTTOM)</code></p>
<p dir="auto">Controls the axis / direction in which child elements are laid out. Available options are <code>CLAY_LEFT_TO_RIGHT</code> (default) and <code>CLAY_TOP_TO_BOTTOM</code>.</p>
<p dir="auto"><em>Did you know that &#34;left to right&#34; and &#34;top to bottom&#34; both have 13 letters?</em></p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360158875-7008aa47-8826-4338-9257-8bc83f7813ce.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1ODg3NS03MDA4YWE0Ny04ODI2LTQzMzgtOTI1Ny04YmM4M2Y3ODEzY2UucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDI3OTZlMzQxYjA3MzJkZTRlYjI2OTc3MTkxYmFiZjFmMjU0OWY3NTY1NDY1Mjc2ZjY0Mjc3NzY0ZjJmN2M0YSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.4FwX7-aIerSHLo10QUY-iwo0qs6_jXspN78cEHnt7X4"><img width="580" alt="Screenshot 2024-08-22 at 11 10 27 AM" src="https://private-user-images.githubusercontent.com/2264338/360158875-7008aa47-8826-4338-9257-8bc83f7813ce.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1ODg3NS03MDA4YWE0Ny04ODI2LTQzMzgtOTI1Ny04YmM4M2Y3ODEzY2UucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDI3OTZlMzQxYjA3MzJkZTRlYjI2OTc3MTkxYmFiZjFmMjU0OWY3NTY1NDY1Mjc2ZjY0Mjc3NzY0ZjJmN2M0YSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.4FwX7-aIerSHLo10QUY-iwo0qs6_jXspN78cEHnt7X4"/></a>
<hr/>
<p dir="auto"><strong><code>.padding</code></strong> - <code>Clay_Padding</code></p>
<p dir="auto"><code>CLAY_LAYOUT(.padding = { .x = 16, .y = 16 })</code></p>
<p dir="auto">Controls horizontal and vertical white-space &#34;padding&#34; around the <strong>outside</strong> of child elements.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360155943-9311cf10-b8aa-40fe-922a-5dee3663f1a0.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1NTk0My05MzExY2YxMC1iOGFhLTQwZmUtOTIyYS01ZGVlMzY2M2YxYTAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODI0MDBiOTZkODQ2MWIwNzgxNGM3Njk5ZDJhYWVmZDI0YWMwNzc0MTBmMDNiZTM0ZTQxZTQ0OTk4MTYxMzE1MCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.jYyCajAm3uJADCU9DCbBpyRAb-2e2UTFk5z3U35rdGU"><img width="486" alt="Screenshot 2024-08-22 at 10 50 49 AM" src="https://private-user-images.githubusercontent.com/2264338/360155943-9311cf10-b8aa-40fe-922a-5dee3663f1a0.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1NTk0My05MzExY2YxMC1iOGFhLTQwZmUtOTIyYS01ZGVlMzY2M2YxYTAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODI0MDBiOTZkODQ2MWIwNzgxNGM3Njk5ZDJhYWVmZDI0YWMwNzc0MTBmMDNiZTM0ZTQxZTQ0OTk4MTYxMzE1MCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.jYyCajAm3uJADCU9DCbBpyRAb-2e2UTFk5z3U35rdGU"/></a>
<hr/>
<p dir="auto"><strong><code>.childGap</code></strong> - <code>uint16_t</code></p>
<p dir="auto"><code>CLAY_LAYOUT(.childGap = 16)</code></p>
<p dir="auto">Controls the white-space <strong>between</strong> child elements as they are laid out. When <code>.layoutDirection</code> is <code>CLAY_LEFT_TO_RIGHT</code> (default), this will be horizontal space, whereas for <code>CLAY_TOP_TO_BOTTOM</code> it will be vertical space.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360158177-fa0dae1f-1936-47f6-a299-634bd7d40d58.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1ODE3Ny1mYTBkYWUxZi0xOTM2LTQ3ZjYtYTI5OS02MzRiZDdkNDBkNTgucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NTA5MjEzODk0MWY0YmZlNmE5ZDAxMTEwMjFlNjEzM2ZhMjE2ZjU3NjEzM2U4MzMyYzA5NjJmMWMzZjQ0MTk3OCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.VAKIsASBcb7c1XXYG03YWDL3DLAzn58GNIN0LbnI4YA"><img width="600" alt="Screenshot 2024-08-22 at 11 05 15 AM" src="https://private-user-images.githubusercontent.com/2264338/360158177-fa0dae1f-1936-47f6-a299-634bd7d40d58.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE1ODE3Ny1mYTBkYWUxZi0xOTM2LTQ3ZjYtYTI5OS02MzRiZDdkNDBkNTgucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NTA5MjEzODk0MWY0YmZlNmE5ZDAxMTEwMjFlNjEzM2ZhMjE2ZjU3NjEzM2U4MzMyYzA5NjJmMWMzZjQ0MTk3OCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.VAKIsASBcb7c1XXYG03YWDL3DLAzn58GNIN0LbnI4YA"/></a>
<hr/>
<p dir="auto"><strong><code>.childAlignment</code></strong> - <code>Clay_ChildAlignment</code></p>
<p dir="auto"><code>CLAY_LAYOUT(.childAlignment = { .x = CLAY_ALIGN_X_LEFT, .y = CLAY_ALIGN_Y_CENTER })</code></p>
<p dir="auto">Controls the alignment of children relative to the height and width of the parent container. Available options are:</p>
<div dir="auto" data-snippet-clipboard-copy-content=".x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;
.y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;"><pre>.<span>x</span> <span>=</span> <span>CLAY_ALIGN_X_LEFT</span> (<span>default</span>) | <span>CLAY_ALIGN_X_CENTER</span> | <span>CLAY_ALIGN_X_RIGHT</span>;
.<span>y</span> <span>=</span> <span>CLAY_ALIGN_Y_TOP</span> (<span>default</span>) | <span>CLAY_ALIGN_Y_CENTER</span> | <span>CLAY_ALIGN_Y_BOTTOM</span>;</pre></div>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360161038-be61b4a7-db4f-447c-b6d6-b2d4a91fc664.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE2MTAzOC1iZTYxYjRhNy1kYjRmLTQ0N2MtYjZkNi1iMmQ0YTkxZmM2NjQucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9MjYwNmM3NTgyYjliZTI1ZDM0OTk5M2E2Njc1ZDIyYmM5MThhYzZmMDA2NTZlNDUxNTI2NjNkMDcwNDg0ZjAzNCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.zBD_GD5PyQ2RY8HSdAl31ehAuvohHrPn-85cdrIw-dY"><img width="1030" alt="Screenshot 2024-08-22 at 11 25 16 AM" src="https://private-user-images.githubusercontent.com/2264338/360161038-be61b4a7-db4f-447c-b6d6-b2d4a91fc664.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDE2MTAzOC1iZTYxYjRhNy1kYjRmLTQ0N2MtYjZkNi1iMmQ0YTkxZmM2NjQucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9MjYwNmM3NTgyYjliZTI1ZDM0OTk5M2E2Njc1ZDIyYmM5MThhYzZmMDA2NTZlNDUxNTI2NjNkMDcwNDg0ZjAzNCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.zBD_GD5PyQ2RY8HSdAl31ehAuvohHrPn-85cdrIw-dY"/></a>
<hr/>
<p dir="auto"><strong><code>.sizing</code></strong> - <code>Clay_Sizing</code></p>
<p dir="auto"><code>CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_PERCENT(0.5) })</code></p>
<p dir="auto">Controls how final width and height of element are calculated. The same configurations are available for both the <code>.width</code> and <code>.height</code> axis. There are several options:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>CLAY_SIZING_FIT(float min, float max) (default)</code> - The element will be sized to fit its children (plus padding and gaps), up to <code>max</code>. If <code>max</code> is left unspecified, it will default to <code>FLOAT_MAX</code>. When elements are compressed to fit into a smaller parent, this element will not shrink below <code>min</code>.</p>
</li>
<li>
<p dir="auto"><code>CLAY_SIZING_GROW(float min, float max)</code> - The element will grow to fill available space in its parent, up to <code>max</code>. If <code>max</code> is left unspecified, it will default to <code>FLOAT_MAX</code>. When elements are compressed to fit into a smaller parent, this element will not shrink below <code>min</code>.</p>
</li>
<li>
<p dir="auto"><code>CLAY_SIZING_FIXED(float fixed)</code> - The final size will always be exactly the provided <code>fixed</code> value. Shorthand for <code>CLAY_SIZING_FIT(fixed, fixed)</code></p>
</li>
<li>
<p dir="auto"><code>CLAY_SIZING_PERCENT(float percent)</code> - Final size will be a percentage of parent size, minus padding and child gaps. <code>percent</code> is assumed to be a float between <code>0</code> and <code>1</code>.</p>
</li>
</ul>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360223410-1236efb1-77dc-44cd-a207-7944e0f5e500.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDIyMzQxMC0xMjM2ZWZiMS03N2RjLTQ0Y2QtYTIwNy03OTQ0ZTBmNWU1MDAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NDViNWRmMGY0NjM2NDUwZjdiZmNlNGYxZGQwYWMxYjYyMWU3NTY2YTQ0M2MyMWJjZmM1NjRmZjA4M2FjMzVhNyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.MOAeMU164ZhF8wrj3OSdHZpqTh6b_4Aj4bO92k_qG4M"><img width="1056" alt="Screenshot 2024-08-22 at 2 10 33 PM" src="https://private-user-images.githubusercontent.com/2264338/360223410-1236efb1-77dc-44cd-a207-7944e0f5e500.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDIyMzQxMC0xMjM2ZWZiMS03N2RjLTQ0Y2QtYTIwNy03OTQ0ZTBmNWU1MDAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NDViNWRmMGY0NjM2NDUwZjdiZmNlNGYxZGQwYWMxYjYyMWU3NTY2YTQ0M2MyMWJjZmM1NjRmZjA4M2FjMzVhNyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.MOAeMU164ZhF8wrj3OSdHZpqTh6b_4Aj4bO92k_qG4M"/></a>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360224810-a26074ff-f155-4d35-9ca4-9278a64aac00.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDIyNDgxMC1hMjYwNzRmZi1mMTU1LTRkMzUtOWNhNC05Mjc4YTY0YWFjMDAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YWYxNDhhNmUyZjU0ZDFkZmZmNTI4NjhhYmRkNzkxOWI1OTBlMzNmYTVlYzdhYWI0ZGVhZjM0ZDAxNTQ2ZTljOCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.wZCZ-4c9fYmjpC3rsprGh3jB8Osnm6lnko2jxJVOdNU"><img width="1141" alt="Screenshot 2024-08-22 at 2 19 04 PM" src="https://private-user-images.githubusercontent.com/2264338/360224810-a26074ff-f155-4d35-9ca4-9278a64aac00.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDIyNDgxMC1hMjYwNzRmZi1mMTU1LTRkMzUtOWNhNC05Mjc4YTY0YWFjMDAucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YWYxNDhhNmUyZjU0ZDFkZmZmNTI4NjhhYmRkNzkxOWI1OTBlMzNmYTVlYzdhYWI0ZGVhZjM0ZDAxNTQ2ZTljOCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.wZCZ-4c9fYmjpC3rsprGh3jB8Osnm6lnko2jxJVOdNU"/></a>
<p dir="auto"><strong>Example Usage</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="CLAY_CONTAINER(CLAY_ID(&#34;Button&#34;), CLAY_LAYOUT(.layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16), {
    // Children will be laid out vertically with 16px of padding around and between
});"><pre><span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;Button&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>layoutDirection</span> <span>=</span> <span>CLAY_TOP_TO_BOTTOM</span>, .<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>() }, .<span>padding</span> <span>=</span> {<span>16</span>, <span>16</span>}, .<span>childGap</span> <span>=</span> <span>16</span>), {
    <span>// Children will be laid out vertically with 16px of padding around and between</span>
});</pre></div>

<p dir="auto"><strong>CLAY_RECTANGLE_CONFIG()</strong> is used for configuring rendering for <a href="#clay_rectangle">CLAY_RECTANGLE()</a> elements. The config will be passed through to render commands as <code>Clay_RenderCommand.config.rectangleElementConfig</code></p>
<p dir="auto"><strong>Struct API (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// CLAY_RECTANGLE_CONFIG(.member = value) supports these options
Clay_RectangleConfig {
    Clay_Color color {
        float r; float g; float b; float a;
    };
    float cornerRadius;

    #ifdef CLAY_EXTEND_CONFIG_RECTANGLE
        // Contents of CLAY_EXTEND_CONFIG_RECTANGLE will be pasted here
    #endif
}"><pre><span>// CLAY_RECTANGLE_CONFIG(.member = value) supports these options</span>
<span>Clay_RectangleConfig</span> {
    <span>Clay_Color</span> <span>color</span> {
        <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
    };
    <span>float</span> <span>cornerRadius</span>;

    <span>#ifdef</span> <span>CLAY_EXTEND_CONFIG_RECTANGLE</span>
        <span>// Contents of CLAY_EXTEND_CONFIG_RECTANGLE will be pasted here</span>
    <span>#endif</span>
}</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_RECTANGLE_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Extension</strong></p>
<p dir="auto">The underlying <code>Clay_RectangleElementConfig</code> can be extended with new members by using:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define CLAY_EXTEND_CONFIG_RECTANGLE float newField;
#include &#34;clay.h&#34; // Define your extension before including clay.h"><pre><span>#define</span> <span>CLAY_EXTEND_CONFIG_RECTANGLE</span> float newField;
<span>#include</span> <span>&#34;clay.h&#34;</span> <span>// Define your extension before including clay.h</span></pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.color</code></strong> - <code>Clay_Color</code></p>
<p dir="auto"><code>CLAY_RECTANGLE_CONFIG(.color = {120, 120, 120, 255})</code></p>
<p dir="auto">Conventionally accepts <code>rgba</code> float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.</p>
<hr/>
<p dir="auto"><strong><code>.cornerRadius</code></strong> - <code>float</code></p>
<p dir="auto"><code>CLAY_RECTANGLE_CONFIG(.cornerRadius = 16)</code></p>
<p dir="auto">Defines the radius in pixels for the arc of rectangle corners (<code>0</code> is square, <code>rectangle.width / 2</code> is circular).</p>
<p dir="auto">Note that the <code>CLAY_CORNER_RADIUS(radius)</code> function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. <code>CLAY_BORDER_CONFIG(.cornerRadius = CLAY_CORNER_RADIUS(10))</code></p>

<p dir="auto"><strong>CLAY_TEXT_CONFIG()</strong> is a macro used to create and store <code>Clay_TextElementConfig</code> structs, which are for configuring <a href="#clay_text">CLAY_TEXT</a> elements. The config used in declaration will be passed both as an argument to the user-provided <code>Clay_MeasureText(Clay_String *text, Clay_TextElementConfig *config)</code> function as well as the in the final output as <code>Clay_RenderCommand.config.textElementConfig</code>.</p>
<p dir="auto"><strong>Struct API (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// CLAY_TEXT_CONFIG(.member = value) supports these options
Clay_TextElementConfig {
    Clay_Color textColor {
        float r; float g; float b; float a;
    };
    uint16_t fontId;
    uint16_t fontSize;
    uint16_t letterSpacing;
    uint16_t lineSpacing;

    #ifdef CLAY_EXTEND_CONFIG_TEXT
        // Contents of CLAY_EXTEND_CONFIG_TEXT will be pasted here
    #endif
};"><pre><span>// CLAY_TEXT_CONFIG(.member = value) supports these options</span>
<span>Clay_TextElementConfig</span> {
    <span>Clay_Color</span> <span>textColor</span> {
        <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
    };
    <span>uint16_t</span> <span>fontId</span>;
    <span>uint16_t</span> <span>fontSize</span>;
    <span>uint16_t</span> <span>letterSpacing</span>;
    <span>uint16_t</span> <span>lineSpacing</span>;

    <span>#ifdef</span> <span>CLAY_EXTEND_CONFIG_TEXT</span>
        <span>// Contents of CLAY_EXTEND_CONFIG_TEXT will be pasted here</span>
    <span>#endif</span>
};</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_TEXT_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Extension</strong></p>
<p dir="auto">The underlying <code>Clay_TextElementConfig</code> can be extended with new members by using:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define CLAY_EXTEND_CONFIG_TEXT float newField;
#include &#34;clay.h&#34; // Define your extension before including clay.h"><pre><span>#define</span> <span>CLAY_EXTEND_CONFIG_TEXT</span> float newField;
<span>#include</span> <span>&#34;clay.h&#34;</span> <span>// Define your extension before including clay.h</span></pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.textColor</code></strong></p>
<p dir="auto"><code>CLAY_TEXT_CONFIG(.textColor = {120, 120, 120, 255})</code></p>
<p dir="auto">Conventionally accepts <code>rgba</code> float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.</p>
<hr/>
<p dir="auto"><strong><code>.fontId</code></strong></p>
<p dir="auto"><code>CLAY_TEXT_CONFIG(.fontId = FONT_ID_LATO)</code></p>
<p dir="auto">It&#39;s up to the user to load fonts and create a mapping from <code>fontId</code> to a font that can be measured and rendered.</p>
<hr/>
<p dir="auto"><strong><code>.fontSize</code></strong></p>
<p dir="auto"><code>CLAY_TEXT_CONFIG(.fontSize = 16)</code></p>
<p dir="auto">Font size is generally thought of as <code>x pixels tall</code>, but interpretation is left up to the user &amp; renderer.</p>
<hr/>
<p dir="auto"><strong><code>.letterSpacing</code></strong></p>
<p dir="auto"><code>CLAY_TEXT_CONFIG(.letterSpacing = 1)</code></p>
<p dir="auto"><code>.letterSpacing</code> results in <strong>horizontal</strong> white space between individual rendered characters.</p>
<hr/>
<p dir="auto"><strong><code>.lineSpacing</code></strong></p>
<p dir="auto"><code>CLAY_TEXT_CONFIG(.lineSpacing = 1)</code></p>
<p dir="auto"><code>.lineSpacing</code> results in <strong>vertical</strong> white space between lines of text (from both <code>\n</code> characters and text wrapping) and will affect layout of parents and siblings.</p>
<p dir="auto"><strong>Example Usage</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// A 24px, red text element that says &#34;John Smith&#34;
CLAY_TEXT(CLAY_ID(&#34;Username&#34;), CLAY_STRING(&#34;John Smith&#34;), CLAY_TEXT_CONFIG(.fontSize = 24, .fontId = 2, .textColor = {255, 0, 0, 255}));"><pre><span>// A 24px, red text element that says &#34;John Smith&#34;</span>
<span>CLAY_TEXT</span>(<span>CLAY_ID</span>(<span>&#34;Username&#34;</span>), <span>CLAY_STRING</span>(<span>&#34;John Smith&#34;</span>), <span>CLAY_TEXT_CONFIG</span>(.<span>fontSize</span> <span>=</span> <span>24</span>, .<span>fontId</span> <span>=</span> <span>2</span>, .<span>textColor</span> <span>=</span> {<span>255</span>, <span>0</span>, <span>0</span>, <span>255</span>}));</pre></div>

<p dir="auto"><strong>CLAY_IMAGE_CONFIG()</strong> is a macro used to create and store <code>Clay_ImageElementConfig</code> structs, which are for configuring <a href="#clay_image">CLAY_IMAGE</a> elements. The config will be passed through to render commands as <code>Clay_RenderCommand.config.imageElementConfig</code></p>
<p dir="auto"><strong>Struct API (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="Clay_ImageElementConfig {
    Clay_Dimensions sourceDimensions {
        float width; float height; 
    };
    // --
    #ifndef CLAY_EXTEND_CONFIG_IMAGE
        void * imageData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_IMAGE is specified
    #else CLAY_EXTEND_CONFIG_IMAGE
        // Contents of CLAY_EXTEND_CONFIG_IMAGE will be pasted here
    #endif
};"><pre><span>Clay_ImageElementConfig</span> {
    <span>Clay_Dimensions</span> <span>sourceDimensions</span> {
        <span>float</span> <span>width</span>; <span>float</span> <span>height</span>; 
    };
    <span>// --</span>
    <span>#ifndef</span> <span>CLAY_EXTEND_CONFIG_IMAGE</span>
        <span>void</span> <span>*</span> <span>imageData</span>; <span>// Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_IMAGE is specified</span>
    <span>#else</span> <span>CLAY_EXTEND_CONFIG_IMAGE</span>
        <span>// Contents of CLAY_EXTEND_CONFIG_IMAGE will be pasted here</span>
    <span>#endif</span>
};</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_IMAGE_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Extension</strong></p>
<p dir="auto">The underlying <code>Clay_ImageElementConfig</code> can be extended with new members by using:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define CLAY_EXTEND_CONFIG_IMAGE float newField;
#include &#34;clay.h&#34; // Define your extension before including clay.h"><pre><span>#define</span> <span>CLAY_EXTEND_CONFIG_IMAGE</span> float newField;
<span>#include</span> <span>&#34;clay.h&#34;</span> <span>// Define your extension before including clay.h</span></pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.sourceDimensions</code></strong> - <code>Clay_Dimensions</code></p>
<p dir="auto"><code>CLAY_IMAGE_CONFIG(.sourceDimensions = { 1024, 768 })</code></p>
<p dir="auto">Used to perform <strong>aspect ratio scaling</strong> on the image element. As of this version of clay, aspect ratio scaling only applies to the <code>height</code> of an image (i.e. image height will scale with width growth and limitations, but width will not scale with height growth and limitations)</p>
<hr/>
<p dir="auto"><strong><code>.imageData</code></strong> - <code>void *</code></p>
<p dir="auto"><code>CLAY_IMAGE_CONFIG(.imageData = &amp;myImage)</code></p>
<p dir="auto"><code>.imageData</code> is a generic void pointer that can be used to pass through image data to the renderer. <strong>Note:</strong> this field is generally not recommended for usage due to the lack of type safety, see <code>#define CLAY_EXTEND_CONFIG_IMAGE</code> in <a href="#preprocessor-directives">Preprocessor Directives</a> for an alternative.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Load an image somewhere in your code
Image profilePicture = LoadImage(&#34;profilePicture.png&#34;);
// Note that when rendering, .imageData will be void* type.
CLAY_IMAGE(CLAY_ID(&#34;ProfilePicture&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_IMAGE_CONFIG(.imageData = &amp;profilePicture, .sourceDimensions = { 60, 60 }), {});

// OR ----------------

// Extend CLAY_CUSTOM_IMAGE_CONFIG with your custom image format
#define CLAY_EXTEND_CONFIG_IMAGE struct t_Image image;
// Extensions need to happen _before_ the clay include
#include &#34;clay.h&#34;

typedef struct t_Image {
    ImageFormat format;
    u8int_t *internalData;
    // ... etc
} Image;

// You can now use CLAY_IMAGE_CONFIG with your custom type and still have type safety &amp; code completion
CLAY_IMAGE(CLAY_ID(&#34;ProfilePicture&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_IMAGE_CONFIG(.image = { .format = IMAGE_FORMAT_RGBA, .internalData = &amp;imageData }, .sourceDimensions = { 60, 60 }), {});"><pre><span>// Load an image somewhere in your code</span>
<span>Image</span> <span>profilePicture</span> <span>=</span> <span>LoadImage</span>(<span>&#34;profilePicture.png&#34;</span>);
<span>// Note that when rendering, .imageData will be void* type.</span>
<span>CLAY_IMAGE</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePicture&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_IMAGE_CONFIG</span>(.<span>imageData</span> <span>=</span> <span>&amp;</span><span>profilePicture</span>, .<span>sourceDimensions</span> <span>=</span> { <span>60</span>, <span>60</span> }), {});

<span>// OR ----------------</span>

<span>// Extend CLAY_CUSTOM_IMAGE_CONFIG with your custom image format</span>
<span>#define</span> <span>CLAY_EXTEND_CONFIG_IMAGE</span> struct t_Image image;
<span>// Extensions need to happen _before_ the clay include</span>
<span>#include</span> <span>&#34;clay.h&#34;</span>

<span>typedef</span> <span>struct</span> <span>t_Image</span> {
    <span>ImageFormat</span> <span>format</span>;
    <span>u8int_t</span> <span>*</span><span>internalData</span>;
    <span>// ... etc</span>
} <span>Image</span>;

<span>// You can now use CLAY_IMAGE_CONFIG with your custom type and still have type safety &amp; code completion</span>
<span>CLAY_IMAGE</span>(<span>CLAY_ID</span>(<span>&#34;ProfilePicture&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_IMAGE_CONFIG</span>(.<span>image</span> <span>=</span> { .<span>format</span> <span>=</span> <span>IMAGE_FORMAT_RGBA</span>, .<span>internalData</span> <span>=</span> <span>&amp;</span><span>imageData</span> }, .<span>sourceDimensions</span> <span>=</span> { <span>60</span>, <span>60</span> }), {});</pre></div>

<p dir="auto"><strong>CLAY_FLOATING_CONFIG()</strong> is a macro used to create and store <code>Clay_FloatingElementConfig</code> structs, which are for configuring <a href="#clay_floating_container">CLAY_FLOATING_CONTAINER</a> elements.</p>
<p dir="auto"><strong>Struct Definition (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    Clay_Vector2 offset {
        float x, float y
    };
    Clay_Dimensions expand {
        float width, float height
    };
    uint16_t zIndex;
    uint32_t parentId;
    Clay_FloatingAttachPoints attachment {
        .element = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM
        .parent = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM
    };
} Clay_FloatingElementConfig;"><pre><span>typedef</span> <span>struct</span>
{
    <span>Clay_Vector2</span> <span>offset</span> {
        <span>float</span> <span>x</span>, <span>float</span> <span>y</span>
    }<span></span>;
    <span>Clay_Dimensions</span> <span>expand</span> {
        <span>float</span> <span>width</span>, <span>float</span> <span>height</span>
    };
    <span>uint16_t</span> <span>zIndex</span>;
    <span>uint32_t</span> <span>parentId</span>;
    <span>Clay_FloatingAttachPoints</span> <span>attachment</span> {
        .<span>element</span> <span>=</span> <span>CLAY_ATTACH_POINT_LEFT_TOP</span> (<span>default</span>) | <span>CLAY_ATTACH_POINT_LEFT_CENTER</span> | <span>CLAY_ATTACH_POINT_LEFT_BOTTOM</span> | <span>CLAY_ATTACH_POINT_CENTER_TOP</span> | <span>CLAY_ATTACH_POINT_CENTER_CENTER</span> | <span>CLAY_ATTACH_POINT_CENTER_BOTTOM</span> | <span>CLAY_ATTACH_POINT_RIGHT_TOP</span> | <span>CLAY_ATTACH_POINT_RIGHT_CENTER</span> | <span>CLAY_ATTACH_POINT_RIGHT_BOTTOM</span>
        .<span>parent</span> <span>=</span> <span>CLAY_ATTACH_POINT_LEFT_TOP</span> (<span>default</span>) | <span>CLAY_ATTACH_POINT_LEFT_CENTER</span> | <span>CLAY_ATTACH_POINT_LEFT_BOTTOM</span> | <span>CLAY_ATTACH_POINT_CENTER_TOP</span> | <span>CLAY_ATTACH_POINT_CENTER_CENTER</span> | <span>CLAY_ATTACH_POINT_CENTER_BOTTOM</span> | <span>CLAY_ATTACH_POINT_RIGHT_TOP</span> | <span>CLAY_ATTACH_POINT_RIGHT_CENTER</span> | <span>CLAY_ATTACH_POINT_RIGHT_BOTTOM</span>
    };
} <span>Clay_FloatingElementConfig</span>;</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_FLOATING_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.offset</code></strong> - <code>Clay_Vector2</code></p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.offset = { -24, -24 })</code></p>
<p dir="auto">Used to apply a position offset to the floating container <em>after</em> all other layout has been calculated.</p>
<hr/>
<p dir="auto"><strong><code>.expand</code></strong> - <code>Clay_Dimensions</code></p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.expand = { 16, 16 })</code></p>
<p dir="auto">Used to expand the width and height of the floating container <em>before</em> laying out child elements.</p>
<hr/>
<p dir="auto"><strong><code>.zIndex</code></strong> - <code>float</code></p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.zIndex = 1)</code></p>
<p dir="auto">All floating elements (as well as their entire child hierarchies) will be sorted by <code>.zIndex</code> order before being converted to render commands. If render commands are drawn in order, elements with higher <code>.zIndex</code> values will be drawn on top.</p>
<hr/>
<p dir="auto"><strong><code>.parentId</code></strong> - <code>uint32_t</code></p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.parentId = CLAY_ID(&#34;HeaderButton&#34;))</code></p>
<p dir="auto">By default, floating containers will &#34;attach&#34; to the parent element that they are declared inside. However, there are cases where this limitation could cause significant performance or ergonomics problems. <code>.parentId</code> allows you to specify a <code>CLAY_ID()</code> to attach the floating container to. The parent element with the matching id can be declared anywhere in the hierarchy, it doesn&#39;t need to be declared before or after the floating container in particular.</p>
<p dir="auto">Consider the following case:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Load an image somewhere in your code
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 1), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
    if (tooltip.attachedButtonIndex == 1) {
        CLAY_FLOATING_CONTAINER(/* floating config... */);
    }
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 2), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
    if (tooltip.attachedButtonIndex == 2) {
        CLAY_FLOATING_CONTAINER(/* floating config... */);
    }
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 3), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
    if (tooltip.attachedButtonIndex == 3) {
        CLAY_FLOATING_CONTAINER(/* floating config... */);
    }
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 4), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
    if (tooltip.attachedButtonIndex == 4) {
        CLAY_FLOATING_CONTAINER(/* floating config... */);
    }
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 5), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
    if (tooltip.attachedButtonIndex == 5) {
        CLAY_FLOATING_CONTAINER(/* floating config... */);
    }
});"><pre><span>// Load an image somewhere in your code</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>1</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
    <span>if</span> (<span>tooltip</span>.<span>attachedButtonIndex</span> <span>==</span> <span>1</span>) {
        <span>CLAY_FLOATING_CONTAINER</span>(<span>/* floating config... */</span>);
    }
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>2</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
    <span>if</span> (<span>tooltip</span>.<span>attachedButtonIndex</span> <span>==</span> <span>2</span>) {
        <span>CLAY_FLOATING_CONTAINER</span>(<span>/* floating config... */</span>);
    }
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>3</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
    <span>if</span> (<span>tooltip</span>.<span>attachedButtonIndex</span> <span>==</span> <span>3</span>) {
        <span>CLAY_FLOATING_CONTAINER</span>(<span>/* floating config... */</span>);
    }
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>4</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
    <span>if</span> (<span>tooltip</span>.<span>attachedButtonIndex</span> <span>==</span> <span>4</span>) {
        <span>CLAY_FLOATING_CONTAINER</span>(<span>/* floating config... */</span>);
    }
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>5</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
    <span>if</span> (<span>tooltip</span>.<span>attachedButtonIndex</span> <span>==</span> <span>5</span>) {
        <span>CLAY_FLOATING_CONTAINER</span>(<span>/* floating config... */</span>);
    }
});</pre></div>
<p dir="auto">The definition of the above UI is significantly polluted by the need to conditionally render floating tooltips as a child of many possible elements. The alternative, using <code>parentId</code>, looks like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Load an image somewhere in your code
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 1), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 2), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 3), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 4), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
});
CLAY_CONTAINER(CLAY_IDI(&#34;SidebarButton&#34;, 5), &amp;CLAY_LAYOUT_DEFAULT, {
    // .. some button contents
});

// Any other point in the hierarchy
CLAY_FLOATING_CONTAINER(CLAY_ID(&#34;OptionTooltip&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING_CONFIG(.parentId = CLAY_IDI(&#34;SidebarButton&#34;, tooltip.attachedButtonIndex)), {
    // Tooltip contents...
});"><pre><span>// Load an image somewhere in your code</span>
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>1</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>2</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>3</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>4</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
});
<span>CLAY_CONTAINER</span>(<span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>5</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, {
    <span>// .. some button contents</span>
});

<span>// Any other point in the hierarchy</span>
<span>CLAY_FLOATING_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;OptionTooltip&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_FLOATING_CONFIG</span>(.<span>parentId</span> <span>=</span> <span>CLAY_IDI</span>(<span>&#34;SidebarButton&#34;</span>, <span>tooltip</span>.<span>attachedButtonIndex</span>)), {
    <span>// Tooltip contents...</span>
});</pre></div>
<hr/>
<p dir="auto"><strong><code>.attachment</code></strong> - <code>Clay_FloatingAttachPoints</code></p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP });</code></p>
<p dir="auto">In terms of positioning the floating container, <code>.attachment</code> specifies</p>
<ul dir="auto">
<li>The point on the floating container (<code>.element</code>)</li>
<li>The point on the parent element that it &#34;attaches&#34; to (<code>.parent</code>)</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360709305-b8c6dfaa-c1b1-41a4-be55-013473e4a6ce.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDcwOTMwNS1iOGM2ZGZhYS1jMWIxLTQxYTQtYmU1NS0wMTM0NzNlNGE2Y2UucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YTA4NWMyMDU1NzUxNGJiNjc0YzgxY2UxZjJmM2IzZmJmZDMxZWViOWYzMzU4NjJjNmQ3ZGE2ODEzYTliMTY2ZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.X3eY-5bw0SHgRwtAUjQqhbfWQjJKp53nWwRYGpRiFfU"><img src="https://private-user-images.githubusercontent.com/2264338/360709305-b8c6dfaa-c1b1-41a4-be55-013473e4a6ce.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDcwOTMwNS1iOGM2ZGZhYS1jMWIxLTQxYTQtYmU1NS0wMTM0NzNlNGE2Y2UucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YTA4NWMyMDU1NzUxNGJiNjc0YzgxY2UxZjJmM2IzZmJmZDMxZWViOWYzMzU4NjJjNmQ3ZGE2ODEzYTliMTY2ZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.X3eY-5bw0SHgRwtAUjQqhbfWQjJKp53nWwRYGpRiFfU" alt="Screenshot 2024-08-23 at 11 47 21 AM"/></a></p>
<p dir="auto">You can mentally visualise this as finding a point on the floating container, then finding a point on the parent, and lining them up over the top of one another.</p>
<p dir="auto">For example:</p>
<p dir="auto">&#34;Attach the LEFT_CENTER of the floating container to the RIGHT_TOP of the parent&#34;</p>
<p dir="auto"><code>CLAY_FLOATING_CONFIG(.attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP });</code></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/2264338/360710131-ebe75e0d-1904-46b0-982d-418f929d1516.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDcxMDEzMS1lYmU3NWUwZC0xOTA0LTQ2YjAtOTgyZC00MThmOTI5ZDE1MTYucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZGE3YTlhOWU3YTJhZWY3MTExYTBlZDQxNzA5NDYyODc5YTcwYjI4NjkxZmJlYzk2YzcyOWY2NzlkYzQxYmFhZiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.cSMt0qCjEsPUImfSZcjunP7tNCRaCrwA6cHnjn7VOZk"><img src="https://private-user-images.githubusercontent.com/2264338/360710131-ebe75e0d-1904-46b0-982d-418f929d1516.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjQ3NjIxMDYsIm5iZiI6MTcyNDc2MTgwNiwicGF0aCI6Ii8yMjY0MzM4LzM2MDcxMDEzMS1lYmU3NWUwZC0xOTA0LTQ2YjAtOTgyZC00MThmOTI5ZDE1MTYucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDgyNyUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA4MjdUMTIzMDA2WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZGE3YTlhOWU3YTJhZWY3MTExYTBlZDQxNzA5NDYyODc5YTcwYjI4NjkxZmJlYzk2YzcyOWY2NzlkYzQxYmFhZiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.cSMt0qCjEsPUImfSZcjunP7tNCRaCrwA6cHnjn7VOZk" alt="Screenshot 2024-08-23 at 11 53 24 AM"/></a></p>

<p dir="auto"><strong>CLAY_SCROLL_CONFIG()</strong> is a macro used to create and store <code>Clay_ScrollContainerElementConfig</code> structs, which are for configuring <a href="#clay_scroll_container">CLAY_SCROLL_CONTAINER</a> elements.</p>
<p dir="auto"><strong>Struct Definition (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    bool horizontal;
    bool vertical;
} Clay_ScrollContainerElementConfig;"><pre><span>typedef</span> <span>struct</span>
{
    <span>bool</span> <span>horizontal</span>;
    <span>bool</span> <span>vertical</span>;
} <span>Clay_ScrollContainerElementConfig</span>;</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_SCROLL_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.horizontal</code></strong> - <code>bool</code></p>
<p dir="auto"><code>CLAY_SCROLL_CONFIG(.horizontal = true)</code></p>
<p dir="auto">Enables or disables horizontal scrolling for this container element.</p>
<hr/>
<p dir="auto"><strong><code>.vertical</code></strong> - <code>bool</code></p>
<p dir="auto"><code>CLAY_SCROLL_CONFIG(.vertical = true)</code></p>
<p dir="auto">Enables or disables vertical scrolling for this container element.</p>
<p dir="auto"><strong>Examples</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="CLAY_SCROLL_CONTAINER(CLAY_ID(&#34;MainContent&#34;), &amp;CLAY_LAYOUT_DEFAULT, CLAY_SCROLL_CONFIG(.vertical = true), {
    // Create child content with a fixed height of 5000
    CLAY_CONTAINER(CLAY_ID(&#34;ScrollInner&#34;), CLAY_LAYOUT(.sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_FIXED(5000) }), {});
});"><pre><span>CLAY_SCROLL_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;MainContent&#34;</span>), <span>&amp;</span><span>CLAY_LAYOUT_DEFAULT</span>, <span>CLAY_SCROLL_CONFIG</span>(.<span>vertical</span> <span>=</span> true), {
    <span>// Create child content with a fixed height of 5000</span>
    <span>CLAY_CONTAINER</span>(<span>CLAY_ID</span>(<span>&#34;ScrollInner&#34;</span>), <span>CLAY_LAYOUT</span>(.<span>sizing</span> <span>=</span> { .<span>width</span> <span>=</span> <span>CLAY_SIZING_GROW</span>(), .<span>height</span> <span>=</span> <span>CLAY_SIZING_FIXED</span>(<span>5000</span>) }), {});
});</pre></div>

<p dir="auto"><strong>CLAY_BORDER_CONFIG()</strong> is a macro used to create and store <code>Clay_BorderContainerElementConfig</code> structs, which are for configuring <a href="#clay_border_container">CLAY_BORDER_CONTAINER</a> elements.</p>
<p dir="auto"><strong>Struct Definition (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    Clay_Border left {
        float width;
        Clay_Color color {
            float r; float g; float b; float a;
        };
    };
    Clay_Border right {
        float width;
        Clay_Color color {
            float r; float g; float b; float a;
        };
    }
    Clay_Border top {
        float width;
        Clay_Color color {
            float r; float g; float b; float a;
        };
    };
    Clay_Border bottom {
        float width;
        Clay_Color color {
            float r; float g; float b; float a;
        };
    };
    Clay_Border betweenChildren {
        float width;
        Clay_Color color {
            float r; float g; float b; float a;
        };
    };
    Clay_CornerRadius cornerRadius {
        float topLeft;
        float topRight;
        float bottomLeft;
        float bottomRight;
    };
} Clay_BorderContainerElementConfig;"><pre><span>typedef</span> <span>struct</span>
{
    <span>Clay_Border</span> <span>left</span> {
        <span>float</span> <span>width</span>;
        <span>Clay_Color</span> <span>color</span> {
            <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
        };
    };
    <span>Clay_Border</span> <span>right</span> {
        <span>float</span> <span>width</span>;
        <span>Clay_Color</span> <span>color</span> {
            <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
        };
    }
    <span>Clay_Border</span> <span>top</span> {
        <span>float</span> <span>width</span>;
        <span>Clay_Color</span> <span>color</span> {
            <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
        };
    };
    <span>Clay_Border</span> <span>bottom</span> {
        <span>float</span> <span>width</span>;
        <span>Clay_Color</span> <span>color</span> {
            <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
        };
    };
    <span>Clay_Border</span> <span>betweenChildren</span> {
        <span>float</span> <span>width</span>;
        <span>Clay_Color</span> <span>color</span> {
            <span>float</span> <span>r</span>; <span>float</span> <span>g</span>; <span>float</span> <span>b</span>; <span>float</span> <span>a</span>;
        };
    };
    <span>Clay_CornerRadius</span> <span>cornerRadius</span> {
        <span>float</span> <span>topLeft</span>;
        <span>float</span> <span>topRight</span>;
        <span>float</span> <span>bottomLeft</span>;
        <span>float</span> <span>bottomRight</span>;
    };
} <span>Clay_BorderContainerElementConfig</span>;</pre></div>
<p dir="auto"><strong>Usage</strong></p>
<p dir="auto">As with all config macros, <code>CLAY_BORDER_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.left, .right, .top, .bottom</code></strong> - <code>Clay_Border</code></p>
<p dir="auto"><code>CLAY_BORDER_CONFIG(.left = { 2, COLOR_RED }, .right = { 4, COLOR_YELLOW } /* etc */)</code></p>
<p dir="auto">Indicates to the renderer that a border of <code>.color</code> should be draw at the specified edges of the bounding box, <strong>overlapping the box contents by <code>.width</code></strong>.</p>
<p dir="auto">This means that border configuration does not affect layout, as the width of the border doesn&#39;t contribute to the total container width or layout position. Border containers with zero padding will be drawn over the top of child elements.</p>
<hr/>
<p dir="auto"><strong><code>.betweenChildren</code></strong> - <code>Clay_Border</code></p>
<p dir="auto"><code>CLAY_BORDER_CONFIG(.betweenChildren = { 2, COLOR_RED })</code></p>
<p dir="auto">Configures the width and color of borders to be drawn between children. These borders will be vertical lines if the parent uses <code>.layoutDirection = CLAY_LEFT_TO_RIGHT</code> and horizontal lines if the parent uses <code>CLAY_TOP_TO_BOTTOM</code>. Unlike <code>.left, .top</code> etc, this option <strong>will generate additional rectangle render commands representing the borders between children.</strong> As a result, the renderer does not need to specifically implement rendering for these border elements.</p>
<hr/>
<p dir="auto"><strong><code>.cornerRadius</code></strong> - <code>float</code></p>
<p dir="auto"><code>CLAY_BORDER_CONFIG(.cornerRadius = 16)</code></p>
<p dir="auto">Defines the radius in pixels for the arc of border corners (<code>0</code> is square, <code>rectangle.width / 2</code> is circular). It is up to the renderer to decide how to interpolate between differing border widths and colors across shared corners.</p>
<p dir="auto">Note that the <code>CLAY_CORNER_RADIUS(radius)</code> function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. <code>CLAY_BORDER_CONFIG(.cornerRadius = CLAY_CORNER_RADIUS(10))</code></p>
<p dir="auto"><strong>Convenience Macros</strong></p>
<p dir="auto">There are some common cases for border configuration that are repetitive, i.e. specifying the same border around all four edges. Some convenience macros are provided for these cases:</p>
<ul dir="auto">
<li><code>CLAY_BORDER_CONFIG_OUTSIDE(.width = 2, .color = COLOR_RED)</code> - Shorthand for configuring all 4 outside borders at once.`</li>
<li><code>CLAY_BORDER_CONFIG_OUTSIDE_RADIUS(width, color, radius)</code> - Shorthand for configuring all 4 outside borders at once, with the provided <code>.cornerRadius</code>. Note this is a function-like macro and does not take <code>.member = value</code> syntax.</li>
<li><code>CLAY_BORDER_CONFIG_ALL(.width = 2, .color = COLOR_RED)</code> - Shorthand for configuring all 4 outside borders and <code>.betweenChildren</code> at once.</li>
<li><code>CLAY_BORDER_CONFIG_ALL_RADIUS(width, color, radius)</code> - Shorthand for configuring all 4 outside borders and <code>.betweenChildren</code> at once, with the provided <code>cornerRadius</code>. Note this is a function-like macro and does not take <code>.member = value</code> syntax.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">CLAY_CUSTOM_ELEMENT_CONFIG</h3><a id="user-content-clay_custom_element_config" aria-label="Permalink: CLAY_CUSTOM_ELEMENT_CONFIG" href="#clay_custom_element_config"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>CLAY_CUSTOM_ELEMENT_CONFIG()</strong> is a macro used to create and store <code>Clay_CustomElementConfig</code> structs, which are for configuring <a href="https://www.nathanael0x4c.com/nicbarker/clay/blob/main">CLAY_CUSTOM_ELEMENT</a> elements.</p>
<p dir="auto"><strong>Struct Definition (Pseudocode)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    #ifndef CLAY_EXTEND_CONFIG_CUSTOM
        void * customData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_CUSTOM is specified
    #else CLAY_EXTEND_CONFIG_CUSTOM
        // Contents of CLAY_EXTEND_CONFIG_CUSTOM will be pasted here
    #endif
} Clay_CustomElementConfig;"><pre><span>typedef</span> <span>struct</span>
{
    <span>#ifndef</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span>
        <span>void</span> <span>*</span> <span>customData</span>; <span>// Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_CUSTOM is specified</span>
    <span>#else</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span>
        <span>// Contents of CLAY_EXTEND_CONFIG_CUSTOM will be pasted here</span>
    <span>#endif</span>
} <span>Clay_CustomElementConfig</span>;</pre></div>
<p dir="auto">As with all config macros, <code>CLAY_CUSTOM_ELEMENT_CONFIG()</code> accepts designated initializer syntax and provides default values for any unspecified struct members.</p>
<p dir="auto"><strong>Extension</strong></p>
<p dir="auto">The underlying <code>Clay_ImageCustomConfig</code> can be extended with new members by using:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define CLAY_EXTEND_CONFIG_CUSTOM float newField;
#include &#34;clay.h&#34; // Define your extension before including clay.h"><pre><span>#define</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span> float newField;
<span>#include</span> <span>&#34;clay.h&#34;</span> <span>// Define your extension before including clay.h</span></pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><code>.customData</code> - <code>void *</code></p>
<p dir="auto"><code>CLAY_CUSTOM_CONFIG(.customData = &amp;myCustomData)</code></p>
<p dir="auto"><code>.customData</code> is a generic void pointer that can be used to pass through custom data to the renderer. <strong>Note:</strong> this field is generally not recommended for usage due to the lack of type safety, see <code>#define CLAY_EXTEND_CONFIG_CUSTOM</code> in <a href="https://www.nathanael0x4c.com/nicbarker/clay/blob/main">Preprocessor Directives</a> for an alternative.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data
#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;
// Extensions need to happen _before_ the clay include
#include &#34;clay.h&#34;

// A rough example of how you could handle laying out 3d models in your UI
typedef struct t_CustomElementData {
    CustomElementType type;
    union {
        Model model;
        Video video;
        // ...
    };
} CustomElementData;

Model myModel = Load3DModel(filePath);
CustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }
// ...
CLAY_CONTAINER(id, style, {
    // This config is type safe and contains the CustomElementData struct
    CLAY_CUSTOM_ELEMENT(id, style, CLAY_CUSTOM_ELEMENT_CONFIG(.customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }))
});

// Later during your rendering
switch (renderCommand-&gt;commandType) {
    // ...
    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {
        // Your extended struct is passed through
        CustomElementData *data = renderCommand-&gt;elementConfig.customElementConfig-&gt;customData;
        if (!customElement) continue;
        switch (customElement-&gt;type) {
            case CUSTOM_ELEMENT_TYPE_MODEL: {
                // Render your 3d model here
                break;
            }
            case CUSTOM_ELEMENT_TYPE_VIDEO: {
                // Render your video here
                break;
            }
            // ...
        }
        break;
    }
}"><pre><span>// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data</span>
<span>#define</span> <span>CLAY_EXTEND_CONFIG_CUSTOM</span> struct t_CustomElementData customData;
<span>// Extensions need to happen _before_ the clay include</span>
<span>#include</span> <span>&#34;clay.h&#34;</span>

<span>// A rough example of how you could handle laying out 3d models in your UI</span>
<span>typedef</span> <span>struct</span> <span>t_CustomElementData</span> {
    <span>CustomElementType</span> <span>type</span>;
    <span>union</span> {
        <span>Model</span> <span>model</span>;
        <span>Video</span> <span>video</span>;
        <span>// ...</span>
    };
} <span>CustomElementData</span>;

<span>Model</span> <span>myModel</span> <span>=</span> <span>Load3DModel</span>(<span>filePath</span>);
<span>CustomElement</span> <span>modelElement</span> <span>=</span> (<span>CustomElement</span>) { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }
<span>// ...</span>
<span>CLAY_CONTAINER</span>(<span>id</span>, <span>style</span>, {
    <span>// This config is type safe and contains the CustomElementData struct</span>
    <span>CLAY_CUSTOM_ELEMENT</span>(<span>id</span>, <span>style</span>, <span>CLAY_CUSTOM_ELEMENT_CONFIG</span>(.<span>customData</span> <span>=</span> { .<span>type</span> <span>=</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>, .<span>model</span> <span>=</span> <span>myModel</span> }))
});

<span>// Later during your rendering</span>
<span>switch</span> (<span>renderCommand</span><span>-&gt;</span><span>commandType</span>) {
    <span>// ...</span>
    <span>case</span> <span>CLAY_RENDER_COMMAND_TYPE_CUSTOM</span>: {
        <span>// Your extended struct is passed through</span>
        <span>CustomElementData</span> <span>*</span><span>data</span> <span>=</span> <span>renderCommand</span><span>-&gt;</span><span>elementConfig</span>.<span>customElementConfig</span><span>-&gt;</span><span>customData</span>;
        <span>if</span> (!<span>customElement</span>) <span>continue</span>;
        <span>switch</span> (<span>customElement</span><span>-&gt;</span><span>type</span>) {
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_MODEL</span>: {
                <span>// Render your 3d model here</span>
                <span>break</span>;
            }
            <span>case</span> <span>CUSTOM_ELEMENT_TYPE_VIDEO</span>: {
                <span>// Render your video here</span>
                <span>break</span>;
            }
            <span>// ...</span>
        }
        <span>break</span>;
    }
}</pre></div>


<p dir="auto"><code>uint32_t CLAY_ID(char *label)</code></p>
<p dir="auto">Generates a <code>uint32_t</code> string hash from the provided <code>char *label</code>. Used both to generate ids when defining element macros, as well as for referencing ids later when using utility functions such as <a href="#clay-pointerover">Clay_PointerOver</a></p>

<p dir="auto"><code>uint32_t CLAY_IDI(char *label, int index)</code></p>
<p dir="auto">Generates a <code>uint32_t</code> string hash from the provided <code>char *label</code>, combined with the <code>int index</code>. Used for generating ids for sequential elements (such as in a <code>for</code> loop) without having to construct dynamic strings at runtime.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Data Structures &amp; Definitions</h2><a id="user-content-data-structures--definitions" aria-label="Permalink: Data Structures &amp; Definitions" href="#data-structures--definitions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
	uint32_t capacity;
	uint32_t length;
	Clay_RenderCommand *internalArray;
} Clay_RenderCommandArray;"><pre><span>typedef</span> <span>struct</span>
{
	<span>uint32_t</span> <span>capacity</span>;
	<span>uint32_t</span> <span>length</span>;
	<span>Clay_RenderCommand</span> <span>*</span><span>internalArray</span>;
} <span>Clay_RenderCommandArray</span>;</pre></div>
<p dir="auto">Returned by <a href="#clay_endlayout">Clay_EndLayout</a>, this array contains the <a href="#clay_rendercommand">Clay_RenderCommand</a>s representing the calculated layout.</p>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.capacity</code></strong> - <code>uint32_t</code></p>
<p dir="auto">Represents the total capacity of the allocated memory in <code>.internalArray</code>.</p>
<hr/>
<p dir="auto"><strong><code>.length</code></strong> - <code>uint32_t</code></p>
<p dir="auto">Represents the total number of <code>Clay_RenderCommand</code> elements stored consecutively at the address <code>.internalArray</code>.</p>
<hr/>
<p dir="auto"><strong><code>.internalArray</code></strong> - <code>Clay_RenderCommand</code></p>
<p dir="auto">An array of <a href="#clay_rendercommand">Clay_RenderCommand</a>s representing the calculated layout. If there was at least one render command, this array will contain elements from <code>.internalArray[0]</code> to <code>.internalArray[.length - 1]</code>.</p>

<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    Clay_Rectangle boundingBox;
    Clay_ElementConfigUnion config;
    Clay_String text;
    uint32_t id;
    Clay_RenderCommandType commandType;
} Clay_RenderCommand;"><pre><span>typedef</span> <span>struct</span>
{
    <span>Clay_Rectangle</span> <span>boundingBox</span>;
    <span>Clay_ElementConfigUnion</span> <span>config</span>;
    <span>Clay_String</span> <span>text</span>;
    <span>uint32_t</span> <span>id</span>;
    <span>Clay_RenderCommandType</span> <span>commandType</span>;
} <span>Clay_RenderCommand</span>;</pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.commandType</code></strong> - <code>Clay_RenderCommandType</code></p>
<p dir="auto">An enum indicating how this render command should be handled. Possible values include:</p>
<ul dir="auto">
<li><code>CLAY_RENDER_COMMAND_TYPE_NONE</code> - Should be ignored by the renderer, and never emitted by clay under normal conditions.</li>
<li><code>CLAY_RENDER_COMMAND_TYPE_RECTANGLE</code> - A rectangle should be drawn, configured with <code>.config.rectangleElementConfig</code></li>
<li><code>CLAY_RENDER_COMMAND_TYPE_BORDER</code> - A border should be drawn, configured with <code>.config.borderElementConfig</code></li>
<li><code>CLAY_RENDER_COMMAND_TYPE_TEXT</code> - Text should be drawn, configured with <code>.config.textElementConfig</code></li>
<li><code>CLAY_RENDER_COMMAND_TYPE_IMAGE</code> - An image should be drawn, configured with <code>.config.imageElementConfig</code></li>
<li><code>CLAY_RENDER_COMMAND_TYPE_SCISSOR_START</code> - Named after <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml" rel="nofollow">glScissor</a>, this indicates that the renderer should begin culling any subsequent pixels that are drawn outside the <code>.boundingBox</code> of this render command.</li>
<li><code>CLAY_RENDER_COMMAND_TYPE_SCISSOR_END</code> - Only ever appears after a matching <code>CLAY_RENDER_COMMAND_TYPE_SCISSOR_START</code> command, and indicates that the scissor has ended.</li>
<li><code>CLAY_RENDER_COMMAND_TYPE_CUSTOM</code> - A custom render command controlled by the user, configured with <code>.config.customElementConfig</code></li>
</ul>
<hr/>
<p dir="auto"><strong><code>.boundingBox</code></strong> - <code>Clay_Rectangle</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    float x, y, width, height;
} Clay_Rectangle;"><pre><span>typedef</span> <span>struct</span> {
    <span>float</span> <span>x</span>, <span>y</span>, <span>width</span>, <span>height</span>;
} <span>Clay_Rectangle</span>;</pre></div>
<p dir="auto">A rectangle representing the bounding box of this render command, with <code>.x</code> and <code>.y</code> representing the top left corner of the element.</p>
<hr/>
<p dir="auto"><strong><code>.config</code></strong> - <code>Clay_ElementConfigUnion</code></p>
<p dir="auto">A C union containing various pointers to config data, with the type dependent on <code>.commandType</code>. Possible values include:</p>
<ul dir="auto">
<li><code>config.rectangleElementConfig</code> - Used when <code>.commandType == CLAY_RENDER_COMMAND_TYPE_RECTANGLE</code>. See <a href="#clay_rectangle_config">CLAY_RECTANGLE_CONFIG</a> for details.</li>
<li><code>config.textElementConfig</code> - Used when <code>.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT</code>. See <a href="#clay_text_config">CLAY_TEXT_CONFIG</a> for details.</li>
<li><code>config.imageElementConfig</code> - Used when <code>.commandType == CLAY_RENDER_COMMAND_TYPE_IMAGE</code>. See <a href="#clay_image_config">CLAY_IMAGE_CONFIG</a> for details.</li>
<li><code>config.borderElementConfig</code> - Used when <code>.commandType == CLAY_RENDER_COMMAND_TYPE_BORDER</code>. See <a href="#clay_border_config">CLAY_BORDER_CONFIG</a> for details.</li>
<li><code>config.customElementConfig</code> - Used when <code>.commandType == CLAY_RENDER_COMMAND_TYPE_CUSTOM</code>. See <a href="#clay_custom_config">CLAY_CUSTOM_CONFIG</a> for details.</li>
<li><code>config.floatingElementConfig</code> - Not used and will always be NULL.</li>
<li><code>config.scrollElementConfig</code> - Not used and will always be NULL.</li>
</ul>
<hr/>
<p dir="auto"><strong><code>.text</code></strong> - <code>Clay_String</code></p>
<p dir="auto">Only used if <code>.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT</code>. A <code>Clay_String</code> containing a string slice (char *chars, int length) representing text to be rendered. <strong>Note: This string is not guaranteed to be null terminated.</strong> Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support <strong>ptr, length</strong> style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.</p>
<hr/>
<p dir="auto"><strong><code>.id</code></strong> - <code>uint32_t</code></p>
<p dir="auto">The id that was originally used with the element macro that created this render command. See <a href="#clay_id">CLAY_ID</a> for details.</p>

<div dir="auto" data-snippet-clipboard-copy-content="typedef struct
{
    Clay_Vector2 *scrollPosition;
    Clay_Dimensions scrollContainerDimensions;
    Clay_Dimensions contentDimensions;
    Clay_ScrollContainerElementConfig config;
    bool found;
} Clay_ScrollContainerData;"><pre><span>typedef</span> <span>struct</span>
{
    <span>Clay_Vector2</span> <span>*</span><span>scrollPosition</span>;
    <span>Clay_Dimensions</span> <span>scrollContainerDimensions</span>;
    <span>Clay_Dimensions</span> <span>contentDimensions</span>;
    <span>Clay_ScrollContainerElementConfig</span> <span>config</span>;
    <span>bool</span> <span>found</span>;
} <span>Clay_ScrollContainerData</span>;</pre></div>
<p dir="auto"><strong>Fields</strong></p>
<p dir="auto"><strong><code>.scrollPosition</code></strong> - <code>Clay_Vector2 *</code></p>
<p dir="auto">A pointer to the internal scroll position of this scroll container. Mutating it will result in elements inside the scroll container shifting up / down (<code>.y</code>) or left / right (<code>.x</code>).</p>
<hr/>
<p dir="auto"><strong><code>.scrollContainerDimensions</code></strong> - <code>Clay_Dimensions</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    float width, height;
} Clay_Dimensions;"><pre><span>typedef</span> <span>struct</span> {
    <span>float</span> <span>width</span>, <span>height</span>;
} <span>Clay_Dimensions</span>;</pre></div>
<p dir="auto">Dimensions representing the outer width and height of the scroll container itself.</p>
<hr/>
<p dir="auto"><strong><code>.contentDimensions</code></strong> - <code>Clay_Dimensions</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    float width, height;
} Clay_Dimensions;"><pre><span>typedef</span> <span>struct</span> {
    <span>float</span> <span>width</span>, <span>height</span>;
} <span>Clay_Dimensions</span>;</pre></div>
<p dir="auto">Dimensions representing the inner width and height of the content <em>inside</em> the scroll container. Scrolling is only possible when the <code>contentDimensions</code> are larger in at least one dimension than the <code>scrollContainerDimensions</code>.</p>
<hr/>
<p dir="auto"><strong><code>.config</code></strong> - <code>Clay_ScrollContainerElementConfig</code></p>
<p dir="auto">The <a href="#clay_scroll_config">Clay_ScrollContainerElementConfig</a> for the matching scroll container element.</p>
</article></div></div>
  </body>
</html>
