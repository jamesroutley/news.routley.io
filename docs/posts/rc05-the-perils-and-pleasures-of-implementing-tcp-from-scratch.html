<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stace.dev/rc-05-tcp-in-rust/">Original</a>
    <h1>RC05: The perils and pleasures of implementing TCP from scratch</h1>
    
    <div id="readability-page-1" class="page"><div id="___gatsby"><div tabindex="-1" id="gatsby-focus-wrapper"><div data-is-root-path="false"><main><article itemscope="" itemtype="http://schema.org/Article"><header><p>December 18, 2023</p></header><section><p>
I&#39;m attending the Fall 2 batch at <a href="https://www.recurse.com/scout/click?t=4b09801ab494151291278015fdbdd197">Recurse Center</a>! Posts in this series cover things I&#39;m working on or find interesting during my time here.
</p>
<p>One of my main goals for my time at Recurse is to learn Rust. Since I have  already <a href="https://stace.dev/writing-a-dns-resolver/">implemented a DNS resolver in Rust</a>, I thought it might be fun to dive into the next <a href="https://en.wikipedia.org/wiki/OSI_model">layer</a>. And so TCP, being a more complex protocol than UDP, seemed a natural next step to explore. I‚Äôve found learning a language through a concrete project much more fun (for me), and it forces me to use a large chunk of the language features together. I was also lucky in that TCP as a problem space seemed fit for Rust‚Äôs focus on systems programming.</p>
<p>I‚Äôve previously read <a href="https://doc.rust-lang.org/book/">The Rust Book</a>, but even after reading all of the chapters and coding out the exercises, I found that I didn‚Äôt quite grasp a sizeable chunk of Rust‚Äôs concepts and features, such as ownership and traits. Or rather I would understand it at the point of reading, but then if a week later I was asked to explain ownership, all I‚Äôd know is that Rust has this concept of ownerships‚Ä¶ This still weak understanding of Rust‚Äôs more unique features partly motivated my writing of a toy DNS resolver in Rust. Although that did help improve my Rust afterwards, I still felt like I was using Rust as a tourist and not in any idiomatic sense.</p>
<p>If you‚Äôre wondering why (I chose) Rust? The hype. I‚Äôve heard good things about it from many different places. And, it‚Äôs a systems programming language that‚Äôs strongly typed. A language that would seem to let me explore OS internals without losing my sanity to simple bugs. Additionally, I‚Äôve also heard a lot of good things about Rust‚Äôs community, which made me feel excited and comfortable dedicating time into learning it.</p>
<h4>Quick aside: how TCP works</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a> is a transport layer protocol that guarantees a reliable and in-order transfer of data over the network. For example, this webpage is delivered over HTTPS, which runs on top of TCP.</p>
<h4>Scoping out a small enough TCP</h4>
<p>TCP can be a complex protocol. It was, according to <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Historical_origin">Wikipedia</a>, introduced in 1974. As the adoption and use of the Internet has changed dramatically since then, the protocol has evolved over time. The sheer number of IETF RFCs published to describe, update, and improve TCP and its various additional features reflects this change. The Wikipedia article for TCP lists about 30 RFCs in its <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Bibliography">bibliography</a>.<sup id="fnref-1"><a href="#fn-1">1</a></sup> A few are for IP (as in IP addresses), but mostly they‚Äôre for TCP.</p>
<p>Since I wanted to keep my project small to start with, my main aim was to implement a ‚Äúgood enough‚Äù‚Äîsimple and skeletal‚ÄîTCP client that‚Äôll allow me to retrieve web pages over the internet. And skipping features like congestion control and window scaling that weren‚Äôt essential to this goal. To that end, I used RFC793‚Äîthe 1981 document that was the standard until its obsoletion last year‚Äîas the reference for my implementation.<sup id="fnref-2"><a href="#fn-2">2</a></sup></p>
<h2>Looking at Rust‚Äôs <code>std::net</code> for inspiration</h2>
<p>I was new to Rust and its patterns, and so I first based off the interface of my TCP implementation on Rust‚Äôs <code>TcpStream</code> with a limited subset of functions. The goal was to be able swap out the standard library‚Äôs implementation with my own implementation of <code>TcpStream</code> and produce the same results when calling HTTP GET on a webpage.</p>
<div data-language="rust"><pre><code><span>use</span> <span>std<span>::</span></span><span>{</span>
    <span>io<span>::</span></span><span>{</span><span>Read</span><span>,</span> <span>Write</span><span>}</span><span>,</span>
    <span>net<span>::</span></span><span>TcpStream</span><span>,</span>
    <span>str</span><span>,</span>
<span>}</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>-&gt;</span> <span>std<span>::</span>io<span>::</span></span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>mut</span> stream <span>=</span> <span>TcpStream</span><span>::</span><span>connect</span><span>(</span><span>&#34;example.com:80&#34;</span><span>)</span><span>?</span><span>;</span>

    <span>println!</span><span>(</span><span>&#34;* Connected to {}&#34;</span><span>,</span> stream<span>.</span><span>peer_addr</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>let</span> <span>mut</span> response <span>=</span> <span>[</span><span>0</span><span>;</span> <span>2048</span><span>]</span><span>;</span>

    <span>let</span> _ <span>=</span> stream<span>.</span><span>write</span><span>(</span><span>b&#34;GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#34;</span><span>)</span><span>;</span>
    <span>let</span> _ <span>=</span> stream<span>.</span><span>read</span><span>(</span><span>&amp;</span><span>mut</span> response<span>)</span><span>;</span>

    <span>if</span> <span>let</span> <span>[</span>headers<span>,</span> content<span>]</span> <span>=</span> <span>&amp;</span><span>(</span><span>str</span><span>::</span><span>from_utf8</span><span>(</span><span>&amp;</span>response<span>)</span>
        <span>.</span><span>unwrap</span><span>(</span><span>)</span>
        <span>.</span><span>split</span><span>(</span><span>&#34;\r\n\r\n&#34;</span><span>)</span>
        <span>.</span><span>take</span><span>(</span><span>2</span><span>)</span>
        <span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>&amp;</span><span>str</span><span>&gt;&gt;</span><span>(</span><span>)</span><span>)</span><span>[</span><span>..</span><span>]</span>
    <span>{</span>
        <span>for</span> h <span>in</span> headers<span>.</span><span>split</span><span>(</span><span>&#34;\r\n&#34;</span><span>)</span> <span>{</span>
            <span>println!</span><span>(</span><span>&#34;&lt; {}&#34;</span><span>,</span> h<span>)</span><span>;</span>
        <span>}</span>
        <span>println!</span><span>(</span><span>&#34;&lt;&#34;</span><span>)</span><span>;</span>
        <span>println!</span><span>(</span><span>&#34;{} &#34;</span><span>,</span> content<span>)</span><span>;</span>
    <span>}</span>

    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span></code></pre></div>
<p>A HTTP GET request using Rust&#39;s <code>std::net::TcpStream</code>.</p>
<p>But before I could get started on replacing <code>std::net</code>‚Äôs <code>TcpStream</code>, I had to figure out how to connect my implementation to the internet. How would I be able to send and receive packets with other servers from the Rust program?</p>
<h2>An unexpected <a href="https://en.wikipedia.org/wiki/Interrupt">trap</a>? (no pun intended)</h2>
<p>I didn‚Äôt expect it at the beginning, but one of the main difficulties with this project hasn‚Äôt so much been understanding and implementing TCP. That does take some time and is not easy to do, but more difficult, at least for me, was trying to figure out how to integrate this custom TCP/IP stack that I have with the OS‚Äô network stack to access the internet.</p>
<p>One of the first rabbit holes that I went into was trying to use <a href="https://man7.org/linux/man-pages/man7/raw.7.html">raw sockets</a> to send and receive my TCP packets. Unbeknownst to me then, this proved to be quite a fool‚Äôs errand, at least on macOS because BSD sockets doesn‚Äôt allow for the reading of TCP packets. I wrote about that experience <a href="https://stace.dev/rc-02-debugging-macos-raw-sockets/">here</a>. Chastised, I then went to peek into how another implementing TCP guide approached this initial setup. The guide used a TUN device on a Linux VM. I was still, for reasons unknown to me now (misplaced pride? na√Øvet√©?), determined to make my TCP implementation work without having to install a VM. Spoiler alert: I eventually did. I also gave away a week before that trying to figure out how to install and use a TUN device on macOS.</p>
<p>After deciding to use a VM and get unstuck, I next had to figure out how to use the TUN device. I wanted to understand what the associated system calls that I saw in the examples were doing, especially <code>ioctl</code>. And I encountered rather cryptic errors for <code>ioctl</code> with the raw pointers that I passed in, which I suspect had to do with Rust‚Äôs memory representation of its byte slices. In any case, although I wanted to better understand how this system call worked, it‚Äôs <a href="https://lwn.net/Articles/844875/">not a system call that‚Äôs known to be easily understood</a>, and after a few days hitting diminishing returns, I decided that I should really move on to actually looking at TCP instead of trying to read Linux kernel source code.</p>
<p>Once I figured out how to successfully send a SYN packet and read the expected SYN ACK response through a TUN device using my Rust program, I was midway through my 12 week batch. I had thought that I‚Äôd be finished with the project by now (famous last words), but at least I could now start focusing on understanding and implementing TCP proper.</p>
<h2>Translating RFC793 into Rust code</h2>
<p>It turns out that reading the IETF RFCs wasn‚Äôt as scary as I expected. For me they were illuminating reads and great references for the moments when I was unsure of how to proceed with my implementation. I suppose this might be obvious in retrospect, considering its purpose. RFC793 gave detailed explanations on how to manage the TCP window, the different cases in which a connection could be established or closed, which made translating the spec into code less ambiguous than I expected. There was still the question of how I wanted do it in Rust, for example how would I structure the code and which traits might I want to consider using. For the most parts, I found that I could at least code out a basic working implementation.</p>
<h2>When in doubt, code<sup id="fnref-3"><a href="#fn-3">3</a></sup></h2>
<p>I used to be rather particular with commits. A (probably) irrational habit. I would get stuck trying to seek a perfect implementation on the first cut, but over time I let myself be more open to making imperfect commits, or more specifically, commits that reflected an imperfect state, as long as the code compiled. I wanted my development to follow a logical linear narrative, but when writing a program‚Äîespecially for the first time‚Äîit often follows a haphazard sketch. In any case, letting myself just figure out how to get something done, coding it out, and saving those changes as checkpoints were much more important than maintaining a ‚Äúclean‚Äù commit log.</p>
<blockquote>
<p>Make an intentionally bad or joke version of what you want to do! Like an anti-prototype. A minimum <strong>un</strong>viable version. It will probably be fun, you‚Äôll be defining what you¬†<em>do</em>¬†want to do more clearly, and fixing something is often more motivating than a blank screen.</p>
</blockquote>
<p>Sage advice from another Recurser.</p>
<h2>Some other fun things I learnt</h2>
<ul>
<li><code>tcpdump</code> and <code>strace</code> were invaluable for me when debugging my code. The former allowed me to understand what packets were being sent and received, and the latter to check the arguments passed into system calls. There was one instance where I passed in the wrong slice of bytes when calculating the TCP checksum and I learnt to use <code>strace</code>‚Äôs <code>-e write=3</code> to print out the hexdump of the data passed to <code>write</code>. Learning about this (probably) saved me hours of debugging.</li>
<li>While trying to read and check TCP packets in a loop, I encountered a mutable borrow error that I didn‚Äôt quite understand and learnt about <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius</a>. It was an unexpected limitation in Rust‚Äôs borrow checker which made for a fun learning experience and helped reinforce my understanding of the rules around mutable borrows.</li>
<li>During my batch, I also worked on the <a href="http://cryptopals.com">cryptopals challenges</a> in Rust and participated in the <a href="https://rust-for-rustaceans.com/">Rust for Rustaceans</a> book club. Both were unplanned before I joined the batch, but they turned out to be very synergistic with this project. Using Rust for a similar, but different problem domain helped strengthen my understanding of Rust. Meanwhile, reading Rust for Rustaceans provided inspiration on what features of Rust might be useful. For example, I learnt about the typestate pattern in Rust from it and this turned out to be <a href="https://stace.dev/rc-04-typechecking-tcp-states-in-rust/">perfect for my TCP implementation</a>.</li>
</ul>
<h2>What I might have done differently</h2>
<h3>Use a VM from the start</h3>
<p>I‚Äôd be more open to using a VM from the beginning because it would encourage me to be less afraid of breaking things. This was the main reason why I eventually went ahead to install a VM once I realised that I didn‚Äôt want to risk breaking my computer‚Äôs network stack without knowing how to fix it. And there was also much more documented references on how to work with TUN devices in Linux than BSD or macOS, which reduced the chances of encountering unexpected and hard to debug differences in API behaviour.</p>
<h3>Don‚Äôt be afraid to refer to existing tutorials as needed</h3>
<p>I didn‚Äôt want to just read a guide on how to implement TCP because I wanted to <a href="https://www.recurse.com/self-directives#work-at-the-edge">work at the edge of my abilities</a>, and give myself the opportunity to scope problems, encounter dead ends, and figure things out along the way. It helped that I was able to dedicate an extended period of time for this in a helpful community. In retrospect, I think that this was a good but perhaps misguided idea. In the end, I did consult a number of different implementations (toy and production-grade ones) and tutorials. They offered a rich example of different approaches and considerations to the problem. They also offered concrete examples of how a scoped down or real world TCP implementation could be done. Additionally, reading them introduced me to RFCs that I didn‚Äôt know about, which enriched my knowledge of the protocol. I also used selected tutorial examples as references when working with the <code>ioctl</code>, <code>read</code>, and <code>write</code> system calls since those APIs deal with bytes and have error messages that can be particularly difficult to debug.</p>
<h2>What‚Äôs next</h2>
<p>TCP as a problem space has turned out to be a surprisingly fun and fruitful domain to experiment and try out the different Rust concepts that I‚Äôve been learning about. In implementing TCP, I had a chance to use a myriad of Rust features and also learn about network programming at the same time. Additionally, working on this within the Recurse community has been an invaluable and fun experience. It‚Äôs less demotivating to know that you‚Äôre not alone and can ask for help or pair when I‚Äôm seriously stuck.</p>
<p>Now that I‚Äôve come to the end of my Recurse batch, I‚Äôm going to take a break from working on this. In my free time, I plan to next explore integrating async to handle multiple connection and also explore how security and privacy gets implemented for TCP, which seems like it‚Äôd be a nice tie-in to the cryptopals and cryptography stuff I‚Äôve been working on.</p>
<p>Thanks for making it this far! If you‚Äôre interested in checking out the code, it‚Äôs on <a href="https://github.com/staceytay/tcp">GitHub</a>. Also if you‚Äôve any questions, thoughts or comments, <a href="https://stace.dev/cdn-cgi/l/email-protection#214c446152554042440f454457">I‚Äôd love to hear from you</a>.</p>
</section><hr/><div><div data-gatsby-image-wrapper=""><p><img aria-hidden="true" data-placeholder-image="" decoding="async" src="data:image/jpeg;base64,/9j/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUGBgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYHCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAYHCAX/xAAYAQADAQEAAAAAAAAAAAAAAAADBQcEBv/aAAwDAQACEAMQAAABz/pqi7cX766cgIcBkhQ+fkonr/8A/8QAHBAAAQUBAQEAAAAAAAAAAAAABQECAwQGBxQW/9oACAEBAAEFAg1lfcCecqP7K5supBBiGTZnNkuqXpyxR6gtqCpF+AtzUzHT68f1f//EACARAAIBAQkAAAAAAAAAAAAAAAECAAMEERITIjFBYrH/2gAIAQMBAT8BfIqUWfFqXiU2YoJbCRcew9EG0//EACARAAICAQMFAAAAAAAAAAAAAAECAAMRBAUxEhMhobL/2gAIAQIBAT8BtpsCYavwwyDj3FRa16Zt6g6bB47Z+TBxP//EACgQAAIBBAIAAwkAAAAAAAAAAAECAwAEESEFEhMxYRQVMkFRcYGRof/aAAgBAQAGPwK9mSJ3bwm6oh8yZBr+1DxXK3fES213EUVbG5aR7ZwNdj5bxj7ioFijwI+LgTH016Vdc/e+EI47fB6nxHzkH4Rv1ocZZ8m0sjnuFMysnVd5RcCj7OxKm3Q9m+dXXIu6xs91IesIwo3jX6riruEjPvNVIxoiTqGH5zUkY0scSqgXWBX/xAAeEAEBAAICAgMAAAAAAAAAAAABEQAhMVFBYXGBof/aAAgBAQABPyFvR1p0Xyx+4tQF7OGBFxDwZa4VrsOn2zSe0K0njcbPGnE9LRyERDbWt2nbkQ3dOY1Kusr5eSWYL0PeCgPWQSQSw827Z1AmjWf/2gAMAwEAAgADAAAAECTnv//EABsRAQADAAMBAAAAAAAAAAAAAAEAESExUXGB/9oACAEDAQE/ELSOB66q+VxOT7EJ6JQDrpBIJ//EABsRAQADAQADAAAAAAAAAAAAAAEAESExQVFx/9oACAECAQE/ELFVlheHHoOjx28IQDzJVoRj4+EJWf/EABsQAQEAAwEBAQAAAAAAAAAAAAERACExQVGB/9oACAEBAAE/EDnDR6h48pLY8MmCgL4AUyjaNytzQXxG31oUT3f3eC/QC1+RUOXKnTKeycCSNhHusBwFUKal9SSzfn24xKRuWBSHYqnarkoQL3lqA7W83rJhuNkgCD96+5//2Q==" alt=""/></p><picture><source type="image/webp" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/541c0/profile-pic.webp 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/57ec1/profile-pic.webp 128w" sizes="64px"/><img data-gatsby-image-ssr="" layout="fixed" data-main-image="" sizes="64px" decoding="async" loading="lazy" data-src="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/c7570/profile-pic.jpg 128w" alt="Stacey Tay"/></picture></div><p>Hi! I‚Äôm Stacey. Welcome to my<!-- --> <a href="https://stace.dev/">blog</a>. I‚Äôm a software engineer with an interest in programming languages and web performance. I also like making üçµ, reading fiction, and discovering random<!-- --> <a href="https://www.quora.com/What-should-everybody-know-about-tea-in-terms-of-health-benefits-or-detriments-carbon-footprint-quality-and-how-my-choice-of-tea-reflects-on-me/answer/Stacey-Tay-1">word origins</a>.</p></div></article></main></div></div></div></div>
  </body>
</html>
