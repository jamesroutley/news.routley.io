<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lorenstew.art/blog/10-kanban-boards/">Original</a>
    <h1>I built the same app 10 times: Evaluating frameworks for mobile performance</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-dmqsi53g=""> <div data-astro-cid-dmqsi53g="">  <div data-astro-cid-dmqsi53g="">  <article data-astro-cid-7jjqptxk="">  <div data-astro-cid-7jjqptxk=""> 
<h2 id="why-i-built-this">Why I Built This</h2>
<p>My team needed to choose a framework for an upcoming app. The requirements were clear: it had to work well on mobile. Not “acceptable on mobile,” but actually good. We’re building tools for real estate agents working in the field: open houses, parking lots, spotty cellular signals. When someone’s standing in front of a potential buyer trying to look professional, a slow-loading app isn’t just an annoyance. It’s a liability.</p>
<p>I started with what seemed like a reasonable comparison: Next.js (our current default when a framework is required) versus SolidStart and SvelteKit (alternatives I’d heard good things about). Three frameworks, should be straightforward. But when I built the first implementations and started measuring, something became clear: the issues I was seeing with Next.js weren’t specific to Next.js. They were fundamental to React’s architecture. I wondered whether the other dominant frameworks (Angular, Vue) might have similar mobile web performance limitations.</p>
<p>That question changed the scope. If I was going to make a real recommendation for the team, I needed to test all the major meta-frameworks and understand the full landscape of alternatives. Three frameworks became ten. What started as a practical evaluation for work turned into something bigger: a semi-comprehensive look at what’s actually possible for mobile web performance in 2025.</p>
<p>This post shares what I discovered. The measurements are real, the kanban apps are identical (same features, same database, same styling), and the differences are dramatic. Marko delivers 12.6 kB raw (6.8 kB compressed). Next.js ships 497.8 kB raw (154.5 kB compressed). That’s a 39x difference in raw size that translates to real seconds on cellular networks.</p>
<p>If you’re interested in the theoretical implications of why framework diversity matters, I wrote about that in <a href="https://www.lorenstew.art/blog/react-won-by-default">React Won by Default</a>. This post focuses on the data: what I built, what I measured, and what it means for teams making similar decisions.</p>
<hr/>
<h2 id="key-takeaways-tldr">Key Takeaways (TL;DR)</h2>
<blockquote>
<p><strong>Next-Gen Frameworks Deliver Instant Performance:</strong> Marko (39ms), SolidStart (35ms), SvelteKit (38ms), and Nuxt (38ms) all achieve essentially instant First Contentful Paint in the 35-39ms range. This is 12 to 13 times faster than Next.js at 467ms. The 4ms spread between fastest and slowest is statistically measurable but perceptually meaningless to users. All next-gen frameworks feel instant. The real performance story isn’t splitting hairs over 3ms differences, it’s the massive gap between next-gen and React/Angular.</p>
<p><strong>Bundle Size Champion: Marko</strong> delivers 88.8 kB raw (28.8 kB compressed) for the board page, 6.36 times smaller than Next.js’s 564.9 kB raw (176.3 kB compressed). This is 44% smaller than the next closest competitor (SolidStart at 41.5 kB compressed), making Marko the clear choice when bundle size is the absolute top priority.</p>
<p><strong>Resumability Pattern: Qwik City</strong> at 114.8 kB raw (58.4 kB compressed) eliminates traditional hydration via resumability, yielding instant interactivity for larger client-side apps. Different architectural approach that solves different problems.</p>
<p><strong>Nuxt Proves Established Frameworks Can Compete:</strong> At 224.9 kB raw (72.3 kB compressed) with 38ms FCP, Nuxt demonstrates that established “big three” frameworks can achieve next-gen performance when properly configured. Vue’s architecture allows competitive mobile web performance while maintaining a mature ecosystem. React and Angular show no path to similar results.</p>
<p><strong>Critical scaling difference</strong>: MPA frameworks (Marko, HTMX) ship minimal JavaScript per page, staying lean as you add features. SPA frameworks ship routing and framework runtime upfront, with higher baselines even using code splitting. Marko delivers around 12.6 to 88.8 kB raw regardless of total routes. SPAs maintain 85.9 to 666.5 kB raw baselines plus route chunks.</p>
</blockquote>
<p><strong>The key finding?</strong> The dominant frameworks show dramatically different results. React has an unavoidable performance ceiling. TanStack Start achieves 373.6 kB raw (118.2 kB compressed) bundles using React 19, only 1.51 times better than Next.js’s 564.9 kB raw (176.3 kB compressed). Angular ships similarly heavy bundles via Analog at 666.5 kB raw (203.4 kB compressed). But Vue (via Nuxt) proved different, achieving competitive 224.9 kB raw (72.3 kB compressed) bundles with instant 38ms FCP that matches next-gen frameworks. Meanwhile, next-gen frameworks like SolidStart deliver 128.6 kB raw (41.5 kB compressed) bundles with equally instant 35ms FCP, 4.39 times smaller than Next.js and 2.91 times smaller than TanStack Start with React. The perfect controlled comparison: TanStack Start with React (373.6 kB raw) versus TanStack Start with Solid (182.6 kB raw). Same meta-framework, same patterns, but React bundles are 2x the size of Solid, isolating React’s runtime cost.</p>
<p><strong>Mobile is the web.</strong> These measurements matter because mobile web is the primary internet for billions of people. If your app is accessible via URL, people will use it on phones with cellular connections. Optimizing for desktop and hoping mobile is good enough is backwards. The web is mobile. Build for that reality.</p>
<p>Each build uses the same database, features, and UI so the comparison stays fair. The differences in raw bundle size for the board page range from 4.39 to 6.36 times smaller compared to Next.js for modern alternatives. <strong>Important: These measurements represent disciplined baseline implementations with minimal dependencies.</strong> Real production apps typically ship 5 to 10 times more JavaScript from analytics, authentication, feature flags, and third party libraries, meaning the framework differences compound significantly in practice. On mobile devices with cellular connections, this matters enormously.</p>
<blockquote>
<p>Before diving in, a reminder from my <a href="https://www.lorenstew.art/blog/progressive-complexity-manifesto">Progressive Complexity Manifesto</a>: The frameworks compared here represent Level 5 complexity. They are powerful tools for when you need unified client-side state, a lot of reactivity, and/or client-side navigation. But most applications thrive at lower levels. For instance, Level 3 (server-rendered HTML enhanced with HTMX and vanilla JavaScript, as demonstrated in the kanban-htmx app in this repo) can handle complex interactive applications with minimal JavaScript. Level 4 adds occasional Web Components using Lit for reusable elements. These simpler approaches often deliver even smaller bundles and much simpler codebases. This post focuses on Level 5 options for cases that demand them, while remembering simpler paths often suffice.</p>
</blockquote>
<h2 id="why-mobile-web-performance-matters">Why Mobile Web Performance Matters</h2>
<p>For this evaluation, mobile performance wasn’t just a nice to have. It was the primary constraint. Our users are real estate agents working in the field: open houses with 30 people hammering the same cell tower, parking lots between showings, anywhere but a desk with WiFi. They need tools that work instantly, not “eventually load.”</p>
<p>We’re not building a native app. We’re building for the web, which means if it has a URL, people will access it on their phones. And for our users, the app could be used on a phone just as frequently as a desktop.</p>
<p>This reality shaped the evaluation. I couldn’t just pick a framework that “works on mobile.” I needed something that genuinely performs well on cellular connections with mid-tier devices. The difference between a framework shipping 30 kB versus 170 kB isn’t academic. It’s the difference between an app that feels professional and one that makes our users look bad in front of clients.</p>
<p><strong>The business cost of slow performance</strong>: Research from <a href="https://www.speedcurve.com/blog/downtime-vs-slowtime/">Tammy Everts at SpeedCurve</a> reveals something surprising. While site downtime causes 9% permanent user abandonment, slow performance causes 28% permanent abandonment. That’s over 3x worse. Even more revealing: slowdowns occur 10x more frequently than outages, resulting in roughly 2x total revenue impact despite lower per-hour costs. Beyond the abandonment numbers, slow performance creates a psychological effect where users start perceiving your entire brand negatively. Content seems “boring,” design looks “tacky,” even when those elements haven’t changed. Slowness poisons everything. These aren’t abstract metrics. They’re measurable business costs that compound with every framework kilobyte you ship to mobile users.</p>
<p><strong>The real-world cost:</strong> A 113 kB difference at 3G speeds (750 kbps) means 1.2 seconds for download plus 500ms to 1s for parse/execution on mobile CPUs. Total: 1.5 to 2 seconds slower between frameworks. On 4G the gap shrinks but remains noticeable. On spotty connections (like an open house with 30 people hammering the same cell tower) it becomes painful.</p>
<p><strong>“But it’s cached!”</strong> This objection misses reality. Cache busting is standard. Every deployment means users download again. First impressions matter. So do second, third, and tenth impressions. Your users remember waiting.</p>
<p>This is why I expanded the evaluation beyond the initial three frameworks. I needed to understand what’s actually possible. When someone pulls up the app in a parking lot between showings, every second counts. Building for mobile performance first means desktop on WiFi is excellent by default. The reverse isn’t true. Optimize for desktop and mobile users suffer.</p>
<p>I discovered the difference between frameworks reflects fundamentally different engineering priorities. Some frameworks prioritize runtime flexibility, shipping extensive abstractions to support wide use cases. Others prioritize runtime size and mobile performance from the ground up. The bundle sizes I measured for the board page varied by up to 7x (from 28.8 kB compressed to 203.4 kB compressed), differences that matter enormously on cellular networks.</p>
<h2 id="the-experiment-setup">The Experiment Setup</h2>
<p>I built a Kanban board application ten times, once in each of these frameworks: <a href="https://nextjs.org/"><strong>Next.js 16</strong></a> (React 19 with built-in compiler) representing React’s Virtual DOM approach with automatic optimization, <a href="https://tanstack.com/start/latest/docs/framework/react/overview"><strong>TanStack Start</strong></a> (also React 19) for a leaner React meta-framework without App Router overhead, <a href="https://tanstack.com/start/latest/docs/framework/solid/overview"><strong>TanStack Start + Solid</strong></a> (SolidJS 1.9) using the same meta-framework with fine-grained reactivity, <a href="https://nuxt.com/"><strong>Nuxt 4</strong></a> (Vue 3) for Vue’s reactive refs with SSR-first developer experience, <a href="https://analogjs.org/"><strong>Analog</strong></a> (Angular 20) using Angular’s modern signals API with meta-framework tooling, <a href="https://markojs.com/docs/marko-run/getting-started"><strong>Marko</strong></a> (@marko/run) for streaming SSR with fine-grained reactivity, <a href="https://docs.solidjs.com/solid-start/"><strong>SolidStart</strong></a> (SolidJS 1.9) for native Solid integration with fine-grained reactivity through signals, <a href="https://svelte.dev/docs/kit/introduction"><strong>SvelteKit</strong></a> (Svelte 5) for fine-grained reactivity with runes, <a href="https://qwik.dev/docs/qwikcity/"><strong>Qwik City</strong></a> for resumability instead of hydration, and <strong><a href="https://astro.build/">Astro</a> + <a href="https://htmx.org/">HTMX</a></strong> for a traditional MPA approach.</p>
<p>Each implementation includes the exact same features: board creation and listing pages, four fixed lists per board (Todo, In Progress, QA, Done), full CRUD operations for cards, drag-and-drop card reordering within lists and movement between lists, assignee assignment from a static user list, tag management, comments on cards with authorship tracking, completion status toggles, optimistic UI updates for drag-and-drop and chart changes (HTMX lacks this though), and server-side form validation using <a href="https://valibot.dev/">Valibot</a>.</p>
<p>All ten apps share the same foundation. The database is SQLite with <a href="https://orm.drizzle.team/">Drizzle ORM</a> using an identical schema across all implementations. Styling comes from <a href="https://tailwindcss.com/">Tailwind CSS</a> plus <a href="https://daisyui.com/">DaisyUI</a> to keep the UI consistent. Each framework implementation contains roughly 17 components. Most importantly, every app performs real database queries against relational data (boards → lists → cards → tags/comments/users) rather than working with hardcoded arrays.</p>
<p>You can check out the code <a href="https://github.com/lorenseanstewart/kanban-comparison">here</a>.</p>
<p><strong>A critical choice about dependencies</strong>: These apps intentionally minimize dependencies compared to what many developers typically reach for. For mobile web applications, every dependency represents a choice to ship additional kilobytes to users. I used necessary UI libraries like drag-and-drop packages (which vary by ecosystem), but deliberately avoided data fetching libraries, state management helpers, and other utilities that frameworks already handle natively. Each ecosystem has popular packages that add convenience but increase bundle size (React developers often reach for tanstack-query for data fetching, state management libraries, or form helpers). To illustrate the trade-off: tanstack-query alone weighs approximately 13 kB gzipped. That single dependency is already larger than Marko’s entire homepage bundle at 6.8 kB. By avoiding these “nice to have” dependencies and using each framework’s built-in capabilities instead, the bundle differences you’ll see reflect framework architectural choices, not different amounts of functionality or third-party helpers.</p>
<p><strong>Measurement Methodology</strong>: All bundle sizes in this comparison represent median values from 10 measurement runs with browser cache cleared between each run to ensure cold-load performance measurements. Server warmup requests and IQR outlier removal ensure robust statistics. I report both raw (uncompressed) JavaScript sizes and compressed transfer sizes. The raw size reflects actual code volume generated by each framework and is more consistent for comparison since it doesn’t vary by server compression settings. The compressed size shows what users actually download over the network. See the complete <a href="https://github.com/lorenseanstewart/kanban-comparison/blob/main/METHODOLOGY.md">measurement methodology</a> for details on statistical approach, test conditions, and limitations.</p>
<p>Here’s how the tech stacks compare:</p>

<p>This isn’t a todo list with hardcoded arrays. It’s a real app with database persistence, complex state management, and the kind of interactions you’d actually build for a real product.</p>
<h3 id="framework-architectures-at-a-glance">Framework Architectures at a Glance</h3>
<p>To avoid repetition throughout this post, here are the key architectural approaches for each framework tested:</p>
<p><strong>React-based (Next.js, TanStack Start + React):</strong> Use Virtual DOM reconciliation where components re-render and React diffs changes before updating the DOM. React’s compiler automatically optimizes components through memoization using a Control Flow Graph-based High-Level Intermediate Representation, reducing manual optimization needs but not bundle size. Next.js employs React Server Components (RSC) which serialize component trees into a special RSC Payload format, adding meta-framework overhead. TanStack Start uses traditional SSR without RSC complexity. Both ship React’s runtime including Virtual DOM reconciler, synthetic event system, and platform abstractions, creating unavoidable baseline costs for mobile users.</p>
<p><strong>Solid-based (SolidStart, TanStack Start + Solid):</strong> Fine-grained reactivity via signals with read/write segregation where getters are separate from setters. JSX syntax similar to React, but signals automatically track dependencies, eliminating manual dependency arrays and rules of hooks. Components run once during initial render; subsequent updates happen directly at the reactive primitive level without re-executing component functions, minimizing CPU overhead on mobile devices. TanStack Start provides more feature-rich routing which causes slightly larger bundles compared to SolidStart’s leaner integration.</p>
<p><strong>SvelteKit:</strong> Compile-time optimization that transforms components into imperative DOM updates, with minimal runtime overhead since the compiler does most work at build time. Runes ($state, $derived, $effect) powered by signals enable fine-grained reactivity, with universal reactive primitives that work in .js/.ts files beyond just .svelte components. The compiler converts developer-written code into lean, optimized production code. This approach generates JavaScript with smaller bundles through aggressive tree-shaking, helping mobile performance on both network transfer and parse time.</p>
<p><strong>Nuxt (Vue):</strong> Reactive refs with <code>.value</code> access for reactivity tracking. Uses aggressive optimization including compile cache for faster cold starts and reactive keys for intelligent data fetching. In Vue 3 the reactivity system has been refactored for improved performance and memory efficiency, critical for mobile devices. Vapor Mode (experimental, not used here) offers a compile-first approach that bypasses Virtual DOM entirely, compiling templates directly to native DOM operations with significantly smaller runtime overhead. Despite being a “big three” framework, Nuxt achieves competitive bundle sizes and exceptional runtime performance, with support for mixed component trees combining different rendering strategies.</p>
<p><strong>Analog (Angular):</strong> Modern signals API provides fine-grained reactivity through primitives like signal, effect, linkedSignal, queries, and inputs. Zoneless mode enables removing zone.js from bundles entirely, eliminating its synchronization overhead which improves mobile CPU efficiency. Uses dependency injection patterns and ships with RxJS for enterprise reactive patterns, creating heavier bundles despite signals-based reactivity. Angular remains a “batteries-included” framework where common functionality is built-in rather than requiring third-party libraries. Incremental hydration reduces time-to-interactive by hydrating components progressively rather than all at once.</p>
<p><strong>Marko:</strong> Streaming SSR with fine-grained reactivity powered by compiler analysis. The compiler analyzes the reactivity graph at build time and compiles away components themselves, shipping only the minimal code needed for events and effects, achieving zero component overhead at runtime. Statically analyzes which components are stateful versus server-only, breaking pages into top-level stateful components and selectively serializing only needed data. HTML-first syntax with automatic dependency tracking eliminates boilerplate. Supports streaming asynchronous SSR with selective hydration where only interactive parts ship JavaScript to the client, critical for minimizing mobile bundle size.</p>
<p><strong>Qwik City:</strong> Resumability architecture that serializes application state and component boundaries directly into HTML during server rendering, allowing the client to “resume” execution without traditional hydration that requires re-executing components to attach event listeners. Employs fine-grained lazy loading down to the component level, deferring JavaScript downloads until actual user interaction occurs. Event handlers, component logic, and complex interactions are delivered lazily on-demand, eliminating bulk initial JavaScript execution that burdens mobile CPUs. Optimized for edge platforms with distributed deployment, delivering sub-second load times on mobile networks. Best suited for complex client-heavy applications requiring instant interactivity.</p>
<p><strong>Astro + HTMX:</strong> Multi-page architecture (MPA) where Astro serves as a simple HTML renderer with no client-side JavaScript framework. HTMX handles all interactivity through declarative HTML attributes that trigger server requests and swap HTML fragments into the page. Instead of client-side state management, interactions send requests to the server which returns HTML snippets that HTMX injects into the DOM. This approach ships minimal JavaScript (just the HTMX library) and keeps pages lean as routes increase. Best suited for applications where server round trips are acceptable and client-side reactivity isn’t critical. Trades rich client-side state management for extreme simplicity and tiny bundles, optimal for form-driven or content-heavy applications.</p>
<p><strong>TanStack Start:</strong> Meta-framework with a client-first architecture philosophy (versus server-first approaches like Next.js RSC), maintaining powerful server capabilities while prioritizing client-side routing and state management. Router-centric design where the majority of framework functionality comes from TanStack Router, which is framework-agnostic and supports React and Solid. Provides isomorphic loaders that work on both server and client, streaming SSR for progressive rendering, and server functions for type-safe RPC. React version ships traditional hydration with React’s baseline costs, while Solid version achieves roughly half the bundle size using identical routing infrastructure, demonstrating how UI library choice impacts mobile performance.</p>
<blockquote>
<p><strong>Fairness Check</strong>: Pinned versions, identical data volume on Board page, normalized CSS/icon handling (treeshake/purge). All measurements use Chrome Lighthouse with mobile emulation (Pixel 5, 4G throttling, 1x CPU). The measurement script uses 1x CPU to isolate bundle size impact from CPU performance variance. Cache is cleared between each measurement run to simulate first-visit experience.</p>
</blockquote>
<h2 id="why-i-expanded-from-three-to-ten-frameworks">Why I Expanded from Three to Ten Frameworks</h2>
<p>When I started this evaluation, I expected to compare Next.js, SolidStart, and SvelteKit, then make a recommendation. But building those first three implementations revealed something I hadn’t anticipated: the performance issues I saw in Next.js weren’t just a React problem. They were likely systemic across the “big three” dominant framework ecosystems (React, Angular, Vue).</p>
<p>React (via Next.js) ships 154.5 to 176.3 kB compressed (486.1 to 564.9 kB raw) with poor runtime performance at 467ms FCP. Angular (via Analog) ships 125.4 to 203.4 kB compressed (430.3 to 666.5 kB raw). Both suffer from heavy baseline bundles that create performance costs for mobile users. Vue (via Nuxt) tells a dramatically different story. Nuxt ships competitive bundle sizes at 72.3 kB compressed (224.9 kB raw) AND achieves exceptional 38ms FCP, making it faster than all React and Angular options and competitive with next-gen frameworks like SvelteKit (38ms, tied) and Marko (39ms). This puts Nuxt in a unique position: it’s the only “big three” meta-framework that competes on mobile web performance. React requires architectural changes to achieve similar results. Angular has no clear path forward. Nuxt proved that with proper optimization, even established frameworks can deliver next-gen performance.</p>
<p><strong>React’s explicit strategy:</strong> React Native for mobile. In practice, React’s web runtime trades bundle size for other goals. Many teams pursuing top-tier mobile performance choose React Native. The architectural choices that make React heavy on the web are deliberate. They solve real problems for desktop and app development. But for mobile web, React’s position is essentially: use React Native instead.</p>
<p>This is a strategic business decision, not a technical oversight. Facebook (Meta) doesn’t build heavy React web apps on mobile. They invest heavily in React Native and native apps. When you use their mobile app, you’re not running a web browser rendering a React SPA. You’re running native code. React Native is their solution for mobile performance. The React web framework can be expensive because the assumption is that if you care about mobile, you should use a different tool.</p>
<p>The problem with this strategy is that it abandons the open web. React Native requires building two separate applications. Your company needs React engineers for the web, different engineers or different skill sets for native mobile development, and App Store difficulties on top.</p>
<p><strong>This isn’t just an inconvenience. It’s technofeudalism.</strong> React Native solves the mobile performance problem, but it does so by pushing developers out of the open web and into app store platforms where Apple and Google extract up to 30% of transactions, control distribution, and can revoke access at will. React’s mobile strategy inherently drives teams toward platform capture. The web offers an alternative: no gatekeepers, no platform fees, direct distribution. (I explore this dynamic in depth in “The Web is the Last Commons” section below, building on economist Yanis Varoufakis’s analysis of how app stores operate as digital fiefdoms rather than competitive markets.)</p>
<p>Other frameworks make a different bet: the web should work well on mobile without requiring a parallel native technology. The teams behind Marko, Solid, Svelte, Qwik, and Vue have done phenomenal engineering work rethinking these fundamentals from first principles. They’ve built innovative solutions that optimize for the web as a first-class platform for mobile. They’re all saying: you shouldn’t need a completely different technology stack just to reach people with phones. The web should be competitive on its own.</p>
<p>React’s choice is coherent within their ecosystem strategy. It makes sense given their investment in React Native. But it’s not neutral. It’s a choice that deprioritizes mobile web performance in favor of extensive runtime abstractions. For teams building mobile first web applications, it’s a choice that works against you.</p>
<p>That’s why I expanded the evaluation to ten frameworks. If I was going to make an honest recommendation for the team, I needed to understand what’s actually possible. React’s heavy bundle sizes aren’t bugs or poor engineering. They’re the predictable cost of React’s runtime architectural overhead. Angular has similar bundle size issues. Vue showed that the “big three” can compete on mobile web performance when properly configured. For teams building mobile first web applications without the resources for React Native, React and Angular create unavoidable performance limitations, but Nuxt offers a viable path forward.</p>
<p>The measurements that follow show exactly what that tradeoff looks like in practice. They also show what happens when frameworks prioritize mobile web performance from the start. Marko at 6.8 kB compressed. Solid at 30.6 kB compressed. Svelte at 47.8 kB compressed. These aren’t just smaller numbers. They’re fundamentally different architectural approaches that treat the web as a first class platform for mobile.</p>
<h2 id="bundle-size-reality-check">Bundle Size Reality Check</h2>
<h3 id="the-numbers-versions-used">The Numbers (Versions used)</h3>
<p>Production builds measured showing raw JavaScript size (with compressed/gzipped transfer size in parentheses). Raw size reflects actual code volume and is more consistent for comparison. Compressed size shows what users download over the network.</p>
<p>Framework versions tested: Next.js 16.0.0-beta.0 (React 19.2.0), TanStack Start 1.133.8 (React 19.2.0), Nuxt 4.1.2 (Vue 3.5.22), Analog (Angular core 20.3.3), Marko 6.0.85 with @marko/run 0.8.1, SolidStart (@solidjs/start 1.2.0, solid-js 1.9.9), SvelteKit 2.43.6 (Svelte 5), Qwik City 1.16.1 (Qwik 1.16.1), Astro 5.14.5 + HTMX.</p>
<p><strong>These are minimal baseline implementations.</strong> Typical production apps include authentication, analytics, feature flags, form libraries, and other dependencies that multiply these numbers significantly. The framework overhead shown here compounds with every additional dependency.</p>
<p>Table ordered by board page size (smallest first):</p>







































































<table><thead><tr><th>Framework</th><th>Board Page Raw (Compressed)</th><th>Homepage Raw (Compressed)</th><th>Difference from Next.js (Board Page)</th></tr></thead><tbody><tr><td><strong>Marko</strong></td><td>88.8 kB (28.8 kB)</td><td>12.6 kB (6.8 kB)</td><td><strong>6.36x smaller</strong></td></tr><tr><td><strong>Qwik City</strong></td><td>114.8 kB (58.4 kB)</td><td>88.5 kB (43.6 kB)</td><td><strong>4.92x smaller</strong></td></tr><tr><td><strong>SvelteKit</strong></td><td>125.2 kB (54.1 kB)</td><td>103.4 kB (47.8 kB)</td><td><strong>4.51x smaller</strong></td></tr><tr><td><strong>Astro + HTMX</strong></td><td>127.3 kB (34.3 kB)</td><td>88.9 kB (22.0 kB)</td><td><strong>4.44x smaller</strong></td></tr><tr><td><strong>SolidStart</strong></td><td>128.6 kB (41.5 kB)</td><td>85.9 kB (30.6 kB)</td><td><strong>4.39x smaller</strong></td></tr><tr><td><strong>TanStack Start + Solid</strong></td><td>182.6 kB (60.4 kB)</td><td>153.0 kB (52.0 kB)</td><td><strong>3.09x smaller</strong></td></tr><tr><td><strong>Nuxt</strong></td><td>224.9 kB (72.3 kB)</td><td>224.9 kB (72.3 kB)</td><td><strong>2.51x smaller</strong></td></tr><tr><td><strong>TanStack Start</strong></td><td>373.6 kB (118.2 kB)</td><td>316.8 kB (100.7 kB)</td><td><strong>1.51x smaller</strong></td></tr><tr><td><strong>Next.js 16</strong></td><td>564.9 kB (176.3 kB)</td><td>497.8 kB (154.5 kB)</td><td>Baseline</td></tr><tr><td><strong>Analog</strong></td><td>666.5 kB (203.4 kB)</td><td>430.3 kB (125.4 kB)</td><td>1.18x larger</td></tr></tbody></table>
<p><img src="https://www.lorenstew.art/images/kanban-bundle-size-comparison.svg" alt="Bundle Sizes"/></p>
<p><strong>Field data validation</strong>: The <a href="https://lookerstudio.google.com/u/0/reporting/55bc8fad-44c2-4280-aa0b-5f3f0cd3d2be/page/M6ZPC?params=%7B%22df44%22:%22include%25EE%2580%25800%25EE%2580%2580IN%25EE%2580%2580AngularJS%25EE%2580%2580Nuxt.js%25EE%2580%2580Next.js%2520App%2520Router%25EE%2580%2580Astro%25EE%2580%2580SvelteKit%25EE%2580%2580Qwik%25EE%2580%2580SolidStart%22,%22df46%22:%22include%25EE%2580%25800%25EE%2580%2580IN%25EE%2580%2580mobile%22%7D">Chrome User Experience Report (CrUX)</a> provides real-world Core Web Vitals data from millions of actual websites using these frameworks on mobile devices. This field data complements the controlled measurements in this post. Important caveat: CrUX data reflects how these frameworks are used in production by average developers, not optimal implementations. If a framework shows poorly in CrUX but well in these tests, it demonstrates what’s possible with proper configuration, performance tuning, and dependency discipline. The gap between field data and optimized implementations reveals opportunity for improvement in real-world usage patterns.</p>
<p>The difference between Marko’s 88.8 kB raw (28.8 kB compressed) and Next.js’s 564.9 kB raw (176.3 kB compressed) translates to roughly 1.5 seconds on cellular. These seconds are the baseline. Time waiting to load increases with every feature and every dependency added. Those aren’t just abstract kilobytes. That’s their time, their patience, and ultimately their impression of your product.</p>
<p><strong>Critical scaling consideration</strong>: These bundle sizes represent a mid-complexity app with multiple routes. MPA frameworks like Marko ship minimal JavaScript per page (6.8 to 28.8 kB compressed per route), staying lean as you add features. SPA frameworks ship routing and framework runtime upfront. Even with code splitting, SPAs maintain higher baselines: Solid/Svelte start at 30.6 to 54.1 kB compressed then add route chunks, while React/Vue/Angular start at 72.3 to 203.4 kB compressed. The architectural model creates different scaling characteristics.</p>
<p><strong>Important context on HTMX</strong>: The Astro + HTMX implementation achieves excellent bundle sizes with the simplest codebase, but sacrifices client-side reactivity for server-driven interactions. HTMX excels for simpler, form-driven applications where most interactions trigger server requests. However, as your app’s need for rich client-side state management grows, HTMX becomes less practical. For reactive applications, Marko (6.8 to 28.8 kB compressed), Solid (30.6 to 41.5 kB compressed), and Svelte (47.8 to 54.1 kB compressed) maintain small bundles while delivering rich reactivity.</p>
<h3 id="reacts-ceiling-in-practice-tanstack-vs-next">React’s Ceiling in Practice (TanStack vs Next)</h3>
<p><strong>TanStack Start achieves 100.7 to 118.2 kB compressed bundles (316.8 to 373.6 kB raw) while Next.js ships 154.5 to 176.3 kB compressed (497.8 to 564.9 kB raw)</strong> in this measurement. Both use React 19. That’s only a 33 to 35% improvement, primarily reflecting App Router + RSC and related runtime.</p>
<p>The answer reveals that <strong>React’s runtime architecture is the primary cost</strong>, not just Next.js’s meta-framework choices.</p>
<p><strong>What’s the difference?</strong> Next.js ships the full React Server Components runtime plus serialization layers, component boundary management, caching infrastructure, App Router with all its routing features, progressive enhancement for Server Actions, image optimization, and middleware. TanStack Start strips most of that out: traditional SSR without RSC, leaner routing, and simple RPC-style server functions.</p>
<p>Both use server-side rendering, but Next.js’s RSC model adds substantial overhead. Server Components render on the server only, Client Components get marked with <code>&#34;use client&#34;</code>, the server serializes everything to a special format, and the client needs runtime code to deserialize and coordinate those boundaries. TanStack Start uses the simpler traditional SSR approach: render on server, ship HTML, hydrate everything on the client. No serialization, no boundary coordination.</p>
<p>In this measurement, Next.js’s App Router + RSC adds roughly 53 to 58 kB compressed. The remaining 100.7 to 118.2 kB compressed (316.8 to 373.6 kB raw) is React’s core runtime cost: reconciliation, event system, and hydration baseline.</p>
<p>Compare that to alternatives. <strong>SolidStart</strong> delivers 30.6 to 41.5 kB compressed (85.9 to 128.6 kB raw) using JSX, <strong>2.91x smaller than TanStack Start</strong> with React. <strong>SvelteKit</strong> achieves 47.8 to 54.1 kB compressed (103.4 to 125.2 kB raw), which is 1.97x to 2.47x smaller than TanStack Start. <strong>Qwik</strong> delivers 43.6 to 58.4 kB compressed (88.5 to 114.8 kB raw), which is 1.72x to 2.31x smaller.</p>
<p>For React teams, the path forward isn’t straightforward. TanStack Start proves you can remove Next.js’s overhead, but you’re still carrying React’s 100.7 to 118.2 kB compressed (316.8 to 373.6 kB raw) baseline. SolidStart offers similar JSX syntax with 2.91x smaller bundles. And if you like TanStack Start’s approach, you can use it with Solid for the same routing patterns with dramatically smaller bundles.</p>
<p>Here’s the bottom line: <strong>React’s architecture (not just the Virtual DOM, but also synthetic events, platform patching, and sheer feature complexity) creates unavoidable performance costs that no meta-framework optimization can eliminate.</strong> To be fair, Virtual DOM implementations can be small (see Preact at 4 kB). React’s size reflects deliberate choices to circumvent platform constraints and provide extensive features. TanStack Start proves this: removing App Router overhead yields only a 33 to 35% improvement. To escape this ceiling and achieve 3 to 4 times smaller bundles, you need a fundamentally different architectural approach. Frameworks that lean into the platform instead of circumventing it can deliver dramatic size reductions. The React team chose to accept these costs to solve other problems (Server Components, unified patterns). That’s a legitimate choice. But it’s not negotiable within React.</p>
<h3 id="tanstack-start-react-vs-solid">TanStack Start: React vs Solid</h3>
<p>Here’s where it gets interesting. TanStack Start is a new meta-framework that currently supports both React and Solid. Using the same meta-framework with two different UI libraries gives us the perfect controlled comparison.</p>
<p><strong>TanStack Start with React:</strong> Ships 373.6 kB raw (118.2 kB compressed) compared to Next.js’s 564.9 kB raw (176.3 kB compressed). That’s 34% smaller by raw size. If you’re stuck maintaining an existing Next.js codebase, TanStack Start offers a legitimate escape path from App Router complexity while staying in React. But that’s still 373.6 kB raw (118.2 kB compressed) of React’s core runtime.</p>
<p><strong>TanStack Start with Solid:</strong> Delivers 182.6 kB raw (60.4 kB compressed). That’s 30% larger than SolidStart’s 128.6 kB raw (41.5 kB compressed), but still dramatically better than any React option. The size difference is largely due to TanStack Router having more features than SolidStart’s Router. This buys you additional routing capabilities and framework flexibility.</p>
<p><strong>The controlled comparison that matters:</strong> React at 373.6 kB raw (118.2 kB compressed) versus Solid at 182.6 kB raw (60.4 kB compressed) using identical TanStack Start infrastructure. Same routing, same SSR approach, same patterns. React bundles are 2x the size of Solid. This isolates React’s runtime cost versus Solid’s architecture. No meta-framework differences, no excuses.</p>
<p>All four implementations achieve perfect 100 Lighthouse scores. Bundle size differences are real, but modern devices handle them without impacting perceived performance in this test.</p>
<p><strong>For greenfield projects?</strong> Don’t choose React. TanStack Start with Solid gives you 182.6 kB raw (60.4 kB compressed) bundles, but native SolidStart delivers 128.6 kB raw (41.5 kB compressed) with tighter integration. If you want the absolute smallest with this architecture, go SolidStart. If you like TanStack Start’s patterns and might want framework flexibility later, TanStack Start with Solid is reasonable. But starting a new project with React (whether Next.js or TanStack Start) means voluntarily accepting 2x to 3x larger bundles for no performance gain.</p>
<h2 id="the-verdict-what-im-recommending">The Verdict: What I’m Recommending</h2>
<p>After building ten implementations (with help, of course; see the acknowledgements below) and measuring everything, the data gives clear direction. For our mobile first requirements, here’s what I found:</p>
<p><strong>The next-gen frameworks all achieve essentially instant performance.</strong> The 35-39ms FCP range feels perceptually identical to users, and it’s 12 to 13 times faster than Next.js at 467ms. Since all next-gen frameworks feel equally fast, choose based on bundle size priorities and developer experience rather than microscopic FCP differences.</p>
<p>That said, context matters. Not every project can or should switch frameworks.</p>
<p><strong>When Next.js still makes sense:</strong> For large existing React codebases, migration costs may outweigh performance benefits. If you’re stuck with React and can’t migrate, consider TanStack Start over Next.js for a 21-31% bundle reduction without App Router complexity. That’s a practical business decision. But for greenfield projects? There’s no legacy to maintain, no migration costs to weigh. You’re choosing to build on a foundation that costs your users 2x to 3x more JavaScript on every visit. You’re voluntarily accepting worse performance when better options cost nothing extra. That’s not a neutral technical choice. “We only know React” isn’t a technical constraint, it’s a learning investment decision. And “organizational politics” is real, but it’s not a technical justification. It’s an admission that better options exist but can’t be chosen.</p>
<p><strong>Reality check on common objections:</strong></p>
<p><strong>“But hiring!”</strong> Competent developers learn frameworks. That’s the job. These alternatives are actually easier to learn than React: no rules of hooks, no dependency arrays, no manual memoization dance. The real difficulty isn’t learning curve, it’s creating a engineering culture that acknowledges constraints and makes intentional decisions with these constraints in mind.</p>
<p><strong>“But ecosystem!”</strong> React’s ecosystem is both advantage and liability. Large libraries ship code for scenarios you’ll never encounter. That date picker with every locale? You need 3 features, you’re shipping 300. For mobile-first projects where every kilobyte matters, this becomes a problem. Modern AI tools make building exactly what you need feasible: generate the function instead of importing 50kB for 3 features. Smaller bundles, code you understand.</p>
<p><strong>“But it’s risky!”</strong> Shipping 3x larger bundles to mobile users on cellular is the actual risk. Slow loads damage your brand and cost conversions. The “safe choice” has measurable costs.</p>
<p><strong>“But my users are desktop-only!”</strong> Let’s be honest: “desktop-only” is usually an excuse to skip performance discipline entirely. And it’s rarely true for long. Six months later someone asks “can I check this on my phone?” and suddenly you’re stuck. Better to build it right from the start. Desktop users still benefit from faster parsing and execution. Even on WiFi, 30.6 kB compressed loads noticeably faster than 176.3 kB compressed. More importantly, why would you voluntarily accept 3x worse performance when the better option costs nothing extra? Performance is a feature regardless of screen size. Building with constraints makes you a better engineer. “Desktop-only” shouldn’t mean “no discipline.”</p>
<p><strong>Why you should seriously consider the alternatives</strong>: The mental models are often simpler (see Framework Architectures section). Alternatives like Solid, Svelte, and Marko streamline patterns with automatic reactivity. Performance comes by default with 2x to 6x smaller bundles requiring no optimization work. Mobile web matters with real users on phones, cellular connections, and mid-tier devices. You’ll write less code, ship less JavaScript, and debug fewer framework quirks. Most importantly, greenfield projects deserve choices made on merit rather than defaults.</p>
<p><strong>These alternatives are especially compelling</strong> for mobile-first applications where bundle size directly impacts user experience. They matter for the growing demographic of people who prefer phones over computers. Mobile professionals like real estate agents, field service workers, healthcare staff, delivery drivers, and sales reps benefit most. Teams building internal tools or MVPs without enterprise politics constraining decisions can move faster. Developers who value technical excellence over popularity contests will appreciate the engineering quality. Importantly, teams save significant money by maintaining a single high-performance web codebase instead of splitting resources between separate web and native applications. This often means smaller teams, lower overhead, and faster iteration cycles compared to organizations maintaining web apps and native mobile apps.</p>
<p><strong>Choosing among the alternatives</strong> (organized by primary use case):</p>
<p><strong>Smallest Bundles: Choose Marko</strong> for the absolute best bundle sizes (6.8 to 28.8 kB compressed). Marko delivers 44% smaller bundles than the next closest competitor, making it the clear winner when bundle size is your top priority. The MPA architecture ships minimal JavaScript per page, staying lean as you add routes. The developer experience is excellent once you embrace its streaming model. Note: Marko 6 is currently in beta (tagged as <code>next</code> on npm) and expected to leave beta by end of year, with no expected API changes but ongoing bug fixes and optimizations.</p>
<p><strong>JSX Familiarity: Choose SolidStart</strong> if you want the easiest migration path from React. At 128.6 kB raw (41.5 kB compressed), SolidStart uses JSX syntax with automatic dependency tracking that eliminates manual memoization. This delivers 4.39x smaller bundles than Next.js while feeling immediately familiar to React developers. The mental model is actually simpler than React because signals are more straightforward than hooks.</p>
<p><strong>Best All-Around Developer Experience: Choose SvelteKit</strong> for approachable syntax and excellent defaults. At 125.2 kB raw (54.1 kB compressed), SvelteKit delivers 4.51x smaller bundles than Next.js with progressive enhancement by default and minimal framework overhead. The compiler-based approach means less runtime code and cleaner component logic. Best for developers from any background seeking readable code with few framework quirks.</p>
<p><strong>Resumability Pattern: Choose Qwik City</strong> if you have a larger application that demands immediate interactivity on load with significant client-side functionality. At 88.5 to 114.8 kB raw (43.6 to 58.4 kB compressed), Qwik uses resumability instead of hydration, yielding instant time-to-interactive. Different architectural approach that solves different scaling problems.</p>
<p><strong>Established Ecosystem: Choose Nuxt</strong> if you want Vue’s mature plugin ecosystem with competitive mobile web performance. At 224.9 kB raw (72.3 kB compressed), Nuxt proves that established “big three” frameworks can achieve next-gen performance when properly configured. Best for teams already familiar with Vue, projects that benefit from extensive community plugins, or teams that value the safety of a well-established framework. Nuxt bridges the gap between the familiar and the performant.</p>
<p><strong>Important scaling consideration:</strong> Marko’s MPA architecture ships minimal JavaScript per page (stays lean as you add routes), while SPAs like SvelteKit and SolidStart ship routing and framework runtime upfront then add route chunks. Both use code splitting, but the architectural models create different performance characteristics at scale.</p>
<blockquote>
<p>As discussed in my <a href="https://www.lorenstew.art/blog/progressive-complexity-manifesto">Progressive Complexity Manifesto</a>, these Level 5 frameworks are only necessary when you need unified client-side state and complex reactivity. Most apps can thrive at lower levels with simpler tools like HTMX and vanilla JS/TS.</p>
</blockquote>
<p>When developers have real alternatives, everyone wins. React wouldn’t be adding a compiler if SolidStart and Svelte weren’t proving that automatic optimization matters. The entire ecosystem improves when we stop accepting “good enough” as the ceiling.</p>
<p><strong>My recommendation for the team:</strong> After building all these implementations, <strong>Marko, SolidStart, and SvelteKit are all excellent choices</strong> that would serve our mobile first requirements well. All three feel perceptually instant to users. The real question is priorities: absolute smallest bundles (Marko), easiest React migration (SolidStart), or best all-around developer experience (SvelteKit). If the team has Vue experience, Nuxt is also compelling with its mature ecosystem and competitive performance.</p>
<p>For personal projects outside of work, I’ll be reaching for SvelteKit and increasingly Marko. Their developer experience just feels right, the code flows naturally, and they make building things fun.</p>
<h2 id="performance-reality-what-lighthouse-hides">Performance Reality: What Lighthouse Hides</h2>
<p>Mobile performance scores on the Board page (median from 10 runs), ordered by FCP (fastest first):</p>








































































































<table><thead><tr><th>Framework</th><th>Score</th><th>FCP (ms)</th><th>LCP (ms)</th><th>TBT (ms)</th><th>CLS</th><th>Bundle Size Raw (Compressed)</th></tr></thead><tbody><tr><td><strong>SolidStart</strong></td><td>100</td><td>35</td><td>35</td><td>0</td><td>0.000</td><td>128.6 kB (41.5 kB)</td></tr><tr><td><strong>Nuxt</strong></td><td>100</td><td>38</td><td>38</td><td>0</td><td>0.000</td><td>224.9 kB (72.3 kB)</td></tr><tr><td><strong>SvelteKit</strong></td><td>100</td><td>38</td><td>38</td><td>0</td><td>0.000</td><td>125.2 kB (54.1 kB)</td></tr><tr><td><strong>Marko</strong></td><td>100</td><td>39</td><td>39</td><td>0</td><td>0.000</td><td>88.8 kB (28.8 kB)</td></tr><tr><td><strong>TanStack Start + Solid</strong></td><td>100</td><td>40</td><td>40</td><td>0</td><td>0.013</td><td>182.6 kB (60.4 kB)</td></tr><tr><td><strong>TanStack Start</strong></td><td>100</td><td>43</td><td>43</td><td>0</td><td>0.000</td><td>373.6 kB (118.2 kB)</td></tr><tr><td><strong>Analog</strong></td><td>100</td><td>53</td><td>53</td><td>0</td><td>0.000</td><td>666.5 kB (203.4 kB)</td></tr><tr><td><strong>Astro + HTMX</strong></td><td>100</td><td>54</td><td>54</td><td>0</td><td>0.001</td><td>127.3 kB (34.3 kB)</td></tr><tr><td><strong>Qwik</strong></td><td>100</td><td>58</td><td>58</td><td>0</td><td>0.000</td><td>114.8 kB (58.4 kB)</td></tr><tr><td><strong>Next.js 16</strong></td><td>100</td><td>467</td><td>467</td><td>0</td><td>0.000</td><td>564.9 kB (176.3 kB)</td></tr></tbody></table>
<p><strong>Key Metrics:</strong></p>
<p>FCP (First Contentful Paint) indicates when the first content appears on screen. LCP (Largest Contentful Paint) shows when the main content becomes visible. TBT (Total Blocking Time) measures how long the main thread remains blocked and unavailable for user interactions. CLS (Cumulative Layout Shift) evaluates visual stability, where 0 represents perfect stability with no unexpected layout shifts.</p>
<p><strong>Measurement Conditions</strong>: These scores represent mobile device emulation using Pixel 5 profile with 4G network throttling (10 Mbps download, 40ms round-trip time). I use 1x CPU (no throttling) to isolate bundle size and network impact from CPU performance, which allows fair comparison across frameworks with different runtime characteristics. Each measurement was run 10 times with cache cleared between runs to capture cold-load (first-visit) performance. Server warmup requests and IQR outlier removal ensure robust statistics. Standard deviations vary based on framework characteristics.</p>
<p>But here’s what these metrics hide. All frameworks achieve perfect or near perfect scores (100), but the paint times tell the real story about architectural differences. SolidStart achieves the fastest board page load at 35ms FCP. Nuxt and SvelteKit tie for second at 38ms FCP, with Marko close behind at 39ms. TanStack Start with Solid and TanStack Start with React follow at 40ms and 43ms respectively, showing excellent optimization. <strong>The top eight frameworks (SolidStart, Nuxt, SvelteKit, Marko, TanStack variants, Analog, Astro, Qwik) all render in under 60ms, achieving near-instant perceived performance.</strong> Only Next.js lags dramatically behind at 467ms FCP, representing a 13.3x performance gap compared to SolidStart for identical functionality.</p>
<p>Those paint time differences matter in the real world. SolidStart’s 35ms FCP feels instant, while Next.js’s 467ms FCP is noticeably slower. The framework choice directly impacts whether your app feels like a premium tool or a liability.</p>
<h3 id="where-the-difference-shows">Where the Difference Shows</h3>
<p>All frameworks feel instant in optimal conditions. The twist is this. Smaller bundles (Marko, Solid, Svelte, Qwik) win dramatically on slow networks and mid-tier devices.</p>
<p>On desktop with WiFi, all these frameworks are fast. On cellular with a mid-tier phone, 3.54 to 39.2x smaller bundles create measurably better UX. The 130 kB you saved doesn’t just download faster. It also parses and executes faster on mobile CPUs.</p>
<p><strong>Hydration vs Resumability:</strong></p>
<ul>
<li><strong>Traditional (React, Solid, Svelte, Vue, Angular)</strong>: Download bundle → Parse JS → Execute all components → Attach event listeners (hydration)</li>
<li><strong>Marko</strong>: Download minimal JS → Run effects and attach event listeners directly (fine-grained tree shaking, no re-execution of server code)</li>
<li><strong>Qwik</strong>: Download minimal JS → Resume from serialized HTML → Lazily load interaction handlers on demand</li>
</ul>
<p>Both Marko and Qwik are resumable frameworks that avoid traditional hydration. The key difference is that Qwik uses <em>lazy</em> resumability, progressively loading JavaScript based on actual interactions, while Marko analyzes the reactivity graph at build time to bundle exactly the code needed for events and effects; no lazy loading, but maximum precision in what gets shipped. Traditional frameworks must re-execute all components just to wire up event listeners.</p>
<h3 id="addressing-common-critiques">Addressing Common Critiques</h3>
<p>I know what some of you are thinking. “Aren’t you comparing MPAs to SPAs unfairly?” And “Is this app complex enough?”</p>
<p><strong>App Complexity Defense</strong>: This isn’t some toy todo list. It’s a solid mid-complexity app with real database persistence using SQLite plus Drizzle ORM, relational queries across boards to lists to cards to tags and comments, drag-and-drop reordering, (some) optimistic updates, modals, and server validation. It matches the kind of internal tools or MVPs teams crank out every day. The bundle differences come straight from framework overhead, not the features themselves, and those gaps only get bigger at scale with more routes and dependencies. If your production app throws in auth or real-time stuff, framework baselines would just bloat even more, not shrink.</p>
<p><strong>MPA vs SPA Nuances</strong>: The routing pattern debate misses the point, reactivity models matter way more. With features like <a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">View Transitions API</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API">Speculation Rules API</a>, MPAs like Marko or HTMX feel just as snappy as SPAs for navigation. The real split is in scaling. MPAs ship minimal JS per page, for example Marko sticks to 6.8 to 28.8 kB, while SPAs lug around upfront runtime from 83.9 to 666.5 kB baselines plus chunks.</p>
<p><strong>A Note on Ecosystems</strong>: the “small ecosystem” concern is often overstated. For mobile-first applications, we should be extremely selective about every dependency we add. Each package increases bundle size and maintenance burden. Modern AI tools like Claude, ChatGPT, and Cursor excel at generating focused code for your specific use case. Instead of importing a 50 kB library for 3 features, AI can help you write exactly what you need in 2 kB. This approach yields smaller bundles, code you actually understand, and <a href="https://github.blog/security/supply-chain-security/our-plan-for-a-more-secure-npm-supply-chain/">fewer supply chain risks</a>. Large ecosystems are sometimes advantageous, but they’re also a liability when every import costs your mobile users.</p>
<h2 id="does-complexity-buy-you-anything">Does Complexity Buy You Anything?</h2>
<p>If Next.js’s bundles are only 21 to 31% larger than TanStack Start (both using React), what are you actually getting for that extra 44 to 54 kB? And more importantly, do the dominant frameworks’ baselines (React at 100.7 to 118.2 kB compressed, Vue at 72.3 kB compressed, Angular at 125.4 to 203.4 kB compressed) buy you anything compared to alternatives that deliver 30.6 to 54.1 kB compressed?</p>
<h3 id="the-complexity-tax">The Complexity Tax</h3>
<p>Each of the big three has conceptual complexity that alternatives avoid. React has rules around hooks and dependency arrays. Angular carries dependency injection patterns and RxJS complexity. Vue requires understanding refs and reactivity tracking. After seeing that TanStack Start (with React) only achieves marginal improvements over Next.js (21 to 31%), it’s clear that framework complexity and bundle weight often go hand-in-hand. Here’s how state management, effects, and data fetching compare:</p>
<p><strong>1. State Management</strong></p>
<pre tabindex="0" data-language="jsx"><code><span><span>// React - useState with functional updates to avoid stale closures</span></span>
<span><span>const</span><span> [</span><span>count</span><span>, </span><span>setCount</span><span>] </span><span>=</span><span> useState</span><span>(</span><span>0</span><span>);</span></span>
<span><span>setCount</span><span>((</span><span>prev</span><span>) </span><span>=&gt;</span><span> prev </span><span>+</span><span> 1</span><span>);</span></span>
<span></span>
<span><span>// Solid - getter/setter pattern, explicit read/write</span></span>
<span><span>const</span><span> [</span><span>count</span><span>, </span><span>setCount</span><span>] </span><span>=</span><span> createSignal</span><span>(</span><span>0</span><span>);</span></span>
<span><span>setCount</span><span>(</span><span>count</span><span>() </span><span>+</span><span> 1</span><span>);</span></span>
<span></span>
<span><span>// Svelte - looks like normal variables</span></span>
<span><span>let</span><span> count </span><span>=</span><span> $state</span><span>(</span><span>0</span><span>);</span></span>
<span><span>count </span><span>=</span><span> count </span><span>+</span><span> 1</span><span>;</span></span>
<span></span>
<span><span>// Vue/Nuxt - .value access for reactivity</span></span>
<span><span>const</span><span> count</span><span> =</span><span> ref</span><span>(</span><span>0</span><span>);</span></span>
<span><span>count.value </span><span>=</span><span> count.value </span><span>+</span><span> 1</span><span>;</span></span>
<span></span>
<span><span>// Qwik - .value property, serializable</span></span>
<span><span>const</span><span> count</span><span> =</span><span> useSignal</span><span>(</span><span>0</span><span>);</span></span>
<span><span>count.value </span><span>=</span><span> count.value </span><span>+</span><span> 1</span><span>;</span></span>
<span></span>
<span><span>// Angular/Analog - getter/setter like Solid</span></span>
<span><span>const</span><span> count</span><span> =</span><span> signal</span><span>(</span><span>0</span><span>);</span></span>
<span><span>count.</span><span>set</span><span>(</span><span>count</span><span>() </span><span>+</span><span> 1</span><span>);</span></span>
<span></span>
<span><span>// Marko - direct assignment with automatic reactivity</span></span>
<span><span>&lt;let</span><span>/count</span><span>=</span><span>0</span><span>&gt;</span></span>
<span><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span><span>  count = count + 1; // Automatically reactive</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre>
<p><strong>2. Effects with Dependencies</strong></p>
<pre tabindex="0" data-language="jsx"><code><span><span>// React - manual dependency array (explicit but error-prone)</span></span>
<span><span>useEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>log</span><span>(count);</span></span>
<span><span>}, [count]); </span><span>// You must maintain this manually. Mistakes cause hard-to-debug stale closures and infinite loops. This is not a documentation problem, it&#39;s a design problem.</span></span>
<span></span>
<span><span>// Solid - automatic tracking</span></span>
<span><span>createEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>count</span><span>()); </span><span>// Automatically subscribes to count</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Svelte - automatic tracking</span></span>
<span><span>$effect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>log</span><span>(count); </span><span>// Automatically subscribes to count</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Vue/Nuxt - explicit or automatic</span></span>
<span><span>watch</span><span>(</span></span>
<span><span>  () </span><span>=&gt;</span><span> count.value,</span></span>
<span><span>  (</span><span>val</span><span>) </span><span>=&gt;</span><span> console.</span><span>log</span><span>(val)</span></span>
<span><span>); </span><span>// explicit</span></span>
<span><span>watchEffect</span><span>(() </span><span>=&gt;</span><span> console.</span><span>log</span><span>(count.value)); </span><span>// automatic</span></span>
<span></span>
<span><span>// Qwik - explicit tracking</span></span>
<span><span>useTask$</span><span>(({ </span><span>track</span><span> }) </span><span>=&gt;</span><span> {</span></span>
<span><span>  track</span><span>(() </span><span>=&gt;</span><span> count.value);</span></span>
<span><span>  console.</span><span>log</span><span>(count.value);</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Angular/Analog - automatic tracking</span></span>
<span><span>effect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>count</span><span>()); </span><span>// Automatically subscribes</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Marko - automatic tracking with &lt;script&gt;</span></span>
<span><span>&lt;let</span><span>/count</span><span>=</span><span>0</span><span>&gt;</span></span>
<span><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span><span>  console.log(count); // Automatically subscribes to count</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre>
<p><strong>3. Server Data Fetching</strong></p>
<pre tabindex="0" data-language="tsx"><code><span><span>// Next.js - async Server Component (implicit server boundary)</span></span>
<span><span>// Looks like regular component code but runs on server. No explicit data contract.</span></span>
<span><span>// This works beautifully until it doesn&#39;t, and when bugs arise from the server/client</span></span>
<span><span>// boundary being invisible, they&#39;re extremely hard to debug.</span></span>
<span><span>export</span><span> default</span><span> async</span><span> function</span><span> Page</span><span>() {</span></span>
<span><span>  const</span><span> board</span><span> =</span><span> await</span><span> db.query.boards.</span><span>findFirst</span><span>();</span></span>
<span><span>  return</span><span> &lt;</span><span>div</span><span>&gt;{board.name}&lt;/</span><span>div</span><span>&gt;;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// SvelteKit - remote functions with query (experimental)</span></span>
<span><span>// .remote.ts file defines server-side query function</span></span>
<span><span>export</span><span> const</span><span> getBoardData</span><span> =</span><span> query</span><span>(v.</span><span>string</span><span>(), </span><span>async</span><span> (</span><span>board_id</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  return</span><span> await</span><span> db.query.boards.</span><span>findFirst</span><span>();</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// In component: use $derived rune with await</span></span>
<span><span>const</span><span> boardData</span><span> =</span><span> $derived</span><span>(</span><span>await</span><span> getBoardData</span><span>(params.id));</span></span>
<span></span>
<span><span>// SolidStart - streaming with Suspense</span></span>
<span><span>// Explicit async resource with streaming support</span></span>
<span><span>const</span><span> board</span><span> =</span><span> createAsync</span><span>(() </span><span>=&gt;</span><span> getBoard</span><span>());</span></span>
<span><span>&lt;</span><span>Suspense</span><span>&gt;{</span><span>board</span><span>()?.name}&lt;/</span><span>Suspense</span><span>&gt;;</span></span>
<span></span>
<span><span>// Qwik - automatic serialization</span></span>
<span><span>// $ suffix marks server-only code, automatically serialized</span></span>
<span><span>export</span><span> const</span><span> useBoard</span><span> =</span><span> routeLoader$</span><span>(</span><span>async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>  return</span><span> await</span><span> db.query.boards.</span><span>findFirst</span><span>();</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Nuxt - built-in caching</span></span>
<span><span>// Composable with explicit key and built-in deduplication</span></span>
<span><span>const</span><span> { </span><span>data</span><span>: </span><span>board</span><span> } </span><span>=</span><span> await</span><span> useAsyncData</span><span>(</span><span>&#34;board&#34;</span><span>, () </span><span>=&gt;</span></span>
<span><span>  db.query.boards.</span><span>findFirst</span><span>()</span></span>
<span><span>);</span></span>
<span></span>
<span><span>// Analog - DI with server data</span></span>
<span><span>// Dependency injection brings Angular patterns to server data</span></span>
<span><span>export</span><span> const</span><span> load</span><span> =</span><span> injectLoad</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> service</span><span> =</span><span> inject</span><span>(BoardService);</span></span>
<span><span>  return</span><span> service.</span><span>getBoard</span><span>();</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Marko - route handlers with $global context</span></span>
<span><span>// Server handler runs first, sets data on context for page component</span></span>
<span><span>// +handler.ts</span></span>
<span><span>export</span><span> async</span><span> function</span><span> GET</span><span>(</span><span>context</span><span>) {</span></span>
<span><span>  const</span><span> board</span><span> =</span><span> await</span><span> db.query.boards.</span><span>findFirst</span><span>();</span></span>
<span><span>  context.board </span><span>=</span><span> board; </span><span>// Available as $global.board in component</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// +page.marko</span></span>
<span><span>&lt;</span><span>div</span><span>&gt;${$global.board.name}&lt;/</span><span>div</span><span>&gt;;</span></span></code></pre>
<p>The “big three” frameworks each carry conceptual complexity, though with different outcomes. React has rules around hooks and dependency arrays. Angular brings enterprise patterns like dependency injection alongside RxJS streams. Vue requires understanding refs and .value access, but unlike React and Angular, Vue (via Nuxt) has proven it can deliver competitive mobile web performance despite this complexity. These patterns become familiar with practice but never fully disappear and add cognitive overhead. Meta-frameworks compound these complexities: Next.js adds Server/Client boundaries and RSC serialization, Analog brings full Angular DI to the server, and Nuxt adds caching layers and composable patterns.</p>
<p>Most alternatives are conceptually simpler once learned. Svelte is most approachable (looks like enhanced HTML/JS). Solid and Marko use automatic tracking that eliminates manual dependency management. No rules of hooks, no dependency arrays, no .value boilerplate. The simpler mental models correlate with smaller bundles: less runtime complexity means less code to ship.</p>
<h2 id="does-nextjs-16s-built-in-compiler-change-anything">Does Next.js 16’s Built-in Compiler Change Anything?</h2>
<p>The React team recognizes the complexity problem. Their solution, now fully integrated in Next.js 16: the React Compiler automatically handles memoization to reduce re-renders.</p>
<h3 id="what-the-compiler-does">What the Compiler Does</h3>
<p>The React Compiler analyzes your code and inserts <code>useMemo</code> and <code>useCallback</code> automatically. In Next.js 16, this is no longer experimental; it’s built-in and enabled by default. It’s a genuine improvement that reduces boilerplate.</p>
<h3 id="the-results">The Results</h3>
<p>The compiler helps with re-render optimization and removes manual memoization boilerplate. But it doesn’t address Next.js’s bundle size: Next.js ships 176.3 kB compressed (564.9 kB raw) for the board page while TanStack Start ships 118.2 kB compressed (373.6 kB raw) with the same React 19. The compiler can’t eliminate dependency arrays for <code>useEffect</code>. You still need to understand hooks, closures, and React’s rendering model.</p>
<h3 id="the-irony">The Irony</h3>
<p>The compiler improves React’s developer experience, which is valuable. But it highlights an interesting contrast. React optimizes Virtual DOM re-renders, while alternatives like SolidStart eliminate re-renders entirely through fine-grained reactivity. SvelteKit’s compiler eliminates much of the runtime overhead at build time. Qwik eliminates hydration cost through resumability.</p>
<p>The difference in philosophy is clear. React’s compiler optimizes the existing model. The alternatives questioned the model itself.</p>
<h2 id="the-web-is-the-last-commons-why-this-matters-beyond-frameworks">The Web is the Last Commons: Why This Matters Beyond Frameworks</h2>
<p>Here’s where this gets bigger than framework choice. When you ship a native app to the App Store or Google Play instead of building a web app, you’re not just making a technical decision. You’re accepting a deal that would’ve been unthinkable twenty years ago. Apple and Google each take up to 30% of every transaction (with exceptions depending on program and category). They set rules. They decide what you can ship. They can revoke your access tomorrow with no recourse. You have no alternative market. You can’t even compete on price because the fee is baked into many transactions.</p>
<p>Economist Yanis Varoufakis calls this “technofeudalism” in his book of the same name. The App Store isn’t a marketplace, it’s a fiefdom. Developers are digital serfs, bound to the cloud lords’ land (their platforms) with no exit. Users get locked into this too. The App Store is a curated garden where algorithms owned by two companies decide what you see. Your data gets harvested. Your choices get filtered. You’re not a customer with alternatives, you’re a subject in a walled garden.</p>
<p>The web? The web is different. No single company takes a cut. No algorithm curates your choices. Distribution is direct. Users can actually vote with their feet. It’s not perfect, but it’s the closest thing we have left to an open market where developers retain agency and users retain choice.</p>
<p>When companies abandon the web to go app-only, they’re not making a neutral technical decision. They’re voluntarily moving their users from a competitive marketplace into a feudal system. And yeah, I know that sounds dramatic, but Varoufakis has spent years documenting how the economics of digital platforms have created exactly this dynamic.</p>
<p><strong>Why you should care, no matter what you believe:</strong></p>
<p>If you lean capitalist, app stores create an environment that is the opposite of what capitalism is supposed to be. Monopolistic rent extraction replacing competition and innovation. No market mechanism to challenge them. That’s not capitalism, that’s just extraction.</p>
<p>If you lean anti-capitalist, technofeudalism is arguably worse than regular capitalism because at least capitalism has friction and regulatory handles. This has neither. It’s total private control with zero market competition.</p>
<p>Either way, the web is the last place where economic activity can happen outside the thumb of tech oligarchs. Building web apps matters. Shipping small, fast, performant web apps matters even more, and most web traffic comes from the mobile web. Every kilobyte you save is another reason for teams to choose the web over building a native app subject to app store control and fees.</p>
<h2 id="conclusion-what-this-evaluation-revealed">Conclusion: What This Evaluation Revealed</h2>
<p>What started as a simple framework comparison for an upcoming work project turned into something more revealing. The data shows clearly what’s possible when frameworks prioritize mobile web performance from the start.</p>
<p>The evaluation revealed what happens when you rethink fundamentals. SolidStart, SvelteKit, Qwik, and Marko represent different architectural priorities that push boundaries in ways the dominant frameworks cannot. Competition drives innovation. These alternatives show what’s achievable when mobile web performance is the primary design constraint, not an afterthought.</p>
<p>For teams serving mobile professionals on cellular networks (like ours), these costs are paid on every visit. React and Angular often face architectural performance ceilings. Vue proved that established frameworks can compete when properly configured. And remember, these measurements represent initial page loads. MPA frameworks maintain their lean profile across routes, while SPAs add route chunks to their baseline.</p>
<p>For anyone starting a new project, the evaluation raises an important question: <strong>Is there any reason to make your app 25.9x heavier than necessary?</strong> (And that’s before adding the authentication, analytics, and third party libraries that typically multiply production bundle sizes 5 to 10 times, making the real world gap even larger.) Building an app that works well on mobile isn’t difficult if you make good architectural decisions at the beginning. The right choice early on means your app performs well everywhere, not just on desktop WiFi. Choose MPA frameworks for the leanest per page bundles, or lightweight SPAs for excellent performance with familiar patterns.</p>
<p>Here’s what the evaluation made clear: <strong>if you want to build a better product than your competitors, why would you build exactly like them?</strong> When everyone uses Next.js, winning on performance requires fighting React’s architecture. When you use Marko, SolidStart, SvelteKit, or Nuxt instead, the advantage comes easily. Your app is faster by default. Your bundle is smaller without optimization work. Your users get a better experience without extra effort. That’s not just good engineering. That’s differentiation.</p>
<p>When you pick Marko and ship 28.8 kB instead of Next.js at 176.3 kB, you’re not just making your users’ experience better on cellular networks. You’re making the web more competitive. You’re making it a more attractive place for companies to exist. You’re pushing back against the gravity that pulls everything toward native only distribution.</p>
<h2 id="reproducing-these-results">Reproducing These Results</h2>
<p>All measurements in this comparison follow a rigorous statistical methodology designed for reproducibility and defensibility. Each framework was measured 10 times per page using Chrome Lighthouse with mobile emulation (Pixel 5, 4G throttling, 1x CPU). Server warmup requests stabilize performance before measurements. IQR (Interquartile Range) outlier removal ensures robust statistics. Browser cache was cleared between runs to measure cold-load performance that simulates first-visit experience. I report median values to reduce the impact of outliers, and standard deviations quantify measurement reliability. The complete methodology including statistical approach, test environment details, compression detection, known limitations, and reproducibility instructions is documented at <a href="https://github.com/lorenseanstewart/kanban-comparison/blob/main/METHODOLOGY.md">METHODOLOGY.md</a>.</p>
<h2 id="call-to-action">Call to Action</h2>
<p><strong>Try it yourself</strong>: Clone the <a href="https://github.com/lorenseanstewart/kanban-comparison">repository</a>, build all ten implementations, and test them on a throttled 3G connection in Chrome DevTools. When mobile web is your only option, the numbers tell a clear story.</p>
<p><strong>On a less serious note</strong>: You can take a look at all ten apps to examine how the code looks and get a general feel for each framework. I advocate coding for fun, and the code in the repo might be a great place to help you try something new.</p>
<p><strong>Share your experience</strong>: Have you tried Marko, SolidStart, SvelteKit, Qwik, or Nuxt? What framework would you choose for a mobile-first project and why? I’d love to hear your thoughts on Twitter or Bluesky.</p>
<p><strong>Keep exploring</strong>: The full metrics data and measurement methodology are available in the repository for you to verify, reproduce, or extend. Build your own comparison and share your findings.</p>
<p>The real winner? You. Your team. Your users. When you start your next project with Marko, SolidStart, or SvelteKit, you’ll ship faster, smaller, and with less framework overhead. That’s a real competitive advantage.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>A huge thanks to everyone who helped with this evaluation.</p>
<p><strong>Early draft reviewers</strong>: <a href="https://bsky.app/profile/infrequently.org">Alex Russell</a> and <a href="https://x.com/dylan_piercey">Dylan Piercey</a> provided invaluable feedback on the post structure and arguments.</p>
<p><strong>Framework-specific reviews</strong>:</p>
<ul>
<li><strong>Marko</strong>: <a href="https://x.com/dylan_piercey">Dylan Piercey</a> for reviewing the implementation</li>
<li><strong>Qwik</strong>: <a href="https://x.com/wmertens">Wout Mertens</a> for reviewing the Qwik implementation</li>
<li><strong>Analog</strong>: <a href="https://x.com/brandontroberts">Brandon Roberts</a> for his review</li>
<li><strong>Solid/SolidStart</strong>: <a href="https://github.com/madaxen86">Martin Rapp</a>, <a href="https://x.com/RyanCarniato">Ryan Carniato</a>, and <a href="https://x.com/AtilaFassina">Atila Fassina</a> for their assistance</li>
<li><strong>Next.js</strong>: <a href="https://github.com/SunnyMan617">Sunny_man</a> for reviewing the Next code</li>
<li><strong>Svelte/SvelteKit</strong>: The helpful folks in the Svelte Discord, especially <a href="https://x.com/kevmodrome">Kevin Åberg Kultalahti</a>, <a href="https://x.com/dummdidumm_">Simon H</a>, and <a href="https://x.com/benmccann">Ben McCann</a></li>
<li><strong>TanStack</strong>: <a href="https://x.com/schanuelmiller">Manuel Schiller</a> and <a href="https://x.com/brenelz">Brenley Dueck</a> for help with the TanStack apps</li>
</ul>
<p>Your contributions made this post more accurate and comprehensive. Thank you!</p> </div>  </article>  </div> </div> </div></div>
  </body>
</html>
