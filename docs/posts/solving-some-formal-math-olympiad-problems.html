<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openai.com/blog/formal-math/">Original</a>
    <h1>Solving some formal math olympiad problems</h1>
    
    <div id="readability-page-1" class="page"><article id="post-formal-math">

  

  <section>
  <div>
    <section>
      
      
      <!--kg-card-begin: markdown--><p>We built a neural theorem prover for <a href="https://leanprover.github.io/">Lean</a> that learned to solve a variety of challenging high-school olympiad problems, including problems from the <a href="https://www.maa.org/math-competitions/amc-1012">AMC12</a> and <a href="https://www.maa.org/math-competitions/invitational-competitions">AIME</a> competitions, as well as two problems adapted from the <a href="https://www.imo-official.org/">IMO</a>. The prover uses a language model to find proofs of formal statements. Each time we find a new proof, we use it as new training data, which improves the neural network and enables it to iteratively find solutions to harder and harder statements.</p>
<section><a href="https://cdn.openai.com/papers/Formal_Mathematics_Statement_Curriculum_Learning__ICML_2022.pdf">Read Paper</a></section>
<p>We achieved a new state-of-the-art (41.2% vs 29.3%) on the <a href="https://arxiv.org/abs/2109.00110">miniF2F</a> benchmark, a challenging collection of high-school olympiad problems. Our approach, which we call <em>statement curriculum learning</em>, consists of manually collecting a set of statements of varying difficulty levels (without proof) where the hardest statements are similar to the benchmark we target. Initially our neural prover is weak and can only prove a few of them. We iteratively search for new proofs and re-train our neural network on the newly discovered proofs, and after 8 iterations, our prover ends up being vastly superior when tested on miniF2F.</p>
<p>Formal mathematics is an exciting domain to study because of (i) its richness, letting you prove arbitrary theorems which require reasoning, creativity and insight and (ii) its similarity to games—where AI has been spectacularly successful—in that it has an automated way of determining whether a proof is successful (i.e., verified by the formal system). As demonstrated in the trivial example below, proving a formal statement requires generating a sequence of proof steps, each proof step consisting in a call to a tactic. These tactics take mathematical terms as arguments and each tactic call will transform the current statement to prove, into statements that are easier to prove, until nothing is left to prove.</p>
<div data-id="0">
<div><p>Problem 1</p>
<p>Adapted from AMC12 2000 Problem 5</p><p>
Prove that if $|x - 2| = p$, where $x &lt; 2$, then $x - p = 2 - 2p$.
</p></div><!-- end informal statement  -->

<div id="formal-0">
<pre><code><span>theorem</span> <span>amc12_2000_p5</span>      
  (x p : ℝ)                
  (h₀ : x &lt; 2)             
  (h₁ : abs (x - 2) = p) :
  x - p = 2 - 2 * p :=
<span>begin</span>                      
  
  
  <span><span>have h₂ : abs (x - 2) = -(x - 2), {</span></span>
    <span>apply abs_of_neg,</span>
    <span>linarith,</span>
  <span>},</span>
  <span>rw h₁ at h₂,</span>
  
  
  <span>linarith,</span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<p>We observe that the capability to generate original mathematical terms required as arguments of tactics, which cannot be done without a neural language model, emerges from our training procedure. The proof below is an example of it: the proof step <code>use n + 1</code> (entirely generated by our models) proposes to use <code>n + 1</code> as a solution, the rest of the formal proof relying on the <a href="https://leanprover-community.github.io/mathlib_docs/tactic/ring_exp.html"><code>ring_exp</code></a> tactic to verify that it is indeed valid.</p>
<div data-id="1">
<div><p>Problem 2</p>
<p>Adapted from AMC12B 2020 Problem 6</p><p>
For all integers $n ≥ 9$, prove that $((n + 2)! −(n + 1)!) / n!$ is a perfect square.
</p></div><!-- end informal statement  -->

<div id="formal-1">
<pre><code><span>theorem</span> <span>amc12b_2020_p6</span>
  (n : ℕ)
  (h0 : 9 ≤ n) :
  ∃ x : ℕ, (x:ℝ)^2 = 
    (nat.factorial (n + 2) - nat.factorial (n + 1))
    / nat.factorial n :=
<span>begin</span>
  
  <span><span>use n + 1,</span></span>
  <span>field_simp [nat.factorial_ne_zero, pow_succ&#39;],</span>
  <span>ring_exp</span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<p>We also observe that our models and search procedure are capable of producing proofs that chain multiple non-trivial reasoning steps. In the proof below, the model starts by using contraposition leading to the existential statement (<code>∃ (x : ℝ), f x ≠ a * x + b</code>). It then generates a witness for it with <code>use (0 : ℝ)</code> and finishes the proof by leveraging the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_num"><code>norm_num</code></a> tactic.</p>
<div data-id="2">
<div><p>Problem 3</p>
<p>Adapted from the MATH dataset</p><p>
Let $f(x) = Ax + B$ and $g(x) = Bx + A$, where $A \ne B$. If $f(g(x)) - g(f(x)) = B - A$, prove that $A + B = 0$.
</p></div><!-- end informal statement  -->

<div id="formal-2">
<pre><code><span>theorem</span> <span>mathd_train_algebra_217</span>
  (a b : ℝ)
  (f g : ℝ → ℝ)
  (h₀ : ∀ x, f x = a * x + b)
  (h₁ : ∀ x, f x = b * x + a)
  (h₂ : a ≠ b)
  (h₃ : ∀ x, f (g x) - g (f x) = b - a) :
  a + b = 0 :=
<span>begin</span>
  <span>revert h₀ h₁ h₂ h₃,</span>
  
  <span><span>contrapose!,</span></span>
  <span>rintro ⟨h₀, ⟨h₁, h₂⟩⟩,</span>
  
  
  <span><span>use (0 : ℝ),</span></span>
  <span>simp only [sub_eq_iff_eq_add, h₀, mul_zero, zero_add],</span>
  <span>norm_num at h₀,</span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<p>Our models, trained with <em>statement curriculum learning</em>, were able to close a variety of problems from training textbooks as well as <a href="https://www.maa.org/math-competitions/amc-1012">AMC12</a> and <a href="https://www.maa.org/math-competitions/invitational-competitions">AIME</a> competitions, and 2 problems adapted from the <a href="https://www.imo-official.org/">IMO</a>. We present below three examples of such generated proofs.</p>
<div data-id="3">
<div><p>Problem 4</p>
<p>Adapted from IMO 1964 Problem 2</p><p>
Suppose $a$, $b$, $c$ are the sides of a triangle.
Prove that $a^2(b + c − a) + b^2(c + a − b) + c^2(a + b − c) \leq 3abc$.
</p></div><!-- end informal statement -->

<div id="formal-3">
<pre><code><span>theorem</span> <span>imo_1964_p2</span>
  (a b c : ℝ)
  (h₀ : 0 &lt; a ∧ 0 &lt; b ∧ 0 &lt; c)
  (h₁ : c &lt; a + b)
  (h₂ : b &lt; a + c)
  (h₃ : a &lt; b + c) :
  a^2 * (b + c - a) + b^2 * (c + a - b) + c^2 * (a + b - c) 
    ≤ 3 * a * b * c :=
<span>begin</span>
  
  <span><span>nlinarith [sq_nonneg (b - a),</span></span>
             <span><span>sq_nonneg (c - b),</span></span>
             <span><span>sq_nonneg (c - a)]</span></span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<div data-id="4">
<div><p>Problem 5</p>
<p>Adapted from AIME 1984 Problem 1</p><p>
Prove that $a2 + a4 + a6 + a8 + ...+ a98 = 93$ if $a1$, $a2$, $a3...$ is an arithmetic progression with common difference $1$, and $a1 + a2 + a3 + ... + a98 = 137$.
</p></div><!-- end informal statement -->

<div id="formal-4">
<pre><code><span>theorem</span> <span>aime_1984_p1</span>
  (u : ℕ → ℚ)
  (h₀ : ∀ n, u (n + 1) = u n + 1)
  (h₁ : ∑ k in finset.range 98, u k.succ = 137) :
  ∑ k in finset.range 49, u (2 * k.succ) = 93 :=
<span>begin</span>
  <span>rw finset.sum_eq_multiset_sum,</span>
  <span>dsimp [finset.range] at h₁,</span>
  <span>simp [h₀],</span>
  <span>ring,</span>
  <span>norm_num at h₁,</span>
  <span>norm_num,</span>
  <span>apply eq_of_sub_eq_zero,</span>
  <span>{ simp only [*, abs_of_pos, add_zero] at *, linarith },</span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<div data-id="5">
<div><p>Problem 6</p>
<p><span>Adapted from IMO Longlist 1990 Problem 77</span></p>
</div><!-- end informal statement -->

<div id="formal-5">
<pre><code><span>theorem</span> <span>imo_longlist_1990_p77</span>
  (a b c : ℝ) :
  (a * b + b * c + c * a)^3 ≤
    (a^2 + a * b + b^2) * (b^2 + b * c + c^2) *
    (c^2 + c * a + a^2) :=
<span>begin</span>
  
  
  
  <span>let u : euclidean_space ℝ (fin 2) := ![a, b],</span>
  <span>let v : euclidean_space ℝ (fin 2) := ![b, c],</span>
  <span><span>have h₀ := real_inner_mul_inner_self_le u v,</span></span>
  <span>simp [u, v, fin.sum_univ_succ, </span>
        <span>←pow_two, ←pow_two, le_of_lt, mul_assoc] at h₀,</span>
  
  
  <span><span>have h₃ : 0 ≤ (c + a) * (c + a),</span></span>
  <span>{ nlinarith, },</span>
  <span>have h₄ := sq_nonneg (a * b + b * c + c * a),</span>
  <span>simp [sq, h₀, h₃, mul_add, add_mul] at h₄ ⊢,</span>
  <span>nlinarith [sq_nonneg (b - a),</span>
             <span>sq_nonneg (c - b),</span>
             <span>sq_nonneg (a - c)]</span>
<span>end</span>
</code></pre>
</div><!-- end formal -->
<!-- end informal -->
</div><!-- end proof -->
<p>Formal mathematics involves two main challenges that make a naive application of reinforcement learning unlikely to succeed.</p>
<ul>
<li>(i) <strong>Infinite action space</strong>: not only does formal mathematics have an extremely large search space (like Go for example), it also has an infinite action space. At each step of a proof search, the model must choose not from a well-behaved finite set of actions, but a complex and infinite set of tactics, involving exogenous mathematical terms that have to be generated (e.g., generating a mathematical statement to be used as a witness, an object used in steps such as &#34;there exists an $x$ s.t. …&#34;, or a cut, the introduction and the chaining of a lemma in the middle of a proof).</li>
<li>(ii) <strong>Lack of self-play</strong>: conversely to 2-player games, a prover is not playing against an opponent but against a set of statements to prove. When faced with a statement that is just too hard, there is no obvious reframing that will let the prover generate intermediary easier statements to tackle first. This asymmetry prevents naive application of the self-play algorithms that were successful with 2-player games.</li>
</ul>
<p>In our work, we address the infinite action space problem by sampling actions from a language model as we search for a proof. Language models have the capability to generate the tactic calls as well as the original mathematical terms often required as arguments. Our basis for addressing the lack of self-play is the observation that the key role of self-play in 2-player games is to provide an unsupervised curriculum. Our methodology proposes to replace this unsupervised curriculum with an auxiliary set of problem statements (without requiring proofs) of varying difficulty. We empirically show that, when the difficulty of these auxiliary problems is varied enough, our training procedure is able to solve a curriculum of increasingly difficult problems, eventually generalizing to the set of problems we care about.</p>
<p>While these results are extremely exciting, as they demonstrate that deep learning models are capable of non-trivial mathematical reasoning when interacting with a formal system, we are still very far from best-student performance on these competitions, only occasionally, rather than consistently, closing challenging olympiad problems. We hope nonetheless that our work will motivate research in this domain, in particular towards the <a href="https://imo-grand-challenge.github.io/">IMO Grand Challenge</a> and that the <em>statement curriculum learning</em> methodology we propose will help accelerate progress in automated reasoning in general.</p>


</section>
  </div>
</section>
  






</article></div>
  </body>
</html>
