<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zackoverflow.dev/writing/how-often-does-python-allocate/">Original</a>
    <h1>How often does Python allocate?</h1>
    
    <div id="readability-page-1" class="page"><div>
			<article>
				
                <span>10/30/2025</span>
				
				<!-- {pubDate && <time>{pubDate.toString()}</time>} -->
				
				
	
	<p>The answer is &#34;very often&#34;</p>
	<hr/>
	<p>I recently saw this <a href="https://x.com/LukasHozda/status/1983544977037627673">tweet</a> which I thought was funny:</p>
<p><img src="https://zackoverflow.dev/img/python-allocation-tweet.png" alt="Python allocating tweet"/></p>
<p>How true is it?</p>
<p>I was surprised to learn that CPython represents each integer in a heap
allocated <code>PyLongObject*</code>.</p>
<p>Does that mean Python heap allocates <i>every</i> integer you create? Integers
are likely the most used data type of any program, that means a lot of
heap allocations.</p>
<p>Beyond heap allocations, this could just make basic arithmetic operations like
adding two numbers 200-500x slower<sup><a id="footnote-ref-1" href="#footnote-1">1</a></sup>.</p>
<p>Or maybe it uses the well-known, industry standard <a href="https://en.wikipedia.org/wiki/Tagged_pointer">pointer tagging</a> technique to avoid
allocating small integers?</p>
<p>To figure out I modified CPython to print when it allocates a <code>PyLongObject*</code>:</p>
<pre tabindex="0"><code><span><span>static</span><span> PyLongObject </span><span>*</span></span>
<span><span>long_alloc</span><span>(</span><span>Py_ssize_t</span><span> </span><span>size</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>assert</span><span>(</span><span>size </span><span>&gt;=</span><span> </span><span>0</span><span>);</span></span>
<span><span>    PyLongObject </span><span>*</span><span>result </span><span>=</span><span> </span><span>NULL;</span></span>
<span></span>
<span><span>    /* ... */</span></span>
<span></span>
<span><span>    </span><span>Py_ssize_t</span><span> ndigits </span><span>=</span><span> size </span><span>?</span><span> size </span><span>:</span><span> </span><span>1</span><span>;</span></span>
<span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>ndigits </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span></span>
<span><span>        result </span><span>=</span><span> </span><span>(</span><span>PyLongObject </span><span>*)</span><span>_Py_FREELIST_POP</span><span>(</span><span>PyLongObject</span><span>,</span><span> ints</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>result </span><span>==</span><span> </span><span>NULL)</span><span> </span><span>{</span></span>
<span><span>        </span><span>printf</span><span>(</span><span>&#34;</span><span>ALLOCATING a new number object</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>        </span></span>
<span><span>        result </span><span>=</span><span> </span><span>PyObject_Malloc</span><span>(</span><span>offsetof</span><span>(</span><span>PyLongObject</span><span>,</span><span> </span><span>long_value</span><span>.</span><span>ob_digit</span><span>)</span><span> </span><span>+</span></span>
<span><span>                                ndigits</span><span>*sizeof(</span><span>digit</span><span>));</span></span>
<span><span>        </span><span>if</span><span> </span><span>(!</span><span>result</span><span>)</span><span> </span><span>{</span></span>
<span><span>            </span><span>PyErr_NoMemory</span><span>();</span></span>
<span><span>            </span><span>return</span><span> </span><span>NULL;</span></span>
<span><span>        </span><span>}</span></span>
<span><span>        </span><span>_PyObject_Init</span><span>((</span><span>PyObject</span><span>*)</span><span>result</span><span>,</span><span> </span><span>&amp;</span><span>PyLong_Type</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    /* ...omitted code... */</span></span>
<span><span>    </span><span>return</span><span> result</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>And wrote a script to add some numbers 100k times:</p>
<pre tabindex="0"><code><span><span># lol.py</span></span>
<span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(</span><span>0</span><span>,</span><span> </span><span>100_000</span><span>):</span></span>
<span><span>  </span><span>print</span><span>(</span><span>i </span><span>+</span><span> </span><span>1</span><span>)</span></span>
<span></span></code></pre>
<p>And then counted the number of times it allocated:</p>
<pre tabindex="0"><code><span><span>echo</span><span> </span><span>&#34;</span><span>Allocating number object </span><span>$(</span></span>
<span><span>    </span><span>./python.exe</span><span> lol.py </span><span>\</span></span>
<span><span>    </span><span>|</span><span> </span><span>rg</span><span> -o ALLOCATING </span><span>\</span></span>
<span><span>    </span><span>|</span><span> </span><span>wc</span><span> -l</span></span>
<span><span>)</span><span> times</span><span>&#34;</span></span>
<span></span></code></pre>
<pre tabindex="0"><code><span><span>Allocating number object 100904 times</span></span>
<span><span></span></span></code></pre>
<p>Huh, that seems like a lot!</p>
<p>It looks like it could be allocating once per each iteration in the loop.</p>
<p>Let’s take out the <code>print</code> statement and see if it’s just the addition:</p>
<pre tabindex="0"><code><span><span># lol.py</span></span>
<span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(</span><span>0</span><span>,</span><span> </span><span>100_000</span><span>):</span></span>
<span><span>  a </span><span>=</span><span> i </span><span>+</span><span> </span><span>1</span></span>
<span></span></code></pre>
<pre tabindex="0"><code><span><span>echo</span><span> </span><span>&#34;</span><span>Allocating number object </span><span>$(</span></span>
<span><span>    </span><span>./python.exe</span><span> lol.py </span><span>\</span></span>
<span><span>    </span><span>|</span><span> </span><span>rg</span><span> -o ALLOCATING </span><span>\</span></span>
<span><span>    </span><span>|</span><span> </span><span>wc</span><span> -l</span></span>
<span><span>)</span><span> times</span><span>&#34;</span></span>
<span></span>
<span></span></code></pre>
<pre tabindex="0"><code><span><span>Allocating number object 905 times</span></span>
<span><span></span></span></code></pre>
<p>That’s almost 100k less, so it <i>does</i> look like it’s the printing and CPython has
some optimization in place to avoid allocations for addition.</p>
<p>Let’s look at the internal function to add two integers, <code>long_add(a, b)</code>.</p>
<p>Just by looking at its signature, the return type is <code>PyLongObject*</code>, which <i>could</i>
mean that it’s allocating a new object everytime you add two integers:</p>
<pre tabindex="0"><code><span><span>static</span><span> PyLongObject </span><span>*</span></span>
<span><span>long_add</span><span>(</span><span>PyLongObject </span><span>*</span><span>a</span><span>,</span><span> PyLongObject </span><span>*</span><span>b</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>// An integer is &#34;compact&#34; if it is &lt;= 2^30</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>_PyLong_BothAreCompact</span><span>(</span><span>a</span><span>,</span><span> b</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>// Unwrap the values of `a` and `b` and add them</span></span>
<span><span>        stwodigits z </span><span>=</span><span> </span><span>medium_value</span><span>(</span><span>a</span><span>)</span><span> </span><span>+</span><span> </span><span>medium_value</span><span>(</span><span>b</span><span>);</span></span>
<span><span>        </span><span>return</span><span> </span><span>_PyLong_FromSTwoDigits</span><span>(</span><span>z</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span></span>
<span><span>    /* ... more code ... */</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>The <code>_PyLong_BothAreCompact(...)</code> function checks a bitfield on <code>PyLongObject</code> to
check if it’s “compact” (the integer value can fit in 63 bits) which will always
be the case for our script.</p>
<p>The code appears to be unwrapping the integer values for <code>a</code> and <code>b</code>, which are
represented inside of <code>PyLongObject</code> structs, and adding them together.</p>
<p>The reason the result of adding them together has the type <code>stwodigits</code> is because
<code>PyLongObject</code> stores the number in base 2<sup>30</sup>, essentially each digit is a 30bit
integer.</p>
<p>Let’s look at <code>_PyLong_FromSTwoDigits</code>:</p>
<pre tabindex="0"><code><span><span>/* Create a new int object from a C word-sized int */</span></span>
<span><span>static</span><span> </span><span>inline</span><span> PyLongObject </span><span>*</span></span>
<span><span>_PyLong_FromSTwoDigits</span><span>(</span><span>stwodigits </span><span>x</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>IS_SMALL_INT</span><span>(</span><span>x</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>return</span><span> </span><span>(</span><span>PyLongObject</span><span>*)</span><span>get_small_int</span><span>((</span><span>sdigit</span><span>)</span><span>x</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span><span>assert</span><span>(</span><span>x </span><span>!=</span><span> </span><span>0</span><span>);</span></span>
<span><span>    /* check that it is &lt;= 2^(32-1) */</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>is_medium_int</span><span>(</span><span>x</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>return</span><span> </span><span>(</span><span>PyLongObject</span><span>*)</span><span>_PyLong_FromMedium</span><span>((</span><span>sdigit</span><span>)</span><span>x</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span><span>return</span><span> </span><span>(</span><span>PyLongObject</span><span>*)</span><span>_PyLong_FromLarge</span><span>(</span><span>x</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>There’s three separate code paths:</p>
<ol>
<li>
<p>when <code>x</code> is a “small int”: call <code>get_small_int(x)</code>.</p>
</li>
<li>
<p>when <code>x</code> is a “medium int”: call <code>_PyLong_FromMedium(x)</code>.</p>
</li>
<li>
<p>when <code>x</code> is a “large int”: call <code>_PyLong_FromLarge(x)</code>.</p>
</li>
</ol>
<p>The call to <code>get_small_int()</code> is catching my eye. Is it like the tagged pointer
trick I mentioned earlier?</p>
<pre tabindex="0"><code><span><span>static</span><span> PyObject </span><span>*</span></span>
<span><span>get_small_int</span><span>(</span><span>sdigit </span><span>ival</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>assert</span><span>(</span><span>IS_SMALL_INT</span><span>(</span><span>ival</span><span>));</span></span>
<span><span>    </span><span>return</span><span> </span><span>(</span><span>PyObject </span><span>*)&amp;</span><span>_PyLong_SMALL_INTS</span><span>[</span><span>_PY_NSMALLNEGINTS </span><span>+</span><span> ival</span><span>];</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Nope, it seems there is a pre-allocated list of objects for integers in the
range of <code>-5 -&gt; 1025</code><sup><a id="footnote-ref-2" href="#footnote-2">2</a></sup>. This would account for 1025 iterations of our loop but
not for the rest.</p>
<p>Let’s look at the medium case (meaning <code>x</code> is less than 2<sup>32-1</sup>) and the
<code>_PyLong_FromMedium()</code> function:</p>
<pre tabindex="0"><code><span><span>static</span><span> PyObject </span><span>*</span></span>
<span><span>_PyLong_FromMedium</span><span>(</span><span>sdigit </span><span>x</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>assert</span><span>(!</span><span>IS_SMALL_INT</span><span>(</span><span>x</span><span>));</span></span>
<span><span>    </span><span>assert</span><span>(</span><span>is_medium_int</span><span>(</span><span>x</span><span>));</span></span>
<span></span>
<span><span>    PyLongObject </span><span>*</span><span>v </span><span>=</span><span> </span><span>(</span><span>PyLongObject </span><span>*)</span><span>_Py_FREELIST_POP</span><span>(</span><span>PyLongObject</span><span>,</span><span> ints</span><span>);</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>v </span><span>==</span><span> </span><span>NULL)</span><span> </span><span>{</span></span>
<span><span>        v </span><span>=</span><span> </span><span>PyObject_Malloc</span><span>(sizeof(</span><span>PyLongObject</span><span>));</span></span>
<span><span>        </span><span>if</span><span> </span><span>(</span><span>v </span><span>==</span><span> </span><span>NULL)</span><span> </span><span>{</span></span>
<span><span>            </span><span>PyErr_NoMemory</span><span>();</span></span>
<span><span>            </span><span>return</span><span> </span><span>NULL;</span></span>
<span><span>        </span><span>}</span></span>
<span><span>        </span><span>_PyObject_Init</span><span>((</span><span>PyObject</span><span>*)</span><span>v</span><span>,</span><span> </span><span>&amp;</span><span>PyLong_Type</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    digit abs_x </span><span>=</span><span> x </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>?</span><span> </span><span>-</span><span>x </span><span>:</span><span> x</span><span>;</span></span>
<span><span>    </span><span>_PyLong_SetSignAndDigitCount</span><span>(</span><span>v</span><span>,</span><span> x</span><span>&lt;</span><span>0</span><span>?-</span><span>1</span><span>:</span><span>1</span><span>,</span><span> </span><span>1</span><span>);</span></span>
<span><span>    </span><span>v</span><span>-&gt;</span><span>long_value</span><span>.</span><span>ob_digit</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> abs_x</span><span>;</span></span>
<span><span>    </span><span>return</span><span> </span><span>(</span><span>PyObject</span><span>*)</span><span>v</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Okay, it seems to <i>not</i> be using the <code>long_alloc()</code> function from earlier and
instead trying to get a <code>PyLongObject*</code> from a freelist (using
<code>_Py_FREELIST_POP()</code>), or otherwise allocating the memory for it if that fails.</p>
<p>A “freelist” is a common technique used in memory allocation strategies to keep
track of freed allocations so they can be reused later, avoiding allocating more
memory if possible.</p>
<p>If we look at the <code>long_dealloc()</code> function, there’s a codepath specifically for
pushing the allocation to the freelist and <i>not</i> calling free on it so it can be
reused:</p>
<pre tabindex="0"><code><span><span>static</span><span> </span><span>void</span></span>
<span><span>long_dealloc</span><span>(</span><span>PyObject </span><span>*</span><span>self</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    /* ... */</span></span>
<span><span>       </span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>PyLong_CheckExact</span><span>(</span><span>self</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>_PyLong_IsCompact</span><span>((</span><span>PyLongObject </span><span>*)</span><span>self</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>_Py_FREELIST_FREE</span><span>(</span><span>ints</span><span>,</span><span> self</span><span>,</span><span> PyObject_Free</span><span>);</span></span>
<span><span>        </span><span>return</span><span>;</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span><span>Py_TYPE</span><span>(</span><span>self</span><span>)-&gt;</span><span>tp_free</span><span>(</span><span>self</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>I deleted the <code>printf()</code> I added to <code>long_alloc()</code> earlier, and added two print
statements to <code>_PyLong_FromMedium()</code> to print if it allocated or reused memory:</p>
<pre tabindex="0"><code><span><span>&gt;</span><span> ./python.exe lol.py </span><span>|</span><span> </span><span>rg</span><span> </span><span>&#39;</span><span>ALLOCATING|REUSING</span><span>&#39;</span><span> </span><span>|</span><span> </span><span>sort</span><span> </span><span>|</span><span> </span><span>uniq</span><span> </span><span>-c</span></span>
<span></span></code></pre>
<pre tabindex="0"><code><span><span>  102 ALLOCATING</span></span>
<span><span>99193 REUSING</span></span>
<span><span></span></span></code></pre>
<p>Our script appears to actually be <i>reusing</i> most of the <code>PyLongObject</code> objects!</p>
<p>So where did the allocation come from when our script was <code>print()</code>’ing the
integers? It turns out the implemention of <code>print()</code> allocates a scratch
<code>PyLongObject*</code> for conversion purposes, even though this can be avoided in most
cases<sup><a id="footnote-ref-3" href="#footnote-3">3</a></sup>.</p>

It’s nice to see that simply adding two numbers in a loop does not allocate
memory everytime.
<p>We just saw an optimization to reduce the <i>frequency</i> of allocations (by reusing
them), but I also want to poke around and see if Python is doing anything to
amortize the actual <i>cost</i> of an allocation.</p>
<p>Here’s the internal allocation function used for objects:</p>
<pre tabindex="0"><code><span><span>static</span><span> </span><span>inline</span><span> </span><span>void</span><span>*</span></span>
<span><span>pymalloc_alloc</span><span>(</span><span>OMState </span><span>*</span><span>state</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>Py_UNUSED</span><span>(</span><span>ctx</span><span>),</span><span> </span><span>size_t</span><span> </span><span>nbytes</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>UNLIKELY</span><span>(</span><span>nbytes </span><span>==</span><span> </span><span>0</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>return</span><span> </span><span>NULL;</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>UNLIKELY</span><span>(</span><span>nbytes </span><span>&gt;</span><span> SMALL_REQUEST_THRESHOLD</span><span>))</span><span> </span><span>{</span></span>
<span><span>        </span><span>return</span><span> </span><span>NULL;</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    </span><span>uint</span><span> size </span><span>=</span><span> </span><span>(</span><span>uint</span><span>)(</span><span>nbytes </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>&gt;&gt;</span><span> ALIGNMENT_SHIFT</span><span>;</span></span>
<span><span>    poolp pool </span><span>=</span><span> </span><span>usedpools</span><span>[</span><span>size </span><span>+</span><span> size</span><span>];</span></span>
<span><span>    pymem_block </span><span>*</span><span>bp</span><span>;</span></span>
<span></span>
<span><span>    </span><span>if</span><span> </span><span>(</span><span>LIKELY</span><span>(</span><span>pool </span><span>!=</span><span> </span><span>pool</span><span>-&gt;</span><span>nextpool</span><span>))</span><span> </span><span>{</span></span>
<span><span>        /*</span></span>
<span><span>         * There is a used pool for this size class.</span></span>
<span><span>         * Pick up the head block of its free list.</span></span>
<span><span>         */</span></span>
<span><span>        </span><span>++</span><span>pool</span><span>-&gt;</span><span>ref</span><span>.</span><span>count</span><span>;</span></span>
<span><span>        bp </span><span>=</span><span> </span><span>pool</span><span>-&gt;</span><span>freeblock</span><span>;</span></span>
<span><span>        </span><span>assert</span><span>(</span><span>bp </span><span>!=</span><span> </span><span>NULL);</span></span>
<span></span>
<span><span>        </span><span>if</span><span> </span><span>(</span><span>UNLIKELY</span><span>((</span><span>pool</span><span>-&gt;</span><span>freeblock</span><span> </span><span>=</span><span> </span><span>*(</span><span>pymem_block </span><span>**)</span><span>bp</span><span>)</span><span> </span><span>==</span><span> </span><span>NULL))</span><span> </span><span>{</span></span>
<span><span>            </span><span>// Reached the end of the free list, try to extend it.</span></span>
<span><span>            </span><span>pymalloc_pool_extend</span><span>(</span><span>pool</span><span>,</span><span> size</span><span>);</span></span>
<span><span>        </span><span>}</span></span>
<span><span>    </span><span>}</span></span>
<span><span>    </span><span>else</span><span> </span><span>{</span></span>
<span><span>        /* There isn&#39;t a pool of the right size class immediately</span></span>
<span><span>         * available:  use a free pool.</span></span>
<span><span>         */</span></span>
<span><span>        bp </span><span>=</span><span> </span><span>allocate_from_new_pool</span><span>(</span><span>state</span><span>,</span><span> size</span><span>);</span></span>
<span><span>    </span><span>}</span></span>
<span></span>
<span><span>    </span><span>return</span><span> </span><span>(</span><span>void</span><span> </span><span>*)</span><span>bp</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>It looks like the memory allocator for objects is a <a href="https://www.gingerbill.org/article/2019/02/16/memory-allocation-strategies-004/">pool allocator</a> with multiple
different pools based on the size of the object.</p>
<p>The pool allocator splits its backing buffer into fixed size chunks and typically
is implemented with a freelist. This comes with some pretty nice advantages.</p>
<p>First, because everything is fixed in size, allocating and freeing becomes very
simple (and thus faster!) especially since it doesn’t need to do any of the
complicated bookkeeping <code>malloc(...)</code> needs to do to work for <i>any</i> allocation size.</p>
<p>There’s also less <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">fragmentation</a> (because that arises from variable allocation
sizes, which means you can optimally reuse freed memory as the pool is not
getting fragmented.</p>
<p>Similarly to an <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">arena</a>, you pay most of the cost upfront by pre-allocating a
backing buffer at initialization. In fact in CPython’s case, the pool’s backing
buffer itself is allocated by an arena whose capacity is 1mb or 256kb:</p>
<pre tabindex="0"><code><span><span>#ifdef</span><span> </span><span>USE_LARGE_ARENAS</span></span>
<span><span>    </span><span>#define</span><span> </span><span>ARENA_BITS</span><span>              </span><span>20</span><span>                    /* 1 MiB */</span></span>
<span><span>#else</span></span>
<span><span>    </span><span>#define</span><span> </span><span>ARENA_BITS</span><span>              </span><span>18</span><span>                    /* 256 KiB */</span></span>
<span><span>#endif</span></span>
<span></span>
<span><span>#define</span><span> </span><span>ARENA_SIZE</span><span>              </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> ARENA_BITS</span><span>)</span></span>
<span><span>#define</span><span> </span><span>ARENA_SIZE_MASK</span><span>         </span><span>(</span><span>ARENA_SIZE </span><span>-</span><span> </span><span>1</span><span>)</span></span>
<span></span></code></pre>
<p>Also, CPython will use <code>mmap()</code> with <code>MAP_ANONYMOUS</code> so it reserves 1mb of <i>virtual</i> memory
upfront and the physical memory is allocated on demand on page faults.</p>
<p>With all these tricks, it’s likely that our script (the one that prints and <i>does</i>
seem to allocate memory in the loop) is probably reusing memory from the pool
allocator more than it’s actually allocating new memory (at least for
<code>PyLongObject</code> integers)</p>

So to finally answer the title question “How often does Python allocate?”, the
answer is what everyone expected: <i>very often</i>. There are some good optimizations, but
it could definitely do better :)
<p>Despite some of the optimizations, there’s obviously still a big of overhead of
executing all this allocation code, when theoretically all it should take the
CPU to add two integers is a single <code>ADD</code> instruction.</p>
<p>In addition, the representation of <code>PyLongObject</code> is designed to handle both small
and really big integers alike, meaning the code to handle the
slow and unlikely path (using a really big integer in your Python script)
pessimizes the fast path (using regularly sized integers).</p>
<p>To be honest, I’m a little surprised Python is missing some kind of tagged
pointer optimization here, which would allow it to avoid heap allocations and
directly the encode the value of some integers in the pointer. I consider
this to be a very well-known optimization that many interpreters of dynamically typed languages
use (e.g. V8, JSC, LuaJIT) and has been around since Smalltalk in the 80s<sup><a id="footnote-ref-4" href="#footnote-4">4</a></sup>!</p>
<p>But we do see a good example of how using specialized memory allocators lets us
greatly reduce some of the costs of memory allocation.</p>
<p>This is why Zig is one my favorite languages. The answer to the question of “I
wonder if this is allocating?” is “does this function take an allocator?“<sup><a id="footnote-ref-5" href="#footnote-5">5</a></sup>. And the
<code>std.mem.Allocator</code> interface lets you easily swap out allocators, and all of the
standard library is designed to accept a <code>std.mem.Allocator</code> when it wants to
allocate memory.</p>







			</article>
		</div></div>
  </body>
</html>
