<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.timing.is/swiftui-production-experience-problems-solutions-performance-tips/">Original</a>
    <h1>30k lines of SwiftUI in production later</h1>
    
    <div id="readability-page-1" class="page"><section>
				<p>It took a few hours to fall in love with SwiftUI. So much so that we instantly decided to abandon a cross-platform codebase and go fully native on iOS. <a href="https://apps.apple.com/us/app/timing-is-a-tool-for-time/id6444193986">timing.is shipped this month on the App Store</a>. It was built entirely in SwiftUI. It was in development for <em>12 months</em>. It would have been less if SwiftUI just gave. Unfortunately, repeatedly it would take. Towards the latter stages of development, we even re-considered our decision to go with it. At the end, we didn’t drop it for a couple of reasons. We were too deep into the process. Being a bootstrapped operation that was already severely behind schedule, we couldn’t afford to restart. But this wasn’t why. Despite the regular friction, we still <em>loved</em> it. Because like any commitment, you must let the majority rule. It was <em>fun</em> at least 51% of the time. But let’s talk about the &lt;= 49% that wasn’t.</p><p>First things first, let me be clear this is <em>not</em> another “Is SwiftUI ready for production?” hit piece. Because let me be even more clear: <em>IT IS</em>! Of course, in our opinion. And our opinion was based on satisfying highly complex requirements (c<em>alendars are fundamentally simple, but we didn’t want to build just another that contributed to digital waste</em>). In other words, if you’re building something remotely conventional and/or with minimal stress load, then I wager it will be fun more like 98% of the time. We managed at the end, but there were compromises made. It could — and really should — have been easier, especially considering SwiftUI has had three major updates since it was announced in 2019. Because, as you’re about to read, the problems we had — unlike our needs — were relatively basic. </p><p><em>Disclaimer: it is entirely possible some of the issues we faced have solutions we are unaware of. But we’ve looked and tried to no avail. This however highlights an important point though: these fundamentals should just work.</em></p><h3 id="scrollview-to-hell">ScrollView to Hell</h3><p>Okay, <em>deep breath</em>. This was the control that we wrestled with the most. An infinite scroll is expected in a calendar app. Executing this was relatively straightforward, but only moving forward in time. Because trying to load items on demand scrolling up resulted in a noticeable jitter. <a href="https://stackoverflow.com/questions/65614647/infinite-vertical-scrollview-both-ways-add-items-dynamically-at-top-bottom-tha">I asked on StackOverflow, and 2k views since, it’s apparent there’s no native approach that works</a>. I actually raised this in a WWDC lab with a SwiftUI engineer last year, and their recommendation was to 1) create a <code>LazyVStack</code> with a ridiculously large data set in both directions and 2) scroll to today <code>onAppear</code>. A creative workaround, except unfortunately <code>scrollTo</code> behaves unreliably inside a <code>LazyVStack</code>. It would usually not even come close to the intended target, occassionally missed it by a little, and rarely correctly. We were lucky to eventually find <a href="https://twitter.com/marcpalmerdev">Marc Palmer</a>’s excellent piece “<a href="https://marcpalmer.net/is-your-swiftui-scrollview-scrolling-to-the-wrong-location-in-ios-15/">Is your SwiftUI ScrollView scrolling to the wrong location?</a>”. This was the catch:</p><blockquote>Eventually I isolated it. <code>scrollTo(id ...)</code> does not scroll to the frame of the view with the <code>id</code> if you have a <code>ForEach</code> in the <code>ScrollView</code> and the result of the <code>ForEach</code> body for the view you want to scroll to <em><em>contains other views</em></em>. </blockquote><p>Like, seriously? </p><p>Implementing the advised changes helped, but still wasn’t reliable enough (<em>we would stress test the experience with a really busy calendar</em>). Reluctantly, we had to re-design to accept reality: from the Agenda view, currently you can’t go back in time unfortunately.  </p><p>In these situations, you have three options: fight, concede or re-evaluate. We were stubborn and battled relentlessly. Our advice is to timebox a fight, and don’t delay a clear outcome. It’s recommended you use the constraint as an opportunity to re-design so that as far as the user is concerned, the limitation is never felt and — actually — you’ve made it feel intentional! That’s what we intend to do when we introduce retrospective elements to the product.</p><p>Unfortunately SwiftUI’s <code>ScrollView</code> had other pain points rooted to its inability to gracefully handle competing gestures, i.e. scrolling may be disrupted due to hijacking gestures or vice-versa. For example, we wanted each calendar item to be tappable <em>and</em> long-pressable. This worked out of the box, except the <code>onLongPressGesture</code>’s minimum duration was being ignored. It was frustratingly slow to open. <a href="https://stackoverflow.com/questions/58284994/swiftui-how-to-handle-both-tap-long-press-of-button">No clean solutions existed</a>. Fortunately, <a href="https://twitter.com/danielsaidi">Daniel Saidi</a> <a href="https://danielsaidi.com/blog/2022/11/16/using-complex-gestures-in-a-scroll-view">recently persevered a solution</a>: his <code>ScrollViewGestureButton</code> performed magic tricks using a stealthy <code>ButtonStyle</code>. Similarly, our Day screen consists of a horizontal pager consisting of multiple adjacent vertical scrollviews. For a scroll and swipe to work simultaneously, <a href="https://twitter.com/ciaranrobrien?lang=en-GB">Ciaran O’Brien</a> ingeniously also used a <code>ButtonStyle</code> to <a href="https://www.hackingwithswift.com/forums/swiftui/a-guide-to-delaying-gestures-in-scrollview/6005">create an artificial delay</a> because there’s no equivalent of UIKit’s <code>delaysContentTouches</code> on a <code>UIScrollView</code>. </p><hr/><p>Besides <code>ScrollView</code>, we regularly faced battles with performance and state. Admittedly, our troubles were more likely self-inflicted. We depend heavily on Observables. As a result, it is <em>so easy</em> for an app of moderate complexity to experience issues if your architecture is not rock solid. Views will refresh unnecessarily. And in a calendar with an infinite scroll, this will lead to noticeable slowdowns. You’re always literally one <code>@Published</code> property away from triggering one. <a href="https://twitter.com/mitrevski">Martin Mitrevski</a>’s <a href="https://martinmitrevski.com/2022/04/14/swiftui-performance-tips/">SwiftUI performance tips</a> is a must read when it comes to the topic. Recent <a href="https://twitter.com/oskargroth/status/1609168733058080770">tweets of wisdom</a> from <a href="https://twitter.com/oskargroth">Oskar Groth</a> also resonated. Our approach no longer defaults to carelessly creating Publishers and is much more considerate:</p><ol><li>If a view must refresh after a specific property’s value is changed, then <em>consider</em> giving it a <code>@Published</code> property wrapper.</li><li>Proceed with the <code>@Published</code> assignment <em>if</em> there are no other properties that may be changed simultaneously that also demand a view refresh.</li><li>If there are, then instead determine if there’s a more consolidated approach to announce a change. For example, a separate Publisher whose value is changed once the activity causing the object’s properties to mutate is complete. Or Martin’s suggestion to <code>objectWillChange.send()</code> at that point.</li></ol><p>Similarly, what makes an <code>@EnvironmentObject</code> a convenience is what makes it a nuissance. If a view refers to any, make sure it needs to respond to every publisher change contained within them. If they don’t, then consider replacing the reference to a new object that it’s <em>fully</em> associated to. </p><figure><img src="https://blog.timing.is/content/images/2023/01/gifs-1-6.gif" alt="" loading="lazy" width="222" height="480"/><figcaption>Before: infinite Timeline screen mid-cycle when we used Publishers liberally</figcaption></figure><figure><img src="https://blog.timing.is/content/images/2023/01/giff-1-4.gif" alt="" loading="lazy" width="222" height="480"/><figcaption>After: severely reduced number of Publishers on the Timeline (credit to <a href="https://mastodon.org.uk/@samdeane">Sam Deane</a> for playing the role of co-detective)</figcaption></figure><p>In general, if you got yourself in a pickle — like I did several times — don’t do what I did every time: just as I naively set unnecessary/non-optimal publishers to begin with, I foolishly thought the opposite — removing any that <em>seem</em> unnecessary — is the way to go. Before you remove any, study the property’s trail. I had a few examples of a removal not immediately having any visible consequences, only for it become apparent after some time when the view didn’t respond to changes in a specific scenario. Finally, in case I forget again, remember an <code>@EnvironmentObject</code> will trigger a view update even if the view has no reference to any of its properties. An inexpensive way to determine unnecessary redraws is by setting the background colour of a view to <code>Color.random</code>, <a href="https://twitter.com/steipete/status/1379483193708052480?lang=en">a clever trick</a> by <a href="https://twitter.com/steipete">Peter Steinberger</a>.</p><hr/><p>An honorable mention goes to <code>TextField</code>. Just a few fresh examples of run-ins we had with it are:</p><p>1) we wanted to move our entry UI to open in a sheet and with immediate focus on the title TextField, but there’s a noticeable delay before the keyboard pops up. So we didn’t.</p><p>2) we support typing a new entry and hitting [Next] to add another without losing keyboard focus. A new bug in iOS 16 means when you do, the keyboard begins a close transition before sliding back up to position. This one is in the current version, because we decided dropping the ability to add consecutive items would bother users more than this UI hiccup. In the meantime, we’re searching for a workaround because we’re not expecting a fix till the summer at this point. </p><p>3) when you are editing an entry, we want the title field’s cursor position to be at the beginning. But, alas, not possible.</p><hr/><p>Despite all of the above, we remain committed to and in awe of SwiftUI. We’re experienced enough to not allow <em>moments </em>of frustration — however regular — to cloud our judgement on the overall <em>experience</em>. Considering our setbacks don’t relate to obscure requirements, we’re confident they’ll eventually be ironed out. However, we’re less certain when. In the meantime, whenever we hit an obstacle, we’ll keep a good fight (:</p><hr/><p><em><a href="https://apps.apple.com/us/app/timing-is-a-tool-for-time/id6444193986">timing.is now available on the App Store</a>. Made with love (and occasional despair) in SwiftUI. </em></p><p><em>Follow me on <a href="https://twitter.com/mtrostyle">Twitter @mtrostyle</a> and/or <a href="https://mas.to/@bardi">Mastodon @bardi</a> where I’ll be sharing more on timing’s SwiftUI developments.</em></p>
			</section></div>
  </body>
</html>
