<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/golang/go/issues/60078">Original</a>
    <h1>Proposal: Less error-prone loop variable scoping</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">We propose to change for loop variables declared with <code>:=</code> from one-instance-per-loop to one-instance-per-iteration. This change would apply only to packages in modules that explicitly declare a new enough Go version in the go.mod file, so all existing code is unaffected. Changing the loop semantics would prevent unintended sharing in per-iteration closures and goroutines (see <a href="https://go.dev/doc/faq#closures_and_goroutines" rel="nofollow">this entry in the Go FAQ</a> for one explanation). We expect this change to fix many subtly broken for loops in new code, as well as in old code as it is updated to the newer Go version. There was an earlier pre-proposal discussion of this idea at <a data-error-text="Failed to load title" data-id="4441437" data-permission-text="Title is private" data-url="https://github.com/golang/go/discussions/56010" data-hovercard-type="discussion" data-hovercard-url="/golang/go/discussions/56010/hovercard" href="https://github.com/golang/go/discussions/56010">#56010</a>.</p>
<p dir="auto">For example, consider a loop like the one in this test:</p>
<div data-snippet-clipboard-copy-content="func TestAllEven(t *testing.T) {
	testCases := []int{0, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}"><pre><code>func TestAllEven(t *testing.T) {
	testCases := []int{0, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}
</code></pre></div>
<p dir="auto">This test aims to check that all the test cases are even, but it doesn&#39;t check them all. The problem is that <code>t.Parallel</code> stops the closure and lets the loop continue, and then it runs all the closures in parallel when the loop is over and <code>TestAllEven</code> has returned. By the time the <code>if</code> statement in the closure executes, the loop is done, and <code>v</code> has its final iteration value, 6. All four subtests now continue executing in parallel, and they all check that 6 is even, instead of checking each of the test cases.</p>
<p dir="auto">Most Go developers are familiar with this mistake and know the answer: add <code>v := v</code> to the loop body:</p>
<div data-snippet-clipboard-copy-content="func TestAllEven(t *testing.T) {
	testCases := []int{0, 2, 4, 6}
	for _, v := range testCases {
		v := v // MAKE ITERATION VALUE SHARING BUG GO AWAY
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}"><pre><code>func TestAllEven(t *testing.T) {
	testCases := []int{0, 2, 4, 6}
	for _, v := range testCases {
		v := v // MAKE ITERATION VALUE SHARING BUG GO AWAY
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}
</code></pre></div>
<p dir="auto">Changing the loop semantics would in essence insert this kind of <code>v := v</code> statement for every for loop variable declared with <code>:=</code>. It would fix this loop and many others to do what the author clearly intends.</p>
<p dir="auto">A subtler variation is when the code says <code>testCases := []int{1, 2, 4, 6}</code> (note the non-even test case 1):</p>
<div data-snippet-clipboard-copy-content="func TestAllEvenBuggy(t *testing.T) {
	testCases := []int{1, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}"><pre><code>func TestAllEvenBuggy(t *testing.T) {
	testCases := []int{1, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}
</code></pre></div>
<p dir="auto"><code>TestAllEvenBuggy</code> <em>passes</em> today, because the test is only checking 6, four times. Changing the loop semantics would still fix the loop to do what the author clearly intended, but it would break the test, because the test is passing <em>incorrectly</em>. So there is the potential to cause problems for users.</p>
<p dir="auto">Because of this potential for problems, the new loop semantics would only apply in Go modules that have opted in to the release with the new loops. If that was Go 1.22, then only packages in a module with a <code>go.mod</code> that says <code>go 1.22</code> would get the new loop semantics. Packages in other modules, including packages in dependencies, would get the old semantics. This would guarantee that all existing Go code keeps working the same as it does today, even when compiling with a new toolchain. People only need to debug loop changes when they opt in to the new semantics in <code>go.mod</code>. This approach is in keeping with our backwards and forwards compatibility work, <a data-error-text="Failed to load title" data-id="1468685410" data-permission-text="Title is private" data-url="https://github.com/golang/go/issues/56986" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/56986/hovercard" href="https://github.com/golang/go/issues/56986">#56986</a> and <a data-error-text="Failed to load title" data-id="1469986510" data-permission-text="Title is private" data-url="https://github.com/golang/go/issues/57001" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/57001/hovercard" href="https://github.com/golang/go/issues/57001">#57001</a>, specifically the principle that toolchain upgrades preserve the behavior of old code, and compatibility is based on the <code>go</code> line.</p>
<p dir="auto">If this proposal is accepted, users will need additional tooling support for a successful transition. That would come primarily in two forms: a compiler mode that reports affected loops, and a debugging tool that identifies the specific loops whose changed compilation is responsible for causing a test failure. There is a demo of the tooling support at the end of this comment.</p>
<p dir="auto">The tooling support is important and necessary, but we expect it to be needed only rarely. Analysis and conversion of Google&#39;s own Go source code found that only about 1 package test per 8,000 started failing due to the new semantics, and the bug was essentially always in the test itself, like in <code>TestAllEvenBuggy</code>. In contrast, the new <code>loopclosure</code> vet analysis that shipped in Go 1.20 flagged definite bugs in 1 test per 400. The rest stayed passing with their bugs fixed by the new semantics. That is, in Google&#39;s code base, about 5% of the tests that contain this kind of sharing mistake were like <code>TestAllEvenBuggy</code>, exposed as buggy by the new semantics. The other 95% of the tests with this kind of mistake still passed when they started testing what they intended to. Of all the test failures, only one was caused by a loop variable semantic test change in non-test code. That code was very low-level and could not tolerate a new allocation in the loop. The design document has details. This evidence suggests that <strong>changing the semantics is usually a no-op, and when itâ€™s not, it fixes buggy code far more often than it breaks correct code.</strong></p>
<p dir="auto">Based on the preliminary discussion the further work summarized here, <a data-hovercard-type="user" data-hovercard-url="/users/dr2chase/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/dr2chase">@dr2chase</a> and I propose that we make the change in an appropriate future Go version, perhaps Go 1.22 if the stars align, and otherwise a later version.</p>
<p dir="auto">More details can be found in the <a href="https://go.dev/s/loopvar-design" rel="nofollow">design document</a>.</p>
<p dir="auto"><strong>Update, May 10 2023</strong>: Note that the change will <em>not</em> break the common idiom of changing a loop variable in the body of a 3-clause for loops. See <a href="https://github.com/golang/go/issues/60078#issuecomment-1542419062" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/60078/hovercard">this comment</a> for details and links before commenting about 3-clause for loops. Thanks.</p>
<hr/>
<h3 dir="auto">Tooling Demonstration</h3>
<p dir="auto">To demonstrate the tooling we would provide to support a successful transition, here is a complete example of a test that passes today but fails with the new loop semantics:</p>
<div data-snippet-clipboard-copy-content="% cat x_test.go
package x

import &#34;testing&#34;

func Test(t *testing.T) {
	testCases := []int{1, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Log(v)
		})
	}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}
%"><pre><code>% cat x_test.go
package x

import &#34;testing&#34;

func Test(t *testing.T) {
	testCases := []int{1, 2, 4, 6}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Log(v)
		})
	}
	for _, v := range testCases {
		t.Run(&#34;sub&#34;, func(t *testing.T) {
			t.Parallel()
			if v&amp;1 != 0 {
				t.Fatal(&#34;odd v&#34;, v)
			}
		})
	}
}
%
</code></pre></div>
<p dir="auto">Building the program with <code>-d=loopvar=2</code> reports all the affected loops:</p>
<div data-snippet-clipboard-copy-content="% GOEXPERIMENT=loopvar go test -gcflags=all=-d=loopvar=2 x_test.go
# runtime
go/src/runtime/proc.go:1815:7: loop variable freem now per-iteration, stack-allocated
go/src/runtime/proc.go:3149:7: loop variable enum now per-iteration, stack-allocated
go/src/runtime/mgcmark.go:810:6: loop variable d now per-iteration, stack-allocated
go/src/runtime/traceback.go:623:7: loop variable iu now per-iteration, stack-allocated
go/src/runtime/traceback.go:943:7: loop variable iu now per-iteration, stack-allocated
# runtime/pprof
go/src/runtime/pprof/pprof.go:386:9: loop variable r now per-iteration, heap-allocated
go/src/runtime/pprof/proto.go:363:6: loop variable e now per-iteration, stack-allocated
go/src/runtime/pprof/proto.go:612:9: loop variable frame now per-iteration, heap-allocated
go/src/runtime/pprof/protomem.go:29:9: loop variable r now per-iteration, heap-allocated
# command-line-arguments [command-line-arguments.test]
./x_test.go:7:9: loop variable v now per-iteration, stack-allocated
./x_test.go:15:9: loop variable v now per-iteration, stack-allocated
./x_test.go:20:9: loop variable v now per-iteration, stack-allocated
# internal/fuzz
go/src/internal/fuzz/fuzz.go:432:9: loop variable e now per-iteration, stack-allocated
--- FAIL: Test (0.00s)
    --- FAIL: Test/sub (0.00s)
        x_test.go:11: odd v 1
    --- FAIL: Test/sub#08 (0.00s)
        x_test.go:24: odd v 1
FAIL
FAIL	command-line-arguments	0.199s
FAIL
%"><pre><code>% GOEXPERIMENT=loopvar go test -gcflags=all=-d=loopvar=2 x_test.go
# runtime
go/src/runtime/proc.go:1815:7: loop variable freem now per-iteration, stack-allocated
go/src/runtime/proc.go:3149:7: loop variable enum now per-iteration, stack-allocated
go/src/runtime/mgcmark.go:810:6: loop variable d now per-iteration, stack-allocated
go/src/runtime/traceback.go:623:7: loop variable iu now per-iteration, stack-allocated
go/src/runtime/traceback.go:943:7: loop variable iu now per-iteration, stack-allocated
# runtime/pprof
go/src/runtime/pprof/pprof.go:386:9: loop variable r now per-iteration, heap-allocated
go/src/runtime/pprof/proto.go:363:6: loop variable e now per-iteration, stack-allocated
go/src/runtime/pprof/proto.go:612:9: loop variable frame now per-iteration, heap-allocated
go/src/runtime/pprof/protomem.go:29:9: loop variable r now per-iteration, heap-allocated
# command-line-arguments [command-line-arguments.test]
./x_test.go:7:9: loop variable v now per-iteration, stack-allocated
./x_test.go:15:9: loop variable v now per-iteration, stack-allocated
./x_test.go:20:9: loop variable v now per-iteration, stack-allocated
# internal/fuzz
go/src/internal/fuzz/fuzz.go:432:9: loop variable e now per-iteration, stack-allocated
--- FAIL: Test (0.00s)
    --- FAIL: Test/sub (0.00s)
        x_test.go:11: odd v 1
    --- FAIL: Test/sub#08 (0.00s)
        x_test.go:24: odd v 1
FAIL
FAIL	command-line-arguments	0.199s
FAIL
%
</code></pre></div>
<p dir="auto">Note that some loops are in the Go standard library. Those are unlikely to be the cause, so we can limit the diagnostics to the current package by dropping <code>all=</code>:</p>
<div data-snippet-clipboard-copy-content="% GOEXPERIMENT=loopvar go test -gcflags=-d=loopvar=2 x_test.go
# command-line-arguments [command-line-arguments.test]
./x_test.go:7:9: loop variable v now per-iteration, stack-allocated
./x_test.go:15:9: loop variable v now per-iteration, stack-allocated
./x_test.go:20:9: loop variable v now per-iteration, stack-allocated
--- FAIL: Test (0.00s)
    --- FAIL: Test/sub (0.00s)
        x_test.go:11: odd v 1
    --- FAIL: Test/sub#08 (0.00s)
        x_test.go:24: odd v 1
FAIL
FAIL	command-line-arguments	0.119s
FAIL
%"><pre><code>% GOEXPERIMENT=loopvar go test -gcflags=-d=loopvar=2 x_test.go
# command-line-arguments [command-line-arguments.test]
./x_test.go:7:9: loop variable v now per-iteration, stack-allocated
./x_test.go:15:9: loop variable v now per-iteration, stack-allocated
./x_test.go:20:9: loop variable v now per-iteration, stack-allocated
--- FAIL: Test (0.00s)
    --- FAIL: Test/sub (0.00s)
        x_test.go:11: odd v 1
    --- FAIL: Test/sub#08 (0.00s)
        x_test.go:24: odd v 1
FAIL
FAIL	command-line-arguments	0.119s
FAIL
%
</code></pre></div>
<p dir="auto">That trims the diagnostic output, but it still leaves us to check all our loops. In this trivial example, 2 of 3 are buggy, but in a real program there are fewer needles and more haystack. To solve that problem, we can use a dynamic tool that reruns a test, varying which loops compile with the new semantics, to identify the specific loops that cause the failure:</p>
<div data-snippet-clipboard-copy-content="% bisect -loopvar go test x_test.go
bisect: checking target with all changes disabled
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=n x_test.go... ok (13 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=n x_test.go... ok (13 matches)
bisect: checking target with all changes enabled
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=y x_test.go... FAIL (13 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=y x_test.go... FAIL (13 matches)
bisect: target succeeds with no changes, fails with all changes
bisect: searching for minimal set of changes to enable to cause failure
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+0 x_test.go... ok (7 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+0 x_test.go... ok (7 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+1 x_test.go... FAIL (6 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+1 x_test.go... FAIL (6 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+01 x_test.go... FAIL (3 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+01 x_test.go... FAIL (3 matches)
...
bisect: FOUND failing change set
--- change set #1 (enabling changes causes failure)
./x_test.go:7:9
---
...
bisect: FOUND failing change set
--- change set #2 (enabling changes causes failure)
./x_test.go:20:9
---
...
bisect: target succeeds with all remaining changes enabled
%"><pre><code>% bisect -loopvar go test x_test.go
bisect: checking target with all changes disabled
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=n x_test.go... ok (13 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=n x_test.go... ok (13 matches)
bisect: checking target with all changes enabled
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=y x_test.go... FAIL (13 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=y x_test.go... FAIL (13 matches)
bisect: target succeeds with no changes, fails with all changes
bisect: searching for minimal set of changes to enable to cause failure
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+0 x_test.go... ok (7 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+0 x_test.go... ok (7 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+1 x_test.go... FAIL (6 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+1 x_test.go... FAIL (6 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+01 x_test.go... FAIL (3 matches)
bisect: run: go test -gcflags=all=-d=loopvar=1,loopvarhash=+01 x_test.go... FAIL (3 matches)
...
bisect: FOUND failing change set
--- change set #1 (enabling changes causes failure)
./x_test.go:7:9
---
...
bisect: FOUND failing change set
--- change set #2 (enabling changes causes failure)
./x_test.go:20:9
---
...
bisect: target succeeds with all remaining changes enabled
%
</code></pre></div>
<p dir="auto">Now we know to spend our attention on the loops at lines 7 and 20, which are in fact the buggy ones. (The loop at line 15 has been cleared of suspicion.) Bisect uses an adaptation of binary search that can identify the relevant loop in a relatively small number of trials, making it useful even on very large, very complicated tests that run for a long time.</p>
      </div>
</div></div>
  </body>
</html>
