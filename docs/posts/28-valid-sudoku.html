<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/28%29-Valid-Sudoku">Original</a>
    <h1>28) Valid Sudoku</h1>
    
    <div id="readability-page-1" class="page"><article><p><code>Math.trunc()</code> strips all decimal parts of a number and returns just the integer.</p>
<p>I got to about here:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// row sum can&#39;t repeat itself, digits must be 1-9</span></span>
<span data-line=""><span>// col sum is same</span></span>
<span data-line=""><span>// 3x3 areas are the same</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    const</span><span> validNums</span><span> =</span><span> [</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span><span>, </span><span>7</span><span>, </span><span>8</span><span>, </span><span>9</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> 0</span><span>; row </span><span>&lt;</span><span> 10</span><span>; row</span><span>++</span><span>){</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> 0</span><span>; col </span><span>&lt;</span><span> 10</span><span>; col</span><span>++</span><span>){</span></span>
<span data-line=""><span>            let</span><span> val </span><span>=</span><span> board[row][col]</span></span>
<span data-line=""><span>            if</span><span> (</span><span>!</span><span>validNums.</span><span>includes</span><span>(val))</span></span>
<span data-line=""><span>            if</span><span> (rowSet.</span><span>has</span><span>(val)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(val)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> 0</span><span>; row </span><span>&lt;</span><span> 10</span><span>; row</span><span>++</span><span>){</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> 0</span><span>; col </span><span>&lt;</span><span> 10</span><span>; col</span><span>++</span><span>){</span></span>
<span data-line=""><span>            let</span><span> val </span><span>=</span><span> board[col][row]</span></span>
<span data-line=""><span>            if</span><span> (</span><span>!</span><span>validNums.</span><span>includes</span><span>(val))</span></span>
<span data-line=""><span>            if</span><span> (rowSet.</span><span>has</span><span>(val)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(val)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>And then got intimidated by checking which box I was ‚Äúin‚Äù. Or actually, that language already gives a hint of how this might be done. More accurately, I was intimidated by checking whether the box contained a repeat of the current number.</p>
<p>In an answer later, I found that this nifty function does a good job at determining the box:
<code>const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)</code></p>
<p>Let‚Äôs see if I can understand this. There are 9 boxes total.</p>
<p>I guess one way to think about it is really just mapping the larger space of a 9x9 grid onto a 3x3 grid. With this logic, every column coordinate can be divided by 3 and floored.</p>
<p>Column 9 becomes column 3.
Column 8 though, becomes column 2, which is no good.</p>

<p>This is what I was starting with:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    // rows</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        board[i].</span><span>reduce</span><span>((</span><span>total</span><span>, </span><span>num</span><span>)</span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>            return</span><span> /</span><span>^</span><span>[1-9]</span><span>$</span><span>/</span><span>.</span><span>test</span><span>(num) </span><span>?</span><span> total </span><span>+</span><span> num </span><span>:</span><span> total;</span></span>
<span data-line=""><span>        }, </span><span>0</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>I guess my idea was to use a reducer to go through each <em>row</em> we get as the top level of our nested array, and to add everything up to make sure we didn‚Äôt, idk, have more than‚Ä¶45? The sum of 9+8+7+6‚Ä¶etc.</p>
<p>But that was silly. This is screaming for <code>sets</code>. <code>Sets</code> are always the best if they can be used, because their operations are all O(n)!</p>
<p>But the plus is that my very misguided approach <em>did</em> finally teach me how to use reducers. And a bit of regex.</p>
<h2 id="some-more-questions-that-came-up">Some more questions that came up:<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#some-more-questions-that-came-up"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="typing-data-structures-in-ts">Typing data structures in TS<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#typing-data-structures-in-ts"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>const moo: Map&lt;number, number&gt; = new Map()</code></p>
<p>vs.</p>
<p><code>const moo = new Map&lt;number, number&gt;()</code></p>
<p>Conclusion: not sure which is better, but the first is more customary and I think both are okay. I‚Äôd look into it more but</p>
<h3 id="reviewing-nullish-coalescence-vs-logical-or">Reviewing nullish coalescence vs Logical OR<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#reviewing-nullish-coalescence-vs-logical-or"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>||</code> is logical or, and <code>??</code> is elegantly named <code>nullish coalescence</code>.</p>
<p>Logical or is the more permissive of the two, which can make it less safe to use when the values of <code>0</code> or empty strings are on the table. If a value ends up being either of these, the righthand side of operator will be returned, which isn‚Äôt always ideal.</p>
<p><code>??</code> or nullish coalescence, will <em>only</em> return the right-hand operand (what a fancy word that I would like to use in a sentence some day!) if that value is spefically <code>null</code> or <code>undefined</code>.</p>
<p>The reason I wanted to use it was for a common case of <code>Map.set()</code> incrementation, where it‚Äôs important to treat the case where there is a <code>map</code> value differently than when not.</p>
<p>To my point, <code>Map.get(6) + 23</code> will create a <code>NaN</code> if <code>Map.get(6)</code> doesn‚Äôt exist, since adding a number to <code>undefined</code> results in <code>NaN</code></p>
<p>My favorite way I‚Äôve found to deal with this so far  <code>(Map.get(6) ?? 0) + 4</code> but curious about other ways to handle this.</p>
<p>Woah! Of course! The <code>.get()</code> method on a map allows for a <code>default</code> value to be passed as a second argument! Amazing. So we can do <code>someMap.get(6, 0) + 1</code>. This is really what I‚Äôve wanted all along.</p>
<hr/>
<p>Okay let‚Äôs try this‚Ä¶</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> validSet</span><span>(</span><span>theSet</span><span>, </span><span>val</span><span>, </span><span>ignoreValue</span><span>){</span></span>
<span data-line=""><span>    if</span><span> (theSet.</span><span>has</span><span>(val) </span><span>&amp;&amp;</span><span> val </span><span>!==</span><span> &#39;.&#39;</span><span>) </span><span>return</span><span> true</span></span>
<span data-line=""><span>    return</span><span> false</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    let</span><span> result </span><span>=</span><span> true</span></span>
<span data-line=""><span>    let</span><span> columnsSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""><span>    let</span><span> squaresSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // rows</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        const</span><span> y</span><span> =</span><span> Math.</span><span>ceil</span><span>((i </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>        const</span><span> row</span><span> =</span><span> board[i]</span></span>
<span data-line=""><span>        row.</span><span>forEach</span><span>((</span><span>col</span><span>, </span><span>index</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>            result </span><span>=</span><span> validSet</span><span>(rowSet, col, </span><span>&#39;.&#39;</span><span>)</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(col)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // cols</span></span>
<span data-line=""><span>            const</span><span> colSet</span><span> =</span><span> columnsSet[i]</span></span>
<span data-line=""><span>            result </span><span>=</span><span> validSet</span><span>(colSet, col, </span><span>&#39;.&#39;</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Tile by tile</span></span>
<span data-line=""><span>            let</span><span> x </span><span>=</span><span> Math.</span><span>ceil</span><span>((index </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            let</span><span> tile </span><span>=</span><span> (y </span><span>-</span><span> 1</span><span>) </span><span>*</span><span> 3</span><span> +</span><span> x</span></span>
<span data-line=""><span>            const</span><span> squareSet</span><span> =</span><span> squaresSet[tile</span><span>-</span><span>1</span><span>]</span></span>
<span data-line=""><span>            result </span><span>=</span><span> validSet</span><span>(squareSet, col, </span><span>&#39;.&#39;</span><span>)</span></span>
<span data-line=""><span>        })</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> result</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>So‚Ä¶this took me an hour. With some major distractions! In many ways I‚Äôm proud of it, but it took me way too long. And! It doesn‚Äôt pass anyways. I had a pretty basic mistake, which was that I was overwriting the <code>result</code> variable. Fixed that:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> invalidSet</span><span>(</span><span>theSet</span><span>, </span><span>val</span><span>, </span><span>ignoreValue</span><span>){</span></span>
<span data-line=""><span>    return</span><span> theSet.</span><span>has</span><span>(val) </span><span>&amp;&amp;</span><span> val </span><span>!==</span><span> &#39;.&#39;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> columnsSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""><span>    let</span><span> squaresSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // rows</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        const</span><span> y</span><span> =</span><span> Math.</span><span>ceil</span><span>((i </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>        const</span><span> row</span><span> =</span><span> board[i]</span></span>
<span data-line=""><span>        row.</span><span>forEach</span><span>((</span><span>col</span><span>, </span><span>index</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>            if</span><span> (</span><span>invalidSet</span><span>(rowSet, col, </span><span>&#39;.&#39;</span><span>)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(col)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // cols</span></span>
<span data-line=""><span>            const</span><span> colSet</span><span> =</span><span> columnsSet[i]</span></span>
<span data-line=""><span>            if</span><span> (</span><span>invalidSet</span><span>(colSet, col, </span><span>&#39;.&#39;</span><span>)) </span><span>return</span><span> false</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Tile by tile</span></span>
<span data-line=""><span>            let</span><span> x </span><span>=</span><span> Math.</span><span>ceil</span><span>((index </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            let</span><span> tile </span><span>=</span><span> (y </span><span>-</span><span> 1</span><span>) </span><span>*</span><span> 3</span><span> +</span><span> x</span></span>
<span data-line=""><span>            const</span><span> squareSet</span><span> =</span><span> squaresSet[tile</span><span>-</span><span>1</span><span>]</span></span>
<span data-line=""><span>            if</span><span> (</span><span>invalidSet</span><span>(squareSet, col, </span><span>&#39;.&#39;</span><span>)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>        })</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Still doesn‚Äôt pass. Here‚Äôs ChatGPT‚Äôs, which does pass</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> validSet</span><span>(</span><span>theSet</span><span>, </span><span>val</span><span>) {</span></span>
<span data-line=""><span>    if</span><span> (theSet.</span><span>has</span><span>(val) </span><span>&amp;&amp;</span><span> val </span><span>!==</span><span> &#39;.&#39;</span><span>) </span><span>return</span><span> false</span><span>; </span><span>// Return false if duplicate</span></span>
<span data-line=""><span>    theSet.</span><span>add</span><span>(val);</span></span>
<span data-line=""><span>    return</span><span> true</span><span>;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>) {</span></span>
<span data-line=""><span>    let</span><span> columnsSet </span><span>=</span><span> Array.</span><span>from</span><span>({ length: </span><span>9</span><span> }, () </span><span>=&gt;</span><span> new</span><span> Set</span><span>());</span></span>
<span data-line=""><span>    let</span><span> squaresSet </span><span>=</span><span> Array.</span><span>from</span><span>({ length: </span><span>9</span><span> }, () </span><span>=&gt;</span><span> new</span><span> Set</span><span>());</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Iterate through rows and columns</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> 9</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>();</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> 9</span><span>; j</span><span>++</span><span>) {</span></span>
<span data-line=""><span>            const</span><span> val</span><span> =</span><span> board[i][j];</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Skip empty cells</span></span>
<span data-line=""><span>            if</span><span> (val </span><span>===</span><span> &#39;.&#39;</span><span>) </span><span>continue</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Check row validity</span></span>
<span data-line=""><span>            if</span><span> (</span><span>!</span><span>validSet</span><span>(rowSet, val)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Check column validity</span></span>
<span data-line=""><span>            if</span><span> (</span><span>!</span><span>validSet</span><span>(columnsSet[j], val)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Check 3x3 sub-box validity</span></span>
<span data-line=""><span>            const</span><span> boxIndex</span><span> =</span><span> Math.</span><span>floor</span><span>(i </span><span>/</span><span> 3</span><span>) </span><span>*</span><span> 3</span><span> +</span><span> Math.</span><span>floor</span><span>(j </span><span>/</span><span> 3</span><span>);</span></span>
<span data-line=""><span>            if</span><span> (</span><span>!</span><span>validSet</span><span>(squaresSet[boxIndex], val)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> true</span><span>; </span><span>// All checks passed</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span></code></pre></figure>
<h3 id="differences-from-chatgpts">Differences from ChatGPT‚Äôs<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#differences-from-chatgpts"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>A)
They use <code>Array.from({length: 5}, () =&gt; new Set())</code> instead which is, in my mind, trivial. I tested out the performance differences here <a href="https://forums.tigsource.com/devnotes/LeetCode-Journal/32)-Minesweeper" data-slug="devnotes/LeetCode-Journal/32)-Minesweeper">32) Minesweeper</a> and they weren‚Äôt really clear to me.</p>
<p>B) They still create a new <code>set</code> for every <code>row</code> as we go, but they choose to access the <code>[i][j]</code> nesting all at once, which seems to keep things simpler. It also means the next point is executed sooner and therefore a lot of efficiently:</p>
<p>C) They check if the character is ‚Äô.‚Äô for empty early on, for every character, before doing (almost) anything else. This also simplifies the <code>validSet</code> function and separates it into a clearer interest of concerns.</p>
<p>D) Instead of using <code>Math.ceil</code> on a <code>i+1</code> index, they just use <code>Math.floor</code> on the index itself, which is much less confusing, and works almost exactly the same. Since this is simpler, this lets them do the <code>Math.floor(i/3)</code> operation inline which reads pretty well.</p>
<p>Yeah! Looks great. I love what they did to my function.</p>
<p>HOWEVER. I still haven‚Äôt worked out exactly what isn‚Äôt working in my code and I think I am due for a debugging session.</p>
<h3 id="debugging">Debugging<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#debugging"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Oh. Interesting. I can‚Äôt use a <code>continue</code> within a <code>forEach</code> loop. Or <code>break</code>. Good to know. Man it‚Äôs crazy, but it‚Äôs like almost all iterators make you regret using them except for trad <code>for</code> loops which just never us down.</p>
<p>HAHA.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> columnsSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""><span>    let</span><span> squaresSet </span><span>=</span><span> [</span><span>...</span><span>Array</span><span>(</span><span>9</span><span>)].</span><span>map</span><span>(</span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // rows</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        const</span><span> y</span><span> =</span><span> Math.</span><span>ceil</span><span>((i </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>        const</span><span> row</span><span> =</span><span> board[i]</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> index </span><span>=</span><span> 0</span><span>; index </span><span>&lt;</span><span> row.</span><span>length</span><span>; index</span><span>++</span><span>){</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            let</span><span> col </span><span>=</span><span> row[index]</span></span>
<span data-line=""><span>            if</span><span> (col </span><span>===</span><span> &#39;.&#39;</span><span>) </span><span>continue</span></span>
<span data-line=""><span>            console.</span><span>log</span><span>({col})</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            if</span><span> (rowSet.</span><span>has</span><span>(col)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(col)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // cols</span></span>
<span data-line=""><span>            const</span><span> colSet</span><span> =</span><span> columnsSet[index]</span></span>
<span data-line=""><span>            if</span><span> (colSet.</span><span>has</span><span>(col)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            colSet.</span><span>add</span><span>(col)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // Tile by tile</span></span>
<span data-line=""><span>            let</span><span> x </span><span>=</span><span> Math.</span><span>ceil</span><span>((index </span><span>+</span><span> 1</span><span>)</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            let</span><span> tile </span><span>=</span><span> (y </span><span>-</span><span> 1</span><span>) </span><span>*</span><span> 3</span><span> +</span><span> x</span></span>
<span data-line=""><span>            // console.log({tile})</span></span>
<span data-line=""><span>            const</span><span> squareSet</span><span> =</span><span> squaresSet[tile</span><span>-</span><span>1</span><span>]</span></span>
<span data-line=""><span>            if</span><span> (squareSet.</span><span>has</span><span>(tile</span><span>-</span><span>1</span><span>)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            squareSet.</span><span>add</span><span>(col)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Finally got it. There were a tiny of tiny mistakes. This is a really great challenge for overall code quality and consistency practice, as well as general practice traversing through a variety of structures and just making sure that variables and indexes are being used correctly.</p>

<p>Okay, I got it in <code>6:20.</code> Let‚Äôs try for faster.
Finally! Got it in <code>2:50</code>. Accidentally used <code>j</code> instead of <code>boxIndex</code> one time.</p>
<p>So I think this may be a good place to check quickly, how can I write less verbose code that is faster to write?</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    type</span><span> BoardSet</span><span> =</span><span> Set</span><span>&lt;</span><span>string</span><span>&gt;</span></span>
<span data-line=""><span>    const</span><span> squaresSet</span><span>:</span><span> BoardSet</span><span>[] </span><span>=</span><span> Array.</span><span>from</span><span>({length: </span><span>9</span><span>}, </span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""><span>    const</span><span> columnsSet</span><span>:</span><span> BoardSet</span><span>[] </span><span>=</span><span> Array.</span><span>from</span><span>({length: </span><span>9</span><span>}, </span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>())</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        const</span><span> row</span><span> =</span><span> board[i]</span></span>
<span data-line=""><span>        const</span><span> rowSet</span><span>:</span><span> BoardSet</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> row.</span><span>length</span><span>; j</span><span>++</span><span>){</span></span>
<span data-line=""><span>            const</span><span> tile</span><span> =</span><span> board[i][j]</span></span>
<span data-line=""><span>            if</span><span> (tile </span><span>===</span><span> &#34;.&#34;</span><span>) </span><span>continue</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // rows</span></span>
<span data-line=""><span>            if</span><span> (rowSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // columns</span></span>
<span data-line=""><span>            const</span><span> columnSet</span><span> =</span><span> columnsSet[j]</span></span>
<span data-line=""><span>            if</span><span> (columnSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            columnSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // square set</span></span>
<span data-line=""><span>            const</span><span> boxIndex</span><span> =</span><span> Math.</span><span>floor</span><span>(i</span><span>/</span><span>3</span><span>)</span><span>*</span><span>3</span><span> +</span><span> Math.</span><span>floor</span><span>(j</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            const</span><span> boxSet</span><span> =</span><span> squaresSet[boxIndex]</span></span>
<span data-line=""><span>            if</span><span> (boxSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            boxSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Here‚Äôs a creative way to reduce lines! I think it kinda makes sense, but it‚Äôs way less readable. Let‚Äôs see if I can even do this from scratch.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    type</span><span> BoardSet</span><span> =</span><span> Set</span><span>&lt;</span><span>string</span><span>&gt;</span></span>
<span data-line=""><span>    const</span><span> allSets</span><span>:</span><span> BoardSet</span><span>[][] </span><span>=</span><span> Array</span></span>
<span data-line=""><span>    .</span><span>from</span><span>({length: </span><span>3</span><span>},</span><span>_</span><span>=&gt;</span><span> Array</span></span>
<span data-line=""><span>    .</span><span>from</span><span>({length: </span><span>9</span><span>}, </span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>()))</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> board[i].</span><span>length</span><span>; j</span><span>++</span><span>){</span></span>
<span data-line=""><span>            const</span><span> tile</span><span> =</span><span> board[i][j]</span></span>
<span data-line=""><span>            if</span><span> (tile </span><span>===</span><span> &#34;.&#34;</span><span>) </span><span>continue</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // rows</span></span>
<span data-line=""><span>            const</span><span> rowSet</span><span> =</span><span> allSets[</span><span>0</span><span>][i]</span></span>
<span data-line=""><span>            if</span><span> (rowSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            rowSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // columns</span></span>
<span data-line=""><span>            const</span><span> columnSet</span><span> =</span><span> allSets[</span><span>1</span><span>][j]</span></span>
<span data-line=""><span>            if</span><span> (columnSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            columnSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // square set</span></span>
<span data-line=""><span>            const</span><span> boxIndex</span><span> =</span><span> Math.</span><span>floor</span><span>(i</span><span>/</span><span>3</span><span>)</span><span>*</span><span>3</span><span> +</span><span> Math.</span><span>floor</span><span>(j</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            const</span><span> boxSet</span><span> =</span><span> allSets[</span><span>2</span><span>][boxIndex]</span></span>
<span data-line=""><span>            if</span><span> (boxSet.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            boxSet.</span><span>add</span><span>(tile)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Got it! Implemented this from scratch in <code>4:13</code>.</p>
<p>Woah okay, so I tried to make it more DRY in another way, and it backfired:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    type</span><span> BoardSet</span><span> =</span><span> Set</span><span>&lt;</span><span>string</span><span>&gt;</span></span>
<span data-line=""><span>    const</span><span> allSets</span><span>:</span><span> BoardSet</span><span>[][] </span><span>=</span><span> Array</span></span>
<span data-line=""><span>        .</span><span>from</span><span>({length: </span><span>3</span><span>}, </span><span>_</span><span>=&gt;</span><span> Array</span></span>
<span data-line=""><span>        .</span><span>from</span><span>({length: </span><span>9</span><span>}, </span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    ))</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> board[i].</span><span>length</span><span>; j</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>            const</span><span> tile</span><span> =</span><span> board[i][j]</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            function</span><span> returnOrAdd</span><span>(</span><span>set</span><span>){</span></span>
<span data-line=""><span>                if</span><span> (set.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>                set.</span><span>add</span><span>(tile)</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (tile </span><span>===</span><span> &#34;.&#34;</span><span>) </span><span>continue</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // rows</span></span>
<span data-line=""><span>            const</span><span> row</span><span> =</span><span> allSets[</span><span>0</span><span>][i]</span></span>
<span data-line=""><span>            returnOrAdd</span><span>(row)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // columns</span></span>
<span data-line=""><span>            const</span><span> col</span><span> =</span><span> allSets[</span><span>1</span><span>][j]</span></span>
<span data-line=""><span>            returnOrAdd</span><span>(col)</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // squares</span></span>
<span data-line=""><span>            const</span><span> boxIndex</span><span> =</span><span> Math.</span><span>floor</span><span>(i</span><span>/</span><span>3</span><span>)</span><span>*</span><span>3</span><span> +</span><span> Math.</span><span>floor</span><span>(j</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            const</span><span> square</span><span> =</span><span> allSets[</span><span>2</span><span>][boxIndex]</span></span>
<span data-line=""><span>            if</span><span> (square.</span><span>has</span><span>(tile)) </span><span>return</span><span> false</span></span>
<span data-line=""><span>            square.</span><span>add</span><span>(tile)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>See how I made this closure, cleverly (üòú) re-using the tile value for use when this closure is defined? Well, it turns out this doesn‚Äôt work because <code>returning</code> inside of a closure inside a parent function behaves differently than returning at the scope of that parent function.</p>
<p>This is interesting to me because it highlights how loops aren‚Äôt closures! When writing this originally, I was curious whether I could <code>return false</code> inside of two nested loops as a way to interrupt my function at the soonest sign of an invalid sudoku, and it turned out that the answer was <em>yes</em>.</p>
<p>So If I wanted to continue making things more DRY, I could do this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValidSudoku</span><span>(</span><span>board</span><span>:</span><span> string</span><span>[][])</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    type</span><span> BoardSet</span><span> =</span><span> Set</span><span>&lt;</span><span>string</span><span>&gt;</span></span>
<span data-line=""><span>    const</span><span> allSets</span><span>:</span><span> BoardSet</span><span>[][] </span><span>=</span><span> Array</span></span>
<span data-line=""><span>        .</span><span>from</span><span>({length: </span><span>3</span><span>}, </span><span>_</span><span>=&gt;</span><span> Array</span></span>
<span data-line=""><span>        .</span><span>from</span><span>({length: </span><span>9</span><span>}, </span><span>_</span><span>=&gt;</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    ))</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> board.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> board[i].</span><span>length</span><span>; j</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>            const</span><span> tile</span><span> =</span><span> board[i][j]</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            function</span><span> checkAndAddToSet</span><span>(</span><span>set</span><span>){</span></span>
<span data-line=""><span>                if</span><span> (set.</span><span>has</span><span>(tile)) </span><span>return</span><span> true</span></span>
<span data-line=""><span>                set.</span><span>add</span><span>(tile)</span></span>
<span data-line=""><span>                return</span><span> false</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (tile </span><span>===</span><span> &#34;.&#34;</span><span>) </span><span>continue</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // rows</span></span>
<span data-line=""><span>            if</span><span> (</span><span>checkAndAddToSet</span><span>(allSets[</span><span>0</span><span>][i])) </span><span>return</span><span> false</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // columns</span></span>
<span data-line=""><span>            if</span><span> (</span><span>checkAndAddToSet</span><span>(allSets[</span><span>1</span><span>][j])) </span><span>return</span><span> false</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // squares</span></span>
<span data-line=""><span>            const</span><span> boxIndex</span><span> =</span><span> Math.</span><span>floor</span><span>(i</span><span>/</span><span>3</span><span>)</span><span>*</span><span>3</span><span> +</span><span> Math.</span><span>floor</span><span>(j</span><span>/</span><span>3</span><span>)</span></span>
<span data-line=""><span>            if</span><span> (</span><span>checkAndAddToSet</span><span>(allSets[</span><span>2</span><span>][boxIndex])) </span><span>return</span><span> false</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>But personally, I think we‚Äôre going way beyond what is actually helpful. It just makes things less readable. I think there was a time when I thought that just continual encapsulation made for more readable, higher quality, easier to maintain code, and I definitely changed my mind. A few years ago at least now. The above code, in my opinion, though dryer, is worse. The closure used for encapsulation here isn‚Äôt helpful, and doesn‚Äôt really group functionality in any sort of meaningful way, it just happens to prevent the same couple lines from being repeating.</p>
<p>So in terms of code-line savings‚Ä¶I guess it saves us 6 lines. But it also introduces‚Ä¶5</p>
<p>So let‚Äôs look at our balance sheet here:</p>













<div><table><thead><tr><th>What was improved</th><th>What was lost</th></tr></thead><tbody><tr><td>we have one less line of code</td><td>readability</td></tr></tbody></table></div>
<p>Doesn‚Äôt really seem worth it, as fun as it is to encapsulate stuff. What a rush!</p>
<p>To go on a massive tangent here, I did some pretty customary encapsulation when I was working on a <a href="https://forums.tigsource.com/devnotes/MOGs" data-slug="devnotes/MOGs">multiplayer online game</a>, as there were a lot of game objects with various properties and inheritance in the game state on the back end and on the frontend a bit of very abstract-able behavior where those properties were interpreted into opinionated methods of rendering using 3JS.</p>
<p>I don‚Äôt think I did a poor job, but I will say that the inheritance-heavy OOP paradigm I ended up using certainly leads to a lot of jumping around files, and during that process I sometimes sort of forget what I‚Äôm doing sometimes, or what certain properties or methods do.</p>
<p>One potentially alternative in this case may be an ECS, or entity-component-system, which allows methods and properties to be defined globally and then just attached to objects. This seems like it could be a nice way to keep things flatter (less encapsulated), and hopefully more readable.</p></article></div>
  </body>
</html>
