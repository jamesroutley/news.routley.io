<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://alok.github.io/2024/03/29/boolean-algebra-davide-radaelli/">Original</a>
    <h1>Boolean Algebra, Arithmetic POV</h1>
    
    <div id="readability-page-1" class="page"><div>
            


            <div role="main">
                <div>
                    




<article>
  <p>(written long time ago, publish or languish)</p>

<p>These are some notes I made for Davide Radaelli for the first section of Schuller’s lectures on physics.</p>

<p>Let’s turn Boolean algebra into something we know better: arithmetic.</p>

<p>First we’ll set False to 0 and True to 1. To handle overflow, any arithmetic is
mod 2. So even numbers are \(0\) and odd numbers are \(1\).</p>

<p>There are 4 unary operators:</p>

<ul>
  <li>2 constant functions: \(x \rightarrow 0\), \(x \rightarrow 1\)</li>
  <li>identity: \(x \rightarrow x + 0\). I like to write it as \((+0)\)</li>
  <li>negation: \(x \rightarrow x + 1\). I like to write it as \((+1)\) or \(-x\).</li>
</ul>

<p>Now for binary operators: <code>and</code> and <code>or</code>.</p>

<p><code>and</code> can be represented as multiplication. But <code>or</code> cannot be represented as
addition. True or True is True, but \(1 + 1 = 2 = 0 =\) False. That’s no good.</p>

<p>The annihilation properties of <code>and</code> and <code>or</code> suggest a way out.
<code>True or \_</code> is always True, <code>False or x</code> is the identity function on x.</p>

<p><code>False and _</code> is always False, <code>True and x</code> is the identity function on x.</p>

<p>Notice the duality between these properties. It’ll come in handy in a moment.</p>

<p>The solution for how to represent these popped into my head randomly, which I dislike
intensely, since that’s not a reliable problem solving method. But my
subconscious doesn’t care.</p>

<p>We can use min and max. \(x\) and \(y\) is \(\min(x, y)\), \(x\) or \(y\) is \(\max(x, y)\).
The properties above are represented as:</p>

<ul>
  <li>
\[\max(1, -) = 1\]
  </li>
  <li>
\[\max(0, x) = x\]
  </li>
  <li>
\[\min(0, -) = 0\]
  </li>
  <li>
\[\min(1, x) = x\]
  </li>
</ul>

<p><code>and</code> is interesting because it can be represented 2 ways, as min or as multiplication.</p>

<p>But what’s <code>+</code> then? Thinking categorically, sums are coproducts, which are on
the side of math that encodes the idea of single choices, <em>any</em> rather than <em>all</em>.
Closest match is <code>exclusive or</code>. Turns out that works (check the truth table
yourself to be sure).</p>

<p>The last big boolean operator to handle is implication. It’s exponentiation.</p>

<p>\(a\) implies \(b\) is the same as \(b^a\), at least if \(0^0\) is understood to be \(1\), which
combinatorics suggests. It satisfies all the relevant identities, except that \(a
^{(b+c)} \neq a^b + a^c\). It does work if you use or instead of xor though.</p>

<p>Here’s some Julia code to test it out. I manually checked the basic implication
truth table.</p>

<div><div><pre><code><span>using</span> <span>RandomizedPropertyTest</span>

<span>@quickcheck</span> <span>(</span><span>c</span><span>^</span><span>(</span><span>a</span> <span>*</span> <span>b</span><span>)</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>a</span><span>)</span><span>^</span><span>b</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>b</span><span>)</span><span>^</span><span>a</span><span>)</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>c</span><span>^</span><span>(</span><span>a</span> <span>⊻</span> <span>b</span><span>)</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>a</span> <span>*</span> <span>c</span><span>^</span><span>b</span><span>)</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>b</span> <span>*</span> <span>c</span><span>^</span><span>a</span><span>))</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>c</span><span>^</span><span>(</span><span>a</span> <span>|</span> <span>b</span><span>)</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>a</span> <span>*</span> <span>c</span><span>^</span><span>b</span><span>)</span> <span>==</span> <span>(</span><span>c</span><span>^</span><span>b</span> <span>*</span> <span>c</span><span>^</span><span>a</span><span>))</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>a</span> <span>*</span> <span>(</span><span>b</span> <span>|</span> <span>c</span><span>)</span> <span>==</span> <span>(</span><span>a</span> <span>*</span> <span>b</span><span>)</span> <span>|</span> <span>(</span><span>a</span> <span>*</span> <span>c</span><span>))</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>a</span> <span>|</span> <span>b</span> <span>==</span> <span>max</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>))</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>a</span> <span>&amp;</span> <span>b</span> <span>==</span> <span>min</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>==</span> <span>a</span> <span>*</span> <span>b</span><span>)</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span>
<span>@quickcheck</span> <span>(</span><span>a</span> <span>*</span> <span>(</span><span>b</span> <span>⊻</span> <span>c</span><span>)</span> <span>==</span> <span>(</span><span>a</span> <span>*</span> <span>b</span><span>)</span> <span>⊻</span> <span>(</span><span>a</span> <span>*</span> <span>c</span><span>))</span> <span>((</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span><span>::</span><span>Bool</span><span>)</span> <span># doesn&#39;t hold in all cases, such as a,b,c=1,1,0</span>
</code></pre></div></div>

<h2 id="predicate-logic">Predicate Logic</h2>

<p>Let’s explore \(\exists\) and \(\forall\).</p>

<p>Dually, \(\forall\) is interpreted as ‘all’. We can understand it as a product, using intersection as multiplication. Empty products are interpreted as True.</p>

<p><strong>Example:</strong> Consider a set we’re quantifying over is \(\{1, 2, 3\}\). Let \(P\) be a predicate that is true for 1 and false for 2 and 3. Then, we’d express \(\forall x P(x)\) as \(P(1) \land P(2) \land P(3)\). If at least one of these is false, then the entire expression is false, since you’re effectively multiplying by 0.</p>

<p>\(\exists\) is interpreted as ‘exists’ or ‘any’. Its analogy to a sum is that empty sums are False. All \(\exists\) statements about the empty set are automatically false. Instead of xor (the sum), we use or (max).</p>

<p><strong>Example:</strong> If the set we’re quantifying over is \(\{1, 2, 3\}\), and \(P\) is defined to be true for 1 and false for 2 and 3, then we’d express \(\exists x P(x)\) as \(P(1) \lor P(2) \lor P(3)\). If at least one of these is true, then the whole expression is true.</p>


</article>

  <!-- mathjax -->
  <!-- XXX Need to add  mathjax: true to each post to get it to work-->
  
    


  




  






  
  
  





  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


                </div>
            </div>
        </div></div>
  </body>
</html>
