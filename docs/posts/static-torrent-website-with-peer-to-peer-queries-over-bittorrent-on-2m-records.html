<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boredcaveman.xyz/post/0x2_static-torrent-website-p2p-queries.html">Original</a>
    <h1>Static torrent website with peer-to-peer queries over BitTorrent on 2M records</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
<h2>Static torrent website with peer-to-peer queries over BitTorrent on 2M records</h2>
<p>7/3/2022</p>
<h3>TL;DR</h3>
<p>Thanks to SQLite VFS abstraction, it is possible to implement your own file system on which SQLite parks data and structures. Inspired by Phiresky&#39;s <a href="https://github.com/phiresky/sql.js-httpvfs">sql.js-httpvfs</a> which uses <code>HTTP Range</code> requests to lazy load blocks of storage from a static web server, I changed few lines of code to point the VFS <code>read()</code> calls to a database seeded by peers as a torrent. A 300 MiB db with 2 million records can be queried from seeders for full text searches in less than 2 MiB traffic with the BitTorrent protocol, all inside the browser, in a static website. <a href="https://boredcaveman.xyz/demo/p2psearch">LIVE DEMO HERE!</a></p>
<h3>1. On the last demo</h3>
<p>In the last <a href="https://boredcaveman.xyz/post/0x1_dbless-torrent-website.html">post</a> I discussed about a demo of a static torrent website which retrieves a small database (13 MiB with 135,000 records) from the IPFS peer-to-peer network to let users do their searches. The purpose was to <strong>not let the database vanish</strong> in the void, together with the torrents, <strong>in case of service shutdown</strong>. The solution was to <strong>host it away from servers</strong>. Unfortunately this approach showed me the limits from the start: 10 seconds to download the whole database under ideal conditions, a little waste of time and network traffic for just a little database which I would use for a single query to retrieve 40 records out of 135,000. Not efficient and only suitable for small communities and local websites.</p>
<p>After posting it on <a href="https://news.ycombinator.com/item?id=29917818">HN</a> for comments, some users dropped this gem I didn&#39;t know about:</p>
<blockquote>
<p>&gt; Enhance it with the fact you can lazy load sqlite query using HTTP Range as demonstrated in: <a href="https://news.ycombinator.com/item?id=27016630">https://news.ycombinator.com/item?id=27016630</a></p>
</blockquote>
<blockquote>
<p>&gt; <a href="https://github.com/phiresky/sql.js-httpvfs">https://github.com/phiresky/sql.js-httpvfs</a></p>
</blockquote>
<h3>2. sql.js-httpvfs: under the looking glass</h3>
<p>As shown in a <a href="https://phiresky.github.io/blog/2021/hosting-sqlite-databases-on-github-pages/">post</a> by the author, this project makes possible to do sql queries on a database hosted on a static web server, <strong>without a backend</strong>, by <em>&#34;just&#34;</em> translating SQLite <code>read()</code> calls to <code>HTTP Range</code> requests for blocks of the .sqlite file. The results are out of this world:</p>
<blockquote>
<p>&gt; 20 GET requests, fetching a total of 270 KiB to do a complex query on a 670 MiB database with 8,000,000 records</p>
<p>&gt; 33 GET requests, fetching a total of 70 KiB to do a full text search on a 8 MiB table</p>
</blockquote>
<h4>2.1 SQLite VFS</h4>
<p>By doing my searches I discovered the main magic trick behind the project: <a href="https://sqlite.org/vfs.html">SQLite&#39;s VFS</a> (Virtual File System). Thanks to SQLite design it&#39;s possible to attach whatever implementation of a virtual file systems you like under its feet and make it work transparently. To do this you have to code a module that implements some functions like <code>read()</code> and <code>write()</code> the way it&#39;s described in the documentation and register the module with a call: <code>sqlite3_vfs_register(module)</code>.</p>
<p>The author has implemented a VFS using the good old synchronous XMLHttpRequests (XHR) in javascript by tricking them to get the requested portions of storage with the Range HTTP header from a remote server.</p>
<h4>2.2 .wasm</h4>
<p>Another magic trick involved is the connection of the <code>.js</code> VFS code with <code>.c</code> source code of SQLite.</p>
<p>At the moment I have no idea how this actually works and I can&#39;t reproduce it (I&#39;m busycaveman rn). As far as I know a wrapper function is injected when compiling the <code>.c</code> source code to <code>.wasm</code> with emscripten and then the <code>.js</code> VFS code is hooked at runtime by the browser. Part of the process has been automated by <a href="https://github.com/sql-js/sql.js">sql.js</a>.</p>
<h4>2.3 Lazy loading</h4>
<p>The last part of this insane project is the lazy loading. It&#39;s not strictly related to the project, rather it&#39;s in the nature of DBMS. Thanks to various indexing techniques used by database engines, the amount of I/O involved in a text search query is very low in terms of size. As mentioned before, 270 KiB of reads over a 670 MiB database to complete a complex query seems good compared to the whole 13 MiB database of the last demo.</p>
<h3>3. What if sql.js + VFS + torrent?</h3>
<p>By doing simple math I quickly realized that the same project would have worked if the whole database was parked on different peers and the XHR requests were translated to equivalent bittorrent piece requests. 270 KiB is absolutely nothing in these days.</p>
<p>The idea is nothing new. BitTorrent Inc already coupled these two pieces of puzzle in <a href="https://github.com/bittorrent/sqltorrent">https://github.com/bittorrent/sqltorrent</a>. Another developer took inspiration from that to build <a href="https://github.com/lmatteis/torrent-net">https://github.com/lmatteis/torrent-net</a> which uses sqltorrent in its backend and exposes a website interface to do text searches like a torrent website. But as I said from the start, I don&#39;t want any kind of backend running in the server, but just a static webpage with a bundle.js that works out of the box inside the browser. In this way the website could be copy-pasted easily.</p>
<p>Here&#39;s my journey.</p>
<h3>4. OUR code</h3>
<h4>4.1 WebTorrent</h4>
<p><a href="https://webtorrent.io/">WebTorrent</a> is a working bittorrent client library written in javascript that runs entirely on browser. It&#39;s actually a composition of low level modules well designed and separated. It uses WebRTC for peer-to-peer communications so it can only communicates with bittorrent clients that support WebRTC.</p>
<p>An interesting API function provided by this library let you select the exact range of bytes you need from a selected file in the torrent and gives you back a ReadableStream, which is good because you don&#39;t have to deal with peers/pieces/offsets. This call also prioritize that range. The code is simple:</p>
<pre><code>const client = new WebTorrent()
const torrentId = &#39;magnet:?xt=urn:btih:whatever+trackers+webseeds&#39;

client.add(torrentId, function (torrent) {
	const stream = torrent.files[0].createReadStream({ start: 0, end: 4096 - 1 })

	stream.on(&#39;data&#39;, (chunk) =&gt; {
		// chunk ready to be used
	})
})
</code></pre>
<h4>4.2 Fork of Phiresky&#39;s sql.js-httpvfs code (FAILED)</h4>
<p>I found the original code of the project very difficult to understand, mainly because I have no experience with nodejs and modules management / packaging. After spending a lot of time looking at the code I decided to look around for similiar projects. The main difficult was to find the correct spot to convert the whole chain of synchronous calls into <strong>a</strong>synchronous calls, starting from the <code>execute()</code> and <code>read()</code> down to the <code>doXHR()</code> (the function in charge of actually reading bytes from somewhere), since the WebTorrent library is event-based and requires promises to deal with it.</p>
<p>Fortunately I didn&#39;t have to look past the README.md to find an alternative:</p>
<blockquote>
<p>&gt; <a href="https://github.com/rhashimoto/wa-sqlite">wa-sqlite</a>, which is a much simpler wasm wrapper for SQLite than sql.js a and has different VFSes that don&#39;t require an EMScripten dependency. sql.js-httpvfs could easily be reimplemented on top of this.</p>
</blockquote>
<h4>4.3 Rhashimoto&#39;s wa-sqlite</h4>
<p>This user did a great job by doing the same work phiresky did just before implementing the httpVFS, to allow any user to implement its own VFS in its own way. The repo has also some working examples with synchronous and <strong>a</strong>synchronous calls like the <code>wa-sqlite/src/examples/MemoryAsyncVFS.js</code>:</p>
<pre><code>xRead(fileId, pData, iOffset) {
	// just a wrapper around a sync function
	return this.handleAsync(async () =&gt; {
		super.xRead(fileId, pData, iOffset)
	})
}
</code></pre>
<p>From this point I had all the ingredients, so I started cooking.</p>
<h3>5. The demo</h3>
<p><img src="https://boredcaveman.xyz/img/0x2_boss_small.jpeg" alt=""/></p>
<p><a href="https://boredcaveman.xyz/demo/p2psearch">LIVE DEMO HERE!</a></p>
<h4>5.1 Building and slicing the database</h4>
<p>In the repo of sql.js-httpvfs the author had to balance the number of requests and network traffic by tricking the page_size of the sqlite database and decided to use 1024 bytes instead of 4096 (default). According to the <a href="https://wiki.theory.org/index.php/BitTorrentSpecification">bittorrent protocol specification v1.0</a> my requests to peers must be of 16 KiB minimum, so I decided to use 16 KiB pages.</p>
<p>Sincerely I don&#39;t remember where I got this csv dump of torrents (they are all dead maybe). It&#39;s 200 MiB in size containing over 2,000,000 records. I prepared the database according to Phiresky&#39;s guide with little changes:</p>
<pre><code>sqlite3&gt; .mode csv
sqlite3&gt; .import dump.csv orig_torrents
sqlite3&gt; CREATE VIRTUAL TABLE torrents USING fts5(magnet UNINDEXED, title, size UNINDEXED);
sqlite3&gt; INSERT INTO torrents SELECT * FROM orig_torrents;
sqlite3&gt; .save example.sqlite3
sqlite3&gt; .quit
</code></pre>
<pre><code>sqlite3&gt; DROP TABLE orig_torrents;
sqlite3&gt; VACUUM;
sqlite3&gt; PRAGMA journal_mode = delete;
sqlite3&gt; PRAGMA page_size = 16384;
sqlite3&gt; INSERT INTO torrents(torrents) VALUES (&#39;optimize&#39;);
sqlite3&gt; VACUUM;
sqlite3&gt; .quit
</code></pre>
<p>Because the full text search module fts5 makes a copy of the values, it is safe to drop the original table. Now, from a 200 MiB csv dump I had a 310 MiB database fully indexed for text searches on titles.</p>
<h4>5.2 Repo changes</h4>
<p>I then worked on the <a href="https://github.com/rhashimoto/wa-sqlite">wa-sql</a> project.</p>
<p>Before running <code>make</code> to compile the SQLite amalgamation source code I added a flag to support the fts5 module:</p>
<pre><code>$ git clone https://github.com/rhashimoto/wa-sqlite
$ cd wa-sqlite
$ yarn install
$ vim Makefile

+	-DSQLITE_ENABLE_FTS5

$ make
$ cd src/
$ curl -O https://cdn.jsdelivr.net/npm/webtorrent@1.8.1/webtorrent.min.js
</code></pre>
<h4>5.3 Code</h4>
<p>It&#39;s worth mentioning that WebTorrent is designed as a high-level streaming torrent library composed by low level modules like bittorrent-protocol, bittorrent-dht etc... and because of this I had to deal with the limitation of <strong>not being able to ask ONLY for pieces I&#39;m interested in</strong>. Since it&#39;s not a final product but it&#39;s just a demo I&#39;m ok with it. The result is a low/medium waste of traffic which I tried to limit with some tricks.</p>
<p>Here&#39;s the main changes I made to <code>wa-sqlite/src/examples/MemoryAsyncVFS.js</code>:</p>
<pre><code>import * as VFS from &#39;../VFS.js&#39;
import WebTorrent from &#39;./webtorrent.min.js&#39;

const SLOW_SPEED = 16384 // At least 1 minRequestSize per second
const MAX_SPEED = -1
let torrentPieceLength = 0
let torrentLastPieceLength = 0

const client = new WebTorrent()

const torrentPromise = new Promise((resolve, reject) =&gt; {
	const torrentId = &#39;magnet:?xt=urn:btih:whatever+trackers+webseeds&#39;

	try {
		client.add(torrentId, (torrent) =&gt; {
			torrentPieceLength = torrent.pieceLength
			torrentLastPieceLength = torrent.lastPieceLength

			client.throttleDownload(SLOW_SPEED) 
			resolve(torrent)
		})
	} catch (err) {
		reject(err)
	}
})

xOpen(name, fileId, flags, pOutFlags) {
	return this.handleAsync(async () =&gt; {
		await torrentPromise
		return super.xOpen(name, fileId, flags, pOutFlags) // I don&#39;t care
	});
}

xRead(fileId, pData, iOffset) {
	// exclusive: [from, to)
	const from = iOffset
	const to = iOffset + pData.size
	const nBytes = to - from
	
	// same: [fromPiece, toPiece)
	const fromPiece = Math.floor(from / torrentPieceLength)
	const toPiece = Math.ceil(pData.size / torrentPieceLength)
	const nPieces = toPiece - fromPiece

	return this.handleAsync(async () =&gt; {
		const data = await new Promise((resolve, reject) =&gt; {
			torrentPromise.then((torrent) =&gt; {
				torrent.critical(fromPiece, toPiece - 1)
				client.throttleDownload(MAX_SPEED)
				return torrent.files[0].createReadStream({ start: from, end: to - 1 })
			}).then((stream) =&gt; {
				stream.on(&#39;data&#39;, (chunk) =&gt; {
					client.throttleDownload(SLOW_SPEED)
					resolve(chunk)
				})
			})
		})

		if (nBytes) {
			pData.value.set(new Int8Array(data, 0, nBytes));
		}

		if (nBytes &lt; pData.size) {
			pData.value.fill(0, nBytes);
			return VFS.SQLITE_IOERR_SHORT_READ;
		}
		return VFS.SQLITE_OK
	})
}

xFileSize(fileId, pSize64) {
	return this.handleAsync(async () =&gt; {			
		await torrentPromise.then((torrent) =&gt; {
			pSize64.set(torrent.length)
		})
		return VFS.SQLITE_OK;
	})
}

</code></pre>
<p>And here is how I glued all together inside the
<code>index.js</code>:</p>
<pre><code>import SQLiteAsyncESMFactory from &#39;./src/wa-sqlite-async.mjs&#39;;
import * as SQLite from &#39;./src/sqlite-api.js&#39;;
import { MemoryAsyncVFS } from &#39;./src/MemoryAsyncVFS.js&#39;;

let sqlite3a = {}
let dbPromise = {}
const initializeDb = (async function() {
	const SQLiteAsyncModule = await SQLiteAsyncESMFactory();

	sqlite3a = SQLite.Factory(SQLiteAsyncModule);
	sqlite3a.vfs_register(new MemoryAsyncVFS());
	
	// sqlite3a doesn&#39;t know what&#39;s behind xRead()
	// it&#39;s opening the database from seeders!
	dbPromise = sqlite3a.open_v2(&#39;memory-async&#39;, undefined, &#39;memory-async&#39;);
})()

async function search(input) {
	await initializeDb

	dbPromise
		.then((db) =&gt; {
			const query = `SELECT * FROM torrents WHERE title MATCH &#39;` + input + `&#39; LIMIT 20;`
			const callback = function(row, column) { results.innerText += row + &#39;\n&#39; }
			sqlite3a.exec(db, query, callback)
		})
}

// DOM code
document.querySelector(...)
</code></pre>
<p>After some clean up, the dir looked like this:</p>
<pre><code>$ tree
├── dist
│   ├── wa-sqlite-async.mjs
│   ├── wa-sqlite-async.wasm
├── src
│   ├── MemoryAsyncVFS.js
│   ├── MemoryVFS.js
│   ├── sqlite-api.js
│   ├── sqlite-constants.js
│   └── VFS.js
├── index.html
├── index.js
</code></pre>
<p>The last step was to bundle all together, reducing the number of files and size and making it browser compatible with webpack:</p>
<pre><code>$ yarn add webpack webpack-cli
$ ./node_modules/.bin/webpack ./index.js -o dist
$ tree
├── dist
│   ├── 89635f597f687bd55656.wasm
│   ├── bundle.js
├── index.html
</code></pre>
<p>You can find all the code at <a href="https://gitlab.com/boredcaveman/p2psearch">https://gitlab.com/boredcaveman/p2psearch</a></p>
<h3>6. Results</h3>
<ul>
<li>DB Size: 310 MiB</li>
<li>Records: 2,000,000 defined as (magnet, title, size)
<ul>
<li>magnets are just hash strings</li>
</ul>
</li>
<li>Loading time: 1/2 seconds to ask trackers for the database torrent</li>
<li>Execution time of a query: from 10 to 20 seconds to get 20 matches
<ul>
<li>results appears 1 by 1 as they are found, it needs 3 to 5 seconds to get the first matches</li>
</ul>
</li>
<li>Network traffic:
<ul>
<li>effective: 800 KiB to 2 MiB for a text search query limited at 20 results</li>
<li>waste: 1 to 15 MiB because pieces are downloaded without any control, with just prioritization of the pieces we&#39;re interested in</li>
</ul>
</li>
</ul>
<h3>7. Final thoughts</h3>
<p>Even though it&#39;s just a demo, this project does actually what I was trying to do from the start, a torrent website, or whatever text search website, that does not store the database on the server, but let the users participate in the hosting effort by making a copy of the public database and serving it from their computers in a peer-to-peer way. With this design, the takedown of a single website is useless since the actual data is not there. Also, hosting a static webpage is cheap and simple as downloading a torrent.</p>
<p>From a different point of view, a website like this acts as a software-server: you just ask for the software, and, once downloaded, the actual work is done locally by the browser.</p>
<h4>7.1 Pros ordered by relevance</h4>
<ul>
<li>It resists chensorship</li>
<li>Database size and number of records are not a problem</li>
<li>Text searches on the whole database</li>
<li>Low traffic (ideal)</li>
</ul>
<h4>7.2 Cons ordered by relevance</h4>
<ul>
<li>Privacy problem: everyone with a torrent client can see who is visiting the website, because every client is a peer asking for pieces of database</li>
<li>Waste of network traffic:
<ul>
<li>as said before, this demo uses a high-level bittorrent library, I have no control over the download aside from throttling and pieces prioritization</li>
</ul>
</li>
<li>At the moment, to do your part and host a copy of the database, you have to use a WebRTC capable bittorrent client like WebTorrent Desktop or websites like Instant.io. More infos at <a href="https://webtorrent.io/faq">https://webtorrent.io/faq</a></li>
</ul>
<p>Peace!</p>
<hr/>
<p>Hey dudes, since this demo s*cks it only needs 20 concurrent queries to saturate the network cap of my VPS, would you help me for just 1 day? Seed a copy of the database with <a href="https://webtorrent.io/desktop/">WebTorrent Desktop</a>, <a href="https://instant.io/">Instant.io</a> or any WebRTC capable client, or just keep the following code running in nodejs:</p>
<p>Magnet:</p>
<pre><code>magnet:?xt=urn:btih:160da04261d7c9544620003c7821ed780b18f7db&amp;dn=example.sqlite3&amp;tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&amp;tr=udp%3A%2F%2Fopen.tracker.cl%3A1337%2Fannounce&amp;tr=udp%3A%2F%2F9.rarbg.com%3A2810%2Fannounce&amp;tr=udp%3A%2F%2Fwww.torrent.eu.org%3A451%2Fannounce&amp;tr=udp%3A%2F%2Fvibe.sleepyinternetfun.xyz%3A1738%2Fannounce&amp;tr=udp%3A%2F%2Ftracker1.bt.moack.co.kr%3A80%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.zerobytes.xyz%3A1337%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.tiny-vps.com%3A6969%2Fannounce&amp;tr=wss%3A%2F%2Ftracker.btorrent.xyz&amp;tr=wss%3A%2F%2Ftracker.openwebtorrent.com
</code></pre>
<p><code>index.js</code></p>
<pre><code>import WebTorrent from &#39;webtorrent-hybrid&#39;
const client = new WebTorrent()

var magnetURI = &#39;magnet:?xt=urn:btih:160da04261d7c9544620003c7821ed780b18f7db&amp;dn=example.sqlite3&amp;tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&amp;tr=udp%3A%2F%2Fopen.tracker.cl%3A1337%2Fannounce&amp;tr=udp%3A%2F%2F9.rarbg.com%3A2810%2Fannounce&amp;tr=udp%3A%2F%2Fwww.torrent.eu.org%3A451%2Fannounce&amp;tr=udp%3A%2F%2Fvibe.sleepyinternetfun.xyz%3A1738%2Fannounce&amp;tr=udp%3A%2F%2Ftracker1.bt.moack.co.kr%3A80%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.zerobytes.xyz%3A1337%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.tiny-vps.com%3A6969%2Fannounce&amp;tr=wss%3A%2F%2Ftracker.btorrent.xyz&amp;tr=wss%3A%2F%2Ftracker.openwebtorrent.com&#39;

client.add(magnetURI, { path: &#39;/path/to/downloads/CHANGE_ME!!!1!&#39; }, function (torrent) {
	torrent.on(&#39;done&#39;, function () {
		console.log(&#39;Torrent download finished. Seeding...&#39;)
	})
})
</code></pre>
<pre><code>$ vim package.json
{
	&#34;type&#34;: &#34;module&#34;,
	&#34;dependencies&#34;: {
		&#34;webtorrent-hybrid&#34;: &#34;^5.0.2&#34;
	}
}
$ yarn install
$ nodejs index.js
</code></pre>

		</div>
	</div></div>
  </body>
</html>
