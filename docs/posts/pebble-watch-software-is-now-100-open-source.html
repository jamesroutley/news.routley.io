<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ericmigi.com/blog/pebble-watch-software-is-now-100percent-open-source">Original</a>
    <h1>Pebble Watch software is now 100% open source</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>
In this tenth installment of <a href="https://blog.veitheller.de/scheme-macros/">my series on Scheme macros</a>, we will be looking at some meta macros—macros that make the act of writing macros easier and cleaner.
  </p>
<p>
Specifically, we’re going to look at macros for the following:
  </p>
<div>
  <ul><li>Defining simpler macros more cleanly using <code>defmacro</code>,</li>
<li>generating fresh symbols when we need them using <code>gensym</code>, and</li>
<li>ensuring single evaluation of, for instance, macro arguments using <code>once</code>.</li>
  
</ul></div>
<p>
All of these are well-known macros and techniques, but we’ll be writing our own very simple implementations to gain an understanding of how an implementation like that could work. This means that for all of them, we are limiting their power. I’ll leave you with references to go deeper into a possible implementation for all of them. We’re not just going to scratch the surface, but we’re also not going spelunking today.
  </p>
<p>
As always, we’re going to use my little (mostly dead) Scheme dialect <a href="https://github.com/zepto-lang/zepto">zepto</a> for the implementation, but all of this should be portable with small tweaks.
  </p>

<p>
I’ve written more <code>define-syntax</code> macros than I can remember, and I still find them awkward to write and look at. I understand their power, but I still prefer a simpler function-like definition most of the time. Something like this:
  </p>
<div>
  <div>
      <pre><code>(defmacro my-when (test body ...)
  (if test
  	(begin body ...)
  	#f))
  
(my-when #t (write &#34;hello&#34;))
(my-when #f (write &#34;nope&#34;))</code></pre>
    </div>
  
</div>
<p>
It has less power, but also less overhead, and captures our intent. It’s perfect for simple macros with a single clause and without literal sets. Luckily, we can define this short-hand quite easily.
  </p>
<div>
  <div>
      <pre><code>(define-syntax defmacro
  (syntax-rules ()
    ((_ name (args ...) form)
      (define-syntax name
        (syntax-rules ()
          ((name args ...)
            form))))))</code></pre>
    </div>
  
</div>
<p>
If you’ve followed along for this entire series, this should read almost naturally. In case the nested <code>define-syntax</code> throws you off, however, here’s an explanation: we define a macro that takes its argument and splices it into another macro definition, such that we get this transformation:
  </p>
<div>
  <div>
      <pre><code>(defmacro my-when (test body ...)
  (if test
  	(begin body ...)
  	#f))
  	
; expands to
 
(define-syntax my-when
  (syntax-rules ()
    ((my-when test body ...)
      (if test
        (begin body ...)
        #f))))</code></pre>
    </div>
  
</div>
<p>
It’s a nice little shorthand that makes reading the macro much easier!
  </p>
<p>
If you want to learn more about how someone could implement a “full definition” of this, I encourage you to take a look at <a href="https://github.com/racket/racket/blob/8f0f634de986fe7f7c511477bff89711c615711a/racket/src/ChezScheme/examples/compat.ss#L204">how Racket implements `define-macro`</a>.
  </p>

<p>
Sometimes, we just need to generate a unique identifier. Macro hygiene handles this for us, but occasionally we will need to splice in an identifier into a piece of syntax. In a lot of Lisps, that is exactly what <code>gensym</code> does.
  </p>
<div>
  <div>
      <pre><code>(defmacro x () (gensym))

(write (x))
(write (x))</code></pre>
    </div>
  
</div>
<p>
The identifier printed out should be unique across calls to <code>x</code>.
  </p>
<p>
Again, we can implement this quite simply with a counter:
  </p>
<div>
  <div>
      <pre><code>(define gensym-prefix &#34;GENSYM-&#34;)
(define gensym-counter 1000)

(defmacro gensym ()
  (begin
    (set! gensym-counter (+ gensym-counter 1))
    (string-&gt;symbol (++ gensym-prefix (-&gt;string gensym-counter)))))</code></pre>
    </div>
  
</div>
<p>
Here, too, our newly minted <code>defmacro</code> makes things quite readable and short. All we do is increment our counter, append it to a prefix, and return the resulting symbol. It’s not exactly the cleanest code, but it approximates what every implementation of <code>gensym</code> does, including <a href="https://github.com/carp-lang/Carp/blob/master/core/Gensym.carp">the implementation for Carp (a statically compiled Lisp I’ve worked on) by yours truly</a>.
  </p>
<p>
In zepto, compile time and runtime are not separated and thread safety is not an issue, so this is fine. In other languages, this might be a bit more of a problem, which is why they choose a different implementation path.
  </p>
<p>
For instance, <a href="https://github.com/racket/racket/blob/8f0f634de986fe7f7c511477bff89711c615711a/racket/src/bc/src/symbol.c#L980">in Racket this is implemented in C</a>, although it does essentially the same thing. Still, reading small definitions like these are good exercises to understand a virtual machine’s implementation, so if you are interested in how a Scheme might be implemented in C, this might help.
  </p>

<p>
Macros have the inherent problem of dealing with syntax and thus behaving differently than we are used to from functions. Consider this:
  </p>
<div>
  <div>
      <pre><code>(defmacro square (x)
  (* x x))
	
(macro-expand &#39;(square (+ 1 5)))
; =&gt; (* (+ 1 5) (+ 1 5))</code></pre>
    </div>
  
</div>
<p>
Already we are duplicating work. Occasionally we’d like to be able to ensure a piece of code is really just evaluated once. Something like this:
  </p>
<div>
  <div>
      <pre><code>(defmacro square (x)
  (once (x)
    (* x x)))</code></pre>
    </div>
  
</div>
<p>
This macro is a classic known originally as <code>once-only</code>, implemented by the brilliant Peter Norvig. I first learned about it in the book <a href="https://letoverlambda.com/index.cl/guest/chap3.html#sec_6">Let over Lambda</a> by Doug Hoyte.
  </p>
<p>
Now, unfortunately we cannot do this in `syntax-rules` Scheme, since it would break hygiene, so we’d have to rely on something like this:
  </p>
<div>
  <div><pre><code>
(define-syntax once
  (syntax-rules ()
    ((_ ((t1 e1) (t2 e2) ...) body ...)
     (let ((t1 e1) (t2 e2) ...) body ...))))

(defmacro square (s)
  (once ((t s))
    (* t t)))</code></pre>
    </div>
  
</div>
<p>
Since this is boring and essentially boils down to a small wrapper around <code>let</code>, I believe we can do better if we are willing to throw hygiene under the bus and <code>eval</code> our way to success! This is left as an exercise to the reader.
  </p>
<p>
But fret not! We will still explore this macro, just in a setting that is more suited to it and where hygiene is not a concern. I’ll reach for Carp, but you might just as well look at it in Common Lisp or Clojure.
  </p>
<div>
  <div>
      <pre><code>(defndynamic replacerfn [arg]
  [(gensym) arg])

(defndynamic generate-let [acc replacer]
  (append acc [(list &#39;quote (car replacer)) (cadr replacer)]))

(defndynamic generate-reverse-let [acc replacer]
  (append acc [(cadr replacer) (list &#39;quote (car replacer))]))

(defmacro defmacro! [name args body]
  (let [replacer (map replacerfn args)]
      (eval
        `(defmacro %name %args
          %(list &#39;list &#39;(quote let) (reduce generate-let [] replacer)
            (list &#39;let (reduce generate-reverse-let [] replacer)
                body))))))

(defmacro! square [y] `(* %y %y))

(eval (square (do (macro-log &#34;hi&#34;) 10))) ; will print &#34;hi&#34; once</code></pre>
    </div>
  
</div>
<p>
A few years ago, I implemented a version of this with a few more capabilities <a href="https://github.com/hellerve/talks/blob/45d68eeb969ca3e11063f7df767e4222e3dbe657/recurse-february-2021/examples.carp#L41-L49">for a talk at the Recurse Center</a>. The version here is derived from that. For <code>once</code>, attacking the code from various angles can help you get a handle on it.
  </p>
<p>
This version essentially bakes <code>once</code> into the definition of <code>defmacro</code>, making our macro more robust against re-evaluation.
  </p>
<p>
Nonetheless, I will explain it to you. It essentially relies on a two-way binding at different times. Let’s go by evaluation order instead of definition order. The inner <code>let</code> will be evaluated first. It binds all symbols to their respective gensyms. This will then be evaluated to rewrite the body—every occurrence of the original variable will be replaced by the gensym.
  </p>
<p>
Let’s illustrate it (this is not exactly what happens, but might help with the intuition):
  </p>
<div>
  <div>
      <pre><code>; original pass:
(defmacro! square [y]
  `(* %y %y))
  
 ; first pass:
 (defmacro square [y]
   (let [y &#39;gensym-symbol]
     `(* %y %y)))
     
 ; evaluated first pass:
 (defmacro square [y]
  `(* %gensym-symbol %gensym-symbol))</code></pre>
    </div>
  
</div>
<p>
In the second pass, the outer <code>let</code> kicks in. It will be added to the definition rather than executed, and will bind the generated symbols to the original variable:
  </p>
<div>
  <div><pre><code>(defmacro square [y]
  `(* %gensym-symbol %gensym-symbol))
  
 ; expanded:
 (defmacro square [y]
   (let [gensym-symbol y]
    `(* %gensym-symbol %gensym-symbol)))</code></pre>
    </div>
  
</div>
<p>
And this is the code we finally end up with, ensuring that <code>y</code> will only be evaluated once, stored in a variable, and then rewritten.
  </p>
<p>
If this was a bit much, don’t fret! This macro is often described as one of the pinnacles of the craft, and Peter Norvig wrote “If you can understand how to write and when to use once-only, then you truly understand macros.” It’s a macro worth studying, but one that feels slippery even after you’ve implemented it a few times in various languages.
  </p>

<p>
And that concludes today’s session on macros! We’re getting into truly advanced territory now, implementing macros to make writing macros more convenient.
  </p>
<p>
I hope you enjoyed this session, I know I did! These macros are near and dear to my heart, and each one represents another layer of the macro onion peeled back!
  </p>
<p>
Let me know whether you liked this one, and if you have any more macro or language feature requests! I’ll be sure to put it in the backlog! See you around!
  </p>
      
    </div></div>
  </body>
</html>
