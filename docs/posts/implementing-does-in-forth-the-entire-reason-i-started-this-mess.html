<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boston.conman.org/2025/06/09.1">Original</a>
    <h1>Implementing DOES&gt; in Forth, the entire reason I started this mess</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<!-- google_ad_section_start --> <!-- Hey, it can't hurt! -->
<h2><a name="2025-06-09" href="https://boston.conman.org/2025/06/09">Monday, June 09, 2025</a></h2>

<h3><a rel="bookmark" name="2025-06-09.1" href="https://boston.conman.org/2025/06/09.1">Implementing DOES&gt; in Forth, the entire reason I started this mess</a></h3>

<!-- Forth, ANS Forth, implementing Forth, DOES>, assembly, 6809 -->

<p><a href="https://boston.conman.org/2025/06/02.1">The issue</a> I had with <code>DOES&gt;</code> isn&#39;t that it&#39;s hard to use—it&#39;s just that I had no idea how one would go about implementing it,
much like Javascript programmers use closures without having to think about how they&#39;re implemented
(even if they&#39;re aware of closures in the first place).
So,
before going into how it works,
a sample from <a href="https://www.forth.com/starting-forth/11-forth-compiler-defining-words/">Starting Forth</a> is in order.</p>

<pre title="Forth">: STAR 42 EMIT ;

: .ROW CR 8 0 DO
    DUP 128 AND IF STAR ELSE SPACE THEN 2*
  LOOP DROP ;

: SHAPE CREATE 8 0 DO C, LOOP
  DOES&gt; DUP 7 + DO I C@ .ROW -1 +LOOP CR ;

HEX 18 18 3C 5A 99 24 24 24 SHAPE MAN
</pre>


<p>These two words support the example.
The first word, <code>STAR</code> just prints a asterisk
(42 is the ASCII code for the word).
The second word,
<code>.ROW</code>,
takes an 8-bit value and for each bit,
if it&#39;s a 1,
prints an asterisk,
otherwise,
it prints a space.
<code>DO</code> <code>LOOP</code> is Forth&#39;s <code>for</code> loop by the way.
The next word,
<code>SHAPE</code> is the interesting one.
But first,
we need to discuss <code>CREATE</code>.</p>

<p>This word creates a new entry in the Forth dictionary by reading the next word
(defined as a collection of non-space letters)
in the input as the name.
It then gives the newly created word a default action of pushing the address of the body of the word into the stack.
Going ahead a bit,
the word <code>MAN</code> just after <code>CREATE</code> is run will look like this
(in assembly):</p>

<pre title="Assembly">man		fdb	shape	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;man&#39;
.xt		fdb	forth_core_create.runtime
.body
</pre>


<p>When <code>MAN</code> is run,
the address of <code>.body</code> will be pushed onto the stack.
<code>CREATE</code> is typically used to create “smart data structures”—data structures that know how to do some action.</p>

<p>Now,
getting back to the example,
when <code>SHAPE</code> is run,
the first thing it does is call <code>CREATE</code> to create a new word,
then it compiles 8 values off the top of the stack into the body of the newly created word.
Just prior to <code>DOES&gt;</code>, 
<code>MAN</code> will look like:</p>

<pre title="Assembly">man		fdb	shape	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;man&#39;
.xt		fdb	forth_core_create.runtime
.body		fcb	$24
		fcb	$24
		fcb	$24
		fcb	$99
		fcb	$5A
		fcb	$3C
		fcb	$18
		fcb	$18
</pre>


<p>Now we get to <code>DOES&gt;</code>.
Due to the nature of what it does,
<code>DOES&gt;</code> is an immediate word—that is,
its executing during compilation to do the voodoo that it do.
Um, does.
Somehow,
it needs to modify the newly created word to not only push the address of its body onto the stack,
but execute the code that appears after itself.
So the code to be executed needs to be compiled and stored somewhere,
and somehow <code>MAN</code>
(in this example) needs to run this code.</p>

<p>And this was the problem I had with the word—<em>how does this all work?</em>
Even the well known <a href="http://git.annexia.org/?p=jonesforth.git;a=summary">JonesForth</a>,
implemented as an <abbr title="Indirect Threaded Code">ITC</abbr>,
<a href="http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.f;h=5c1309574ae1165195a43250c19c822ab8681671;hb=HEAD#l1769">didn&#39;t bother with implementing <code>DOES&gt;</code></a>
(and now that I have implemented <code>DOES&gt;</code>,
I suspect I know why JonesForth didn&#39;t implement it).</p>

<p>The runtime portion of <code>CREATE</code> just pushes the address of the body of the word into the stack.
The data bytes following the <var>xt</var> have no meaning in and of themselves
(even as code it&#39;s nonsensical).
I did a search and found only <a href="https://www.bradrodriguez.com/papers/moving3.htm">one page</a> that describes how to implement <code>DOES&gt;</code>,
but:</p>

<ol>
<li>it was part three of a series of articles describing how Forth&#39;s are implemented;</li>
<li>using terminology no longer used by the ANS Forth standard;</li>
<li>attempting to describe how to implement Forth on several different <abbr title="Central Processing Unit">CPU</abbr> architectures;</li>
<li>using a few different methods (like <abbr title="Indirect Threaded Code">ITC</abbr>, <abbr title="Direct Threaded Code">DTC</abbr> and <abbr title="Subroutine Threaded Code">STC</abbr>);</li>
<li>and on this page, a wierd side trip through another Forth word <code>;CODE</code>.</li>
</ol>

<p>It wasn&#39;t an exactly easy source to read,
but between part three and <a href="https://www.bradrodriguez.com/papers/moving1.htm">part one</a>,
I was able to puzzle it out
(and it makes much more sense now that I&#39;ve done it).
Now I can discribe the result using a single architecture
(6809) and a single implementation (<abbr title="Indirect Threaded Code">ITC</abbr>).
The trick here is to realize that <code>DOES&gt;</code> has a temporal aspect unlike any other Forth word.</p>

<p>Most immediate words in Forth have two temporal aspects—at the time of compilation,
and later at runtime.
For instance,
<code>IF</code>&#39;s compile time aspect is to compile a conditional jump into the word,
and the runtime aspect is to do said conditional jump
(at least,
it does so in my implementation).
But <code>DOES&gt;</code> has <em>three</em> temporal aspects:</p>

<pre title="Forth">: SHAPE CREATE ...a DOES&gt; ( time 1 ) ...b ;
...c SHAPE MAN (time 2 )
MAN (time 3 )
</pre>


<p>At time 1,
we are compiling a word that creates other words
(so at this point, <code>CREATE</code> is compiled, not run).
The compiler looks up <code>DOES&gt;</code>, 
notices that it&#39;s an immediate word and executes it.
<code>DOES&gt;</code> at this point needs to include code to cause <code>SHAPE</code> to stop executing,
then somehow leave … something … behind for time 2,
and somehow compile the rest of the code <code>...b</code> for later execution.</p>

<p>At time 2,
we&#39;re defining a new word.
<code>CREATE</code> has been called and the initialization code for this new word <code>…a</code> has been executed.
At this point,
<code>DOES&gt;</code> needs to modify the new word … somehow … to execute the code that followed it at time 1.</p>

<p>And at time 3,
the word created is run and somehow,
it needs to know where the code to run is located.
But going back to what <code>CREATE</code> and the inialization code left us:</p>

<pre title="Assembly">man		fdb	shape	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;man&#39;
.xt		fdb	forth_core_create.runtime
.body		fcb	$24
		fcb	$24
		fcb	$24
		fcb	$99
		fcb	$5A
		fcb	$3C
		fcb	$18
		fcb	$18
</pre>


<p>What can be done?</p>

<p>The easy answer—<code>DOES&gt;</code> updates the <var>xt</var> of the newly created word at time 2.
Where is this <var>xt</var> created?
At time 1.
And when is it uses?
At time 3.</p>

<p>Here&#39;s what happens.</p>

<p><code>DOES&gt;</code> is an immediate word.
When it runs at time 1,
it compiles into the current word
(in this example, <code>SHAPE</code>)
the <var>xt</var> of its runtime.
So <code>SHAPE</code> will look like this:</p>

<pre title="Assembly">shape		fdb	dot_row	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;shape&#39;
.xt		fdb	forth_core_colon.runtime
		fdb	forth_core_create.xt
		fdb	forth_core_literal.runtime_xt
		fdb	8
		fdb	forth_core_literal.runtime_xt
		fdb	0
		fdb	forth_core_do.runtime_xt
.L1		fdb	forth_core_literal.runtime_xt
		fdb	128
		fdb	forth_core_and.xt
		fdb	forth_core_if.runtime_xt
		fdb	.L2
		fdb	dot_row.xt
		fdb	forth_core_ext_again.runtime_xt
		fdb	.L3
.L2		fdb	forth_core_space.xt
.L3		fdb	forth_core_two_star.xt
		fdb	forth_core_loop.runtime_xt
		fdb	.L1
		fdb	forth_core_drop.xt
		fdb	forth_core_does.runtime_xt
</pre>


<p>(Note:  here you can see that literal numbers have the <code>LITERAL</code> runtime action,
that <code>IF</code> compiles to its runtime action.
There are two Forth words that pretty much do the same thing—<code>AHEAD</code> does an unconditional branch forward,
and <code>AGAIN</code> does an unconditional branch backwards;
they basically both do an unconditional branch,
so I picked one to handle both internally and I picked <code>AGAIN</code> for this.
More on this in a later post.)</p>

<p>To create the new <var>xt</var> that words created by <code>SHAPE</code> will use
(or any word that includes <code>DOES&gt;</code>)
it then lays out a single instruction,
<code>JSR forth_core_create.does_hook</code>
(more on this in a bit).
It then exits,
keeping the compiler “on” so the rest of the code that follows <code>DOES&gt;</code> gets compiled into the word
(<code>SHAPE</code> in this case).
This is all <code>DOES&gt;</code> does (man, that sounds weird) at time 1.
At the end,
<code>SHAPE</code> looks like:</p>

<pre title="Assembly">shape		fdb	dot_row	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;shape&#39;
.xt		fdb	forth_core_colon.runtime
		fdb	forth_core_create.xt
		fdb	forth_core_literal.runtime_xt
		fdb	8
		fdb	forth_core_literal.runtime_xt
		fdb	0
		fdb	forth_core_do.runtime_xt
.L1		fdb	forth_core_literal.runtime_xt
		fdb	128
		fdb	forth_core_and.xt
		fdb	forth_core_if.runtime_xt
		fdb	.L2
		fdb	dot_row.xt
		fdb	forth_core_ext_again.runtime_xt
		fdb	.L3
.L2		fdb	forth_core_space.xt
.L3		fdb	forth_core_two_star.xt
		fdb	forth_core_loop.runtime_xt
		fdb	.L1
		fdb	forth_core_drop.xt
		fdb	forth_core_does.runtime_xt

.does		jsr	forth_core_create.does_hook	; !!!

		fdb	forth_core_dupe.xt
		fdb	forth_core_literal.runtime_xt
		fdb	7
		fdb	forth_core_plus.xt
		fdb	forth_core_do.runtime_xt
.L4		fdb	forth_core_i.xt
		fdb	forth_core_c_fetch.xt
		fdb	dot_row.xt
		fdb	forth_core_literal.runtime_xt
		fdb	-1
		fdb	forth_core_ext_plus_loop.runtime_xt
		fdb	.L4
		fdb	forth_core_c_r.xt
		fdb	forth_core_exit.xt
</pre>


<p>Now we execute <code>SHAPE</code>.
Things go along until we get to <code>forth_core_does.runtime_xt</code>.
At this point,
the <code>Y</code> register is pointing to the <code>JSR forth_core_create.does_hook</code>
(see <a href="https://boston.conman.org/2025/06/04.1">the previous installment for why this is</a>—but to recap:
the <code>Y</code> register is the Forth <abbr title="Instruction Pointer">IP</abbr>).
We get the <var>xt</var> of the newly created word
(and yes,
I had to modify <code>CREATE</code> to stash this for later use)
to replace the default <var>xt</var>.
At this point, <code>MAN</code> now looks like:</p>

<pre title="Assembly">man		fdb	shape	; link to next word
		fdb	.xt - .name
.name		fcc	&#39;man&#39;
.xt		fdb	shape.does
.body		fcb	$24
		fcb	$24
		fcb	$24
		fcb	$99
		fcb	$5A
		fcb	$3C
		fcb	$18
		fcb	$18
</pre>


<p>Then the <code>DOES&gt;</code> runtime basically does a Forth return,
ending the execution of <code>SHAPE</code>.
Thus ends the steps that happen at time 2.</p>

<p>When <code>MAN</code> executes,
it executes <code>JSR forth_core_create.does_hook</code>.
This is a small extension to forth_core_create that does the double duty of pushing the address of the body onto the stack,
and setting things up to run the Forth code compiled just after that instruction:</p>

<pre title="Assembly">forth_core_create
		fdb	forth_core_c_r
		fdb	.xt - .name
.name		fcc	&#34;CREATE&#34;
.xt		fdb	.body
.body		...		; not important right now

.does_hook	puls	d	; pull return address of the stack
		pshs	y	; push Forth IP onto return stack
		tfr	d,y	; point to DOES&gt; code
.runtime	leax	2,x	; get body from xt
		pshu	x	; push into the stack
		ldx	,y++	; NEXT
		jmp	[,x]
</pre>


<p>The <code>forth_core_create.does_hook</code> pulls the return address
(from the <code>JSR</code> instruction) from the stack—this contains the Forth code after <code>DOES&gt;</code> that needs to run.
We then push the existing <code>Y</code> register onto the stack,
then set <code>Y</code> to the Forth code to execute.
This leads right into <code>forth_core_create.runtime</code>,
which pushes the body of the word
(in this case, <code>MAN</code>)
onto the stack,
and then jumps into the code following the <code>DOES&gt;</code>.</p>

<p>And at the end of all this,
you get:</p>

<pre title="Forth">MAN
   **   
   **   
  ****  
 * ** * 
*  **  *
  *  *  
  *  *  
  *  *
 OK
</pre>


<p>I suspect the reason why JonesForth didn&#39;t implement <code>DOES&gt;</code> has to do with the direct subroutine call in the middle of a Forth word.
This only works if memory is both writable and exectuable,
and modern systems tend to disallow that.
There might be a way around this,
but I haven&#39;t yet bothered to figure it out.
I&#39;m just happy to have figured it out as it is.</p>

<hr/>

<h4>Discussions about this entry</h4>

<ul>
<li><a href="https://lobste.rs/s/w1ludh/implementing_does_forth_entire_reason_i">Implementing DOES&gt; in Forth, the entire reason I started this mess | Lobsters</a></li>
<li><a href="https://lemmy.bestiver.se/post/432839">Implementing DOES&gt; in Forth, the entire reason I started this mess - Lemmy: Bestiverse</a></li>
<li><a href="https://news.ycombinator.com/item?id=44231594">Implementing DOES&gt; in Forth, the entire reason I started this mess | Hacker News</a></li>

</ul>


<!-- google_ad_section_end -->
</div></div>
  </body>
</html>
