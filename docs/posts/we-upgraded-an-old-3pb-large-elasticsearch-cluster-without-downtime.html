<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://underthehood.meltwater.com/blog/2022/11/11/how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/">Original</a>
    <h1>We upgraded an old, 3PB large, Elasticsearch cluster without downtime</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/3-petabyte-es-upgrade-light.jpg" width="240" title="Machine (robot) learning how to do load balancing"/></p><p>Back in 2018, now five years ago, we published <a href="https://underthehood.meltwater.com/blog/2018/02/06/running-a-400+-node-es-cluster/">a blog post</a> describing our 400+ node Elasticsearch cluster. In that post we brought up an important topic:</p><blockquote><p>So far, we have elected to not upgrade the cluster. We would like to, but so far there have been more urgent tasks. How we actually perform the upgrade is undecided, but it might be that we choose to create another cluster rather than upgrading the current one.</p></blockquote><p>Well, the day to upgrade finally came. </p><p>A few weeks ago, we completed the last steps in terminating our old, 1100 nodes large Elasticsearch cluster and its surrounding infrastructure. At that time, all dependent applications had already been routed over to our new Elasticsearch cluster that would replace it. This meant that the shutdown itself was a non-event for our users, but for us in the team, it was an important milestone and a worthy ending to a successful multi year project.</p><p>We decided to write this blog post series to share the learnings we made and describe some of the challenges we had and how we overcame them.</p><p>This blog-post describes the project overview, the challenges we had with the old cluster and the constraints we operated within. The other posts in this series will deep dive into other interesting topics. We plan to release one new post at least every week up until Christmas, with roughly the following schedule</p><ul><li><p>Part 2 - Two consistent clusters (Nov 18)</p></li><li><p>Part 3 - Search Performance &amp; Wildcards (Nov 25)</p></li><li><p>Part 4 - Tokenization for high recall in all languages (Dec 2)</p></li><li><p>Part 5 - Development process (Dec 9)</p></li><li><p>Part 6 - Testing &amp; Rollout strategy (Dec 16)</p></li><li><p>Part 7 - Final architecture &amp; Learnings (Dec 23)</p></li></ul><p>So stay tuned for more.</p><h2 id="background-and-use-cases">Background and use cases</h2><p>As described in <a href="https://underthehood.meltwater.com/blog/2018/11/05/optimal-shard-placement-in-a-petabyte-scale-elasticsearch-cluster/">prior blog posts</a>, we at Meltwater are users of the <a href="https://github.com/elastic/elasticsearch">Elasticsearch open source search engine</a>. We use it to store around <strong>400 billion</strong> <em>social media posts</em> and <em>editorial articles</em> from all the news sources you can imagine. The platform then provides our customers with search results, graphs, analytics, dataset exports and high-level insights.</p><p>Up until last month, this massive dataset was hosted on a custom forked and in-house maintained version of Elasticsearch. The cluster contained close to 1100 <a href="https://aws.amazon.com/ec2/instance-types/i3en/">i3en.3xlarge</a> nodes running in AWS. The cluster had many thousands of indices, almost 100,000 shards and close to 1PB of primary data, reaching over 3PB with replicas.</p><p>Today, after the upgrade, the dataset is actually a bit larger, <strong>3.5PB</strong> (for reasons that we will explain in a later blog post) and the total number of nodes is now “only” 320 (mainly <a href="https://aws.amazon.com/ec2/instance-types/i3en/">i3en.6xlarge</a> instances). Perhaps most importantly, we now run <em>an officially supported version of Elasticsearch</em>.</p><h2 id="reasons-for-the-upgrade">Reasons for the upgrade</h2><p>For older versions of Elasticsearch, Elastic and Amazon advise against running clusters larger than 100 nodes. But as you have probably gathered by now, we passed that limit many years ago. We kept patching and improving our custom version to keep serving our business growth and ever-expanding use cases.</p><p>However, as our cluster grew, we eventually began to feel the limitations of running such an old version. For example, the version we used did not handle incremental updates to the cluster state very well. Elasticsearch sent around <em>the entire state</em>, which in our case was &gt;100mb large, to <em>every single one</em> of our 1100 nodes, <em>for every single state change.</em> This meant that a significant bottleneck was our 100 Gigabit network bandwidth on the master nodes.</p><p>Some other trouble areas running the old Elasticsearch version were:</p><ul><li><p>Unpredictable behavior when nodes and shards were leaving/joining the cluster</p></li><li><p>The S3 backup handling</p><ul><li>Due to <a href="https://github.com/elastic/elasticsearch-cloud-aws/issues/174">inefficiencies in how the old version of Elasticsearch handled S3 type repositories,</a> we were unable to delete old backups fast enough to keep up with the inflow of new data. So our backups kept on growing and growing in size.</li></ul><p><img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/snapshot-bucket-size-growing-graph.png" width="600" title="Graph showing snapshot sizes growing"/></p><ul><li>We had to periodically switch the S3 bucket and start over with a new snapshot from scratch a few times per year to keep the storage costs at an acceptable level.</li></ul></li><li><p>Spiky heap usage combined with insufficient (or lacking) circuit breakers and safety nets</p><ul><li><p>We had numerous occasions where a poorly written user query was allowed to execute and allocate too much memory, and caused nodes to enter <a href="https://www.infoq.com/articles/Java_Garbage_Collection_Distilled/">gc hell</a> and crash.</p></li><li><p>GC hell means that a node is spending all its time and cpu on garbage collection and does not have time to do other useful work, such as responding to cluster pings or executing searches. A node that enters this phase slows down the entire cluster as the master, and all other nodes, get timeouts on their requests to the node in gc hell. <a href="https://www.infoq.com/articles/Java_Garbage_Collection_Distilled/">Java garbage collection is a fascinating subject, but out of scope for this blog post.</a></p></li></ul><p><img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/max-jvm-heap-used-graph.png" width="600" title="Graph showing JVM heap used"/></p><ul><li>Not to mention that even when nodes were operating in “normal” mode, the heap usage looked very spiky and unpredictable.</li></ul></li><li><p>Too much of our <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/near-real-time.html">segment data</a> was stored on the heap</p><ul><li>We used &gt;10TiB of RAM, or about 40% of our total available Java heap in the whole cluster for segment data alone. The <em>Java heap</em> (not disk or cpu) was our primary scaling metric for the whole cluster</li></ul></li><li><p>Unable to use newer versions of Java and more modern garbage collection implementations.</p><ul><li><p>This forced us not to use more than 30GB java heap per node, even if the OS could have several 100s of GB RAM available.</p></li><li><p>In turn, this, forced us to scale out (= more machines) instead of scaling up (=more powerful machines), which is not always the most optimal choice</p></li></ul></li></ul><p>All of the above issues, and more, we believed would be improved if we upgraded to a later version of Elasticsearch.</p><p>Last but not least, we also knew that Meltwater would continue to grow. We knew that we would have a continuous need to support even more data, more users and more use cases in the future, and we felt that we were approaching a hard limit on the size of the cluster on the current Elasticsearch version.</p><p>Therefore, the organization finally decided that it was time to invest in a the mutli-year project to upgrade our Elasticsearch cluster.</p><h2 id="where-did-we-land">Where did we land?</h2><p>As previously explained, we will share a lot more on <em>how</em> we did the migration but we wanted to start by giving you a sneak peek into the benefits the upgrade gave us in the end, and it is best explained in a number of figures.</p><p>In all figures below <strong>light blue</strong> = the old cluster, and <strong>dark blue</strong> = the new cluster.</p><p> <img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/number-of-elasticsearch-nodes-old-vs-new-cluster.png" width="400" title="Number of nodes in old vs new cluster"/> <img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/snapshot-bucket-sizes-old-vs-new-cluster.png" width="400" title="Snapshot bucket size in old vs new cluster"/></p><p>The <strong>left figure</strong> shows that we were able to run with ~320 nodes instead of &gt;1100. It also shows how long we were running with two parallel clusters and the gradual scale up/scale down we could do as more and more data and searches were moved from the old into the new system.</p><p>The <strong>right figure</strong> shows that the uncontrolled growth of the snapshot size was indeed fixed in the new elasticsearch version and we can now keep the backup costs down.</p><p> <img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/max-jvm-heap-usage-showing-improved-performance.png" width="400" title="Graph showing max JVM heap usage"/> <img src="https://underthehood.meltwater.com/images/own/2022-11-11-how-we-upgraded-an-old-3pb-large-elasticsearch-cluster-without-downtime-part-1-introduction/sum-jmp-heap-showing-improved-performance.png" width="400" title="Graph showing sum of JVM heap on all nodes"/></p><p>These two figures show the improvements that were made in heap usage patterns. The <strong>left figure</strong> shows that the heap usage is basically flat for the new cluster. The <strong>right figure</strong> shows that the sum of the heap usage is also lower now (<strong>14 TiB</strong> vs <strong>22 TiB</strong>) even though that was not a goal by itself.</p><p>We can also see in the above figures that we have been able to further optimize and <em>scale down</em> the new cluster after the migration was completed. That would not have been possible in the old version where we always had to scale up due to the constant growth of our dataset.</p><p>But, let’s not get ahead of ourselves further than this. This blog post series is just as much about <em>how</em> and <em>why</em> we did things and not only about what we gained in the end.</p><p>So, back to the story about the migration.</p><h2 id="rollout-requirements">Rollout requirements</h2><p>Meltwater is a global company, which means that our systems need to operate and be available 24 hours a day, 7 days a week.</p><p>While we can schedule occasional downtimes for maintaining parts of our system, taking down the engine that powers all of Meltwater’s search and analytics functionality was simply not an option. Therefore, any rollout strategy without a safe rollback strategy was not acceptable.</p><p>Given this constraint, our only option was to plan an upgrade path that would make the process invisible to our customers, to our support organization and all the other 30+ development teams we have in the company.</p><p>Further, we also had a requirement to do an incremental rollout where we could switch individual queries/users/applications back and forth between the new and the old system.</p><p>So in short, we had to design a <strong>gradual, reversible, no-downtime</strong> rollout for the whole system.</p><p>Stay tuned for the next part in this series to learn about how we set out to solve for those requirements by using two Elasticsearch clusters running in parallel serving the same data.</p><p><em>Up next: Two consistent clusters (Coming soon)</em></p></div></div>
  </body>
</html>
