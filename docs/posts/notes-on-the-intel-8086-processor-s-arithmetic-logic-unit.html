<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2026/01/notes-on-intel-8086-processors.html">Original</a>
    <h1>Notes on the Intel 8086 processor&#39;s arithmetic-logic unit</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7538688365288775324" itemprop="description articleBody">
<p>In 1978, Intel introduced the 8086 processor, a revolutionary chip that led to the modern x86 architecture.
Unlike modern 64-bit processors, however, the 8086 is a 16-bit chip.
Its arithmetic/logic unit (ALU) operates on 16-bit values, performing arithmetic operations such as addition and subtraction,
as well as logic operations including bitwise AND, OR, and XOR.
The 8086&#39;s ALU is a complicated part of the chip, performing 28 operations in total.<span id="fnref:operations"><a href="#fn:operations">1</a></span></p>
<p>In this post, I discuss the circuitry that controls the ALU, generating the appropriate control signals for a
particular operation.
The process is more complicated than you might expect. First, a machine code instruction results in the execution of multiple
microcode instructions.
Using the ALU is a two-step process: one microcode instruction (micro-instruction) configures the ALU for the desired operation,
while a second
micro-instruction gets the results from the ALU.
Moreover, based on both the microcode micro-instruction and the machine code instruction, the control circuitry sends control signals to the ALU,
reconfiguring it for the desired operation.
Thus, this circuitry provides the &#34;glue&#34; between the micro-instructions and the ALU.</p>
<p>The die photo below shows the 8086 processor under a microscope.
I&#39;ve labeled the key functional blocks.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes the instructions.
In the lower right corner, the microcode ROM holds the micro-instructions.
The ALU is in the lower left corner, with bits 7-0 above and bits 15-8 below, sandwiching the status flag circuitry.
The ALU control circuitry, highlighted in red at the bottom of the chip, is the focus of this article.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/die-labeled.jpg"><img alt="The die of the 8086 with the metal layer removed to show the silicon and polysilicon underneath. Click this image (or any other) for a larger version." height="622" src="https://static.righto.com/images/8086-alu-notes/die-labeled-w600.jpg" title="The die of the 8086. Click this image (or any other) for a larger version." width="600"/></a></p><p>The die of the 8086. Click this image (or any other) for a larger version.</p>
<h2>Microcode</h2>
<p>The 8086 processor implements most machine instructions in microcode, with a micro-instruction for each step of the machine instruction.
(I discuss the 8086&#39;s microcode in detail <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">here</a>.)
The 8086 uses an interesting architecture for microcode:
each micro-instruction performs two unrelated operations. The first operation moves data between a source and a destination.
The second operation can range from a jump or subroutine call to a memory read/write or an ALU operation.
An ALU operation has a five-bit field to specify a particular operation and a two-bit field to specify
which temporary register provides the input. As you&#39;ll see below, these two fields play an important role in the ALU circuitry.</p>
<p>In many cases, the 8086&#39;s micro-instruction doesn&#39;t specify the ALU operation, leaving the details to be substituted from the machine instruction opcode.
For instance, the ADD, SUB, ADC, SBB, AND, OR, XOR, and CMP
machine instructions share the same microcode, while the hardware selects the ALU operation from the instruction opcode.
Likewise, the increment and decrement instructions use the same microcode, as do the decimal adjust instructions DAA and DAS, and the
ASCII adjust instructions AAA and AAS.
Inside the micro-instruction, all these operations are performed with a &#34;pseudo&#34; ALU operation called XI (for some reason).
If the microcode specifies an XI ALU operation, the hardware replaces it with the ALU operation specified in the instruction.
Another important feature of the microcode is 
that you need to perform one ALU micro-instruction to configure the ALU&#39;s operation, but the result isn&#39;t
available until a later micro-instruction, which moves the result to a destination.
This has the consequence that the hardware must remember the ALU operation.</p>
<p>To make this concrete, here is the microcode that implements a typical arithmetic instruction such as <code>ADD AL, BL</code> or <code>XOR [BX+DI], CX</code>.
This microcode consists of three micro-instructions. 
The left half of each micro-instruction specifies a data movement, first moving the two arguments to ALU temporary registers
and then storing the ALU result (called Σ).
The right half of each micro-instruction performs the second task.
First, the ALU is configured to perform an <code>XI</code> operation using temporary register A. Recall that <code>XI</code> indicates the ALU operation
is filled in from the machine instruction; this is how the same microcode handles eight different types of machine instructions.
In the second micro-instruction, the next machine instruction is started unless a memory writeback is required (<code>WB</code>).
The last micro-instruction is <code>RNI</code> (Run Next Instruction) to start a new machine instruction. It also indicates that the
processor status flags (<code>F</code>) should be updated to indicate if the ALU result is zero, positive, overflow, and so forth.<span id="fnref:addressing"><a href="#fn:addressing">2</a></span></p>

<pre>M → tmpa   XI   tmpa  <span>Load first argument, configure ALU.</span>
R → tmpb   WB,NXT     <span>Load second argument, start Next instruction if no memory writeback</span>
Σ → M      RNI  F     <span>Store ALU result, Run Next Instruction, update status Flags</span>
</pre>

<h2>The ALU circuit</h2>
<p>The ALU is the heart of a processor, performing arithmetic and logic operations.
Microprocessors of the 1970s typically supported addition and subtraction; logical AND, OR, and XOR; and various bit shift operations.
(Although the 8086 had multiply and divide instructions, these were implemented in microcode, not in the ALU.)
Since an ALU is both large and critical to performance, chip architects try to optimize its design.
As a result, different microprocessors have widely different ALU designs.
For instance, the 6502 microprocessor has separate circuits for addition and each logic operation; a multiplexer selects the appropriate
output.
The Intel 8085, on the other hand, uses an optimized clump of gates that performs the desired operation based on control signals (<a href="https://www.righto.com/2013/01/inside-alu-of-8085-microprocessor.html">details</a>), while the Z80&#39;s 4-bit CPU uses a different clump of gates (<a href="https://www.righto.com/2013/09/the-z-80-has-4-bit-alu-heres-how-it.html">details</a>).</p>
<p>The 8086 takes a different approach, using two lookup tables (along with other gates) to generate the carry and output signals for each bit in the ALU.
By setting the lookup tables appropriately, the ALU can be configured to perform the desired operation.
(This is similar to how an FPGA implements arbitrary functions through lookup tables.)
The schematic below shows the circuit for one bit of the ALU.
I won&#39;t explain this circuit in detail since I explained it in <a href="https://www.righto.com/2020/08/reverse-engineering-8086s.html">an earlier article</a>.<span id="fnref:shift-right"><a href="#fn:shift-right">3</a></span>
The relevant part of this circuit is the six control signals at the left.
The two multiplexers (trapezoidal symbols) implement the lookup tables by using the two input argument bits to select outputs from
the control signals to control carry generation and carry propagation.
Thus, by feeding appropriate control signals into the ALU, the 8086 can reconfigure the ALU to perform the desired operation.
For instance, with one set of control signals, this circuit will add. Other sets of control signals will cause the circuit to subtract
or compute a logical operation, such as AND or XOR.
The 8086 has 16 copies of this circuit, so it operates on 16-bit values.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/alu-schematic.png"><img alt="The circuit that implements one bit in the 8086&#39;s ALU." height="382" src="https://static.righto.com/images/8086-alu-notes/alu-schematic-w600.png" title="The circuit that implements one bit in the 8086&#39;s ALU." width="600"/></a></p><p>The circuit that implements one bit in the 8086&#39;s ALU.</p>
<p>The 8086 is a complicated processor, and its instructions have many special cases, so controlling the ALU is
more complex than described above.
For instance, the compare operation is the same as a subtraction, except the numerical result of a compare is discarded; just the
status flags are updated.
The add versus add-with-carry instructions require different values for the carry into bit 0, while subtraction requires the
carry flag to be inverted since it is treated as a borrow.
The 8086&#39;s ALU supports increment and decrement operations, but also increment and decrement by 2, which requires an increment signal into bit
1 instead of bit 0.
The bit-shift operations all require special treatment. For instance, a rotate can use the carry bit or exclude the carry bit, while
and arithmetic shift right requires the top bit to be duplicated.
As a result, along with the six lookup table (LUT) control signals, the ALU also requires numerous control signals to adjust its
behavior for specific instructions.
In the next section, I&#39;ll explain how these control signals are generated.</p>
<h2>ALU control circuitry on the die</h2>
<p>The diagram below shows the components of the ALU control logic as they appear on the die.
The information from the micro-instruction enters at the right and is stored in the latches.
The PLAs (Programmable Logic Arrays) decode the instruction and generate the control signals.
These signals flow to the left, where they control the ALU.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/logic-labeled.jpg"><img alt="The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal." height="338" src="https://static.righto.com/images/8086-alu-notes/logic-labeled-w500.jpg" title="The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal." width="500"/></a></p><p>The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal.</p>
<p>As explained earlier, if the microcode specifies the <code>XI</code> operation, the operation field is replaced with a value based on the machine instruction opcode.
This substitution is performed by the <code>XI</code> multiplexer before the value is stored in the operation latch.
Because of the complexity of the 8086 instruction set, the <code>XI</code> operation is not as straightforward as you might expect.
This multiplexer gets three instruction bits from a special register called the &#34;X&#34; register, another instruction bit from the instruction
register, and the final bit from a decoding circuit called the Group Decode ROM.<span id="fnref:xi"><a href="#fn:xi">4</a></span></p>
<p>Recall that one micro-instruction specifies the ALU operation, and a later micro-instruction accesses the result. Thus, the
ALU control circuitry must remember the specified operation so it can be used later. 
In particular, the control circuitry must keep track of the ALU operation to perform and the temporary register specified.
The control circuitry uses three flip-flops to keep track of the specified temporary register, one flip-flop for each register.
The micro-instruction contains a two-bit field that specifies the temporary register. The control circuitry decodes this field and
activates the associated flip-flop.
The outputs from these flip-flops go to the ALU and enable the associated temporary register.
At the start of each machine instruction,<span id="fnref:sc"><a href="#fn:sc">5</a></span> the flip-flops are reset, so temporary register A is selected by default.</p>
<p>The control circuitry uses five flip-flops to store the five-bit operation field from the micro-instruction.
At the start of each machine instruction, the flip-flops are reset so operation 0 (ADD) is specified by default.
One important consequence is that an add operation can potentially be performed without a micro-instruction to configure the ALU,
shortening the microcode by one micro-instruction and thus shortening the instruction time by one cycle.</p>
<p>The five-bit output from the operation flip-flops goes to the operation PLA (Programmable Logic Array)<span id="fnref:pla"><a href="#fn:pla">7</a></span>, which decodes the operation
into 27 control signals.<span id="fnref:control"><a href="#fn:control">6</a></span>
Many of these signals go to the ALU, where they control the behavior of the ALU for special cases.
About 15 of these signals go to the Lookup Table (LUT) PLA, which generates the six lookup table signals for the ALU.
At the left side of the LUT PLA, special high-current driver circuits amplify the control signals before they are sent to the ALU.
Details on these drivers are in the footnotes.<span id="fnref:driver"><a href="#fn:driver">8</a></span></p>
<h2>Conclusions</h2>
<p>Whenever I look at the circuitry of the 8086 processor, I see the differences between a RISC chip and a CISC chip.
In a RISC (Reduced Instruction Set Computer) processor such as ARM, instruction decoding is straightforward, as is the processor circuitry.
But in the 8086, a CISC (Complex Instruction Set Computer) processor, there are corner cases and complications everywhere.
For instance, an 8086 machine instruction sometimes specifies the ALU operation in the first byte and sometimes in the second byte,
and sometimes elsewhere, so the X register latch, the XI multiplexer, and the Group Decode ROM are needed.
The 8086&#39;s ALU includes obscure operations including four types of BCD adjustments and seven types of shifts, making the ALU more
complicated.
Of course, the continuing success of x86 shows that this complexity also has benefits.</p>
<p>This article has been a deep dive into the details of the 8086&#39;s ALU, but I hope you have found it interesting.
If it&#39;s too much detail for you, you might prefer my overview of the <a href="https://www.righto.com/2020/08/reverse-engineering-8086s.html">8086 ALU</a>.</p>
<p>For updates, follow me on
 Bluesky (<a href="https://bsky.app/profile/righto.com">@righto.com</a>),
Mastodon (<a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="cea5aba0bda6a7bcbca7a8a88ea1a2aaacb7baabbde0bdbeafadab">[email protected]</span></a>),
or <a href="https://www.righto.com/feeds/posts/default">RSS</a>.</p>
<p>Credits:
Thanks to Marcin Peczarski for discussion.
My microcode analysis is based on Andrew Jenner&#39;s <a href="https://www.reenigne.org/blog/8086-microcode-disassembled/">8086 microcode disassembly</a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
