<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jcarroll.com.au/2023/07/07/array-languages-r-vs-apl/">Original</a>
    <h1>Array Languages: R vs. APL (2023)</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        <p>I’ve been learning at least one new programming language a month through
<a href="https://exercism.org/">Exercism</a> <span>(exercism.org)</span> which has been really fun and interesting. I frequently say that “every language you learn teaches you something about all the
others you know” and with nearly a dozen under my belt so far I’m starting to worry about the combinatorics of that statement.</p>
<p>APL isn’t on the list of languages but I’ve seen it in <a href="https://codegolf.stackexchange.com/">codegolf</a> <span>(codegolf.stackexchange.com)</span> solutions often enough that it
seemed worth a look.</p>
<p>Now, when I say “learning” I mean “good enough to do 5 toy exercises” which is
what you need to do to in order to earn the badge for that month in the <a href="https://exercism.org/challenges/12in23">“#12in23
challenge”</a> <span>(exercism.org)</span> (gamification FTW). That’s often
sufficient for me to get a taste for the language and see if it’s something I’d
like to dive deeper into.</p>
<p>It means I’ve been watching a lot of “&lt;language&gt; beginner tutorial” videos recently,
which may have been what prompted YouTube to suggest to me a video from
<a href="https://www.youtube.com/@code_report">code_report</a> <span>(www.youtube.com)</span>; I think <a href="https://www.youtube.com/watch?v=UVUjnzpQKUo">this one</a> <span>(www.youtube.com)</span>
comparing a <a href="https://leetcode.com/">leetcode</a> <span>(leetcode.com)</span> solution to the problem</p>
<blockquote>
<p>find the GCD (greatest common divisor) of the smallest and largest numbers in an array</p>
</blockquote>
<p>written in 16 (sixteen!!!) languages. Some of those I know a little or a moderate
amount about, but one stood out. The APL solution comprises 5 glyphs (symbols)
representing operations</p>
<pre><code>      ⌈/∨⌊/</code></pre>
<p>I’ve seen APL solutions pop up in codegolf and they’ve just looked like madness,
which is probably fair. The linked video prompted me to look into some of their
other videos and they do a great job explaining the glyphs in APL and how they
compare to other languages. It turns out this madness is not nearly as hard to
read as it looks. The above glyphs represent “maximum” (⌈), “reduce” (/), “GCD”
(∨), and “minimum” (⌊) and those all correspond well to the problem statement.
The function itself is
<a href="https://en.wikipedia.org/wiki/Tacit_programming">“point-free”</a> <span>(en.wikipedia.org)</span> whereby the
argument(s) aren’t specified at all; like saying <code>mean</code> rather than <code>mean(x)</code>.
For the truly adventurous: <a href="https://blog.devgenius.io/the-hideous-beauty-of-point-free-programming-e8608e3df09d">‘The Hideous Beauty of Point-Free Programming; An
exercise in combinators using
Haskell’</a> <span>(blog.devgenius.io)</span></p>
<p>I ended up diving deeper and deeper, and it all started to make more and more sense.</p>
<p>In a recent stream, <a href="https://www.youtube.com/@ThePrimeagen">ThePrimeagen</a> <span>(www.youtube.com)</span> responded
to the comment about some language that “&lt;x&gt; is more readable” with “readability is
just familiarity” and that stuck with me - I’m not entirely sure I 100% agree with it
because I can find several ways to write some code that someone familiar with that
language will either find easy or hard to read, despite familiarity. I think {dplyr} in R
does a fantastic job of abstracting operations with verbs and making data pipelines
easy to comprehend, certainly much more than the base-equivalent code.</p>
<p>So, would APL be “readable” if I was more familiar with it? Let’s find out!</p>
<p>There aren’t <em>that</em> many glyphs in APL - there are far more unique functions in
most big libraries from any mainstream language. Looking at the top of the ‘ride’
editor for Dyalog APL there are 80 glyphs. To make a slightly unfair example, there
are a lot of exported functions (288 of them) in {dplyr}…</p>
<pre><code>packageVersion(&#34;dplyr&#34;)</code></pre>
<pre><code>## [1] &#39;1.0.10&#39;</code></pre>
<pre><code>ns &lt;- sort(getNamespaceExports(&#34;dplyr&#34;))
head(ns, 20)</code></pre>
<pre><code>##  [1] &#34;.data&#34;        &#34;%&gt;%&#34;          &#34;across&#34;       &#34;add_count&#34;    &#34;add_count_&#34;  
##  [6] &#34;add_row&#34;      &#34;add_rownames&#34; &#34;add_tally&#34;    &#34;add_tally_&#34;   &#34;all_equal&#34;   
## [11] &#34;all_of&#34;       &#34;all_vars&#34;     &#34;anti_join&#34;    &#34;any_of&#34;       &#34;any_vars&#34;    
## [16] &#34;arrange&#34;      &#34;arrange_&#34;     &#34;arrange_all&#34;  &#34;arrange_at&#34;   &#34;arrange_if&#34;</code></pre>
<pre><code>tail(ns, 20)</code></pre>
<pre><code>##  [1] &#34;tbl_vars&#34;            &#34;tibble&#34;              &#34;top_frac&#34;           
##  [4] &#34;top_n&#34;               &#34;transmute&#34;           &#34;transmute_&#34;         
##  [7] &#34;transmute_all&#34;       &#34;transmute_at&#34;        &#34;transmute_if&#34;       
## [10] &#34;tribble&#34;             &#34;type_sum&#34;            &#34;ungroup&#34;            
## [13] &#34;union&#34;               &#34;union_all&#34;           &#34;validate_grouped_df&#34;
## [16] &#34;validate_rowwise_df&#34; &#34;vars&#34;                &#34;with_groups&#34;        
## [19] &#34;with_order&#34;          &#34;wrap_dbplyr_obj&#34;</code></pre>
<p>Taking the functions listed as <code>S3method</code> or <code>export</code> in the
<a href="https://github.com/tidyverse/dplyr/blob/main/NAMESPACE"><code>NAMESPACE</code></a> <span>(github.com)</span>
file is 470+. Sure, these aren’t <em>all</em> user-facing, but still. Lots.</p>
<p>So, 80 isn’t a “huge” number, if that’s the <strong>entire language</strong>.</p>
<p>I watched some more videos about what the glyphs mean and how they work. I
started to become slightly familiar with what they mean. Learning is done with
the hands, not the eyes, though - as <a href="https://giansegato.com/essays/edutainment-is-not-learning">this (not new) blog post</a> <span>(giansegato.com)</span> goes into great
detail on, so
I felt that I needed to actually write something. I installed Dyalog APL and the
ride editor (given that it uses glyphs, a non-standard editor seems to make sense;
I’ve otherwise been completing the Exercism solutions in emacs). I also found <a href="https://tryapl.org">tryapl.org</a> <span>(tryapl.org)</span> as an online editor.</p>
<p>The first step was to just follow along what I’d seen in the videos. I had
most recently watched <a href="https://www.youtube.com/watch?v=8ynsN4nJxzU">this one</a> <span>(www.youtube.com)</span> that
does include a comparison to R (and Julia) so I tried to recreate what I’d seen
built up. I was shocked that I actually could!</p>
<div>
<p><img src="https://jcarroll.com.au/2023/07/07/array-languages-r-vs-apl/images/49288d6d46f5baac.png" alt="Recreating construction of an X-matrix in APL using tryapl.org"/></p><p>Recreating construction of an X-matrix in APL using tryapl.org</p>
</div>
<p>From reshaping into a matrix, to building up the sequence, to inserting the
combinator - it all came together easily enough.</p>
<p>On “combinators” - if you aren’t familiar with Lambda Calculus and have a spare hour,
<a href="https://youtu.be/3VQ382QG-y4">this</a> <span>(youtu.be)</span> is a wonderful talk explaining the basics
and demonstrating them using JavaScript.</p>
<p>More videos, more learning. I found <a href="https://youtu.be/MKb4WD6mioE">this one</a> <span>(youtu.be)</span>
which is another leetcode problem which was roughly</p>
<blockquote>
<p>find the maximum value of the sum of rows of a matrix</p>
</blockquote>
<p>That sounded like something R would easily handle, but this particular
video didn’t feature R. It <em>did</em> feature C++, the solution for which
requires two <code>for</code> loops and looked (to me) horrific - I’m used to just
passing a matrix to an R function and not having to worry about loops.</p>
<p>I’ve had many discussions on this topic because for whatever reason, <code>for</code>
loops have a particular reputation in R despite them not (necessarily) being
any worse than any other solution. The short response is that if you’re using one
when you could be using vectorisation, you’re probably stating your problem poorly
and can do better (in terms of readability, performance, or both). <a href="https://youtu.be/TdbweYvwnss">This video</a> <span>(youtu.be)</span>
covers the points really nicely.</p>
<p>Jenny Bryan <a href="https://speakerdeck.com/jennybc/row-oriented-workflows-in-r-with-the-tidyverse?slide=16">made the point</a> <span>(speakerdeck.com)</span> that</p>
<blockquote>
<p>Of course someone has to write loops… It doesn’t have to be you</p>
</blockquote>
<p>alluding to the fact that vectorisation (either with the <code>*apply</code> family or <code>purrr</code>)
still has a C loop buried within (I covered some of this myself in <a href="https://jcarroll.com.au/2022/04/22/where-for-loop-art-thou/">another post</a>).</p>
<p><a href="https://fosstodon.org/@milesmcbain/110658467908744395">Miles McBain makes a point of never using them</a> <span>(fosstodon.org)</span> (directly).</p>
<p>Okay, so, returning to the leetcode problem. The APL solution in the video is
reshaping (<code>⍴</code>) a vector to a matrix then reducing (<code>/</code>) addition (<code>+</code>) across rows (last-axis; c.f. first axis would be <code>+⌿</code>) and reducing (<code>/</code>) that with maximum (<code>⌈</code>)
making the entire solution</p>
<pre><code>      x ← 3 3⍴1 2 3 5 5 5 3 1 4
      ⌈/+/x
 15</code></pre>
<p>which is an elegant, compact solution. APL agrees to ignore the <code>[1]</code> at the
start of R’s default output if R agrees to ignore the odd indenting of APL commands.</p>
<p>As a sidenote: I <strong>love</strong> that I finally get to use the OG assignment arrow <code>←</code>
that inspired the usage in R (as <code>&lt;-</code>). This isn’t some ligature font, it’s the
actual arrow glyph with Unicode code point U+2190. The APL keyboard has this on
a key and that was common around the time that it made it into R (or S).</p>
<p>The video explains that this solution is
particularly nice because it’s explicit that two “reduce” operations
are occurring. The <code>+</code> operator in APL can be either unary (takes 1 argument) or
binary (takes 2 arguments) but it can’t loop over an entire vector. To achieve that,
it’s combined with <code>/</code> which performs “reduce”, essentially applying <code>+</code> across
the input.</p>
<p>It’s a fairly straightforward answer with R, too:</p>
<pre><code>a &lt;- matrix(c(1, 2, 3,
              5, 5, 5,
              3, 1, 4),
            3, 3, byrow = TRUE)
a</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    5    5    5
## [3,]    3    1    4</code></pre>
<pre><code>max(rowSums(a))</code></pre>
<pre><code>## [1] 15</code></pre>
<p>and done. Nice. No <code>for</code> loops. Or are there? Of course there are, somewhere, but
can we write this “like” the APL solution and be more explicit with the “reduce”
steps over binary operators? R has a <code>Reduce()</code> function for exactly this case.</p>
<p>A simplified <code>rowSums()</code> function could just be applying the <code>sum</code> operation to
the rows of the matrix</p>
<pre><code>s &lt;- function(x) apply(x, 1, sum)</code></pre>
<p>but <code>sum(x)</code> is itself vectorised - it’s an application of the binary <code>+</code> operation
across a vector, so really we could have</p>
<pre><code>s &lt;- function(x) apply(x, 1, \(y) Reduce(`+`, y))
s(a)</code></pre>
<pre><code>## [1]  6 15  8</code></pre>
<p>This isn’t so bad compared to APL which “naturally” performs the reduction
over that dimension. Compare (<code>⍝</code> signifies a comment):</p>
<pre><code>      x
1 2 3
5 5 5
3 1 4

⍝ &#34;rowSums&#34;

      +/x
6 15 8

⍝ &#34;colSums&#34;

      +⌿x
9 8 12</code></pre>
<p>There’s nothing here that says <code>x</code> <em>needs</em> to have more than 1 dimension, though -
it’s the same operator(s) on a vector, just that they do the same thing</p>
<pre><code>      +/(1 2 3)
6
      +⌿(1 2 3)
6</code></pre>
<p><code>max</code> is also vectorised, so a simple, ostensibly binary version of that could be</p>
<pre><code>m &lt;- function(x, y) ifelse(x &gt; y, x, y)
m(1, 2)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre><code>m(4, 2)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Together, an R solution using these could be</p>
<pre><code>Reduce(m, s(a))</code></pre>
<pre><code>## [1] 15</code></pre>
<p>which, if we shortened <code>Reduce</code> to a single character</p>
<pre><code>R &lt;- Reduce</code></pre>
<p>would be</p>
<pre><code>R(m, s(a))</code></pre>
<pre><code>## [1] 15</code></pre>
<p>That’s not a lot more characters than APL. I’ve abstracted at least one of the functions, though - APL uses the operators directly, in which case we’d have</p>
<pre><code>maxWealth &lt;- \(x) R(m, apply(x, 1, \(y) R(`+`, y)))
maxWealth(a)</code></pre>
<pre><code>## [1] 15</code></pre>
<p>That’s <em>only</em> using <code>Reduce</code>, binary <code>+</code>, a simplified <code>max</code> (which we could
imagine was a built-in we could shorten to <code>m</code>), and the <code>apply</code> over rows.</p>
<p>Comparing these directly (with some artistic license):</p>
<pre><code> m R + R
 ⌈ / + /</code></pre>
<p>The point of this whole exercise wasn’t to rebuild the APL solution in R - it
was to think more deeply about what abstractions R offers and how they compare
to a language that uses (only) the atomic constructs directly.</p>
<p>I <em>love</em> that in R I can pass either individual values or a vector to <code>sum</code>
and it “just deals with it”</p>
<pre><code>sum(4, 5, 6) # sum some &#34;scalars&#34;</code></pre>
<pre><code>## [1] 15</code></pre>
<pre><code>vals &lt;- c(4, 5, 6)
sum(vals) # sum a vector</code></pre>
<pre><code>## [1] 15</code></pre>
<p>This ability to hide/abstract the looping over dimensions and to work directly with
objects with more than one dimension is what <a href="https://en.wikipedia.org/wiki/Array_programming#R">qualifies R as an “array language”</a> <span>(en.wikipedia.org)</span>.
This is also (mimicking, perhaps) <a href="https://www.jernesto.com/articles/rapl.html">“rank polymorphism”</a> <span>(www.jernesto.com)</span> which APL does have. Julia
gets around this with “broadcasting”. But, at least in R, this hides/abstracts some of what is happening, and sometimes/often, that’s a <code>for</code> loop.</p>
<p>Does every programmer need to know the gory details? Absolutely not. Might it be
useful for gaining a better understanding of the language and how to work with it?
I really think it is. It’s why I’m digging further and further into functional
programming in general.</p>
<p>I do believe that the APL solution is more explicit in what it’s doing; that it
doesn’t hide (much, if any) of the implementation details. I’m comfortable
with the abstractions in R and will continue to write R for this reason, but if
I had a need to do some array math in any other language, I now feel like APL
really does have a lot to offer.</p>
<p><strong>Bonus Round</strong></p>
<p>I was thinking about the leetcode problem and thought that a slightly more
complex version would be to return “which row has the maximum?” rather than
the maximum itself.</p>
<p>In R, there is another useful function to achieve this</p>
<pre><code>which.max(rowSums(a))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>so, have I learned enough APL to do this myself?</p>
<p>There’s a “Grade Down” operator (<code>⍒</code>) which seems equivalent to R’s
<code>order(decreasing = TRUE)</code> and a “First” operator (<code>⊃</code>) like <code>head(n = 1)</code>
so a solution seems to be to get the indices of the sorted (decreasing)
elements then take the first one</p>
<pre><code>      ⊃⍒+/x
2</code></pre>
<p>Apparently an alternative would be to find the (first) element of the input (<code>⍵</code>) that
matches the maximum which would be</p>
<pre><code>      {⍵⍳⌈/⍵}(+/x)
2</code></pre>
<p>which, at least to me, isn’t as elegant.</p>
<p>Lastly, <a href="https://mastodon.social/@kjhealy/110661489858307306">Kieran Healy</a> <span>(mastodon.social)</span>
relayed to me a small algorithm for finding ‘primes smaller
than some number’ in APL which cleaned up as</p>
<pre><code>      ((⊢~∘.×⍨)1↓⍳)(50)
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47</code></pre>
<p>This makes use of some combinators (e.g. the C-combinator <code>⍨</code> - possibly the
coolest glyph in the entire system),
but roughly involves filtering values not (<code>~</code>)
members (<code>∈</code>) of values produced by the outer (<code>º</code>) product (<code>.</code>) using
multiplication (<code>×</code>) (i.e. numbers that can be made by multiplying other
numbers) from the sequence (<code>⍳</code>) from 2 to some value (dropping (<code>↓</code>) 1;
<code>3↓⍳8 == 4:8</code>). With the small amount I’ve learned - mostly from watching
someone else use the language - I was able to decipher at least <em>what</em> the
operators were in all of that, even if I probably couldn’t come up with the
solution myself.</p>
<p>I’m happy to call that “readable”.</p>
<p>I looked around for code to generate the primes below some number in R. I couldn’t (easily) find one that worked without an explicit loop. I found
a version in <a href="https://github.com/mmaechler/sfsmisc/blob/81015322032edd9f900e5103ac11c70de49619bd/R/prime-numbers-fn.R#L15-L31">{sfsmisc}</a> <span>(github.com)</span> which compacts to</p>
<pre><code>primes. &lt;- function(n) {
  ## By Bill Venables &lt;= 2001
  x &lt;- 1:n
  x[1] &lt;- 0
  p &lt;- 1
  while((p &lt;- p + 1) &lt;= floor(sqrt(n)))
    if(x[p] != 0)
      x[seq(p^2, n, p)] &lt;- 0
  x[x &gt; 0]
}
primes.(50)</code></pre>
<pre><code>##  [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47</code></pre>
<p>Taking inspiration from the APL solution, though - what if we just generate all
products from the set of numbers <code>2:n</code> and exclude those as “not prime” from all
the numbers up to <code>n</code>?</p>
<pre><code>primes &lt;- function(n) {
  s &lt;- 2:n
  setdiff(s, c(outer(s, s, `*`)))
}
primes(50)</code></pre>
<pre><code>##  [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47</code></pre>
<p>That… works! It’s slower and uses more memory, for sure, but that wasn’t
our criteria, and isn’t relevant for a once-off evaluation. Even better - I can
“read” exactly what it’s doing.</p>
<p>I’ve learned a lot and I’ll continue to learn more about APL because I really do
think that understanding how these operators come together to build a function
will be enlightening in terms of a functional approach.</p>
<p>I still haven’t made it to trying out BQN (<em>almost</em> constructed by incrementing
each letter of APL, <code>IBM -&gt; HAL</code> style, but perhaps officially
<a href="https://mlochbaum.github.io/BQN/">“Big Questions Notation”</a> <span>(mlochbaum.github.io)</span>, and sometimes
pronounced “bacon”) but it sounds like it has some newer improvements over APL
and will be worth a try.</p>
<p>As always, comments and discussions are welcome here or on <a href="https://fosstodon.org/@jonocarroll">Mastodon</a> <span>(fosstodon.org)</span>.</p>
</article>

      
        
      


      
        
          
          
          
        
        
      

    </div>
  </div>
</div></div>
  </body>
</html>
