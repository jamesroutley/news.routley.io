<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adamgrant.micro.blog/2025/07/24/123050.html">Original</a>
    <h1>Python classes aren’t always the best solution</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Python is an incredibly versatile programming language known for its simplicity and readability. Among its features, the ability to use classes for object-oriented programming is both powerful and frequently recommended. However, classes aren’t always the best solution. In many cases, Python’s built-in types, functions, and standard library modules provide simpler, cleaner alternatives. Here are several scenarios where you might not need a Python class:</p>
<h2 id="simple-data-containers-use-named-tuples-or-data-classes">Simple Data Containers: Use Named Tuples or Data Classes</h2>
<p>Often, classes are created just to store data. Python’s built-in alternatives, such as named tuples or data classes (Python 3.7+), can be simpler and more concise.</p>
<p>Example with a Class:</p>
<div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>Point</span>:
<span>def</span> __init__(self, x, y):
self<span>.</span>x <span>=</span> x
self<span>.</span>y <span>=</span> y

point <span>=</span> Point(<span>10</span>, <span>20</span>)
</code></pre></div><p>Alternative with NamedTuple:</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> collections <span>import</span> namedtuple

Point <span>=</span> namedtuple(<span>&#39;Point&#39;</span>, [<span>&#39;x&#39;</span>, <span>&#39;y&#39;</span>])
point <span>=</span> Point(<span>10</span>, <span>20</span>)
</code></pre></div><p>Alternative with DataClass (Python 3.7+):</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> dataclasses <span>import</span> dataclass

<span>@dataclass</span>
<span>class</span> <span>Point</span>:
    x: int
    y: int

point <span>=</span> Point(<span>10</span>, <span>20</span>)
</code></pre></div><p>Both namedtuple and dataclass are cleaner and automatically provide methods like <code>__init__</code>, <code>__repr__</code>, and comparison methods without extra boilerplate.</p>
<h2 id="stateless-utility-functions-just-use-functions">Stateless Utility Functions: Just Use Functions</h2>
<p>If your class has methods but no state (no instance attributes), you probably don’t need a class at all.</p>
<p>Example with an unnecessary class:</p>
<div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>MathUtils</span>:
    <span>@staticmethod</span>
    <span>def</span> <span>add</span>(a, b):
        <span>return</span> a <span>+</span> b

result <span>=</span> MathUtils<span>.</span>add(<span>3</span>, <span>4</span>)
</code></pre></div><p>Simpler alternative using a function:</p>
<div><pre tabindex="0"><code data-lang="python"><span>def</span> <span>add</span>(a, b):
    <span>return</span> a <span>+</span> b

result <span>=</span> add(<span>3</span>, <span>4</span>)
</code></pre></div><p>In Python, functions are first-class citizens and often simpler than creating classes for stateless operations.</p>
<h2 id="grouping-constants-use-modules">Grouping Constants: Use Modules</h2>
<p>Sometimes classes are used merely to group constants. Python modules naturally serve this purpose without extra boilerplate.</p>
<p>Example with class:</p>
<div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>Config</span>:
    HOST <span>=</span> <span>&#39;localhost&#39;</span>
    PORT <span>=</span> <span>8080</span>

print(Config<span>.</span>HOST)
</code></pre></div><p>Simpler alternative using module constants:</p>
<h3 id="configpyhttpsconfigpy"><a href="https://config.py">config.py</a></h3>
<div><pre tabindex="0"><code data-lang="python">HOST <span>=</span> <span>&#39;localhost&#39;</span>
PORT <span>=</span> <span>8080</span>
</code></pre></div><h3 id="another-file">another file</h3>
<div><pre tabindex="0"><code data-lang="python"><span>import</span> config
print(config<span>.</span>HOST)
</code></pre></div><p>This approach is simpler and leverages Python’s natural module system.</p>
<h2 id="managing-state-with-simple-structures-use-dictionaries-or-lists">Managing State with Simple Structures: Use Dictionaries or Lists</h2>
<p>For simple state management, dictionaries or lists might suffice. Classes become overkill when you simply want to store mutable data.</p>
<p>Example with a class:</p>
<div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>Inventory</span>:
    <span>def</span> __init__(self):
        self<span>.</span>items <span>=</span> []

inventory <span>=</span> Inventory()
inventory<span>.</span>items<span>.</span>append(<span>&#39;apple&#39;</span>)
</code></pre></div><p>Alternative with a built-in list:</p>
<div><pre tabindex="0"><code data-lang="python">inventory <span>=</span> []
inventory<span>.</span>append(<span>&#39;apple&#39;</span>)
</code></pre></div><p>The built-in type simplifies the code and makes it clear and straightforward.</p>
<h2 id="simple-one-off-operations-use-lambdas-or-comprehensions">Simple One-off Operations: Use Lambdas or Comprehensions</h2>
<p>When performing simple operations, using lambdas or comprehensions can greatly simplify code compared to defining methods within classes.</p>
<p>Example with unnecessary class method:</p>
<div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>Transformer</span>:
    <span>def</span> <span>transform</span>(self, data):
        <span>return</span> [x <span>*</span> <span>2</span> <span>for</span> x <span>in</span> data]

transformer <span>=</span> Transformer()
result <span>=</span> transformer<span>.</span>transform([<span>1</span>, <span>2</span>, <span>3</span>])
</code></pre></div><p>Simpler with comprehension:</p>
<div><pre tabindex="0"><code data-lang="python">result <span>=</span> [x <span>*</span> <span>2</span> <span>for</span> x <span>in</span> [<span>1</span>, <span>2</span>, <span>3</span>]]
</code></pre></div><p>Or even a lambda for one-off use:</p>
<div><pre tabindex="0"><code data-lang="python">transform <span>=</span> <span>lambda</span> data: [x <span>*</span> <span>2</span> <span>for</span> x <span>in</span> data]
result <span>=</span> transform([<span>1</span>, <span>2</span>, <span>3</span>])
</code></pre></div><h2 id="avoiding-complexity-built-in-libraries">Avoiding Complexity: Built-in Libraries</h2>
<p>Python’s standard library is extensive. Before writing your own class, check if your requirement is already covered.</p>
<p>Example:
You might think you need a custom class to manage and serialize configurations, but Python’s built-in <code>configparser</code> or <code>json</code> module is usually enough.</p>
<div><pre tabindex="0"><code data-lang="python"><span>import</span> json

config <span>=</span> {<span>&#39;host&#39;</span>: <span>&#39;localhost&#39;</span>, <span>&#39;port&#39;</span>: <span>8080</span>}
<span>with</span> open(<span>&#39;config.json&#39;</span>, <span>&#39;w&#39;</span>) <span>as</span> f:
    json<span>.</span>dump(config, f)
</code></pre></div><p>Using built-ins reduces bugs, improves readability, and saves development time.</p>
<h2 id="when-you-actually-need-a-class">When You Actually Need a Class</h2>
<p>Classes are very powerful and useful, especially when:
•	You need to encapsulate state and behavior.
•	Your objects have clear behavior (methods) associated with their data.
•	You’re modeling complex, hierarchical structures (inheritance and composition).</p>
<p>But as demonstrated, Python’s built-in features and standard libraries often provide cleaner, simpler solutions.</p>
<p>Classes have their place, but Python’s simplicity often allows you to avoid unnecessary complexity. Whenever you’re inclined to write a class, first ask yourself if built-ins, standard libraries, or simpler techniques could achieve the same goal more efficiently.</p>
<p>Keep your code clean, simple, and Pythonic. Sometimes that means skipping the class entirely.</p>
<p><img src="https://adamgrant.micro.blog/uploads/2025/a2e712b6-3426-46ec-886b-f76e30299b32.png"/>

    </p></div></div>
  </body>
</html>
