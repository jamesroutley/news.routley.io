<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quickwit.io/blog/compressed-indexable-bitset/">Original</a>
    <h1>A Compressed Indexable Bitset</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>In this blog post, we discuss the implementation of an indexable bitset in tantivy.</em></p><p><img loading="lazy" alt="A tale about picking the right brick" src="https://quickwit.io/assets/images/lego-1dcf1e1d86e031a26654e055f292928f.jpg" width="1280" height="960"/></p><p>Modern software engineering is about picking the right building blocks (libraries, data structures, databases, frameworks, or APIs) and interconnecting them.  Many of us deplore this situation. They are nostalgic for the days when software was lean, and every codebase was its own little island with its own beautiful culture and idioms.</p><p>I personally think this change is for the best.
Software engineering has matured, and our productivity has considerably increased as a result. One thing that irks me, however, is how branding is influencing our technological choices. If our only agency is choosing the right tool for the job, let&#39;s be smart and professional about it.</p><p>This blog post could have been a very short blog post: &#34;We use Roaring bitmap because it is blazing fast&#34;... But I suspect we are all very tired of those lazy shortcuts and all crave a proper long technical discussion.</p><p>Instead, in this blog post, I will explain our thought process in detail:</p><ul><li>What our problem was,</li><li>Why we ended up picking up Roaring Bitmap,</li><li>Why we tweaked it a bit,</li><li>Where we think we could improve our current solution.</li></ul><p>Search engines are not just about search.
Products like Quickwit or Elasticsearch are also great for interactive analytics.
Let&#39;s have a look at the following dashboard backed by Quickwit thanks to our new <a href="https://quickwit.io/blog/observing-rust-app-with-quickwit-jaeger-grafana">Grafana plugins</a>:</p><p><img loading="lazy" alt="Dashboard" src="https://quickwit.io/assets/images/dashboard-fadff280c9cbe1e6b8cbfc6f5eb47e50.png" width="1172" height="711"/></p><p>To compute the data displayed here, Quickwit wields together an inverted index and a columnar storage. <em>(yes, Quickwit is ambidextrous)</em></p><p>Let&#39;s consider, for instance, the timeline graph on the top left. It shows my activity on GitHub using the <a href="https://www.gharchive.org/" target="_blank" rel="noopener noreferrer">GitHub archive dataset</a>.</p><ul><li>The <strong>inverted index</strong> will give us an iterator over all of the events I am the author of.</li><li>The <strong>columnar</strong> will provide a column of timestamps.</li></ul><p>In pseudo-code, this computation will then look like this:</p><div><div><pre tabindex="0"><code><span><span>let</span><span> </span><span>mut</span><span> date_histogram </span><span>=</span><span> </span><span>DateHistogram</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>let</span><span> time_column </span><span>=</span><span> columnar</span><span>.</span><span>column</span><span>(</span><span>&#34;time&#34;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>for</span><span> doc_id </span><span>in</span><span> inverted_index</span><span>.</span><span>search</span><span>(</span><span>&#34;author.id:fulmicoton&#34;</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>let</span><span> timestamp </span><span>=</span><span> time_column</span><span>.</span><span>get</span><span>(</span><span>doc</span><span>)</span><span>;</span><span></span><br/></span><span><span>    date_histogram</span><span>.</span><span>record</span><span>(</span><span>timestamp</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><span>return</span><span> date_histogram</span><span>;</span><br/></span></code></pre></div></div><p>The <code>time_column</code> encodes a mapping from <code>doc_id</code> (a 32-bit unsigned integer) to timestamps.</p><p>In tantivy, this columnar format is called fast fields <em>(Yes, I agree this is a terrible name)</em>.
In Lucene, it is called <code>DocValues</code> <em>(I will let you appreciate this one)</em>.</p><p>Until recently, tantivy&#39;s columnar format was very limited. In
particular, we did not support sparse columns: fast fields were required to have values in all documents.
We also required all fast fields to be explicitly declared in the schema.</p><p>To make Quickwit truly schemaless and offer a proper alternative to Elasticsearch for analytics, we had to make our columnar format more flexible.
Here is how it works today.</p><p>The columnar is just a dictionary of named columns.
A <code>Column&lt;T&gt;</code> object carries:</p><ul><li>a dense column of values (<code>ColumnValues&lt;T&gt;</code>)</li><li>an index that maps each <code>doc_id</code> to the right range of value in the column values (<code>ColumnIndex</code>)</li></ul><p>The <code>ColumnIndex</code> is an enum, as it is encoded differently depending on the cardinality of the column:</p><p><img loading="lazy" alt="Diagram showing the different cardinalities" src="https://quickwit.io/assets/images/cardinality-27f9adecda950d57e2df1ef3ae26535f.png" width="1093" height="588"/></p><ul><li><p><strong>Required</strong>: Every document has exactly one value. The mapping from <code>doc_id</code> to  <code>value_id</code> is simply the identity function, and nothing needs to be stored.</p></li><li><p><strong>Optional</strong>: Every document has at most one value. As we will see, this index is equivalent to storing the set of documents having a value. This is precisely the optional index that I want to discuss.</p></li><li><p><strong>Multivalued</strong>: If a document can have any number of values. We simply encode a dense column with the <code>start_row_ids</code> of each document. The range is then given by
<code>start_row_ids.get(doc_id)..start_row_ids.get(doc_id + 1)</code>. We have specific codecs to efficiently compress the <code>start_row_ids</code> while allowing random access. But this is not the subject of this blog post.</p></li></ul><p>We have finally reached the core of this blog post:
Let&#39;s talk about how we encode the optional column index!</p><p>As we have seen, an optional column index stores the set of documents holding a value.</p><p>We need two operations on this set, called <code>rank</code> (well, in our case <code>rank_if_exists</code>) and <code>select</code>. Don&#39;t blame me for the names this time. This is how these operations are called in the literature.</p><p>Let&#39;s have a look at a simple example first to get a proper intuition of what these two operations are about:</p><p><img loading="lazy" src="https://quickwit.io/assets/images/select_rank-b44b619efb13f6b3458ec5c3ab27b67d.png" width="477" height="402"/></p><p>Here we are looking at a bitset containing the elements <code>{2, 4, 6}</code>.
If we consider the list of sorted elements <code>[2, 4, 6]</code>.</p><ul><li><code>2</code> is at position <code>0</code>. Therefore, <code>rank_if_exists(2) = Some(0)</code>,</li><li><code>4</code> is at position <code>1</code>. Therefore, <code>rank_if_exists(4) = Some(1)</code>,</li><li><code>6</code> is at position <code>2</code>. Therefore, <code>rank_if_exists(5) = Some(2)</code>.</li></ul><p>Simple, isn&#39;t it? <code>select</code> is then the inverse operation.</p><p><code>rank_if_exists</code> is used to access the value associated to a <code>doc_id</code>. It is typically called once for every document matching the query. Once we have the rank, it can be used to look up into a dense vector of values.
The rust implementation of the function that fetches a value looks like this:</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>fn</span><span> </span><span>get_value</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>column</span><span>:</span><span> </span><span>&amp;</span><span>Column</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span><span> doc_id</span><span>:</span><span> </span><span>u32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>let</span><span> value_id </span><span>=</span><span> column</span><span>.</span><span>column_index</span><span>.</span><span>rank_if_exists</span><span>(</span><span>doc_id</span><span>)</span><span>?</span><span>;</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>Some</span><span>(</span><span>column</span><span>.</span><span>column_value</span><span>[</span><span>value_id</span><span>]</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>Of course, as we search, we will call <code>rank_if_exists</code> with increasing values of <code>doc_id</code>. It is therefore tempting to rely on this access pattern and use a set representation that performs rank by skipping and scanning. That&#39;s how a column format like Parquet does it.</p><p>Lucene itself chose in <a href="https://issues.apache.org/jira/browse/LUCENE-7407?jql=text%20~%20%22advanceExact%20docValues%22" target="_blank" rel="noopener noreferrer">LUCENE-7077</a> to lean toward an iterator interface for its <code>DocValues</code>.
This was a bit of a controversial change at the time. Let&#39;s spell out the trade-off is:</p><ul><li>A sequential codec usually compresses better.</li><li>A sequential codec might be less CPU efficient.</li></ul><p>Some efforts like <a href="https://issues.apache.org/jira/browse/LUCENE-8585" target="_blank" rel="noopener noreferrer">LUCENE-8585</a> alleviate the performance impact of scanning through doc values.</p><p>We made the other choice in tantivy. Our rank API allows for random access. Wherever it does not hurt compression too much, we want our indexable set to allow for a <code>O(1) </code> random access rank.</p><h3 id="select"><code>select</code><a href="#select" aria-label="Direct link to select" title="Direct link to select">​</a></h3><p>Given a <code>value_id</code>, <code>select</code> answers the question, &#34;To which document does this <code>value_id</code> belong?&#34;.</p><p>We have <code>rank(select(value_id)) == value_id</code>.</p><p>In Quickwit, we use this operation in range queries. You can read a little bit more about this in a <a href="https://quickwit.io/blog/simd-range">previous blog post</a>.</p><p>Contrary to <code>rank</code>, we tend to call select in batches. These batches are by nature less selective, so we do rely on a stateful iterator here. Fast random access is not necessary here.</p><p>We want our bitset to be as small as possible and still offer fast <code>rank</code> operation and <code>select</code> operation. Ideally, we want the <code>rank</code> to offer fast random access.</p><p>Like Lucene, our compressed index is based on <a href="https://roaringbitmap.org/" target="_blank" rel="noopener noreferrer">Roaring bitmaps</a>, except our solution has a minor twist to accelerate <code>rank</code> operations.</p><p>The idea of roaring bitmaps is to partition our <code>doc_id</code> space in blocks of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>16</span></span></span></span></span></span></span></span></span></span></span></span></span> documents. For each block, depending on the number of documents we have, we use a dense or a sparse codec.</p><p>In roaring bitmap, a dense block is a bitset of 2^16 bits.
Every single document, regardless of whether it is part of the set or not, takes exactly <code>1 bit</code>.</p><p>In our codec, we added extra data to improve the performance of rank operations.</p><p>We split the block into <code>1024</code> mini-blocks of 64 elements each.
Each mini-block then consists in:</p><ul><li>the rank (relative to the block) at the beginning of the mini-block: 16 bits,</li><li>a bitset: 64 bits.</li></ul><p>Each mini-block stores 64 documents and takes 80 bits.
That&#39;s 1.25 bits per document.</p><h3 id="rank">rank<a href="#rank" aria-label="Direct link to rank" title="Direct link to rank">​</a></h3><p><code>rank</code> is where our extra 0.25 bits come handy.
Here is what the implementation of <code>rank_if_exists</code> looks like:</p><div><div><pre tabindex="0"><code><span><span>fn</span><span> </span><span>rank_u64</span><span>(</span><span>bitvec</span><span>:</span><span> </span><span>u64</span><span>,</span><span> doc</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u16</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>let</span><span> mask </span><span>=</span><span> </span><span>(</span><span>1u64</span><span> </span><span>&lt;&lt;</span><span> doc</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span><span></span><br/></span><span><span>    </span><span>let</span><span> masked_bitvec </span><span>=</span><span> bitvec </span><span>&amp;</span><span> mask</span><span>;</span><span></span><br/></span><span><span>    masked_bitvec</span><span>.</span><span>count_ones</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>u16</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>DenseBlock</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>&#39;a</span><span> </span><span>[</span><span>u8</span><span>]</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>struct</span><span> </span><span>DenseMiniBlock</span><span> </span><span>{</span><span></span><br/></span><span><span>    bitvec</span><span>:</span><span> </span><span>u64</span><span>,</span><span></span><br/></span><span><span>    rank</span><span>:</span><span> </span><span>u16</span><span>,</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>impl</span><span> </span><span>DenseBlock</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>rank_if_exists</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> doc</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>u16</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>let</span><span> block_pos </span><span>=</span><span> doc </span><span>/</span><span> </span><span>64</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> pos_in_block_bit_vec </span><span>=</span><span> doc </span><span>%</span><span> </span><span>64</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> index_block </span><span>=</span><span> </span><span>self</span><span>.</span><span>mini_block</span><span>(</span><span>block_pos</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> ones_in_block </span><span>=</span><span> </span><span>rank_u64</span><span>(</span><span>index_block</span><span>.</span><span>bitvec</span><span>,</span><span> pos_in_block_bit_vec</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> rank </span><span>=</span><span> index_block</span><span>.</span><span>rank </span><span>+</span><span> ones_in_block</span><span>;</span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>        </span><span>if</span><span> </span><span>get_bit_at</span><span>(</span><span>index_block</span><span>.</span><span>bitvec</span><span>,</span><span> pos_in_block_bit_vec</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>Some</span><span>(</span><span>rank</span><span>)</span><span></span><br/></span><span><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>None</span><span></span><br/></span><span><span>        </span><span>}</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>mini_block</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> mini_block_id</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>DenseMiniBlock</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>If the data is in my L1 cache, on dense parts, the overall codec <code>rank_if_exists</code> implementation runs in <code>5ns</code> on my laptop.</p><h3 id="select-1">select<a href="#select-1" aria-label="Direct link to select" title="Direct link to select">​</a></h3><p>Select is trickier. We do a linear search through the mini-blocks to find the block containing our target document. Once it is identified, we identify the exact document by popping bits from our 64-bits bitset.</p><div><div><pre tabindex="0"><code><span><span>fn</span><span> </span><span>select_u64</span><span>(</span><span>mut</span><span> bitvec</span><span>:</span><span> </span><span>u64</span><span>,</span><span> rank</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u16</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>0</span><span>..</span><span>rank </span><span>{</span><span></span><br/></span><span><span>        bitvec </span><span>&amp;=</span><span> bitvec </span><span>-</span><span> </span><span>1</span><span>;</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span>    bitvec</span><span>.</span><span>trailing_zeros</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>u16</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>impl</span><span> </span><span>DenseBlock</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> rank</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u16</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>let</span><span> block_id </span><span>=</span><span> </span><span>self</span><span>.</span><span>find_miniblock_containing_rank</span><span>(</span><span>rank</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> index_block </span><span>=</span><span> </span><span>self</span><span>.</span><span>mini_block</span><span>(</span><span>block_id</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> in_block_rank </span><span>=</span><span> rank </span><span>-</span><span> index_block</span><span>.</span><span>rank</span><span>;</span><span></span><br/></span><span><span>        block_id </span><span>*</span><span> </span><span>64</span><span> </span><span>+</span><span> </span><span>select_u64</span><span>(</span><span>index_block</span><span>.</span><span>bitvec</span><span>,</span><span> in_block_rank</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>find_miniblock_containing_rank</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> rank</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>u16</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>In practice, a stateful <code>SelectCursor</code> object makes sure that we do not rerun over and over this linear search from the start. You can have a look at the <a href="https://github.com/quickwit-oss/tantivy/blob/main/columnar/src/column_index/optional_index/set_block/dense.rs#L108-L124" target="_blank" rel="noopener noreferrer">implementation here</a>.</p><p>Following roaring bitmaps, our sparse blocks just store the 16 lower bits of our docs one after the other. How can we implement <code>rank</code> and <code>select</code> efficiently here?</p><h3 id="rank-1">rank<a href="#rank-1" aria-label="Direct link to rank" title="Direct link to rank">​</a></h3><p>We simply run a binary search. This isn&#39;t great, is it?
Well, there is definitely a lot of room for improvement, and we might explore alternatives in
the future. A good paper on the subject is <a href="https://arxiv.org/pdf/1509.05053.pdf" target="_blank" rel="noopener noreferrer">Array layout for comparison based-search</a>.</p><p>Thankfully, as we will see in the next section, there are at most <code>5,120</code> elements in sparse blocks. The loop body will be entered at most 13 times.
Also, by nature, sparse blocks are less likely to show up in heavy queries.</p><div><div><pre tabindex="0"><code><span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>SparseBlock</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>rank_if_exists</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> el</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>u16</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>self</span><span>.</span><span>binary_search</span><span>(</span><span>el</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>binary_search</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> target</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>u16</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>let</span><span> data </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>0</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> size </span><span>=</span><span> </span><span>self</span><span>.</span><span>num_vals</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> left </span><span>=</span><span> </span><span>0</span><span>;</span><span></span><br/></span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> right </span><span>=</span><span> size</span><span>;</span><span></span><br/></span><span><span>        </span><span>while</span><span> left </span><span>&lt;</span><span> right </span><span>{</span><span></span><br/></span><span><span>            </span><span>let</span><span> mid </span><span>=</span><span> left </span><span>+</span><span> size </span><span>/</span><span> </span><span>2</span><span>;</span><span></span><br/></span><span><span>            </span><span>let</span><span> mid_val </span><span>=</span><span> </span><span>self</span><span>.</span><span>value_at_idx</span><span>(</span><span>data</span><span>,</span><span> mid</span><span>)</span><span>;</span><span></span><br/></span><span><span>            </span><span>if</span><span> target </span><span>&gt;</span><span> mid_val </span><span>{</span><span></span><br/></span><span><span>                left </span><span>=</span><span> mid </span><span>+</span><span> </span><span>1</span><span>;</span><span></span><br/></span><span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> target </span><span>&lt;</span><span> mid_val </span><span>{</span><span></span><br/></span><span><span>                right </span><span>=</span><span> mid</span><span>;</span><span></span><br/></span><span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span><br/></span><span><span>                </span><span>return</span><span> </span><span>Some</span><span>(</span><span>mid</span><span>)</span><span>;</span><span></span><br/></span><span><span>            </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>            size </span><span>=</span><span> right </span><span>-</span><span> left</span><span>;</span><span></span><br/></span><span><span>        </span><span>}</span><span></span><br/></span><span><span>        </span><span>None</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><h3 id="select-2">select<a href="#select-2" aria-label="Direct link to select" title="Direct link to select">​</a></h3><p>Select is dead simple. We just have to perform a memory lookup. We can&#39;t do much faster, can we?</p><div><div><pre tabindex="0"><code><span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>SparseBlock</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> rank</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>u16</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>let</span><span> offset </span><span>=</span><span> rank </span><span>as</span><span> </span><span>usize</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span><span></span><br/></span><span><span>        </span><span>u16</span><span>::</span><span>from_le_bytes</span><span>(</span><span>self</span><span>.</span><span>0</span><span>[</span><span>offset</span><span>..</span><span>offset </span><span>+</span><span> </span><span>2</span><span>]</span><span>.</span><span>try_into</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>We have seen that the dense bitset takes 1.25 bits per document in our segment, while the sparse codec takes 16 bits per element in the set.
Obviously, we want to pick the dense codec for blocks with a lot of documents and the sparse codec for blocks with few documents (duh!).</p><p>Regardless of the number of elements in the set, a dense block always takes 10,240 bytes.
On the other hand, a sparse block takes 2 bytes per doc in the block. The decision threshold, therefore, happens when we have less
than <code>10,240 / 2 = 5,120</code> documents in the block.</p><p>We have discussed how we represent our blocks. We also need to talk a little about the metadata of that list of blocks.</p><p>It might seem like a trifle, but some datasets may present a very high number (hundreds, thousands!) of very sparse columns. For this reason, we need to make sure these super sparse columns only take a few bytes.</p><p>Today, we store the overall number of rows in the entire file as a <code>VInt</code> at the beginning of each column. This is a bit silly, as it is the same value for every column. I will ignore it in the computation below, but I had to confess this engineering sin.</p><p>We then store the sparse lists of non-empty blocks. For each block, we store</p><ul><li>the <code>block_id</code> (2 bytes)</li><li>the <code>number of elements in the block</code> (2 bytes).</li></ul><p>As we open a column, we read all of this metadata and expand it into a dense vector to allow for random access.
We can afford this: there are at most a few hundred blocks per split.</p><p>A set with a single document in a 10 million split will therefore take
4 bytes of metadata, and 2 bytes for the actual document&#39;s lower bits.
Overall, <strong>the smallest possible optional index will take 6 bytes</strong>.</p><p>For a dense set, on the other hand, our metadata will be negligible, and our column will take
<code>1.25 bits</code> per document in our segment. For an optional column in a split of 10 million documents, this is <code>1.5MB</code>.</p><p>I avoided the use of the word compact so far as it has a very specific meaning in computer science. A compact data structure is smaller than some multiple of a theoretical minimum.</p><p>It happens that, no, our data structure is not really compact.</p><p>Now what does the theory tell us?</p><p>If we build a subset of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext> ⁣</mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">[</mo><mtext> ⁣</mtext><mo stretchy="false">[</mo></mrow><annotation encoding="application/x-tex">[\![0, M[\![</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>[</span><span></span><span>[</span><span>0</span><span>,</span><span></span><span>M</span><span>[</span><span></span><span>[</span></span></span></span></span>, by considering each element one by one and picking them with a probability <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span></span>, <a href="https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem" target="_blank" rel="noopener noreferrer">Shanon&#39;s source coding theorem</a> tells us we cannot do better (in average) than <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>p</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M p log_2(p)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Mpl</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>p</span><span>)</span></span></span></span></span> bits to encode our set. This is also <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{log_2}(p)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>l</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span>(</span><span>p</span><span>)</span></span></span></span></span> per document in the set, depending on how you prefer to see it.</p><p>We can now plot the number of bits taken per document in the set for different values of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span></span>. Note we used here a log-scale for the X-axis.</p><p><img loading="lazy" alt="Bits per document" src="https://quickwit.io/assets/images/bits_per_doc-04bbe5c0434fe72d26a9e0ae3a5f00bc.png" width="600" height="371"/></p><p>The graph shows two interesting spots, showing a lot of headroom.
Around <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">p=1/2^{18}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span>1/</span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>18</span></span></span></span></span></span></span></span></span></span></span></span></span>, we are a bit larger than twice the theoretical minimum. In that range, most blocks will have one, two, or three elements. The culprit is our poorly compressed metadata.</p><p>The second spot is at around <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>13</mn></mrow><annotation encoding="application/x-tex">P=1/13</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span><span></span><span>=</span><span></span></span><span><span></span><span>1/13</span></span></span></span></span>, where we reach 3 times the theoretical minimum. Here we are at the limit between the dense and the sparse space. This is an interesting region because these are large columns. We might want to improve our compression here.</p><p>On the sparse side, this is also precisely the range where our rank performance also shows the largest performance headroom for the <code>rank</code> function.</p><p>Our codec does not qualify as &#34;compact&#34;.
It is, however, important to notice that roaring bitmaps have an edge over theory. In practice, documents are not independent. In a log dataset, for instance, documents are often sorted by time. A rare large request could generate a large trace presenting many spans with a given column. Roaring bitmaps are able to adapt to such changes of regime and hence break the floor of the theoretical minimum.</p><p>To handle columns with an optional cardinality, we needed a way of encoding an indexable set. The set had to be reasonably well compressed and have a way to perform fast rank and select operations. Fast random access for rank operations was especially desirable.</p><p>We ended up copying Roaring bitmap and just augmented it to allow for fast rank operations in dense blocks. Thanks to this extra information, rank operation now takes a few nanoseconds, and our dense blocks are only 25% larger.</p><p>The theory also helped us identify significant headroom on compression and rank performance for sets with a density of around <code>1/13</code>.</p><p>We haven&#39;t discussed other solutions like <a href="http://groups.di.unipi.it/~ottavian/files/elias_fano_sigir14.pdf" target="_blank" rel="noopener noreferrer">Partitioned Elias-Fano indexes</a> or <a href="https://dl.acm.org/doi/10.1145/3318464.3380588" target="_blank" rel="noopener noreferrer">Tree-Encoded Bitmaps</a>.</p><p>We simply did not investigate them. There are no efficient off-the-shelf implementations of these solutions, so we had to implement one. Roaring bitmap has the merit of being incredibly simple to implement and optimize.</p><p>Interestingly, if you skim papers about similar data structures, you may notice that they sometimes mention as &#34;an exercise to the reader&#34; the possibility to add extra data to get <code>O(1)</code> rank complexity... which is exactly what we did here!</p></div></div>
  </body>
</html>
