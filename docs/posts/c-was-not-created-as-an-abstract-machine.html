<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/CAsAbstractMachine">Original</a>
    <h1>C was not created as an abstract machine</h1>
    
    <div id="readability-page-1" class="page"><div><h2>C was not created as an abstract machine (of course)</h2>

	<p><small>February  1, 2023</small></p>
</div><div><p>Today on the Fediverse I saw <a href="https://tilde.zone/@nytpu/109790943342750288">a post by @nytpu</a>:</p>

<blockquote><p>Reminder that the C spec specifies an abstract virtual machine; it&#39;s
just that it&#39;s not an interpreted VM *in typical implementations*
(i.e. not all, I know there was a JIT-ing C compiler at some
point), and C was lucky enough to have contemporary CPUs and
executable/library formats and operating systems(â€¦) designed with
its VM in mind</p>
</blockquote>

<p>(There have also been actual C interpreters, some of which had
strict adherence to the abstract semantics, <a href="https://www.bibsonomy.org/bibtex/21e785f8868649a455d3071bddf8e9fd5/liangzk">cf</a>
(available online in <a href="https://archive.org/details/1988-proceedings-summer-san-francisco">the Usenix summer 1988 proceedings</a>).)</p>

<p>This is simultaneously true and false. It&#39;s absolutely true that
the semantics of formal standard C are defined in terms of an
abstract (virtual) machine, instead of any physical machine. The
determined refusal of the specification to tie this abstract machine
in concrete CPUs is the source of a significant amount of frustration
in people who would like, for example, for there to be some semantics
attached to what happens when you dereference an invalid pointer.
They note that actual CPUs running C code all have defined semantics,
so why can&#39;t C? But, well, as is frequently said, <a href="https://queue.acm.org/detail.cfm?id=3212479&amp;doi=10.1145%2F3212477.3212479">C Is Not a
Low-level Language</a>
(<a href="https://mendeddrum.org/@fanf/109791475329996779">via</a>) and the
semantics of C don&#39;t correspond exactly to CPU semantics. So I
agree with nytpu&#39;s overall sentiments, as I understand them.</p>

<p>However, it&#39;s absolutely false that C was merely &#39;lucky&#39; that
contemporary CPUs, OSes, and so on were designed with its abstract
model in mind. Because the truth is <strong>the concrete C implementations
came first and the standard came afterward</strong> (and I expect nytpu
knows this and was making a point in their post). Although the ANSI C
standardization effort did invent some things, for the most part C was
what I&#39;ve called <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/WaysToStandards">a <em>documentation</em> standard</a>,
where people wrote down what was already happening. C was shaped by
the CPUs it started on (and then somewhat shaped again by the ones it
was eagerly ported to), Unix was shaped by C, and by the time that
the C standard was producing drafts in the mid to late 1980s, C was
shaping CPUs through the movement for <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/TwoRISCStories">performance-focused RISC CPUs</a> (which wanted to optimize performance in
significant part for Unix programs written in C, although they also
cared about Fortran and so on).</p>

<p>(It&#39;s also not the case that C only succeeded in environments that
were designed for it. In fact <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/CTriumph">C succeeded in at least one OS
environment that was relatively hostile to it and that wanted to
be used with an entirely different language</a>.)</p>

<p>Although I&#39;m not absolutely sure, I suspect that the C standard
defining it in abstract terms was in part either enabled or forced
by the wide variety of environments that C already ran in by the
late 1980s. Defining abstract semantics avoided the awkward issue
of blessing any particular set of concrete ones, which at the time
would have advantaged some people while disadvantaging others. This
need for compromise between highly disparate (C) environments is
what brought us charming things like <a href="https://en.wikipedia.org/wiki/Digraphs_and_trigraphs">trigraphs</a> and a decision
not to require two&#39;s-complement integer semantics (<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2218.htm">it&#39;s been
proposed to change this</a>, and
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf">trigraphs are gone in C23</a>, <a href="https://thephd.dev/c23-is-coming-here-is-what-is-on-the-menu">also</a>).</p>

<p>Dating from when ANSI C was defined and C compilers became increasingly
aggressive about optimizing around &#39;undefined behavior&#39; (<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/CUndefinedDereference">even if
this created security holes</a>), you could say
that modern software and probably CPUs has been shaped by the
abstract C machine. Obviously, software increasingly has to avoid
doing things that will blow your foot off in the model of the C
abstract machine, because your C compiler will probably arrange to
blow your foot off in practice on your concrete CPU. Meanwhile,
things that aren&#39;t allowed by the abstract machine are probably not
generated very much by actual C compilers, and things that aren&#39;t
generated by C compilers don&#39;t get as much love from CPU architects
as things that do.</p>

<p>(This neat picture is complicated by the awkward fact that many
CPUs probably runs significantly more C++ code than true C code,
since so many significant programs are written in the former instead
of the latter.)</p>

<p>It&#39;s my view that recognizing that C comes from running on concrete
CPUs and was strongly shaped by concrete environments (OS, executable
and library formats, etc) matters for understanding the group of C
users who are unhappy with aggressively optimizing C compilers that
follow the letter of the C standard and its abstract machine. <strong>Those
origins of C were there first</strong>, and it&#39;s not irrational for people
used to them to feel upset when <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/CUndefinedDereference">the C abstract machine creates a
security vulnerability in their previously working software because
the compiler is very clever</a>. The C abstract
machine is not a carefully invented thing that people then built
implementations of, an end in and of itself; it started out as a
neutral explanation and justification of how actual existing C
things behaved, a means to an end.</p>
</div></div>
  </body>
</html>
