<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joshfonseca.com/blogs/animal-crossing-llm">Original</a>
    <h1>I replaced Animal Crossing&#39;s dialogue with a live LLM by hacking GameCube memory</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
			
			<p>A bridge from 2001 to today, with no game code changes required.</p>
		</div>

		<figure>
			<img src="https://joshfonseca.com/assets/images/ac/Modern%20AI%20in%2024%20Year%20Old%20Game%20Screenshot%20(3).png" alt="Cookie says: &#39;Oh my gosh, Josh :)! I just had the weirdest dream, like, everything we do is a game! Arfer!&#39;" loading="lazy"/>
			<figcaption>Cookie: &#34;Oh my gosh, Josh :)! I just had the weirdest dream, like, everything we do is a game! Arfer!&#34;</figcaption>
		</figure>

		<p>
			Animal Crossing. Infamous for its charming but ultimately repetitive dialogue. Having picked up the GameCube classic again, I was shocked (/s) to discover that the villagers still say the same things they did 23 years ago. Let&#39;s change that.
		</p>
		<p>
			The problem? The game runs on a Nintendo GameCube, a 24-year-old console with a 485 MHz PowerPC processor, 24MB of RAM, and absolutely no internet connectivity. It was fundamentally, physically, and philosophically designed to be an offline island.
		</p>
		<p>
			This is the story of how I built a bridge from 2001 to today, making a vintage game console talk to a cloud-based AI without modifying a single line of the original game&#39;s code.
		</p>

		<h2>The First Hurdle: Speaking to the Game üó£Ô∏è</h2>
		<p>
			My first stroke of luck was immense. The week I started this project, a massive effort by the Animal Crossing decompilation community reached completion. Instead of staring at PowerPC assembly, I had access to readable C code.
		</p>
		<p>
			Digging through the source, I quickly found the relevant functions under a file named <code>m_message.c</code>. This was it, the heart of the dialogue system. A simple test confirmed I could hijack the function call and replace the in-game text with my own string.
		</p>

		<p>C: A glimpse into the decompiled dialogue system</p>
		<pre><code>// A glimpse into the decompiled Animal Crossing source code
// The function that changes message data in the dialogue system.
// My initial entry point for hijacking the text.

extern int mMsg_ChangeMsgData(mMsg_Window_c* msg_p, int index) {
    if (index &gt;= 0 &amp;&amp; index &lt; MSG_MAX &amp;&amp; mMsg_LoadMsgData(msg_p-&gt;msg_data, index, FALSE)) {
        msg_p-&gt;end_text_cursor_idx = 0;
        mMsg_Clear_CursolIndex(msg_p);
        mMsg_SetTimer(msg_p, 20.0f);
        return TRUE;
    }
    
    return FALSE;
}
</code></pre>

		<p>
			Easy win, right? But changing static text is one thing. How could I get data from an external AI into the game in real time?
		</p>
		<p>
			My first thought was to just add a network call. But that would mean writing an entire network stack for the GameCube from scratch (TCP/IP, sockets, HTTP) and integrating it into a game engine that was never designed for it. That was a non-starter.
		</p>
		<p>
			My second thought was to use the Dolphin emulator&#39;s features to write to a file on my host machine. The game would write a &#34;request&#34; file with context, and my Python script would see it, call the LLM, and write back a &#34;response&#34; file. Unfortunately, I couldn&#39;t get the sandboxed GameCube environment to access the host filesystem. Another dead end.
		</p>

		<h2>The Breakthrough: The Memory Mailbox üì¨</h2>
		<p>
			The solution came from a classic technique in game modding: Inter-Process Communication (IPC) via shared memory. The idea is to allocate a specific chunk of the GameCube&#39;s RAM to act as a &#34;mailbox.&#34; My external Python script can write data directly into that memory address, and the game can read from it.
		</p>

		<div>
			<p>
				graph TD
					A[Python Script] -- &#34;Writes LLM response&#34; --&gt; B{Memory Mailbox @ 0x81298360}
					B -- &#34;Game reads new dialogue&#34; --&gt; C[Animal Crossing on Dolphin Emulator]
					C -- &#34;Writes current speaker &amp; context&#34; --&gt; B
			</p>
		</div>

		<p>Python: The core of the &#34;Memory Mailbox&#34; interface</p>
		<pre><code># This is the bridge. These functions read from and write to GameCube RAM via Dolphin.
GAMECUBE_MEMORY_BASE = 0x80000000

def read_from_game(gc_address: int, size: int) -&gt; bytes:
    &#34;&#34;&#34;Reads a block of memory from a GameCube virtual address.&#34;&#34;&#34;
    real_address = GAMECUBE_MEMORY_BASE + (gc_address - 0x80000000)
    return dolphin_process.read(real_address, size)

def write_to_game(gc_address: int, data: bytes) -&gt; bool:
    &#34;&#34;&#34;Writes a block of data to a GameCube virtual address.&#34;&#34;&#34;
    real_address = GAMECUBE_MEMORY_BASE + (gc_address - 0x80000000)
    return dolphin_process.write(real_address, data)
</code></pre>

		<p>
			This was the path forward. But it created a new, painstaking task: I had to become a memory archaeologist. I needed to find the exact stable memory addresses for the active dialogue text and the current speaker&#39;s name.
		</p>
		<p>
			To do this, I wrote my own memory scanner in Python. The process was a tedious loop:
		</p>
		<ul>
			<li><b>Talk to a villager.</b> The moment their dialogue box appeared, I&#39;d freeze the emulator.</li>
			<li><b>Scan.</b> I&#39;d run my script to scan all 24 million bytes of the GameCube&#39;s RAM for the string of text on screen (e.g., &#34;Hey, how&#39;s it going?&#34;).</li>
			<li><b>Cross-Reference.</b> This often returned multiple addresses. So, I&#39;d unfreeze, talk to a different villager, and scan for their name to figure out which memory block belonged to the active speaker.</li>
		</ul>
		<p>
			After hours of talking, freezing, and scanning, I finally nailed down the key addresses: <code>0x8129A3EA</code> for the speaker&#39;s name and <code>0x81298360</code> for the dialogue buffer. I could now reliably read who was talking and, more importantly, write data back to the dialogue box.
		</p>

		<h2>What About the GameCube Broadband Adapter? üåê</h2>
		<p>
			Yes, the GameCube had an official Broadband Adapter (BBA). But <i>Animal Crossing</i> shipped without networking primitives, sockets, or any game-layer protocol to use it. Using the BBA here would have required building a tiny networking stack and patching the game to call it. That means: hooking engine callsites, scheduling async I/O, and handling retries/timeouts, all inside a codebase that never expected the network to exist.
		</p>
		<ul>
			<li><b>Engine hooks:</b> Hijack safe points in the message loop to send/receive packets.</li>
			<li><b>Driver/protocol:</b> Provide a minimal UDP/RPC interface over BBA.</li>
			<li><b>Robustness:</b> Handle timeouts, retries, and partial reads without stalling animations/UI.</li>
		</ul>
		<div>
			<p>
				graph LR
					subgraph Option A: BBA Network Shim
						AC[Animal Crossing] --&gt; Hooks[Net Shim Hooks]
						Hooks --&gt; BBA[BBA Driver]
						BBA --&gt; LAN[(LAN)]
						LAN --&gt; Host[Host Bridge Server]
					end
					subgraph Option B: RAM Mailbox
						AC2[Animal Crossing] --&gt; Mailbox[RAM Mailbox]
						Mailbox --&gt; Py[Python Watcher]
						Py --&gt; LLM[LLM]
					end
			</p>
		</div>
		<p>
			I chose the RAM mailbox because it&#39;s deterministic, requires zero kernel/driver work, and stays entirely within the emulator boundary, with no binary network stack needed. That said, a BBA shim is absolutely possible (and a fun future project for real hardware via Swiss + homebrew).
		</p>

		<p>C: Minimal RPC envelope for a hypothetical BBA shim</p>
		<pre><code>#include &lt;stdint.h&gt;

/* Minimal RPC envelope for a hypothetical BBA shim */
typedef struct {
    uint32_t magic;    // &#39;ACRP&#39;
    uint16_t type;     // 1=Request, 2=Response
    uint16_t length;   // payload length
    uint8_t  payload[512];
} RpcMsg;

int ac_net_send(const RpcMsg* msg);         // sends via BBA
int ac_net_recv(RpcMsg* out, int timeoutMs); // polls with timeout
</code></pre>

		<p>Python: Host-side UDP bridge (very simplified)</p>
		<pre><code>import socket, json
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((&#34;0.0.0.0&#34;, 19135))
while True:
    data, addr = sock.recvfrom(2048)
    msg = json.loads(data.decode(&#34;utf-8&#34;, &#34;ignore&#34;))
    # ... call Writer/Director LLMs ...
    reply = json.dumps({&#34;ok&#34;: True, &#34;text&#34;: &#34;Hi from the cloud!&#34;}).encode()
    sock.sendto(reply, addr)
</code></pre>

		<h2>Speaking the Game&#39;s Secret Language ü§´</h2>
		<p>
			I eagerly tried writing &#34;Hello World&#34; to the dialogue address and... the game froze. The character animations kept playing, but the dialogue wouldn&#39;t advance. I was so close, yet so far.
		</p>
		<p>
			The problem was that I was sending plain text. Animal Crossing doesn&#39;t speak plain text. It speaks its own encoded language filled with control codes.
		</p>
		<p>
			Think of it like HTML. Your browser doesn&#39;t just display words; it interprets tags like <code>&lt;b&gt;</code> to make text bold. Animal Crossing does the same. A special prefix byte, <code>CHAR_CONTROL_CODE</code>, tells the game engine, &#34;The next byte isn&#39;t a character, it&#39;s a command!&#34;
		</p>
		<p>
			These commands control everything: text color, pauses, sound effects, character emotions, and even the end of a conversation. If you don&#39;t send the <code>&lt;End Conversation&gt;</code> control code, the game simply waits forever for a command that never comes. That&#39;s why it was freezing.
		</p>
		<p>
			Once again, the decompilation community saved me. They had already documented most of these codes. I just needed to build the tools to use them.
		</p>
		<p>
			I wrote an encoder and a decoder in Python. The decoder could read raw game memory and translate it into a human-readable format, and the encoder could take my text with custom tags and convert it back into the exact sequence of bytes the GameCube understood.
		</p>
		<p>Python: A small sample of the control codes I had to encode/decode</p>
		<pre><code># A small sample of the control codes I had to encode/decode
CONTROL_CODES = {
    0x00: &#34;&lt;End Conversation&gt;&#34;,
    0x03: &#34;&lt;Pause [{:02X}]&gt;&#34;,        # e.g., &lt;Pause [0A]&gt; for a short pause
    0x05: &#34;&lt;Color Line [{:06X}]&gt;&#34;,  # e.g., &lt;Color Line [FF0000]&gt; for red
    0x09: &#34;&lt;NPC Expression [Cat:{:02X}] [{}]&gt;&#34;, # Trigger an emotion
    0x59: &#34;&lt;Play Sound Effect [{}]&gt;&#34;,  # e.g., &lt;Play Sound Effect [Happy]&gt;
    0x1A: &#34;&lt;Player Name&gt;&#34;,
    0x1C: &#34;&lt;Catchphrase&gt;&#34;,
}

# The magic byte that signals a command is coming
PREFIX_BYTE = 0x7F
</code></pre>

		<p>
			With my new encoder, I tried again. This time, I wasn&#39;t just sending text. I was speaking the game&#39;s language. And it worked. The hardest part of the hack was done.
		</p>

		<h2>Building the AI Brain üß†</h2>
		<p>
			With the communication channel established, it was time for the fun part: building the AI.
		</p>
		<p>
			My initial approach was to have a single LLM do everything: write dialogue, stay in character, and insert the technical control codes. The results were a mess. The AI was trying to be a creative writer and a technical programmer simultaneously and was bad at both.
		</p>
		<p>
			The solution was to split the task into a two-model pipeline: a <b>Writer</b> and a <b>Director</b>.
		</p>
		<ul>
			<li><b>The Writer AI:</b> This model&#39;s only job is to be creative. It receives a detailed character sheet (which I generated by scraping the Animal Crossing Fan Wiki) and focuses on writing dialogue that is funny, in-character, and relevant to the context.</li>
			<li><b>The Director AI:</b> This model receives the pure text from the Writer. Its job is purely technical. It reads the dialogue and decides how to &#34;shoot the scene.&#34; It adds pauses for dramatic effect, emphasizes words with color, and chooses the perfect facial expression or sound effect to match the mood.</li>
		</ul>
		<p>
			This separation of concerns worked perfectly.
		</p>

		<div>
			<p>
				graph LR
					subgraph Game World
						Dolphin(Dolphin Emulator)
					end

					subgraph Python Bridge
						Watcher(watch_dialogue.py)
						Encoder(Encoder/Decoder)
					end

					subgraph AI Core
						Writer(Writer LLM)
						Director(Director LLM)
					end

					subgraph External Data
						Wiki(Fan Wiki)
						News(RSS Feeds)
					end

					Dolphin &lt;--&gt; |IPC via RAM| Watcher
					Watcher --&gt; |Context| Writer
					Wiki --&gt; |Character Sheets| Writer
					News --&gt; |Current Events| Writer

					Writer --&gt; |Raw Dialogue| Director
					Director --&gt; |Decorated Dialogue| Encoder
					Encoder --&gt; |Encoded Bytes| Watcher
			</p>
		</div>

		<h2>Emergent Behavior ü§™</h2>
		<p>
			First I piped in a lightweight news feed. Within minutes, villagers began weaving headlines into small talk, no prompts, just context.
		</p>

		<figure>
			<img src="https://joshfonseca.com/assets/images/ac/Modern%20AI%20in%2024%20Year%20Old%20Game%20Screenshot%20(2).png" alt="Mitzi mentions European leaders meeting Trump and Zelenskyy" loading="lazy"/>
			<figcaption>Mitzi: &#34;About the news? European leaders are planning to meet with Trump and Zelenskyy!&#34;</figcaption>
		</figure>

		<p>
			Then I gave them a tiny shared memory for gossip, who said what, to whom, and how they felt. Predictably, it escalated into an anti-Tom Nook movement.
		</p>

		<figure>
			<img src="https://joshfonseca.com/assets/images/ac/Modern%20AI%20in%2024%20Year%20Old%20Game%20Screenshot%20(1).png" alt="Cookie says Tom Nook is taking all the bells" loading="lazy"/>
			<figcaption>Cookie: &#34;Everything&#39;s going great in town, but sometimes I feel like Tom Nook is, like, taking all the bells!&#34;</figcaption>
		</figure>

		<p>
			And I was reminded that I used Fox News as the news feed.
		</p>

		<figure>
			<img src="https://joshfonseca.com/assets/images/ac/Modern%20AI%20in%2024%20Year%20Old%20Game%20Screenshot.png" alt="Cookie says a woman was killed in a robbery in a blue city" loading="lazy"/>
			<figcaption>Cookie: &#34;A woman was killed in a robbery in a blue city!&#34;</figcaption>
		</figure>

		<p>
			Now the game is a strange, hilarious, and slightly unsettling :)
		</p>
		<p>
			All the code for this project, including the memory interface, dialogue encoder, and AI prompting logic, is available on GitHub. It was one of the most challenging and rewarding projects I&#39;ve ever tackled, blending reverse engineering, AI, and a deep love for a classic game.</p>
	</div></div>
  </body>
</html>
