<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mywiki.wooledge.org/ParsingLs">Original</a>
    <h1>Why you shouldn&#39;t parse the output of ls(1)</h1>
    
    <div id="readability-page-1" class="page"><div dir="ltr" id="content" lang="en">
 <p>The <tt>ls(1)</tt> command is pretty good at showing you the attributes of a single file (at least in some cases), but when you ask it for a <em>list</em> of files, there&#39;s a huge problem: Unix allows almost any character in a filename, including whitespace, newlines, commas, pipe symbols, and pretty much anything else you&#39;d ever try to use as a delimiter except NUL. There are <a href="http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html">proposals</a> to try and &#34;fix&#34; this within <a href="https://www.everipedia.com/posix/">POSIX</a>, but they won&#39;t help in dealing with the current situation (see also <a href="http://www.dwheeler.com/essays/filenames-in-shell.html">how to deal with filenames correctly</a>).  In its default mode, if standard output isn&#39;t a terminal, <tt>ls</tt> separates filenames with newlines.  This is fine until you have a file with a newline in its name.  Since very few implementations of <tt>ls</tt> allow you to terminate filenames with NUL characters instead of newlines, this leaves us unable to get a list of filenames safely with <tt>ls</tt> -- at least, not portably. <span id="line-6"></span><span id="line-7"></span></p><pre><span id="line-1"></span>$ touch &#39;a space&#39; $&#39;a\nnewline&#39;
<span id="line-2"></span>$ echo &#34;don&#39;t taze me, bro&#34; &gt; a
<span id="line-3"></span>$ ls | cat
<span id="line-4"></span>a
<span id="line-5"></span>a
<span id="line-6"></span>newline
<span id="line-7"></span>a space</pre><p>This output appears to indicate that we have two files called <tt>a</tt>, one called <tt>newline</tt> and one called <tt>a space</tt>. <span id="line-18"></span><span id="line-19"></span></p><p>Using <tt>ls -l</tt> we can see that this isn&#39;t true at all: <span id="line-20"></span><span id="line-21"></span></p><pre><span id="line-1-1"></span>$ ls -l
<span id="line-2-1"></span>total 8
<span id="line-3-1"></span>-rw-r-----  1 lhunath  lhunath  19 Mar 27 10:47 a
<span id="line-4-1"></span>-rw-r-----  1 lhunath  lhunath   0 Mar 27 10:47 a?newline
<span id="line-5-1"></span>-rw-r-----  1 lhunath  lhunath   0 Mar 27 10:47 a space</pre><p>The problem is that from the output of <tt>ls</tt>, neither you or the computer can tell what parts of it constitute a filename.  Is it each word? No. Is it each line?  No.  There is no correct answer to this question other than: you can&#39;t tell. <span id="line-30"></span><span id="line-31"></span></p><p>Also notice how <tt>ls</tt> sometimes garbles your filename data (in our case, it turned the newline character in between the words &#34;<tt>a</tt>&#34; and &#34;<tt>newline</tt>&#34; into a question mark.  Some systems put a <tt>\n</tt> instead.).  On some systems it doesn&#39;t do this when its output isn&#39;t a terminal, while on others it always mangles the filename.  All in all, you really can&#39;t and shouldn&#39;t trust the output of <tt>ls</tt> to be a true representation of the filenames that you want to work with. <span id="line-32"></span><span id="line-33"></span></p><p>Now that we&#39;ve seen the problem, let&#39;s explore various ways of coping with it.  As usual, we have to start by figuring out <a href="https://mywiki.wooledge.org/XyProblem">what we actually want to do</a>. <span id="line-34"></span><span id="line-35"></span></p><h2 id="Enumerating_files_or_doing_stuff_with_files">Enumerating files or doing stuff with files</h2>
<p>When people try to use <tt>ls</tt> to get a list of filenames (either all files, or files that match a <a href="https://mywiki.wooledge.org/glob">glob</a>, or files sorted in some way) things fail disastrously. <span id="line-37"></span><span id="line-38"></span></p><p>If you just want to iterate over all the files in the current directory, use a <tt>for</tt> loop and a <a href="https://mywiki.wooledge.org/glob">glob</a>: <span id="line-39"></span><span id="line-40"></span></p><pre><span id="line-1-2"></span># Good!
<span id="line-2-2"></span>for f in *; do
<span id="line-3-2"></span>    [ -e &#34;$f&#34; ] || [ -L &#34;$f&#34; ] || continue
<span id="line-4-2"></span>    ...
<span id="line-5-2"></span>done</pre><p>Consider also using &#34;shopt -s nullglob&#34; so that an empty directory won&#39;t give you a literal &#39;*&#39;. <span id="line-49"></span><span id="line-50"></span></p><pre><span id="line-1-3"></span># Good! (Bash-only)
<span id="line-2-3"></span>shopt -s nullglob
<span id="line-3-3"></span>for f in *; do
<span id="line-4-3"></span>    ...
<span id="line-5-3"></span>done</pre><p><strong>Never</strong> do these: <span id="line-59"></span><span id="line-60"></span><span id="line-61"></span><span id="line-62"></span><span id="line-63"></span><span id="line-64"></span></p><pre><span id="line-1-4"></span># BAD! Don&#39;t do this!
<span id="line-2-4"></span>for f in $(ls); do
<span id="line-3-4"></span>    ...
<span id="line-4-4"></span>done</pre><pre><span id="line-1-5"></span># BAD! Don&#39;t do this!
<span id="line-2-5"></span>for f in $(find . -maxdepth 1); do # find is just as bad as ls in this context
<span id="line-3-5"></span>    ...
<span id="line-4-5"></span>done</pre><pre><span id="line-1-6"></span># BAD! Don&#39;t do this!
<span id="line-2-6"></span>arr=($(ls)) # Word-splitting and globbing here, same mistake as above
<span id="line-3-6"></span>for f in &#34;${arr[@]}&#34;; do
<span id="line-4-6"></span>    ...
<span id="line-5-4"></span>done</pre><pre><span id="line-1-7"></span># BAD! Don&#39;t do this! (The function itself is correct.)
<span id="line-2-7"></span>f() {
<span id="line-3-7"></span>    local f
<span id="line-4-7"></span>    for f; do
<span id="line-5-5"></span>        ...
<span id="line-6-1"></span>    done
<span id="line-7-1"></span>}
<span id="line-8"></span>
<span id="line-9"></span>f $(ls) # Word-splitting and globbing here, same mistake as above.</pre><p>See <a href="https://mywiki.wooledge.org/BashPitfalls">BashPitfalls</a> and <a href="https://mywiki.wooledge.org/DontReadLinesWithFor">DontReadLinesWithFor</a> for more details. <span id="line-94"></span><span id="line-95"></span></p><p>Things get more difficult if you wanted some specific sorting that only <tt>ls</tt> can do, such as ordering by <tt>mtime</tt>.  If you want the oldest or newest file in a directory, don&#39;t use <tt>ls -t | head -1</tt> -- read <a href="https://mywiki.wooledge.org/BashFAQ/099">Bash FAQ 99</a> instead.  If you truly need a list of <em>all</em> the files in a directory in order by <tt>mtime</tt> so that you can process them in sequence, switch to perl, and have your perl program do its own directory opening and sorting.  Then do the processing in the perl program, or -- worst case scenario -- have the perl program spit out the filenames with NUL delimiters. <span id="line-96"></span><span id="line-97"></span></p><p>Even better, put the modification time <em>in</em> the filename, in YYYYMMDD format, so that <a href="https://mywiki.wooledge.org/glob">glob</a> order is also mtime order.  Then you don&#39;t need <tt>ls</tt> or perl or anything.  (The <em>vast</em> majority of cases where people want the oldest or newest file in a directory can be solved just by doing this.) <span id="line-98"></span><span id="line-99"></span></p><p>You could patch <tt>ls</tt> to support a <tt>--null</tt> option and submit the patch to your OS vendor.  That should have been done about 15 years ago.  (In fact, people <em>tried</em>, and it was rejected!  <a href="https://mywiki.wooledge.org/ParsingLs#coreutils">See below</a>.) <span id="line-100"></span><span id="line-101"></span></p><p>Of course, the reason that wasn&#39;t done is because very few people <em>really</em> need the sorting of <tt>ls</tt> in their scripts.  Mostly, when people want a list of filenames, they use <a href="https://mywiki.wooledge.org/UsingFind">find(1)</a> instead, because they don&#39;t care about the order.  And BSD/GNU <tt>find</tt> has had the ability to terminate filenames with NULs for a very long time. <span id="line-102"></span><span id="line-103"></span></p><p>So, instead of this: <span id="line-104"></span><span id="line-105"></span></p><pre><span id="line-1-8"></span># Bad!  Don&#39;t!
<span id="line-2-8"></span>ls | while read filename; do
<span id="line-3-8"></span>  ...
<span id="line-4-8"></span>done</pre><p>Try this: <span id="line-113"></span><span id="line-114"></span></p><pre><span id="line-1-9"></span># Be aware that this does not do the same as above. This goes recursive and lists only on normal files (i.e. no dirs or symlinks). It may work for some situation but is not at all a replacement for the above.
<span id="line-2-9"></span>find . -type f -print0 | while IFS= read -r -d &#39;&#39; filename; do
<span id="line-3-9"></span>  ...
<span id="line-4-9"></span>done</pre><p>Even better, most people don&#39;t really want a list of filenames.  They want to <em>do things</em> to files instead.  The list is just an <a href="https://mywiki.wooledge.org/XyProblem">intermediate step to accomplishing some real goal</a>, such as <em>change www.mydomain.com to mydomain.com in every *.html file</em>.  <tt>find</tt> can pass filenames directly to another command.   There is usually no need to write the filenames out in a straight line and then rely on some other program to read the stream and separate the names back out. <span id="line-122"></span><span id="line-123"></span></p>
<p>If you&#39;re after the file&#39;s size, the portable method is to use <tt>wc</tt> instead: <span id="line-125"></span><span id="line-126"></span></p><pre><span id="line-1-10"></span># POSIX
<span id="line-2-10"></span>size=$(wc -c &lt; &#34;$file&#34;)</pre><p>Most implementations of <tt>wc</tt> will detect that stdin is a regular file, and get the size by calling <tt>fstat(2)</tt>.  However, this is not guaranteed.  Some implementations may actually read all the bytes. <span id="line-132"></span><span id="line-133"></span></p><p>Other metadata is often hard to get at in a portable way.  <tt>stat(1)</tt> is not available on every platform, and when it is, it often takes a completely different syntax of arguments.  There is no way to use <tt>stat</tt> in a way that it won&#39;t break for the next POSIX system you run the script on. Though, if you&#39;re OK with that, both the GNU implementations of <tt>stat(1)</tt> and <tt>find(1)</tt> (via the <tt>-printf</tt> option) are very good ways to get file information, depending upon whether you want it for a single file or multiple files. AST <tt>find</tt> also has <tt>-printf</tt>, but again with incompatible formats, and it&#39;s much less common than GNU <tt>find</tt>. <span id="line-134"></span><span id="line-135"></span></p><pre><span id="line-1-11"></span># GNU
<span id="line-2-11"></span>size=$(stat -c %s -- &#34;$file&#34;)
<span id="line-3-10"></span>(( totalSize = $(find . -maxdepth 1 -type f -printf %s+)0 ))</pre><p>If all else fails, you can try to parse <strong>some</strong> metadata out of <tt>ls -l</tt>&#39;s output.  A few warnings: <span id="line-142"></span><span id="line-143"></span></p><ol type="1"><li><p>Run <tt>ls</tt> with only <strong>one file at a time</strong> (remember, you can&#39;t reliably tell where the first filename ends, because there is no good delimiter -- and no, a newline is not a good enough delimiter -- so there&#39;s no way to tell where the second file&#39;s metadata starts). <span id="line-144"></span></p></li><li><p><strong>Don&#39;t parse the time/date stamp or beyond</strong> (the time/date fields are usually formatted in a very platform- and <a href="https://mywiki.wooledge.org/locale">locale</a>-dependent manner and thus cannot be parsed reliably). <span id="line-145"></span></p></li><li><p><strong>Do not forget the <tt>-d</tt> option</strong> without which if ever the file was of type <em>directory</em>, the contents of that directory would be listed instead <strong>and the <tt>--</tt> delimiter</strong> to avoid problems with file names starting with <tt>-</tt>. <span id="line-146"></span></p></li><li><p><strong>Set the locale to C/POSIX for <tt>ls</tt></strong> as the output format is unspecified outside of that locale. In particular the timestamp format is generally locale dependant, but anything else could. <span id="line-147"></span></p></li><li><p>Remember that <tt>read</tt>&#39;s splitting behaviour depends on the current value of <tt>$IFS</tt> <span id="line-148"></span></p></li><li><p>Prefer the numeric output for <em>owner</em> and <em>group</em> with <tt>-n</tt> instead of <tt>-l</tt> as whilst very uncommon, user and group names could contain whitespace. User and group names may also be truncated. <span id="line-149"></span><span id="line-150"></span><span id="line-151"></span></p></li></ol><p>This much is relatively safe: <span id="line-152"></span><span id="line-153"></span></p><pre><span id="line-1-12"></span>IFS=&#39; &#39; read -r mode links owner _ &lt; &lt;(LC_ALL=C ls -nd -- &#34;$file&#34;)</pre><p>Note that the mode string is also often platform-specific.  E.g. OS X adds an @ for files with xattrs and a + for files with extended security information.  GNU sometimes adds a . or + character.  So, you may need to limit the mode field to the first 10 characters, depending on what you&#39;re doing with it. <span id="line-158"></span><span id="line-159"></span></p><pre><span id="line-1-13"></span>mode=${mode:0:10}</pre><p>In case you don&#39;t believe us, here&#39;s why not to try to parse the timestamp: <span id="line-164"></span><span id="line-165"></span></p><pre><span id="line-1-14"></span># OpenBSD 4.4:
<span id="line-2-12"></span>$ ls -l
<span id="line-3-11"></span>-rwxr-xr-x  1 greg  greg  1080 Nov 10  2006 file1
<span id="line-4-10"></span>-rw-r--r--  1 greg  greg  1020 Mar 15 13:57 file2
<span id="line-5-6"></span>
<span id="line-6-2"></span># Debian unstable (2009):
<span id="line-7-2"></span>$ ls -l
<span id="line-8-1"></span>-rw-r--r-- 1 wooledg wooledg       240 2007-12-07 11:44 file1
<span id="line-9-1"></span>-rw-r--r-- 1 wooledg wooledg      1354 2009-03-13 12:10 file2</pre><p>On OpenBSD, as on most versions of Unix, <tt>ls</tt> shows the timestamps in three fields -- month, day, and year-or-time, with the last field being the time (hours:minutes) if the file is less than 6 months old, or the year if the file is more than 6 months old. <span id="line-178"></span><span id="line-179"></span></p><p>On Debian unstable (<em>circa</em> 2009), with a contemporary version of GNU coreutils, <tt>ls</tt> showed the timestamps in two fields, with the first being Y-M-D and the second being H:M, no matter how old the file is. <span id="line-180"></span><span id="line-181"></span></p><p>So, it should be pretty obvious we <em>never</em> want to have to parse the output of <tt>ls</tt> if we want a timestamp from a file.  You&#39;d have to write code to handle all three of the time/date formats shown above, and possibly more. <span id="line-182"></span><span id="line-183"></span></p><p>But for the fields <em>before</em> the date/time, it&#39;s <em>usually</em> pretty reliable. <span id="line-184"></span><span id="line-185"></span></p><p>(Note: some versions of <tt>ls</tt> don&#39;t print the group ownership of a file by default, and require a <tt>-g</tt> flag to do so.  Others print the group by default, and <tt>-g</tt> suppresses it.  You&#39;ve been warned.) <span id="line-186"></span><span id="line-187"></span></p><p>If we wanted to get metadata from <em>more than one file</em> in the same <tt>ls</tt> command, we run into the same problem we had before -- files can have newlines in their names, which screws up our output.  Imagine how code like this would break if we have a file with a newline in its name: <span id="line-188"></span><span id="line-189"></span></p><pre><span id="line-1-15"></span># Don&#39;t do this
<span id="line-2-13"></span>{ IFS=&#39; &#39; read -r &#39;perms[0]&#39; &#39;links[0]&#39; &#39;owner[0]&#39; &#39;group[0]&#39; _
<span id="line-3-12"></span>  IFS=&#39; &#39; read -r &#39;perms[1]&#39; &#39;links[1]&#39; &#39;owner[1]&#39; &#39;group[1]&#39; _
<span id="line-4-11"></span>} &lt; &lt;(LC_ALL=C ls -nd -- &#34;$file1&#34; &#34;$file2&#34;)</pre><p>Similar code that uses two separate <tt>ls</tt> calls would probably be OK, since the second <tt>read</tt> command would be guaranteed to start reading at the beginning of an <tt>ls</tt> command&#39;s output, instead of possibly in the middle of a filename, and remember <tt>ls</tt> sorts its output and may fail to find either of the files so you can&#39;t be sure what goes into <tt>perms[1]</tt>...  While adding the <tt>-q</tt> option to <tt>ls</tt> would work around the first problem, it would not address the others. <span id="line-197"></span><span id="line-198"></span></p><p>If all of this sounds like a big bag of hurt to you, you&#39;re right.  It probably isn&#39;t worth trying to dodge all this lack of standardization. See <a href="https://mywiki.wooledge.org/BashFAQ/087">Bash FAQ 87</a> for some ways of getting file metadata without parsing <tt>ls</tt> output at all. <span id="line-199"></span><span id="line-200"></span></p><h2 id="Notes_on_GNU_coreutils_ls">Notes on GNU coreutils ls</h2>
<p>A patch to add a <tt>-0</tt> option (analogous to <tt>find -print0</tt>) in GNU coreutils <a href="http://lists.gnu.org/archive/html/coreutils/2014-02/msg00005.html">was rejected in 2014</a>. However, in a surprise reversal, a <tt>--zero</tt> option has been added in <a href="https://lists.gnu.org/archive/html/info-gnu/2021-09/msg00010.html">GNU coreutils 9.0 (2021)</a>.  If you&#39;re fortunate enough to be writing for platforms with <tt>ls --zero</tt>, you get to use that for tasks like &#34;delete the 5 oldest files in this directory&#34;. <span id="line-204"></span><span id="line-205"></span></p><pre><span id="line-1-16"></span># Bash 4.4 and coreutils 9.0
<span id="line-2-14"></span># Delete the 5 oldest files in the current directory.
<span id="line-3-13"></span>readarray -t -d &#39;&#39; -n 5 sorted &lt; &lt;(ls --zero -tr)
<span id="line-4-12"></span>(( ${#sorted[@]} == 0 )) || rm -- &#34;${sorted[@]}&#34;</pre><p>Less recent (<em>circa</em> 2016) versions of GNU coreutils have a <tt>--quoting-style</tt> option with various choices. <span id="line-213"></span><span id="line-214"></span></p><p>One of them <em>is actually useful</em> when combined with bash&#39;s <tt>eval</tt> command.  Specifically, <tt>--quoting-style=shell-always</tt> produces output that Bourne-like shells can parse back into filenames. <span id="line-215"></span><span id="line-216"></span></p><pre><span id="line-1-17"></span>$ touch zzz yyy $&#39;zzz\nyyy&#39;
<span id="line-2-15"></span>$ ls --quoting-style=shell-always
<span id="line-3-14"></span>&#39;yyy&#39;  &#39;zzz&#39;  &#39;zzz?yyy&#39;
<span id="line-4-13"></span>$ ls --quoting-style=shell-always | cat
<span id="line-5-7"></span>&#39;yyy&#39;
<span id="line-6-3"></span>&#39;zzz&#39;
<span id="line-7-3"></span>&#39;zzz
<span id="line-8-2"></span>yyy&#39;</pre><p>It uses always uses single quotes to quote file names (with singles quotes themselves rendered as <tt>\&#39;</tt> outside of quotes) which is the only safe quoting method. <span id="line-228"></span><span id="line-229"></span></p><p>Note that some control characters are still rendered as <tt>?</tt> when the output goes to the terminal, but that doesn&#39;t happen for redirected output (like when piped to <tt>cat</tt> as seen above or more generally when the output is post-processed). <span id="line-230"></span><span id="line-231"></span></p><p>Combining with <tt>eval</tt>, we can solve certain kinds of problems, like <em>get the 5 oldest files in this directory</em>.  Of course, <tt>eval</tt> must be used with care. <span id="line-232"></span><span id="line-233"></span></p><pre><span id="line-1-18"></span># Bash + recent (since ~2016) GNU coreutils
<span id="line-2-16"></span>
<span id="line-3-15"></span># Get all the files, in sorted order by mtime.
<span id="line-4-14"></span>eval &#34;sorted=( $(ls -rt --quoting-style=shell-always) )&#34;
<span id="line-5-8"></span>
<span id="line-6-4"></span># First 5 array elements are the 5 oldest files.
<span id="line-7-4"></span># We can display them to a human:
<span id="line-8-3"></span>(( ${#sorted[@]} == 0 )) || printf &#39;&lt;%s&gt;\n&#39; &#34;${sorted[@]:0:5}&#34;
<span id="line-9-2"></span>
<span id="line-10"></span># Or we can send them into xargs -r0:
<span id="line-11"></span>print0() {
<span id="line-12"></span>  [ &#34;$#&#34; -eq 0 ] || printf &#39;%s\0&#39; &#34;$@&#34;
<span id="line-13"></span>}
<span id="line-14"></span>print0 &#34;${sorted[@]:0:5}&#34; | xargs -r0 something
<span id="line-15"></span>
<span id="line-16"></span># Or whatever we want to do with them</pre><p>GNU <tt>ls</tt> also supports <tt>--quoting-style=shell-escape</tt> (which in version 8.25 became the default when <tt>ls</tt> is printing to a terminal), but that one is not as safe as it produces output that is not always quoted or uses quoting operators that are not portable or unsafe when used in some locales. <span id="line-253"></span><span id="line-254"></span></p><hr/><p> <span id="line-255"></span><a href="https://mywiki.wooledge.org/CategoryShell">CategoryShell</a> <span id="line-256"></span><span id="bottom"></span></p></div></div>
  </body>
</html>
