<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/introducing-swift-erlang-actor-system/81248">Original</a>
    <h1>Swift-erlang-actor-system</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
              <p>I&#39;m excited to share a new actor system we&#39;ve been building for Swift&#39;s distributed actors: <a href="https://github.com/otp-interop/swift-erlang-actor-system" rel="noopener nofollow ugc">swift-erlang-actor-system</a>.</p>
<p>This actor system enables Swift programs to join a distributed Erlang cluster.</p>
<p>Here&#39;s an example of a simple chat program using the actor system:</p>
<p><a href="https://gist.github.com/user-attachments/assets/97e42c3f-773e-49a7-b584-1c590ac635a6" rel="noopener nofollow ugc">Demo Video</a></p>
<p>Erlang (and other languages that run on its VM) can connect multiple runtime systems together with <a href="https://www.erlang.org/doc/system/distributed.html" rel="noopener nofollow ugc">distributed Erlang</a>. Each runtime is referred to as a &#34;node&#34;. Erlang also supports &#34;C nodes&#34;, which allow a program other than the Erlang runtime system to communicate with Erlang nodes and other C nodes.</p>
<p>We&#39;ve wrapped this C node functionality into an actor system that can be used with Swift&#39;s distributed actors. Here&#39;s how you can try it out:</p>

<ol>
<li><a href="https://elixir-lang.org/install.html" rel="noopener nofollow ugc">Install Elixir</a> following their instructions. For example, on macOS you can install with Homebrew:</li>
</ol>
<pre data-code-wrap="sh"><code>brew install elixir
</code></pre>
<ol start="2">
<li>Start <code>epmd</code>, the &#34;Erlang Port Mapper Daemon&#34;. This is how Erlang nodes discover each other by name, instead of IP and port:</li>
</ol>
<pre data-code-wrap="swift"><code>epmd
</code></pre>
<ol start="3">
<li>Start an interactive Elixir node and get the cookie and hostname:</li>
</ol>
<pre data-code-wrap="sh"><code>iex --sname elixir_node
</code></pre>
<pre data-code-wrap="sh"><code>iex(elixir_node@YOUR_HOSTNAME)&gt; Node.get_cookie()
:YOUR_COOKIE
</code></pre>
<ol start="4">
<li>Create a Swift package with a dependency on <code>otp-interop/swift-erlang-actor-system</code>, and setup a node and distributed actor:</li>
</ol>
<pre data-code-wrap="swift"><code>import ErlangActorSystem
import Distributed

// 1. Declare a distributed actor
@StableNames
distributed actor Counter {
    typealias ActorSystem = ErlangActorSystem
  
    private(set) var count: Int = 0
  
    @StableName(&#34;increment&#34;)
    distributed func increment() {
        count += 1
        print(count)
    }
  
    @StableName(&#34;decrement&#34;)
    distributed func decrement() {
        count -= 1
        print(count)
    }
}

// 2. Create a node
let actorSystem = try await ErlangActorSystem(name: &#34;swift_node&#34;, cookie: &#34;LJTPNYYQIOIRKYDCWCQH&#34;)

// 3. Connect to another node
try await actorSystem.connect(to: &#34;elixir_node@DCKYRD-NMXCKatri&#34;)

// 4. Create an instance of a distributed actor using the ErlangActorSystem.
let counter = Counter(actorSystem: actorSystem)

// 5. Give the actor a name so we can find it from another node.
actorSystem.register(counter, name: &#34;counter&#34;)

// run loop
while true {}
</code></pre>
<ol start="5">
<li>
<p>Run the Swift executable.</p>
</li>
<li>
<p>And send messages to our Swift node from Elixir:</p>
</li>
</ol>
<pre data-code-wrap="elixir"><code>iex(elixir_node@YOUR_HOSTNAME)&gt; GenServer.cast({:counter, :&#34;swift_node@YOUR_HOSTNAME&#34;}, :increment)
iex(elixir_node@YOUR_HOSTNAME)&gt; GenServer.cast({:counter, :&#34;swift_node@YOUR_HOSTNAME&#34;}, :decrement)
</code></pre>
<p>Swift&#39;s actors map nicely to Erlang processes, and Swift&#39;s language-level support for distributed actors makes interfacing between the two languages easy.</p>

<p>In the <code>otp-interop</code> GitHub organization, you&#39;ll also find <a href="https://github.com/otp-interop/elixir_pack" rel="noopener nofollow ugc"><code>elixir_pack</code></a>, a package for bundling Elixir applications to run on iOS and other Apple platforms.</p>
<p>We needed a clean way to communicate between Swift and Elixir on-device—and Swift&#39;s distributed actors were a perfect match.</p>
<p>We&#39;ve also started exploring using distributed Erlang for client-server interaction by <a href="https://github.com/otp-interop/tcp_filter_dist" rel="noopener nofollow ugc">filtering messages</a> before accepting them on the server.</p>

<p><code>swift-erlang-actor-system</code> uses the <a href="https://www.erlang.org/doc/apps/erl_interface/ei_users_guide.html" rel="noopener nofollow ugc"><code>erl_interface</code></a> C library from Erlang/OTP for networking and serialization. It&#39;s included as a C source target in the Swift Package.</p>
<p>You can swap out the <code>Transport</code> to support custom use cases—such as <a href="https://github.com/otp-interop/web_socket_dist" rel="noopener nofollow ugc">using WebSockets</a> instead of raw TCP sockets.</p>
<h2><a name="p-373293-message-serialization-4" href="#p-373293-message-serialization-4"></a>Message Serialization</h2>
<p>Distributed Erlang uses <a href="https://www.erlang.org/doc/apps/erts/erl_ext_dist.html" rel="noopener nofollow ugc">External Term Format</a> to serialize any value in the Erlang VM. <code>erl_interface</code> provides functions for encoding/decoding terms. We expose this via <code>TermEncoder</code> and <code>TermDecoder</code> classes that can convert any <code>Codable</code> type to this format.</p>
<p>We&#39;ve also started experimenting with <a href="https://github.com/otp-interop/swift-external-term-format/tree/swift-binary-parsing" rel="noopener nofollow ugc">using <code>swift-binary-parsing</code></a> to decode terms.</p>
<h2><a name="p-373293-stable-names-5" href="#p-373293-stable-names-5"></a>Stable Names</h2>
<p>One of the challenges we faced when building this actor system was identifying remote calls across languages.</p>
<p>By default, Swift uses mangled function names to identify remote calls. To call a function on a Swift node from an Erlang node, your Erlang node would need to know about Swift&#39;s name mangling.</p>
<p>To get around this, we added the <code>@StableNames</code> macro. This allows you to decorate the methods of your actor with custom unique names.</p>
<p>This is also important when working with Swift&#39;s <code>@Resolvable</code> macro. <code>@Resolvable</code> is used on protocols to define actors that are only ever used remotely. We use this to interface with processes that are implemented on the Erlang node. <code>@StableNames</code> works with <code>@Resolvable</code> too, you just have to add a conformance to <code>HasStableNames</code>:</p>
<pre data-code-wrap="elixir"><code>defmodule Counter do
    use GenServer

    @impl true
    def init(count), do: {:ok, count}

    @impl true
    def handle_call(:count, _from, state) do
        {:reply, state, state}
    end

    @impl true
    def handle_cast(:increment, _from, state) do
        {:noreply, state + 1}
    end

    @impl true
    def handle_cast(:decrement, _from, state) do
        {:noreply, state - 1}
    end
end
</code></pre>
<pre data-code-wrap="swift"><code>@Resolvable
@StableNames
protocol Counter: DistributedActor, HasStableNames
    where ActorSystem == ErlangActorSystem
{
    @StableName(&#34;count&#34;)
    distributed var count: Int { get }

    @StableName(&#34;increment&#34;)
    distributed func increment()

    @StableName(&#34;decrement&#34;)
    distributed func decrement()
}
</code></pre>
<p>A concrete actor implementing this protocol called <code>$Counter</code> will be created. It will use the stable names provided via the macro to send the correct messages to the Erlang node.</p>
<pre data-code-wrap="swift"><code>let counter: some Counter = try $Counter.resolve(
    id: .name(&#34;counter&#34;, node: &#34;iex@hostname&#34;),
    using: actorSystem
)

try await counter.increment()
#expect(try await counter.count == 1)
</code></pre>
<p>Stable names will likely be necessary in most cross-language actor systems. I&#39;d like to see something like this integrated into Swift in the future.</p>
<p>Looking forward to hearing your thoughts on this actor system, and distributed actors in Swift in general.</p>
            </div></div>
  </body>
</html>
