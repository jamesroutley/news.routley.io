<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/convert-to-utc/">Original</a>
    <h1>.apply() need not apply</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-05-02T00:00:00-07:00">May 2, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p>Here’s an interesting puzzle I encountered.</p>

<p>I’m working with a dataset with two features of interest: naive datetimes (naive meaning without any timezone information) and timezones. What I’d like is a new feature that has all the date and time information in the datetime feature, except converted to UTC time.</p>

<p>Seems simple enough, right? Well… no. Especially not for a very, very big dataset.</p>

<!--more-->

<figure>
<img src="https://www.linux.it/assets/images/utc_conversion_1.png" alt="robot foot race"/>
<figcaption>It&#39;s a race! By DALL-E 2</figcaption>
</figure>


<p>Here’s a simplified version of the dataset I’m working with:</p>



<div>

<table>
  <thead>
    <tr>
      <th></th>
      <th>datetime_naive</th>
      <th>timezone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2022-10-08 19:13:00</td>
      <td>America/New_York</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-11-04 08:00:00</td>
      <td>America/Los_Angeles</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2023-04-05 09:00:00</td>
      <td>America/New_York</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2022-11-25 14:40:00</td>
      <td>America/Denver</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2023-03-11 09:00:00</td>
      <td>America/New_York</td>
    </tr>
  </tbody>
</table>
</div>



<div><div><pre><code>datetime_naive    datetime64[ns]
timezone                  object
dtype: object
</code></pre></div></div>

<p>As promised, there’s <code>datetime_naive</code>, which is contains our date/time information, and <code>timezone</code>, which contains the timezone string.</p>

<p>Now, if the <code>datetime_naive</code> feature all belonged to the same timezone (say, “America/New_York”), converting to UTC after first localizing to East coast time is trivial:</p>

<div><div><pre><code><span>tz</span> <span>=</span> <span>&#39;America/New_York&#39;</span>

<span>data</span><span>[</span><span>&#39;datetime_nyc&#39;</span><span>]</span> <span>=</span> <span>data</span><span>[</span><span>&#39;datetime_naive&#39;</span><span>].</span><span>dt</span><span>.</span><span>tz_localize</span><span>(</span><span>tz</span><span>)</span>
<span>data</span><span>[</span><span>&#39;datetime_utc&#39;</span><span>]</span> <span>=</span> <span>data</span><span>[</span><span>&#39;datetime_nyc&#39;</span><span>].</span><span>dt</span><span>.</span><span>tz_convert</span><span>(</span><span>&#39;UTC&#39;</span><span>)</span>

<span>data</span><span>.</span><span>head</span><span>()</span>
</code></pre></div></div>

<div>

<table>
  <thead>
    <tr>
      <th></th>
      <th>datetime_naive</th>
      <th>timezone</th>
      <th>datetime_nyc</th>
      <th>datetime_utc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2022-10-08 19:13:00</td>
      <td>America/New_York</td>
      <td>2022-10-08 19:13:00-04:00</td>
      <td>2022-10-08 23:13:00+00:00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-11-04 08:00:00</td>
      <td>America/Los_Angeles</td>
      <td>2022-11-04 08:00:00-04:00</td>
      <td>2022-11-04 12:00:00+00:00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2023-04-05 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-04-05 09:00:00-04:00</td>
      <td>2023-04-05 13:00:00+00:00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2022-11-25 14:40:00</td>
      <td>America/Denver</td>
      <td>2022-11-25 14:40:00-05:00</td>
      <td>2022-11-25 19:40:00+00:00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2023-03-11 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-03-11 09:00:00-05:00</td>
      <td>2023-03-11 14:00:00+00:00</td>
    </tr>
  </tbody>
</table>
</div>



<div><div><pre><code>datetime_naive                      datetime64[ns]
timezone                                    object
datetime_nyc      datetime64[ns, America/New_York]
datetime_utc                   datetime64[ns, UTC]
dtype: object
</code></pre></div></div>

<p>First I localized <code>datetime_naive</code> to East Coast time (<code>datetime_nyc</code>), and then I converted that to UTC (<code>datetime_utc</code>). You’ll notice that <code>datetime_naive</code> and <code>datetime_nyc</code> are almost identical, except the localized version includes the UTC offset information, which above is either -04:00 or -05:00 depending on DST. The dtypes differ, as well, with <code>datetime_nyc</code> typed as a <em>localized</em> datetime64 object.</p>

<p>Then, I converted the localized <code>datetime_nyc</code> to UTC time, so you’ll notice that the UTC offset for <code>datetime_utc</code> (as expected) is now +00:00. Its dtype is localized to UTC, as well.</p>

<p>So, that’s easy enough. But our problem is not this. Our problem is complicated by the fact that each datetime value in <code>datetime_naive</code> corresponds to a distinct timezone, so calling <code>.dt.tz_localize()</code> will not work, since we aren’t localizing the entire feature.</p>



<figure>
<img src="https://www.linux.it/assets/images/utc_conversion_3.png" alt="robot foot race"/>
<figcaption>Let&#39;s see what you can do. By DALL-E 2</figcaption>
</figure>

<p>My first thought was to convert each <code>datetime_naive</code> record individually using <code>.apply()</code> in tandem with the pytz library. Something like this:</p>

<div><div><pre><code><span>import</span> <span>pytz</span>

<span>def</span> <span>convert_to_utc</span><span>(</span><span>dt</span><span>,</span> <span>tz</span><span>):</span>
    <span>tz</span> <span>=</span> <span>pytz</span><span>.</span><span>timezone</span><span>(</span><span>tz</span><span>)</span>
    <span>localized</span> <span>=</span> <span>tz</span><span>.</span><span>localize</span><span>(</span><span>dt</span><span>)</span>
    <span>utc</span> <span>=</span> <span>localized</span><span>.</span><span>astimezone</span><span>(</span><span>pytz</span><span>.</span><span>utc</span><span>)</span>
    <span>return</span> <span>utc</span>

<span>data</span><span>[</span><span>&#39;datetime_utc&#39;</span><span>]</span> <span>=</span> <span>data</span><span>.</span><span>apply</span><span>(</span><span>lambda</span> <span>row</span><span>:</span> <span>convert_to_utc</span><span>(</span><span>row</span><span>[</span><span>&#39;datetime_naive&#39;</span><span>],</span> <span>row</span><span>[</span><span>&#39;timezone&#39;</span><span>]),</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
<span>data</span><span>.</span><span>head</span><span>()</span>
</code></pre></div></div>

<div>

<table>
  <thead>
    <tr>
      <th></th>
      <th>datetime_naive</th>
      <th>timezone</th>
      <th>datetime_utc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2022-10-08 19:13:00</td>
      <td>America/New_York</td>
      <td>2022-10-08 23:13:00+00:00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-11-04 08:00:00</td>
      <td>America/Los_Angeles</td>
      <td>2022-11-04 15:00:00+00:00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2023-04-05 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-04-05 13:00:00+00:00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2022-11-25 14:40:00</td>
      <td>America/Denver</td>
      <td>2022-11-25 21:40:00+00:00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2023-03-11 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-03-11 14:00:00+00:00</td>
    </tr>
  </tbody>
</table>
</div>



<div><div><pre><code>datetime_naive         datetime64[ns]
timezone                       object
datetime_utc      datetime64[ns, UTC]
dtype: object
</code></pre></div></div>

<p>Using <code>.apply()</code>, we call <code>convert_to_utc()</code> for each row of the dataframe, passing the paired <code>datetime_naive</code> and <code>timezone</code> values as arguments. Then <code>convert_to_utc()</code> localized the <code>datetime_naive</code> value according to the <code>timezone</code> before converting the localized valu to UTC.</p>

<p>Now, this works. Sort of. This dataset has 1,000 records. The one I was working with when I encountered this problem had millions. I’m not sure how long the operation took because I was too impatient, so let’s just say it took a while. <code>.apply()</code> is not the most efficent route.</p>

<p>How to proceed? I really scratched my head about this for a while. At first I was thinking that maybe I could chunk the dataset and perform the same <code>.apply()</code> method on one (smaller) chunk at a time. After all, it works well enough for 1,000 records, doesn’t it? My thinking was that maybe I was bumping up against a memory issue. I implemented this solution, but still was too impatient to find out how long it took to process the entire dataset.</p>



<figure>
<img src="https://www.linux.it/assets/images/utc_conversion_2.png" alt="robot foot race"/>
<figcaption>Specter of the vector. By DALL-E 2</figcaption>
</figure>

<p>Knowing how fast it was to simply localize an entire datetime feature to a given timezone and then convert that, I kept on thinking that there must be a vectorized solution to this. Maybe if I process all the datetimes for a given timezone at once?</p>

<p>That ended up looking something like this:</p>

<div><div><pre><code><span>def</span> <span>vectorized_convert_to_utc</span><span>(</span><span>df</span><span>,</span> <span>dt_col</span><span>,</span> <span>tz_col</span><span>):</span>
    <span># Get list of timezone
</span>    <span>tzs</span> <span>=</span> <span>df</span><span>[</span><span>tz_col</span><span>].</span><span>unique</span><span>()</span>

    <span>for</span> <span>tz</span> <span>in</span> <span>tzs</span><span>:</span>
        <span># Create mask for current timezome
</span>        <span>is_current_tz</span> <span>=</span> <span>(</span><span>df</span><span>[</span><span>tz_col</span><span>]</span> <span>==</span> <span>tz</span><span>)</span>

        <span># Localize all datetime records matching `tz` and convert to UTC
</span>        <span>df</span><span>.</span><span>loc</span><span>[</span><span>is_current_tz</span><span>,</span> <span>&#39;datetime_utc&#39;</span><span>]</span> <span>=</span> <span>(</span>
            <span>df</span><span>.</span><span>loc</span><span>[</span><span>is_current_tz</span><span>,</span> <span>dt_col</span><span>].</span><span>dt</span><span>.</span><span>tz_localize</span><span>(</span><span>tz</span><span>).</span><span>dt</span><span>.</span><span>tz_convert</span><span>(</span><span>&#39;UTC&#39;</span><span>)</span>
        <span>)</span>

    <span>return</span> <span>df</span><span>[</span><span>&#39;datetime_utc&#39;</span><span>]</span>

<span>data</span><span>[</span><span>&#39;datetime_utc&#39;</span><span>]</span> <span>=</span> <span>vectorized_convert_to_utc</span><span>(</span><span>data</span><span>,</span> <span>&#39;datetime_naive&#39;</span><span>,</span> <span>&#39;timezone&#39;</span><span>)</span>
<span>data</span><span>.</span><span>head</span><span>()</span>
</code></pre></div></div>

<div>

<table>
  <thead>
    <tr>
      <th></th>
      <th>datetime_naive</th>
      <th>timezone</th>
      <th>datetime_utc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2022-10-08 19:13:00</td>
      <td>America/New_York</td>
      <td>2022-10-08 23:13:00+00:00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-11-04 08:00:00</td>
      <td>America/Los_Angeles</td>
      <td>2022-11-04 15:00:00+00:00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2023-04-05 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-04-05 13:00:00+00:00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2022-11-25 14:40:00</td>
      <td>America/Denver</td>
      <td>2022-11-25 21:40:00+00:00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2023-03-11 09:00:00</td>
      <td>America/New_York</td>
      <td>2023-03-11 14:00:00+00:00</td>
    </tr>
  </tbody>
</table>
</div>



<div><div><pre><code>datetime_naive         datetime64[ns]
timezone                       object
datetime_utc      datetime64[ns, UTC]
dtype: object
</code></pre></div></div>

<p>The result is the same here, but it was miles apart with my other dataset of millions of records instead of 1,000, since the computation actually finished.</p>



<figure>
<img src="https://www.linux.it/assets/images/utc_conversion_4.png" alt="robot foot race"/>
<figcaption>We got a winner, folks. By DALL-E 2</figcaption>
</figure>

<p>Let’s speed test side by side:</p>

<div><div><pre><code><span># `.apply()`
</span><span>%</span><span>timeit</span> <span>data</span><span>.</span><span>apply</span><span>(</span><span>lambda</span> <span>row</span><span>:</span> <span>convert_to_utc</span><span>(</span><span>row</span><span>[</span><span>&#39;datetime_naive&#39;</span><span>],</span> <span>row</span><span>[</span><span>&#39;timezone&#39;</span><span>]),</span> <span>axis</span><span>=</span><span>1</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>136 ms ± 2.9 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre></div></div>

<div><div><pre><code><span># Vectorized
</span><span>%</span><span>timeit</span> <span>vectorized_convert_to_utc</span><span>(</span><span>data</span><span>,</span> <span>&#39;datetime_naive&#39;</span><span>,</span> <span>&#39;timezone&#39;</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>2.32 ms ± 113 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre></div></div>

<p>Hot damn! That right there is why the vectorized solution crunched through millions of records no problem, while <code>.apply()</code> left me hanging. It’s ~60 times faster. Which checks out, since even the vectorized version took maybe 5 seconds to execute on my machine, which means applying <code>.apply()</code> would’ve taken 5 minutes.</p>


                                                              
                                                                            
          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
