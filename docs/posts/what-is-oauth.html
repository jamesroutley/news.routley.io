<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leaflet.pub/p/did:plc:3vdrgzr2zybocs45yfhcr6ur/3mfd2oxx5v22b">Original</a>
    <h1>What Is OAuth?</h1>
    
    <div id="readability-page-1" class="page"><div><p id="0" data-index="0"><span> </span><a href="https://x.com/geoffreylitt/status/2022036670946979875" target="_blank">recently asked a question about OAuth</a><span> on dead-Twitter:</span></p><blockquote id="1" data-index="1"><span>I desperately need a Matt Levine style explanation of how OAuth works. What is the historical cascade of requirements that got us to this place?</span></blockquote><p id="2" data-index="2"><span>There are plenty of explanations of the inner mechanical workings of OAuth, and lots of explanations about how various flows etc work, but Geoffrey is asking a </span><a href="https://x.com/geoffreylitt/status/2022288861284446225?s=20" target="_blank">different question</a><span>:</span></p><blockquote id="3" data-index="3"><span>What I need is to understand </span><span>why it is designed this way</span><span>, and to see </span><span>concrete examples of use cases that motivate the design</span></blockquote><p id="4" data-index="4"><span>In the 19 years (!) since I wrote the first sketch of an OAuth specification, there has been a lot of minutiae and cruft added, but the core idea remains the same. Thankfully, it&#39;s a very simple core. Geoffrey&#39;s a </span><span>very</span><span> smart guy, and the fact that he&#39;s asking this question made me think it&#39;s time to write down an answer to this.</span></p><p id="5" data-index="5"><span>It&#39;s maybe easiest to start with the Sign-In use-case, which is a much more complicated specification (</span><a href="https://openid.net/developers/how-connect-works/" target="_blank">OpenID Connect</a><span>) than core </span><a href="https://datatracker.ietf.org/doc/html/rfc6749" target="_blank">OAuth</a><span>. OIDC uses OAuth under the hood, but helps us get to the heart of what&#39;s actually happening.</span></p><hr/><p id="7" data-index="7"><span>OIDC is functionally equivalent to &#34;magic link&#34; authentication.</span></p><p id="8" data-index="8"><span>We send a secret to a place that only the person trying to identify themselves can access, and they prove that they can access that place by showing us the secret.</span></p><p id="9" data-index="9"><span>That&#39;s it.</span></p><p id="10" data-index="10"><span>The rest is just accumulated consensus, in part bikeshedding (agreeing on vocabulary, etc), part UX, and part making sure that all the specific mechanisms are secure.</span></p><hr/><p id="12" data-index="12"><span>There&#39;s also an historical reason to start with OIDC to explain how all this works: in late 2006, I was working on Twitter, and we wanted to support OpenID (then 1.0) so that </span><span>ahem</span><span> Twitter wouldn&#39;t become a centralized holder of online identities. After chatting with the OpenID folks, we quickly realized that as it was constructed, we wouldn&#39;t be able to support </span><span>both</span><span> desktop clients </span><span>and</span><span> web sign-in, since our users wouldn&#39;t have passwords anymore! (mobile apps didn&#39;t exist yet, but weren&#39;t far out). So, in order to allow OpenID sign-in, we needed a way for folks using Twitter via alternative clients to sign in without a password.</span></p><p id="13" data-index="13"><span>There were plenty of solutions for this; Flickr had an approach, AWS had one, delicious had one, lots of sites just let random other apps sign-in to your account with your password, etc, but virtually every site in the &#34;Web 2.0&#34; cohort needed a way to do this. They were all insecure and all fully custom.</span></p><p id="14" data-index="14"><span>Rather than building TwitterAuth, I figured it was time to have a standard. Insert XKCD 927:</span></p><a id="15" data-index="15" href="https://xkcd.com/927/" target="_blank"><div><div><p>Standards</p><p>Fortunately, the charging one has been solved now that we&amp;#39;ve all standardized on mini-USB. Or is it micro-USB? Shit.</p><p>https://xkcd.com/927/</p></div></div></a><p id="16" data-index="16"><span>Thankfully, against all odds, we now have one standard for delegated auth. What it </span><span>does</span><span> is very simple:</span></p><hr/><p id="18" data-index="18"><span>At its core, OAuth for delegation is a standard way to do the following:</span></p><ul><li><p id="19.0" data-index="19.0"><span>The first half exists to send, with consent, a multi-use secret to a known delegate.</span></p></li><li><p id="19.1" data-index="19.1"><span>The other half of OAuth details how the delegate can use that secret to make subsequent requests on behalf of the person that gave the consent in the first place.</span></p></li></ul><p id="20" data-index="20"><span>That&#39;s it. </span><span>The rest is (sadly, mostly necessary) noise.</span></p><hr/><p id="22" data-index="22"><span>Obviously, the above elides </span><span>absolute volumes</span><span> of detail about how this is done securely and in a consistent interoperable way. This is the unenviable work of standards bodies. I have plenty of opinions on the pros and cons of our current standards bodies, but that&#39;s for another time.</span></p><p id="23" data-index="23"><span>There are very credible arguments that the-set-of-IETF-standards-that-describe-OAuth are less a standard than a framework. I&#39;m not sure that&#39;s a bad thing, though. HTML is a framework, too – not all browsers need to implement all features, by design.</span></p><p id="24" data-index="24"><span>OIDC itself is an interesting thing – immediately after creating OAuth, we realized that we could compose OpenID&#39;s behaviour out of OAuth, even though it was impossible to use OpenID to do what OAuth did. For various social, political, technical, and operational reasons it took the better part of a decade to write down the bits to make that insight a thing that was true in the world. I consider it one of my biggest successes with OAuth that I was in no way involved in that work. I don&#39;t have children, but know all the remarkable and complicated feelings of having created something that takes on a life of its own.</span></p><p id="25" data-index="25"><span>More generally, though, authentication and authorization are complicated, situated beasts, impossible to separate from the UX and architectural concerns of the systems that incorporate them.</span></p><p id="26" data-index="26"><span>The important thing when implementing a standard like OAuth is to understand first </span><span>what </span><span>you&#39;re trying to do and </span><span>why</span><span>. Once that&#39;s in place, the </span><span>how</span><span> is usually a &#34;simple&#34; question of mechanics with fairly constrained requirements. I think that&#39;s what makes Geoffrey&#39;s question so powerful – it digs into the core of the reason why OAuth is often so inscrutable to so many: the complicated machinery of the standard means that the actual goals it encodes are lost.</span></p><p id="27" data-index="27"><span>Hopefully, this post helps clear that up!</span></p></div></div>
  </body>
</html>
