<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.instantdb.com/essays/agents_building_counterstrike">Original</a>
    <h1>Codex, Opus, Gemini try to build Counter Strike</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the last week weâ€™ve had three major model updates: Gemini 3 Pro, Codex Max 5.1, Claude Opus 4.5. We thought weâ€™d give them a challenge:</p>
<p><strong>Build a basic version of Counter Strike.</strong> The game had to be a 3D UI and it had to be multiplayer.</p>
<p>If you&#39;re curious, pop open (an ideally large computer screen) and you can try out each model&#39;s handiwork yourself:</p>
<ol>
<li><strong>Codex Max 5.1</strong>: <a href="https://cscodex.vercel.app/" node="[object Object]">https://cscodex.vercel.app/</a></li>
<li><strong>Claude Opus 4.5</strong>: <a href="https://csclaude.vercel.app/" node="[object Object]">https://csclaude.vercel.app/</a></li>
<li><strong>Gemini 3 Pro</strong>: <a href="https://csgemini.vercel.app/" node="[object Object]">https://csgemini.vercel.app/</a></li>
</ol>
<p>We have a full video of us going through the build <a href="https://youtu.be/fm-OoCWQlmc" node="[object Object]">here</a>, but for those who prefer text, you get this post.</p>
<p>We&#39;ll go over some of our high-level impressions on each model, then dive deeper into the performance of specific prompts.</p>
<h2>The Setup</h2>
<p>We signed up for the highest-tier plan on each model provider and used the defaults set for their CLI. For Codex, thatâ€™s 5.1 codex-max on the medium setting. For Claude itâ€™s Opus 4.5. And with Gemini it&#39;s 3 pro.</p>
<p>We then gave each model about 7 consecutive prompts. Prompts were divided into two categories:</p>
<p><strong>Frontend:</strong> At first agents only having to worry about the game mechanics. Design the scene, the enemies, the logic for shooting, and some sound effects.</p>
<p><strong>Backend:</strong> Once that was done agents would then make the game multiplayer. They would need to build be selection of rooms. Users could join them and start shooting.</p>
<h2>A High-Level Overview</h2>
<p>So, how&#39;d each model do?</p>
<p>In a familiar tune with the other Anthropic models, <strong>Opus 4.5 won out on the frontend</strong>. It made nicer maps, nicer characters, nicer guns, and generally had the right scene from the get-go.</p>
<p>Once the design was done, <strong>Gemini 3 Pro started to win in the backend</strong>. It got less errors adding multiplayer and persistence. In general Gemini did the best with making logical rather than visual changes.</p>
<p><strong>Codex Max felt like an â€œin-betweenâ€ model on both frontend and backend.</strong> It got a lot of â€œ2nd placeâ€ points in our book. It did reasonably well on the frontend and reasonably well on the backend, but felt less spikey then the other models.</p>
<p>Hereâ€™s the scorecard in detail:</p>







































































<table><thead><tr><th></th><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td><strong>Frontend</strong></td><td></td><td></td><td></td></tr><tr><td>Boxes + Physics</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td><td>ğŸ¥ˆ</td></tr><tr><td>Characters + guns</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td><td>ğŸ¥ˆ</td></tr><tr><td>POV gun</td><td>ğŸ¥ˆ</td><td>ğŸ¥‡</td><td>ğŸ¥‰</td></tr><tr><td>Sounds</td><td>ğŸ¥ˆ</td><td>ğŸ¥‡</td><td>ğŸ¥ˆ</td></tr><tr><td><strong>Backend</strong></td><td></td><td></td><td></td></tr><tr><td>Moving</td><td>ğŸ¥ˆ</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td></tr><tr><td>Shooting</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td><td>ğŸ¥‰</td></tr><tr><td>Saving rooms</td><td>ğŸ¥ˆ</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td></tr><tr><td><strong>Bonus</strong></td><td>ğŸ¥ˆ</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td></tr></tbody></table>
<p>Okay, now letâ€™s get deeper into each prompt.</p>

<p>Goal number 1 was to set up the physics for the game. Models needed to design a map with a first-person viewpoint, and the ability to shoot enemies.</p>
<blockquote>
<p><strong>Prompt</strong></p>
<p>I want you to create a browser-based version of counter strike, using three js.</p>
<p>For now, just make this local: don&#39;t worry about backends, Instant, or
anything like that.</p>
<p>For the first version, just make the main character a first-person view with
a cross hair. Put enemies at random places. Enemies have HP. You can
shoot them, and kill them. When an enemy is killed, they respawn.</p>
<p>Make everything simple polygons -- rectangles.</p>
</blockquote>
<p>Hereâ€™s a side-by-side comparison of the visuals each model came up with:</p>















<table><thead><tr><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td><img src="https://www.instantdb.com/posts/counter_strike/map_codex.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/map_claude.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/map_gemini.png" alt=""/></td></tr></tbody></table>
<p>Visually Claude came up with the most interesting map. There were obstacles, a nice floor, and you could see everything well.</p>
<p>Gemini got the something nice working too.</p>
<p>Codex had an error on itâ€™s first run <sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label" node="[object Object]">[<!-- -->1<!-- -->]</a></sup> (it called a function without importing it), but it fixed it real quick. Once bugs were fixed, itâ€™s map was the least visually pleasing. Things were darker, there were no obstacles, and it was hard to tell the floor.</p>

<p>Now that we had a map and some polygons, we asked the models to style up the characters. This was our prompt:</p>
<blockquote>
<p>I want you to make the enemies look more like people. Use a bunch of square polygons to represent a person, and maybe a little gun</p>
</blockquote>
<p>Hereâ€™s the result of their work:</p>















<table><thead><tr><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td><img src="https://www.instantdb.com/posts/counter_strike/enemy_codex.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/enemy_claude.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/enemy_gemini.png" alt=""/></td></tr></tbody></table>
<p>Again it feels like Claude did the best job here. The character look quite human â€” almost at the level of design in Minecraft. Gemini did well too. Codex made itâ€™s characters better, but everything was a single color, which really diminished it compared to the others.</p>

<p>We then asked each model to add a gun to our first-person view. When we shoot, we wanted a recoil animation.</p>
<blockquote>
<p>I want you to make it so I also have a gun in my field of view. When I shoot, the gun moves a bit.</p>
</blockquote>
<p>Hereâ€™s the side-by-side of how the recoil felt for each model:</p>















<table><thead><tr><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td><img src="https://www.instantdb.com/posts/counter_strike/recoil_codex.gif" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/recoil_claude.gif" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/recoil_gemini.gif" alt=""/></td></tr></tbody></table>
<p>Here both Claude and Codex got the gun working in one shot. Claudeâ€™s gone looks like a real darn pistol though.</p>
<p>Gemini had an issue trying to stick the gun to the camera. This got us in quite a back and forth, until we realized that the gun was transparent.</p>

<p>We were almost done the frontend: the final step was sound. Hereâ€™s what we asked:</p>
<blockquote>
<p>I want you to use chiptunes to animate the sound of shots. I also want to animate deaths.</p>
</blockquote>
<p>All models added sounds pretty easily. The ending part in our prompt: â€œI also want to animate deaths.â€ was added at the spur of the moment in the video. Our intention was to add sound to deaths. <em>But</em> thatâ€™s not what happened.</p>
<p>All 3 models misunderstood the sentence in in the same way: they thought the wanted to animate how the characters died. Fair enough, re-reading the sentence again, we would understand it that way too.</p>
<p>Hereâ€™s the results they came up with:</p>

<p>All the models got the sound done easily. They all got animations, but we thought Claudeâ€™s animation felt the most fun.</p>

<p>Now that all models had a real frontend, we asked them to make it multiplayer.</p>
<p>We didnâ€™t want the models to worry about shots just yet: goal 1 was to share the movement positions. Hereâ€™s what we asked it to do:</p>
<blockquote>
<p>I want you to use Instant presence.</p>
<p>Don&#39;t save anything in the database, just use presence and topics. You can
look up the docs.</p>
<p>There should should just be one single room.</p>
<p>You no longer the need to have the enemies that are randomly placed. All the players are what get placed.</p>
<p>For now, don&#39;t worry about shots. Let&#39;s just make it so the positions of the players are what get set in presence.</p>
</blockquote>
<p>Gemini got this right in one shot. Both Codex and Claude needed some more prodding.</p>

















<table><thead><tr><th></th><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td>Moving</td><td>ğŸ¥ˆ</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td></tr></tbody></table>
<p>It was interesting to see how each model tried to solve problems:</p>
<p>Codex used <em>lots</em> of introspection. It would constantly look at the typescript library and look at the functions that were available. It didnâ€™t seem to look at the docs as much.</p>
<p>Claude looks at the docs a bunch. It read and re-read our docs on presence, but rarely introspected the library like Codex did.</p>
<p>Gemini seemed to do both. It looked at the docs, but then I think because it constantly ran the build step, it found any typescript errors it had, and fixed it up.</p>
<p>Gemini made the fastest progress here, though all of them got through, as long as we pasted the errors back.</p>

<p>Then we moved to getting shots to work. Here was the prompt:</p>
<blockquote>
<p>Now let&#39;s make shots work. When I shoot, send the shot as a topic, and
make it affect the target&#39;s HP. When the target HP goes to zero, they should die and respawn.</p>
</blockquote>

















<table><thead><tr><th></th><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td>Shooting</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td><td>ğŸ¥ˆ</td></tr></tbody></table>
<p>Claude got this right in one shot. Gemini and Codex had a few issues to fix, but just pasting the errors got them though.</p>

<p>Now that all models had a single room working, it was time to get them supporting <em>multiple</em> rooms.</p>
<p>The reason we added this challenge, was to see (a) how they would deal with a new API (persistence), and (b) how they would deal with the refactor necessary for multiple rooms.</p>
<blockquote>
<p>So, now I want you to make it so the front page is actually a list of
maps. Since our UI is using lots of polygons, make the style kind of
polygonish</p>
<p>Make the UI look like the old counter strike map selection screen.
I want you to save these <code>maps</code> in the database. Each map has a name.
Use a script to generate 5 random maps with cool names.</p>
<p>Then, push up some permissions so that anyone can view maps, but they cannot
create or edit them.</p>
<p>When you join a map, you can just use the map id as the room id for
presence.</p>
</blockquote>
<h2>The maps UI</h2>
<p>All models did great with the UI. Hereâ€™s how each looked:</p>















<table><thead><tr><th>Codex</th><th>Claude</th><th>Gemini</th></tr></thead><tbody><tr><td><img src="https://www.instantdb.com/posts/counter_strike/ui_codex.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/ui_claude.png" alt=""/></td><td><img src="https://www.instantdb.com/posts/counter_strike/ui_gemini.png" alt=""/></td></tr></tbody></table>
<p>We kind of like Geminiâ€™s UI the most, but they were all pretty cool.</p>
<h2>The Persistence</h2>
<p>And the persistence worked well too. They all dutifully created schema for maps, pushed a migration, and seeded 5 maps.</p>
<h2>The Refactor</h2>
<p><em>But</em> things got complicated in the refactor.</p>

















<table><thead><tr><th></th><th>gpt 5.1 codex max (medium)</th><th>Claude 4.5 Opus</th><th>Gemini 3 Pro</th></tr></thead><tbody><tr><td>Saving rooms</td><td>ğŸ¥ˆ</td><td>ğŸ¥‰</td><td>ğŸ¥‡</td></tr></tbody></table>
<p>Gemini got things done in one shot. It also chose to keep the map id in the URL, which made it much handier to use. Codex took one back and forth with a query error.</p>
<p>But Claude <em>really</em> got stuck. The culprit was hooks. Because useEffect can run multiple times, it ended up having a few very subtle bugs. For example, it made 2 canvas objects instead of 1. It also had multiple animation refs running at once.</p>
<p>It was hard to get it to fix things by itself. We had to put our engineer hats on and actually look at the code to unblock Claude here.</p>
<p>This did give us a few ideas though:</p>
<ol>
<li>Claudeâ€™s issues were human-like. How many of us get tripped up with useEffect running twice, or getting dependency arrays wrong? I think improving the React DX on these two issues could really push humans and agents further.</li>
<li>And would have happened if a non-programmer was building this? They would have gotten really stuck. We think there needs to be more tools to go from â€œstrictly vibe codingâ€, to â€œreal programmingâ€. Right now the jump feels too steep.</li>
</ol>
<p>At the end, all models built real a multiplayer FPS, with zero code written by hand! Thatâ€™s pretty darn cool.</p>
<h2>Parting thoughts</h2>
<p>Well, models have definitely improved. They can take much higher-level feedback, and much higher-level documentation. What really strikes us though is how much they can iterate on their own work thanks to the CLI.</p>
<p>Thereâ€™s still lots to go though. The promise that you never have to look at the code doesnâ€™t quite feel real yet.</p>
</div></div>
  </body>
</html>
