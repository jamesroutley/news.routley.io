<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signoz.io/blog/llm-observability-opentelemetry/">Original</a>
    <h1>LLM Observability in the Wild – Why OpenTelemetry Should Be the Standard</h1>
    
    <div id="readability-page-1" class="page"><div><!--$--><!--$--><!--$--><main><section><div><div><article><p>A few days ago I hosted a live conversation with Pranav, co-founder of Chatwoot, about issues his team was running into with LLM observability.</p><p>The short version: building, debugging, and improving AI agents in production gets messy fast. There&#39;s multiple competing standards for default libraries for LLM observability. And many such libraries like OpenInference which claim to be based on OpenTelemetry don&#39;t strictly adhere to it&#39;s conventions. This introduces problems for users who are trying to get better observability across their stack.</p><p>Here’s a write-up of what we covered and what I think it means for anyone shipping LLM features into real products. Feel free to watch the complete video</p><p><iframe src="https://www.youtube.com/embed/DPL35sYPGPU" title="YouTube Video Player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe></p><p>Pranav and I go way back to our YC days in 2021, and it&#39;s always interesting to see how our paths have evolved. Chatwoot has built something really compelling - an open-source customer support platform that unifies conversations across every channel you can imagine: live chat, email, WhatsApp, social media, you name it. All in a single dashboard.</p><p>But here&#39;s where it gets interesting. They&#39;ve built an AI agent called &#34;Captain&#34; that can work across all these channels. You build the logic once, and it can handle support queries whether they come through email, live chat, or WhatsApp. Pretty neat, right?</p><p>The problem started showing up in production in the most unexpected ways. Sometimes their AI would randomly respond in Spanish when it absolutely shouldn&#39;t. Other times, responses just weren&#39;t quite right, and they had no visibility into <em>why</em>.</p><p>This is where Pranav&#39;s journey into LLM observability began, it mirrors what I&#39;ve been seeing across many companies building LLM applications. You need to understand:</p><ul><li>What documents were retrieved for a RAG query?</li><li>Which tool calls were made?</li><li>What was the exact input and output at each step?</li><li>Why did the AI make certain decisions?</li></ul><p>Without this visibility, you&#39;re essentially flying blind in production.</p><h2 id="the-standards-problem"><a href="#the-standards-problem" aria-hidden="true" tabindex="-1"></a>The Standards Problem</h2><p>Here&#39;s where things get really interesting, and frankly, frustrating. Pranav explored several solutions:</p><p><strong>OpenAI&#39;s native tracing</strong> looked promising with rich, detailed traces showing guardrails, agent flows, and tool calls. But it&#39;s tightly coupled to OpenAI&#39;s agent framework. Also, it only provides traces as an atomic unit. If you want to filter spans based on attributes or just examine specific spans directly, you can&#39;t do that.</p><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"><figure><img src="https://signoz.io/img/blog/2025/09/openAI-agent-traces.webp" alt="OpenAI agent workflow traces"/><figcaption><i>OpenAI agent workflow traces<!-- --> </i></figcaption></figure></div></div><p><strong>New Relic</strong> was easy to integrate since they already use it, and it supports OpenTelemetry. But the UI required clicking through 5-6 layers just to see relevant information. Not ideal when you&#39;re trying to debug production issues.</p><p><strong>Phoenix</strong> caught their attention because it follows the OpenInference standard, which provides much richer, AI-specific span types. You can easily filter for just LLM calls, tool calls, or agent spans. The traces are beautiful and informative.</p><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"><figure><img src="https://signoz.io/img/blog/2025/09/phoenix-unknown.webp" alt="Phoenix doesn&#39;t recognize OpenTelemetry span kinds"/><figcaption><i>Phoenix doesn&#39;t recognize OpenTelemetry span kinds<!-- --> </i></figcaption></figure></div></div><p>But here&#39;s the kicker: Chatwoot is primarily a Ruby on Rails shop, and guess what? No Ruby SDK for OpenInference. Moreover, Phoenix doesn&#39;t completely adhere to OTel semantic conventions, so if you send it telemetry data directly via OpenTelemetry, it doesn&#39;t recognize the type of spans, etc.</p><p>As shown in the example above, Phoenix doesn&#39;t shows data sent with OpenTelemetry span kinds as <code>unknown</code>.</p><p>This is where the conversation got really technical and revealed a fundamental industry problem. There are essentially two standards emerging:</p><p><strong>OpenTelemetry</strong> is the industry standard. It has libraries for every language, it&#39;s production-ready, and it&#39;s widely adopted. But it was built for traditional applications, not AI workflows. It only supports basic span types: internal, server, client, producer, consumer. That&#39;s it.</p><p><strong>OpenInference</strong> was created specifically for AI applications. It has rich span types like LLM, tool, chain, embedding, agent, etc. You can easily query for &#34;show me all the LLM calls&#34; or &#34;what were all the tool executions.&#34; But it&#39;s newer, has limited language support, and isn&#39;t as widely adopted.</p><p>The tragic part? OpenInference claims to be &#34;OpenTelemetry compatible,&#34; but as Pranav discovered, that compatibility is shallow. You can send OpenTelemetry format data to Phoenix, but it doesn&#39;t recognize the AI-specific semantics and just shows everything as &#34;unknown&#34; spans.</p><p>For teams using languages like Ruby that don&#39;t have direct OpenInference SDK support, this becomes even more challenging. Pranav had to choose between:</p><ol><li>Building an SDK from scratch for Ruby</li><li>Using OpenTelemetry and losing AI-specific insights</li><li>Switching to a different language stack just for AI observability (way tougher)</li></ol><p>None of these are great options.</p><p>At SigNoz we’re all-in on OpenTelemetry. One reason: OTel’s consistency enables out-of-the-box experiences across your <em>whole</em> stack. Example: we can auto-surface <a target="_blank" rel="noopener noreferrer" href="https://signoz.io/docs/external-api-monitoring/overview/">external API</a> usage and performance based on span kinds and attributes. When parts of the app send telemetry via non-OTel conventions, those views degrade.</p><p>Chatwoot lands similarly: their entire product already emits OTel. Pulling in a second telemetry standard just for LLMs fragments the picture and complicates how they go about observability. This also silos their observability into different products which makes it difficult to solves issues when they occur.</p><ul><li><strong>Pick one telemetry backbone</strong> - If most of your app is OTel, prefer staying OTel-native for LLMs too, even if it means adding richer attributes until GenAI conventions catch up.</li><li><strong>LLM specific libraries</strong> - Even if you have to use LLM specific libraries like OpenInference, try to keep your usage as close to OpenTelemetry as possible so that you are aware what non-OTel attributes you are using which may break things.</li><li><strong>Follow OTel GenAI working group</strong> - There is active work happening in OTel <a target="_blank" rel="noopener noreferrer" href="https://opentelemetry.io/blog/2024/otel-generative-ai/">Gen AI working group</a>. Follow the work happening there and do share your use cases so that the standards which OpenTelemetry builds are able to cater to most common use cases.</li></ul><p>As the LLM space is still evolving rapidly, we as a community need to share our voices so that the standards are robust.</p><hr/><p>We’re continuing to invest in OpenTelemetry-native LLM observability so teams don’t have to choose between stability and clarity. Concretely, that means:</p><ul><li><p>Clear dashboards and traces when LLM calls are modeled using OTel spans/attributes. You can find examples and dashboards in our <a target="_blank" rel="noopener noreferrer" href="https://signoz.io/docs/llm-observability/">LLM observability</a> docs. Though we have also use LLM specific libraries like OpenInference in our docs (as they are still the easiest way for ppl to get started), we have kept the dashboards as close to OTel standards as possible. We also plan to actively update this as OTel GenAI semantic conventions become more mature.</p></li><li><p>Guidance and examples for popular frameworks (LangChain, LlamaIndex, etc.) on emitting OTel-friendly telemetry.</p></li><li><p>Build features leveraging OpenTelemetry semantic conventions so that you get great out-of-box experience in SigNoz and adhere to thoughtful defaults that keep your services, DBs, queues, and LLM agents—in one coherent picture.</p></li></ul><p>If you’re wrestling with these trade-offs, we’d love to hear what’s breaking for you and what “rich semantics” you actually use day-to-day.</p><hr/><p>Huge thanks to Pranav for going deep, especially from the Ruby perspective. If you’re shipping AI features and care about operability, add your voice: push for richer GenAI semantics in OpenTelemetry, and share real traces (sanitized) that show what you need to see.</p><p>If you want to compare notes or need help getting your LLM telemetry into an OTel-native view, ping me.</p></article></div></div></section></main><!--/$--><!--/$--><!--/$--></div></div>
  </body>
</html>
