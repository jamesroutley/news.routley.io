<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elastio.github.io/bon/blog/the-weird-of-function-local-types-in-rust">Original</a>
    <h1>The weird of function-local types in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-v-e6f2a212=""><div data-v-e6f2a212=""><div><h2 id="context" tabindex="-1">Context <a href="#context" aria-label="Permalink to &#34;Context&#34;">‚Äã</a></h2><p>I was writing documentation for my proc-macro crate that generates builders for functions and structs called <a href="https://elastio.github.io/bon/docs/guide/overview"><code>bon</code></a>. I made the following simple example of code to compare <a href="https://elastio.github.io/bon/docs/guide/overview"><code>bon</code></a> with the other alternative crate <a href="https://docs.rs/buildstructor/latest/buildstructor/" target="_blank" rel="noreferrer"><code>buildstructor</code></a>.</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>#[derive(buildstructor::</span><span>Builder</span><span>)]</span></span>
<span><span>struct</span><span> User</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>String</span></span>
<span><span>}</span></span>
<span></span>
<span><span>User</span><span>::</span><span>builder</span><span>()</span></span>
<span><span>    .</span><span>name</span><span>(</span><span>&#34;Foo&#34;</span><span>)</span></span>
<span><span>    .</span><span>build</span><span>();</span></span></code></pre></div><p>This example code was part of the doc comment, which I tested by running <code>cargo test --doc</code>. However, it didn&#39;t compile:</p><div><p><span>log</span></p><pre tabindex="0"><code><span><span>cannot find type `User` in this scope</span></span>
<span><span> --&gt; doc-test/path/here.rs</span></span>
<span><span>  |</span></span>
<span><span>2</span><span> | struct User {</span></span>
<span><span>  |        ^^^^ not found in this scope</span></span></code></pre></div><p>Suddenly the code generated by macro can&#39;t find the <code>User</code> struct it was placed on ü§®. And this is where weird things need some explanation. To figure out what&#39;s happening, let&#39;s build an understanding of how name resolution works for &#34;local&#34; items.</p><h2 id="name-resolution-for-local-items" tabindex="-1">Name resolution for local items <a href="#name-resolution-for-local-items" aria-label="Permalink to &#34;Name resolution for local items&#34;">‚Äã</a></h2><p>It&#39;s possible to define an item such as a <code>struct</code>, <code>impl</code> block or <code>fn</code> inside any block expression in Rust. For example, this code defines a &#34;local&#34; anonymous struct inside of a function block:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span></span>
<span><span>    let</span><span> user</span><span> = </span><span>User</span><span>;</span></span>
<span><span>}</span></span></code></pre></div><p>Here, the <code>User</code> struct is only accessible inside of the function block&#39;s scope. We can&#39;t reference it outside of this function:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// error: cannot find type `User` in this scope</span></span>
<span><span>type</span><span> Foo</span><span> = </span><span>User</span><span>;                                </span></span>
<span></span>
<span><span>mod</span><span> child_module {</span></span>
<span><span>    // error: unresolved import `super::User`; no `User` in the root</span></span>
<span><span>    use</span><span> super</span><span>::</span><span>User</span><span>;                                                 </span></span>
<span><span>}</span></span></code></pre></div><p>This doesn&#39;t work because, logically, there should be something in the path that says <code>{fn example()}::User</code>. However, there is no syntax in Rust to express the <code>{fn example()}</code> scope.</p><p>But what does <code>std::any::type_name()</code> return for that <code>User</code> struct then? Let&#39;s figure this out:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() -&gt; &amp;&#39;</span><span>static</span><span> str</span><span> {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span></span>
<span><span>    std</span><span>::</span><span>any</span><span>::</span><span>type_name</span><span>::&lt;</span><span>User</span><span>&gt;()</span></span>
<span><span>}</span></span>
<span></span>
<span><span>fn</span><span> main</span><span>() {</span></span>
<span><span>    println!</span><span>(</span><span>&#34;{}&#34;</span><span>, </span><span>example</span><span>());</span></span>
<span><span>}</span></span></code></pre></div><p>This outputs the following:</p><div><p><span>log</span></p><pre tabindex="0"><code><span><span>crate_name::example::User</span></span></code></pre></div><p>So, the function name becomes part of the path as if it was just a simple module. However, this isn&#39;t true, or at least this behaviour isn&#39;t exposed in the language. If we try to reference the <code>User</code> from the surrounding scope using that syntax, we are still out of luck:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>type</span><span> Foo</span><span> = </span><span>example</span><span>::</span><span>User</span><span>; </span></span></code></pre></div><p>This generates a compile error:</p><div><p><span>log</span></p><pre tabindex="0"><code><span><span>error[E0433]: failed to resolve: function `example` is not a crate or module</span></span>
<span><span> --&gt; path/to/code.rs</span></span>
<span><span>  |</span></span>
<span><span>6</span><span> | type Foo = example::User;</span></span>
<span><span>  |            ^^^^^^^ function `example` is not a crate or module</span></span></code></pre></div><p>So there is just no way to refer to the <code>User</code> struct outside of the function scope, right?... Wrong üê±! There is a way to do this, but it&#39;s so complicated that let&#39;s just assume we can&#39;t do that in production code.</p><p>If you are curious, first, try to solve this yourself:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>type</span><span> Foo</span><span> = </span><span>/* how can we get the `User` type from the `example` function here? */</span><span>;</span></span></code></pre></div><p>and then take a look at the solution below:</p><details><summary>Solution for referring to a local item outside the function body.</summary><p>The idea is to implement a trait for the local type and then use that trait in the outside scope to get the local type.</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>trait</span><span> TypeChannel</span><span> {</span></span>
<span><span>    type</span><span> Type</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>struct</span><span> GetUserType</span><span>;</span></span>
<span></span>
<span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span> {</span></span>
<span><span>        name</span><span>: </span><span>String</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // We can implement a trait from the surrounding scope</span></span>
<span><span>    // that uses the local item.</span></span>
<span><span>    impl</span><span> TypeChannel</span><span> for</span><span> GetUserType</span><span> {</span></span>
<span><span>        type</span><span> Type</span><span> = </span><span>User</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>type</span><span> RootUser</span><span> = &lt;</span><span>GetUserType</span><span> as</span><span> TypeChannel</span><span>&gt;::</span><span>Type</span><span>;</span></span>
<span></span>
<span><span>// Another interesting fact. The fields of the `User` struct aren&#39;t private</span></span>
<span><span>// in the root scope. You can create the `User` struct via the `RootUser` type</span></span>
<span><span>// alias and reference its fields in the top-level scope just fine üê±.</span></span>
<span><span>fn</span><span> main</span><span>() {</span></span>
<span><span>    let</span><span> user</span><span> = </span><span>RootUser</span><span> {</span></span>
<span><span>        name</span><span>: </span><span>&#34;Bon&#34;</span><span>.</span><span>to_owned</span><span>()</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    println!</span><span>(</span><span>&#34;Here is {}!&#34;</span><span>, </span><span>user</span><span>.name);</span></span>
<span><span>}</span></span></code></pre></div><p>Now this compiles... but well, I&#39;d rather burn this code with fire üî•.</p><p>By the way, <code>rust-analyzer</code> doesn&#39;t support this pattern. It can&#39;t resolve the <code>RootUser</code> type and its fields, but <code>rustc</code> works fine with this.</p></details><hr/><p>Now, let&#39;s see what happens if we define a child module inside of the function block.</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span></span>
<span><span>    mod</span><span> child_module {</span></span>
<span><span>        use</span><span> super</span><span>::</span><span>User</span><span>; </span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div><p>Does this compile? Surely, it should compile, because the child module becomes a child of the anonymous function scope, so it should have access to symbols defined in the function, right?... Wrong üê±!</p><p>It still doesn&#39;t compile with the error:</p><div><p><span>txt</span></p><pre tabindex="0"><code><span><span>unresolved import `super::User`; no `User` in the root</span></span></code></pre></div><p>This is because <code>super</code> doesn&#39;t refer to the parent function scope, instead it refers to the top-level module (called <code>root</code> by the compiler in the error message) that defines the <code>example()</code> function. For example, this code compiles:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>struct</span><span> TopLevelStruct</span><span>;</span></span>
<span></span>
<span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span>;</span></span>
<span></span>
<span><span>    mod</span><span> child_module {</span></span>
<span><span>        use</span><span> super</span><span>::</span><span>TopLevelStruct</span><span>; </span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div><p>As you can see we took <code>TopLevelStruct</code> from <code>super</code>, so it means <code>super</code> refers to the surrounding module of the <code>example</code> function, and we already know <s>we can&#39;t</s> how hacky it is to access the symbols defined inside of that <code>example</code> function from within the surrounding module.</p><p>So.. this brings us to the following dilemma.</p><h2 id="how-does-this-affect-macros" tabindex="-1">How does this affect macros? <a href="#how-does-this-affect-macros" aria-label="Permalink to &#34;How does this affect macros?&#34;">‚Äã</a></h2><p>Macros generate code, and that code must not always be fully accessible to the scope where the macro was invoked. For example, a macro that generates a builder struct would like to restrict access to the private fields of the generated builder struct for the surrounding module.</p><p>I&#39;ll use <code>bon</code>&#39;s macros syntax to showcase this.</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>use</span><span> bon</span><span>::builder;</span></span>
<span></span>
<span><span>#[builder]</span></span>
<span><span>struct</span><span> User</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>String</span><span>,</span></span>
<span><span>}</span></span></code></pre></div><p>Let&#39;s see what the generated code for this example may look like (very simplified).</p><div><p>TIP</p><p>The real code generated by <a href="https://elastio.github.io/bon/docs/guide/overview"><code>#[bon::builder]</code></a> is a bit more complex, it uses typestate pattern to catch all potential developer errors at compile time üê±.</p></div><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>struct</span><span> User</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>String</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Default</span><span>)]</span></span>
<span><span>struct</span><span> UserBuilder</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/* {snipped} ... impl blocks for `UserBuilder` that define setters ... */</span></span>
<span></span>
<span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    let</span><span> builder</span><span> = </span><span>UserBuilder</span><span>::</span><span>default</span><span>();</span></span>
<span></span>
<span><span>    // oops, we can access the builder&#39;s internal fields here</span></span>
<span><span>    let</span><span> _</span><span> = </span><span>builder</span><span>.name;                                     </span></span>
<span><span>}</span></span></code></pre></div><p>The problem with this approach is that <code>UserBuilder</code> is defined in the same module scope as the <code>User</code> struct. It means all fields of <code>UserBuilder</code> are accessible by this module. This is how the visibility of private fields works in Rust - the entire module where the struct is defined has access to the private fields of that struct.</p><p>The way to avoid this problem is to define the builder in a nested child module, to make private fields of the builder struct accessible only within that child module.</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>struct</span><span> User</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>String</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>use</span><span> user_builder</span><span>::</span><span>UserBuilder</span><span>;</span></span>
<span></span>
<span><span>mod</span><span> user_builder { </span></span>
<span><span>    use</span><span> super</span><span>::*;</span></span>
<span></span>
<span><span>    #[derive(</span><span>Default</span><span>)]</span></span>
<span><span>    pub</span><span>(</span><span>super</span><span>) </span><span>struct</span><span> UserBuilder</span><span> {</span></span>
<span><span>        name</span><span>: </span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;,</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    let</span><span> builder</span><span> = </span><span>UserBuilder</span><span>::</span><span>default</span><span>();</span></span>
<span></span>
<span><span>    // Nope, we can&#39;t access the builder&#39;s fields now.</span></span>
<span><span>    // let _ = builder.name;</span></span>
<span><span>}</span></span></code></pre></div><p>So... problem solved, right?... Wrong üê±!</p><p>Now imagine our builder macro is invoked for a struct defined inside of a local function scope:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>use</span><span> bon</span><span>::builder;</span></span>
<span></span>
<span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> Password</span><span>(</span><span>String</span><span>);</span></span>
<span></span>
<span><span>    #[builder]</span></span>
<span><span>    struct</span><span> User</span><span> {</span></span>
<span><span>        password</span><span>: </span><span>Password</span><span>,</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div><p>If <code>#[builder]</code> creates a child module, then we have a problem. Let&#39;s see the generated code:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> example</span><span>() {</span></span>
<span><span>    struct</span><span> Password</span><span>(</span><span>String</span><span>);</span></span>
<span></span>
<span><span>    struct</span><span> User</span><span> {</span></span>
<span><span>        password</span><span>: </span><span>Password</span><span>,</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    mod</span><span> user_builder {                  </span></span>
<span><span>        use</span><span> super</span><span>::*;                   </span></span>

<span><span>        pub</span><span>(</span><span>super</span><span>) </span><span>struct</span><span> UserBuilder</span><span> { </span></span>
<span><span>            password</span><span>: </span><span>Option</span><span>&lt;</span><span>Password</span><span>&gt;, </span></span>
<span><span>        }                               </span></span>
<span><span>    }                                   </span></span>
<span><span>}</span></span></code></pre></div><p>This doesn&#39;t compile with the error:</p><div><p><span>log</span></p><pre tabindex="0"><code><span><span>password: Option&lt;Password&gt;,</span></span>
<span><span>                 ^^^^^^^^ not found in this scope</span></span></code></pre></div><p>Why is that? As we discussed higher child modules defined inside function blocks can&#39;t access symbols defined in the function&#39;s scope. The <code>use super::*</code> imports items from the surrounding top-level module instead of the function scope.</p><p>It means, that if we want to support local items in our macro we just can&#39;t use a child module if the code inside of that child module needs to reference types (or any items) from the surrounding scope.</p><p>The core problem is the conflict:</p><ul><li>We want to make the builder&#39;s fields private, so we need to define the builder struct inside of a child module.</li><li>We want to reference types from the surrounding scope in the builder&#39;s fields, including local items, so we can&#39;t define the builder struct inside the child module.</li></ul><p>This is the problem that I found in <code>buildstructor</code>. The only way to solve this is to make a compromise, which I did when implementing <a href="https://elastio.github.io/bon/docs/guide/overview"><code>#[bon::builder]</code></a>. The compromise is not to use a child module, and obfuscate the private fields of the builder struct with leading <code>__</code> and <code>#[doc(hidden)]</code> attributes to make it hard for the user to access them (even though not physically impossible).</p><p>But then... Defining types inside of functions is rather a niche use case. How do child modules in macro-generated code break the doc test mentioned at the beginning of this article?</p><h2 id="how-does-this-break-doc-tests" tabindex="-1">How does this break doc tests? <a href="#how-does-this-break-doc-tests" aria-label="Permalink to &#34;How does this break doc tests?&#34;">‚Äã</a></h2><p>Doc tests are usually code snippets that run some code defined on the top level. They don&#39;t typically contain an explicit <code>main()</code> function.</p><p>For example, a doc test like this:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>let</span><span> foo</span><span> = </span><span>1</span><span> + </span><span>1</span><span>;</span></span>
<span><span>assert_eq!</span><span>(</span><span>foo</span><span>, </span><span>2</span><span>);</span></span></code></pre></div><p>is <a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html#pre-processing-examples" target="_blank" rel="noreferrer">implicitly wrapped by <code>rustdoc</code></a> in a <code>main()</code> function like this:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> main</span><span>() {</span></span>
<span><span>    let</span><span> foo</span><span> = </span><span>1</span><span> + </span><span>1</span><span>;</span></span>
<span><span>    assert_eq!</span><span>(</span><span>foo</span><span>, </span><span>2</span><span>);</span></span>
<span><span>}</span></span></code></pre></div><p>So... If we write a code example in a doc comment with a macro that generates a child module, the doc test will probably not compile. This is what happened in the original doc test featuring <code>buildstructor</code>.</p><p>Let&#39;s bring it up again:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>#[derive(buildstructor::</span><span>Builder</span><span>)]</span></span>
<span><span>struct</span><span> User</span><span> {</span></span>
<span><span>    name</span><span>: </span><span>String</span></span>
<span><span>}</span></span>
<span></span>
<span><span>User</span><span>::</span><span>builder</span><span>()</span></span>
<span><span>    .</span><span>name</span><span>(</span><span>&#34;Foo&#34;</span><span>)</span></span>
<span><span>    .</span><span>build</span><span>();</span></span></code></pre></div><p>When preprocessing the doc test <code>rustdoc</code> wraps this code in <code>main()</code>:</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> main</span><span>() {</span></span>
<span><span>    #[derive(buildstructor::</span><span>Builder</span><span>)]</span></span>
<span><span>    struct</span><span> User</span><span> {</span></span>
<span><span>        name</span><span>: </span><span>String</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    User</span><span>::</span><span>builder</span><span>()</span></span>
<span><span>        .</span><span>name</span><span>(</span><span>&#34;Foo&#34;</span><span>)</span></span>
<span><span>        .</span><span>build</span><span>();</span></span>
<span><span>}</span></span></code></pre></div><p>Then <code>buildstructor</code> generates a child module, that refers to <code>User</code> (next code is simplified):</p><div><p><span>rust</span></p><pre tabindex="0"><code><span><span>fn</span><span> main</span><span>() {</span></span>
<span><span>    struct</span><span> User</span><span> {</span></span>
<span><span>        name</span><span>: </span><span>String</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    mod</span><span> user_builder {</span></span>
<span><span>        use</span><span> super</span><span>::*;</span></span>
<span></span>
<span><span>        struct</span><span> UserBuilder</span><span> {</span></span>
<span><span>            name</span><span>: </span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        impl</span><span> UserBuilder</span><span> {</span></span>
<span><span>            // `User` is inaccessible here</span></span>
<span><span>            fn</span><span> build</span><span>(</span><span>self</span><span>) -&gt; </span><span>User</span><span> {       </span></span>
<span><span>                /* */</span></span>
<span><span>            }</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div><h2 id="summary" tabindex="-1">Summary <a href="#summary" aria-label="Permalink to &#34;Summary&#34;">‚Äã</a></h2><p>Does this mean generating child modules for privacy in macros is generally a bad idea? It depends... The main thing is not to reference items from the surrounding scope in the child module. For example, if you need to add <code>use super::*</code> in your macro-generated code, then this is already a bad call. You should think of local items and doc tests when you do this.</p><p>If you liked this article check out my previous blog post <a href="https://elastio.github.io/bon/blog/how-to-do-named-function-arguments-in-rust"><em>&#39;How to do named function arguments in Rust&#39;</em></a> (it&#39;s also available <a href="https://www.reddit.com/r/rust/comments/1eeem92/how_to_do_named_function_arguments_in_rust/" target="_blank" rel="noreferrer">on Reddit</a>). Also, check out the <a href="https://github.com/elastio/bon" target="_blank" rel="noreferrer"><code>bon</code> crate on GitHub</a>. Consider giving it a star ‚≠ê if you like it.</p><div><p>TIP</p><p>You can leave comments for this post <a href="https://www.reddit.com/r/rust/comments/1eowtoi/the_weird_of_functionlocal_types_in_rust/" target="_blank" rel="noreferrer">on Reddit</a>.</p></div></div></div></div></div>
  </body>
</html>
