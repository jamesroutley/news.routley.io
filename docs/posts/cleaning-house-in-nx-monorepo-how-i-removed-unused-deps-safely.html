<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnjames.blog/posts/cleaning-house-in-nx-monorepo-how-i-removed-120-unused-deps-safely">Original</a>
    <h1>Cleaning house in Nx monorepo, how i removed unused deps safely</h1>
    
    <div id="readability-page-1" class="page"><article><p>Short version, I ran <a href="https://knip.dev/" target="_blank" rel="noopener">Knip</a> across our <a href="https://nx.dev/" target="_blank" rel="noopener">Nx</a> repo, took the “unused” list as a hint, deleted candidates, built, tested, booted apps, and put a few back when they were secretly used. Net, about 120 packages gone. Yarn install dropped by roughly a minute. Fewer CVE nags. Everyone slept better.</p><h3>the situation</h3><p>We got a chunky Nx monorepo. Roughly 500 deps scattered across apps and packages/libs, not all living in the root. Installs felt slow. Security alerts felt noisy. I wanted to clean house without breaking anything or making dev life worse.</p><h3>why i ditched depcheck and tried knip</h3><p>I used to reach for <a href="https://www.npmjs.com/package/depcheck" target="_blank" rel="noopener">depcheck</a>. It’s been on life support for years and doesn’t love modern setups. Knip looked current, understands monorepos, and actually sniffs entry points for common stacks. Depcheck recommends it too. It builds a little graph from imports and config refs, then compares it to package.json. Good enough for a first pass.</p><h3>what i actually did</h3><p>Baseline scan first:</p><pre><code>yarn dlx knip</code></pre><p>Then I ran the usual suspects to see what would scream if I yanked packages:</p><pre><code>yarn nx affected -t build <span>test</span> lint

yarn nx run &lt;app&gt;:serve   </code></pre><p>Knip’s pass flagged a ton of stuff on the first scan. About 40% of what it called “unused” turned out to be false positives in my setup. Totally fine, that’s expected.</p><h3>how i treated the results</h3><p>Knip is a signal, not the judge. For each package it flagged:</p><ol><li>uninstall it</li><li>build, test, lint, e2e, codegen/typegen, and then boot the owning app</li><li>if something broke, put it back and document why in my Knip ignore list</li></ol><p>Most of the false positives were “used but not imported” stuff:</p><ul><li>strings in config files, for example Jest preset or runner names</li><li>CLI tools only used in scripts or CI</li><li>plugin discovery patterns</li><li>type-only or toolchain stuff</li></ul><p>I kept a running ignore list with little comments so future me/dev isn’t confused.</p><h3>the knip setup</h3><p>I made the config monorepo-aware and added a few ignores that always trip scanners in our stack. Yours will vary, but this is just a taste without exposing too much:</p><pre><code>
<span>const</span> config = {
  <span>include</span>: [<span>&#34;dependencies&#34;</span>, <span>&#34;devDependencies&#34;</span>],
  <span>ignoreWorkspaces</span>: [<span>&#34;packages/eslint-config&#34;</span>],
  <span>ignoreDependencies</span>: [
    <span>&#34;ts-node&#34;</span>, 
    <span>&#34;cross-env&#34;</span>, 
  ],
  <span>workspaces</span>: {
    <span>&#34;apps/cms&#34;</span>: {
      <span>ignoreDependencies</span>: [<span>&#34;@sanity/vision&#34;</span>],
    },
    <span>&#34;packages/ui&#34;</span>: {
      <span>ignoreDependencies</span>: [
        <span>&#34;tw-animate-css&#34;</span>, 
        <span>&#34;@tailwindcss/typography&#34;</span>, 
      ],
    },
  },
}

<span>export</span> <span>default</span> config</code></pre><h3>verification loop</h3><p>Delete the thing. Build. Test. Yadda, yadda. Quick smoke in dev. If it’s green, ship it. If not, restore and ignore with a one-liner note.</p><p>I also did a preview deploy and watched for dumb stuff like missing assets or new console errors. Nothing exciting showed up, which is the best possible outcome.</p><h3>numbers</h3><p>Before, about 510 unique packages across the workspace. After, about 390. Roughly 120 gone. Yarn install shaved off around a minute on my machine and in CI. Exactly what I wanted.</p><h3>what knip nailed, and where it didn’t</h3><p>Good at common React and server app entry points, and lots of config conventions. Not great when usage is indirect or only happens in scripts or CI. That’s fine. Humans still have jobs.</p><h3>how i merged it without ruining anyone’s day</h3><p>Small PRs are safer, but I batched this one, deployed to a preview branch, then merged during a quiet slot so rollback would only touch my PR. I left it live while I clicked through a few user flows and tailed logs. All quiet.</p><h3>the extra bit</h3><p>Knip can also flag unused files, enums, types. Nice for dead code hunts. Same rule, treat it as a hint and verify with real builds and tests.</p><h3>what i’d do next</h3><p>Wire Knip into CI as a gentle report first. Let it run for a sprint while you tune the ignore list, then consider failing on new unused deps. Keeps the bloat from creeping back in.</p><h3>that’s it</h3><p>I didn’t reinvent anything here. Knip found low-hanging fruit, I did the human check, and we shipped a smaller, cleaner repo without drama.</p></article></div>
  </body>
</html>
