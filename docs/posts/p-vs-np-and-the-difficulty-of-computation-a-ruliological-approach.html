<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/">Original</a>
    <h1>P vs. NP and the Difficulty of Computation: A ruliological approach</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><img title="P vs. NP and the Difficulty of Computation: A Ruliological Approach" src="https://content.wolfram.com/sites/43/2026/01/P-vs-NP-hero-v3.png" alt="P vs. NP and the Difficulty of Computation: A Ruliological Approach" width="620" height="353"/><span></span></p>
<h2 id="empirical-theoretical-computer-science">Empirical Theoretical Computer Science</h2>
<p>“Could there be a faster program for that?” It’s a fundamental type of question in theoretical computer science. But except in special cases, such a question has proved fiendishly difficult to answer. And, for example, in half a century, almost no progress has been made even on the rather coarse (though very famous) <a href="https://www.wolframscience.com/nks/notes-12-8--p-versus-np-questions/">P vs. NP question</a>—essentially of whether for any nondeterministic program there will always be a deterministic one that is as fast. From a purely theoretical point of view, it’s never been very clear how to even start addressing such a question. But what if one were to look at the question empirically, say in effect just by enumerating possible programs and explicitly seeing how fast they are, etc.? </p>
<p>One might imagine that any programs one could realistically enumerate would be too small to be interesting. But what I <a href="https://www.wolframscience.com/nks/chap-2--the-crucial-experiment/">discovered in the early 1980s</a> is that this is absolutely not the case—and that in fact it’s very common for programs even small enough to be easily enumerated to show extremely rich and complex behavior. With this intuition I already in the 1990s <a href="https://www.wolframscience.com/nks/p761--undecidability-and-intractability/">began some empirical exploration</a> of things like the fastest ways to compute functions with <a href="https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs#sect-3-4--turing-machines">Turing machines</a>. But now—particularly with the <a href="https://writings.stephenwolfram.com/2021/11/the-concept-of-the-ruliad/">concept of the ruliad</a>—we have a framework for thinking more systematically about the space of possible programs, and so I’ve decided to look again at what can be discovered by <a href="https://writings.stephenwolfram.com/category/ruliology">ruliological investigations</a> of the computational universe about questions of <a href="https://www.wolframscience.com/nks/notes-12-8--computational-complexity-theory/">computational complexity theory</a> that have arisen in theoretical computer science—including the P vs. NP question.<span id="more-71843"></span></p>
<p>We won’t resolve the P vs. NP question. But we will get a host of definite, more restricted results. And by looking “underneath the general theory” at explicit, concrete cases we’ll get a sense of some of the fundamental issues and subtleties of the P vs. NP question, and why, for example, proofs about it are likely to be so difficult.</p>
<p>Along the way, we’ll also see lots of evidence of the <a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence#sect-12-6--computational-irreducibility">phenomenon of computational irreducibility</a>—and the general pattern of the difficulty of computation. We’ll see that there are computations that can be “reduced”, and done more quickly. But there are also others where we’ll be able to see with absolute explicitness that—at least within the class of programs we’re studying—there’s simply no faster way to get the computations done. In effect this is going to give us lots of proofs of restricted forms of computational irreducibility. And seeing these will give us ways to further build our intuition about the ever-more-central phenomenon of computational irreducibility—as well as to see how in general we can use the <a href="https://writings.stephenwolfram.com/2021/09/charting-a-course-for-complexity-metamodeling-ruliology-and-more/#the-pure-basic-science-of-ruliology">methodology of ruliology</a> to explore questions of theoretical computer science.</p>
<h2 id="the-basic-setup">The Basic Setup</h2>
<p><em>Click any diagram to get Wolfram Language code to reproduce it.</em></p>
<p>How can we enumerate possible programs? We could pick any model of computation. But to help connect with traditional theoretical computer science, I’ll use a classic one: <a href="https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs#sect-3-4--turing-machines">Turing machines</a>. </p>
<p>Often in theoretical computer science one concentrates on yes/no decision problems. But here it’ll typically be convenient instead to think (more “mathematically”) about <a href="https://www.wolframscience.com/nks/p759--undecidability-and-intractability/">Turing machines that compute integer functions</a>. The setup we’ll use is as follows. Start the Turing machine with the digits of some integer <em>n</em> on its tape. Then run the Turing machine, stopping if the Turing machine head goes further to the right than where it started. The value of the function with input <em>n</em> is then read off from the binary digits that remain on its tape when the Turing machine stops. (There are many other <a href="https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/" target="_blank" rel="noopener">“halting” criteria we could use</a>, but this is a particularly robust and convenient one.)</p>
<p>So for example, given a Turing machine with rule</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg1.png" alt="" title="" width="179" height="37"/> </p>

<p>we can feed it successive integers as input, then run the machine to find the successive values it computes:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg2.png" alt="" title="" width="666" height="217"/> </p>

<p>In this case, the function that the Turing machine computes is</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg3.png" alt="" title="" width="654" height="37"/> </p>

<p>or in graphical form:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg4.png" alt="" title="" width="547" height="202"/> </p>

<p>For each input, the Turing machine takes a certain number of steps to stop and give its output (i.e. the value of the function):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg5.png" alt="" title="" width="547" height="204"/> </p>

<p>But this particular Turing machine isn’t the only one that can compute this function. Here are two more:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg6.png" alt="" title="" width="662" height="258"/> </p>

<p>The outputs are the same as before, but the runtimes are different:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg7.png" alt="" title="" width="433" height="285"/> </p>

<p>Indicating these respectively by  <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01232026basicimg9.png" width="7" height="7"/> <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01232026basicimg10.png" width="7" height="7"/> <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01232026basicimg11.png" width="7" height="7"/>  and plotting them together, we see that there are definite trends—but no clear winner for “fastest program”: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg11.png" alt="" title="" width="647" height="112"/> </p>

<p>In <a href="https://www.wolframscience.com/nksonline/page-1142b/">computational complexity theory</a>, it’s common to discuss how runtime varies with input size—which here means taking each block of inputs with a given number of digits, and just finding its maximum:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg12.png" alt="" title="" width="420" height="252"/> </p>

<p>And what we see is that in this case the first Turing machine shown is “systematically faster” than the other two—and in fact provides the fastest way to compute this particular function among Turing machines of the size we’re using. </p>
<p>Since we’ll be dealing with lots of Turing machines here, it’s convenient to be able to specify them just with numbers—and we’ll do it the way <tt><a href="https://reference.wolfram.com/language/ref/TuringMachine.html">TuringMachine</a></tt> in the <a href="https://www.wolfram.com/language/">Wolfram Language</a> does. And with this setup, the machines we’ve just considered have numbers 261, 3333 and 1285.</p>
<p>In thinking about functions computed by Turing machines, there is one immediate subtlety to consider. We’ve said that we find the output by reading off what’s on the Turing machine tape when the Turing machine stops. But what if the machine never stops? (Or in our case, what if the head of the Turing machine never reaches the right-hand end?) Well, then there’s no output value defined. And in general, the functions our Turing machines compute will only be partial functions—in the sense that for some of their inputs, there may be no output value defined (as here for machine 2189):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg13.png" alt="" title="" width="603" height="147"/> </p>

<p>When we plot such partial functions, we’ll just have a gap where there are undefined values: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg14.png" alt="" title="" width="397" height="154"/> </p>

<p>In what follows, we’ll be exploring Turing machines of different “sizes”. We’ll assume that there are two possible colors for each position on the tape—and that there are <em>s</em> possible states for the head. The total number of possible Turing machines with <em>k</em> = 2 colors and <em>s</em> states is (2<em>ks</em>)<sup><em>ks</em></sup>—which grows rapidly with <em>s</em>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026basicimg16.png" alt="" title="" width="674" height="55"/> </p>

<p>For any given function we’ll then be able to ask what machine (or machines) up to a given size compute it the fastest. In other words, by explicitly studying possible Turing machines, we’ll be able to establish an absolute lower bound on the computational difficulty of computing a function, at least when that computation is done by a Turing machine of at most a given size. (And, yes, the size of the Turing machine can be thought of as characterizing its “<a href="https://www.wolframscience.com/nks/notes-10-3--algorithmic-information-theory/">algorithmic information content</a>”.)</p>
<p>In traditional computational complexity theory, it’s usually been very difficult to establish lower bounds. But our ruliological approach here will allow us to systematically do it (at least relative to machines of a given size, i.e. with given algorithmic information content). (It’s worth pointing out that <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#with-a-sufficiently-large-turing-machine">if a machine is big enough</a>, it can include a lookup table for any number of cases of any given function—making questions about the difficulty of computing at least those cases rather moot.) </p>
<h2 id="the-s1-k2-turing-machines">The s = 1, k = 2 Turing Machines</h2>
<p>To begin our systematic investigation of possible programs, let’s consider what is essentially the simplest possible case: Turing machines with one state and two possible colors of cells on their tape <nobr>(<em>s</em> = 1, <em>k</em> = 2)</nobr>. There are just 16 of these machines—which we can number 0 through 15—with rules:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img1.png" alt="" title="" width="388" height="167"/> </p>

<p>Here’s what each of these machines does for successive integer inputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img2.png" alt="" title="" width="692" height="277"/> </p>

<p>Looking at the outputs in each case, we can plot the functions these compute: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img3.png" alt="" title="" width="587" height="228"/> </p>

<p>And here are the corresponding runtimes:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img4.png" alt="" title="" width="586" height="222"/> </p>

<p>Out of all 16 machines, 8 compute total functions (i.e. the machines always terminate, so the values of the functions are defined for every input), and 8 don’t. Four machines produce “complicated-looking” functions; an example is machine 14, which computes the function: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img5.png" alt="" title="" width="618" height="119"/> </p>

<p>There are a <a href="https://oeis.org/A086799" target="_blank" rel="noopener">variety of representations</a> for this function, including</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img6.png" alt="" title="" width="94" height="14"/> </p>

<p>and:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img7.png" alt="" title="" width="279" height="14"/> </p>

<p>The way the function is computed by the Turing machine is</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img8.png" alt="" title="" width="643" height="201"/> </p>

<p>and the runtime is given by </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img9.png" alt="" title="" width="618" height="111"/> </p>

<p>which<a href="https://oeis.org/A037227" target="_blank" rel="noopener"> is simply</a>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img10.png" alt="" title="" width="193" height="14"/> </p>

<p>For input of size <em>n</em>, this implies the worst-case time complexity for computing this function is <nobr>2<em>n </em>– 1</nobr>. The fraction of size-<em>n</em> inputs that have time complexity <nobr>2<em>t</em> + 1</nobr> is <nobr>2<sup>–<em>t</em></sup></nobr>—leading to a median time complexity that converges to the constant value of 2 and a mean one that converges to 3. </p>
<p>Each one of the 1-state machines works at least slightly differently. But in the end, all of them are simple enough in their behavior that one can readily give a “closed-form formula” for the value of <em>f</em>[<em>i</em>] for any given <em>i</em>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s1k2img13.png" alt="" title="" width="610" height="79"/> </p>

<p>One thing that’s notable is that—except in the trivial case where all values are undefined—there are no examples among <nobr><em>s</em> = 1, <em>k</em> = 2</nobr> Turing machines where different machines compute the same function. In effect, there are just too few Turing machines of this type to end up with overlaps. But, as we’ll see, as soon as we get to <nobr><em>s</em> = 2, <em>k</em> = 2</nobr> there start to be overlaps….</p>
<h2 id="s2-k2-turing-machines">s = 2, k = 2 Turing Machines</h2>
<p>There are a total of <a href="https://www.wolframscience.com/nks/p79--turing-machines/">4096 possible 2-state, 2-color Turing machines</a>. Running all these machines, we find that they compute a total of 350 distinct functions—of which 189 are total. Here are plots of these distinct total functions—together with a count of how many machines generate them (altogether 2017 of the 4096 machines always terminate, and therefore compute total functions):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01292026s2k2img1.png" alt="" title="" width="625" height="646"/> </p>

<p>Plotting the values of all these functions in 3D, we see that the vast majority have values <em>f</em>[<em>i</em>] that are close to their inputs <em>i</em>—indicating that in a sense the Turing machines usually “don’t do much” to their input:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img2.png" alt="" title="" width="405" height="240"/> </p>

<p>To see more clearly what the machines “actually do”, we can look at the quantity <nobr><em>f</em>[<em>i</em>] – <em>i</em></nobr>. We then find that for 59 of the 189 distinct functions (and 1325 of the underlying machines) the values of this quantity are ultimately periodic. Most often the period is 4, as in</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img3.png" alt="" title="" width="633" height="202"/> </p>

<p>though in 6 cases it is 2, and in 3 cases (which include the “most popular” case <nobr><em>f</em>[<em>i</em>] = <em>i</em>)</nobr> it is 1. </p>
<p>Dropping periodic cases, the remaining distinct <nobr><em>f</em>[<em>i</em>] – <em>i</em></nobr> are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img4.png" alt="" title="" width="648" height="549"/> </p>

<p>Some of what we see here is similar to the 1-state case. An example of different behavior occurs for machine 2223</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img5.png" alt="" title="" width="577" height="191"/> </p>

<p>which gives for <nobr><em>f</em>[<em>i</em>] – <em>i</em></nobr>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img6.png" alt="" title="" width="473" height="160"/> </p>

<p>In this case <em>f</em>[<em>i</em>] turns out to be expressible simply as</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2-aimg1.png" alt="" title="" width="181" height="14"/> </p>

<p>or:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2-aimg2.png" alt="" title="" width="200" height="20"/> </p>

<p>Another example is machine 2079</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img9.png" alt="" title="" width="577" height="230"/> </p>

<p>which gives for <nobr><em>f</em>[<em>i</em>] – <em>i</em></nobr>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img10.png" alt="" title="" width="473" height="162"/> </p>

<p>This function once again turns out to be expressible in “closed form”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2-aimg3.png" alt="" title="" width="342" height="14"/> </p>

<p>Some functions grow rapidly. For example, machine 3239</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img12.png" alt="" title="" width="564" height="226"/> </p>

<p>has values:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img13.png" alt="" title="" width="448" height="150"/> </p>

<p>These have the property that <nobr><em>f</em>[2<sup><em>j</em></sup>] = 2<sup>2<em>j</em> + 3</sup> – 1</nobr>, so that <nobr><em>f</em>[<em>i</em>] ~ <em>i</em><sup>2</sup></nobr>.</p>
<p>There are many subtleties even in dealing with 2-state Turing machines. For example, different machines may “look like” they’re generating the same function <em>f</em>[<em>i</em>] up to a certain value of <em>i</em>, and only then deviate. The most extreme example of such a “surprise” among machines generating total functions occurs among:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img17.png" alt="" title="" width="472" height="78"/> </p>

<p>Up to <nobr><em>i </em>= 26</nobr>, all these machines generate the same values for <em>f</em>[<em>i</em>] for all <em>i</em>. But then at <nobr><em>i </em>= 27</nobr>, suddenly <nobr><em>f</em>[<em>i</em>] = 24</nobr> for the first machine, and <nobr><em>f</em>[<em>i</em>] = 0</nobr> for the others:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img18.png" alt="" title="" width="662" height="507"/> </p>

<p>What about partial functions? At least for 2-state machines, if undefined values in <em>f</em>[<em>i</em>] are ever going to occur, they always already occur for small <em>i</em>. The “longest holdouts” are machines 1960 and 2972, which are both first undefined for input 8</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s2k2img19.png" alt="" title="" width="610" height="223"/> </p>

<p>but which “become undefined” in different ways: in machine 1960, the head systematically moves to the left, while in machine 2972, it moves periodically back and forth forever, without ever reaching the right-hand end. (Despite their different mechanisms, both rules share the feature of being undefined for all inputs that are multiples of 8.)</p>
<h2 id="runtimes-in-s2-k2-machines">Runtimes in s = 2, k = 2 Machines</h2>
<p>What about runtimes? If a function <em>f</em>[<em>i</em>] is computed by several different Turing machines, the details of how it’s computed by each machine will normally be at least slightly different. Still, in many cases the mechanisms are similar enough that their runtimes are the same. And in the end, among all the 2017 machines that compute our 189 distinct total functions, there are only 103 distinct “profiles” of runtime vs. input (and indeed many of these are very similar): </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg1.png" alt="" title="" width="664" height="577"/> </p>

<p>The picture gets simpler if, rather than plotting runtimes for each specific input value, we instead plot the worst-case runtime for all inputs of a given size. (In effect we’re plotting against <tt><a href="http://reference.wolfram.com/language/ref/IntegerLength.html">IntegerLength</a></tt><tt>[</tt><em>i</em>, 2<tt>]</tt> or <tt><a href="http://reference.wolfram.com/language/ref/Ceiling.html">Ceiling</a></tt><tt>[</tt><tt><a href="http://reference.wolfram.com/language/ref/Log2.html">Log2</a></tt><tt>[</tt><em>i </em>+ 1<tt>]]</tt>.) There turn out to be just 71 distinct profiles for such worst-case time complexity</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg2.png" alt="" title="" width="640" height="368"/> </p>

<p>and indeed all of these have fairly simple closed forms—which for even <em>n</em> are (with directly analogous forms for odd <em>n</em>):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg3.png" alt="" title="" width="683" height="161"/> </p>

<p>If we consider the behavior of these worst-case runtimes for large input lengths <em>n</em>, we find that fairly few distinct growth rates occur—notably with linear, quadratic and exponential cases, but nothing in between:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg4.png" alt="" title="" width="542" height="52"/> </p>

<p>The machines with the fastest growth <nobr>(2<sup><em>n</em> + 2</sup>)</nobr> are the closely related 378 and 1351. Both in effect “go to a lot of effort”—but eventually just compute the identity function <em>f</em>[<em>i</em>] = <em>i</em>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg6.png" alt="" title="" width="577" height="181"/> </p>

<p>For a size-<em>n</em> input, the maximum value of the function is just the maximum integer with <em>n</em> digits, or <nobr>2<sup><em>n</em></sup> – 1</nobr>. The maximum runtimes <nobr>2<sup><em>n</em> + 2</sup> – 3</nobr> appear exactly for these inputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg9.png" alt="" title="" width="397" height="119"/> </p>

<p>And at these maxima, the machine is effectively operating like a binary counter, generating all the states it can, with the head moving in a very regular nested pattern:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg10.png" alt="" title="" width="357" height="98"/> </p>

<p>It turns out that for <nobr><em>s</em> = 2, <em>k </em>= 2</nobr> Turing machines, all machines that have exponentially growing runtimes ultimately compute rather trivial functions—essentially just the identity function. Of the 4 machines whose runtimes asymptotically increase like <nobr>2<sup><em>n</em> + 1</sup></nobr>, 3626 and 3717 compute the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr>, while 2289 and 1953 compute <nobr><em>i</em> + <tt><a href="http://reference.wolfram.com/language/ref/Mod.html">Mod</a></tt><tt>[</tt><em>i</em> + 1, 2<tt>]</tt></nobr>. Only one machine—924—has asymptotic runtime growth <nobr>2<sup><em>n</em></sup></nobr>; its actual worst-case runtime is <nobr>2<sup><em>n</em></sup> – 2</nobr>, and it computes <nobr><em>i – </em><tt>Mod</tt><tt>[</tt><em>i</em>, 2<tt>]</tt></nobr>. </p>
<p>Of the 8 machines with runtimes growing like <nobr>2<em>n</em><sup>2</sup></nobr>, all lead to functions with nested structures whose maximum values for inputs of size <em>n</em> grow like <nobr>4<sup><em>n</em></sup></nobr> (corresponding to maximum function values <nobr><em>f</em>[<em>i</em>] ~ <em>i</em><sup>2</sup></nobr>)—here shown on a log-log plot:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg17.png" alt="" title="" width="355" height="110"/> </p>

<p>The two machines with asymptotic runtime growth <nobr><em>n</em><sup>2</sup></nobr> and the machine with asymptotic runtime growth <nobr><em>n</em><sup>2</sup>/2</nobr> show somewhat more complicated behavior (note that the function values are on a log-log plot):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg20.png" alt="" title="" width="669" height="145"/> </p>

<p>Here’s the actual behavior of these machines when given inputs 1 through 10:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026runtimesimg21.png" alt="" title="" width="656" height="581"/> </p>

<p>(The lack of runtimes intermediate between quadratic and exponential is notable—and perhaps reminiscent of the rarity of “intermediate growth” seen for example in the cases of <a href="https://www.wolframscience.com/nks/notes-5-6--semigroups-and-groups-and-multiway-systems/">finitely generated groups</a> and <a href="https://bulletins.wolframphysics.org/2021/10/multicomputation-with-numbers-the-case-of-simple-multiway-systems/" target="_blank" rel="noopener">multiway systems</a>.)</p>
<h2 id="runtime-distributions">Runtime Distributions</h2>
<p>Our emphasis so far has been on worst-case runtimes: the largest runtimes required for inputs of any given size. But we can also ask about the distribution of runtimes within inputs of a given size. </p>
<p>So, for example, here are the runtimes for all size-11 inputs for a particular, fairly typical Turing machine (<nobr><em>s </em>= 2, <em>k </em>= 2</nobr>, machine 3111):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026distributionsimg1.png" alt="" title="" width="647" height="109"/> </p>

<p>The maximum (“worst-case”) value here is 43—but the median is only 13. In other words, while some computations take a while, most run much faster—so that the runtime distribution is peaked at small values:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026distributionsimg2.png" alt="" title="" width="392" height="109"/> </p>

<p>(The way our Turing machines are set up, they always run for an even number of steps before terminating—since to terminate, the head must move one position to the right for every position it moved to the left.)</p>
<p>If we increase the size of the inputs, we see that the distribution, at least in this case, is close to exponential:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026distributionsimg3.png" alt="" title="" width="239" height="128"/> </p>

<p>It turns out that this kind of exponential distribution is typical of what we see in almost all Turing machines. (It’s notable that this is rather different from the <em>t</em><sup> –1/2</sup> “stopping time” distribution we’d expect if the Turing machine head was “on average” executing a random walk with an absorbing boundary.) There are nevertheless machines whose distributions deviate significantly from exponential, examples being:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026distributionsimg5.png" alt="" title="" width="653" height="153"/> </p>

<p>Some simply have long tails to their exponentials. Others, however, have an overall non-exponential form. </p>
<h2 id="how-fast-can-functions-be-computed">How Fast Can Functions Be Computed?</h2>
<p>We’ve now seen lots of functions—and runtime profiles—that <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines can produce. And this puts us in a position to say more about our core question: how fast can functions be computed?</p>
<p>We’ve seen that there are machines that compute functions quite slowly—like in exponential time. But are these machines the fastest that compute those particular functions? It turns out the answer is no. </p>
<p>And if we look across all 189 total functions computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines, and ask how fast the fastest machines that compute those functions are, we find the following:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg1.png" alt="" title="" width="450" height="52"/> </p>

<p>In other words, there are 8 functions that are the “most difficult to compute” for <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines—and that can’t be computed by such machines in less than of order 2<nobr><em>n</em><sup>2</sup></nobr> time. </p>
<p>What are these functions? Here’s one of them (computed by machine 1511):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg3.png" alt="" title="" width="650" height="37"/> </p>

<p>If we plot this function, it seems to have a nested form</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg4.png" alt="" title="" width="387" height="118"/> </p>

<p>which becomes somewhat more obvious on a log-log plot:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg5.png" alt="" title="" width="399" height="127"/> </p>

<p>As it turns out, there’s what amounts to a “closed form” for this function</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026fast-aimg1.png" alt="" title="" width="450" height="14"/> </p>

<p>though unlike the closed forms we saw above, this one involves <tt><a href="https://reference.wolfram.com/language/ref/Nest.html">Nest</a></tt>, and effectively computes its results recursively:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg7.png" alt="" title="" width="652" height="99"/> </p>

<p>How about machine 1511? Well, here’s how it computes this function—in effect visibly using recursion: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg8.png" alt="" title="" width="642" height="195"/> </p>

<p>The runtimes are</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg9.png" alt="" title="" width="357" height="112"/> </p>

<p>giving worst-case runtimes for inputs of size <em>n</em> of the form:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg10.png" alt="" title="" width="77" height="14"/> </p>

<p>It turns out all 8 functions with minimum runtimes growing like <nobr>2<em>n</em><sup>2</sup></nobr> work very much the same—with exact runtimes for machines that compute them being:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg12.png" alt="" title="" width="647" height="40"/> </p>

<p>For the functions with fastest computation times <nobr><em>n</em><sup>2</sup></nobr> and <nobr><em>n</em><sup>2</sup>/2</nobr>, we saw in the previous section both the form of these functions and the behaviors of the Turing machines that compute them. The runtimes for these machines (for even <em>n</em>) are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01262026fastimg15.png" alt="" title="" width="368" height="50"/> </p>

<p>So what can we conclude? Well, we now know some functions that cannot be computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines any faster than in quadratic time. In other words, by exhaustively looking at all <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines, we’ve established lower bounds for the computation times of these functions—at least within this class of Turing machines. </p>
<h2 id="computing-the-same-functions-at-different-speeds">Computing the Same Functions at Different Speeds</h2>
<p>We now know the fastest that certain functions can be computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines. But can those same functions also be computed slower by other machines of the same type? It turns out that for the cases we discussed in the previous section, there is only one <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machine that computes each of these functions. In other words, there’s neither a faster nor a slower way to compute these functions with <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines.</p>
<p>And in fact it’s common for there to be only one machine that computes a given function. Out of the 189 total functions that can be computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines, 105 can be computed by only one such machine. Still, there are other functions where multiple machines compute the same function—with the most extreme case being the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr> which can be computed by no fewer than 299 different machines: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg1.png" alt="" title="" width="521" height="40"/> </p>

<p>OK, but if multiple machines compute the same function, we can then ask how their speeds compare. Well, it turns out that for 145 of our 189 total functions all the different machines that compute the same function do so with the same “runtime profile” (i.e. with the same runtime for each input <em>i</em>). But that leaves 44 functions for which there are multiple runtime profiles: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg2.png" alt="" title="" width="348" height="40"/> </p>

<p>Here are all these 44 functions, together with the distinct runtime profiles for machines that compute them:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg3.png" alt="" title="" width="666" height="323"/> </p>

<p>Much of the time we see that the possible runtime profiles for computing a given function differ only very little. But sometimes the difference is more significant. For example, for the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr>, where there are a total of 299 machines that compute it, there turn out to be 10 distinct runtime profiles:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg4.png" alt="" title="" width="536" height="195"/> </p>

<p>Within these 10 profiles, there are 3 distinct rates of growth for the worst-case runtime by input size: constant, linear, and exponential</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg5.png" alt="" title="" width="627" height="93"/> </p>

<p>exemplified by machines 3197, 3589 and 3626 respectively:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg6.png" alt="" title="" width="652" height="429"/> </p>

<p>Of course, there’s a trivial way to compute this particular function—just by having a Turing machine that doesn’t change its input. And, needless to say, such a machine has runtime 1 for all inputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg7.png" alt="" title="" width="652" height="34"/> </p>

<p>It turns out that for <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines, the only total functions that show such a large range of possible runtimes are the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr>, and the closely related <nobr><em>f</em>[<em>i</em>] = <em>i</em> + <tt>Mod</tt>[<em>i</em>, 2]</nobr>—which is computed for example by machines 829, 926 and 924:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg8.png" alt="" title="" width="652" height="334"/> </p>

<p>But although there are not different “orders of growth” for worst-case runtimes among any other (total) functions computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines, there are plenty of specific variations in runtimes—either changes in overall scale, or changes in “periodicity”. For example, machines 773, 897 and 919 all compute the function</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg9.png" alt="" title="" width="558" height="80"/> </p>

<p>by slightly different methods</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg10.png" alt="" title="" width="616" height="270"/> </p>

<p>with different worst-case runtime profiles</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg11.png" alt="" title="" width="627" height="101"/> </p>

<p>or:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg12.png" alt="" title="" width="537" height="21"/> </p>

<p>By the way, if we consider partial instead of total functions, nothing particularly different happens, at least with <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines—and the only linear vs. exponential runtimes are associated with machines like</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg13.png" alt="" title="" width="628" height="195"/> </p>

<p>that are again essentially computing the identity function.</p>
<p>Another question is how <nobr><em>s </em>= 2</nobr> Turing machines compare to <nobr><em>s </em>= 1</nobr> ones. Not surprisingly, there are lots of <nobr><em>s </em>= 2</nobr> machines that can compute the same functions as <nobr><em>s </em>= 1</nobr> machines:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg14.png" alt="" title="" width="627" height="147"/> </p>

<p>But how fast are the computations? This compares the possible worst-case runtimes for <nobr><em>s </em>= 2</nobr> machines and (in purple) for an <nobr><em>s </em>= 1</nobr> machine that computes the same function:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg15.png" alt="" title="" width="643" height="125"/> </p>

<p>There must always be <nobr><em>s </em>= 2</nobr> machines that compute at the same speed as <nobr><em>s </em>= 1</nobr> machines. All that’s needed is for the rule for the <nobr><em>s </em>= 2</nobr> machine never to “access” its second state when starting from <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg16.png" width="5" height="10"/>, as in:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg17.png" alt="" title="" width="173" height="36"/> </p>

<p>But can <nobr><em>s </em>= 2</nobr> machines run faster than the corresponding <nobr><em>s </em>= 1</nobr> machines? The answer turns out to be no. And typically <nobr><em>s </em>= 2</nobr> machines tend to be slower, basically because they do more “puttering around”, as in:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026computingimg18.png" alt="" title="" width="600" height="268"/> </p>

<h2 id="absolute-lower-bounds-and-the-efficiency-of-machines">Absolute Lower Bounds and the Efficiency of Machines</h2>
<p>We’ve seen that different Turing machines can take different times to compute particular functions. But how fast can any conceivable Turing machine—even in principle—compute a given function? </p>
<p>There’s an obvious absolute lower bound to the runtime: with the way we’ve set things up, if a Turing machine is going to take input <em>i</em> and generate output <em>j</em>, its head has to at least be able to go far enough to the left to reach all the bits that need to change in going from <em>i</em> to <em>j</em>—as well as making it back to the right-hand end so that the machine halts. The number of steps required for this is</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg1.png" alt="" title="" width="315" height="14"/> </p>

<p>which for values of <em>i</em> and <em>j</em> up to 8 bits is:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg2.png" alt="" title="" width="618" height="288"/> </p>

<p>So how do the runtimes of actual Turing machine computations compare with these absolute lower bounds?</p>
<p>Here’s the behavior of <em>s </em>= 1, <em>k </em>= 2 machines 1 and 3, where for each input we’re giving the actual runtime along with the absolute lower bound:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg3.png" alt="" title="" width="591" height="227"/> </p>

<p>In the second case, the machine is always as efficient as it absolutely can be; in the first case, it only sometimes is—though the maximum slowdown is only 2 steps. </p>
<p>For <em>s </em>= 2, <em>k </em>= 2 machines, the differences can be much larger. For example, machine 378 can take exponential time—even though the absolute lower bound in this case is just 1 step, since this machine computes the identity function: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg4.png" alt="" title="" width="591" height="307"/> </p>

<p>Here’s another example (machine 1447) in which the actual runtime is always roughly twice the absolute lower bound:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg5.png" alt="" title="" width="672" height="337"/> </p>

<p>But how does the smallest (worst-case) runtime for any <em>s </em>= 2 Turing machine to compute a given function compare to the absolute lower bound? Well, in a result that presages what we’ll see later in discussing the P vs. NP question, the difference can be increasingly large: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg6.png" alt="" title="" width="629" height="97"/> </p>

<p>The functions being computed here are</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg7.png" alt="" title="" width="630" height="78"/> </p>

<p>and the fastest <em>s </em>= 2 Turing machines that do this are (machines 2205, 3555 and 2977):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026absoluteimg8.png" alt="" title="" width="592" height="609"/> </p>

<p>Our absolute lower bound determines how fast a Turing machine can possibly generate a given output. But one can also think of it as something that measures how much a Turing machine has “achieved” when it generates a given output. If the output is exactly the same as the input, the Turing machine has effectively “achieved nothing”. The more they differ, the more one can think of the machine having “achieved”. </p>
<p>So now a question one can ask is: are there functions where little is achieved in the transformation from input to output, but where the minimum runtime to perform this transformation is still long? One might wonder about the identity function—where in effect “nothing is achieved”. And indeed we’ve seen that there are Turing machines that compute this function, but only slowly. However, there are also machines that compute it quickly—so in a sense its computation doesn’t need to be slow. </p>
<p>The function above computed by machine 2205 is a somewhat better example. The (worst-case) “distance” between input and output grows like 2<em>n</em> with the input size <em>n</em>, but the fastest the function can be computed is what machine 2205 does, with a runtime that grows like 10<em>n</em>. Yes, these are still both linear in <em>n</em>. But at least to some extent this is an example of a function that “doesn’t need to be slow to compute”, but is at least somewhat slow to compute—at least for any <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 2</nobr> Turing machine.</p>
<h2 id="space-complexity">Space Complexity</h2>
<p>How difficult is it to compute the value of a function, say with a Turing machine? One measure of that is the time it takes, or, more specifically, how many Turing machine steps it takes. But another measure is how much “space” it takes, or, more specifically, with our setup, how far to the left the Turing machine head goes—which determines how much “Turing machine memory” or “tape” has to be present. </p>
<p>Here’s a typical example of the comparison between “space” and “time” used in a particular Turing machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026spaceimg1.png" alt="" title="" width="615" height="124"/> </p>

<p>If we look at all possible space usage profiles as a function of input size we see that—at least for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 2</nobr> Turing machines—the results are rather unremarkable; the space usage either becomes constant, or increases basically linearly with input size:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026spaceimg2.png" alt="" title="" width="590" height="251"/> </p>

<p>(One could also consider different measures of “complexity”—perhaps appropriate for different kinds of idealized hardware. Examples include seeing the total length of path traversed by the head, the total area of the region delimited by the head, the number of times 1 is written to the tape during the computation, etc.)</p>
<h2 id="runtime-distributions-for-particular-inputs-across-machines">Runtime Distributions for Particular Inputs across Machines</h2>
<p>We’ve talked quite a lot about how runtime varies with input (or input size) for a particular machine. But what about the complementary question: given a particular input, how does runtime vary across different machines? Consider, for example, the <nobr><em>s </em>= 1,</nobr> <nobr><em>k </em>= 2</nobr> Turing machines. Here’s what happens with all 16 such machines, starting with input value 1: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg1.png" alt="" title="" width="556" height="130"/> </p>

<p>The runtimes for these machines are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg2.png" alt="" title="" width="432" height="40"/> </p>

<p>Here’s what we see if we continue to larger inputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg3.png" alt="" title="" width="359" height="292"/> </p>

<p>The maximum (finite) runtime across all <nobr><em>s </em>= 1,</nobr> <nobr><em>k </em>= 2</nobr> machines then varies with input <em>i</em> according to</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg4.png" alt="" title="" width="683" height="40"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg5.png" alt="" title="" width="357" height="114"/> </p>

<p>or in closed form:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg6B.png" alt="" title="" width="326" height="17"/> </p>

<p>For <em>s </em>= 2, <em>k </em>= 2 machines, the distribution of runtimes with input 1 is</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg7.png" alt="" title="" width="270" height="113"/> </p>

<p>where the maximum value of 17 is achieved for machine 1447. For larger inputs the maximum runtimes are: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg8.png" alt="" title="" width="642" height="40"/> </p>

<p>Plotting these maximum runtimes</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg9.png" alt="" title="" width="357" height="111"/> </p>

<p>we see a big peak at input 127, corresponding to runtime 509 (achieved by machines 378 and 1351). And, yes, plotting the distribution for input 127 of runtimes for all machines, we see that this is a significant outlier:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg10.png" alt="" title="" width="355" height="114"/> </p>

<p>If one computes runtimes maximized over all machines and all inputs for successively larger sizes of inputs, one gets (once again dominated by machines 378 and 1351):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg11.png" alt="" title="" width="465" height="40"/> </p>

<p>By the way, one can compute not only runtimes but also values and widths maximized across machines: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg12.png" alt="" title="" width="653" height="55"/> </p>

<p>And, no, the maximum value isn’t always of the form <nobr>2<sup><em>m</em></sup> – 1:</nobr> the first case where it isn’t is input 265—where it’s 383, as generated by machine 2242:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026particularimg14.png" alt="" title="" width="86" height="133"/> </p>

<h2 id="s3-k2-turing-machines-and-the-problem-of-undecidability">s = 3, k = 2 Turing Machines and the Problem of Undecidability</h2>
<p>We’ve so far looked at <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> and <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines. Now let’s talk about <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> ones. There are a total of 2,985,984 such machines. And it might seem like a straightforward question to ask: how many distinct functions can these machines compute? But actually this question is far from straightforward. </p>
<p>The issue—as so often—is of <a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence#sect-12-6--computational-irreducibility">computational irreducibility</a>. Let’s say you have a machine and you’re trying to figure out if it computes a particular function. Or you’re even just trying to figure out if for input <em>i</em> it gives output <em>j</em>. Well, you might say, why not just run the machine? And of course you can do that. But the problem is: how long should you run it for? Let’s say the machine has been running for a million steps, and still hasn’t generated any output. Will the machine eventually stop, producing either output <em>j</em> or some other output? Or will the machine just keep running forever, and never generate any output at all? </p>
<p>If the behavior of the machine was computationally reducible, then you could expect to be able to “jump ahead” and figure out what it would do, without following all the steps. But if it’s computationally irreducible, then you can’t expect to do that. It’s a classic <a href="https://www.wolframscience.com/nks/p754--undecidability-and-intractability/">halting problem</a> situation. And you have to conclude that the general problem of determining whether the machine will generate, say, output <em>j</em> is <a href="https://www.wolframscience.com/nks/notes-12-8--history-of-undecidability/">undecidable</a>. </p>
<p>Of course, in lots of particular cases (say, for lots of particular inputs) it may be easy enough to tell what’s going to happen, either just by running for some number of steps, or by using <a href="https://writings.stephenwolfram.com/2025/01/who-can-understand-the-proof-a-window-on-formalized-mathematics/">some kind of proof</a> or other abstract derivation. But the point is that—because of computational irreducibility—there’s no upper bound on the amount of computational effort that could be needed. And so the problem of “always getting an answer” has to be considered formally undecidable. </p>
<p>But what happens in practice? Let’s say we look at the behavior of all <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines when given the specific input 1. Running the machines for a million steps, we deduce a certain distribution of runtimes: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg1.png" alt="" title="" width="629" height="86"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg2.png" alt="" title="" width="235" height="84"/> </p>

<p>And we then conclude that a bit more than half the machines halt—with the largest finite runtime being the fairly modest 53, achieved by machine 630283 (essentially equivalent to 718804):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg3.png" alt="" title="" width="261" height="289"/> </p>

<p>But is this actually correct? Or do some of the machines we think don’t halt based on running for a million steps actually eventually halt—but only after more steps? </p>
<p>Here are a few examples of what happens:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg4.png" alt="" title="" width="584" height="183"/> </p>

<p>And, yes, in all these cases we can readily see that the machines will never halt—and instead, potentially after some transient, their heads just move essentially periodically forever. Here’s the distribution of periods one finds</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg5.png" alt="" title="" width="355" height="142"/> </p>

<p>with the longest-period cases being:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg6.png" alt="" title="" width="647" height="324"/> </p>

<p>And here’s the distribution of transients</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg7.png" alt="" title="" width="355" height="139"/> </p>

<p>with the longest-transient cases being: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg8.png" alt="" title="" width="656" height="324"/> </p>

<p>But this doesn’t quite account for all the machines that don’t halt after a million steps: there are still 1938 left over. There are 91 distinct patterns of growth—and here are samples of what happens: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg9.png" alt="" title="" width="491" height="562"/> </p>

<p>All of these eventually have a fundamentally nested structure. The patterns grow at different rates—but always in a regular succession of steps. Sometimes the spacings between these steps are polynomials, sometimes exponentials—implying either fractional power or logarithmic growth of the corresponding pattern. But the important point for our purposes here is that we can be confident that—at least with input 1—we know which <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines halt, and which do not. </p>
<p>But what happens if we increase the input value we provide? Here are the first 20 maximum finite lifetimes we get:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg10.png" alt="" title="" width="679" height="40"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg11.png" alt="" title="" width="357" height="95"/> </p>

<p>In the “peak case” of input 10, the distribution of runtimes is</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg12.png" alt="" title="" width="355" height="123"/> </p>

<p>with, yes, the maximum value being a somewhat strange outlier. </p>
<p>What is that outlier? It’s <a href="https://www.wolframscience.com/nks/p763--undecidability-and-intractability/">machine 600720</a> (along with the related machine 670559)—and we’ll be discussing it in more depth in the <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#machine-600720">next section</a>. But suffice it to say now that 600720 shows up repeatedly as the <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine with the longest runtimes. Is there a machine with a longer runtime? It’s hard to be absolutely certain. But at least for runtimes up to 10<sup>8</sup> and inputs up to 20 we can say that there definitely is not. And based on the distributions of runtimes we see—as well as comparisons with what we saw in the more manageable case of <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines—it seems likely that there are indeed no machines with longer runtimes, at least for small inputs. </p>
<p>What about for larger inputs? Well, things get wilder then. Like, for example, consider the case of machine 1955095. For all inputs up to 41, the machine halts after a modest number of steps:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg14.png" alt="" title="" width="657" height="410"/> </p>

<p>But then, at input 42, there’s suddenly a surprise—and the machine never halts:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg15.png" alt="" title="" width="668" height="248"/> </p>

<p>And, yes, we can immediately tell it never halts, because we can readily see that the same pattern of growth repeats periodically—every 24 steps. (A more extreme example is <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine 1227985, which halts for all inputs up to 150—then doesn’t halt for input 151.) </p>
<p>And, yes, things like this are the “long arm” of undecidability reaching in. But by successively investigating both larger inputs and longer runtimes, one can develop reasonable confidence that—at least most of the time—one is correctly identifying both cases that lead to halting, and ones that do not. And from this one can estimate that of all the 2,985,984 possible <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines, the number that always halt is 1,455,560 or thereabouts. (Uncertainties in this result come from the possibility of machines that either fail to halt only on inputs above 2 million, or halt on smaller inputs, but only after more than 100 million steps.) </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg16.png" alt="" title="" width="54" height="10"/> </p>

<p>Summarizing our results we find that—somewhat surprisingly—the <a href="https://www.wolframscience.com/nks/notes-10-3--algorithmic-information-theory/">halting fraction</a> is quite similar for different numbers of states, and always close to 1/2:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg17.png" alt="" title="" width="269" height="79"/> </p>

<p>And based on our census of halting machines, we can then conclude that the number of distinct total functions computed by <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines is 18,429:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026undecidabilityimg18.png" alt="" title="" width="202" height="40"/> </p>

<h2 id="machine-600720">Machine 600720</h2>
<p>In looking at the runtimes of <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> machines we noticed an outlier: a machine that can give exceptionally long runtimes. That machine is 600720 (along with the related machine 670559):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg1.png" alt="" title="" width="258" height="36"/> </p>

<p>I actually first noticed this machine in the 1990s as part of my work on <em><a href="https://www.wolframscience.com/nks/">A New Kind of Science</a></em><em>—</em>and with considerable effort was able to give a <a href="https://www.wolframscience.com/nks/notes-12-8--turing-machine-600720/">rather elaborate analysis</a> of at least some of its behavior:</p>

<p>The first remarkable thing about the machine is the dramatic peaks it exhibits in the output values it generates:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg3.png" alt="" title="" width="492" height="143"/> </p>

<p>These peaks are accompanied by corresponding (somewhat less dramatic) peaks in runtime:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg4.png" alt="" title="" width="498" height="146"/> </p>

<p>The first of the peaks shown here occurs at input <em>i</em> = 34—with runtime 315,391, and output <nobr>2<sup>1148</sup> – 1</nobr> (or about <nobr>4 × 10<sup>345</sup>).</nobr> What is the Turing machine doing underneath when it shows these peaks? It’s easier to see for the earlier peaks (and the later images here have been squashed to make their behavior more obvious)</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg7.png" alt="" title="" width="464" height="367"/> </p>

<p>but the basic point is that the machine seems to behave in a very “deliberate” way that one might imagine could be analyzed. </p>
<p>It turns out, though, that the analysis is surprisingly complicated. Here’s a table of maximum (worst-case) runtimes (and corresponding inputs and outputs):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg8.png" alt="" title="" width="657" height="82"/> </p>

<p>For odd <em>n</em> &gt; 3, the maximum runtime occurs when the input value <em>i</em> is:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg9.png" alt="" title="" width="89" height="33"/> </p>

<p>The corresponding initial states for the Turing machine are of the form:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machine-aimg1.png" alt="" title="" width="457" height="13"/> </p>

<p>The output value with such an input (for odd <em>n </em>&gt; 3) is then</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg11.png" alt="" title="" width="588" height="13"/> </p>

<p>while the runtime—derived effectively by “mathematicizing” what the Turing machine does for these inputs—is given by the bizarrely complex formula:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg12.png" alt="" title="" width="584" height="153"/> </p>

<p>What is the asymptotic behavior? It’s roughly 6<sup>α<em>n</em></sup> where α varies with <em>n</em> according to:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg14.png" alt="" title="" width="654" height="98"/> </p>

<p>So this is how long it can take the Turing machine to compute its output. But can we find that output faster, say just by finding a “mathematical formula” for it? For inputs <em>i</em> with some particular forms (like the one above) it is indeed possible to find such formulas:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg15.png" alt="" title="" width="108" height="14"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg16.png" alt="" title="" width="171" height="14"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg17.png" alt="" title="" width="133" height="14"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg18.png" alt="" title="" width="224" height="19"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026machineimg19.png" alt="" title="" width="235" height="38"/> </p>

<p>But in the vast majority of cases there doesn’t seem to be any simple mathematical-style formula. And indeed one can expect that this Turing machine is a typical computationally irreducible system: you can always find its output (here the value <em>f</em>[<em>i</em>]) by explicitly running the machine, but there’s no general way to shortcut this, and to systematically get to the answer by some reduced, shorter computation. </p>
<h2 id="runtimes-in-s3-k2-turing-machines">Runtimes in s = 3, k = 2 Turing Machines</h2>
<p>We discussed above that out of the 2.99 million possible <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> Turing machines, about 1.45 million always halt, and thus produce a definite output for any given input. But what are their runtimes, and how do these increase with the size of their input? Just as we saw for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 2</nobr> machines, there turn out to be only a limited number of distinct runtime “profiles”—here about 7000 of them. And if we ask about asymptotic behavior, the number of distinct possibilities is at most half this.</p>
<p>There are machines that give asymptotically constant runtime</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img1.png" alt="" title="" width="617" height="104"/> </p>

<p>with all odd asymptotic runtime values up to 21 (along with 25) being possible:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img2.png" alt="" title="" width="244" height="113"/> </p>

<p>Then there are machines that give asymptotically linear runtimes, with even coefficients from 2 to 20 (along with 24)—for example:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img3.png" alt="" title="" width="617" height="82"/> </p>

<p>By the way, note that (as we mentioned before) some machines realize their worst-case runtimes for many specific inputs, while in other machines such runtimes are rare (here illustrated for machines with asymptotic runtimes 24<em>n</em>):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img4.png" alt="" title="" width="618" height="80"/> </p>

<p>Sometimes there are machines whose worst-case runtimes increase linearly, but in effect with fractional slopes:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img5.png" alt="" title="" width="618" height="83"/> </p>

<p>There are many machines whose worst-case runtimes increase in an ultimately linear way—but with “oscillations”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img6.png" alt="" title="" width="519" height="95"/> </p>

<p>Averaging out the oscillations gives an overall growth rate of the form α<em>n</em>, where α is an integer or rational number with (as it turns out) denominator 2 or 3; the possible values for α are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img7.png" alt="" title="" width="574" height="48"/> </p>

<p>There are also machines with worst-case runtimes growing like α<em>n</em><sup>2</sup>, with α an integer from 1 to 10 (though missing 7): </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img9.png" alt="" title="" width="577" height="74"/> </p>

<p>And then there are a few machines (such as 129559 and 1166261) with cubic growth rates.</p>
<p>The next—and, in fact, single largest—group of machines have worst-case runtimes that asymptotically grow exponentially, following <a href="https://reference.wolfram.com/language/ref/LinearRecurrence.html">linear recurrences</a>. The possible asymptotic growth rates seem to be (ϕ is the golden ratio <span><img src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img10.png" width="82" height="23"/></span>):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img11.png" alt="" title="" width="161" height="25"/> </p>

<p>Some particular examples of machines with these growth rates include (we’ll see 5<sup><em>n</em>/2</sup> and 4<sup><em>n</em></sup> examples in the <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#functions-and-their-runtimes-in-s3-k2-turing-machines">next section</a>):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img14.png" alt="" title="" width="589" height="170"/> </p>

<p>The first of these is machine 1020827, and the exact worst-case runtime for input size <em>n</em> in this case is:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img15A.png" alt="" title="" width="250" height="29"/> </p>

<p>The second case shown (machine 117245) has exact worst-case runtime</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img16A.png" alt="" title="" width="250" height="29"/> </p>

<p>which satisfies the linear recurrence:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img17A.png" alt="" title="" width="221" height="20"/> </p>

<p>The third case (machine 1007039) has exact worst-case runtime:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img18A.png" alt="" title="" width="236" height="30"/> </p>

<p>It’s notable that in all of these cases, the maximum runtime for input size <em>n</em> occurs for input <nobr><em>i</em> = 2<sup><em>n</em></sup> – 1.</nobr> Here are the actual behaviors of the underlying machines (which all in the end turn out to just compute the identity function):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01302026s3k2img2.png" alt="" title="" width="672" height="348"/> </p>

<p>Continuing and squashing the results, it becomes clear that there’s a nested structure to these patterns:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img21.png" alt="" title="" width="170" height="245"/> </p>

<p>By the way, it’s certainly not necessary that the worst-case runtime must occur at the largest input of a given size. Here’s an example (machine 888388) where that’s not what happens</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img22.png" alt="" title="" width="357" height="96"/> </p>

<p>and where in the end the 2<sup><em>n</em>/2</sup> growth is achieved by having the same worst-case runtime for input sizes <em>n</em> and <em>n </em>+ 1 for all even <em>n</em>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2-aimg4.png" alt="" title="" width="62" height="18"/> </p>

<p>One feature of everything we’ve seen here is the runtimes we’ve deduced are either asymptotically powers or asymptotically exponentials. There’s nothing in between—for example nothing like <em>n</em><sup>Log[<em>n</em>]</sup> or 4<sup>Sqrt[<em>n</em>]</sup>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01272026s3k2img27.png" alt="" title="" width="347" height="161"/> </p>

<p>No doubt there are Turing machines with such <a href="https://www.wolframscience.com/nksonline/page-938c/">intermediate growth</a>, but apparently none with <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2.</nobr></p>
<h2 id="functions-and-their-runtimes-in-s3-k2-turing-machines">Functions and Their Runtimes in s = 3, k = 2 Turing Machines</h2>
<p>As we discussed above, out of the 2.99 million possible <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines, about 1.45 million always halt, and thus compute total functions. But what are these functions? In general, many machines can compute the same function. And in the end there seem to be about 18,000 distinct functions that <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines can compute. Ranking these functions by the number of machines that compute them, we get the following distribution: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg1.png" alt="" title="" width="597" height="122"/> </p>

<p>The functions computed by the most machines are (where, not surprisingly, the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr> is the overall winner):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg2.png" alt="" title="" width="692" height="191"/> </p>

<p>The minimum number of machines that can compute a given function is always 2—because there’s always one machine with a <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg3.png" width="34" height="9"/> transition, and another with a <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg4.png" width="34" height="9"/> transition, as in:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg5.png" alt="" title="" width="349" height="86"/> </p>

<p>But altogether there are about 13,000 of these “isolate” machines, where no other <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine can compute the same function they do. These functions can be thought of as representing computations that are computationally irreducible—at least for <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines.</p>
<p>So what are these functions—and how long do they take to compute? And remember, these are functions that are computed by isolate machines—so whatever the runtime of those machines is, this can be thought of as defining a lower bound on the runtime to compute that function, at least by any <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine. </p>
<p>So what are the functions with the longest runtimes computed by isolate machines? The overall winner seems to be the function computed by machine 600720 that we discussed above. </p>
<p>Next appears to come machine 589111</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg6.png" alt="" title="" width="646" height="259"/> </p>

<p>with its asymptotically 4<sup><em>n</em></sup> runtime:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg8.png" alt="" title="" width="619" height="121"/> </p>

<p>And although the values here, say for <nobr><em>i </em>= 95</nobr> and <nobr><em>i </em>= 191</nobr>, are huge (<nobr>≈10<sup>56</sup></nobr> and <nobr>≈10<sup>114</sup></nobr>), the corresponding absolute lower bounds for generating these values are respectively just 377 and 761, which are still dramatically smaller than the actual runtimes in these cases: 23,471 and 96,053.</p>
<p>Next appear to come machines like 599063</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg11.png" alt="" title="" width="686" height="219"/> </p>

<p>with asymptotic <nobr>5<sup><em>n</em>/2</sup> ≈ 2.25<sup><em>n</em></sup></nobr> runtime:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg14.png" alt="" title="" width="619" height="118"/> </p>

<p>Despite the seemingly somewhat regular pattern of values for this function, the machine that computes it is an isolate, so we know that at least among <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines, the function can’t be computed any faster.</p>
<p>What about the other machines with asymptotically exponential runtimes that we saw in the previous section? Well, the particular <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#runtimes-in-s3-k2-turing-machines">machines we used as examples there</a> aren’t even close to isolates. But there are other machines that have the same exponentially growing runtimes, and that are isolates. And, just for once, there’s a surprise.</p>
<p>For asymptotic runtime 2<sup><em>n</em></sup>, it turns out that there is just a single isolate machine: 1342057:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg16.png" alt="" title="" width="617" height="123"/> </p>

<p>But look at how simple the function this machine computes is. In fact, <nobr><em>f</em>[<em>i</em>] – <em>i</em></nobr> is just periodic, repeating with period 16 the block:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg17.png" alt="" title="" width="337" height="13"/> </p>

<p>But despite the simplicity of this, it still takes the Turing machine worst-case runtime <nobr><span><img src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg23.png" width="36" height="32"/></span> – 1</nobr> to compute it. The “most difficult” inputs are of the form 2<sup><em>n</em></sup> – 2, and here’s what the machine does in the first few of those cases:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg20.png" alt="" title="" width="392" height="427"/> </p>

<p>And, yes, after a transient at the beginning, all the machine is ultimately doing is to compute <nobr><em>i </em>+ 1</nobr>. But the point is that if one looks at the whole sequence of function values computed by the machine, there is simply no other <nobr><em>s</em> = 3, <em>k</em> = 2</nobr> Turing machine that can do the computation (well, apart from the immediately equivalent machine 2415947). So—despite its simplicity—we must conclude that this function is in effect irreducible for <nobr><em>s</em> = 3, <em>k</em> = 2</nobr> Turing machines, and is forced to a have worst-case runtime that is asymptotically 2<sup><em>n</em></sup>. </p>
<p>Going on to asymptotic runtimes of the form 3<sup><em>n</em>/2</sup>, it turns out there’s only one function for which there’s a machine (1007039) with this asymptotic runtime—and this function can be computed by over a hundred machines, many with faster runtimes, though some with slower (2<sup><em>n</em></sup>) runtimes (e.g. 879123).</p>
<p>What about asymptotic runtimes of order <span><img src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg24.png" width="16" height="16"/></span>? It’s more or less the same story as with 3<sup><em>n</em>/2</sup>. There are 48 functions which can be computed by machines with this worst-case runtime. But in all cases there are also many other machines, with many other runtimes, that compute the same functions.</p>
<p>But now there’s another surprise. For asymptotic runtime 2<sup><em>n</em>/2</sup> there are two functions computed only by isolate machines (889249 and 1073017):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg27.png" alt="" title="" width="617" height="119"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg28.png" alt="" title="" width="617" height="119"/> </p>

<p>So, once again, these functions have the feature that they can’t be computed any faster by any other <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machine.</p>
<p>When we looked at <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machines, we saw a machine—378—that has asymptotic worst-case runtime 2<sup><em>n</em></sup>. But the big difference from what we’re seeing now with <nobr><em>s</em> = 3, <em>k</em> = 2</nobr> machines is that <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine 378 is not an isolate. As it happens, what it computes is just the identity function <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr>. And while machine 378 takes exponential time to compute this function, there are lots of other <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines that compute the same function much faster, and indeed in constant time. </p>
<p>Among <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines, we found that there are no functions whose fastest runtimes grow more than quadratically with size. But now, for <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines, there are examples of functions whose fastest runtimes grow not polynomially but exponentially. </p>
<p>There are, of course, many more <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines than <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> ones. But it could be that with all those machines there would be sufficiently many that at least one of them would compute any given function quickly. In fact, however, what we see is that the number of distinct functions is large enough that there end up being many “isolate” machines that are the only ones (at least with <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>) that compute a given function. And when those machines have asymptotically exponential runtimes, they in effect define an (exponential) lower bound (among <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines) for the runtime of the functions they compute. </p>
<p>Isolate machines immediately define lower bounds on runtime for the functions they compute. But in general (as we saw above) there can be many machines that compute a given function. For example, as mentioned above, there are 210,792 <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines that compute the identity function. These machines have 102 distinct runtime profiles</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg30.png" alt="" title="" width="615" height="122"/> </p>

<p>with asymptotic runtimes ranging from constant to linear, quadratic and exponential. (The most rapidly increasing runtime is ~2<sup><em>n</em></sup>.)</p>
<p>For each function that can be computed, there’s a slightly different collection of runtime profiles; here are the ones for the functions computed by the next largest numbers of machines:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026functionsimg32.png" alt="" title="" width="578" height="217"/> </p>

<h2 id="can-bigger-machines-compute-functions-faster">Can Bigger Machines Compute Functions Faster?</h2>
<p>We saw above that there are functions which cannot be computed asymptotically faster than particular bounds by, say, any <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machine. But what if we consider larger Turing machines (say <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>)? Will there be a larger Turing machine which can compute a given function faster?</p>
<p>The first thing to say is that (as we <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#computing-the-same-functions-at-different-speeds">discussed before</a> for <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> vs. <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> machines) if a Turing machine of some size (say <nobr><em>s </em>= 2, <em>k </em>= 2</nobr>) computes a given function, then there must always be larger Turing machines (say <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>) that compute the same function. Indeed, there are usually many such machines. So, for example, among <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines, this is the distribution of how many of them compute each function computed by an <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine (the minimum of 304 is obtained for the function computed by <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine 2439):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg1.png" alt="" title="" width="357" height="138"/> </p>

<p>Among <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines we found that there are functions that cannot be computed asymptotically faster than quadratically by any such machine. An example is the function computed by machine 1511</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg2.png" alt="" title="" width="617" height="116"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg3.png" alt="" title="" width="559" height="194"/> </p>

<p>where the exact worst-case runtime is:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg4.png" alt="" title="" width="77" height="14"/> </p>

<p>But now we can ask whether this function can be computed faster by any <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine. It turns out that there are 352 such machines that compute this function. Of these, 342 have the exact same worst-case runtime, and none of the machines compute the functions asymptotically faster than quadratically. Still, there are 10 machines that manage to compute the function slightly faster, with runtime:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg5.png" alt="" title="" width="77" height="14"/> </p>

<p>An example is machine 1069163:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg6.png" alt="" title="" width="559" height="166"/> </p>

<p>We can think of what’s happening as being that we start from the <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> Turing machine rule</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg7.png" alt="" title="" width="164" height="34"/> </p>

<p>and in effect optimize this by using a slightly more complicated “instruction set”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg8.png" alt="" title="" width="249" height="35"/> </p>

<p>In looking at <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machines we found examples of functions that could be computed by such machines only with runtimes that asymptotically increase exponentially with input size. So now we can ask whether, if we go to <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> Turing machines, it become possible to compute those functions faster.</p>
<p>As an example, consider the function computed by the isolate machine 1342057:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg9.png" alt="" title="" width="617" height="119"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg10.png" alt="" title="" width="580" height="222"/> </p>

<p>This has asymptotic runtime 4<sup><em>n</em></sup>. But now if we look at <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> machines, then among the <nobr>16<sup>8</sup> = 4,294,967,296</nobr> such machines, one finds 2220 that compute this function. Of these, 1583 have the exact same worst-case runtime as the original <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine. And many others also have asymptotically exponential runtimes. But it turns out that there are other machines that have much faster runtimes. For example, machine 1517414255 asymptotically has a constant worst-case runtime of just 7:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg13.png" alt="" title="" width="629" height="98"/> </p>

<p>There are also machines with linearly and quadratically increasing runtimes—though, confusingly, for the first few input sizes, they seem to be increasing just as fast as our original <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg14.png" alt="" title="" width="498" height="74"/> </p>

<p>Here are the underlying rules for these particular Turing machines:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg15.png" alt="" title="" width="228" height="142"/> </p>

<p>And here’s the full spectrum of runtime profiles achieved by <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> machines for our function: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg16.png" alt="" title="" width="615" height="122"/> </p>

<p>There are runtimes that are easy to recognize as exponentials—though with bases like 2,<span><img src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg17.png" width="22" height="21"/></span>, 3/2, <span><img src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg18.png" width="22" height="20"/></span> that are smaller than 4. Then there are linear and polynomial runtimes of the kind we just saw. And there’s some slightly exotic “oscillatory” behavior, like with machine 1418699063</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg19.png" alt="" title="" width="292" height="80"/> </p>

<p>that seems to settle down to a periodic sequence of ratios, growing asymptotically like 2<sup><em>n</em>/4</sup>.</p>
<p>What about other functions that are difficult to compute by <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines? Quite often it turns out to be a somewhat different story. For example, for the function computed by <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine 600720, there are 1602 <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> machines that also compute it. But unlike in the case we just saw, there aren’t a whole collection of runtime profiles: instead there are just two:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01212026biggerimg21.png" alt="" title="" width="429" height="79"/> </p>

<p>One of these follows exactly the runtimes of 600720; the other is not the same, but is very close, with about half the runtimes being the same, and the other half having maximal differences that grow linearly with <em>n</em>. </p>
<p>And what this means is that—unlike the function computed by <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine 1342057, the function computed by <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine 600720 can’t be computed any faster by any <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> machine than by an <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine. In other words, going to a larger machine (at least <nobr><em>s </em>= 4</nobr>) doesn’t help in the computation of this function.</p>
<p>Looking at other functions that are “hard to compute” with <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines, one sometimes finds that they become easier to compute if one uses <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> machines, but often they do not.</p>
<h2 id="with-a-sufficiently-large-turing-machine">With a Sufficiently Large Turing Machine…</h2>
<p>We’ve been talking so far about very small Turing machines—with at most a handful of distinct cases in their rules. But what if we consider much larger Turing machines? Would these allow us to systematically do computations much faster?</p>
<p>Given a particular (finite) mapping from input to output values, say</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026sufficientlyimg1.png" alt="" title="" width="112" height="40"/> </p>

<p>it’s quite straightforward to construct a Turing machine</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01292026sufficientlyimg1.png" alt="" title="" width="596" height="80"/> </p>

<p>whose state transitions in effect just “immediately look up” these values:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026sufficientlyimg3.png" alt="" title="" width="461" height="139"/> </p>

<p>(If we try to compute a value that hasn’t been defined, the Turing machine will simply not halt.)</p>
<p>If we stay with a fixed value of <em>k</em>, then for a “function lookup table” of size <em>v</em>, the number of states we need for a “direct representation” of the lookup table is directly proportional to <em>v</em>. Meanwhile, the runtime is just equal to the absolute lower bound we discussed above, which is linearly proportional to the sizes of input and output. </p>
<p>Of course, with this setup, as we increase <em>v</em> we increase the size of the Turing machine. And we can’t guarantee to encode a function defined, say, for all integers, with anything less than an infinite Turing machine. </p>
<p>But by the time we’re dealing with an infinite Turing machine we don’t really need to be computing anything; we can just be looking everything up. And indeed computation theory always in effect assumes that we’re limiting the size of our machines. And as soon as we do this, there starts to be all sorts of richness in questions like which functions are computable, and what runtime is required to compute them. </p>
<p>In the past, we might just have assumed that there is some arbitrary bound on the size of Turing machines, or, in effect, a bound on their “<a href="https://www.wolframscience.com/nks/notes-10-3--algorithmic-information-theory/">algorithmic information content</a>” or “program size”. But the point of what we’re doing here is to explore what happens not with arbitrary bounds, but with bounds that are small enough to allow us to do exhaustive empirical investigations.</p>
<p>In other words, we’re restricting ourselves to low algorithmic (or program) complexity and</p>
<h2 id="beyond-binary-turing-machines">Beyond Binary Turing Machines</h2>
<p>In everything we’ve done so far, we’ve been looking at “binary” (i.e. <nobr><em>k </em>= 2)</nobr> Turing machines that have only values 0 and 1 on their tapes. But what if we consider more possible values—say “ternary” (i.e. <nobr><em>k </em>= 3)</nobr> Turing machines, with values 0, 1 and 2 on their tapes?</p>
<p>The setup we’ve been using translates immediately:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg1.png" alt="" title="" width="212" height="30"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg2.png" alt="" title="" width="635" height="117"/> </p>

<p>The simplest case is <nobr><em>s </em>= 1,</nobr> <nobr><em>k </em>= 3—yielding</nobr> <nobr>6<sup>3</sup> = 216</nobr> possible machines: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg4.png" alt="" title="" width="669" height="341"/> </p>

<p>Of these machines, 88 always halt—and compute 77 distinct functions. The possible runtimes are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01302026beyond-cimg1.png" alt="" title="" width="564" height="53"/> </p>

<p>And unlike what we saw even for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 2,</nobr> there are now “isolate” machines whose worst-case runtime grows quadratically—the largest runtime being achieved by machine 29:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg6.png" alt="" title="" width="113" height="32"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg7.png" alt="" title="" width="600" height="163"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg8.png" alt="" title="" width="617" height="116"/> </p>

<p>For <em>s </em>= 2, <em>k </em>= 3, we have <nobr>12<sup>6</sup> = 2,985,984</nobr> possible machines—the same number as for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2.</nobr> And indeed the behavior we see is similar to what we saw for <em>s </em>= 3, <em>k </em>= 2. With input 1, the number of machines that halt after 1 and 3 steps is actually identical in the two cases (1492992 and 373248, respectively). The fraction of machines that ever halt is similar, though not identical: 68.2% for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> and 67.6% for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3.</nobr> The longest “finite lifetime” for input 1 is 53 for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> and 83 for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3:</nobr></p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg10.png" alt="" title="" width="308" height="439"/> </p>

<p>In both cases, of the machines that don’t halt, the vast majority become periodic. For <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2,</nobr> the largest period (starting from input 1) is 35; for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3,</nobr> it is 50:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg11.png" alt="" title="" width="526" height="324"/> </p>

<p>Just as for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2,</nobr> there are some <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> machines that don’t become periodic, though (at least with input 1) all yield nested patterns, with some examples being</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg12.png" alt="" title="" width="596" height="308"/> </p>

<p>or in squashed form:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg13.png" alt="" title="" width="595" height="220"/> </p>

<p>If we look beyond input 1, we find that about 1.12 million <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> machines always halt (compared to 1.45 million for <em>s </em>= 3, <em>k </em>= 2), But if we ask how many distinct functions these machines compute, the result is around 173,000—nearly ten times as many as for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> machines. Why is this? This shows the distribution of the number of <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> machines computing a given function:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg14.png" alt="" title="" width="578" height="116"/> </p>

<p>A notable feature is that the tail consists of functions computed by only one machine. In the <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> case, symmetry between transitions to <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg20.png" alt="" title="" width="9" height="6"/> and <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg21.png" alt="" title="" width="9" height="6"/> means that there are always at least two machines computing a given function. But with <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> this “degeneracy” is broken, leading to a larger number of distinct functions. </p>
<p>What about runtimes? The results for <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> seem to be generally similar to those for <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2,</nobr> though a bit wilder. The fastest growing runtimes seem to asymptotically grow like 9<sup><em>n</em></sup>, an example being machine 840971, whose worst-case runtimes for successive input sizes are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg23.png" alt="" title="" width="330" height="13"/> </p>

<p>In a sense it should not be surprising that there is so much similarity between the behavior of <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> Turing machines and <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> ones. After all, the total number of possible machines of each kind is the same, as is the number of underlying cases in their rules. </p>
<p>However, if we look not at the kind of “one-sided” (or “halt if you go to the right”) Turing machines we are considering here, but instead at Turing machines where the head can go freely in either direction, then one difference emerges. Starting with a blank tape, all <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> machines eventually behave in readily predictable ways. But—as I discovered in <em>A New Kind of Science</em>—<a href="https://www.wolframscience.com/nks/p709--universality-in-turing-machines-and-other-systems/">the <nobr><em>s </em>= 2,</nobr> <nobr><em>k </em>= 3</nobr> machine 596440 does not</a>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg24.png" alt="" title="" width="228" height="32"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg25.png" alt="" title="" width="641" height="232"/> </p>

<p>And this fact provides a clue that such a machine (or, actually, the 14 essentially equivalent machines of which this is one example) might be capable of universal computation. And indeed <a href="https://www.wolframscience.com/prizes/tm23/">it can be shown that</a>—at least with appropriate (infinite) initial conditions, the machine can successfully be “programmed” to emulate systems that are known to be universal, thereby proving that it itself is universal.</p>
<p>How does this machine fare with our one-sided setup? Here’s what it does with the first few inputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01302026beyond-dimg1.png" alt="" title="" width="620" height="89"/> </p>

<p>And what one finds is that for any input, the head of the machine eventually goes to the right, so with our one-sided setup we consider the machine to halt:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg27.png" alt="" title="" width="617" height="121"/> </p>

<p>It turns out that the worst-case runtime for input of size <em>n</em> grows according to:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg28.png" alt="" title="" width="55" height="11"/> </p>

<p>But if we look at the function computed by this machine we can ask whether there are ways to compute it faster. And it turns out there are 11 other <em>s </em>= 2, <em>k </em>= 3 machines (though, for example, no <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> ones) that compute the exact same function. If we look at their behavior from a blank tape</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg29.png" alt="" title="" width="648" height="76"/> </p>

<p>one might think they would be simple enough to have shorter runtimes. But in fact in the one-sided setup their behavior is basically identical to our original machine.</p>
<p>OK, but what about <nobr><em>s </em>= 3,</nobr> <nobr><em>k </em>= 2</nobr> machines? Probably their higher symmetry makes them not “reveal their computational capabilities” if they are started from a blank tape. But one can expect that with more complicated initial conditions, they may do more complicated things. Still, at least with “input 1” (i.e. a single 1 on an otherwise blank tape) there are nested behaviors like these, but nothing more: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026beyondimg30.png" alt="" title="" width="650" height="265"/> </p>

<h2 id="recognizable-functions">Recognizable Functions</h2>
<p>We’ve been talking a lot about how fast Turing machines can compute functions. But what can we say about what functions they compute? With appropriate encoding of inputs and decoding of outputs, we know that (essentially by definition) any computable function can be computed by some Turing machine. But what about the simple Turing machines we’ve been using here? And what about “without encodings”? </p>
<p>The way we’ve set things up, we’re taking both the input and the output to our Turing machines to be the sequences of values on their tapes—and we’re interpreting these values as digits of integers. So that means we can think of our Turing machines as defining functions from integers to integers. But what functions are they? </p>
<p>Here are two <nobr><em>s</em> = 2, <em>k</em> = 2</nobr> Turing machines that <a href="https://www.wolframscience.com/nks/p760--undecidability-and-
intractability/">compute the function <nobr><em>f</em>[<em>i</em>] = <em>i</em> + 1</nobr></a>—complete with the appropriate long-range carry, say for input 7:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg1.png" alt="" title="" width="636" height="155"/> </p>

<p>There are a total of 17 <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines that do this computation. (There are no <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> machines, and 8934 <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines.) There are no <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machines that compute <nobr><em>f</em>[<em>i</em>] = <em>i </em>+ <em>a</em></nobr> for <nobr><em>a</em> &gt; 1</nobr>—but there are 14 <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines that compute <nobr><em>f</em>[<em>i</em>] = <em>i </em>+ 2</nobr>, examples being:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg2.png" alt="" title="" width="636" height="182"/> </p>

<p>Still, for <nobr><em>a</em> &gt; 2</nobr>, there are again no <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines that compute <nobr><em>f</em>[<em>i</em>] = <em>i </em>+ <em>a</em></nobr>.</p>
<p>If we restrict ourselves to even inputs, then we can compute <nobr><em>f</em>[<em>i</em>] = <em>i </em>+ 2</nobr> even with an <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg3.png" alt="" title="" width="640" height="86"/> </p>

<p>Similarly, there are <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>, machines that for even inputs compute <nobr><em>f</em>[<em>i</em>] = <em>i </em>+ <em>a</em></nobr> up to <nobr><em>a </em>= 4</nobr>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg4.png" alt="" title="" width="640" height="208"/> </p>

<p>What about other “mathematically simple” functions, say <nobr><em>f</em>[<em>i</em>] = 2<em>i</em> or <em>f</em>[<em>i</em>] = <em>i</em><sup>2</sup></nobr>? At least up to <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> there are no machines that, for example, compute these particular functions. And in general there seems to be something of a disconnect between what’s simple mathematically, and what’s simple in a Turing machine. It’s bit like what happens with mathematical operations and digit sequences of numbers: except in rare cases, <a href="https://www.wolframscience.com/nks/chap-4--systems-based-on-numbers#sect-4-5--mathematical-constants">simple mathematical operations don’t lead to simple patterns in digit sequences</a>. </p>
<p>We’ve already seen a variety of examples where our Turing machines can be interpreted as evaluating <a href="https://reference.wolfram.com/language/guide/BitwiseOperations.html">bitwise functions</a> of their inputs. A more minimal case would be something like a single bitflip—and indeed there is an <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine that can compute a flip of the “last digit” on its tape:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg6.png" alt="" title="" width="631" height="49"/> </p>

<p>To be able to flip a higher-order digit, one needs a Turing machine with more states. There are two <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines that flip the second-to-last digit:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg7.png" alt="" title="" width="615" height="61"/> </p>

<p>And in general—as these pictures suggest—flipping the <em>m</em><sup>th</sup> bit can be done with a Turing machine with at least <nobr><em>m </em>+ 1</nobr> possible states for its head. </p>
<p>What about Turing machines that compute periodic functions? Strict (nontrivial) periodicity seems difficult to achieve. But here, for example, is an <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine (actually, the unique one) that computes <nobr><em>f</em>[<em>i</em>] = <em>i</em> + <tt>Mod</tt><tt>[</tt><em>i</em>, 2<tt>]</tt></nobr>: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg9.png" alt="" title="" width="664" height="75"/> </p>

<p>With both <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> and <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>, there are no machines that compute <nobr><em>f</em>[<em>i</em>] = <em>i</em> + <tt>Mod[</tt><em>i</em>, 3<tt>]</tt></nobr>. But with <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> there are 4 machines that compute <nobr><em>f</em>[<em>i</em>] = <em>i</em> + <tt>Mod[</tt><em>i</em>, 4<tt>]</tt></nobr>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026recognizableimg10.png" alt="" title="" width="664" height="89"/> </p>

<p>Another thing one might ask is whether one Turing machine can emulate another. And indeed that’s what we see happening—very directly—whenever one Turing machine computes the same function as another. </p>
<p>(We also know that there exist universal Turing machines—the <a href="https://www.wolframscience.com/prizes/tm23/">simplest having <nobr><em>s </em>= 2, <em>k </em>= 3</nobr></a>—that can ultimately emulate any other Turing machines. But in general such emulation will not be as direct as what we’re studying here; instead it’ll involve potentially very complex encoding of input and output.)</p>
<h2 id="empirical-computational-irreducibility">Empirical Computational Irreducibility</h2>
<p><a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence#sect-12-6--computational-irreducibility">Computational irreducibility</a> has been central to much of the science I’ve done in the past four decades or so. And indeed it’s guided our intuition in much of what we’ve been exploring here. But the things we’ve discussed now also allow us to take an empirical look at the core phenomenon of computational irreducibility itself. </p>
<p>Computational irreducibility is ultimately about the idea that there can be computations where in effect there is no shortcut: there is no way to systematically find their results except by running each of their steps. In other words, given an irreducible computation, there’s basically no way to come up with another computation that gives the same result, but in fewer steps. Needless to say, if one wants to tighten up this intuitive idea, there are lots of detailed issues to consider. For example, what about just using a computational system that has “bigger primitives”? Like many other foundational concepts in theoretical science, it’s difficult to pin down exactly how one should set things up—so that one doesn’t either implicitly assume what one’s trying to explain, or so restrict things that everything becomes essentially trivial.</p>
<p>But using what we’ve done here, we can explore a definite—if restricted—version of computational irreducibility in a very explicit way. Imagine we’re computing a function using a Turing machine. What would it mean to say that that function—and the underlying behavior of the Turing machine that computes it—is computationally irreducible? Essentially it’s that there’s no other faster way to compute that function.</p>
<p>But if we restrict ourselves to computation by a certain size of Turing machine, that’s exactly what we’ve studied at great length here. And, for example, whenever we have what we’ve called an “isolate” Turing machine, we know that no other Turing machine of the same size can compute the same function. So that means one can say that the function is computationally irreducible with respect to Turing machines of the given size. </p>
<p>How robust is such a notion? We’ve seen examples above where a given function can be computed, say, only in exponential time by an <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> Turing machine, but in linear time by an <nobr><em>s </em>= 4, <em>k </em>= 2</nobr> Turing machine. But the expectation is that as we increase the size of machines—and thus the number of possible machines—there will end up being more and more functions where no significant speedup can be achieved by having a larger machine. And such functions we can then think of as being in effect “absolutely computationally irreducible”.</p>
<p>But the important point here is that we can already see a restricted version of computational irreducibility just by looking explicitly at Turing machines of a given size. And this allows us to get concrete results about computational irreducibility, or at least about this restricted version of it. </p>
<p>One of the remarkable discoveries in looking at lots of kinds of systems over the years has been just how common the phenomenon of computational irreducibility seems to be. But usually we haven’t had a way to rigorously say that we’re seeing computational irreducibility in any particular case. All we typically know is that we can’t “visually decode” what’s going on, nor can particular methods we try. (And, yes, the fact that a wide variety of different methods <a href="https://www.wolframscience.com/nks/chap-10--processes-of-perception-and-analysis#sect-10-5--data-compression">almost always agree about what’s “compressible”</a> and what’s not encourages our conclusions about the presence of computational irreducibility.)</p>
<p>In looking at Turing machines here, we’re often seeing “visual complexity”, not so much in the detailed—often ponderous—behavior with a particular initial condition, but more, for example, in what we get by plotting function values against inputs. But now we have a more rigorous—if restricted—test for computational irreducibility: we can ask whether the function that’s being computed is irreducible with respect to this size of Turing machine, or, typically equivalently, whether the Turing machine we’re looking at is an isolate. </p>
<p>So now we can, for example, explore how common irreducibility defined in this way might be. Here are results for some of the classes of small Turing machines we’ve studied above:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026irreducibilityimg1.png" alt="" title="" width="495" height="105"/> </p>

<p>And what we see is that—much like our impression from computational systems like cellular automata—computational irreducibility is indeed very common among small Turing machines, where now we’re using our rigorous, if restricted, notion of computational irreducibility. </p>
<p>(It’s worth commenting that while “global” features of Turing machines—like the functions they compute—may be computationally irreducible, there can still be lots of computational reducibility in their more detailed properties. And indeed what we’ve seen here is that there are plenty of features of the behavior of Turing machines—like the back-and-forth motion of their heads—that look visually simple, and that we can expect to compute in dramatically faster ways than just running the Turing machine itself.) </p>
<h2 id="nondeterministic-multiway-turing-machines">Nondeterministic (Multiway) Turing Machines</h2>
<p>So far, we’ve made a fairly extensive study of ordinary, deterministic (“single-way”) Turing machines. But the P vs. NP question is about comparing the capabilities of such deterministic Turing machines with the capabilities of nondeterministic—or multiway—Turing machines. </p>
<p>An ordinary (deterministic) Turing machine has a rule such as</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg1.png" alt="" title="" width="154" height="32"/> </p>

<p>that specifies a unique sequence of successive configurations for the Turing machine</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg2.png" alt="" title="" width="69" height="115"/> </p>

<p>which we can represent as:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg3.png" alt="" title="" width="86" height="235"/> </p>

<p>A <a href="https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/" target="_blank" rel="noopener">multiway Turing machine</a>, on the other hand, can have multiple rules, such as</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg4.png" alt="" title="" width="336" height="32"/> </p>

<p>which are applied in all possible ways to generate a whole multiway graph of successive configurations for the Turing machine</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg5.png" alt="" title="" width="431" height="287"/> </p>

<p>where we have indicated edges in the multiway graph associated with the application of each rule respectively by <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg8.png" alt="" title="" width="13" height="3"/> and <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg9.png" alt="" title="" width="13" height="3"/>, and where identical Turing machine configurations are merged. </p>
<p>Just as we have done for ordinary (deterministic) Turing machines, we take multiway Turing machines to reach a halting configuration whenever the head goes further to the right than it started—though now this may happen on multiple branches—so that the Turing machine in effect can generate multiple outputs.</p>
<p>With the way we have set things up, we can think of an ordinary (deterministic) Turing machine as taking an input <em>i</em> and giving as output some value <em>f</em>[<em>i</em>] (where that value might be undefined if the Turing machine doesn’t halt for a given <em>i</em>). In direct analogy, we can think of a multiway Turing machine as taking an input <em>i</em> and giving potentially a whole collection of corresponding outputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg10.png" alt="" title="" width="522" height="196"/> </p>

<p>Among the immediate complications is the fact that the machine may not halt, at least on some branches—as happens for input 3 here, indicated by a red dot in the plot above: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg11.png" alt="" title="" width="240" height="303"/> </p>

<p>(In addition, we see that there can be multiple paths that lead to a given output, in effect defining multiple runtimes for that output. There can also be cycles, but in defining “runtimes” we ignore these.)</p>
<p>When we construct a multiway graph we are effectively setting up a representation for all possible paths in the evolution of a (multiway) system. But when we talk about nondeterministic evolution we are typically imagining that just a single path is going to be followed, but we don’t know which. </p>
<p>Let’s say that we have a multiway Turing machine that for every given input generates a certain set of outputs. If we were to pick just one of the outputs from each of these sets, we would effectively in each case be picking one path in the multiway Turing machine. Or, in other words, we would be “doing a nondeterministic computation”, or in effect getting output from a nondeterministic Turing machine.</p>
<p>As an example, let’s take our multiway Turing machine <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach#:~:text=A%20multiway%20Turing%20machine%2C%20on%20the%20other%20hand%2C%20can%20have%20multiple%20rules%2C%20such%20as">from above</a>. Here is an example of how this machine—thought of as a nondeterministic Turing machine—can generate a certain sequence of output values:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg12.png" alt="" title="" width="548" height="204"/> </p>

<p>Each of these output values is achieved by following a certain path in the multiway graph obtained with each input: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg13.png" alt="" title="" width="648" height="201"/> </p>

<p>Keeping only the path taken (and including the underlying Turing machine configuration) this represents how each output value was “derived”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg14.png" alt="" title="" width="459" height="213"/> </p>

<p>The length of the path can then be thought of as the runtime required for the nondeterministic Turing machine to reach the output value. (When there are multiple paths to a given output value, we’ll typically consider “the runtime” to be the length of the shortest of these paths.) So now we can summarize the runtimes from our example as follows:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg15A.png" alt="" title="" width="402" height="143"/> </p>

<p>The core of the P vs. NP problem is to compare the runtime for a particular function obtained by deterministic and nondeterministic Turing machines. </p>
<p>So, for example, given a deterministic Turing machine that computes a certain function, we can ask whether there is a nondeterministic Turing machine which—if you picked the right branch—can compute that same function, but faster. </p>
<p>In the case of the example above, there are two possible underlying Turing machine rules indicated by <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg16.png" alt="" title="" width="13" height="3"/> and <img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg17.png" alt="" title="" width="13" height="3"/>. For each input we can choose at each step a different rule to apply in order to get to the output: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026nondeterministicimg18.png" alt="" title="" width="149" height="191"/> </p>

<p>The possibility of using different rules at different steps in effect allows much more freedom in how our computation can be done. The P vs. NP question concerns whether this freedom allows one to fundamentally speed up the computation of a given function.</p>
<p>But before we explore that question further, let’s take a look at what multiway (nondeterministic) Turing machines typically do; in other words, let’s study their ruliology. </p>
<h2 id="multiway-nondeterministic-s1-k2-turing-machines">Multiway (Nondeterministic) s = 1, k = 2 Turing Machines</h2>
<p>As our first example of doing <a href="https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/" target="_blank" rel="noopener">ruliology for multiway Turing machines</a>, let’s consider the case of pairs of <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> Turing machine rules. There are 16 individual such rules, and therefore <nobr>16 × (16 – 1) = 120</nobr> (orderless) pairs. Here are the functions computed by all these multiway Turing machines:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg1.png" alt="" title="" width="691" height="450"/> </p>

<p>Sometimes, as in machine {1,9}, there turns out to be a unique output value for every input:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg2.png" alt="" title="" width="357" height="141"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01292026multiwayimg1.png" alt="" title="" width="556" height="265"/> </p>

<p>Sometimes, as in machine {5,9}, there is usually a unique value, but sometimes not:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg4.png" alt="" title="" width="350" height="138"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg5.png" alt="" title="" width="464" height="216"/> </p>

<p>Something similar happens with {3,7}:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg6.png" alt="" title="" width="350" height="138"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg7.png" alt="" title="" width="444" height="261"/> </p>

<p>There are cases—like {1,3}—where for some inputs there’s a “burst” of possible outputs:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg8.png" alt="" title="" width="357" height="141"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg9.png" alt="" title="" width="672" height="250"/> </p>

<p>There are also plenty of cases where for some inputs</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg10.png" alt="" title="" width="351" height="139"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg11.png" alt="" title="" width="620" height="421"/> </p>

<p>or for all inputs, there are branches that do not halt:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg12.png" alt="" title="" width="357" height="141"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg13.png" alt="" title="" width="599" height="203"/> </p>

<p>What about runtimes? Well, for each possible output in a nondeterministic Turing machine, we can see how many steps it takes to reach that output on any branch of the multiway graph, and we can consider that minimum number to be the “nondeterministic runtime” needed to compute that output. </p>
<p>It’s the quintessential setup for NP computations: if you can successfully guess what branch to follow, you can potentially get to an answer quickly. But if you have to explicitly check each branch in turn, that can be a slow process. </p>
<p>Here’s an example showing possible outputs and possible runtimes for a sequence of inputs for the {3,7} nondeterministic machine</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg14.png" alt="" title="" width="617" height="123"/> </p>

<p>or, combined in 3D:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg15.png" alt="" title="" width="307" height="174"/> </p>

<p>So what functions can a nondeterministic machine like this “nondeterministically” generate? For each input we have to pick one of the possible corresponding (“multiway”) outputs. And in effect the possible functions correspond to possible “threadings” through these values</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg16.png" alt="" title="" width="321" height="129"/> </p>

<p>or:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg17.png" alt="" title="" width="588" height="108"/> </p>

<p>To each function one can then associate a “nondeterministic runtime” for each output, here:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026multiwayimg18.png" alt="" title="" width="588" height="108"/> </p>

<h2 id="nondeterministic-vs-deterministic-machines">Nondeterministic vs. Deterministic Machines</h2>
<p>We’ve seen how a nondeterministic machine can in general generate multiple functions, with each output from the function being associated with a minimum (“nondeterministic”) runtime. But how do the functions that a particular nondeterministic machine can generate compare with the functions that deterministic machines can generate? Or, put another way, given a function that a nondeterministic machine can generate (or “compute”), what deterministic machine is required to compute the same function?</p>
<p>Let’s look at the <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> {3,7} machine we discussed above. Here are three cases of functions it can generate:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg1.png" alt="" title="" width="555" height="68"/> </p>

<p>Can we find a deterministic <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> machine that will reproduce any of these functions? For the first one shown, the answer, rather trivially, is yes. Because this function is what we get by always following the “machine 3” (<img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg2.png" width="13" height="3"/>) branch in the multiway system</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg3.png" alt="" title="" width="668" height="261"/> </p>

<p>so that it inevitably gives the same results as deterministic machine 3. </p>
<p>But (apart from the other trivial case based on following “machine 7” branches) none of the other functions we can generate from this nondeterministic machine can be reproduced by any <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> deterministic machines.</p>
<p>What about <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> deterministic machines? Well, there we have a bit more luck. Because there turn out to be a couple of nontrivial choices in our {3,7} nondeterministic machine that lead to functions that can be reproduced by deterministic (<nobr><em>s </em>= 2, <em>k </em>= 2</nobr>) Turing machines. Here’s an example of a function that can be generated by the {3,7} nondeterministic machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg4.png" alt="" title="" width="401" height="155"/> </p>

<p>And here are the paths through the multiway graphs for that machine that get to these values</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg5.png" alt="" title="" width="618" height="243"/> </p>

<p>with the “paths on their own” being</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg6.png" alt="" title="" width="616" height="130"/> </p>

<p>yielding “nondeterministic runtimes”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg7.png" alt="" title="" width="249" height="110"/> </p>

<p>This is how the deterministic <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine 2253 reproduces the sequence of values for this function:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg8.png" alt="" title="" width="490" height="102"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg9.png" alt="" title="" width="586" height="47"/> </p>

<p>Here are the pair of underlying rules for the nondeterministic machine</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg10.png" alt="" title="" width="190" height="37"/> </p>

<p>and here is the deterministic machine that reproduces a particular function it can generate:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg11.png" alt="" title="" width="162" height="34"/> </p>

<p>This example is rather simple, and has the feature that even the deterministic machine always has a very small runtime. But now the question we can ask is whether a function that takes a deterministic machine of a certain class a certain time to compute can be computed in a smaller time if its results are “picked out of” a nondeterministic machine. </p>
<p>We saw above that <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine 1511 computes its output with a runtime that increases quadratically with input size—and we also saw that no other (deterministic) <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine computes the same output faster. And the same is basically also true for <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines (though 6 machines, of which 1069163 is an example, do manage to compute the output not in <nobr>1 + 4<em>n</em> + 2<em>n</em><sup>2</sup></nobr> steps, but in the slightly faster <nobr>1 + 2<em>n</em>+ 2<em>n</em><sup>2</sup></nobr> steps).</p>
<p>But what about a nondeterministic machine? How fast can this be?</p>
<p>It turns out that there are 15 nondeterministic machines based on pairs of <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> rules that can successfully reproduce the function computed by the <nobr><em>s </em>= 2, <em>k </em>= 2</nobr> machine 1511. Here is an example from the {0,3} nondeterministic machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg14.png" alt="" title="" width="565" height="208"/> </p>

<p>Here are the paths within the multiway graph for the nondeterministic machine that are sampled to generate the deterministic Turing machine result:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg15.png" alt="" title="" width="511" height="300"/> </p>

<p>And here are these “paths on their own”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg16.png" alt="" title="" width="686" height="341"/> </p>

<p>We can compare these with the computations needed in the deterministic machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg17.png" alt="" title="" width="601" height="179"/> </p>

<p>With our rendering, the lengths of the nondeterministic paths might look longer. But in fact they are considerably shorter, as we see by plotting them (in orange) along with the deterministic runtimes (in gray):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg18.png" alt="" title="" width="617" height="169"/> </p>

<p>Looking now at the worst-case runtimes for inputs of size <em>n</em>, we get:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg19.png" alt="" title="" width="302" height="99"/> </p>

<p>For the deterministic machine we found above for input size <em>n</em>, this worst-case runtime is given by:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg20.png" alt="" title="" width="77" height="14"/> </p>

<p>But now the runtime in the nondeterministic machine turns out to be:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg21.png" alt="" title="" width="39" height="11"/> </p>

<p>In other words, we’re seeing that nondeterminism makes it substantially faster to compute this particular function—at least by small Turing machines. </p>
<p>In a deterministic machine, it’s always the same underlying rule that’s applied at each step. But in a nondeterministic machine with the setup we’re using, we’re independently choosing one of two different rules to apply at each step. The result is that for every function value we compute, we’re making a sequence of choices:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg22.png" alt="" title="" width="603" height="191"/> </p>

<p>And the core question that underlies things like the P vs. NP problem is how much advantage the freedom to make these choices conveys—and whether, for example, it allows us to “nondeterministically” compute in polynomial time what takes more than polynomial (say, exponential) time to compute deterministically.</p>
<p>As a first example, let’s look at the function computed by the <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> deterministic machine 1342057. We found above that this machine is an isolate, that takes worst-case runtime  <nobr><span><img src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg23.png" width="36" height="32"/></span> – 1</nobr> to compute the (admittedly rather simple) function it computes. So what happens with nondeterministic machines? </p>
<p>Well, it turns out that the <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> nondeterministic machine {0,7} can (nondeterministically) compute the same function: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg24.png" alt="" title="" width="459" height="174"/> </p>

<p>And indeed, while the deterministic machine takes exponentially increasing runtime, the nondeterministic machine has a runtime that quickly approaches the fixed constant value of 5:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg25.png" alt="" title="" width="420" height="130"/> </p>

<p>But is this somehow trivial? As the plot above suggests, the nondeterministic machine (at least eventually) generates all possible odd output values (and for even input <em>i</em>, also generates <nobr><em>f</em>[<em>i</em>] = <em>i</em></nobr>). But if we look at the whole multiway graph, we see that it can take a while for the nondeterministic machine to generate any particular output value:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg26.png" alt="" title="" width="674" height="223"/> </p>

<p>What makes the runtime end up being constant, however, is that in this particular case, the output <em>f</em>[<em>i</em>] is always close to <em>i</em> (in fact, <nobr>|<em>f</em>[<em>i</em>] – <em>i</em>| ≤ 5</nobr>).</p>
<p>There are actually no fewer than <nobr>9 <em>s </em>= 1, <em>k </em>= 2</nobr> nondeterministic machines that can nondeterministically compute the same function. All of them work essentially the same way, generating (at least for odd <em>i</em>) all possible outputs—with runtime at most 9.</p>
<p>And while all of them are in a sense straightforward in their operation, they illustrate the point that even when a function requires exponential time for a deterministic Turing machine, it can require much less time for a nondeterministic machine—and even a nondeterministic machine that has a much smaller rule. </p>
<p>What about other cases of functions that require exponential time for deterministic machines? The functions computed by the <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> deterministic machines with the most rapid runtime growth—600720 and 589111—can’t be computed by any nondeterministic machine based on pairs of <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> machines. But functions computed by other deterministic machines with runtime ~2<sup><em>n</em></sup> can also be computed in constant time by nondeterministic machines. </p>
<p>Something slightly different happens with <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machine 889249. This machine has asymptotic runtime 2<sup><em>n</em>/2</sup>. The function it computes can also be computed by an <nobr><em>s </em>= 1, <em>k </em>= 2</nobr> nondeterministic machine, but now that machine computes the function not in constant time, but instead with asymptotic runtime <nobr>2<em>n </em>+ 1</nobr> (and, yes, for <nobr><em>i </em>= 1</nobr> the nondeterministic machine is actually slower, taking 5 steps instead of 1):</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg29.png" alt="" title="" width="414" height="126"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026vsimg30.png" alt="" title="" width="685" height="156"/> </p>

<h2 id="the-limit-of-nondeterminism-and-the-ruliad">The Limit of Nondeterminism and the Ruliad</h2>
<p>A deterministic Turing machine has a single, definite rule that’s applied at each step. In the previous sections we’ve explored what’s in a sense a minimal case of nondeterminism in Turing machines—where we allow not just one, but two different possible rules to be applied at each step. But what if we increase the nondeterminism—say by allowing more possible rules at each step? </p>
<p>We’ve seen that there’s a big difference between determinism—with one rule—and even our minimal case of nondeterminism, with two rules. But if we add in, say, a third rule, it doesn’t seem to typically make any qualitative difference. So what about the limiting case of <a href="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/" target="_blank" rel="noopener">adding in all conceivable rules</a>?</p>
<p>We can think of what we get as an “everything machine”—a machine that has every possible rule case for any possible Turing machine, say for <nobr><em>s </em>= 1, <em>k </em>= 2</nobr>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg1.png" alt="" title="" width="370" height="32"/> </p>

<p>Running this “everything machine” for one step starting with input 1 we get:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg2.png" alt="" title="" width="315" height="285"/> </p>

<p>Four of the rule cases just lead back to the initial state. Then of the other four, two lead to halting states, and two do not. Dropping self-loops, going another couple of steps, and using a different graph rendering, we see that outputs 2 and 3 now appear:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg3.png" alt="" title="" width="548" height="211"/> </p>

<p>Here are the results for input 2:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg4.png" alt="" title="" width="560" height="166"/> </p>

<p>So where can the “everything machine” reach, and how long does it take? The answer is that from any input <em>i</em> it can eventually reach absolutely any output value <em>j</em>. The minimum number of steps required (i.e. the minimum path length in the multiway graph) is just the absolute lower bound that <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#absolute-lower-bounds-and-the-efficiency-of-machines">we found for runtimes in deterministic machines above</a>: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg5.png" alt="" title="" width="315" height="14"/> </p>

<p>Starting with input 1, the nondeterministic runtime to reach output <em>j</em> is then</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg6.png" alt="" title="" width="176" height="14"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg7.png" alt="" title="" width="305" height="103"/> </p>

<p>which grows logarithmically with output value, or linearly with output size. </p>
<p>So what this means is that the “everything machine” lets one nondeterministically go from a given input to a given output in the absolutely minimum number of steps structurally possible. In other words, with enough nondeterminism every function becomes nondeterministically “easy to compute”.</p>
<p>An important feature of the “everything machine” is that we can think of it as being a <a href="https://writings.stephenwolfram.com/2021/11/the-concept-of-the-ruliad/">fragment of the ruliad</a>. The full ruliad—which appears at the foundations of physics, mathematics and much more—is the entangled limit of all possible computations. There are many possible bases for the ruliad; Turing machines are one. In the full ruliad, we’d have to consider all possible Turing machines, with all possible sizes. The “everything machine” we’ve been discussing here gives us just part of that, corresponding to all possible Turing machine rules with a specific number of states and colors. </p>
<p>In representing all possible computations, the ruliad—like the “everything machine”—is maximally nondeterministic, so that it in effect includes all possible computational paths. But when we apply the ruliad in science (and even mathematics) we are interested not so much in its overall form as in particular slices of it which are sampled by <a href="https://writings.stephenwolfram.com/2023/12/observer-theory/">observers that, like us, are computationally bounded</a>. And indeed in the past few years it’s become clear that there’s a lot to say about the foundations of many fields by thinking in this way.</p>
<p>And one feature of computationally bounded observers is that they’re not maximally nondeterministic. Instead of following all possible paths in the multiway system, they tend to follow specific paths or bundles of paths—for example reflecting the <a href="https://writings.stephenwolfram.com/2025/05/what-if-we-had-bigger-brains-imagining-minds-beyond-ours/">single thread of experience</a> that characterizes our human perception of things. So—when it comes to observers—the “everything machine” is somehow too nondeterministic. An actual (computationally bounded) observer will be concerned with one or just a few “threads of history”. In other words, if we’re interested in slices of the ruliad that observers will sample, what will be relevant is not so much the “everything machine” but rather deterministic machines, or at most machines with the kind of limited nondeterminism that we’ve studied the past few sections. </p>
<p>But just how does what the “everything machine” can do compare with what all possible deterministic machines can do? In some ways, this is a core question in the comparison between determinism and nondeterminism. And it’s straightforward to start studying it empirically.</p>
<p>For example, here are successive steps in the multiway graph for the (<nobr><em>s </em>= 1, <em>k </em>= 2</nobr>) “everything machine”, with <a href="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/#the-space-of-deterministic-turing-machine-computations" target="_blank" rel="noopener">the path associated with each possible deterministic (<nobr><em>s </em>= 1, <em>k </em>= 2</nobr>) machine highlighted</a>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg8.png" alt="" title="" width="553" height="224"/> </p>

<p>In a sense these pictures illustrate the “reach” of deterministic vs. nondeterministic computation. In this particular case, with <nobr><em>s </em>= 1, <em>k </em>= 2</nobr>, the only values that can ever be reached by deterministic machines from input 1 are 0, 1 and 3—even though nondeterministically the “everything machine” can reach every possible integer. </p>
<p>For <nobr><em>s </em>= 2, <em>k </em>= 2</nobr>, we get</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg9.png" alt="" title="" width="553" height="224"/> </p>

<p>and the values that can be reached by deterministic machines are:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg10.png" alt="" title="" width="170" height="13"/> </p>

<p>But how long does it take to reach these values? This shows as dots the possible (deterministic) runtimes; the filling represents the minimum (nondeterministic) runtimes for the “everything machine”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg11.png" alt="" title="" width="319" height="130"/> </p>

<p>The most dramatic outlier occurs with value 31, which is reached deterministically only by machine 1447, in 15 steps, but which can be reached in 9 (nondeterministic) steps by the “everything machine”:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg12.png" alt="" title="" width="90" height="181"/> </p>

<p>For <nobr><em>s </em>= 3, <em>k </em>= 2</nobr>, the divergence between deterministic and nondeterministic cases increases:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg13.png" alt="" title="" width="413" height="160"/> </p>

<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2026/01/sw01282026limitimg14.png" alt="" title="" width="675" height="55"/> </p>

<h2 id="what-does-it-all-mean-for-p-vs-np">What Does It All Mean for P vs. NP?</h2>
<p>The P vs. NP question asks whether every computation that can be done by any nondeterministic Turing machine with a runtime that increases at most polynomially with input size can also be done by some deterministic Turing machine with a runtime that also increases at most polynomially. Or, put more informally, it asks whether introducing nondeterminism can fundamentally speed up computation. </p>
<p>In its full form, this is an infinite question, that talks about limiting behavior over all possible inputs, in all possible Turing machines. But within this infinite question, there are definite, finite subquestions we can ask. And one of the things we’ve done here is in effect to explore some of these questions in an explicit, ruliological way. Looking at these finite subquestions won’t in any direct way be able to resolve the full P vs. NP question.</p>
<p>But it can give us important intuition about the P vs. NP question, and what some of the difficulties and subtleties involved in it are. When one analyzes specific, <a href="https://www.wolframscience.com/nks/notes-12-8--classes-of-fast-algorithms/">constructed algorithms</a>, it’s common to see that their runtimes vary quite smoothly with input size. But one of the things we’ve seen here is that for arbitrary Turing machines “in the wild”, it’s very typical for the runtimes to jump around in complicated ways. It’s also not uncommon to see dramatic outliers that occur only for very specific inputs. </p>
<p>If there was just one outlier, then in the limit of arbitrarily large input size it would eventually become irrelevant. But what if there were an unending sequence of outliers, of unpredictable sizes at unpredictable positions? Ultimately we expect all sorts of computational irreducibility, which in the limit can make it infinitely difficult to determine in any particular case the limiting behavior of the runtime—and, for example, to find out if it’s growing like a polynomial or not. </p>
<p>One might imagine, though, that if one looked at enough inputs, enough Turing machines, etc. then somehow any wildness would get in some way averaged out. But our ruliological results don’t encourage that idea. And indeed they tend to show that “there’s always more wildness”, and it’s somehow ubiquitous. One might have imagined that computational irreducibility—or undecidability—would be sufficiently rare that it wouldn’t affect investigations of “global” questions like the P vs. NP one. But our results suggest that, to the contrary, there are all sorts of complicated details and “exceptions” that seem to get in the way of general conclusions. </p>
<p>Indeed, there seem to be issues at every turn. Some are related to unexpected behavior and outliers in runtimes. Some are related to the question of whether a particular machine ever even halts at all for certain inputs. And yet others are related to taking limits of sizes of inputs versus sizes of Turing machines, or amounts of nondeterminism. What our ruliological explorations have shown is that such issues are not obscure corner cases; rather they are generic and ubiquitous.</p>
<p>One has the impression, though, that they are more pronounced in deterministic than in nondeterministic machines. Nondeterministic machines in some sense “aggregate” over paths, and in doing so, wash out the “computational coincidences” which seem ubiquitous in determining the behavior of deterministic machines. </p>
<p>Certainly the specific experiments we’ve done on machines of limited size do seem to support the idea that there are indeed computations that can be done quickly by a nondeterministic machine, but for which in deterministic machines there are for example at least occasional large runtime outliers, which imply longer general runtimes.</p>
<p>I had always suspected that the P vs. NP question would ultimately get ensnared in issues of computational irreducibility and undecidability. But from our explicit ruliological explorations we get an explicit sense of how this can happen. Will it nevertheless ultimately be possible to resolve the P vs. NP question with a finite mathematical-style proof based, say, on standard mathematical axioms? The results here make me doubt it. </p>
<p>Yes, it will be possible to get at least certain restricted global results—in effect by “mining” pockets of computational reducibility. And, as we already know from what we have seen repeatedly here, it’s also possible to get definite results for, say, specific (ultimately finite) classes of Turing machines. </p>
<p>I’ve only scratched the surface here of the ruliological results that can be found. In some cases to find more just requires expending more computer time. In other cases, though, we can expect that new methodologies, particularly around “bulk” automated theorem proving, will be needed. </p>
<p>But what we’ve seen here already makes it clear that there is much to be learned by ruliological methods about questions of theoretical computer science—P vs. NP among them. In effect, we’re seeing that theoretical computer science can be done not only “purely theoretically”—say with methods from traditional mathematics—but also “empirically”, finding results and developing intuition by doing explicit computational experiments and enumerations. </p>
<hr/>
<h2 id="some-personal-notes">Some Personal Notes</h2>
<p>My efforts on what I now call ruliology <a href="https://www.wolframscience.com/nks/chap-1--the-foundations-for-a-new-kind-of-science#sect-1-4--the-personal-story-of-the-science-in-this-book">started at the beginning of the 1980s</a>, and in the early years I almost exclusively <a href="https://www.wolframscience.com/nks/p23--how-do-simple-programs-behave/">studied cellular automata</a>. A large part of the reason was just that these were the first types of simple programs I’d investigated, and in them I had made a series of discoveries. I was certainly aware of Turing machines, but viewed them as less connected than cellular automata to <a href="https://www.wolframscience.com/nks/p1--an-outline-of-basic-ideas/">my goal of studying actual systems in nature and elsewhere</a>—though ultimately theoretically equivalent. </p>
<p>It wasn’t until 1991, when I started systematically studying different types of simple programs as I embarked on my book <em><a href="https://www.wolframscience.com/nks/">A New Kind of Science</a></em> that I actually began to do <a href="https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs#sect-3-4--turing-machines">simulations of Turing machines</a>. (Despite their widespread use in theoretical science for more than half a century, I think <a href="https://www.wolframscience.com/nks/notes-3-4--history-of-turing-machines/">almost nobody</a> else—<a href="https://writings.stephenwolfram.com/2012/06/happy-100th-birthday-alan-turing/">from Alan Turing on</a>—had ever actually simulated them either.) At first I wasn’t particularly enamored of Turing machines. They seemed a little less elegant than <a href="https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs#sect-3-3--mobile-automata">mobile automata</a>, and had much less propensity to show interesting and complex behavior than cellular automata. </p>
<p>Towards the end of the 1990s, though, I was working to connect my discoveries in what became <em>A New Kind of Science</em> to existing results in theoretical computer science—and Turing machines emerged as a useful bridge. In particular, as part of the <a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence/">final chapter of <em>A New Kind of Science</em>—“The Principle of Computational Equivalence”</a>—I had a <a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence#sect-12-8--undecidability-and-intractability">section entitled “Undecidability and Intractability”</a>. And in that section I <a href="https://www.wolframscience.com/nks/p761--undecidability-and-intractability/">used Turing machines</a> as a way to explore the relation of my results to existing results on computational complexity theory.</p>
<p>And it was in the process of that effort that I invented the kind of one-sided Turing machines I’ve used here:</p>
<p><a data-url="https://www.wolframscience.com/nks/p759--undecidability-and-intractability/" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg1.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg1.png" width="547" height="349"/></a></p>
<p>I <a href="https://www.wolframscience.com/nks/notes-12-8--one-sided-turing-machines/">concentrated on the <em>s </em>= 2, <em>k </em>= 2 machines</a> (for some reason I never looked at <em>s </em>= 1, <em>k </em>= 2), and found classes of machines that compute the same function—sometimes at different speeds: </p>
<p><img src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg2.png" alt="Page 761 of the book A New Kind of Science showing examples of computations being done by Turing machines with two states and two colors" title="Page 761 of the book A New Kind of Science showing examples of computations being done by Turing machines with two states and two colors" width="531" height="699"/></p>
<p>And even though the computers <a href="https://www.wolframscience.com/nks/notes-0-1--computer-experiments/">I was using at the time</a> were much slower than the ones I use today, I <a href="https://www.wolframscience.com/nks/p762--undecidability-and-intractability/">managed to extend what I was doing to <em>s </em>= 3, <em>k </em>= 2</a>. At every turn, though, I came face to face with computational irreducibility and undecidability. I tried quite hard do things like resolve the exact number of distinct functions for <nobr><em>s </em>= 3, <em>k </em>= 2</nobr> machines, but in the end didn’t succeed and just gave an “approximate” number:</p>
<p><a alt="" title="" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg3.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg3.png" width="547" height="187"/></a></p>
<p>Nearly three decades later, I think I <a href="https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/#s3-k2-turing-machines-and-the-problem-of-undecidability">finally have the exact number</a>. (Note that some of the details from <em>A New Kind of Science</em> are also different from what I have here, because in <em>A New Kind of Science</em> I included partial functions in my enumeration; here I’m mostly insisting on total functions, that halt and give a definite result for all inputs.) </p>
<p>After <em>A New Kind of Science</em> was released in 2002, I made another foray into Turing machines in 2007, <a href="https://writings.stephenwolfram.com/2007/05/today-we-put-a-prize-on-a-small-turing-machine/">putting up a prize on the fifth anniversary of the book</a> for a proof (or refutation) of my <a href="https://www.wolframscience.com/nks/p709--universality-in-turing-machines-and-other-systems/">suspicion that <em>s </em>= 2, <em>k </em>= 3 machine 596440 was capable of universal computation</a>. The <a href="https://writings.stephenwolfram.com/2007/10/the-prize-is-won-the-simplest-universal-turing-machine-is-proved/">prize was soon won</a>, establishing this machine as the very simplest universal Turing machine: </p>
<p><a alt="" title="" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg4.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg4.png" width="413" height="477"/></a></p>
<p>Many years passed. I occasionally suggested projects on Turing machines to students at the <a href="https://education.wolfram.com/summer-school">summer research program</a> we started in 2003 (more on that later…). And I participated in <a href="https://writings.stephenwolfram.com/2012/06/happy-100th-birthday-alan-turing/">celebrations of Alan Turing’s centenary in 2012</a>. Then in 2020 we <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/">announced the Wolfram Physics Project</a>—and I looked at Turing machines again, now as an <a href="https://www.wolframphysics.org/technical-introduction/equivalence-and-computation-in-our-models/correspondence-with-other-systems/#p-381" target="_blank" rel="noopener">example of a computational system that could be encoded with hypergraph rewriting</a>, and studied using physics-inspired causal graphs, etc.:</p>
<p><a data-url="https://www.wolframphysics.org/technical-introduction/equivalence-and-computation-in-our-models/correspondence-with-other-systems/#p-381" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg5.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg5.png" width="615" height="435"/></a></p>
<p>Less than two months after the launch of our Physics Project I was studying what I now call the ruliad—and I decided to <a href="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/" target="_blank" rel="noopener">use Turing machines as a model for it</a>: </p>
<p><a data-url="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg6.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg6.png" width="427" height="400"/></a></p>
<p>A crucial part of this was the idea of multiway Turing machines:</p>
<p><a data-url="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg7.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg7.png" width="432" height="321"/></a></p>
<p>I’d <a href="https://www.wolframscience.com/nks/chap-5--two-dimensions-and-beyond#sect-5-6--multiway-systems">introduced multiway systems</a> in <em>A New Kind of Science</em>, and had examples close to multiway Turing machines in the book. But now multiway Turing machines were more central to what I was doing—and in fact I started studying essentially what I’ve here called the “everything machine” (though the details were different, because I wasn’t considering Turing machines that can halt):</p>
<p><a alt="" title="" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg8.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg8.png" width="432" height="348"/></a></p>
<p>I also started looking at the comparison between what can be reached deterministically and nondeterministically—and <a href="https://bulletins.wolframphysics.org/2020/06/exploring-rulial-space-the-case-of-turing-machines/#deterministic-turing-machine-paths-in-rulial-space" target="_blank" rel="noopener">discussed the potential relation of this to the P vs. NP question</a>: </p>
<p><a alt="" title="" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg9.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg9.png" width="432" height="492"/></a></p>
<p>By the next year, I was <a href="https://writings.stephenwolfram.com/2021/09/multicomputation-a-fourth-paradigm-for-theoretical-science/">expanding my study of multiway systems</a>, and exploring many different examples—with one of them being <a href="https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/" target="_blank" rel="noopener">multiway Turing machines</a>:</p>
<p><a data-url="https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/" href="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg10.png"><img loading="lazy" alt="Click to enlarge" title="Click to enlarge" src="https://content.wolfram.com/sites/43/2026/01/sw01232026notesimg10.png" width="427" height="455"/></a></p>
<p>Soon I realized that the general approach I was taking could be applied not only to the foundations of physics, but also to <a href="https://writings.stephenwolfram.com/2021/09/multicomputation-a-fourth-paradigm-for-theoretical-science/#potential-application-areas">foundations of other fields</a>. I studied the <a href="https://writings.stephenwolfram.com/2022/03/the-physicalization-of-metamathematics-and-its-implications-for-the-foundations-of-mathematics/">foundations of mathematics</a>, of <a href="https://writings.stephenwolfram.com/2023/02/computational-foundations-for-the-second-law-of-thermodynamics/">thermodynamics</a>, of <a href="https://writings.stephenwolfram.com/2024/08/whats-really-going-on-in-machine-learning-some-minimal-models/">machine learning</a> and of <a href="https://writings.stephenwolfram.com/2024/05/why-does-biological-evolution-work-a-minimal-model-for-biological-evolution-and-other-adaptive-processes/">biology</a>. But what about the foundations of theoretical computer science? </p>
<p>Over the years, I’d explored the ruliology of many kinds of systems studied in theoretical computer science—doing deep dives into <a href="https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/">combinators for their centenary in 2020</a>, as well as <a href="https://writings.stephenwolfram.com/2025/09/the-ruliology-of-lambdas/">(last year) into lambdas</a>. In all these investigations, I was constantly seeing concrete versions of phenomena discussed in theoretical computer science—even though my emphasis tended to be different. But I was always curious what one might be able to say about central questions in theoretical computer science—like P vs. NP. </p>
<p>I had imagined that the principal problem in doing an empirical investigation of something like P vs. NP would just be to enumerate enough cases. But when I got into it, I realized that the shadow of computational irreducibility loomed even larger than I’d imagined—and that even within particular cases it could be irreducibly difficult to figure out what one needed to know about their behavior.</p>
<p>Fairly late in the project I was trying to look up some “conventional wisdom” about NP problems. Most of it was couched in rather traditional mathematical terms, and didn’t seem likely to have too much to say about what I was doing. But then I found a paper entitled “<a href="http://www.joostjjoosten.nl/papers/SlowDownTMNew.pdf" target="_blank" rel="noopener">Program-size versus Time Complexity: Slowdown and Speed-up Phenomena in the Micro-cosmos of Small Turing Machines</a>”—and I was excited to see that it was following up on what I’d done in <em>A New Kind of Science</em>, and doing ruliology. But then I realized: the lead author of the paper, Joost Joosten, had been an (already-a-professor) <a href="https://education.wolfram.com/summer-school/alumni/2009/joosten/">student at our summer program in 2009</a>, and I’d in fact suggested the original version of the project (though the paper had taken it further, and in some slightly different directions than I’d anticipated). </p>
<p>Needless to say, what I’ve now done here raises a host of new questions, which can now be addressed by future projects done at our summer programs, and beyond….</p>
<p><em>Note</em>: For general historical background see my related writings from <a href="https://www.wolframscience.com/nks/notes-12-8--p-versus-np-questions/">2002</a> and <a href=" https://bulletins.wolframphysics.org/2021/02/multiway-turing-machines/#notes" target="_blank" rel="noopener">2021</a>.</p>
<h2 id="thanks">Thanks</h2>
<p>Thanks to Willem Nielsen, Nik Murzin and Brian Mboya of the <a href="https://wolframinstitute.org/" target="_blank" rel="noopener">Wolfram Institute</a> for extensive help. Thanks also to Wolfram Institute affiliate Anneline Daggelinckx, as well as to Richard Assar and Pavel Hajek of the Wolfram Institute for additional help. Work at the Wolfram Institute on this project was <a href="https://www.templeton.org/grant/causality-observers-and-computation-a-new-approach-to-fundamental-physics-and-metamathematics" target="_blank" rel="noopener">supported in part by the John Templeton Foundation</a>.</p>
<p>Additional input on the project was provided by Lenore &amp; Manuel Blum, Christopher Gilbert, Josh Grochow, Don Knuth and Michael Sun. Matthew Szudzik also <a href="https://www.wolframscience.com/nks/pxii--preface/">contributed relevant work</a> in 1999 <a href="https://writings.stephenwolfram.com/2022/05/the-making-of-a-new-kind-of-science/">during the development</a> of <em>A New Kind of Science</em>.</p>
        </div></div>
  </body>
</html>
