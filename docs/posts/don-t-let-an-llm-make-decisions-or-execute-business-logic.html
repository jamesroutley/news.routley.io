<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sgnt.ai/p/hell-out-of-llms/">Original</a>
    <h1>Don’t let an LLM make decisions or execute business logic</h1>
    
    <div id="readability-page-1" class="page"><div> <figure>
  <img src="https://sgnt.ai/hell.jpeg" alt="Get out of there"/>
</figure>
<p>Don’t let an LLM make decisions or execute business logic: they suck at that. I build NPCs for an online game, and I get asked a lot “How did you get ChatGPT to do that?” The answer is invariably: “I didn’t, and also you shouldn’t”.</p>
<p>In most applications, the LLM should be the user-interface only between the user and an API into your application logic. The LLM shouldn’t be executing any logic. Get the hell out of the LLM as soon as possible, and stay out as long as you can.</p>
<h2 id="y-tho">Y Tho?</h2>
<p>This is best illustrated by a contrived example: you want to write a chess-playing bot you access over WhatsApp. The user sends a description of what they want to do (“use my bishop to take the knight”), and the bot plays against them.</p>
<p>Could you get the LLM to be in charge of maintaining the state of the chess board and playing convincingly? <a href="https://dynomight.net/chess/">Possibly, maybe</a>. Would you? Hell no, for some intuitive reasons:</p>
<ul>
<li><strong>Performance</strong>: It’s impressive that LLMs might be able to play chess at all, but they suck at it (as of 2025-04-01). A specialized chess engine is always going to be a faster, better, cheaper chess player. Even modern chess engines like Stockfish that incorporate neural networks are still purpose-built specialized systems with well-defined inputs and evaluation functions - not general-purpose language models trying to maintain game state through text.</li>
<li><strong>Debugging and adjusting</strong>: It’s impossible to reason about and debug <em>why</em> the LLM made a given decision, which means it’s very hard to change <em>how</em> it makes those decisions if you need to tweak them. You don’t understand the journey it took through the high-dimensional semantic space to get to your answer, and it’s really poor at explaining it too. Even purpose-built neural networks like those in chess engines can be challenging for observability, and a general LLM is a nightmare, despite Anthropic’s <a href="https://www.anthropic.com/research/tracing-thoughts-language-model">great strides in this area</a></li>
<li><strong>And the rest…</strong>: testing LLM outputs is much harder than unit-testing known code-paths; LLMs are much worse at math than your CPU; LLMs are insufficiently good at picking random numbers; version-control and auditing becomes much harder; monitoring and observability gets painful; state management through natural language is fragile; you’re at the mercy of API rate limits and costs; and security boundaries become fuzzy when everything flows through prompts.</li>
</ul>
<h2 id="examples"><strong>Examples</strong></h2>
<p>The chess example illustrates the fundamental problem with using LLMs for core application logic, but this principle extends far beyond games. In any domain where precision, reliability, and efficiency matter, you should follow the same approach:</p>
<ol>
<li>The user says they want to attack player X with their vorpal sword? The LLM shouldn’t be the system figuring out is the user has a vorpal sword, or what the results of that would be: the LLM is responsible for translating the free-text the user gave you into an API call <em>only</em> and translating the result into text for the user</li>
<li>You’re building a negotiation agent that should respond to user offers? The LLM isn’t in charge of the negotiation, just in charge of packaging it up, passing it off to the negotiating engine, and telling the user about the result</li>
<li>You need to make a random choice about how to respond to the user? The LLM doesn’t get to choose</li>
</ol>
<h2 id="reminder-of-what-llms-are-good-at"><strong>Reminder of what LLMs are good at</strong></h2>
<p>While I’ve focused on what LLMs shouldn’t do, it’s equally important to understand their strengths so you can leverage them appropriately:</p>
<p>LLMs excel at transformation and at categorization, and have a pretty good grounding in “how the world works”, and this is where you in your process you should be deploying them.</p>
<p>The LLM is good at taking “hit the orc with my sword” and turning it into <code>attack(target=&#34;orc&#34;, weapon=&#34;sword&#34;)</code>. Or taking <code>{&#34;error&#34;: &#34;insufficient_funds&#34;}</code> and turning it into “You don’t have enough gold for that.”</p>
<p>The LLM is good at figuring out what the hell the user is trying to do and routing it to the right part of your system. Is this a combat command? An inventory check? A request for help?</p>
<p>Finally, the LLM is good at knowing about human concepts, and knowing that a “blade” is probably a sword and “smash” probably means attack.</p>
<p>Notice that all these strengths involve transformation, interpretation, or communication—not complex decision-making or maintaining critical application state. By restricting LLMs to these roles, you get their benefits without the pitfalls described earlier.</p>
<h2 id="the-future"><strong>The future</strong></h2>
<p>What LLMs can and can’t do is ever-shifting and reminds me of the “<a href="https://en.wikipedia.org/wiki/God_of_the_gaps">God of the gaps</a>”. a term from theology where each mysterious phenomenon was once explained by divine intervention—until science filled that gap. Likewise, people constantly identify new “human-only” tasks to claim that LLMs aren’t truly intelligent or capable. Then, just a few months later, a new model emerges that handles those tasks just fine, forcing everyone to move the goalposts again, examples <em>passim</em>. It’s a constantly evolving target, and what seems out of reach today may be solved sooner than we expect.</p>
<p>And so like in our chess example, we will probably soon end up with LLMs that can handle all of our above examples reasonably well. I suspect however that most of the drawbacks won’t go away: your non-LLM logic that you pass off to is going to be easier to reason about, easier to maintain, cheaper to run, and more easily version-controlled.</p>
<p>Even as LLMs continue to improve, the fundamental architectural principle remains: use LLMs for what they’re best at—the interface layer—and rely on purpose-built systems for your core logic.</p> </div></div>
  </body>
</html>
