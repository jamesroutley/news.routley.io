<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/habedi/hann">Original</a>
    <h1>Hann: A Fast Approximate Nearest Neighbor Search Library for Go</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto">
<themed-picture data-catalyst-inline="true"><picture>
    <img alt="Hiking Gopher" src="https://github.com/habedi/hann/raw/main/logo.svg" height="30%" width="30%"/>
</picture></themed-picture>
</div>
<hr/>
<p dir="auto">Hann is a high-performance approximate nearest neighbor search (ANN) library for Go.
It provides a collection of index data structures for efficient similarity search in high-dimensional spaces.
Currently, supported indexes include Hierarchical Navigable Small World (HNSW),
Product Quantization Inverted File (PQIVF), and Random Projection Tree (RPT).</p>
<p dir="auto">Hann can be seen as a core component of a vector database (like Milvus, Pinecone, Weaviate, Qdrant, etc.).
It can be used to add fast in-memory similarity search capabilities to your Go applications.</p>

<ul dir="auto">
<li>Unified interface for different indexes (see <a href="https://github.com/habedi/hann/blob/main/core/index.go">core/index.go</a>)</li>
<li>Support for indexing and searching vectors of arbitrary dimension</li>
<li>Fast distance computation using SIMD (AVX) instructions (see <a href="https://github.com/habedi/hann/blob/main/core/simd_distance.c">core/simd_distance.c</a>)</li>
<li>Support for bulk insertion, deletion, and update of vectors</li>
<li>Support for saving indexes to disk and loading them back</li>
</ul>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Index Name</th>
<th>Space Complexity</th>
<th>Build Complexity</th>
<th>Search Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://arxiv.org/abs/1603.09320" rel="nofollow">HNSW</a></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(nd + nM)$</math-renderer></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(n\log n)$</math-renderer></td>
<td>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(\log n)$</math-renderer> average case</td>
</tr>
<tr>
<td><a href="https://ieeexplore.ieee.org/document/5432202" rel="nofollow">PQIVF</a></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(nk + kd)$</math-renderer></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(nki)$</math-renderer></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(\frac{n}{k})$</math-renderer></td>
</tr>
<tr>
<td><a href="https://dl.acm.org/doi/10.1145/1374376.1374452" rel="nofollow">RPT</a></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(nd)$</math-renderer></td>
<td><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(n\log n)$</math-renderer></td>
<td>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$O(\log n)$</math-renderer> average case</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<ul dir="auto">
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$n$</math-renderer>: number of vectors</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$d$</math-renderer>: number of dimensions (vector length)</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$M$</math-renderer>: links per node (HNSW)</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$k$</math-renderer>: number of clusters (PQIVF)</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="13e1ef3394dde34a4c81156fad33bfda">$i$</math-renderer>: iterations for clustering (PQIVF)</li>
</ul>

<p dir="auto">The HNSW index supports the use of Euclidean, squared Euclidean, Manhattan, and cosine distances.
If cosine distance is used, the vectors are normalized on read (before they are used in the index or for search).
Note that squared Euclidean distance is slightly faster to compute than Euclidean distance
and gives the same order of closest vectors as Euclidean distance.
It can be used in place of Euclidean distance if only the order of closest vectors to
query vector is needed, not the actual distances.</p>
<p dir="auto">The PQIVF and RPT indexes support Euclidean distance only.</p>

<p dir="auto">Hann can be installed as a typical Go module using the following command:</p>
<div dir="auto" data-snippet-clipboard-copy-content="go get github.com/habedi/hann@main"><pre>go get github.com/habedi/hann@main</pre></div>
<p dir="auto">Hann requires Go 1.21 or later, a C (or C++) compiler, and a CPU that supports AVX instructions.</p>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Example File</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/simple_hnsw.go">simple_hnsw.go</a></td>
<td>Create and use an HNSW index with inline data</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/hnsw.go">hnsw.go</a></td>
<td>Create and use an HNSW index</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/hnsw_large.go">hnsw_large.go</a></td>
<td>Create and use an HNSW index (using large datasets)</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/pqivf.go">pqivf.go</a></td>
<td>Create and use a PQIVF index</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/pqivf_large.go">pqivf_large.go</a></td>
<td>Create and use a PQIVF index (using large datasets)</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/rpt.go">rpt.go</a></td>
<td>Create and use an RPT index</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/cmd/rpt_large.go">rpt_large.go</a></td>
<td>Create and use an RPT index (using large datasets)</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/load_data.go">load_data.go</a></td>
<td>Helper functions for loading example datasets</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/utils.go">utils.go</a></td>
<td>Extra helper functions for the examples</td>
</tr>
<tr>
<td><a href="https://github.com/habedi/hann/blob/main/example/run_dataset.go">run_datasets.go</a></td>
<td>The code to create different indexes and try them with different datasets</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">Use the following commands to download the datasets used in the examples:</p>

<div dir="auto" data-snippet-clipboard-copy-content="# Only needed to run the examples that use large datasets
make download-data-large"><pre><span><span>#</span> Only needed to run the examples that use large datasets</span>
make download-data-large</pre></div>
<p dir="auto">Note that to run the examples using large datasets, possibly a machine with large amounts of memory is needed
like 32 GB or more.</p>
<p dir="auto">Check the <a href="https://github.com/habedi/hann/blob/main/example/data">data</a> directory for information about the datasets.</p>
<hr/>

<p dir="auto">The detailed documentation for Hann packages is available on <a href="https://pkg.go.dev/github.com/habedi/hann" rel="nofollow">pkg.go.dev</a>.</p>

<p dir="auto">The <a href="https://github.com/habedi/hann/blob/main/hnsw"><code>hnsw</code></a> package provides an implementation of the HNSW graph index introduced
by <a href="https://arxiv.org/abs/1603.09320" rel="nofollow">Malkov and Yashunin (2016)</a>.
HNSW organizes data into multiple layers of a proximity graph, which allows fast approximate nearest neighbor searches
by greedily traversing the graph from top to bottom.</p>
<p dir="auto">The index has the following parameters:</p>
<ul dir="auto">
<li><strong>M</strong>: Controls the maximum number of neighbor connections per node. Higher values improve accuracy but increase
memory and indexing time (typical range: 5–48).</li>
<li><strong>Ef</strong>: Defines search breadth during insertion and searching. Higher values improve accuracy but
increase computational cost (typical range: 10–200).</li>
</ul>

<p dir="auto">The <a href="https://github.com/habedi/hann/blob/main/pqivf"><code>pqivf</code></a> package provides an implementation of the PQIVF index introduced
by <a href="https://ieeexplore.ieee.org/document/5432202" rel="nofollow">Jegou et al. (2011)</a>.
PQIVF first clusters data into coarse groups (inverted lists), then compresses vectors in each cluster using <a href="https://ieeexplore.ieee.org/document/5432202" rel="nofollow">product
quantization</a>.
This allows fast approximate nearest neighbor searches by limiting queries to relevant clusters and
efficiently comparing compressed vectors, which reduces search time and storage requirements.</p>
<p dir="auto">The index has the following parameters:</p>
<ul dir="auto">
<li><strong>coarseK</strong>: Controls the number of coarse clusters for initial quantization. Higher values improve search performance
but increase indexing time (typical range: 50–4096).</li>
<li><strong>numSubquantizers</strong>: Determines the number of subspaces for product quantization. More subquantizers improve
compression and accuracy at the cost of increased indexing time (typical range: 4–16).</li>
<li><strong>pqK</strong>: Sets the number of codewords per subquantizer. Higher values increase accuracy and storage usage (typical
value: 256).</li>
<li><strong>kMeansIters</strong>: Number of iterations used to train the product quantization codebooks (recommended value: 25).</li>
</ul>

<p dir="auto">The <a href="https://github.com/habedi/hann/blob/main/rpt"><code>rpt</code></a> package provides an implementation of the RPT index introduced
by <a href="https://dl.acm.org/doi/10.1145/1374376.1374452" rel="nofollow">Dasgupta and Freund (2008)</a>.
RPT recursively partitions data using randomly generated hyperplanes to build a tree structure, which allows efficient
approximate nearest neighbor searches through a tree traversal process.</p>
<p dir="auto">The index has the following parameters:</p>
<ul dir="auto">
<li><strong>leafCapacity</strong>: Controls the maximum number of vectors stored in each leaf node. Lower values increase tree depth,
improving search speed but slightly increasing indexing time (typical range: 5–50).</li>
<li><strong>candidateProjections</strong>: Number of random projections considered at each tree split. Higher values improve split
quality at the cost of increased indexing time (typical range: 1–10).</li>
<li><strong>parallelThreshold</strong>: Minimum number of vectors in a subtree to trigger parallel construction. Higher values lead to
better concurrency during indexing but use more memory (typical value: 100).</li>
<li><strong>probeMargin</strong>: Margin used to determine additional branches probed during searches. Higher values improve recall but
increase search overhead because of additional distance computations (typical range: 0.1–0.5).</li>
</ul>

<p dir="auto">The verbosity level of logs produced by Hann can be controlled using the <code>HANN_LOG</code> environment variable.
Possible values include:</p>
<ul dir="auto">
<li><code>0</code>, <code>false</code>, or <code>off</code> to disable logging altogether;</li>
<li><code>full</code> or <code>all</code> to enable full logging (<code>DEBUG</code> level);</li>
<li>Use any other value (including not setting the <code>HANN_LOG</code> environment variable) to enable basic logging (<code>INFO</code> level;
default behavior).</li>
</ul>

<p dir="auto">For more consistent indexing and search results across different runs, set the <code>HANN_SEED</code> environment variable to an
integer.
This will initialize the random number generator, but some variations are still possible (for example, due to
multithreading).</p>
<hr/>

<p dir="auto">See <a href="https://github.com/habedi/hann/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a> for details on how to make a contribution.</p>

<p dir="auto">The logo is named the &#34;Hiking Gopher&#34; and was created by <a href="https://github.com/egonelbre/gophers">Egon Elbre</a>.</p>

<p dir="auto">Hann is licensed under the MIT License (<a href="https://github.com/habedi/hann/blob/main/LICENSE">LICENSE</a>).</p>
</article></div></div>
  </body>
</html>
