<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codecs.multimedia.cx/2022/02/looking-at-zig-programming-language/">Original</a>
    <h1>Looking at Zig Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>Back when I wrote my rant about C++ and its bad influence on C (yeah, about three quarters of year ago) I got recommendations to look at Zig and finally decided to download 0.9.0 release and play it. Long story short: it’s an interesting language with some good ideas but not the one I’d use.</p>
<p>First of all, Zig feels more like a cross between D and Go, while Rust coming from ML family of programming languages ironically feels more like C—and I’m still a C programmer. The features like importing (sub)packages like <code>const fs = @import(&#34;std&#34;).fs;</code> or being able to compile C with the same compiler are well-known features of D. While postfix notation (e.g. <code>var foo: u8</code> or <code>pub fn main() !void</code>), <code>defer</code> and having JSON support in the standard library definitely reminds of Go (and I was surprised to find support for various binary formats like ELF, COFF or PDB in <code>std</code>; compared to that <code>std.Progress</code> is nothing special). No idea though where pointer dereferencing as <code>foo.* = 42;</code> comes from. Additionally Zig has optional type and error built-in types which is a bit strange for a language posing as simple (in Rust they rightfully belong to the standard library as there’s nothing there that prevents them from being implemented in a language itself); probably it was a verbosity trade-off since Rust <code>Option&lt;OptValue&gt;</code> and <code>Result&lt;RetType, ErrType&gt;</code> is bulkier than Zig <code>?OptValue</code> and <code>ErrType!RetType</code> respectively (and it makes applying special rules to those types harder).</p>
<p>And speaking of verbosity and error types, Zig is too verbose in all the wrong places. Error handling all works fine and <code>try doStuff();</code> is no worse than <code>doStuff()?;</code> in Rust, the problems come when you don’t simply want to return on error. You can’t ignore return result and, developing further the infamous Go <code>result, err := func();</code> idiom, you always have to process both values. While in Rust I can write <code>if file.write(data).is_err() { ... }</code> in Zig the compiler will complain if you don’t use actual error value in some way or if you do not use result value (but luckily you can send it to bit bucket) which means that proper code in this case looks like <code>_ = file.write(data) catch |err| { silence_err_somehow(err); ... }</code>.</p>
<p>Side note: I find Rust approach of making variables constant by default better in terms of preventing programmer from making certain class of mistakes (but it gets a bit annoying when most of your variables are mutable, so it’s more the matter of taste).</p>
<p>Then you have loops that disagree with my tastes. C has extremely powerful <code>for(;;)</code> loop, in Rust you have <code>for X in Y</code> loop taking an iterator plus there are ranges and other utility functions to replicate some of the C <code>for(;;)</code> features (e.g. <code>for i in (0..10).rev().step_by(3)</code> instead of <code>for(i = 9; i &gt;= 0; i -= 3)</code>). In Zig you have <code>for iter |item[, index]|</code> and for the traditional C-like loop you have to use <code>while</code> with post-condition like <code>while (i &lt; 10) : (i += 1) {}</code>. And I won&#39;t even talk about <code>while</code> with <code>else</code> clause.</p>
<p>What I really dislike though is rather inconsistent (again, to my tastes) language design. You have language keywords and you have built-in functions with rather arbitrary grouping. For instance, built-in functions include: package importing directives (<code>@import</code>, <code>@cImport</code>), type casting (<code>@as</code>, <code>@ptrCast</code>, <code>@boolToInt</code>), special instructions (atomic operations, <code>@breakpoint</code>, vector operations) and generic calculations (like <code>@cos</code> or <code>@sqrt</code>). I guess some of those were introduced to make for the lack of generics (and where <code>comptime</code> can&#39;t help) but I&#39;d rather have many of those functions either moved into the standard library or associated with the proper types i.e. <code>val.clz()</code> instead of <code>@clz(val)</code> (and I&#39;d make <code>undefined</code> a built-in function too instead of a keyword). And I&#39;d like to have them separated in syntax by purpose. I&#39;m not going to mention how it&#39;s done in Rust but even in C with all its deficiencies you had preprocessor directives starting with a grille sign e.g. <code>#include</code> and built-in compiler functions were conventionally prefixed with two underscores e.g. <code>__builtin_clz()</code>. The rest looked like normal language constructs and I didn&#39;t have to care how <code>offsetof(struct, field)</code> is implemented or whether the compiler is smart enough to use x87 instruction (or SSE nowadays) for cosine calculation. To repeat it again, I know that the current scheme is caused by some self-imposed limitations coming from the language and the compiler design principles but they don&#39;t align with me.</p>
<p>To offset negativity I should mentions some things in Zig that I found useful or at least interesting. First of all, not explicitly specifying array size (you can&#39;t do that in Rust for constants even if the compiler should be able to figure out array size from its contents). Built-in tests that have a free-form description are also a good idea (in Rust you can only name test function more creatively). Explicit wrapping operations for integers are nice (and writing <code>foo -%= bar;</code> is not as verbose as <code>foo = foo.wrapping_sub(bar);</code>). Sentinel-terminated arrays/slices is an interesting idea. Explicit compile-time calculations look very helpful. A dedicated <code>opaque</code> sounds like a good idea. The ability to compile C or C++ code is a nice feature (and I wish <code>rustc</code> would have a stand-alone assembly files support). There are some other nice compiler features (like cross-compiling out of the box) but they seem to be related to the compiler itself and not the language.</p>
<p>Overall, Zig is by no means is a bad language (and looks good enough to write a multimedia framework in it among other things), it just does not align well with my tastes. Let&#39;s wait and see how it develops.</p>

								
				<p>
					<small>
												This entry was posted on Saturday, February 5th, 2022 at 8:01 am and is filed under <a href="https://codecs.multimedia.cx/category/useless-rants/" rel="category tag">Useless Rants</a>.						You can follow any responses to this entry through the <a href="https://codecs.multimedia.cx/2022/02/looking-at-zig-programming-language/feed/">RSS 2.0</a> feed. 

													You can <a href="#respond">leave a response</a>, or <a href="https://codecs.multimedia.cx/2022/02/looking-at-zig-programming-language/trackback/" rel="trackback">trackback</a> from your own site.
						
					</small>
				</p>

			</div></div>
  </body>
</html>
