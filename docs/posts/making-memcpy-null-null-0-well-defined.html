<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2024/12/11/making-memcpynull-null-0-well-defined">Original</a>
    <h1>Making memcpy(NULL, NULL, 0) well-defined</h1>
    
    <div id="readability-page-1" class="page"><div>
                  
                <div>
          <p>Undefined behavior (UB) in the C programming language is a regular source of heated discussions among programmers. On the one hand, UB can be important for compiler optimizations. On the other hand, it makes is easy to introduce bugs that lead to security issues.</p><p>The good news is that <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3322.pdf">N3322</a> has been accepted for C2y, which will remove undefined behavior from one particular corner of the C language, making all of the following well-defined:</p><pre><code>memcpy(NULL, NULL, 0);
memcmp(NULL, NULL, 0);
(int *)NULL + 0;
(int *)NULL - 0;
(int *)NULL - (int *)NULL;</code></pre><p>This only applies when a null pointer is combined with a &#34;zero-length&#34; operation. The following are still undefined:</p><pre><code>memcpy(NULL, NULL, 4);
(int *)NULL + 4;</code></pre><p>The removal of this undefined behavior is not expected to have any negative impact on performance. In fact, the reverse is true.</p><h2>Motivation</h2><p>The examples above are somewhat silly because they hard-code a <code>NULL</code>/<code>nullptr</code> constant. However, it is easy to run into this situation with a pointer that is only sometimes null. For example, consider a typical representation for a string with a known length:</p><pre><code>struct str {
   char *data;
   size_t len;
};</code></pre><p>An empty string would usually be represented as <code>(struct str) { .data = NULL, .len = 0 }</code>, with the <code>data</code> pointer being <code>NULL</code>. Now, consider a function that checks if two strings are equal:</p><pre><code>bool str_eq(const struct str *str1, const struct str *str2) {
   return str1-&gt;len == str2-&gt;len &amp;&amp;
          memcmp(str1-&gt;data, str2-&gt;data, str1-&gt;len) == 0;
}</code></pre><p>This implementation looks very reasonable at first glance. However, it exhibits undefined behavior if both of the inputs are empty strings. In that case, we will call <code>memcmp(NULL, NULL, 0)</code>, which is undefined behavior according to the C standard.</p><p>This kind of UB introduces the risk that the compiler will optimize away following null pointer checks. For example, GCC will happily remove the <code>dest == NULL</code> branch in the following code, while Clang deliberately does not perform this optimization:</p><pre><code>int test(char *dest, const char *src, size_t len) {
   memcpy(dest, src, len);
   if (dest == NULL) {
       // This branch will be removed by GCC due to undefined behavior.
   }
}</code></pre><p>The correct way to write the <code>str_eq</code> function is as follows:</p><pre><code>bool str_eq(const struct str *str1, const struct str *str2) {
   return str1-&gt;len == str2-&gt;len &amp;&amp;
          (str1-&gt;len == 0 ||
           memcmp(str1-&gt;data, str2-&gt;data, str1-&gt;len) == 0);
}</code></pre><p>The new code is correct, but worse in every other way:</p><ul><li>It increases code size, by requiring an extra check at each inlined call-site.</li><li>It decreases performance, by redundantly checking something <code>memcmp</code> has to handle anyway.</li><li>It increases code complexity.</li></ul><p>At the same time, there is no useful way in which the C library can make use of this undefined behavior to provide a more efficient implementation. This is the kind of UB that benefits nobody, and should be removed from the language.</p><h2>Null pointer arithmetic</h2><p>The original proposal was focused on removing UB for memory library calls, but an early reviewer pointed out that this is not sufficient. After all, we also need to take into account how these library functions are implemented.</p><p>For example, let&#39;s consider a typical implementation for a <code>memcpy</code>-like function:</p><pre><code>void copy(char *dst, const char *src, size_t n) {
   for (const char *end = src + n; src &lt; end; src++) {
       *dst++ = *src;
   }
}</code></pre><p>This function exhibits undefined behavior when called as <code>copy(NULL, NULL, 0)</code>, because <code>NULL + 0</code> is undefined behavior in C.</p><p>To avoid this, and make the overall language self-consistent, we need to define <code>NULL + 0</code> as returning <code>NULL</code> and <code>NULL - NULL</code> as returning 0. This also aligns C with C++ semantics, where this was already well-defined.</p><h2>Opposition</h2><p>When this proposal was discussed at two WG14 meetings, the opposition didn&#39;t come from the direction I expected.</p><p>The most broadly controversial part of the proposal was to define <code>NULL - NULL</code> as returning 0. The reason for this is that when address spaces get involved (which are not part of standard C, but may be implemented as an extension), there may be multiple representations of a null pointer. Making sure that subtracting two &#34;different&#34; nulls still results in zero might require the generation of additional code, breaking the premise that this change is entirely free.</p><p>However, the most vocal opposition came from a static analysis perspective: Making null pointers well-defined for zero length means that static analyzers can no longer unconditionally report <code>NULL</code> being passed to functions like <code>memcpy</code>â€”they also need to take the length into account now. If an <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3089.pdf"><code>_Optional</code> qualifier</a> is introduced in the future, <code>memcpy</code> arguments would have to be qualified with it. GCC is considering the introduction of a <a href="https://gcc.gnu.org/pipermail/gcc-patches/2024-November/668505.html"><code>nonnull_if_nonzero</code></a> attribute to represent the new pre-condition.</p><p>After the seemingly negative discussion, I was somewhat surprised that the vote not only went strongly in favor of the change, but also came with a recommendation to implementers to apply the change <a href="https://www.open-std.org/jtc1/sc22/wg14/www/previous.html">retroactively</a> to old standard versions. This means that, once compilers and C libraries have implemented the change, it should apply even without specifying the <code>-std=c2y</code> flag.</p><h2>Compiler builtins</h2><p>I work on the middle-end of the <a href="https://llvm.org/">LLVM</a> compiler toolchain. Being far removed from any &#34;user-facing&#34; parts of the compiler, I am generally not involved with standardization efforts.</p><p>The reason I got involved here at all is the specification for LLVM&#39;s internal memcpy intrinsic:</p><blockquote><p>The <code>llvm.memcpy.*</code> intrinsics copy a block of memory from the source location to the destination location, which must either be equal or non-overlapping. [...]</p></blockquote><p>The <code>llvm.memcpy</code> intrinsic may lower to a call to the <code>memcpy</code> function, which is treated as a &#34;compiler runtime builtin&#34; here, even though it is ultimately also provided by the C library.</p><p>When used as a builtin, LLVM requires that both <code>memcpy(x, x, s)</code> and <code>memcpy(NULL, NULL, 0)</code> are well-defined, even though the C standard says they are UB. GCC and MSVC have similar assumptions.</p><p>Making <code>memcpy(NULL, NULL, 0)</code> officially well-defined removes one of the assumptions, while the <code>memcpy(x, x, s)</code> case remains for now. Allowing this was originally also part of the proposal, but was later dropped, because it didn&#39;t fit well with the other changes.</p><p>In a weird turn of events, this change to the C standard came about because Rust developers kept nagging me about the mismatch between LLVM and C semantics.</p><h2>Acknowledgements</h2><p>This paper was a collaboration with Aaron Ballman, who also drove the discussion during the actual WG14 meetings. Special thanks go to David Stone, whose early feedback radically changed the direction of the proposal from memory library calls in particular to &#34;zero-length&#34; operations in general.</p>
          
                            </div>
      </div></div>
  </body>
</html>
