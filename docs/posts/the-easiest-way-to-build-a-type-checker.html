<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jimmyhmiller.com/easiest-way-to-build-type-checker">Original</a>
    <h1>The Easiest Way to Build a Type Checker</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Type checkers are a piece of software that feel incredibly simple, yet incredibly complex. Seeing <a href="https://github.com/webyrd/hindley-milner-type-inferencer/blob/master/type-inferencer.scm">Hindley-Milner written in a logic programming language</a> is almost magical, but it never helped me understand how it was implemented. Nor does actually trying to read anything about Algorithm W or any academic paper explaining a type system. But thanks to <a href="https://www.youtube.com/watch?v=utyBNDj7s2w">David Christiansen</a>, I have discovered a setup for type checking that is so conceptually simple it demystified the whole thing for me. It goes by the name Bidirectional Type Checking.</p>
<h2>Bidirectional Type Checking</h2>
<p>The two directions in this type checker are <code>inferring</code> types and <code>checking</code> types. Unlike Hindley-Milner, we do need some type annotations, but these are typically at function definitions. So code like the sillyExample below is completely valid and fully type checks despite lacking annotations. How far can we take this? I&#39;m not a type theory person. Reading papers in type theory takes me a while, and my comprehension is always lacking, but <a href="https://arxiv.org/pdf/1908.05839">this paper</a> seems like a good starting point for answering that question.</p>
<pre><code><span>function</span> <span>sillyExample</span><span>(</span><span>x<span>:</span> <span>number</span></span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>10</span><span>;</span>
  <span>let</span> b <span>=</span> <span>20</span><span>;</span>
  <span>let</span> e <span>=</span> a<span>;</span>
  <span>let</span> f <span>=</span> b<span>;</span>
  <span>let</span> q <span>=</span> a <span>+</span> e<span>;</span>
  <span>let</span> g <span>=</span> <span>&#34;hello&#34;</span><span>;</span>
  <span>let</span> h <span>=</span> <span>&#34;world&#34;</span><span>;</span>
  <span>let</span> i <span>=</span> <span>100</span> <span>+</span> q<span>;</span>
  <span>return</span> x<span>;</span>
<span>}</span>
</code></pre>
<p>So, how do we actually create a bidirectional type checker? I think the easiest way to understand it is to see a full working implementation. So that&#39;s what I have below for a very simple language. To understand it, start by looking at the types to figure out what the language supports, then look at each of the <code>infer</code> cases. But don&#39;t worry, if it doesn&#39;t make sense, I will explain in more detail below.</p>
<pre><code><span>export</span> <span>type</span> Type <span>=</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;number&#34;</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;string&#34;</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;function&#34;</span><span>;</span> arg<span>:</span> Type<span>;</span> returnType<span>:</span> Type <span>}</span><span>;</span>

<span>export</span> <span>type</span> Expr <span>=</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;number&#34;</span><span>;</span> value<span>:</span> <span>number</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;string&#34;</span><span>;</span> value<span>:</span> <span>string</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;varLookup&#34;</span><span>;</span> name<span>:</span> <span>string</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;function&#34;</span><span>;</span> param<span>:</span> <span>string</span><span>;</span> body<span>:</span> Expr <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;call&#34;</span><span>;</span> fn<span>:</span> Expr<span>;</span> arg<span>:</span> Expr <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;let&#34;</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> value<span>:</span> Expr<span>;</span> <span>type</span><span>?</span><span>:</span> Type <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#34;block&#34;</span><span>;</span> statements<span>:</span> Expr<span>[</span><span>]</span><span>;</span> <span>return</span><span>:</span> Expr <span>}</span><span>;</span>

<span>export</span> <span>type</span> Context <span>=</span> Map<span>&lt;</span><span>string</span><span>,</span> Type<span>&gt;</span><span>;</span>

<span>export</span> <span>function</span> <span>infer</span><span>(</span><span>ctx<span>:</span> Context<span>,</span> expr<span>:</span> Expr</span><span>)</span><span>:</span> Type <span>{</span>
  <span>switch</span> <span>(</span>expr<span>.</span>kind<span>)</span> <span>{</span>
    <span>case</span> <span>&#34;number&#34;</span><span>:</span>
      <span>return</span> <span>{</span> kind<span>:</span> <span>&#34;number&#34;</span> <span>}</span><span>;</span>

    <span>case</span> <span>&#34;string&#34;</span><span>:</span>
      <span>return</span> <span>{</span> kind<span>:</span> <span>&#34;string&#34;</span> <span>}</span><span>;</span>

    <span>case</span> <span>&#34;varLookup&#34;</span><span>:</span>
      <span>const</span> <span>type</span> <span>=</span> ctx<span>.</span><span>get</span><span>(</span>expr<span>.</span>name<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>!</span><span>type</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>Unbound variable: </span><span><span>${</span>expr<span>.</span>name<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
      <span>}</span>
      <span>return</span> <span>type</span><span>;</span>

    <span>case</span> <span>&#34;call&#34;</span><span>:</span>
      <span>const</span> fnType <span>=</span> <span>infer</span><span>(</span>ctx<span>,</span> expr<span>.</span>fn<span>)</span><span>;</span>
      <span>if</span> <span>(</span>fnType<span>.</span>kind <span>!==</span> <span>&#34;function&#34;</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;Cannot call non-function&#34;</span><span>)</span><span>;</span>
      <span>}</span>
      <span>check</span><span>(</span>ctx<span>,</span> expr<span>.</span>arg<span>,</span> fnType<span>.</span>arg<span>)</span><span>;</span>
      <span>return</span> fnType<span>.</span>returnType<span>;</span>

    <span>case</span> <span>&#34;function&#34;</span><span>:</span>
      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;Cannot infer type for function without annotation&#34;</span><span>)</span><span>;</span>

    <span>case</span> <span>&#34;let&#34;</span><span>:</span>
      <span>const</span> valueType <span>=</span> <span>infer</span><span>(</span>ctx<span>,</span> expr<span>.</span>value<span>)</span><span>;</span>
      <span>if</span> <span>(</span>expr<span>.</span><span>type</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>typesEqual</span><span>(</span>valueType<span>,</span> expr<span>.</span><span>type</span><span>)</span><span>)</span> <span>{</span>
          <span>let</span> expected <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>expr<span>.</span><span>type</span><span>)</span><span>;</span>
          <span>let</span> actual <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>valueType<span>)</span><span>;</span>
          <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>expected </span><span><span>${</span>expected<span>}</span></span><span>, got </span><span><span>${</span>actual<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span>
      ctx<span>.</span><span>set</span><span>(</span>expr<span>.</span>name<span>,</span> valueType<span>)</span><span>;</span>
      <span>return</span> valueType<span>;</span>

    <span>case</span> <span>&#34;block&#34;</span><span>:</span>
      <span>let</span> blockCtx <span>=</span> <span>new</span> <span>Map</span><span>(</span>ctx<span>)</span><span>;</span>
      <span>for</span> <span>(</span><span>const</span> stmt <span>of</span> expr<span>.</span>statements<span>)</span> <span>{</span>
        <span>infer</span><span>(</span>blockCtx<span>,</span> stmt<span>)</span><span>;</span>
      <span>}</span>
      <span>return</span> <span>infer</span><span>(</span>blockCtx<span>,</span> expr<span>.</span><span>return</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>function</span> <span>check</span><span>(</span><span>ctx<span>:</span> Context<span>,</span> expr<span>:</span> Expr<span>,</span> expected<span>:</span> Type</span><span>)</span><span>:</span> <span>void</span> <span>{</span>
  <span>switch</span> <span>(</span>expr<span>.</span>kind<span>)</span> <span>{</span>
    <span>case</span> <span>&#34;function&#34;</span><span>:</span>
      <span>if</span> <span>(</span>expected<span>.</span>kind <span>!==</span> <span>&#34;function&#34;</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;Function must have function type&#34;</span><span>)</span><span>;</span>
      <span>}</span>
      <span>const</span> newCtx <span>=</span> <span>new</span> <span>Map</span><span>(</span>ctx<span>)</span><span>;</span>
      newCtx<span>.</span><span>set</span><span>(</span>expr<span>.</span>param<span>,</span> expected<span>.</span>arg<span>)</span><span>;</span>
      <span>check</span><span>(</span>newCtx<span>,</span> expr<span>.</span>body<span>,</span> expected<span>.</span>returnType<span>)</span><span>;</span>
      <span>break</span><span>;</span>

    <span>case</span> <span>&#34;block&#34;</span><span>:</span>
      <span>let</span> blockCtx <span>=</span> <span>new</span> <span>Map</span><span>(</span>ctx<span>)</span><span>;</span>
      <span>for</span> <span>(</span><span>const</span> stmt <span>of</span> expr<span>.</span>statements<span>)</span> <span>{</span>
        <span>infer</span><span>(</span>blockCtx<span>,</span> stmt<span>)</span><span>;</span>
      <span>}</span>
      <span>check</span><span>(</span>blockCtx<span>,</span> expr<span>.</span><span>return</span><span>,</span> expected<span>)</span><span>;</span>
      <span>break</span><span>;</span>

    <span>default</span><span>:</span>
      <span>const</span> actual <span>=</span> <span>infer</span><span>(</span>ctx<span>,</span> expr<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>!</span><span>typesEqual</span><span>(</span>actual<span>,</span> expected<span>)</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>Type mismatch: expected </span><span><span>${</span>expected<span>}</span></span><span>, got </span><span><span>${</span>actual<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
      <span>}</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>function</span> <span>typesEqual</span><span>(</span><span>a<span>:</span> Type<span>,</span> b<span>:</span> Type</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span> <span>(</span>a<span>.</span>kind <span>!==</span> b<span>.</span>kind<span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>if</span> <span>(</span>a<span>.</span>kind <span>===</span> <span>&#34;function&#34;</span> <span>&amp;&amp;</span> b<span>.</span>kind <span>===</span> <span>&#34;function&#34;</span><span>)</span> <span>{</span>
    <span>return</span> <span>typesEqual</span><span>(</span>a<span>.</span>arg<span>,</span> b<span>.</span>arg<span>)</span> <span>&amp;&amp;</span> <span>typesEqual</span><span>(</span>a<span>.</span>returnType<span>,</span> b<span>.</span>returnType<span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre>
<p>Here we have, in ~100 lines, a fully functional type checker for a small language. Is it without flaw? Is it feature complete? Not at all. In a real type checker, you might not want to know only if something typechecks, but you might want to decorate the various parts with their type; we don&#39;t do that here. We don&#39;t do a lot of things. But I&#39;ve found that this tiny bit of code is enough to start extending to much larger, more complicated code examples.</p>
<h2>Explanation</h2>
<p>If you aren&#39;t super familiar with the implementation of programming languages, some of this code might strike you as a bit odd, so let me very quickly walk through the implementation. First, we have our data structures for representing our code:</p>
<pre><code><span>export</span> <span>type</span> Type <span>=</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;string&#39;</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;function&#39;</span><span>,</span> arg<span>:</span> Type<span>,</span> returnType<span>:</span> Type <span>}</span>

<span>export</span> <span>type</span> Expr <span>=</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span><span>,</span> value<span>:</span> <span>number</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;string&#39;</span><span>,</span> value<span>:</span> <span>string</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;varLookup&#39;</span><span>,</span> name<span>:</span> <span>string</span> <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;function&#39;</span><span>,</span> param<span>:</span> <span>string</span><span>,</span> body<span>:</span> Expr <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;call&#39;</span><span>,</span> fn<span>:</span> Expr<span>,</span> arg<span>:</span> Expr <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;let&#39;</span><span>,</span> name<span>:</span> <span>string</span><span>,</span> value<span>:</span> Expr<span>,</span> <span>type</span><span>?</span><span>:</span> Type <span>}</span>
  <span>|</span> <span>{</span> kind<span>:</span> <span>&#39;block&#39;</span><span>,</span> statements<span>:</span> Expr<span>[</span><span>]</span><span>,</span> <span>return</span><span>:</span> Expr <span>}</span>
</code></pre>
<p>Using this data structure, we can write code in a way that is much easier to work with than the actual string that we use to represent code. This kind of structure is called an &#34;abstract syntax tree&#34;. For example</p>
<pre><code><span>// double(5)</span>
<span>{</span>
  kind<span>:</span> <span>&#39;call&#39;</span><span>,</span>
  fn<span>:</span> <span>{</span> kind<span>:</span> <span>&#39;varLookup&#39;</span><span>,</span> name<span>:</span> <span>&#39;double&#39;</span> <span>}</span><span>,</span>
  arg<span>:</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span><span>,</span> value<span>:</span> <span>5</span> <span>}</span>
<span>}</span>
</code></pre>
<p>This structure makes it easy to walk through our program and check things bit by bit.</p>
<h3>Context</h3>
<pre><code><span>export</span> <span>type</span> Context <span>=</span> Map<span>&lt;</span><span>string</span><span>,</span> Type<span>&gt;</span>
</code></pre>
<p>This simple line of code is the key to how all variables, all functions, etc, work. When we enter a function or a block, we make a new Map that will let us hold the local variables and their types. We pass this map around, and now we know the types of things that came before it. If we wanted to let you define functions out of order, we&#39;d simply need to do two passes over the tree. The first to gather up the top-level functions, and the next to type-check the whole program. (This code gets more complicated with nested function definitions, but we&#39;ll ignore that here.)</p>
<h3>Inference</h3>
<p>Each little bit of <code>infer</code> may seem a bit trivial. So, to explain it, let&#39;s add a new feature, addition.</p>
<pre><code><span>// add this into our Expr type</span>
<span>|</span> <span>{</span> kind<span>:</span> <span>&#39;add&#39;</span><span>,</span> left<span>:</span> Expr<span>,</span> right<span>:</span> Expr <span>}</span>
</code></pre>
<p>Now we have something just a bit more complicated, so how would we write our inference for this? Well, we are going to do the simple case; we are only allowed to add numbers together. Given that our code would look something like this:</p>
<pre><code><span>case</span> <span>&#39;add&#39;</span><span>:</span>
  <span>const</span> leftType <span>=</span> <span>check</span><span>(</span>ctx<span>,</span> expr<span>.</span>left<span>,</span> <span>{</span>kind<span>:</span> <span>&#34;number&#34;</span><span>}</span><span>)</span>
  <span>const</span> rightType <span>=</span> <span>check</span><span>(</span>ctx<span>,</span> expr<span>.</span>right<span>,</span> <span>{</span>kind<span>:</span> <span>&#34;number&#34;</span><span>}</span><span>)</span>
  <span>return</span> <span>{</span>kind<span>:</span> <span>&#34;number&#34;</span><span>}</span><span>;</span>
</code></pre>
<p>This may seem a bit magical. How does <code>check</code> make this just work? Imagine that we have the following expression:</p>
<pre><code><span>// 2 + 3 + 4</span>
 <span>{</span>
    kind<span>:</span> <span>&#39;add&#39;</span><span>,</span>
    left<span>:</span> <span>{</span>
      kind<span>:</span> <span>&#39;add&#39;</span><span>,</span>
      left<span>:</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span><span>,</span> value<span>:</span> <span>2</span> <span>}</span><span>,</span>
      right<span>:</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span><span>,</span> value<span>:</span> <span>3</span> <span>}</span>
 <span>}</span><span>,</span>
    right<span>:</span> <span>{</span> kind<span>:</span> <span>&#39;number&#39;</span><span>,</span> value<span>:</span> <span>4</span> <span>}</span>
 <span>}</span>
</code></pre>
<p>There is no special handling in <code>check</code> for <code>add</code> so we end up at</p>
<pre><code><span>default</span><span>:</span>
  <span>const</span> actual <span>=</span> <span>infer</span><span>(</span>ctx<span>,</span> expr<span>)</span>
  <span>if</span> <span>(</span><span>!</span><span>typesEqual</span><span>(</span>actual<span>,</span> expected<span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>Type mismatch: expected </span><span><span>${</span>expected<span>}</span></span><span>, got </span><span><span>${</span>actual<span>}</span></span><span>`</span></span><span>)</span>
 <span>}</span>
</code></pre>
<p>If you trace out the recursion (once you get used to recursion, you don&#39;t actually need to do this, but I&#39;ve found it helps people who aren&#39;t used to it), we get something like</p>
<pre><code> <span>infer</span><span>(</span><span>2</span> <span>+</span> <span>3</span> <span>+</span> <span>4</span><span>)</span>
    <span>check</span><span>(</span><span>2</span> <span>+</span> <span>3</span><span>,</span> <span>number</span><span>)</span>
      <span>infer</span><span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span>
        <span>check</span><span>(</span><span>2</span><span>,</span> <span>number</span><span>)</span>
          <span>infer</span><span>(</span><span>2</span><span>)</span> → <span>number</span>
        <span>check</span><span>(</span><span>3</span><span>,</span> <span>number</span><span>)</span>
          <span>infer</span><span>(</span><span>3</span><span>)</span> → <span>number</span>
    <span>check</span><span>(</span><span>4</span><span>,</span> <span>number</span><span>)</span>
      <span>infer</span><span>(</span><span>4</span><span>)</span> → <span>number</span>
</code></pre>
<p>So now for our first left, we will recurse back to <code>infer</code>, then to <code>check</code>, and finally bottom out in some simple thing we know how to <code>infer</code>. This is the beauty of our bidirectional checker. We can interleave these <code>infer</code> and <code>check</code> calls at will!</p>
<p>How would we change our add to work with strings? Or coerce between number and string? I leave that as an exercise to the reader. It only takes just a little bit more code.</p>
<h2>Making it Feel Real</h2>
<p>I know for a lot of people this might all seem a bit abstract. So here is a very quick, simple proof of concept that uses this same strategy above for a subset of TypeScript syntax (it does not try to recreate the TypeScript semantics for types).</p>
<!-- -->
<p>If you play with this, I&#39;m sure you will find bugs. You will find features that aren&#39;t supported. But you will also see the beginnings of a reasonable type checker. (It does a bit more than the one above, because otherwise the demos would be lame. Mainly multiple arguments and adding binary operators.)</p>
<p>But the real takeaway here, I hope, is just how straightforward type checking can be. If you see some literal, you can <code>infer</code> its type. If you have a variable, you can look up its type. If you have a type annotation, you can <code>infer</code> the type of the value and <code>check</code> it against that annotation. I have found that following this formula makes it quite easy to add more and more features.</p></div></div>
  </body>
</html>
