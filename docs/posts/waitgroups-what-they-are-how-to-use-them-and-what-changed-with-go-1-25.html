<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mfbmina.dev/en/posts/waitgroups/">Original</a>
    <h1>Waitgroups: What they are, how to use them and what changed with Go 1.25</h1>
    
    <div id="readability-page-1" class="page"><article role="main"><p>Imagine the following problem: you need to process hundreds of records and generate a single output. One way to solve this is to process each record sequentially and unify the output only at the end. However, this can be extremely slow, depending on the time spent processing each record. Another way is to process them concurrently, speeding up the overall time. In my post about <a href="https://mfbmina.dev/en/posts/introduction-concurrency-go/">introduction to concurrency</a>, I talked a bit about <code>goroutines</code> and <code>channels</code>. Now, I’ve decided to talk about <code>waitgroups</code>, a way to simplify the management of multiple <code>goroutines</code>.</p><p><code>Waitgroups</code> are part of the <a href="https://pkg.go.dev/sync#WaitGroup" target="_blank">sync</a> package, and their use is relatively simple. For each <code>goroutine</code> you start, you must add 1 to the <code>sync</code> counter, and then you have to wait for all <code>goroutines</code> to finish their work. Each <code>goroutine</code> must reduce the counter by 1 to indicate its completion. For example:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>Before1_25</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>r</span> <span>:=</span> <span>rand</span><span>.</span><span>IntN</span><span>(</span><span>10</span><span>)</span>
</span></span><span><span>  <span>wg</span> <span>:=</span> <span>sync</span><span>.</span><span>WaitGroup</span><span>{}</span>
</span></span><span><span>  <span>wg</span><span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span> <span>// Wait for 1 more goroutine to process
</span></span></span><span><span><span></span>  <span>go</span> <span>doSomethingTheOldWay</span><span>(</span><span>&amp;</span><span>wg</span><span>,</span> <span>r</span><span>)</span> <span>// Doing something async
</span></span></span><span><span><span></span>  <span>wg</span><span>.</span><span>Wait</span><span>()</span> <span>// Wait until all goroutines finishes
</span></span></span><span><span><span></span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>doSomethingTheOldWay</span><span>(</span><span>wg</span> <span>*</span><span>sync</span><span>.</span><span>WaitGroup</span><span>,</span> <span>sleep</span> <span>int</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>defer</span> <span>wg</span><span>.</span><span>Done</span><span>()</span> <span>// Tell the waitgroup you&#39;re done. It the same as wg.Add(-1)
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>time</span><span>.</span><span>Duration</span><span>(</span><span>sleep</span><span>)</span> <span>*</span> <span>time</span><span>.</span><span>Second</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Although they are easy to use, you must always ensure the correct number of <code>goroutines</code> in the <code>waitgroup</code>. In other words, for every <code>goroutine</code> added with <code>wg.Add</code>, you must have a <code>wg.Done</code>. If this doesn’t happen, it can cause a <a href="https://en.wikipedia.org/wiki/Deadlock_%5c%28computer_science%5c%29" target="_blank">deadlock</a> during <code>wg.Wait</code>. This occurs, for example, if we add a <code>goroutine</code> to the <code>waitgroup</code> and never call <code>wg.Done</code>. The reverse of this problem is finishing more <code>goroutines</code> than were added to the waitgroup, which generates a <code>panic</code> with the message <code>panic: sync: negative WaitGroup counter</code>. However, this problem is intermittent, as the main process might finish before the <code>goroutine</code>. To avoid these cases, the <a href="https://github.com/uber-go/goleak" target="_blank">goleak</a> library implements a <code>goroutine</code> leak validator.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestCases</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>t</span><span>.</span><span>Run</span><span>(</span><span>&#34;Before1_25&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>defer</span> <span>goleak</span><span>.</span><span>VerifyNone</span><span>(</span><span>t</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>Before1_25</span><span>()</span>
</span></span><span><span>  <span>})</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Starting with Go version 1.25, everything changed, and our API became even simpler and free of these problems! Instead of manually having to control which <code>goroutines</code> were added and signal their end, we can simply use the new function <code>wg.Go</code>, which does this automatically.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>After1_25</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>r</span> <span>:=</span> <span>rand</span><span>.</span><span>IntN</span><span>(</span><span>10</span><span>)</span>
</span></span><span><span>  <span>wg</span> <span>:=</span> <span>sync</span><span>.</span><span>WaitGroup</span><span>{}</span>
</span></span><span><span>  <span>wg</span><span>.</span><span>Go</span><span>(</span><span>func</span><span>()</span> <span>{</span> <span>doSomethingTheNewWay</span><span>(</span><span>r</span><span>)</span> <span>})</span>
</span></span><span><span>  <span>wg</span><span>.</span><span>Wait</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>doSomethingTheNewWay</span><span>(</span><span>sleep</span> <span>int</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>time</span><span>.</span><span>Duration</span><span>(</span><span>sleep</span><span>)</span> <span>*</span> <span>time</span><span>.</span><span>Second</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Since this function accepts a <code>func()</code> as an argument, you need to wrap your function inside another one if you need to pass arguments. As the increment and decrement are now handled automatically, the problems mentioned above no longer exist, and it has indeed become even simpler to work concurrently.</p><p>Although it is not the focus of this post, I want to mention another improvement in this version of the language. Before version 1.25, if your application ran on Kubernetes, you needed to use a library like <a href="https://github.com/uber-go/automaxprocs" target="_blank">automaxprocs</a> to get a valid CPU value for <code>goroutines</code>. Now, this is done for us automatically. For those interested, I recommend reading the article <a href="https://go.dev/blog/container-aware-gomaxprocs" target="_blank">Container-aware GOMAXPROCS</a>.</p><p>In the next post, I want to explore more about the <code>sync</code> package and how we can use its other functionalities to manage concurrent work more simply. The examples are in this <a href="https://github.com/mfbmina/poc_waitgroups" target="_blank">repository</a>. Comment below what you thought of the post and the new features in Go 1.25!</p></article></div>
  </body>
</html>
