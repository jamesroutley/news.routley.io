<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.theregister.com/2024/02/09/it_incident_report_the_clock/">Original</a>
    <h1>Curious tale of broken VPNs, the Year 2038, and certs that expired 100 years ago</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
<p><span>Interview</span> Back in late 2010, &#34;Zimmie&#34; was working in IT support for a vendor that made VPN devices and an associated operating system. He got a call on a Monday from a customer – a large specialty retailer in the US – about its VPN hardware that had stopped working over the weekend.</p>
<p>After looking into the report, the problem appeared to be the result of a certificate validation failure, as he described in a recent <a target="_blank" rel="nofollow" href="https://infosec.exchange/@bob_zim/111862834586135218">post</a> on Mastodon.</p>
<p>&#34;My then-employer&#39;s VPN devices are managed by a central server,&#34; explained Zimmie to <em>The Register</em>. &#34;This server runs its own certificate authority (CA) which it uses to sign certificates for all the devices. The VPN endpoints then use these to authenticate to the management server (eg, when sending logs) and to each other (mostly for VPNs). The CA is a core part of the management software.&#34;</p>

    

<p>Zimmie told us he preferred not to publicly identify himself, the vendor, or its customer so as not to embarrass anyone. But he was okay with <em>The Register</em> recounting his tale.</p>

        


        

<p>Zimmie noted that the validation check had failed because the system couldn&#39;t check the certificate revocation list (CRL) – a list of digital certificates that have been revoked by the issuing authority.</p>
<blockquote>

<p>The software which handles the validation allocates 512 KiB of space to store the CRL, and it&#39;s too big? This CA is very lightly used, so it shouldn&#39;t be possible to hit the limit within a human lifespan</p>
</blockquote>
<p>&#34;These devices authenticated to each other with certificates much like the ones used for HTTPS, but signed by a private certificate authority (CA),&#34; he explained.</p>
<p>&#34;Each customer had their own CA for this. Part of the process of validating the certificates is asking the CA if the certificate has been revoked. The validation was failing because the VPN box couldn&#39;t download the certificate revocation list (CRL) to confirm the peer&#39;s certificate wasn&#39;t on it. Why couldn&#39;t it download the CRL?&#34;</p>
<p>Checking the VPN device&#39;s certificate operation log showed that the CRL was too big to be downloaded, he found.</p>

        

<p>&#34;The software which handles the validation allocates 512 KiB of space to store the CRL, and it&#39;s too big? This CA is very lightly used, so it shouldn&#39;t be possible to hit the limit within a human lifespan. What&#39;s going on with the CRL that it hit the limit so early?&#34;</p>
<p>A 2015 <a target="_blank" rel="nofollow" href="https://www.cs.umd.edu/~dml/papers/revocations_imc15.pdf">paper</a> [PDF] on certificate revocation published by University of Maryland researchers notes that the CRL size for the median certificate is 51KB and that half of all CRLs are under 900B.</p>
<p>This one was nearly 1MB, and Zimmie discovered the size was due to the CA repeatedly revoking and reissuing every certificate it signed once per second. The CRL had grown more than 250 KiB per day over the weekend which, he estimated, amounted to a century of growth in just a day.</p>

        

<p>&#34;Fortunately, the certificate authority had a certificate operation log,&#34; recounted Zimmie. &#34;This log records every time the CA revokes a certificate, signs a new one, or performs a few other operations. Looking at the most recent entries, I see the CA process woke up, decided the CA&#39;s own certificate is expired, then revoked and reissued every certificate it had signed. I look further back, and I see it did the same process one second earlier. And one second before that.&#34;</p>
<blockquote>

<p>It&#39;s not valid before 2037, and it&#39;s not valid after 1910? That means it&#39;s never valid. How did that happen?</p>
</blockquote>
<p>These digital <a target="_blank" rel="nofollow" href="https://datatracker.ietf.org/doc/html/rfc5280">certificates</a>, according to Zimmie, have two dates: notBefore, a date before which they&#39;re not valid; and notAfter, a date after which they&#39;re expired.</p>
<p>&#34;I look at the CA&#39;s certificate, and it says it&#39;s not valid after 1910,&#34; he wrote. &#34;Weird, but that at least explains why the CA is telling us its certificate is expired. But when it issues a replacement certificate for itself, the replacement expires in 1910, too. That&#39;s <em>extremely</em> weird. It should reissue the certificate with new dates.&#34;</p>
<p>Zimmie took note of the notBefore date. &#34;People rarely care about this date, because it&#39;s extremely rare to get certificates which aren&#39;t valid yet,&#34; he explained.</p>
<p>&#34;But this one isn&#39;t valid before some time in 2037. Wait, what? It&#39;s not valid before 2037, and it&#39;s not valid after 1910? That means it&#39;s never valid. How did that happen?&#34;</p>
<h3>Bad calculations</h3>
<p>Readers who deal with networking may already have some idea: Something is amiss with the time calculation.</p>
<p>&#34;Quite a while ago, the developers of UNIX decided to track time as a signed 32-bit counter of the number of seconds since midnight, January 1, 1970,&#34; explained Zimmie.</p>
<p>&#34;Linux kept this decision for compatibility. The &#39;signed&#39; part means the number can be negative, to allow time values before 1970 to be represented. Thirty-two bits is enough for a little under 4.3 billion seconds. The sign means you get about 2.1 billion seconds before 1970 and about 2.1 billion after. Two point one billion seconds is a little under 25,000 days, or a little over 68 years.&#34;</p>
<p>Sixty-eight years after 1970, Zimmie said, is 2038. Anyone who deals with UNIX time should recognize the year 2038, which has <a target="_blank" rel="nofollow" href="https://theyear2038problem.com/">its own website</a> warning of troubles ahead.</p>
<p>&#34;The latest time which can be represented like this is 03:14:07 UTC on January 19, 2038,&#34; said Zimmie. &#34;Once the timer is incremented from this second, the value &#39;overflows&#39; and goes from being a large positive number to being a large negative number. The next second this counter can represent is 20:45:52 UTC on December 13, 1901. This is called the Year 2038 Problem.&#34;</p>
<p>Noting that the certificate authority signs its own certificate to be valid for a ten-year period, Zimmie concluded it ran into the 2038 problem when calculating expiration dates. That suggested a bug in the date math library, or the code implementing that library. But that still left the question of why it was renewing certificates with the same dates.</p>
<p>Zimmie checked the CA&#39;s automatic renewal code and confirmed that it won&#39;t reissue the certificate with an earlier start date when it expires.</p>
<p>&#34;That makes sense under normal operation, but makes it impossible to recover from odd situations like the one my customer found himself in,&#34; he explained. &#34;Another bug. But why did it sign a certificate not valid before 2037 in the first place?&#34;</p>
<ul>

<li><a href="https://www.theregister.com/2023/12/22/on_call/">Superuser mostly helped IT, until a BSOD saw him invent a farcical fix</a></li>

<li><a href="https://www.theregister.com/2024/02/08/windows_11_sudo/">Microsoft embraces its inner penguin as sudo sneaks into Windows 11</a></li>

<li><a href="https://www.theregister.com/2024/01/16/retro_enterprise_administration/">Remember when enterprise administration was more than just a browser dashboard?</a></li>

<li><a href="https://www.theregister.com/2024/01/30/windows_311_trundles_on/">Windows 3.11 trundles on as job site pleads for &#39;driver updates&#39; on German trains</a></li>
</ul>
<p>After checking the lengthy CA operation log, he found a system date stamp in 2037 about the CA renewing itself.</p>
<p>&#34;Now the certificate starting in 2037 makes sense, except for the not-so-minor fact it&#39;s 2010, not 2037,&#34; he said. &#34;So why does the CA operation log have entries from 2037?&#34;</p>
<p>The customer, Zimmie recalled, reported that he didn&#39;t set the time to 2037. &#34;He&#39;s using NTP, though, and it&#39;s synchronizing with the time server every 120 seconds,&#34; he elaborated, referring to the Network Time Protocol, which is used to sync computer clocks to a network time signal.</p>
<p>&#34;I started looking through the NTP client logs. Most of the entries are from the client adjusting the clock a small fraction of a second forward or back. I filter out all the entries with adjustments starting with &#39;-0.&#39; or &#39;0.&#39;, and I find some much larger adjustments. Tens of thousands of seconds. Hundreds of thousands. Millions. I find one adjustment of around -4 billion seconds, then it&#39;s back to millions or hundreds of thousands of seconds at a time.&#34;</p>
<h3>Time travel</h3>
<p>According to Zimmie, the system believed that the NTP server had set the time to 2010, 2019, 2028, 2037, 1907, 1918, and so on until it cycled back to the present.</p>
<p>&#34;The NTP client in the OS is really bad, and it&#39;s clearly allowing time adjustments much larger than are reasonable,&#34; he lamented. &#34;The CA was running on an appliance OS provided by my employer, so we own the NTP client. Third bug of the day. At least now we know why the certificate authority thought it was 2037!&#34;</p>
<blockquote>

<p>The NTP client in the OS is really bad, and it&#39;s clearly allowing time adjustments much larger than are reasonable</p>
</blockquote>
<p>That still left the question of why the NTP client raced forward through the available timestamp space.</p>
<p>&#34;It happened again a few days later, and we got a packet capture proving it actually handed out the bogus timestamps,&#34; he explained. &#34;Unfortunately, the NTP server was an appliance from another vendor, so I can only speculate. I think it was a value type mistake in C.&#34;</p>
<p>Zimmie told us &#34;C has the concept of signed integers and unsigned integers, but the separation between them is extremely weak. You can tell the system to take this signed integer value and store it somewhere, then you can accidentally interpret it as an unsigned value later.</p>
<p>&#34;For positive integers, this doesn&#39;t matter. It becomes a problem with negative integers, though. For several reasons, they are stored in memory in what is called &#39;two&#39;s complement&#39; form. When you store the value -1 as a 32-bit signed integer, the representation in memory is 0xFFFFFFFF. If you then interpret that as an unsigned integer, you get the value 4,294,967,295.&#34;</p>
<p>According to Zimmie, the NTP server used a radio receiver to listen to an upstream time source.</p>
<p>&#34;These radios are commonly GPS receivers, but CDMA cell networks at the time also provided precise enough time information. I suspect the NTP server had a badly faulty internal clock which ran very fast. I also suspect it lost the radio signal for long enough for the internal clock to get at least one whole second ahead of the time acquired from the radio.</p>
<p>&#34;When it reacquired the radio signal, I think it subtracted the internal clock time from the radio time to find out how many seconds off it was. If I&#39;m right, it got a small negative number. I think it then treated this as an unsigned integer when figuring out how many seconds behind it is and the small negative number turned into a <em>HUGE</em> positive number. With that, it raced ahead 4.29 billion seconds as fast as it could.&#34;</p>
<p>&#34;In my experience, the most baffling behavior is almost always caused by very small mistakes,&#34; quipped Zimmie. &#34;This small mistake would explain the behavior.&#34;</p>
<p>Zimmie wrote in his post that recovery was difficult. &#34;Without the VPN connections working, they needed someone to physically go to around a hundred sites and get each one to trust the new CA,&#34; he explained. &#34;It also ended up happening a few times before everything could be fixed.&#34;</p>
<p><em>The Register</em> asked Zimmie why he believes this story has resonated with people who have seen it on social media.</p>
<p>&#34;People enjoy mysteries,&#34; he replied. &#34;We want to understand. I like telling that story because it illustrates how a simple problem can actually be bigger than you think, but big, weird problems can still be broken down and understood. I think that resonates with a lot of people.&#34;</p>
<p>It&#39;s also a bit of fun when you&#39;re actually solving the mystery.</p>
<p>&#34;I generally start troubleshooting an issue by asking the system what it is doing,&#34; explained Zimmie. &#34;Packet captures, poking through logs, and so on. After a few rounds of this, I start hypothesizing a reason, and testing my hypothesis. Basic scientific method stuff. Most are simple to check. When they&#39;re wrong, I just move on. As I start narrowing down the possibilities, and the hypotheses are proven, it&#39;s electric. Making an educated guess and proving it&#39;s right is incredibly satisfying.&#34;</p>
<p>Zimmie told <em>The Register</em> that NTP implementation problems like this are uncommon.</p>
<p>&#34;I think the closest thing I&#39;ve seen in the last ten years was that <a target="_blank" href="https://www.theregister.com/2021/10/19/gpsd_bug_reset/">gpsd bug</a> you wrote about in late 2021,&#34; he recalled. &#34;Of course, the nastiest bugs and implementation issues seem to wait to strike until we least expect it. I&#39;m definitely going to be on the lookout for NTP issues as we close in on 2038.&#34; ®</p>                                
                    </div></div>
  </body>
</html>
