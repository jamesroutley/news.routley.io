<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jviotti.com/2024/01/05/is-objective-c-bool-a-boolean-type-it-depends.html">Original</a>
    <h1>Is Objective-C BOOL a boolean type? It depends</h1>
    
    <div id="readability-page-1" class="page"><article>
        <header>
          
          <time datetime="2024-01-05">January 5,
2024</time>
          <hr/>

          <blockquote>
            <p>TL;DR: This article describes how the Objective-C
<code>BOOL</code> type is differently defined on Apple platforms, and
how these differences are defined in LLVM</p>
          </blockquote>
        </header>

        

        <p>The Objective-C programming language introduces its own type
        to represent boolean values: <a href="https://developer.apple.com/documentation/objectivec/bool"><code>BOOL</code></a>.
        The instances of this type are the constants <a href="https://developer.apple.com/documentation/objectivec/yes"><code>YES</code></a>
        and <a href="https://developer.apple.com/documentation/objectivec/no"><code>NO</code></a>.</p>
        <p>This is a simple example of invoking a function that takes a
        <code>BOOL</code> value as an argument:</p>
        <div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>void</span> print_boolean<span>(</span>BOOL value<span>)</span> <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span>value <span>?</span> <span>@&#34;True&#34;</span> <span>:</span> <span>@&#34;False&#34;</span><span>);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>print_boolean<span>(</span>YES<span>);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>print_boolean<span>(</span>NO<span>);</span></span></code></pre></div>
        <p>While <code>BOOL</code> might look trivial, its definition is
        rather complex. It depends on which Apple platform and
        architecture you are targeting, which can result in unexpected
        behavior.</p>
        <blockquote>
        <p>This article is based on Xcode 15.1 (15C65) running on macOS
        Sonoma 14.2.1 on a 2020 M1 MacBook Pro.</p>
        </blockquote>
        <h2 id="an-example-of-unexpected-behavior">An example of
        unexpected behavior</h2>
        <p>I write a lot of Objective-C++. A useful feature of C++ is <a href="https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170">function
        overloading</a>: the ability to define multiple functions with
        the same name that differ only on the type of arguments they
        accept. When you invoke such a function, the compiler will
        automatically determine which overload to call.</p>
        <p>Recently, I stumbled into a case where for the same code,
        macOS Intel and macOS Apple Silicon invoked different overloads.
        Here is a minimal reproducible Objective-C++ example of the
        issue:</p>
        <div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>// To locally run this example:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>// $ xcrun clang++ main.mm -o objc-bool-test</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>// $ ./objc-bool-test</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;objc/runtime.h&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;iostream&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;cstdlib&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span>void</span> print<span>(</span><span>bool</span> value<span>)</span> <span>{</span> std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;(bool) &#34;</span> <span>&lt;&lt;</span> value <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span> <span>}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span>void</span> print<span>(</span><span>int</span> value<span>)</span> <span>{</span> std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;(int) &#34;</span> <span>&lt;&lt;</span> value <span>&lt;&lt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span> <span>}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;YES: &#34;</span><span>;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  print<span>(</span>YES<span>);</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;NO: &#34;</span><span>;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  print<span>(</span>NO<span>);</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span>return</span> EXIT_SUCCESS<span>;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
        <p>On my Apple Silicon Mac (running Xcode 15.1), the above
        program invokes the <code>bool</code> overloads:</p>
        <pre><code>YES: (bool) 1
NO: (bool) 0</code></pre>
        <p>However, on my macOS Intel Mac (running Xcode 14.3.2), the
        above program invokes the <code>int</code> overloads:</p>
        <pre><code>YES: (int) 1
NO: (int) 0</code></pre>
        <h2 id="exploring-the-objective-c-runtime">Exploring the
        Objective-C runtime</h2>
        <p>This discrepancy between Apple Silicon and Intel is not
        clarified by the documentation, which appears to contradict
        itself to a certain degree. The <a href="https://developer.apple.com/documentation/objectivec/bool">documentation</a>
        states that the canonical definition for <code>BOOL</code> is a
        type alias to <code>bool</code>. However, under <em>Special
        Considerations</em>, the documentation states that <em>the type
        of <code>BOOL</code> is actually <code>char</code>.</em></p>
        <p>When documentation doesn’t help, we can take a look under the
        hood. The <code>BOOL</code> type is defined by the <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C</a>
        runtime, whose public headers are distributed by Xcode at the
        following directory:</p>
        <div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>$</span> ls <span>$(</span><span>xcode-select</span> <span>--print-path</span><span>)</span>/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/objc</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>List.h</span>               Protocol.h           objc-api.h           objc-runtime.h</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>NSObjCRuntime.h</span>      hashtable.h          objc-auto.h          objc-sync.h</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>NSObject.h</span>           hashtable2.h         objc-class.h         objc.h</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span>Object.h</span>             message.h            objc-exception.h     runtime.h</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>ObjectiveC.apinotes</span>  module.modulemap     objc-load.h</span></code></pre></div>
        <p>As we can confirm with a quick search, the header that is
        concerned with booleans is <code>objc.h</code>, which is
        included by <code>runtime.h</code>, the entry point of the
        Objective-C runtime.</p>
        <h3 id="the-yes-and-no-constants">The <code>YES</code> and
        <code>NO</code> constants</h3>
        <p>These boolean constants are defined in two ways:</p>
        <div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>// $(xcode-select --print-path)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/objc/objc.h</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>#if __has_feature(objc_bool)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>#define YES __objc_yes</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span>#define NO  __objc_no</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span>#else</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span>#define YES ((BOOL)1)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span>#define NO  ((BOOL)0)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>The <a href="https://clang.llvm.org/docs/LanguageExtensions.html#has-feature-and-has-extension"><code>__has_feature</code></a>
        macro is defined by LLVM as a language extension for
        introspecting on compiler features. While not standard, <a href="https://gcc.gnu.org/onlinedocs/cpp/_005f_005fhas_005ffeature.html">GCC
        also supports <code>__has_feature</code></a>. However, the
        <code>objc_bool</code> feature that the Objective-C runtime
        header references is never defined by LLVM. Therefore, the
        definition we are interested in is the second one:</p>
        <div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>#define YES ((BOOL)1)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>#define NO  ((BOOL)0)</span></span></code></pre></div>
        <p>If you are curious, the <code>__objc_yes</code> and
        <code>__objc_no</code> symbols in the first clause of the
        definition are built-in types <a href="https://github.com/llvm/llvm-project/blob/llvmorg-17.0.6/clang/lib/Parse/ParseObjc.cpp#L2880-L2885">recognized
        by the LLVM parser</a> and are available for use. For example,
        this program is valid:</p>
        <div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>void</span> print_boolean<span>(</span>BOOL value<span>)</span> <span>{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span>value <span>?</span> <span>@&#34;True&#34;</span> <span>:</span> <span>@&#34;False&#34;</span><span>);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>print_boolean<span>(</span>__objc_yes<span>);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>print_boolean<span>(</span>__objc_no<span>);</span></span></code></pre></div>
        <h3 id="the-bool-type-alias">The <code>BOOL</code> type
        alias</h3>
        <p>Now that we know that <code>YES</code> and <code>NO</code>
        are defined by casting the numeric constants <code>1</code> and
        <code>0</code> to <code>BOOL</code>, let’s turn our attention to
        the <code>BOOL</code> type. This type alias is defined in the
        <code>objc.h</code> header as follows:</p>
        <div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>// $(xcode-select --print-path)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/objc/objc.h</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>#if OBJC_BOOL_IS_BOOL</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span>typedef</span> bool BOOL<span>;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>#else</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>#   define OBJC_BOOL_IS_CHAR 1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span>typedef</span> <span>signed</span> <span>char</span> BOOL<span>;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span>// BOOL is explicitly signed so @encode(BOOL) == &#34;c&#34; rather than &#34;C&#34;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span>// even if -funsigned-char is used.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>As we can see, the <code>BOOL</code> type is either an alias
        to <code>bool</code> or an alias to <code>signed char</code>
        depending on the value of the <code>OBJC_BOOL_IS_BOOL</code>
        preprocessor define. Additionally, the Objective-C runtime will
        define <code>OBJC_BOOL_IS_CHAR</code> if <code>BOOL</code> is
        set to the latter. This definition is convenient for writing
        code that must make assumptions over the underlying
        <code>BOOL</code> type. For example:</p>
        <div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>#import </span><span>&lt;Foundation/Foundation.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>#if OBJC_BOOL_IS_CHAR</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span><span>@&#34;My BOOL is a signed char&#34;</span><span>);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>#else</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span><span>@&#34;My BOOL is a bool&#34;</span><span>);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span>return</span> EXIT_SUCCESS<span>;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
        <h3 id="the-objc_bool_is_bool-definition">The
        <code>OBJC_BOOL_IS_BOOL</code> definition</h3>
        <p>We learnt that whether <code>BOOL</code> is a type alias to
        <code>bool</code> or to <code>signed char</code> depends on the
        value of the <code>OBJC_BOOL_IS_BOOL</code> preprocessor
        definition. Like the other constants and aliases we explored so
        far, this definition is also declared in the <code>objc.h</code>
        header:</p>
        <div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>// $(xcode-select --print-path)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/objc/objc.h</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>#if defined(__OBJC_BOOL_IS_BOOL)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span>// Honor __OBJC_BOOL_IS_BOOL when available.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>#   if __OBJC_BOOL_IS_BOOL</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>#       define OBJC_BOOL_IS_BOOL 1</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span>#   else</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span>#       define OBJC_BOOL_IS_BOOL 0</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span>#   endif</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span>#else</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span>// __OBJC_BOOL_IS_BOOL not set.</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span>#   if TARGET_OS_OSX || TARGET_OS_MACCATALYST || ((TARGET_OS_IOS || 0) &amp;&amp; !__LP64__ &amp;&amp; !__ARM_ARCH_7K)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>#      define OBJC_BOOL_IS_BOOL 0</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span>#   else</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span>#      define OBJC_BOOL_IS_BOOL 1</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span>#   endif</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>The first clause is straightforward: if the
        <code>__OBJC_BOOL_IS_BOOL</code> preprocessor definition exists,
        set <code>OBJC_BOOL_IS_BOOL</code> to it.</p>
        <p>However, the second clause is a lot more involved. The code
        says that the Objective-C runtime aliases <code>BOOL</code> to
        <code>signed char</code> in one of the following conditions:</p>
        <ul>
        <li>If you are writing a macOS application
        (<code>TARGET_OS_OSX</code>), independently of the target
        architecture</li>
        <li>If you are writing a <a href="https://developer.apple.com/mac-catalyst/">Mac
        Catalyst</a> application
        (<code>TARGET_OS_MACCATALYST</code>)</li>
        <li>If you are writing an iOS application
        (<code>TARGET_OS_IOS</code>) that does not make use of the <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">LP64
        data model</a> (<code>__LP64__</code>) and is not an ARMv7 chip
        (<a href="https://opensource.apple.com/source/xnu/xnu-4570.1.46/osfmk/arm/arch.h.auto.html"><code>__ARM_ARCH_7K</code></a>)</li>
        </ul>
        <p>We can deduct that the second clause does not apply here,
        given we see a discrepancy on how <code>BOOL</code> is defined
        in macOS Intel and macOS Apple Silicon. Otherwise both
        architectures would alias <code>BOOL</code> to
        <code>signed char</code> given the presence of
        <code>TARGET_OS_OSX</code>. Therefore, we can conclude that
        <code>__OBJC_BOOL_IS_BOOL</code> is always set, which we can
        confirm with the following simple program:</p>
        <div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>// main.m</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>#import </span><span>&lt;Foundation/Foundation.h&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span>#if defined(__OBJC_BOOL_IS_BOOL)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span><span>@&#34;__OBJC_BOOL_IS_BOOL is %i&#34;</span><span>,</span> __OBJC_BOOL_IS_BOOL<span>);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span>#else</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  NSLog<span>(</span><span>@&#34;__OBJC_BOOL_IS_BOOL is not defined&#34;</span><span>);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span>return</span> EXIT_SUCCESS<span>;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
        <p>As expected, <code>__OBJC_BOOL_IS_BOOL</code> is defined on
        both my Apple Silicon Mac and my Intel Mac as 1 and 0,
        respectively. Additionally, <a href="https://github.com/apple-oss-distributions/objc4/blob/objc4-906.2/test/bool.c#L23-L25">there
        is a test</a> in the <a href="https://github.com/apple-oss-distributions/objc4">Objective-C
        runtime source code</a> that asserts that
        <code>__OBJC_BOOL_IS_BOOL</code> is always defined:</p>
        <div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>// https://github.com/apple-oss-distributions/objc4/blob/objc4-906.2/test/bool.c</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>#if __OBJC__ &amp;&amp; !defined(__OBJC_BOOL_IS_BOOL)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span>#   error no __OBJC_BOOL_IS_BOOL</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span>#endif</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <h2 id="fiddling-with-__objc_bool_is_bool">Fiddling with
        <code>__OBJC_BOOL_IS_BOOL</code></h2>
        <p>Now that we know that <code>__OBJC_BOOL_IS_BOOL</code> is the
        preprocessor define that ultimately controls the underlying type
        of the <code>BOOL</code> alias, we can try to control it.</p>
        <blockquote>
        <p>I’m doing it here for experimentation purposes, but I highly
        discourage changing the <code>__OBJC_BOOL_IS_BOOL</code>
        definition (mainly on production code!), as we don’t know how
        deep its implications can be to frameworks that depends on the
        Objective-C runtime. There are probably good reasons why Apple
        sets different aliases for different platforms and
        architectures. Instead, if you need to introspect on
        <code>BOOL</code>, probably better to make use of the
        <code>OBJC_BOOL_IS_CHAR</code> definition we discussed
        before.</p>
        </blockquote>
        <p>On my Apple Silicon Mac, I can successfully build and run the
        Objective-C++ <a href="#an-example-of-unexpected-behavior"><em>unexpected
        behavior</em> example</a> from the beginning of this article,
        forcing the Objective-C runtime to alias <code>BOOL</code> to
        <code>signed char</code> by explicitly setting
        <code>__OBJC_BOOL_IS_BOOL</code> to <code>0</code>:</p>
        <div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>$</span> xcrun clang++ main.mm <span>-o</span> force-signed-char <span>-D__OBJC_BOOL_IS_BOOL</span><span>=</span>0</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>In</span> file included from <span>&lt;</span>built-in<span>&gt;</span>:444:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>&lt;</span>command <span>line</span><span>&gt;</span>:1:9: warning: <span>&#39;__OBJC_BOOL_IS_BOOL&#39;</span> macro redefined [-Wmacro-redefined]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span>#define __OBJC_BOOL_IS_BOOL 0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span>^</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>&lt;</span>built-in<span>&gt;</span>:34:9: <span>note:</span> previous definition is here</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span>#define __OBJC_BOOL_IS_BOOL 1</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span>^</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span>1</span> warning generated.</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span>$</span> ./force-signed-char</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span>YES:</span> <span>(</span><span>int</span><span>)</span> <span>1</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span>NO:</span> <span>(</span><span>int</span><span>)</span> <span>0</span></span></code></pre></div>
        <p>While it worked and we managed to affect the alias, let’s
        take a close look at the compilation warning. The compiler is
        warning us that we are overwriting
        <code>__OBJC_BOOL_IS_BOOL</code>, which was (as we expected for
        Apple Silicon) previously defined like this:</p>
        <div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>#define __OBJC_BOOL_IS_BOOL 1</span></span></code></pre></div>
        <p>However, this definition is not coming from the Objective-C
        runtime nor any other header. Instead, its coming directly from
        LLVM, as signified by the source location that the compiler is
        sharing with us:</p>
        <pre><code>&lt;built-in&gt;:34:9</code></pre>
        <p>Using <code>grep(1)</code>, we can confirm that the
        Objective-C runtime public headers never declare (only consume)
        the <code>__OBJC_BOOL_IS_BOOL</code> definition:</p>
        <div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>$</span> cd <span>$(</span><span>xcode-select</span> <span>--print-path</span><span>)</span>/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>$</span> grep <span>--recursive</span> <span>&#39;__OBJC_BOOL_IS_BOOL&#39;</span> usr/include/objc</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>usr/include/objc/objc.h:#if</span> defined<span>(</span><span>__OBJC_BOOL_IS_BOOL</span><span>)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span>usr/include/objc/objc.h:</span>    // Honor __OBJC_BOOL_IS_BOOL when available.</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span>usr/include/objc/objc.h:#</span>   if __OBJC_BOOL_IS_BOOL</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>usr/include/objc/objc.h:</span>    // __OBJC_BOOL_IS_BOOL not set.</span></code></pre></div>
        <h2 id="digging-deeper-into-llvm">Digging deeper into LLVM</h2>
        <p>To find the mysterious <code>__OBJC_BOOL_IS_BOOL</code>
        definition, let’s dig into LLVM. On my main machine, I’m running
        AppleClang 1500.1.0.2.5 (Xcode 15.1), which <a href="https://en.wikipedia.org/wiki/Xcode">corresponds to LLVM
        16</a>. By searching for occurrences of
        <code>__OBJC_BOOL_IS_BOOL</code> in such LLVM version, we can
        find that <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/InitPreprocessor.cpp"><code>clang/lib/Frontend/InitPreprocessor.cpp</code></a>
        sets <code>__OBJC_BOOL_IS_BOOL</code> based on a method called
        <code>useSignedCharForObjCBool</code>:</p>
        <div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/InitPreprocessor.cpp#L859-L862</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>// Define a macro that describes the Objective-C boolean type even for C</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span>// and C++ since BOOL can be used from non Objective-C code.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>Builder<span>.</span>defineMacro<span>(</span><span>&#34;__OBJC_BOOL_IS_BOOL&#34;</span><span>,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                    Twine<span>(</span>TI<span>.</span>useSignedCharForObjCBool<span>()</span> <span>?</span> <span>&#34;0&#34;</span> <span>:</span> <span>&#34;1&#34;</span><span>));</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>In turn, the <code>useSignedCharForObjCBool</code> method of
        the <code>TargetInfo</code> class is defined in <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/include/clang/Basic/TargetInfo.h"><code>clang/include/clang/Basic/TargetInfo.h</code></a>
        to simply return the <code>UseSignedCharForObjCBool</code>
        boolean class member:</p>
        <div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/include/clang/Basic/TargetInfo.h#L848-L855</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>/// Check if the Objective-C built-in boolean type should be signed</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span>/// char.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span>///</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span>/// Otherwise, if this returns false, the normal built-in boolean type</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span>/// should also be used for Objective-C.</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span>bool</span> useSignedCharForObjCBool<span>()</span> <span>const</span> <span>{</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span>return</span> UseSignedCharForObjCBool<span>;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>By default, the <code>UseSignedCharForObjCBool</code> boolean
        class member is set to <code>true</code>:</p>
        <div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Basic/TargetInfo.cpp#L135</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>TargetInfo<span>::</span>TargetInfo<span>(</span><span>const</span> llvm<span>::</span>Triple <span>&amp;</span>T<span>)</span> <span>:</span> Triple<span>(</span>T<span>)</span> <span>{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  UseSignedCharForObjCBool <span>=</span> <span>true</span><span>;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <h3 id="the-objective-c-to-c-re-writer">The Objective-C to C++
        re-writer</h3>
        <p>There is a single method in the <code>TargetInfo</code> class
        that directly affects the value of the
        <code>UseSignedCharForObjCBool</code> boolean class member. This
        method is called <code>noSignedCharForObjCBool</code>, and as
        its name implies, sets <code>UseSignedCharForObjCBool</code> to
        <code>false</code>. Its definition looks like this:</p>
        <div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/include/clang/Basic/TargetInfo.h#L856-L858</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span>void</span> noSignedCharForObjCBool<span>()</span> <span>{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  UseSignedCharForObjCBool <span>=</span> <span>false</span><span>;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>Interestingly enough, the only place where this method is
        invoked is in <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/CompilerInstance.cpp"><code>clang/lib/Frontend/CompilerInstance.cpp</code></a>,
        to unconditionally alias <code>BOOL</code> to <code>bool</code>
        on the Objective-C to C++ re-writer that we extensively covered
        in a <a href="https://www.jviotti.com/2023/12/01/understanding-objective-c-by-transpiling-it-to-cpp.html">previous
        post</a>:</p>
        <div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/CompilerInstance.cpp#L1023-L1025</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span>// rewriter project will change target built-in bool type from its default.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>getFrontendOpts<span>().</span>ProgramAction <span>==</span> frontend<span>::</span>RewriteObjC<span>)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  getTarget<span>().</span>noSignedCharForObjCBool<span>();</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>If you are curious, you can read <a href="https://github.com/llvm/llvm-project/commit/29898f45657314c7fa7f61e8157a36c832015fcc">the
        LLVM commit</a> that initially introduced the
        <code>noSignedCharForObjCBool</code> method and opted for the
        native <code>bool</code> type in the Objective-C to C++
        re-writer.</p>
        <h3 id="the-objective-c-compiler">The Objective-C compiler</h3>
        <p>Leaving the Objective-C experimental C++ re-writer aside, the
        supported targets of the production-ready Objective-C compiler
        set the <code>UseSignedCharForObjCBool</code> boolean class
        member when subclassing from <code>TargetInfo</code>.</p>
        <p>We can use <code>grep(1)</code> to find every target subclass
        that mentions <code>UseSignedCharForObjCBool</code> as
        follows:</p>
        <div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>$</span> grep <span>--recursive</span> <span>&#39;UseSignedCharForObjCBool&#39;</span> clang/lib/Basic/Targets <span>|</span> <span>uniq</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span>clang/lib/Basic/Targets/AArch64.cpp:</span>  UseSignedCharForObjCBool = false<span>;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span>clang/lib/Basic/Targets/X86.h:</span>      UseSignedCharForObjCBool = false<span>;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span>clang/lib/Basic/Targets/ARM.cpp:</span>    UseSignedCharForObjCBool = false<span>;</span></span></code></pre></div>
        <p>Let’s take a closer look at each of these matches.</p>
        <h4 id="aarch64"><code>AArch64</code></h4>
        <p>The AArch64 target corresponds to 64-bit ARM chips, such as
        Apple Silicon. For this target,
        <code>UseSignedCharForObjCBool</code> is unconditionally set to
        <code>false</code>, so the <code>__OBJC_BOOL_IS_BOOL</code>
        preprocessor define is always <code>1</code>:</p>
        <div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Basic/Targets/AArch64.cpp#L1432</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>DarwinAArch64TargetInfo<span>::</span>DarwinAArch64TargetInfo<span>(</span><span>const</span> llvm<span>::</span>Triple <span>&amp;</span>Triple<span>,</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                                                 <span>const</span> TargetOptions <span>&amp;</span>Opts<span>)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span>:</span> DarwinTargetInfo<span>&lt;</span>AArch64leTargetInfo<span>&gt;(</span>Triple<span>,</span> Opts<span>)</span> <span>{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  UseSignedCharForObjCBool <span>=</span> <span>false</span><span>;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>As expected, this matches the behavior we saw at the
        beginning of the article: for Apple Silicon Macs, the
        Objective-C runtime aliases <code>BOOL</code> to
        <code>bool</code>.</p>
        <h4 id="x86"><code>X86</code></h4>
        <p>For 32-bit Intel chips, <code>BOOL</code> is always an alias
        to <code>signed char</code> except for watchOS. For its first 8
        versions (until 2022), watchOS shipped with <a href="https://en.wikipedia.org/wiki/WatchOS#watchOS_8">32-bit
        support</a>, so this configuration is for old watchOS simulators
        running on Intel Macs:</p>
        <div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Basic/Targets/X86.h#L533-L536</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>DarwinI386TargetInfo<span>(</span><span>const</span> llvm<span>::</span>Triple <span>&amp;</span>Triple<span>,</span> <span>const</span> TargetOptions <span>&amp;</span>Opts<span>)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span>:</span> DarwinTargetInfo<span>&lt;</span>X86_32TargetInfo<span>&gt;(</span>Triple<span>,</span> Opts<span>)</span> <span>{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span>// The watchOS simulator uses the builtin bool type for Objective-C.</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  llvm<span>::</span>Triple T <span>=</span> llvm<span>::</span>Triple<span>(</span>Triple<span>);</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>T<span>.</span>isWatchOS<span>())</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    UseSignedCharForObjCBool <span>=</span> <span>false</span><span>;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>For 64-bit Intel chips, <code>BOOL</code> is always an alias
        to <code>signed char</code> except for iOS. As the comment
        clarifies, this configuration is for iOS simulators running on
        Intel Macs:</p>
        <div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Basic/Targets/X86.h#L915-L918</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>DarwinX86_64TargetInfo<span>(</span><span>const</span> llvm<span>::</span>Triple <span>&amp;</span>Triple<span>,</span> <span>const</span> TargetOptions <span>&amp;</span>Opts<span>)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span>:</span> DarwinTargetInfo<span>&lt;</span>X86_64TargetInfo<span>&gt;(</span>Triple<span>,</span> Opts<span>)</span> <span>{</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span>// The 64-bit iOS simulator uses the builtin bool type for Objective-C.</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  llvm<span>::</span>Triple T <span>=</span> llvm<span>::</span>Triple<span>(</span>Triple<span>);</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>T<span>.</span>isiOS<span>())</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    UseSignedCharForObjCBool <span>=</span> <span>false</span><span>;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>As expected, this matches the behavior we saw at the
        beginning of the article: for Intel Macs, the Objective-C
        runtime aliases <code>BOOL</code> to
        <code>signed char</code>.</p>
        <h4 id="arm"><code>ARM</code></h4>
        <p>Finally, for 32-bit ARM chips, <code>BOOL</code> is always an
        alias to <code>signed char</code> except for watchOS. The
        watchOS product always targeted ARM, so this configuration is
        likely for production watchOS deployments until version 8 (after
        which 32-bit support was removed):</p>
        <div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>// See https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Basic/Targets/ARM.cpp#L1412-L1417</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>DarwinARMTargetInfo<span>::</span>DarwinARMTargetInfo<span>(</span><span>const</span> llvm<span>::</span>Triple <span>&amp;</span>Triple<span>,</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>                                         <span>const</span> TargetOptions <span>&amp;</span>Opts<span>)</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span>:</span> DarwinTargetInfo<span>&lt;</span>ARMleTargetInfo<span>&gt;(</span>Triple<span>,</span> Opts<span>)</span> <span>{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>Triple<span>.</span>isWatchABI<span>())</span> <span>{</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span>...</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span>// BOOL should be a real boolean on the new ABI</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    UseSignedCharForObjCBool <span>=</span> <span>false</span><span>;</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span>...</span></span></code></pre></div>
        <p>If you are looking for a higher-level view, the test suite of
        the Objective-C runtime has an <a href="https://github.com/apple-oss-distributions/objc4/blob/objc4-906.2/test/bool.c#L7-L21">interesting
        case</a> for determining whether the “real” boolean type should
        apply or not on the platform under test.</p>
        <h2 id="summary">Summary</h2>
        <p>If you made it this far, you might be wondering how
        <code>BOOL</code> grew so complicated. While we cannot tell for
        sure without Apple insider’s knowledge, I believe the reasons
        are historical.</p>
        <p>Back in 1984, Objective-C was designed to be a strict
        superset of the C language. At the time, the C language didn’t
        have built-in support for booleans, and Objective-C’s decision
        of re-purposing <code>signed char</code> to hold boolean values
        was sensible. You can see an ancient definition of
        <code>BOOL</code> that is unconditionally aliased to
        <code>signed char</code> <a href="https://opensource.apple.com/source/objc4/objc4-237/runtime/objc.h.auto.html">here</a>.</p>
        <p>More than a decade later, as part of the C99 specification,
        the C language released support for boolean values through the
        <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdbool.h.html"><code>&lt;stdbool.h&gt;</code></a>
        header. Then, later versions of the Objective-C runtime started
        conditionally aliasing <code>BOOL</code> to the new
        <code>bool</code> type in modern Apple products. It is likely
        that older platform and architecture combinations still use
        <code>signed char</code> for legacy reasons.</p>
        <blockquote>
        <p>If you want to continue learning about the curiosities of the
        <code>BOOL</code> type, you might also enjoy <a href="https://bignerdranch.com/blog/bools-sharp-corners/">BOOL’s
        sharp corners</a> by the Big Nerd Ranch, and Google’s <a href="https://google.github.io/styleguide/objcguide.html#bool-pitfalls">Objective-C
        Styleguide</a>.</p>
        </blockquote>
        <p><strong>HN Discussion</strong>: <a href="https://news.ycombinator.com/item?id=38909377">https://news.ycombinator.com/item?id=38909377</a>.</p>
      </article></div>
  </body>
</html>
