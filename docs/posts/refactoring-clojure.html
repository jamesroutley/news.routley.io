<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.orsolabs.com/post/refactoring-clojure-1/">Original</a>
    <h1>Refactoring Clojure</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<p>This article is based on <a href="https://adambard.com/blog/write-friendlier-clojure/">Writing Friendlier Clojure</a> by <a href="https://adambard.com/">Adam Bard</a>, where he shows his approach at refactoring some Clojure code that implements an order-1 word-level <a href="https://web.archive.org/web/20080512091003/http://www.cs.bell-labs.com/cm/cs/pearls/sec153.html">Markov text generator</a>.</p>
<p>Our mission is to take this code and make it readable:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>markov-data</span> [<span>text</span>]
</span></span><span><span>  (<span>let </span>[<span>maps</span>
</span></span><span><span>        (<span>for </span>[<span>line</span> (<span>clojure.string/split</span> <span>text</span> #<span>&#34;\.&#34;</span>)
</span></span><span><span>              <span>m</span> (<span>let </span>[<span>l</span> (<span>str </span><span>line</span> <span>&#34;.&#34;</span>)
</span></span><span><span>                      <span>words</span>
</span></span><span><span>                      (<span>cons </span><span>:start</span> (<span>clojure.string/split</span> <span>l</span> #<span>&#34;\s+&#34;</span>))]
</span></span><span><span>                  (<span>for </span>[<span>p</span> (<span>partition</span> <span>2</span> <span>1</span> (<span>remove </span>#(<span>= </span><span>&#34;&#34;</span> <span>%</span>) <span>words</span>))]
</span></span><span><span>                    {(<span>first </span><span>p</span>) [(<span>second </span><span>p</span>)]}))]
</span></span><span><span>          <span>m</span>)]
</span></span><span><span>    (<span>apply merge-with concat </span><span>maps</span>)))
</span></span><span><span>
</span></span><span><span>(<span>defn </span><span>sentence</span> [<span>data</span>]
</span></span><span><span>  (<span>loop </span>[<span>ws</span> (<span>data</span> <span>:start</span>)
</span></span><span><span>         <span>acc</span> []]
</span></span><span><span>    (<span>let </span>[<span>w</span> (<span>rand-nth</span> <span>ws</span>)
</span></span><span><span>          <span>nws</span> (<span>data</span> <span>w</span>)
</span></span><span><span>          <span>nacc</span> (<span>concat </span><span>acc</span> [<span>w</span>])]
</span></span><span><span>      (<span>if </span>(<span>= </span><span>\.</span> (<span>last </span><span>w</span>))
</span></span><span><span>        (<span>clojure.string/join</span> <span>&#34; &#34;</span> <span>nacc</span>)
</span></span><span><span>        (<span>recur</span> <span>nws</span> <span>nacc</span>)))))
</span></span></code></pre></div><p>After playing a bit with it in the REPL to get a feeling of what is going on and of the shape of the data structure involved, we can start thinking how to refactor.</p>
<p>Remember that <em>refactoring</em> means changing the code <em>without</em> changing its behavior, so to know that we are not changing the behavior we need tests. Since the code exists already, we need  <a href="https://michaelfeathers.silvrback.com/characterization-testing">characterization tests</a>, well explained in the book <em><a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a></em> by Michael Feathers.</p>
<p>The following tests characterize the function <code>markov-data</code>:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>deftest</span> <span>markov-of-empty-string</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;.&#34;</span>]} (<span>markov/markov-data</span> <span>&#34;&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-one-word-with-stop</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A.&#34;</span>]} (<span>markov/markov-data</span> <span>&#34;A.&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-one-word-without-stop</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A.&#34;</span>]} (<span>markov/markov-data</span> <span>&#34;A&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-two-words</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A&#34;</span>], <span>&#34;A&#34;</span> [<span>&#34;B.&#34;</span>]} (<span>markov/markov-data</span> <span>&#34;A B.&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-two-1-word-sentences</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A.&#34;</span> <span>&#34;B.&#34;</span>]} (<span>markov/markov-data</span> <span>&#34;A. B.&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-two-2-word-sentences</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A&#34;</span> <span>&#34;C&#34;</span>], <span>&#34;A&#34;</span> [<span>&#34;B.&#34;</span>], <span>&#34;C&#34;</span> [<span>&#34;D.&#34;</span>]}
</span></span><span><span>         (<span>markov/markov-data</span> <span>&#34;A B. C D.&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-two-sentences-with-repetition</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A&#34;</span> <span>&#34;A&#34;</span>], <span>&#34;A&#34;</span> [<span>&#34;B.&#34;</span> <span>&#34;B&#34;</span>], <span>&#34;B&#34;</span> [<span>&#34;C.&#34;</span>]}
</span></span><span><span>         (<span>markov/markov-data</span> <span>&#34;A B. A B C&#34;</span>))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>markov-of-four-words-with-repetition</span>
</span></span><span><span>  (<span>is</span> (<span>= </span>{<span>:start</span> [<span>&#34;A&#34;</span>], <span>&#34;A&#34;</span> [<span>&#34;B&#34;</span> <span>&#34;B.&#34;</span>], <span>&#34;B&#34;</span> [<span>&#34;A&#34;</span>]}
</span></span><span><span>         (<span>markov/markov-data</span> <span>&#34;A B A B.&#34;</span>))))
</span></span></code></pre></div><p>From the REPL and the tests we see that function <code>markov-data</code> takes a string and returns a hash map whose keys are the words in the string and whose values are sequences of the words just after the key, implementing an  <a href="https://web.archive.org/web/20080512091003/http://www.cs.bell-labs.com/cm/cs/pearls/sec153.html">order-1 word-level Markov process</a>. In addition the special key <code>:start</code> represents all the words that start a sentence.</p>
<p>Letâ€™s look at the original code again:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>markov-data</span> [<span>text</span>]
</span></span><span><span>  (<span>let </span>[<span>maps</span>
</span></span><span><span>        (<span>for </span>[<span>line</span> (<span>clojure.string/split</span> <span>text</span> #<span>&#34;\.&#34;</span>)
</span></span><span><span>              <span>m</span> (<span>let </span>[<span>l</span> (<span>str </span><span>line</span> <span>&#34;.&#34;</span>)
</span></span><span><span>                      <span>words</span>
</span></span><span><span>                      (<span>cons </span><span>:start</span> (<span>clojure.string/split</span> <span>l</span> #<span>&#34;\s+&#34;</span>))]
</span></span><span><span>                  (<span>for </span>[<span>p</span> (<span>partition</span> <span>2</span> <span>1</span> (<span>remove </span>#(<span>= </span><span>&#34;&#34;</span> <span>%</span>) <span>words</span>))]
</span></span><span><span>                    {(<span>first </span><span>p</span>) [(<span>second </span><span>p</span>)]}))]
</span></span><span><span>          <span>m</span>)]
</span></span><span><span>    (<span>apply merge-with concat </span><span>maps</span>)))
</span></span></code></pre></div><p>It seems easier to start from scratch as opposed to refactor it. The characterization tests above will help ensuring that the returned hash map stays the same.</p>
<p>We notice that the input string <code>text</code> is made of one or more <em>sentences</em>, where a sentence is a sequence of words terminated by a full stop character (<code>.</code>). As such, we can start by writing a function to process only one sentence.</p>
<p>We take the sentence, we split it in words and we consume one word after the other, updating the hash map as we go. This calls for a <code>reduce</code>. The trick is to realize that the function passed to <code>reduce</code> is not really limited to two arguments (first the accumulator and second the element of the collection), because the accumulator can be a vector and we can do destructuring:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>process-sentence</span> [<span>data</span> <span>sentence</span>]
</span></span><span><span>  (<span>let </span>[[<span>data</span> <span>_</span>]                                                                   <span>; &lt;1&gt;</span>
</span></span><span><span>        (<span>reduce </span>(<span>fn </span>[[<span>data</span> <span>key</span>] <span>word</span>]                                              <span>; &lt;2&gt;</span>
</span></span><span><span>                    [(<span>update</span> <span>data</span> <span>key </span>(<span>fn </span>[<span>val</span>] (<span>if </span><span>val </span>(<span>conj val </span><span>word</span>) [<span>word</span>])))  <span>; &lt;3&gt;</span>
</span></span><span><span>                     <span>word</span>])                                                        <span>; &lt;4&gt;</span>
</span></span><span><span>                [<span>data</span> <span>:start</span>]
</span></span><span><span>                (<span>string/split</span> (<span>string/trim</span> <span>sentence</span>) #<span>&#34;\s+&#34;</span>))]
</span></span><span><span>    <span>data</span>))                                                                         <span>; &lt;5&gt;</span>
</span></span></code></pre></div><ul>
<li><strong>&lt;2&gt;</strong> The function passed to <code>reduce</code> takes as arguments <code>[[data key] word]</code>, where the vector <code>[data key]</code> contains both the real accumulator (the hash map <code>data</code>) and the word <code>key</code>.</li>
<li><strong>&lt;3&gt;</strong> Everything is done here, with <code>update</code>. The <code>if</code> is needed to differentiate when the hash map doesnâ€™t have key <code>key</code> (deduced because <code>val</code> is <code>nil</code>).</li>
<li><strong>&lt;3&gt;,&lt;4&gt;</strong> Construct the return value of the function, which is the vector <code>[updated-data word]</code>, where <code>updated-data</code> is the updated hash map and <code>word</code> is the element of the collection, that will be used on the next call of the function as the hash map key.</li>
<li><strong>&lt;1&gt;</strong> The <code>let</code> is needed to deconstruct the last return of the function, extract the hash map and return only it at <strong>&lt;5&gt;</strong>.</li>
</ul>
<p>Now that we have a function able to process a single sentence, we can go back to <code>markov-data</code> and realize that we can use <code>reduce</code> again, this time passing to it <code>process-sentence</code> and splitting the input string <code>text</code> on the boundaries of the full stop character:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>markov-data</span> [<span>text</span>]
</span></span><span><span>  (<span>let </span>[<span>data</span> (<span>-&gt;&gt;</span> (<span>string/split</span> <span>text</span> #<span>&#34;\.&#34;</span>)
</span></span><span><span>                  (<span>filter </span>(<span>complement </span><span>string/blank?</span>))
</span></span><span><span>                  (<span>map </span>#(<span>str </span><span>%</span> <span>&#34;.&#34;</span>))                        <span>; &lt;1&gt;</span>
</span></span><span><span>                  (<span>reduce </span><span>process-sentence</span> {}))]
</span></span><span><span>    (<span>if </span>(<span>empty?</span> <span>data</span>)
</span></span><span><span>      {<span>:start</span> [<span>&#34;.&#34;</span>]}                                        <span>; &lt;2&gt;</span>
</span></span><span><span>      <span>data</span>)))
</span></span></code></pre></div><ul>
<li><strong>&lt;1&gt;</strong> We add a full stop character to each sentence. This is visible also in the characterization tests. The reason is because the full stop character is the termination condition for the other function <code>sentence</code>, as we will see.</li>
<li><strong>&lt;2&gt;</strong> Again we make sure that the hash map contains at least one full stop character.</li>
</ul>
<p>Now it is the turn of function <code>sentence</code>, for which we could expect difficulties in testing, since it involves randomness.</p>
<p>The first 3 characterization tests are simple, no randomness involved:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>deftest</span> <span>sentence-of-empty-string-is-the-dot</span>
</span></span><span><span>  (<span>is</span> (<span>= </span><span>&#34;.&#34;</span> (<span>markov/sentence</span> (<span>markov/markov-data</span> <span>&#34;&#34;</span>)))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>sentence-of-one-word-is-itself</span>
</span></span><span><span>  (<span>is</span> (<span>= </span><span>&#34;A.&#34;</span> (<span>markov/sentence</span> (<span>markov/markov-data</span> <span>&#34;A.&#34;</span>)))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>sentence-of-one-sentence-is-itself</span>
</span></span><span><span>  (<span>is</span> (<span>= </span><span>&#34;A B C.&#34;</span> (<span>markov/sentence</span> (<span>markov/markov-data</span> <span>&#34;A B C.&#34;</span>)))))
</span></span></code></pre></div><p>The next 2 tests are more complicated because they must consider the randomness of a Markov process:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>deftest</span> <span>sentence-of-non-repeating-words-is-one-of-the-original-sentences</span>
</span></span><span><span>  (<span>let </span>[<span>out</span> (<span>markov/sentence</span> (<span>markov/markov-data</span> <span>&#34;A B C D. E F G. H I.&#34;</span>))]
</span></span><span><span>    (<span>is</span> (<span>some </span>#{<span>out</span>} [<span>&#34;A B C D.&#34;</span> <span>&#34;E F G.&#34;</span> <span>&#34;H I.&#34;</span>]))))
</span></span><span><span>
</span></span><span><span>(<span>deftest</span> <span>sentence-of-simple-repetition</span>
</span></span><span><span>  (<span>let </span>[<span>out</span> (<span>markov/sentence</span> (<span>markov/markov-data</span> <span>&#34;A B C. B D.&#34;</span>))]
</span></span><span><span>    (<span>is</span> (<span>some </span>#{<span>out</span>} [<span>&#34;B C.&#34;</span> <span>&#34;A B D.&#34;</span> <span>&#34;B D.&#34;</span> <span>&#34;A B C.&#34;</span>]))))
</span></span></code></pre></div><p>The trick here is to use a small input and enumerate all the possible outputs, using  the construct</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>some </span>#{<span>&#34;A&#34;</span>} [<span>&#34;A&#34;</span> <span>&#34;B&#34;</span> <span>&#34;C&#34;</span>])
</span></span></code></pre></div><p>which is the Clojure idiomatic way to test if element <code>&#34;A&#34;</code> is contained in collection <code>[&#34;A&#34; &#34;B&#34; &#34;C&#34;]</code>.</p>
<p>Now we can refactor. The original again:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>sentence</span> [<span>data</span>]
</span></span><span><span>  (<span>loop </span>[<span>ws</span> (<span>data</span> <span>:start</span>)
</span></span><span><span>         <span>acc</span> []]
</span></span><span><span>    (<span>let </span>[<span>w</span> (<span>rand-nth</span> <span>ws</span>)                       <span>; &lt;1&gt;</span>
</span></span><span><span>          <span>nws</span> (<span>data</span> <span>w</span>)
</span></span><span><span>          <span>nacc</span> (<span>concat </span><span>acc</span> [<span>w</span>])]
</span></span><span><span>      (<span>if </span>(<span>= </span><span>\.</span> (<span>last </span><span>w</span>))                       <span>; &lt;2&gt;</span>
</span></span><span><span>        (<span>clojure.string/join</span> <span>&#34; &#34;</span> <span>nacc</span>)
</span></span><span><span>        (<span>recur</span> <span>nws</span> <span>nacc</span>)))))
</span></span></code></pre></div><ul>
<li><strong>&lt;1&gt;</strong> Introduces the randomness of the Markov process.</li>
<li><strong>&lt;2&gt;</strong> The termination condition.</li>
</ul>
<p>For our refactoring, we replace the <code>loop</code> with a recursive function call and we use the fact that a Clojure function can have different arities. The version with arity 1, respecting the API, calls the version with arity 3, the recursion point.</p>
<p>We also use slightly longer variable names to increase readability and the idiomatic way to add to a vector:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span>(<span>defn </span><span>sentence</span>
</span></span><span><span>  ([<span>data</span>]
</span></span><span><span>   (<span>sentence</span> <span>data</span> (<span>:start</span> <span>data</span>) []))
</span></span><span><span>  ([<span>data</span> <span>words</span> <span>acc</span>]
</span></span><span><span>   (<span>let </span>[<span>word</span>     (<span>rand-nth</span> <span>words</span>)
</span></span><span><span>         <span>acc-next</span> (<span>conj </span><span>acc</span> <span>word</span>)]
</span></span><span><span>     (<span>if </span>(<span>string/ends-with?</span> <span>word</span> <span>&#34;.&#34;</span>)
</span></span><span><span>       (<span>string/join</span> <span>&#34; &#34;</span> <span>acc-next</span>)
</span></span><span><span>       (<span>recur</span> <span>data</span> (<span>get </span><span>data</span> <span>word</span>) <span>acc-next</span>)))))
</span></span></code></pre></div><p>We are done. Although the refactored code is slightly longer than the original, it is readable and so maintainable.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://adambard.com/blog/write-friendlier-clojure/">Writing Friendlier Clojure</a></li>
<li><a href="https://adambard.com/">Adam Bard</a></li>
<li><a href="https://web.archive.org/web/20080512091003/http://www.cs.bell-labs.com/cm/cs/pearls/sec153.html">Markov text generator</a></li>
<li><a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a></li>
<li><a href="https://michaelfeathers.silvrback.com/characterization-testing">characterization tests</a></li>
<li><a href="https://clojure.org/guides/spec">clojure.spec</a></li>
</ul>

</div></div>
  </body>
</html>
