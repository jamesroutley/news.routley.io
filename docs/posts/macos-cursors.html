<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mac-cursors.netlify.app">Original</a>
    <h1>macOS Cursors</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1954021">
    
      <div><p>My first time at RC, I would go down rabbit holes as long as its fun. This time at RC, I wanted to be more deliberate. In any case, extremes are bad. At least this is how I justified going from working on a series of Prolog exercises to thinking more broadly how things fit together.</p><p>In a previous <a href="https://payments.posthaven.com/rc-w5d1-first-day-with-prolog">post</a>, the sample solution to the Dinesman puzzle highlights the declarative programming approach. In other words, the program describes the what, not the how. If you’re thinking “this sounds like SQL”, yes, it is very much like SQL. When you run a query in PostgreSQL, the query engine will figure out the scans and the joins, the optimizer speeds things up. You just supply the query.</p><p>In fact, this helpful diagram shows how Prolog relates to relational algebra (the theoretical basis for SQL). It’s from an Introduction to Datalog <a href="https://x775.net/2019/03/18/Introduction-to-Datalog.html">post</a>, which is a highly-recommended read.</p><div>        <div id="posthaven_gallery[1979805]">
          <p>
          <img src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/medium_datalog.jpg" data-posthaven-state="processed" data-medium-src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/medium_datalog.jpg" data-medium-width="800" data-medium-height="424" data-large-src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/large_datalog.jpg" data-large-width="1200" data-large-height="636" data-thumb-src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/thumb_datalog.jpg" data-thumb-width="200" data-thumb-height="200" data-xlarge-src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/xlarge_datalog.jpg" data-xlarge-width="1370" data-xlarge-height="726" data-orig-src="https://phaven-prod.s3.amazonaws.com/files/image_part/asset/2969244/dV8ppJ9J08RNl9KyF05ibUA_Wt4/datalog.jpg" data-orig-width="1370" data-orig-height="726" data-posthaven-id="2969244"/>
        </p>
          
        </div>

</div><p>How does Datalog compare to Prolog? Prolog is a general-purpose (Turing-complete) language, whereas Datalog is the subset oriented around querying. Datalog seems limited as a subset but benefits in two ways. First, the order of clauses doesn’t matter. Second, Prolog works top-down by returning one result a time, whereas Datalog works with whole sets of data. Rich Hickey talks about Datalog as the query language for Datomic <a href="https://www.infoq.com/interviews/hickey-datomic/">here</a>.</p><p>How does Datalog compare to SQL? SQL is an implementation of relational algebra. Relational algebra does not support recursion, while certain SQL dialects extend this by allowing recursion through Common Table Expressions (CTEs). Rules in Prolog are allowed to be recursive but is much cleaner, or perhaps in the term that I’ve become rather fond of, much more ergonomic.</p></div>
    
  </div></div>
  </body>
</html>
