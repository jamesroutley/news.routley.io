<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w1d4-domain-specific-software-sketch">Original</a>
    <h1>RC W1D4 - Domain-specific software (sketch)</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1942296">
    
      <div><p>OK we’re back on to &#39;sharing sketches of my blog post ideas along the way’, here we go.</p><p>When I think about CS topics, I think about operating systems, databases, networking etc. These are domain-agnostic. I began to ponder, are there specific aspects of a language, framework or paradigm that’s particularly useful for working in a specific domain (finance, healthcare, education etc)? What choices would you make based on what you’re optimizing for? Is domain-specific software a thing?</p><p>SICP touches on this at the <a href="https://sarabander.github.io/sicp/html/Chapter-3.xhtml#Chapter-3">start</a> of Chapter 3:</p><blockquote><p>One powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled.</p></blockquote><p>This preface led to a discussion of mutability and functional vs imperative models. A related idea is the argument that the functional model allows us to focus on the domain, and not the step-by-step execution.<br/>
</p><p>I had a coffee chat with Jacquin Mininger which led to a number of threads and resources, as sketched out below. I’ll likely finesse these once I’ve done a bit more homework. Mistakes my own.</p><p><b>Types</b> - With strong types, we’re able to constrain the space of illegal states (since we can’t use a function that operates on strings to work on integers, say). With static types, we are able to run these checks at compile time. With an expressive type system, you can even say represent a EUR/USD pair with its own type instead of a float, so it’s not possible to mistake this for a GBP/USD pair (I believe this example is from <a href="https://blog.ploeh.dk/2020/01/20/algebraic-data-types-arent-numbers-on-steroids/">here</a>, which I need to re-read).</p><p><b>Pure functions</b> - When you don’t have side effects, your code is easier to understand because its impact is isolated. It also makes refactoring easier. A thought that came up here is Jane St being a fan of OCaml. While the functional aspect is a plus, it&#39;s easy to overlook how it’s an even bigger plus when it’s both the functional and types working together to maximize how much the domain can be ‘expressed&#39; in code.</p><p><b>Proofs</b> - These provide an even stronger check. Agda and Coq are popular choices, but can be slow. Haskell is faster. Rust is even faster and has a much larger supporting ecosystem.</p><p><b>Math</b> - There are some domains like crypto where the desired behavior is expressed in math, which also translates more naturally into Haskel.</p><p><b>Performance</b> - It’s easier to reason about performance when using imperative languages because it’s closer to what the processor is doing. This means that it’s harder to do or less natural when using a functional language. It’s also easier to reason about performance when you don’t have to worry about the garbage collector ’stopping the world’; here Rust having no runtime can fare better vs Go.</p><p><b>Haskell</b> - Related to the performance point above, this also means that you’ll need to know the compiler / GHC well to figure out where your bottlenecks are when writing Haskell.</p><p><b>Finance and crypto</b> - The &#39;return on investment’ of using functional languages may be higher here given the emphasis on correctness. While this may weigh the choice towards correctness over performance, there are subdomains like high-frequency trading where you shouldn&#39;t be in business if you don&#39;t have performance.</p><p><b>Other domains</b> - I have very little context if domain-specific software is a thing outside of finance and crypto, naturally would love to hear thoughts. I only also have the one example of Nubank acquiring Cognitech / Clojure, which anecdotally stresses the finance example.</p></div>
    
  </div></div>
  </body>
</html>
