<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.bugsiki.dev/posts/zig-profilers/">Original</a>
    <h1>Zig Profiling on Apple Silicon</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you’re a developer rocking an Apple Silicon Mac and writing in Zig, congratulations - you’ve chosen the scenic route through the desert of profiling tools.
It’s just you, your code, and a tumbleweed named <strong>Apple Instruments</strong>.
But don’t worry - we’ll try to find some oases.</p>
<p>Okay, it’s not that bad, but we’re far away from the rich ecosystem of profiling tools available on Linux.</p>
<p><strong>Note:</strong></p>
<blockquote>
<p>I have limited experience using low-level languages, so this article doesn’t provide a deep dive into profiling,
but rather serves as an entry point to the world of profiling.</p>
</blockquote>
<h2 id="classification">Classification</h2>
<p>We focus only on these types of profilers:</p>
<ul>
<li>
<p><strong>CPU time profilers:</strong></p>
<ul>
<li>Statistical (timer-based) sampling: periodically samples stacks to estimate where time is spent.</li>
<li>Hardware event–based sampling (PMU): samples on counter overflows (cycles, cache-misses, branches) to attribute microarchitectural stalls.</li>
</ul>
</li>
<li>
<p><strong>Instrumentation profilers:</strong> insert probes at function entry/exit or around code regions to mark scopes.</p>
</li>
</ul>
<p>There are many other types of profilers, like memory profilers, network profilers, etc., but we won’t cover them here.</p>
<p>Many profilers combine methods from both categories.</p>
<p>For Linux, we have <strong>perf</strong>, <strong>valgrind</strong>, and <strong>tracy</strong>. These tools cover almost all possible cases. Sadly, that’s not true for Apple Silicon Macs:</p>
<ol>
<li><strong>perf</strong> - supports only Linux as it relies on the Linux kernel.</li>
<li><strong>valgrind</strong> - doesn’t support macOS on arm64.</li>
<li><strong>tracy</strong> - mostly works, but callstack sampling is not supported.</li>
</ol>
<h2 id="interfaces">Interfaces</h2>
<p>Apple provides several interfaces for profiling:</p>
<ol>
<li><a href="https://developer.apple.com/documentation/kernel/mach"><strong>Mach Interface</strong></a> - provides access to threads, address spaces, memory objects, and IPC primitives.</li>
<li><a href="https://en.wikipedia.org/wiki/DTrace"><strong>DTrace Framework</strong></a> - similar to Mach, but requires root privileges and disabling System Integrity Protection (SIP) for profiling system apps.</li>
<li><strong>kperf</strong> - private framework, Apple’s alternative to Linux <strong>perf</strong>.</li>
</ol>
<h2 id="available-tools">Available Tools</h2>
<h3 id="1-samplyhttpsgithubcommstangesamply">1. <a href="https://github.com/mstange/samply">Samply</a></h3>
<p>Samply is a sampling profiler that collects stack traces, per thread, at a specified sampling interval (default: 1ms or 1000Hz). Both on- and off-CPU samples are collected.</p>
<p>It relies on the Mach Interface to collect samples and uses the Firefox Profiler as its UI.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Sampling executables or already running processes</li>
<li>Feature-rich UI: call tree, flamegraph, source code, CPU usage</li>
</ul>
<p><strong>Install:</strong></p>
<div><pre tabindex="0"><code data-lang="shell"><span><span><span># using cargo</span>
</span></span><span><span>cargo install --locked samply
</span></span><span><span>
</span></span><span><span><span># homebrew</span>
</span></span><span><span>brew install samply
</span></span></code></pre></div><p><strong>Usage:</strong></p>
<div><pre tabindex="0"><code data-lang="sh"><span><span><span># fresh start</span>
</span></span><span><span>samply record &lt;command&gt;
</span></span><span><span>
</span></span><span><span><span># pid (requires signing binary, can be done using `samply setup`)</span>
</span></span><span><span>samply record -p &lt;pid&gt;
</span></span></code></pre></div><p><img loading="lazy" src="https://blog.bugsiki.dev/posts/zig-profilers/images/samply-ui.png" alt="samply"/>
</p>
<h3 id="2-poophttpsgithubcomandrewrkpoop">2. <a href="https://github.com/andrewrk/poop">poop</a></h3>
<p>It’s not a joke - it’s the Performance Optimizer Observation Platform, shortened to <strong>poop</strong>.
This tool was created by <a href="https://github.com/andrewrk">Andrew Kelley</a> to compare performance based on hardware counters.
The upstream version doesn’t support macOS as it relies fully on <strong>perf</strong>. There is a <a href="https://github.com/andrewrk/poop/pull/70">PR</a> that adds support for macOS, including Apple Silicon.
Since the PR hasn’t been merged yet, and its build fails, you can use <a href="https://github.com/verte-zerg/poop/tree/kperf-macos">this fork</a>.
Under the hood, it uses Apple’s private framework <strong>kperf</strong>.</p>
<p>Big shout-out to:</p>
<ul>
<li><a href="https://github.com/ibireme"><strong>ibireme</strong></a> for <a href="https://x.com/ibireme/status/1476802948160442368">researching</a>
<a href="https://github.com/apple/darwin-xnu">Apple’s open sourced code</a> and reverse engineering Apple Instruments.</li>
<li><a href="https://github.com/tensorush"><strong>tensorush</strong></a> for implementing the PR.</li>
</ul>
<p>Keep in mind that this PR hasn’t been merged yet, so it may contain bugs. I tested it on macOS 15.5 (M2 Pro), and it works fine,
but I can’t guarantee that it will work on newer versions as it relies on a private API and Apple can change it at any time.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Getting hardware counters, e.g. branch misses, instructions</li>
<li>Comparing performance across different commands</li>
</ul>
<p><strong>Install:</strong></p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>git clone https://github.com/verte-zerg/poop.git -b kperf-macos
</span></span><span><span>cd poop
</span></span><span><span><span># use zig version 0.14.1</span>
</span></span><span><span>zig build --release<span>=</span>fast
</span></span><span><span>cp ./zig-out/bin/poop ~/.local/bin/poop
</span></span></code></pre></div><p><strong>Usage:</strong></p>
<div><pre tabindex="0"><code data-lang="shell"><span><span><span># root privileges are required on macOS</span>
</span></span><span><span>sudo poop &lt;cmd1&gt; &lt;cmd2&gt; ...
</span></span><span><span>
</span></span><span><span><span># you can specify the duration param (in ms) to increase count of runs</span>
</span></span><span><span><span># count = &lt;duration&gt; // &lt;first time run&gt;</span>
</span></span><span><span>sudo poop --duration <span>60000</span> &lt;cmd1&gt; &lt;cmd2&gt; ...
</span></span></code></pre></div><p><img loading="lazy" src="https://blog.bugsiki.dev/posts/zig-profilers/images/poop.png" alt="poop"/>
</p>
<h3 id="3-tracyhttpsgithubcomwolfpldtracy">3. <a href="https://github.com/wolfpld/tracy">Tracy</a></h3>
<p>Tracy is a real-time instrumentation and sampling profiler. It supports time-based zone sampling but does not support callstack sampling (e.g. full backtraces) on Apple Silicon.
You can still use its instrumentation features, which are useful if you want to profile a long-running process.</p>
<p>I can’t describe the profiler better than <a href="https://www.youtube.com/watch?v=ghXk3Bk5F2U">Marcos Slomp at CppCon 2023</a>.
That said, keep in mind that callstack sampling doesn’t work on macOS with Apple Silicon.
He doesn’t mention this in the talk and skips a live demo in favor of pre-recorded results.
Maybe it’s a skill issue on my side and I just don’t know how to cook it,
but Tracy’s <a href="https://github.com/wolfpld/tracy/releases/latest/download/tracy.pdf">manual</a> (see page 27) clearly says callstack sampling isn’t supported on Apple Silicon.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Rich UI: source code, call tree, CPU/GPU usage, and much more</li>
<li>Remote profiling</li>
<li>Many instrumentation features, like messages, scopes, values</li>
</ul>
<p><strong>Install:</strong>
Since Tracy is an instrumentation profiler, you should embed the client library and some additional code in your app.</p>
<ol>
<li>Clone the tracy repository</li>
</ol>
<div><pre tabindex="0"><code data-lang="shell"><span><span>git clone https://github.com/wolfpld/tracy.git
</span></span></code></pre></div><ol start="2">
<li>Install <strong>tracy-profiler</strong> using Homebrew or by manually compiling the <strong>tracy</strong> repository.</li>
</ol>
<div><pre tabindex="0"><code data-lang="shell"><span><span>brew install tracy
</span></span></code></pre></div><p>Note that Homebrew contains only version 0.11.1, while version 0.12.2 is already released.
I recommend sticking with the Homebrew version to avoid the hassle of building 0.12.2 from scratch.</p>
<ol start="3">
<li>
<p>Copy the <code>tracy.zig</code> implementation to your codebase. You can take it from the <a href="https://github.com/ziglang/zig/blob/master/src/tracy.zig">Zig repo</a>,
making sure you use the file from the corresponding version of your Zig.</p>
</li>
<li>
<p>Update your <code>build.zig</code> file to include the tracy library. As a reference, you can use the <a href="https://github.com/ziglang/zig/blob/master/src/tracy.zig"><code>build.zig</code></a>
file from the Zig repo, just search for the <code>tracy</code> keyword. Here is a diff over a base <code>build.zig</code>:</p>
</li>
</ol>
<div><pre tabindex="0"><code data-lang="diff"><span><span>diff --git a/build.zig b/build.zig
</span></span><span><span>index 6bc8766..0011695 100644
</span></span><span><span><span>--- a/build.zig
</span></span></span><span><span><span></span><span>+++ b/build.zig
</span></span></span><span><span><span></span><span>@@ -9,6 +9,11 @@ pub fn build(b: *std.Build) void {
</span></span></span><span><span><span></span>         .target = target,
</span></span><span><span>     });
</span></span><span><span>
</span></span><span><span><span>+    const tracy = b.option([]const u8, &#34;tracy&#34;, &#34;Enable Tracy integration. Supply path to Tracy source&#34;);
</span></span></span><span><span><span>+    const tracy_callstack = b.option(bool, &#34;tracy-callstack&#34;, &#34;Include callstack information with Tracy data. Does nothing if -Dtracy is not provided&#34;) orelse (tracy != null);
</span></span></span><span><span><span>+    const tracy_allocation = b.option(bool, &#34;tracy-allocation&#34;, &#34;Include allocation information with Tracy data. Does nothing if -Dtracy is not provided&#34;) orelse (tracy != null);
</span></span></span><span><span><span>+    const tracy_callstack_depth: u32 = b.option(u32, &#34;tracy-callstack-depth&#34;, &#34;Declare callstack depth for Tracy data. Does nothing if -Dtracy_callstack is not provided&#34;) orelse 10;
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>     const exe = b.addExecutable(.{
</span></span><span><span>         .name = &#34;tracy_demo&#34;,
</span></span><span><span>         .root_module = b.createModule(.{
</span></span><span><span><span>@@ -23,6 +28,27 @@ pub fn build(b: *std.Build) void {
</span></span></span><span><span><span></span>
</span></span><span><span>     b.installArtifact(exe);
</span></span><span><span>
</span></span><span><span><span>+    const exe_options = b.addOptions();
</span></span></span><span><span><span>+    exe.root_module.addOptions(&#34;build_options&#34;, exe_options);
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    exe_options.addOption(bool, &#34;enable_tracy&#34;, tracy != null);
</span></span></span><span><span><span>+    exe_options.addOption(bool, &#34;enable_tracy_callstack&#34;, tracy_callstack);
</span></span></span><span><span><span>+    exe_options.addOption(bool, &#34;enable_tracy_allocation&#34;, tracy_allocation);
</span></span></span><span><span><span>+    exe_options.addOption(u32, &#34;tracy_callstack_depth&#34;, tracy_callstack_depth);
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    if (tracy) |tracy_path| {
</span></span></span><span><span><span>+        const client_cpp = b.pathJoin(
</span></span></span><span><span><span>+            &amp;[_][]const u8{ tracy_path, &#34;public&#34;, &#34;TracyClient.cpp&#34; },
</span></span></span><span><span><span>+        );
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+        const tracy_c_flags: []const []const u8 = &amp;.{ &#34;-DTRACY_ENABLE=1&#34;, &#34;-fno-sanitize=undefined&#34; };
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+        exe.root_module.addIncludePath(.{ .cwd_relative = tracy_path });
</span></span></span><span><span><span>+        exe.root_module.addCSourceFile(.{ .file = .{ .cwd_relative = client_cpp }, .flags = tracy_c_flags });
</span></span></span><span><span><span>+        exe.root_module.linkSystemLibrary(&#34;c++&#34;, .{ .use_pkg_config = .no });
</span></span></span><span><span><span>+        exe.root_module.link_libc = true;
</span></span></span><span><span><span>+    }
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>     const run_step = b.step(&#34;run&#34;, &#34;Run the app&#34;);
</span></span><span><span>
</span></span><span><span>     const run_cmd = b.addRunArtifact(exe);
</span></span></code></pre></div><ol start="5">
<li>Instrument your code with <code>tracy</code>. Here is a simple usage example:</li>
</ol>
<div><pre tabindex="0"><code data-lang="diff"><span><span>diff --git a/src/main.zig b/src/main.zig
</span></span><span><span>index e21e514..0c06f22 100644
</span></span><span><span><span>--- a/src/main.zig
</span></span></span><span><span><span></span><span>+++ b/src/main.zig
</span></span></span><span><span><span></span><span>@@ -1,7 +1,11 @@
</span></span></span><span><span><span></span> const std = @import(&#34;std&#34;);
</span></span><span><span> const tracy_demo = @import(&#34;tracy_demo&#34;);
</span></span><span><span><span>+const tracy = @import(&#34;tracy.zig&#34;);
</span></span></span><span><span><span></span>
</span></span><span><span> pub fn main() !void {
</span></span><span><span><span>+    const tr = tracy.trace(@src());
</span></span></span><span><span><span>+    defer tr.end();
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>     // Prints to stderr, ignoring potential errors.
</span></span><span><span>     std.debug.print(&#34;All your {s} are belong to us.\n&#34;, .{&#34;codebase&#34;});
</span></span><span><span>     try tracy_demo.bufferedPrint();
</span></span></code></pre></div><ol start="6">
<li>Build your app with <code>-Dtracy=&lt;path to tracy repo&gt;</code>.</li>
</ol>
<div><pre tabindex="0"><code data-lang="shell"><span><span>zig build -Dtracy<span>=</span>&lt;path to tracy repo&gt;
</span></span></code></pre></div><p><strong>Usage:</strong></p>
<ol>
<li>Run <strong>tracy-profiler</strong>, click <code>Connect</code></li>
<li>Run your program.</li>
</ol>
<p>The connection should be established and you’ll see the tracy profiler UI. On Apple Silicon it will show only CPU usage,
but you can instrument your code with additional frames and messages. Just take a look at the copied <code>tracy.zig</code>.</p>
<p><img loading="lazy" src="https://blog.bugsiki.dev/posts/zig-profilers/images/tracy.png" alt="tracy"/>
</p>
<h3 id="4-apple-instruments">4. Apple Instruments</h3>
<p>Apple Instruments is a powerful tool that allows you to perform CPU profiling, fetch hardware counters, and much more.</p>
<p>Instruments offers most of the same capabilities as <strong>samply</strong> or <strong>poop</strong> - and adds more, like GPU usage and counters, HTTP traffic, Neural Engine events, etc.</p>
<p>I’d only reach for it if the other tools fall short.
The main downside of this tool is that its UI and app in general is too slow, which sounds like a joke, since we’re talking about performance here!</p>
<p>It includes a command-line tool, <strong>xctrace</strong>, for scripting recordings and exports - but it’s painfully slow as well.
For example, I have a ray-tracing binary that runs in about 4 seconds, but recording 3 runs and exporting them to XML (yes, it’s the only supported output format)
took about 40 seconds (about 30 seconds overhead).</p>
<p>You can read about it in the <a href="https://help.apple.com/instruments/mac/current/">Apple Documentation</a> or in various other articles.</p>
<p><img loading="lazy" src="https://blog.bugsiki.dev/posts/zig-profilers/images/apple-instruments.png" alt="apple-instruments"/>
</p>
<h2 id="conclusion">Conclusion</h2>
<p>The profiling landscape on Apple Silicon is not as rich as on Linux, but there are still some good options available.
I found that <strong>samply</strong> is the best to take a quick look at the performance of my app, while <strong>poop</strong> is an excellent tool for iterative performance optimization.
<strong>tracy</strong> is a powerful tool for instrumentation profiling, although I haven’t yet had a real use case for it.</p>
<h2 id="sources">Sources</h2>
<ol>
<li><a href="https://github.com/wolfpld/tracy/releases/latest/download/tracy.pdf">Tracy - User Manual</a></li>
<li><a href="https://lemire.me/blog/2021/03/24/counting-cycles-and-instructions-on-the-apple-m1-processor/">Article - Counting cycles and instructions on the Apple M1 processor</a></li>
<li><a href="https://poweruser.blog/using-dtrace-with-sip-enabled-3826a352e64b">Article - Using dtrace on MacOS with SIP enabled</a></li>
<li><a href="https://medium.com/@techhara/profiling-visualize-program-bottleneck-with-flamegraph-macos-4a2b3598df8a">Article - macOS Profiling - visualize program bottleneck with Flamegraph</a></li>
<li><a href="https://www.youtube.com/watch?v=ghXk3Bk5F2U">Talk - CppCon 2023: Marcos Slomp - An Introduction to Tracy Profiler in C++</a></li>
<li><a href="https://x.com/ibireme/status/1476802948160442368">X - Post about reading Apple M1 CPU performance counters in macOS</a></li>
<li><a href="https://x.com/mitchellh/status/1947430231515808134">X - Post about profiling on Apple Silicon</a></li>
</ol>


  </div></div>
  </body>
</html>
