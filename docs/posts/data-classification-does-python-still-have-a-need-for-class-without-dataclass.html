<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.glyph.im/2023/02/data-classification.html">Original</a>
    <h1>Data Classification: Does Python still have a need for class without dataclass?</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Is there a place for non-<code>@dataclass</code> classes in Python any more?</p>
<p>I have <a href="https://blog.glyph.im/2016/08/attrs.html">previously — and somewhat famously — written
favorably</a> about <code>@dataclass</code>’s venerable progenitor,
<a href="https://www.attrs.org/en/stable/">attrs</a>, and how you should use it for pretty
much everything.</p>
<p>At the time, <code>attrs</code> was an additional dependency, a piece of technology that
you could bolt on to your Python stack to make your particular code better.
While I advocated for it strongly, there are all the usual implicit reasons
against using a new thing. It was an additional dependency, it might not
interoperate with <em>other</em> convenience mechanisms for type declarations that you
were already using (i.e. <code>NamedTuple</code>), it might look weird to other Python
programmers familiar with existing tools, and so on.  I don’t think that any of
these were <em>good</em> counterpoints, but there was nevertheless a robust discussion
to be had in addressing them all.</p>
<p>But for many years now, dataclasses have been — and currently are — <a href="https://peps.python.org/pep-0557/">built in
to the language</a>. They are increasingly
integrated to the toolchain at a deep level that is difficult for application
code — or even other specialized tools — to replicate.  Everybody knows what
they are.  Few or none of those reasons apply any longer.</p>
<p>For example, classes defined with <code>@dataclass</code> are now <a href="https://github.com/mypyc/mypyc/issues/671">optimized as a C
structure might be when you compile them with
<code>mypyc</code></a>, a trick that is extremely
useful in some circumstances, which <a href="https://github.com/mypyc/mypyc/issues/883">even attrs itself now has trouble keeping
up with</a>.</p>
<p>This all raises the question for me: beyond backwards compatibility, is there
<em>any</em> point to having non-<code>@dataclass</code> classes any more?  Is there any
remaining justification for writing them in new code?</p>
<p>Consider my original example, translated from attrs to dataclasses.  First, the
non-dataclass version:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>class</span> <span>Point3D</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>):</span>
        <span>self</span><span>.</span><span>x</span> <span>=</span> <span>x</span>
        <span>self</span><span>.</span><span>y</span> <span>=</span> <span>y</span>
        <span>self</span><span>.</span><span>z</span> <span>=</span> <span>z</span>
</code></pre></div></td></tr></tbody></table></div>

<p>And now the dataclass one:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>

<span>@dataclass</span>
<span>class</span> <span>Point3D</span><span>:</span>
    <span>x</span><span>:</span> <span>int</span>
    <span>y</span><span>:</span> <span>int</span>
    <span>z</span><span>:</span> <span>int</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Many of my original points still stand.  It’s still less repetitive.  In fewer
characters, we’ve expressed considerably more information, and we get more
functionality (<code>repr</code>, sorting, hashing, etc).  There doesn’t seem to be much
of a downside besides the strictness of the types, and if <code>typing.Any</code> were a
builtin, <code>x: any</code> would be fine for those who don’t want to unduly constrain
their code.</p>
<p>The one real downside of the latter over the former right now is the need for
an import.  Which, at this point, just seems… confusing?  Wouldn’t it be
nicer to be able to just write this:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>class</span> <span>Point3D</span><span>:</span>
    <span>x</span><span>:</span> <span>int</span>
    <span>y</span><span>:</span> <span>int</span>
    <span>z</span><span>:</span> <span>int</span>
</code></pre></div></td></tr></tbody></table></div>

<p>and not need to faff around with decorator semantics and fudging the difference
between Mypy (or Pyright or Pyre) type-check-time and Mypyc or Cython compile
time?  Or even better, to not need to <em>explain</em> the complexity of all these
weird little distinctions to new learners of Python, and to have to cover
<code>import</code> before <code>class</code>?</p>
<p>These tools all already treat the <code>@dataclass</code> decorator as a totally special
language construct, not really like a decorator at all, so to really explore it
you have to explain a special case and then a special case <em>of</em> a special case.
The extension hook <a href="https://peps.python.org/pep-0681/">for this special case of the special
case</a> notwithstanding.</p>
<p>If we didn’t want any new syntax, we would need a <code>from __future__ import
dataclassification</code> or some such for a while, but this doesn’t seem like an
impossible bar to clear.</p>
<hr/>
<p>There are still some folks who <a href="https://www.linkedin.com/feed/update/urn:li:activity:7030601707717894144/">don’t like type annotations at
all</a>,
and there’s still the possibility of awkward implicit changes in meaning when
transplanting code from a place with <code>dataclassification</code> enabled to one
without, so perhaps an entirely new unambiguous syntax could be provided.  One
that more closely mirrors the meaning of parentheses in <code>def</code>, moving
inheritance (a feature which, whether you like it or not, is clearly far less
central to class definitions than ‘what fields do I have’) off to its own part
of the syntax:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>data</span> <span>Point3D</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>,</span> <span>y</span><span>:</span> <span>int</span><span>,</span> <span>z</span><span>:</span> <span>int</span><span>)</span> <span>from</span> <span>Vector</span><span>:</span>
    <span>def</span> <span>method</span><span>(</span><span>self</span><span>):</span>
        <span>...</span>
</code></pre></div></td></tr></tbody></table></div>

<p>which, for the “I don’t like types” contingent, could reduce to this in the
minimal case:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>data</span> <span>Point3D</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>):</span>
    <span>pass</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Just thinking pedagogically, I find it super compelling to imagine moving from
teaching <code>def foo(x, y, z):...</code> to <code>data Foo(x, y, z):...</code> as opposed to
<code>@dataclass class Foo: x: int...</code>.</p>
<p>I don’t have any desire for semantic changes to accompany this, just to make it
possible for newcomers to ignore the circuitous historical route of the
<code>@dataclass</code> syntax and get straight into defining their own types with legible
<code>repr</code>s from the very beginning of their Python journey.</p>
<p>(And make it possible for me to skip a couple of lines of boilerplate in short
examples, as a bonus.)</p>
<hr/>
<p>I’m curious to know what y’all think, though.  Shoot me <a href="mailto:data-classification-351017@glyph.im">an
email</a> or <a href="https://mastodon.social/@glyph/109861982356222515">a
toot</a> and let me know.</p>
<p>In particular:</p>
<ol>
<li>Do you think there’s some reason I’m missing why Python’s current method for
   defining classes via a bunch of dunder methods is still better than
   dataclasses, or should stick around into the future for reasons beyond
   “compatibility”?</li>
<li>Do you think “compatibility” is sufficient reason to keep the syntax the way
   it is forever, and I’m underestimating the cost of adding a keyword like
   this?</li>
<li>If you do think that a change should be made, would you prefer:<ol>
<li>changing the meaning of <code>class</code> itself via a <code>__future__</code> import,</li>
<li>a new <code>data</code> keyword like the one I’ve proposed,</li>
<li>a new keyword that functions exactly like the one I have proposed but
     really want to bikeshed the word <code>data</code> a bunch,</li>
<li>something more incremental like just putting <code>dataclass</code> and <code>field</code> in
     builtins,</li>
<li>or an option I haven’t even contemplated here?</li>
</ol>
</li>
</ol>
<p>If I find I’m not alone in this perhaps I will wander over to the <a href="https://discuss.python.org/c/welcome/12">Python
discussion boards</a> to have a more
substantive conversation...</p>
<hr/>
<p>Thank you to <a href="https://www.patreon.com/creatorglyph">my patrons</a> who are helping
me while I try to turn… whatever this is… along with open source maintenance
and application development, into a real job.  Do you want to see me pursue
ideas like this one further?  If so, you can <a href="https://www.patreon.com/join/8655595">support me on Patreon as
well</a>!</p>
</div></div>
  </body>
</html>
