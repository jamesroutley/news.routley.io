<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cipht.net/2024/01/01/getaddrinfo.html">Original</a>
    <h1>Bug story: getaddrinfo(3) and PBR</h1>
    
    <div id="readability-page-1" class="page"><div id="universe">
<div id="post">
<h2><a href="http://cipht.net/2024/01/01/getaddrinfo.html">Bug story: getaddrinfo(3) and PBR</a>
<span>
<time>January 01, 2024</time>
<span>[c, posix, openwrt, bugs]</span>
</span>
</h2>
<p>
A while ago I was working on <a href="https://en.wikipedia.org/wiki/Wireless_access_point">wireless access points</a> (APs) based on
<a href="https://openwrt.org/">OpenWrt</a>. One day I discovered that remote logging wasn&#39;t working, and
the debugging that followed had some surprises.
</p>
<p>
On OpenWrt, there&#39;s a process called <code>logread</code> responsible for
shipping the logs to another device via the <a href="https://en.wikipedia.org/wiki/Syslog">syslog protocol</a>. These
APs don&#39;t persist their logs between boots, so sending logs to a
system that can store them was essential for diagnosing problems. I
noticed <code>logread</code> wasn&#39;t running, though it starts on boot, so I added
something to the init script to restart <code>logread</code> if it crashed, and
was going to call it a day. But I went to test it, and the logs
weren&#39;t showing up; sometimes, the logs would show up right after the
AP booted, but then at some point, it would stop working.
</p>
<p>
I had already spent a lot of time on the other side of this, the
syslog that receives the logs, and was pretty sure the setup was
correct there. So I ran <code>logread</code> by hand, and it failed with
</p>
<pre id="org60ccdb6">failed to connect: Permission denied
</pre>
<p>
What? Permission denied? I read <a href="https://git.openwrt.org/?p=project/ubox.git;a=blob;f=log/logread.c;h=f48dd4bb6ae0ad436702b09dfee4371a004e2217;hb=HEAD">the code</a> to find out where this was
happening, and it was in <code>usock()</code>, which is some socket code that&#39;s
used all over OpenWrt, and there were no obvious calls that could fail
with <code>EACCES</code> in it.
</p>
<p>
After checking some ACLs, making sure this couldn&#39;t possibly be a
permission problem (it&#39;s running as root), I decided to <code>strace</code>
<code>logread</code> (this required rebuilding the flash image for the AP, which
is why I didn&#39;t do it earlier), and saw:
</p>
<pre id="org8a81a44">socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, IPPROTO_UDP) = 8
connect(8, {sa_family=AF_INET, sin_port=htons(65535), sin_addr=inet_addr(&#34;127.0.0.1&#34;)}, 16) = 0
close(8)                                = 0
socket(AF_INET6, SOCK_DGRAM|SOCK_CLOEXEC, IPPROTO_UDP) = 8
connect(8, {sa_family=AF_INET6, sin6_port=htons(65535), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;::1&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 EACCES (Perm
ission denied)
close(8)                                = 0
</pre>
<p>
What the heck? First off, the connection <code>logread</code> is trying to make
in this case is a TCP connection, and we&#39;re giving it an IP address;
why is it making UDP connections to <code>localhost</code>? And why are those
connections failing?
</p>
<p>
I had a guess on why this started happening – a little while before,
IPv6 had been disabled on these devices. Maybe it hadn&#39;t been done
thoroughly enough? I checked <code>ip addr</code>, and <code>lo</code> definitely did not
have <code>::1</code> as an address, and IPv6 was disabled through the
<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt"><code>disable_ipv6</code> <code>sysctl</code></a>.
</p>
<p>
I decided that it was probably <a href="https://git.openwrt.org/?p=project/libubox.git;a=blob;f=usock.c;h=15b6988e3c6d8269eb6fde2c085d3eccc6349c22;hb=HEAD#l157">a call to</a> <a href="https://man7.org/linux/man-pages/man3/getaddrinfo.3.html"><code>getaddrinfo()</code></a> making UDP
connections – maybe it&#39;s trying to resolve DNS – but why port 65535?
Is that just an ephemeral port it&#39;s choosing every single time?
</p>
<p>
I tested <code>getaddrinfo</code> from Lua (the only interpreted language on the
device), but it worked fine, so there had to be something about how
<code>usock</code> was calling it; did it want IPv6 addresses specifically or
something?
</p>
<p>
<a href="https://musl.libc.org/">musl</a> is the libc of choice on these devices. Checking its
<a href="https://git.musl-libc.org/cgit/musl/tree/src/network/getaddrinfo.c?id=dc9285ad1dc19349c407072cc48ba70dab86de45#n44">implementation</a> of <code>getaddrinfo</code>, we see this block of code near the
top:
</p>
<div>
<pre><span>if</span> <span>(</span>flags &amp; AI_ADDRCONFIG<span>)</span> <span>{</span>
    <span>/* </span><span>Define the &#34;an address is configured&#34; condition for address</span>
<span>     * families via ability to create a socket for the family plus</span>
<span>     * routability of the loopback address for the family.</span><span> */</span>
    <span>// </span><span>…</span>
    <span>static</span> <span>const</span> <span>struct</span> <span>sockaddr_in6</span> <span>lo6</span> = <span>{</span>
        .sin6_family = AF_INET6, .sin6_port = 65535,
        .sin6_addr = IN6ADDR_LOOPBACK_INIT
    <span>}</span>;
    <span>const</span> <span>void</span> *<span>ta</span><span>[</span>2<span>]</span> = <span>{</span> &amp;lo4, &amp;lo6 <span>}</span>;
    <span>// </span><span>…</span>
    <span>for</span> <span>(</span>i=0; i&lt;2; i++<span>)</span> <span>{</span>
      <span>// </span><span>…</span>
      <span>int</span> <span>s</span> = socket<span>(</span>tf<span>[</span>i<span>]</span>, SOCK_CLOEXEC|SOCK_DGRAM,
                     IPPROTO_UDP<span>)</span>;
      <span>if</span> <span>(</span>s&gt;=0<span>)</span> <span>{</span>
        <span>int</span> <span>cs</span>;
        pthread_setcancelstate<span>(</span>
                               PTHREAD_CANCEL_DISABLE, &amp;cs<span>)</span>;
        <span>int</span> <span>r</span> = connect<span>(</span>s, ta<span>[</span>i<span>]</span>, tl<span>[</span>i<span>]</span><span>)</span>;
        pthread_setcancelstate<span>(</span>cs, 0<span>)</span>;
        close<span>(</span>s<span>)</span>;
        <span>if</span> <span>(</span><span>!</span>r<span>)</span> <span>continue</span>;
      <span>}</span>
      <span>switch</span> <span>(</span>errno<span>)</span> <span>{</span>
      <span>case</span> EADDRNOTAVAIL:
      <span>case</span> EAFNOSUPPORT:
      <span>case</span> EHOSTUNREACH:
      <span>case</span> ENETDOWN:
      <span>case</span> ENETUNREACH:
        <span>break</span>;
      <span>default</span>:
        <span>return</span> EAI_SYSTEM;
      <span>}</span>
      <span>// </span><span>…</span>
</pre>
</div>
<p>
And sure enough, <code>usock</code> always sets <code>AI_ADDRCONFIG</code> on flags. So
this is a kind of probing connect musl is using to check the validity
of IPv4 or IPv6 on the system. The <code>connect</code> is returning <code>EACCES</code>,
but musl isn&#39;t handling it as part of the errors it considers
&#34;normal&#34;. It bails out early, and leaves <code>errno</code> set to <code>EACCES</code>
where <code>logread</code> prints it out to mystify us.
</p>
<p>
But why would <code>connect</code> fail with <code>EACCES</code>? The man page doesn&#39;t list
anything that makes sense for this.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup> Weirder still, I
decide to check if there are any IPv6 addresses at all – and there is
one, but for <code>eth0</code>, not <code>lo</code>. I delete it, and suddenly <code>logread</code>
works.
</p>
<p>
At this point I start looking for information about musl&#39;s
<code>getaddrinfo</code> and this issue, and <a href="https://www.openwall.com/lists/musl/2019/12/05/1">find a patch</a> posted to the mailing
list with no replies, never applied.
</p>
<p>
Sweet! I head over to <a href="https://musl.libc.org/support.html"><code>#musl</code></a> on IRC and ask them if it wasn&#39;t
applied for a reason, and they say it must have been overlooked. But
then someone tries to reproduce with the instructions in the patch,
and can&#39;t.
</p>
<p>
I dive into the kernel source trying to figure out what actually
returns <code>EACCES</code> here. There is a <span>lot</span> of code under
<code>ip6_datagram_connect</code> so I tried to grep and pray, but there were
still too many possibilites to know for sure. This is an opportunity
to use <a href="https://www.kernel.org/doc/html/v5.0/trace/ftrace.html"><code>ftrace</code></a>! I had to rebuild the kernel, since these are
stripped down images for embedded devices, and I was worried
<code>trace-cmd</code> might actually crash the device, but I got a capture fine.
I could see clearly that the last useful function called under
<code>ip6_datagram_connect</code> was <code>fib6_rule_action</code>, which can return
<code>EACCES</code>, but why? What even are these rules?
</p>
<p>
I spent a while even trying to figure out what these rules are and how
to manipulate them. It turns out they&#39;re for &#34;<a href="https://en.wikipedia.org/wiki/Policy-based_routing">policy-based routing</a>&#34;
(PBR), which I hadn&#39;t really explored before. I didn&#39;t even realize
some of these firewall-like policies could be handled at this level.
</p>
<p>
I was running the <code>ip rule</code> command and not seeing anything
interesting, until I finally read the source for <code>ip</code> and <a href="https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/tree/ip/iprule.c#n552">noticed it
defaults to IPv4</a> – I needed to run <code>ip -6 rule</code>, but that flag is
in the <code>ip(8)</code> manpage, not the <code>ip-rule(8)</code> manpage for the
subcommand. But running it on the AP, I saw:
</p>
<pre id="orgd181ca7"># ip -6 rule
0:      from all lookup local
32766:  from all lookup main
4200000001:     from all iif lo lookup unspec 12
4200000002:     from all iif eth0 lookup unspec 12
4200000003:     from all iif eth1 lookup unspec 12
</pre>
<p>
I&#39;m not sure I fully understand these rules now, and it took a bit of
looking (and <code>strace</code> to confirm the netlink message being sent) to
see that this is action &#34;12&#34;, which isn&#39;t one of the actions in the
(mainline) kernel. But it was enough info to demonstrate that the
issue could be reproduced on any Linux system with
</p>
<pre id="org27bebd9">ip -6 rule add from all iif lo lookup unspec prohibit
</pre>
<p>
Some discussion on the musl mailing list revealed that action 12 is a
special rule <a href="https://git.openwrt.org/?p=openwrt/svn-archive/archive.git;a=blob;f=target/linux/generic/patches-3.19/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch;h=f32458df30ad466d4e3ac8224cbec1bd074b43ec;hb=35d90ba52069c96afd1a74600b91499e5feed0e0#l42">OpenWrt adds in their kernel</a>. I discovered that
<code>netifd</code>, which manages interfaces and rules on OpenWrt, was setting
IPv6 policies like this, even when IPv6 was disabled, so <a href="https://patchwork.ozlabs.org/project/openwrt/patch/20210430143037.6763-1-julian@cipht.net/">I patched
that out</a>. And finally remote logging worked again.
</p>
<p>
This was a surprising set of interactions. Figuring it out was
tractable thanks to having all the source for everything, and
reasonable tools for introspection. Is there a moral to this story?
Perhaps a few tidbits: strace and ftrace are good; getaddrinfo is bad;
maybe don&#39;t disable IPv6; and <a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/commit/man2/connect.2?id=375c65a9c2f5fef9796672078769104074530ec1">blessed are those who update manpages</a>.
</p>


</div>
</div></div>
  </body>
</html>
