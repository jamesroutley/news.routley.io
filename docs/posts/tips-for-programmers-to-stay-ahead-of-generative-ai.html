<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spectrum.ieee.org/ai-programming">Original</a>
    <h1>Tips for programmers to stay ahead of generative AI</h1>
    
    <div id="readability-page-1" class="page"><div data-elid="2662065692" data-post-url="https://spectrum.ieee.org/ai-programming" data-authors="Rina Diane Caballar" data-headline="How Coders Can Survive—and Thrive—in a ChatGPT World" data-page-title="How Coders Can Survive—and Thrive—in a ChatGPT World - IEEE Spectrum"><div><p><a href="https://spectrum.ieee.org/topic/artificial-intelligence/" target="_self">Artificial intelligence</a>, particularly generative AI powered by large language models (LLMs), <a href="https://spectrum.ieee.org/artificial-general-intelligence" target="_blank">could upend</a> many <a href="https://spectrum.ieee.org/ai-code-generation-language-models" target="_self">coders’ livelihoods</a>. But some experts argue that AI won’t replace human programmers—not immediately, at least.</p><p>“You will have to worry about people who are using AI replacing you,” says <a href="https://www.tanishq.ai/" rel="noopener noreferrer" target="_blank">Tanishq Mathew Abraham</a>, a Ph.D. candidate in <a href="https://spectrum.ieee.org/topic/biomedical/">biomedical</a> engineering at the University of California, Davis and the CEO of medical AI research center <a href="https://medarc.ai/" rel="noopener noreferrer" target="_blank">MedARC</a>.</p><p>So how can software developers make themselves more useful and relevant in what appears to be a coming age of LLM-centered coding? Here are some tips and techniques for coders to survive and thrive in a generative AI world.</p><h2>Stick to Basics and Best Practices</h2><p>While the myriad AI-based coding assistants could help with code completion and code generation, the fundamentals of programming remain: the ability to read and reason about your own and others’ code, and understanding how the code you write fits into a larger system.</p><p>“I believe AI can dramatically increase the productivity of software developers, but there is a lot more to software engineering than just generating code—from eliciting user requirements to debugging, testing, and more,” says <a href="https://hci.seas.harvard.edu/people/priyan-vaithilingam" rel="noopener noreferrer" target="_blank">Priyan Vaithilingam</a>, a Ph.D. student working in the intersection of human-computer interaction and programming languages at Harvard University’s <a href="https://seas.harvard.edu/" rel="noopener noreferrer" target="_blank">John A. Paulson School of Engineering and Applied Sciences</a>.</p><p>One of the most integral programming skills continues to be the domain of human coders: problem solving. Analyzing a problem and finding an elegant solution for it is still a highly regarded coding expertise.</p><p>“There’s a creative aspect to it, and a lot of those skills of approaching a problem are more important than the actual language or tools,” says <a href="https://ines.io/" rel="noopener noreferrer" target="_blank">Ines Montani</a>, a Fellow of the <a href="https://www.python.org/psf/fellows/" target="_blank">Python Software Foundation</a> and cofounder and CEO of <a href="https://explosion.ai/" rel="noopener noreferrer" target="_blank">Explosion</a>, a software company specializing in developer tools for AI and natural-language processing. “Don’t fall into the trap of comparing yourself to the AI, which is more or less a statistical output of a large model. There are differences in what a developer does versus what the model outputs—there’s more to being a developer than just writing arbitrary lines of code.”</p><p>Additionally, good software-engineering practices are proving even more valuable than before. These practices include planning out the system design and software architecture, which serves as a good context for AI-based tools to more effectively predict what code you need next.</p><p>“A human coder is still the one who has to figure out the structure of a piece of code, the right abstractions around which to organize it, and the requirements for different interfaces,” says <a href="https://www.csail.mit.edu/person/armando-solar-lezama" rel="noopener noreferrer" target="_blank">Armando Solar-Lezama</a>, an associate director and chief operating officer of MIT’s <a href="https://www.csail.mit.edu/" rel="noopener noreferrer" target="_blank">Computer Science and Artificial Intelligence Laboratory</a>, and who leads the lab’s computer-aided programming group. “All of those are central to software-engineering practice, and they’re not going to go away soon.”</p><h2>Find the Tool That Fits Your Needs</h2><p>Finding the right AI-based tool is essential. Each tool has its own ways to interact with it, and there are different ways to incorporate each tool into your development workflow—whether that’s automating the creation of unit tests, generating test data, or writing documentation.</p><p><a href="https://github.com/features/copilot" rel="noopener noreferrer" target="_blank">GitHub Copilot</a> and other AI coding assistants, for instance, can augment programming, offering suggestions as you code. <a href="https://openai.com/blog/chatgpt" rel="noopener noreferrer" target="_blank">ChatGPT</a> and Google’s <a href="https://bard.google.com/" rel="noopener noreferrer" target="_blank">Bard</a>, on the other hand, act more like conversational AI programmers and can be used to answer questions about APIs (application programming interfaces) or generate code snippets.</p><p>The trick is to experiment. Play around with the AI tool, get a feel for how it works, consider the quality of its outputs—but keep an open mind for other tools. “AI is such a fast-moving field. You don’t want to just settle on a tool and then use that for the rest of your life, so you’ll need to adapt quickly to new ones,” Abraham says.</p><p>Think about appropriate use cases as well. Generative AI tools can provide a swift route to learning new programming languages or frameworks, and they can also be a quicker way to kick off small projects and create prototypes.</p><h2>Clear and Precise Conversations Are Key</h2><p>When using AI coding assistants, be detailed about what you need and view it as an iterative process. Abraham proposes writing a comment that explains the code you want so the assistant can generate relevant suggestions that meet your requirements.</p><p>For conversational AI programmers, you’ll need to know the best way to frame your prompts. This is where <a href="https://learnprompting.org/docs/basics/prompting" rel="noopener noreferrer" target="_blank">prompt engineering</a> comes in.</p><p>One approach Abraham suggests is <a href="https://www.promptingguide.ai/techniques/cot" rel="noopener noreferrer" target="_blank">chain-of-thought prompting</a>. This involves a divide-and-conquer strategy where you break down a problem into multiple steps and tackle each one to solve the entire problem. “Asking the model to do too much at a given time can lead to disaster. You want it to be able to work with manageable chunks of information and produce manageable chunks of code,” he says.</p><p>Instead of asking an AI programmer to code an entire program from scratch, for example, consider the different tasks the program is trying to accomplish. Divide those tasks further and ask the model to write specific functions for each. You might need to reason with the model about the steps it needs to take to achieve a task, resulting in a back-and-forth conversation.</p><p>“Treat it almost like a smart intern who knows a lot about a subject but isn’t that experienced,” Abraham says.</p><p>Precision and clarity are vital with prompt engineering. “You need to ask the model very clearly what you want, be very precise about what you’re asking it to do, and make sure you’re following up,” Abraham says.</p><p>It can also be valuable to learn the basic concepts of <a href="https://spectrum.ieee.org/topic/artificial-intelligence/">artificial intelligence</a> and machine learning, as well as get a sense of how large language models work and their strengths and weaknesses. You don’t need to dive deep, but having some general knowledge can give you important context about the results.</p><p>To help you get started, Abraham recommends the <a href="https://github.com/openai/openai-cookbook" rel="noopener noreferrer" target="_blank">OpenAI Cookbook</a>, which has sections on prompting libraries and tools, prompting guides, and video courses, while Vaithilingam suggests reading up on <a href="http://jalammar.github.io/illustrated-transformer/" rel="noopener noreferrer" target="_blank">the Illustrated Transformer</a> to find out more about models and machine-learning basics.</p><h2>Be Critical and Understand the Risks</h2><p>Software engineers should be <a href="https://spectrum.ieee.org/ai-software" target="_self">critical of the outputs of large language models</a>, as they tend to <a href="https://spectrum.ieee.org/ai-hallucination" target="_self">hallucinate</a> and produce inaccurate or incorrect code. “It’s easy to get stuck in a debugging rabbit hole when blindly using AI-generated code, and subtle bugs can be difficult to spot,” Vaithilingam says.</p><p>That’s why checking generated code is crucial, though it adds an extra step, which might harm more than help productivity. But Abraham argues that “it’s easier to verify the code than it is to write it from scratch in some cases, and it’s a faster approach to generate and then verify before incorporating into whatever codebase you have.”</p><p>It might be worth putting the outputs of these models into perspective, asking the following questions: What data was this model trained on? What was filtered out and not included in that data? How old is the training data, and what version of a programming language, software package, or library was the model trained on? The answers to these questions could impact the results and provide more context about them.</p><p>Developers should also be wary of entering proprietary code into these models. Some companies, such as <a href="https://www.tabnine.com/" rel="noopener noreferrer" target="_blank">Tabnine</a>, offer enterprise versions of their AI coding assistants, providing <a href="https://spectrum.ieee.org/ai-and-data-privacy" target="_self">privacy</a> while still learning an organization’s coding patterns and style.</p><p><a href="https://spectrum.ieee.org/generative-ai-ip-problem" target="_self">Copyright</a> is another factor to consider, though it’s less of a worry if you’re using these tools to complete a few lines of code or generate code for common or trivial tasks compared to producing bigger chunks of code.</p><p>“Programmers should have some sense of how original what they’re trying to do is and to what extent is it unique to their context,” Solar-Lezama says. “If the model is producing a somewhat original piece of code, it’s important to be suspicious and skeptical before putting that in a production codebase.”</p><p>An even larger issue is security, as these models may generate code containing vulnerabilities. According to Vaithilingam, software-development best practices such as code reviews and strong test pipelines can help safeguard against this risk.</p><p>“One of the things that more experienced software engineers bring to the table is the awareness of the most common vulnerabilities in code and the most common ways in which code can be made vulnerable,” says Solar-Lezama. “They build this intuition about what to pay attention to and what raises red flags. Moving forward, these kinds of techniques are going to become more important parts of the software engineering mix.”</p><p>For programmers to survive in a generative AI world, they’ll need to embrace AI as a tool and incorporate AI into their workflow while recognizing the opportunities and limitations of these tools—and still relying on their human coding capabilities to thrive.</p></div></div></div>
  </body>
</html>
