<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ShellsAndCurrentDirectory">Original</a>
    <h1>Unix Shells and the Current Directory</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Unix shells and the current directory</h2>

	<p><small>November 25, 2023</small></p>
</div><div><p>Famously, Unix has the concept of a process&#39;s &#39;current directory&#39;,
including for your shell processes. Recently, I saw <a href="https://mastodon.social/@mcc/111473183237943793">an interesting
Fediverse discussion</a>
on some aspects of the current directory which aren&#39;t necessarily
obvious, partly because both Unix kernels and Unix shells have become
more complicated over time.</p>

<p>The Unix kernel keeps track of your current directory not as text
path but as a reference to a kernel object, normally the directory&#39;s
<em>inode</em>. In the old days this was all the kernel actually knew about
the current directory, but today Linux (and perhaps other Unixes)
have developed kernel caches of the mappings between names and
inodes; in Linux, these are <em>dnodes</em> (I believe for &#39;directory
(entry) node&#39;). Linux&#39;s dnodes mean that the kernel almost always
knows the name of your current directory, if it has one.</p>

<p>(Your current directory may not have a name, for example because
the directory has been removed. If you do &#39;mkdir /tmp/example; cd
/tmp/example; rmdir /tmp/example&#39; your current directory still
exists in some sense, but it&#39;s lost its name and most everything
else.)</p>

<p>One of the ways that Linux uses its knowledge of the file (path)
names of things is with /proc/*/cwd and more generally all of
the file names in /proc/*/fd. Another way is that the Linux
kernel has a <a href="https://man7.org/linux/man-pages/man3/getcwd.3.html"><code>getcwd()</code></a> system call
that returns this information to you, which is what <code>getcwd(3)</code>
normally uses. Interested parties can see this system call being
used in the depths of &#39;strace /bin/pwd&#39;. On systems that don&#39;t have
a <code>getcwd()</code> system call, how /bin/pwd works is much more brute
force. The traditional implementation is to stat() &#39;.&#39;, the current
directory, and then read through &#39;..&#39;, the parent directory, until
you find the name for the current directory (which you can identify
by its inode number). Then repeat for the next level up until you&#39;ve
reached the root directory, and put all of the name components
together into the path.</p>

<p>(It appears that FreeBSD also has a similar system call, based on
what &#39;truss /bin/pwd&#39; reports, and <a href="https://man.openbsd.org/getcwd.3">the OpenBSD getcwd(3) manual
page</a> says that OpenBSD does too.
FreeBSD appears to implement this with <a href="https://cgit.freebsd.org/src/tree/sys/kern/vfs_cache.c">a name cache in the kernel</a>. I haven&#39;t
looked at the OpenBSD kernel source.)</p>

<p>Complicating this picture is shells. For a long time, many shells
have kept track of a name for their current directory themselves,
often materializing this in the &#39;<code>$PWD</code>&#39; environment variable. The
shell has to keep track of this name as a text string or the rough
equivalent, which makes it potentially less accurate than the
kernel&#39;s version. However, it has some advantages, because unlike
the kernel, the shell knows what name you typed in order to get to
the directory, which may not be the actual filesystem name of the
directory because of things like symbolic links.  Shells often use
this knowledge so that names like &#39;..&#39; and even &#39;.&#39; work on the
text version, not the filesystem version.</p>

<p>(Sometimes people then write shell scripts and other code that
assumes &#39;<code>$PWD</code>&#39; is accurate if it&#39;s present, which is not necessarily
true. Sadness often ensues. Because &#39;<code>$PWD</code>&#39; is a regular environment
variable, it&#39;s not automatically updated when someone&#39;s code does
a chdir() call.)</p>

<p>That sounds abstract so here&#39;s an example. If you typed &#39;cd /u/cks&#39;
and /u/cks is actually a symbolic link to /h/281/cks, the kernel
only knows your current directory as &#39;/h/281/cks&#39;. If you ask the
kernel to change directory to &#39;..&#39;, the parent, you will wind up
in /h/281. If you ask the shell to &#39;cd ..&#39;, the shell can put you
in /u, the textual parent of &#39;/u/cks&#39;, the path you typed to get
to your current directory. Shells with this behavior usually have
a &#39;pwd&#39; builtin that prints their &#39;logical&#39; text view of your current
directory, as opposed to the filesystem view that /bin/pwd will
print.</p>

<p>All of this shell behavior (and Unix kernel behavior) isn&#39;t necessarily
well known (or perhaps clearly documented, although all of the
pieces are there if you read enough things). Usually this doesn&#39;t
matter because everything works well enough and does what people
expect.</p>

<p>(Some people have strong reactions to shells using their &#39;logical
path&#39; instead of the filesystem path for things like &#39;cd ..&#39;. These
people are less happy with the current state of affairs. If you&#39;re
one of these people and use Bash, you want &#39;set -P&#39; or &#39;set -o
physical&#39;.)</p>

<p>(This elaborates on <a href="https://mastodon.social/@cks/111473985663630141">what I said on the Fediverse</a>.)</p>
</div></div>
  </body>
</html>
