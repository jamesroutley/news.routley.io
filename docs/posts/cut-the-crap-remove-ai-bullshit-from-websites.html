<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cut-the-crab.streamlit.app/">Original</a>
    <h1>Show HN: Cut the crap – remove AI bullshit from websites</h1>
    
    <div id="readability-page-1" class="page"><div><div id="remainder"><p>In my opinion, both Rust and Zig have (very different!) hard edges that ultimately lead you towards writing better programs. The “obvious” hard edge that Rust has is the borrow checker, which other people have beaten to death. The borrow checker is a beautiful piece of software; I’m not interested in discussing it here.</p><p>No, with Rust i was so immediately taken with the <code>Iterator</code> trait and the ease of creating <code>Vecs</code> and <code>HashSets</code> and so forth with <code>.collect()</code> that i spent a large amount of thought while ramping up with the first several problems so that my processing of the input could go something like</p><pre><code><span>fn</span> <span>process</span><span>(</span><span>input</span><span>:</span> <span>&amp;</span><span>str</span><span>)</span> -&gt; <span>u32</span> <span>{</span>
	<span>input</span><span>.</span><span>lines</span><span>(</span><span>)</span>
	    <span>.</span><span>map</span><span>(</span>|<span>line</span>| <span>{</span> ..<span>.</span><span></span> <span>}</span><span>)</span>
	    <span>// ...</span>
	    <span>.</span><span>fold</span><span>(</span>..<span>.</span><span></span><span>)</span>
<span>}</span>
</code></pre>
<p>I write more procedurally in Zig (which doesn&#39;t have first-class support for &#34;generic&#34; iteration processing like <code>map</code> or <code>fold</code> or first-class closures), which I think is an instance of a Zig hard edge that improves correctness (more on this another time, I guess), but Rust&#39;s affordance for it taught me a lot in terms of rigorous thinking about scope and clarity of purpose: each iterator chain exists to transform an input to an output—it doesn&#39;t have access the full input or other context unless you correctly make that available to it. (Correctly in the sense of the borrow checker.) Paradoxically, even though <code>process</code> is provided the full file as input, this <code>impl Iterator</code> code structure also promotes a &#34;streaming&#34; mentality for processing the data; I find I don&#39;t create more than is actually necessary.</p><p>By the way, I’d argue that passing the entire file contents to this function is always correct: Advent of Code text files are small, even when they stretch into the kilobytes—that&#39;s a small number in comparison to my total RAM, I try to keep in mind. Additionally, the <code>input</code> parameter introduces the correct <a href="https://notes.nicole.computer/notes/Code-Seams" target="_blank">“code seam” (thanks Nicole Watts for a beautiful new-to-me metaphor!)</a> for testing your solution.</p><p>That&#39;s kind of the high-minded thing Rust taught me. The other thing I learned via doing Advent of Code in Rust is feeling comfortable using the containers it provides. Rust makes this easier than Zig as of 0.13 on a name level—if you want a growable array of objects, all of type <code>T</code>, what you want is a <code>Vec&lt;T&gt;</code>. If you want to start with a collection of objects, you can construct one with the <code>vec!</code> macro. If you want to deduplicate a list, what you want is a <code>HashSet&lt;T&gt;</code>, or if you want to associate keys to values, you want a <code>HashMap&lt;K,V&gt;</code>. The <code>Vec</code> type is so common it&#39;s imported into every Rust scope, but making <code>HashSet</code> and <code>HashMap</code> available to you is not difficult.</p><p>Zig does great on this front, actually; it has great default implementations of all of these container types. They&#39;re just named poorly. One instance of poor name choices is already being corrected for Zig 0.14. I&#39;ll save discussing that for later. First, I&#39;d like to argue for another change towards better defaults.</p><p>In Zig, here is the signature of <code>std.HashMap</code>:</p><pre><code><span>pub</span> <span>fn</span> <span>HashMap</span><span>(</span><span>comptime</span> <span>K</span><span>:</span> <span>type</span><span>,</span> 
	<span>comptime</span> <span>V</span><span>:</span> <span>type</span><span>,</span> 
	<span>comptime</span> <span>Context</span><span>:</span> <span>type</span><span>,</span> 
	<span>comptime</span> <span>max_load_percentage</span><span>:</span> <span>u64</span><span>,</span>
<span>)</span> <span>type</span> <span>{</span> <span>...</span> <span>}</span>
</code></pre>
<p>(Yes, that&#39;s a function. In Zig, to create a type that depends on another type, y ou write a function which takes in a parameter like <code>comptime T: type</code> and returns a <code>type</code>. This saves you from having to write generics using a thornier sublanguage instead of regular Zig.)</p><p>The <code>Context</code> type is responsible for actually hashing keys of type <code>K</code> and determining when two keys are the same. You can write a <code>Context</code> type yourself without crying too much; for Advent of Code 2023, I did—<strong>for the simple and sad reason that this type has the best name,</strong> while the type that actually deserves the best name does not.</p><p>As of Zig 0.13, I will confidently assert that the type you want maybe 90% of the time you reach for a <code>std.HashMap</code> is actually one of <code>std.AutoHashMapUnmanaged(K, V)</code>, <code>std.AutoArrayHashMapUnmanaged(K, V)</code>, or in the particular case of string keys, <code>std.StringHashMapUnmanaged</code> or <code>std.StringArrayHashMapUnmanaged</code>.</p><p>The <code>Unmanaged</code> issue, as I alluded to earlier, is being fixed already. If the issue of the <code>Auto</code> prefix is not already being changed, I&#39;d like to propose that it should be.</p><p>Here <code>Auto</code> means &#34;use a best guess at a default hashing function&#34;. (<code>Array</code> means store keys and values contiguously so that iterating over them is fast and ergonomic. I read somewhere that even iterating once is enough to justify reaching for this type.) It&#39;s great that Zig allows you to swap out the default (or even <code>std</code>-provided) methods for hashing with your own. The &#34;ground&#34; types <code>HashMapUnmanaged</code> and <code>ArrayHashMapUnmanaged</code> are well thought through in terms of API design. My issue with them is that for a beginner, they shadow the correct type to reach for first.</p><p>I propose that current <code>std.HashMap</code> should become <code>std.HashMapWithContext</code> and that <code>std.AutoHashMap</code> should become <code>std.HashMap</code>. I&#39;m happy to defer to the core team&#39;s expertise on how to manage the transition period.</p><p>Now, to be sure, the core of this proposal could be summarily dismissed as a &#34;skill issue&#34;. On the one hand, reading documentation or the <code>std</code> library code quickly reveals the existence of the <code>Auto...</code> types. And on the other, learning to write reasonably useful hashing functions is a skill that will serve a budding programmer well.</p><p>I think this dismissal is a mistake. In my personal experience, Zig&#39;s extremely legible standard library code and thoughtful approach to default implementations has helped me grow as a programmer in ways I never anticipated. By providing friction in the right places, the language has steered me towards better design and more correct code. In this particular instance, I think juice, while worth an eventual squeeze, might come at an off-putting price for a beginner. To wit, I didn&#39;t learn to comfortably reach for hash maps from Zig; I learned it from Rust.</p><p>This is more of an addendum, but I&#39;d like to also propose the addition of <code>std.HashSet(T)</code> as well, as in <a href="https://github.com/ziglang/zig/issues/6919" target="_blank">#6919</a>. My reason for doing so, though, is different. For example, I would be happy to see a simple implementation like</p><pre><code><span>pub</span> <span>fn</span> <span>std</span><span>.HashSet</span><span>(</span><span>K</span><span>)</span> <span>type</span> <span>{</span>
    <span>return</span> <span>std</span><span>.</span><span>ArrayAutoHashMapUnmanaged</span><span>(</span><span>K</span><span>,</span> <span>void</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>The reason I would like to ask for this addition to the standard library is not functional but pedagogical: again, realizing that you <em>can</em> implement a <code>HashSet</code> type by creating a <code>HashMap</code> type with a zero-sized value type is a beautiful realization that I don&#39;t want to deny a beginner Zig programmer; the challenge is that coming to that realization on one&#39;s own is nontrivial.</p><p>You could be forgiven for thinking that <code>Vec&lt;T&gt;</code> translates to Zig&#39;s <code>@Vector</code>—that&#39;s Rust&#39;s (really C++&#39;s) fault; choosing the name <code>Vec</code> for this data structure was an awful mistake. It&#39;s also such an old one that I can&#39;t hold it against Rust. Zig&#39;s current answer is <code>std.ArrayList(T)</code>. I don&#39;t mind it as a name: &#34;Array&#34; to me signals contiguity, while &#34;List&#34; suggests that you can grow it. The problem is that actually you really want <code>std.ArrayListUnmanaged(T)</code>. There&#39;s room for difference of opinions on this, but here are three reasons that convinced me of this:</p><h2>Initialization</h2><p>You can default-initialize <code>std.ArrayListUnmanaged(T)</code>, as in</p><pre><code><span>var</span> <span>list</span><span>:</span> <span>std</span><span>.</span><span>ArrayListUnmanaged</span><span>(</span><span>T</span><span>)</span> = <span>.</span><span>{</span><span>}</span><span>;</span>
</code></pre>
<p>Actually, with Zig&#39;s upcoming &#34;decl literal&#34; syntax, it becomes preferred to write something like <code>.empty</code> instead of <code>.{}</code>. The reason to prefer this over <code>.{}</code> is that making it possible to initialize a struct of type <code>S</code> with <code>.{}</code> requires you to set default values for all of the fields of <code>S</code>; but <code>std.ArrayListUnmanaged(T)</code> has two fields, <code>items</code> and <code>capacity</code>, and it is a mistake to override one default value without also setting the other.</p><p>Since Zig has no &#34;default&#34; allocator, <code>std.ArrayList(T)</code> must either be initialized completely by hand or by calling <code>init(allocator)</code>. If you compose a larger struct by including a <code>std.ArrayList(T)</code>, that means you cannot default-init your larger struct either and must write an <code>init</code> function.</p><h2>Size</h2><p><code>@sizeOf(std.ArrayList(T) == 5 * @sizeOf(usize)</code>, while <code>@sizeOf(std.ArrayListUnmanaged(T)) == 3 * @sizeOf(usize)</code>. This is because <code>std.ArrayList(T)</code> takes possession of a <code>std.mem.Allocator</code> object, which it uses to manage its allocation as you interact with the <code>ArrayList</code>, while <code>std.ArrayListUnmanaged</code> does not, instead requiring you to pass the same <code>Allocator</code> as an argument each time you execute a call which could allocate or deallocate memory.</p><p>I mistakenly thought that in Rust, which uses the borrow checker to manage memory for you, <code>Vec&lt;T&gt;</code> has size equal to only <code>2 * @sizeOf(usize)</code>, which would be ideal for a type you&#39;d like to pass around a lot. It appears that actually by default it has the same size as <code>std.ArrayListUnmanaged</code>. Some other Rust containers like those in the <code>ecow</code> crate <em>do</em> manage this by hiding both the <code>capacity</code> field (and the <code>Allocator</code>, when you&#39;re using one with positive size) inside its heap allocation. I don’t think Zig should adopt this sleight of hand for the standard container type.</p><h2>Optimizability</h2><p>I&#39;ve read—although here I have to joyfully confess my lack of expertise—that making the <code>Allocator</code> a parameter as opposed to a field allows the LLVM backend (which as of 0.13 is the main way Zig produces machine code) to &#34;devirtualize&#34; the allocation calls.</p><p>Here&#39;s my understanding of what that means: in Zig, a <code>std.mem.Allocator</code> is a type-erased interface for a number of different approaches to allocation, in much the same way that objects in an object-oriented programming language like C++ or Java might conform to an &#34;interface&#34; (or the way the Rust compiler will generate code for you if you pass something as <code>Box&lt;dyn Trait&gt;</code>).</p><p>Zig doesn&#39;t have first-class interfaces or traits; instead <code>std.mem.Allocator</code> follows a &#34;pointer + vtable&#34; pattern (making <code>std.mem.Allocator</code> a type that sometimes goes by the name &#34;fat pointer&#34;). If you open <code>Allocator.zig</code> in Zig&#39;s standard library, you&#39;ll see that the definition of an <code>Allocator</code> type has two fields, which I&#39;ll summarize as:</p><pre><code><span>pub</span> <span>const</span> <span>Allocator</span> = <span>struct</span> <span>{</span>
	<span>ptr</span><span>:</span> <span>*</span><span>anyopaque</span><span>,</span>
	<span>vtable</span><span>:</span> <span>*</span><span>const</span> <span>VTable</span><span>,</span>

	<span>pub</span> <span>const</span> <span>VTable</span> = <span>struct</span> <span>{</span>
	    <span>alloc</span><span>: *const fn // …,
	    resize: *const fn // …,
	    free: *const fn</span> <span>// …,</span>
    <span>}</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<p>That is, <code>Allocator</code> has two fields: <code>ptr</code> and <code>vtable</code>. Both of these are pointers; <code>ptr</code> to an unspecified type (<code>anyopaque</code>) and <code>vtable</code> to a <code>const VTable</code>. If you look at the definition of <code>VTable</code>, which I&#39;ve abridged above, you&#39;ll see that it contains only function pointers; the methods on the <code>Allocator</code> struct call through these function pointers to actually do the allocation work. When you set up an <code>Allocator</code> in Zig, it&#39;s typically a two-step process. For example, most of my Advent of Code solutions (actually, most of my Zig programs full stop) begin with the following lines:</p><pre><code><span>var</span> <span>gpa</span><span>:</span> <span>std</span><span>.</span><span>heap</span><span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> = <span>.</span><span>{</span><span>}</span><span>;</span>
<span>defer</span> <span>_</span> = <span>gpa</span><span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>allocator</span> = <span>gpa</span><span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>The <code>gpa</code> variable must be <code>var</code> rather than <code>const</code> because <code>allocator()</code> captures a mutable pointer to it—under the hood, the <code>allocator()</code> function looks something like this</p><pre><code><span>pub</span> <span>fn</span> <span>allocator</span><span>(</span><span>self</span><span>:</span> <span>*</span><span>@This</span><span>(</span><span>)</span><span>)</span> <span>std</span><span>.</span><span>mem</span><span>.</span><span>Allocator</span> <span>{</span>
	<span>return</span> <span>.</span><span>{</span>
		<span>.</span><span>ptr</span> = <span>self</span><span>,</span>
		<span>// yes, we are returning a pointer </span>
		<span>// to what appears to be a local variable!</span>
		<span>// this is fine because the contents of the literal</span>
		<span>// are completely known at compile time,</span>
		<span>// so the literal actually has a static lifetime.</span>
		<span>.</span><span>vtable</span> = <span>&amp;</span><span>.</span><span>{</span>
			<span>// these are functions implemented in </span>
			<span>// general_purpose_allocator.zig</span>
			<span>.</span><span>alloc</span> = <span>alloc</span><span>,</span>
			<span>.</span><span>resize</span> = <span>resize</span><span>,</span>
			<span>.</span><span>free</span> = <span>free</span><span>,</span>
		<span>}</span><span>,</span>
	<span>}</span><span>;</span>
<span>}</span>
</code></pre>
<p>I&#39;m told (although I have to continue to joyfully confess that I am not an expert!) that calling functions through function pointers can be expensive. This makes sense—you have to prepare the computer to jump to an essentially arbitrary section of code to run, whereas with a &#34;normal&#34; function call, you know where you&#39;re going already.</p><p>Now, there are ways to mitigate this expense: one of them is &#34;devirtualization&#34;, which as far as I understand means that if the compiler knows that the function pointer is always pointing to the same place in code, when it optimizes, it can replace the &#34;virtual&#34; function call with a &#34;normal&#34; one.</p><p>The point is that for <code>std.ArrayListUnmanaged(T)</code>, the compiler is far more likely to be able to come to this conclusion: because the <code>Allocator</code> only ever appears as a function parameter (and function parameters are always <code>const</code> in Zig), the chances of the compiler realizing that it never changes are much higher, since you cannot change fields of a <code>const</code> struct, and you cannot reach through and change values on the other side of the <code>*const VTable</code> either. But for <code>std.ArrayList(T)</code>, if you take (as you must) a mutable pointer to the <code>ArrayList</code>, suddenly, while it is not possible for you to change values on the other side of <code>*const VTable</code>, you <em>can</em> change out that <code>*const VTable</code> for another one wholesale. There&#39;s no reason you <em>would,</em> and I doubt that anyone <em>does,</em> but the possibility is more likely to make the compiler go &#34;nah, too risky, I can&#39;t devirtualize that&#34;.</p></div></div></div>
  </body>
</html>
