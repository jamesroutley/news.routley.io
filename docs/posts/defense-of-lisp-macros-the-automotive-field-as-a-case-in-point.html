<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mihaiolteanu.me/defense-of-lisp-macros">Original</a>
    <h1>Defense of Lisp macros: The automotive field as a case in point</h1>
    
    <div id="readability-page-1" class="page"><div id="contents">
            

            <p> <em>Replacing Lisp&#39;s beautiful parentheses with dozens of special tools and
                languages, none powerful enough to conquer the whole software landscape, leads to
                fragmentation and extra effort from everyone, vendors and developers alike. The
                automotive field is a case in point.</em>
            </p>

            <ul>
                    <a href="#intro">
                        <li>Intro</li>
                    </a>
                    <a href="#three-problems">
                        <li>The three basic problems all tools try to solve</li>
                    </a>
                    <a href="#automotive-tools">
                        <li>Automotive has special tools and languages for everything</li>
                    </a>
                    <a href="#live-systems">
                        <li>The need to interact with a running system childbirths more tools</li>
                    </a>
                    <a href="#language-environment">
                        <li>A language is not just its syntax but the tools and environment around it</li>
                    </a>
                    <a href="#non-formal-methods">
                        <li>Rules and processes are enforced with non-formal methods</li>
                    </a>
                    <a href="#dsls">
                        <li>Domain specific languages are everywhere</li>
                    </a>
                    <a href="#autosar">
                        <li>Move away from the language completely and just click buttons</li>
                    </a>
                    <a href="#the-future">
                        <li>The future: self-driving cars go all in on DSLs</li>
                    </a>
                    <a href="#conclusion">
                        <li>Conclusion</li>
                    </a>                    
                </ul>
            

            <p id="intro">
                <h2>Intro</h2>
            </p>
            <p> The fearsome Lisp macros and other aliens brought to life by the Lisp parentheses
                often get the blame for breeding a style of software development rich in
                abstractions and <a target="_blank" href="https://wiki.c2.com/?StumblingBlocksForDomainSpecificLanguages">domain
                specific languages</a> in contrast to the easily recognizable C-like creatures. What
                is not officially admitted is that in any project or industry of sufficient size, an
                overabundance of better, improved, simple, easy to use tools, programming languages,
                standards and best practices are employed and brought to life in an ah-hoc manner. A
                confirmation of <a target="_blank" href="https://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule">Greenspun&#39;s Tenth
                Rule</a>, if you will. Though the motivation behind this proliferation be that &#34;this
                is just the way things are&#34; or that &#34;the project is just too complex&#34;, part of
                reason lies in the use of programming languages that lack power, extensibility and
                interactivity. </p>

            <p> I&#39;ll look at the automotive industry which relies solely on the C programming
                language, at least on the surface, and bring to light these hidden creatures. When a
                people is not powerful enough to rule the whole continent, every beggar together
                with their pack of hideous horses vies for their neighbor&#39;s riches. The landscape is
                fractured and tens of languages and dialects are spoken. All journeys take much
                longer than usual. Pacts, alliances and agreements for safe passage with all tribe
                leaders need to be signed and constantly updated. One sees in their voyage countless
                rituals none better or more widespread than the other. Without a powerful language
                to hold it all together, the automotive world is also split into pieces with each
                wannabe king claiming it has found the path to the happy life and deserves to mount
                the throne. Watch for this sign in what follows and for the three main problems all
                these tools try to solve once and for all.  </p>

            
            <p id="three-problems">
                <h2> The three basic problems all tools try to solve </h2>
            </p>
            <p> Firstly, how to find out what your application is doing in real time once it is up
                and running. How to check your assumptions, backtrack, readjust and try again, how
                to have access to as many parts of the running system as possible and how to modify
                anything without slowing down your pace, like a road cyclist who doesn&#39;t need to
                stop at every curb to change gears and loose momentum. How to achieve all this
                seamlessly and concentrate on the project itself and not the tooling and the
                irrelevant problems around it. In short, how to be one with the system at all stages
                of development with as few interruptions as possible.  </p>

            <p>
                Secondly, how to come up with more intuitive and powerful means to develop, express
                and even comprehend whole software systems above the minutest details of algorithms
                and if&#39;s and else&#39;s. The classic &#34;can&#39;t see the forest for the trees &#34; idiom. What
                does the system do at a higher level? How it is organized? How can I easily and
                meaningfully change it without going into too much pointer arithmetic details? How
                do I speak about it, how do I cram it all up inside my brain to aid my understanding
                and explore it in my mind or with my colleagues and clients to better get the
                message across and align on goals and purposes. Ideally, it would be in a language
                closer to English or a language that everybody speaks fluently or even something
                visual I can slurp up all at once, like a painting that I can glance instantly and
                not a book that takes weeks to read, though of course, now I need some training or
                experience in the arts to understand anything and there are myriads of
                interpretation of those brushes before my eyes. But still, a language that is
                formally verifiable and able to be evaluated by a computer without much intervention
                from my side. This is the heart of abstraction towers and of domain specific
                languages. Many tools try to solve this problem without even knowing it.
            </p>

            <p>
                Lastly, how to organize everything around the main programming language. What tools
                are best for building or packaging your software, what tools for writing code and
                how to settle on a definition of &#34;best&#34;. How to organizing teams, agree on
                standards, writing style, where to keep requirements and how to keep them in sync
                with the implementation. How to make sure everyone is on the same page regarding the
                language features, how to use those features in a standard way and what to avoid,
                either because one wants to prevent different ways of doing things or because some
                of those things are really dangerous. How to solve the &#34;shortage of qualified
                people&#34; problem which branches into how to make things more beginner friendly,
                easier and intuitive by avoiding C pointers and C macros and recursion, for example
                and by employing GUI tools and code generators that avoid these pitfalls. Only to
                fall into different mousetraps, of course.
            </p>

            <p>
                All solutions, the problems they beget and again the solutions to fix them in this
                never-ending circle all spring from these initial needs and wants.
            </p>

            <p id="automotive-tools">
                <h2>Automotive has special tools and languages for everything</h2>
            </p>
            <p>
                A car&#39;s software is split into dedicated <a target="_blank" href="https://en.wikipedia.org/wiki/Electronic_control_unit">ECU</a>s,
                each controlling the seats, windows or engine, among others. These microcontrollers
                with memory and peripherals and developed independently by different teams are all
                connected by a single communication network and exchange thousands of uniquely
                identified <a target="_blank" href="https://en.wikipedia.org/wiki/CAN_bus">CAN</a> messages
                each second. To simplify, each ECU behaves like a server, and the list of messages
                it sends and receives represents its API. These are the microservices of the
                automotive world, if you will.
            </p>

            <p>
                At a minimum, an ECU must receive wake-up and periodic CAN messages from other ECUs
                to function properly. In the development phase, where these other ECUs are
                physically missing from one&#39;s desk, an engineer needs to simulate them in software
                together with the ability to sniff out CAN messages from their physical ECU, similar
                to what a <a target="_blank" href="https://en.wikipedia.org/wiki/Wireshark">Wireshark</a> user
                sniffing network packets does. In a first sign of wannabe sole rulers across wast
                landscapes, Vector&#39;s
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/software/canoe/">CANoe</a>,
                is &#34;the only tool for all development and test tasks and a versatile tool for
                the development, testing and analysis of entire ECU networks as well as individual
                ECUs.&#34;
            </p>

            <p>
                In my experience, at the start of any new project it best to first discover the
                project at the fastest speed possible, with the full knowledge that my initial
                solution will not be correct and most of my code will not even survive the first few
                iterations. The classic &#34;build one to throw one away&#34; idiom. These iterations will
                help understand and even rewrite some of my initial assumptions. In extreme cases
                even to confirm that what I&#39;m trying to develop is useless or impossible to
                build. This then is the first step in developing a software product or probably any
                handiwork. CANoe, and plenty of other tools in this field, confirms this need and
                that C is not the right tool to be going out exploring dangerous paths in the middle
                of the night,
            </p>

            <blockquote>
                <p>
                    At the beginning of the development process, CANoe is used to create simulation
                    models which simulate the behavior of the ECUs. Over the further course of ECU
                    development, these models serve as the basis for analysis, testing and the
                    integration of bus systems and ECUs. This makes it possible to detect problems
                    early and correct them. Graphic and text based analysis windows are provided for
                    evaluating the results.
                </p>
                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/products/canoe/canoe/docs/Product%20Informations/CANoe_ProductInformation_EN.pdf">
                        CANoe: Product Information</a>
                </p>
            </blockquote>

            <p>
                To aid this purpose, CANoe&#39;s
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/canoe/canoe/graphics/Gallery/CANoe14_Simulation_gallery_EN.jpg">simulation
                panel</a> contains a visual representation of a car&#39;s network and the attached ECUs
                with the intention of simulating the whole car before writing any C code. Each ECU
                can be clicked around and programmed in <a target="_blank" href="https://www.vector.com/us/en/know-how/capl/">CAPL</a>,
                an event-driven programming language developed by Vector. It has C-like syntax,
                intentionally chosen to make C developers feel right at home, as Vector notes, while
                also acknowledging is doesn&#39;t introduce any groundbreaking ideas or
                abstractions. Instead, it tries to make life easier for engineers: &#34;the goal of CAPL
                has always been to solve specific tasks as simply as possible. Typical tasks are
                reacting to received messages, checking and setting signal values and sending
                messages. A program should restrict itself to precisely these things and not require
                any additional overhead.&#34; The
                <a target="_blank" href="https://www.vector.com/int/en/know-how/capl/">
                    CAPL know-how</a> page has all the details.
            </p>

            <p>
                This software <a target="_blank" href="https://www.google.com/search?q=model%20based%20development">modeling</a>
                and the introduction of new, easier, intuitive, even graphical languages and
                interfaces similar in style to what one is already familiar with is a recurring
                theme throughout this journey. Watch out for it.
            </p>

            <p>
                CANoe&#39;s
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/canoe/canoe/graphics/Gallery/CANoe17.3_Analysis_gallery_EN.jpg">
                trace panel</a> displays all the messages on a CAN network, the sniffing requirement
                I&#39;ve mentioned above. All messages have unique ids and each message&#39;s payload
                contains one or more signals that are attached a predefined meaning, like
                <em>ignition_on</em> or <em>vehicle_speed</em>. Thus, on receiving a CAN message, a
                hypothetical ECU implementation in C would first check its id in a big switch case,
                let&#39;s say. If the id is from the approved list of messages, C goes on and reads the
                payload. We can imagine getters and setters for such signals, like <em>getIgnitionStatus</em> or a
                periodically called function like <em>sendVehicleSpeed</em> that sends this info out
                on the CAN network for all the other ECUs to see. All this data about ids, messages
                and signals can be hard coded, but if it would, CANoe and similar tools would have a
                hard time deciphering what are essentially just bytes on a wire and the user would,
                in the best scenario, only see hexadecimal values in their graphical
                interfaces. They would have to either check the source code to see what they mean or
                some kind of a table like an excel sheet shared by all team members where all
                message ids and signals are kept together and assigned human-readable tags and extra
                info. So to make life &#34;easier&#34; for everyone the list of all CAN messages available
                on a network, together with the ECUs that send or receive them is kept in a
                <a target="_blank" href="http://mcu.so/Microcontroller/Automotive/dbc-file-format-documentation_compress.pdf">dbc</a> database
                that is then used by both the C implementation and the visual tools, a proprietary
                file format also developed by Vector. I&#39;ve put the easier part into quotes. Every
                time I see something advertised as easy and intuitive I&#39;m seeing green meadows and
                leafy forests, blood-sucking ticks waiting in the ambush.
            </p>

            <p>
                Take a look at a
                <a target="_blank" href="https://hackage.haskell.org/package/ecu-0.0.8/src/src/j1939_utf8.dbc">
                    dbc file example</a>. Not human readable. The handling of these databases which,
                by the way, are now officially part of the project&#39;s requirements and managed by the
                client, is done with yet another tool:
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/software/candb/">
                    CANdb</a>. Interestingly, dbc files do not contain the default values nor the interval at
                which signals must be sent, so this extra info is kept in some other medium, like
                <a target="_blank" href="https://stackoverflow.com/questions/48151369/how-to-generate-signal-possible-values-from-dbc-as-a-generic-output-with-capl">
                    excel files</a>, as seen it in practice.
            </p>

            <p>
                But see what problem this need of ours to express CAN messages in a human-readable
                format introduces? Now the list of CAN messages is extracted away from the
                implementation language, extracted and expressed in a format the C language does not
                understand. As a result, every time the client updates the database, the developer
                has to manually translate each and every message from the dbc and excel sheets back
                to source code. A developer&#39;s job, after all. Only this code is quite repetitive,
                huge, prone to fat fingers errors and really boring. All messages have the same
                structure only different names and different byte-orderings. The sane way is to let
                code generators do this job. But code generators are already a new language, the
                language they&#39;re implemented in and the language of how to use them. A rift has
                suddenly appeared out of the blue.
            </p>

            <p>
                Climb up that high mountain and observe the king&#39;s country. C is the implementation
                language for an ECU that handles well-structured CAN messages. Nothing fancy. But
                the need to display and send those messages from external tools, possibly through
                scripting languages, the need to handle these messages with tools that don&#39;t require
                programming skills, the need to gather them into a single file easy to peruse, talk
                about and exchange between teams, all these needs forces the list of such messages
                outside of the implementation language, outside of C. If C&#39;s syntax, with no outside
                help, would be able to express such and use such a list to generate its own
                functions, interfaces and header files from it, that is if C would be able to write
                C, then these extra tools, dbc files, excel sheets and extra build steps would not
                be needed. CANoe or any other tools on their part could use use this well-formatted
                list for their own needs. Even better, if that format would be human-readable as C
                code should be, even creating, editing, searching, diff-ing and reading these files
                in one&#39;s text editor, would be possible without extra tools. But that is not the
                case, and so, we have a fine display of foot soldiers instead of a beautiful white
                horse.
            </p>

            <p>
                To finish this discussion in glory and to confirm in the reader&#39;s eyes that in this
                particular case the introduction of a new language brings nothing really new just a
                slightly different syntax, check out the CAPL example from Vector&#39;s
                <a target="_blank" href="https://support.vector.com/sys_attachment.do?sys_id=a5a6bc0e1bfe18948e9a535c2e4bcb9b">
                    Tips and tricks for the use of CAPL</a>.
            </p>

            <p>
                As a side node, Vector considers C macros too powerful, though they don&#39;t shy away from
                their own macro flavors to aid in writing generic programs,
            </p>

            <blockquote>
                <p>
                    The preprocessor is a powerful tool in the C language, but it can also lead to
                    confusion and consequently to errors. Therefore, only a subset of the well-known
                    preprocessor directives in C is offered in CAPL with comparable semantics [...]
                    In CAPL, there are a number of predefined macros that are available to users for
                    use in the code or for conditional compiling.  Macros for use in the code can be
                    used anywhere in the code without restriction.  In contrast to C, macros may be
                    used freely within string constants, identifiers for variables, and function
                    names. They always begin and end with a % character, and they are primarily used
                    to write generic programs.
                </p>

                <p>
                <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/_technical-articles/CAPL_2_CANNewsletter_201409_PressArticle_EN.pdf">
                    Tips and tricks for the use of CAPL
                </a>
                </p>
            </blockquote>

            <p>
                I&#39;ve simplified things a bit for the sake of discussion and considered only CAN
                networks thus far, but it is worth mentioning that when there are other networks
                present as they usually are, dbc files are not enough. They can&#39;t express Lin,
                FlexRay, MOST or Ethernet networks. An new, xml-based file format is needed for
                that:
                <a target="_blank" href="https://hal.science/hal-02275436/document">FIBEX</a>. A
                first hint that <a target="_blank" href="https://www.defmacro.org/ramblings/lisp.html">xml is quite popular</a>
                for parentheses nay-sayers and a confirmation that the landscape is truly split into
                little kingdoms. I will quote a big chunk from the standard since it reiterates some
                of the things I&#39;ve already covered and as such it might aid up the reader&#39;s
                understanding,
            </p>

            <blockquote>
                <p>
                    A single cluster (ECU) can transfer several hundred or even thousands of shared
                    signals. A network can contain several clusters that are interconnected via so
                    called gateways that transfer signals between them. Many protocols used within
                    the different clusters have been developed to support the different needs of a
                    wide range of applications. Among them are CAN, LIN, FlexRay, and
                    MOST. Obviously, the importance of communication technologies has been increased
                    dramatically.
                </p>

                <p>
                    Databases are necessary to store the information of all signals and their
                    parameters in order to manage efficiently these networks. That data is used for
                    various design and verification steps. Many dedicated tools have shown up on the
                    market to support that. However, their application focus may
                    differ. Unfortunately, no common format for the exchange of data between
                    different tools is presently available. The growing number of signals in a
                    reasonable network yields an increasing demand for a straightforward way to
                    exchange data to avoid an error prone manual handling of redundant
                    data. Furthermore, the fast-growing communication requirements of the
                    implemented functions result into an increasing number of new, extended, and
                    more dedicated tools. This increases the need for an exchange format that
                    supports better data handling.
                </p>

                <p>
                    FIBEX is an XML data structure that can describe a complete network within one
                    file. This data generally includes definitions of signals, frames, clusters, and
                    ECUs sending and receiving the signals. FIBEX can be used to transfer network
                    information between different tools. It is not intended to replace but to
                    supplement established standards that are often used to store data locally. The
                    coexistence with existing formats is regarded as an advantage since available
                    tools and standards can still be used. FIBEX provides a bridge between them.
                </p>

                <p>
                    FIBEX’ strength is seen in the field of tool integration, data exchange, and
                    data integrity. It is “more powerful” than most of the more dedicated
                    formats. For example a single instance can contain the description of clusters
                    with different protocols as well as the transfer function of the gateway between
                    them. FIBEX should be used as an extension whenever the specific format is not
                    sufficient. Since many tool vendors have announced to support FIBEX, a
                    conversion between FIBEX and specific formats should be well supported.
                </p>
                    
                <p>
                    <a target="_blank" href="https://hal.science/hal-02275436/document">FIBEX – An Exchange Format for Networks Based on Field Busses</a></p>
            </blockquote>

            <p id="live-systems">
                <h2>The need to interact with a running system childbirths more tools</h2>
            </p>
            <p>
                In a <a target="_blank" href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/#s16-lisp-as-a-system">perfect world</a> I
                can play with a running system directly from my text editor. I can change variables
                and check their values, I can call any function from anywhere and display, save and
                modify the return result of such calls instantly, I can scribble wild ideas directly
                in code with as little ceremony as possible, I can modify, update and define new
                functions on the go, all this without the need of extra tools, rebuild and restart
                steps. All the code is available at my fingertips, all features before my eyes, no
                hidden parts, no forbidden areas, perfect freedom, all cards on the table, both
                hands on the keyboard. What a joy!
            </p>

            <p>
                In the real world the hints of such joys start with a debugger but these joys are
                soon wrecked. Debuggers understand these time consuming, focus-assassins and
                debilitating &#34;code change, rebuild, restart&#34; cycles,
            </p>

            <blockquote>
                <p>
                    The classic debugging technique is to simply add trace code to the program to
                    print out values of variables as the program executes [...] First of all, this
                    approach requires a constant cycle of strategically adding trace code,
                    recompiling the program, running the program and analyzing the output of the
                    trace code, removing the trace code after the bug is fixed, and repeating these
                    steps for each new bug that is discovered. This is highly time consuming and
                    fatigue making. Most importantly, these actions distract you from the real task
                    and reduce your ability to focus on the reasoning process necessary to find the
                    bug.
                </p>

                <p>
                    <a target="_blank" href="https://www.amazon.com/Art-Debugging-GDB-DDD-Eclipse-ebook/dp/B002N3M6U4">
                    The Art of Debugging with GDB, DDD, and Eclipse</a>
                </p>
            </blockquote>

            <p>
                But debuggers only temporarily avoid the cycle, as any code changes still involve a
                rebuild. And they introduce new tools able to examine the state of a running system,
                tools with their own special terminology, user interfaces and scripting
                languages. On this last point, haven&#39;t you noticed that every intuitive, simple to
                understand, button-clicking tool is heaven in its birthing phases and can act as the
                true savior for a while? Until things get serious, at which point a real programming
                language is always produced for those repetitive or error-prone tasks. Windows
                people have figured that out and turned this problem into
                <a target="_blank" href="https://en.wikipedia.org/wiki/UiPath">fortunes</a>.
                <a target="_blank" href="https://news.ycombinator.com/item?id=41061237">Figma</a>
                people as well.
                <a target="_blank" href="https://news.ycombinator.com/item?id=14482988">Visual
                programming</a> to make life easier?! Regardless, the automotive world doesn&#39;t lack
                such scripting languages as each vendor promotes a different debugger for their own
                special microcontrollers. I&#39;ll mention Lauterbach&#39;s
                <a target="_blank" href="https://support.lauterbach.com/downloads/files/practice-reference-card-pdf-2">PRACTICE</a>
                scripting language with its ancient 
                <a target="_blank" href="https://www2.lauterbach.com/pdf/practice_user.pdf">GOTO statements</a>and
                macros of three different kinds (local, global or private) and even recursive
                macros. Macros&#39; crusaders surely like the idea of macros. Check the documentation
                for the details.
            </p>            

            <p>
                There are alternatives to the use of debuggers in the automotive field, none better
                nor powerful enough to conquer all the other tribes, as I&#39;ve already hinted in the
                introduction, not even the debugger itself. I&#39;ll look at two of them.
            </p>

            <p>
                Firstly, the
                <a target="_blank" href="https://raw.githubusercontent.com/Microrain-zh/uds_protocol/master/ISO_14229-1_2013.en.PDF.pdf">
                Unified Diagnostic Services (UDS)</a> or Diag, for short. It&#39;s a feature all ECUs
                must implement by law and it allows a car shop to configure, update, and check the
                ECU&#39;s status. Diag is still about sending CAN messages, or routines in
                Diag-speak. These are standardized messages used to read certain memory addresses,
                predefined identifiers which are mapped to variables in the C implementation, as
                well as to write them. In short, poke your ECU like it was a server with all kinds
                of GET or POST requests and
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/canoe/canoe/graphics/Gallery/CANoe15_Diagnostics_gallery_EN.jpg">
                check its response</a> in CANoe&#39;s or other vendor&#39;s intuitive
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/software/canoe/diagnostics/">Diag</a>
                interface. The 400 pages long ISO standard has all the details,
            </p>

            <blockquote>
                <p>
                    Modern vehicles have a diagnostic interface for off-board diagnostics, which
                    makes it possible to connect a computer (client) or diagnostics tool, which is
                    referred to as tester, to the communication system of the vehicle. Thus, UDS
                    requests can be sent to the controllers which must provide a response (this may
                    be positive or negative). This makes it possible to interrogate the fault memory
                    of the individual control units, to update them with new firmware, have
                    low-level interaction with their hardware (e.g. to turn a specific output on or
                    off), or to make use of special functions (referred to as routines) to attempt
                    to understand the environment and operating conditions of an ECU to be able to
                    diagnose faulty or otherwise undesirable behavior.
                </p>

                <p>
                    <a target="_blank" href="https://en.wikipedia.org/wiki/Unified_Diagnostic_Services">Wikipedia: Unified Diagnostic Services</a><br/>
                    
                </p>
            </blockquote>

            <p>
                In a shocking move, the dbc file format we&#39;ve already seen is not designed to hold
                Diag messages though Diag messages are still just CAN messages. At 500 pages long,
                the ODX standard introduces a new xml-based file format to fill this gap,
            </p>

            <blockquote>
                <p>
                    The ODX specification contains the data model to describe all diagnostic data of
                    a vehicle and physical ECU, e.g. diagnostic trouble codes, data parameters,
                    identification data, input/output parameters, ECU configuration (variant coding)
                    data and communication parameters. ODX is described in Unified Modeling
                    Language (UML) diagrams and the data exchange format uses XML.
                </p>

                <p>
                    <a target="_blank" href="https://libgen.li/ads.php?md5=c5d5a0dc51624268ded4b34c632ec846">
                        ISO 22901-1: Road vehicles - Open diagnostic data exchange (ODX)</a>
                </p>
            </blockquote>

            <p>
                In a rare admission of a war campaign gone wrong, or to smear its adversaries and
                push its own solutions, Vector recognizes this is a complex beast one dares not tame
                with bare hands,
            </p>

            <blockquote>
                <p>
                    Until now, the process of creating ODX data has been restricted to just a
                    limited circle of experts, due to its complexity. The current specification
                    encompasses almost 400 pages. Users of the ODX data would rather concentrate on
                    their actual task, namely the development of diagnostic applications, without
                    having to deal with the specification or the data format and its dialects. With
                    suitable tool support this is possible.
                </p>

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/_technical-articles/diagnostics/ODX_HanserAutomotive_200612_PressArticle_EN.pdf"> ODX in Practice: Experiences, challenges and potential</a>                   
                </p>
            </blockquote>

            <p>
                The suitable tool is Vector&#39;s
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/software/candelastudio">CANdelaStudio</a>.
                In a surprise move, the Diag data is not saved in the ODX format, as expected, but
                in its own proprietary CDD (CANdelaStudio Diagnostic Description) file format. It&#39;s
                the hunting season for file formats! The advantages section mentions that CDD files
                can be exported to other formats like CSV, HTML, ODX, RTF, XML,
                <a target="_blank" href="https://www.vector.com/at/en/products/application-areas/ecu-calibration/a2l-data-description">a2l</a>,
                DEXT or CDI (I couldn&#39;t find what this is). I&#39;ll quote Autosar&#39;s DEXT, and come back
                to Autosar itself later in this article, since it give some reasons why even ODX is
                not sufficient for all needs and even new standards and formats are needed,
            </p>

            <blockquote>
                <p>
                    The market shows a high demand for transferring diagnostic demands to [...]
                    suppliers. In the past, due to the absence of integral options, many file
                    formats like ODX or EcuC were often used. But neither ODX nor EcuC is well
                    suited to transfer this information. For example, ODX lacks in fault memory
                    details and EcuC has a very generic nature that renders the enforcement of a
                    strict model formalization very difficult. Therefore, the obvious solution
                    approach has been to define a new standardized AUTOSAR exchange format on
                    diagnostic functionality that can be used similar to a System Description,
                    formalized as an ARXML file.
                </p>

                <p>
                    <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R20-11/CP/AUTOSAR_TPS_DiagnosticExtractTemplate.pdf">
                        AUTOSAR: Diagnostic Extract Template
                    </a>
                </p>
            </blockquote>

            <p>
                I&#39;ve seen examples on the rigidness of these tools. Sometimes people want to
                highlight the features to be implemented in the next release or make some notes
                around them. Other times the team would ask the client if this or that Diag service
                can be added or this or that CAN message added, removed or modified, either because
                it was really wrong or because it was an internal message the team relies on. Since
                these visual tools do not provide the features to annotate, copy/paste, modify or
                comment out things, the teams relies on word documents, excel sheets, emails or just
                video calls and drawings on screen. With these, the places where one finds the
                project requirements increases as well, only because these languages developed to
                extend the original stiff language, are themselves not extendable by their users.
            </p>

            <p>
                Diag still doesn&#39;t solve the development speed problem. It has access to some
                predefined variables for reading and writing. It can call out functions through
                these Diag routines and all this helps. When one of these variables or some part of
                the code you&#39;re currently developing is not callable through any Diag routine, the
                solution is to implement such a routine which requires knowledge of how the Diag
                module works, something that might be outside your actual problem you&#39;re trying to
                solve. This still bring us back to a rebuild and reflash cycle.
            </p>

            <p>
                Secondly, the other alternative to a Debugger is Calibration. A new protocol and a
                new standard. A way to modify configuration options, or memory addresses, in a
                running ECU without touching the code The absence of any features to do so without
                recompiling the whole project is clearly stated as the motivation behind the
                standard,
            </p>

            <blockquote>
                <p>
                    The calibration of parameters is an essential part of ECU software
                    development. Once a new set of parameters has been determined, the next
                    development step is to run tests in order to evaluate the effectiveness of the
                    calibration. For this purpose, internal variables are read from memory and
                    transferred to a system that displays the data in a human-readable format.
                </p>

                <p>                    
                    In the early days of ECU development, the values of calibration parameters were
                    directly modified in the source code. Variables had to be made available for
                    data logging in the source code as well. Every change to parameters or the list
                    of measurable variables required modifications in the source code,
                    re-compilation and flashing of the ECU.
                </p>

                <p>
                    As the control software grew in complexity [...] this process became too
                    cumbersome and slow. Additionally, the process of measurement &amp; calibration
                    needed to be separated from the process of software development, because a
                    calibration engineer would need to change a parameter value or would want to
                    record the values from a measurement variable, he had to ask the software
                    developer to compile a new software version for him. This is the fundamental
                    motivation for the group of ASAM MCD standards. The MCD standard provided the
                    way to abstract the calibration from the physical memory locations.
                </p>

                <p>
                    <a target="_blank" href="https://www.asam.net/standards/detail/mcd-2-mc/wiki/">ASAM MCD-2 MC</a>                    
                </p>
            </blockquote>

            <p>
                CANoe&#39;s <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/_technical-articles/CANoe_AMD_XCP_PressArticle_201812_EN.pdf">
                AMD/XCP</a> plugin offers another perspective on this issue,
            </p>

            <blockquote>
                <p>
                Option AMD/XCP extends CANoe by adding the ability to access ECU memory. This access is done via the
                ASAM-standardized XCP or CCP protocol and is convenient to configure with files in A2L format.
                </p>

                <p>
                CANoe offers access to internal ECU values via XCP/CCP for testing and analysis tasks. In contrast
                to the pure blackbox test, in which only the external ECU signals are stimulated and measured,
                internal values can also be calibrated and evaluated over XCP/CCP. Changes to these parameters lead
                to specific error states, and the resulting ECU behavior can be tested directly. It is also possible
                to test different variants of ECU software – switching is performed directly over XCP. Missing
                sensor values can also be simulated by writing values to the relevant memory locations via XCP/CCP.
                </p>

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/products/canoe/canoe/docs/Product%20Informations/CANoe_ProductInformation_EN.pdf">CANoe: Product Information</a>
                </p>
            </blockquote>

            <p>
                An a2l file contains all the memory addresses we want to be able to read and write
                together with a meaning attached to each address, the size and the type of data one
                expects to find there (here is a
                <a target="_blank" href="https://github.com/christoph2/pyA2L/blob/18db093f9856a51d304dcde05f84b3d6e63b3d62/examples/example-a2l-file.a2l">a2l
                example file</a> and <a target="_blank" href="https://www.asam.net/index.php?eID=dumpFile&amp;t=f&amp;f=2132&amp;token=1672c6611f14141ae705140149a9401141821de0">ASAM&#39;s downloads section</a>
                offers additional examples). Functions that transform from one type of data to
                another are also defined in such files as there is a conversion of types between the
                target (ECU, C implementation) and the tools that use that data in a &#34;human-readable
                format&#34;. For complex transformations where a real programming language is needed,
                the standard mentions a way to specify Windows DLL files in the a2l files. No
                mention of Linux, for example. Additionally the transfer protocol (XCP or CCP)
                between the PC must also be specified by a metalanguage (AML). This is the same rift
                we&#39;ve seen before. Simplistically, one side needs to know what to ask for and to
                know how to interpret the response once it receives it; the other side needs to know
                where to look for the requested information. In the middle, someone must take care
                that the message gets across the valley through some medium (XCP or CCP),
            </p>

            <blockquote>
                <p>
                    To convert the ECU internal characteristic and measurement implementation values
                    into physical values, ASAM MCD-2 MC describes computation methods for their
                    conversion between both representations. Calibration engineers can work with the
                    ECU data in a familiar format without having to understand ECU-internal data
                    formats. Software engineers can provide this data to them or even get the
                    description files automatically generated from code generators. An include
                    mechanism ensures that description files can originate from different sources.
                </p>

                <p>
                    The ECU normally stores the measurement and calibration quantities internally in
                    an implementation optimized format. This format is very often a fixed-point
                    format. Outside the ECU physical models are used. The standard describes by
                    so-called record layouts how data are stored inside the ECU and which
                    computation methods are needed to transform the ECU internal data representation
                    into the physical one and vice versa.
                </p>

                <p>
                    The standard also allows to describe and configure the ECU interfaces or vendor
                    specific extensions by a meta description language (AML). For ASAM standardized
                    ECU interfaces, such as CCP and XCP the content of these AML parts are also
                    standardized. But there are also a lot of vendor specific instantiations in the
                    market which use this mechanism.
                </p>
                
                <p>    
                    Measurement and calibration systems are normally only used during development
                    phase of ECUs. They allow a direct, address-oriented write and read-access but
                    also a synchronous, continuous measurement access to ECU internal variables.
                </p>

                <p>
                    <a target="_blank" href="https://pdfcoffee.com/download/asam-ae-mcd-2-mc-bs-v1-7-1-pdf-free.html">ASAM MCD-2 MC (ASAP2 / A2L) - Data Model for ECU Measurement and Calibration (Version 1.7.1)</a>
                </p>
            </blockquote>

            <p>
                This is another non-human readable file format to be handled only with tools. Since
                the memory addresses in a2l files are hard coded, any C code change that results in a
                change of allocated addresses after a build must lead to a change in the a2l file as
                well, or we&#39;ll read and write a different location than the one we&#39;d expect to. This
                step is done with code generator tools, as confirmed even by the official
                documentation.
            </p>

            <p>
                Tools and standards, a protocol (XCP, not CAN) and a file format (a2l) are needed to
                access what are practically variables from a running application,
            </p>

            <blockquote>
                <p>
                    With the XCP protocol standardized by ASAM, the user can read individual values
                    directly from the ECU as needed. Once the A2L file has been configured and the
                    necessary values selected, CANoe automatically acquires them and maps them as system
                    variables. The user can then use these variables in any of the testing
                    tasks. Besides offering access to ECU inputs and outputs, they also provide an
                    in-depth look into the ECU’s memory.
                </p>

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/_technical-articles/CANoe_AMD_XCP_PressArticle_201812_EN.pdf">
                        Vector: A Look Behind the Scenes; ECU testing with XCP support</a>                    
                </p>
            </blockquote>

            <p>
                The testing phase itself is done with CAPL or with CANape as we&#39;ll soon see. One
                extracts the values of variables from a running ECU, maps them through an a2l file,
                makes them available to one&#39;s system and uses them for testing purposes using a
                different language than the language used to implement the system in the first
                place. Does that sound &#34;simple&#34;? No need to stress it, but any bugs or missing
                features found in this way will need to be fixed by modifying the C code, the
                language the actual system is implemented in. So back again to the rebuild cycle.
            </p>

            <p>
                The a2l files specify the addresses and what goes where, a sort of an API, if you
                will. But the actual data to be written or read from an ECU is stored in a different
                format.
                <a target="_blank" href="https://www.asam.net/standards/detail/cdf/wiki/">ASAM
                CDF</a> specifies an XML file format for this purpose while the
                <a target="_blank" href="https://www.asam.net/standards/detail/mdf/wiki/">ASAM MDF</a>
                a &#34;very efficient binary format&#34;. As well as the a2l example mentioned above, the
                ASAM&#39;s website
                <a target="_blank" href="https://www.asam.net/standards/detail/cdf/wiki/">downloads section</a>
                also has
                <a target="_blank" href="https://www.asam.net/index.php?eID=dumpFile&amp;t=f&amp;f=2132&amp;token=1672c6611f14141ae705140149a9401141821de0">
                cdf and mdf file examples</a>.
            </p>

            <p>
                Vector has found &#34;clever&#34; ways to generate the a2l files, either through
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/asap2/ASAP2Tool-Set_Screenshot_EN.png">ASAP2 Studio</a>&#39;s
                &#34;intuitive&#34; interface
                <a target="_blank" href="https://www.vector.com/at/en/products/application-areas/ecu-calibration/a2l-data-description">among
                others</a>, but also from source code directly via C code comments. This, of course,
                needs outside parsers and code generators since C can do nothing with its own code,
                which in this case is not even code but a predefined way to tag comments similar to
                what some tools would use to generate documentation. Here is an example from
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/asap2/Docs/ASAP2Tool-Set_Manual_EN.pdf">ASAP2
                Tool-Set User Manual</a> on how to annotate C code with comments for the automatic
                generation of a2l files at build time (check the manual for more examples),
            </p>

            <blockquote>
                <p>
                    /*</p><p>
                        results in...
                    </p>
                    
                    /begin MEASUREMENT sample1 &#34;&#34;</blockquote>

            <p>
                This rift, this mismatch at the boundary between two systems expressed in different
                languages, is another recurring theme. It always creates a need to conceive extra
                formats to patch that gap and make the two understand each other and use each other&#39;s
                data. That&#39;s a big problem when tools proliferate due to there not being a powerful
                one in the first place. It is why our traveler takes ten days for a journey that
                should take just one. Kings of the old knew that. If everybody does not speak the
                same language and enjoy the same culture, willingly or forcefully through the kiss
                of the sword, every journey through the king&#39;s land involves talking to every
                tribesman to secure safe passage. Some ask exorbitant prices, some refuse
                outright. A dirty business and a bad climate for business.
            </p>

            <p>
                It is the same story with prose writing, I find. If English hadn&#39;t given me the
                words and metaphors and the technical means to wrap up things in rifts and kings, I
                would either have to use another language (and offer the reader a dictionary and a
                way of translating from one expression to another, similar to what a2l does) or
                repeat the same things over and over. But as things stand I can wrap up concepts
                already talked about and understood by the reader in a few words or images and refer
                to them instead, shifting the discussion to a higher level. Or my language can be
                visual, like in arts, or theater or music. In that case the medium of transmission
                is different which is what all these file formats do. Eventually in life one must
                pass beyond the everyday language of &#34;he did this, then he did that&#34; to express some
                different concepts and feelings. Maybe that&#39;s the meaning of the well-known saying
                that &#34;Lisp has assisted a number of our most gifted fellow humans in thinking
                previously impossible thoughts&#34;. Additionally, the quest for such metaphors is
                another technical problem. Similar to iteration speed in programming, I want to
                quickly find new words, write them down, reread, edit, delete, write again. As fast
                as possible. I can&#39;t imagine what writing without a computer was like in the past.
            </p>

            <p>
                I&#39;ve hinted in a previous comment about a tool to handle all this calibration
                business in one place, a special tool only for this purpose,
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/software/canape">CANape</a>
                (CAN Application Programming Environment) or &#34;The Universal Tool in the Vehicle,
                Test Bench and Laboratory&#34; (see 
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/canape/Docs/CANape_ProductInformation_EN.pdf">
                    CANape: Product Information</a>).
            </p>

            <p>
                The Wikipedia article on <a target="_blank" href="https://en.wikipedia.org/wiki/CANape">CANape</a> stresses
                the part where one does not modify the source code but updates the configuration
                variables to change an ECUs behavior, which is avoiding the exact rebuild-restart
                cycle I&#39;ve underlined already.
            </p>

            <p>
                Again, because buttons and clicks help a user only up to a certain point, to make
                sense of the possibly thousands of data points per second, CANape uses a scripting
                language. Can you guess it? Is it CAPL? No! It&#39;s CASL (Calculation and Scripting
                Language). Don&#39;t stress, though, &#34;the syntax of CASL is very similar to the C
                programming language&#34;. The official manual even assures one of only needing a
                general programming knowledge of C and nothing else,
            </p>

            <blockquote>
                <p>
                    Note: Do not confuse CASL with the programming language CAPL, which is used in
                    the CANoe and CANalyzer environments. CAPL is an event-oriented programming
                    language. So-called CAPL program nodes are used to specify when an event will be
                    executed and the nature of the reaction. CASL, on the other hand, is a
                    signal-oriented language.
                </p>

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/products/canape/Docs/CANape_CASL_Manual_EN.pdf">
                        CANape CASL: User Manual</a>
                </p>
            </blockquote>

            <p>
                The fear of pointers is still with us, plus extra trivialities,
            </p>

            <blockquote>
                <p>
                    The CANape scripting language CASL is very similar to the C programming language. However, it
                    differs in the following aspects:
                </p>
                <ul>
                    <li>CANape uses only double values for internal calculations</li>
                    <li>CANape does not use pointers</li>
                    <li>A missing result type is interpreted as void</li>
                    <li>Arrays of any dimension and size may be passed</li>
                    <li>An empty parameter list is allowed like in C++</li>
                    <li>Overloading of functions (i.e., multiple functions with the same name but with
                        different parameter lists) is possible like in C++</li>
                    <li>A parameter check is made like in C++</li>

                </ul>
                

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/products/canape/Docs/CANape_CASL_Manual_EN.pdf">
                        CANape CASL: User Manual</a>
                </p>
            </blockquote>

            <p>
                CASL is still not strong enough. It can be extended through DLLs for case where you
                might still want to go back and actually
                <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/_application-notes/AN-IMC-1-012_How_to_use_C-Code_Functions_in_CANape.pdf">
                    use C functions directly from CASL</a>, a language developed to interact with
                systems developed in C, or I donno, it all starts to get really confusing at this
                point so I&#39;ll leave it to you to explore it further.
            </p>

            <p id="language-environment">
                <h2>A language is not just its syntax but the tools and environment around it</h2>
            </p>

            <p>
                Embedded developers are a special kind of software people. They use countless IDEs,
                probably a legacy of each microprocessor vendor mixing up their own IDE to be sold
                as opium for all the known software affections. At least in that other fantasy land,
                the rivalry is between two venerable kings, Emacs and VIM, but here the
                <a target="_blank" href="https://www.reddit.com/r/embedded/comments/1e4rbbk/of_ides_and_holy_wars">holy wars</a> look
                different, some of them use plain Nodepad, some have &#34;advanced&#34; to Notepad++,
                <a target="_blank" href="https://ww1.microchip.com/downloads/en/devicedoc/50002027d.pdf">MPLAB</a>,
                <a target="_blank" href="https://www.st.com/en/development-tools/stm32cubeide.html">CubeIDE</a>,
                <a target="_blank" href="https://doc.qt.io/qtcreator">QtCreator</a> and some to
                <a target="_blank" href="https://www.nxp.com/docs/en/user-guide/IDE_5.9_Users_Guide.pdf">CodeWarrior</a>,
                the best kind of warrior for our wannabe emperor. Even the DSLs (yes, let&#39;s call
                them that and stop pretending) like CAPL and CASL and the other programming
                languages we&#39;ve seen until now come with their own IDEs.
            </p>

            <p>
                Here is what GreenHils, one these poison-mixers, is saying
            </p>

            <blockquote>
                <p>
                    By using a common set of development tools across projects, software engineers
                    can more easily share code or move between projects without compromising
                    productivity. The Project Builder’s intuitive GUI automates and simplifies the
                    configuration of complex programming projects. With its automatic dependency
                    determination, the Builder also helps cut time-to-market by eliminating the need
                    to write and debug makefiles.
                </p>

                <p>
                    <a target="_blank" href="http://flashtech.com.my/PDF/GH-MultiIDE.pdf">MULTI -
                        Integrated Development Environment for Device Software Optimization</a>
                </p>
            </blockquote>

            <p>
                God forbid the maker and his makefiles. They&#39;re too old and well established to keep
                using them. QtCreator employs
                <a target="_blank" href="https://doc.qt.io/qt-6/qmake-manual.html">qmake</a>
                to &#34;help simplify the build process for development projects across different
                platforms. It automates the generation of makefiles so that only a few lines of
                information are needed to create each makefile&#34;. The MULTI IDE uses a proprietary,
                xml-based, configuration file (<a target="_blank" href="https://amazingalgorithms.com/file-extensions/gpj">gpj</a>)
                instead of makefiles but it also generates makefiles behind our backs. The switch to
                other tools to edit configuration options now becomes a near impossibility, as now
                everything that can be configured must be configured through that vendor&#39;s random
                interface, buttons and menus, a new interface from the ones already familiar to you,
                an interface bound to change. Some IDEs even have different config files that are
                incompatible from one version to the next,
            </p>

            <blockquote>
                <p>
                    [...] my main complaint with other tools is proprietary config file formats
                    which leave me stuck using their low-effort interface for absolutely every
                    change before compiling. If I can&#39;t use my favorite text-based tool to
                    diff/compare and make meaningful configuration changes, I will curse every extra
                    click or scroll that I&#39;m forced to perform in their proprietary software just to
                    change an option for which I already know the name.
                </p>

                <p>
                    <a target="_blank" href="https://www.reddit.com/r/embedded/comments/1cgsgbw/how_to_improve_autosar_stack/">A reddit user</a>
                </p>                
            </blockquote>

            <p>
                As an example of how complicated and how non-standard such a setup can become, see
                the official Getting Started with
                <a target="_blank" href="https://www.nxp.com/docs/en/supporting-information/DWF13_AMF_AUT_T1059.pdf">Green Hills Tools</a>
                 guide from Renesas, a semiconductor manufacturer, as there is no freely available
                 online documentation or tutorial from GreenHills itself on how all this works.
            </p>

            <p>
                Speaking of Renesas, they proudly boast their own accomplishments in the IDE&#39;s field,
            </p>

            <blockquote>
                <p>
                    CS+ is an IDE integrating the necessary tools for the development phase of
                    software (e.g. design, implementation, and debugging) into a single platform. By
                    providing an integrated environment, it is possible to perform all development
                    using just this product, without the need to use many different tools
                    separately.
                </p>

                <p>
                    <a target="_blank" href="https://www.renesas.com/us/en/document/man/cs-v80500-integrated-development-environment-users-manual-ghs-ccrh850-build-tool-operation">
                    CS+ V8.05.00 Integrated Development Environment: User’s Manual</a>
                </p>
            </blockquote>

            <p>
                But Renesas goes one step further into unexplored territory. They have four
                different IDEs in their shop and even different, incompatible proprietary config
                file formats at that! Even inside the same company it proves quite impossible to decide
                on a single file format. There is ample documentation on
                <a target="_blank" href="https://www.renesas.com/us/en/software-tool/migration-tools-ide">
                    how to migrate between IDEs</a>
                (or <a target="_blank" href="https://www.renesas.com/us/en/document/mat/project-conversion-between-e-studio-and-cs-notes-and-tips">here</a>)
                and even from their IDEs to GreenHills. That&#39;s just a hint on how complicated even
                the business of writing code in a text editor can become.
            </p>

            <p id="non-formal-methods">
                <h2>Rules and processes are enforced with non-formal methods</h2>
            </p>

            <p>
                Even in a
                <a target="_blank" href="https://mihaiolteanu.me/language-abstractions">dead language like C</a>
                that offers no means to create incomprehensible DSLs and rich abstractions one can
                still bring to life ugly monsters,
            </p>

            <blockquote>
                <p>
                While C programs can be laid out in a structured and comprehensible manner, C makes
                it easy for programmers to write obscure code that is difficult to understand.
                </p>

                <p>
                There are areas of the language that are commonly misunderstood by programmers. For
                example, C has more operators than some other languages and consequently has a high
                number of different operator precedence levels, some of which are not intuitive. The
                type rules provided by C can also be confusing to programmers who are familiar with
                strongly-typed languages. For example, operands may be &#34;promoted&#34; to wider types,
                meaning that the type resulting from an operation is not necessarily the same as
                that of the operands.
                </p>

                <p>
                C programs can be compiled into small and efficient machine code, but the trade-off
                is that there is a very limited degree of run-time checking. C programs generally do
                not provide run-time checking for common problems such as arithmetic exceptions
                (e.g. divide by zero), overflow, validity of pointers, or array bound errors. The C
                philosophy is that the programmer is responsible for making such checks explicitly.
                </p>

                <p>
                    <a target="_blank" href="https://github.com/sakura1083841400/MISRA-C/blob/main/MISRA%20C%202012%20Guidelines%20for%20the%20use%20of.pdf">
                        MISRA C:2012 Guidelines for the use of the C language in critical systems
                    </a>
                </p>
            </blockquote>

            <p>
                The solution in automotive is to define standards that enforce certain coding
                practices, ban features like multiple returns from a single function, ban recursive
                functions or the dynamic allocation of memory (malloc) at runtime. But since one
                needs global constants to at least keep ECU configuration options (see Calibration,
                for example), this last rule forces a static pre-allocation of all memory at
                build-time. The usual approach is to keep tables with variable names, addresses and
                memory sizes in excel sheets, but since excel sheets are outside of C syntax, guess
                what do we need to bring in again?  Code generators! I won&#39;t dwelve on this issues
                again as it&#39;s already familiar from the dbc files discussion.
            </p>

            <p>
                The somewhat good news is that some of MISRA rules can be enforced with static
                checkers. These can generate reports about what rules are followed and what not,
                similar to a compiler. That bad news is that some rules can only be checked by
                manual inspection alone so you put your faith in the good will and patience of the
                developer,
            </p>

            <blockquote>
                <p>
                    It is possible to check that C source code complies with MISRA C by means of inspection alone.
                    However, this is likely to be extremely time-consuming and error prone. Any realistic process for
                    checking code against MISRA C will therefore involve the use of at least one static analysis tool.
                </p>

                <p>
                    All of the factors that apply to compiler selection apply also to the selection of static analysis
                    tools, although the validation of analysis tools is a little different from that of compilers. An
                    ideal static analysis tool would:
                </p>

                <ul>
                        <li>Detect all violations of MISRA C guidelines;</li>
                        <li>Produce no &#34;false positives&#34;, i.e. would only report genuine violations and would not report
                            non-violations or possible violations.</li>
                    </ul>
                
                
                <p>
                    It is not, and never will be, possible to produce a static analysis tool that
                    meets this ideal behavior. The ability to detect the maximum number of
                    violations possible, while minimizing the number of false positive messages, is
                    therefore an important factor in choosing a tool.
                </p>

                <p>
                    There is a wide range of tools available with execution times ranging from
                    seconds to days. Broadly speaking, tools that consume less time are more likely
                    to produce false positives than those that consume large amounts of
                    time. Consideration should also be given to the balance between analysis time
                    and analysis precision during tool selection.
                </p>

                <p>
                    Analysis tools vary in their emphasis. Some might be general purpose, whereas
                    others might focus on performing a thorough analysis of a subset of potential
                    issues. Thus it might be necessary to use more than one tool in order to
                    maximize the coverage of issues.
                </p>

                <p>
                    Each mandatory, required and advisory rule is classified as decidable or
                    undecidable. This classification describes the theoretical ability of a static
                    analyzer to answer the question “Does this code comply with this rule?” The
                    directives are not classified in this way because it is impossible, given only
                    the source code, to devise an algorithm that could guarantee to check for
                    compliance.
                </p>

                <p>
                    <a target="_blank" href="https://github.com/sakura1083841400/MISRA-C/blob/main/MISRA%20C%202012%20Guidelines%20for%20the%20use%20of.pdf">
                        MISRA C:2012 Guidelines for the use of the C language in critical systems
                    </a>
                </p>
            </blockquote>

            <p>
                One feature, or a limitation, is that the committee admits not all use-cases can be
                foreseen by the standard so it offers a &#34;deviation&#34; feature. A deviation is another
                non-formal piece of text saying this or that rule can be skipped in this or that
                circumstance: &#34;It is important that such deviations are properly recorded and
                authorized. Individual programmers can be prevented from deviating guidelines by
                means of a formal authorization procedure. Formal record keeping is good practice and
                supports any safety argument that might be made for the software.&#34;
            </p>

            <p>
                So MISRA rules save some headaches and errors when applied, but there are places
                where they don&#39;t apply and that is necessary for the project and good. After a while
                you kinda start
                <a target="_blank" href="https://news.ycombinator.com/item?id=38182855">ignoring MISRA</a>
                with &#34;we need this here anyway, MISRA doesn&#39;t know what is doing, I&#39;ll just check
                this in and be merry&#34;. It is a standard that employs extra tooling for it to be
                enforced and generates additional documents, be them Word documents or code
                comments, or what have you.
            </p>

            <p> I don&#39;t think this is truly realized, but all this information written down in word
                sheets, requirements, knowledge passed on in meetings, little tricks and short hacks
                solved in video calls, information passed in emails and instant messaging is
                information that is part of the project, that is put down in some kind of a
                language, a non-formal one like English or tables or boxes or scribbles or laughs
                and jokes. The more a project has of these, the harder it is to talk about and
                verify the actual state of the project as it is obviously impossible to evaluate a
                non-formal language like you would a formal programming language and thus it becomes
                that much harder to explore and play with, test and explore the project.</p>

            
            <p id="dsls">
                <h2>Domain specific languages are everywhere</h2>
            </p>
            <p> Some colleagues openly admitted of not knowing C at all, even though their CVs and
                their positions assumed such knowledge. But how? They&#39;ve developed visual models in <a target="_blank" href="https://www.mathworks.com/products/simulink.html">Simulink</a>, &#34;a block
                diagram environment used to design systems with multi domain models, simulate before
                moving to hardware, and deploy without writing code.&#34; Unlike the CANoe ECU models
                that are meant to aid in the understanding of the project but need a software
                developer to write the ECU code, this graphical programming language also generates the C
                code, efficient and MISRA compliant at that. See the <a target="_blank" href="https://www.mathworks.com/solutions/embedded-code-generation/production-code-automotive-ecu.html">Automotive
                Code Generation</a> page for details. C is here treated as a kind of a bytecode,
                never to be seen, never to be touched. Now don&#39;t go buzzing me with &#34;we don&#39;t need
                nor like DSLs here&#34; silly story. I won&#39;t believe you anymore. I can&#39;t!  </p>

            <p>
                The graphical programming language, similar to
                <a target="_blank" href="https://www.ni.com/en/shop/labview.html">LabVIEW</a> if
                you&#39;re more familiar with that, is used to move blocks around and connect them to
                pass the data and the computational results from one block to another, as one would
                call functions and return their values in a classic text-based programming
                language. Behind each block is
                <a target="_blank" href="https://www.mathworks.com/products/matlab/programming-with-matlab.html">
                    Matlab</a>, &#34;a high-level programming language designed for engineers and scientists
                that expresses matrix and array mathematics directly&#34;. Some user success stories for
                warm-up follow,
            </p>

            <blockquote>
                <p>
                    Simulink is particularly helpful in two stages of our development process. Early
                    on, it helps us try new ideas and visualize how they will work. After generating
                    code and conducting in-vehicle tests, we can run multiple simulations, refine
                    the design, and regenerate code for the next iteration.
                </p>

                <p>
                    <a target="_blank" href="https://www.mathworks.com/products/simulink.html">
                        Jonny Andersson, Scania
                    </a>
                </p>
            </blockquote>

            <blockquote>
                <p>
                    Whether you’re developing controls for [...] an autonomous vehicle, an
                    excavator, [...], if your team is manually writing code and using document-based
                    requirements capture, the only way to answer these questions will be through
                    trial and error or testing on a physical prototype. And if a single requirement
                    changes, the entire system will have to be recorded and rebuilt, delaying the
                    project by days, or even weeks.
                </p>
                
                <p>
                    Using Model-Based Design with MATLAB® and Simulink®, instead of handwritten code
                    and documents, you create a system model [...]. You can simulate the model at
                    any point to get an instant view of system behavior and to test out multiple
                    what-if scenarios without risk, without delay, and without reliance on costly
                    hardware.
                </p>

                <p>
                    <a target="_blank" href="https://www.mathworks.com/content/dam/mathworks/white-paper/gated/model-based-design-with-simulation-white-paper.pdf">
                        Model-Based Design for Embedded Control Systems
                    </a>                   
                </p>
            </blockquote>

            <p>
                Exactly the issue I&#39;ve touched upon in the introduction. C&#39;s abstractions are not
                powerful enough to rise above dumb low-level details and get a clear picture of what
                you&#39;re trying to achieve, talk about that, share those bigger ideas with colleagues
                and refine on them. It also touches on that other point, namely, the iteration
                speed, how fast can you go from one version to the next, how fast can you change the
                implementation, test it, rewrite it, change your assumptions, see something
                tangible and not just imagining things and talking about things in meetings and on
                informal communication channels, be them video or texting.
            </p>

            <p>
                But, my apologies for the interruption, I&#39;ll let these people talk for themselves,
                since they touch on all the pain points so beautifully,
            </p>
            
            <blockquote>
                <p>
                    In a traditional workflow, where requirements are captured in documents, hand off
                    can lead to errors and delay. Often, the engineers creating the design documents
                    or requirements are different from those who design the system. Requirements may
                    be “thrown over a wall,” meaning there’s no clear or consistent communication
                    between the two teams.
                </p>

                <p>
                    In Model-Based Design, you author, analyze, and manage requirements within your
                    Simulink model. You can create rich text requirements with custom attributes and
                    link them to designs, code, and tests. Requirements can also be imported and
                    synchronized from external sources such as requirements management tools. When a
                    requirement linked to the design changes, you receive automatic notification. As
                    a result, you can identify the part of the design or test directly affected by
                    the change and take appropriate action to address it.
                </p>

                <p>
                    In a traditional workflow, embedded code must be handwritten from system models
                    or from scratch.  Software engineers write control algorithms based on
                    specifications written by control systems engineers. Each step in this
                    process—writing the specification, manually coding the algorithms, and debugging
                    the handwritten code can be both time-consuming and error-prone. With
                    Model-Based Design, instead of writing thousands of lines of code by hand, you
                    generate code directly from your model, and the model acts as a bridge between
                    the software engineers and the control systems engineers. The generated code can
                    be used for rapid prototyping or production. Rapid prototyping provides a fast
                    and inexpensive way to test algorithms on hardware in real time and perform
                    design iterations in minutes rather than weeks. You can use prototype hardware
                    or your production ECU. With the same rapid prototyping hardware and design
                    models, you can conduct hardware-in-the-loop testing and other test and
                    verification activities to validate hardware and software designs before
                    production.  Production code generation converts your model into the actual code
                    that will be implemented on the production embedded system. The generated code
                    can be optimized for specific processor architectures and integrated with
                    handwritten legacy code.
                </p>
               
                <p>
                    <a target="_blank" href="https://www.mathworks.com/content/dam/mathworks/white-paper/gated/model-based-design-with-simulation-white-paper.pdf">
                        Model-Based Design for Embedded Control Systems
                    </a>                   
                </p>
            </blockquote>

            <p>
                Check out an example of generating C code from a Simulink model with the
                <a target="_blank" href="https://www.mathworks.com/help/rtw/ug/generating-code-using-simulink-coder.html">Simulink Coder</a>.
                Since the generated code must fit in with the rest of the project, sometimes adjustments are
                necessary, like in this example on how to
                <a target="_blank" href="https://www.mathworks.com/help/rtw/ug/configure-model-data-for-c-code-generation.html">configure the model</a> for
                C code generation.                
            </p>

            <p>
                Needless to say, this is a whole new and complex language, &#34;we don&#39;t need no special
                new languages besides C, we need only if&#39;s, else&#39;s and everything as concrete as
                possible&#34; people be damned. No wonder engineers working with Simulink are not
                necessarily C developers. Simulink is a brand new universe that takes years to swim
                safely through its waters, regardless of what the marketing white paper above says
                about it being easy to use and avoiding the &#34;time-consuming and error-prone&#34; method
                of hand-writing your own code. HAND-WRITING YOUR CODE?! That&#39;s an activity for
                future to be software anarchists! Regardless, the suits of the present seem to have
                developed a fondness towards it and for code that generates code. Code that
                generates code?! Wait, I&#39;ve heard that idea before and it usually gets smashed to
                pieces as being &#34;irrelevant for us here&#34;. Regardless, I&#39;ll pass the microphone
                again,
            </p>

            <blockquote>
                <p>
                    Compact, efficient code: the code automatically generated with Embedded Coder
                    and Simulink Coder required about 16% less RAM than the handwritten code used on
                    a previous version of the Cruise Controller; the code met all project
                    requirements for efficiency and structure.
                </p>

                <p>
                    High test efficiency: debugging the control software on the desktop instead of
                    in the vehicle enabled the Daimler team to reduce the time and cost associated
                    with resolving software problems.
                </p>

                <p>
                    Fast development: the entire project, including analysis, restructuring,
                    modeling, and testing, took just 18 months. It would have been nearly impossible
                    to achieve this project deadline without the use of simulation, production code
                    generation, and processor-in-the-loop capabilities offered by MathWorks.
                </p>

                <p>
                    <a target="_blank" href="https://www.mathworks.com/company/user_stories/daimler-designs-cruise-controller-for-mercedes-benz-trucks.html">
                        Daimler Designs Cruise Controller for Mercedes-Benz Trucks
                    </a>
                </p>
            </blockquote>

            <blockquote>
                <p>
                    Code development costs cut by two-thirds: by modeling the control application
                    software in Simulink and using the model as an executable specification, we have
                    eliminated misunderstandings that can occur between OEMs and suppliers. Further,
                    by generating code from our models, we have eliminated the bugs and human errors
                    that come with hand-coding. These improvements enabled us to cut code
                    development costs by roughly two-thirds and shorten development times.
                </p>

                <p>
                    <a target="_blank" href="https://www.mathworks.com/company/user_stories/nissan-accelerates-development-and-testing-of-engine-control-software.html?s_tid=srchtitle">
                        Nissan Accelerates Development and Testing of Engine Control Software
                    </a>
                </p>
            </blockquote>

            <blockquote>
                <p>
                    We also anticipated many design iterations, so we wanted an easy way to
                    visualize results and debug our designs. In addition, we wanted to save time by
                    generating code, but the code had to be efficient, as the CPU load on our
                    electronics control unit (ECU) was already about 60% when we started the sensor
                    fusion project.
                </p>

                <p>
                    <a target="_blank" href="https://www.mathworks.com/company/technical-articles/developing-advanced-emergency-braking-systems-at-scania.html?s_tid=srchtitle">
                        Developing Advanced Emergency Braking Systems at Scania               
                    </a>
                </p>
            </blockquote>

            <blockquote>
                <p>
                    According to my experience with Toyota, pretty much all of the code is written
                    in C. But there are some several functions mainly about bit manipulation which
                    are written in assembly. However, they are shifting towards model-based
                    development using higher level language like MATLAB, and convert back to C to
                    shorten the development cycle and improve in readability, re usability and code
                    maintenance.
                </p>

                <p>
                    <a target="_blank" href="https://www.quora.com/What-programing-language-is-used-to-write-software-for-a-cars-electronic-control-unit-ECU?no_redirect=1">
                        A Quora user on programming languages for ECUs
                    </a>
                </p>
            </blockquote>

            <p>
                C is truly dead at this point. But why not stab it a little longer? What would be
                the harm in it, anyway?
            </p>

            <blockquote>
                <p>
                    ASCET provides an innovative solution for the functional and software
                    development of modern embedded software systems. ASCET supports every step of
                    the development process with a new approach to modeling, code generation and
                    simulation, thus making higher quality, shorter innovation cycles and cost
                    reductions a reality.
                </p>

                <p>
                    The ASCET tools support model-based software development. In model-based
                    development, you construct an executable specification – the model – of your
                    system and establish its properties through simulation and testing in early
                    stages of development. When you are satisfied that the model behaves as
                    required, it can be converted automatically to production quality code. The key
                    advantage of model-based development is that the software system can be designed
                    by domain experts, using domain-specific notions, independently from knowing any
                    details how it will be realized by an implementation.
                </p>

                <a target="_blank" href="https://etas.services/download-center-files/products_ASCET_Software_Products/etas-ascet-developer-7.9.0-getting-started-20240126.pdf">
                    ETAS ASCET Developer 7.9.0: Getting Started
                </a></blockquote>

            <p>
                Die C, die, even though you&#39;re already dead!
            </p>

            <blockquote>
                <p>
                    But C has a dark side. It is too easy for errors to creep into the code that can
                    be extremely difficult to find. Problems start with the syntax because it makes
                    writing code vulnerable to error. For example, optional braces, assignment in
                    expressions, and automatic switch/case fall through, etc. Then there are
                    semantically dubious or complex features that are difficult to use correctly and
                    encourage “programming on the edge of safety.“ For example, goto statements,
                    pointers, and integral promotion. These aspects can also interact in dangerous
                    ways
                </p>

                <p>
                    ETAS is rising to all these challenges with a new language to engineer safe and
                    secure software effectively: Embedded Software Development Language (ESDL). ESDL
                    eliminates typical C pitfalls and, in addition, enables software reuse,
                    simplifies maintenance, and supports product-line variant engineering. ESDL
                    enables developers to spend time solving problems instead of programming around
                    the inadequacies of C.
                </p>

                <p>
                    Using code generation to create C Efficient use of ESDL in development is
                    enabled with ETAS ASCET DEVELOPER 7, an Eclipse-based Integrated
                    Development Environment (IDE) and a C code generator.
                </p>

                <p>
                    The IDE provides modern editing features like language templates, content
                    assistance proposals and quick fixes for problems. This makes ESDL easy to learn
                    for beginners. ASCET-DEVELOPER 7 also continually checks for ESDL programming
                    violations, calculates quality metrics, and offers best-practice
                    recommendations. Feedback is provided to developers “on-the-fly” during edit
                    time, therefore reducing the time between making a coding error and its
                    detection to zero.
                </p>

                <p>
                    <a target="_blank" href="https://www.etas.com/data/RealTimes_2017/rt_2017_1_16_en.pdf">
                        ESDL: Safety and Security in Code
                    </a>
                </p>
            </blockquote>

            <p>
                Same story again from ETAS, a subsidiary of Bosch. It is interesting to note that
                the model and the code are seen as different entities. In Lisp world, the model that
                generates the Lisp code is still Lisp. That&#39;s the big difference. In automotive
                world, the model that generates C code is something entirely different. It could be
                a visual language, it could make use of xml files, it can implement a scripting
                language. All these combined define the modeling language.
            </p>

            <p>
                Sure it is easy to fall prey to such hype and most of is maybe just that, hype
                and marketing and people wanting to make money and gain market share. Nothing wrong
                with it. But having never seen more powerful systems, having never played with the
                parentheses, for example, makes one that more gullible and easily impressed by such
                promises.
            </p>

            <p>
                Do you want to explore Siemens&#39;
                <a target="_blank" href="https://www.plm.automation.siemens.com/media/global/es/Siemens-PLM-Simcenter-Embedded-Software-Designer-fs-71311-A4_tcm54-55209.pdf">Simcenter Embedded Software Designer</a>
                on your own? Go on!
            </p>


            <p id="autosar">
                <h2>Move away from the language completely and just click buttons</h2>
            </p>

            <blockquote>
                <p>
                    Your mistake is in assuming that you&#39;ll write code when using Autosar. Autosar
                    exists so that the company doesn&#39;t need to hire developers to write code. The
                    ideal is to buy everything from suppliers who also take on the liability in case
                    there are bugs and recalls need to be made. If you work with Autosar, you need
                    to be VERY clear with your future employer about what EXACTLY your duties will
                    be. It is very likely that your role as an &#34;Autosar developer&#34; will mainly
                    consist of integrating Autosar components and configuring them.
                </p>

                <!-- <p>
                     It really depends on how much are you willing to risk, are you young? Do you
                     have debts to paid? if you are young but are not in a serious need of money I
                     would not recommend entering Autosar C, take the risk and find something else,
                     if your need of money is really really hard then yes you will always find
                     something.
                     </p>
                -->
                <p>
                    Lol, you are joking right? Any person who values their time and career future
                    and wants to actually develop something fun would stay away from AUTOSAR.
                </p>

                <p>
                    I like cars and tried the Autosar route. It kind of sucked the fun out of
                    development for me.
                </p>

                <p>
                    <a target="_blank" href="https://www.reddit.com/r/embedded/comments/zdb02b/to_autosar_or_not_to_autosar/">
                        Reddit answers to a user asking if they should go with Autosar in their career
                    </a>
                </p>
            </blockquote>

            <p>
                <a target="_blank" href="https://www.autosar.org/">Autosar</a>&#39;s goal is to aid
                in <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R21-11/CP/AUTOSAR_TPS_SoftwareComponentTemplate.pdf">
                    code reuse</a> through standard modules and interfaces. The modules are
                implemented and sold by third-party vendors, either independently or as a
                <a target="_blank" href="https://www.vector.com/int/en/products/products-a-z/embedded-software/microsar/">whole stack</a>
                while their configuration and the connection between them (the function calls,
                after all) are done through visual tools and code generators.
            </p>

            <p>
                There are two main Autosar schools of thought, the
                <a target="_blank" href="https://www.autosar.org/standards/classic-platform">Classic Platform</a>
                where the ECU&#39;s software is split into three layers, the
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R22-11/CP/AUTOSAR_EXP_LayeredSoftwareArchitecture.pdf">
                    Layered Software Architecture</a> document having all the details and the pretty
                pictures and the
                <a target="_blank" href="https://www.autosar.org/standards/adaptive-platform">Adaptive Platform</a>
                which &#34;implements the AUTOSAR Runtime for Adaptive Applications (ARA). Two types of
                interfaces are available, services and APIs. The platform consists of functional
                clusters which are grouped in services and the AUTOSAR Adaptive Basis.&#34; Yes, I
                really don&#39;t know what that means or why they are called platforms.
            </p>

            

            <p>
                The reason for this split, aside from the &#34;increased complexity&#34; and
                &#34;high-performance computing needs&#34; mentioned in the
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R21-11/AP/AUTOSAR_EXP_SWArchitecture.pdf">
                    Explanation of Adaptive Platform Software Architecture</a>
                and a really surprise move on the part of the more than 350 Autosar
                <a target="_blank" href="https://www.autosar.org/about/partners">
                    Autosar legislators</a>, is that these platforms are specifically
                <a target="_blank" href="https://www.mathworks.com/help/autosar/ug/autosar-platform-comparison.html">
                    targeting C and C++</a>. Autosar is not language-agnostic though it boasts itself as 
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R20-11/AP/AUTOSAR_RS_General.pdf">
                    a rich and modern programming environment
                </a>. As such, the standard is quite low-level, it does specify the details of what
                goes where but does not build new abstractions to make it easy to talk about the
                project. It does build visual tools instead, as we shall see. A change to a
                different programming language, like Rust, would again force the change to a still
                new standard, as the change from C to C++ did, if that future ever comes before
                Autosar anarchists storm the castle and burn it to the ground,
            </p>

            <blockquote>
                <p>
                    If you want a dead end career, autosar is a good place to start. I could barely
                    sustain for a month working with that messed up software.
                </p>

                <p>
                    <a target="_blank" href="https://www.reddit.com/r/embedded/comments/198iurj/is_automotive_embedded_autosar_only/">
                        Reddit: comment to the question &#34;Is automotive embedded Autosar only?&#34;
                    </a>
                </p>                
            </blockquote>

            <p>
                It also brings it new types that have to be mapped back to C++, similar to
                a2l. Remember the dictionaries and the transport medium across that rift? Either
                way, the gist is that modules developed by one vendor, if it follows the correct
                Autosar platform and platform version can be used like lego bricks. Pluck them
                into a project using the same Autosar platform and version alongside other modules
                developed by the same or even a different vendor and it should all work, it&#39;s
                interfaces will have the structure and semantics defined by Autosar. Hardly
                groundbreaking! Though it needs over
                <a target="_blank" href="https://www.autosar.org/search">
                    2300 official documents
                </a> spanning more than
                <a target="_blank" href="https://www.ar-compendium.com">
                    13000 pages</a> to specify in the minutest of details the architecture of the entire software
                stack of the ECU itself, what goes into each module, what goes out, the types of
                data, the function signatures, all that.
            </p>

            <blockquote>
                <p>
                The AUTOSAR application communication interface shall allow AUTOSAR applications to use the same
                interface definition independently of whether they are located on the same or on different ECUs. A
                standardized interface definition for applications is a prerequisite for the reuse of software and
                hardware independent deployment.
                </p>

                <p>
                    <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R22-11/FO/AUTOSAR_RS_Main.pdf">
                        Autosar: Main Requirements
                    </a>
                </p>
            </blockquote>

            <p>
                Things are a bit messy when it comes to file formats. Unlike the safe lands we&#39;ve seen before, the
                XML file is again the choice for such module specification, though it also requires UML diagrams,
                excel files, GUI tools and splashy visuals,
            </p>

            <blockquote>
                <p>
                    In a development process, many different tools with different representation of
                    AUTOSAR models are used (Excel Sheets, Modeling Tools, UML, XML, etc.). Each
                    tool and its underlying representation of data have their advantages and
                    disadvantages. These tools and representations can be grouped into technological
                    spaces.
                </p>

                <p>
                    Using XML and UML within AUTOSAR combines the strength of both technological
                    spaces: AUTOSAR defined templates for data that is exchanged in AUTOSAR. Since
                    XML is widely accepted as a standard for representation and exchange of
                    structured data it was chosen to be the basis for the exchange of AUTOSAR
                    models. Due to the complexity of the data and its interrelationships a manual
                    creation of a consistent AUTOSAR XML schema turned out to be time-consuming and
                    error prone. In addition the expressive power of XML schema is not sufficient
                    for expressing content related constraints between data entities.
                </p>

                <p>
                    Therefore a meta-model based approach was chosen to graphically describe the
                    templates by means of UML2.0 class diagrams. Constraints that cannot be
                    formulated graphically are described textually in the template specifications
                    respectively as OCL (Object constraint language). The UML model which defines
                    all data entities and interrelationships that can be used for describing AUTOSAR
                    systems and related artifacts is called AUTOSAR meta-model. An instance of the
                    meta-model, i.e. a concrete description of software components, etc., is called
                    an AUTOSAR model.
                </p>
            </blockquote>

            <p>
                Autosar here even mentions the reason behind needing a new format:
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R22-11/CP/AUTOSAR_EXP_AIUserGuide.pdf">
                    commonly readable</a> by both parties across the rift. Commonly readable again,
                not human readable. Here are some arxml examples:
                <a target="_blank" href="https://github.com/telehan/autosar-arxml/blob/master/examples/autosar3/portinterfaces/PortInterfaces.arxml">
                    PortInterfaces.arxml</a> and
                <a target="_blank" href="https://github.com/nikidimitrow/Learning-AUTOSAR-fundamental/blob/master/BasicsOfAUTOSAR/EcuM_swc.arxml">
                    EcuM_swc.arxml</a>.
            </p>

            <p>
                If in CANoe one would bring in help to model a single ECU, in Autosar one models the
                entire car by way of these Components which then get assigned to either the same ECU
                or different ECUs connected to the same CAN network, for example. This is somewhat
                similar to what Kubernetes would do when you want another instance of your Docker
                app up and running without having to worry where it will be deployed. 
            </p>

            <p>
                Autosar comes with its own terminology (runnables, software components, PDUs, Ports,
                splittables, etc; check the 140 pages long
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R22-11/FO/AUTOSAR_TR_Glossary.pdf">
                    glossary</a> for more). The UML diagrams even have their own original icons (see
                <a target="_blank" href="https://www.autosar.org/fileadmin/standards/R20-11/CP/AUTOSAR_EXP_VFB.pdf">
                    Autosar: Virtual Functional Bus, Chapter 3: Overall mechanisms and concepts</a>).
            </p>

            <p>
                GUI tooling <b>is</b> the way to develop software with Autosar, from configuring,
                splitting, merging, modifying the arxml files to generating the C or C++ code. There
                are some old friends in this space, with
                <a target="_blank" href="https://cdn.vector.com/cms/content/know-how/autosar/Documents/AUTOSAR_Solution_Fact_Sheet_EN.pdf">
                    Vector</a> offering &#34;a complete solution for your projects: tools, basic software,
                engineering services, on-site support and training classes. Additionally numerous
                other tools for ECU testing as well as measurement and calibration are available.&#34;
                Similar to Matlab&#39;s Simulink, there is an emphasis on
                <a target="_blank" href="https://cdn.vector.com/cms/content/products/DaVinci/Developer_Classic/DEV_SW_Design_Graphic.jpg">
                    visual programming</a>, <a target="_blank" href="https://cdn.vector.com/cms/content/products/DaVinci/Developer_Classic/DEV_DataExchangeAnalysis.jpg">
                    user-friendliness</a> and
                <a target="_blank" href="https://d23rjziej2pu9i.cloudfront.net/wp-content/uploads/2020/12/14160240/9_Getting-started-Configuring-modules.png">
                    easy</a> to ride wild horses. Everything easy and intuitive. Has nobody here read
                <a target="_blank" href="https://norvig.com/21-days.html">
                    Teach Yourself Programming in Ten Years</a>? Or &#34;Teach Yourself Programming&#34;, for that matter? Or &#34;Programming&#34;? Was it
                replaced with
                <a target="_blank" href="https://www.youtube.com/watch?v=ChowxIrpIIY">
                    Model, Build &amp; Execute App in Only 10 Minutes</a>, instead?
            </p>

            <blockquote>
                <p>
                DaVinci Developer Classic is a tool for designing the architecture of software components (SWCs) for
                AUTOSAR Classic ECUs. This tool lets you create a graphic design of the interfaces, define the
                internal behavior with runnable entities and link the SWCs to one another.
                </p>
                
                <p>
                This function lets you generate the header file and the implementation template file for C-based
                applications easily and quickly from the DaVinci Developer Classic tool.
                </p>

                <p>
                Advantages: User-friendly and easy design of AUTOSAR SWCs; Numerous graphic editing functions; Check
                the SWCs for AUTOSAR conformity; Link model-based development tools via ARXML
                </p>

                <p>
                    <a target="_blank" href="https://cdn.vector.com/cms/content/products/DaVinci/DaVinci_Developer_FactSheet_EN.pdf">
                        Vector: DaVinci Developer Fact Sheet
                    </a></p>
            </blockquote>

            <p>
                DaVinci&#39;s Modeling Language (DML) is a kind of visual language that all tools in
                this Autosar sphere employ, the goal being a &#34;simplified representation of the ARMXL
                models&#34;. Check the
                <a target="_blank" href="https://www.vector.com/se/en/products/products-a-z/software/davinci-developer-adaptive">
                    DaVinci Developer Adaptive</a> for extra info, video sessions included.
            </p>

            <p>
                Dassault Systèmes offers the
                <a target="_blank" href="https://www.3ds.com/fileadmin/AB_Refresh1_2.pdf">
                    AUTOSAR Builder™</a>, another user friendly wizard (check page 6 for a &#34;beautiful&#34; model),
            </p>

            <blockquote>
                <p>
                    AUTOSAR Builder is 100% AUTOSAR standard-compliant. To ease the creation of
                    complex AUTOSAR models, it offers user friendly wizards and advanced graphical
                    and table-based editors, guiding the user thru typical AUTOSAR design
                    steps. Therefore, it hides the complexity of AUTOSAR design activity through
                    features which not only prevent the user from creating erroneous designs but
                    also by offering automated completion/creation of AUTOSAR design elements.
                </p>

                <a target="_blank" href="https://www.3ds.com/products/catia/autosar-builder">
                    Dassault Systèmes: CATIA Autosar Builder
                </a>
            </blockquote>

            <p>
                <a target="_blank" href="https://www.elektrobit.com/products/ecu/eb-tresos/studio/">
                    Tresos Studio</a> from Elektrobit is another wizard.
                Check how one would go about
                <a target="_blank" href="https://d23rjziej2pu9i.cloudfront.net/wp-content/uploads/2021/12/EB_tresos/EB_tresos_AUTOSAR_Builder_Workflow.pdf">
                    building a new project with EB Tresos</a>. Buttons, clicks, new terminology. Easy
                    and fun!
            </p>

            <blockquote>
                <p>
                    ECU basic software configuration, validation, and generation in one single
                    environment. Users benefit from one tool environment for configuration,
                    validation, and code generation instead of juggling multiple
                    tools. Multithreading mechanisms are used to save time for code
                    generation. Various assistant functions and wizards ease day-to-day work.
                </p>

                <p>
                    <a target="_blank" href="https://www.elektrobit.com/products/ecu/eb-tresos/studio/">
                        Elektrobit: EB Tresos Studio
                    </a>
                </p>
            </blockquote>

            <p>
                Engineers leave companies and the field completely due to Autosar, but business
                suits seem to like it since it&#39;s just buttons one can click so they can understand
                that. While kings dream of impossibly expensive grand palaces the soldiers in the
                field know about how crazy all this is, they feel and see that they&#39;ve become button
                clickers instead of software engineers. But I&#39;ll let others share their pain and
                misery of having to live with a DSL not invented by one person but by an association
                of over 350 automotive &#34;partners&#34; worldwide,
            </p>

            <blockquote>
                <p>
                If you want to increase the chances of being miserable in your professional career start working
                with autosar. I worked 3 months with it, and just bailed, I spend more time dealing with the
                tooling than actually implementing a feature.
                </p>

                <p>
                The only way I learned any of that was to screw around with it and very deliberately ask questions
                when updates were made so that I could learn. By the end of it, I was able to make simple changes
                but honestly I still never understood what was going on behind the scenes. If you get good at it,
                it’s decent job security. But it’s gonna be quite a ride.
                </p>

                <p>
                What you do do all day long is use Autosar GUIs. For those, no public tutorials exist as far as I&#39;m
                aware because not only do these tools cost serious money, the seminars taught on how to use them
                aren&#39;t free either.  This exactly is why you can&#39;t meaningfully learn Autosar without having an
                Autosar-related job. You just don&#39;t have access to the tools and 3rd party libraries.
                </p>

                <a target="_blank" href="https://www.reddit.com/r/embedded/comments/167clxg/how_to_learn_autosar/">
                    Users feelings on Reddit about their own experience with Autosar
                </a>
            </blockquote>

            <blockquote>
                <p>
                    AUTOSAR takes a long time to get a hold of. I got 1.5 years in it and I still
                    haven&#39;t understood that thing properly. You can spend 10 years working on just
                    Com stack or diag stack that would still be about 15-20% of autosar
                    architecture. In fact you can spend your entire career with just that one
                    stack. I know folks who have worked 5 years in one stack and struggle when they
                    change over to a new stack. It&#39;s a painful software to deal with, at least on
                    the vector daVinci software, you make one drop-down menu selection and your
                    configuration in 2 other places would have been changed. The documentation for
                    the architecture is published on the autosar website and it&#39;s free to read. The
                    software is a whole other story. You can&#39;t buy the software because it&#39;s really
                    expensive. You can&#39;t pirate download the software because the automobile
                    companies usually send a list of features needed and the companies like vector
                    which provide the software just release the software with the requested features
                    for that specific project. You gotta have to bang your head a lot and struggle
                    for a few initially to get a hold of the thing.
                </p>

                <p>
                    Basically a tool that is supposed to make a bunch of automotive makers happy but
                    in reality it leaves everyone equally unhappy, but because it is &#34;standardized&#34;
                    it gets used anyway.
                </p>

                <p>
                    I actually LOVE automotive. But I would never touch any AUTOSAR project. AUTOSAR
                    is basically just a convoluted way to deflect blame (and liability) when some
                    weird software bugs happen. I would go as far as saying that AUTOSAR makes
                    software quality worse, because nobody understands how this complex monster of
                    XML, headers, configs, #ifdevs etc works. I prefer to spend my time to write
                    solid architecture, easy understandable code, and test the shit out of my
                    code. Complexity is the enemy of quality.
                </p>

                <p>
                    Now I just sit back with a margarita in my hand and enjoy watching the European
                    car brands being out-innovated by more nimble, flexible, maintainable,
                    adaptable, robust, &#34;fitter&#34; Asian brands. Once the last German automotive
                    supplier is gone kaputt, AUTOSAR will be forgotten by history. Darwin always
                    wins in the end....
                </p>

                <p>
                    Autosar is bad. It is bad as specification(nonono it is not a standard, it is a
                    specification) for multiple reason. But that is not actually a problem. The
                    problem is implementations. They are horrible, they are bad at any angle. Buggy
                    tooling, ignoring actual autosar(they call it a deviation), slow, incompatible,
                    ugly implemented bsp level, where you have to learn tens and hundreds of
                    workarounds and tricks. Simplest operation takes weeks to implement.
                </p>

                <p>
                    It is the ecosystem around the autosar that is cancerous. The tools are buggy
                    and atrocious. The code they produce is unreadable and in some instances buggy
                    as well. The documentation is also non-existent. The complexity is bigger than
                    developing by hand but I guess you gain the time of testing and complying with
                    all the standards. And all these at a very high price point. The few months I
                    worked with some of these tools were the most miserable months of my career. If
                    you work above mcal you are not an embedded developer you are a systems
                    engineer. Where I work the people that have only worked on automotive lack very
                    fundamental knowledge of embedded. I wonder what will happen in the automotive
                    industry when there will be very few that grasp the low level.
                </p>

                <p>
                    Vector daVinci is really a pain in the ... . The documentation is somehow vague
                    , they do not offer too many details. And i found a lot of bugs in the cbd
                    package that i received from them after being bought for more than a couple
                    thousands. On the other hand , i had a project in which i had to rewrite
                    manually the CanNm stack (non autosar project which used autosar type NM) and
                    still has problems. The idea of standardization is not bad by itself, only the
                    complexity of configuring correctly the project is driving me nuts.
                </p>

                <p>
                    <a target="_blank" href="https://www.reddit.com/r/embedded/comments/1cef2ql/hate_for_autosar/">
                        Reddit: Hate for Autosar
                    </a>                    
                </p>
            </blockquote>

            <p id="the-future">
                <h2>The future: self-driving cars go all in on DSLs</h2>
            </p>

            <p>
                The wannabes Caesars have done it. They won&#39;t leave any stone unturned, not a single
                place on the continent remains untouched by their grandiosity. And as such, they
                have legislated new languages with which now one speaks of the driving conditions
                and of the interactions between cars, though I don&#39;t see what new things they
                introduce besides the &#34;human-readable Python-like syntax, that provides for a lower
                learning curve for domain experts while supporting a domain model that is directly
                recognizable by domain experts&#34; (<a target="_blank" href="https://publications.pages.asam.net/standards/ASAM_OpenSCENARIO/ASAM_OpenSCENARIO_DSL/latest/language-reference/introduction.html#_domain_specific_language">
                ASAM introduction</a>) and a need to &#34;describe the behavior of the autonomous vehicle as well as
                other actors or entities in the environment.&#34;
            </p>

            <p>
                This standard started out as an xml-based format but evolved into a full-fleged DSL,
                the <a target="_blank" href="https://publications.pages.asam.net/standards/ASAM_OpenSCENARIO/ASAM_OpenSCENARIO_DSL/latest/introduction.html">
                ASAM OpenSCENARIO</a>, which defines a declarative, constraint-based and aspect-oriented programming
                language. All in one. Here is a &#34;scenario&#34; that requires an initial speed of 40 to
                60 kph, as pieces of code are now called not functions but scenarios, similar to
                Autosar&#39;s reinventing the familiar modules terminology into components,
            </p>

            <blockquote>
                <p>
                    scenario my_scenario:</p>

                <p>
                    <a target="_blank" href="https://publications.pages.asam.net/standards/ASAM_OpenSCENARIO/ASAM_OpenSCENARIO_DSL/latest/user-guide/writing_reusable_scenarios.html">
                        ASAM: OpenSCENARIO DSL, Writing Reusable Scenarios                   
                    </a>
                </p>
            </blockquote>

            <p>
                I won&#39;t dwelve much on this one mostly because I haven&#39;t used it, except to note
                that other companies are basing their own DSLs on OpensSenario, like Foretellix&#39;s
                Measurable Scenario Definition Language (M-SDL),
            </p>

            <blockquote>
                <p>
                    The Measurable Scenario Description Language (M-SDL) is a mostly declarative
                    programming language. The only scenario that executes automatically is the
                    top-level scenario, top.main. You control the execution flow of the program by
                    adding scenarios to top.main. M-SDL is an aspect-oriented programming
                    language. This means you can modify the behavior or aspects of some or all
                    instances of an object to suit the purposes of a particular verification test,
                    without disturbing the original description of the object.
                </p>

                <p>
                    <a target="_blank" href="https://releases.asam.net/OpenSCENARIO/2.0-concepts/M-SDL_LRM_OS.pdf">
                        Foretellix: Measurable Scenario Description Language Reference        
                    </a>
                </p>
            </blockquote>

            <p>
                Here is an example from the reference manual that shows how to define a new scenario
                called <em>two_phases</em>. It defines a single actor, <em>car1</em>, which is a green
                truck. It uses the serial operator to activate the <em>car1.drive</em> scenario, and it
                applies the <em>speed()</em> modifier,
            </p>

            <blockquote>
                <p>
                    # A two-phase scenario</p>

                <p>
                    <a target="_blank" href="https://releases.asam.net/OpenSCENARIO/2.0-concepts/M-SDL_LRM_OS.pdf">
                        Foretellix: Measurable Scenario Description Language Reference        
                    </a>
                    
                </p>
            </blockquote>

            <p>
                At a first glance, and similar to the CAPL observation I&#39;ve made above, it doesn&#39;t
                look to me that they introduce really new or desperately needed language abstractions
                that aren&#39;t available in other languages.
            </p>

            <p>
                There is even a specification for the road network, in xml of course,
            </p>

            <blockquote>
                <p>
                    ASAM OpenDRIVE was developed in response to demand for the specification of an
                    exchange format to define static road networks that can be used in driving
                    simulation applications.
                </p>

                <p>
                    The ASAM OpenDRIVE Specification specifies the file format for static road
                    network descriptions. The Extensible Markup Language (XML) is used to represent
                    these descriptions. The ASAM OpenDRIVE Specification specifies how to model
                    static road networks. In more detail, it specifies the structure, the sequence,
                    the elements, and values to represent static road networks.
                </p>

                <p>
                    <a target="_blank" href="https://publications.pages.asam.net/standards/ASAM_OpenDRIVE/ASAM_OpenDRIVE_Specification/latest/specification/00_preface/00_introduction.html">
                        ASAM OpenDRIVE
                    </a>
                </p>
            </blockquote>

            <p>
                If this
                <a target="_blank" href="https://www.youtube.com/watch?v=2pX2dJL0Jnc">
                    video presentation of ASAM OpenDRIVE</a> doesn&#39;t convince you of its value,
                there is a different standard for road networks one can use, a standard developed by
                the same German car manufacturers, also based on xml,
            </p>

            <blockquote>
                <p>
                    The Navigation Data Standard (NDS) is a standardized format for automotive-grade
                    navigation databases, jointly developed by automobile manufacturers and
                    suppliers. NDS is an association registered in Germany. Members are automotive
                    OEMs, map data providers, and navigation device/application providers.
                </p>

                <p>
                    <a target="_blank" href="https://en.wikipedia.org/wiki/Navigation_Data_Standard">
                        Wikipedia: Navigation Data Standard
                    </a></p>
            </blockquote>

            <p>
                Well, the list of examples can go on and on but we&#39;ve reached the edge of the
                continent. What remains is to turn our horses around and explore the little kingdoms
                we&#39;ve already encountered in our journey in more detail. Or, who knows, you can
                venture into the rough seas ahead and bring to light new DSL, file formats,
                standards and intuitively easy to use tools now that your appetite has been wet.
            </p>

            <p id="conclusion">
                <h2>Conclusion</h2>
            </p>
            <p>
                The pristine C land has been torn to pieces. Every imaginable torture has been
                inflicted upon it. Its use restricted, features forbidden, fresh blood brought in to
                replace its inadequacies, people banned for even seeing its face, its true self
                painted over with colorful interfaces. Nobody wants to see its true image, nobody to
                hear its voice. Yet, they say it is the thing they all need. Like health, they all
                praise it then drink themselves to death. A plethora of tools to increase the speed
                of development, to inspect a running system, to exchange requirements and reach
                agreement between teams and stakeholders as to what needs to be developed and extra
                programming languages have taken its place.
            </p>

            <p>
                If Lisp gives its practitioners the freedom to dream and play with their own wild
                abstractions, its absence gives companies the opportunity to flood the market with
                junk-food software and keep developers hooked on these cheap, calorie intensive but
                nutritionally void substitutes. And build fortunes, as a result.
            </p>

            <p>
                On the other hand, I feel skeptical that one tool can solve all problems. I feel
                skeptical that Lisp can be used everywhere. That fact that it works so well in a
                couple of instances, like it does for Emacs or
                <a target="_blank" href="https://stumpwm.github.io/">StumpWM</a> among others, is no
                real argument. The cost, the energy, the developers&#39; know-how, must all be counted
                in as well. There is only so much talent lying around in any industry.
                <a target="_blank" href="https://mihaiolteanu.me/if-lisp-is-so-great">Not everybody
                    can live in designer houses</a>, some must live in cramped apartment blocks. It
                is possible that the software industry has stretched itself thin, most probably
                driven by profits. Software is the promised land where investors multiply their
                fortunes. When more and more of these gold-seekers pour in, the &#34;human resources&#34;
                needs increase as well. At one point there is a lack of sufficiently trained or
                naturally inclined practitioners to be able to do the job. So naturally the response
                is to lower the entry threshold. Naturally the response is to simplify, improve and
                expand on the tools these newcomers use. The more intuitive, the better. With the
                negative effects we see all around us. It is possible indeed that a small team of
                knowledgeable parentheses masters could build a car&#39;s software in Lisp, do it
                better and more efficiently than what is now available in the industry with all these
                tools we&#39;ve seen. But add in dozens of car companies in the mix all wanting a market
                share in this gold rush and the number of available teams riding wild horses
                and still being able to
                <a target="_blank" href="https://en.wikipedia.org/wiki/Parthian_shot">take a shot</a>
                decreases dramatically. So what is one supposed to do? Bring in the tamed
                horses. The old ones, too. Even the lame ones! In times of war, even donkeys are
                good enough and can count as horses for a while.
            </p>
        </div></div>
  </body>
</html>
