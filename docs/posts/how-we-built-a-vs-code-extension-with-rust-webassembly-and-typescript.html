<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.osohq.com/post/building-vs-code-extension-with-rust-wasm-typescript">Original</a>
    <h1>How we built a VS Code Extension with Rust, WebAssembly, and TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div><p>We build Oso, a batteries-included framework for building authorization in your application. At the core of Oso is <a href="https://docs.osohq.com/learn/polar-foundations.html">Polar</a>, a declarative language for writing authorization policies. While someday we’ll release a feature that lets a fully-sentient Oso write your authorization policy for you, in the interim we thought it would be a good idea to improve the developer experience of writing Polar policies.</p>
<p>Along with Oso&#39;s 0.24 release, we shipped a <a href="https://marketplace.visualstudio.com/items?itemName=osohq.oso">VS Code extension</a> that surfaces policy errors &amp; warnings in VS Code instead of requiring you to run your application to see them. This shortens the development cycle for editing policies, giving you more time to spend on whatever sparks joy for you (and us more time to spend on making sure the kill orders issued by our sentient beta were a one-time glitch).</p>
<p>In this post, we&#39;ll talk through our design decisions in building the extension, and along the way we&#39;ll touch on the Language Server Protocol and, more generally, how an IDE extension works. If you’ve ever wanted to write an IDE extension for your language of choice, this post might be for you.</p>
<h2>Why We Chose VS Code</h2>
<p>We expect our users to write Polar in a variety of environments, and there are a wide range of IDEs out there. We restricted our initial focus to VS Code because we&#39;ve had the most requests from our community for it. We also knew we were going to want to fan out the functionality beyond VS Code in the future, and building on top of the Language Server Protocol (LSP) would minimize the work required to port the extension&#39;s functionality to Vim, IntelliJ, Emacs, and other editors.</p>
<p>There&#39;s a <em>huge</em> range of features that an IDE integration can provide, like auto-completion and jump-to-definition. For our initial foray we scoped it down to surfacing policy errors &amp; warnings. When writing Polar policies, these can be parsing errors (like &#34;you&#39;re missing a semicolon&#34;) or validation errors (like &#34;your policy references an unknown term&#34;). There&#39;s a lot of value in surfacing those issues to the developer ASAP. Limiting ourselves to those diagnostics improved the developer experience without giving us an endless list of features to implement.</p>
<h2>Using the Language Server Protocol (LSP)</h2>
<p>Microsoft’s open-source <a href="https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/">Language Server Protocol</a> abstracts a common set of IDE functionality across a JSON-RPC bridge. Every IDE that speaks LSP sends the same set of events across that bridge, like &#34;a document has been opened&#34; or &#34;the user has requested all references for a particular symbol.&#34; Every language server that speaks LSP can implement features like documentation-on-hover <em>once</em> and get that functionality across every LSP-fluent editor.</p>
<p>Before the Language Server Protocol, if we wanted to build a Polar language server to surface errors &amp; warnings in VS Code, we&#39;d use VSCode-specific APIs. Then, when we wanted to port the same functionality to IntelliJ, we&#39;d have to figure out the corresponding APIs in IntelliJ, and the same for Vim, Emacs, and every other IDE. It would be a lot of duplicated effort to build N slight variations of the same feature set.</p>
<h2>Design</h2>
<p>For the initial design, we knew a few things:</p>
<ul>
<li>We wanted to write the language server in Rust. The Polar interpreter is written in Rust, so writing the language server in Rust meant it would be easy to build on top of existing APIs in our Rust core. Also, the team knows Rust well, and it&#39;s generally our default for greenfield projects.</li>
<li>The language server would be a new crate, <code>polar-language-server</code>, to avoid concerning <code>polar-core</code> with LSP-specific code.</li>
<li>The extension would be written in TypeScript, because VS Code expects extensions to have a JavaScript entrypoint file that exposes hooks for VS Code to manage the extension&#39;s lifecycle.</li>
</ul>
<p>This last point brings up the first big question we had to answer: where should the boundary be between TypeScript and Rust?</p>
<h2>Why We Chose WebAssembly</h2>
<p>If we want to maximize the amount we write in Rust, a minimal TypeScript extension would handle extension activation, kick off the Polar language server (written in Rust) in a separate process, and then get out of the way and let VS Code talk to the server via the Language Server Protocol. However, that explanation glosses over how we distribute the language server. VS Code users will install the extension via the VS Code extension marketplace, but how are they going to get the Polar language server onto their system?</p>
<p>If we write the server in Rust, we have four primary options for distribution. We can quickly rule out two of them:</p>
<ol>
<li>Publish the new crate to <a href="http://crates.io">crates.io</a> and have folks <code>cargo install</code> the crate if they want to use the VS Code extension. This was easy to rule out because we can&#39;t ask folks to install a compatible Rust toolchain with Cargo just to use our VS Code extension.</li>
<li>Build platform-specific binaries from the Rust crate and either ask folks to manually download the correct one or do some host identification magic to attempt to download the correct one for their platform. This was also pretty easy to rule out because, as the proud parents of a release process consisting of well over 100 GitHub Actions jobs, we&#39;re <a href="https://www.osohq.com/post/cross-platform-rust-libraries">all-too-familiar with the complexities of multi-platform builds</a>.</li>
</ol>
<p>We’re left with two viable options:</p>
<ol>
<li>Leverage our existing multi-platform pipeline and bundle the language server into the Oso language libraries as an executable. We already ship an executable REPL with every library, so there&#39;s some prior art here.</li>
<li>Compile the server to WebAssembly (Wasm) and run the whole extension (client &amp; server) in Node.js, VS Code&#39;s native runtime.</li>
</ol>
<p>Comparing and contrasting bundling the language server into the language libraries (3) and compiling to Wasm (4) in the above list:</p>
<ul>
<li>Bundling would mean the version of Oso in the language server would always match the version installed in the project because the language server would come from the installed library. Going the Wasm route would mean we&#39;d always ship the latest version of Oso in the extension, and folks whose projects weren&#39;t using the latest version might see different errors and warnings during development than at runtime if, for example, we introduce a new validation check or make a breaking change to the parser.</li>
<li>Bundling would require writing &amp; maintaining significantly more new code than compiling to Wasm. For bundling, we&#39;d have to figure out how to slot the new language server API into the existing language libraries that we build and distribute for Python, Node.js, Ruby, Rust, Java, and Go, whereas compiling a new crate to Wasm wouldn&#39;t impact the language libraries at all.</li>
<li>Bundling would result in distributing the extension &amp; language server separately, so we would have to think about how to handle the two pieces running different major versions of the Language Server Protocol. It&#39;s fair to assume this wouldn&#39;t be a common issue, but it&#39;s still something we don&#39;t need to think about at all with the Wasm option, where we distribute the language server with the extension as an additional <code>.wasm</code> file.<ul>
<li>It&#39;s also worth noting that the Language Server Protocol startup handshake involves the server telling the client which pieces of the protocol it supports, so, even if we distributed the extension and language server separately (the bundling option), we&#39;d be able to enable new client functionality without breaking backwards compatibility with older servers running the same major LSP version.</li>
</ul>
</li>
</ul>
<p>Both options involve tradeoffs, and we really could&#39;ve gone either way. However, we ultimately decided to go with option 4—compiling the server to WebAssembly and packaging the client and server together as a JavaScript package—because it seemed like it would be quicker to implement, would make packaging and distribution relatively straightforward, and the language server scaffolding packages in JavaScript&#39;s ecosystem are more mature than Rust&#39;s.</p>
<h2>Finding an LSP library for Rust</h2>
<p>There are three main Rust crates that provide scaffolding for a language server: <code>tower-lsp</code>, <code>lspower</code> (a fork of <code>tower-lsp</code>), and <code>lsp-server</code>. Both <code>tower-lsp</code> and <code>lspower</code> require implementing the language server as an asynchronous service powered by Tower, a framework for async Rust. We didn&#39;t think the benefits of asynchrony would be worth the added complexity to the language server. (For what it&#39;s worth, the folks behind Rust Analyzer, the most mature LSP implementation in Rust, <a href="https://github.com/rust-analyzer/lsp-server/issues/26#issuecomment-743731291">seem to agree</a>.) For one, the extension runs in a separate process and doesn&#39;t impact the editor&#39;s responsiveness, and anyway parsing a Polar policy and surfacing errors and warnings is a very fast operation (~1 ms). Additionally, there are <a href="https://github.com/ebkalderon/tower-lsp/issues/177">open</a> <a href="https://github.com/ebkalderon/tower-lsp/issues/284">questions</a> about the model at the core of <code>tower-lsp</code> and <code>lspower</code> and whether Tower&#39;s request/response model is a natural fit for the Language Server Protocol, which more naturally maps to a pair of streams from client→server and server→client. We also looked into <code>lsp-server</code>, the synchronous language server scaffold used by Rust Analyzer, but the lack of documentation and explicit aim to not be <a href="https://github.com/rust-analyzer/lsp-server/issues/16#issuecomment-646567569">&#34;a good general purpose library at the moment&#34;</a> scared us off.</p>
<p>Ultimately, we decided that none of the three scaffolding crates were worth the tradeoffs, and we ended up creating a few </p>
<h2>Implementation</h2>
<p>With our sights set on Wasm, implementing the language server in Rust largely went off without a hitch, and we landed on a clean, three-part design consisting of a TypeScript entrypoint module, a second, tiny TypeScript module that delegates connection handling to Microsoft&#39;s <code>vscode-languageserver</code> package, and the <code>polar-language-server</code> crate compiled to Wasm.</p>
<p><a href="https://github.com/osohq/oso/tree/2d5e72fa667f56917524eef8bdcaf903e9ae0fb1/vscode/oso/client">The extension&#39;s entrypoint</a> is a TypeScript module that exposes <code>activate()</code> and <code>deactivate()</code> functions so that VS Code can manage the extension&#39;s lifecycle. On activation, the extension kicks off <a href="https://github.com/osohq/oso/blob/2d5e72fa667f56917524eef8bdcaf903e9ae0fb1/vscode/oso/client/src/index.ts#L257">a separate language server process for each VS Code workspace</a> in order to support multi-root workspaces.</p>
<p>There are actually a few layers between the process that we kick off per workspace and the <code>polar-language-server</code> Wasm module. At the top is an instance of the <code>LanguageClient</code> class provided by Microsoft&#39;s <code>vscode-languageclient</code> package. The <code>LanguageClient</code> instance is in charge of <a href="https://github.com/osohq/oso/blob/2d5e72fa667f56917524eef8bdcaf903e9ae0fb1/vscode/oso/client/src/index.ts#L172">kicking off the language server</a>, handling communication between VS Code and the server, and passing some configuration to VS Code like which types of files we&#39;re interested in for a particular workspace.</p>
<p>When the <code>LanguageClient</code> boots up <a href="https://github.com/osohq/oso/tree/2d5e72fa667f56917524eef8bdcaf903e9ae0fb1/vscode/oso/server">the tiny &#34;server&#34; TypeScript module</a>, we initialize the Wasm-ified <code>polar-language-server</code> and manage the server side of the LSP connection from TypeScript. By keeping connection management in TypeScript, we&#39;re able to delegate all of that logic to the <code>vscode-languageserver</code> package instead of having to reimplement it ourselves in <code>polar-language-server</code>. We forward all LSP notification messages (e.g., <code>textDocument/didOpen</code>) straight to <code>polar-language-server</code>, where the <code>PolarLanguageServer::on_notification</code> method de-serializes the message from JSON into a Rust type provided by the excellent <code>lsp_types</code> crate. We also pass in a JavaScript callback to the <code>polar-language-server</code> constructor so that it can send diagnostics back across the LSP divide to VS Code.</p>
<p>Unencumbered by all of the busywork we delegated to Microsoft&#39;s JavaScript packages, <a href="https://github.com/osohq/oso/tree/2d5e72fa667f56917524eef8bdcaf903e9ae0fb1/polar-language-server">the <code>polar-language-server</code> crate</a> has one job: whenever the state of a particular workspace&#39;s Polar policy changes (i.e., a <code>.polar</code> file was added, changed, or deleted), it reloads the policy, translates any errors or warnings into VS Code diagnostics, and punts those diagnostics back across the fence to VS Code, which then displays them inline in the editor.</p>
<h2>Wrapping Up</h2>
<p>By splitting the language server into a thin TypeScript wrapper and a Rust core, we were able to build on top of some nice LSP scaffolding that exists in the JavaScript ecosystem while still implementing all of the new diagnostic-wrangling logic in Rust. The extension now surfaces issues as the policy is edited in VS Code, resulting in less time flipping back-and-forth between editor and terminal and more time focused on writing the authorization policy:</p>
<p><img alt="Untitled" src="https://images.osohq.com/building-vs-code-extension-with-rust-wasm-typescript/Blog%20writing%2012e0d5933594447e9ae0546e49c1645a/Untitled.png"/></p>
<p>We’d love to hear feedback on the new extension and/or any features or editors you’d like to see supported; please <a href="https://join-slack.osohq.com/">join us on Slack</a> or <a href="https://github.com/osohq/oso/issues">open a GitHub issue</a>. Also, if this project sounds like something that would be fun to get paid to work on, <a href="https://www.osohq.com/company/jobs">we’re hiring</a>!</p></div></div>
  </body>
</html>
