<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.controlpaths.com/2025/06/29/parallelizing_sha256-calculation-fpga/">Original</a>
    <h1>Parallelizing SHA256 Calculation on FPGA</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>A few weeks ago, I wrote an <a href="https://www.controlpaths.com/2025/03/30/crypto-fpga/">article</a> where I developed a hash calculator on an FPGA. Specifically, I implemented an SHA-256 calculator. This module computes the hash of a string (up to 25 bytes) in 68 clock cycles.</p>

<p>The design leverages the parallelism of FPGAs to compute the W matrix and the recursive rounds concurrently. However, it produces only one hash every 68 clock cycles, leaving most of the FPGA underutilized during that time.</p>

<p>In this article we are going to elevate the performance of that system by adding a set of hash calculators to be able of computing several hashes at the same time.</p>

<p>The next diagram shows the structure of the project. I needed to change the hash calculator module to optimize it. If you remember the SHA-256 algorithm, it needs a set of pre-computed values, the K matrix. In this project, that matrix is not inside the SHA core, instead it is in a top level, where all the hash cores have access. This way only one K matrix has to be stored. In addition, the initialization of the W matrix values is performed in parallel, eliminating the AXI Stream interface.</p>

<p><img src="https://www.controlpaths.com/assets/img/2025/2026-06-29-parallelizing_sha256-calculation-fpga_img1.png" alt="FSM diagram"/></p>

<p>This two changes reduce the logic used by the core, and elevate its performance. This new SHA core is named <code>sha256_core_pif</code> (pif means parallel interface).</p>

<div><div><pre><code><span>module</span> <span>sha256_core_pif</span> <span>(</span>
  <span>input</span> <span>wire</span> <span>aclk</span><span>,</span> 
  <span>input</span> <span>wire</span> <span>aresetn</span><span>,</span> 

  <span>/* input data channel */</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w0</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w1</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w2</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w3</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w4</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w5</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w6</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w7</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w8</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w9</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w10</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w11</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w12</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>string_w13</span><span>,</span>
  <span>input</span> <span>wire</span> <span>string_dv</span><span>,</span>
  <span>output</span> <span>wire</span> <span>string_ready</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>7</span><span>:</span><span>0</span><span>]</span> <span>string_size</span><span>,</span>
  <span>output</span> <span>reg</span> <span>[</span><span>6</span><span>:</span><span>0</span><span>]</span> <span>round</span><span>,</span>
  <span>input</span> <span>wire</span> <span>[</span><span>31</span><span>:</span><span>0</span><span>]</span> <span>k_round</span><span>,</span>
  
  <span>/* output data channel */</span>
  <span>output</span> <span>reg</span> <span>sha256_dv</span><span>,</span>
  <span>output</span> <span>reg</span> <span>[</span><span>255</span><span>:</span><span>0</span><span>]</span> <span>sha256_data</span>
<span>);</span>

</code></pre></div></div>

<p>Then, a module called <code>SHA256_manager</code> was added to coordinate all the cores and feed them with the appropriate input values.</p>

<p>The application I implemented is a simple hash cracker or password cracker. It receives a SHA-256 hash and attempts to recover the original string that generated it. This cannot be solved analytically; instead, the <code>SHA256_manager</code> iteratively hashes candidate strings, starting from the first printable character. It then increments the character until it reaches the last one, at which point it appends a new character and restarts the process.</p>

<p>There are 95 printable ASCII characters. This means the system must compute 95 hashes for strings of length 1, 95^2 = 9 025 for two-character strings, and 95^3 = 857 375 for three-character strings. In general, the number of required hashes is 95^n for strings of length n.</p>

<p>All the <code>sha256_core_pif</code> returns the hash calculated, and the <code>SHA256_manager</code> compares all with the received hash. If one of them is the same, then the hash sent to the first <code>sha256_core_pif</code> is sent to the host computer, and also the number of the <code>sha256_core_pif</code> that computes the correct hash. This way, the host computer can obtain the correct string.</p>

<p>The project uses the Litefury board connected to a Raspberry Pi 5 over PCIe. In the next diagram you can find the block design of Vivado.</p>

<p><img src="https://www.controlpaths.com/assets/img/2025/2026-06-29-parallelizing_sha256-calculation-fpga_img2.png" alt="Vivado block design"/></p>

<p>To meet the timing requirements, I needed to reduce the AXI clock speed to 62.5 MHz. Using this configuration, I was able of integrate 12 <code>sha256_core_pif</code> modules.</p>

<p><img src="https://www.controlpaths.com/assets/img/2025/2026-06-29-parallelizing_sha256-calculation-fpga_img5.png" alt="DMA AXI Clock"/></p>

<p>Regarding the utilization of the FPGA, you will see that it is not close to be full, but the problem was to met the timing requirements.</p>

<p><img src="https://www.controlpaths.com/assets/img/2025/2026-06-29-parallelizing_sha256-calculation-fpga_img3.png" alt="Utilization"/></p>

<p>Using 12 accelerators, and a clock speed of 62.5MHz, all the requirements were met.</p>

<p><img src="https://www.controlpaths.com/assets/img/2025/2026-06-29-parallelizing_sha256-calculation-fpga_img4.png" alt="Timing"/></p>

<p>In the host side, I created a Python driver to manage the LiteFury. I used the xDMA drivers from Xilinx with the modification we made in <a href="https://www.controlpaths.com/2024/02/18/connecting-litefury-to-raspberrypi5/">this</a> article. Now, the Python driver just needs to open the <code>/dev/xdma0_user</code> peripheral, and write the registers according the register map of the AXI peripheral.</p>

<div><div><pre><code><span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>uio_path</span><span>=</span><span>&#34;/dev/xdma0_user&#34;</span><span>,</span> <span>map_size</span><span>=</span><span>0x20000</span><span>):</span>
    <span>self</span><span>.</span><span>fd</span> <span>=</span> <span>os</span><span>.</span><span>open</span><span>(</span><span>uio_path</span><span>,</span> <span>os</span><span>.</span><span>O_RDWR</span> <span>|</span> <span>os</span><span>.</span><span>O_SYNC</span><span>)</span>
    <span>self</span><span>.</span><span>map_size</span> <span>=</span> <span>map_size</span>
    <span>self</span><span>.</span><span>m</span> <span>=</span> <span>mmap</span><span>.</span><span>mmap</span><span>(</span><span>self</span><span>.</span><span>fd</span><span>,</span> <span>self</span><span>.</span><span>map_size</span><span>,</span> <span>mmap</span><span>.</span><span>MAP_SHARED</span><span>,</span> <span>mmap</span><span>.</span><span>PROT_READ</span> <span>|</span> <span>mmap</span><span>.</span><span>PROT_WRITE</span><span>,</span> <span>offset</span><span>=</span><span>0</span><span>)</span>

<span>def</span> <span>close</span><span>(</span><span>self</span><span>):</span>
    <span>self</span><span>.</span><span>m</span><span>.</span><span>close</span><span>()</span>
    <span>os</span><span>.</span><span>close</span><span>(</span><span>self</span><span>.</span><span>fd</span><span>)</span>

<span>def</span> <span>write</span><span>(</span><span>self</span><span>,</span> <span>addr</span><span>,</span> <span>value</span><span>):</span>
    <span>self</span><span>.</span><span>m</span><span>.</span><span>seek</span><span>(</span><span>addr</span><span>+</span><span>self</span><span>.</span><span>AXI_PERIPH_OFFSET</span><span>)</span>
    <span>self</span><span>.</span><span>m</span><span>.</span><span>write</span><span>(</span><span>struct</span><span>.</span><span>pack</span><span>(</span><span>&#34;&lt;I&#34;</span><span>,</span> <span>value</span><span>))</span>  <span># Little endian
</span>
<span>def</span> <span>read</span><span>(</span><span>self</span><span>,</span> <span>addr</span><span>):</span>
    <span>self</span><span>.</span><span>m</span><span>.</span><span>seek</span><span>(</span><span>addr</span><span>+</span><span>self</span><span>.</span><span>AXI_PERIPH_OFFSET</span><span>)</span>
    <span>return</span> <span>struct</span><span>.</span><span>unpack</span><span>(</span><span>&#34;&lt;I&#34;</span><span>,</span> <span>self</span><span>.</span><span>m</span><span>.</span><span>read</span><span>(</span><span>4</span><span>))[</span><span>0</span><span>]</span>
</code></pre></div></div>

<p>As I mentioned before, to obtain the final string, we need to read the resulting string addresses, and add the number of the winner module.</p>

<div><div><pre><code><span>def</span> <span>get_password</span><span>(</span><span>self</span><span>,</span> <span>winner</span><span>):</span>
    <span>pw</span> <span>=</span> <span>b</span><span>&#39;&#39;</span>
    <span>for</span> <span>addr</span> <span>in</span> <span>self</span><span>.</span><span>REG_R</span><span>:</span>
        <span>word</span> <span>=</span> <span>self</span><span>.</span><span>read</span><span>(</span><span>addr</span><span>)</span>
        <span>pw</span> <span>+=</span> <span>word</span><span>.</span><span>to_bytes</span><span>(</span><span>4</span><span>,</span> <span>&#39;big&#39;</span><span>)</span>
    <span># Add the value of the winner as integer to the resulting string
</span>    <span>pw_int</span> <span>=</span> <span>int</span><span>.</span><span>from_bytes</span><span>(</span><span>pw</span><span>,</span> <span>&#39;big&#39;</span><span>)</span> <span>+</span> <span>winner</span>
    <span># Convert the result to bytes
</span>    <span>pw_bytes</span> <span>=</span> <span>pw_int</span><span>.</span><span>to_bytes</span><span>(</span><span>len</span><span>(</span><span>pw</span><span>),</span> <span>&#39;big&#39;</span><span>)</span>
    <span># Invert the order of the result
</span>    <span>pw_bytes</span> <span>=</span> <span>pw_bytes</span><span>[::</span><span>-</span><span>1</span><span>]</span>
    <span># ASCII decodingssh p
</span>    <span>return</span> <span>pw_bytes</span><span>.</span><span>rstrip</span><span>(</span><span>b</span><span>&#39;</span><span>\x00</span><span>&#39;</span><span>).</span><span>decode</span><span>(</span><span>&#39;ascii&#39;</span><span>,</span> <span>errors</span><span>=</span><span>&#39;ignore&#39;</span><span>)</span>
</code></pre></div></div>

<p>To test the project, I created another Python script that calculates the SHA-256 of a string (It also can be done using the openSSL library). Then, the hash calculated is sent to the accelerator, and it returns the initial string.</p>

<div><div><pre><code>~/pass_cracker/python <span>$ </span>python3 sha256_comp.py eoi
SHA-256 of <span>&#39;eoi&#39;</span>: 7c02b8671bb4824e1cea44af7b628e88b81495699d5e9cb0e2533af99320a81b

~/pass_cracker/python <span>$ </span><span>sudo </span>python3 pass_cracker.py 7c02b8671bb4824e1cea44af7b628e88b81495699d5e9cb0e2533af99320a81b
Password: eoi
</code></pre></div></div>

<p>Projects like this can be quite impressive to engineers unfamiliar with FPGAs. The ability to accelerate SHA-256 computation by performing different tasks in parallel — and even using multiple hash calculators simultaneously — often sparks curiosity and interest in FPGA technology.</p>

<p>The role of FPGAs in fields like cryptography and cybersecurity is expected to grow significantly in the coming years, as increasingly faster and more flexible systems are required.</p>

<p>All the files of this project are shared in the <a href="https://github.com/controlpaths/sha256/tree/main/python">controlpaths GitHub</a></p>

<p><strong>Are you involved in a cryptography project and wants to know if an FPGA could help? Contact me.</strong></p>

  </div></div>
  </body>
</html>
