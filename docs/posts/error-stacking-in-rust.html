<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://greptime.com/blogs/2024-05-07-error-rust">Original</a>
    <h1>Error Stacking in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-v-0de291f9=""><div data-v-0de291f9=""><div><div><p>TL;DR:</p><p>In this article, we discuss the practice of Rust error handling topic in <a href="https://github.com/GreptimeTeam/greptimedb" target="_blank" rel="noreferrer">GreptimeDB</a> and shares possibly future work in the end.</p><p>Topics including: (1) How to build a cheaper yet more accurate error stack to replace system backtrace; (2) How to organize errors in large projects; (3) How to print errors in different schemes to log and end users.</p><p>An error in GreptimeDB might look like this:</p><div><pre><code><span><span>0: Foo error, at src/common/catalog/src/error.rs:80:10</span></span>
<span><span>1: Bar error, at src/common/function/src/error.rs:90:10</span></span>
<span><span>2: Root cause, invalid table name, at src/common/catalog/src/error.rs:100:10</span></span></code></pre></div></div><h2 id="introduce" tabindex="-1">Introduce <a href="#introduce" aria-label="Permalink to &#34;Introduce&#34;">​</a></h2><h3 id="understanding-error-in-rust" tabindex="-1">Understanding <code>Error</code> in Rust <a href="#understanding-error-in-rust" aria-label="Permalink to &#34;Understanding `Error` in Rust&#34;">​</a></h3><p>Rust&#39;s error handling is centered around the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err" target="_blank" rel="noreferrer"><code>Result&lt;T, E&gt;</code></a> enum, where <code>E</code> typically (but unnecessarily) extends <a href="https://doc.rust-lang.org/std/error/trait.Error.html" target="_blank" rel="noreferrer"><code>std::error::Error</code></a>.</p><div><p><span>rust</span></p><pre><code><span><span>pub</span><span> </span><span>enum</span><span> </span><span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>E</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    /// Contains the success value</span></span>
<span><span>    </span><span>Ok</span><span>(</span><span>T</span><span>),</span></span>
<span><span>    /// Contains the error value</span></span>
<span><span>    </span><span>Err</span><span>(</span><span>E</span><span>),</span></span>
<span><span>}</span></span></code></pre></div><p>This blog shares our experience organizing variant types of <code>Error</code> in a complex system like GreptimeDB, from how an error is defined to how to log the error or present it to end-users. Such a system is composed of multiple components with their own <code>Error</code> definitions.</p><h3 id="status-quo-of-rust-s-error-handling" tabindex="-1">Status Quo of Rust&#39;s Error Handling <a href="#status-quo-of-rust-s-error-handling" aria-label="Permalink to &#34;Status Quo of Rust&#39;s Error Handling&#34;">​</a></h3><p>A few standard libraries in Rust provide <code>Error</code> structs that implement <code>std::error::Error</code>, like <code>std::io::Error</code> or <code>std::fmt::Error</code>. But developers would usually define custom errors for their project, as either they want to express the application specific error info, or there is a necessity to group multiple errors in an enum.</p><p>Since the <code>std::error::Error</code> trait is not quite complicated, it&#39;s easy to implement manually for one custom error type. However, you usually won&#39;t want to do so. Because as error variants grow, it would be very hard to work with the flooding template code.</p><p>Nowadays, there are some widely used utility crates to help work with customized error types. For example, <a href="https://docs.rs/thiserror/latest/thiserror/" target="_blank" rel="noreferrer"><code>thiserror</code></a> and <a href="https://docs.rs/anyhow/latest/anyhow/" target="_blank" rel="noreferrer"><code>anyhow</code></a> are developed by the famous Rust wizard @dtolnay, with the distinction that <code>thiserror</code> is mainly for libraries and <code>anyhow</code> is for binaries. This rule suits most of the cases.</p><p>But for projects like GreptimeDB, where we divide the entire workspace into several individual sub-crates, we need to define one error type for each crate while keeping a streamlined combination. Neither <code>thiserror</code> nor <code>anyhow</code> can achieve this easily.</p><p>Hence, we chose another crate, <a href="https://docs.rs/snafu/latest/snafu/" target="_blank" rel="noreferrer"><code>snafu</code></a>, to instrument our error system. It&#39;s like a combination of <code>thiserror</code> and <code>anyhow</code>. <code>thiserror</code> provides a convenient macro to define custom error types, with display, source, and some context fields. And <code>anyhow</code> gives a <code>Context</code> trait that can easily transform from one underlying error into another with a new context.</p><p><code>thiserror</code> mainly implements the <a href="https://doc.rust-lang.org/std/convert/trait.From.html" target="_blank" rel="noreferrer"><code>std::convert::From</code></a> trait for your error types, so that you can simply use <code>?</code> to propagate the error you receive. Consequently, this also means you cannot define two error variants from the same source type. Considering you are performing some I/O operations, you won&#39;t know whether an error is generated in the write path or the read path. This is also an important reason we don&#39;t use <code>thiserror</code>: the context is blurred in type.</p><h2 id="stacking-the-error" tabindex="-1">Stacking the Error <a href="#stacking-the-error" aria-label="Permalink to &#34;Stacking the Error&#34;">​</a></h2><h3 id="design-goals" tabindex="-1">Design Goals <a href="#design-goals" aria-label="Permalink to &#34;Design Goals&#34;">​</a></h3><p>In the real world, knowing barely the root cause of error is inadequate. Suppose we are building a protocol component in GreptimeDB. It reads messages from the network, decodes them, performs some operations, and then sends them. We may encounter errors from several aspects:</p><div><p><span>rust</span></p><pre><code><span><span>enum</span><span> </span><span>Error</span><span>{</span></span>
<span><span>    </span><span>ReadSocket</span><span>(</span><span>hyper</span><span>::</span><span>Error</span><span>),</span></span>
<span><span>    </span><span>DecodeMessage</span><span>(</span><span>serde_json</span><span>::</span><span>Error</span><span>),</span></span>
<span><span>    </span><span>Operation</span><span>(</span><span>GreptimeError</span><span>),</span></span>
<span><span>    </span><span>EncodeMessage</span><span>(</span><span>serde_json</span><span>::</span><span>Error</span><span>),</span></span>
<span><span>    </span><span>WriteSocket</span><span>(</span><span>hyper</span><span>::</span><span>Error</span><span>),</span></span>
<span><span>}</span></span></code></pre></div><p>One possible error message we can get is: <code>DecodeMessage(serde_json: invalid character at 1)</code>. However, in a specific code snippet, there can be more than 10 places where decoding the message (and thus throw this error)! How can we figure out in which step we see the invalid character?</p><p>So, despite the error itself telling what has happened, if we want to have a clue on where this error occurs and if we should pay attention to it, we need the error to carry more information. For comparison, here is an example of an error log you might see from GreptimeDB.</p><div><p><span>plain</span></p><pre><code><span><span>Failed to handle protocol</span></span>
<span><span>0: Failed to handle incoming content, query: blabla, at src/protocol/handler.rs:89:22</span></span>
<span><span>1: Failed to reading next message at queue 5 of 10, at src/protocol/loop.rs:254:14</span></span>
<span><span>2: Failed to decode `01010001001010001` to ProtocolHeader, at src/protocol/codec.rs:90:14</span></span>
<span><span>3: serde_json(invalid character at position 1)</span></span></code></pre></div><p><strong>A good error report is not only about how it gets constructed, but what is more important, to tell what human can understand from its cause and trace. We call it Stacked Error.</strong> It should be intuitive and you must have seen a similar format elsewhere like backtrace.</p><p>From this log, it&#39;s easy to know the entire thing with full context, from the user-facing behavior to the root cause. Plus the exact line and column number of where each error is propagated. You will know that this error is <em>&#34;from the query &#34;blabla&#34;, the fifth package&#39;s header is corrupted&#34;</em>. It&#39;s likely to be invalid user input and we may not need to handle it from the server side.</p><p>This example shows the critical information that an error should contain:</p><ul><li><strong>The root cause</strong> that tells what is happening.</li><li><strong>The full context stack</strong> that can be used in debugging or figuring out where the error occurs.</li><li><strong>What happens from the user&#39;s perspective.</strong> Decide whether we need to expose the error to users.</li></ul><p>The first root cause is often clear in many cases, like the DecodeMessage example above, as long as the library or function we used implements their error type correctly. But only having the root cause can be not enough.</p><p>Here is another <a href="https://github.com/delta-incubator/delta-kernel-rs/pull/151" target="_blank" rel="noreferrer">evidence</a> from Delta Lake developed by Databricks:</p><p><img src="https://greptime.com/blogs/2024-05-07-error-rust/rust1.png" alt="Databricks&#39;s example"/></p><p>In the following sections, we will focus on the context stack and the way to present errors. And shows the way we implement it. So hopefully you can reproduce the same practices as in GreptimeDB.</p><h3 id="system-backtrace" tabindex="-1">System Backtrace <a href="#system-backtrace" aria-label="Permalink to &#34;System Backtrace&#34;">​</a></h3><p>So, now you have the root cause (<code>DecodeMessage(serde_json: invalid character at 1)</code>). But it&#39;s not clear at which step this error occurs: when decoding the header, or the body?</p><p>A intuitive thought is to capture the backtrace. <code>.unwrap()</code> is the first choice, where the backtrace will show up when error occurs (of course this is a bad practice). It will give you a complete call stack along with the line number.</p><p>Such a call stack contains the full trace, including lots of unrelated system stacks, runtime stacks and std stacks. If you&#39;d like to find the call in application code, you have to inspect the source code stack by stack, and skip all the unrelated ones.</p><p>Nowadays, many libraries also provide the ability to capture backtrace on an <code>Error</code> is constructed. Regardless of whether the system backtrace can provide what we truly want, it&#39;s very costly on either CPU (<a href="https://github.com/GreptimeTeam/greptimedb/pull/1261" target="_blank" rel="noreferrer">#1261</a>) and memory (<a href="https://github.com/GreptimeTeam/greptimedb/pull/1273" target="_blank" rel="noreferrer">#1273</a>).</p><p>Capturing a backtrace will significantly slow down your program, as it needs to walk through the call stack and translate the pointer. Then, to be able to translate the stack pointer we will need to include a large <code>debuginfo</code> in our binary. In GreptimeDB, this means increasing the binary size by &gt;700MB (4x compared to 170MB without debuginfo). And there will be many noises in the captured system backtrace because the system can&#39;t distinguish whether the code comes from the standard library, a third-party async runtime or the application code.</p><p>There is another difference between the system backtrace and the proposed Stacked Error. System backtrace tells us how to get to the position where the error occurs and you cannot control it, while the Stacked Error shows how the error is propagated.</p><p>Take the following code snippet as an example to examine the difference between system backtrace and virtual stack:</p><div><p><span>rust</span></p><pre><code><span><span>async</span><span> </span><span>fn</span><span> </span><span>handle_request</span><span>(</span><span>req</span><span>:</span><span> </span><span>Request</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>Output</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    </span><span>let</span><span> msg </span><span>=</span><span> </span><span>decode_msg</span><span>(&amp;</span><span>req</span><span>.</span><span>msg</span><span>).</span><span>context</span><span>(</span><span>DecodeMessage</span><span>)?;</span><span> // propagate error with new stack and context</span></span>
<span><span>    </span><span>verify_msg</span><span>(&amp;</span><span>msg</span><span>)?;</span><span> // pass error to the caller directly</span></span>
<span><span>    </span><span>process_msg</span><span>(</span><span>msg</span><span>).</span><span>await</span><span>?</span><span> // pass error to the caller directly</span></span>
<span><span>}</span></span>
<span></span>
<span><span>async</span><span> </span><span>fn</span><span> </span><span>decode_msg</span><span>(</span><span>msg</span><span>:</span><span> </span><span>&amp;</span><span>RawMessage</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>Message</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    </span><span>serde_json</span><span>::</span><span>from_slice</span><span>(&amp;</span><span>msg</span><span>).</span><span>context</span><span>(</span><span>SerdeJson</span><span>)</span><span> // propagate error with new stack and context</span></span>
<span><span>}</span></span></code></pre></div><p>System backtace will print the whole call stack, like:</p><div><pre><code><span><span>1: &lt;alloc::boxed::Box&lt;F,A&gt; as core::ops::function::Fn&lt;Args&gt;&gt;::call</span></span>
<span><span>            at /rustc/3f28fe133475ec5faf3413b556bf3cfb0d51336c/library/alloc/src/boxed.rs:2029:9</span></span>
<span><span>    std::panicking::rust_panic_with_hook</span></span>
<span><span>            at /rustc/3f28fe133475ec5faf3413b556bf3cfb0d51336c/library/std/src/panicking.rs:783:13</span></span>
<span><span>... many lines for std&#39;s internal traces</span></span>
<span><span></span></span>
<span><span>22: tokio::runtime::task::raw::RawTask::poll</span></span>
<span><span>            at /home/wayne/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/task/raw.rs:201:18</span></span>
<span><span>... many lines for tokio&#39;s internal traces</span></span>
<span><span></span></span>
<span><span>32: std::thread::Builder::spawn_unchecked_::{{closure}}::{{closure}}</span></span>
<span><span>            at /rustc/3f28fe133475ec5faf3413b556bf3cfb0d51336c/library/std/src/thread/mod.rs:529:17</span></span>
<span><span>... many lines for std&#39;s internal traces</span></span></code></pre></div><p>As you can see, it includes a lot of internal stacks that you are uninterested in.</p><p>For other complex logic like batch processing, where errors may not be propagate immediately but be holded for a while, virtual stack can also help making it easy to understand. System backtrace is captured in place when the leaf error is generated, like in the middle step of a map-reduce logic. But with virtual stack, you can postpone the timing to or after reduce step, where you have more information about the overall task.</p><h3 id="virtual-user-stack" tabindex="-1">Virtual User Stack <a href="#virtual-user-stack" aria-label="Permalink to &#34;Virtual User Stack&#34;">​</a></h3><p>Now let&#39;s introduce the virtual user stack. The word &#34;virtual&#34; means the contrast of the system stack. Means it&#39;s defined and constructed fully on user code. Look closer into the previous example:</p><div><pre><code><span><span>0: Failed to handle incoming content, query: blabla, at src/protocol/handler.rs:89:22</span></span>
<span><span>1: Failed to reading next message at queue 5 of 10, at src/protocol/loop.rs:254:14</span></span>
<span><span>2: Failed to decode `01010001001010001` to ProtocolHeader, at src/protocol/codec.rs:90:14</span></span>
<span><span>3: serde_json(invalid character at position 1)</span></span></code></pre></div><p>A stack layer is composed of 3 parts: <code>[STACK_NUM]: [MSG], at [FILE_LOCATION]</code></p><ul><li><strong>Stack num</strong> is the number of this stack. Smaller number means outer error layer. And starts from 0 of course.</li><li><strong>Message</strong> is the message related to one layer. This is scraped from the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html" target="_blank" rel="noreferrer"><code>std::fmt::Display</code></a> implementation of that error. Developers can attach useful context here, like the query string or loop counter.</li><li><strong>File location</strong> is the location where one error is generated (and propagated, for intermediate error layer). Rust provides <a href="https://doc.rust-lang.org/std/macro.file.html" target="_blank" rel="noreferrer"><code>file!</code></a>, <a href="https://doc.rust-lang.org/std/macro.line.html" target="_blank" rel="noreferrer"><code>line!</code></a> and <a href="https://doc.rust-lang.org/std/macro.column.html" target="_blank" rel="noreferrer"><code>column!</code></a> macros to help get that information. And the way we display it is also considered, most editors can jump to that location directly.</li></ul><p>In practice, we utilize <a href="https://docs.rs/snafu/0.8.2/snafu/struct.Location.html" target="_blank" rel="noreferrer"><code>snafu::Location</code></a> to gather the code location. So each location points to where the error is constructed. Through this chain we know how this error is generated and propagated to the uppermost.</p><p>Here is what it looks like all together from the code side:</p><div><p><span>rust</span></p><pre><code><span><span>#[</span><span>derive</span><span>(</span><span>Snafu</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>Error</span><span> </span><span>{</span></span>
<span><span>    </span><span>#[</span><span>snafu</span><span>(</span><span>display</span><span>(</span><span>&#34;</span><span>General catalog error: </span><span>&#34;</span><span>))]</span><span> // &lt;-- the `Display` impl derive</span></span>
<span><span>    </span><span>Catalog</span><span> </span><span>{</span></span>
<span><span>        location</span><span>:</span><span> </span><span>Location</span><span>,</span><span> // &lt;-- the `location`</span></span>
<span><span>        source</span><span>:</span><span> </span><span>catalog</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>,</span><span> // &lt;-- inner cause</span></span>
<span><span>    </span><span>}</span></span>
<span><span>}</span></span></code></pre></div><p>Besides, we implemented a proc-macro <a href="https://greptimedb.rs/common_macro/attr.stack_trace_debug.html" target="_blank" rel="noreferrer"><code>stack_trace_debug</code></a> to scrape necessary information from the Error&#39;s definition and generate the implementation of the related trait <a href="https://greptimedb.rs/common_error/ext/trait.StackError.html" target="_blank" rel="noreferrer"><code>StackError</code></a>, which provides useful methods to access and print the error:</p><div><p><span>rust</span></p><pre><code><span><span>pub</span><span> </span><span>trait</span><span> </span><span>StackError</span><span>:</span><span> </span><span>std</span><span>::</span><span>error</span><span>::</span><span>Error</span><span> </span><span>{</span></span>
<span><span>    </span><span>fn</span><span> </span><span>debug_fmt</span><span>(&amp;</span><span>self</span><span>,</span><span> layer</span><span>:</span><span> </span><span>usize</span><span>,</span><span> buf</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;);</span></span>
<span><span>    </span><span>fn</span><span> </span><span>next</span><span>(&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;&amp;</span><span>dyn</span><span> </span><span>StackError</span><span>&gt;;</span></span>
<span><span>    </span><span>fn</span><span> </span><span>last</span><span>(&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>&amp;</span><span>dyn</span><span> </span><span>StackError</span><span> </span><span>where</span><span> Self</span><span>:</span><span> </span><span>Sized</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></span>
<span><span>}</span></span></code></pre></div><p>This proc-macro mainly does two things:</p><ul><li>Implement <a href="https://greptimedb.rs/common_error/ext/trait.StackError.html" target="_blank" rel="noreferrer"><code>StackError</code></a> as the scaffold</li><li>Implement <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html" target="_blank" rel="noreferrer"><code>std::fmt::Debug</code></a> based on <code>debug_fmt()</code></li></ul><p>By the way, we have added <code>Location</code> and <code>display</code> to all errors in GreptimeDB. This is the hard work behind the methodology.</p><h3 id="macro-details" tabindex="-1">Macro Details <a href="#macro-details" aria-label="Permalink to &#34;Macro Details&#34;">​</a></h3><p>Error is a singly linked list, like an onion from outer to inner. So we can capture an error at the outermost and walk through it.</p><p>One tricky thing we did here is about how to distinguish internal and external errors. Internal errors all implement the same trait <a href="https://greptimedb.rs/common_error/ext/trait.ErrorExt.html" target="_blank" rel="noreferrer"><code>ErrorExt</code></a> which can be used as a marker. But depending on this requires a <code>downcast</code> every time. We avoid this extra <code>downcast</code> call by simply giving a different name to them and detect in our macro.</p><p>As shown below, we name all external errors <code>error</code> and all internal errors <code>source</code>. Then return <code>None</code> on implementing <a href="https://greptimedb.rs/common_error/ext/trait.StackError.html#tymethod.next" target="_blank" rel="noreferrer"><code>StackError::next</code></a> method if we find an error, or <code>Some(source)</code> if we read source.</p><div><p><span>rust</span></p><pre><code><span><span>#[</span><span>derive</span><span>(</span><span>Snafu</span><span>)]</span></span>
<span><span>#[</span><span>stack_trace_debug</span><span>]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>Error</span><span> </span><span>{</span></span>
<span><span>    </span><span>#[</span><span>snafu</span><span>(</span><span>display</span><span>(</span><span>&#34;</span><span>Failed to deserialize value</span><span>&#34;</span><span>))]</span></span>
<span><span>    </span><span>ValueDeserialize</span><span> </span><span>{</span></span>
<span><span>        </span><span>#[</span><span>snafu</span><span>(</span><span>source</span><span>)]</span></span>
<span><span>        error</span><span>:</span><span> </span><span>serde_json</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>,</span><span> // &lt;-- external source</span></span>
<span><span>        location</span><span>:</span><span> </span><span>Location</span><span>,</span></span>
<span><span>    </span><span>},</span></span>
<span></span>
<span><span>    </span><span>#[</span><span>snafu</span><span>(</span><span>display</span><span>(</span><span>&#34;</span><span>Table engine not found: </span><span>{}&#34;</span><span>,</span><span> engine_name</span><span>))]</span></span>
<span><span>    </span><span>TableEngineNotFound</span><span> </span><span>{</span></span>
<span><span>        engine_name</span><span>:</span><span> </span><span>String</span><span>,</span></span>
<span><span>        location</span><span>:</span><span> </span><span>Location</span><span>,</span></span>
<span><span>        source</span><span>:</span><span> </span><span>table</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>,</span><span>    // &lt;-- internal source</span></span>
<span><span>    </span><span>}</span></span>
<span><span>}</span></span></code></pre></div><p>The method <a href="https://greptimedb.rs/common_error/ext/trait.StackError.html#tymethod.debug_fmt" target="_blank" rel="noreferrer"><code>StackError::debug_fmt</code></a> is used to render the error stack. It would be called recursively in the generated code. Each layer of error will write its own debug message to the mutable <code>buf</code>. The content will contain error description captured from <code>#[snafu(display)]</code> attribute, the variant arm type like <code>TableEngineNotFound</code> and the location from the enumeration.</p><p>Given we already defined our error types in that way, adopting stack error doesn&#39;t require too much work, only adding the attribute macro <code>#[stack_trace_debug]</code> to every error type would be enough.</p><h3 id="present-error-to-end-users" tabindex="-1">Present Error to End Users <a href="#present-error-to-end-users" aria-label="Permalink to &#34;Present Error to End Users&#34;">​</a></h3><p>So far, we&#39;ve covered most aspects. Now, let&#39;s delve into the final piece which is how to present errors to your users.</p><p>Unlike system developers, users may not care about the line number and even the stack. What information, then, is truly beneficial to end users?</p><p>This topic is very subjective. Still taking the above error as an example, let&#39;s consider which parts would or should users care about:</p><div><p><span>plain</span></p><pre><code><span><span>Failed to handle protocol</span></span>
<span><span>0: Failed to handle incoming content, query: blabla, at src/protocol/handler.rs:89:22</span></span>
<span><span>1: Failed to reading next message at queue 5 of 10, at src/protocol/loop.rs:254:14</span></span>
<span><span>2: Failed to decode `01010001001010001` to ProtocolHeader, at src/protocol/codec.rs:90:14</span></span>
<span><span>3: serde_json(invalid character at position 1)</span></span></code></pre></div><p>The first line gives a brief description of this error, i.e., what users actually saw from the top layer. We should keep it as well. Line 2 and line 3 are about internal details, which are too verbose to include. Line 4 is the leaf internal error, or the boundary from internal code to external dependency. It might sometimes contain useful information, so we count it in. However, we only include the error description since the stack number and code location are useless to users. Then the last line is external error, which is usually the root cause and we&#39;d also include it.</p><p>Let&#39;s assemble the pieces we just picked. The final error message presents to users is as follow:</p><div><p><span>plain</span></p><pre><code><span><span>Failed to handle protocol - Failed to decode `01010001001010001` to ProtocolHeader (serde_json(invalid character at position 1))</span></span></code></pre></div><p>This can be achieved easily with previous <code>StackError::next</code> and <a href="https://greptimedb.rs/common_error/ext/trait.StackError.html#method.last" target="_blank" rel="noreferrer"><code>StackError::last</code></a>. Or you can customize the format you want with those methods.</p><p>Our experience is that the leaf (or the innermost) error&#39;s message might be useful as it is closer to what really goes wrong. The message can be further divided into two parts: internal and external, where the internal error is those defined in our codebase and the external is from dependencies, like <code>serde_json</code> from the previous example. The root (or the outermost) error&#39;s category is more accurate as it comes from where the error is thrown to the user.</p><p>In short, the error message scheme we proposed is:</p><div><p><span>plain</span></p><pre><code><span><span>KIND - REASON ([EXTERNAL CAUSE])</span></span></code></pre></div><h2 id="cost" tabindex="-1">Cost? <a href="#cost" aria-label="Permalink to &#34;Cost?&#34;">​</a></h2><p>The virtual stack is sweet so far, and it proves to be both more cost-effective and accurate compared to the system backtrace. So what is the cost?</p><p>As for runtime overhead, it only requires some string format for the per-level reason and location.</p><p>It&#39;s even better in binary size. In GreptimeDB&#39;s binary, the debug symbols occupied ~700MB. As a comparison, the <code>strip</code>-ed binary size is around 170MB, with <code>.rodata</code> section size <code>016a2225</code> (~22.6M), and the <code>.text</code> section occupies <code>06ad7511</code> (~ 106.8M).</p><p>Removing all <code>Location</code> reduces the <code>.rodata</code> size to <code>0169b225</code> (still ~22.6M, changes are very small) and the overall binary size to 170MB, while removing all <code>#[snafu(display)]</code> reduces the <code>.rodata</code> size to <code>01690225</code> (~22.5M) and the overall binary size to 170MB.</p><p>Hence, the Stacked Error mechanism&#39;s overhead to binary size is very low (~100K).</p><h2 id="conclusion-and-future-works" tabindex="-1">Conclusion and Future Works <a href="#conclusion-and-future-works" aria-label="Permalink to &#34;Conclusion and Future Works&#34;">​</a></h2><p>In this post, we present how to implement a proc-macro <a href="https://greptimedb.rs/common_macro/attr.stack_trace_debug.html" target="_blank" rel="noreferrer"><code>stack_trace_debug</code></a> and use it to assemble a low-overhead but still powerful stacked error message. It also provides a convenient way to walk through the error chain, to help render the error in different schema for different purposes.</p><p>This macro is only adopted in GreptimeDB now, we are attempting to make it more generic for different projects. A wide adoption of this pattern can also make it even more powerful by bridging third-party stacks and detailed reasons.</p><p>Besides, <code>std::error::Error</code> now provides an unstable API <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.provide" target="_blank" rel="noreferrer"><code>provide</code></a>, that allows getting a field in a struct. We can consider using it in refactoring our stack-trace utils.</p><hr/><h4 id="about-greptime" tabindex="-1">About Greptime <a href="#about-greptime" aria-label="Permalink to &#34;About Greptime&#34;">​</a></h4><p>We help industries that generate large amounts of time-series data, such as Connected Vehicles (CV), IoT, and Observability, to efficiently uncover the hidden value of data in real-time.</p><p>Visit the <a href="https://www.greptime.com/resources" target="_blank" rel="noreferrer">latest version</a> from any device to get started and get the most out of your data.</p><ul><li><a href="https://github.com/GreptimeTeam/greptimedb" target="_blank" rel="noreferrer">GreptimeDB</a>, written in Rust, is a distributed, open-source, time-series database designed for scalability, efficiency, and powerful analytics.</li><li><a href="https://www.greptime.com/product/cloud" target="_blank" rel="noreferrer">GreptimeCloud</a> is a fully-managed cloud database-as-a-service (DBaaS) solution built on GreptimeDB. It efficiently supports applications in fields such as observability, IoT, and finance. The built-in observability solution, <a href="https://www.greptime.com/product/ai" target="_blank" rel="noreferrer">GreptimeAI</a>, helps users comprehensively monitor the cost, performance, traffic, and security of LLM applications.</li><li><strong>Vehicle-Cloud Integrated TSDB</strong> solution is tailored for business scenarios of automotive enterprises. It addresses the practical business pain points that arise when enterprise vehicle data grows exponentially.</li></ul><p>If anything above draws your attention, don&#39;t hesitate to star us on <a href="https://github.com/GreptimeTeam/greptimedb" target="_blank" rel="noreferrer">GitHub</a> or join GreptimeDB Community on <a href="https://www.greptime.com/slack" target="_blank" rel="noreferrer">Slack</a>. Also, you can go to our <a href="https://github.com/GreptimeTeam/greptimedb/contribute" target="_blank" rel="noreferrer">contribution page</a> to find some interesting issues to start with.</p></div></div></div></div>
  </body>
</html>
