<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hh409.user.srcf.net/blog/lens-distortion-correction-lines.html">Original</a>
    <h1>Wide angle lens distortion correction from lines</h1>
    
    <div id="readability-page-1" class="page"><section id="Lens Distortion">
            <div>
                
                <p>
                    When a human looks at an image that is distorted with a wide angle lens, we can tell pretty much immediately that the image is distorted. 
                    Specifically we can tell that objects with straight lines in the 3D world do not have straight lines in the image.
                    
                    In almost all computer vision applications, we want to correct this distortion before we do anything else. 
                    But how exactly do we go about making straight-lines straight again?
                </p>
                <h2>Simple Radial Undistortion Models</h2>
                <p> 
                    To actually estimate undistortion we will need to have a model to fit to our distorted image. 
                    Mathematically one of the simplest ways to describe a lens undistortion model is simply to use
                    some form of spherically symetric function that operates on pixel coordinates. If we define our 
                    distorted pixels as $(u&#39;, v&#39;)$ our undistorted pixels as $(u, v)$ and the centre of image distortion
                    as $(c_x, c_y)$ then we can write a general radially symmetric undistortion model as:
                </p><p>
                $$\begin{aligned}
                    &amp; r = \sqrt{(u&#39; - c_x)^2 + (v&#39; - c_y)^2} \\
                    &amp; u = f(r) (u&#39; - c_x) + c_x \\
                    &amp; v = f(r) (v&#39; - c_y) + c_y
                \end{aligned}$$
                </p><p>
                    Where $f(r)$ is some 1D function of $r$ that we can use to model the required undistortion in the image.
                </p>
                <p> 
                    There are many different possible functions that we could use for $f(r)$ but one 
                    of the simplest and most effective is a polynomial division model:
                </p><p>
                $$\begin{aligned}
                    &amp; d(r) = \frac{1}{1 + d_1 r^2 + d_2 r^4} \\
                    \\
                    &amp; u = d(r) (u&#39; - c_x) + c_x \\
                    &amp; v = d(r) (v&#39; - c_y) + c_y
                \end{aligned}$$
                </p><p>
                    This polynomial division model is symmetric about the origin and has two parameters $d_1$ and $d_2$.
                    By adjusting these parameters we can model a wide range of different amounts of distortion.
                </p>

                <h2>Estimating Distortion by Straighting Lines</h2>
                <p>
                    One way to estimate the distortion in an image is to use straight lines. 
                    We can use the fact that straight lines in the 3D world should be straight in the image to estimate the distortion.
                </p>
                <p>
                    If we can evaluate how &#34;straight-line-y&#34; our image is then we can use this in a non-linear optmisation process
                    to tweak our undistortion process until we have the most &#34;straight-line-y&#34; image, 
                    ie. the best possible undistorted image.
                </p>
                <p>
                    So how can we measure how full of straight lines an image is? 
                    Traditional computer vision and image processing folks will be well aware of the <href="https: en.wikipedia.org="" wiki="" radon_transform"="">Radon transform and 
                    its discrete cousin the <href="https: en.wikipedia.org="" wiki="" hough_transform"="">Hough transform.
                    These are integral transforms that and are really interesting, the documentation on the Radon transform in `scikit-image` is
                    <a href="https://scikit-image.org/docs/stable/auto_examples/transform/plot_radon_transform.html">here</a> and 
                    is very much worth a read.
                </href="https:></href="https:></p>
                <p>
                    To detect lines in an image with these transforms, the first thing we need to do is to compute the edges of the image.
                    My personal favourite way to do this is by convolution use the Sobel filter. The Sobel filter is a convolution filter that computes the gradient of the image.
                    It&#39;s fast, easy to use and gives good results. Below is the original image and the result of applying the Sobel filter to it.
                </p>
                <p><img src="https://hh409.user.srcf.net/blog/Originals.jpg" alt="Original images"/>
                <img src="https://hh409.user.srcf.net/blog/Sobel.png" alt="Edge intensity"/></p><p>
                    The following code is used to compute the edges and Radon transform of the images and plot the results.
                </p>
                <pre>                <code>
    import cv2
    from skimage.transform import radon
    import matplotlib.pyplot as plt

    # Load the distorted and undistorted image
    distorted_image = cv2.imread(&#39;distorted_image.png&#39;, cv2.IMREAD_COLOR)
    undistorted_image = cv2.imread(&#39;undistorted_image.png&#39;, cv2.IMREAD_COLOR)
    distorted_image_gray = np.array(cv2.cvtColor(distorted_image, cv2.COLOR_BGR2GRAY), dtype=np.float64)
    undistorted_image_gray = np.array(cv2.cvtColor(undistorted_image, cv2.COLOR_BGR2GRAY), dtype=np.float64)

    # Convolve with the sobel filter to get the edges
    def compute_edge_intensity(image_gray: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Compute the edge intensity of the image using the Sobel filter.
        &#34;&#34;&#34;
        x = cv2.Sobel(image_gray, cv2.CV_64F, 1, 0, ksize=3)
        y = cv2.Sobel(image_gray, cv2.CV_64F, 0, 1, ksize=3)
        return np.sqrt(x**2 + y**2)

    print(&#34;Computing edges of the images&#34;)
    distorted_image_edges = compute_edge_intensity(distorted_image_gray)
    undistorted_image_edges = compute_edge_intensity(undistorted_image_gray)

    # Compute the Radon transform of the images
    print(&#34;Computing Radon transform of the images&#34;)
    theta = np.linspace(0.0, 180.0, max(image.shape), endpoint=False)
    radon_distorted = radon(distorted_image_edges, theta=theta, circle=False)
    radon_undistorted = radon(undistorted_image_edges, theta=theta, circle=False)

    # Normalize the Radon transform
    radon_distorted = radon_distorted/np.max(radon_distorted.flatten())
    radon_undistorted = radon_undistorted/np.max(radon_undistorted.flatten())

    # Plot the images
    plt.figure()
    plt.subplot(1, 2, 1)
    plt.imshow(distorted_image)
    plt.title(&#39;Distorted Image&#39;)
    plt.subplot(1, 2, 2)
    plt.imshow(undistorted_image)
    plt.title(&#39;Undistorted Image&#39;)
    plt.tight_layout()

    # Plot the edges of the images
    plt.figure()
    plt.subplot(1, 2, 1)
    plt.imshow(distorted_image_edges, cmap=&#39;gray&#39;)
    plt.title(&#39;Edges of Distorted Image&#39;)
    plt.subplot(1, 2, 2)
    plt.imshow(undistorted_image_edges, cmap=&#39;gray&#39;)
    plt.title(&#39;Edges of Undistorted Image&#39;)
    plt.tight_layout()

    # Plot the Radon transform of the images
    plt.figure()
    plt.subplot(1, 2, 1)
    plt.imshow(radon_distorted, cmap=&#39;gray&#39;)
    plt.title(&#39;Radon Transform of Distorted Image&#39;)
    plt.ylabel(&#39;r&#39;)
    plt.subplot(1, 2, 2)
    plt.imshow(radon_undistorted, cmap=&#39;gray&#39;)
    plt.title(&#39;Radon Transform of Undistorted Image&#39;)
    plt.tight_layout()
    plt.show()
                </code>
                </pre>  

                <p><img src="https://hh409.user.srcf.net/blog/Radon.png" alt="Radon transform"/></p><p>
                    Above is the Radon transform of the distorted and undistorted images, normalised relative to their maximum values.
                    The transform of the distorted image appears on average brighter than the undistorted radon transform which is what we would expect
                    as on average the undistorted radon transform has much sharper peaks.
                </p>

                <p>
                    The Hough transform is similar to the above Radon transform but is used to detect discrete lines in an image rather
                    than transform the image into a different space. It is similar to selecting peaks from the Radon transform and the OpenCV
                    version directly outputs the lines that it detects in the image.
                </p>

                <p>
                    These transforms are all well and good but are there any actual production ready algorithms that use these transforms to estimate straight-line-y-ness? And 
                    how do you go from a transform to a number you can actually optimise?
                    For the rest of this blog post we will be considering the model and methods taken from this very interesting paper:
                    <a href="https://www.ipol.im/pub/art/2016/130/article_lr.pdf">An Iterative Optimization Algorithm for Lens Distortion Correction Using Two-Parameter Models</a>.
                </p>

                <div>
                    <h2>Breakdown of the Estimation Algorithm</h2>
                    <p>
                        The algorithm from the paper is broken down into several steps. We will work through them showing intermediate results as we go.
                        Let&#39;s work with this distorted image of Chicago:
                    </p>
                    <p><img src="https://hh409.user.srcf.net/blog/chicago_distorted.jpg" alt="Distorted image"/>
                </p></div>

                <div>
                    <h3>Stage 1: Edge Detection using the Canny Method</h3>
                    <p>
                        <a href="https://en.wikipedia.org/wiki/Canny_edge_detector">The Canny Method</a> is a multi-stage algorithm that detects edges in an image. It is 
                        one of the most well known and popular edge detection algorithms. It is implemented in Matlab <a href="https://www.mathworks.com/help/images/ref/edge.html">here</a> and in OpenCV <a href="https://docs.opencv.org/4.x/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de">here</a>.
                        However the paper we are looking at today implements it themselves and this allows them a large degree of control over the process.
                        The steps of the Canny method are:
                    </p>
                    <ul>
                        <li><b>Gaussian Convolution</b>: Smooth the input image using an approximation of the recursive filter for Gaussian convolution.</li>
                        <li><b>Image Gradient</b>: Compute the image gradient using specific convolution masks to ensure rotation invariance.</li>
                        <li><b>Canny Thresholds</b>: Set the low and high thresholds for the Canny method as percentiles of the gradient norm.</li>
                        <li><b>Non-maximum Suppression</b>: Identify local maxima of the gradient norm in the gradient direction and classify them as edges.</li>
                        <li><b>Hysteresis Implementation</b>: Classify pixels as edges if they are connected to edge pixels, and explore their neighborhoods recursively.</li>
                    </ul>
                    <p>This produces an image that looks like this with individual edge pixels set to 1 and all else set to 0:</p>
                    <p><img src="https://hh409.user.srcf.net/blog/chicago_canny.png" alt="Canny"/>    
                </p></div>

                <div>
                    <h3>Stage 2: Detect Lines with Improved Hough Transform</h3>
                    <p> 
                        With the edges detected the authors of the paper next move onto their Hough transform based line detection algorithm. First of all they defined 
                        an extension of the Hough transform to include a curvature parameter. This effectively turns the Hough transform from a line integral
                        transform into a curvature parametrised curve integral transform and by stepping through this parameter the authors of the paper create a 3D output space.
                        Points in this 3D Hough output space map to specific curves in the image (lines in the undistorted space) and using the best lines available from this step
                        the authors are able to estimate a starting point for the first parameter of the undistortion model and the centre of distortion.
                    </p>
                    <ul>
                        <li><b>Extract Distortion Model</b>: Extract a one-parameter distortion model and the most voted lines using an extended Hough transform.</li>
                        <li><b>Voting Process</b>: Fill the 3D score volume based on edge points, distance, and angle variations to vote in the Hough space.</li>
                        <li><b>Line Detection</b>: Select lines with the highest votes and refine the points associated with these lines.</li>
                    </ul>

                    <p>This produces an image that looks like this with individual line segements highlighted and ready for undistortion estimation.</p>
                    <p><img src="https://hh409.user.srcf.net/blog/chicago_hough.png" alt="Hough transform"/>
                </p></div>
                <div>
                    <h3>Stage 3: Iterative Optimization</h3>
                    <p>
                        With a good starting point for the centre of distortion and the first parameter of the undistortion model the authors start refining the model using a non-linear optimization algorithm.
                        They compute the distance to a straight line for each point associated with a specific line and then optimise the distortion model to minimise this. They then
                        update the point-line associations and repeat the process until there are no changes in the number of points associated with each line.
                    </p>
                    <ul>
                        <li><b>Initialize Parameters</b>: Start with initial distortion parameters and center of distortion.</li>
                        <li><b>Gradient and Hessian Calculation</b>: Compute the gradient vector and Hessian matrix for the distortion parameters.</li>
                        <li><b>Iterative Minimization</b>: Use an iterative scheme to minimize the energy function, which reduces the distance from points to lines.</li>
                        <li><b>Model Update</b>: Update the lens distortion model with the optimized parameters.</li>
                    </ul>
                </div>
                <div>
                    <h3>Stage 4: Image Distortion Correction</h3>
                    <p>
                        Finally with the full distortion model calculated the authors can apply the distortion to the whole
                        original colour image and generate a corrected image.
                    </p>
                    <ul>
                        <li><b>Inverse Vector Calculation</b>: Compute the inverse vector for image pixels using the estimated lens distortion model.</li>
                        <li><b>Distortion-Free Image Computation</b>: Apply bilinear interpolation to generate the distortion-free output image based on the corrected pixel coordinates.</li>
                    </ul>
                    <p>We now have an undistorted image, and we didn&#39;t have to play around with checkerboards:</p>
                    <p><img src="https://hh409.user.srcf.net/blog/chicago_undistorted.jpg" alt="Undistorted image"/>
                </p></div>




                <h2>Matching Division Model to OpenCV</h2>
                <p>
                   While it&#39;s nice to have an algorithm that can estimate the distortion without needing a specific checkerboard
                   it&#39;s generally a good idea to be able to use very popular libraries like OpenCV to do our undistorting for us
                   as these libraries are very widespread in the robotics community and well maintained. If we can convert
                   our division model to the OpenCV model then we can estimate with our Hough code and then store coefficients 
                   and undistort with OpenCV.
                </p>

                <p>
                    Lets write out the equations for the two models and then we can compare the similarities and differences between them.
                </p>
                <p>
                    The division model:
                </p><p>
                $$\begin{aligned}
                    &amp; r = \sqrt{(u&#39; - c_x)^2 + (v&#39; - c_y)^2} \\
                    &amp; d(r) = \frac{1}{1 + d_1 r^2 + d_2 r^4} \\
                    \\
                    &amp; u = d(r) (u&#39; - c_x) + c_x \\
                    &amp; v = d(r) (v&#39; - c_y) + c_y
                \end{aligned}$$
                </p><p>
                    What do we notice about the division model?
                </p>
                <ol>
                    <li>The division model is a direct <strong>correction</strong> model; it is a model that is used to correct the distortion that is present in the image by transforming distorted pixels. </li>
                    <li>The division model operates in <strong>image coordinates</strong>. This means that the distortion model is applied after the multiplication by the focal length so the scale of the polynomial is dependent on the focal length.</li>
                </ol>
                
                <p>
                    And now the OpenCV model:
                </p><p>
                $$\begin{aligned}
                    &amp; r_\theta = \sqrt{x^2 + y^2} \\
                    &amp; \theta = \arctan(r_\theta) \\
                    &amp; \theta_d = \theta \left(1 + k_1 \theta^2 + k_2 \theta^4 + k_3 \theta^6 + k_4 \theta^8\right) \\
                    &amp; s(r_\theta) = \frac{\theta_d}{r_\theta} \\
                    \\
                    &amp; u&#39; = s(r_\theta) x f + c_x \\
                    &amp; v&#39; = s(r_\theta) y f + c_y
                \end{aligned}$$
                </p><p>
                    What do we notice about the OpenCV model?
                </p>
                <ol>
                    <li>The OpenCV model is a <strong>distortion</strong> model; it is a generative model where the coefficients of the model describe a polynomial that is used to distort rays of light that would otherwise be modeled as projecting onto an image plane as in the pinhole model.</li>
                    <li>The OpenCV model operates in <strong>normalized image coordinates</strong>. This means that the distortion model is applied before multiplication by the focal length so the scale of the polynomial is not dependent on the focal length.</li>
                </ol>

                <p>
                    The first thing to do that will make things a lot easier when converting one to the other is to assume that we have 
                    centred our image at the principal distortion point, $(c_x, c_y) = (0, 0)$.
                </p>
                <p>
                    We then need to link the two models in terms of a single one of $r$ or $r_\theta$. 
                    Let&#39;s start with the OpenCV model:
                </p><p>

                $$\begin{aligned}
                    &amp; r_\theta^2 = x^2 + y^2 \\
                    &amp; r^2 = u&#39;^2 + v&#39;^2 \\
                    &amp; u&#39; = s(r_\theta) x f \\
                    &amp; v&#39; = s(r_\theta) y f \\
                    &amp; r^2 = \left(s(r_\theta) x f\right)^2 + \left(s(r_\theta) y f\right)^2 \\
                    &amp; = f^2 s(r_\theta)^2 (x^2 + y^2) \\
                    &amp; = f^2 s(r_\theta)^2 r_\theta^2 \\
                    \\
                    &amp; r = f s(r_\theta) r_\theta
                \end{aligned}$$

                </p><p>
                    We can then also consider the division model:
                </p><p>
                $$\begin{aligned}
                    &amp; r = \sqrt{u&#39;^2 + v&#39;^2} \\
                    &amp; d(r) = \frac{1} {(1 + d_1  r^2 + d_2 r^4)} \\
                    &amp; u = d(r) u&#39; \\
                    &amp; v = d(r) v&#39; \\
                    &amp; u^2 + v^2 = d(r)^2  (u&#39;^2 + v&#39;^2) \\
                    \\
                    &amp; x f = u \\
                    &amp; y f = v \\
                    &amp; u^2 + v^2 = f^2  (x^2 + y^2) \\
                    \\
                    &amp; f^2 (x^2 + y^2) = d(r)^2 (u&#39;^2 + v&#39;^2) \\
                    &amp; f^2 r_\theta^2 = d(r)^2 r^2 \\
                    &amp; r_\theta^2 = d(r)^2 r^2 / f^2 \\
                    &amp; r_\theta = d(r) r / f
                \end{aligned}$$

                </p><p>
                    Substituting $r_\theta = d(r) r / f$ into $r = f s(r_\theta) r_\theta$ we get:
                </p><p>
                $$\begin{aligned}
                    &amp; r = \frac{f s \left( d(r) r / f \right) d(r) r}{ f} \\
                    &amp; r = s \left( d(r) r / f \right) d(r) r \\
                    &amp; r \left( s \left( d(r) r / f \right) d(r) - 1 \right) = 0 \\
                    &amp; s \left( d(r) r / f \right) d(r) - 1 = 0 \\
                    &amp; s \left( d(r) r / f \right) = \frac{1} {d(r)}
                \end{aligned}$$
                </p><p>
                    This gives us a cost function. We can compute $d(r)$ for a range of $r$ values and then use 
                    a non-linear optimization algorithm to find the values of $k_i$ that minimize the cost function.
                </p>
                <p>
                    This is what the code would look like to do this:
                </p>
                <pre>                <code>

def match_opencv_distortion_to_undistortion_model(undistortion_model: Callable, max_r: float):
    &#34;&#34;&#34;
    Implements fitting s() using the equation:
    s(d(r) * r / f) = 1 / d(r) 
    &#34;&#34;&#34;
    r_array = np.linspace(1.0, max_r, 4000)
    d = np.array([undistortion_model(r) for r in r_array])
    def cost_function(k_array):
        k1, k2, k3, k4 = k_array
        sumout = 0.0
        for i, r in enumerate(r_array):
            r_theta = d[i] * r / DEFAULT_OPENCV_FOCAL_LENGTH
            sumout += (1.0 / d[i] - opencv_fisheye_polynomial(r_theta, k1, k2, k3, k4, opencv_focal_length=1.0))**2
        return sumout
    k0 = [0.0, 0.0, 0.0, 0.0]
    res = minimize(
        cost_function,
        k0,
        method=&#39;l-bfgs-b&#39;,
        options={&#39;ftol&#39;: 1e-10, &#39;disp&#39;: False, &#39;maxiter&#39;: 10000},
    )
    print(res)
    return res.x
                    </code>
                </pre>


                <p>
                    We could of course decide to go the other way, given an OpenCV model we could compute $d(r)$ by
                    some more gentle algebra manipulation:
                </p><p>
                $$\begin{aligned}
                    &amp; r_\theta = d(r) r / f \\
                    &amp; r = f s(r_\theta) r_\theta \\
                    &amp; r_\theta = d\left( f s(r_\theta) r_\theta \right) s(r_\theta) r_\theta 
                \end{aligned}$$
                </p><p>
                    This gives us a cost function. We can compute $s(r_\theta)$ for a range of $r_\theta$ values and then use 
                    a non-linear optimization algorithm to find the values of $d_i$ that minimize the cost function.
                </p>

                <div>
                    <h3>Conclusion and Code</h3>
                    <p>
                        In this blog post we have looked at how to estimate lens distortion using straight lines in an image. 
                        We have seen how the Radon and Hough transform can be used to detect lines in an image and we have 
                        analysed a production system for carrying out lens distortion using straight lines only. 
                        If you would like to play around with the code I have added some pybindings to the original C++ code
                        and it is all available on my <a href="https://github.com/hugohadfield/LensDistortionFromLines">GitHub</a>.
                    </p>
                </div>

                                

            </div>
        </section></div>
  </body>
</html>
