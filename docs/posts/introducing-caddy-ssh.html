<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.caffeinatedwonders.com/2022/03/28/new-ssh-server/">Original</a>
    <h1>Show HN: Introducing Caddy-SSH</h1>
    
    <div id="readability-page-1" class="page"><div>
        <h2 id="prologue">Prologue</h2>
<p>Much of the Internet infrastructure runs on software written in memory unsafe programming languages. Two independent studies by <a href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/">Microsoft</a> and <a href="https://www.zdnet.com/article/chrome-70-of-all-security-bugs-are-memory-safety-issues/">Google</a> present the same figure of ~70% of bugs being rooted in memory safety issues. The <a href="https://www.abetterinternet.org/docs/memory-safety/">ISRG estimates ~80%</a> of the vulnerabilities exploited in the wild are memory safety bugs. The existing tools to save unsafe languages are bandaids, and we ought to do better by spending an ounce of prevention. The Internet and the collective community should not panic for another Heartbleed. The concern is grave enough for the ISRG to commission the <a href="https://www.memorysafety.org/">Prossimo project</a> ‚Äúto move the Internet‚Äôs security-sensitive software infrastructure to memory safe code‚Äù <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Prossimo‚Äôs current initiatives are concerned with  Rusttls, the Linux kernel, curl, Apache mod_tls, NTP, and DNS.</p>
<p>There is lots of work left to do for the rest of us. There are plethora of supportive and functional software that runs the Internet. The myriad of web servers, ssh servers, OpenSSL, gpg, and the various VPN services and others are all serving users for critical needs. The efforts are underway to build modern and memory safe alternatives of legacy infrastructure. Caddy, age, Tailscale, and Algo are leading the way on some of those fronts.</p>
<p>Modern software should not only be flexible and modular, but also have sane, safe, and secure defaults. For instance, the HTTP server of Caddy is HTTPS by default, even for localhost. It also does <em>not</em> enable <em>nor</em> support TLS 1.1 or lower, and Caddy only enables the ciphers <code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</code>, <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code>, <code>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</code>, <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>, <code>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305</code>, <code>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</code> by default, which are all part of the <a href="https://ciphersuite.info/cs/?security=secure&amp;singlepage=true">secure and recommended cipher suite list</a>. Any other ciphersuite outside of the recommended list must be willfully and <a href="https://caddyserver.com/docs/caddyfile/directives/tls#ciphers">manually enabled by the user</a>, but it is not part of the default configuration that is intended to be <a href="https://en.wikipedia.org/wiki/Secure_by_default">secure by default</a>.</p>
<p>It is with those concerns that I built the <a href="https://github.com/mohammed90/caddy-ssh"><code>ssh</code></a> server app atop <a href="https://caddyserver.com/">Caddy</a>. Modular, memory safe, and secure by default: choose all three.</p>
<p>Et Voila: <a href="https://github.com/mohammed90/caddy-ssh">Caddy-SSH</a></p>
<h2 id="reveal-caddy-sshhttpsgithubcommohammed90caddy-ssh">Reveal: <a href="https://github.com/mohammed90/caddy-ssh">Caddy-SSH</a></h2>
<p>Few days before the Caddy v2.0.0 release in 2020, I mused with the rest of the Caddy team about how hard or easy it will be to have a Caddy <code>ssh</code> app akin to its <code>http</code> app. Talk is cheap, so I wielded my editor to build the proof-of-concept.</p>
<blockquote><p lang="en" dir="ltr">Ooo, someone is building a pure-Go (memory-safe!) SSH server for Caddy. <a href="https://twitter.com/hashtag/golang?src=hash&amp;ref_src=twsrc%5Etfw">#golang</a></p>‚Äî üßó‚Äç‚ôÇÔ∏è Matt Holt (@mholt6) <a href="https://twitter.com/mholt6/status/1256349693610582018?ref_src=twsrc%5Etfw">May 1, 2020</a></blockquote>


<p>Sure enough, it was easy to whip up a rough prototype within few days by standing on the shoulders of the giants: <a href="https://caddyserver.com">Caddy</a> and <a href="https://github.com/gliderlabs/ssh">github.com/gliderlabs/ssh</a>. This is when Matt Hold, of Caddy, sent out the spoiler tweet.</p>
<blockquote><p lang="en" dir="ltr">Just logged into a memory-safe SSH server written in pure <a href="https://twitter.com/hashtag/golang?src=hash&amp;ref_src=twsrc%5Etfw">#golang</a> and served by Caddy. üëÄ - cheers to <a href="https://twitter.com/MohammedSahaf?ref_src=twsrc%5Etfw">@MohammedSahaf</a>. This could be huge <a href="https://t.co/2O5qGuzYsb">pic.twitter.com/2O5qGuzYsb</a></p>‚Äî üßó‚Äç‚ôÇÔ∏è Matt Holt (@mholt6) <a href="https://twitter.com/mholt6/status/1257073951525572608?ref_src=twsrc%5Etfw">May 3, 2020</a></blockquote>


<p>At that time, the ssh server app was far from complete, but we know it is possible. I spent the next ~2 years working on the project, squeezing the time between $DAYJOB, school, and life to get it to the MVP stage. This is where we are now. The project currently resides on GitHub at <a href="https://github.com/mohammed90/caddy-ssh"><code>mohammed90/caddy-ssh</code></a> and you can also find it listed on the <a href="https://caddyserver.com/docs/modules/">Caddy server website</a>.</p>
<p>Users can currently login using ssh keys or password, backed by either the operating system (requires cgo) or via URLs referenced in the config (e.g. referring to <code>https://github.com/&lt;username&gt;.keys)</code>. The authentication providers are Caddy modules, so they can be whatever you want as long as they adhere to the defined interface.</p>
<p>The default module for hostkey generation is called <code>fallback</code>, which load for any existing hostkeys but will generate only RSA 4096 and ed25519 if either is absent. The source of the signers is modular, which means it can source the hostkey anyway it sees fit, which may be Hashicorp Vault or some microservice endpoint.</p>
<p>An authorization mechanism exists, which is also modular and can take action based on any criteria, whether based on internal state (e.g. count of currently active sessions), user metadata, or other session-related data. The authorization criteria can be chained using the <code>ssh.session.authorizers.chained</code> module, which runs the authorizers as middlewares applying the authorization and deauthorization logic in FIFO. Users can spawn shells and tunnels and are subject to modular authorization mechanisms as well.</p>
<p>Being a Caddy app and inspired much by Caddy‚Äôs design, the connection configuration and actions (analogous to HTTP handlers) are all executed and applied based on the matchers defined along them.</p>
<h2 id="whats-next">What‚Äôs Next</h2>
<p><a href="https://github.com/mohammed90/caddy-ssh/pull/3">Windows Support</a>: The Windows support is lagging behind due to difficulties with the PTY management on Windows. The OS-backed password authentication was implemented, thanks to Justen Walker (jwalk) on the Gopher Slack for guidance, but the spawned sessions are always bound by the user running the server. This was initially implemented with dependency on the <a href="https://github.com/rprichard/winpty">winpty project</a>, which successfully spawns a session but bound by the current user running the ssh server. Later attempt to use <a href="https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/">ConPTY</a> failed due to Windows security context and permissions which require me to deep-dive into the Windows sandbox models. At this point, I left the Windows parts WIP until the spawning of sessions using logged-in user context is implemented properly.</p>
<p><a href="https://github.com/mohammed90/caddy-ssh/pull/2">Config Adapter</a>: The <code>sshd_config</code> adapter is theoretically possible, which will enable the caddy-ssh app to load the current sshd config and take over. This makes the transition smoother for most users. After some minor work on it I realized it requires a proper parser to effectively manage the match config scopes. I have pulled this part into a <a href="https://github.com/mohammed90/caddy-ssh/pull/2">PR</a> for a future visit.</p>
<p>Multi-Factor Authentication: This is blocked by an upstream <a href="https://github.com/golang/go/issues/17889">issue in x/crypto/ssh</a>. The workaround implemented by SFTPGo requires forking x/crypto/ssh, which I am not in favor of. It is best if the implementation is upstreamed to benefit the ecosystem instead. The other workaround requires an abuse of the <code>keyboard-interactive</code> authentication method, but it will only work with passwords. Another workaround is to rotate the passwords over time in similar manner to the second-factor TOTP that is often used with Google Authenticator, Microsoft Authenticator, or you favorite password manager app. I have implemented this to test the waters. You can find the working implementation <a href="https://github.com/mohammed90/caddy-ssh/pull/8">in the linked PR</a>.</p>
<p>Host-key Rotation: OpenSSH 6.8 (2015) was released with support for <a href="https://lwn.net/Articles/637156/">automatic hostkey rotation</a>. I‚Äôm not aware of any blockers except for writing the code. I admit not having looked at the intricacies of how this works yet.</p>
<p>Rich Connection Context: The way x/crypto/ssh is implemented now does not expose the username at the time of applying the server configuration for an incoming connection. This hinders some of the advanced functions provided by OpenSSH, e.g. match on username to decide on custom hostkeys. Figuring this out requires deep-dive into the OpenSSH code as well as x/crypto/ssh.</p>
<p>You: Modular, open-source software lives and dies by its ecosystem. I have tried to build a good foundation for other modules to be developed. Feedback from the community is most valuable at this point to steward the project forward. File issues and feature requests, send pull requests, and discuss the design. Once we have a solid foundation, we can extract the proper bits outside the <code>internal/</code> package for consumers.</p>
<p>For now, Matt can mark one of those as done :)</p>
<blockquote><p lang="en" dir="ltr">Plugin ideas for Caddy (up for grabs): SSH server, VPN server, Git server.</p>‚Äî üßó‚Äç‚ôÇÔ∏è Matt Holt (@mholt6) <a href="https://twitter.com/mholt6/status/889926101732126725?ref_src=twsrc%5Etfw">July 25, 2017</a></blockquote>




        
    </div></div>
  </body>
</html>
