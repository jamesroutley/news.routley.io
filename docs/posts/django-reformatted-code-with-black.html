<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/django/django/pull/15387">Original</a>
    <h1>Django: Reformatted code with Black</h1>
    
    <div id="readability-page-1" class="page"><article><h2 id="hytradboi">HYTRADBOI</h2><p>Many new talks have been added to the <a href="https://www.hytradboi.com/#speakers">HYTRADBOI schedule</a>. There are another 15 or so in the pipeline.</p><p>It&#39;s starting to look pretty exciting.</p><h2 id="milestones">Milestones</h2><p>I&#39;ve been thinking lately about the psychological need for a sense of completion, or at least milestones.</p><p>In industrial jobs my work has typically been organized around discrete projects with a clear roadmap like &#39;support the postgres json api&#39;.</p><p>For academics, I imagine papers and conference deadlines produce a similar demarcation of projects and time.</p><p>But when doing independent research I&#39;ve typically fallen into the habit of creating unbounded projects with no internal structure. I don&#39;t think this has been good for my sanity.</p><p><a href="https://www.inkandswitch.com/">Ink &amp; Switch</a> have an appealing research model. There&#39;s clearly an overarching theme, but the actual research is done in individual three month projects, each of which has a clear goal and finishes with a writeup at the end of the period regardless of what state the project is in.</p><p>I think this would kill the sense of sunk costs that keep me moving down a particular branch of research long after the returns have declined.</p><p>With that in mind, I&#39;ve tried to retroactively separate the <a href="https://www.scattered-thoughts.net/#imp">history of imp</a> into distinct versions. I think both v0 and v1 were well-scoped projects that succesfully answered the motivating questions:</p><ul><li>v0 showed that I could describe a html GUI with relations and get good enough performance to hit frame budgets.</li><li>v1 showed that it is possible to make a relational language that is as capable as sql but with a dramatically simpler specification.</li></ul><p>But v2 is a mess that doesn&#39;t have a clear goal and is being pulled in many different directions. I wanted to explore using imp as a general-purpose language. I wanted to explore live interaction as a development model. I wanted to explore relational approaches to local-first software. And on top of all of that I was trying to ship something that other people could use.</p><p>So I&#39;m going to put a pin in v2. And in the future I think it would be a good idea for each successive effort to have a new version number, a clear focus (especially with regards to research vs development), and a deadline after which I write up the results.</p><p>Similarly for <a href="https://github.com/jamii/dida">dida</a>. If I split the &#34;easier to use and understand&#34; goal into two I think it&#39;s fair to say that &#34;easier to understand&#34; is a success. Dida contains all the core ideas of differential dataflow (minus the parallel layer) but is under 2000 lines of direct well-commented code and is accompanied by a <a href="https://github.com/jamii/dida/blob/main/docs/why.md">detailed explanation</a> of the core algorithms. That&#39;s a milestone.</p><p>This is a kind of magic trick. I didn&#39;t write any new code or give up on any goals, but I no longer feel weighed down by unfinished work.</p><h2 id="data-soup">Data soup</h2><p>My computer usage is full of tiny CRUD problems that are typically solved either with single-purpose apps or with adhoc manual effort. Here&#39;s a random selection off the top of my head:</p><ul><li>reading queue <ul><li>currently: whatever is currently downloaded in kindle app, whatever is unread in rss reader, occasionally snoozed emails to self</li><li>problems: list differs between phone and kindle, no solution for non-kindle/rss sources eg academic papers</li></ul></li><li>bibliography <ul><li>current: ratings in goodreads</li><li>problems: goodreads often loses data, doesn&#39;t offer search within texts, doesn&#39;t work for eg academic papers</li></ul></li><li>notes <ul><li>current: goodreads ratings + kindle annotations + markdown on my website + text files fed into spaced repetition tool</li><li>problems: spread out, multiple formats</li></ul></li><li>spaced repetition <ul><li>current: text files + custom tui + json load/dump of history</li><li>problems: only on laptop, no sync to phone, so rarely used</li></ul></li><li>work journal <ul><li>current: single text file</li><li>problems: no search by date</li></ul></li><li>todo list <ul><li>current: text file on phone, per-day list in work.md, calendar entries, emails left in inbox, notepad on desk</li><li>problems: no sync between different lists on different devices, no support for recurring tasks, no assistance with prioritization or estimating workload</li></ul></li><li>issue tracking for code/research projects <ul><li>current: text file per project</li><li>problems: hard to organize, hard to share</li></ul></li><li>website <ul><li>current: markdown files + git + zola + bash + netlify-cli</li><li>problems: very limited template language leads to doing things manually (eg the &#39;log&#39; section on the frontpage is edited by hand because zola shortcodes don&#39;t have access to global variables) or not at all (eg no anchors for sections on frontpage), non-trivial overhead for creating new posts, workflow for images sucks, incremental build doesn&#39;t handle includes in templates correctly (eg have to manually rebuild for every css change because I inline it)</li></ul></li><li>wife&#39;s website <ul><li>current: zola + netlify cms</li><li>problems: no drafts, wrong css in previews, editor doesn&#39;t support tables</li></ul></li><li>office hours <ul><li>current: calendly + google calendar</li><li>problems: doesn&#39;t support fastmail calendar so I have to manually insert busy times in calendly</li></ul></li><li>shopping list <ul><li>current: add items to google sheets throughout week, delete when buying</li><li>problems: mobile ui is clunky, sync uses extravagant bandwidth (seen &gt;50mb for a shopping list with 30 items)</li><li>(don&#39;t have signal in the supermarket so any solution has to work offline)</li></ul></li><li>accounts <ul><li>current: mine in julia script using csv statement, wife&#39;s in google sheets and entered entirely by hand, total breakdown calculated by hand using outputs from both</li><li>problems: sheets requires far too much manual effort and is error-prone, julia script requires too much technical knowledge</li></ul></li><li>budget / projections <ul><li>current: julia script</li><li>problems: doesn&#39;t read from accounts, output is hard to share, my wife can&#39;t alter variables</li></ul></li><li>weight tracker <ul><li>current: proprietary android app</li><li>problems: no sync between devices, hard to export data to produce a non-terrible graph</li></ul></li><li>time tracker <ul><li>current: none</li><li>problems: no idea where my time goes</li></ul></li><li>hytradboi <ul><li>current: google forms for talk submissions, hand-edited html for schedule</li><li>problems: no way to track as-yet-unsubmitted talks, annoying to feed data into site generator (eg have to deal with google auth), no support for sending emails (eg send reminder to speakers who haven&#39;t uploaded their talk yet)</li></ul></li><li>sponsorship graph (<a href="https://www.scattered-thoughts.net/writing/2021/sponsorship.png">eg</a>) <ul><li>current: trigger a csv export from github, download it from my email inbox, run a julia script to produce a graph, click on the graph and save to png, move png to my website repo, add a markdown image link to post</li><li>problems: annoying manual work</li></ul></li><li>email search <ul><li>current: either fastmail ui or notmuch-emacs</li><li>problems: keep forgetting the weird filter dsl, have trouble constructing larger queries</li></ul></li></ul><p>For most of these the actual logic is not very complicated and the effort lies instead in persistence, cross-device sync, cross-platform gui, automatic deployment etc - the kind of problems I described in <a href="https://www.scattered-thoughts.net/writing/pain-we-forgot/">Pain we forgot</a>. This is sufficiently effortful that I rarely write code to solve my own problems, even very simple problems like the ones above.</p><p>This is why I think a lot of talk about end-user programming misses the point - we don&#39;t even have very good solutions for programmer programming yet. There&#39;s so much action around different approaches to making it easier to specify the logic, but the logic is the easy part of these problems.</p><h2 id="airtable">Airtable</h2><p>Most of the problems above can be solved pretty nicely in <a href="https://www.airtable.com/">airtable</a>.</p><p>For example, here is the example from <a href="https://www.scattered-thoughts.net/writing/pain-we-forgot/">Pain we forgot</a>, including automations which send out emails to gather orders from employees and send the days order to the caterer:</p><p><img src="https://d33wubrfki0l68.cloudfront.net/1c7011592e478a16fce3edb04b87efbb9f1a8ba9/3c8fb/log/0020/airtable-pain-we-forgot.png"/></p><p>And here is a simple accounts table with total spending broken down by year, month and tag:</p><p><img src="https://d33wubrfki0l68.cloudfront.net/418c2d4ddac0489fff609f93af47789cba5a793e/c84b1/log/0020/airtable-accounts.png"/></p><p>Even my email inbox would look pretty reasonable in airtable:</p><p><img src="https://d33wubrfki0l68.cloudfront.net/54b4978a169fc79e1a577dc4ee70a840ef69f270/f7bfb/log/0020/airtable-email-0.png"/></p><p><img src="https://d33wubrfki0l68.cloudfront.net/6f8ba9a766bf7137ae841154eabd63a22f6fadf6/4322d/log/0020/airtable-email-1.png"/></p><p>Airtable is not the first software to follow this database + widgets approach but it&#39;s by far the best I&#39;ve used on many axes. For many usecases it&#39;s a great solution. Organizations that have complex and constantly changing workflows are typically poorly served by paying for custom software development - misunderstood requirements, frustrating UIs, slow turnaround on change requests. Airtable is a huge improvement.</p><p>So why don&#39;t I use airtable to solve my data soup problems?</p><p>The biggest downside is the existential risk. Airtable has <a href="https://medium.com/airtable-eng/the-continual-evolution-of-airtables-codebase-migrating-a-million-lines-of-code-to-typescript-612c008baf5c">&#39;over a hundred engineers and over a million lines of code... most of Airtable&#39;s engineers are yet to be hired, and most of Airtable&#39;s code is yet to be written, by many orders of magnitude&#39;</a>. Airtable seems to be doing very well but the expected lifespan of even very successful SaaS companies is typically much shorter than the lifespan of personal data. That data can be exported from airtable, but the logic and UI can&#39;t. Even if the airtable code base was open source it would be far too large to outlive the company - just preventing the build from bitrotting would probably require a full-time maintainer in the long run, given how javascript ecosystems age.</p><p>I also get frustrated by arbitrary limitations of the query model. For example if I upload some bank transactions and group by counter-party it will automatically show the total amount spent per counterparty. But if I sort by amount, it sorts the records within each group by amount rather than sorting the groups by total amount. As far as I can tell there is no way to sort the groups. In my existing accounts script there is a list of (regex,tag) pairs. For each transaction, the first matching regex determines the tag. In airtable I&#39;d love for the list of (regex,tag) pairs to itself be a table so it&#39;s easy to edit, but it doesn&#39;t seem to be possible to do any kind of query across tables except via linked records. The best I&#39;ve come up with so far is attaching a js script that, when manually triggered, reads from both tables and mutates the tag column. In imp this kind of query is trivial.</p><p>The performance would also bug me. The little inbox demo I made takes several seconds to load. The contacts autocomplete popup takes maybe a second, despite the fact that it only has to complete from a list of 3 contacts and they should surely be cached given that I just opened it several times. I have ... 89063 emails in my mailbox. I&#39;m not confident that the UI would take kindly to that. (Loading my mailbox into airtable would also take me into the &#39;call us&#39; pricing tier.) But with native tools like <a href="https://notmuchmail.org/notmuch-emacs/">notmuch-emacs</a> searching in my mailbox typically takes ~50ms.</p><p>Finally, I don&#39;t like being dependent on an internet connection. Especially for things like todo lists, shopping lists, checking if I have room in my budget for donuts etc which I do from my phone and often in areas with spotty service.</p><p>The way I look at it, airtable is this bundle of constraints:</p><ul><li>Solve the &#39;pain we forgot&#39; problem</li><li>Solve the end-user programming problem</li><li>Maximize ease of use</li><li>Cloud-first</li></ul><p>Whereas what I want is:</p><ul><li>Solve the &#39;pain we forgot&#39; problem</li><li>Expose some expressive query language</li><li>Maximize long-term maintainability</li><li>Local-first</li></ul><p>Which opens up all kinds of fun research questions. What would a CRDT look like for an airtable-like schema editor? How could all those myriad UI interactions be handled without mountains of custom UI code? How did Jamie manage to turn a shopping list into a research project?</p><h2 id="fossil">Fossil</h2><p><a href="https://www.fossil-scm.org/">Fossil</a> is the one of the few local-first apps I know that is actually used in anger. It started out as just a DVCS but over time grew a wiki, issue tracker, forum and various other embedded apps. All of which run offline and can be pushed/pulled between repos and even forked.</p><p>So I was curious to find out how it worked under the hood.</p><p>The underlying data-structure is content-addressed append-only set of artefacts. Forum threads, wiki pages, issues etc are built by summing up the effects of special event artefacts.</p><p>Forums are effectively OR-sets - all you can do to a post once it has been made is delete it, leaving a tombstone in the tree.</p><p>Wiki pages do last-write-wins. I expected to at least get a merge conflict, but no.</p><p>Issues are bags of key-value pairs, where each pair does last-write-wins.</p><p>In one sense, it&#39;s disappointing that there is so little handling of conflicts.</p><p>But on the other hand, there is very little handling of conflicts and it seems like it&#39;s fine in practice. So maybe many problems can fall to being broken down into atomic facts and doing last-write-wins for each fact?</p><h2 id="self-hosting">Self-hosting</h2><p>I lurked in various discussions of self-hosting recently. One point that seemed rarely challenged is that self-hosting is hard.</p><p>That has been my experience for many pieces of software. But self-hosting fossil is really easy.</p><p>What makes most software hard to self-host?</p><ul><li>Too many moving pieces</li><li>Too many configs to learn</li><li>Non-trivial backup and restore</li></ul><p>What makes fossil easy to self-host?</p><ul><li>Single executable</li><li>Builtin web server (<code>fossil serve</code>)</li><li>Single file database (easy backup and recovery)</li><li>Sync to other devices (your local working copy of a fossil repo is also a backup)</li><li>Config stored in the database</li><li>Config edited by builtin web interface (<code>fossil ui</code>)</li></ul><p>Other things we could add:</p><ul><li>Automatic updates <ul><li>Notifies me first if update requires more than a few seconds downtime, manual action (eg migration) or might break something. (Notifying people is often the part I&#39;m most worried about breaking and is often hard to configure eg synapse wants a separate email gateway set up. But fossil will talk directly to fastmail for me.)</li></ul></li><li>Self-check <ul><li>Notify me if not reachable from the internet</li><li>Notify me if running out of disk space</li></ul></li><li>Simplified hosting <ul><li>Give them a binary and a database, they run it (and restart it if necessary)</li><li>Notify me about crashes/restarts</li><li>Ship a minimal OS that does nothing but run my binary</li><li>Deal with OS upgrades (shouldn&#39;t cause problems if not depending on dynamic libraries, userland services etc)</li></ul></li><li>Put a console/repl in the web interface so I can do bulk edits (eg banning users)</li></ul><p>Why isn&#39;t this more common? I suspect because most software is optimized for industrial use, not personal use. For industrial uses the operations overhead is not a big deal compared to the development and operational efficiency gained by breaking things up into communicating services. But for personal uses the overwhelming priority is reducing complexity so that nothing fails.</p><h2 id="links">Links</h2><p><a href="https://looker-open-source.github.io/malloy/documentation/index.html">Malloy</a> is a yet another &#39;better sql&#39;, but a pretty credible one. It leans hard into nested relational algebra, producing a language that feels a lot like <a href="https://www.tableau.com/products/desktop">tableau</a> looks. I was initially put off by the fact that it only supported pre-defined joins, but <a href="https://looker-open-source.github.io/malloy/documentation/language/join.html">adhoc joins</a> were added recently.</p><p>Andy Matuschak published a <a href="https://andymatuschak.org/2021/">2021 retrospective</a> covering the challenges of creative work, life as an independent researcher, the long-term prospects of patronage and the lack of a &#39;tools for thought&#39; community.</p></article></div>
  </body>
</html>
