<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrocomputing.stackexchange.com/questions/26083/how-could-early-unix-os-comprise-so-few-lines-of-code">Original</a>
    <h1>How could the early Unix OS comprise so few lines of code?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<blockquote>
<p>Is it true, and if so how did they manage it?</p>
</blockquote>
<p>Yes, it is true, as proven by the book linked in Brian&#39;s answer.</p>
<p>As to how they managed it: computers are, as a rule of thumb getting more complex over time. Turning that around means that in the past, computers were on average simpler than today. The <a href="https://pdos.csail.mit.edu/6.828/2005/readings/pdp11-40.pdf" rel="nofollow noreferrer">PDP11 reference manual</a> has around 200 pages (with the PDP-11 being considered the smallest machine having been able to run Unix); the <a href="http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf" rel="nofollow noreferrer">8086/8088 manual</a> clocks in at 100 pages for the CPU itself but takes 800 in total to describe additional I/O processors and other relatively important parts of the architecture. The 1993 manuals for the <a href="https://ardent-tool.com/CPU/Docs_Intel.html#Pentium" rel="nofollow noreferrer">Pentium Family</a> already span around 1900 pages, and well past 2000 for the IA-64 docs.</p>
<p>This means all aspects - the hardware itself (from CPUs over the general architecture to ancillary modules like GPUs, or even math co-processors back in the foggy past), but also the software (i.e., features expected by programmers or users), the networking, and so on and forth, got ever more complex; and at the same time, users expected the OS to handle all of that in lieu of the applications ever more.</p>
<p>Many of these complexities scale up exponentially in that adding one feature in one of those areas influence many of the others, thus leading to additional lines of code in many places.</p>
<p>So even if a completely new OS today had zero baggage in the form of backward compatibility, or having to support large numbers of historic hardware devices, it would be much larger than in the distant past simply because the system architecture (CPU, GPU, I/O, RAM, and other low-level modules, together with busses and so on) is vastly more complex on even small machines today than it was in the past.</p>
<p>(As a little bonus: you can run a <a href="https://pdp11.aiju.de" rel="nofollow noreferrer">PDP-11 emulator with the Unix v6 kernel</a> in your browser of choice (including access to <code>cc</code> so you can compile programs). It doesn&#39;t do much for this answer, but I find it awesome enough to include it. Here is the deep link to the actual <a href="https://pdp11.aiju.de/pdp11.js" rel="nofollow noreferrer">JavaScript code of the emulation</a>. Imagine how long this code would be for a modern CPU...)</p>
    </div></div>
  </body>
</html>
