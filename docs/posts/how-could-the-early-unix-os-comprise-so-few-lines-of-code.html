<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrocomputing.stackexchange.com/questions/26083/how-could-early-unix-os-comprise-so-few-lines-of-code">Original</a>
    <h1>How could the early Unix OS comprise so few lines of code?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<p>If you look at the code in the modern Linux kernel, you will find that most of the code is in the device drivers.  There are tens of millions of lines of code to support everything imaginable -- the networking cards in 1990s DEC Alpha workstations, the soundcards in late 1980s ISA IBM PC-compatibles, modern 64-bit ARM tablets, all the USB devices, and so on.</p>
<p>On top of that, we have dozens of file systems, support for many different kinds of networking protocols.  There are multiple different schedulers -- not just for processes, but block IO and network transfers.  And so on.  In fact, the feature variety and hardware drivers make up the great majority of Linux code.  Linux, before all these features and bloat were added, as originally released as a crude kernel for 386 machines, was also measured in tens of thousands of lines of code.</p>
<p>I&#39;ve written a small multitasking kernel, for an embedded application, so I feel qualified to say: it really isn&#39;t that big of a job.  The basic UNIX design of processes and file system is a structure that has several interworking parts, so it&#39;s delicate and finnicky.  But it&#39;s not ultimately that complex.</p>
<p>Basic memory management takes a few hundred lines.  Implementing basic processes takes a few hundred lines.  A basic file system takes a few thousand lines of C code.  Device drivers depend on the complexity of the device, but can be quite small.  You just need drivers for a terminal of some kind, and a disk of some kind.</p>
<p>That will give you the core to load binaries, execute them, and give them some system calls for reading/writing files.  That&#39;s about all the original UNIX provided.  But then you will want networking and fast algorithms for disk caching.  It rapidly starts adding up.</p>
    </div></div>
  </body>
</html>
