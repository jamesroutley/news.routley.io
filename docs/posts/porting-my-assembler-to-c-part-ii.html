<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/Assembler-Part-2/">Original</a>
    <h1>Porting my assembler to C, Part II</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-07-14T00:00:00-07:00">July 14, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        

<p>I’ve been keeping that good Impossible Stuff Day energy going today and made excellent progress on my assembler project. It can’t handle labels or symbols yet, however it is happily parsing A instructions with number literals as well as the whole gamut of C instructions. It reads from a file, but for the sake of convenience it currently just emits machine code translations to <code>stdout</code> like so:</p>

<div><div><pre><code> 1:    @2 --&gt; 0000000000000010
 2:   D=A --&gt; 1110110000010000
 3:    @3 --&gt; 0000000000000011
 4: D=D+A --&gt; 1110000010010000
 5:    @0 --&gt; 0000000000000000
 6:   M=D --&gt; 1110001100001000
</code></pre></div></div>

<p>Hey, cool!</p>

<p>Here are some of my solutions to the many little challenges along the way.</p>



<p>This is a feature my previous iteration did not have, which meant that the assembler assembled very little of sample .asm files that indented with reckless abandon.</p>

<p>Here’s what I did:</p>

<div><div><pre><code> <span>// trim leading spaces from `line_in[]`</span>
 <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>=</span> <span>0</span><span>;</span>
 <span>while</span> <span>(</span><span>line_in</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>&#39; &#39;</span> <span>||</span> <span>line_in</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>&#39;\t&#39;</span><span>)</span>
     <span>i</span><span>++</span><span>;</span>
 <span>if</span> <span>(</span><span>i</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
     <span>while</span> <span>(</span><span>line_in</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>&#39;\0&#39;</span><span>)</span>
         <span>line_in</span><span>[</span><span>j</span><span>++</span><span>]</span> <span>=</span> <span>line_in</span><span>[</span><span>i</span><span>++</span><span>];</span>
     <span>line_in</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
 <span>}</span>
</code></pre></div></div>

<p>I am using two pointers, <code>i</code> and <code>j</code>, which both start at zero. I march <code>i</code> along past every damn space and tab it sees and then stop. Presuming <code>i</code> has indeed done some marching, which is to say that it is no longer <code>0</code>, I then march <code>i</code> (from wherever it is) and <code>j</code> (which is at zero) along until <code>line[i] == &#39;\0&#39;</code>, and as I go I reassign whatever non-space character is at <code>line_in[i]</code> to <code>line_in[j]</code>, in effect shifting the non-space portion of the string left.</p>



<p>Identifying A instructions is easy enough – they start with <code>@</code>. And identifying L instructions (i.e., labels) is also easy enough – they start with <code>(</code>. Everything else is a C instruction. Tokenizing a C instruction turned out to be a bit tricky, though, since they can consist of two or three parts.</p>

<p>The general format is <code>&lt;destination&gt;=&lt;computation&gt;;&lt;jump&gt;</code>, however a valid command need only have <code>&lt;destination&gt;</code> or <code>&lt;jump&gt;</code> (or both, although this is rare in practice). That means I’m often faced with a command that looks like <code>M=M-1</code> (just the destination and computation commands) or that look like <code>D;JNE</code> (just the computation and jump commands).</p>

<p>At first I played around with <code>strtok()</code> and <code>strsep()</code>. <code>strtok()</code> in particular seemed promising, since you can pass it multiple characters to split on (in this case <code>=;</code>), and on successive iterations it returns the next chunk of the input string. The problem I encountered, though, was how to efficiently deal with the results. If all C Instructions had three tokens, that would have been one thing, but most of the time they end up consisting of just two tokens. How, then, to know if you’re getting a destination/computation pair or a computation/jump pair?</p>

<p>Eventually I abandoned this (although I’m sure there’s a good way of doing what I wanted to do) in favor of <code>strchr()</code>, which takes in a string and a search character and returns the index of the first occurrence of that character if it’s there or <code>NULL</code> if not. Here’s what the code looked like:</p>

<div><div><pre><code><span>void</span> <span>tokenize</span><span>(</span><span>char</span> <span>*</span><span>line</span><span>,</span> <span>char</span> <span>*</span><span>comp</span><span>,</span> <span>char</span> <span>*</span><span>dest</span><span>,</span> <span>char</span> <span>*</span><span>jump</span><span>)</span>
<span>{</span>
    <span>char</span> <span>*</span><span>equal_sign</span><span>,</span> <span>*</span><span>semicolon</span><span>;</span>

    <span>// if there&#39;s an equal sign, we must have dest. and comp. tokens at least</span>
    <span>if</span> <span>((</span><span>equal_sign</span> <span>=</span> <span>strchr</span><span>(</span><span>line</span><span>,</span> <span>&#39;=&#39;</span><span>)))</span> <span>{</span>
        <span>*</span><span>equal_sign</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
        <span>strcpy</span><span>(</span><span>dest</span><span>,</span> <span>line</span><span>);</span>             <span>// copy everything up to the equal sign to dest</span>
        <span>strcpy</span><span>(</span><span>comp</span><span>,</span> <span>equal_sign</span> <span>+</span> <span>1</span><span>);</span>   <span>// copy everything else to comp</span>
        <span>// if comp contains a semi-colon, we have to extract the jump command</span>
        <span>if</span> <span>((</span><span>semicolon</span> <span>=</span> <span>strchr</span><span>(</span><span>comp</span><span>,</span> <span>&#39;;&#39;</span><span>)))</span> <span>{</span>
            <span>*</span><span>semicolon</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>          <span>// terminate comp where the semicolon was</span>
            <span>strcpy</span><span>(</span><span>jump</span><span>,</span> <span>semicolon</span> <span>+</span> <span>1</span><span>);</span><span>// copy everything else to jump</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>strcpy</span><span>(</span><span>jump</span><span>,</span> <span>&#34;&#34;</span><span>);</span>           <span>// else jump is NULL</span>
        <span>}</span>
    <span>// if there&#39;s no equal sign, we just have comp. and jump tokens</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>semicolon</span> <span>=</span> <span>strchr</span><span>(</span><span>line</span><span>,</span> <span>&#39;;&#39;</span><span>);</span>
        <span>*</span><span>semicolon</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
        <span>strcpy</span><span>(</span><span>dest</span><span>,</span> <span>&#34;&#34;</span><span>);</span>               <span>// dest. is NULL</span>
        <span>strcpy</span><span>(</span><span>comp</span><span>,</span> <span>line</span><span>);</span>             <span>// copy everything up to semi-colon to comp</span>
        <span>strcpy</span><span>(</span><span>jump</span><span>,</span> <span>semicolon</span> <span>+</span> <span>1</span><span>);</span>    <span>// copy everything else to jump</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>I pass this function my <code>line_in</code> string, as well as empty strings to hold each of the three tokens. It is this function’s job to put stuff in those.</p>

<p>First, I check to see if the line has an equal sign. If so, then we assume it has destination and computation tokens at the very least, so we copy everything up to the <code>=</code> to <code>dest</code> and everything after it to <code>comp</code>. Then, we check <code>comp</code> for the presence of a semicolon. If there is one, we terminate <code>comp</code> where the semicolon was and copy everything after to <code>jump</code>. If not, then <code>comp</code> is complete and <code>jump</code> just needs to be set to NULL.</p>

<p>If, on the other hand, the input line does not have an equal sign, then we just go ahead and assume it only consists of computation and jump instructions. Same process here, except we set <code>dest</code> to NULL, <code>comp</code> to everything up to where the semicolon was, and <code>jump</code> to everything after.</p>

<p>When I was trying to figure this out, I made this little REPL version of the tokenizer, which looks like this:</p>

<p><img src="https://www.youtube.com/assets/images/2023-07-14/tokenizer_demo.gif" alt="Tokenizer Demo"/></p>



<p>Once we have our tokens, we need some way of tranlsating them to their binary equivalents. For example, a 3-bit jump command like <code>JLT</code> is encoded as <code>100</code>, and a 3-bit destination command like <code>MD</code> is encoded as <code>011</code>. There are 8 permutations of both jump and destination commands, which is fitting for 3-bit numbers (\(2^3=8\)).</p>

<p>The computation commands consist of 7 bits, but mercifully there are not \(2^7\) permutations to deal with! Just 28 permutations in this version of assembly.</p>

<p>As another reminder, here’s what the C instruction encoding looks like:</p>

<table>
  <tbody><tr>
    <td>1</td>
    <td>x</td>
    <td>x</td>
    <td>a</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>d</td>
    <td>d</td>
    <td>d</td>
    <td>j</td>
    <td>j</td>
    <td>j</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<ul>
  <li><span>C instruction bit</span>: identifies the computation instruction as such</li>
  <li>bits 13 and 14 aren’t used</li>
  <li><span><b>a</b> bit</span>: dictates whether the ALU should accept its <code>y</code> input from the A Register or from somewhere in Memory. Effectively part of the computation instruction.</li>
  <li><span><b>c</b> bits</span>: comutation instruction</li>
  <li><span><b>d</b> bits</span>: destination instruction</li>
  <li><span><b>j</b> bits</span>: jump instruction</li>
</ul>

<p>When I initially wrote my assembler in Python, my approach was to use dictionaries as lookup tables to match each of the 8 destination instructions with their 3-bit binary counterparts, each of the 8 jump instructions with their 3-bit binary counterparts, and each of the 28 computation instructions with their 7-bit counterparts, sort of like this:</p>

<div><div><pre><code><span>dest_table</span> <span>=</span> <span>{</span>
   <span>&#39;M&#39;</span>  <span>:</span><span>&#39;001&#39;</span><span>,</span>
   <span>&#39;D&#39;</span>  <span>:</span><span>&#39;010&#39;</span><span>,</span>
   <span>&#39;MD&#39;</span> <span>:</span><span>&#39;011&#39;</span><span>,</span>
   <span>&#39;A&#39;</span>  <span>:</span><span>&#39;100&#39;</span><span>,</span>
   <span>&#39;AM&#39;</span> <span>:</span><span>&#39;101&#39;</span><span>,</span>
   <span>&#39;AD&#39;</span> <span>:</span><span>&#39;110&#39;</span><span>,</span>
   <span>&#39;AMD&#39;</span><span>:</span><span>&#39;111&#39;</span>
   <span>}</span>
<span>jump_table</span> <span>=</span> <span>{</span>
   <span>&#39;JGT&#39;</span><span>:</span><span>&#39;001&#39;</span><span>,</span>
   <span>&#39;JEQ&#39;</span><span>:</span><span>&#39;010&#39;</span><span>,</span>
   <span>&#39;JGE&#39;</span><span>:</span><span>&#39;011&#39;</span><span>,</span>
   <span>&#39;JLT&#39;</span><span>:</span><span>&#39;100&#39;</span><span>,</span>
   <span>&#39;JNE&#39;</span><span>:</span><span>&#39;101&#39;</span><span>,</span>
   <span>&#39;JLE&#39;</span><span>:</span><span>&#39;110&#39;</span><span>,</span>
   <span>&#39;JMP&#39;</span><span>:</span><span>&#39;111&#39;</span>
   <span>}</span>
<span>comp_table</span> <span>=</span> <span>{</span>
   <span>&#39;0&#39;</span>  <span>:</span><span>&#39;0101010&#39;</span><span>,</span>
   <span>&#39;1&#39;</span>  <span>:</span><span>&#39;0111111&#39;</span><span>,</span>
   <span>&#39;-1&#39;</span> <span>:</span><span>&#39;0111010&#39;</span><span>,</span>
   <span>&#39;D&#39;</span>  <span>:</span><span>&#39;0001100&#39;</span><span>,</span>
   <span>&#39;A&#39;</span>  <span>:</span><span>&#39;0110000&#39;</span><span>,</span>
   <span>&#39;M&#39;</span>  <span>:</span><span>&#39;1110000&#39;</span><span>,</span>
   <span>&#39;!D&#39;</span> <span>:</span><span>&#39;0001101&#39;</span><span>,</span>
   <span>&#39;!A&#39;</span> <span>:</span><span>&#39;0110001&#39;</span><span>,</span>
   <span>&#39;!M&#39;</span> <span>:</span><span>&#39;1110001&#39;</span><span>,</span>
   <span>&#39;-D&#39;</span> <span>:</span><span>&#39;0001111&#39;</span><span>,</span>
   <span>&#39;-A&#39;</span> <span>:</span><span>&#39;0110011&#39;</span><span>,</span>
   <span>&#39;-M&#39;</span> <span>:</span><span>&#39;1110011&#39;</span><span>,</span>
   <span>&#39;D+1&#39;</span><span>:</span><span>&#39;0011111&#39;</span><span>,</span>
   <span>&#39;A+1&#39;</span><span>:</span><span>&#39;0110111&#39;</span><span>,</span>
   <span>&#39;M+1&#39;</span><span>:</span><span>&#39;1110111&#39;</span><span>,</span>
   <span>&#39;D-1&#39;</span><span>:</span><span>&#39;0001110&#39;</span><span>,</span>
   <span>&#39;A-1&#39;</span><span>:</span><span>&#39;0110010&#39;</span><span>,</span>
   <span>&#39;M-1&#39;</span><span>:</span><span>&#39;1110010&#39;</span><span>,</span>
   <span>&#39;D+A&#39;</span><span>:</span><span>&#39;0000010&#39;</span><span>,</span>
   <span>&#39;D+M&#39;</span><span>:</span><span>&#39;1000010&#39;</span><span>,</span>
   <span>&#39;D-A&#39;</span><span>:</span><span>&#39;0010011&#39;</span><span>,</span>
   <span>&#39;D-M&#39;</span><span>:</span><span>&#39;1010011&#39;</span><span>,</span>
   <span>&#39;A-D&#39;</span><span>:</span><span>&#39;0000111&#39;</span><span>,</span>
   <span>&#39;M-D&#39;</span><span>:</span><span>&#39;1000111&#39;</span><span>,</span>
   <span>&#39;D&amp;A&#39;</span><span>:</span><span>&#39;0000000&#39;</span><span>,</span>
   <span>&#39;D&amp;M&#39;</span><span>:</span><span>&#39;1000000&#39;</span><span>,</span>
   <span>&#39;D|A&#39;</span><span>:</span><span>&#39;0010101&#39;</span><span>,</span>
   <span>&#39;D|M&#39;</span><span>:</span><span>&#39;1010101&#39;</span><span>,</span>
   <span>}</span>
</code></pre></div></div>

<p>Then it was just a matter of concatenating the strings that resulted.</p>

<div><div><pre><code><span>dest</span> <span>=</span> <span>dest_table</span><span>.</span><span>get</span><span>(</span><span>d_token</span><span>,</span> <span>&#39;000&#39;</span><span>)</span>
<span>jump</span> <span>=</span> <span>jump_table</span><span>.</span><span>get</span><span>(</span><span>j_token</span><span>,</span> <span>&#39;000&#39;</span><span>)</span>
<span>comp</span> <span>=</span> <span>comp_table</span><span>.</span><span>get</span><span>(</span><span>c_token</span><span>,</span> <span>&#39;0000000&#39;</span><span>)</span>

<span>c_instruction</span> <span>=</span> <span>&#39;&#39;</span><span>.</span><span>join</span><span>([</span><span>&#39;111&#39;</span><span>,</span> <span>comp</span><span>,</span> <span>dest</span><span>,</span> <span>jump</span><span>])</span>
</code></pre></div></div>

<p>C doesn’t have hashmaps built in, of course. I considered building the data structure, but then thought it was overkill for lookups from lists of just a handful of items. Instead, I decided to use the ol’ parallel arrays method (although truth be told this concept was brand new to me!). If dictionaries/hashmaps have key/value pairs, this other method uses one array to hold the keys and the other to hold the values. To find what you need, you do a linear-time search on the keys array, hold on to the index once you find it, and then index in to the values array in constant time to get your match. It’s a far cry from the awesome O(1) time-complexity that a hashmap boasts, but, you know what? It’s fine.</p>

<p>Here, then, is an example of one of my parallel arrays:</p>

<div><div><pre><code> <span>char</span> <span>*</span><span>dest_keys</span><span>[]</span> <span>=</span> <span>{</span> <span>&#34;M&#34;</span><span>,</span> <span>&#34;D&#34;</span><span>,</span> <span>&#34;MD&#34;</span><span>,</span> <span>&#34;A&#34;</span><span>,</span> <span>&#34;AM&#34;</span><span>,</span> <span>&#34;AD&#34;</span><span>,</span> <span>&#34;AMD&#34;</span> <span>};</span>
 <span>int</span>   <span>dest_vals</span><span>[]</span> <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span> <span>};</span>
</code></pre></div></div>

<p>And here is the matching lookup function:</p>

<div><div><pre><code><span>int</span> <span>parse_dest</span><span>(</span><span>char</span> <span>*</span><span>dest_command</span><span>)</span>
<span>{</span>
    <span>int</span> <span>len</span> <span>=</span> <span>sizeof</span><span>(</span><span>dest_vals</span><span>)</span><span>/</span><span>sizeof</span><span>(</span><span>dest_vals</span><span>[</span><span>0</span><span>]);</span>

    <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span><span>len</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(</span><span>dest_command</span><span>,</span> <span>dest_keys</span><span>[</span><span>i</span><span>]))</span> <span>{</span>
            <span>return</span> <span>dest_vals</span><span>[</span><span>i</span><span>];</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>(I’m realizing all of a sudden that, while I can’t consolidate the three pairs of parallel arrays into a single parralel array – since, for instance, some destination instructions and computation instructions are identical – I <em>can</em> get away with a single parsing function, since each one does the same thing! Duh.)</p>

<p>Anyway, the parsing function does the thing I described: it searches through the keys array for the destination token, and if it finds a match it returns the value at that same index of the values array. Else it returns 0.</p>



<p>You may have noticed that the values array above did not consist of 3-bit strings but of integers. Aha! This is my final breakthrough of the day (which, incidentally, was a direct beneficiary of my <a href="https://www.datadoodad.com/recurse%20center/RC41/">excursions into network programming</a>). In Python, as I mentioned, I just concatenated each of my little bitstrings together to form my C-instruction. Sounds tedious in C, though. Fortunately I realized I can build up the 16-bit integer I need using bitwise operations.</p>

<p>Here’s how I’d do it in Python:</p>

<div><div><pre><code><span># tokens
</span><span>d_token</span> <span>=</span> <span>5</span>   <span># --&gt; 101 for dest. token AM
</span><span>c_token</span> <span>=</span> <span>114</span> <span># --&gt; 1110010 for comp. token M-1
</span><span>j_token</span> <span>=</span> <span>0</span>   <span># --&gt; 000 when jump is NULL
</span>
<span># c-instruction under construction
</span><span>c_inst</span> <span>=</span> <span>7</span>   <span># --&gt; 111, which is what our three most signficant bits will need to be
</span>
<span>c_inst</span> <span>&lt;&lt;=</span> <span>7</span>      <span># make room for the 7-bit computation token
</span><span>c_inst</span> <span>|=</span> <span>c_token</span> <span># add in computation token
</span><span>c_inst</span> <span>&lt;&lt;=</span> <span>3</span>      <span># make room for the 3-bit dest token
</span><span>c_inst</span> <span>|=</span> <span>d_token</span> <span># add in the destination token
</span><span>c_inst</span> <span>&lt;&lt;=</span> <span>3</span>      <span># make room for the 3-bit jump token
</span><span>c_inst</span> <span>|=</span> <span>j_token</span> <span># add in the jump token
</span>
<span>print</span><span>(</span><span>c_inst</span><span>)</span>                   <span># =&gt; 64680
</span><span>print</span><span>(</span><span>&#34;{:016b}&#34;</span><span>.</span><span>format</span><span>(</span><span>c_inst</span><span>))</span> <span># =&gt; 1111110010101000
</span></code></pre></div></div>

<p>Voila! Now our 16-bit C instruction is represented by a single 16-bit unsigned integer. Yes, I’ll eventually need to convert this to a 16-bit bitstring, <a href="https://www.datadoodad.com/recurse%20center/RC43/">but I already built that conversion function</a>.</p>

<p>Here’s my C version:</p>

<div><div><pre><code><span>void</span> <span>build_C_COMMAND</span><span>(</span><span>char</span> <span>*</span><span>line_in</span><span>,</span> <span>char</span> <span>*</span><span>line_out</span><span>)</span>
<span>{</span>
    <span>uint16_t</span> <span>out</span> <span>=</span> <span>7</span><span>;</span>
    <span>int</span> <span>dest</span><span>,</span> <span>comp</span><span>,</span> <span>jump</span><span>;</span>
    <span>char</span> <span>dest_command</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>char</span> <span>comp_command</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>char</span> <span>jump_command</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>

    <span>tokenize</span><span>(</span><span>line_in</span><span>,</span> <span>comp_command</span><span>,</span> <span>dest_command</span><span>,</span> <span>jump_command</span><span>);</span>

    <span>dest</span> <span>=</span> <span>parse_dest</span><span>(</span><span>dest_command</span><span>);</span>
    <span>comp</span> <span>=</span> <span>parse_comp</span><span>(</span><span>comp_command</span><span>);</span>
    <span>jump</span> <span>=</span> <span>parse_jump</span><span>(</span><span>jump_command</span><span>);</span>

    <span>// set output bits</span>
    <span>out</span> <span>=</span> <span>7</span><span>;</span> <span>out</span> <span>&lt;&lt;=</span> <span>7</span><span>;</span>         <span>// set most signifiant 3 bits to 111</span>
    <span>out</span> <span>|=</span> <span>comp</span><span>;</span> <span>out</span> <span>&lt;&lt;=</span> <span>3</span><span>;</span>     <span>// set 7 comp bits</span>
    <span>out</span> <span>|=</span> <span>dest</span><span>;</span> <span>out</span> <span>&lt;&lt;=</span> <span>3</span><span>;</span>     <span>// set 3 dest bits</span>
    <span>out</span> <span>|=</span> <span>jump</span><span>;</span>                <span>// set 3 jump bits</span>
    <span>itob</span><span>(</span><span>out</span><span>,</span> <span>line_out</span><span>,</span> <span>16</span><span>);</span>    <span>// convert to binstring</span>
<span>}</span>
</code></pre></div></div>

<p>Next on the list is handling symbols and labels.</p>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
