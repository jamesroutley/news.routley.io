<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ezzeriesa.notion.site/Rewriting-my-toy-blockchain-in-Rust-9a130f225666488491ba497004821fbb">Original</a>
    <h1>Rewriting my toy blockchain in Rust</h1>
    
    <div id="readability-page-1" class="page">
		<p>I started 2022 with a <a href="https://www.recurse.com/mini-retreats">mini batch</a> at the <a href="https://www.recurse.com">Recurse Center</a>. I did a <a href="https://payments.posthaven.com">full batch</a> in Fall 2020, and hanging out with people working on their side projects full time seems like a fun way to kick off the year.</p>
<p>My plan was to port my toy blockchain from Python to Rust (repo <a href="https://github.com/savarin/readcoin">here</a>, write-up <a href="https://ezzeriesa.notion.site/A-minimal-Bitcoin-inspired-implementation-9559908f03ad4cb7a09ee60a457198e2">here</a>). The initial project had multiple iterations, starting with proof-of-work and later Merkle trees and elliptic curve cryptography - a suitable candidate for a 1-week rewrite.</p>
<p>As with a lot of RC projects (for me anyway), things rarely play out as planned. I had moments of confusion with the Rust compiler, moved past that to contemplate working on speedups, but ended up compiling to WebAssembly to enable mining in the browser.</p>
<p>What I thought made for a nice ending was being able to connect the mini batch project with what I had previously worked on at RC.</p>

<p>For our purposes, a blockchain is a distributed database where records are divided into &#39;blocks&#39; and the blocks form a &#39;chain&#39;.</p>
<p>Each block is made up of a header (where block attributes live) and a body (where records live).</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef8db0bc-d2e7-4f7e-a2e2-5a65eb03c634/block.jpg" alt="block.jpg"/></p>
<p>The hash of the header is used to identify each block (commonly referred to as the <strong>block hash</strong>) and is included in the header of the next block (hence the chain).</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dc9ffec-ad49-40b1-98bf-0cabcaf5a334/chain.jpg" alt="chain.jpg"/></p>
<p>The Python function to initialize the header is relatively straightforward - a simple conversion from ints to bytes followed by a concatenation. Note that all the attributes are pre-determined except for the nonce.</p>
<pre><code>VERSION: int = 0

def init_header(previous_hash: bytes, timestamp: int, nonce: int) -&gt; bytes:
    &#34;&#34;&#34;Initialize header.&#34;&#34;&#34;
    return (
        VERSION.to_bytes(1, byteorder=&#34;big&#34;)
        + previous_hash
        + timestamp.to_bytes(4, byteorder=&#34;big&#34;)
        + nonce.to_bytes(32, byteorder=&#34;big&#34;)
    )
</code></pre>
<p>The nonce is chosen such that the leading bytes of the block hash are zero. The more zeroes we want, the more difficult it is to find the nonce. In the example below we require the two leading bytes be zero, or four leading zeroes in hex. The first ten integers doesnâ€™t get us there.</p>
<pre><code>previous_hash = (0).to_bytes(32, byteorder=&#34;big&#34;)
timestamp = 1634700000

def sha256_2x(header: bytes) -&gt; bytes:
    &#34;&#34;&#34;Apply SHA-256 twice.&#34;&#34;&#34;
    return hashlib.sha256(hashlib.sha256(header).digest()).hexdigest()

for nonce in range(10):
    header = init_header(previous_hash, timestamp, nonce)
    print(f&#34;nonce: {nonce}, hash: {sha256_2x(header)}&#34;)
</code></pre>

	

</div>
  </body>
</html>
