<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mclare.blog/posts/adapting-a-bloom-filter-to-rust">Original</a>
    <h1>Adapting a Bloom Filter to Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><figure>
    <span>
      <a href="https://mclare.blog/static/cbf5e275937cc3c1067bc53538fb9390/493ac/three_status.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/cbf5e275937cc3c1067bc53538fb9390/8ac56/three_status.webp 240w,
/static/cbf5e275937cc3c1067bc53538fb9390/d3be9/three_status.webp 480w,
/static/cbf5e275937cc3c1067bc53538fb9390/e46b2/three_status.webp 960w,
/static/cbf5e275937cc3c1067bc53538fb9390/f992d/three_status.webp 1440w,
/static/cbf5e275937cc3c1067bc53538fb9390/882b9/three_status.webp 1920w,
/static/cbf5e275937cc3c1067bc53538fb9390/b33a3/three_status.webp 4032w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/cbf5e275937cc3c1067bc53538fb9390/8ff5a/three_status.png 240w,
/static/cbf5e275937cc3c1067bc53538fb9390/e85cb/three_status.png 480w,
/static/cbf5e275937cc3c1067bc53538fb9390/d9199/three_status.png 960w,
/static/cbf5e275937cc3c1067bc53538fb9390/07a9c/three_status.png 1440w,
/static/cbf5e275937cc3c1067bc53538fb9390/29114/three_status.png 1920w,
/static/cbf5e275937cc3c1067bc53538fb9390/493ac/three_status.png 4032w" sizes="(max-width: 960px) 100vw, 960px" type="image/png"/>
          <img src="https://mclare.blog/static/cbf5e275937cc3c1067bc53538fb9390/d9199/three_status.png" alt="Neotrellis Bloom Filter Test Indicator" title="Neotrellis Bloom Filter Test Indicator" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span>
    <figcaption>Neotrellis Bloom Filter Test Indicator</figcaption>
  </figure></div>
<p>I like little <a href="https://mclare.blog/posts/building-a-tiny-pomodoro-timer" target="_blank" rel="nofollow noopener noreferrer">productivity</a> <a href="https://mclare.blog/posts/tinky-care" target="_blank" rel="nofollow noopener noreferrer">minders</a>, particularly when they’re a separate “thing” from one of my screens (and less likely to get buried in window management). When one of my batchmates from Recurse Center made use of an <a href="https://www.adafruit.com/product/4020" target="_blank" rel="nofollow noopener noreferrer">Adafruit Neotrellis</a> for running his test suites, I knew I wanted to eventually use his <a href="http://github.com/shapr/bloohm" target="_blank" rel="nofollow noopener noreferrer">hack</a> for my own <a href="https://github.com/m-clare/bloomrs" target="_blank" rel="nofollow noopener noreferrer">purposes</a> (plus the idea of using a <a href="https://www.jasondavies.com/bloomfilter/" target="_blank" rel="nofollow noopener noreferrer">Bloom</a> <a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="nofollow noopener noreferrer">filter</a> to display unique tests sounded really cool!)</p>
<p>I bought the neotrellis board probably a year ago, but never had time to test out the original code. Once I did, and understood how it works (it’s written in <a href="https://www.haskell.org/" target="_blank" rel="nofollow noopener noreferrer">Haskell</a>), I wanted to challenge myself to rewrite it in <a href="https://www.rust-lang.org/" target="_blank" rel="nofollow noopener noreferrer">Rust</a>. I’ve made it about halfway through <a href="https://doc.rust-lang.org/stable/book/" target="_blank" rel="nofollow noopener noreferrer">The Rust Book</a> in my spare time, but I learn a lot faster when I have a project or end goal in mind (particularly one less vague than “get a software job that uses Rust”).</p>
<p>First I needed to prep my Neotrellis to get the proper libraries for running Bloohm. Adafruit recommends updating the Neotrellis <a href="https://learn.adafruit.com/adafruit-neotrellis-m4/update-the-uf2-bootloader" target="_blank" rel="nofollow noopener noreferrer">bootloader</a> and then installing these <a href="https://learn.adafruit.com/adafruit-neotrellis-m4/adafruit-circuitpython-trellism4-library" target="_blank" rel="nofollow noopener noreferrer">libraries</a>. To use the same python file from Bloohm, you’ll need to additionally install </p><p><code>adafruit_adxl34x.mpy</code></p><p> from the v7.x <a href="https://circuitpython.org/libraries" target="_blank" rel="nofollow noopener noreferrer">CircuitPython</a> library (we haven’t updated to CircuitPython 8).</p>
<p>I also needed to adapt the shell scripts written for capturing the test commands, as it seems that every single time I plug in the neotrellis, I get a different address for the serial device. It ended up that my device usually had the pattern ending in 4 digits, but zsh doesn’t recognize standard regex, so I had to investigate using a glob pattern to get the same effect. I ended up with my shell commands differing a bit from the source code like so:</p>
<div><div data-language="shell"><pre><code><span>function</span> <span>test</span> <span>(</span><span>)</span> <span>{</span>
        <span>export</span> <span>thecmd</span><span>=</span><span>&#34;<span>$*</span>&#34;</span>
        <span>export</span> <span>port</span><span>=</span><span><span>$(</span><span>ls</span> <span>-t</span> /dev/tty.usbmodem<span>[</span><span>0</span>-9<span>]</span><span>[</span><span>0</span>-9<span>]</span><span>[</span><span>0</span>-9<span>]</span><span>[</span><span>0</span>-9<span>]</span> <span>|</span> <span>head</span> <span>-n</span> <span>1</span><span>)</span></span>
        bloomrs <span>-s</span> <span>$port</span> <span>-t</span> y <span>-d</span> <span>$PWD</span>:A <span>-c</span> <span>$thecmd</span>
        <span>time</span> <span>$*</span> <span>&amp;&amp;</span> fin <span>||</span> die<span>;</span>

<span>function</span> <span>fin</span> <span>(</span><span>)</span> <span>{</span>
        bloomrs <span>-s</span> <span>$port</span> <span>-t</span> g <span>-d</span> <span>$PWD</span>:A <span>-c</span> <span>$thecmd</span>
<span>}</span>

<span>function</span> <span>die</span><span>(</span><span>)</span> <span>{</span>
        bloomrs <span>-s</span> <span>$port</span> <span>-t</span> r <span>-d</span> <span>$PWD</span>:A <span>-c</span> <span>$thecmd</span>
<span>}</span></code></pre></div></div>
<p>I’ve never worked with serial ports or command line tools in Rust. I used <a href="https://rust-cli.github.io/book/tutorial/index.html" target="_blank" rel="nofollow noopener noreferrer">this tutorial</a> to learn about writing CLI applications in Rust, and then used the clap crate to be a bit more explicit about the commands needed to run the bloom filter. I particularly like that you get documentation built in via your commented code.</p>
<p>The idea of the bloom filter is pretty simple. Run the unique string from the command and its current directory through a hash function, and then take the result and mod 32 to map the hash to a specific LED on the neotrellis. I struggled with this because the Haskell implementation was able to actually read in and reduce the giant hash number, and I couldn’t figure out how to consume the generic array with 32 bytes returned from the hash function (Sha256 in my case) to be able to take the modulo. I initially got by just taking the modulo of the last byte, since 32 is a factor of 256.</p>
<p>My first implementation in Rust was pretty inefficient and used a lot of different crates to get different <a href="https://github.com/RustCrypto/hashes" target="_blank" rel="nofollow noopener noreferrer">hash functions</a>. I paired with another <a href="https://socialnotwork.net/@nebkor" target="_blank" rel="nofollow noopener noreferrer">Recurser</a> to improve the code and ultimately cut down the program to only use Rust’s hash function from its <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html" target="_blank" rel="nofollow noopener noreferrer">standard library</a>. We also managed to squash a bug with the serial port where running multiple commands in the same line would sometimes trigger a panic that the serial port was busy (which meant the yellow “in progress” LEDs were never fired). I’ve got an idea for using this on an external indicator that doesn’t require a specialized piece of hardware, but that’ll be a project for another week!</p>
<p>Github repo: <a href="https://github.com/m-clare/bloomrs" target="_blank" rel="nofollow noopener noreferrer">https://github.com/m-clare/bloomrs</a></p>
<p><img src="https://mclare.blog/00fd3eedde7c0ce8673a276fe0480644/run_command.gif" alt="Working Bloom Filter Test Indicator"/></p></div></div>
  </body>
</html>
