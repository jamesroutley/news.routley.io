<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lilymara.xyz/posts/2024/01/transit-kindle/">Original</a>
    <h1>Never Missing the Train Again</h1>
    
    <div id="readability-page-1" class="page"><div><article><details><summary>Contents</summary><nav id="TableOfContents"><ol><li><a href="#jailbreaking-your-kindle">Jailbreaking your Kindle</a></li><li><a href="#get-an-image-on-the-kindle">Get an Image on the Kindle</a></li><li><a href="#serve-_useful_-images">Serve <em>useful</em> images</a></li><li><a href="#muni">MUNI</a></li><li><a href="#starting-over-from-scratch---architecture">Starting Over From Scratch - Architecture</a></li><li><a href="#getting-the-data">Getting the Data</a></li><li><a href="#building-a-png-with-skia">Building a PNG with Skia</a></li><li><a href="#building-a-png-backed-by-data">Building a PNG backed by data</a></li><li><a href="#serving-the-png-with-axum">Serving the PNG with Axum</a></li><li><a href="#refining-the-ui">Refining the UI</a></li><li><a href="#fin">Fin.</a></li></ol></nav></details><section><p>I live in San Francisco, and I don’t own a car. This means that I walk or take
public transit nearly everywhere that I go. There’s a lot of ways to find out
when the next bus/train/tram/trolleybus/cable car/ferry is stopping nearby so
that you don’t miss it. There are no shortage of apps that will guide you to
your destination using any and all means of public transit, and those are great!
I particularly like <a href="https://citymapper.com">CityMapper</a>. But apps aren’t always
the best for getting around a city, especially for leaving your own apartment.</p><p>The most frustrating thing about these transit apps is that they assume that
they’re going to guide you through the entire transit process. They often work
on the “where are you and where are you going” model of something like Google
Maps. This is great for people new to a city, or exploring a new area of the
city, they can get all the guidance they need. But when I’m leaving from my own
apartment, I know where the closest transit stops are and where they go. I don’t
need an app to tell me <em>which</em> line to take to go downtown, I really just need
to know <em>when</em> each transit line has an upcoming train/tram/bus. These goals are
at odds with the goals of a general-purpose navigation app that’s somewhat
useful to everyone in a broad range of circumstances, so like most truly useful
things we need to build it ourselves.</p><p>I was first inspired to build this project after reading <a href="https://matthealy.com/kindle">Matt Healy’s 2021 blog
post</a> on building a smart home display with a
Kindle. Matt used an old Kindle to display things like weather, calendar events,
meal plans, and house cleaning schedules. I figured I could probably adapt his
guide and make myself an always-available display of upcoming transit arrival
at the stops nearest to my apartment. I also saw <a href="https://ben.page/eink">Ben Borgers&#39;
post</a> about using an old Nook as an iCloud photo frame.
These devices are super cool, and can be had for quite cheap. I had a few old
Kindles lying around collecting dust, and I was excited at the prospect of using
them for something productive again.</p><div><div><p>This is a long blog post. It was a lot of work writing it, so I hope you read it all and enjoy (and email me to tell me you liked it pls), but yeah you&#39;re in for a long one here.</p></div></div><div><div><p>Display upcoming transit arrival times on a Kindle</p></div></div><p>The first step is to jailbreak your Kindle. I’m not going to detail the steps
required to accomplish this here, there are numerous guides out there. The
<a href="https://wiki.mobileread.com/wiki/Kindle_Hacks_Information#Jail_break_JB">mobileread
wiki</a>
and forums were an invaluable resource during this process. The main goal here
is to enable USBNet, this will give us the ability to SSH into the kindle, which
we will use to set up the cron job that updates the display.</p><ul><li><a href="https://www.mobileread.com/forums/showthread.php?t=346037&amp;highlight=wifi">Jailbreak</a></li><li><a href="https://www.mobileread.com/forums/showthread.php?t=225030">All hacks</a><ul><li><a href="https://www.mobileread.com/forums/showthread.php?t=203326">Launcher</a></li><li><a href="https://www.mobileread.com/forums/showthread.php?t=251143">Package installer</a></li><li>Usbnet - enabled via the package installer</li><li><a href="https://www.mobileread.com/forums/showpost.php?p=2895606&amp;postcount=13">Setting up usbnet in macOS</a></li></ul></li></ul><p>Now that the Kindle is jailbroken, I set out trying to get some image to display
on the Kindle. It was no use setting up a system to automatically build the
images for showing on the Kindle if I couldn’t first get <em>something</em> on there to
show up in a readable state. This was much more of an adventure than I was
expecting.</p><div><div><p>Display <em>some</em> image on the Kindle</p></div></div><p>First, I identified the image that I wanted to Display. Thankfully, BART (the
main transit agency that I used at the time I started the project) has a website
that provided basically exactly what I wanted. BART’s <a href="https://www.bart.gov/schedules/eta/CIVC">Real Time
Departure</a> page shows all of the
upcoming trains at whatever station you want, and it even refreshes itself in
the background.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-00.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-00.png" alt="Screenshot of the BART realtime departure page for the Civic Center/UN Plaza station"/></a></p><p>I grabbed a screenshot of the central area of the page, which seems almost
designed to be a standalone dashboard, transferred it to the Kindle, and
attempted to display it. The Kindle CLI has a tool that can be used to display
image files easily.</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span># On laptop</span>
</span></span><span><span>$ python3 -m http.server
</span></span><span><span>
</span></span><span><span><span># On Kindle</span>
</span></span><span><span>$ wget 192.168.50.28:8000/bart-screenshot.png
</span></span><span><span><span># Clear the e-ink display</span>
</span></span><span><span>$ eips -c
</span></span><span><span><span># Display the PNG file on the display</span>
</span></span><span><span>$ eips -g bart-screenshot.png
</span></span></code></pre></div><p>After attempting to display my screenshot, it was apparent that it wouldn’t be
quite so simple.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-01.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-01.jpeg" alt="Photo of a Kindle displaying screenshot of the BART realtime departure page. The image is stretched and warped and barely readable"/></a></p></div><p>The image was stretched to such an extreme extent that it was unusable. I went
back to the drawing board. I created a “calibration image” in
<a href="https://photopea.com">Photopea</a>, my image editor of choice, and set out trying
to figure out where I went wrong. The image was the exact size of my Kindle’s
display - 1024x758. After displaying the image on my Kindle, I started to piece
together what might be going on. Take a look at the expected PNG image, and what
actually showed up on the Kindle display:</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-02.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-02.png" alt="custom calibration image. it has large circles centered at each of the four corners, along with lines running from top left to bottom right, and top right to bottom left, and text labels “top,” “bottom,” “left,” and “right” in the four quadrants created by the lines"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-03.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-03.jpeg" alt="photo of kindle displaying the calibration image, messed up. the top and bottom left corner circles appear in the right location, but the entire image appears stretched, as if it were pinned to the left edge of the display and then stretched to two or three times its width. The point where the diagonal lines meet in the middle of the image is not visible, it appears as though that should be slightly off to the right of the screen based on the lines."/></a></p></div><p>Based on the stretch of the image, and the fact that the image seemed to cut off
around 33% of the way through the x-axis, I tried shrinking the image’s
horizontal dimension to 1/3, so it was now 1024x252. This provided <em>slightly</em>
better results, but something was still very clearly wrong.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-04.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-04.png" alt="same custom calibration image as above, but compressed to 1/3 of the original width."/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-05.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-05.jpeg" alt="photo of kindle displaying calibration image. the proportions of the image appear correct, but the image is cut off at 1/3 of the width of the screen"/></a></p></div><p>I noticed this time that the image appeared to be un-stretched, but it didn’t
fill the entire screen. I reasoned that the Kindle must be displaying only the
pixels that fell within the bounds reported in the PNG metadata. I created
another calibration image which had the full size of the Kindle display, but
only put data in the left 33% of it. This was the most promising result yet.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-06.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-06.png" alt="calibration image mashed up against the leftmost 1/3 of the image, with the remaining horizontal 2/3 of the image being white space"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-07.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-07.jpeg" alt="photo of kindle displaying calibration image correctly"/></a></p></div><p>I applied this “empty space &amp; stretching” technique to my BART screenshot, and
displayed it on the page. initially, this looked very promising. On closer
inspection however, I was disappointed.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-08.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-08.jpeg" alt="photo of kindle displaying a screenshot of the BART station status page. there is a zoomed-in inset showing heavy pixelation exists on the displayed image"/></a></p><p>The image appeared extremely pixelated on the Kindle display. Notice in the
image that the text “Kindle” on the frame is very clear, the pixelation on the
display is <em>not</em> because of the camera, it is an issue with the display.</p><p>Matt Healy had helpfully linked to the code he was using to drive his Kindle
display, and I figured he must have figured this issue out if his Kindle was
working correctly. I looked through his Node.js code and quickly found <a href="https://github.com/lankybutmacho/web-to-kindle-heroku/blob/2a9473f30c71a257931927aa0af73bd16bd800a3/index.js#L36C1-L48C2">this
critical
function</a>:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>convert</span>(<span>filename</span>) {
</span></span><span><span>  <span>return</span> <span>new</span> Promise((<span>resolve</span>, <span>reject</span>) =&gt; {
</span></span><span><span>    <span>const</span> <span>args</span> <span>=</span> [
</span></span><span><span>      <span>filename</span>,
</span></span><span><span>      <span>&#34;-gravity&#34;</span>,
</span></span><span><span>      <span>&#34;center&#34;</span>,
</span></span><span><span>      <span>&#34;-extent&#34;</span>,
</span></span><span><span>      <span>&#34;600x800&#34;</span>,
</span></span><span><span>      <span>&#34;-colorspace&#34;</span>,
</span></span><span><span>      <span>&#34;gray&#34;</span>,
</span></span><span><span>      <span>&#34;-depth&#34;</span>,
</span></span><span><span>      <span>&#34;8&#34;</span>,
</span></span><span><span>      <span>filename</span>,
</span></span><span><span>    ];
</span></span><span><span>    <span>execFile</span>(<span>&#34;convert&#34;</span>, <span>args</span>, (<span>error</span>, <span>stdout</span>, <span>stderr</span>) =&gt; {
</span></span><span><span>      <span>if</span> (<span>error</span>) {
</span></span><span><span>        <span>console</span>.<span>error</span>({ <span>error</span>, <span>stdout</span>, <span>stderr</span> });
</span></span><span><span>        <span>reject</span>();
</span></span><span><span>      } <span>else</span> {
</span></span><span><span>        <span>resolve</span>();
</span></span><span><span>      }
</span></span><span><span>    });
</span></span><span><span>  });
</span></span><span><span>}
</span></span></code></pre></div><p>He feeds his screenshots into <a href="https://imagemagick.org/index.php">ImageMagick</a>’s
<code>convert</code> utility and does a few things with them, but of particular note are
these arguments</p><div><pre tabindex="0"><code data-lang="sh"><span><span>-colorspace gray -depth <span>8</span>
</span></span></code></pre></div><p>Of course! I was feeding a 24-bit (3 channel RGB) PNG image into the Kindle’s
software, but the Kindle has only a greyscale screen, so they never bothered to
add support for 24-bit PNG files. The “normal” image appears stretched because
as far as the Kindle is concerned, all of the pixels are triplicated, it just
naively reads image data out of the PNG blob and assumes it’s an 8-bit image. It
cut off the 1/3 width image partway through the display because the width
metadata on the image made the Kindle think it should only render it over 1/3 of
the screen. The 1/3 width data, full-width metadata image works but looks poor
because 2/3 of the resolution is being sacrificed. After using <code>convert</code> to turn
my screenshot into an 8-bit PNG image, it displays correctly on the Kindle.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-09.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-09.jpeg" alt="photo of a kindle displaying the BART civic center status page, the image appears crisp and readable, but some of the text is cut off of the right edge of the display."/></a></p><p>Now that I can display an image that looks alright, I padded the image so that
it would fully fit within the viewport of the Kindle and re-displayed it.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-10.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-10.png" alt="screenshot of the BART civic center status page, reduced to the size of a kindle display. there are large white bars on the bottom and top of the image to compensate for the narrow aspect ratio of the screenshot"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-11.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/just-img-11.jpeg" alt="photo of kindle displaying BART civic center status page, the screenshot appears readable and fills the entire kindle display."/></a></p></div><p>And there it is!</p><div><div><p>We got an image to show up on the Kindle! Remember, the key things
were to make sure the image matches the dimensions of the Kindle
display, and uses only 8-bit color depth.</p></div></div><p>Now that we know how to make an image show up on the Kindle, we need to build
something that will provide us with an endless stream of <em>useful</em> images.</p><p>Remember that our actual goal here is to display transit arrival times, which
aren’t very helpful if you post them once and they never change. We need to
build something capable of generating Kindle-compatible screenshots if we want
this project to actually be useful. Since there was already a UI provided by
BART, I opted for the lazy approach. I built a Node.js server that used
Puppeteer to take a screenshot of the part of the page I cared about, tweaked it
to the size and color depth for the Kindle display, and returned it via an HTTP
endpoint. I put the server on a Raspberry Pi and set the Kindle up to fetch
images every minute via cron.</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span># On Kindle</span>
</span></span><span><span>
</span></span><span><span><span># Add the wget/eips commands from above</span>
</span></span><span><span>$ vi /usr/bin/refresh-image
</span></span><span><span>$ chmod +x /usr/bin/refresh-image
</span></span><span><span>
</span></span><span><span><span># Add the line `* * * * * /usr/bin/refresh-image`</span>
</span></span><span><span>$ vi /etc/crontab/root
</span></span><span><span>
</span></span><span><span><span># Restart the cron daemon so it runs our script</span>
</span></span><span><span>$ initctl restart cron
</span></span></code></pre></div><p>The Node.js version is very similar to the code that Matt created for his blog
post, with one notable exception. Since the BART page had auto-refreshing built
into it, I opened up a copy of the page at the beginning of the program’s start
time and just let that refresh in the background instead of re-loading the page
every time an HTTP request came in. I’m not going to spend much time on the
design of this server, but if you’re interested the code is up on <a href="https://github.com/lily-mara/bart-screenshot">my
github</a>.</p><div><div><p>We&#39;re successfully displaying BART departure times on a Kindle!</p></div></div><p>This system worked pretty well for a while. It would stop refreshing every once
in a while, the server would need to be restarted sometimes because it ran out
of memory, but it generally worked. It did start to break down however, once I
wanted to add support for MUNI.</p><p>The San Francisco Bay Area has
<a href="https://www.seamlessbayarea.org/blog/transitagencieslist">27</a> (really!) transit
operators. The list of modes of transit I listed at the top of the document
wasn’t a joke, we do have busses, trains, trams, trolley busses, cable cars, and
ferries, and multiple agencies that operate most of those different forms of
transit. At first my system only reported on BART, the regional rapid transit
system. Eventually though, I wanted to get arrival times for the other nearby
transit provider.</p><p>The San Francisco Municipal Railway (MUNI) operates trolley busses, gas busses,
light rail, and cable cars in San Francisco. Next to my apartment I had bus
stops and light rail stops that I frequently used and wanted to get the status
of. I thought I could adapt my Node.js screenshot tool to pull data on the MUNI
stops near me too, and I was somewhat successful at first. Like BART, MUNI has a
page where they report on the time to arrival of various lines at all of
their stops across the city.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-00.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-00.png" alt="screenshot of MUNI church st station status page. it shows upcoming K, M, and S trains."/></a></p><p>I figured it would be a straightforward endeavor to pull screenshots from the
status pages of all the stops that I cared about, and assemble them into one
view. I imagined it would look something like this:</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-01.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-01.png" alt="display of upcoming train lines organized into two columns, with each column displaying multiple rows, one for each transit line. each line displays the line ID in a colored bubble, alongside a destination name and minutes to the next vehicle arrival for each line"/></a></p><p>I was able to make this by assembling some screenshots by hand in Photopea. Now
that I had a goal, I set out to it. I was able to make something that pulled in
all the screenshots by maintaining multiple open browser tabs in Puppeteer,
combining them with ImageMagick, and returning them to the Kindle. I was pretty
happy with how it looked.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-02.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-02.png" alt="display of upcoming train lines organized into two columns, with each column displaying multiple rows, one for each transit line. each line displays the line ID in a colored bubble, alongside a destination name and minutes to the next vehicle arrival for each line"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-03.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-03.jpeg" alt="photo of a kindle displaying the previous image"/></a></p></div><p>This worked for a short time but it quickly became problematic. For a hint as to
why, look at the number of sections. Each of the seven sections on the image
represents a browser tab that Puppeteer needs to keep open in order to fetch
screenshots. Remember that the Node.js server was running on a Raspberry Pi, it
didn’t have an excess of memory to operate in and Chrome is not known for its
svelte-ness. In a related issue, MUNI was frequently returning HTTP 429 errors
because I was fetching data from them too often. Apparently they have relatively
low rate limits on these pages. These two issues combined to mean my BART &amp; MUNI
screens together were far less reliable than the BART one was on its own. Here’s
a rare picture of both displays working in tandem.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-04.jpeg"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/muni-04.jpeg" alt="photo of two kindles mounted to a wall, one above the other. the top kindle displays the bart civic center status page, and the bottom kindle displays an assemblage of MUNI train and bus arrivals"/></a></p><p>I stuck it out for a while, restarting my HTTP server when the stop data became
stale or health checks started failing. Eventually though, I grew tired of this
and realized I’d need to rethink my approach if I wanted this system to work. An
at-a-glance information system <em>needs</em> to be reliable, otherwise what’s the
point? If I can’t rely on the data on the screen being accurate, it might as
well not be there. So now we begin the most beautiful process in software -
starting from scratch.</p><div><div><p>In an effort to add more functionality, we&#39;ve made the system too
resource intensive to meet its requirements and we need to start
over.</p></div></div><p>I picked Node.js for the first server because I was using Puppeteer. I don’t
particularly like Javascript, so given the ability to start from scratch I
happily pivoted to Rust. We’ll be making a Rust HTTP server with
<a href="https://docs.rs/axum/latest/axum/">Axum</a> which serves PNG data. The public
contract of the service will be nearly identical to the Node.js service, but the
internals will be completely different.</p><p>We’re doing away with Puppeteer, so we need to figure out how we’re going to
source the data for stops. I don’t particularly want to parse it out of the HTML
pages that BART &amp; MUNI provide, and thankfully there’s an API provided by 511,
the Bay Area’s transit information system. Their <a href="https://511.org/open-data/transit">Stop Monitoring
API</a> will give us exactly what we need - the
estimated time of upcoming arrivals at any transit stop in the Bay Area.</p><p>Next, since we’re not relying on a browser engine to render the display, we will
be using a 2D graphics library to render a PNG directly. This should have a much
lower resource cost than using an entire browser engine, at the cost of some
decreased flexibility. After some brief research, I settled on using the <a href="https://github.com/rust-skia/rust-skia">Rust
bindings</a> for the popular
<a href="https://skia.org">Skia</a> graphics library. Skia is actually the graphics library
underpinning Chrome, so we’ll be getting some of the same rendering technology
with a lot less of the bloat from Puppeteer.</p><div><div><p>The final server code for this project was ~1,200 lines long. I will
<em>not</em> be explaining the entirety of the program in this blog
post, if you&#39;d like to go spelunking in there on your own, <a href="https://github.com/lily-mara/transit-kindle">here it is</a>. We will be covering the most
important/interesting parts of the codebase but there will be
simplifications and omissions.</p></div></div><p>There are three main components of this project. First, we’ll have to find the
upcoming transit arrival times. Next, we need to be able to take these
arrival times and render them as an 8-bit PNG image. Finally (and probably the
simplest) is an HTTP server which can return the generated PNG image data.</p><p>Let’s start by making sure we can pull the upcoming transit arrival times from
511.org and write them out to the console. We’ll start by making a new project
with <code>cargo new</code> and defining our dependencies.</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span># In Cargo.toml</span>
</span></span><span><span>[<span>dependencies</span>]
</span></span><span><span><span># HTTP client crate</span>
</span></span><span><span><span>reqwest</span> = { <span>version</span> = <span>&#34;0.11.18&#34;</span>, <span>default-features</span> = <span>false</span>, <span>features</span> = [
</span></span><span><span>    <span>&#34;json&#34;</span>,
</span></span><span><span>
</span></span><span><span>    <span># 511.org API responses are gzip-encoded and enabling this feature will</span>
</span></span><span><span>    <span># automatically decompress the payloads upon receiving them</span>
</span></span><span><span>    <span>&#34;gzip&#34;</span>,
</span></span><span><span>
</span></span><span><span>    <span># I used rustls because I was getting openssl linking errors on my Raspberry</span>
</span></span><span><span>    <span># Pi and I&#39;m too lazy to figure out how to actually fix those, so I just</span>
</span></span><span><span>    <span># statically linked a TLS library. You do not have to use rustls, but if you</span>
</span></span><span><span>    <span># omit this line, you will need to enable some other TLS backend.</span>
</span></span><span><span>    <span>&#34;rustls-tls&#34;</span>,
</span></span><span><span>] }
</span></span><span><span>
</span></span><span><span><span># The de-facto standard serialization/deserialization crate for Rust, we&#39;ll</span>
</span></span><span><span><span># use this to parse the 511.org response bodies.</span>
</span></span><span><span><span>serde</span> = { <span>version</span> = <span>&#34;1.0.174&#34;</span>, <span>features</span> = [<span>&#34;derive&#34;</span>] }
</span></span><span><span>
</span></span><span><span><span># Serde is a generic serialization framework, it doesn&#39;t know about any</span>
</span></span><span><span><span># particular languages. The serde_json crate will allow us to parse JSON</span>
</span></span><span><span><span># specifically.</span>
</span></span><span><span><span>serde_json</span> = <span>&#34;1.0.103&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Time handling library, will allow us to parse time data from strings in the</span>
</span></span><span><span><span># 511.org response bodies.</span>
</span></span><span><span><span>chrono</span> = { <span>version</span> = <span>&#34;0.4.26&#34;</span>, <span>features</span> = [<span>&#34;serde&#34;</span>] }
</span></span><span><span>
</span></span><span><span><span># Async runtime that powers the concurrency systems our application will use -</span>
</span></span><span><span><span># `full` feature required as library is shipped with only the minimum core</span>
</span></span><span><span><span># functionality enabled and we need a little more than that.</span>
</span></span><span><span><span>tokio</span> = { <span>version</span> = <span>&#34;1.29.1&#34;</span>, <span>features</span> = [<span>&#34;full&#34;</span>] }
</span></span><span><span>
</span></span><span><span><span># Generic error reporting library</span>
</span></span><span><span><span>eyre</span> = <span>&#34;0.6&#34;</span>
</span></span></code></pre></div><p>Now before we can get to coding, we need to <a href="https://511.org/open-data/token">get an API
key</a> from 511.org, and take a look at the API
definition. The 511.org docs are either <a href="https://511.org/open-data/transit">not super
detailed</a>, or <a href="https://511.org/media/407/show">quite
detailed</a>, depending on which docs you check.
We’ll be using the “Real-Time stop monitoring” endpoint, which the
not-super-detailed docs summarize like this:</p><blockquote><p>Real-time Stop Monitoring API provides the expected arrival and departure times of vehicles at a stop in XML and JSON formats.</p><p>Endpoint: <code>http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=[operatorID]</code></p><p>Allowable parameters: api_key (mandatory), agency (mandatory), stopcode (optional) and format (optional)</p></blockquote><p>The “agency” parameter refers to the code for which of the 27 different Bay Area
transit agencies you’re requesting data for. You can only get data on one agency
at a time. We’re going to be pulling data for the San Francisco Municipal
Railway, which has the agency code <code>SF</code> (you can find the agency ID for other
transit agencies by using the
<code>https://api.511.org/transit/gtfsoperators?api_key=[your_key]</code> endpoint for a
list of all agencies and their IDs). The StopMonitoring endpoint either returns
upcoming arrival times for a single stop, or <em>all stops</em> of the given transit
agency, which can be a lot of data! The 511.org APIs have a relatively low rate
limit (60 requests per hour!) so if we expect to be able to show real-time
status, we can’t fetch times one stop at a time. Unfortunately, as far as I can
tell, there is no way to fetch data on multiple stops at once other than
fetching data for <em>all</em> stops.</p><p>Ok, let’s open <code>main.rs</code> and grab all of the upcoming stop times for SF MUNI!</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> reqwest::Client;
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>    <span>let</span> response <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&#34;</span>).send().<span>await</span><span>?</span>.text().<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    println!(<span>&#34;</span><span>{response}</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>Now this program is going to print <em>a lot</em> of text, let’s make sure we redirect
that to a file so we can more easily explore it. This also may take a little
bit, for me the HTTP request takes around 5 seconds to complete and returns
about 27 MiB of data!</p><pre tabindex="0"><code>$ cargo run &gt; stops.json
</code></pre><p>If we open the resulting JSON file and format it (my formatted JSON file is over
1 million lines long!) so that it’s a bit easier to read, we can start to
understand the structure of the data that’s coming back. If we extract the outer structure of the object and the first element from the ~26k item-long list, we’ll see something like this:</p><div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;ServiceDelivery&#34;</span>: {
</span></span><span><span>    <span>&#34;ResponseTimestamp&#34;</span>: <span>&#34;2024-01-28T18:21:20Z&#34;</span>,
</span></span><span><span>    <span>&#34;ProducerRef&#34;</span>: <span>&#34;SF&#34;</span>,
</span></span><span><span>    <span>&#34;Status&#34;</span>: <span>true</span>,
</span></span><span><span>    <span>&#34;StopMonitoringDelivery&#34;</span>: {
</span></span><span><span>      <span>&#34;version&#34;</span>: <span>&#34;1.4&#34;</span>,
</span></span><span><span>      <span>&#34;ResponseTimestamp&#34;</span>: <span>&#34;2024-01-28T18:21:20Z&#34;</span>,
</span></span><span><span>      <span>&#34;Status&#34;</span>: <span>true</span>,
</span></span><span><span>      <span>&#34;MonitoredStopVisit&#34;</span>: [
</span></span><span><span>        {
</span></span><span><span>          <span>&#34;RecordedAtTime&#34;</span>: <span>&#34;2024-01-28T18:21:12Z&#34;</span>,
</span></span><span><span>          <span>&#34;MonitoringRef&#34;</span>: <span>&#34;15918&#34;</span>,
</span></span><span><span>          <span>&#34;MonitoredVehicleJourney&#34;</span>: {
</span></span><span><span>            <span>&#34;LineRef&#34;</span>: <span>&#34;29&#34;</span>,
</span></span><span><span>            <span>&#34;DirectionRef&#34;</span>: <span>&#34;IB&#34;</span>,
</span></span><span><span>            <span>&#34;FramedVehicleJourneyRef&#34;</span>: {
</span></span><span><span>              <span>&#34;DataFrameRef&#34;</span>: <span>&#34;2024-01-28&#34;</span>,
</span></span><span><span>              <span>&#34;DatedVehicleJourneyRef&#34;</span>: <span>&#34;11493704&#34;</span>
</span></span><span><span>            },
</span></span><span><span>            <span>&#34;PublishedLineName&#34;</span>: <span>&#34;SUNSET&#34;</span>,
</span></span><span><span>            <span>&#34;OperatorRef&#34;</span>: <span>&#34;SF&#34;</span>,
</span></span><span><span>            <span>&#34;OriginRef&#34;</span>: <span>&#34;14648&#34;</span>,
</span></span><span><span>            <span>&#34;OriginName&#34;</span>: <span>&#34;Fitzgerald Ave &amp; Keith St&#34;</span>,
</span></span><span><span>            <span>&#34;DestinationRef&#34;</span>: <span>&#34;13706&#34;</span>,
</span></span><span><span>            <span>&#34;DestinationName&#34;</span>: <span>&#34;Bowley St &amp; Lincoln Blvd&#34;</span>,
</span></span><span><span>            <span>&#34;Monitored&#34;</span>: <span>true</span>,
</span></span><span><span>            <span>&#34;InCongestion&#34;</span>: <span>null</span>,
</span></span><span><span>            <span>&#34;VehicleLocation&#34;</span>: {
</span></span><span><span>              <span>&#34;Longitude&#34;</span>: <span>&#34;-122.4319&#34;</span>,
</span></span><span><span>              <span>&#34;Latitude&#34;</span>: <span>&#34;37.721199&#34;</span>
</span></span><span><span>            },
</span></span><span><span>            <span>&#34;Bearing&#34;</span>: <span>&#34;300.0000000000&#34;</span>,
</span></span><span><span>            <span>&#34;Occupancy&#34;</span>: <span>&#34;seatsAvailable&#34;</span>,
</span></span><span><span>            <span>&#34;VehicleRef&#34;</span>: <span>&#34;8739&#34;</span>,
</span></span><span><span>            <span>&#34;MonitoredCall&#34;</span>: {
</span></span><span><span>              <span>&#34;StopPointRef&#34;</span>: <span>&#34;15918&#34;</span>,
</span></span><span><span>              <span>&#34;StopPointName&#34;</span>: <span>&#34;Persia Ave &amp; Paris St&#34;</span>,
</span></span><span><span>              <span>&#34;VehicleLocationAtStop&#34;</span>: <span>&#34;&#34;</span>,
</span></span><span><span>              <span>&#34;VehicleAtStop&#34;</span>: <span>&#34;true&#34;</span>,
</span></span><span><span>              <span>&#34;DestinationDisplay&#34;</span>: <span>&#34;Baker Beach&#34;</span>,
</span></span><span><span>              <span>&#34;AimedArrivalTime&#34;</span>: <span>&#34;2024-01-28T18:21:16Z&#34;</span>,
</span></span><span><span>              <span>&#34;ExpectedArrivalTime&#34;</span>: <span>&#34;2024-01-28T18:21:21Z&#34;</span>,
</span></span><span><span>              <span>&#34;AimedDepartureTime&#34;</span>: <span>&#34;2024-01-28T18:21:16Z&#34;</span>,
</span></span><span><span>              <span>&#34;ExpectedDepartureTime&#34;</span>: <span>null</span>,
</span></span><span><span>              <span>&#34;Distances&#34;</span>: <span>&#34;&#34;</span>
</span></span><span><span>            }
</span></span><span><span>          }
</span></span><span><span>        }
</span></span><span><span>        <span>// ~26k other JSON objects that look basically like that
</span></span></span><span><span><span></span>      ]
</span></span><span><span>    }
</span></span><span><span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>Now obviously, there’s a whole lot of information in this response. Let’s try
trimming this down to what we might need in order to render our display.
Remember that we’re trying to display the upcoming arrival times for a few
lines at a few known stops. We’ll filter out all of the fields that aren’t
necessary for this purpose so we can focus on what counts.</p><div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;ServiceDelivery&#34;</span>: {
</span></span><span><span>    <span>&#34;StopMonitoringDelivery&#34;</span>: {
</span></span><span><span>      <span>&#34;MonitoredStopVisit&#34;</span>: [
</span></span><span><span>        {
</span></span><span><span>          <span>&#34;MonitoredVehicleJourney&#34;</span>: {
</span></span><span><span>            <span>// This is the ID of the line, in this case, we&#39;re looking at the #29 bus
</span></span></span><span><span><span></span>            <span>&#34;LineRef&#34;</span>: <span>&#34;29&#34;</span>,
</span></span><span><span>
</span></span><span><span>            <span>// The &#34;direction&#34; of the bus. SF MUNI vehicles report directions
</span></span></span><span><span><span></span>            <span>// relative to downtown San Francisco, either &#34;inbound&#34; (IB) or
</span></span></span><span><span><span></span>            <span>// &#34;outbound&#34; (OB). It&#39;s a bit strange for this particular line,
</span></span></span><span><span><span></span>            <span>// since it goes _nowhere near downtown SF_ :/ but that&#39;s the system
</span></span></span><span><span><span></span>            <span>// we have. This bus is heading inbound, which means it&#39;s going West
</span></span></span><span><span><span></span>            <span>// from Bayview, then cutting North through the Sunset towards Baker
</span></span></span><span><span><span></span>            <span>// Beach.
</span></span></span><span><span><span></span>            <span>&#34;DirectionRef&#34;</span>: <span>&#34;IB&#34;</span>,
</span></span><span><span>
</span></span><span><span>            <span>// The name of the final stop on this line in the direction that
</span></span></span><span><span><span></span>            <span>// this bus is headed.
</span></span></span><span><span><span></span>            <span>&#34;DestinationName&#34;</span>: <span>&#34;Bowley St &amp; Lincoln Blvd&#34;</span>,
</span></span><span><span>            <span>&#34;MonitoredCall&#34;</span>: {
</span></span><span><span>              <span>// This is the ID of the stop of this estimated arrival. This
</span></span></span><span><span><span></span>              <span>// particular stop is at Persia Ave &amp; Paris St. in the Excelsior
</span></span></span><span><span><span></span>              <span>// neighborhood of SF. We will not have to map stop IDs to
</span></span></span><span><span><span></span>              <span>// locations for this project, but we will need to map locations
</span></span></span><span><span><span></span>              <span>// to Stop IDs.
</span></span></span><span><span><span></span>              <span>&#34;StopPointRef&#34;</span>: <span>&#34;15918&#34;</span>,
</span></span><span><span>
</span></span><span><span>              <span>// This is the time that the transit agency expects this
</span></span></span><span><span><span></span>              <span>// particular #29 bus to reach the Persia &amp; Paris stop.
</span></span></span><span><span><span></span>              <span>&#34;ExpectedArrivalTime&#34;</span>: <span>&#34;2024-01-28T18:21:21Z&#34;</span>,
</span></span><span><span>
</span></span><span><span>              <span>// This is a somewhat friendlier name for the destination. We&#39;ll
</span></span></span><span><span><span></span>              <span>// use this but fall back to the longer one if this is
</span></span></span><span><span><span></span>              <span>// unavailable.
</span></span></span><span><span><span></span>              <span>&#34;DestinationDisplay&#34;</span>: <span>&#34;Baker Beach&#34;</span>
</span></span><span><span>            }
</span></span><span><span>          }
</span></span><span><span>        }
</span></span><span><span>      ]
</span></span><span><span>    }
</span></span><span><span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>Basically all of the other fields in this response are irrelevant for our
purposes. There’s probably some future feature expansions that could be powered
by the other data, but for now we’re going to focus on these.</p><p>Now that we have a bit of an understanding on how the data are structured, let’s
filter our data by the stops that we actually care about. This step is going to
vary a bit depending on which transit operator you’re using. For SF MUNI, the
stop IDs are relatively easy to figure out. The <a href="https://www.sfmta.com/stops/persia-ave-paris-st-15918">SF MUNI
website</a> has realtime
stop monitoring pages, which show you the ID of the stop in question. In the
case of that link, it’s the stop that we just looked at in the JSON snippet
above, #15918 at Persia &amp; Paris. Use the MUNI website to find the IDs of the
stops close to you, paying attention to the fact that MUNI stops correspond with
only one direction of transit. This means that there are two “Persia Ave &amp; Paris
St” stops for the #29 bus, <a href="https://www.sfmta.com/stops/persia-ave-paris-st-15918">#15918 for
inbound</a> busses, and <a href="https://www.sfmta.com/stops/persia-ave-paris-st-15919">#15919
for outbound</a> busses.</p><p>Now that our Rust program is going to have to start caring about the structure
of the returned JSON data, we can’t just pass it around like text, we actually
need to parse it.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> reqwest::Client;
</span></span><span><span><span>use</span> serde::Deserialize;
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>StopMonitoringResponse</span> {
</span></span><span><span>    service_delivery: <span>ServiceDelivery</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>ServiceDelivery</span> {
</span></span><span><span>    stop_monitoring_delivery: <span>StopMonitoringDelivery</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>StopMonitoringDelivery</span> {
</span></span><span><span>    monitored_stop_visit: Vec<span>&lt;</span>MonitoredStopVisit<span>&gt;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>MonitoredStopVisit</span> {
</span></span><span><span>    monitored_vehicle_journey: <span>MonitoredVehicleJourney</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>MonitoredVehicleJourney</span> {
</span></span><span><span>    line_ref: Option<span>&lt;</span>String<span>&gt;</span>,
</span></span><span><span>    direction_ref: Option<span>&lt;</span>String<span>&gt;</span>,
</span></span><span><span>    destination_name: Option<span>&lt;</span>String<span>&gt;</span>,
</span></span><span><span>    monitored_call: <span>MonitoredCall</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[derive(Deserialize, Debug)]</span>
</span></span><span><span><span>#[serde(rename_all = </span><span>&#34;PascalCase&#34;</span><span>)]</span>
</span></span><span><span><span>struct</span> <span>MonitoredCall</span> {
</span></span><span><span>    expected_arrival_time: Option<span>&lt;</span>String<span>&gt;</span>,
</span></span><span><span>    stop_point_ref: String,
</span></span><span><span>    destination_display: Option<span>&lt;</span>String<span>&gt;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>    <span>let</span> response: <span>StopMonitoringResponse</span> <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&amp;stopCode=17073,18059&#34;</span>).send().<span>await</span><span>?</span>.json().<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> stops_i_care_about <span>=</span> Vec::new();
</span></span><span><span>
</span></span><span><span>    <span>for</span> stop_visit <span>in</span> response
</span></span><span><span>        .service_delivery
</span></span><span><span>        .stop_monitoring_delivery
</span></span><span><span>        .monitored_stop_visit
</span></span><span><span>    {
</span></span><span><span>        <span>let</span> stop <span>=</span> <span>&amp;</span>stop_visit
</span></span><span><span>            .monitored_vehicle_journey
</span></span><span><span>            .monitored_call
</span></span><span><span>            .stop_point_ref;
</span></span><span><span>        <span>if</span> stop <span>==</span> <span>&#34;15918&#34;</span> <span>||</span> stop <span>==</span> <span>&#34;15919&#34;</span> {
</span></span><span><span>            stops_i_care_about.push(stop_visit.monitored_vehicle_journey);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    println!(<span>&#34;</span><span>{stops_i_care_about:#?}</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>This should show us only the upcoming arrival times for the busses at both
directions of the Persia &amp; Paris stop. Let’s try running it:</p><pre tabindex="0"><code>$ cargo run &gt; stops.txt
Error: error decoding response body: expected value at line 1 column 1

Caused by:
    expected value at line 1 column 1

Location:
    src/main.rs:48:44
</code></pre><p>Uh oh! For some reason, our JSON parser didn’t like the value returned by the
511.org server. Was it not valid JSON? It certainly looked like valid JSON when
we looked at it. It turns out that 511.org returns a <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 Byte order
mark</a> as the first three
bytes of its API response, something that our JSON parser is not expecting.
We’ll need to remove those bytes before feeding the response to our JSON parser.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>..</span>.
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>    <span>// Using the `.text()` function parses the response as UTF-8 and strips the
</span></span></span><span><span><span></span>    <span>// Byte order mark
</span></span></span><span><span><span></span>    <span>let</span> response_txt <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&#34;</span>).send().<span>await</span><span>?</span>.text().<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> response: <span>StopMonitoringResponse</span> <span>=</span> serde_json::from_str(<span>&amp;</span>response_txt)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> stops_i_care_about <span>=</span> Vec::new();
</span></span><span><span>
</span></span><span><span>    <span>for</span> stop_visit <span>in</span> response
</span></span><span><span>        .service_delivery
</span></span><span><span>        .stop_monitoring_delivery
</span></span><span><span>        .monitored_stop_visit
</span></span><span><span>    {
</span></span><span><span>        <span>let</span> stop <span>=</span> <span>&amp;</span>stop_visit
</span></span><span><span>            .monitored_vehicle_journey
</span></span><span><span>            .monitored_call
</span></span><span><span>            .stop_point_ref;
</span></span><span><span>        <span>if</span> stop <span>==</span> <span>&#34;15918&#34;</span> <span>||</span> stop <span>==</span> <span>&#34;15919&#34;</span> {
</span></span><span><span>            stops_i_care_about.push(stop_visit.monitored_vehicle_journey);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    println!(<span>&#34;</span><span>{stops_i_care_about:#?}</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>Now let’s try running this one more time.</p><p>We should get an output file that looks something like this:</p><pre tabindex="0"><code>[
    MonitoredVehicleJourney {
        line_ref: Some(
            &#34;29&#34;,
        ),
        direction_ref: Some(
            &#34;IB&#34;,
        ),
        destination_name: Some(
            &#34;Bowley St &amp; Lincoln Blvd&#34;,
        ),
        monitored_call: MonitoredCall {
            expected_arrival_time: Some(
                &#34;2024-01-28T19:10:40Z&#34;,
            ),
            stop_point_ref: &#34;15918&#34;,
            destination_display: &#34;Baker Beach&#34;
        },
    },
    MonitoredVehicleJourney {
        line_ref: Some(
            &#34;29&#34;,
        ),
        direction_ref: Some(
            &#34;OB&#34;,
        ),
        destination_name: Some(
            &#34;Fitzgerald Ave &amp; Keith St&#34;,
        ),
        monitored_call: MonitoredCall {
            expected_arrival_time: Some(
                &#34;2024-01-28T19:12:56Z&#34;,
            ),
            stop_point_ref: &#34;15919&#34;,
            destination_display: &#34;Presidio&#34;
        },
    },
...
</code></pre><p>At the time I ran this, I got about 20 upcoming arrivals back. This is going to
be much more manageable than the 26k arrivals that we were initially looking at.</p><p>Let’s see if we can print out the arrivals in order of soonest to latest for
each direction.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> std::collections::HashMap;
</span></span><span><span><span>..</span>.
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> lines_and_directions_to_arrivals <span>=</span> HashMap::new();
</span></span><span><span>    <span>// This will organize the data into groups based on the line ID and the
</span></span></span><span><span><span></span>    <span>// direction that the bus is traveling when it reaches the stop
</span></span></span><span><span><span></span>    <span>for</span> arrival <span>in</span> stops_i_care_about {
</span></span><span><span>        <span>if</span> <span>let</span> Some(line) <span>=</span> arrival.line_ref.clone() {
</span></span><span><span>            <span>if</span> <span>let</span> Some(direction) <span>=</span> arrival.direction_ref.clone() {
</span></span><span><span>                lines_and_directions_to_arrivals
</span></span><span><span>                    .entry((line, direction))
</span></span><span><span>                    .or_insert(Vec::new())
</span></span><span><span>                    .push(arrival);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// This will sort the list of arrivals for each stop by the (lexographic)
</span></span></span><span><span><span></span>    <span>// order of the expected arrival time of each bus.
</span></span></span><span><span><span></span>    <span>for</span> stops <span>in</span> lines_and_directions_to_arrivals.values_mut() {
</span></span><span><span>        stops.sort_by_key(<span>|</span>s<span>|</span> s.monitored_call.expected_arrival_time.clone());
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>for</span> ((line, direction), arrivals) <span>in</span> lines_and_directions_to_arrivals {
</span></span><span><span>        println!(<span>&#34;=======&#34;</span>);
</span></span><span><span>        println!(<span>&#34;</span><span>{line}</span><span>: </span><span>{direction}</span><span>&#34;</span>);
</span></span><span><span>        <span>for</span> arrival <span>in</span> arrivals {
</span></span><span><span>            <span>if</span> <span>let</span> Some(time) <span>=</span> arrival.monitored_call.expected_arrival_time {
</span></span><span><span>                println!(<span>&#34;- </span><span>{}</span><span>&#34;</span>, time);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>Running the code in its current form should give us something that’s (nearly) usable!</p><pre tabindex="0"><code>$ cargo run
=======
29: OB
- 2024-01-28T19:31:55Z
- 2024-01-28T19:44:42Z
- 2024-01-28T19:52:49Z
- 2024-01-28T20:04:48Z
- 2024-01-28T20:16:35Z
- 2024-01-28T20:28:35Z
- 2024-01-28T20:40:35Z
- 2024-01-28T20:52:35Z
- 2024-01-28T21:04:35Z
=======
29: IB
- 2024-01-28T19:20:11Z
- 2024-01-28T19:32:42Z
- 2024-01-28T19:43:15Z
- 2024-01-28T19:55:15Z
- 2024-01-28T20:07:15Z
- 2024-01-28T20:19:15Z
- 2024-01-28T20:31:15Z
- 2024-01-28T20:43:15Z
- 2024-01-28T21:07:15Z
- 2024-01-28T21:19:15Z
- 2024-01-28T21:31:15Z
</code></pre><p>This technically shows us upcoming bus times, but it’s not especially helpful.
Let’s turn those UTC timestamps into “how many minutes away is this bus.”</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> chrono::prelude::<span>*</span>;
</span></span><span><span>
</span></span><span><span><span>..</span>.
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>for</span> ((line, direction), arrivals) <span>in</span> lines_and_directions_to_arrivals {
</span></span><span><span>        println!(<span>&#34;=======&#34;</span>);
</span></span><span><span>        println!(<span>&#34;</span><span>{line}</span><span>: </span><span>{direction}</span><span>&#34;</span>);
</span></span><span><span>        <span>for</span> arrival <span>in</span> arrivals {
</span></span><span><span>            <span>if</span> <span>let</span> Some(time) <span>=</span> arrival.monitored_call.expected_arrival_time {
</span></span><span><span>                <span>let</span> time <span>=</span> time.parse::<span>&lt;</span>DateTime<span>&lt;</span>Utc<span>&gt;&gt;</span>()<span>?</span>;
</span></span><span><span>
</span></span><span><span>                <span>if</span> time <span>&lt;</span> Utc::now() {
</span></span><span><span>                    <span>continue</span>;
</span></span><span><span>                }
</span></span><span><span>
</span></span><span><span>                println!(<span>&#34;- </span><span>{}</span><span>min&#34;</span>, (time <span>-</span> Utc::now()).num_minutes());
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>Running this gives us something pretty close to our eventual goal.</p><div><pre tabindex="0"><code data-lang="sh"><span><span>$ cargo run
</span></span><span><span><span>=======</span>
</span></span><span><span>29: OB
</span></span><span><span>- 13min
</span></span><span><span>- 27min
</span></span><span><span>- 42min
</span></span><span><span>- 57min
</span></span><span><span>- 72min
</span></span><span><span>- 87min
</span></span><span><span>- 102min
</span></span><span><span>- 117min
</span></span><span><span><span>=======</span>
</span></span><span><span>29: IB
</span></span><span><span>- 18min
</span></span><span><span>- 30min
</span></span><span><span>- 59min
</span></span><span><span>- 74min
</span></span><span><span>- 89min
</span></span><span><span>- 104min
</span></span><span><span>- 124min
</span></span></code></pre></div><p>Now that we have these data, let’s take a look at how we can put them into a
PNG!</p><p>Now, I’d never used Skia before, and I’d certainly never used the Skia Rust
bindings before. Before we try to display bus times, let’s make sure we
understand how to set up our PNG rendering pipeline. When exploring a new
problem space, “Hello World” is usually a good first program to build. Let’s
make a PNG8 image that’s 1024x758 (the size of the Kindle screen) and make it
display “Hello World” in the middle of the image.</p><p>We’ll need to start by including <code>skia-safe</code> in our dependencies.</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span># in Cargo.toml</span>
</span></span><span><span><span>skia-safe</span> = <span>&#34;0.70&#34;</span>
</span></span></code></pre></div><p>Now, let’s make a new binary (for the time being) that we’ll use for
experimenting with Image files. I’ll get us started with my (heavily annotated)
“Hello World” Skia program.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> std::{fs::File, io::Write};
</span></span><span><span>
</span></span><span><span><span>use</span> eyre::{ensure, eyre};
</span></span><span><span><span>use</span> skia_safe::{
</span></span><span><span>    AlphaType, Bitmap, Canvas, Color4f, ColorType, Font, FontMgr, FontStyle, ImageInfo, Paint,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>// A skia &#34;bitmap&#34; is used as an in-memory region to store all of the pixels
</span></span></span><span><span><span></span>    <span>// of our image. It is initially an empty 0x0 memory region.
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> bitmap <span>=</span> Bitmap::new();
</span></span><span><span>
</span></span><span><span>    <span>// The `ensure` macro from eyre will exit the function with an Err if this
</span></span></span><span><span><span></span>    <span>// `set_info` call does not return `true`.
</span></span></span><span><span><span></span>    ensure!(
</span></span><span><span>        <span>// This `set_info` call sets up the bitmap for the dimensions and color
</span></span></span><span><span><span></span>        <span>// depth that we expect it to have.
</span></span></span><span><span><span></span>        bitmap.set_info(
</span></span><span><span>            <span>&amp;</span>ImageInfo::new(
</span></span><span><span>                <span>// This is the width and height of the image
</span></span></span><span><span><span></span>                (<span>1024</span>, <span>758</span>),
</span></span><span><span>                <span>// Since color depth affects per-pixel storage, we need to set
</span></span></span><span><span><span></span>                <span>// this ahead of time so that Skia knows how much space (one
</span></span></span><span><span><span></span>                <span>// byte) to allocate for each pixel in our image.
</span></span></span><span><span><span></span>                ColorType::Gray8,
</span></span><span><span>                <span>// Our image will have no alpha channel
</span></span></span><span><span><span></span>                AlphaType::Unknown,
</span></span><span><span>                <span>// The colorspace of an 8-bit PNG doesn&#39;t matter that much (to
</span></span></span><span><span><span></span>                <span>// me at least)
</span></span></span><span><span><span></span>                None
</span></span><span><span>            ),
</span></span><span><span>            None
</span></span><span><span>        )
</span></span><span><span>    );
</span></span><span><span>    <span>// We need to allocate the required space for our image&#39;s pixels after
</span></span></span><span><span><span></span>    <span>// calling `set_info`.
</span></span></span><span><span><span></span>    bitmap.alloc_pixels();
</span></span><span><span>
</span></span><span><span>    <span>// A skia &#34;canvas&#34; is the drawing context. It is the thing that knows how to
</span></span></span><span><span><span></span>    <span>// draw text, 2D shapes, and everything else interesting that we care about
</span></span></span><span><span><span></span>    <span>// drawing. We pass our bitmap to the constructor as this is where all of
</span></span></span><span><span><span></span>    <span>// our image data will end up.
</span></span></span><span><span><span></span>    <span>let</span> canvas <span>=</span> Canvas::from_bitmap(<span>&amp;</span>bitmap, None).ok_or(eyre!(<span>&#34;skia canvas&#34;</span>))<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>// This call blanks the image with a fully white background. All the colors
</span></span></span><span><span><span></span>    <span>// we&#39;ll be dealing with are represented as 32-bit floats between 0 and 1.
</span></span></span><span><span><span></span>    canvas.clear(Color4f::new(<span>1.0</span>, <span>1.0</span>, <span>1.0</span>, <span>1.0</span>));
</span></span><span><span>
</span></span><span><span>    <span>// In order to draw text, we need to load a &#34;font,&#34; which is a combination
</span></span></span><span><span><span></span>    <span>// of a &#34;typeface,&#34; and a size. We&#39;ll load the &#34;Arial&#34; typeface and create a
</span></span></span><span><span><span></span>    <span>// 48-point font with it.
</span></span></span><span><span><span></span>    <span>let</span> font_manager <span>=</span> FontMgr::new();
</span></span><span><span>    <span>let</span> typeface <span>=</span> font_manager
</span></span><span><span>        .match_family_style(<span>&#34;Arial&#34;</span>, FontStyle::normal())
</span></span><span><span>        .unwrap();
</span></span><span><span>    <span>let</span> font <span>=</span> Font::new(typeface, <span>48.0</span>);
</span></span><span><span>
</span></span><span><span>    <span>// Most of the drawing commands we&#39;ll give Skia will require us to use a
</span></span></span><span><span><span></span>    <span>// &#34;paint,&#34; something that tells Skia what color something should be. This
</span></span></span><span><span><span></span>    <span>// black paint will be used as the color of our &#34;Hello World&#34; text.
</span></span></span><span><span><span></span>    <span>let</span> black_paint <span>=</span> Paint::new(Color4f::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>1.0</span>), None);
</span></span><span><span>
</span></span><span><span>    canvas.draw_str(<span>&#34;Hello World!&#34;</span>, (<span>100.0</span>, <span>100.0</span>), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>    <span>// After drawing our image, we need to save it out to the filesystem so that
</span></span></span><span><span><span></span>    <span>// we can view it. First we must convert our raw bitmap into a PNG image.
</span></span></span><span><span><span></span>    <span>let</span> png <span>=</span> bitmap
</span></span><span><span>        .as_image()
</span></span><span><span>        .encode(None, skia_safe::EncodedImageFormat::<span>PNG</span>, None)
</span></span><span><span>        .ok_or(eyre!(<span>&#34;skia image encode&#34;</span>))<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>// These are the raw bytes of our PNG image. In this example, we&#39;re saving
</span></span></span><span><span><span></span>    <span>// the bytes to the filesystem, but in the future these bytes will be
</span></span></span><span><span><span></span>    <span>// streamed over an HTTP endpoint to our Kindle.
</span></span></span><span><span><span></span>    <span>let</span> png_bytes <span>=</span> png.as_bytes();
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> f <span>=</span> File::create(<span>&#34;out.png&#34;</span>)<span>?</span>;
</span></span><span><span>    f.write_all(png_bytes)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>If we run this binary and open the generated <code>out.png</code> file, we should see our
message!</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/hello-world.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/hello-world.png" alt="hello world png file"/></a></p><p>Now that we can render some text, let’s try to render some bus times instead.
We’ll aim to create a table-like display with a column for inbound vehicles and
another for outbound vehicles. Each row in the table will represent a line in a
particular direction. I’m going to make some fake times, in the interest of
fast iteration time (remember it’s rather slow to fetch data from the 511.org
API, and there’s also a low rate limit).</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>// These contain line IDs, Destination names, and lists of times of upcoming
</span></span></span><span><span><span></span>    <span>// buses/trains.
</span></span></span><span><span><span></span>    <span>let</span> inbound_bus_times: <span>&amp;</span>[(<span>&amp;</span><span>str</span>, <span>&amp;</span><span>str</span>, <span>&amp;</span>[<span>&amp;</span><span>str</span>])] <span>=</span> <span>&amp;</span>[
</span></span><span><span>        (<span>&#34;22&#34;</span>, <span>&#34;Marina&#34;</span>, <span>&amp;</span>[<span>&#34;5min&#34;</span>, <span>&#34;7min&#34;</span>]),
</span></span><span><span>        (<span>&#34;K&#34;</span>, <span>&#34;Embarcadero&#34;</span>, <span>&amp;</span>[<span>&#34;3min&#34;</span>, <span>&#34;10min&#34;</span>]),
</span></span><span><span>        (<span>&#34;J&#34;</span>, <span>&#34;Downtown&#34;</span>, <span>&amp;</span>[<span>&#34;0min&#34;</span>, <span>&#34;8min&#34;</span>, <span>&#34;13min&#34;</span>]),
</span></span><span><span>    ];
</span></span><span><span>    <span>let</span> outbound_bus_times: <span>&amp;</span>[(<span>&amp;</span><span>str</span>, <span>&amp;</span><span>str</span>, <span>&amp;</span>[<span>&amp;</span><span>str</span>])] <span>=</span> <span>&amp;</span>[
</span></span><span><span>        (<span>&#34;22&#34;</span>, <span>&#34;UCSF&#34;</span>, <span>&amp;</span>[<span>&#34;3min&#34;</span>, <span>&#34;9min&#34;</span>]),
</span></span><span><span>        (<span>&#34;K&#34;</span>, <span>&#34;Balboa Park&#34;</span>, <span>&amp;</span>[<span>&#34;12min&#34;</span>, <span>&#34;20min&#34;</span>]),
</span></span><span><span>        (<span>&#34;J&#34;</span>, <span>&#34;Balboa Park&#34;</span>, <span>&amp;</span>[<span>&#34;1min&#34;</span>, <span>&#34;127min&#34;</span>, <span>&#34;128min&#34;</span>]),
</span></span><span><span>    ];
</span></span><span><span>
</span></span><span><span>    <span>// Since we have two sets of times to render, we&#39;ll create a lambda that
</span></span></span><span><span><span></span>    <span>// allows us to run the same code against two different sets of inputs - the
</span></span></span><span><span><span></span>    <span>// two different sets of times, and the left and right column of the image.
</span></span></span><span><span><span></span>    <span>let</span> draw_times <span>=</span> <span>|</span>times: <span>&amp;</span>[(<span>&amp;</span><span>str</span>, <span>&amp;</span><span>str</span>, <span>&amp;</span>[<span>&amp;</span><span>str</span>])], x1: <span>f32</span>, x2: <span>f32</span><span>|</span> {
</span></span><span><span>        <span>let</span> <span>mut</span> y <span>=</span> <span>30.0</span>;
</span></span><span><span>        <span>for</span> (line_id, destination, times) <span>in</span> times {
</span></span><span><span>            canvas.draw_str(line_id, (x1 <span>+</span> <span>20.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>            canvas.draw_str(destination, (x1 <span>+</span> <span>60.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>            <span>let</span> <span>mut</span> times_str <span>=</span> String::new();
</span></span><span><span>            <span>for</span> time <span>in</span> <span>*</span>times {
</span></span><span><span>                times_str.push_str(time);
</span></span><span><span>                times_str.push_str(<span>&#34;, &#34;</span>);
</span></span><span><span>            }
</span></span><span><span>            times_str.pop();
</span></span><span><span>            times_str.pop();
</span></span><span><span>
</span></span><span><span>            canvas.draw_str(times_str, (x1 <span>+</span> <span>260.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>            canvas.draw_line((x1 <span>+</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), (x2 <span>-</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), <span>&amp;</span>black_paint);
</span></span><span><span>            y <span>+=</span> <span>40.0</span>;
</span></span><span><span>        }
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>let</span> width <span>=</span> <span>1024.0</span>;
</span></span><span><span>    <span>let</span> height <span>=</span> <span>758.0</span>;
</span></span><span><span>    <span>let</span> midpoint <span>=</span> <span>512.0</span>;
</span></span><span><span>
</span></span><span><span>    draw_times(inbound_bus_times, <span>0.0</span>, midpoint);
</span></span><span><span>    canvas.draw_line((midpoint, <span>0.0</span>), (midpoint, height), <span>&amp;</span>black_paint);
</span></span><span><span>    draw_times(outbound_bus_times, midpoint, width);
</span></span><span><span>
</span></span><span><span>    <span>..</span>.
</span></span><span><span>}
</span></span></code></pre></div><p>There’s not really a whole lot that’s new to us in this code example except for
the <code>draw_line</code> function. We’re using it to put a line underneath each
bus/train’s next arrival times, and in the middle of the image to divide the two
columns. It’s all just loops and setting text on the image. Running this
program, we get a functional (if quite stale) display of times.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-01.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-01.png" alt="display with two columns, with rows in each column for transit lines. each row displays a line id, followed by a destination name, followed by next arrival times. all text is left-aligned and all of the row ids are vertically aligned with each other row-to-row, all the destinations are aligned, and all the times are aligned. it appears as if it were made in a spreadsheet application"/></a></p><p>Now that we’re displaying an image, let’s see if we can connect our API fetching
code to the PNG generation code.</p><p>In order to accomplish this, we’re going to need to change some of the data
structures we’re using to hold the journeys to more closely align with what our
image generation code needs. Remember that the image generation code is
expecting data broken down by direction, line ID, line destination, and then
times. I’m also going to switch the data from the sleepy Prussia &amp; Paris stop to
a few stops located at Van Ness and Market, one of MUNI’s busiest
interconnection spots (anecdotally). Let’s start with these changes before we
add in the image generation.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>    <span>let</span> response_txt <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&#34;</span>).send().<span>await</span><span>?</span>.text().<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> response: <span>StopMonitoringResponse</span> <span>=</span> serde_json::from_str(<span>&amp;</span>response_txt)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> journeys_i_care_about <span>=</span> Vec::new();
</span></span><span><span>
</span></span><span><span>    <span>for</span> stop_visit <span>in</span> response
</span></span><span><span>        .service_delivery
</span></span><span><span>        .stop_monitoring_delivery
</span></span><span><span>        .monitored_stop_visit
</span></span><span><span>    {
</span></span><span><span>        <span>let</span> stop <span>=</span> <span>&amp;</span>stop_visit
</span></span><span><span>            .monitored_vehicle_journey
</span></span><span><span>            .monitored_call
</span></span><span><span>            .stop_point_ref;
</span></span><span><span>        <span>// These four stop IDs represent IB/OB traffic at the Van Ness Metro
</span></span></span><span><span><span></span>        <span>// stop, and East/West traffic on Market St at Van Ness.
</span></span></span><span><span><span></span>        <span>if</span> [<span>&#34;15419&#34;</span>, <span>&#34;16996&#34;</span>, <span>&#34;15692&#34;</span>, <span>&#34;15696&#34;</span>].contains(<span>&amp;</span>stop.as_ref()) {
</span></span><span><span>            journeys_i_care_about.push(stop_visit.monitored_vehicle_journey);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// The name is a little unwieldy, but this layered HashMap holds journeys
</span></span></span><span><span><span></span>    <span>// organized first by direction (IB/OB), then a combination of line ID &amp;
</span></span></span><span><span><span></span>    <span>// destination name.
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> directions_to_lines_destinations_to_journeys <span>=</span> HashMap::new();
</span></span><span><span>    <span>for</span> journey <span>in</span> journeys_i_care_about {
</span></span><span><span>        <span>let</span> Some(line) <span>=</span> journey.line_ref.clone() <span>else</span> {
</span></span><span><span>            <span>continue</span>;
</span></span><span><span>        };
</span></span><span><span>        <span>let</span> Some(direction) <span>=</span> journey.direction_ref.clone() <span>else</span> {
</span></span><span><span>            <span>continue</span>;
</span></span><span><span>        };
</span></span><span><span>        <span>let</span> Some(destination) <span>=</span> journey.monitored_call.destination_display.clone() <span>else</span> {
</span></span><span><span>            <span>continue</span>;
</span></span><span><span>        };
</span></span><span><span>
</span></span><span><span>        directions_to_lines_destinations_to_journeys
</span></span><span><span>            .entry(direction)
</span></span><span><span>            .or_insert(HashMap::new())
</span></span><span><span>            .entry((line, destination))
</span></span><span><span>            .or_insert(Vec::new())
</span></span><span><span>            .push(journey);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>for</span> lines_destinations_to_journeys <span>in</span> directions_to_lines_destinations_to_journeys.values_mut()
</span></span><span><span>    {
</span></span><span><span>        <span>for</span> journeys <span>in</span> lines_destinations_to_journeys.values_mut() {
</span></span><span><span>            journeys.sort_by_key(<span>|</span>j<span>|</span> j.monitored_call.expected_arrival_time.clone());
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// We&#39;ll worry about this function later
</span></span></span><span><span><span></span>    draw_image(directions_to_lines_destinations_to_journeys)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>Now that we have the data prepped, let’s make the changes to our image
generation to support live data.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>draw_image</span>(
</span></span><span><span>    directions_to_lines_destinations_to_journeys: <span>HashMap</span><span>&lt;</span>
</span></span><span><span>        String,
</span></span><span><span>        HashMap<span>&lt;</span>(String, String), Vec<span>&lt;</span>MonitoredVehicleJourney<span>&gt;&gt;</span>,
</span></span><span><span>    <span>&gt;</span>,
</span></span><span><span>) -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> <span>mut</span> bitmap <span>=</span> Bitmap::new();
</span></span><span><span>    ensure!(bitmap.set_info(
</span></span><span><span>        <span>&amp;</span>ImageInfo::new((<span>1024</span>, <span>758</span>), ColorType::Gray8, AlphaType::Unknown, None),
</span></span><span><span>        None
</span></span><span><span>    ));
</span></span><span><span>    bitmap.alloc_pixels();
</span></span><span><span>
</span></span><span><span>    <span>let</span> canvas <span>=</span> Canvas::from_bitmap(<span>&amp;</span>bitmap, None).ok_or(eyre!(<span>&#34;skia canvas&#34;</span>))<span>?</span>;
</span></span><span><span>
</span></span><span><span>    canvas.clear(Color4f::new(<span>1.0</span>, <span>1.0</span>, <span>1.0</span>, <span>1.0</span>));
</span></span><span><span>
</span></span><span><span>    <span>let</span> font_manager <span>=</span> FontMgr::new();
</span></span><span><span>    <span>let</span> typeface <span>=</span> font_manager
</span></span><span><span>        .match_family_style(<span>&#34;Arial&#34;</span>, FontStyle::normal())
</span></span><span><span>        .unwrap();
</span></span><span><span>    <span>let</span> font <span>=</span> Font::new(typeface, <span>24.0</span>);
</span></span><span><span>
</span></span><span><span>    <span>let</span> black_paint <span>=</span> Paint::new(Color4f::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>1.0</span>), None);
</span></span><span><span>
</span></span><span><span>    <span>let</span> inbound_journeys <span>=</span> <span>&amp;</span>directions_to_lines_destinations_to_journeys[<span>&#34;IB&#34;</span>];
</span></span><span><span>    <span>let</span> outbound_journeys <span>=</span> <span>&amp;</span>directions_to_lines_destinations_to_journeys[<span>&#34;OB&#34;</span>];
</span></span><span><span>
</span></span><span><span>    <span>let</span> draw_times <span>=</span> <span>|</span>lines_destinations_to_journeys: <span>&amp;</span><span>HashMap</span><span>&lt;</span>
</span></span><span><span>        (String, String),
</span></span><span><span>        Vec<span>&lt;</span>MonitoredVehicleJourney<span>&gt;</span>,
</span></span><span><span>    <span>&gt;</span>,
</span></span><span><span>                      x1: <span>f32</span>,
</span></span><span><span>                      x2: <span>f32</span><span>|</span> {
</span></span><span><span>        <span>let</span> <span>mut</span> y <span>=</span> <span>30.0</span>;
</span></span><span><span>        <span>for</span> ((line_id, destination), journeys) <span>in</span> lines_destinations_to_journeys {
</span></span><span><span>            canvas.draw_str(line_id, (x1 <span>+</span> <span>20.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>            canvas.draw_str(destination, (x1 <span>+</span> <span>60.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>            <span>let</span> <span>mut</span> times_str <span>=</span> String::new();
</span></span><span><span>            <span>for</span> journey <span>in</span> journeys {
</span></span><span><span>                <span>let</span> Some(time_str) <span>=</span> <span>&amp;</span>journey.monitored_call.expected_arrival_time <span>else</span> {
</span></span><span><span>                    <span>continue</span>;
</span></span><span><span>                };
</span></span><span><span>
</span></span><span><span>                <span>let</span> Ok(time) <span>=</span> time_str.parse::<span>&lt;</span>DateTime<span>&lt;</span>Utc<span>&gt;&gt;</span>() <span>else</span> {
</span></span><span><span>                    <span>continue</span>;
</span></span><span><span>                };
</span></span><span><span>
</span></span><span><span>                <span>if</span> time <span>&lt;</span> Utc::now() {
</span></span><span><span>                    <span>continue</span>;
</span></span><span><span>                }
</span></span><span><span>
</span></span><span><span>                <span>let</span> time <span>=</span> format!(<span>&#34;</span><span>{}</span><span>min, &#34;</span>, (time <span>-</span> Utc::now()).num_minutes());
</span></span><span><span>
</span></span><span><span>                times_str.push_str(<span>&amp;</span>time);
</span></span><span><span>            }
</span></span><span><span>            times_str.pop();
</span></span><span><span>            times_str.pop();
</span></span><span><span>
</span></span><span><span>            canvas.draw_str(times_str, (x1 <span>+</span> <span>260.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>            canvas.draw_line((x1 <span>+</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), (x2 <span>-</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), <span>&amp;</span>black_paint);
</span></span><span><span>            y <span>+=</span> <span>40.0</span>;
</span></span><span><span>        }
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>let</span> width <span>=</span> <span>1024.0</span>;
</span></span><span><span>    <span>let</span> height <span>=</span> <span>758.0</span>;
</span></span><span><span>    <span>let</span> midpoint <span>=</span> <span>512.0</span>;
</span></span><span><span>
</span></span><span><span>    draw_times(inbound_journeys, <span>0.0</span>, midpoint);
</span></span><span><span>    canvas.draw_line((midpoint, <span>0.0</span>), (midpoint, height), <span>&amp;</span>black_paint);
</span></span><span><span>    draw_times(outbound_journeys, midpoint, width);
</span></span><span><span>
</span></span><span><span>    <span>let</span> png <span>=</span> bitmap
</span></span><span><span>        .as_image()
</span></span><span><span>        .encode(None, skia_safe::EncodedImageFormat::<span>PNG</span>, None)
</span></span><span><span>        .ok_or(eyre!(<span>&#34;skia image encode&#34;</span>))<span>?</span>;
</span></span><span><span>    <span>let</span> png_bytes <span>=</span> png.as_bytes();
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> f <span>=</span> File::create(<span>&#34;out.png&#34;</span>)<span>?</span>;
</span></span><span><span>    f.write_all(png_bytes)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>There’s a little bit more logic in there now, but it’s basically the same as the
previous standalone image generator. Let’s run our program and get a beautiful,
accurate timetable of the Van Ness busses and trams!</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-02.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-02.png" alt="display of two columns with rows in each column holding data on transit lines. there are a large number of points where text appears overlaid on other text, it is extremely difficult to read any of the text"/></a></p><p>Uh oh. Now, absolutely nobody in the world could have predicted this, but our
real-world data were more complicated than the test data that I thought up while
I was heavily biased towards “I don’t want to type very much.” The main issue
here is that we have a static layout for each of our rows, despite the fact that
there’s a slightly different amount of data to display in each of the rows.
We’re going to have to do a little bit of <em>visual design</em>, but before we do let’s add
a little short-circuit to the API-calling code so that we can iterate on this
quickly and not get rate-limited.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> response_txt <span>=</span> <span>match</span> std::fs::read_to_string(<span>&#34;data.json&#34;</span>) {
</span></span><span><span>        Ok(x) <span>=&gt;</span> x,
</span></span><span><span>        Err(_) <span>=&gt;</span> {
</span></span><span><span>            <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>            <span>let</span> data <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&#34;</span>).send().<span>await</span><span>?</span>.text().<span>await</span><span>?</span>;
</span></span><span><span>            std::fs::write(<span>&#34;data.json&#34;</span>, <span>&amp;</span>data)<span>?</span>;
</span></span><span><span>            data
</span></span><span><span>        }
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>let</span> response: <span>StopMonitoringResponse</span> <span>=</span> serde_json::from_str(<span>&amp;</span>response_txt)<span>?</span>;
</span></span><span><span>    <span>..</span>.
</span></span></code></pre></div><p>Now then, here’s how we’re going to update the drawing:</p><ul><li>Right-justify the times of upcoming vehicles so that there’s no wasted space
at the end of the timetables</li><li>Remove the “min” between each time on the table, adding it only at the end of
the list. This maximizes useful information and minimizes cruft</li><li>Only display the next 3 vehicles, we don’t have space for all of them</li><li>Scoot the destination names a bit to the right to compensate for the longer
bus names</li></ul><p>Let’s start with these three changes and see how far that gets us. The
<code>draw_times</code> lambda in <code>draw_image</code> is really the only thing that needs to
change.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> draw_times <span>=</span> <span>|</span>lines_destinations_to_journeys: <span>&amp;</span><span>HashMap</span><span>&lt;</span>
</span></span><span><span>    (String, String),
</span></span><span><span>    Vec<span>&lt;</span>MonitoredVehicleJourney<span>&gt;</span>,
</span></span><span><span><span>&gt;</span>,
</span></span><span><span>                    x1: <span>f32</span>,
</span></span><span><span>                    x2: <span>f32</span><span>|</span> {
</span></span><span><span>    <span>let</span> <span>mut</span> y <span>=</span> <span>30.0</span>;
</span></span><span><span>    <span>for</span> ((line_id, destination), journeys) <span>in</span> lines_destinations_to_journeys {
</span></span><span><span>        canvas.draw_str(line_id, (x1 <span>+</span> <span>20.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>        canvas.draw_str(destination, (x1 <span>+</span> <span>90.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>        <span>let</span> <span>mut</span> times_str <span>=</span> String::new();
</span></span><span><span>        <span>for</span> journey <span>in</span> <span>&amp;</span>journeys[<span>..</span>journeys.len().min(<span>3</span>)] {
</span></span><span><span>            <span>let</span> Some(time_str) <span>=</span> <span>&amp;</span>journey.monitored_call.expected_arrival_time <span>else</span> {
</span></span><span><span>                <span>continue</span>;
</span></span><span><span>            };
</span></span><span><span>
</span></span><span><span>            <span>let</span> Ok(time) <span>=</span> time_str.parse::<span>&lt;</span>DateTime<span>&lt;</span>Utc<span>&gt;&gt;</span>() <span>else</span> {
</span></span><span><span>                <span>continue</span>;
</span></span><span><span>            };
</span></span><span><span>
</span></span><span><span>            <span>if</span> time <span>&lt;</span> Utc::now() {
</span></span><span><span>                <span>continue</span>;
</span></span><span><span>            }
</span></span><span><span>
</span></span><span><span>            <span>let</span> time <span>=</span> format!(<span>&#34;</span><span>{}</span><span>, &#34;</span>, (time <span>-</span> Utc::now()).num_minutes());
</span></span><span><span>
</span></span><span><span>            times_str.push_str(<span>&amp;</span>time);
</span></span><span><span>        }
</span></span><span><span>        times_str.pop();
</span></span><span><span>        times_str.pop();
</span></span><span><span>        times_str.push_str(<span>&#34; min&#34;</span>);
</span></span><span><span>
</span></span><span><span>        canvas.draw_str_align(times_str, (x2 <span>-</span> <span>20.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint, Align::Right);
</span></span><span><span>        canvas.draw_line((x1 <span>+</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), (x2 <span>-</span> <span>10.0</span>, y <span>+</span> <span>10.0</span>), <span>&amp;</span>black_paint);
</span></span><span><span>        y <span>+=</span> <span>40.0</span>;
</span></span><span><span>    }
</span></span><span><span>};
</span></span></code></pre></div><p>After this, we can re-run the program and get a much more legible (if quite
bland and odd) timetable.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-03.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-03.png" alt="display with two columns, with rows in each column for transit lines. each row displays a line id, followed by a destination name, followed by next arrival times. line ids and destinations are left-aligned, arrival times are right-aligned and all of the row ids are vertically aligned with each other row-to-row, all the destinations are aligned, and all the times are aligned. it appears as if it were made in a spreadsheet application, but by someone who cared slightly"/></a></p><p>This isn’t a great looking timetable, and it’s not what the finished product is
going to look like, but it is what we’re going to start out with. Now that we
can generate a PNG with real image data, let’s move on to serving it via HTTP.</p><p>Now that we can generate a PNG, let’s build a server that can feed our image
file to the Kindle. We’ll need to add Axum to our dependency list.</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span># In Cargo.toml</span>
</span></span><span><span><span>axum</span> = <span>&#34;0.7&#34;</span>
</span></span></code></pre></div><p>And thankfully, this is about the easiest part of the project to build. Let’s
start by writing an HTTP server with a handler for our PNG file, and make that
handler return an empty body.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> axum::{
</span></span><span><span>    body::{Body, Bytes},
</span></span><span><span>    http::StatusCode,
</span></span><span><span>    response::Response,
</span></span><span><span>    routing::get,
</span></span><span><span>    Router,
</span></span><span><span>};
</span></span><span><span><span>use</span> tokio::net::TcpListener;
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> app <span>=</span> Router::new().route(<span>&#34;/stops.png&#34;</span>, get(handle_stops_png));
</span></span><span><span>
</span></span><span><span>    <span>let</span> listener <span>=</span> TcpListener::bind(<span>&amp;</span><span>&#34;0.0.0.0:3001&#34;</span>).<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    eprintln!(<span>&#34;Visit http://localhost:3001/stops.png&#34;</span>);
</span></span><span><span>
</span></span><span><span>    axum::serve(listener, app.into_make_service()).<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>async</span> <span>fn</span> <span>handle_stops_png</span>() -&gt; <span>Response</span><span>&lt;</span>Body<span>&gt;</span> {
</span></span><span><span>    Response::builder()
</span></span><span><span>        .status(StatusCode::<span>OK</span>)
</span></span><span><span>        .header(<span>&#34;Content-Type&#34;</span>, <span>&#34;image/png&#34;</span>)
</span></span><span><span>        .body(Body::from(Bytes::from(<span>&amp;</span>[])))
</span></span><span><span>        .unwrap()
</span></span><span><span>}
</span></span></code></pre></div><p>Running this server with <code>cargo run</code> and visiting
<code>http://localhost:3001/stops.png</code> in your browser won’t return any content, but
it should respond with a HTTP 200. Now let’s connect our HTTP server with the
image generation code. We need to make some subtle changes to that code so that
image data gets passed around in memory instead of being written to a file.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>..</span>.
</span></span><span><span>
</span></span><span><span><span>async</span> <span>fn</span> <span>handle_stops_png</span>() -&gt; <span>Response</span><span>&lt;</span>Body<span>&gt;</span> {
</span></span><span><span>    Response::builder()
</span></span><span><span>        .status(StatusCode::<span>OK</span>)
</span></span><span><span>        .header(<span>&#34;Content-Type&#34;</span>, <span>&#34;image/png&#34;</span>)
</span></span><span><span>        .body(Body::from(Bytes::from(get_image().<span>await</span>.unwrap())))
</span></span><span><span>        .unwrap()
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// This used to be the `main` function when the program was just saving images
</span></span></span><span><span><span>// to disk, notice that the return type has changed
</span></span></span><span><span><span></span><span>async</span> <span>fn</span> <span>get_image</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>Vec<span>&lt;</span><span>u8</span><span>&gt;&gt;</span> {
</span></span><span><span>    <span>let</span> response_txt <span>=</span> <span>match</span> std::fs::read_to_string(<span>&#34;data.json&#34;</span>) {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>let</span> png_bytes <span>=</span> draw_image(directions_to_lines_destinations_to_journeys)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    Ok(png_bytes)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Notice that the return type of this function has changed
</span></span></span><span><span><span></span><span>fn</span> <span>draw_image</span>(
</span></span><span><span>    directions_to_lines_destinations_to_journeys: <span>HashMap</span><span>&lt;</span>
</span></span><span><span>        String,
</span></span><span><span>        HashMap<span>&lt;</span>(String, String), Vec<span>&lt;</span>MonitoredVehicleJourney<span>&gt;&gt;</span>,
</span></span><span><span>    <span>&gt;</span>,
</span></span><span><span>) -&gt; <span>eyre</span>::Result<span>&lt;</span>Vec<span>&lt;</span><span>u8</span><span>&gt;&gt;</span> {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>let</span> png_bytes <span>=</span> png.as_bytes();
</span></span><span><span>
</span></span><span><span>    <span>// Recall that previously these bytes were written to a file instead of
</span></span></span><span><span><span></span>    <span>// being returned from the function.
</span></span></span><span><span><span></span>    Ok(png_bytes.to_owned())
</span></span><span><span>}
</span></span></code></pre></div><p>If we run this server and visit the image page in our browser, we should see our
beautiful schedule!</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-04.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-04.png" alt="screenshot of a web browser showing the previous schedule image"/></a></p><p>If we try to display this on our Kindle by fetching it via <code>wget</code> and displaying
it via <code>eips</code>, we’ll be disappointed to see that the image is rotated and cut
off. Of course the Kindle is designed to be held in portrait orientation, so we
need to manually rotate our image to landscape orientation if we want it to
display correctly. This can be done by applying a rotation matrix before we
begin drawing.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> <span>mut</span> bitmap <span>=</span> Bitmap::new();
</span></span><span><span>ensure!(bitmap.set_info(
</span></span><span><span>    <span>// Notice that the dimensions we&#39;re using for width and height have been flipped here
</span></span></span><span><span><span></span>    <span>&amp;</span>ImageInfo::new((<span>758</span>, <span>1024</span>), ColorType::Gray8, AlphaType::Unknown, None),
</span></span><span><span>    None
</span></span><span><span>));
</span></span><span><span>bitmap.alloc_pixels();
</span></span><span><span>
</span></span><span><span><span>let</span> canvas <span>=</span> Canvas::from_bitmap(<span>&amp;</span>bitmap, None).ok_or(eyre!(<span>&#34;skia canvas&#34;</span>))<span>?</span>;
</span></span><span><span><span>// The point we&#39;re rotating around is (width/2, width/2)
</span></span></span><span><span><span></span>canvas.rotate(<span>90.0</span>, Some(Point::new(<span>379.0</span>, <span>379.0</span>)));
</span></span></code></pre></div><p>This should return a rotated image that displays correctly on the Kindle.
Images in the rest of this post will be displayed in landscape orientation for
ease of viewing.</p><p>Now that we have something that works end-to-end, let’s improve the layout of
our schedule a bit.</p><div><div><p>We now have an HTTP server that can render upcoming transit arrival times in a format that our Kindle can digest. It&#39;s important to recognize that the project is perfectly usable as it is right now (if you remove the &#34;cache all the data forever&#34; bit), and all of the further work that we&#39;re going to look at is <em>enhancement</em>. Something doesn&#39;t need to be beautiful to be functional, but it is nice when things are beautiful.</p></div></div><p>Now our schedule may be, strictly speaking, usable. But it’s not what I’d call
beautiful. Despite our spacing efforts, text can still overlay each other, and
the most important things don’t look the most important. Let’s start by doing
something that sounds simple (but actually isn’t). Let’s put the Line ID in a
nice little bubble so that it stands out.</p><p>We’re going to do this by first making a helper function that can tell us how
big a given piece of text is expected to be, based on the font and the paint
that we’re going to use to render it.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> skia_safe::{
</span></span><span><span>    utils::text_utils::Align, AlphaType, Bitmap, Canvas, Color4f, ColorType, Font, FontMgr,
</span></span><span><span>    FontStyle, ImageInfo, Paint, Rect,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>..</span>.
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>text_bounds</span>(text: <span>&amp;</span><span>str</span>, (x, y): (<span>f32</span>, <span>f32</span>), font: <span>&amp;</span><span>Font</span>, paint: <span>&amp;</span><span>Paint</span>) -&gt; <span>Rect</span> {
</span></span><span><span>    <span>let</span> (text_width, text_measurements) <span>=</span> font.measure_str(text, Some(paint));
</span></span><span><span>    <span>// It took me a few tries to figure out exactly how to make use of the
</span></span></span><span><span><span></span>    <span>// `measure_str` method, but this gives us a bounding box on the exact size
</span></span></span><span><span><span></span>    <span>// of whatever text we input.
</span></span></span><span><span><span></span>    Rect::new(x, y <span>+</span> text_measurements.top, x <span>+</span> text_width, y)
</span></span><span><span>}
</span></span></code></pre></div><p>Next, we’ll use this method to draw a rounded rectangle, slightly larger than
the line ID.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>..</span>.
</span></span><span><span><span>fn</span> <span>draw_image</span>(
</span></span><span><span>    directions_to_lines_destinations_to_journeys: <span>HashMap</span><span>&lt;</span>
</span></span><span><span>        String,
</span></span><span><span>        HashMap<span>&lt;</span>(String, String), Vec<span>&lt;</span>MonitoredVehicleJourney<span>&gt;&gt;</span>,
</span></span><span><span>    <span>&gt;</span>,
</span></span><span><span>) -&gt; <span>eyre</span>::Result<span>&lt;</span>Vec<span>&lt;</span><span>u8</span><span>&gt;&gt;</span> {
</span></span><span><span>    <span>..</span>.
</span></span><span><span>    <span>let</span> black_paint <span>=</span> Paint::new(Color4f::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>1.0</span>), None);
</span></span><span><span>    <span>// We need a new paint, since we want our bubble to be a light grey color so
</span></span></span><span><span><span></span>    <span>// that it shows up behind the black text
</span></span></span><span><span><span></span>    <span>let</span> line_id_bubble_paint <span>=</span> Paint::new(Color4f::new(<span>0.8</span>, <span>0.8</span>, <span>0.8</span>, <span>1.0</span>), None);
</span></span><span><span>
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>let</span> draw_times <span>=</span> <span>|..</span>.<span>|</span> {
</span></span><span><span>        <span>for</span> ((line_id, destination), journeys) <span>in</span> lines_destinations_to_journeys {
</span></span><span><span>            <span>let</span> bounds <span>=</span> text_bounds(
</span></span><span><span>                line_id,
</span></span><span><span>                (x1 <span>+</span> <span>20.0</span>, y),
</span></span><span><span>                <span>&amp;</span>font,
</span></span><span><span>                <span>&amp;</span>line_id_bubble_paint,
</span></span><span><span>            )
</span></span><span><span>            .with_outset((<span>8.0</span>, <span>8.0</span>));
</span></span><span><span>            canvas.draw_round_rect(bounds, <span>24.0</span>, <span>24.0</span>, <span>&amp;</span>line_id_bubble_paint);
</span></span><span><span>            canvas.draw_str(line_id, (x1 <span>+</span> <span>20.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>            <span>..</span>.
</span></span><span><span>        }
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>..</span>.
</span></span><span><span>}
</span></span></code></pre></div><p>Also, now that we know the exact X-coordinate where our Line ID (and associated
bubble) will end, we can use this to place the destination string with exactly
15 pixels of padding room.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>canvas.draw_str(destination, (bounds.right <span>+</span> <span>15.0</span>, y), <span>&amp;</span>font, <span>&amp;</span>black_paint);
</span></span></code></pre></div><p>These two small changes produce something that already looks leagues better.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-05.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-05.png" alt="display with two columns, with rows in each column for transit lines. each row displays a line id inside of a light grey bubble, followed by a destination name, followed by next arrival times. line ids and destinations are left-aligned, arrival times are right-aligned and all of the row ids are vertically aligned with each other row-to-row, and all the times are aligned. it doesn’t really look like a spreadsheet anymore"/></a></p><p>The last change that we’ll look at in detail here is to add column headers to
the page.</p><p>We’ll accomplish this by drawing a light grey rectangle at the top of the page,
then writing our column IDs inside the two halves of that rectangle,
center-aligned. We’ll also need to adjust the starting value for <code>y</code> in our
<code>draw_times</code> function to <code>60.0</code> to compensate for the new top of the image.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>..</span>.
</span></span><span><span><span>let</span> width <span>=</span> <span>1024.0</span>;
</span></span><span><span><span>let</span> height <span>=</span> <span>758.0</span>;
</span></span><span><span><span>let</span> midpoint <span>=</span> <span>512.0</span>;
</span></span><span><span>
</span></span><span><span>canvas.draw_rect(Rect::new(<span>0.0</span>, <span>0.0</span>, width, <span>30.0</span>), <span>&amp;</span>line_id_bubble_paint);
</span></span><span><span>canvas.draw_str_align(
</span></span><span><span>    <span>&#34;Muni Inbound&#34;</span>,
</span></span><span><span>    (midpoint <span>/</span> <span>2.0</span>, <span>23.0</span>),
</span></span><span><span>    <span>&amp;</span>font,
</span></span><span><span>    <span>&amp;</span>black_paint,
</span></span><span><span>    Align::Center,
</span></span><span><span>);
</span></span><span><span>canvas.draw_str_align(
</span></span><span><span>    <span>&#34;Muni Outbound&#34;</span>,
</span></span><span><span>    (midpoint <span>+</span> midpoint <span>/</span> <span>2.0</span>, <span>23.0</span>),
</span></span><span><span>    <span>&amp;</span>font,
</span></span><span><span>    <span>&amp;</span>black_paint,
</span></span><span><span>    Align::Center,
</span></span><span><span>);
</span></span><span><span>canvas.draw_line((<span>0.0</span>, <span>30.0</span>), (width, <span>30.0</span>), <span>&amp;</span>black_paint);
</span></span><span><span>
</span></span><span><span>draw_times(inbound_journeys, <span>0.0</span>, midpoint);
</span></span><span><span><span>..</span>.
</span></span></code></pre></div><p>Running this now, we get something that looks (I think) quite serviceable.</p><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/render-06.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/render-06.png" alt="display with two columns with a header row. the left column is labeled “Muni Inbound” and the right column is labeled “Muni Outbound”. There are rows in each column for transit lines. each row displays a line id inside of a light grey bubble, followed by a destination name, followed by next arrival times. line ids and destinations are left-aligned, arrival times are right-aligned and all of the row ids are vertically aligned with each other row-to-row, and all the times are aligned."/></a></p><p>I did do more refinements after this, but I’m not going to discuss them in
detail in this blog post.</p><p>Now that we have the image sorted, making a deployable version of this server is
just a matter of removing the “cache the data forever” code that’s at the top of
the HTTP handler.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>async</span> <span>fn</span> <span>get_image</span>() -&gt; <span>eyre</span>::Result<span>&lt;</span>Vec<span>&lt;</span><span>u8</span><span>&gt;&gt;</span> {
</span></span><span><span>    <span>let</span> client <span>=</span> Client::new();
</span></span><span><span>
</span></span><span><span>    <span>let</span> response_txt <span>=</span> client.get(<span>&#34;http://api.511.org/transit/StopMonitoring?api_key=[your_key]&amp;agency=SF&#34;</span>).send().<span>await</span><span>?</span>.text().<span>await</span><span>?</span>;
</span></span><span><span>    <span>let</span> response: <span>StopMonitoringResponse</span> <span>=</span> serde_json::from_str(<span>&amp;</span>response_txt)<span>?</span>;
</span></span><span><span>    <span>..</span>.
</span></span><span><span>}
</span></span></code></pre></div><p>And that’s all I’m gonna cover in this one! This is the longest blog post I’ve
ever written (it’s longer than some of the chapters of <a href="https://lilymara.xyz/posts/refactoring-to-rust/">my
book</a>!). This project has been
in flight for a very long time. The BART-screenshot-powered version of this
Kindle project was working around February of 2023, and I put the final UI
polish on the Rust rewrite in January 2024. There are a few things that I didn’t
cover in here because it just seemed like the post was getting long enough as it
is:</p><ul><li>The caching system that fetched API data continuously in the background so
that the HTTP server is very fast</li><li>Extra pieces of the UI - time in the lower left corner and data cache status
in the lower right corner</li><li>Anti-aliasing</li><li>Cutting off destination names if they stretch into the arrival time area so
the strings don’t overlap (with gradient!)</li><li>Setting different grey colors for each of the lines so that they can be
slightly more quickly distinguished</li><li>Making the whole thing config file driven</li><li>Error-handling - the real version of the server will return a PNG file
displaying the error and it’s <code>.source()</code> chain, so that it’s clearly
visible on the Kindle</li></ul><p>Something that might not be obvious to people that haven’t done this kind of
writing is that you basically have to re-do the project in slow motion when you
write a post like this (unless you’re writing the blog post as you’re
prototyping, but I wouldn’t recommend that). The steps that we took in building
up the UI were different than the steps that I took when building it myself,
because it took me a while to figure out the right way to do things. Here are
some of the intermediate states that I took when building the UI, along with the
final current state.</p><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-01.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-01.png" alt="a two-column schedule, with very oblong, off-center, and too-dark bubbles around each of the line IDs"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-02.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-02.png" alt="a two-column schedule, with rounded rectangle light grey bubbles around line IDs, column headers, and a footer displaying the time"/></a></p></div><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-03.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-03.png" alt="two-column schedule, with antialiased bubbles around line IDs, column headers, and a footer displaying the time and text reading “data age 79 min”"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-04.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-04.png" alt="two-column schedule, with bubbles of different grey shades for line IDs"/></a></p></div><div><p><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-05.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-05.png" alt="two-column schedule, with destination name text that appears to fade behind the arrival times if it is too long, and a footer that displays the time and the word “MUNI” followed by a check mark"/>
</a><a href="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-06.png"><img src="https://lilymara.xyz/posts/2024/01/transit-kindle/unified-06.png" alt="two-column schedule, with shorter destination name text"/></a></p></div><p>The final (simplified) code for the server we built together is on my github
<a href="https://github.com/lily-mara/transit-kindle-simplified">here</a>, and the server
that I actually use to power the Kindle on my wall is
<a href="https://github.com/lily-mara/transit-kindle">here</a>. Thanks for reading!</p><div><div><p>Writing this post was a lot of work. I don&#39;t have any tracking, sponsorships, or (real) ads on this website. I just write because I like sharing things with people. If you liked this blog post and you&#39;d like to show your appreciation, please consider making a donation to <a href="https://translifeline.org">Trans Lifeline</a> or <a href="https://www.eqfl.org">Equality Florida</a>. The country is <a href="https://www.erininthemorning.com/p/erins-anti-trans-risk-map-early-legislative">scary</a> right now for trans people, with Florida (and more recently Utah) passing some of the more draconian laws.</p></div></div></section><p><open-heart href="https://corazon.sploot.com?id=https%3a%2f%2flilymara.xyz%2fposts%2f2024%2f01%2ftransit-kindle%2f" emoji="❤️">💖</open-heart></p><div><div><p>I don&#39;t have a comment box on this website on purpose, but I&#39;d be happy to hear your feedback or questions if you
<a href="mailto:blog@lilymara.xyz?subject=RE%3A%20Never%20Missing%20the%20Train%20Again%2c%20Thanks%20to%20Rust">send me an email</a>.</p></div></div></article></div></div>
  </body>
</html>
