<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boinkor.net/2023/07/tsnsrv-or-easily-accessing-services-on-your-tailscale-network/">Original</a>
    <h1>tsnsrv, or easily accessing services on your tailscale network</h1>
    
    <div id="readability-page-1" class="page"><div id="layout">
    


    <div>
        <div>
            
            <div>
                
                <section>
                    
                    
                    <div>
                        <p>Like many people on the internet, I recently saw <a href="https://tailscale.dev/blog/tsup-tsnet">this great
talk</a> by <a href="https://xeiaso.net/">Xe
Iaso</a> about things you can do on your Tailscale
network with the <a href="https://pkg.go.dev/tailscale.com/tsnet"><code>tsnet</code></a> package. It got me wondering what more I
could do with tailscale myself. Then, three days later, I noticed that
my <a href="https://us.kobobooks.com/products/kobo-sage">Kobo e-reader</a> had stopped syncing with <a href="https://github.com/janeczku/calibre-web">calibre-web</a> and I knew
something about how I accessed my homelab-hosted services would have
to change.</p>
<h2 id="what-i-had-working-before">What I had working before</h2>
<p>I run about 10 services that are important to my personal life:
home-assistant, calibre-web are examples of that; all of them live on
machines that I run, and are accessible only on my private
network. That used to be a weird OpenVPN-based monstrosity, but these
days it’s all done via <a href="https://tailscale.com/">tailscale</a>, a
wireguard-based service that gets your computers (and only your
computers) talking to each other really quickly &amp; easily.</p>
<p>Those services each had a hostname under a domain, say
<code>home-assistant.ts.example.com</code>, and I ran an nginx instance that
serves as a <a href="https://www.nginx.com/resources/glossary/reverse-proxy-server/">reverse proxy</a>.</p>
<p>I’d had most of that configured with a 100kB nginx.conf file that <a href="https://search.nixos.org/options?channel=23.05&amp;show=services.nginx.virtualHosts&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=services.nginx.virtualHosts">nix
mercifully generates for
me</a>,
and that nginx server was exposed to my tailnet by having nginx listen
on the tailscale-internal <code>100.</code> IP address (and that address alone).</p>
<p>So there were a few problems:</p>
<ul>
<li>I want to share some of these services with my partner, but not all
of these services. There are no access controls outside some manual
jank (<a href="https://github.com/antifuchs/htpasswd-login/">see</a>).</li>
<li>Some services really don’t expect to be run behind a reverse proxy
that buffers requests&amp;responses, like nginx does in a <code>server</code>
block. You can use <code>stream</code> blocks for some, but not all features I
need for all the services I run are supported there.</li>
<li>All this was serviced by a letsencrypt certificate for
<code>ts.example.com</code>, with tons of SubjectAltNames, which caused
letsencrypt to email me about every name combination that ever got
one issued, every time a certificate expires. That’s kinda a very
tiny problem, but <a href="https://twitter.com/alicegoldfuss/status/681541049823567877">ugh</a>.</li>
<li>Configuring services to listen on the tailnet-internal address is
great until you reboot the machine: The tailscale interface often
would take an arbitrary amount of time to come up, and there was no
good way to wait until tailscale was “up”… so nginx would croak on
startup and had to be manually kicked (occasionally retries got it
working automatically, and those were good days).</li>
<li>And most importantly, it was ~impossible to teach the Kobo reader
and calibre-web to connect to the port I had to listening on the
internet for its external syncing service (8443, which for some
reason the Kobo URL parser drops? From the URL?!).</li>
</ul>
<p>Ok, so most things kinda worked, and that would be good enough for
many! But knowing what I know now felt itchy: that you can easily
build a reverse proxy that exposes services on your own tailscale
network, and fix most, if not all, of these issues.</p>
<h2 id="enter-tsnsrv">Enter tsnsrv</h2>
<p><a href="https://github.com/antifuchs/tsnsrv"><code>tsnsrv</code></a> is a small reverse proxy (using
golang’s
<a href="https://pkg.go.dev/net/http/httputil@go1.20.5#ReverseProxy"><code>httputil.ReverseProxy</code></a>),
which uses the <a href="https://pkg.go.dev/tailscale.com/tsnet"><code>tsnet</code></a> library to do the cool things Xe does in the
talk linked above. That is:</p>
<ul>
<li>Each service being proxied gets its own tailnet “machine” entry,
which (in combination with ACL tags) allows very fine-grained
control over who gets access to what services.</li>
<li>Go’s ReverseProxy streams the request and response bodies, no more
buffers that need their size adjusted or spilled to disk if I upload
or download large files, e.g. in <a href="https://docspell.org/">docspell</a>.</li>
<li>Tailscale manages the hostname and its TLS certificate
automatically, which also means I don’t get email about
potentially-expiring certs.</li>
<li>There is literally no inter-service dependency. My local services
listen on 127.0.0.1 (or a Unix domain socket!), and tsnsrv brings up
its own tailnet-internal IP address, one per service.</li>
<li>And best of all, it’s possible to run a tailscale funnel endpoint on
the standard HTTPS port (443) which means my Kobo reader can sync
with calibre-web again, without gross hacks. Joy.</li>
</ul>
<h2 id="how-does-that-work">How does that work?</h2>
<p><a href="https://github.com/antifuchs/tsnsrv"><code>tsnsrv</code></a> is a little go program; each of its processes uses the
<a href="https://pkg.go.dev/tailscale.com/tsnet"><code>tsnet</code></a> library to register itself as a node on my tailscale
network. Each of those nodes gets its own wireguard key, a hostname
provisioned under my <code>ts.net</code> subdomain, and each of those hostnames
gets a TLS cert provisioned, too. Some services (notably <a href="https://github.com/janeczku/calibre-web">calibre-web</a>
sync) need exposure to the public internet via the <a href="https://tailscale.com/kb/1223/tailscale-funnel/">tailscale funnel</a>,
so it also supports registering with as a funnel service.</p>
<p>But mostly, I use this to run services that only authorized people
should reach (namely me and not all the 5.07 billion people on the
internet)!</p>
<p>And thanks to the ability to define ACLs for accessing each of these
“tailnet machines”, even the other people on my tailnet (my partner,
my parents, etc) can reach only exactly the services that they need…
And not, say, my internal alertmanager, where they could accidentally
silence an alarm.</p>
<h2 id="why-not-traefik-or-caddy-they-ship-something-similar">Why not traefik or caddy? They ship something similar!</h2>
<p>This setup differs slightly from other systems like <a href="https://caddyserver.com/docs/caddyfile/directives/tls#tailscale">Caddy</a> and
<a href="https://doc.traefik.io/traefik/master/https/tailscale/">Traefik</a>, in that it leans heavily on the “machine = one service”
idea. With Traefik, there’s only really one “service”, traefik, and it
proxies to all your other services, likely under a subpath of your
URL. That’s great until you try to use a service that doesn’t love
being served under a subpath. Same for Caddy - the two proxies seem to
use tailscale mostly for automatic TLS cert provisioning, and for
providing a hostname (that of the server running the proxy).</p>
<p>So, with these services it’s no ACLs for you (other than “all or
nothing” based on the server running the services), no convenient
hostnames and occasionally, no service at all because whatever you’re
running expects to own the entire URL path and not just a
subdirectory.</p>
<p>tsnsrv instead, in the easiest case, is is a single commandline,
<code>tsnsrv -name happy-computer http://127.0.0.1:8000</code> and then you point
your browser at <code>https://happy-computer.example-example.ts.net</code> -
done.</p>
<p>If that sounds intriguing to you, definitely watch Xe’s <a href="https://tailscale.dev/blog/tsup-tsnet">great
talk</a> for more cool ideas on
what to do on the tailnet, and maybe give <a href="https://github.com/antifuchs/tsnsrv">tsnsrv</a> a spin?</p>
                    </div>
                    
                </section>
            </div>
            


        </div>
    </div>
</div></div>
  </body>
</html>
