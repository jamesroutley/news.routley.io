<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hirrolot.github.io/posts/how-to-keep-lambda-calculus-simple.html">Original</a>
    <h1>How to keep lambda calculus simple</h1>
    
    <div id="readability-page-1" class="page"><div><a href="#the-original-implementation"><h2 id="the-original-implementation">The original implementation</h2></a><p>Let us start with the AST definitions. Terms are represented as
follows <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p><div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>ITerm</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Ann</span> <span>CTerm</span> <span>Type</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Bound</span> <span>Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Free</span> <span>Name</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>ITerm</span> <span>:@:</span> <span>CTerm</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>CTerm</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Inf</span> <span>ITerm</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Lam</span> <span>CTerm</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Name</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Global</span> <span>String</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Local</span> <span>Int</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Quote</span> <span>Int</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Type</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>TFree</span> <span>Name</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Fun</span> <span>Type</span> <span>Type</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span></code></pre></div><p>So we have <code>ITerm</code> and <code>CTerm</code> denoting
<em>inferrable</em> and <em>checkable</em> terms, respectively. This
distinction stems from the type checking approach taken by the paper,
which is called <em>bidirectional type checking</em>. More about it
later. For now, just focus on the data constructors, which are pretty
self-explanatory; the only curious cases are <code>Ann</code> and
<code>Inf</code>, but let us ignore them as well for a moment.</p><p>We distinguish two kinds of variables: <code>Bound</code> variables
and <code>Free</code> ones. The first kind of variables is called <a href="https://en.wikipedia.org/wiki/De_Bruijn_index"><em>De Bruijn
indices</em></a>: each bound variable is a natural number (starting from
zero) that designates the number of binders between itself and a
corresponding binder. For example, the term
<code>\x -&gt; \y -&gt; x</code> (the “K combinator”) is represented as
<code>\_ -&gt; \_ -&gt; 1</code>. (If we were returning <code>y</code>
instead of <code>x</code>, we would write <code>0</code> instead.)</p><p>The second kind of variables can divide into three subkinds:
<code>Global</code>, <code>Local</code> and <code>Quote</code>. Global
variables are represented as strings and should not possess any
surprises; the two other kinds will become clearer later.</p><p>Now, terms must evaluate to something. Evaluated terms are called
<em>values</em>:</p><div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Value</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>VLam</span> (<span>Value</span> <span>-&gt;</span> <span>Value</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>VNeutral</span> <span>Neutral</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Neutral</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>NFree</span> <span>Name</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>NApp</span> <span>Neutral</span> <span>Value</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span>vfree ::</span> <span>Name</span> <span>-&gt;</span> <span>Value</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>vfree n <span>=</span> <span>VNeutral</span> (<span>NFree</span> n)</span></code></pre></div><p>Values are either fully evaluated lambda abstractions
<code>VLam</code> or neutral terms <code>VNeutral</code>. Lambda
abstractions are represented as Haskell functions; you can say that you
are using <em>Higher-Order Abstract Syntax</em> as a <em>semantic
domain</em> here to assert self-dominance. Neutral terms are
computations blocked by a variable whose value is unknown: for example,
if we apply some value <code>brrr</code> to a variable <code>x</code>,
we will obtain <code>NApp (NFree $ Global &#34;x&#34;) brrr</code>. This is what
people call <em>open evaluation</em>, that is, evaluation that can
account for free variables.</p><p>The evaluation algorithm itself:</p><div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Env</span> <span>=</span> [<span>Value</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>NameEnv</span> v <span>=</span> [(<span>Name</span>, v)]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>iEval ::</span> <span>ITerm</span> <span>-&gt;</span> (<span>NameEnv</span> <span>Value</span>, <span>Env</span>) <span>-&gt;</span> <span>Value</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>iEval (<span>Ann</span> e _) d <span>=</span> cEval e d</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>iEval (<span>Free</span> x) d <span>=</span> <span>case</span> <span>lookup</span> x (<span>fst</span> d) <span>of</span> <span>Nothing</span> <span>-&gt;</span> (vfree x); <span>Just</span> v <span>-&gt;</span> v</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>iEval (<span>Bound</span> ii) d <span>=</span> (<span>snd</span> d) <span>!!</span> ii</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>iEval (e1 <span>:@:</span> e2) d <span>=</span> vapp (iEval e1 d) (cEval e2 d)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>vapp ::</span> <span>Value</span> <span>-&gt;</span> <span>Value</span> <span>-&gt;</span> <span>Value</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>vapp (<span>VLam</span> f) v <span>=</span> f v</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>vapp (<span>VNeutral</span> n) v <span>=</span> <span>VNeutral</span> (<span>NApp</span> n v)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span>cEval ::</span> <span>CTerm</span> <span>-&gt;</span> (<span>NameEnv</span> <span>Value</span>, <span>Env</span>) <span>-&gt;</span> <span>Value</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>cEval (<span>Inf</span> ii) d <span>=</span> iEval ii d</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>cEval (<span>Lam</span> e) d <span>=</span> <span>VLam</span> (\x <span>-&gt;</span> cEval e (((\(e, d) <span>-&gt;</span> (e, (x <span>:</span> d))) d)))</span></code></pre></div><p>Since we have two kinds of terms, the evaluation function is divided
into two kinds as well. Here is a case-by-case explanation of the
algorithm:</p><ol type="1">
<li><code>iEval (Ann e _) d</code>: this rule just pushes evaluation to
the checkable term <code>e</code>.</li>
<li><code>iEval (Free x) d</code>: if we can find the free variable
<code>x</code> in the environment of free variables <code>fst d</code>,
we return its value; otherwise, we return a neutral value
<code>vfree x</code>.</li>
<li><code>iEval (Bound ii) d</code>: we return the value of the bound
variable <code>ii</code> from the environment of bound variables
<code>snd d</code>. The nice trick here is that the <em>i</em>-th
position within <code>Env</code> corresponds to the value of the
variable <em>i</em> (i.e., the environment is De
Bruijn-<em>indexed</em>), so the ridiculously ugly operator
<code>!!</code> is enough.</li>
<li><code>iEval (e1 :@: e2) d</code>: we evaluate the two terms and hand
them to <code>vapp</code>. In <code>vapp</code>, if the first value is
<code>VLam</code>, we just apply the second value to it; otherwise, we
return a neutral value <code>VNeutral (NApp n v)</code>.</li>
<li><code>cEval (Inf ii) d</code>: as with <code>Ann</code>, we just
push evaluation to the inferrable term <code>ii</code>.</li>
<li><code>cEval (Lam e) d</code>: we return a Haskell function as an
evaluated lambda abstraction. In it, we accept <code>x</code> as an
evaluated argument. Our job within the function is to evaluate the body
<code>e</code> in an environment extended with <code>x</code>. Since
<code>Env</code> indices are De Bruijn indices, and the De Bruijn index
of <code>x</code> is <code>0</code>, we extend the environment of bound
variables with <code>x</code> by prepending it. Once we are done with
that, we evaluate the body <code>e</code> in the new environment of
bound variables.</li>
</ol><p>To be able to see the result of evaluation, we need a mechanism for
printing values. Since Haskell cannot derive <code>Show</code> for
<code>VLam (Value -&gt; Value)</code>, we need to implement the
mechanism on our own. The approach taken in the paper is to define a
conversion function <code>quote</code> that takes a value back to a
(printable) term:</p><div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>quote0 ::</span> <span>Value</span> <span>-&gt;</span> <span>CTerm</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>quote0 <span>=</span> quote <span>0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>quote ::</span> <span>Int</span> <span>-&gt;</span> <span>Value</span> <span>-&gt;</span> <span>CTerm</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>quote ii (<span>VLam</span> f) <span>=</span> <span>Lam</span> (quote (ii <span>+</span> <span>1</span>) (f (vfree (<span>Quote</span> ii))))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>quote ii (<span>VNeutral</span> n) <span>=</span> <span>Inf</span> (neutralQuote ii n)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span>neutralQuote ::</span> <span>Int</span> <span>-&gt;</span> <span>Neutral</span> <span>-&gt;</span> <span>ITerm</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>neutralQuote ii (<span>NFree</span> x) <span>=</span> boundfree ii x</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>neutralQuote ii (<span>NApp</span> n v) <span>=</span> neutralQuote ii n <span>:@:</span> quote ii v</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span>boundfree ::</span> <span>Int</span> <span>-&gt;</span> <span>Name</span> <span>-&gt;</span> <span>ITerm</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>boundfree ii (<span>Quote</span> k) <span>=</span> <span>Bound</span> (ii <span>-</span> k <span>-</span> <span>1</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>boundfree ii x <span>=</span> <span>Free</span> x</span></code></pre></div><p><code>quote</code> takes 1) a natural number (starting from zero) of
binders that have been passed so far, and 2) a value to be converted to
a term. Again, here is a case-by-case explanation:</p><ol type="1">
<li><code>quote ii (VLam f)</code>: this is where the <code>Quote</code>
constructor is used: we apply <code>f</code> to
<code>vfree (Quote ii)</code>, recursively <code>quote</code> the result
of the substitution on a new level <code>ii + 1</code>, and wrap it in
<code>Lam</code>. <code>Quote ii</code> is effectively a De Bruijn
<em>level</em> <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>: if it occurs somewhere in
<code>f (vfree (Quote ii))</code>, we will convert it to a proper bound
variable.</li>
<li><code>quote ii (VNeutral n)</code>: we push the conversion to
<code>neutralQuote</code>:
<ol type="1">
<li><code>neutralQuote ii (NFree x)</code>: in <code>boundfree</code>,
1) if <code>x</code> is a <code>Quote k</code> variable (that has been
applied to <code>f</code> while converting <code>VLam f</code>), then we
can convert it to a <code>Bound</code> variable using the formula
<code>ii - k - 1</code>. By doing so, we essentially convert a De Bruijn
<em>level</em> <code>k</code> to a proper De Bruijn <em>index</em>. 2)
If <code>x</code> is any other kind of a variable, we just return it
without changes.</li>
<li><code>neutralQuote ii (NApp n v)</code>: nothing interesting here;
we just push the conversion to <code>neutralQuote</code> and
<code>quote</code> recursively.</li>
</ol></li>
</ol><p>To see how it works, take our lovely K combinator as an example:</p><ol type="1">
<li><code>quote 0 (VLam (\x -&gt; VLam (\y -&gt; x)))</code></li>
<li><code>Lam (quote 1 (VLam (\y -&gt; vfree (Quote 0))))</code></li>
<li><code>Lam (Lam (quote 2 (vfree (Quote 0))))</code></li>
<li><code>Lam (Lam (neutralQuote 2 (NFree (Quote 0))))</code></li>
<li><code>Lam (Lam (Bound 1))</code></li>
</ol><p>Finally, let us move on to type checking. The type and data
definitions are:</p><div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Context</span> <span>=</span> [(<span>Name</span>, <span>Info</span>)]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Info</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>HasKind</span> <span>Kind</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>HasType</span> <span>Type</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Kind</span> <span>=</span> <span>Star</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Result</span> a <span>=</span> <span>Either</span> <span>String</span> a</span></code></pre></div><p><code>Context</code> is a list containing typing information
<code>Info</code> about every free variable in a term that we want to
type-check:</p><ul>
<li><code>HasKind Star</code> means that a variable is a type
variable.</li>
<li><code>HasType ty</code> means that a variable is a term variable of
the type <code>ty</code>.</li>
</ul><p><code>Result</code> is just the <code>Either</code> monad with
<code>String</code> used as the error type.</p><p>The type checking algorithm is defined as follows <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p><div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>cKind ::</span> <span>Context</span> <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Kind</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>cKind g (<span>TFree</span> x) <span>Star</span> <span>=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x g <span>of</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasKind</span> <span>Star</span>) <span>-&gt;</span> <span>return</span> ()</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>cKind g (<span>Fun</span> kk kk&#39;) <span>Star</span> <span>=</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    cKind g kk <span>Star</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    cKind g kk&#39; <span>Star</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span>iType0 ::</span> <span>Context</span> <span>-&gt;</span> <span>ITerm</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>iType0 <span>=</span> iType <span>0</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span>iType ::</span> <span>Int</span> <span>-&gt;</span> <span>Context</span> <span>-&gt;</span> <span>ITerm</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>iType ii g (<span>Ann</span> e ty) <span>=</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    cKind g ty <span>Star</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    cType ii g e ty</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span>return</span> ty</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>iType ii g (<span>Free</span> x) <span>=</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x g <span>of</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasType</span> ty) <span>-&gt;</span> <span>return</span> ty</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>iType ii g (e1 <span>:@:</span> e2) <span>=</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    si <span>&lt;-</span> iType ii g e1</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span>case</span> si <span>of</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>      <span>Fun</span> ty ty&#39; <span>-&gt;</span> <span>do</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        cType ii g e2 ty</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span>return</span> ty&#39;</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>      _ <span>-&gt;</span> throwError <span>&#34;illegal application&#34;</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span>cType ::</span> <span>Int</span> <span>-&gt;</span> <span>Context</span> <span>-&gt;</span> <span>CTerm</span> <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>cType ii g (<span>Inf</span> e) ty <span>=</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    ty&#39; <span>&lt;-</span> iType ii g e</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    unless (ty <span>==</span> ty&#39;) (throwError <span>&#34;type mismatch&#34;</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>cType ii g (<span>Lam</span> e) (<span>Fun</span> ty ty&#39;) <span>=</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>  cType</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    (ii <span>+</span> <span>1</span>)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    ((<span>Local</span> ii, <span>HasType</span> ty) <span>:</span> g)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    (cSubst <span>0</span> (<span>Free</span> (<span>Local</span> ii)) e)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    ty&#39;</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>cType ii g _ _ <span>=</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>  throwError <span>&#34;type mismatch&#34;</span></span></code></pre></div><p><code>cKind</code> checks that a given type is well-formed in a given
context. In <code>cKind g (TFree x) Star</code>, if we can find the
variable <code>x</code> in the context <code>g</code>, and it is a type
variable, then we return <code>()</code>. If there is no such variable
in the context, we throw an error. The algorithm, for some reason, does
not consider the case when the variable exists but is not a type
variable, so this function is partial. The second case is
uninteresting.</p><p>Then two functions follow, <code>iType</code> and <code>cType</code>.
They are the reason why we separated the representation of terms into
inferrable and checkable: while certain terms can be inferred
(variables, applications, and type annotations), some can only be
checked (lambda abstractions and <code>Inf</code>) <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p><p>To type-check such a language, we employ <em>bidirectional type
checking</em>. In detail, we have the function <code>iType</code> that
<em>infers</em> a type of a term and <code>cType</code> that checks a
term against a given type. These functions are mutually recursive:
whenever <code>iType</code> needs to check a term, it calls
<code>cType</code>, and vice versa.</p><p>The cases of <code>iType</code> just encode the corresponding rules
of a simply typed lambda calculus. This function is partial as well, now
for two reasons: 1) the case <code>iType ii g (Free x)</code> does not
consider the scenario when the variable is present but is not a term
variable, and 2) <code>iType</code> does not handle <code>Bound</code>
variables at all.</p><p>The only interesting case of <code>cType</code> is
<code>cType ii g (Lam e) (Fun ty ty&#39;)</code>. To check a lambda
abstraction, we manually substitute all references to the binder with
<code>(Free (Local ii))</code> – again, this is a De Bruijn
<em>level</em>; then we check the body <code>e</code> in the context
<code>g</code> extended with <code>(Local ii, HasType ty)</code>. If the
binder is referred somewhere in the body <code>e</code>, we will
encounter it in the case <code>iType ii g (Free x)</code>.</p><p>Here are the definitions of <code>iSubst</code> and
<code>cSubst</code>:</p><div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>iSubst ::</span> <span>Int</span> <span>-&gt;</span> <span>ITerm</span> <span>-&gt;</span> <span>ITerm</span> <span>-&gt;</span> <span>ITerm</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>iSubst ii r (<span>Ann</span> e ty) <span>=</span> <span>Ann</span> (cSubst ii r e) ty</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>iSubst ii r (<span>Bound</span> j) <span>=</span> <span>if</span> ii <span>==</span> j <span>then</span> r <span>else</span> <span>Bound</span> j</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>iSubst ii r (<span>Free</span> y) <span>=</span> <span>Free</span> y</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>iSubst ii r (e1 <span>:@:</span> e2) <span>=</span> iSubst ii r e1 <span>:@:</span> cSubst ii r e2</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span>cSubst ::</span> <span>Int</span> <span>-&gt;</span> <span>ITerm</span> <span>-&gt;</span> <span>CTerm</span> <span>-&gt;</span> <span>CTerm</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>cSubst ii r (<span>Inf</span> e) <span>=</span> <span>Inf</span> (iSubst ii r e)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>cSubst ii r (<span>Lam</span> e) <span>=</span> <span>Lam</span> (cSubst (ii <span>+</span> <span>1</span>) r e)</span></code></pre></div><p>The function is pretty boring: all it does is just substituting a
selected <code>Bound</code> variable for <code>ITerm</code>. In fact, we
have already seen substitution happening in <code>iEval</code>; the
difference is that now we do not have the opportunity to mimick
substitution with a native Haskell function application, because the
syntax of terms is first-order (it does not represent lambda
abstractions in terms of Haskell functions).</p><p>Let us complete the section with some examples:</p><div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>id&#39; <span>=</span> <span>Lam</span> (<span>Inf</span> (<span>Bound</span> <span>0</span>))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>const&#39; <span>=</span> <span>Lam</span> (<span>Lam</span> (<span>Inf</span> (<span>Bound</span> <span>1</span>)))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>tfree a <span>=</span> <span>TFree</span> (<span>Global</span> a)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>free x <span>=</span> <span>Inf</span> (<span>Free</span> (<span>Global</span> x))</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>term1 <span>=</span> <span>Ann</span> id&#39; (<span>Fun</span> (tfree <span>&#34;a&#34;</span>) (tfree <span>&#34;a&#34;</span>)) <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>term2 <span>=</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span>Ann</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    const&#39;</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    ( <span>Fun</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        ( <span>Fun</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            (tfree <span>&#34;a&#34;</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> id&#39;</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>env1 <span>=</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  [ (<span>Global</span> <span>&#34;y&#34;</span>, <span>HasType</span> (tfree <span>&#34;a&#34;</span>)),</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    (<span>Global</span> <span>&#34;a&#34;</span>, <span>HasKind</span> <span>Star</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>env2 <span>=</span> [(<span>Global</span> <span>&#34;b&#34;</span>, <span>HasKind</span> <span>Star</span>)] <span>++</span> env1</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span>-- Inf (Free (Global &#34;y&#34;))</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>test_eval1 <span>=</span> quote0 (iEval term1 ([], []))</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span>-- Lam (Inf (Bound 0))</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>test_eval2 <span>=</span> quote0 (iEval term2 ([], []))</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span>-- Right (TFree (Global &#34;a&#34;))</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>test_type1 <span>=</span> iType0 env1 term1</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span>-- Right (Fun (TFree (Global &#34;b&#34;)) (TFree (Global &#34;b&#34;)))</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>test_type2 <span>=</span> iType0 env2 term2</span></code></pre></div><a href="#the-first-alternative-higher-order-style"><h2 id="the-first-alternative-higher-order-style">The first alternative,
higher-order style</h2></a><p>“We pick an implementation that allows us to follow the type system
closely, and that reduces the amount of technical overhead to a relative
minimum, so that we can concentrate on the essence of the algorithms
involved.” – I simply cannot agree with this statement from the
paper.</p><p>Let us enumerate all the naming schemes used in the original
implementation:</p><ul>
<li>De Bruijn indices <code>Bound</code>;</li>
<li>De Bruijn levels <code>Local</code> for type checking;</li>
<li>De Bruijn levels <code>Quote</code> for quoting;</li>
<li>Named variables <code>Global</code>;</li>
<li>Higher-Order Abstract Syntax <code>VLam</code>.</li>
</ul><p>And yet, with all this machinery at our disposal, we still need to
implement substitution manually. This is somewhat sad.</p><p>So let us think about how to simplify the implementation.
<code>iSubst</code> and <code>cSubst</code> give us a useful hint: we
basically implement substitution <em>algorithmically</em>, whereas in
the evaluation and quoting code, we can just apply a Haskell function
<code>f</code> to a (value) argument to achieve similar behaviour. An
obvious desire would be to employ the same technique for terms, thereby
making them <a href="https://cstheory.stackexchange.com/a/20075"><em>higher-order</em></a>.</p><p>Our decision leads to several consequences:</p><ul>
<li>Since terms and values will now use the same representation of
functions, there is no need to distinguish between them <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</li>
<li><code>Bound</code> variables can be removed from the representation,
since Haskell is now in charge of substitution.</li>
<li><code>quote</code> can be removed, since we now only have
terms.</li>
<li><code>Quote</code> variables can be removed, since there is no
quoting now.</li>
<li>Terms will no longer derive <code>Show</code> and <code>Eq</code>
automatically, since Haskell cannot print functional values. We will
have to implement printing manually.</li>
<li><code>eval</code> will only take an environment of <code>Free</code>
variables, since Haskell is now in charge of substitution.</li>
<li><code>iSubst</code> and <code>cSubst</code> can be removed, since
terms are now higher-order.</li>
</ul><p>Also, let us erase the distinction between checkable and inferrable
terms. The choice to separate them avoids one <code>throwError</code> in
the type checker at the expense of requiring us to separate every single
function acting on terms into two functions: <code>iEval</code> and
<code>cEval</code>, <code>iSubst</code> and <code>cSubst</code>, and
etc., although these functions do not really care about the distinction.
Let us be pragmatic instead of being smart.</p><p>The new data definitions are:</p><div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Term</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Ann</span> <span>Term</span> <span>Type</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Free</span> <span>Name</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Term</span> <span>:@:</span> <span>Term</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Lam</span> (<span>Term</span> <span>-&gt;</span> <span>Term</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Name</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Global</span> <span>String</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Local</span> <span>Int</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Type</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>TFree</span> <span>Name</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Fun</span> <span>Type</span> <span>Type</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>)</span></code></pre></div><p>The key change is that <code>Lam</code> is now a Haskell function
<code>Term -&gt; Term</code>. The <code>eval</code> algorithm is now
even simpler:</p><div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>eval ::</span> <span>Term</span> <span>-&gt;</span> <span>NameEnv</span> <span>Term</span> <span>-&gt;</span> <span>Term</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>eval (<span>Ann</span> e _) env <span>=</span> eval e env</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>eval (<span>Free</span> x) env <span>=</span> <span>case</span> <span>lookup</span> x env <span>of</span> <span>Nothing</span> <span>-&gt;</span> <span>Free</span> x; <span>Just</span> v <span>-&gt;</span> v</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>eval (e1 <span>:@:</span> e2) env <span>=</span> vapp (eval e1 env) (eval e2 env)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>eval (<span>Lam</span> f) env <span>=</span> <span>Lam</span> (\x <span>-&gt;</span> eval (f x) env)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>vapp ::</span> <span>Term</span> <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Term</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>vapp (<span>Lam</span> f) v <span>=</span> f v</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>vapp e1 e2 <span>=</span> e1 <span>:@:</span> e2</span></code></pre></div><p>Notice how we evaluate <code>Lam f</code>: we return a new
<code>Lam</code> that accepts a value <code>x</code> as an argument,
invokes native Haskell substitution <code>f x</code>, and evaluates the
expansion in the same environment of global variables.</p><p>The data definitions for type checking are the same. The type checker
is now:</p><div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>cKind ::</span> <span>Context</span> <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Kind</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>cKind g (<span>TFree</span> x) <span>Star</span> <span>=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x g <span>of</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasKind</span> <span>Star</span>) <span>-&gt;</span> <span>return</span> ()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>cKind g (<span>Fun</span> kk kk&#39;) <span>Star</span> <span>=</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    cKind g kk <span>Star</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    cKind g kk&#39; <span>Star</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span>iType0 ::</span> <span>Context</span> <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>iType0 <span>=</span> iType <span>0</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span>iType ::</span> <span>Int</span> <span>-&gt;</span> <span>Context</span> <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>iType ii g (<span>Ann</span> e ty) <span>=</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    cKind g ty <span>Star</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    cType ii g e ty</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span>return</span> ty</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>iType _ g (<span>Free</span> x) <span>=</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x g <span>of</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasType</span> ty) <span>-&gt;</span> <span>return</span> ty</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>iType ii g (e1 <span>:@:</span> e2) <span>=</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    si <span>&lt;-</span> iType ii g e1</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span>case</span> si <span>of</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>      <span>Fun</span> ty ty&#39; <span>-&gt;</span> <span>do</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        cType ii g e2 ty</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        <span>return</span> ty&#39;</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>      _ <span>-&gt;</span> throwError <span>&#34;illegal application&#34;</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>iType _ _ (<span>Lam</span> _) <span>=</span> throwError <span>&#34;not inferrable&#34;</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span>cType ::</span> <span>Int</span> <span>-&gt;</span> <span>Context</span> <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>cType ii g (<span>Lam</span> f) (<span>Fun</span> ty ty&#39;) <span>=</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>  cType</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    (ii <span>+</span> <span>1</span>)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    ((<span>Local</span> ii, <span>HasType</span> ty) <span>:</span> g)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    (f (<span>Free</span> (<span>Local</span> ii)))</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    ty&#39;</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>cType _ _ (<span>Lam</span> _) _ <span>=</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>  throwError <span>&#34;expected a function type&#34;</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>cType ii g e ty <span>=</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    ty&#39; <span>&lt;-</span> iType ii g e</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    unless (ty <span>==</span> ty&#39;) (throwError <span>&#34;type mismatch&#34;</span>)</span></code></pre></div><p>The key change here is that instead of calling <code>cSubst</code> in
<code>cType</code>, we just apply <code>f</code> to
<code>Free (Local ii)</code>. This is possible because <code>f</code> is
now a Haskell function. Also, we can throw the error
<code>&#34;not inferrable&#34;</code> in <code>iType</code> if we are asked to
infer <code>Lam</code>.</p><p>Finally, we need a way to print terms. “As we mentioned earlier, the
use of higher-order abstract syntax requires us to define a
<em>quote</em> function that takes a <code>Value</code> back to a term.”
– this is not true. Of course, quoting to a printable term is a way to
go, but it is not the only option. Instead, we can derive
<code>Show</code> for <code>Term</code> ourselves:</p><div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Show</span> <span>Term</span> <span>where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span>show</span> <span>=</span> go <span>0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      go ii (<span>Ann</span> e ty) <span>=</span> <span>&#34;(&#34;</span> <span>++</span> go ii e <span>++</span> <span>&#34; : &#34;</span> <span>++</span> <span>show</span> ty <span>++</span> <span>&#34;)&#34;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      go _ (<span>Free</span> x) <span>=</span> <span>show</span> x</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      go ii (e1 <span>:@:</span> e2) <span>=</span> <span>&#34;(&#34;</span> <span>++</span> go ii e1 <span>++</span> <span>&#34; &#34;</span> <span>++</span> go ii e2 <span>++</span> <span>&#34;)&#34;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      go ii (<span>Lam</span> f) <span>=</span> <span>&#34;(λ. &#34;</span> <span>++</span> go (ii <span>+</span> <span>1</span>) (f (<span>Free</span> (<span>Local</span> ii))) <span>++</span> <span>&#34;)&#34;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Show</span> <span>Type</span> <span>where</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span>show</span> (<span>TFree</span> x) <span>=</span> <span>show</span> x</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span>show</span> (<span>Fun</span> ty ty&#39;) <span>=</span> <span>&#34;(&#34;</span> <span>++</span> <span>show</span> ty <span>++</span> <span>&#34; -&gt; &#34;</span> <span>++</span> <span>show</span> ty&#39; <span>++</span> <span>&#34;)&#34;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Show</span> <span>Name</span> <span>where</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span>show</span> (<span>Global</span> x) <span>=</span> x</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span>show</span> (<span>Local</span> ii) <span>=</span> <span>show</span> ii</span></code></pre></div><p>Let us test our new implementation:</p><div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>id&#39; <span>=</span> <span>Lam</span> (\x <span>-&gt;</span> x)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>const&#39; <span>=</span> <span>Lam</span> (\x <span>-&gt;</span> <span>Lam</span> (\_ <span>-&gt;</span> x))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>tfree a <span>=</span> <span>TFree</span> (<span>Global</span> a)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>free x <span>=</span> <span>Free</span> (<span>Global</span> x)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>term1 <span>=</span> <span>Ann</span> id&#39; (<span>Fun</span> (tfree <span>&#34;a&#34;</span>) (tfree <span>&#34;a&#34;</span>)) <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>term2 <span>=</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span>Ann</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    const&#39;</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    ( <span>Fun</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        ( <span>Fun</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>            (tfree <span>&#34;a&#34;</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> id&#39;</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>env1 <span>=</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>  [ (<span>Global</span> <span>&#34;y&#34;</span>, <span>HasType</span> (tfree <span>&#34;a&#34;</span>)),</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    (<span>Global</span> <span>&#34;a&#34;</span>, <span>HasKind</span> <span>Star</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>env2 <span>=</span> [(<span>Global</span> <span>&#34;b&#34;</span>, <span>HasKind</span> <span>Star</span>)] <span>++</span> env1</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span>-- (((λ. 0) : (a -&gt; a)) y)</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>test_id_show <span>=</span> <span>show</span> term1</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span>-- ((((λ. (λ. 0)) : ((b -&gt; b) -&gt; (a -&gt; (b -&gt; b)))) (λ. 0)) y)</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>test_const_show <span>=</span> <span>show</span> term2</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span>-- y</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>test_eval1 <span>=</span> <span>show</span> (eval term1 [])</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span>-- (λ. 0)</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>test_eval2 <span>=</span> <span>show</span> (eval term2 [])</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span>-- Right a</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>test_type1 <span>=</span> <span>show</span> (iType0 env1 term1)</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a><span>-- Right (b -&gt; b)</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>test_type2 <span>=</span> <span>show</span> (iType0 env2 term2)</span></code></pre></div><p>All in all, our new implementation uses only three naming schemes:
higher-order <code>Lam</code>, <code>Global</code> variables, and De
Bruijn levels <code>Local</code>. We could also remove global variables
and use <code>Local</code> instead, but this would make the examples
less readable.</p><a href="#the-second-alternative-first-order-style"><h2 id="the-second-alternative-first-order-style">The second
alternative, first-order style</h2></a><p>Perhaps surprisingly, we can use a first-order <a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>
encoding for both terms and values without implementing substitution by
term traversal. The trick is to use De Bruijn <em>indices</em> for terms
and De Bruijn <em>levels</em> for values:</p><div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Term</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Ann</span> <span>Term</span> <span>Type</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Bound</span> <span>Int</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Free</span> <span>Name</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Term</span> <span>:@:</span> <span>Term</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Lam</span> <span>Term</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Name</span> <span>=</span> <span>Global</span> <span>String</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Type</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>TFree</span> <span>Name</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Fun</span> <span>Type</span> <span>Type</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Value</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>VLam</span> <span>Env</span> <span>Term</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>VNeutral</span> <span>Neutral</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Neutral</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>NVar</span> <span>Int</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>NFree</span> <span>Name</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>NApp</span> <span>Neutral</span> <span>Value</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Env</span> <span>=</span> [<span>Value</span>]</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span>vvar ::</span> <span>Int</span> <span>-&gt;</span> <span>Value</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>vvar n <span>=</span> <span>VNeutral</span> (<span>NVar</span> n)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span>vfree ::</span> <span>Name</span> <span>-&gt;</span> <span>Value</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>vfree n <span>=</span> <span>VNeutral</span> (<span>NFree</span> n)</span></code></pre></div><p>The <code>Bound</code> constructor is a De Bruijn index, whereas
<code>NVar</code> is a De Bruijn level. The <code>VLam</code>
constructor is called a <em>closure</em>: a lambda body
<code>Term</code> and an environment <code>Env</code> bundled together.
The <code>Env</code> contains values for all unbound variables in
<code>Term</code>, except for the variable <code>Bound 0</code>, which
is the lambda binder. Later, when we should apply <code>VLam</code> to
some argument <code>v</code>, we will extend the environment with
<code>v</code> by prepending it <a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p><p>Here is the evaluation algorithm:</p><div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>NameEnv</span> v <span>=</span> [(<span>Name</span>, v)]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>eval ::</span> <span>Term</span> <span>-&gt;</span> (<span>NameEnv</span> <span>Value</span>, <span>Env</span>) <span>-&gt;</span> <span>Value</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>eval (<span>Ann</span> e _) d <span>=</span> eval e d</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>eval (<span>Bound</span> ii) d <span>=</span> <span>snd</span> d <span>!!</span> ii</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>eval (<span>Free</span> x) d <span>=</span> <span>case</span> <span>lookup</span> x (<span>fst</span> d) <span>of</span> <span>Nothing</span> <span>-&gt;</span> vfree x; <span>Just</span> v <span>-&gt;</span> v</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>eval (e1 <span>:@:</span> e2) d <span>=</span> vapp (<span>fst</span> d) (eval e1 d) (eval e2 d)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>eval (<span>Lam</span> m) d <span>=</span> <span>VLam</span> (<span>snd</span> d) m</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span>vapp ::</span> <span>NameEnv</span> <span>Value</span> <span>-&gt;</span> <span>Value</span> <span>-&gt;</span> <span>Value</span> <span>-&gt;</span> <span>Value</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>vapp e (<span>VLam</span> d m) v <span>=</span> eval m (e, v <span>:</span> d)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>vapp _ (<span>VNeutral</span> n) v <span>=</span> <span>VNeutral</span> (<span>NApp</span> n v)</span></code></pre></div><p>There are two interesting cases:</p><ol type="1">
<li><code>eval (Lam m) d</code>: we do not perform any evaluation here;
instead, we just construct a lambda value <code>VLam</code> with
unevaluated <code>m</code>. This is in contrast with the two previous
implementations, where we called <code>eval</code> under a
<code>VLam</code> binder.</li>
<li><code>vapp e (VLam d m) v</code>: we prepend <code>d</code> with
<code>v</code> and continue evaluating <code>m</code>; since
<code>d</code> must contain values for all free variables of
<code>m</code> except <code>Bound 0</code>, <code>v : d</code> will
contain values for <em>all</em> free variables in <code>m</code>,
including <code>Bound 0</code>.</li>
</ol><p>Since we have the term-value separation again, we can implement
<code>quote</code> <a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a>:</p><div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>quote0 ::</span> <span>Value</span> <span>-&gt;</span> <span>Term</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>quote0 <span>=</span> quote [] <span>0</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span>quote ::</span> <span>NameEnv</span> <span>Value</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Value</span> <span>-&gt;</span> <span>Term</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>quote e ii (<span>VLam</span> d m) <span>=</span> <span>Lam</span> (quote e (ii <span>+</span> <span>1</span>) (eval m (e, vvar ii <span>:</span> d)))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>quote e ii (<span>VNeutral</span> n) <span>=</span> neutralQuote e ii n</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span>neutralQuote ::</span> <span>NameEnv</span> <span>Value</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Neutral</span> <span>-&gt;</span> <span>Term</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>neutralQuote _ ii (<span>NVar</span> i) <span>=</span> <span>Bound</span> (ii <span>-</span> i <span>-</span> <span>1</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>neutralQuote _ _ (<span>NFree</span> x) <span>=</span> <span>Free</span> x</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>neutralQuote e ii (<span>NApp</span> n v) <span>=</span> neutralQuote e ii n <span>:@:</span> quote e ii v</span></code></pre></div><p>To quote <code>VLam d m</code>, we first evaluate <code>m</code> in
the environment <code>d</code> extended with <code>vvar ii</code>, which
is a neutral variable corresponding to the current De Bruijn level
<code>ii</code>. Here, <code>vvar ii</code> stands as an argument whose
value is unknown. If, during the evaluation of <code>m</code>, we should
see that it refers to <code>Bound 0</code>, we will replace
<code>Bound 0</code> with <code>vvar ii</code> we have just added to the
environment. We then continue with quoting the evaluated <code>m</code>
under the next level <code>ii + 1</code>. Finally, we wrap the result in
<code>Lam</code>.</p><p>The data definitions for type checking are:</p><div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>GlobalContext</span> <span>=</span> [(<span>Name</span>, <span>Info</span>)]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Context</span> <span>=</span> [<span>Type</span>]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Info</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>HasKind</span> <span>Kind</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>HasType</span> <span>Type</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Kind</span> <span>=</span> <span>Star</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Result</span> a <span>=</span> <span>Either</span> <span>String</span> a</span></code></pre></div><p>In addition to <code>Info</code>, <code>Kind</code>, and
<code>Result</code> we have already seen, we introduce
<code>GlobalContext</code> and <code>Context</code>.
<code>GlobalContext</code> is a list associating names of global
variables to their <code>Info</code>, whereas <code>Context</code> is a
De Bruijn-indexed list of types of bound variables. <code>Context</code>
can only associate <em>term</em> variables to their types; it cannot
contain any information about <em>type</em> variables, since we are only
dealing with <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simple
types</a>.</p><p>The type checking algorithm is:</p><div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>cKind ::</span> (<span>GlobalContext</span>, <span>Context</span>) <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Kind</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>cKind g (<span>TFree</span> x) <span>Star</span> <span>=</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x (<span>fst</span> g) <span>of</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasKind</span> <span>Star</span>) <span>-&gt;</span> <span>return</span> ()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>cKind g (<span>Fun</span> kk kk&#39;) <span>Star</span> <span>=</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    cKind g kk <span>Star</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    cKind g kk&#39; <span>Star</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span>iType0 ::</span> <span>GlobalContext</span> <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>iType0 g <span>=</span> iType <span>0</span> (g, [])</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span>iType ::</span> <span>Int</span> <span>-&gt;</span> (<span>GlobalContext</span>, <span>Context</span>) <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Result</span> <span>Type</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>iType ii g (<span>Ann</span> e ty) <span>=</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    cKind g ty <span>Star</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    cType ii g e ty</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span>return</span> ty</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>iType _ g (<span>Bound</span> i) <span>=</span> <span>return</span> (<span>snd</span> g <span>!!</span> i)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>iType _ g (<span>Free</span> x) <span>=</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>lookup</span> x (<span>fst</span> g) <span>of</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span>Just</span> (<span>HasType</span> ty) <span>-&gt;</span> <span>return</span> ty</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span>Nothing</span> <span>-&gt;</span> throwError <span>&#34;unknown identifier&#34;</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>iType ii g (e1 <span>:@:</span> e2) <span>=</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    si <span>&lt;-</span> iType ii g e1</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span>case</span> si <span>of</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>      <span>Fun</span> ty ty&#39; <span>-&gt;</span> <span>do</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>        cType ii g e2 ty</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        <span>return</span> ty&#39;</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>      _ <span>-&gt;</span> throwError <span>&#34;illegal application&#34;</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>iType _ _ (<span>Lam</span> _) <span>=</span> throwError <span>&#34;not inferrable&#34;</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span>cType ::</span> <span>Int</span> <span>-&gt;</span> (<span>GlobalContext</span>, <span>Context</span>) <span>-&gt;</span> <span>Term</span> <span>-&gt;</span> <span>Type</span> <span>-&gt;</span> <span>Result</span> ()</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>cType ii g (<span>Lam</span> m) (<span>Fun</span> ty ty&#39;) <span>=</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>  cType (ii <span>+</span> <span>1</span>) (<span>fst</span> g, ty <span>:</span> <span>snd</span> g) m ty&#39;</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>cType _ _ (<span>Lam</span> _) _ <span>=</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>  throwError <span>&#34;expected a function type&#34;</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>cType ii g e ty <span>=</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>  <span>do</span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    ty&#39; <span>&lt;-</span> iType ii g e</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    unless (ty <span>==</span> ty&#39;) (throwError <span>&#34;type mismatch&#34;</span>)</span></code></pre></div><p>The interesting cases are:</p><ol type="1">
<li><code>iType _ g (Bound i)</code>: we index (<code>!!</code>) the
context of bound variables <code>snd g</code> with <code>i</code>. As a
result, we obtain the type of <code>Bound i</code>.</li>
<li><code>cType ii g (Lam m) (Fun ty ty&#39;)</code>: we check the lambda
body <code>m</code> against <code>ty&#39;</code> in an extended context of
bound variables <code>ty : snd g</code>. The old context
<code>snd g</code> is extended with <code>ty</code> because
<code>Bound 0</code> must have the type <code>ty</code>.</li>
</ol><p>As usual, let us test our implementation:</p><div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>id&#39; <span>=</span> <span>Lam</span> (<span>Bound</span> <span>0</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>const&#39; <span>=</span> <span>Lam</span> (<span>Lam</span> (<span>Bound</span> <span>1</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>tfree a <span>=</span> <span>TFree</span> (<span>Global</span> a)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>free x <span>=</span> <span>Free</span> (<span>Global</span> x)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>term1 <span>=</span> <span>Ann</span> id&#39; (<span>Fun</span> (tfree <span>&#34;a&#34;</span>) (tfree <span>&#34;a&#34;</span>)) <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>term2 <span>=</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span>Ann</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    const&#39;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    ( <span>Fun</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        ( <span>Fun</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>            (tfree <span>&#34;a&#34;</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>            (<span>Fun</span> (tfree <span>&#34;b&#34;</span>) (tfree <span>&#34;b&#34;</span>))</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> id&#39;</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    <span>:@:</span> free <span>&#34;y&#34;</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>env1 <span>=</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>  [ (<span>Global</span> <span>&#34;y&#34;</span>, <span>HasType</span> (tfree <span>&#34;a&#34;</span>)),</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    (<span>Global</span> <span>&#34;a&#34;</span>, <span>HasKind</span> <span>Star</span>)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>env2 <span>=</span> [(<span>Global</span> <span>&#34;b&#34;</span>, <span>HasKind</span> <span>Star</span>)] <span>++</span> env1</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span>-- Free (Global &#34;y&#34;)</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>test_eval1 <span>=</span> quote0 (eval term1 ([], []))</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span>-- Lam (Bound 0)</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>test_eval2 <span>=</span> quote0 (eval term2 ([], []))</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span>-- Right (TFree (Global &#34;a&#34;))</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>test_type1 <span>=</span> iType0 env1 term1</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span>-- Right (Fun (TFree (Global &#34;b&#34;)) (TFree (Global &#34;b&#34;)))</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>test_type2 <span>=</span> iType0 env2 term2</span></code></pre></div><p>The approach we have taken here is called <em>Normalization by
Evaluation</em>, abbreviated as <em>NbE</em>. Over time, it has become a
standard way of implementing dependent type theories, as it is both
reasonably efficient and easy to implement. An interested reader can
find more information from these sources:</p><ul>
<li><a href="https://github.com/AndrasKovacs/elaboration-zoo">AndrasKovacs/elaboration-zoo</a>
András Kovács.</li>
<li><a href="https://davidchristiansen.dk/tutorials/implementing-types-hs.pdf">“Checking
Dependent Types with Normalization by Evaluation: A Tutorial (Haskell
Version)”</a> by David Thrane Christiansen.</li>
</ul><a href="#final-words"><h2 id="final-words">Final words</h2></a><p>We have not touched dependent types – all our discussion was limited
to simply typed lambda calculus. Although dependent types are a bit more
interesting with respect to type checking, the general idea behind
naming schemes remains the same.</p><p>In both approaches I have demonstrated, we could get rid of global
variables, but I have not done that for the sake of readability of the
examples. In the first approach, the essential naming schemes are De
Bruijn indices (terms) and higher-order lambda abstractions (values),
whereas in the second approach, the essential naming schemes are De
Bruijn indices (terms) and De Bruijn levels (values).</p><p>Both approaches are reasonably simple. The downside of the first
approach is that we had to implement printing manually (although it was
not a big deal), whereas the usage examples of the second approach
looked a tad less readable due to De Bruijn indices. The higher-order
approach is typically favoured by eDSL designers, whereas the
first-order approach is predominantly used as an internal representation
of a compiler/interpreter. Since we can transform named variables to De
Bruijn indices automatically, the end user should not notice any
difference.</p><p>If you feel confused about anything, feel free to ask in the
comments.</p><a href="#references"><h2 id="references">References</h2></a></div></div>
  </body>
</html>
