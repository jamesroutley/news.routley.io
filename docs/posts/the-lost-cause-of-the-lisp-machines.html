<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tfeb.org/fragments/2025/11/18/the-lost-cause-of-the-lisp-machines/">Original</a>
    <h1>The lost cause of the Lisp machines</h1>
    
    <div id="readability-page-1" class="page"><div>

        <!-- Main column -->
        <div id="content">





          <article>
  <header>
    
    <p>
<time datetime="2025-11-18" pubdate="true">2025-11-18</time> :: <span><a href="https://www.tfeb.org/fragments/tags/lisp.html">lisp</a>, <a href="https://www.tfeb.org/fragments/tags/stupidity.html">stupidity</a>, <a href="https://www.tfeb.org/fragments/tags/stories.html">stories</a></span></p>
  </header>

<p>I am just really bored by Lisp Machine romantics at this point: they should go away. I expect they never will.</p>
<!-- more-->

<h2 id="history">History</h2>

<p>Symbolics <a href="https://www.latimes.com/archives/la-xpm-1993-02-02-fi-1060-story.html" title="Symbolics Inc. Seeks Chapter 11 Protection">went bankrupt in early 1993</a>. In the way of these things various remnants of the company lingered on for, in this case, decades. But 1983 was when the Lisp Machines died.</p>

<p>The death was not unexpected: by the time I started using mainstream Lisps in 1989<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-1-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-1-return">1</a></sup> everyone knew that special hardware for Lisp was a dead idea. The common idea was that the arrival of RISC machines had killed it, but in fact machines like the Sun 3/260 in its ‘AI’ configuration<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-2-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-2-return">2</a></sup> were already hammering nails in its coffin. In 1987 I read a report showing the Lisp performance of an early RISC machine, using <a href="https://en.wikipedia.org/wiki/Kyoto_Common_Lisp" title="Kyoto Common Lisp">Kyoto Common Lisp</a>, not a famously fast implementation of CL, beating a Symbolics on <a href="https://www.dreamsongs.com/Files/Timrep.pdf" title="Performance and evaluation of Lisp systems">the Gabriel benchmarks</a> [PDF link].</p>

<p>1993 is 32 years ago. The Symbolics 3600, probably the first Lisp machine that sold in more than tiny numbers, was introduced in 1983, ten years earlier. People who used Lisp machines other than as historical artefacts are old today<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-3-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-3-return">3</a></sup>.</p>

<p>Lisp machines were both widely available and offered the best performance for Lisp for a period of about five years which ended nearly forty years ago. They were probably never competitive in terms of performance for the money.</p>

<p>It is time, and long past time, to let them go.</p>

<p>But still the romantics — some of them even old enough to remember the Lisp machines — repeat their myths.</p>

<h2 id="it-was-the-development-environment">‘It was the development environment’</h2>

<p>No, it wasn’t.</p>

<p>The development environments offered by both families of Lisp machines were seriously cool, at least for the 1980s. I mean, they really were very cool indeed. Some of the ways they were cool matter today, but some don’t. For instance in the 1980s and early 1990s Lisp images were very large compared to available memory, and machines were also extremely slow in general. So good Lisp development environents did a lot of work to hide this slowness, and in general making sure you only very seldom had to restart everthing, which took significant fractions of an hour, if not more. None of that matters today, because machines are so quick and Lisps so relatively small.</p>

<p>But that’s not the only way they were cool. They really were just lovely things to use in many ways. But, despite what people might believe: <em>this did not depend on the hardware</em>: there is no reason at all why a development environent that cool could not be built on stock hardware. Perhaps, (perhaps) that was not true in 1990: it is certainly true today.</p>

<p>So if a really cool Lisp development environment doesn’t exist today, it is nothing to do with Lisp machines not existing. In fact, as someone who used Lisp machines, I find the LispWorks development environment at least as comfortable and productive as they were. But, oh no, the full-fat version is not free, and no version is open source. Neither, I remind you, were they.</p>

<h2 id="they-were-much-faster-than-anything-else">‘They were much faster than anything else’</h2>

<p>No, <a href="#history" title="History">they weren’t</a>. Please, stop with that.</p>

<h2 id="the-hardware-was-user-microcodable-you-see">‘The hardware was user-microcodable, you see’</h2>

<p>Please, stop telling me things about <em>machines I used</em>: believe it or not, I know those things.</p>

<p>Many machines were user-microcodable before about 1990. That meant that, technically, a user of the machine could implement their own instruction set. I am sure there are cases where people even did that, and a much smaller number of cases where doing that was not just a waste of time.</p>

<p>But in almost all cases the only people who wrote microcode were the people who built the machine. And the reason they wrote microcode was because it is the easiest way of implementing a very complex instruction set, especially when you can’t use vast numbers of transistors. For instance if you’re going to provide an ‘add’ instruction which will add numbers of any type, trapping back into user code for some cases, then by far the easiest way of doing that is going to be by writing code, not building hardware. And that’s what the Lisp machines did.</p>

<p>Of course, the compiler could have generated that code for hardware without that instruction. But with the special instruction the compiler’s job is much easier, and code is smaller. A small, quick compiler and small compiled code were very important with slow machines which had tiny amounts of memory. Of course a compiler not made of wet string could have used type information to <em>avoid</em> generating the full dispatch case, but wet string was all that was available.</p>

<p>What microcodable machines almost never meant was that users of the machines would write microcode.</p>

<p>At the time, the tradeoffs made by Lisp machines might even have been reasonable. CISC machines in general were probably good compromises given the expense of memory and how rudimentary compilers were: I can remember being horrified at the size of compiled code for RISC machines. But I was horrified because I wasn’t thinking about it properly. Moore’s law was very much in effect in about 1990 and, among other things, it meant that the amount of memory you could afford was rising exponentially with time: the RISC people understood that.</p>

<h2 id="they-were-lisp-all-the-way-down">‘They were Lisp all the way down’</h2>

<p>This, finally, maybe, is a good point. They were, and you could dig around and change things on the fly, and this was pretty cool. Sometimes you could even replicate the things you’d done later. I remember playing with sound on a 3645 which was really only possible because you could get low-level access to the disk from Lisp, as the disk could just marginally provide data fast enough to stream sound.</p>

<p>On the other hand they had no isolation and thus no security at all: people didn’t care about that in 1985, but if I was using a Lisp-based machine today I would certainly be unhappy if my web browser could modify my device drivers on the fly, or poke and peek at network buffers. A machine that was Lisp all the way down today would need to ensure that things like that couldn’t happen.</p>

<p>So may be it would be Lisp all the way down, but you absolutely would not have the kind of ability to poke around in and redefine parts of the guts you had on Lisp machines. Maybe that’s still worth it.</p>

<p>Not to mention that I’m just not very interested in spending a huge amount of time grovelling around in the guts of something like an SSL implementation: those things exist already, and I’d rather do something new and cool. I’d rather do something that Lisp is uniquely suited for, not reinvent wheels. Well, may be that’s just me.</p>

<p>Machines which were Lisp all the way down might, indeed, be interesting, although they could not look like 1980s Lisp machines if they were to be safe. But that does not mean they would need special hardware for Lisp: they wouldn’t. If you want something like this, hardware is not holding you back: there’s no need to endlessly mourn the lost age of Lisp machines, you can start making one now. Shut up and code.</p>

<p>And now we come to the really strange arguments, the arguments that we need special Lisp machines either for reasons which turn out to be straightforwardly false, or because we need something that Lisp machines <em>never were</em>.</p>

<h2 id="good-lisp-compilers-are-too-hard-to-write-for-stock-hardware">‘Good Lisp compilers are too hard to write for stock hardware’</h2>

<p>This mantra is getting old.</p>

<p>The most important thing is that <em>we have good stock-hardware Lisp compilers today</em>. As an example, today’s CL compilers are not far from CLANG/LLVM for floating-point code. I tested SBCL and LispWorks: it would be interesting to know how many times more work has gone into LLVM than them for such a relatively small improvement. I can’t imagine a world where these two CL compilers would not be at least comparable to LLVM if similar effort was spent on them<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-4-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-4-return">4</a></sup>.</p>

<p>These things are so much better than the wet-cardboard-and-string compilers that the LispMs had it’s not funny.</p>

<p>A large amount of work is also going into compilation for other dynamically-typed, interactive languages which aim at high performance. That means on-the-fly compilation and recompilation of code where both the compilation and the resulting code must be quick. Example: <a href="https://julialang.org/" title="Julia">Julia</a>. Any of that development could be reused by Lisp compiler writers if they needed to or wanted to (I don’t know if they do, or should).</p>

<p>Ah, but then it turns out that that’s not what is meant by a ‘good compiler’ after all. It turns out that ‘good’ means ‘compillation is fast’.</p>

<p>All these compilers are pretty quick: the computational resources used by even a pretty hairy compiler have not scaled anything like as fast as those needed for the problems we want to solve (that’s why Julia can use LLVM on the fly). Compilation is also not an Amdahl bottleneck as it can happen on the node that needs the compiled code.</p>

<p>Compilers are so quick that a widely-used CL implementation exists where EVAL uses the compiler, unless you ask it not to.</p>

<p>Compilation options are also a thing: you can ask compilers to be quick, fussy, sloppy, safe, produce fast code and so on. Some radically modern languages also allow this to be done in a standardised (but extensible) way at the language level, so you can say ‘make this inner loop really quick, and I have checked all the bounds so don’t bother with that’.</p>

<p>The tradeoff between a fast Lisp compiler and a really good Lisp compiler is imaginary, at this point.</p>

<h2 id="they-had-wonderful-keyboards">‘They had wonderful keyboards’</h2>

<p>Well, if you didn’t mind the weird layouts: yes, they did<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-5-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-5-return">5</a></sup>. And has <em>exactly nothing</em> to do with Lisp.</p>

<p>And so it goes on.</p>

<h2 id="bored-now">Bored now</h2>

<p>There’s a well-known syndrome amongst photographers and musicians called GAS: gear acquisition syndrome. Sufferers from this<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-6-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-6-return">6</a></sup> pursue an endless stream of purchases of gear — cameras, guitars, FX pedals, the last long-expired batch of a legendary printing paper — in the strange hope that the next camera, the next pedal, that paper, will bring out the Don McCullin, Jimmy Page or Chris Killip in them. Because, of course, Don McCullin &amp; Chris Killip only took the pictures they did because he had the right cameras: it was nothing to do with talent, practice or courage, no.</p>

<p>GAS is a lie we tell ourselves to avoid the awkward reality that what we actually need to do is <em>practice</em>, a lot, and that even if we did that we might not actually be very talented.</p>

<p>Lisp machine romanticism is the same thing: a wall we build ourself so that, somehow unable to climb over it or knock it down, we never have to face the fact that the only thing stopping us is us.</p>

<p>There is no purpose to arguing with Lisp machine romantics because they will never accept that the person building the endless barriers in their way is the same person they see in the mirror every morning. They’re too busy building the walls.</p>

<hr/>

<p>As a footnote, I went to a talk by an HPC person in the early 90s (so: after the end of the cold war<sup><a href="#2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-7-definition" name="2025-11-18-the-lost-cause-of-the-lisp-machines-footnote-7-return">7</a></sup> and when the HPC money had gone) where they said that HPC people needed to be aiming at machines based on what big commercial systems looked like as nobody was going to fund dedicated HPC designs any more. At the time that meant big cache-coherent SMP systems. Those hit their limits and have really died out now: the bank I worked for had dozens of fully-populated big SMP systems in 2007, it perhaps still has one or two they can’t get rid of because of some legacy application. So HPC people now run on enormous shared-nothing farms of close-to-commodity processors with very fat interconnect and are wondering about / using GPUs. That’s similar to what happened to Lisp systems, of course: perhaps, in the HPC world, there are romantics who mourn the lost glories of the Cray–3. Well, if I was giving a talk to people interested in the possibilities of hardware today I’d be saying that in a few years there are going to be a <em>lot</em> of huge farms of GPUs going very cheap if you can afford the power. People could be looking at whether those can be used for anything more interesting than the huge neural networks they were designed for. I don’t know if they can.</p>

<hr/>


  
</article>
        </div>
      </div></div>
  </body>
</html>
