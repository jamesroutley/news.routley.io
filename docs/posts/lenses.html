<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fpcomplete.com/haskell/tutorial/lens/">Original</a>
    <h1>Lenses</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Firstly, what is lens/lenses/optics?</p>
<ul>
<li>A really great solution to the &#34;records problem&#34;</li>
<li>An almost accidental discover</li>
<li>Ridiculously complicated type level playground</li>
<li>Collections of lots of different related things</li>
<li>The first real subtyping solution in Haskell</li>
<li>A complete language based on Haskell</li>
</ul>
<h2 id="the-records-problem">The records problem</h2>
<p>Imagine a nested data structure:</p>
<pre><code><span>data </span><span>Address </span><span>= </span><span>Address</span><span>
  { addressCity </span><span>:: !</span><span>Text
  </span><span>, addressStreet </span><span>:: !</span><span>Text</span><span>
  }
</span><span>data </span><span>Person </span><span>= </span><span>Person</span><span>
  { personAddress </span><span>:: !</span><span>Address
  </span><span>, personName </span><span>:: !</span><span>Text</span><span>
  }
</span></code></pre>
<p>If you have a value <code>alice :: Person</code>, and you want to get the
person&#39;s city, you can use record accessors as normal functions:</p>
<pre><code><span>getPersonCity </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Text
</span><span>getPersonCity </span><span>=</span><span> addressCity </span><span>.</span><span> personAddress

</span><span>alice&#39;sCity </span><span>:: </span><span>Text
</span><span>alice&#39;sCity </span><span>=</span><span> getPersonCity alice
</span></code></pre>
<p>That&#39;s pretty elegant. But let&#39;s say that you want to change Alice&#39;s
city to something else. In a mutable, object-oriented language, you&#39;d
probably expect something like:</p>
<pre><code><span>alice.address.city = &#34;Los Angeles&#34;;
</span></code></pre>
<p>The first issue in Haskell is that we can&#39;t mutate <code>alice</code>; we instead
have to return a <em>new</em> <code>Person</code> value with the updated city. Type
signature wise, we&#39;d be looking at:</p>
<pre><code><span>setPersonCity </span><span>:: </span><span>Text </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span></code></pre>
<p>That makes sense. Now let&#39;s see how we&#39;d implemente this:</p>
<pre><code><span>import </span><span>Data.Text </span><span>(</span><span>Text</span><span>)

</span><span>data </span><span>Address </span><span>= </span><span>Address</span><span>
  { addressCity </span><span>:: !</span><span>Text
  </span><span>, addressStreet </span><span>:: !</span><span>Text</span><span>
  }
</span><span>data </span><span>Person </span><span>= </span><span>Person</span><span>
  { personAddress </span><span>:: !</span><span>Address
  </span><span>, personName </span><span>:: !</span><span>Text</span><span>
  }

</span><span>getPersonCity </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Text
</span><span>getPersonCity </span><span>=</span><span> addressCity </span><span>.</span><span> personAddress

</span><span>setPersonCity </span><span>:: </span><span>Text </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>setPersonCity city person </span><span>=</span><span> person
  { personAddress </span><span>=</span><span> (personAddress person)
      { addressCity </span><span>=</span><span> city
      }
  }
</span></code></pre>
<p>Well... that obviously sucks. It only gets worse as the nesting levels
go deeper. Let&#39;s look at some ways to make this easier to stomach.</p>
<h2 id="modifier-functions">Modifier functions</h2>
<p>Let&#39;s see if we can make this slightly less painful with some modifier
functions:</p>
<pre><code><span>modifyAddressCity </span><span>::</span><span> (</span><span>Text </span><span>-&gt; </span><span>Text</span><span>) </span><span>-&gt; </span><span>Address </span><span>-&gt; </span><span>Address
</span><span>modifyAddressCity f address </span><span>=</span><span> address
  { addressCity </span><span>=</span><span> f (addressCity address)
  }

</span><span>modifyPersonAddress </span><span>::</span><span> (</span><span>Address </span><span>-&gt; </span><span>Address</span><span>) </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>modifyPersonAddress f person </span><span>=</span><span> person
  { personAddress </span><span>=</span><span> f (personAddress person)
  }

</span><span>modifyPersonCity </span><span>::</span><span> (</span><span>Text </span><span>-&gt; </span><span>Text</span><span>) </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>modifyPersonCity </span><span>=</span><span> modifyPersonAddress </span><span>.</span><span> modifyAddressCity

</span><span>setPersonCity </span><span>:: </span><span>Text </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>setPersonCity city </span><span>=</span><span> modifyPersonCity (const city)
</span></code></pre>
<p>Composing the modifier functions works nicely, and then we can easily
convert a modifier function into a setter function. Writing the
initial modifier functions is tedious, but that&#39;s the price of doing
business.</p>
<p>Another downside is that we&#39;ve totally separated out the getter and
modifier functions. Let&#39;s see if we can combine those.</p>
<h2 id="old-style-lenses">Old style lenses</h2>
<p>If our problem is splitting up the getters and modifiers, let&#39;s just
stick them together.</p>
<pre><code><span>data </span><span>Lens</span><span> s a </span><span>= </span><span>Lens</span><span>
  { lensGetter </span><span>::</span><span> s </span><span>-&gt;</span><span> a
  , lensModify </span><span>::</span><span> (a </span><span>-&gt;</span><span> a) </span><span>-&gt;</span><span> s </span><span>-&gt;</span><span> s
  }
</span></code></pre>
<p>Previously we could compose our getters and modifiers with the good
old <code>.</code> function composition operator, but now we need something a bit
more specialized:</p>
<pre><code><span>composeLens </span><span>:: </span><span>Lens a b </span><span>-&gt; </span><span>Lens b c </span><span>-&gt; </span><span>Lens a c
</span><span>composeLens (</span><span>Lens</span><span> getter1 modify1) (</span><span>Lens</span><span> getter2 modify2) </span><span>= </span><span>Lens</span><span>
  { lensGetter </span><span>=</span><span> getter2 </span><span>.</span><span> getter1
  , lensModify </span><span>=</span><span> modify1 </span><span>.</span><span> modify2
  }
</span></code></pre>
<p>With that in hand, we can write lenses for an address&#39;s city, a
person&#39;s address, put them together, and then easily extract a setter:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>Lens Person Address
</span><span>personAddressL </span><span>= </span><span>Lens</span><span>
  { lensGetter </span><span>=</span><span> personAddress
  , lensModify </span><span>= \</span><span>f person </span><span>-&gt;</span><span> person { personAddress </span><span>=</span><span> f (personAddress person) }
  }

</span><span>addressCityL </span><span>:: </span><span>Lens Address Text
</span><span>addressCityL </span><span>= </span><span>Lens</span><span>
  { lensGetter </span><span>=</span><span> addressCity
  , lensModify </span><span>= \</span><span>f address </span><span>-&gt;</span><span> address { addressCity </span><span>=</span><span> f (addressCity address) }
  }

</span><span>personCityL </span><span>:: </span><span>Lens Person Text
</span><span>personCityL </span><span>=</span><span> personAddressL </span><span>`composeLens`</span><span> addressCityL

</span><span>setPersonCity </span><span>:: </span><span>Text </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>setPersonCity city </span><span>=</span><span> lensModify personCityL (const city)
</span></code></pre>
<p>This works, but it feels clunky. It also has some performance overhead
we didn&#39;t have previously due to the creation of the <code>Lens</code>
values. And a more advanced topic we haven&#39;t even touched on yet: it
doesn&#39;t allow for <em>polymorphic update</em>, which deals with changing type
variables (we won&#39;t deal with that for now).</p>
<h2 id="van-laarhoven-lenses">Van Laarhoven lenses</h2>
<p>In all honesty, understanding exactly how these next forms of lenses
work isn&#39;t strictly necessary. It&#39;s built on the same premise as the
previous kinds of lenses, but it&#39;s:</p>
<ul>
<li>More efficient</li>
<li>More easily composable</li>
<li>Generalizes to other cases</li>
<li>Handles polymorphic updates</li>
<li>Produces much crazier error messages</li>
</ul>
<p>Let&#39;s start slowly in motivating this. Our first goal is to see if we
can combine our getter and modifier into a single value, without using
a product type. We need to be able to extract both a getter and
modifier from this value, so it has to provide the following:</p>
<pre><code><span>type </span><span>Lens</span><span> s a </span><span>= ?

</span><span>view </span><span>:: </span><span>Lens s a </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>a
</span><span>view </span><span>= ?

</span><span>over </span><span>:: </span><span>Lens s a </span><span>-&gt;</span><span> (</span><span>a </span><span>-&gt; </span><span>a</span><span>) </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>s
</span><span>over </span><span>= ?
</span></code></pre>
<p>(Ignore the funny names, they&#39;re part of <code>lens</code>.)</p>
<p>It doesn&#39;t seem like those two output types (<code>s -&gt; a</code> and <code>(a -&gt; a) -&gt; s -&gt; s</code>) have much in common. But we&#39;re going to use a trick to make
them match up. Let&#39;s start with the <code>over</code> result:</p>
<pre><code><span>(a </span><span>-&gt;</span><span> a) </span><span>-&gt;</span><span> (s </span><span>-&gt;</span><span> s)
</span></code></pre>
<p>I&#39;m going to wrap up the results of the two functions inside the
<code>Identity</code> functor:</p>
<pre><code><span>newtype </span><span>Identity</span><span> a </span><span>= </span><span>Identity</span><span> { runIdentity </span><span>::</span><span> a }
  </span><span>deriving </span><span>Functor

</span><span>type </span><span>LensModify</span><span> s a </span><span>=</span><span> (a </span><span>-&gt; </span><span>Identity</span><span> a) </span><span>-&gt;</span><span> (s </span><span>-&gt; </span><span>Identity</span><span> s)

</span><span>over </span><span>:: </span><span>LensModify s a </span><span>-&gt;</span><span> (</span><span>a </span><span>-&gt; </span><span>a</span><span>) </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>s
</span><span>over lens f s </span><span>=</span><span> runIdentity (lens (</span><span>Identity </span><span>.</span><span> f) s)
</span></code></pre>
<p>And we can create values for this lens type with:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>LensModify Person Address
</span><span>personAddressL f person </span><span>= </span><span>Identity </span><span>$</span><span> person
  { personAddress </span><span>=</span><span> runIdentity </span><span>$</span><span> f </span><span>$</span><span> personAddress person
  }
</span></code></pre>
<p>Or, if we want to take advantage of the <code>Functor</code> instance and not
play with wrapping and unwrapping the <code>Identity</code> values, we get:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>LensModify Person Address
</span><span>personAddressL f person </span><span>=</span><span>
      (</span><span>\</span><span>address </span><span>-&gt;</span><span> person { personAddress </span><span>=</span><span> address })
  </span><span>&lt;$&gt;</span><span> f (personAddress person)
</span></code></pre>
<p>Alright, let&#39;s switch over to the getter side. This time around, we
want to start with the same basic <code>(a -&gt; a) -&gt; (s -&gt; s)</code>, but apply a
<em>different</em> wrapper type to allow us to get a getter function at the
end, <code>s -&gt; a</code>. So in other words, we need to be able to convert from
<code>s -&gt; Wrapper s</code> to <code>s -&gt; a</code>. This may seem impossible at first, but
it turns out that there&#39;s a cool trick to make this happen:</p>
<pre><code><span>newtype </span><span>Const</span><span> a b </span><span>= </span><span>Const</span><span> { getConst </span><span>::</span><span> a }
  </span><span>deriving </span><span>Functor

</span><span>type </span><span>LensGetter</span><span> s a </span><span>=</span><span> s </span><span>-&gt; </span><span>Const</span><span> a s

</span><span>view </span><span>:: </span><span>LensGetter s a </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>a
</span><span>view lens s </span><span>=</span><span> getConst (lens s)

</span><span>personAddressL </span><span>:: </span><span>LensGetter Person Address
</span><span>personAddressL person </span><span>= </span><span>Const</span><span> (personAddress person)
</span></code></pre>
<p>This is fairly complex. <code>Const</code> is a data type that does the same
thing as the <code>const</code> function: it holds onto one value and ignores a
second. Here, <code>Const</code> is keeping our <code>Address</code> value for us and
allowing use to extract it inside <code>view</code>. Stare at it a while and it
will make sense, but it&#39;s also just a convoluted way to get to our
goal.</p>
<p>Ultimately, our goal is to make <code>LensGetter</code> and <code>LensModify</code> the same
thing. But right now, they don&#39;t look very similar.</p>
<pre><code><span>type </span><span>LensModify</span><span> s a </span><span>=</span><span> (a </span><span>-&gt; </span><span>Identity</span><span> a) </span><span>-&gt;</span><span> (s </span><span>-&gt; </span><span>Identity</span><span> s)
</span><span>type </span><span>LensGetter</span><span> s a </span><span>=</span><span> s </span><span>-&gt; </span><span>Const</span><span> a s
</span></code></pre>
<p>In order to bring them more inline, we need to redefine <code>LensGetter</code> as:</p>
<pre><code><span>type </span><span>LensGetter</span><span> s a </span><span>=</span><span> (a </span><span>-&gt; </span><span>Const</span><span> a s) </span><span>-&gt;</span><span> (s </span><span>-&gt; </span><span>Const</span><span> a s)
</span></code></pre>
<p>And it turns out by shuffling around some things just a bit, we can
make this work as well:</p>
<pre><code><span>type </span><span>LensGetter</span><span> s a </span><span>=</span><span> (a </span><span>-&gt; </span><span>Const</span><span> a a) </span><span>-&gt;</span><span> (s </span><span>-&gt; </span><span>Const</span><span> a s)

</span><span>view </span><span>:: </span><span>LensGetter s a </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>a
</span><span>view lens s </span><span>=</span><span> getConst (lens </span><span>Const</span><span> s)

</span><span>personAddressL </span><span>:: </span><span>LensGetter Person Address
</span><span>personAddressL f person </span><span>= </span><span>Const </span><span>$</span><span> getConst </span><span>$</span><span> f (personAddress person)
</span></code></pre>
<p>Again, kind of crazy, but it works. Our wrapper type is now <code>Const a</code>,
and we pass in the <code>Const</code> data constructor to the <code>lens</code>. It all
kinda sorta works. One final tweak on all of this. Previously, we
defined our modify lens using the <code>Functor</code> interface so we didn&#39;t
need to know about <code>Identity</code> at all:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>LensModify Person Address
</span><span>personAddressL f person </span><span>=</span><span>
      (</span><span>\</span><span>address </span><span>-&gt;</span><span> person { personAddress </span><span>=</span><span> address })
  </span><span>&lt;$&gt;</span><span> f (personAddress person)
</span></code></pre>
<p>It turns out that this <em>exact same function body</em> works for defining
<code>LensGetter</code>:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>LensGetter Person Address
</span><span>personAddressL f person </span><span>=</span><span>
      (</span><span>\</span><span>address </span><span>-&gt;</span><span> person { personAddress </span><span>=</span><span> address })
  </span><span>&lt;$&gt;</span><span> f (personAddress person)
</span></code></pre>
<p>And now we can finally unify our getter and modify lenses into one:</p>
<pre><code><span>type </span><span>Lens</span><span> s a </span><span>=</span><span> forall f</span><span>. </span><span>Functor</span><span> f </span><span>=&gt;</span><span> (a </span><span>-&gt;</span><span> f a) </span><span>-&gt;</span><span> (s </span><span>-&gt;</span><span> f s)

</span><span>newtype </span><span>Identity</span><span> a </span><span>= </span><span>Identity</span><span> { runIdentity </span><span>::</span><span> a }
  </span><span>deriving </span><span>Functor

</span><span>newtype </span><span>Const</span><span> a b </span><span>= </span><span>Const</span><span> { getConst </span><span>::</span><span> a }
  </span><span>deriving </span><span>Functor

</span><span>over </span><span>:: </span><span>Lens s a </span><span>-&gt;</span><span> (</span><span>a </span><span>-&gt; </span><span>a</span><span>) </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>s
</span><span>over lens f s </span><span>=</span><span> runIdentity (lens (</span><span>Identity </span><span>.</span><span> f) s)

</span><span>view </span><span>:: </span><span>Lens s a </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>a
</span><span>view lens s </span><span>=</span><span> getConst (lens </span><span>Const</span><span> s)

</span><span>personAddressL </span><span>:: </span><span>Lens Person Address
</span><span>personAddressL f person </span><span>=</span><span>
      (</span><span>\</span><span>address </span><span>-&gt;</span><span> person { personAddress </span><span>=</span><span> address })
  </span><span>&lt;$&gt;</span><span> f (personAddress person)

</span><span>getPersonAddress </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Address
</span><span>getPersonAddress </span><span>=</span><span> view personAddressL

</span><span>modifyPersonAddress </span><span>::</span><span> (</span><span>Address </span><span>-&gt; </span><span>Address</span><span>) </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>modifyPersonAddress </span><span>=</span><span> over personAddressL

</span><span>setPersonAddress </span><span>:: </span><span>Address </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>setPersonAddress address </span><span>=</span><span> modifyPersonAddress (const address)
</span></code></pre>
<p>This means that we have a lens if we support <em>all possible functors</em>
in that type signature. It turns out, almost as if by magic, that this
allows us to recapture getter and modifier functions (and via
modifier, setter functions).</p>
<p>The formulation is wonky, and very difficult to grasp. Don&#39;t worry if
the intuition hasn&#39;t kicked in. It turns out that you can use lenses
quite a bit without fully grokking them.</p>
<h2 id="composing-lenses">Composing lenses</h2>
<p>First, let&#39;s define a helper function for turning a getter and a
setter into a lens:</p>
<pre><code><span>lens </span><span>::</span><span> (</span><span>s </span><span>-&gt; </span><span>a</span><span>) </span><span>-&gt;</span><span> (</span><span>s </span><span>-&gt; </span><span>a </span><span>-&gt; </span><span>s</span><span>) </span><span>-&gt; </span><span>Lens s a
</span><span>lens getter setter </span><span>= \</span><span>f s </span><span>-&gt;</span><span> setter s </span><span>&lt;$&gt;</span><span> f (getter s)
</span></code></pre>
<p>Then we can more easily define lenses for <code>person.address</code> and
<code>address.city</code>:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>Lens Person Address
</span><span>personAddressL </span><span>=</span><span> lens personAddress (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { personAddress </span><span>=</span><span> y })

</span><span>addressCityL </span><span>:: </span><span>Lens Address Text
</span><span>addressCityL </span><span>=</span><span> lens addressCity (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { addressCity </span><span>=</span><span> y })
</span></code></pre>
<p>How do we compose them together into the <code>person.address.city</code> lens?
If we expand the type signatures a bit it may become obvious:</p>
<pre><code><span>personAddressL </span><span>:: </span><span>Functor f </span><span>=&gt;</span><span> (</span><span>Address </span><span>-&gt; </span><span>f Address</span><span>) </span><span>-&gt;</span><span> (</span><span>Person </span><span>-&gt; </span><span>f Person</span><span>)
</span><span>addressCityL </span><span>:: </span><span>Functor f </span><span>=&gt;</span><span> (</span><span>Text </span><span>-&gt; </span><span>f Text</span><span>) </span><span>-&gt;</span><span> (</span><span>Address </span><span>-&gt; </span><span>f Address</span><span>)
</span><span>personCityL </span><span>:: </span><span>Functor f </span><span>=&gt;</span><span> (</span><span>Text </span><span>-&gt; </span><span>f Text</span><span>) </span><span>-&gt;</span><span> (</span><span>Person </span><span>-&gt; </span><span>f Person</span><span>)
</span></code></pre>
<p>How would you implement <code>personCityL</code>? Well, turns out to be really
easy:</p>
<pre><code><span>personCityL </span><span>:: </span><span>Lens Person Text
</span><span>personCityL </span><span>=</span><span> personAddressL</span><span>.</span><span>addressCityL
</span></code></pre>
<p>This is a great strength of lenses: <em>they work with normal function
composition</em>. They also work in what Haskellers would consider
<em>backwards</em> order: the composition seems to flow from left to right
instead of right to left. But on the other hand, this seems to match
up perfectly with what object oriented developers expect, so that&#39;s
nice.</p>
<h2 id="helper-functions-and-operators">Helper functions and operators</h2>
<p>Dealing directly with the <code>Lens</code> type is needlessly painful. Instead,
we work through helper functions and operators. You&#39;ve already seen
<code>view</code>, <code>over</code>, and <code>lens</code>. Let&#39;s implement a few more:</p>
<pre><code><span>(^</span><span>.</span><span>) </span><span>::</span><span> s </span><span>-&gt; </span><span>Lens</span><span> s a </span><span>-&gt;</span><span> a
s ^</span><span>.</span><span> lens </span><span>=</span><span> view lens s

</span><span>infixl </span><span>8</span><span> ^</span><span>.</span><span>

(</span><span>%~</span><span>) </span><span>:: </span><span>Lens</span><span> s a </span><span>-&gt;</span><span> (a </span><span>-&gt;</span><span> a) </span><span>-&gt;</span><span> s </span><span>-&gt;</span><span> s
(</span><span>%~</span><span>) </span><span>=</span><span> over

</span><span>infixr </span><span>4 </span><span>%~

</span><span>reverseCity </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>reverseCity </span><span>=</span><span> personAddressL</span><span>.</span><span>addressCityL </span><span>%~ </span><span>T</span><span>.</span><span>reverse

</span><span>getCity </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Text
</span><span>getCity person </span><span>=</span><span> person ^</span><span>.</span><span> personAddressL</span><span>.</span><span>addressCityL

</span><span>set </span><span>:: </span><span>Lens s a </span><span>-&gt; </span><span>a </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>s
</span><span>set lens a s </span><span>=</span><span> runIdentity </span><span>$</span><span> lens (</span><span>\</span><span>_olda </span><span>-&gt; </span><span>Identity</span><span> a) s

</span><span>setCity </span><span>:: </span><span>Text </span><span>-&gt; </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>setCity </span><span>=</span><span> set (personAddressL</span><span>.</span><span>addressCityL)
</span></code></pre><h2 id="polymorphic-updates">Polymorphic updates</h2>
<p>It turns out that we can make lenses a bit more general. If we look at
the current type:</p>
<pre><code><span>type </span><span>Lens</span><span> s a </span><span>=</span><span> forall f</span><span>. </span><span>Functor</span><span> f </span><span>=&gt;</span><span> (a </span><span>-&gt;</span><span> f a) </span><span>-&gt;</span><span> (s </span><span>-&gt;</span><span> f s)
</span></code></pre>
<p>It requires that the field originally be of type <code>a</code> and ultimately of
type <code>a</code>. It also requires that the value overall is of type <code>s</code> and
ultimately of type <code>s</code>. Let&#39;s create a new datatype where this would
be limiting:</p>
<pre><code><span>data </span><span>Person</span><span> age </span><span>= </span><span>Person</span><span>
  { personName </span><span>:: !</span><span>Text
  </span><span>, personAge </span><span>:: !</span><span>age
  }

</span><span>aliceInt </span><span>:: </span><span>Person Int
</span><span>aliceInt </span><span>= </span><span>Person </span><span>&#34;</span><span>Alice</span><span>&#34; </span><span>30

</span><span>personAgeL </span><span>:: </span><span>Lens</span><span> (</span><span>Person age</span><span>) </span><span>age
</span><span>personAgeL </span><span>=</span><span> lens personAge (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { personAge </span><span>=</span><span> y })

</span><span>setAge </span><span>:: </span><span>age </span><span>-&gt; </span><span>Person oldAge </span><span>-&gt; </span><span>Person age
</span><span>setAge age person </span><span>=</span><span> person { personAge </span><span>=</span><span> age }

</span><span>aliceDouble </span><span>:: </span><span>Person Double
</span><span>aliceDouble </span><span>=</span><span> setAge </span><span>30.5</span><span> aliceInt
</span></code></pre>
<p>Try as we might, we cannot use <code>personAgeL</code> to change the age value
from an <code>Int</code> to a <code>Double</code>. Its construction requires that the input
and output <code>age</code> type variable remain the same. However, with a small
extension to our <code>Lens</code> type, we can make this work:</p>
<pre><code><span>type </span><span>Lens</span><span> s t a b </span><span>=</span><span> forall f</span><span>. </span><span>Functor</span><span> f </span><span>=&gt;</span><span> (a </span><span>-&gt;</span><span> f b) </span><span>-&gt;</span><span> (s </span><span>-&gt;</span><span> f t)

</span><span>-- Our old monomorphic variant
</span><span>type </span><span>Lens</span><span>&#39; s a </span><span>= </span><span>Lens</span><span> s s a a
</span></code></pre>
<p>This says that we have some data structure, <code>s</code>. Inside <code>s</code> is a value
<code>a</code>. If you replace that <code>a</code> with a <code>b</code>, you get out a <code>t</code>. Sound
weird? Let&#39;s see it in practice:</p>
<pre><code><span>personAgeL </span><span>:: </span><span>Lens</span><span> (</span><span>Person age1</span><span>) (</span><span>Person age2</span><span>) </span><span>age1 age2
</span><span>personAgeL </span><span>=</span><span> lens personAge (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { personAge </span><span>=</span><span> y })

</span><span>setAge </span><span>:: </span><span>age </span><span>-&gt; </span><span>Person oldAge </span><span>-&gt; </span><span>Person age
</span><span>setAge </span><span>=</span><span> set personAgeL
</span></code></pre><h2 id="getters-setters-folds-traversals">Getters, setters, folds, traversals...</h2>
<p>What we&#39;ve seen so far is the original motivating case. It turns out
that there are many crazy ways of generalizing a <code>Lens</code> further to
represent more usages. This comes by means of various techniques, such
as:</p>
<ul>
<li>Using concrete types</li>
<li>Using a different typeclass constraint from <code>Functor</code></li>
<li>Replace functions (e.g., <code>a -&gt; f b</code>) with profunctors (e.g. <code>p a (f b)</code>)</li>
</ul>
<p>We&#39;ve already seen examples of the concrete types approach. Let&#39;s use
their more standard names now:</p>
<pre><code><span>type </span><span>ASetter</span><span> s t a b </span><span>=</span><span> (a </span><span>-&gt; </span><span>Identity</span><span> b) </span><span>-&gt;</span><span> s </span><span>-&gt; </span><span>Identity</span><span> t
</span><span>type </span><span>ASetter</span><span>&#39; s a </span><span>= </span><span>ASetter</span><span> s s a a
</span><span>type </span><span>Getting</span><span> r s a </span><span>=</span><span> (a </span><span>-&gt; </span><span>Const</span><span> r a) </span><span>-&gt;</span><span> s </span><span>-&gt; </span><span>Const</span><span> r s
</span><span>type </span><span>SimpleGetter</span><span> s a </span><span>=</span><span> forall r</span><span>. </span><span>Getting</span><span> r s a
</span></code></pre>
<p>By using different typeclasses, we&#39;re able to create a form of
subtyping. For example, every <code>Applicative</code> is also a <code>Functor</code>. So if
we define a new type like this:</p>
<pre><code><span>type </span><span>Traversal</span><span> s t a b </span><span>=</span><span> forall f</span><span>. </span><span>Applicative</span><span> f </span><span>=&gt;</span><span> (a </span><span>-&gt;</span><span> f b) </span><span>-&gt;</span><span> s </span><span>-&gt;</span><span> f t
</span></code></pre>
<p>Every <code>Lens s t a b</code> is also a <code>Traversal s t a b</code>, but the reverse is
not true. We can go even deeper down the rabit hole with:</p>
<pre><code><span>type </span><span>Fold</span><span> s a </span><span>=</span><span> forall f</span><span>.</span><span> (</span><span>Contravariant</span><span> f, </span><span>Applicative</span><span> f) </span><span>=&gt;</span><span> (a </span><span>-&gt;</span><span> f a) </span><span>-&gt;</span><span> s </span><span>-&gt;</span><span> f s
</span></code></pre>
<p>Now we need <code>f</code> to be both <code>Applicative</code> and <code>Contravariant</code>, so that
all <code>Traversal</code>s are <code>Fold</code>s, but not all <code>Fold</code>s are
<code>Traversal</code>s. This actually matches up with the related typeclasses
<code>Foldable</code> and <code>Traversable</code>, where the latter is a subclass of the
former.</p>
<p><em>But what does this have to do with field accessors?</em> you may
ask. This is what I was implying above with lens being its own
language on top of Haskell: if desired, you can replace a lot of
functionality found elsewhere with lens-centric code. All of these
different types I&#39;ve mentioned are known as <em>optics</em>, and since they
all have roughly the same shape, they compose together very nicely.</p>
<h2 id="packages">Packages</h2>
<p>The <code>lens</code> package itself is fully loaded, and provides <em>lots</em> of
helper functions, operators, types, and generality. It also has a
relatively heavy dependency footprint. Many projects instead use
<code>microlens</code>, which has a much lighter footprint, but also lacks some
functionality (for example, prisms).</p>
<h2 id="template-haskell">Template Haskell</h2>
<p>If writing those lenses above by hand seems tedious to you, you&#39;re not
alone. Many people use macros/code generation/Template Haskell (all
the same thing in Haskell) to automatically generate lenses, and
sometimes typeclasses to generalize them. Examples:</p>
<ul>
<li>https://www.stackage.org/haddock/lts-12.21/microlens-th-0.4.1.1/Lens-Micro-TH.html</li>
<li>https://www.stackage.org/haddock/lts-12.21/lens-4.15.4/Control-Lens-TH.html</li>
</ul>
<h2 id="best-practices">Best practices</h2>
<p>The most important decision to be made for a team is <em>how</em> to use
lenses. Best practices are vital. You do not want half the team using
advanced lens features and the other half not understanding them at
all. I can advise on what I consider best practices, but it will
depend a lot on how your team wants to approach things. What I&#39;ve
standardized on:</p>
<ul>
<li>Using the basic <code>Lens</code> types and its functions: solid gold, do it,
don&#39;t hold back! The biggest downside is the slightly confusing
error messages, but you get used to that quickly</li>
<li>Replacing common library functions (like <code>lookup</code>) with their lensy
counterparts (like <code>at</code>): not worth it. You&#39;ll make your code
shorter, but I prefer the standard Haskell idioms to relearning with
lens.</li>
<li>Advanced techniques like prisms, folds, traversals: soft avoidance
on my part. I think usually the standard Haskell techniques are
better suited, but again you&#39;ll be able to code golf more easily
with the optics. Prisms in particular are, in my experience, a ripe
source of bugs, where pattern matching can lead to much clearer
code.</li>
</ul>
<p>We should base the homework exercises around how deeply into lenses
the team wants to go.</p>
<h2 id="exercise-1">Exercise 1</h2>
<p>Fill out the stubs below to make the test suite pass. Probably goes
without saying, but: use the generated lenses (<code>address</code>, <code>street</code>,
<code>age</code>, etc) wherever possible instead of falling back to records.</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>{-# </span><span>LANGUAGE</span><span> TemplateHaskell #-}
{-# </span><span>LANGUAGE</span><span> OverloadedStrings #-}
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Data.Text </span><span>(</span><span>Text</span><span>)
</span><span>import </span><span>Test.Hspec

data </span><span>Address </span><span>= </span><span>Address</span><span>
  { _street </span><span>:: !</span><span>Text
  </span><span>, _city </span><span>:: !</span><span>Text</span><span>
  }

makeLenses &#39;&#39;</span><span>Address

</span><span>data </span><span>Person </span><span>= </span><span>Person</span><span>
  { _name </span><span>:: !</span><span>Text
  </span><span>, _address </span><span>:: !</span><span>Address
  </span><span>, _age </span><span>:: !</span><span>Int</span><span>
  }

makeLenses &#39;&#39;</span><span>Person

</span><span>hollywood </span><span>:: </span><span>Text
</span><span>hollywood </span><span>= </span><span>&#34;</span><span>Hollywood Blvd</span><span>&#34;

</span><span>alice </span><span>:: </span><span>Person
</span><span>alice </span><span>= </span><span>Person</span><span>
  { _name </span><span>= </span><span>&#34;</span><span>Alice</span><span>&#34;
  </span><span>, _address </span><span>= </span><span>Address</span><span>
      { _street </span><span>=</span><span> hollywood
      , _city </span><span>= </span><span>&#34;</span><span>Los Angeles</span><span>&#34;</span><span>
      }
  , _age </span><span>= </span><span>30</span><span>
  }

</span><span>wilshire </span><span>:: </span><span>Text
</span><span>wilshire </span><span>= </span><span>&#34;</span><span>Wilshire Blvd</span><span>&#34;

</span><span>aliceWilshire </span><span>:: </span><span>Person
</span><span>aliceWilshire </span><span>=</span><span> _ </span><span>-- FIXME set Alice&#39;s street to Wilshire

</span><span>getStreet </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Text
</span><span>getStreet </span><span>=</span><span> _

</span><span>-- | Increase age by 1
</span><span>birthday </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>birthday </span><span>=</span><span> _

</span><span>getAge </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Int
</span><span>getAge </span><span>=</span><span> _

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>lives on Wilshire</span><span>&#34; </span><span>$</span><span>
    _street (_address aliceWilshire) </span><span>`shouldBe`</span><span> wilshire
  it </span><span>&#34;</span><span>getStreet works</span><span>&#34; </span><span>$</span><span>
    getStreet alice </span><span>`shouldBe`</span><span> hollywood
  it </span><span>&#34;</span><span>birthday</span><span>&#34; </span><span>$</span><span>
    getAge (birthday alice) </span><span>`shouldBe`</span><span> _age alice </span><span>+ </span><span>1
</span></code></pre><h2 id="exercise-2">Exercise 2</h2>
<p>Remove the <code>{-# LANGUAGE TemplateHaskell #-}</code> line from the previous
exercise and get the code to compile. You&#39;ll need to define your own
lenses to make this work. Use the <code>lens</code> helper function, and make
sure to add type signatures to the values you create.</p>
<h2 id="exercise-3">Exercise 3</h2>
<p>Real challenge: now implement those lenses again, but without using
the <code>lens</code> helper function. Instead, use <code>fmap</code> or <code>&lt;$&gt;</code> directly.</p>
<h2 id="exercise-4">Exercise 4</h2>
<p>There are tuple lenses provided, named <code>_1</code>, <code>_2</code>, and so on, for
modifying components in tuples. Fill in the stub below so that the
test passes:</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>{-# </span><span>LANGUAGE</span><span> OverloadedStrings #-}
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Test.Hspec

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$</span><span>
  it </span><span>&#34;</span><span>fun with tuples</span><span>&#34; </span><span>$
    let</span><span> tupleLens </span><span>=</span><span> _
        </span><span>tuple </span><span>::</span><span> ((</span><span>Int</span><span>, </span><span>Double</span><span>), (</span><span>Bool</span><span>, </span><span>Char</span><span>, </span><span>String</span><span>))
        tuple </span><span>=</span><span> ((</span><span>1</span><span>, </span><span>2</span><span>), (</span><span>True</span><span>, </span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span>))
     </span><span>in</span><span> over tupleLens not tuple </span><span>`shouldBe`</span><span>
            ((</span><span>1</span><span>, </span><span>2</span><span>), (</span><span>False</span><span>, </span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span>))
</span></code></pre><h2 id="exercise-5">Exercise 5</h2>
<p>Everything we&#39;ve done so far has been on <em>product types</em>. In these
cases, lenses work perfectly: we know that we have every field
available. However, lenses do not work perfectly on <em>sum types</em>, where
values may or may not exist. In these cases, prisms, traversals, and
folds come into play. We&#39;re not necessarily going to be using these in
depth, but it&#39;s good to be aware of them.</p>
<p>Let&#39;s use the <code>_Left</code> and <code>_Right</code> prisms (which work as traversals
and folds as well). Fill in the expected values for the test suite
below to begin to get an intuition for how the traversal functions
work.</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Test.Hspec

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>over left on left</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Left </span><span>5
     </span><span>in</span><span> over _Left (</span><span>+ </span><span>1</span><span>) val </span><span>`shouldBe`</span><span> _
  it </span><span>&#34;</span><span>over left on right</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Right </span><span>5
     </span><span>in</span><span> over _Left (</span><span>+ </span><span>1</span><span>) val </span><span>`shouldBe`</span><span> _
  it </span><span>&#34;</span><span>set left on left</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Left </span><span>5
     </span><span>in</span><span> set _Left </span><span>6</span><span> val </span><span>`shouldBe`</span><span> _
  it </span><span>&#34;</span><span>set left on right</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Right </span><span>5
     </span><span>in</span><span> set _Left </span><span>6</span><span> val </span><span>`shouldBe`</span><span> _
</span></code></pre><h2 id="exercise-6">Exercise 6</h2>
<p>Bonus! This one makes more extreme usage of the folds and
traversals. Reimplement some common library functions using
lenses. This will require looking through the docs for microlens or
lens quite a bit.</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>{-# </span><span>OPTIONS_GHC</span><span> -Wall -Werror #-}
{-# </span><span>LANGUAGE</span><span> RankNTypes #-}
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Test.Hspec
</span><span>import </span><span>Data.Monoid </span><span>(</span><span>Endo</span><span>)

</span><span>-- | map/fmap
</span><span>mapLens </span><span>:: </span><span>ASetter s t a b </span><span>-&gt;</span><span> (</span><span>a </span><span>-&gt; </span><span>b</span><span>) </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>t
</span><span>mapLens </span><span>=</span><span> _

</span><span>-- | toList
</span><span>toListLens </span><span>:: </span><span>Getting</span><span> (</span><span>Endo</span><span> [</span><span>a</span><span>]) </span><span>s a </span><span>-&gt; </span><span>s </span><span>-&gt;</span><span> [</span><span>a</span><span>]
toListLens </span><span>=</span><span> _

</span><span>-- | catMaybes
</span><span>catMaybesLens </span><span>::</span><span> [</span><span>Maybe a</span><span>] </span><span>-&gt;</span><span> [</span><span>a</span><span>]
catMaybesLens </span><span>=</span><span> _

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>mapLens</span><span>&#34; </span><span>$</span><span>
    mapLens _2 not (</span><span>()</span><span>, </span><span>True</span><span>) </span><span>`shouldBe`</span><span> (</span><span>()</span><span>, </span><span>False</span><span>)
  it </span><span>&#34;</span><span>toListLens</span><span>&#34; </span><span>$</span><span>
    toListLens both (</span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>&#39;</span><span>y</span><span>&#39;</span><span>) </span><span>`shouldBe` </span><span>&#34;</span><span>xy</span><span>&#34;</span><span>
  it </span><span>&#34;</span><span>catMaybesLens</span><span>&#34; </span><span>$</span><span>
    catMaybesLens [</span><span>Just </span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>Nothing</span><span>, </span><span>Just </span><span>&#39;</span><span>y</span><span>&#39;</span><span>] </span><span>`shouldBe` </span><span>&#34;</span><span>xy</span><span>&#34;
</span></code></pre><h2 id="solutions">Solutions</h2>
<h3 id="exercise-1-1">Exercise 1</h3>
<p>Note that there are many other ways to solve some of these problems.</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>{-# </span><span>LANGUAGE</span><span> TemplateHaskell #-}
{-# </span><span>LANGUAGE</span><span> OverloadedStrings #-}
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Data.Text </span><span>(</span><span>Text</span><span>)
</span><span>import </span><span>Test.Hspec

data </span><span>Address </span><span>= </span><span>Address</span><span>
  { _street </span><span>:: !</span><span>Text
  </span><span>, _city </span><span>:: !</span><span>Text</span><span>
  }

makeLenses &#39;&#39;</span><span>Address

</span><span>data </span><span>Person </span><span>= </span><span>Person</span><span>
  { _name </span><span>:: !</span><span>Text
  </span><span>, _address </span><span>:: !</span><span>Address
  </span><span>, _age </span><span>:: !</span><span>Int</span><span>
  }

makeLenses &#39;&#39;</span><span>Person

</span><span>hollywood </span><span>:: </span><span>Text
</span><span>hollywood </span><span>= </span><span>&#34;</span><span>Hollywood Blvd</span><span>&#34;

</span><span>alice </span><span>:: </span><span>Person
</span><span>alice </span><span>= </span><span>Person</span><span>
  { _name </span><span>= </span><span>&#34;</span><span>Alice</span><span>&#34;
  </span><span>, _address </span><span>= </span><span>Address</span><span>
      { _street </span><span>=</span><span> hollywood
      , _city </span><span>= </span><span>&#34;</span><span>Los Angeles</span><span>&#34;</span><span>
      }
  , _age </span><span>= </span><span>30</span><span>
  }

</span><span>wilshire </span><span>:: </span><span>Text
</span><span>wilshire </span><span>= </span><span>&#34;</span><span>Wilshire Blvd</span><span>&#34;

</span><span>aliceWilshire </span><span>:: </span><span>Person
</span><span>aliceWilshire </span><span>=</span><span> set (address</span><span>.</span><span>street) wilshire alice

</span><span>getStreet </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Text
</span><span>getStreet </span><span>=</span><span> view (address</span><span>.</span><span>street)
</span><span>--getStreet = (^. address.street)

-- | Increase age by 1
</span><span>birthday </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Person
</span><span>birthday </span><span>=</span><span> over age (</span><span>+ </span><span>1</span><span>)
</span><span>--birthday = age %~ (+ 1)

</span><span>getAge </span><span>:: </span><span>Person </span><span>-&gt; </span><span>Int
</span><span>getAge </span><span>=</span><span> view age

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>lives on Wilshire</span><span>&#34; </span><span>$</span><span>
    _street (_address aliceWilshire) </span><span>`shouldBe`</span><span> wilshire
  it </span><span>&#34;</span><span>getStreet works</span><span>&#34; </span><span>$</span><span>
    getStreet alice </span><span>`shouldBe`</span><span> hollywood
  it </span><span>&#34;</span><span>birthday</span><span>&#34; </span><span>$</span><span>
    getAge (birthday alice) </span><span>`shouldBe`</span><span> _age alice </span><span>+ </span><span>1
</span></code></pre><h3 id="exercise-2-1">Exercise 2</h3>
<pre><code><span>street </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Address Text
</span><span>street </span><span>=</span><span> lens _street (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { _street </span><span>=</span><span> y })

</span><span>address </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Person Address
</span><span>address </span><span>=</span><span> lens _address (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { _address </span><span>=</span><span> y })

</span><span>age </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Person Int
</span><span>age </span><span>=</span><span> lens _age (</span><span>\</span><span>x y </span><span>-&gt;</span><span> x { _age </span><span>=</span><span> y })
</span></code></pre><h3 id="exercise-3-1">Exercise 3</h3>
<pre><code><span>street </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Address Text
</span><span>street f address </span><span>=</span><span> (</span><span>\</span><span>x </span><span>-&gt;</span><span> address { _street </span><span>=</span><span> x }) </span><span>&lt;$&gt;</span><span> f (_street address)

</span><span>address </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Person Address
</span><span>address f person </span><span>=</span><span> (</span><span>\</span><span>x </span><span>-&gt;</span><span> person { _address </span><span>=</span><span> x }) </span><span>&lt;$&gt;</span><span> f (_address person)

</span><span>age </span><span>:: </span><span>Lens</span><span>&#39; </span><span>Person Int
</span><span>age f person </span><span>=</span><span> (</span><span>\</span><span>x </span><span>-&gt;</span><span> person { _age </span><span>=</span><span> x }) </span><span>&lt;$&gt;</span><span> f (_age person)
</span></code></pre><h3 id="exercise-4-1">Exercise 4</h3>
<pre><code><span>let</span><span> tupleLens </span><span>=</span><span> _2</span><span>.</span><span>_1
</span></code></pre><h3 id="exercise-5-1">Exercise 5</h3>
<p>The most important bit here to notice: using <code>set _Left</code> did <em>not</em>
change the data constructor from <code>Right</code> to <code>Left</code>.</p>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Test.Hspec

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>over left on left</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Left </span><span>5
     </span><span>in</span><span> over _Left (</span><span>+ </span><span>1</span><span>) val </span><span>`shouldBe` </span><span>Left </span><span>6</span><span>
  it </span><span>&#34;</span><span>over left on right</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Right </span><span>5
     </span><span>in</span><span> over _Left (</span><span>+ </span><span>1</span><span>) val </span><span>`shouldBe` </span><span>Right </span><span>5</span><span>
  it </span><span>&#34;</span><span>set left on left</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Left </span><span>5
     </span><span>in</span><span> set _Left </span><span>6</span><span> val </span><span>`shouldBe` </span><span>Left </span><span>6</span><span>
  it </span><span>&#34;</span><span>set left on right</span><span>&#34; </span><span>$
    let</span><span> val </span><span>:: </span><span>Either Int Double</span><span>
        val </span><span>= </span><span>Right </span><span>5
     </span><span>in</span><span> set _Left </span><span>6</span><span> val </span><span>`shouldBe` </span><span>Right </span><span>5
</span></code></pre><h3 id="exercise-6-1">Exercise 6</h3>
<pre><code><span>#</span><span>!/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env stack
</span><span>-- stack --resolver lts-12.21 script
</span><span>{-# </span><span>OPTIONS_GHC</span><span> -Wall -Werror #-}
{-# </span><span>LANGUAGE</span><span> RankNTypes #-}
</span><span>import </span><span>Lens.Micro.Platform
</span><span>import </span><span>Test.Hspec
</span><span>import </span><span>Data.Monoid </span><span>(</span><span>Endo</span><span>)

</span><span>-- | map/fmap
</span><span>mapLens </span><span>:: </span><span>ASetter s t a b </span><span>-&gt;</span><span> (</span><span>a </span><span>-&gt; </span><span>b</span><span>) </span><span>-&gt; </span><span>s </span><span>-&gt; </span><span>t
</span><span>mapLens l f </span><span>=</span><span> over l f

</span><span>-- | toList
</span><span>toListLens </span><span>:: </span><span>Getting</span><span> (</span><span>Endo</span><span> [</span><span>a</span><span>]) </span><span>s a </span><span>-&gt; </span><span>s </span><span>-&gt;</span><span> [</span><span>a</span><span>]
toListLens l s </span><span>=</span><span> s ^</span><span>..</span><span> l

</span><span>-- | catMaybes
</span><span>catMaybesLens </span><span>::</span><span> [</span><span>Maybe a</span><span>] </span><span>-&gt;</span><span> [</span><span>a</span><span>]
catMaybesLens list </span><span>=</span><span> list ^</span><span>..</span><span> each</span><span>.</span><span>_Just

</span><span>main </span><span>:: </span><span>IO </span><span>()
</span><span>main </span><span>=</span><span> hspec </span><span>$ do</span><span>
  it </span><span>&#34;</span><span>mapLens</span><span>&#34; </span><span>$</span><span>
    mapLens _2 not (</span><span>()</span><span>, </span><span>True</span><span>) </span><span>`shouldBe`</span><span> (</span><span>()</span><span>, </span><span>False</span><span>)
  it </span><span>&#34;</span><span>toListLens</span><span>&#34; </span><span>$</span><span>
    toListLens both (</span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>&#39;</span><span>y</span><span>&#39;</span><span>) </span><span>`shouldBe` </span><span>&#34;</span><span>xy</span><span>&#34;</span><span>
  it </span><span>&#34;</span><span>catMaybesLens</span><span>&#34; </span><span>$</span><span>
    catMaybesLens [</span><span>Just </span><span>&#39;</span><span>x</span><span>&#39;</span><span>, </span><span>Nothing</span><span>, </span><span>Just </span><span>&#39;</span><span>y</span><span>&#39;</span><span>] </span><span>`shouldBe` </span><span>&#34;</span><span>xy</span><span>&#34;
</span></code></pre>
</div></div>
  </body>
</html>
