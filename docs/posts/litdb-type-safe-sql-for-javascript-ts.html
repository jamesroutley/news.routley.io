<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://litdb.dev/">Original</a>
    <h1>Litdb – type safe SQL for JavaScript/TS</h1>
    
    <div id="readability-page-1" class="page"><div>
                    
<p>To use litdb with your favorite ORM, no driver is required. Just use the <code>litdb</code> package directly:</p>

<p><code>litdb</code> is also available as a module, where it can be used directly in the browser:</p>
<pre><code>&lt;script type=&#34;module&#34;&gt;
import { sqlite as $ } from &#34;https://unpkg.com/litdb/dist/index.min.js&#34;
const { sql, params } = $.from(Contact).select(c =&gt; $`${c.name}`).build()
&lt;/script&gt;
</code></pre>
<p>To get the most out of <code>litdb</code> we recommend using text editors that supports TypeScript definitions
(e.g. VS Code, JetBrains IDEs, neovim, etc.)</p>

<p>Lightweight drivers with native support for its typed SQL Builders and parameterized SQL Expressions
are also available for the popular databases:</p>
<h3 id="bun-sqlite">Bun SQLite​</h3>
<p>Use with <a href="https://bun.sh/docs/api/sqlite">Bun&#39;s native SQLite3 driver</a> (requires Bun):</p>
<div onclick="copy(this)">
                <div>
                    <p>bun install @litdb/bun-sqlite</p>
                    </div>
                
            </div>
<p>See <a href="https://litdb.dev/bun-sqlite">litdb Bun SQLite Docs</a></p>
<h3 id="node-better-sqlite">Node better-sqlite​</h3>
<p>Use with <a href="https://github.com/WiseLibs/better-sqlite3">better-sqlite3</a> (requires Node.js):</p>
<div onclick="copy(this)">
                <div>
                    <p>npm install @litdb/better-sqlite</p>
                    </div>
                
            </div>
<p>See <a href="https://litdb.dev/better-sqlite">litdb better-sqlite3 Docs</a></p>
<h3 id="postgresql">PostgreSQL​</h3>
<p>Use with the <a href="https://github.com/porsager/postgres">postgres.js</a> client:</p>
<div onclick="copy(this)">
                <div>
                    <p>npm install @litdb/postgres</p>
                    </div>
                
            </div>
<p>See <a href="https://litdb.dev/postgres">litdb postgres Docs</a></p>
<h3 id="mysql">MySQL​</h3>
<p>Use with the <a href="https://github.com/sidorares/node-mysql2">mysql2</a> client:</p>
<div onclick="copy(this)">
                <div>
                    <p>npm install @litdb/mysql2</p>
                    </div>
                
            </div>
<p>See <a href="https://litdb.dev/mysql2">litdb mysql2 Docs</a></p>
<h3 id="request-a-driver">Request a Driver​</h3>
<p>If you&#39;d like to see a driver for a specific client, please open or vote for a feature request on litdb&#39;s
<a href="https://github.com/litdb/litdb/discussions/categories/ideas">GitHub Discussions</a>.</p>
<h2 id="driver-usage">Driver Usage​</h2>
<p>The litdb Drivers provide a unified interface for executing custom parameterized SQL, SQL Builders and SQL Fragments
for their respective RDBMS. They&#39;re lightweight data adapters providing convenience APIs for executing SQL with named
and positional parameters. They can be used without litdb SQL Builders, but offer the most value when used together.</p>
<p>The same APIs are available across all drivers, so you can easily switch between them. They include both <strong>sync</strong> APIs
recommended for SQLite libraries that use SQLite&#39;s native blocking APIs, whilst <strong>async</strong> APIs should be used for
all other remote databases, e.g. PostgreSQL and MySQL.</p>
<p>Example of using the <a href="https://bun.sh/docs/api/sqlite">Bun SQLite</a> driver:</p>
<p><strong>db.ts</strong></p>
<pre><code>import { connect } from &#34;@litdb/bun-sqlite&#34;

export const connection = connect(&#34;app.db&#34;) // WAL enabled by default
export const { $, sync:db, async, native } = connection
</code></pre>

<p><strong>app.ts</strong></p>
<pre><code>import { $, db } from &#34;./db&#34;
import { Contact } from &#34;./models&#34;

db.dropTable(Contact)
db.createTable(Contact)
db.insertAll([
    new Contact({ name:&#34;John Doe&#34;, email:&#34;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="254f4a4d4b6548444c490b4a5742">[email protected]</a>&#34; }),
    new Contact({ name:&#34;Jane Doe&#34;, email:&#34;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="791318171c391418101557160b1e">[email protected]</a>&#34; }),
])

const janeEmail = &#39;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="fc969d9299bc919d9590d2938e9b">[email protected]</a>&#39;
const jane = db.one&lt;Contact&gt;($.from(Contact).where(c =&gt; $`${c.email} = ${janeEmail}`))!

// Insert examples
const { lastInsertRowid: bobId } = db.insert(new Contact({ name:&#34;Bob&#34;, email:&#34;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="d3b1bcb193beb2babffdbca1b4">[email protected]</a>&#34; }))
const { lastInsertRowid } = db.exec`INSERT INTO Contact(name,email) VALUES (&#39;Jo&#39;,&#39;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="8ee4e1ceeae1eba0e1fce9">[email protected]</a>&#39;)`
const name = &#39;Alice&#39;, email = &#39;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="7f1e13161c1a3f121e161351100d18">[email protected]</a>&#39;
db.exec`INSERT INTO Contact(name,email) VALUES (${name}, ${email})`

// Typed SQL fragment with named param example
const hasId = &lt;Table extends { id:number }&gt;(id:number|bigint) =&gt;
    (x:Table) =&gt; $.sql($`${x.id} = $id`, { id })

const contacts = db.all($.from(Contact).into(Contact))                // =&gt; Contact[]
const bob = db.one($.from(Contact).where(hasId(bobId)).into(Contact)) // =&gt; Contact    
const contactsCount = db.value($.from(Contact).select`COUNT(*)`)      // =&gt; number
const emails = db.column($.from(Contact).select(c =&gt; $`${c.email}`))  // =&gt; string[]
const contactsArray = db.arrays($.from(Contact))                      // =&gt; any[][]
const bobArray = db.array($.from(Contact).where(hasId(bobId)))        // =&gt; any[]

// Update examples
jane.email = &#39;<a href="https://litdb.dev/cdn-cgi/l/email-protection" data-cfemail="315b505f5471555e541f5e4356">[email protected]</a>&#39;
db.update(jane)                           // Update all properties
db.update(jane, { onlyProps:[&#39;email&#39;] })  // Update only email
db.exec($.update(Contact).set({ email:jane.email }).where(hasId(jane.id))) // query builder

// Delete examples
db.delete(jane)
db.exec($.deleteFrom(Contact).where(hasId(jane.id))) // query builder
</code></pre>
<p>Same source is compatible with other sync drivers, e.g. can replace <code>@litdb/bun-sqlite</code> with <code>@litdb/better-sqlite</code> to use
with <a href="https://litdb.dev/better-sqlite#usage">better-sqlite</a>. See also async usage docs for <a href="https://litdb.dev/postgres#usage">postgres</a> and <a href="https://litdb.dev/mysql2#usage">mysql2</a>.</p>

                </div></div>
  </body>
</html>
