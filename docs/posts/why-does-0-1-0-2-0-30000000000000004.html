<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/02/08/why-does-0-1-plus-0-2-equal-0-30000000000000004/">Original</a>
    <h1>Why does 0.1 &#43; 0.2 = 0.30000000000000004?</h1>
    
    <div id="readability-page-1" class="page"><div>
     


    

<p>Hello! I was trying to write about floating point yesterday,
and I found myself wondering about this calculation, with 64-bit floats:</p>

<pre><code>&gt;&gt;&gt; 0.1 + 0.2
0.30000000000000004
</code></pre>

<p>I realized that I didn’t understand exactly how it worked. I mean, I know
floating point calculations are inexact, and I know that you can’t exactly
represent <code>0.1</code> in binary, but: there’s a floating point number that’s closer to
0.3 than <code>0.30000000000000004</code>! So why do we get the answer
<code>0.30000000000000004</code>?</p>

<p>If you don’t feel like reading this whole post with a bunch of calculations, the short answer is that
<code>0.1000000000000000055511151231257827021181583404541015625 + 0.200000000000000011102230246251565404236316680908203125</code> lies exactly between
2 floating point numbers,
<code>0.299999999999999988897769753748434595763683319091796875</code> (usually printed as <code>0.3</code>) and
<code>0.3000000000000000444089209850062616169452667236328125</code> (usually printed as <code>0.30000000000000004</code>). The answer is
<code>0.30000000000000004</code> (the second one) because its significand is even.</p>

<h3 id="how-floating-point-addition-works">how floating point addition works</h3>

<p>This is roughly how floating point addition works:</p>

<ol>
<li>Add together the numbers (with extra precision)</li>
<li>Round the result to the nearest floating point number</li>
</ol>

<p>So let’s use these rules to calculate 0.1 + 0.2. I just learned how floating
point addition works yesterday so it’s possible I’ve made some mistakes in this
post, but I did get the answers I expected at the end.</p>

<h3 id="step-1-find-out-what-0-1-and-0-2-are">step 1: find out what 0.1 and 0.2 are</h3>

<p>First, let’s use Python to figure out what the exact values of <code>0.1</code> and <code>0.2</code> are, as 64-bit floats.</p>

<pre><code>&gt;&gt;&gt; f&#34;{0.1:.80f}&#34;
&#39;0.10000000000000000555111512312578270211815834045410156250000000000000000000000000&#39;
&gt;&gt;&gt; f&#34;{0.2:.80f}&#34;
&#39;0.20000000000000001110223024625156540423631668090820312500000000000000000000000000&#39;
</code></pre>

<p>These really are the exact values: because floating point numbers are in base
2, you can represent them all exactly in base 10. You just need a lot of digits
sometimes :)</p>

<h3 id="step-2-add-the-numbers-together">step 2: add the numbers together</h3>

<p>Next, let’s add those numbers together. We can add the fractional parts together as integers to get the exact answer:</p>

<pre><code>&gt;&gt;&gt; 1000000000000000055511151231257827021181583404541015625 + 2000000000000000111022302462515654042363166809082031250
3000000000000000166533453693773481063544750213623046875
</code></pre>

<p>So the exact sum of those two floating point numbers is <code>0.3000000000000000166533453693773481063544750213623046875</code></p>

<p>This isn’t our final answer though because <code>0.3000000000000000166533453693773481063544750213623046875</code> isn’t a 64-bit float.</p>

<h3 id="step-3-look-at-the-nearest-floating-point-numbers">step 3: look at the nearest floating point numbers</h3>

<p>Now, let’s look at the floating point numbers around <code>0.3</code>. Here’s the closest floating point number to <code>0.3</code> (usually written as just <code>0.3</code>, even though that isn’t its exact value):</p>

<pre><code>&gt;&gt;&gt; f&#34;{0.3:.80f}&#34;
&#39;0.29999999999999998889776975374843459576368331909179687500000000000000000000000000&#39;
</code></pre>

<p>We can figure out the next floating point number after <code>0.3</code> by serializing
<code>0.3</code> to 8 bytes with <code>struct.pack</code>, adding 1, and then using <code>struct.unpack</code>:</p>

<pre><code>&gt;&gt;&gt; struct.pack(&#34;!d&#34;, 0.3)
b&#39;?\xd3333333&#39;
# manually add 1 to the last byte
&gt;&gt;&gt; next_float = struct.unpack(&#34;!d&#34;, b&#39;?\xd3333334&#39;)[0]
&gt;&gt;&gt; next_float
0.30000000000000004
&gt;&gt;&gt; f&#34;{next_float:.80f}&#34;
&#39;0.30000000000000004440892098500626161694526672363281250000000000000000000000000000&#39;
</code></pre>

<p>Apparently you can also do this with <code>math.nextafter</code>:</p>

<pre><code>&gt;&gt;&gt; math.nextafter(0.3, math.inf)
0.30000000000000004
</code></pre>

<p>So the two 64-bit floats around
<code>0.3</code> are
<code>0.299999999999999988897769753748434595763683319091796875</code> and
<code>0.3000000000000000444089209850062616169452667236328125</code></p>

<h3 id="step-4-find-out-which-one-is-closest-to-our-result">step 4: find out which one is closest to our result</h3>

<p>It turns out that <code>0.3000000000000000166533453693773481063544750213623046875</code>
is exactly in the middle of
<code>0.299999999999999988897769753748434595763683319091796875</code> and
<code>0.3000000000000000444089209850062616169452667236328125</code>.</p>

<p>You can see that with this calculation:</p>

<pre><code>&gt;&gt;&gt; (3000000000000000444089209850062616169452667236328125000 + 2999999999999999888977697537484345957636833190917968750) // 2 == 3000000000000000166533453693773481063544750213623046875
True
</code></pre>

<p>So neither of them is closest.</p>

<h3 id="how-does-it-know-which-one-to-round-to">how does it know which one to round to?</h3>

<p>In the binary representation of a floating point number, there’s a number
called the “significand”. In cases like this (where the result is exactly in
between 2 successive floating point number, it’ll round to the one with the
even significand.</p>

<p>In this case that’s <code>0.300000000000000044408920985006261616945266723632812500</code></p>

<p>We actually saw the significand of this number a bit earlier:</p>

<ul>
<li>0.30000000000000004  is <code>struct.unpack(&#39;!d&#39;, b&#39;?\xd3333334&#39;)</code></li>
<li>0.3 is <code>struct.unpack(&#39;!d&#39;, b&#39;?\xd3333333&#39;)</code></li>
</ul>

<p>The last digit of the big endian hex representation of <code>0.30000000000000004</code> is
<code>4</code>, so that’s the one with the even significand (because the significand is at
the end).</p>

<h3 id="let-s-also-work-out-the-whole-calculation-in-binary">let’s also work out the whole calculation in binary</h3>

<p>Above we did the calculation in decimal, because that’s a little more intuitive
to read. But of course computers don’t do these calculations in decimal –
they’re done in a base 2 representation. So I wanted to get an idea of how that
worked too.</p>

<p>I don’t think this binary calculation part of the post is particularly clear
but it was helpful for me to write out. There are a really a lot of numbers and
it might be terrible to read.</p>

<h3 id="how-64-bit-floats-numbers-work-exponent-and-significand">how 64-bit floats numbers work: exponent and significand</h3>

<p>64-bit floating point numbers are represented with 2 integers: an <strong>exponent</strong> and the <strong>significand</strong> and a 1-bit <strong>sign</strong>.</p>

<p>Here’s the equation of how the exponent and significand correspond to an actual number</p>

<p>$$\text{sign} \times 2^\text{exponent} (1 + \frac{\text{significand}}{2^{52}})$$</p>

<p>For example if the exponent was <code>1</code> the significand was <code>2**51</code>, and the sign was positive, we’d get</p>

<p>$$2^{1} (1 + \frac{2^{51}}{2^{52}})$$</p>

<p>which is equal to <code>2 * (1 + 0.5)</code> , or 3.</p>

<h3 id="step-1-get-the-exponent-and-significand-for-0-1-and-0-2">step 1: get the exponent and significand for <code>0.1</code> and <code>0.2</code></h3>

<p>I wrote some inefficient functions to get the exponent and significand of a positive float in Python:</p>

<pre><code>def get_exponent(f):
    # get the first 12 bytes
    bytestring = struct.pack(&#39;!d&#39;, f)
    return int.from_bytes(bytestring, byteorder=&#39;big&#39;) &gt;&gt; 52
def get_significand(f):
    # get the last 52 bytes
    bytestring = struct.pack(&#39;!d&#39;, f)
    x = int.from_bytes(bytestring, byteorder=&#39;big&#39;)
    exponent = get_exponent(f)
    return x ^ (exponent &lt;&lt; 52)
</code></pre>

<p>I’m ignoring the sign bit (the first bit) because we only need these functions
to work on two numbers (0.1 and 0.2) and those two numbers are both positive.</p>

<p>First, let’s get the exponent and significand of 0.1. We need to subtract 1023
to get the actual exponent because that’s how floating point works.</p>

<pre><code>&gt;&gt;&gt; get_exponent(0.1) - 1023
-4
&gt;&gt;&gt; get_significand(0.1)
2702159776422298
</code></pre>

<p>The way these numbers work together to get <code>0.1</code> is <code>2**exponent + significand / 2**(52 - exponent)</code>.</p>

<p>Here’s that calculation in Python:</p>

<pre><code>&gt;&gt;&gt; 2**-4 + 2702159776422298 / 2**(52 + 4)
0.1
</code></pre>

<p>(you might legitimately be worried about floating point accuracy issues with
this calculation, but in this case I’m pretty sure it’s fine because these
numbers by definition don’t have accuracy issues – the floating point numbers starting at <code>2**-4</code>  go up in steps of <code>1/2**(52 + 4)</code>)</p>

<p>We can do the same thing for <code>0.2</code>:</p>

<pre><code>&gt;&gt;&gt; get_exponent(0.2) - 1023
-3
&gt;&gt;&gt; get_significand(0.2)
2702159776422298
</code></pre>

<p>And here’s how that exponent and significand work together to get <code>0.2</code>:</p>

<pre><code>&gt;&gt;&gt; 2**-3 + 2702159776422298 / 2**(52 + 3)
0.2
</code></pre>

<p>(by the way, it’s not a coincidence that 0.1 and 0.2 have the same significand – it’s because <code>x</code> and <code>2*x</code> always have the same significand)</p>

<h3 id="step-2-rewrite-0-1-to-have-a-bigger-exponent">step 2: rewrite <code>0.1</code> to have a bigger exponent</h3>

<p><code>0.2</code> has a bigger exponent than <code>0.1</code> – -3 instead of -4.</p>

<p>So we need to rewrite</p>

<pre><code>2**-4 + 2702159776422298 / 2**(52 + 4)
</code></pre>

<p>to be <code>X / (2**52 + 3)</code></p>

<p>If we solve for X in <code>2**-4 + 2702159776422298 / 2**(52 + 4) = X / (2**52 + 3)</code>, we get:</p>

<p><code>X = 2**51 + 2702159776422298 /2</code></p>

<p>We can calculate that in Python pretty easily:</p>

<pre><code>&gt;&gt;&gt; 2**51 + 2702159776422298 //2
3602879701896397
</code></pre>

<h3 id="step-3-add-the-significands">step 3: add the significands</h3>

<p>Now we’re trying to do this addition</p>

<pre><code>2**-3 + 2702159776422298 / 2**(52 + 3) + 3602879701896397 / 2**(52 + 3)
</code></pre>

<p>So we need to add together <code>2702159776422298</code> and <code>3602879701896397</code></p>

<pre><code>&gt;&gt;&gt; 2702159776422298  + 3602879701896397
6305039478318695
</code></pre>

<p>Cool. But <code>6305039478318695</code> is more than 2**52 - 1 (the maximum value for a significand), so we have a problem:</p>

<pre><code>&gt;&gt;&gt; 6305039478318695 &gt; 2**52
True
</code></pre>

<h3 id="step-4-increase-the-exponent">step 4: increase the exponent</h3>

<p>Right now our answer is</p>

<pre><code>2**-3 + 6305039478318695 / 2**(52 + 3)
</code></pre>

<p>First, let’s subtract 2**52 to get</p>

<pre><code>2**-2 + 1801439850948199 / 2**(52 + 3)
</code></pre>

<p>This is almost perfect, but the <code>2**(52 + 3)</code> at the end there needs to be a <code>2**(52 + 2)</code>.</p>

<p>So we need to divide 1801439850948199  by 2. This is where we run into inaccuracies – <code>1801439850948199</code> is odd!</p>

<pre><code>&gt;&gt;&gt; 1801439850948199  / 2
900719925474099.5
</code></pre>

<p>It’s exactly in between two integers, so we round to the nearest even number (which is what the floating point specification says to do), so our final floating point number result is:</p>

<pre><code>&gt;&gt;&gt; 2**-2 + 900719925474100 / 2**(52 + 2)
0.30000000000000004
</code></pre>

<p>That’s the answer we expected:</p>

<pre><code>&gt;&gt;&gt; 0.1 + 0.2
0.30000000000000004
</code></pre>

<h3 id="this-probably-isn-t-exactly-how-it-works-in-hardware">this probably isn’t exactly how it works in hardware</h3>

<p>The way I’ve described the operations here isn’t literally exactly
what happens when you do floating point addition (it’s not “solving for X” for
example), I’m sure there are a lot of efficient tricks. But I think it’s about
the same idea.</p>

<h3 id="printing-out-floating-point-numbers-is-pretty-weird">printing out floating point numbers is pretty weird</h3>

<p>We said earlier that the floating point number 0.3 isn’t equal to 0.3. It’s actually this number:</p>

<pre><code>&gt;&gt;&gt; f&#34;{0.3:.80f}&#34;
&#39;0.29999999999999998889776975374843459576368331909179687500000000000000000000000000&#39;
</code></pre>

<p>So when you print out that number, why does it display <code>0.3</code>?</p>

<p>The computer isn’t actually printing out the exact value of the number, instead
it’s printing out the <em>shortest</em> decimal number <code>d</code> which has the property that
our floating point number <code>f</code> is the closest floating point number to <code>d</code>.</p>

<p>It turns out that doing this efficiently isn’t trivial at all, and there are a bunch of academic papers about it like <a href="https://legacy.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf">Printing Floating-Point Numbers Quickly and Accurately</a>. or <a href="https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf">How to print floating point numbers accurately</a>.</p>

<h3 id="would-it-be-more-intuitive-if-computers-printed-out-the-exact-value-of-a-float">would it be more intuitive if computers printed out the exact value of a float?</h3>

<p>Rounding to a nice clean decimal value is nice, but in a way I feel like it
might be more intuitive if computers just printed out the exact value of a
floating point number – it might make it seem a lot less surprising when you
get weird results.</p>

<p>To me,
0.1000000000000000055511151231257827021181583404541015625 +
0.200000000000000011102230246251565404236316680908203125
= 0.3000000000000000444089209850062616169452667236328125 feels less surprising than 0.1 + 0.2 = 0.30000000000000004.</p>

<p>Probably this is a bad idea, it would definitely use a lot of screen space.</p>

<h3 id="a-quick-note-on-php">a quick note on PHP</h3>

<p>Someone in the comments somewhere pointed out that <code>&lt;?php echo (0.1 + 0.2 );?&gt;</code>
prints out <code>0.3</code>. Does that mean that floating point math is different in PHP?</p>

<p>I think the answer is no – if I run:</p>

<p><code>&lt;?php echo (0.1 + 0.2 )- 0.3);?&gt;</code> on <a href="https://replit.com/languages/php_cli">this
 page</a>, I get the exact same answer as in
 Python 5.5511151231258E-17. So it seems like the underlying floating point
 math is the same.</p>

<p>I think the reason that <code>0.1 + 0.2</code> prints out <code>0.3</code>  in PHP is that PHP’s
 algorithm for displaying floating point numbers is less precise than Python’s
 – it’ll display <code>0.3</code> even if that number isn’t the closest floating point
 number to 0.3.</p>

<h3 id="that-s-all">that’s all!</h3>

<p>I kind of doubt that anyone had the patience to follow all of that arithmetic,
but it was helpful for me to write down, so I’m publishing this post anyway.
Hopefully some of this makes sense.</p>

</div></div>
  </body>
</html>
