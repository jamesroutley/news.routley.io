<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://niespodd.github.io/webrtc-local-ip-leak/">Original</a>
    <h1>Chromium based browsers leak user local IP via WebRTC foundation attribute</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        

        <p>
            This script uses a pregenerated <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate/foundation">foundation</a>
            lookup table to find local IP address for ICE candidates that render local mDNS hostnames seen as <code>xx-xxx-xxx-xx.local</code>.
        </p>

        


        

        <h2>
            Background
        </h2>
        <p>
            Modern browsers hide user&#39;s local IP address by returning a <code>[rand].local</code> placeholder resulting
            in many popular test websites such as <a href="https://browserleaks.com/webrtc">BrowserLeaks WebRTC Leak Test</a>
            showing no &#34;Local IP Address&#34;.</p>
        <p>
            Similarly creators of <a href="https://github.com/niespodd/browser-fingerprinting#available-stealth-browsers-with-automation-features">the
            (useless) stealth browsers</a> typically mask local IP by merely swapping the address parameter in the RTC
            report and sometimes setting a random <code>foundation</code>. This allows anti-bot vendors to easily
            pinpoint the malicious visitors using these type of solutions.
        </p>

        <p>
            A reference <code>libwebrtc</code> implementation <code><a href="https://github.com/mozilla/libwebrtc/blob/04a109ab593bfb3b5cf42607cac95f6070dc6f50/p2p/base/port.cc#L99">p2p/base/port.cc#L99</a></code>
            takes a local IP address along with used protocol and type and calculates a CRC32:
        </p>
        <pre><code>std::string Port::ComputeFoundation(const std::string&amp; type,
    const std::string&amp; protocol,
    const std::string&amp; relay_protocol,
    const rtc::SocketAddress&amp; base_address) {
    rtc::StringBuilder sb;
    sb &lt;&lt; type
        &lt;&lt; base_address.ipaddr().ToString()
        &lt;&lt; protocol
        &lt;&lt; relay_protocol;
    return rtc::ToString(rtc::ComputeCrc32(sb.Release()));
}
</code>
        </pre>

        <p>
            The test above uses <a href="https://niespodd.github.io/webrtc-local-ip-leak/lookup.json">a mapping of over 23&#39;000&#39;000
            hashes</a> for <a href="https://www.ibm.com/docs/en/networkmanager/4.2.0?topic=translation-private-address-ranges" rel="noreferrer nofollow">local IP ranges</a> to corresponding
            parameters. In a production environment this mapping would be rather stored server-side.
        </p>

        <h2>
            Footnotes üîê
        </h2>
        <p>
            This website does not collect, send or store your data. With a small exception for ICE candidate gathering
            where public STUN server from Google is used.
        </p>
    </div>
</div></div>
  </body>
</html>
