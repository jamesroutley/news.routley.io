<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://loggingsucks.com/">Original</a>
    <h1>Logging Sucks</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
      <div>
        <div>
          
          <p>And here&#39;s how to make it better.</p>
          
        </div>
        <div>
        <div>
          
          <div>
            <div>
              <p><span>2024-12-20T03:14:22.847Z</span> <span>INFO</span> <span>HttpServer started successfully binding=0.0.0.0:3000 pid=28471 env=production version=2.4.1 node_env=production cluster_mode=enabled workers=4</span></p>
              <p><span>2024-12-20T03:14:22.912Z</span> <span>debug</span> <span>PostgreSQL connection pool initialized host=db.internal:5432 database=main pool_size=20 ssl_mode=require idle_timeout=10000ms max_lifetime=1800000ms</span></p>
              <p><span>2024-12-20T03:14:23.156Z</span> <span>INFO</span> <span>Incoming request method=GET path=/api/v1/users/me ip=192.168.1.42 user_agent=&#34;Mozilla/5.0&#34; request_id=req_8f7a2b3c trace_id=abc123def456</span></p>
              <p><span>2024-12-20T03:14:23.201Z</span> <span>debug</span> <span>JWT token validation started issuer=auth.company.com audience=api.company.com exp=1703044800 iat=1703041200 sub=user_abc123 scope=&#34;read write&#34;</span></p>
              <p><span>2024-12-20T03:14:23.445Z</span> <span>WARN</span> <span>Slow database query detected duration_ms=847 query=&#34;SELECT u.*, o.name FROM users u JOIN orgs o ON u.org_id = o.id WHERE u.org_id = $1 AND u.deleted_at IS NULL&#34; rows_returned=2847</span></p>
              <p><span>2024-12-20T03:14:23.892Z</span> <span>debug</span> <span>Redis cache lookup failed key=users:org_12345:list:v2 ttl_seconds=3600 fallback_strategy=database cache_cluster=redis-prod-01 latency_ms=2</span></p>
              <p><span>2024-12-20T03:14:24.156Z</span> <span>info</span> <span>Request completed successfully status=200 duration_ms=1247 bytes_sent=48291 request_id=req_8f7a2b3c cache_hit=false db_queries=3 external_calls=1</span></p>
              <p><span>2024-12-20T03:14:24.312Z</span> <span>ERROR</span> <span>Database connection pool exhausted active_connections=20 waiting_requests=147 timeout_ms=30000 service=postgres suggestion=&#34;Consider increasing pool_size or optimizing queries&#34;</span></p>
              <p><span>2024-12-20T03:14:24.445Z</span> <span>warn</span> <span>Retrying failed HTTP request attempt=1 max_attempts=3 backoff_ms=100 error_code=ETIMEDOUT target_service=payment-gateway endpoint=/v1/charges circuit_state=closed</span></p>
              <p><span>2024-12-20T03:14:25.112Z</span> <span>INFO</span> <span>Circuit breaker state transition service=payment-api previous_state=closed current_state=open failure_count=5 failure_threshold=5 reset_timeout_ms=30000</span></p>
              <p><span>2024-12-20T03:14:25.445Z</span> <span>debug</span> <span>Background job executed successfully job_id=job_9x8w7v6u type=weekly_email_digest duration_ms=2341 emails_sent=1847 failures=3 queue=default priority=low</span></p>
              <p><span>2024-12-20T03:14:26.201Z</span> <span>ERROR</span> <span>Memory pressure critical heap_used_bytes=1932735283 heap_limit_bytes=2147483648 gc_pause_ms=847 gc_type=major rss_bytes=2415919104 external_bytes=8847291</span></p>
              <p><span>2024-12-20T03:14:26.556Z</span> <span>WARN</span> <span>Rate limit threshold approaching user_id=user_abc123 current_requests=890 limit=1000 window_seconds=60 remaining=110 reset_at=2024-12-20T03:15:00Z</span></p>
              <p><span>2024-12-20T03:14:27.112Z</span> <span>info</span> <span>WebSocket connection established client_id=ws_7f8g9h2j protocol=wss rooms=[&#34;team_updates&#34;,&#34;notifications&#34;,&#34;presence&#34;] user_id=user_abc123 ip=192.168.1.42</span></p>
              <p><span>2024-12-20T03:14:27.445Z</span> <span>debug</span> <span>Kafka message consumed successfully topic=user-events partition=3 offset=1847291 key=user_abc123 consumer_group=api-consumers lag=12 processing_time_ms=45</span></p>
              <p><span>2024-12-20T03:14:28.112Z</span> <span>INFO</span> <span>Health check passed service=api-gateway uptime_seconds=847291 active_connections=142 memory_usage_percent=73 cpu_usage_percent=45 status=healthy version=2.4.1</span></p>
              <p><span>2024-12-20T03:14:28.556Z</span> <span>debug</span> <span>S3 upload completed bucket=company-uploads key=avatars/user_abc123/profile.jpg size_bytes=245891 content_type=image/jpeg duration_ms=892 region=us-east-1</span></p>
              <p><span>2024-12-20T03:14:29.112Z</span> <span>warn</span> <span>Deprecated API version detected endpoint=/api/v1/legacy/users version=v1 recommended_version=v3 deprecation_date=2025-01-15 client_id=mobile-app-ios</span></p>
              <!-- Duplicate for seamless loop -->
              <p><span>2024-12-20T03:14:22.847Z</span> <span>INFO</span> <span>HttpServer started successfully binding=0.0.0.0:3000 pid=28471 env=production version=2.4.1 node_env=production cluster_mode=enabled workers=4</span></p>
              <p><span>2024-12-20T03:14:22.912Z</span> <span>debug</span> <span>PostgreSQL connection pool initialized host=db.internal:5432 database=main pool_size=20 ssl_mode=require idle_timeout=10000ms max_lifetime=1800000ms</span></p>
              <p><span>2024-12-20T03:14:23.156Z</span> <span>INFO</span> <span>Incoming request method=GET path=/api/v1/users/me ip=192.168.1.42 user_agent=&#34;Mozilla/5.0&#34; request_id=req_8f7a2b3c trace_id=abc123def456</span></p>
              <p><span>2024-12-20T03:14:23.201Z</span> <span>debug</span> <span>JWT token validation started issuer=auth.company.com audience=api.company.com exp=1703044800 iat=1703041200 sub=user_abc123 scope=&#34;read write&#34;</span></p>
              <p><span>2024-12-20T03:14:23.445Z</span> <span>WARN</span> <span>Slow database query detected duration_ms=847 query=&#34;SELECT u.*, o.name FROM users u JOIN orgs o ON u.org_id = o.id WHERE u.org_id = $1 AND u.deleted_at IS NULL&#34; rows_returned=2847</span></p>
              <p><span>2024-12-20T03:14:23.892Z</span> <span>debug</span> <span>Redis cache lookup failed key=users:org_12345:list:v2 ttl_seconds=3600 fallback_strategy=database cache_cluster=redis-prod-01 latency_ms=2</span></p>
              <p><span>2024-12-20T03:14:24.156Z</span> <span>info</span> <span>Request completed successfully status=200 duration_ms=1247 bytes_sent=48291 request_id=req_8f7a2b3c cache_hit=false db_queries=3 external_calls=1</span></p>
              <p><span>2024-12-20T03:14:24.312Z</span> <span>ERROR</span> <span>Database connection pool exhausted active_connections=20 waiting_requests=147 timeout_ms=30000 service=postgres suggestion=&#34;Consider increasing pool_size or optimizing queries&#34;</span></p>
              <p><span>2024-12-20T03:14:24.445Z</span> <span>warn</span> <span>Retrying failed HTTP request attempt=1 max_attempts=3 backoff_ms=100 error_code=ETIMEDOUT target_service=payment-gateway endpoint=/v1/charges circuit_state=closed</span></p>
              <p><span>2024-12-20T03:14:25.112Z</span> <span>INFO</span> <span>Circuit breaker state transition service=payment-api previous_state=closed current_state=open failure_count=5 failure_threshold=5 reset_timeout_ms=30000</span></p>
              <p><span>2024-12-20T03:14:25.445Z</span> <span>debug</span> <span>Background job executed successfully job_id=job_9x8w7v6u type=weekly_email_digest duration_ms=2341 emails_sent=1847 failures=3 queue=default priority=low</span></p>
              <p><span>2024-12-20T03:14:26.201Z</span> <span>ERROR</span> <span>Memory pressure critical heap_used_bytes=1932735283 heap_limit_bytes=2147483648 gc_pause_ms=847 gc_type=major rss_bytes=2415919104 external_bytes=8847291</span></p>
              <p><span>2024-12-20T03:14:26.556Z</span> <span>WARN</span> <span>Rate limit threshold approaching user_id=user_abc123 current_requests=890 limit=1000 window_seconds=60 remaining=110 reset_at=2024-12-20T03:15:00Z</span></p>
              <p><span>2024-12-20T03:14:27.112Z</span> <span>info</span> <span>WebSocket connection established client_id=ws_7f8g9h2j protocol=wss rooms=[&#34;team_updates&#34;,&#34;notifications&#34;,&#34;presence&#34;] user_id=user_abc123 ip=192.168.1.42</span></p>
              <p><span>2024-12-20T03:14:27.445Z</span> <span>debug</span> <span>Kafka message consumed successfully topic=user-events partition=3 offset=1847291 key=user_abc123 consumer_group=api-consumers lag=12 processing_time_ms=45</span></p>
              <p><span>2024-12-20T03:14:28.112Z</span> <span>INFO</span> <span>Health check passed service=api-gateway uptime_seconds=847291 active_connections=142 memory_usage_percent=73 cpu_usage_percent=45 status=healthy version=2.4.1</span></p>
              <p><span>2024-12-20T03:14:28.556Z</span> <span>debug</span> <span>S3 upload completed bucket=company-uploads key=avatars/user_abc123/profile.jpg size_bytes=245891 content_type=image/jpeg duration_ms=892 region=us-east-1</span></p>
              <p><span>2024-12-20T03:14:29.112Z</span> <span>warn</span> <span>Deprecated API version detected endpoint=/api/v1/legacy/users version=v1 recommended_version=v3 deprecation_date=2025-01-15 client_id=mobile-app-ios</span></p>
            </div>
          </div>
        </div>
        </div>
      </div>
      
    </section>

    <section>
      <div>
        <p>Your logs are lying to you. Not maliciously. They&#39;re just not equipped to tell the truth.</p>
<p>You&#39;ve probably spent hours grep-ing through logs trying to understand why a user couldn&#39;t check out, why that webhook failed, or why your p99 latency spiked at 3am. You found nothing useful. Just timestamps and vague messages that mock you with their uselessness.</p>
<p>This isn&#39;t your fault. <strong>Logging, as it&#39;s commonly practiced, is fundamentally broken.</strong> And no, slapping OpenTelemetry on your codebase won&#39;t magically fix it.</p>
<p>Let me show you what&#39;s wrong, and more importantly, how to fix it.</p>

<h2>The Core Problem</h2>
<p>Logs were designed for a different era. An era of monoliths, single servers, and problems you could reproduce locally. Today, a single user request might touch 15 services, 3 databases, 2 caches, and a message queue. Your logs are still acting like it&#39;s 2005.</p>
<p>Here&#39;s what a typical logging setup looks like:</p>
<div id="log-chaos-simulator">
  <div>
    <p>The Log Chaos Simulator</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<p>That&#39;s 13 log lines for a single successful request. Now multiply that by 10,000 concurrent users. You&#39;ve got 130,000 log lines per second. Most of them saying absolutely nothing useful.</p>
<p>But here&#39;s the real problem: when something goes wrong, these logs won&#39;t help you. They&#39;re missing the one thing you need: <strong>context</strong>.</p>

<h2>Why String Search is Broken</h2>
<p>When a user reports &#34;I can&#39;t complete my purchase,&#34; your first instinct is to search your logs. You type their email, or maybe their user ID, and hit enter.</p>
<div id="futile-search">
  <div>
    <p>The Futile Search</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<p>String search treats logs as bags of characters. It has no understanding of structure, no concept of relationships, no way to correlate events across services.</p>
<ul>When you search for &#34;user-123&#34;, you might find it logged 47 different ways across your codebase:
<li><code>user-123</code></li>
<li><code>user_id=user-123</code></li>
<li><code>{&#34;userId&#34;: &#34;user-123&#34;}</code></li>
<li><code>[USER:user-123]</code></li>
<li><code>processing user: user-123</code></li></ul>
<p>And those are just the logs that <em>include</em> the user ID. What about the downstream service that only logged the order ID? Now you need a second search. And a third. You&#39;re playing detective with one hand tied behind your back.</p>
<blockquote>The fundamental problem: logs are optimized for <em>writing</em>, not for <em>querying</em>.</blockquote>
<p>Developers write <code>console.log(&#34;Payment failed&#34;)</code> because it&#39;s easy in the moment. Nobody thinks about the poor soul who&#39;ll be searching for this at 2am during an outage.</p>

<h2>Let&#39;s Define Some Terms</h2>
<p>Before I show you the fix, let me define some terms. These get thrown around a lot, often incorrectly.</p>
<p><strong>Structured Logging</strong>: Logs emitted as key-value pairs (usually JSON) instead of plain strings. <code>{&#34;event&#34;: &#34;payment_failed&#34;, &#34;user_id&#34;: &#34;123&#34;}</code> instead of <code>&#34;Payment failed for user 123&#34;</code>. Structured logging is necessary but not sufficient.</p>
<p><strong>Cardinality</strong>: The number of unique values a field can have. <code>user_id</code> has high cardinality (millions of unique values). <code>http_method</code> has low cardinality (GET, POST, PUT, DELETE, etc.). High cardinality fields are what make logs actually useful for debugging.</p>
<p><strong>Dimensionality</strong>: The number of fields in your log event. A log with 5 fields has low dimensionality. A log with 50 fields has high dimensionality. More dimensions = more questions you can answer.</p>
<p><strong>Wide Event</strong>: A single, context-rich log event emitted per request per service. Instead of 13 log lines for one request, you emit 1 line with 50+ fields containing everything you might need to debug.</p>
<p><strong>Canonical Log Line</strong>: Another term for wide event, popularized by Stripe. One log line per request that serves as the authoritative record of what happened.</p>
<div id="cardinality-explorer">
  <div>
    <p>Cardinality Explorer</p>
    <p>Loading interactive demo...</p>
  </div>
</div>

<h2>OpenTelemetry Won&#39;t Save You</h2>
<p>I see this take constantly: &#34;Just use OpenTelemetry and your observability problems are solved.&#34;</p>
<p>No. OpenTelemetry is a <strong>protocol and a set of SDKs</strong>. It standardizes how telemetry data (logs, traces, metrics) is collected and exported. This is genuinely useful: it means you&#39;re not locked into a specific vendor&#39;s format.</p>
<p>But here&#39;s what OpenTelemetry does NOT do:</p>
<p>1. <strong>It doesn&#39;t decide what to log.</strong> You still have to instrument your code deliberately.</p>
<div id="otel-reality-check">
  <div>
    <p>The OTel Reality Check</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<p>OpenTelemetry is a delivery mechanism. It doesn&#39;t know that <code>user-789</code> is a premium customer who&#39;s been with you for 3 years and just tried to spend $160. <strong>You</strong> have to tell it.</p>

<h2>The Fix: Wide Events / Canonical Log Lines</h2>
<p>Here&#39;s the mental model shift that changes everything:</p>
<blockquote>Instead of logging <em>what your code is doing</em>, log <em>what happened to this request</em>.</blockquote>
<p>Stop thinking about logs as a debugging diary. Start thinking about them as a structured record of business events.</p>
<p>For each request, emit <strong>one wide event</strong> per service hop. This event should contain every piece of context that might be useful for debugging. Not just what went wrong, but the full picture of the request.</p>
<div id="wide-event-builder">
  <div>
    <p>Build a Wide Event</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<p>Here&#39;s what a wide event looks like in practice:</p>
<pre tabindex="0"><code><span><span>{</span></span>
<span><span>  &#34;timestamp&#34;</span><span>: </span><span>&#34;2025-01-15T10:23:45.612Z&#34;</span><span>,</span></span>
<span><span>  &#34;request_id&#34;</span><span>: </span><span>&#34;req_8bf7ec2d&#34;</span><span>,</span></span>
<span><span>  &#34;trace_id&#34;</span><span>: </span><span>&#34;abc123&#34;</span><span>,</span></span>
<span></span>
<span><span>  &#34;service&#34;</span><span>: </span><span>&#34;checkout-service&#34;</span><span>,</span></span>
<span><span>  &#34;version&#34;</span><span>: </span><span>&#34;2.4.1&#34;</span><span>,</span></span>
<span><span>  &#34;deployment_id&#34;</span><span>: </span><span>&#34;deploy_789&#34;</span><span>,</span></span>
<span><span>  &#34;region&#34;</span><span>: </span><span>&#34;us-east-1&#34;</span><span>,</span></span>
<span></span>
<span><span>  &#34;method&#34;</span><span>: </span><span>&#34;POST&#34;</span><span>,</span></span>
<span><span>  &#34;path&#34;</span><span>: </span><span>&#34;/api/checkout&#34;</span><span>,</span></span>
<span><span>  &#34;status_code&#34;</span><span>: </span><span>500</span><span>,</span></span>
<span><span>  &#34;duration_ms&#34;</span><span>: </span><span>1247</span><span>,</span></span>
<span></span>
<span><span>  &#34;user&#34;</span><span>: {</span></span>
<span><span>    &#34;id&#34;</span><span>: </span><span>&#34;user_456&#34;</span><span>,</span></span>
<span><span>    &#34;subscription&#34;</span><span>: </span><span>&#34;premium&#34;</span><span>,</span></span>
<span><span>    &#34;account_age_days&#34;</span><span>: </span><span>847</span><span>,</span></span>
<span><span>    &#34;lifetime_value_cents&#34;</span><span>: </span><span>284700</span></span>
<span><span>  },</span></span>
<span></span>
<span><span>  &#34;cart&#34;</span><span>: {</span></span>
<span><span>    &#34;id&#34;</span><span>: </span><span>&#34;cart_xyz&#34;</span><span>,</span></span>
<span><span>    &#34;item_count&#34;</span><span>: </span><span>3</span><span>,</span></span>
<span><span>    &#34;total_cents&#34;</span><span>: </span><span>15999</span><span>,</span></span>
<span><span>    &#34;coupon_applied&#34;</span><span>: </span><span>&#34;SAVE20&#34;</span></span>
<span><span>  },</span></span>
<span></span>
<span><span>  &#34;payment&#34;</span><span>: {</span></span>
<span><span>    &#34;method&#34;</span><span>: </span><span>&#34;card&#34;</span><span>,</span></span>
<span><span>    &#34;provider&#34;</span><span>: </span><span>&#34;stripe&#34;</span><span>,</span></span>
<span><span>    &#34;latency_ms&#34;</span><span>: </span><span>1089</span><span>,</span></span>
<span><span>    &#34;attempt&#34;</span><span>: </span><span>3</span></span>
<span><span>  },</span></span>
<span></span>
<span><span>  &#34;error&#34;</span><span>: {</span></span>
<span><span>    &#34;type&#34;</span><span>: </span><span>&#34;PaymentError&#34;</span><span>,</span></span>
<span><span>    &#34;code&#34;</span><span>: </span><span>&#34;card_declined&#34;</span><span>,</span></span>
<span><span>    &#34;message&#34;</span><span>: </span><span>&#34;Card declined by issuer&#34;</span><span>,</span></span>
<span><span>    &#34;retriable&#34;</span><span>: </span><span>false</span><span>,</span></span>
<span><span>    &#34;stripe_decline_code&#34;</span><span>: </span><span>&#34;insufficient_funds&#34;</span></span>
<span><span>  },</span></span>
<span></span>
<span><span>  &#34;feature_flags&#34;</span><span>: {</span></span>
<span><span>    &#34;new_checkout_flow&#34;</span><span>: </span><span>true</span><span>,</span></span>
<span><span>    &#34;express_payment&#34;</span><span>: </span><span>false</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<ul>One event. Everything you need. When this user complains, you search for <code>user_id = &#34;user_456&#34;</code> and you instantly know:
<li>They&#39;re a premium customer (high priority)</li>
<li>They&#39;ve been with you for over 2 years (very high priority)</li>
<li>The payment failed on the 3rd attempt</li>
<li>The actual reason: insufficient funds</li>
<li>They were using the new checkout flow (potential correlation?)</li></ul>
<p>No grep-ing. No guessing. No second search.</p>

<h2>The Queries You Can Now Run</h2>
<p>With wide events, you&#39;re not searching text anymore. You&#39;re querying structured data. The difference is night and day.</p>
<div id="query-playground">
  <div>
    <p>Query Playground</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<p>This is the superpower of wide events combined with high-cardinality, high-dimensionality data. You&#39;re not searching logs anymore. You&#39;re running analytics on your production traffic.</p>

<h2>Implementing Wide Events</h2>
<p>Here&#39;s a practical implementation pattern. The key insight: build the event throughout the request lifecycle, then emit once at the end.</p>
<pre tabindex="0"><code><span><span>// middleware/wideEvent.ts</span></span>
<span><span>export</span><span> function</span><span> wideEventMiddleware</span><span>() {</span></span>
<span><span>  return</span><span> async</span><span> (</span><span>ctx</span><span>, </span><span>next</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    const</span><span> startTime</span><span> =</span><span> Date.</span><span>now</span><span>();</span></span>
<span></span>
<span><span>    // Initialize the wide event with request context</span></span>
<span><span>    const</span><span> event</span><span>:</span><span> Record</span><span>&lt;</span><span>string</span><span>, </span><span>unknown</span><span>&gt; </span><span>=</span><span> {</span></span>
<span><span>      request_id: ctx.</span><span>get</span><span>(</span><span>&#39;requestId&#39;</span><span>),</span></span>
<span><span>      timestamp: </span><span>new</span><span> Date</span><span>().</span><span>toISOString</span><span>(),</span></span>
<span><span>      method: ctx.req.method,</span></span>
<span><span>      path: ctx.req.path,</span></span>
<span><span>      service: process.env.</span><span>SERVICE_NAME</span><span>,</span></span>
<span><span>      version: process.env.</span><span>SERVICE_VERSION</span><span>,</span></span>
<span><span>      deployment_id: process.env.</span><span>DEPLOYMENT_ID</span><span>,</span></span>
<span><span>      region: process.env.</span><span>REGION</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // Make the event accessible to handlers</span></span>
<span><span>    ctx.</span><span>set</span><span>(</span><span>&#39;wideEvent&#39;</span><span>, event);</span></span>
<span></span>
<span><span>    try</span><span> {</span></span>
<span><span>      await</span><span> next</span><span>();</span></span>
<span><span>      event.status_code </span><span>=</span><span> ctx.res.status;</span></span>
<span><span>      event.outcome </span><span>=</span><span> &#39;success&#39;</span><span>;</span></span>
<span><span>    } </span><span>catch</span><span> (error) {</span></span>
<span><span>      event.status_code </span><span>=</span><span> 500</span><span>;</span></span>
<span><span>      event.outcome </span><span>=</span><span> &#39;error&#39;</span><span>;</span></span>
<span><span>      event.error </span><span>=</span><span> {</span></span>
<span><span>        type: error.name,</span></span>
<span><span>        message: error.message,</span></span>
<span><span>        code: error.code,</span></span>
<span><span>        retriable: error.retriable </span><span>??</span><span> false</span><span>,</span></span>
<span><span>      };</span></span>
<span><span>      throw</span><span> error;</span></span>
<span><span>    } </span><span>finally</span><span> {</span></span>
<span><span>      event.duration_ms </span><span>=</span><span> Date.</span><span>now</span><span>() </span><span>-</span><span> startTime;</span></span>
<span></span>
<span><span>      // Emit the wide event</span></span>
<span><span>      logger.</span><span>info</span><span>(event);</span></span>
<span><span>    }</span></span>
<span><span>  };</span></span>
<span><span>}</span></span></code></pre>
<p>Then in your handlers, you enrich the event with business context:</p>
<pre tabindex="0"><code><span><span>app.</span><span>post</span><span>(</span><span>&#39;/checkout&#39;</span><span>, </span><span>async</span><span> (</span><span>ctx</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> event</span><span> =</span><span> ctx.</span><span>get</span><span>(</span><span>&#39;wideEvent&#39;</span><span>);</span></span>
<span><span>  const</span><span> user</span><span> =</span><span> ctx.</span><span>get</span><span>(</span><span>&#39;user&#39;</span><span>);</span></span>
<span></span>
<span><span>  // Add user context</span></span>
<span><span>  event.user </span><span>=</span><span> {</span></span>
<span><span>    id: user.id,</span></span>
<span><span>    subscription: user.subscription,</span></span>
<span><span>    account_age_days: </span><span>daysSince</span><span>(user.createdAt),</span></span>
<span><span>    lifetime_value_cents: user.ltv,</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  // Add business context as you process</span></span>
<span><span>  const</span><span> cart</span><span> =</span><span> await</span><span> getCart</span><span>(user.id);</span></span>
<span><span>  event.cart </span><span>=</span><span> {</span></span>
<span><span>    id: cart.id,</span></span>
<span><span>    item_count: cart.items.</span><span>length</span><span>,</span></span>
<span><span>    total_cents: cart.total,</span></span>
<span><span>    coupon_applied: cart.coupon?.code,</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  // Process payment</span></span>
<span><span>  const</span><span> paymentStart</span><span> =</span><span> Date.</span><span>now</span><span>();</span></span>
<span><span>  const</span><span> payment</span><span> =</span><span> await</span><span> processPayment</span><span>(cart, user);</span></span>
<span></span>
<span><span>  event.payment </span><span>=</span><span> {</span></span>
<span><span>    method: payment.method,</span></span>
<span><span>    provider: payment.provider,</span></span>
<span><span>    latency_ms: Date.</span><span>now</span><span>() </span><span>-</span><span> paymentStart,</span></span>
<span><span>    attempt: payment.attemptNumber,</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  // If payment fails, add error details</span></span>
<span><span>  if</span><span> (payment.error) {</span></span>
<span><span>    event.error </span><span>=</span><span> {</span></span>
<span><span>      type: </span><span>&#39;PaymentError&#39;</span><span>,</span></span>
<span><span>      code: payment.error.code,</span></span>
<span><span>      stripe_decline_code: payment.error.declineCode,</span></span>
<span><span>    };</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  return</span><span> ctx.</span><span>json</span><span>({ orderId: payment.orderId });</span></span>
<span><span>});</span></span></code></pre>
<div id="event-lifecycle">
  <div>
    <p>Wide Event Builder Simulator</p>
    <p>Loading interactive demo...</p>
  </div>
</div>

<h2>Sampling: Keeping Costs Under Control</h2>
<p>&#34;But Boris,&#34; I hear you saying, &#34;if I log 50 fields per request at 10,000 requests per second, my observability bill will bankrupt me.&#34;</p>
<p>Valid concern. This is where <strong>sampling</strong> comes in.</p>
<p><strong>Sampling</strong> means keeping only a percentage of your events. Instead of storing 100% of traffic, you might store 10% or 1%. At scale, this is the only way to stay sane (and solvent).</p>
<p>But naive sampling is dangerous. If you randomly sample 1% of traffic, you might accidentally drop the one request that explains your outage.</p>
<div id="sampling-trap">
  <div>
    <p>The Sampling Trap</p>
    <p>Loading interactive demo...</p>
  </div>
</div>
<h3>Tail Sampling</h3>
<p><strong>Tail sampling</strong> means you make the sampling decision <em>after</em> the request completes, based on its outcome.</p>
<p>The rules are simple:</p>
<p>This gives you the best of both worlds: manageable costs, but you never lose the events that matter.</p>
<pre tabindex="0"><code><span><span>// Tail sampling decision function</span></span>
<span><span>function</span><span> shouldSample</span><span>(</span><span>event</span><span>:</span><span> WideEvent</span><span>)</span><span>:</span><span> boolean</span><span> {</span></span>
<span><span>  // Always keep errors</span></span>
<span><span>  if</span><span> (event.status_code </span><span>&gt;=</span><span> 500</span><span>) </span><span>return</span><span> true</span><span>;</span></span>
<span><span>  if</span><span> (event.error) </span><span>return</span><span> true</span><span>;</span></span>
<span></span>
<span><span>  // Always keep slow requests (above p99)</span></span>
<span><span>  if</span><span> (event.duration_ms </span><span>&gt;</span><span> 2000</span><span>) </span><span>return</span><span> true</span><span>;</span></span>
<span></span>
<span><span>  // Always keep VIP users</span></span>
<span><span>  if</span><span> (event.user?.subscription </span><span>===</span><span> &#39;enterprise&#39;</span><span>) </span><span>return</span><span> true</span><span>;</span></span>
<span></span>
<span><span>  // Always keep requests with specific feature flags (debugging rollouts)</span></span>
<span><span>  if</span><span> (event.feature_flags?.new_checkout_flow) </span><span>return</span><span> true</span><span>;</span></span>
<span></span>
<span><span>  // Random sample the rest at 5%</span></span>
<span><span>  return</span><span> Math.</span><span>random</span><span>() </span><span>&lt;</span><span> 0.05</span><span>;</span></span>
<span><span>}</span></span></code></pre>

<h2>Misconceptions</h2>
<h3>&#34;Structured logging is the same as wide events&#34;</h3>
<p>No. Structured logging means your logs are JSON instead of strings. That&#39;s table stakes. Wide events are a <em>philosophy</em>: one comprehensive event per request, with all context attached. You can have structured logs that are still useless (5 fields, no user context, scattered across 20 log lines).</p>
<h3>&#34;We already use OpenTelemetry, so we&#39;re good&#34;</h3>
<p>You&#39;re using a delivery mechanism. OpenTelemetry doesn&#39;t decide what to capture. You do. Most OTel implementations I&#39;ve seen capture the bare minimum: span name, duration, status. That&#39;s not enough. You need to deliberately instrument with business context.</p>
<h3>&#34;This is just tracing with extra steps&#34;</h3>
<p>Tracing gives you request flow across services (which service called which). Wide events give you context <em>within</em> a service. They&#39;re complementary. <strong>Ideally, your wide events ARE your trace spans, enriched with all the context you need</strong>.</p>
<h3>&#34;Logs are for debugging, metrics are for dashboards&#34;</h3>
<p>This distinction is artificial and harmful. Wide events can power both. Query them for debugging. Aggregate them for dashboards. The data is the same, just different views.</p>
<h3>&#34;High-cardinality data is expensive and slow&#34;</h3>
<p>It&#39;s expensive on <em>legacy logging systems</em> built for low-cardinality string search. Modern columnar databases (ClickHouse, BigQuery, etc.) are specifically designed for high-cardinality, high-dimensionality data. The tooling has caught up. Your practices should too.</p>
<h2>The Payoff</h2>
<p>When you implement wide events properly, debugging transforms from archaeology to analytics.</p>
<p>Instead of: <em>&#34;The user said checkout failed. Let me grep through 50 services and hope I find something.&#34;</em></p>
<p>You get: <em>&#34;Show me all checkout failures for premium users in the last hour where the new checkout flow was enabled, grouped by error code.&#34;</em></p>
<p>One query. Sub-second results. Root cause identified.</p>
<p>Your logs stop lying to you. They start telling the truth. The whole truth.</p>

<p>Complete the form below to get a personalized report on your stack. I&#39;ll tell you what&#39;s working, what&#39;s not, and where you can save money. I genuinely want to hear about your logging nightmares :)</p>
      </div>
    </section>

    <section id="signup">
      <div>
        <p>Free in 30 seconds</p>
        <h2>Get your stack roasted.</h2>
        <p>Answer a few questions and I&#39;ll send you a personalized report with:</p>
        <ul>
          <li>Where wide events would have the biggest impact on your stack</li>
          <li>What to log (and what to stop logging)</li>
          <li>Which tools are worth the cost (and which aren&#39;t)</li>
          <li>Quick wins you can ship this week</li>
        </ul>
        <p>Questions? Logging horror stories? Drop them in the comments below.</p>

        <div>
          
          
          <p>Your logs are just as empty.</p>
        </div>

        

        <div id="instant-analysis">
          <h3>Your stack has been judged.</h3>
          
          <p>Check your email for a detailed analysis.</p>
        </div>
      </div>
    </section>
  </div></div>
  </body>
</html>
