<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stripe.com/blog/markdoc">Original</a>
    <h1>Interactive Docs with Markdoc</h1>
    
    <div id="readability-page-1" class="page"><section>
    <p>At Stripe, our <a href="https://stripe.com/docs" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">product docs</a> are designed to feel like an application rather than a traditional user manual. For example, we incorporate a user&#39;s own API test key into code samples, making it possible to copy and paste code that seamlessly works with the user&#39;s own account. We have client-side interactivity, like checklists and collapsible sections. We tailor the content to the individual user, conditionally displaying content based on their location or the Stripe features they use. These features result in a high-quality user experience that reduces friction and contributes to the success of developers.</p><p>For these capabilities to have the desired impact we have to make it easy for writers to use them in their content. Delivering a good user experience without compromising the authoring experience required us to develop an authoring format that enables writers to express interactivity and simple page logic without mixing code and content.</p><p>Over several years, we learned how to balance interactivity, customization, and authoring productivity while undertaking a major overhaul of our documentation platform.</p><h2>Past is prologue</h2><p>To understand how we got here it&#39;s important to understand where we started. The legacy documentation platform that we replaced was a monolithic Ruby application built with <a href="https://github.com/ruby/erb/blob/master/README.md" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">ERB templates</a> and Sinatra routing. The content freely mixed HTML, Markdown, Ruby, and ERB helper functions.</p><p>Mixing code and content provided a natural way to programmatically tailor the docs to the developer, but it posed serious challenges to quality and maintainability when the body of content grew to hundreds of pages. Alongside the technical burden of maintaining code within the content, the behavior of the code can make the content itself harder to understand and manipulate safely, particularly when used by many different teams with different objectives, timetables, and areas of expertise. Content authoring effectively became software development, and with that became subject to the same technical complexity and overhead. </p><p>We wanted to introduce new content formats with significantly more interactivity and more sophisticated frontend logic, but we knew that the limitations of a code-first approach would prevent us from using these features widely. For example, our <a href="https://stripe.com/docs/payments/quickstart" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">integration builder</a> format, which was originally created as a React application with content authored in JSON, became much easier for technical writers to reproduce and maintain when it was migrated to use Markdoc for the authoring experience.</p><h2>Designing Markdoc</h2><p>When we began building our current documentation platform, we wanted to simplify our authoring experience by adopting an intuitive format like <a href="https://daringfireball.net/projects/markdown/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Markdown</a>. Although Markdown is significantly easier to read and reason about than ERB templates, its simplicity also imposes limitations that make it challenging to use for rich content like our product docs.</p><p>Markdown is a relatively flat format that isn&#39;t designed to express complex structure or hierarchy. It offers a small number of formatting features and provides limited control over presentation. It does not have exotic templating features like support for custom page logic, variables, conditionals, or content reuse. Markdown&#39;s enduring success and relative ubiquity are largely due to its intentionally narrow scope and the restraint exercised in its design. It is easy and enjoyable to use because it prioritizes readability and leans heavily on intuitive plain-text authoring conventions.</p><p>Our custom authoring format, called <a href="https://markdoc.dev/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Markdoc</a>, was designed to decouple code and content while enforcing proper discipline at the boundaries. Instead of allowing each page to be treated like an open-ended application, it imposes constraints on styling and programming, providing prescriptive rails for content extensibility. It extends Markdown with <a href="https://markdoc.dev/docs/syntax" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">custom syntax </a>that meets the needs of our documentation platform without sacrificing Markdown&#39;s simplicity, familiarity, or ease of use for writing prose. Following the ethos and design sensibility of Markdown, Markdoc keeps the overall surface area of new features small by adding a few highly-composable primitives that can be used together to express all the functionality we need.</p><p>Markdoc provides an extensible system for <a href="https://markdoc.dev/docs/tags" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">defining custom tags</a> that can be used seamlessly in Markdown content. Using the custom tag syntax, we&#39;re able to support features like conditional content, content inclusion, and variable interpolation.</p><p>The features we decided to leave out of Markdoc in order to protect content maintainability are a critical aspect of its design. For example, when deciding what built-in flow control to include in Markdoc, we deliberately chose not to include looping. We wanted to discourage writers from performing procedural content generation from inside of a document, forcing them to move it outside of the system for better encapsulation. We also decided to leave out variable assignment in order to ensure that the content is fully stateless, thus eliminating an entire class of potential bugs.</p><blockquote>
  <svg width="15" height="11" viewBox="0 0 15 11" xmlns="http://www.w3.org/2000/svg"><path d="M15 1.72c-1.96.95-2.94 2.07-2.94 3.36.83.1 1.53.44 2.07 1.02.55.58.82 1.25.82 2.01a2.81 2.81 0 0 1-2.8 2.89c-.9 0-1.68-.36-2.33-1.09a3.78 3.78 0 0 1-1-2.63c0-3.1 1.76-5.53 5.26-7.28L15 1.72zm-8.83 0c-1.97.95-2.96 2.07-2.96 3.36.85.1 1.55.44 2.1 1.02.54.58.82 1.25.82 2.01A2.82 2.82 0 0 1 3.3 11 3 3 0 0 1 .98 9.91 3.8 3.8 0 0 1 0 7.28C0 4.18 1.74 1.75 5.23 0l.94 1.72z" fill="#635BFF" fill-rule="nonzero"></path></svg>
  <p>I like Markdoc because it lets us still do anything we want with code in the docs without bogging down the content authoring experience. If we need some new component, designers and engineers can whip that up. So as a writer, I can work in the docs content and stay focused.</p>
  
</blockquote><h2>React integration</h2><p>Markdoc has a modular rendering system that supports multiple output formats. Using Markdoc’s React renderer, a Markdoc document can be rendered to a React virtual DOM. Custom Markdoc tags can be configured to <a href="https://markdoc.dev/docs/render#react" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">output React components</a>, passing through tag attributes as React props. Markdoc also supports assigning custom React components to <a href="https://markdoc.dev/docs/nodes" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">standard Markdown document nodes</a> such as headings and paragraphs.</p><p>Defining custom Markdoc tags that output React components makes it possible to include interactive features, like tab switchers and collapsible content sections, inside of documents. Using custom tags to express these features helps create a writer-friendly interface for the functionality.</p><p>The React ecosystem also has a wealth of useful and interesting libraries that we can incorporate into our documentation to enrich presentation. For example, we&#39;re using the <a href="https://reactflow.dev/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">React Flow</a> library to create interactive diagrams in our documentation. We defined a set of Markdoc tags for expressing the contents of a diagram, making it easy for writers to build beautiful and consistent visual representations of APIs and technical concepts from a set of composable elements.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.ctfassets.net/fzn2n1nzq965/3nSXx3uQbRq8fwq7PxDuw2/3eaa05604f335eb61c846848b61c6135/markdoc-graph-remini-enhanced.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="markdoc-graph-1" src="
        
          https://images.ctfassets.net/fzn2n1nzq965/3nSXx3uQbRq8fwq7PxDuw2/3eaa05604f335eb61c846848b61c6135/markdoc-graph-remini-enhanced.png?w=1620&amp;q=80
        
      " width="4096" height="2510" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Unlike static images, the diagrams that are built with React Flow can easily incorporate interactivity and clickable links. They are also easier to localize and can be restyled universally.</p><p>Moving our documentation frontend to React was an important goal of our platform overhaul. Stripe already used React across many parts of the user experience, including our API reference docs and user dashboard. Enabling integration and cross-pollination between those surfaces and the product docs opens up a lot of exciting opportunities for future innovation, like showing API reference overlays when the reader hovers their cursor over a function or parameter in a code example. Sharing a common set of components from Stripe&#39;s internal design pattern library helps improve cohesion.</p><p>React also offers some compelling technical advantages. The implementation of interactive frontend components in our legacy stack was split between markup ERB templates and logic written in JavaScript which made it difficult to properly encapsulate, extend, and reuse functionality—a set of problems that modern component-based frontend frameworks address in a more satisfying way.</p><p>Markdoc comes with two distinct React renderers: a renderer that dynamically builds the React virtual DOM tree on the client side, and a static renderer that transpiles the document to JavaScript code. We use the dynamic renderer in our documentation platform at Stripe, but the static renderer is useful in cases where you want to treat a piece of Markdoc content as though it is a React component or JavaScript module. For example, the static renderer makes it possible to implement a Markdoc loader for Webpack in only five lines of code.</p><h2>Modular rendering</h2><p>Alongside the React renderers, Markdoc also includes a string-based HTML renderer that can be used for conventional server-side rendering or <a href="https://markdoc.io/docs/examples/html" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">integration with standards-based Web Components</a>. Markdoc&#39;s modular rendering architecture makes it possible for third parties to build custom renderers for additional frameworks and systems.</p><p>Markdoc content is entirely agonistic with respect to the technology used to present the rendered document. Fully decoupling rendering from the document format gives us the flexibility to present the same content in radically different ways in the future—like incorporating it into a native mobile application or generating a print-ready output format such as a PDF. I even used Markdoc to make the slide deck for my <a href="https://www.writethedocs.org/videos/portland/2020/documentation-as-an-application-enabling-interactive-content-that-is-tailored-to-the-user-ryan-paul/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">presentation</a> at the Write the Docs conference back in 2020. The Markdoc community has already started bringing support to other frameworks, including <a href="https://github.com/wobsoriano/vue-markdoc" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Vue</a> and <a href="https://github.com/joshnuss/svelte-markdoc" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Svelte</a>.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.ctfassets.net/fzn2n1nzq965/76NczEJuqFic2ojolDDXKS/84286370b7ed763725a1131d93750aca/markdoc-slide-v2-enhanced-fx.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt=" markdoc-slides1" src="
        
          https://images.ctfassets.net/fzn2n1nzq965/76NczEJuqFic2ojolDDXKS/84286370b7ed763725a1131d93750aca/markdoc-slide-v2-enhanced-fx.png?w=1620&amp;q=80
        
      " width="4096" height="2564" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Ensuring that rendering implementation details don&#39;t bleed into the content also helps to improve the authoring experience, avoiding complexity and simplifying maintainability.</p><h2>Documentation as data</h2><p>Markdoc&#39;s fully declarative syntax parses to an <a href="https://markdoc.io/sandbox?mode=ast" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Abstract Syntax Tree (AST)</a>, a data structure that represents the content of the document. We can take advantage of the AST to perform advanced static analysis and programmatically manipulate our content.</p><p>Markdoc lets us treat our documentation like data, writing simple scripts to programmatically inspect the content. If we want to perform tasks like identifying all of the fenced code blocks that contain a specific string or all of the places where we have a heading nested inside of a callout, we can do that robustly with the AST instead of relying on text scraping and regular expressions.</p><p>We are building automated refactoring tools that use the AST, making it possible to perform complex edits across our entire body of content with a higher degree of robustness than old-fashioned find-and-replace.</p><p>One of the most important ways that we use the AST today is for <a href="https://markdoc.io/docs/validation" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">validation</a>. For every Markdoc tag and document node type, there&#39;s a schema definition specifying the names and types of the attributes it accepts, what kind of document nodes can be nested inside of it as children, and other relevant metadata. The Markdoc validator uses this information to verify the correctness of a given Markdoc document.</p><p>Schemas can also include arbitrary logic that analyzes the document nodes and returns custom errors. We use this to support features like link validation, checking to make sure that every link between pages within our documentation points to a valid route. It can also be useful for enforcing certain style guidelines that relate to the document structure, like preventing authors from using the wrong heading levels in certain places.</p><p>We run the Markdoc validator in our continuous integration system to ensure correctness at build time, but we also have an internal Visual Studio Code extension that exposes validation errors in real time while the user is typing.</p><blockquote>
  <svg width="15" height="11" viewBox="0 0 15 11" xmlns="http://www.w3.org/2000/svg"><path d="M15 1.72c-1.96.95-2.94 2.07-2.94 3.36.83.1 1.53.44 2.07 1.02.55.58.82 1.25.82 2.01a2.81 2.81 0 0 1-2.8 2.89c-.9 0-1.68-.36-2.33-1.09a3.78 3.78 0 0 1-1-2.63c0-3.1 1.76-5.53 5.26-7.28L15 1.72zm-8.83 0c-1.97.95-2.96 2.07-2.96 3.36.85.1 1.55.44 2.1 1.02.54.58.82 1.25.82 2.01A2.82 2.82 0 0 1 3.3 11 3 3 0 0 1 .98 9.91 3.8 3.8 0 0 1 0 7.28C0 4.18 1.74 1.75 5.23 0l.94 1.72z" fill="#635BFF" fill-rule="nonzero"></path></svg>
  <p>Markdoc makes it easy for me to build rich, interactive experiences around documentation, then surface that capability to other authors through a simple declarative interface.</p>
  
</blockquote><h2>Under the hood</h2><p>Markdoc&#39;s parser is written in JavaScript and built on top of a popular open-source Markdown library called <a href="https://github.com/markdown-it/markdown-it" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">markdown-it</a>. Markdoc is relatively lightweight—the markdown-it library is its only direct dependency. It is intended to run in Node.js and similar server-side JavaScript environments, but it can also be bundled for use in the browser.</p><p>Markdoc uses markdown-it as a tokenizer, building its AST from the array of tokens emitted by markdown-it. Parsing logic for Markdoc&#39;s custom tag syntax is generated from a <a href="https://pegjs.org/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">peg.js</a> grammar and integrates with markdown-it via a plugin.</p><p>Markdoc has its own dedicated rendering architecture rather than relying on markdown-it to generate its output. Developing an independent rendering system was necessary in order to handle Markdoc&#39;s custom tags and support multiple output formats.</p><p>Markdoc rendering is performed in several phases. First, the variable resolution step converts all of the variables in the document into their corresponding values. Next, the transformation step recursively walks through the document nodes in the AST and uses the node and tag schema definitions to generate a tree of renderable document nodes—a data structure that corresponds with the shape of the rendered output. Finally, the tree of renderable document nodes is passed into the desired renderer, which emits the actual rendered output.</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.ctfassets.net/fzn2n1nzq965/3y59bwdNgo7EY4Zbl1XNEe/6dc7cf04b94a5cdcba3ab81d978e78a3/markdoc-flow-graph-enhanced2.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="Markdoc rendering flow graph" src="
        
          https://images.ctfassets.net/fzn2n1nzq965/3y59bwdNgo7EY4Zbl1XNEe/6dc7cf04b94a5cdcba3ab81d978e78a3/markdoc-flow-graph-enhanced2.png?w=1620&amp;q=80
        
      " width="3843" height="143" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Markdoc document&#39;s AST can be serialized to JSON and cached for later use, improving performance by obviating the need to parse the document every time it is rendered. Our product documentation platform at Stripe maintains an in-memory cache of the AST at runtime, but we are considering moving to an architecture where we serialize the AST at build time in order to eliminate runtime Markdoc parsing entirely.</p><blockquote>
  <svg width="15" height="11" viewBox="0 0 15 11" xmlns="http://www.w3.org/2000/svg"><path d="M15 1.72c-1.96.95-2.94 2.07-2.94 3.36.83.1 1.53.44 2.07 1.02.55.58.82 1.25.82 2.01a2.81 2.81 0 0 1-2.8 2.89c-.9 0-1.68-.36-2.33-1.09a3.78 3.78 0 0 1-1-2.63c0-3.1 1.76-5.53 5.26-7.28L15 1.72zm-8.83 0c-1.97.95-2.96 2.07-2.96 3.36.85.1 1.55.44 2.1 1.02.54.58.82 1.25.82 2.01A2.82 2.82 0 0 1 3.3 11 3 3 0 0 1 .98 9.91 3.8 3.8 0 0 1 0 7.28C0 4.18 1.74 1.75 5.23 0l.94 1.72z" fill="#635BFF" fill-rule="nonzero"></path></svg>
  <p>When I first started using Markdoc at Stripe, I was delighted by how easy it was to structure docs exactly as I envisioned them. With other authoring tools, useful visual elements like collapsible sections, asides, tabs,  tables, multiple-language code samples, and many more often required heavy customization or new development. With Markdoc, I have a full palette ready to use. After using Markdoc, it&#39;s hard to imagine going back to another authoring tool.</p>
  
</blockquote><h2>May the source be with you</h2><p>Our team at Stripe spends a lot of time thinking about the authoring experience and how to get it right. In many ways, Markdoc is the embodiment of our obsession with building a better authoring experience. It&#39;s our way of bottling up everything we have learned about this topic and sharing it in a reproducible way.</p><p>After migrating all of our content to Markdoc and seeing the advantages fully realized in production, we set out to make Markdoc available under an MIT license so that others could benefit from our efforts.</p><p>We <a href="https://markdoc.dev/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">released Markdoc</a> to the public in May, publishing a <a href="https://www.npmjs.com/package/@markdoc/markdoc" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">package</a> on npm. We also published a <a href="https://markdoc.dev/spec" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">draft specification</a> that formally describes the Markdoc tag syntax, with the aim of making it easier for developers to incorporate support for Markdoc tags into other Markdoc parsing libraries.</p><p> Markdoc is hardly the final word on content authoring, but we hope that our contribution to the dialog will inspire others and help elevate discussion about the importance of the authoring experience in documentation.</p><p>Interested in using Markdoc at work? <a href="https://github.com/markdoc/markdoc/discussions" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Let us know</a> how we can help.</p>
  </section></div>
  </body>
</html>
