<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.prompthub.us/blog/a-complete-guide-to-meta-prompting">Original</a>
    <h1>A Complete Guide to Meta Prompting</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of the first benefits I found when using Large Language Models (LLMs) was that they helped with the blank page problem. I could quickly go from a blog idea to a rough outline in just a few minutes.</p><p>While understanding the <a href="https://www.prompthub.us/blog/10-best-practices-for-prompt-engineering-with-any-model" target="_blank">core principles of prompt engineering</a> is still important, not using LLMs in the process of writing prompts just doesn’t make any sense.</p><p>In the same way that an LLM can help a writer overcome the blank page problem, it can also help prompt engineers establish a solid prompt structure.</p><p>This process of using LLMs to write prompts and using prompts to create other prompts is called meta prompting. Rather than crafting every detail of your prompt, you can use other prompts, systems, and LLMs to help expedite the process.</p><p>In this article, we’ll dive into how meta prompting works, breaking down some of the latest and most popular methods from recent research papers. We’ll cover plenty of examples so you can start using these techniques in your workflows and apps right away. Plus, you’ll be able to see how we’ve integrated meta prompting into PromptHub to make the prompt engineering process extremely efficient.</p><p>‍</p><h2><strong>What is Meta Prompting?</strong></h2><p>Meta prompting is a prompt engineering method that uses large language models (LLMs) to create and refine prompts.</p><p>Unlike traditional prompt engineering, where you write a prompt from scratch and hope for the best, meta prompting guides the LLM to adapt and adjust your prompt dynamically, based on your feedback, allowing it to handle more complex tasks and evolving contexts.</p><p>Now we’ll jump into a variety of the latest meta-prompting methods based on latest research.</p><p>‍</p><div>

<div>
    <div>
    <p>Hey everyone, how&#39;s it going? Dan here. Happy Friday, October 4th—we’re already in October! Today, we’re going to be talking about meta prompting. We’ll go over what meta prompting is and touch on different meta prompting methods that have been discussed in recent research, papers, and GitHub repositories. We’ll keep things surface-level for now, covering a wide range, and in the future, we can dive deeper into specific methods. We’ll also go over some tools that can help you with meta prompting.</p>
    
    <h3>What is Meta Prompting?</h3>
    <p>Meta prompting is a prompt engineering method, so it falls under the broader umbrella of prompt engineering. Essentially, it involves using LLMs in some way to help create and refine prompts. This could be something like using Anthropic’s prompt generator to get a first version of a prompt or using more in-depth and technically advanced methods that we’ll explore today. The key idea is to have an LLM involved in the prompt creation process, just as you might use an LLM when writing a blog post.</p>
    
    <h3>Meta Prompting Methods</h3>
    <p>Let’s dive into several meta prompting methods. You may have heard of some of them, but if not, this will be a good overview.</p>
    
    <h4>Meta Prompting from Stanford and OpenAI</h4>
    <p>This method involves a “conductor” LLM controlling several expert LLMs. The conductor gives instructions to the expert models, which provide outputs. The conductor oversees communication between the LLMs, synthesizes their outputs, and provides a final result to the user. It’s a bit technical to set up but shares similarities with multi-persona prompting. You can find the template for the conductor LLM in PromptHub&#39;s templates page.</p>
    
    <h4>Learn from Contrasted Prompts</h4>
    <p>This method, which I believe originated from Amazon (we’ll confirm in the comments below), uses both negative and positive examples. You start with an initial prompt and input/output pairs. Several prompt candidates are generated, and the outputs are evaluated. The method then compares good and bad outputs to understand what differences in the prompts led to those results. A new prompt is generated based on that comparison. This balanced approach examines both good and bad outputs, and we have templates for this available in our blog post.</p>
    
    <h4>Automatic Prompt Engineer</h4>
    <p>One of the older and more popular meta prompting methods, Automatic Prompt Engineer works similarly to the previous method. The LLM generates multiple prompt candidates based on demonstrations you provide. It evaluates the outputs using a scoring function and refines the prompts based on their performance, generating semantically similar versions of the best-performing prompts. We also have templates for this method in our blog post.</p>
    
    <h4>Prompt Agent</h4>
    <p>Prompt Agent focuses on capturing subject-matter expertise for prompt engineering. It starts with an initial prompt, generates outputs, and evaluates them. The method iteratively refines the prompt by tapping into domain-specific knowledge (e.g., from a financial analyst or medical expert). This process uses a tree-like structure to explore high-reward paths. You can find templates and examples in our blog post.</p>
    
    <h4>Conversational Prompt Engineering (CPE)</h4>
    <p>This method is one of my favorites because it mimics how I often think about prompt engineering. It starts with input examples (e.g., articles for summarization tasks). The user and the LLM interact in a chat interface to discuss the task—what the prompt should accomplish, what a good output looks like, and what to avoid. The LLM helps draw out details from the user. A prompt is generated, and side chats are used to review the outputs, allowing for further refinement.</p>
    
    <h4>DSpy</h4>
    <p>DSpy is an open-source Python repository popular in software engineering circles. It helps create pipelines that refine and iterate on prompts using scoring mechanisms. The LLM generates an initial prompt, evaluates the outputs, and refines the prompt based on low scores. It’s code-first and adaptable, and there are many different modules you can use.</p>
    
    <h4>Text GRAD</h4>
    <p>Text GRAD is a newer open-source tool and an improvement on DSpy. Instead of focusing on quantitative scoring, it uses textual gradients—natural language feedback—to improve prompts. The LLM or a human provides feedback on the outputs, which highlights areas for improvement. This feedback is then used to refine the original prompt.</p>
    
    <h3>Tools for Meta Prompting</h3>
    <p>We’ll wrap up by mentioning some tools that can help with meta prompting:</p>
    <ul>
        <li><strong>PromptHub’s Prompt Generator:</strong> This tool generates prompts tailored to the model provider you&#39;re using. You just input a task description, and it creates a prompt optimized for that specific model.</li>
        <li><strong>Anthropic’s Prompt Generator:</strong> Accessible through their developer console, it’s a powerful tool tailored for Anthropic models.</li>
        <li><strong>OpenAI’s System Instruction Generator:</strong> OpenAI recently released a system instructions generator in their playground. It’s specifically for generating system instructions for OpenAI models.</li>
    </ul>
    <p>We’ve also added the OpenAI system instruction generator’s meta prompt to PromptHub for you to explore.</p>
    
    <p>That’s it for today! Happy prompting, and let us know if you have any questions or want us to dive deeper into any specific meta prompting methods. See you next time!</p>
</div>
</div></div><p>‍</p><h2>PromptHub&#39;s Prompt Iterator</h2><p>Many meta-prompting techniques involve a cycle: generating outputs, collecting user feedback, refining the prompt, and repeating the process. </p><p>Our new Prompt Enhancer, the <a href="https://www.prompthub.us/prompt-enhancers/prompt-iterator" target="_blank">Prompt Iterator</a> automates this entire workflow, allowing you to submit feedback, run prompts, and let the LLM refine them for you. Feel free to try it out for free in PromptHub - it&#39;s available on all plans!</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/67890f0b8212fa978a13c77b_67858e75f3732e27853a7bef_Prompt%2520Iterator%2520Hero%2520Image%2520Option%25201.png" loading="lazy" alt="A modal showing a prompt diff"/></p></figure><p>‍</p><h2>Meta-Prompting</h2><p>The first meta-prompting method we&#39;ll look at is simply called <a href="https://arxiv.org/pdf/2401.12954" target="_blank">Meta-Prompting</a>, developed through a collaboration from Stanford and OpenAI.</p><p>The core idea behind Meta-Prompting is to use an LLM as a conductor that can manage complex tasks by leveraging multiple independent LLMs that are experts in certain areas. This is similar to <a href="https://www.prompthub.us/blog/exploring-multi-persona-prompting-for-better-outputs" target="_blank">multi-persona prompting</a> in that it is a collaboration between different LLMs with a lead conductor.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>The central LLM receives a high-level “meta” prompt (copied below), that includes instructions to break down tasks into subtasks.</li><li>Each subtask is assigned to an &#34;expert&#34; LLM with specific, detailed instructions</li><li>The central LLM oversees communication between the expert LLMs, synthesizes their outputs, applies its own judgement, and generates a final output.</li></ol><h3>Pros</h3><ul role="list"><li>Meta-Prompting is task-agnostic.</li><li>The central model’s ability to coordinate multiple experts enhances problem-solving capabilities, which means more accurate and aligned results</li><li>Doesn’t require a bank of test data</li></ul><h3><strong>Cons</strong></h3><ul role="list"><li>Increased cost and latencies due to many LLM calls and interactions between the experts</li><li>Requires some configuration and set up to handle the inter-model interactions</li><li>Potential context window issues handling large message histories</li></ul><p>‍</p><h3>Meta Prompting prompt template</h3><p>Here is the Meta prompting prompt template straight from the research paper:</p><p>‍</p><p>‍</p><p>In this example, the Meta Model (&#39;Meta-Expert&#39;) directs the task to an Expert Mathematician and provides a clear instruction. This instruction is isolated, allowing the expert to focus on their specific task. The Meta Model then verifies the response and integrates it into the overall solution.</p><p>‍</p><p>The template is also available in PromptHub, feel free to add it to your library!</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fc34b650eae3b7ac494f50_66fc34b3b3411bf39c0a1aa1_Meta%2520prompt%2520conductor.png" loading="lazy" alt="Meta Prompt Conductor template in PromptHub"/></p></figure><p>‍</p><p>‍</p><h2><strong>Learning from Contrastive Prompts (LCP)</strong></h2><p>The next meta-prompting method we&#39;ll check out is from an Amazon paper called <a href="https://arxiv.org/pdf/2409.15199" target="_blank">Learning from Contrastive Prompts (LCP): Automated Optimization and Adaption</a>.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>Starting with an initial prompt and a small training set containing input-output pairs, multiple prompt candidates are generated.</li><li>The LLM generates outputs for each prompt candidate, which are then evaluated to identify where these candidates are succeeding and where they are falling short.</li><li>LCP instructs the LLM to compare good prompts against bad ones, allowing the model to identify what is working and what isn’t.</li><li>Based on this comparison, the LLM generates a new, refined prompt and continues to iteratively improve it.</li></ol><p>Put briefly, the LLM is tasked with contrasting good prompts against bad ones, leveraging the comparison to refine prompts. </p><h3>Pros</h3><ul role="list"><li>LCP’s focus on contrasting both good and bad prompts can lead to a better optimization process and better final prompt variant</li><li>LCP addresses the risk of overfitting by using multiple incorrect samples to create summaries of failure reasons, which enables the generation of a set of diverse prompt candidates</li><li>This diversity enables exploration of the prompt space, preventing the model from getting trapped in a local minimum.</li><li>LCP is also task agnostic</li></ul><h3><strong>Cons</strong></h3><ul role="list"><li>High costs and latencies due to the need to generate, evaluate, and contrast multiple prompts in each iteration.</li><li>The framework requires consistent feedback and evaluation to adapt effectively</li></ul><h3>LCP prompt template</h3><p>Here are the LCP prompt templates straight from the research paper:</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>In this example, the LLM evaluates multiple prompt candidates, learning from both their strengths and weaknesses. By contrasting the best-performing prompts with less effective ones, the LLM iteratively generates an optimized prompt, adapting to changes in the model version or task requirements.</p><p>‍</p><h2><strong>Automatic Prompt Engineer (APE)</strong></h2><p>The next meta-prompting method comes from a paper out of the University of Waterloo called, <a href="https://arxiv.org/pdf/2211.01910" target="_blank">Large Language Models Are Human-Level Prompt Engineers</a>. Their meta-prompting method,  <em>Automatic Prompt Engineer (APE)</em>, treats the prompt as a &#34;program,&#34; optimizing it by searching over a pool of prompt candidates with the goal to maximize a specific score function.</p><h3><strong>How It Works</strong></h3><ol role="list"><li><strong>Instruction Generation</strong>: An LLM generates a set of prompt candidates based on input-output demonstrations.</li><li><strong>Scoring and Evaluation</strong>: Each prompt is evaluated using a scoring function to measure its effectiveness.</li><li><strong>Iterative Search</strong>: The process iteratively uses a Monte Carlo search method, where LLMs refine the best prompts by proposing semantically similar prompt variants.</li></ol><p>Generate a bunch of prompts, score and evaluate them, generate new semantically similar versions and select the prompt version with the highest score.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fb21f3f5e2fc1f8b1a12d6_66fb19e5bacaedd8304baca9_APE%2520Flow%2520image.png" loading="lazy" alt="prompt flow for automatic prompt engineering (APE)"/></p></figure><p>‍</p><h3><strong>Pros</strong></h3><ul role="list"><li>APE’s experiment results consistently outperformed human-engineered prompts</li><li>APE is adaptable and can optimize prompts for different scenarios (zero-shot, chain-of-thought, etc). </li><li>APE is task agnostic</li></ul><h3><strong>Cons</strong></h3><ul role="list"><li>The iterative search process can be computationally intensive</li><li>Requires some dev work to spin up the system (the search process in particular)</li></ul><h3><strong>Example Implementation using APE Templates</strong></h3><p>APE guides the LLM through generating, evaluating, and refining prompts in a structured, step-by-step process. Here&#39;s a quick example flow of how it works using the templates from the research paper:</p><p>‍</p><p>‍</p><p>In this first step, APE generates an initial instruction that could have led to the provided input-output pairs, setting up the foundation for the prompt.</p><p>‍</p><p>‍</p><p>At this stage, the LLM evaluates how effectively the generated instruction from Step 1 performs when given new inputs. This helps identify how well the prompt works without any additional examples.</p><p><code>‍</code></p><p>‍<code>‍<br/></code></p><p>Using the feedback from Step 2, the LLM refines the initial instruction, creating a new version that aims to be more effective based on the evaluation.</p><p>‍</p><p>‍</p><p>This step helps APE further understand how the refined instruction maps to the given input-output pairs, ensuring that the prompt remains accurate and adaptable.</p><p>‍</p><p>‍</p><p>Finally, the LLM incorporates a <a href="https://www.prompthub.us/blog/chain-of-thought-prompting-guide" target="_blank">Chain of Thought reasoning</a> into the prompt, enhancing its ability to handle more complex tasks in a zero-shot setting.</p><p>‍</p><p><strong>Summing it up:</strong></p><ul role="list"><li>The LLM generates multiple instruction candidates based on initial input-output pairs.</li><li>These candidates are scored based on their effectiveness.</li><li>Through an iterative process, the LLM generates improved candidates, refining the instruction to achieve optimal performance.</li></ul><p>‍</p><h2><strong>PromptAgent</strong></h2><p>Next up is a meta-prompting method we&#39;ll check out is called <a href="https://openreview.net/pdf?id=22pyNMuIoa" target="_blank"><em>PromptAgent</em></a><em>.</em> PromptAgent views the prompt generation and optimization process as a planning problem and really tries to focus on leverage expert/SME knowledge in the prompt engineering process.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>The process starts with an initial prompt and a target task.</li><li>Outputs are generated and evaluated</li><li>PromptAgent integrates expert-level knowledge in the feedback loops</li><li>PromptAgent iteratively refines the prompt based on the feedback, growing the prompt space in a tree structure and prioritizing high-reward paths</li></ol><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fb21f3f5e2fc1f8b1a12d2_66fb1cc7c2ba20f3b92df282_Agentprompt%2520main%2520image.png" loading="lazy" alt="Example flow of PromptAgent"/></p></figure><p>‍</p><h3>Pros</h3><ul role="list"><li>PromptAgent’s major differentiator is its focus on mimicking subject matter experts in the prompt engineering process, using expert-like feedback and insights to iteratively refine and optimize prompts.</li><li>PromptAgent uses some prompt engineering to focus on leveraging expert-level knowledge</li><li>The method effectively uses self-reflection and error feedback to achieve a higher level of precision and adaptability.</li><li>AgentPrompt is task agnostic</li></ul><h3><strong>Cons</strong></h3><ul role="list"><li>Implementing AgentPrompt in full requires setting up a tree like reasoning structure, which may be complicated and lead to higher costs</li></ul><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fb21f3f5e2fc1f8b1a12c7_66fb1d19c18762d958a6c6a0_Promptagent%2520comparison%2520against%2520APE%2520and%2520human.png" loading="lazy" alt="A graph comparing performance of human prompt engineers, APE, and PromptAgent"/></p></figure><p>‍</p><h3><strong>Example Implementation with PromptAgent</strong></h3><p>Here are the four core prompt templates directly from the PromptAgent.</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><h2>Conversational Prompt Engineering (CPE)</h2><p>I’m a huge fan of this next meta-prompting method. <a href="https://arxiv.org/pdf/2408.04560" target="_blank"><em>Conversational Prompt Engineering</em></a><em> (CPE)</em> is a simple chat-interface that guides users in creating and refining prompts through an interactive conversation.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>First up, the user selects which model it wants to use (the “target model) and uploads a file with some input examples. For example, if the task is summarizing articles, the file could contain several full-length articles.</li><li>The user and CPE go back in forth via a chat, asking relevant data-driven questions about output preferences. This interaction helps shape an initial prompt.</li><li>Based on user feedback, CPE refines the initial prompt, and incorporates relevant details</li><li>A prompt is created and is sent to a different model (”target” model) to generate outputs</li><li>The user reviews the outputs and provides feedback some more feedback, adjustments are made as necessary</li><li>Once all prompt outputs are approved, CPE generates a final few-shot prompt that includes examples approved by the user.</li></ol><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fb21f3f5e2fc1f8b1a12ce_66fb1edf8e4539970f9ca1f2_CPE%2520Workflow.png" loading="lazy" alt="CPE conversation flow"/></p></figure><p>‍</p><h3>Pros</h3><ul role="list"><li>CPE makes it easy for users to generate personalized, high-quality prompts without needing labeled data or pre-existing prompts</li><li>The simple setup of a chat interface makes it extremely user friendly and leads to better outputs based on feedback and quick iterations</li><li>CPE is task agnostic</li></ul><h3><strong>Cons</strong></h3><ul role="list"><li>The iterative nature of CPE might be time-consuming, as it requires multiple rounds of user feedback to refine the prompts fully.</li><li>Potential memory issues</li></ul><p>‍</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fb21f3f5e2fc1f8b1a12cb_66fb1eea0dc8f8bbe01be7f1_CPE%2520Flow%2520Example.png" loading="lazy" alt="An example of CPE in action"/></p><figcaption>An example dialogue flow for CPE</figcaption></figure><h3><strong>Example Implementation</strong></h3><p>The following templates demonstrates how CPE operates:</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><h2>DSPy</h2><p>The next meta-prompting method we&#39;ll examine is very popular framework called <a href="https://arxiv.org/pdf/2310.03714" target="_blank"><em>DSPy</em></a> (Pronounced Dee-Ess-Pie). DSPy enables technical users to create, optimize, and manage complex pipelines of LLM calls in a structured, programmatic manner.</p><p>DSPy treats LLMs as modular components in a programming model, enabling users to combine, refine, and enhance their interactions over time.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>Users define DSPy modules with specific tasks, like creative writing or sentiment analysis. Each module has a defined signature that outlines the input and expected output.</li><li>DSPy constructs a sequence of LLM calls, allowing for step-by-step processing and optimization.</li><li>DSPy iteratively refines the output by utilizing modules like <code>ChainOfThought</code> to guide the LLM&#39;s reasoning process. It collects data from user feedback and uses scoring mechanisms to identify and prioritize high-quality outputs.</li><li>Teleprompter modules evaluate the LLM&#39;s performance on generated outputs, refining prompts based on scoring metrics and improving the overall quality through adaptive feedback.</li></ol><p>‍</p><p>LLMs serve multiple roles within DSPy, from generating the initial prompts, to generating evaluating outputs, refining prompts, and learning from user interactions. This adaptive, and code-first, framework allows the LLM to evolve and improve its performance over time.</p><h3>Pros</h3><ul role="list"><li>DSPy allows for creating complex, multi-step prompt workflows that adapt based on user input and feedback, making it highly versatile.</li><li>The system learns and improves over time, becoming more efficient at generating accurate and high-quality outputs.</li><li>The integration of modules like <code>ChainOfThought</code> and teleprompters enables more structured, logic-driven prompt generation and evaluation.</li><li>DSPy’s ability to manage multiple LLM calls allows it to refine prompts through self-improving feedback loops, enhancing output quality over successive iterations.</li><li>DSPy is task agnostic</li></ul><h3>Cons</h3><ul role="list"><li>DSPy can be quite complex to set up and requires technical knowledge</li><li>Managing large pipelines with iterative evaluations can become challenging</li></ul><p>‍</p><h3>Example implementation</h3><p>We’ll run through an example use case of content generation to see how DSPy works. Specifically lets say a user wants to create a blog post about &#34;AI Trends 2024&#34;:</p><p>‍</p><h4><strong>Step 1: Initialization</strong></h4><p>The user initializes a DSPy module to generate blog content.</p><p><code>content_generator = dspy.Predict(&#34;topic -&gt; blog_content&#34;)</code></p><h4><strong>Step 2: Initial Content Setup</strong></h4><p>The user provides the topic.</p><p><code>content_generator(topic=&#34;AI Trends 2024&#34;)</code></p><h4><strong>Step 3: Initial Content Generation</strong></h4><p>The LLM generates the following content:</p><p><code>&#34;AI Trends 2024: In the coming year, AI is expected to advance in natural language processing, autonomous vehicles, and healthcare. There will be greater adoption of AI in finance and retail sectors...&#34;</code></p><h4>‍</h4><h4><strong>Step 4: User Review and Feedback</strong></h4><p>The user reviews the generated content and provides feedback.</p><p>Feedback: &#34;Include more examples of AI applications in healthcare.&#34;</p><p>‍</p><h4>‍</h4><p>The revised content:</p><p><code>&#34;In 2024, AI will greatly impact healthcare, with AI-driven diagnostics enabling faster, more accurate medical assessments. Robotic surgery, guided by AI algorithms, will improve precision...&#34;</code></p><h4><strong>Step 6: Scoring and Evaluation by Teleprompter</strong></h4><p>DSPy uses another LLM to score the content based on criteria like specificity, coherence, and completeness.</p><ul role="list"><li>Evaluation Score: 8/10</li><li>Feedback: &#34;The content is clear and covers examples well, but could benefit from a conclusion summarizing the key trends.&#34;</li></ul><p>‍</p><h4>‍</h4><p>Final output:</p><p><code>&#34;In summary, AI trends in 2024 will span across natural language processing, autonomous vehicles, and healthcare, revolutionizing how we interact with technology and improving outcomes across industries...&#34;</code></p><h3><strong>End-to-End Process Recap:</strong></h3><ol role="list"><li><strong>User Inputs</strong>: Initial topic, feedback for improvement.</li><li><strong>LLM Calls</strong>:<ul role="list"><li>Generated initial content based on the topic.</li><li>Adapted prompts based on user feedback.</li><li>Scored and provided evaluations to optimize the prompt.</li><li>Finalized content with concluding elements.</li></ul></li></ol><p>DSPy is a little complicated but is also a very powerful way to leverage LLMs to generate, evaluate, and refine prompts through user interaction and automation.</p><p>‍</p><h2>TEXTGRAD: Textual Gradient-Based Optimization</h2><p>The next and final meta-prompting method we&#39;ll explore is <a href="https://arxiv.org/pdf/2406.07496" target="_blank"><em>TEXTGRAD</em></a>. In many ways, TEXTGRAD can be seen as a successor to DSPy, drawing inspiration from its approach while building upon it to make it even better.</p><p>The main differentiator that TEXTGRAD introduces is its emphasis on using natural language feedback as &#34;textual gradients.&#34; This allows the model to iteratively refine prompts based on detailed, human-like suggestions, leading to more nuanced and accurate outputs over successive iterations.</p><h3><strong>How It Works</strong></h3><ol role="list"><li>It all starts with a base version of the prompt</li><li>A second LLM or (human) reviews and evaluates the output and provides detailed natural language feedback. This feedback serves as the &#34;textual gradient,&#34; highlighting areas for improvement.</li><li>The original prompt and feedback are then sent to another LLM to generate an improved version of the prompt. This iterative process repeats until the prompt’s output meets the desired criteria.</li></ol><p>In TEXTGRAD an LLM is used as both a generator and evaluator. The feedback from one model is used to help another refine the prompt in an iterative fashion.</p><h3>Pros</h3><ul role="list"><li>TEXTGRAD uses natural language feedback to refine outputs, which makes it very flexible</li><li>Since TEXTGRAD focuses on natural language feedback, it allows for more nuanced and specific changes compared to more rigid, numerical optimization techniques</li><li>TEXTGRAD is task agnostic, but really shines on tasks that require detail feedback like creative writing</li></ul><h3>Cons</h3><ul role="list"><li>The iterative nature of TEXTGRAD makes it time-consuming and potentially expensive</li></ul><h3><strong>Example Implementation</strong></h3><p>To show how TEXTGRAD operates, let&#39;s run through an example where a user wants to generate a blog post about &#34;AI Trends in 2024&#34;:</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>The feedback might be:<code>‍</code></p><p>‍</p><p>‍</p><p><strong>Content Regeneration</strong>:</p><p>Using the new optimized prompt, the LLM generates revised content that better incorporates engagement and specific examples as per the feedback.</p><p><strong>Further Iterations</strong>:</p><p>This process repeats, with the LLM incorporating additional feedback, such as improving the conclusion or adding more depth to specific sections.</p><p><strong>Completion</strong>:</p><p>The cycle continues until the generated blog post meets the desired quality criteria, resulting in an engaging, well-structured, and comprehensive output.</p><p>‍</p><h2><strong>Prompt generator tools</strong></h2><p>Prompt generators are an easy way to leverage meta prompting with minimal work. Fortunately, there are several platforms that streamline the whole process.</p><h3><strong>PromptHub’s Prompt Generator</strong></h3><p>Our <a href="https://www.prompthub.us/features/prompt-generator" target="_blank">new prompt generator tool </a>brings together all the insights and techniques we&#39;ve shared on our blog, packaging them into a free tool that you can use to create high-quality prompts.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fd73ca02a04decb45d8e47_66fd736cb1b5ef1ce0c1d2a3_PromptHub%2520Prompt%2520Generator%2520Shot.png" loading="lazy" alt="A modal in the PromptHub application that has a few fields and a button to create a prompt"/></p></figure><p>‍</p><p>‍</p><p>Here&#39;s what our prompt generator offers:</p><ul role="list"><li><strong>Tailored prompts</strong>: Adjusts prompts based on the model provider you&#39;re using, because <a href="https://www.prompthub.us/blog/one-size-does-not-fit-all-an-analaysis-of-model-specific-prompting-strategies" target="_blank">one size doesn’t fit all</a>. </li><li><strong>Best practices built-in</strong>: Leverages prompt engineering best practices—just describe your task, and the tool handles the rest.</li><li><strong>Completely free</strong>: Yes, you heard that right—our prompt generator is free!</li></ul><h3><strong>Anthropic&#39;s Prompt Generator</strong></h3><p>Anthropic stands out as one of the leading companies in prompt engineering, and their prompt generator is a fantastic tool, especially if you frequently work within their development console. Optimized for Anthropic-specific prompts, their generator is both fast and an excellent starting point for creating effective prompts.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fd73ca02a04decb45d8e43_66fd735bdcd36e846fb310e4_Anthropic%2520Prompt%2520Generator%2520Shot.png" loading="lazy" alt="A modal to generate a prompt from the Anthropic dashboard"/></p></figure><p>‍</p><h3><strong>OpenAI&#39;s Prompt Generator</strong></h3><p>At OpenAI&#39;s most recent Dev Day, they launched a new feature that specifically generates system instruction prompts based on a task description However, it&#39;s worth noting that this feature isn&#39;t available for the o1 models, as they currently don&#39;t support system message role types.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fd73ca02a04decb45d8e4b_66fd734bbff6a537c7902e83_Openai%2520Prompt%2520Generator%2520Shot.png" loading="lazy" alt="A modal to generate a prompt from the OpenAI dashboard"/></p></figure><p>‍</p><p>Through some <a href="https://www.prompthub.us/blog/understanding-prompt-injections-and-what-you-can-do-about-them" target="_blank">prompt injections</a> we believe we were able to retrieve the meta prompt powering OpenAI&#39;s new tool. You can access it via the template we made in PromptHub <a href="https://app.prompthub.us/templates/3289" target="_blank">here.</a></p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/646e63db3a42c618e0a9935c/66fdb7b2d6c2d2e8a3ba0c34_66fdb6ea746b660dcc952a97_OpenAI%2520System%2520Instructions%2520Generator.png" loading="lazy" alt="The OpenAI system instruction prompt generator as a template in PromptHub"/></p></figure><p>‍</p><p>‍</p><h2><strong>Conclusion</strong></h2><p>Meta prompting and using prompt generators can be a great place to start when working on a prompt. While they aren’t a complete replacement for understanding some of the underlying mechanisms of LLMs or prompt engineering best practices, but we highly recommend using them.</p><p>We touched on a variety of different meta-prompting methods and different prompt generators throughout this post. Implementing any of these frameworks will enhance your prompt&#39;s performance; it’s just a matter of finding the one that makes the most sense for your needs.</p><p>We&#39;re excited to see how you leverage our prompt generator, and we look forward to continuing to develop new prompt optimization tools that will make meta prompting more accessible for everyone.</p></div></div>
  </body>
</html>
