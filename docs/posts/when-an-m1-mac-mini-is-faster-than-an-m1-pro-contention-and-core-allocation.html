<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eclecticlight.co/2022/02/07/when-an-m1-mac-mini-is-faster-than-an-m1-pro-contention-and-core-allocation/">Original</a>
    <h1>When an M1 Mac mini is faster than an M1 Pro: contention and core allocation</h1>
    
    <div id="readability-page-1" class="page"><article id="post-63676">
	
	<!-- .entry-header -->

	
		<div data-first_letter="S">
		<p>So far <a href="https://eclecticlight.co/2022/01/25/scheduling-of-threads-on-m1-series-chips-second-draft/">my investigations</a> of the performance of the Efficiency (E) and Performance (P) cores in M1 chips have been confined to running multiple threads in a single app. In the real world, processors are more usually running multiple processes which contend for resources including CPU cores. This article looks at how contention works out depending on the Quality of Service (QoS) assigned to different threads.</p>
<p><strong>Model and methods</strong></p>
<p>Two different apps are used here to compete for CPU cores: my free <a href="https://eclecticlight.co/dintch/">Cormorant</a> streams files to compress (and decompress) them using multithreaded lossless compression in <a href="https://developer.apple.com/documentation/applearchive" target="_blank" rel="noopener">Apple Archive</a>; my AsmAttic test utility runs tight CPU-bound loops of assembly code, as I’ve <a href="https://eclecticlight.co/2022/01/12/how-macos-manages-many-processes-on-m1-cores/">explained before</a>. Both apps run their threads in Grand Central Dispatch queues with Quality of Service values set by the user for each test. AsmAttic also sets the number of threads and the number of loops in each thread.</p>
<p>Tests were run on two M1 Macs in Monterey 12.2. One, referred to as <em>M1 mini,</em> is an M1 Mac mini 2020 with 16 GB memory, an internal 500 GB SSD and the original M1 chip with one cluster of 4 E cores and one of 4 P cores; the other, referred to as <em>M1 Pro,</em> is an M1 MacBook Pro 16-inch 2021 with 32 GB memory, an internal 2 TB SSD and the M1 Pro chip with one cluster of 2 E cores and two clusters of 4 P cores each. By all expectations, running either of the test apps would be expected to demonstrate better performance on the M1 Pro compared with the M1 mini.</p>
<p>Additional tools used to examine performance include the <code>powermetrics</code> command tool and Activity Monitor’s <strong>CPU History</strong> window.</p>
<p><strong>Uncontended performance on E and P cores</strong></p>
<p>Before looking at the effects of contention on performance, I first looked at the two tests I intended to use in contention, running at the highest and lowest QoS levels.</p>
<p>Time to compress a 10 GB test file at highest QoS (33) was shorter on the M1 Pro as expected. The task completed in 5.6 seconds on the M1 Pro, and 8.2 seconds on the M1 mini. At this QoS, each test resulted in all available cores being recruited at their maximum frequency, and 100% active residency, according to <code>powermetrics</code>.</p>
<p>When compression was performed at minimum QoS (9), the M1 mini consistently completed the test in a shorter time than the M1 Pro. While the M1 Pro took 55.1 seconds, the M1 mini accomplished the same task in only 37.3 seconds. I have <a href="https://eclecticlight.co/2022/01/03/power-frequency-management-how-m1-e-cores-win/">previously reported</a> that, when running tests on the M1 Pro’s two-core E cluster, cores are run at higher frequency than when running the same test on the M1 mini’s four-core E cluster, and that was seen here too. When the M1 Pro was running the compression test solely on its two E cores, their frequency was 2064 MHz, while the four E cores in the M1 mini ran at a frequency of only 972 MHz. Despite that difference in frequency, the M1 mini required just 68% of the time taken by the M1 Pro.</p>
<p>To confirm that this wasn’t the result of Cormorant being built for an older version of macOS (Big Sur), I built and notarized a new version using Xcode 13.2.1. Using that new version, times observed were unchanged, and the M1 mini remained significantly quicker at compressing on its E cores alone.</p>
<p>Results from the floating point test were consistent with my previous observations, that the two E cores in the M1 Pro are run at higher frequency to compensate for their number, resulting in better performance on the M1 Pro regardless of QoS. At the highest QoS, 10 threads completed on the M1 Pro in 3.6 seconds, while 8 threads took 4.0 seconds on the M1 mini. At the lowest QoS, 2 threads on the M1 Pro completed in 5.1 seconds, and on the M1 mini in 10.3 seconds, essentially the same time it completed 4 threads. High QoS resulted in E and P cores being run at their maximum frequencies, but at low QoS the two chips differed: the M1 Pro ran its two E cores at 2064 MHz, but the M1 mini ran its four E cores at 972 MHz.</p>
<p><strong>Contention on E cores</strong></p>
<p>When tested with contending processes and threads confined to the E cores by the lowest QoS, there were no surprises. With the difference in performance times of the two tests used, each run started with the compression task, then the floating point test was added to that and completed before the end of compression.</p>
<p>Adding only two floating point threads, the M1 mini completed compression in 42.4 seconds, with the floating point test taking 11.9 seconds within that; the M1 Pro completed compression in 63.2 seconds, and the floating point test took only 8.8 seconds. While the E cores of the M1 Pro were run at a frequency of 2064 MHz, even with both tests running concurrently the four E cores in the M1 mini remained at only 972 MHz.</p>
<p>Total elapsed time, within which both compression and floating point tests were completed, was shorter for the M1 mini with four floating point threads (47.9 s) than the M1 Pro running only the compression task (55.1 s).</p>
<p><strong>Contention at intermediate QoS</strong></p>
<p>Apple defines four QoS levels, numerically 9, 17, 25 and 33, of which only one (9) results in threads being constrained to one type of core. Threads at each of the three higher QoS can be run on either E or P cores, depending on allocation by macOS. When looking at the effects of different QoS it’s easy to conclude from uncontended testing that there’s little difference between those three levels. To get a better insight, I ran floating point tests at various QoS against compression at a QoS value fixed at 25, using just the M1 Pro.</p>
<p><span><img data-attachment-id="63682" data-permalink="https://eclecticlight.co/m1qoscontention/" data-orig-file="https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png" data-orig-size="657,333" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="m1qosContention" data-image-description="" data-image-caption="" data-medium-file="https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png?w=300" data-large-file="https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png?w=657" src="https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png?w=940" alt="m1qosContention" srcset="https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png 657w, https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png?w=150 150w, https://eclecticlightdotcom.files.wordpress.com/2022/02/m1qoscontention.png?w=300 300w" sizes="(max-width: 657px) 100vw, 657px"/></span></p>
<p>The table above gives, in the first column, the time in seconds for the compression task to complete. The second column gives the time in seconds for the concurrent floating-point test to complete, with its QoS given in the final column.</p>
<p>This shows the interaction between threads at different QoS levels. When the competing floating-point task has a lower QoS than the compression task, compression is only slowed slightly, and the time required for the floating-point task is more than doubled. When the floating-point task QoS exceeds that of compression, the former takes little longer than it does when run alone, and the compression task takes nearly twice as long.</p>
<p>While there are no surprises here, this demonstrates that allocating queues and threads an appropriate QoS is important even when using the three higher levels, which don’t constrain threads to E cores.</p>
<p><strong>Conclusions</strong></p>
<ul>
<li>Although processes and threads run on both E and P cores complete more quickly on the M1 Pro, when constrained to the E cores some are significantly quicker on the M1 mini. This occurs despite the difference in frequencies of the E cores when running threads at the lowest QoS.</li>
<li>M1 mini and Pro chips run their E cores at different frequencies when running threads at the lowest QoS. The four cores in the M1 mini cluster are then constrained to 972 MHz, while the two cores in the M1 Pro cluster may be run at their maximum frequency of 2064 MHz. Code dependent on resources outside the cluster may still run more slowly on the M1 Pro despite that difference in frequency.</li>
<li>Contending threads from different processes are run concurrently on the core types to which macOS allocates them. Those at the lowest QoS are never run on P cores, even when the E cores are already fully loaded but the P cores are idle.</li>
<li>When run at any of the three higher QoS levels, macOS allocates priority to threads according to their QoS, so that those with higher QoS are given higher priority than those with lower QoS. Assigning an appropriate QoS to threads is therefore important in determining overall performance, particularly when threads are in contention with others. As a result, assessing performance without contention can be misleading.</li>
<li>Understanding core allocation and the interaction of QoS levels under contention are essential to achieving optimal app performance on Apple Silicon Macs.</li>
</ul>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
