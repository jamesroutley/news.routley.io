<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/articles/dropbox-magic-pocket-exabyte-storage/">Original</a>
    <h1>Magic Pocket: Dropbox’s exabyte-scale blob storage system</h1>
    
    <div id="readability-page-1" class="page"><div>
							
								<div>
									<h3>Key Takeaways</h3>
									<ul>
	<li>
	<p>Magic Pocket is a horizontally scalable exabyte-scale blob storage system and is able to maintain 99.99% availability and extremely high durability.</p>
	</li>
	<li>
	<p>The system can run on any HDDs, but primarily runs on Shingled Magnetic Recording disks. It can handle millions of queries per second and automatically identify and repair hundreds of hardware failures per day.</p>
	</li>
	<li>
	<p>Each store storage device can contain 100+ drives. Each storage device stores multiple petabytes of data.</p>
	</li>
	<li>
	<p>Using erasure codes and other optimizations, Dropbox is able to reduce replication costs while maintaining similar durability as replication.</p>
	</li>
	<li>
	<p>Forecasting is crucial to deal with the challenge of storage growth and capacity issues such as dealing with supply chain disruptions.</p>
	</li>
</ul>

									
								</div>
							
							
								
								<p>At QCon San Francisco, I explained how the exabyte scale blob storage system that stores all of Dropbox&#39;s customer data works. At its core, <a href="https://dropbox.tech/infrastructure/inside-the-magic-pocket">Magic Pocket</a> is a very large key-value store where the value can be arbitrarily sized blobs.</p>

<p>Our system has over 12 9s of durability and 99.99% of availability, and we operate across three geographical regions in North America. Our systems are optimized for 4 MB blobs,  immutable writes, and cold data. </p>

<p>Magic Pocket manages tens of millions of requests per second and a lot of the traffic comes from verifiers and background migrations. We have more than 600,000 storage drives currently deployed and we run thousands of compute machines.</p>

<h2>Object Storage Device</h2>


								
								
									








								
								<p>The main focus of the Magic Pocket is the Object Storage Devices (OSD). These devices have over 2 PB of capacity and are made up of around 100 disks per storage machine, utilizing <a href="https://en.wikipedia.org/wiki/Shingled_magnetic_recording">Shingled Magnetic Recording</a> (SMR) technology.</p>

<p>SMR differs from Conventional <a href="https://en.wikipedia.org/wiki/Perpendicular_recording">Magnetic Recording</a> drives as it performs sequential writes instead of random writes, allowing increased density.</p>

<p>The tradeoff of using SMR is that the head erases the next track when you walk over it, preventing random writes in any place.</p>


								
								
									
								
								<p>However, this is perfect for our workload patterns. SMR drives also have a conventional zone that allows for caching of random writes if necessary, which typically accounts for less than 1% of the total capacity of the drive.</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-19-37-1683357609093.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-19-37-1683357609093.png" rel="share"/></p>

<p><small><strong>Figure 1: SMR Track Layout</strong></small></p>

<p>At a high level, the architecture of Magic Pocket consists of three zones: West Coast, Central, and East Coast. The system is built around pockets, which represent logical versions of everything in the system. Magic Pocket can have multiple instances, such as a test pocket or a stage pocket before the production one. Databases and compute are not shared between pockets, and operate independently of each other.</p>

<h2>Zone</h2>

<p>These are the different components of the Magic Pocket architecture in each zone.</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-08-35-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-08-35-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 2: How a zone works</strong></small></p>

<p>The first service is the frontend, which is the service that interacts with the clients. Clients typically make PUT requests with keys and blobs, GET requests, delete calls, or perform scans for available hashes in the system. </p>

<p>When a GET request is made, the hash index, a collection of sharded MySQL databases,  is queried. The hash index is sharded by the hash, which is the key for a blob, and each hash is mapped to a cell or a bucket, along with a checksum. The cells are the isolation units where all the storage devices are located: they can be over 100 PBs and grow up to specific limits in size. When the system runs low on capacity, a new cell is opened up, allowing for horizontal scaling of the system.</p>

<p>The cross-zone replicator is the component performing cross-zone replication, storing data in multiple regions. The operation is done asynchronously, and once a commit happens in the primary region, the data is queued up for replication to another zone. The control plane manages traffic coordination, generates migration plans, and handles machine re-installations. It also manages cell state information.</p>

<h2>Cell</h2>

<p>If I want to fetch a blob, I need to access the bucket service that knows about buckets and volumes: when I ask for a bucket, my request is mapped to a volume and the volume is mapped to a set of OSDs. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-11-00-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-11-00-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 3: How a cell works</strong></small></p>

<p>Once we find the OSD that has our blob, we can retrieve it. For writing data, the frontend service figures out which buckets are open for writing and it commits to the ones that are ready. The buckets are pre-created for us, and the data is stored in a set of OSDs within a volume.</p>

<p>The coordinator is an important component in the cell, managing all the buckets, volumes, and storage machines. The coordinator constantly checks the health of the storage machines, reconciles information with the bucket service and database, and performs erasure coding and repairs: It optimizes data by moving things around within the cell and takes care of moving data to other machines when it is necessary. The volume manager handles the reading, writing, repairing, and erasure encoding of volumes. Verification steps happen both within and outside of the cell.</p>

<h2>Buckets, Volumes, and Extents</h2>

<p>We can now dive deeper into the components of the Magic Pocket storage system, namely buckets, volumes, and extents. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-11-36-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-11-36-1683357513698.png" rel="share"/></p>

<p><strong><small>Figure 4: Buckets, volumes, and extends</small></strong></p>

<p>A bucket is a logical storage unit associated with a volume and extent, which represents 1-2 GBs of data on a disk. When we write, we identify the open buckets and the associated OSDs and then write to the extents. The coordinator manages the bucket, volume, and extent information, and can ensure that data is not lost by finding a new placement for a deleted extent. A volume is composed of one or more buckets, it is either replicated or erasure coded, and it is open or closed. Once a volume is closed, it is never opened up again.</p>

<h2>How to Find a Blob in Object Storage Devices</h2>

<p>In this chapter, we learn how to find a blob in a storage machine. To do this, we store the address of the OSDs with the blob, and we talk directly to those OSDs. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-12-28-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-12-28-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 5: Finding a Blob</strong></small></p>

<p>The OSDs load up all the extent information and create an in-memory index of which hashes they have to the disk offset. If we want to fetch the block, we need to know the volume and which OSDs have the blob. For a PUT, it&#39;s the same process, but we do a write to every single OSD in parallel and do not return until the write has been completed on all storage machines. As the volume is 4x replicated, we have the full copy available in all four OSDs.</p>

<h2>Erasure Coding</h2>

<p>While failures are happening all the time, 4 copies by 2 zones replication is costly. Let&#39;s see the difference between a replicated volume and an erasure-coded volume, and how to handle it. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-13-13-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-13-13-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 6: Erasure Coding</strong></small></p>

<p>Erasure coding is a way to reduce replication costs while maintaining similar durability as replication. In our system, when a volume is almost full, it is closed and eligible to be erasure coded. We use an erasure code, like <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction">Reed Solomon error correction</a> 6 plus 3, with 6 OSDs and 3 parities in a volume group. This means there is a single blob in one data extent, and if one OSD fails, it can be reconstructed. Reconstructions can happen on live requests for data or done in the background as part of repairs. There are many variations of erasure codes with different tradeoffs around overhead: for example, using XOR as an erasure code can be simple, but custom erasure codes can be more suitable. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-13-45-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-13-45-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 7: Failure and erasure coding</strong></small></p>

<p>The paper &#34;<a href="https://www.usenix.org/system/files/conference/atc12/atc12-final181_0.pdf">Erasure Coding in Windows Azure Storage</a>&#34; by Huang and others is a useful resource on the topic, and we use similar techniques within our system.</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-14-42-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-14-42-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 8: Reed Solomon error correction by &#34;<a href="https://www.usenix.org/system/files/conference/atc12/atc12-final181_0.pdf">Erasure Coding in Windows Azure Storage</a>&#34; by Huang et al</strong></small></p>

<p>I previously mentioned an example of Reed Solomon 6, 3 codes with 6 data extents and 3 parities. Another option is called local reconstruction codes, which optimizes read cost. Reed&#39;s 6, 3 codes result in a read penalty of 6 reads when there are any failures. However, with the local reconstruction codes, you can have the same read costs for one type of data failure but with a lower storage overhead of roughly 1.33x compared to Reed Solomon&#39;s 1.5x replication factor. Although this may not seem like a huge difference, it means significant savings on a larger scale. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-15-13-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-15-13-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 9: Reconstruction code comparisons from &#34;<a href="https://www.usenix.org/system/files/conference/atc12/atc12-final181_0.pdf">Erasure Coding in Windows Azure Storage</a>&#34; by Huang et al</strong></small></p>

<p>The local reconstruction codes optimize for one failure within the group, which is usually what you encounter in production. Making this tradeoff is acceptable because more than 2 failures in a volume group are rare. </p>

<p>Even lower replication factors are possible with these codes: the LRC-(12,2,2) code can tolerate any three failures within the group, but not four, with only some failures that can be reconstructed.</p>

<h2>The Cold Storage System</h2>

<p>Can we do better than this for our system? As we have observed that 90% of retrievals are for data uploaded in the last year and 80% of retrievals happen within the first 100 days, we are exploring ways to improve our cross-zone replication</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-15-46-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-15-46-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 10: File access distribution</strong></small></p>

<p>As we have a large amount of cold data that is not accessed frequently, we want to optimize our workload to reduce reads and maintain similar latency, durability, and availability. To achieve this, we observe that we do not have to do live writes into cold storage and can lower our replication factor from 2x by utilizing more than one region. </p>

<p>Let’s see how our cold storage system works, with the inspiration coming from Facebook&#39;s <a href="https://research.facebook.com/publications/f4-facebooks-warm-blob-storage-system/">warm blob storage system</a>. The f4 paper suggests a method to split a blob into two halves and take the <a href="https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation">XOR</a> of those two halves, which are stored individually in different zones. To retrieve the full blob, any one combination of blob1 and blob2 or the XOR must be available in any two regions. However, to do a write, all regions need to be fully available. Note that as the migrations happen in the background and asynchronously, they do not affect the live process.</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-16-24-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-16-24-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 11: Splitting blobs and cold storage</strong></small></p>

<p>What are the benefits of this cold storage system? We have achieved a 25% savings by reducing the replication factor from 2x to 1.5x. The fragments stored in cold storage are still internally erasure-coded, and migration is done in the background. To reduce overhead on backbone bandwidth, we send requests to the two closest zones and only fetch from the remaining zone if necessary. This saves a significant amount of bandwidth as well.</p>

<h2>Release Cycle</h2>

<p>How do we do releases in Magic Pocket? Our release cycle takes around four weeks across all staging and production environments. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-16-54-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-16-54-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 12: Magic Pocket’s release cycle</strong></small></p>

<p>Before committing changes, we run a series of unit and integration tests with all dependencies and a durability stage with a full verification of all data. Each zone has verifications that take about a week per stage: our release cycle is fully automated, and we have checks in place that will abort or not proceed with code changes if there are any alerts. Only in exceptional cases do we stop the automatic deployment process and have to take control.</p>

<h2>Verifications</h2>

<p>What about verifications? Within our system, we conduct a lot of verifications to ensure data accuracy. </p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-17-27-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-17-27-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 13: Verifications</strong></small></p>

<p>One of these is performed by the cross-zone verifier, which synchronizes data mappings between clients upstream and the system. Another is the index verifier, which scans the index table to confirm if specific blobs are present in each storage machine: we simply ask if the machine has the blob based on its loaded extents, without actually fetching the content. The watcher is another component that performs full validation of the blobs themselves, with sampling done after one minute, an hour, a day, and a week. We also have the trash inspector, which ensures that all hashes within an extent are deleted once the extent is deleted.</p>

<h2>Operations</h2>

<p>With Magic Pocket we deal with lots of migrations since we operate out of multiple data centers. We manage a very large fleet of storage machines, and it&#39;s important to know what&#39;s happening all the time. There&#39;s a lot of automated chaos taking place, so we have tons of disaster recovery events to test the reliability of our system: upgrading at this scale is just as difficult as the system itself. Managing background traffic is one of our key operations since it accounts for most of our traffic and disk IOPS. The disk scrubber constantly scans through all of the traffic and checks the checksum for the extents. We categorize traffic by service into different tiers, and live traffic is prioritized by the network. </p>

<p>The control plane generates plans for a lot of the background traffic based on forecasts we have about a data center migration: we take into account the type of migration we are doing, such as for cold storage, and plan accordingly.</p>

<p>We deal with a lot of failures in our system: we have to repair 4 extents every second, which can be anywhere from 1 to 2 GBs in size. We have a pretty strict SLA on repairs (less than 48 hours) and, as it is part of our durability model, we want to keep this repair time as low as possible. Our OSDs get allocated into the system automatically based on the size of the cell and current utilization. </p>

<p>We also have a lot of migrations to different data centers.</p>

<p><img alt="" data-src="articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-18-02-1683357513698.png" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/dropbox-magic-pocket-exabyte-storage/en/resources/1Screenshot from 2023-05-06 09-18-02-1683357513698.png" rel="share"/></p>

<p><small><strong>Figure 14: Migrations</strong></small></p>

<p>Two years ago, we migrated out of the SJC region, and it took extensive planning to make it happen. For very large migrations, like hundreds of PBs, there is significant preparation going on behind the scenes, and we give ourselves extra time to make sure that we can finish the migration in time. </p>

<h2>Forecasting</h2>

<p>Forecasting is a crucial part of managing our storage system at this scale. We are constantly dealing with the challenge of storage growth, which can sometimes be unexpected and require us to quickly adapt and absorb the new data into our system. Additionally, we may face capacity issues due to supply chain disruptions like those caused by the COVID pandemic: as soon as we identify any potential problems, we start working on backup plans as it takes a considerable amount of time to order and deliver new capacity to the data centers. Our forecasts are directly integrated into the control plane, which helps us execute migrations based on the information provided by our capacity teams.</p>

<h2>Conclusion</h2>

<p>Managing Magic Pocket, four key lessons have helped us maintain the system:</p>

<ul>
	<li>Protect and verify</li>
	<li>Okay to move slow at scale</li>
	<li>Keep things simple</li>
	<li>Prepare for the worst</li>
</ul>

<p>First and foremost, we prioritize protecting and verifying our system. It requires a significant amount of overhead, but it&#39;s crucial to have end-to-end verification to ensure consistency and reliability. </p>

<p>At this scale, it&#39;s important to move slowly and steadily. We prioritize durability and take the time to wait for verifications before deploying anything new. We always consider the risks and prepare for worst-case scenarios.</p>

<p>Simplicity is also a crucial factor. We aim to keep things simple, especially during large-scale migrations, as too many optimizations can create a complicated mental model that makes planning and debugging difficult. </p>

<p>In addition, we always have a backup plan in case of failures or issues during migrations or deployments. We ensure that changes are not a one-way door and can be reversed if necessary. Overall, managing a storage system of this scale requires a careful balance of protection, verification, simplicity, and preparation.</p>

							
							

							









  
    


                            
                            
                                
                            
						</div></div>
  </body>
</html>
