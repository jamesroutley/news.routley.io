<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-08-29-gits-database-internals-i-packed-object-store/">Original</a>
    <h1>Git’s database internals I: packed object store</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    


<main role="main" id="post-66673">
  
<p>Developers collaborate using Git. It is the medium that allows us to share code, work independently on our own machines, and then finally combine our efforts into a common understanding. For many, this is done by following some well-worn steps and sticking to that pattern. This works in the vast majority of use cases, but what happens when we need to do something new with Git? Knowing more about Git’s internals helps when exploring those new solutions.</p>
<p>In this five-part blog post series, we will illuminate Git’s internals to help you collaborate via Git, especially at scale.</p>
<p>It might also be interesting because you love data structures and algorithms. That’s what drives me to be interested in and contribute to Git.</p>
<p>Git’s architecture follows patterns that may be familiar to developers, except the patterns come from a different context. Almost all applications use a database to persist and query data. When building software based on an application database system, it’s easy to get started without knowing any of the internals. However, when it’s time to scale your solution, you’ll have to dive into more advanced features like indexes and query plans.</p>
<p>The core idea I want to convey is this:</p>
<p>Git is the distributed database at the core of your engineering system.</p>
<p>Here are some very basic concepts that Git shares with application databases:</p>
<ol>
<li>Data is persisted to disk.</li>
<li>Queries allow users to request information based on that data.</li>
<li>The data storage is optimized for these queries.</li>
<li>The query algorithms are optimized to take advantage of these structures.</li>
<li>Distributed nodes need to synchronize and agree on some common state.</li>
</ol>
<p>While these concepts are common to all databases, Git is particularly specialized. Git was built to store plain-text source code files, where most change are small enough to read in a single sitting, even if the codebase contains millions of lines. People use Git to store many other kinds of data, such as documentation, web pages, or configuration files.</p>
<p>While many application databases use long-running processes with significant amounts of in-memory caching, Git uses short-lived processes and uses the filesystem to persist data between executions. Git’s data types are more restrictive than a typical application database. These aspects lead to very specialized data storage and access patterns.</p>
<p>Today, let’s dig into the basics of what data Git stores and how it accesses that data. Specifically, we will learn about Git’s <em>object store</em> and how it uses packfiles to compress data that would otherwise contain redundant information.</p>
<h2 id="gits-object-store">Git’s object store<a href="#gits-object-store" aria-label="Git’s object store"></a></h2>
<p>The most fundamental concepts in Git are <em>Git objects</em>. These are the “atoms” of your Git repository. They combine in interesting ways to create the larger structure. Let’s start with a quick overview of the important Git objects. Feel free to skip ahead if you know this, or you can <a href="https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/">dig deep into Git’s object model</a> if you’re interested.</p>
<p>In your local Git repositories, your data is stored in the <code>.git</code> directory. Inside, there is a <code>.git/objects</code> directory that contains your Git objects.</p>
<pre><code>$ ls .git/objects/
01  34  9a  df  info    pack

$ ls .git/objects/01/
12010547a8990673acf08117134bdc181bd735

$ ls .git/objects/pack/
multi-pack-index
pack-7017e6ce443801478cf19006fc5499ba1c4d2960.idx
pack-7017e6ce443801478cf19006fc5499ba1c4d2960.pack
pack-9f9258a8ffe4187f08a93bcba47784e07985d999.idx
pack-9f9258a8ffe4187f08a93bcba47784e07985d999.pack
</code></pre>
<p>The <code>.git/objects</code> directory is called the <em>object store</em>. It is a content-addressable data store, meaning that we can retrieve the contents of an object by providing a hash of those contents.</p>
<p>In this way, the object store is like a database table with two columns: the <em>object ID</em> and the <em>object content</em>. The object ID is the hash of the object content and acts like a primary key.</p>
<p><img src="https://github.blog/wp-content/uploads/2022/08/gitdatabase2.png?resize=337%2C296" alt="Table with columns labeled Object ID and Object Data" width="337" height="296" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase2.png?resize=337%2C296?w=337 337w, https://github.blog/wp-content/uploads/2022/08/gitdatabase2.png?resize=337%2C296?w=300 300w" sizes="(max-width: 337px) 100vw, 337px" loading="lazy" data-recalc-dims="1"/></p>
<p>Upon first encountering content-addressable data stores, it is natural to ask, “How can we access an object by hash if we don’t already know its content?” We first need to have some starting points to navigate into the object store, and from there we can follow links between objects that exist in the structure of the object data.</p>
<p>First, Git has <em>references</em> that allow you to create named pointers to keys in the object database. The <em>reference store</em> mainly exists in the <code>.git/refs/</code> directory and has its own advanced way of storing and querying references efficiently. For now, think of the reference store as a two-column table with columns for the <em>reference name</em> and the <em>object ID</em>. In the reference store, the reference name is the primary key.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase3.png?resize=800%2C309" alt="Image showing how the Object ID table relates to the Object Store" width="800" height="309" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase3.png?resize=800%2C309?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase3.png?resize=800%2C309?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase3.png?resize=800%2C309?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>Now that we have a reference store, we can navigate into the object store from some human-readable names. In addition to specifying a reference by its full name, such as <code>refs/tags/v2.37.0</code>, we can sometimes use short names, such as <code>v2.37.0</code> where appropriate.</p>
<p>In <a href="https://github.com/git/git">the Git codebase</a>, we can start from the <code>v2.37.0</code> reference and follow the links to each kind of Git object.</p>
<ul>
<li>The <code>refs/tags/v2.37.0</code> reference points to an annotated tag object. An annotated tag contains a reference to another object (by object ID) and a plain-text message.</li>
<li>That tag’s object references a commit object. A commit is a snapshot of the worktree at a point in time, along with connections to previous versions. It contains links to <em>parent commits</em>, a <em>root tree</em>, as well as metadata, such as commit time and commit message.</li>
<li>That commit’s root tree references a tree object. A tree is similar to a directory in that it contains entries that link a path name to an object ID.</li>
<li>From that tree, we can follow the entry for <code>README.md</code> to find a blob object. Blobs store file contents. They get their name from the tree that points to them.</li>
</ul>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase4.png?resize=800%2C699" alt="Image displaying hops through the object database in response to a user request." width="800" height="699" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase4.png?resize=800%2C699?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase4.png?resize=800%2C699?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase4.png?resize=800%2C699?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>From this example, we navigated from a ref to the contents of the <code>README.md</code> file at that position in the history. This very simple request of “give me the README at this tag” required several hops through the object database, linking an object ID to that object’s contents.</p>
<p>These hops are critical to many interesting Git algorithms. We will explore how the graph structure of the object store is used by Git’s algorithms in parts two through four. For now, let’s focus on the critical operation of linking an object ID to the object contents.</p>
<h3 id="object-store-queries">Object store queries<a href="#object-store-queries" aria-label="Object store queries"></a></h3>
<p>To store and access information in an application database, developers interact with the database using a query language such as SQL. Git has its own type of query language: the command-line interface. Git commands are how we interact with the Git object store. Since Git has its own structure, we do not get the full flexibility of a relational database. However, there are some parallels.</p>
<p>To select object contents by object ID, the <code><a href="https://git-scm.com/docs/git-cat-file">git cat-file command</a></code> will do the object lookup and provide the necessary information. We’ve already been using <code>git cat-file -p</code> to present “pretty” versions of the Git object data by object ID. The raw content is not always fit for human readers, with object IDs stored as raw hashes and not hexadecimal digits, among other things like null bytes. We can also use <code>git cat-file -t</code> to show the type of an object, which is discoverable from the initial few bytes of the object data.</p>
<p>To insert an object into the object store, we can write directly to a blob using <code><a href="https://git-scm.com/docs/git-hash-object">git hash-object</a></code>. This command takes file content and writes it into a blob in the object store. After the input is complete, Git reports the object ID of the written blob.</p>
<pre><code>$ git hash-object -w --stdin
Hello, world!
af5626b4a114abcb82d63db7c8082c3c4756e51b

$ git cat-file -t af5626b4a114abcb82d63db7c8082c3c4756e51b
blob

$ git cat-file -p af5626b4a114abcb82d63db7c8082c3c4756e51b
Hello, world!
</code></pre>
<p>More commonly, we not only add a file’s contents to the object store, but also prepare to create new commit and tree objects to reference that new content. The <code><a href="https://git-scm.com/docs/git-add">git add command</a></code> hashes new changes in the worktree and stores their blobs in the object store then writes the list of objects to a staging area known as the Git index. The <code><a href="https://git-scm.com/docs/git-commit%60">git commit command</a></code> takes those staged changes and creates trees pointing to all of the new blobs, then creates a new commit object pointing to the new root tree. Finally, <code>git commit</code> also updates the current branch to point to the new commit.</p>
<p>The figure below shows the process of creating several Git objects and finally updating a reference that happens when running <code>git commit -a -m &#34;Update README.md&#34;</code> when the only local edit is a change to the <code>README.md</code> file.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase5.png?resize=536%2C391" alt="Image showing the process of creating several Git objects and updating references" width="536" height="391" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase5.png?resize=536%2C391?w=536 536w, https://github.blog/wp-content/uploads/2022/08/gitdatabase5.png?resize=536%2C391?w=300 300w" sizes="(max-width: 536px) 100vw, 536px" data-recalc-dims="1"/></p>
<p>We can do slightly more complicated queries based on object data. Using <code>git log --pretty=format:&lt;format-string&gt;</code>, we can make custom queries into the commits by pulling out “columns” such as the object ID and message, and even the committer and author names, emails, and dates. See <a href="https://www.git-scm.com/docs/git-log#_pretty_formats">the git log documentation</a> for a full column list.</p>
<p>There are also some prebuilt formats ready for immediate use. For example, we can get a simple summary of a commit using <code><a href="https://git-scm.com/docs/git-log#_pretty_formats">git log --pretty=reference -1 &lt;ref&gt;</a></code>. This query parses the commit at <code>&lt;ref&gt;</code> and provides the following information:</p>
<ul>
<li>An abbreviated object ID.</li>
<li>The first sentence of the commit message.</li>
<li>The commit date in short form.</li>
</ul>
<pre><code>$ git log --pretty=reference -1 378b51993aa022c432b23b7f1bafd921b7c43835
378b51993aa0 (gc: simplify --cruft description, 2022-06-19)
</code></pre>
<p>Now that we’ve explored some of the queries we can make in Git, let’s dig into the actual storage of this data.</p>
<h2 id="compressed-object-storage-packfiles">Compressed object storage: packfiles<a href="#compressed-object-storage-packfiles" aria-label="Compressed object storage: packfiles"></a></h2>
<p>Looking into the <code>.git/objects</code> directory again, we might see several directories with two-digit names. These directories then contain files with long hexadecimal names. These files are called <em>loose objects</em>, and the filename corresponds to the object ID of an object: the first two hexadecimal characters form the directory name while the rest form the filename. While the files themselves are compressed, there is not much interesting about querying these files, since Git relies on filesystem queries to satisfy most of these needs.</p>
<p>However, it does not take many objects before it is infeasible to store an entire Git repository using only loose objects. Not only does it strain the filesystem to have so many files, it is also inefficient when storing many versions of the same text file. Thus, Git’s <em>packed object store</em> in the <code>.git/objects/pack/</code> directory forms a more efficient way to store Git objects.</p>
<h3 id="packfiles-and-pack-indexes">Packfiles and pack-indexes<a href="#packfiles-and-pack-indexes" aria-label="Packfiles and pack-indexes"></a></h3>
<p>Each <code>*.pack</code> file in <code>.git/objects/pack/</code> is called a <em>packfile</em>. Packfiles store multiple objects in compressed forms. Not only is each object compressed individually, they can also be compressed against each other to take advantage of common data.</p>
<p>At its simplest, a packfile contains a concatenated list of objects. It only stores the object data, not the object ID. It is possible to read a packfile to find objects by object ID, but it requires decompressing and hashing each object to compare it to the input hash. Instead, each packfile is paired with a <em>pack-index</em> file ending with <code>.idx</code>. The pack-index file stores the list of object IDs in lexicographical order so a quick binary search is sufficient to discover if an object ID is in the packfile, then an <em>offset</em> value points to where the object’s data begins within the packfile. The pack-index operates like a query index that speeds up read queries that rely on the primary key (object ID).</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase6.png?resize=800%2C309" alt="" width="800" height="309" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase6.png?resize=800%2C309?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase6.png?resize=800%2C309?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase6.png?resize=800%2C309?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>One small optimization is that a <em>fanout table</em> of 256 entries provides boundaries within the full list of object IDs based on their first byte. This reduces the time spent by the binary search, specifically by focusing the search on a smaller number of memory pages. This works particularly well because object IDs are uniformly distributed so the fanout ranges are well-balanced.</p>
<p>If we have a number of packfiles, then we could ask each pack-index in sequence to look up the object. A further enhancement to packfiles is to put several pack-indexes together in a single <em>multi-pack-index</em>, which stores the same offset data plus which packfile the object is in.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase7.png?resize=800%2C309" alt="" width="800" height="309" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase7.png?resize=800%2C309?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase7.png?resize=800%2C309?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase7.png?resize=800%2C309?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>Lookups and prefixes work the same as in pack-indexes, except now we can skip the linear issue with many packs. You can read more about the <code>multi-pack-index</code> file and <a href="https://github.blog/2021-04-29-scaling-monorepo-maintenance/">how it helps scale monorepo maintenance at GitHub</a>.</p>
<h3 id="diffable-object-content">Diffable object content<a href="#diffable-object-content" aria-label="Diffable object content"></a></h3>
<p>Packfiles also have a hyper-specialized version of row compression called <em>deltification</em>. Since read queries are only indexed by the object ID, we can perform extra compression on the object data part.</p>
<p>Git was built to store source code, which consists of plain-text files that are used as input to a compiler or interpreter to create applications. Git was also built to store many versions of this source code as it is changed by humans. This provides additional context about the kind of data typically stored in Git: diffable files with significant portions in common. If you’ve ever wondered why you shouldn’t store large binary files in Git repositories, this is the reason.</p>
<p>The field of software engineering has made it clear that it is difficult to understand applications in their entirety. Humans can grasp a very high-level view of an architecture and can parse small sections of code, but we cannot store enough information in our brains to grasp huge amounts of concrete code at once. You can read more about this in the excellent book, <em><a href="https://www.manning.com/books/the-programmers-brain">The Programmer’s Brain</a></em> by Dr. Felienne Hermans.</p>
<p>Because of the limited size of our working memory, it is best to change code in <a href="https://github.blog/2022-06-30-write-better-commits-build-better-projects/">small, well-documented iterations</a>. This helps the code author, any code reviewers, and future developers looking at the code history. Between iterations, a significant majority of the code remains fixed while only small portions change. This allows Git to use difference algorithms to identify small diffs between the content of blob objects.</p>
<p>There are many ways to compute a difference between two blobs. Git has several difference algorithms implemented which <a href="https://link.springer.com/article/10.1007/s10664-019-09772-z">can have drastically different results</a>. Instead of focusing on unstructured differences, I want to focus on differences between structured object data. Specifically, tree objects usually change in small ways that are easy to compress.</p>
<h3 id="tree-diffs">Tree diffs<a href="#tree-diffs" aria-label="Tree diffs"></a></h3>
<p>Git’s tree objects can also be compared using a difference algorithm that is aware of the structure of tree entries. Each tree entry stores a mode (think Unix file permissions), an object type, a name, and an object ID. Object IDs are for all intents and purposes random, but most edits will change a file without changing its mode, type, or name. Further, large trees are likely to have only a few entries change at a time.</p>
<p>For example, the tip commit at any major Git release only changes one file: the <code>GIT-VERSION-GEN</code> file. This means also that the root tree only has one entry different from the previous root tree:</p>
<pre><code>$ git diff v2.37.0~1 v2.37.0
diff --git a/GIT-VERSION-GEN b/GIT-VERSION-GEN
index 120af376c1..b210b306b7 100755
--- a/GIT-VERSION-GEN
+++ b/GIT-VERSION-GEN
@@ -1,7 +1,7 @@
 #!/bin/sh

 GVF=GIT-VERSION-FILE
-DEF_VER=v2.37.0-rc2
+DEF_VER=v2.37.0

 LF=&#39;
 &#39;

$ git cat-file -p v2.37.0~1^{tree} &gt;old
$ git cat-file -p v2.37.0^{tree} &gt;new

$ diff old new
13c13
&lt; 100755 blob 120af376c147799e6c0069bac1f61709a0286cd6  GIT-VERSION-GEN
---
&gt; 100755 blob b210b306b7554f28dc687d1c503517d2a5f87082  GIT-VERSION-GEN
</code></pre>
<p>Once we have an algorithm that can compute diffs for Git objects, the packfile format can take advantage of that.</p>
<h3 id="delta-compression">Delta compression<a href="#delta-compression" aria-label="Delta compression"></a></h3>
<p>The <a href="https://github.com/git/git/blob/master/Documentation/technical/pack-format.txt">packfile format</a> begins with some simple header information, but then it contains Git object data concatenated together. Each object’s data starts with a type and a length. The type <em>could</em> be the object type, in which case the content in the packfile is the full object content (subject to <code><a href="https://en.wikipedia.org/wiki/Deflate">DEFLATE compression</a></code>). The object’s type could instead be an <em>offset delta</em>, in which case the data is based on the content of a previous object in the packfile.</p>
<p>An offset delta begins with an integer offset value pointing to the relative position of a previous object in the packfile. The remaining data specifies a list of instructions which either instruct how to copy data from the base object or to write new data chunks.</p>
<p>Thinking back to our example of the root tree for Git’s <code>v2.37.0</code> tag, we can store that tree as an offset delta to the previous root tree by copying the tree up until the object ID <code>120af37...</code>, then write the new object ID <code>b210b30...</code>, and finally copy the rest of the previous root tree.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase8.png?resize=800%2C225" alt="" width="800" height="225" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase8.png?resize=800%2C225?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase8.png?resize=800%2C225?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase8.png?resize=800%2C225?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>Keep in mind that these instructions are also <code>DEFLATE</code> compressed, so the new data chunks can also be compressed similarly to the base object. For the example above, we can see that the root tree for <code>v2.37.0</code> is around 19KB uncompressed, 14KB compressed, but can be represented as an offset delta in only 50 bytes.</p>
<pre><code>$ git rev-parse v2.37.0^{tree}
a4a2aa60ab45e767b52a26fc80a0a576aef2a010

$ git cat-file -s v2.37.0^{tree}
19388

$ ls -al .git/objects/a4/a2aa60ab45e767b52a26fc80a0a576aef2a010
-r--r--r--   1 ... ... 13966 Aug  1 13:24 a2aa60ab45e767b52a26fc80a0a576aef2a010

$ git rev-parse v2.37.0^{tree} | git cat-file --batch-check=&#34;%(objectsize:disk)&#34;
50
</code></pre>
<p>Also, an offset delta can be based on another object that is also an offset delta. This creates a <em>delta chain</em> that requires computing the object data for each object in the list. In fact, we need to traverse the delta links in order to even determine the object type.</p>
<p>For this reason, there is a cost to storing objects efficiently this way. At read time, we need to do a bit extra work to materialize the raw object content Git needs to parse to satisfy its queries. There are multiple ways that Git tries to optimize this trade-off.</p>
<p>One way Git minimizes the extra work when parsing delta chains is by keeping the delta-chains short. The <code><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-packdepth">pack.depth config value</a></code> specifies an upper limit on how long delta chains can be while creating a packfile. The default limit is 50.</p>
<p>When writing a packfile, Git attempts to use a recent object as the base and order the delta chain in reverse-chronological order. This allows the queries that involve recent objects to have minimum overhead, while the queries that involve older objects have slightly more overhead.</p>
<p>However, while thinking about the overhead of computing object contents from a delta chain, it is important to think about what kind of resources are being used. For example, to compute the diff between <code>v2.37.0</code> and its parent, we need to load both root trees. If these root trees are in the same delta chain, then that chain’s data on disk is smaller than if they were stored in raw form. Since the packfile also places delta chains in adjacent locations in the packfile, the cost of reading the base object and its delta from disk is almost identical to reading just the base object. The extra overhead of some CPU during the parse is very small compared to the disk read. In this way, reading multiple objects in the same delta chain is <em>faster</em> than reading multiple objects across different chains.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/08/gitdatabase9.png?resize=800%2C546" alt="" width="800" height="546" srcset="https://github.blog/wp-content/uploads/2022/08/gitdatabase9.png?resize=800%2C546?w=800 800w, https://github.blog/wp-content/uploads/2022/08/gitdatabase9.png?resize=800%2C546?w=300 300w, https://github.blog/wp-content/uploads/2022/08/gitdatabase9.png?resize=800%2C546?w=768 768w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<p>In addition, some Git commands query the object store in such a way that we are very likely to parse multiple objects in the same delta chain. We will cover this more in part III when discussing file history queries.</p>
<p>In addition to persisting data efficiently to disk, the packfile format is also critical to how Git synchronizes Git object data across distributed copies of the repository during <code>git fetch</code> and <code>git push</code>. We will learn more about this in part IV when discussing distributed synchronization.</p>
<h2 id="packfile-maintenance">Packfile maintenance<a href="#packfile-maintenance" aria-label="Packfile maintenance"></a></h2>
<p>In order to take advantage of packfiles and their compressed representation of Git objects, Git needs to actually write these packfiles. It is too expensive to create a packfile for every object write, so Git batches the packfile write into certain commands.</p>
<p>You could roll your own packfile using <code><a href="https://www.git-scm.com/docs/git-pack-objects">git pack-objects</a></code> and create a pack-index for it using <code><a href="https://www.git-scm.com/docs/git-index-pack">git index-pack</a></code>. However, you instead might want to recompute a new packfile containing your entire object store using <code><a href="https://www.git-scm.com/docs/git-repack">git repack -a</a></code> or <code><a href="https://www.git-scm.com/docs/git-gc">git gc</a></code>.</p>
<p>As your repository grows, it becomes more difficult to replace your entire object store with a new packfile. For starters, you need enough space to store two copies of your Git object data. In addition, the computation effort to find good delta compression is very expensive and demanding. An optimal way to do delta compression takes quadratic time over the number objects, which is quickly infeasible. Git uses several heuristics to help with this, but still the cost of repacking everything all at once can be more than we are willing to spend, especially if we are just a client repository and not responsible for serving our Git data to multiple users.</p>
<p>There are two primary ways to update your object store for efficient reads without rewriting the entire object store into a new packfile. One is the <a href="https://github.blog/2021-08-16-highlights-from-git-2-33/#geometric-repacking">geometric repacking option</a> where you can run <code><a href="https://git-scm.com/docs/git-repack#Documentation/git-repack.txt--gltfactorgt">git repack --geometric</a></code> to repack only a portion of packfiles until the resulting packfiles form a geometric sequence. That is, each packfile is some fixed multiple smaller than the next largest one. This uses the <code>multi-pack-index</code> to keep logarithmic performance for object lookups, but will occasionally tip over to repack all of the object data. That “tip over” moment only happens when the repository doubles in size, which does not happen very often.</p>
<p>Another approach to reducing the amount of work spent repacking is the <a href="https://git-scm.com/docs/git-maintenance#Documentation/git-maintenance.txt-incremental-repack">incremental repack task</a> in the <code>git maintenance</code> command. This task collects packfiles below a fixed size threshold and groups them together, at least until their total size is above that threshold. The default threshold is two gigabytes. This task is used by default when you enable <a href="https://github.blog/2021-03-15-highlights-from-git-2-31/#introducing-git-maintenance">background maintenance</a> with the <code><a href="https://git-scm.com/docs/git-maintenance#Documentation/git-maintenance.txt-start">git maintenance start command</a></code>. This also uses the <code>multi-pack-index</code> to keep fast lookups, but also will not rewrite the entire object store for large repositories since once a packfile is larger than the threshold it is not considered for repacking. The storage is slightly inefficient here, since objects in newer packfiles could be stored as deltas to objects in those fixed packs, but the simplicity in avoiding expensive repository maintenance is worth that slight overhead.</p>
<p>If you’re interested in keeping your repositories well maintained, then think about these options. You can always perform a full repack that recomputes all delta chains using <code>git repack -adf</code> at any time you are willing to spend that upfront maintenance cost.</p>
<h2 id="what-could-git-learn-from-other-databases">What could Git learn from other databases?<a href="#what-could-git-learn-from-other-databases" aria-label="What could Git learn from other databases?"></a></h2>
<p>Now that we have some understanding about how Git stores and accesses packed object data, let’s think about features that exist in application database systems that might be helpful here.</p>
<p>One thing to note is that there are no <a href="https://en.wikipedia.org/wiki/B-tree">B-trees</a> to be found! Almost every database introduction talks about how B-trees are used to efficiently index data in a database table. Why are they not present here in Git?</p>
<p>The main reason Git does not use B-trees is because it doesn’t do “live updating” of packfiles and pack-indexes. Once a packfile is written, it is static until it is replaced by another packfile containing its objects. That packfile is also not accessed by Git processes until its pack-index is completely written.</p>
<p>In this world, objects are dynamically added to the object store by adding new loose object files (such as in <code>git add</code> or <code>git commit</code>) or by adding new packfiles (such as in <code>git fetch</code>). If a packfile has fixed content, then we can do the most space-and-time efficient index: a binary search tree. Specifically, performing binary search on the list of object IDs in a pack-index is very efficient. It’s not an exact binary search because there <em>is</em> an initial fan-out table for the first byte of the object ID. It’s kind of like a rooted binary tree, except the root node has 256 children instead of only two.</p>
<p>B-trees excel when data is being inserted or removed from the tree. Being able to track those modifications with minimal modifications to the overall tree structure is critical for an application database serving many concurrent requests.</p>
<p>Git does not currently have the capability to update a packfile in real time without shutting down concurrent reads from that file. Such a change could be possible, but it would require updating Git’s storage significantly. I think this is one area where a database expert could contribute to the Git project in really interesting ways.</p>
<p>Another difference between Git and most database systems is that Git runs as short-lived processes. Typically, we think of the database as a process that has data cached in memory. We send queries to the existing process and it returns results and keeps running. Instead, Git starts a new process with every “query” and relies on the filesystem for persisted state. Git also relies on the operating system to cache the disk pages during and between the processes. Expert database systems tell the kernel to stop managing disk pages and instead the database manages the page cache since it knows its usage needs better than a general purpose operating system could predict.</p>
<p>What if Git had a long-running daemon that could satisfy queries on-demand, but also keep that in-memory representation of data instead of needing to parse objects from disk every time? Although the current architecture of Git is not well-suited to this, I believe it is an idea worth exploring in the future.</p>
<h2 id="come-back-tomorrow-for-more">Come back tomorrow for more!<a href="#come-back-tomorrow-for-more" aria-label="Come back tomorrow for more!"></a></h2>
<p>In the next part of this blog series, we will explore how Git commit history queries use the structure of Git commits to present interesting information to the user. We’ll also explore the <code>commit-graph</code> file and how it acts as a specialized query index for these commands.</p>
<p>I’ll also be <a href="https://git-merge.com/#git-internals-a-database-perspective">speaking at Git Merge 2022</a> covering all five parts of this blog series, so I look forward to seeing you there!</p>

      
  </main>


  </div>
</div></div>
  </body>
</html>
