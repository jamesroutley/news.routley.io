<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://motherduck.com/blog/semantic-layer-duckdb-tutorial/">Original</a>
    <h1>Why Semantic Layers Matter (and how to build one with DuckDB)</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Many ask themselves, &#34;Why would I use a semantic layer? What is it anyway?&#34; In this hands-on guide, we’ll build the simplest possible semantic layer using just a YAML file and a Python script—not as the goal itself, but as a way to understand the value of semantic layers. We’ll then query 20 million NYC taxi records with consistent business metrics executed using DuckDB and Ibis. By the end, you’ll know exactly when a semantic layer solves real problems and when it’s overkill.</p>
<p>It&#39;s a topic that I&#39;m passionate about as I&#39;ve been using semantic layers within a Business Intelligence (BI) tool for over twenty years, and only recently have we gotten full-blown semantic layers that can sit outside of a BI tool, combining the advantages of a logical layer with sharing them across your web apps, notebooks, and BI tools. With a semantic layer, your revenue KPI or other complex company measures are defined once in a single source of truth—no need to re-implement them over and over again.</p>
<p>We&#39;ll have a look at the simplest possible semantic layer, which uses a simple YAML file (for the semantics) and a Python script for executing it with Ibis and DuckDB. We&#39;ll do a quick recap of the semantic layer before diving into a practical code example.</p>
<p><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12C11 11.7348 11.1054 11.4804 11.2929 11.2929C11.4804 11.1054 11.7348 11 12 11H20C20.2652 11 20.5196 11.1054 20.7071 11.2929C20.8946 11.4804 21 11.7348 21 12C21 12.2652 20.8946 12.5196 20.7071 12.7071C20.5196 12.8946 20.2652 13 20 13H12C11.7348 13 11.4804 12.8946 11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12ZM12 17H20C20.2652 17 20.5196 16.8946 20.7071 16.7071C20.8946 16.5196 21 16.2652 21 16C21 15.7348 20.8946 15.4804 20.7071 15.2929C20.5196 15.1054 20.2652 15 20 15H12C11.7348 15 11.4804 15.1054 11.2929 15.2929C11.1054 15.4804 11 15.7348 11 16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17ZM16 19H12C11.7348 19 11.4804 19.1054 11.2929 19.2929C11.1054 19.4804 11 19.7348 11 20C11 20.2652 11.1054 20.5196 11.2929 20.7071C11.4804 20.8946 11.7348 21 12 21H16C16.2652 21 16.5196 20.8946 16.7071 20.7071C16.8946 20.5196 17 20.2652 17 20C17 19.7348 16.8946 19.4804 16.7071 19.2929C16.5196 19.1054 16.2652 19 16 19ZM28 6V19.5863C28.0008 19.849 27.9494 20.1093 27.8488 20.352C27.7482 20.5947 27.6003 20.815 27.4137 21L21 27.4137C20.815 27.6003 20.5947 27.7482 20.352 27.8488C20.1093 27.9494 19.849 28.0008 19.5863 28H6C5.46957 28 4.96086 27.7893 4.58579 27.4142C4.21071 27.0391 4 26.5304 4 26V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H26C26.5304 4 27.0391 4.21071 27.4142 4.58579C27.7893 4.96086 28 5.46957 28 6ZM6 26H19V20C19 19.7348 19.1054 19.4804 19.2929 19.2929C19.4804 19.1054 19.7348 19 20 19H26V6H6V26ZM21 21V24.5875L24.5863 21H21Z" fill="#383838"></path></svg> <span>NOTE<!-- -->: Find the Code on GitHub</span></span>
For all the examples shown in this article, find the code on the GitHub repository <a href="https://github.com/sspaeti/semantic-layer-duckdb">semantic-layer-duckdb</a>.
</span></p><section><h2 id="when-you-dont-need-a-semantic-layer">When You Don&#39;t Need a Semantic Layer</h2><p>Let&#39;s start by exploring when you don&#39;t need a semantic layer and when it&#39;s the wrong choice. The simplest and most straightforward reasons are:</p><ul>
<li>You&#39;re just getting started with analytics and only have one consumer, meaning you only have one way of showcasing analytics data, for example, a BI tool, notebooks, or a web app, but not multiple ways of presenting data. This means you don&#39;t apply calculated logic in different places.</li>
<li>You don&#39;t have extensive business logic that you query ad hoc; you have simple counts, SUMs, or averages.</li>
<li>You preprocess all your metrics as SQL transformations into physical tables, meaning your downstream analytics tools get all metrics preprocessed and aggregated, and filtering is fast enough.</li>
</ul></section>
<section><h2 id="why-use-a-semantic-layer">Why Use a Semantic Layer?</h2><p>So when do we actually need one, and what is it? There&#39;s a lot of information out there, including from myself about the <a href="https://www.ssp.sh/blog/rise-of-semantic-layer-metrics/">history and rise [2022]</a>, comparing it to an <a href="https://cube.dev/blog/exploring-the-semantic-layer-through-the-lens-of-mvc">MVC-like approach</a>, or explaining its <a href="https://cube.dev/blog/universal-semantic-layer-capabilities-integrations-and-enterprise-benefits">capabilities</a>. That&#39;s why in this article I focus on the <em>why</em> and showcase how to use it in a practical example in the next chapter.</p><p>The main reasons for using a semantic layer may be one or more of the following needs:</p><ol>
<li><strong>Unified place</strong> to define ad hoc queries once, version-controlled and collaboratively, with the possibility of pulling them into different BI tools, web apps, notebooks, or AI/MCP integration. Avoid <strong>duplication</strong> of metrics in every tool, making <strong>maintainability</strong> and data governance much easier; resulting in a <strong>consistent business layer</strong> with encapsulated business logic.</li>
</ol><p><em><strong>Example</strong></em>: Most organizations quickly run multiple BI tools simultaneously with additional Excel or Google Sheets. Instead of maintaining separate calculated fields and business logic in each tool in a proprietary format, semantic layers provide one definition that works across all platforms.</p><ol start="2">
<li><strong>Caching</strong> is needed for ad hoc queries that are based on various source databases. Defining the metrics that enable pre-calculations for sub-second query responses can benefit any downstream analytics tools compared to implementing custom database connections and different databases. Eliminating potential <strong>data movement costs</strong> by querying data where it lives, using dialect-optimized SQL pushdown across heterogeneous sources. This reduces infrastructure overhead and cloud computing costs.</li>
</ol><p><em><strong>Example</strong></em>: For a non-production or high-load OLTP source, the semantic layer can directly query the various data sources (e.g., IoT data, logs, and other data) instead of moving them into a data lake or data warehouse, and through the cache of the semantic layer, it&#39;s fast enough without data movement.</p><ol start="3">
<li>Unified <strong>access-level security</strong> through <strong>various APIs</strong> (REST, GraphQL, SQL, ODBC/JDBC, MDX/Excel) as well. Unified Analytics API enables self-serve BI by allowing users to connect Excel to a cleaned, fast, and unified API.</li>
</ol><p><em><strong>Example</strong></em>: Centralized row-level and column-level security that works consistently across all downstream analytics tools, rather than trying to manage access controls separately in each BI tool or analytics tool that has access to the data. Users can connect directly with Excel and have the correct permissions and calculated business metrics out of the box.</p><ol start="4">
<li><strong>Dynamic query rewriting</strong> automatically translates simple, business-friendly queries into complex, optimized SQL across multiple databases. This enables users to write intuitive queries using business concepts (like &#34;average_order_value&#34;) without needing to know the underlying data model complexity, table relationships, or database-specific syntax. The semantic layer <strong>abstracts</strong> complex analytics, such as ratios at different grains, time ranges (YoY, trailing periods), and custom calendars, into simple semantic queries.</li>
</ol><p><em><strong>Example</strong></em>: Complex analytics simplified by handling sophisticated calculations that are painful in raw SQL: ratios at different grains (like per-member-per-month in insurance), time intelligence (year-over-date, trailing 12 months, period-over-period), and custom calendar logic. These become simple semantic queries rather than complex subqueries with distinct counts.</p><ol start="5">
<li>Context for LLMs to improve accuracy and natural language querying can be significantly enhanced with a semantic layer, which provides business context and prevents AI from hallucinating frequently, as most of the business logic is configured and defined in a semantic layer, sometimes even data models, to help LLMs further understand the business.</li>
</ol><p><em><strong>Example</strong></em>: Internal Large Language Models (LLMs) or Retrieval-Augmented Generation (RAG) systems need business context to understand the business. A semantic layer&#39;s connection of dimensions and facts, along with metric definitions, can help the model understand and suggest better SQL queries or responses through natural language.</p><hr/><p>More broadly, semantic layers bridge the gap between business needs and data source integration in a very organized and governed way. They are best optimized for larger enterprises with numerous scattered KPIs that can afford to add another layer to their data stack. However, the example below uses the simplest and smallest semantic layer, even with little data.</p><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12C11 11.7348 11.1054 11.4804 11.2929 11.2929C11.4804 11.1054 11.7348 11 12 11H20C20.2652 11 20.5196 11.1054 20.7071 11.2929C20.8946 11.4804 21 11.7348 21 12C21 12.2652 20.8946 12.5196 20.7071 12.7071C20.5196 12.8946 20.2652 13 20 13H12C11.7348 13 11.4804 12.8946 11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12ZM12 17H20C20.2652 17 20.5196 16.8946 20.7071 16.7071C20.8946 16.5196 21 16.2652 21 16C21 15.7348 20.8946 15.4804 20.7071 15.2929C20.5196 15.1054 20.2652 15 20 15H12C11.7348 15 11.4804 15.1054 11.2929 15.2929C11.1054 15.4804 11 15.7348 11 16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17ZM16 19H12C11.7348 19 11.4804 19.1054 11.2929 19.2929C11.1054 19.4804 11 19.7348 11 20C11 20.2652 11.1054 20.5196 11.2929 20.7071C11.4804 20.8946 11.7348 21 12 21H16C16.2652 21 16.5196 20.8946 16.7071 20.7071C16.8946 20.5196 17 20.2652 17 20C17 19.7348 16.8946 19.4804 16.7071 19.2929C16.5196 19.1054 16.2652 19 16 19ZM28 6V19.5863C28.0008 19.849 27.9494 20.1093 27.8488 20.352C27.7482 20.5947 27.6003 20.815 27.4137 21L21 27.4137C20.815 27.6003 20.5947 27.7482 20.352 27.8488C20.1093 27.9494 19.849 28.0008 19.5863 28H6C5.46957 28 4.96086 27.7893 4.58579 27.4142C4.21071 27.0391 4 26.5304 4 26V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H26C26.5304 4 27.0391 4.21071 27.4142 4.58579C27.7893 4.96086 28 5.46957 28 6ZM6 26H19V20C19 19.7348 19.1054 19.4804 19.2929 19.2929C19.4804 19.1054 19.7348 19 20 19H26V6H6V26ZM21 21V24.5875L24.5863 21H21Z" fill="#383838"></path></svg> <span>EXAMPLE<!-- -->: If you want to know more</span></span>
Brian Bickell gave a great talk at the Practical Data Community about semantic layers and the problem they solve. I highly recommend checking that out too at <a href="https://youtu.be/kcctcQhlxOw?si=hdRHLFlWY11bYNgl&amp;t=1119">Semantic Layer Deep Dive</a>. If you&#39;re already on the Practical Data show from Joe Reis, also check out Hamilton Ulmer&#39;s presentation about <a href="https://www.youtube.com/watch?v=EOpkSsSDv40&amp;t=2457s">Instant SQL with DuckDB/MotherDuck</a>, not entirely about semantic layers, but related to the history of SQL and CTEs and how instant SQL can help.
</span><section><h3 id="datasets-vs-aggregations">Datasets vs. Aggregations</h3><p>An important distinction is whether we need <strong>persistent</strong> datasets or we want <strong>ad hoc</strong> queries. These are typically very different. Ad hoc queries must be flexible and change granularity based on added dimensions. This means someone running a query might switch from a daily view to a weekly or monthly one, add a region, and then decide to roll it up to a country level; all of this can happen in a couple of seconds. Therefore, there is no time to refresh or process the data.</p><p>Calculated measures need to be added on the fly, without requiring an ETL job to be reprocessed. A common workaround is to create multiple persistent physical datasets with dbt, each containing the same data but with varying granularity, allowing for the display of different charts in the BI tool with different focuses. A semantic layer, or ad hoc queries, does that on the fly.</p><p>We can differentiate and say:</p><ul>
<li>dataset ≠ aggregations</li>
<li>table columns ≠ metrics</li>
<li>physical table ≠ logical definition</li>
</ul><p>If you find yourself needing the concepts on the right side, that&#39;s when you need a semantic layer—whether built into a BI tool or implemented separately for the reasons mentioned above.</p></section></section>
<section><h2 id="how-a-semantic-layer-works-a-practical-example">How a Semantic Layer Works: A Practical Example</h2><p>Now let&#39;s see this in action by analyzing the most pragmatic semantic layer there is. The simplest semantic layer I found is by Julien Hurault, who recently announced the release of the <a href="https://github.com/boringdata/boring-semantic-layer">Boring Semantic Layer (BSL)</a> project. We use DuckDB as the query engine and Python with <a href="https://github.com/ibis-project/ibis">Ibis</a> for the execution layer.</p><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12C11 11.7348 11.1054 11.4804 11.2929 11.2929C11.4804 11.1054 11.7348 11 12 11H20C20.2652 11 20.5196 11.1054 20.7071 11.2929C20.8946 11.4804 21 11.7348 21 12C21 12.2652 20.8946 12.5196 20.7071 12.7071C20.5196 12.8946 20.2652 13 20 13H12C11.7348 13 11.4804 12.8946 11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12ZM12 17H20C20.2652 17 20.5196 16.8946 20.7071 16.7071C20.8946 16.5196 21 16.2652 21 16C21 15.7348 20.8946 15.4804 20.7071 15.2929C20.5196 15.1054 20.2652 15 20 15H12C11.7348 15 11.4804 15.1054 11.2929 15.2929C11.1054 15.4804 11 15.7348 11 16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17ZM16 19H12C11.7348 19 11.4804 19.1054 11.2929 19.2929C11.1054 19.4804 11 19.7348 11 20C11 20.2652 11.1054 20.5196 11.2929 20.7071C11.4804 20.8946 11.7348 21 12 21H16C16.2652 21 16.5196 20.8946 16.7071 20.7071C16.8946 20.5196 17 20.2652 17 20C17 19.7348 16.8946 19.4804 16.7071 19.2929C16.5196 19.1054 16.2652 19 16 19ZM28 6V19.5863C28.0008 19.849 27.9494 20.1093 27.8488 20.352C27.7482 20.5947 27.6003 20.815 27.4137 21L21 27.4137C20.815 27.6003 20.5947 27.7482 20.352 27.8488C20.1093 27.9494 19.849 28.0008 19.5863 28H6C5.46957 28 4.96086 27.7893 4.58579 27.4142C4.21071 27.0391 4 26.5304 4 26V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H26C26.5304 4 27.0391 4.21071 27.4142 4.58579C27.7893 4.96086 28 5.46957 28 6ZM6 26H19V20C19 19.7348 19.1054 19.4804 19.2929 19.2929C19.4804 19.1054 19.7348 19 20 19H26V6H6V26ZM21 21V24.5875L24.5863 21H21Z" fill="#383838"></path></svg> <span>NOTE<!-- -->: What this Semantic Layer does not have</span></span>
This is a relatively simple semantic layer. More advanced ones include additional features such as multiple robust APIs (REST, GraphQL, SQL, ODBC, Excel), advanced security controls, and a powerful caching layer.
This example focuses on the <a href="https://en.wikipedia.org/wiki/Logical_schema">Logical Data Model</a>, where we can define our business requirements within YAML, an abstraction above our physical layer. Although this is quite close to the physical layer, this is where more advanced semantic layer tools (Cube, dbt SL, GoodData, AtScale) give you more advantages in an enterprise setting.
</span><p>We&#39;re going to build something like what&#39;s illustrated below—where we have YAML definitions as our metrics, such as calculated measures and dimensions, and Ibis for the query translation to run <a href="https://github.com/ibis-project/ibis#how-it-works">any execution engine</a>; here we use DuckDB.</p><img alt="img1" loading="lazy" decoding="async" data-nimg="fill" sizes="90vw,
                        (min-width: 728px) 800px,
                        (min-width: 960px) 950px," srcset="/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=640&amp;q=75 640w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=750&amp;q=75 750w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=828&amp;q=75 828w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=3840&amp;q=75 3840w" src="https://motherduck.com/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg1_sem_da2c2e7350.png&amp;w=3840&amp;q=75"/><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.5C6.71442 1.5 5.45772 1.88122 4.3888 2.59545C3.31988 3.30968 2.48676 4.32484 1.99479 5.51256C1.50282 6.70028 1.37409 8.00721 1.6249 9.26809C1.8757 10.529 2.49477 11.6872 3.40381 12.5962C4.31285 13.5052 5.47104 14.1243 6.73192 14.3751C7.99279 14.6259 9.29973 14.4972 10.4874 14.0052C11.6752 13.5132 12.6903 12.6801 13.4046 11.6112C14.1188 10.5423 14.5 9.28558 14.5 8C14.4982 6.27665 13.8128 4.62441 12.5942 3.40582C11.3756 2.18722 9.72335 1.50182 8 1.5ZM8 13.5C6.91221 13.5 5.84884 13.1774 4.94437 12.5731C4.0399 11.9687 3.33495 11.1098 2.91867 10.1048C2.50238 9.09977 2.39347 7.9939 2.60568 6.927C2.8179 5.86011 3.34173 4.8801 4.11092 4.11091C4.8801 3.34172 5.86011 2.8179 6.92701 2.60568C7.9939 2.39346 9.09977 2.50238 10.1048 2.91866C11.1098 3.33494 11.9687 4.03989 12.5731 4.94436C13.1774 5.84883 13.5 6.9122 13.5 8C13.4983 9.45818 12.9184 10.8562 11.8873 11.8873C10.8562 12.9184 9.45819 13.4983 8 13.5ZM9 11C9 11.1326 8.94732 11.2598 8.85356 11.3536C8.75979 11.4473 8.63261 11.5 8.5 11.5C8.23479 11.5 7.98043 11.3946 7.7929 11.2071C7.60536 11.0196 7.5 10.7652 7.5 10.5V8C7.36739 8 7.24022 7.94732 7.14645 7.85355C7.05268 7.75979 7 7.63261 7 7.5C7 7.36739 7.05268 7.24021 7.14645 7.14645C7.24022 7.05268 7.36739 7 7.5 7C7.76522 7 8.01957 7.10536 8.20711 7.29289C8.39465 7.48043 8.5 7.73478 8.5 8V10.5C8.63261 10.5 8.75979 10.5527 8.85356 10.6464C8.94732 10.7402 9 10.8674 9 11ZM7 5.25C7 5.10166 7.04399 4.95666 7.1264 4.83332C7.20881 4.70999 7.32595 4.61386 7.46299 4.55709C7.60003 4.50032 7.75083 4.48547 7.89632 4.51441C8.04181 4.54335 8.17544 4.61478 8.28033 4.71967C8.38522 4.82456 8.45665 4.9582 8.48559 5.10368C8.51453 5.24917 8.49968 5.39997 8.44291 5.53701C8.38615 5.67406 8.29002 5.79119 8.16668 5.8736C8.04334 5.95601 7.89834 6 7.75 6C7.55109 6 7.36032 5.92098 7.21967 5.78033C7.07902 5.63968 7 5.44891 7 5.25Z" fill="#383838"></path></svg> <span>INFO<!-- -->: Data Catalogs</span></span>
If you wonder how <a href="https://ducklake.select/">DuckLake</a> or other open table format catalogs (Iceberg, Unity, Polaris) fit into the picture, they would be connected to the metrics definition. Hence, the catalog has the complete list of available data assets. You can view open data catalogs as a lookup service for the datasets in your data lake. If you use a semantic layer as we implement here, you won&#39;t need an additional catalog because all your metrics and dimensions are defined within the semantic layer itself.
</span><section><h3 id="getting-started">Getting Started</h3><p>Let&#39;s create a virtual environment where we install our dependencies and install the semantic layer:</p><pre><code>git <span>clone</span> git@github.com:sspaeti/semantic-layer-duckdb.git
uv <span>sync</span> 
</code></pre><p>That will not only install the semantic layer, but also Ibis and other requirements.</p><p>Now we are ready to define our metrics. To simplify this example and focus on the metrics rather than the data, I utilized the <a href="https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page">NYC Taxi Dataset</a>, which we all know and are familiar with. They have a lookup table for pickups and lots of data we can use, and it is available via HTTPS.</p><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12C11 11.7348 11.1054 11.4804 11.2929 11.2929C11.4804 11.1054 11.7348 11 12 11H20C20.2652 11 20.5196 11.1054 20.7071 11.2929C20.8946 11.4804 21 11.7348 21 12C21 12.2652 20.8946 12.5196 20.7071 12.7071C20.5196 12.8946 20.2652 13 20 13H12C11.7348 13 11.4804 12.8946 11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12ZM12 17H20C20.2652 17 20.5196 16.8946 20.7071 16.7071C20.8946 16.5196 21 16.2652 21 16C21 15.7348 20.8946 15.4804 20.7071 15.2929C20.5196 15.1054 20.2652 15 20 15H12C11.7348 15 11.4804 15.1054 11.2929 15.2929C11.1054 15.4804 11 15.7348 11 16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17ZM16 19H12C11.7348 19 11.4804 19.1054 11.2929 19.2929C11.1054 19.4804 11 19.7348 11 20C11 20.2652 11.1054 20.5196 11.2929 20.7071C11.4804 20.8946 11.7348 21 12 21H16C16.2652 21 16.5196 20.8946 16.7071 20.7071C16.8946 20.5196 17 20.2652 17 20C17 19.7348 16.8946 19.4804 16.7071 19.2929C16.5196 19.1054 16.2652 19 16 19ZM28 6V19.5863C28.0008 19.849 27.9494 20.1093 27.8488 20.352C27.7482 20.5947 27.6003 20.815 27.4137 21L21 27.4137C20.815 27.6003 20.5947 27.7482 20.352 27.8488C20.1093 27.9494 19.849 28.0008 19.5863 28H6C5.46957 28 4.96086 27.7893 4.58579 27.4142C4.21071 27.0391 4 26.5304 4 26V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H26C26.5304 4 27.0391 4.21071 27.4142 4.58579C27.7893 4.96086 28 5.46957 28 6ZM6 26H19V20C19 19.7348 19.1054 19.4804 19.2929 19.2929C19.4804 19.1054 19.7348 19 20 19H26V6H6V26ZM21 21V24.5875L24.5863 21H21Z" fill="#383838"></path></svg> <span>NOTE<!-- -->: You can use MotherDuck Shared datasets</span></span>
If you want to use MotherDuck&#39;s shared datasets, please check out <a href="https://motherduck.com/docs/getting-started/sample-data-queries/datasets/">Example Datasets</a>, for example the <a href="https://motherduck.com/docs/getting-started/sample-data-queries/nyc-311-data/">NYC 311 Service Requests Data</a> is uploaded, as well as <a href="https://motherduck.com/docs/getting-started/sample-data-queries/foursquare/">Foursquare</a> and other helpful ones. You can query this data instantly by running duckdb and connecting to MotherDuck as showcased below:
<img alt="MotherDuck DuckDB Query Example" loading="lazy" decoding="async" data-nimg="fill" sizes="90vw,
                        (min-width: 728px) 800px,
                        (min-width: 960px) 950px," srcset="/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=640&amp;q=75 640w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=750&amp;q=75 750w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=828&amp;q=75 828w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=3840&amp;q=75 3840w" src="https://motherduck.com/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg3_sem_a554627e3c.png&amp;w=3840&amp;q=75"/>
</span><p>As we know now, semantic layers are suitable for defining metrics in a central and configurable way, so we use YAML for this. YAML has minimal overhead and is easy to read, which is why most semantic layers use it. Alternatively, SQL would be a better choice, but it lacks essential features like variables and tends to become overly nested and challenging to maintain. YAML, combined with occasional SQL injection, proves to be the most effective solution.</p><p>First, let&#39;s check out what data we are working with—we can quickly count and describe the tables:</p><pre><code>D <span>select</span> count(*) FROM read_parquet(<span>&#34;https://d37ci6vzurychx.cloudfront.net/trip-data/fhvhv_tripdata_2025-06.parquet&#34;</span>);
┌─────────────────┐
│  count_star()   │
│      int64      │
├─────────────────┤
│    19868009     │
│ (19.87 million) │
└─────────────────┘
D DESCRIBE FROM read_parquet(<span>&#34;https://d37ci6vzurychx.cloudfront.net/trip-data/fhvhv_tripdata_2025-06.parquet&#34;</span>);
┌──────────────────────┬─────────────┬─────────┬─────────┬─────────┬─────────┐
│     column_name      │ column_type │  null   │   key   │ default │  extra  │
│       varchar        │   varchar   │ varchar │ varchar │ varchar │ varchar │
├──────────────────────┼─────────────┼─────────┼─────────┼─────────┼─────────┤
│ hvfhs_license_num    │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ dispatching_base_num │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ originating_base_num │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ request_datetime     │ TIMESTAMP   │ YES     │ NULL    │ NULL    │ NULL    │
│ on_scene_datetime    │ TIMESTAMP   │ YES     │ NULL    │ NULL    │ NULL    │
│ pickup_datetime      │ TIMESTAMP   │ YES     │ NULL    │ NULL    │ NULL    │
│ dropoff_datetime     │ TIMESTAMP   │ YES     │ NULL    │ NULL    │ NULL    │
│ PULocationID         │ INTEGER     │ YES     │ NULL    │ NULL    │ NULL    │
│ DOLocationID         │ INTEGER     │ YES     │ NULL    │ NULL    │ NULL    │
│ trip_miles           │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ trip_time            │ BIGINT      │ YES     │ NULL    │ NULL    │ NULL    │
│ base_passenger_fare  │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ tolls                │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ bcf                  │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ sales_tax            │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ congestion_surcharge │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ airport_fee          │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ tips                 │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ driver_pay           │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
│ shared_request_flag  │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ shared_match_flag    │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ access_a_ride_flag   │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ wav_request_flag     │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ wav_match_flag       │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ cbd_congestion_fee   │ DOUBLE      │ YES     │ NULL    │ NULL    │ NULL    │
├──────────────────────┴─────────────┴─────────┴─────────┴─────────┴─────────┤
│ 25 rows                                                          6 columns │
└────────────────────────────────────────────────────────────────────────────┘
</code></pre><p>As well as the CSV lookups:</p><pre><code>D <span>select</span> count(*) from read_csv(<span>&#34;https://d37ci6vzurychx.cloudfront.net/misc/taxi+_zone_lookup.csv&#34;</span>);
┌──────────────┐
│ count_star() │
│    int64     │
├──────────────┤
│     265      │
└──────────────┘
D describe from read_csv(<span>&#34;https://d37ci6vzurychx.cloudfront.net/misc/taxi+_zone_lookup.csv&#34;</span>);
┌──────────────┬─────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name  │ column_type │  null   │   key   │ default │  extra  │
│   varchar    │   varchar   │ varchar │ varchar │ varchar │ varchar │
├──────────────┼─────────────┼─────────┼─────────┼─────────┼─────────┤
│ LocationID   │ BIGINT      │ YES     │ NULL    │ NULL    │ NULL    │
│ Borough      │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ Zone         │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
│ service_zone │ VARCHAR     │ YES     │ NULL    │ NULL    │ NULL    │
└──────────────┴─────────────┴─────────┴─────────┴─────────┴─────────┘
</code></pre><p>This gives us a good sense of what we are dealing with. From the <a href="https://www.nyc.gov/assets/tlc/downloads/pdf/data_dictionary_trip_records_hvfhs.pdf">data dictionary</a>, we understand that <code>PULocationID</code> and <code>DOLocationID</code> represent the Taxi zones to be joined with the above zone lookup by the column <code>LocationID</code>.</p><p>Usually what I do next is use the <a href="https://duckdb.org/docs/stable/guides/meta/summarize.html"><code>SUMMARIZE</code> command</a>, which is a DuckDB-specific query type that gives us statistics about the data such as <code>min</code>, <code>max</code>, <code>approx_unique</code>, <code>avg</code>, <code>std</code>, <code>q25</code>, <code>q50</code>, <code>q75</code>, <code>count</code>. This gives us a fast and handy overview of what we are dealing with.</p><section><h4 id="defining-metrics-in-boring-semantic-layer">Defining Metrics in Boring Semantic Layer</h4><p>Next, we can start defining our metrics. Let&#39;s start by setting the timestamp and its granularity (required by BSL), followed by the dimensions, which looks something like this:</p><pre><code><span>fhvhv_trips:</span>
  <span>table:</span> <span>trips_tbl</span>
  <span>time_dimension:</span> <span>pickup_datetime</span>
  <span>smallest_time_grain:</span> <span>TIME_GRAIN_SECOND</span>
  
  <span>dimensions:</span>
    <span>hvfhs_license_num:</span> <span>_.hvfhs_license_num</span>
    <span>dispatching_base_num:</span> <span>_.dispatching_base_num</span>
    <span>originating_base_num:</span> <span>_.originating_base_num</span>
    <span>request_datetime:</span> <span>_.request_datetime</span>
    <span>pickup_datetime:</span> <span>_.pickup_datetime</span>
    <span>dropoff_datetime:</span> <span>_.dropoff_datetime</span>
    <span>trip_miles:</span> <span>_.trip_miles</span>
    <span>trip_time:</span> <span>_.trip_time</span>
    <span>base_passenger_fare:</span> <span>_.base_passenger_fare</span>
    <span>tolls:</span> <span>_.tolls</span>
    <span>bcf:</span> <span>_.bcf</span>
    <span>sales_tax:</span> <span>_.sales_tax</span>
    <span>congestion_surcharge:</span> <span>_.congestion_surcharge</span>
    <span>airport_fee:</span> <span>_.airport_fee</span>
    <span>tips:</span> <span>_.tips</span>
    <span>driver_pay:</span> <span>_.driver_pay</span>
    <span>shared_request_flag:</span> <span>_.shared_request_flag</span>
    <span>shared_match_flag:</span> <span>_.shared_match_flag</span>
    <span>access_a_ride_flag:</span> <span>_.access_a_ride_flag</span>
    <span>wav_request_flag:</span> <span>_.wav_request_flag</span>
    <span>wav_match_flag:</span> <span>_.wav_match_flag</span>
</code></pre><p>The <code>pickup_datetime</code> is the time column, with the grain set to seconds, and all other columns are treated as dimensions.</p><p>The interesting part is when we set the measures, which are the calculations, that can become very complex and potentially depend on many layers of existing measures. This is how we define our measures:</p><pre><code>  <span>measures:</span>
    <span>trip_count:</span> <span>_.count()</span>
    <span>avg_trip_miles:</span> <span>_.trip_miles.mean()</span>
    <span>avg_trip_time:</span> <span>_.trip_time.mean()</span>
    <span>avg_base_fare:</span> <span>_.base_passenger_fare.mean()</span>
    <span>total_revenue:</span> <span>_.base_passenger_fare.sum()</span>
    <span>avg_tips:</span> <span>_.tips.mean()</span>
    <span>avg_driver_pay:</span> <span>_.driver_pay.mean()</span>
</code></pre><p>And some more that only aggregate flagged data, such as shared trip or wheelchair requested:</p><pre><code>    <span>shared_trip_rate:</span> <span>(_.shared_match_flag</span> <span>==</span> <span>&#39;Y&#39;</span><span>).mean()</span>
    <span>wheelchair_request_rate:</span> <span>(_.wav_request_flag</span> <span>==</span> <span>&#39;Y&#39;</span><span>).mean()</span>
</code></pre><p>To create a functional dashboard and drill down into different angles, we need <strong>dimensions</strong> that provide more context when querying data. For example, if we want to aggregate on <strong>borough</strong> in New York City, this information is not in the trips data, but in our lookup table, as we saw in the above <code>DESCRIBE</code>. Let&#39;s now join this table and use this information.</p><p>First, we define the additional dataset in the YAML as follows:</p><pre><code><span>taxi_zones:</span>
  <span>table:</span> <span>taxi_zones_tbl</span>
  <span>primary_key:</span> <span>LocationID</span>
  
  <span>dimensions:</span>
    <span>location_id:</span> <span>_.LocationID</span>
    <span>borough:</span> <span>_.Borough</span>
    <span>zone:</span> <span>_.Zone</span>
    <span>service_zone:</span> <span>_.service_zone</span>
    
  <span>measures:</span>
    <span>zone_count:</span> <span>_.count()</span>
</code></pre><p>Lastly, we need to join the two datasets. This can be specified like this - added to the <code>fhvhv_trips</code> dataset:</p><pre><code>  <span>joins:</span>
    <span>pickup_zone:</span>
      <span>model:</span> <span>taxi_zones</span>
      <span>type:</span> <span>one</span>
      <span>with:</span> <span>_.PULocationID</span>
</code></pre></section></section><section><h3 id="query-data-through-pythonibis-and-duckdb">Query Data through Python/Ibis and DuckDB</h3><p>Next, we need to set up our execution logic—which is Python code in this case—and use the translation layer Ibis to run DuckDB queries as our SQL engine locally.</p><p>I&#39;ll explain the most important steps here, but I&#39;ll skip some details—the full script you can find in <a href="https://github.com/sspaeti/semantic-layer-duckdb/blob/main/nyc_taxi.py">nyc_taxi.py</a>. First, we import Ibis and our <code>SemanticModel</code> class from Boring Semantic Layer and we define the datasets and execution engine via Ibis—again, here we use DuckDB and read the dataset directly from <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>:</p><pre><code><span>import</span> ibis
<span>from</span> boring_semantic_layer <span>import</span> SemanticModel

con = ibis.duckdb.connect(<span>&#34;:memory:&#34;</span>) 
tables = {
    <span>&#34;taxi_zones_tbl&#34;</span>: con.read_csv(<span>&#34;https://d37ci6vzurychx.cloudfront.net/misc/taxi+_zone_lookup.csv&#34;</span>),
    <span>&#34;trips_tbl&#34;</span>: con.read_parquet(<span>&#34;https://d37ci6vzurychx.cloudfront.net/trip-data/fhvhv_tripdata_2025-06.parquet&#34;</span>),
}
</code></pre><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 12C11 11.7348 11.1054 11.4804 11.2929 11.2929C11.4804 11.1054 11.7348 11 12 11H20C20.2652 11 20.5196 11.1054 20.7071 11.2929C20.8946 11.4804 21 11.7348 21 12C21 12.2652 20.8946 12.5196 20.7071 12.7071C20.5196 12.8946 20.2652 13 20 13H12C11.7348 13 11.4804 12.8946 11.2929 12.7071C11.1054 12.5196 11 12.2652 11 12ZM12 17H20C20.2652 17 20.5196 16.8946 20.7071 16.7071C20.8946 16.5196 21 16.2652 21 16C21 15.7348 20.8946 15.4804 20.7071 15.2929C20.5196 15.1054 20.2652 15 20 15H12C11.7348 15 11.4804 15.1054 11.2929 15.2929C11.1054 15.4804 11 15.7348 11 16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17ZM16 19H12C11.7348 19 11.4804 19.1054 11.2929 19.2929C11.1054 19.4804 11 19.7348 11 20C11 20.2652 11.1054 20.5196 11.2929 20.7071C11.4804 20.8946 11.7348 21 12 21H16C16.2652 21 16.5196 20.8946 16.7071 20.7071C16.8946 20.5196 17 20.2652 17 20C17 19.7348 16.8946 19.4804 16.7071 19.2929C16.5196 19.1054 16.2652 19 16 19ZM28 6V19.5863C28.0008 19.849 27.9494 20.1093 27.8488 20.352C27.7482 20.5947 27.6003 20.815 27.4137 21L21 27.4137C20.815 27.6003 20.5947 27.7482 20.352 27.8488C20.1093 27.9494 19.849 28.0008 19.5863 28H6C5.46957 28 4.96086 27.7893 4.58579 27.4142C4.21071 27.0391 4 26.5304 4 26V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H26C26.5304 4 27.0391 4.21071 27.4142 4.58579C27.7893 4.96086 28 5.46957 28 6ZM6 26H19V20C19 19.7348 19.1054 19.4804 19.2929 19.2929C19.4804 19.1054 19.7348 19 20 19H26V6H6V26ZM21 21V24.5875L24.5863 21H21Z" fill="#383838"></path></svg> <span>NOTE<!-- -->: Scale Up with MotherDuck</span></span>
With one simple change, we can use MotherDuck as the <a href="https://ibis-project.org/backends/duckdb#motherduck">Ibis query engine</a>. Instead of `con = ibis.duckdb.connect(&#34;:memory:&#34;)`, we can use `con = ibis.duckdb.connect(&#34;md:&#34;)`
</span><p>Now that we have read the metrics definition we created in the YAML <code>nyc_taxi.yml</code> file above and mapped it to the tables dataset, the boring semantic layer knows which dataset we have and can query it:</p><pre><code>models = SemanticModel.from_yaml(<span>f&#34;nyc_taxi.yml&#34;</span>, tables=tables)

taxi_zones_sm = models[<span>&#34;taxi_zones&#34;</span>] 
trips_sm = models[<span>&#34;fhvhv_trips&#34;</span>] 
</code></pre><p>And then we define our query as a Python expression with Ibis and BSL—here the <strong>trip volume by pickup borough</strong>:</p><pre><code>expr = trips_sm.query(
  dimensions=[<span>&#34;pickup_zone.borough&#34;</span>],
  measures=[<span>&#34;trip_count&#34;</span>, <span>&#34;avg_trip_miles&#34;</span>, <span>&#34;avg_base_fare&#34;</span>],
  order_by=[(<span>&#34;trip_count&#34;</span>, <span>&#34;desc&#34;</span>)],
  limit=<span>5</span>,
)
</code></pre><p>And we can execute and print it with:</p><pre><code><span>print</span>(expr.execute())
</code></pre><p>The result looks something like this:</p><pre><code>  pickup_zone_borough  trip_count  avg_trip_miles  avg_base_fare
0           Manhattan     7122571        5.296985      33.575738
1            Brooklyn     5433158        4.215820      23.280429
2              Queens     4453220        6.379047      29.778835
3               Bronx     2541614        4.400500      20.313596
4       Staten Island      316533        5.262288      22.200712
</code></pre><p>So what just happened? We defined the dimension (<code>pickup_zone.borough</code>) in which we want to display the measure, configured the three measures to be shown, and specified the order and the number of rows to return with LIMIT.</p><p>The magic is that we can now change the metric in the YAML file, add a CASE WHEN statement, or fix a formatting error all without touching the query or code. Less technical people gain access through a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (Domain Specific Language)</a> and a separate configuration file, which we can version control, collaborate on, or even utilize LLMs to create new measures and dimensions.</p><p>Ibis gives us the flexibility to do it in a Pythonic way.</p><p>Find more examples such as the popular pickup zones, service zone analysis, revenue analysis by trip distance, and accessibility metrics in the whole script <code>nyc_taxi.py</code> and yaml in <code>nyc_taxi.yml</code>.</p><span type="[object Object]"><span type="[object Object]"><svg width="22" height="22" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 12C16.5523 12 17 12.4477 17 13V18C17 18.5523 16.5523 19 16 19C15.4477 19 15 18.5523 15 18V13C15 12.4477 15.4477 12 16 12Z" fill="#383838"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M14.5013 3.40279C14.9567 3.13875 15.4737 2.99969 16 2.99969C16.5264 2.99969 17.0434 3.13875 17.4987 3.40279C17.9532 3.66638 18.3302 4.04519 18.5916 4.50099C18.592 4.50176 18.5925 4.50253 18.5929 4.50331L29.591 23.5C29.8539 23.9553 29.9925 24.4716 29.993 24.9974C29.9934 25.5231 29.8557 26.0397 29.5937 26.4954C29.3316 26.9512 28.9544 27.3301 28.4998 27.5941C28.0452 27.8582 27.5292 27.9981 27.0035 28L27 28H5.00001L4.99648 28C4.47077 27.9981 3.95477 27.8582 3.50019 27.5941C3.0456 27.3301 2.66838 26.9512 2.40633 26.4954C2.14428 26.0397 2.00658 25.5231 2.00705 24.9974C2.00752 24.4716 2.14612 23.9553 2.40898 23.5L13.4071 4.50331C13.4075 4.50253 13.408 4.50176 13.4084 4.50099C13.6698 4.04519 14.0468 3.66638 14.5013 3.40279ZM14.275 5L15.1404 5.50104L4.14103 24.5C4.14095 24.5001 4.1411 24.4999 4.14103 24.5C4.05355 24.6517 4.00721 24.824 4.00705 24.9991C4.00689 25.1744 4.05279 25.3466 4.14014 25.4985C4.2275 25.6504 4.35323 25.7767 4.50476 25.8647C4.6559 25.9525 4.8274 25.9992 5.00216 26H26.9978C27.1726 25.9992 27.3441 25.9525 27.4953 25.8647C27.6468 25.7767 27.7725 25.6504 27.8599 25.4985C27.9472 25.3466 27.9931 25.1744 27.993 24.9991C27.9928 24.8241 27.9467 24.6522 27.8593 24.5006C27.8592 24.5004 27.8594 24.5008 27.8593 24.5006L16.8571 5.49671C16.7707 5.3457 16.6459 5.22021 16.4954 5.13293C16.3449 5.04565 16.174 4.99969 16 4.99969C15.826 4.99969 15.6551 5.04565 15.5046 5.13293C15.3541 5.22021 15.2293 5.3457 15.1429 5.4967L14.275 5Z" fill="#383838"></path><path d="M16 24C16.8284 24 17.5 23.3284 17.5 22.5C17.5 21.6716 16.8284 21 16 21C15.1716 21 14.5 21.6716 14.5 22.5C14.5 23.3284 15.1716 24 16 24Z" fill="#383838"></path></svg> <span>WARNING<!-- -->: Limitations</span></span>
I <a href="https://github.com/boringdata/boring-semantic-layer/issues/32">wasn&#39;t able</a> to join the dataset twice, once for pickup and once for drop-off locations. That&#39;s why I only joined it once in this example.
</span></section><section><h3 id="materialization">Materialization</h3><p>If you wish to speed things up and create a <strong>persistent cube</strong>, the option is there with the help of <a href="https://github.com/xorq-labs/xorq">Xorq</a>—example from <a href="https://github.com/boringdata/boring-semantic-layer/blob/main/examples/example_materialize.py">example_materialize.py</a>.</p><pre><code><span>import</span> <span>pandas</span> <span>as</span> <span>pd</span>
<span>import</span> <span>xorq</span> <span>as</span> <span>xo</span>

<span>from</span> <span>boring_semantic_layer</span> <span>import</span> <span>SemanticModel</span>

<span>df</span> <span>=</span> <span>pd.DataFrame(</span>
    {
        <span>&#34;date&#34;:</span> <span>pd.date_range(&#34;2025-01-01&#34;</span>, <span>periods=5</span>, <span>freq=&#34;D&#34;)</span>,
        <span>&#34;region&#34;:</span> [<span>&#34;north&#34;</span>, <span>&#34;south&#34;</span>, <span>&#34;north&#34;</span>, <span>&#34;east&#34;</span>, <span>&#34;south&#34;</span>],
        <span>&#34;sales&#34;:</span> [<span>100</span>, <span>200</span>, <span>150</span>, <span>300</span>, <span>250</span>],
    }
<span>)</span>

<span>con</span> <span>=</span> <span>xo.connect()</span>
<span>tbl</span> <span>=</span> <span>con.create_table(&#34;sales&#34;,</span> <span>df)</span>

<span>sales_model</span> <span>=</span> <span>SemanticModel(</span>
    <span>table=tbl,</span>
    <span>dimensions={&#34;region&#34;:</span> <span>lambda t:</span> <span>t.region,</span> <span>&#34;date&#34;:</span> <span>lambda t:</span> <span>t.date},</span>
    <span>measures={</span>
        <span>&#34;total_sales&#34;:</span> <span>lambda t:</span> <span>t.sales.sum(),</span>
        <span>&#34;order_count&#34;:</span> <span>lambda t:</span> <span>t.sales.count(),</span>
    <span>},</span>
    <span>time_dimension=&#34;date&#34;,</span>
    <span>smallest_time_grain=&#34;TIME_GRAIN_DAY&#34;,</span>
<span>)</span>

<span>cube</span> <span>=</span> <span>sales_model.materialize(</span>
    <span>time_grain=&#34;TIME_GRAIN_DAY&#34;,</span>
    <span>cutoff=&#34;2025-01-04&#34;,</span>
    <span>dimensions=[&#34;region&#34;,</span> <span>&#34;date&#34;</span><span>],</span>
    <span>storage=None,</span>
<span>)</span>

<span>print(&#34;Cube</span> <span>model</span> <span>definition:&#34;,</span> <span>cube.json_definition)</span>

<span>df_cube</span> <span>=</span> <span>cube.query(</span>
    <span>dimensions=[&#34;date&#34;,</span> <span>&#34;region&#34;</span><span>],</span> <span>measures=[&#34;total_sales&#34;,</span> <span>&#34;order_count&#34;</span><span>]</span>
<span>).execute()</span>
</code></pre></section><section><h3 id="more-complex-measures">More Complex Measures</h3><p>This example is relatively simple, but showcases how you can use a simple semantic layer on top of your data lake with DuckDB.</p><p>If you need more advanced measures that are <strong>dependent on each other</strong>, you can imagine how beneficial it would be. The beauty of semantic layers lies in their ability to simply define dependencies on complex measures, eliminating the need to repeat 100 lines of SQL code in your CTE query.</p><p>Obviously, you could use dbt to manage dependencies, but you wouldn&#39;t have the ad hoc query capability, the on-the-fly filtering, or nicely defined YAML files that represent your dynamic queries.</p></section><section><h3 id="visualizing">Visualizing</h3><p>Interestingly, the BSL also includes some visualization capabilities with a built-in wrapper around <strong><a href="https://vega.github.io/vega-lite/">Vega-Lite</a></strong> (JSON-based grammar for creating interactive visualizations that provides a declarative approach to chart creation) and its Python wrapper <strong><a href="https://altair-viz.github.io/">Altair</a></strong>.</p><p>Just install with <code>uv add &#39;boring-semantic-layer[visualization]&#39; altair[all]</code> and you can create a simple visualization. This is a bit extended to create a nice-looking image, but you can imagine this being much shorter with only the title, for example:</p><pre><code>
png_bytes = expr.chart(
  <span>format</span>=<span>&#34;png&#34;</span>,  
  spec={
	<span>&#34;title&#34;</span>: {
	    <span>&#34;text&#34;</span>: <span>&#34;NYC Taxi Trip Volume by Borough&#34;</span>,
	    <span>&#34;fontSize&#34;</span>: <span>16</span>,
	    <span>&#34;fontWeight&#34;</span>: <span>&#34;bold&#34;</span>,
	    <span>&#34;anchor&#34;</span>: <span>&#34;start&#34;</span>
	},
	<span>&#34;mark&#34;</span>: {
	    <span>&#34;type&#34;</span>: <span>&#34;bar&#34;</span>,
	    <span>&#34;color&#34;</span>: <span>&#34;#2E86AB&#34;</span>,
	    <span>&#34;cornerRadiusEnd&#34;</span>: <span>4</span>
	},
	<span>&#34;encoding&#34;</span>: {
	    <span>&#34;x&#34;</span>: {
		  <span>&#34;field&#34;</span>: <span>&#34;pickup_zone_borough&#34;</span>,
		  <span>&#34;type&#34;</span>: <span>&#34;nominal&#34;</span>,
		  <span>&#34;sort&#34;</span>: <span>&#34;-y&#34;</span>,
		  <span>&#34;title&#34;</span>: <span>&#34;Borough&#34;</span>,
		  <span>&#34;axis&#34;</span>: {
			<span>&#34;labelAngle&#34;</span>: -<span>45</span>,
			<span>&#34;titleFontSize&#34;</span>: <span>12</span>,
			<span>&#34;labelFontSize&#34;</span>: <span>10</span>
		  }
	    },
	    <span>&#34;y&#34;</span>: {
		  <span>&#34;field&#34;</span>: <span>&#34;trip_count&#34;</span>,
		  <span>&#34;type&#34;</span>: <span>&#34;quantitative&#34;</span>,
		  <span>&#34;title&#34;</span>: <span>&#34;Number of Trips&#34;</span>,
		  <span>&#34;axis&#34;</span>: {
			<span>&#34;format&#34;</span>: <span>&#34;.2s&#34;</span>,
			<span>&#34;titleFontSize&#34;</span>: <span>12</span>,
			<span>&#34;labelFontSize&#34;</span>: <span>10</span>
		  }
	    }
	},
	<span>&#34;width&#34;</span>: <span>500</span>,
	<span>&#34;height&#34;</span>: <span>350</span>,
	<span>&#34;background&#34;</span>: <span>&#34;#FAFAFA&#34;</span>
  }
)


<span>with</span> <span>open</span>(<span>&#34;trip-volume-by-pickup-borough-styled.png&#34;</span>, <span>&#34;wb&#34;</span>) <span>as</span> f:
  f.write(png_bytes)

</code></pre><p>The generated PNG looks like this:
<img alt="image" loading="lazy" decoding="async" data-nimg="fill" sizes="90vw,
                        (min-width: 728px) 800px,
                        (min-width: 960px) 950px," srcset="/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=640&amp;q=75 640w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=750&amp;q=75 750w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=828&amp;q=75 828w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=3840&amp;q=75 3840w" src="https://motherduck.com/_next/image/?url=https%3A%2F%2Fmotherduck-com-web-prod.s3.amazonaws.com%2Fassets%2Fimg%2Fimg2_sem_71b5372e80.png&amp;w=3840&amp;q=75"/></p></section></section>
<section><h2 id="what-if-questions-faq">What If Questions [FAQ]</h2><p>This showed you how to implement a semantic layer with DuckDB and simple tools pragmatically. Moreover, I hope it has provided you with a better understanding of the semantic layer and its appropriate usage.</p><p>Before we wrap up, let&#39;s go through the most common questions when it comes to a semantic layer.</p><blockquote>
<p><strong>But why can&#39;t we just use a database?</strong></p>
</blockquote><p>The key is the semantic logic layer, abstracting the physical world from the modeling world. This gives you better flexibility to implement what the business wants, rather than what the physical data model can do.</p><p>Try implementing a &#39;revenue per customer by quarter with year-over-year comparison&#39; across five different BI tools using just database views—you&#39;ll most probably end up with five different implementations that drift apart over time.</p><blockquote>
<p><strong>What if we have 100s of metrics, do we need a semantic layer?</strong></p>
</blockquote><p>That&#39;s precisely when you <em>need</em> a semantic layer most. Managing 100+ metrics across multiple tools without a single unified view becomes a governance nightmare. Each tool ends up with slightly different calculations, and nobody knows which version is the correct one. A semantic layer gives you one source of truth.</p><blockquote>
<p><strong>Isn&#39;t a semantic layer adding too much complexity to the already complex data landscape?</strong></p>
</blockquote><p>Modern data stacks usually come with a handful of tools. A semantic layer most often reduces complexity in a large organization by eliminating metric duplication across those tools.</p><p>The initial setup cost pays for itself when you&#39;re not debugging why revenue numbers differ between Tableau and your web app.</p><blockquote>
<p><strong>What if my data changes frequently? Won&#39;t the semantic layer become a bottleneck for updates?</strong></p>
</blockquote><p>This is a strength of semantic layers. Unlike pre-computed aggregation tables that need to be reprocessed when source data changes, semantic layers generate queries on demand. Your metrics automatically reflect the latest data because they&#39;re calculated in real-time from the source. You only need to update the YAML definitions when business logic changes, not when data refreshes.</p><p>And it can make the process more agile than maintaining dozens of dbt models for different granularities.</p><blockquote>
<p><strong>What if I want to use MCP with it?</strong></p>
</blockquote><p>If you wish to add <a href="https://motherduck.com/blog/faster-data-pipelines-with-mcp-duckdb-ai/">Model Context Protocol (MCP)</a> with Claude Code, for example, the boring semantic layer is built out of the box with it in combination with <a href="https://github.com/xorq-labs/xorq">xorq</a>. Check out a quick showcase in this <a href="https://www.linkedin.com/posts/sven-gonschorek-16b5b0177_i-didnt-expect-connecting-a-data-warehouse-activity-7359199238884417537-En3D">LinkedIn demo</a> by Sven Gonschorek.</p><p>You can also check out the <a href="https://github.com/boringdata/boring-semantic-layer#model-context-protocol-mcp-integration">repo for further information</a> with <code>uv add &#39;boring-semantic-layer[mcp]&#39;</code>. But in this article, I focus on the semantic layer capabilities first, and the importance of using one.</p><blockquote>
<p><strong>What are other popular semantic layer tools?</strong></p>
</blockquote><p>Cube, AtScale, dbt Semantic Layer, GoodData. Some of these tools are more powerful than others; not all support enhanced security, low-level security, or powerful APIs like Excel or caching. I curate a small list of these tools at <a href="https://www.ssp.sh/brain/semantic-layer#semantic-layer-tools">Semantic Layer Tools</a>.</p><blockquote>
<p><strong>How do I use a semantic layer with MotherDuck?</strong></p>
</blockquote><p>Here are a couple of integrations that work out of the box:</p><ul>
<li>Check out the <a href="https://cube.dev/blog/introducing-duckdb-and-motherduck-integrations">integration</a> with Cube on <a href="https://cube.dev/integrations/motherduck-semantic-layer-with-cube">MotherDuck Semantic Layer with Cube</a>. There&#39;s also this <a href="https://youtu.be/z_nb-31Y30I?si=oVtuLmgq4sFckXar">webinar</a>.</li>
<li><a href="https://www.gooddata.com/blog/gooddata-and-motherduck-take-flight-together/">Boost Efficiency</a> with GoodData integration</li>
</ul></section>
<section><h2 id="conclusion">Conclusion</h2><p>I hope you enjoyed this article, which provided a practical illustration of how to use a semantic layer with DuckDB and MotherDuck.</p><p>The beauty of semantic layers lies in their empowering approach to working with metrics, complemented by advanced features, but also with a simple solution like we implemented here. With just a YAML file and a few lines of Python, we&#39;ve created a system that can serve consistent metrics across any tool in your data stack. Whether you&#39;re building dashboards, training ML models, or enabling AI assistants, your business logic stays in one place while your analytics capabilities grow everywhere else.</p><p>Start with something simple, like the Boring Semantic Layer and DuckDB, and prove the value by addressing your most painful metric inconsistencies. Then, scale from there.</p><p>Future you and your coworkers will thank you when &#34;revenue&#34; and &#34;profit&#34; mean the same thing in every tool, all the time.</p></section></div></div></div>
  </body>
</html>
