<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arnoldgalovics.com/microservices-in-production/">Original</a>
    <h1>Don&#39;t start with microservices â€“ monoliths are your friend</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Iâ€™ve been having this thought on the back of my mind for a long time to write about why itâ€™s often a bad idea to start with microservices for a brand new project.</p>



<p>The time has come, thatâ€™s exactly what Iâ€™ll talk about in this article.</p>



<p>Microservices are getting natural and we almost feel like weâ€™ve been always living in the world of microservices. Lately when I talked to other developers and asked how they would start a greenfield project, almost certainly the answer was, well, one microservice for this, another one for this, another one for user management, one more for authentication, another for authorization, one more for session management, and the list could go on.</p>



<p>Iâ€™m gonna try to shed some light on what nobody is talking about when it comes to microservices. And yeah, itâ€™s gonna be a first-hand experience from a past projects I worked on.</p>



<h2>The lie</h2>



<p>I collected some of the pros for going microservices other articles are mentioning:</p>



<ul><li>Fault isolation</li><li>Eliminating the technology lock</li><li>Easier understanding</li><li>Faster deployment</li><li>Scalability</li></ul>



<p>And yeah, these are not false promises in a book but I have to be honest with you, these are not coming easily with your system just because youâ€™re using microservices.</p>



<p>Let me break down each advantage from the list.</p>



<p><strong>Fault isolation</strong>. Since the application is consisting of multiple services, if one goes down or something happens to it, only that part of the system will be affected. Think about Netflix, when youâ€™re watching a show, you donâ€™t care about the recommendations. So if they have a service to handle current watchers and provide them with the video stream; and they have another service to handle personal user recommendations. If the recommendation service goes down, the most important functionality in their system will not be affected, i.e. watching shows. The fault is isolated.</p>



<p><strong>Eliminating the technology lock.</strong> Think about monoliths. Itâ€™s a huge application with hundreds/thousands of APIs, hundreds of database tables are being managed. The app was written in Java and the team spent the last 5 years on developing it. A fancy new language comes out which on paper brings better performance, provides better security, whatever. This could be Go/Rust, and the team wants to experiment with the language and itâ€™s tech stack. How can they do it in a monolith environment? They cannot because itâ€™s a single deployment package. You can just â€“ at least not easily â€“ switch out parts of the app to different languages. </p>



<p>While with microservices, you can use different technology stacks for different services. Service A could be written in Java, service B could be written in Go, service C could be written in <a href="https://en.wikipedia.org/wiki/Whitespace_(programming_language)" data-type="URL" data-id="https://en.wikipedia.org/wiki/Whitespace_(programming_language)" target="_blank" rel="noreferrer noopener">Whitespace</a>, if youâ€™re brave enough. ðŸ™‚</p>



<p><span><strong>Easier understanding</strong></span>. When you have multiple services responsible for a smaller fraction of the overall functionality, the service is going to be inherently smaller, hence easier to understand.</p>



<p><span><strong>Faster deployment</strong></span>. In a regular monolith system, you either deploy completely or you donâ€™t deploy at all. You have one package to be deployed and itâ€™s an all or nothing scenario. With microservices you have the chance to deploy independently, meaning that if you need to deploy an upgrade to the recommendation service (going back to the Netflix example), you can totally deploy that single service and saving up serious time.</p>



<p><strong>Scalability</strong>. My all time favorite. You can scale up your services by starting multiple instances to increase the capacity for a particular functionality. As the previous example stands, if people are looking at a lot of recommendations on Netflix, they can easily start multiple instances of the recommendation service to cope with the load. While in a monolith environment, you either scale every single part of your app up or nothing.</p>



<h2>Microservices in real life</h2>



<p>Iâ€™m gonna hit you with hard truth my friend. Iâ€™m not saying those advantages cannot be achieved but you, your project, your organization have to work really hard to make those possible.</p>



<h3>Infrastructure requirements</h3>



<p>Let me start with one of my biggest difficulties with microservices. The infrastructure footprint.</p>



<div><figure><img loading="lazy" width="1024" height="575" src="https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-1024x575.jpg" alt="" srcset="https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-1024x575.jpg 1024w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-300x168.jpg 300w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-768x431.jpg 768w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-1040x585.jpg 1040w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4-480x270.jpg 480w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Webp.net-resizeimage-4.jpg 1226w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Definitely real pic of 10 <em>r6g.16xlarge (64vCPU, 512GB RAM)</em> servers running a single login application on K8S</figcaption></figure></div>



<p>Have you ever deployed a monolith? Of course we can complicate it but in regular cases this is what youâ€™ll need for a monolith if you deploy it to the cloud. Letâ€™s take a simple online store app as an example.</p>



<ul><li>A load balancer for the app</li><li>A compute instance for running the app</li><li>A (relational) database for the app</li><li>Jenkins for CI(CD)</li><li>Kibana for log aggregation</li></ul>



<p>If youâ€™re going with a microservice:</p>



<ul><li>A Kubernetes cluster</li><li>A load balancer</li><li>Multiple compute instances for running the app and hosting the K8S cluster</li><li>One or more (relational) databases, depending on whether youâ€™re gonna go with single database per service or not</li><li>A messaging system for service-service communication, e.g. Kafka</li><li>Jenkins for CI(CD)</li><li>Kibana for log aggregation</li><li>Prometheus for monitoring</li><li>Jaeger/Zipkin for distributed tracing</li></ul>



<p>And this is just a high-level overview. This should be fairly clear. Microservices can really bring value to the table, but the question is; at what cost? </p>



<p>Even though the promises sound really good, you have more moving pieces within your architecture which naturally leads to more failure. What if your messaging system breaks? What if thereâ€™s an issue with your K8S cluster? What if Jaeger is down and you canâ€™t trace errors? What if metrics are not coming into Prometheus?</p>



<p>Initially youâ€™re going to spend more time (and money for that matter) to build and operate this complex system. </p>



<h3>Faster deployments?</h3>



<p>Iâ€™m gonna touch the first point from the advantage list; faster deployments. When you think about Netflix, Facebook, Twitter and you watch their conference talks when they describe the amount of microservices theyâ€™re running and how they can commit something to Git and within the matter of hours itâ€™ll be in production. Is it too good to be true?</p>



<p>Itâ€™s definitely achievable in my opinion but I admit Iâ€™ve never ever worked on a microservice project like this. Iâ€™m not saying itâ€™s not possible, itâ€™s just really hard to get to, both from a stability, infrastructure and cultural point of view.</p>



<p>Let me share how this usually panned out from my experience. Before even doing a single line of coding on a greenfield project, you usually start with some discovery, how the product can be transformed into a technical solution. You design the system, you design your microservices, how many of them are gonna be there, responsibilities, etc.</p>



<p>One really education project was where we did this exercise and we ended up with 80+ microservices in what, 4 months?</p>



<p>What these 80+ microservices meant in reality is that we can definitely deploy faster a single service than putting the 80+ microservices together into a monolith and deploying that, butâ€¦</p>



<p>The 80+ microservices were so excessively small that a single development unit â€“ story in the Agile world â€“ was never ever fitting into touching only one service. The system was fundamentally screwed and the promise of faster deployment was gone immediately. We were not having faster deployments but the contrary, slower ones. Much slower.</p>



<p>Plus, and Iâ€™ll reflect back to this multiple times. More moving pieces during a deployment means more potential faults. And it happened a lot of times that the infra was not stable enough and deployments randomly failed because</p>



<ul><li>Artifactory/Nexus/Docker repo was unavailable for a tiny fraction of a second when downloading/uploading packages</li><li>The Jenkins builder randomly got stuck</li></ul>



<p>Thatâ€™s just one piece of the puzzle. The product has to be decomposed into microservices. Each service should be responsible for its own thing. For example a recommendation-service in the Netflix should be responsible for giving recommendations to users.</p>



<p>Not everything is Netflix and definitely not everything is so easy to decompose into the right size and with the right responsibility. This is where DDD and bounded contexts can help but on one hand itâ€™s not that easy to practice and sometimes thereâ€™s not even enough time/openness to play with these things.</p>



<h3>The supporting culture</h3>



<p>Anyway, in my opinion the second difficulty with microservices is the organizational/project culture. What if the product (department) doesnâ€™t give a damn about the underlying system architecture? I mean shall they?</p>



<p>An example: what if you have a complex architecture with tons of microservices. The Product Owner comes in and says to the team, letâ€™s develop this entire feature. After the team analyzes the feature request, turns out itâ€™s going to touch 10-15 microservices because itâ€™s connected with a lot of other existing features. What do you do in that case?</p>



<p>You try to break it down into smaller pieces but it smells fishy because the feature doesnâ€™t make sense in pieces and it adds a lot of overhead to release it service-by-service. You certainly cannot say to the Product Owner itâ€™s going to take 3-4x time just because weâ€™re using microservices, can you?</p>



<p>How would that conversation look like?</p>



<ul><li><strong>Product Owner:</strong> Hey guys, I came up with this really great feature. Our competitors are already doing it so we gotta do it quickly. Is it possible to do it in 2 weeks?</li><li><strong>Team:</strong> Well, by the initial looks of it, yeah, we can do it. And the feature also looks to be a good idea to bring more customers. Weâ€™ll regroup and talk it through.</li><li><strong>Team:</strong> Okay, slight problem with that 2 weeks. Since weâ€™re doing microservices to be faster, we need more time to implement this thing because we have to touch 15 services, so weâ€™d need like 6 weeks to do the initial implementation.</li><li><strong>Product Owner:</strong> Initial implementation?</li><li><strong>Team:</strong> Yeah. Itâ€™s 15 services for which the communication is critical so the initial implementation wonâ€™t include error handling, resilient communication patterns, tracing for debugging purposes and other neat things. For that weâ€™ll need an extra 4 weeks.</li><li><strong>* Product Owner jumps out of the window</strong></li></ul>



<div><figure><img loading="lazy" width="480" height="264" src="https://arnoldgalovics.com/wp-content/uploads/2021/12/indignation-jump.gif" alt=""/></figure></div>



<h3>Better fault isolation</h3>



<p>This one is naturally true. If one service goes down, only that service will go down right?</p>



<p>While thatâ€™s kinda true, itâ€™s not black and white. Let me show you an imaginary architecture for Netflix â€“ and Iâ€™m going to oversimplify it:</p>



<figure><img loading="lazy" width="1024" height="571" src="https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1-1024x571.png" alt="" srcset="https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1-1024x571.png 1024w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1-300x167.png 300w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1-768x429.png 768w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1-1536x857.png 1536w, https://arnoldgalovics.com/wp-content/uploads/2021/12/Blank-diagram-1.png 1620w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Letâ€™s say the user wants to see recommendations. The request goes to the recommendation service and it queries the user data to know details about the user and the stores the recommendations in itâ€™s database (which is not on the picture) and since this is user related data, they might need to encrypt it as well.</p>



<p>Now, what happens if the data encryption service goes down? Can we still do recommendations? Not sure, because weâ€™re unable to encrypt the userâ€™s data, so naturally weâ€™ll say, hey dude, we canâ€™t give you recommendations right now, check back in 5 mins. The fault was affecting the system only until the recommendation service and it gracefully responded with the fact that itâ€™s unable to give recommendations right now.</p>



<p>But do you know how much work you have to do to gracefully handle these kind of situations? A lot.</p>



<p>Letâ€™s take another example. The user tries to log in to the system using the login service. Data encryption service is still failing and the login service is calling the analytics service to have some metrics about how many users are trying to log in within a minute timeframe and some other imaginary metrics. The analytics service though is talking to the data encryption service since this data also needs to be encrypted.</p>



<p>Now, the team who wrote the analytics service was in a rush and didnâ€™t have the time to implement proper error handling, so the issue with the data encryption service circles up to the login service. Apparently the login service has been done months ago and the service is not prepared for handling the underlying error from the analytics service so user logins will be simply rejected even though the non-critical analytics service failed.</p>



<p>And I know what you think. Yeah, the team who implemented the login service was irresponsible for not preparing it for this case but what if they thought the analytics service will handle this gracefully? That was written down in the API contract of the analytics service yet it doesnâ€™t work that way.</p>



<p>So what happens when youâ€™re in a monolith app? A service crashing doesnâ€™t really have a meaning in that context, but assume that for some reason the database table thatâ€™s connected to data encryption is inaccessible. </p>



<p>In that case, the error handling will be simple because the only thing you need to prepare for is an exception. Although before praising monoliths too much, thereâ€™s the downside, if the monolith goes down, nothing works. So itâ€™s a balance question, but ask yourself. Is it easier to implement a try-catch block or to handle a synchronous HTTP call/async messaging error?</p>



<p>I remember it was an enourmous to standardize error handling with the 80+ microservices and it took months for a team to finish it. And that didnâ€™t even mean introducing error handling everywhere but just rewriting existing errors to a custom library we used so we can reduce the tedious work required for future error handling scenarios. </p>



<h2>Takeaway</h2>



<p>Iâ€™m not finished. See you in chapter 2.</p>



<p>P.S. follow me on <a href="https://www.facebook.com/arnold.galovics.engineer" data-type="URL" data-id="https://www.facebook.com/arnold.galovics.engineer" target="_blank" rel="noreferrer noopener">Facebook</a>/<a href="https://twitter.com/arnoldgalovics" data-type="URL" data-id="https://twitter.com/arnoldgalovics" target="_blank" rel="noreferrer noopener">Twitter</a> if you feel like.</p>



<div><figure><img loading="lazy" src="https://arnoldgalovics.com/wp-content/uploads/2021/12/775d89db9c8ffcd8589f3acdf37d0e323f-25-this-is-fine-lede-new.rhorizontal.w1200-e1639241817929.jpg" alt="" width="684" height="326" srcset="https://arnoldgalovics.com/wp-content/uploads/2021/12/775d89db9c8ffcd8589f3acdf37d0e323f-25-this-is-fine-lede-new.rhorizontal.w1200-e1639241817929.jpg 912w, https://arnoldgalovics.com/wp-content/uploads/2021/12/775d89db9c8ffcd8589f3acdf37d0e323f-25-this-is-fine-lede-new.rhorizontal.w1200-e1639241817929-300x143.jpg 300w, https://arnoldgalovics.com/wp-content/uploads/2021/12/775d89db9c8ffcd8589f3acdf37d0e323f-25-this-is-fine-lede-new.rhorizontal.w1200-e1639241817929-768x366.jpg 768w" sizes="(max-width: 684px) 100vw, 684px"/><figcaption>Sitting on a production incident call with 80+ microservices. Not a true story.</figcaption></figure></div>
</div></div>
  </body>
</html>
