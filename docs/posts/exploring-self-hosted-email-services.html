<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://synergeticlabs.com/email-alchemy/">Original</a>
    <h1>Exploring Self-Hosted Email Services</h1>
    
    <div id="readability-page-1" class="page"><div>
        <main>
            
<p><code>
<em>&#34;Email: Did that professionally years ago and would rather swallow live scorpions.&#34; -- /u/fliberdygibits</em>
</code>
</p>
<p>Very few technologies have persisted near to their original form as much as email services over time on the internet. It has been over 50 years since Ray decided to use the at symbol to designate a user and destination for electronic mail<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. And while it has a few different skins, the fundamental concept and protocols remain largely unchanged to this day.</p>
<p>Given the lack of underlying evolution of email services, combined with the growth of ecosystems, there has been a dramatic shift to a seemingly monopolistic dominance of email services by Google, Microsoft and Apple (via Gmail, M365 and iCloud respectively). One major advantage enjoyed by users of the users of large providers is their price (free) and accessibility from anywhere (web and mobile applications). Combined with enhanced security capabilities and good spam mitigation, it’s completely understandable why we don’t really spend time thinking about non-mainstream email capabilities.</p>
<p>The scale of the larger operators is difficult to estimate, but it’s very safe to say that Google, Microsoft and Apple are responsible for the majority of email services online. As of March 2020, Google had 2 billion MAU alone<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>While Google and others provide easy access to email, it comes at a cost for other providers - to ensure safe delivery and reduction of spam across large user bases, the bar has been raised, and continues to be raised<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> to successfully deliver email into each ecosystem.</p>
<p>Having recently had a small side project which required email capabilities whilst simultaneously wishing to avoid adopting any specific ecosystem, I set about building a self-hosted email solution.</p>
<p>I am a strong believer that very few problems that I face in life are unique, so I turned to the good folk at /r/selfhosted<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> to find prior art relating to self-hosted email. What I found across dozens of threads relating to email capabilities was a mass of confusion, ad-hoc solutions, dodgy recommendations, delivery nightmares and general complexities intertwined with people who have successfully self-hosted mail for years without issue.</p>
<p>In short - mail hosting looked like a bit of a mess<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<p>The former systems administrator in me ended up wondering was it as hard as some on the subreddit asserted? Was it as easy as others suggest? Or does it land somewhere inbetween?</p>
<p>For the remainder of this essay, I will explore the basic design, build and deployment of Mail Transfer Agent (MTA) and Mail Delivery Agent (MDA) capabilities to host an informal email solution for a non-enterprise project.</p>
<div>
<h3><i></i>  Scope</h3> 
<p><em>Build a self-hosted email server that provides mail services which can reliably deliver emails to the major providers (Gmail, Proton, iCloud, M365) without being canned like spam.</em></p>
</div>
<p>This simple scope is where I began. I must confess that given the informal nature of the project, I didn’t put a lot of forethought into the challenge but was smart enough to pencil the following objectives in a scratch file. In short, the solution should:</p>
<ul>
<li>Pass spam filters when delivering email to major service providers.</li>
<li>Support popular Mail User Agents (MUAs).</li>
<li>Use open source software and protocols where it makes sense.</li>
<li>Be price accessible to the majority of the /r/selfhosted community - less than a cup of coffee per month.</li>
<li>Provide basic anti-spam capabilities.</li>
<li>Leverage Operating System hardening capabilities.</li>
</ul>
<p>Given a list of what’s in scope, one can assume there was plenty considered out of scope. Out of scope items generally encompassed more modern, MUA-implemented features which one will find as a Gmail or Proton user. This includes send-later functionality, AI assisted drafting functionality, native calendar integrations and contacts management. Throughout the project I have also made ad-hoc decisions such as dropping support for legacy protocols (POP3) where it makes sense, but these were not always a deliberate design decision until later. I have also left out of scope building the secondary mail configuration (the secondary mx host in event of primary failure). Finally, I have de-scoped some more advanced tasks such as multi-factor authentication because this is best applied for web MUAs.</p>
<p>With the scope pencilled, there was then the matter of objectives. What was it going to take to get working email services up and running?  These included:</p>
<ul>
<li>Stability.</li>
<li>Hosting.</li>
<li>Operating System.</li>
<li>Security.</li>
</ul>
<p>30 years of being online has taught me that the internet is an incredibly unreliable place<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p>
<p>Networks fail. Hard drives fail. Databases drop. Fishing vessels catch undersea cables. Earthquakes buckle racks. Certain governments have been known to just ‘turn it off’. Solar flares flip bits. Hackers hack. Data centres catch fire. Squirrels take out grids. BGP goes boom.</p>
<p>This is far from an exhaustive list, but illustrates that we must be prepared to engineer around a variety of issues.</p>
<p>To be successful, the solution needs to be reproducible and redeployable in the event of an incident, so I decided to automate it with Ansible. Ansible is a powerful configuration management tool which enables solution as code. If you are unfamiliar with Ansible I recommend reading Jeff Geerling’s fantastic book <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>. There also exists a number pre-existing Ansible projects in the public domain that deal with building a self hosted email server and anyone looking into a solution should consider using well rounded projects such as Mail-in-a-box<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. But for this exercise, I wanted to really understand what it takes and learn some Ansible along the way.</p>
<p>To support recovery, I would deploy with a previously tried and proven backup solution leveraging BorgBackup, an absolutely amazing bit of open source deduplication backup software.</p>
<p>With my sleeves rolled up and looking for a system administration fight, I had two main remaining questions before getting started:</p>
<ul>
<li><em>Where to host the services?</em></li>
<li><em>On what Operating System?</em></li>
</ul>
<p>The first of these questions - hosting - turned into an interesting problem statement.</p>
<p>Over the years, as the adoption of email grew, so did the amount of spam. Like all significant issues with exponential growth, this caught the eye of governments with the hope of regulating themselves out of a technological problem. Politicians hate getting spam.</p>
<p>The US government was no exception and ended up with the creatively named <em>Controlling the Assault of Non-Solicited Pornography And Marketing Act</em><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> or CAN-SPAM for short. This rolls-off-the-tongue act outlines a large number of provisions which discourage situations where unsolicited spam goes unchecked. Whilst the act doesn’t explicitly put restraints or regulations on cloud providers, it has created an environment where providers are now extremely cautious to be associated with spam in any way, shape or form.</p>
<p>The net result of this environment is that many cloud providers (including Google, Amazon, DigitalOcean and Linode) deny TCP/25 for ingress, egress or both by default. While you can appeal and request explicit enablement of these services, that is becoming harder and harder and aimed at business users, not individuals or hobbyists.</p>
<p>It is with caution then, one must select their cloud provider to host email services (if not hosting via a dedicated server or hardware under your control). While I found a number of providers who would, upon request, open port 25 for me, very few meet the objective of being price accessible (that is to say - not stealing more than a cup of coffee per month from the good folk of <em>/r/selfhosted</em>).</p>
<p>It was with some trepidation, but out of necessity, I ended up on OVH VPS services who do allow TCP/25 (ingress and egress) by default. The VPS includes a single CPU vCore, 2 GB of Ram and 20GB of SSD disk which should be enough for our needs. All for $5 per month. Perfect.</p>
<p>My trepidation did not only sit with the fact that they have previously had Data Centres catch fire<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>, or in the fact that much of their address space is tagged as untrustworthy a lot of the time, but more in the fact this meant I didn’t truly understand how the data is handled, or accessed, at rest. Nor could I find an immediate answer to our questions.</p>
<p>Cloud is many things and marketed in many different ways but at its essence, you are renting a computer from someone else. Without a good understanding of that computer, you can never really trust where your data is and how it is handled.</p>
<div>
<h3><i></i>  Data at Rest</h3> 
<p><em>Data at Rest matters. If you do not know how your data is handled (encrypted) when sitting on disk, then you may not fully understand the risk of disclosure of that data.</em></p><p><em>
<p>Given I am unsure how OVH will handle my data at rest, I have not used this solution for any personal data I considered ‘sensitive’.</p>
</em></p><p><em>For the purposes of essaying entertainment and on the assumption I am not hosting anything particularly sensitive, I continue on this adventure but please stay aware of the risks if you undertake your own email server build.
</em></p>
</div>
<p>Having buried my trepidation in the backyard, I moved onto the second question.</p>
<p>What Operating System?</p>
<p>In technology there exists a few persisting religious wars. Editor of choice and Unix distribution of choice. For this project I considered FreeBSD, OpenBSD, NetBSD, Debian Linux and Fedora Linux. My work history has afforded me production experience in all of the above, but to ensure successful hosting on OVH, I narrowed it down to Debian and Fedora. Both have massive communities of support, are battle tested in some of the toughest environments in the world and are accessible to hobbyists.</p>
<p>While I love Debian, I chose Fedora as the workhorse of choice for this project. I did so for two key reasons:</p>
<ol>
<li>
<p>Prior experience has taught me that there is significant complexity in inter-process communications between the various components of mail services. Applying hardening across these multi-threaded processes while dropping privileges can sometimes be challenging with the likes of AppArmor.</p>
</li>
<li>
<p>Package and release management - Personal preference has me wanting faster release cycles for non-critical projects. I believe Fedora (and Ubuntu LTS etc) is reasonably stable unless you are running critical projects. Living on the edge is fine for this project.</p>
</li>
</ol>
<div>
<h3><i></i>  On Debian</h3> 
<p><em>While my decision is Fedora, before publishing this paper I did take the time to test the general approach on Debian with minor changes (such as packages installed by Ansible) and it all worked fine.</em></p>
</div>

<p><code>
<em>&#34;I&#39;d rather eat broken glass than manage my own email server again.&#34; -- /u/ithakaa</em>
</code>
</p>
<p>Reliable mail transport and delivery is a complex problem. The protocols in use are ageing and in some respects have struggled to keep up with the evolution (volume) of other modern internet services.</p>
<p>To simplify the complexity and improve reliability, message handling is split into two key areas: mail transfer (transporting messages) and mail delivery (shoving messages in the user’s inbox).</p>
<p>Mail Transfer Agents (MTAs) are responsible for interfacing with other email servers (along  with message submissions from users). Whether sending or receiving email, the MTA orchestrates the various tasks required to do the job. These tasks include routing, queue management, spam detection, security filtering and bouncing messages. On the surface all seemingly simple tasks but in the real world success relies on layers of complexity having been introduced over time across large code bases.</p>
<p>Universally, the transfer of messages between systems is done over the Simple Mail Transport Protocol (SMTP). This ageing protocol is somehow still responsible for the delivery of email between systems online and given the lack of reliable (and widely adoptable) alternatives, it remains king in the world of electronic mail. The most significant change to SMTP in the last 20 years has been the addition of Transport Layer Security (TLS) support.</p>
<p>A number of free and open source MTAs are available for system operators including Postfix, Exim, QMail and OpenSMTPD. Each comes with their own limitations, quirks and security history. Given SMTPs length of service, there are plenty of MTAs around to choose from.</p>
<p>When making the decision on which MTA to use, I examined the following key attributes:</p>
<ul>
<li>Security features and history.</li>
<li>Performance (given our low resource VPS).</li>
<li>Ease of automation with ansible (plain-text configuration files).</li>
<li>Support for virtual users for maximum flexibility over time.</li>
<li>MDA interoperability.</li>
<li>Reputation and history.</li>
<li>Native packaging on Fedora.</li>
</ul>
<p>Based on this very fast and loose list, I ended up selecting Postfix<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> for the MTA. It’s free and open source. It’s packaged natively. It has a long history of production deployments. It has a strong history with security. It is actively supported. Everything I could ask for to meet the needs of this project.</p>
<p>While the MTA is responsible for the sending and receiving of email, the Mail Delivery Agent (MDA) is very much obsessed with the delivery of an email message to the end user. Beyond that, the MDA is responsible for other important tasks such as mailbox management (folders) and email filtering (rules). It implements protocols such as IMAP and POP3 for the clients to access their messages.</p>
<p>Similarly to MTAs, there are a number of free and open source MDAs available for you to choose from when building the service. These include Dovecot, Courier Maildrop and Cyrus IMAP Server. Key attributes I looked at during MDA selection largely matched the MTA requirements - with one exception: its interoperability with MTAs. This led to the (almost obvious) decision to leverage Dovecot<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup> as the MDA.</p>
<p>It turns out, I was not alone in this decision and the Postfix / Dovecot combo is a popular one. This gave me a nice warm fuzzy feeling as I pushed on with this seemingly simple task. There should be no major issues using natively packaged versions, have them interact with each other and do so on limited resources VPS. Furthermore, I should be able to secure them accordingly. As we see below, these assumptions turned out to be accurate.</p>
<p>For the purposes of our configuration, we want Virtual Mail (vmail) users. Traditional Unix MTAs expect the target mail user to be an actual user on that system. Time moves slow in Unixland, and by default even Postfix on Fedora will expect a local user to deliver to.</p>
<p>We don’t want to create a full Operating System user for mail access only (for a variety of reasons including security), so instead we will create a MariaDB database which defines our virtual users for mail services to consume.</p>
<p>With the high level design made, we ended up with the following initial stack:</p>
<ul>
<li>Fedora Server 38.</li>
<li>MariaDB (for vmail functionality).</li>
<li>Postfix (as the MTA).</li>
<li>Dovecot (as the MDA).</li>
</ul>
<p>And the next steps looked something like:</p>
<ul>
<li>Configure the base OS and networking.</li>
<li>Install and configure a database for vmail.</li>
<li>Use Let’s Encrypt to create some certificates for TLS services.</li>
<li>Install and configure Dovecot.</li>
<li>Install and configure Postfix.</li>
</ul>
<p>The overall installation, configuration and use of Ansible is out of scope of this work, however. I have provided an example Ansible project<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup> as a starting point for those working on their own server.</p>
<p>To get started, I wanted a robust foundation for the mail server installation. To achieve this, I created a basic ansible role (<code>base_os</code>) which does the following:</p>
<ul>
<li>Install and configure FirewallD (SSH, Mosh).</li>
<li>Install a set of baseline packages (non-mail related).</li>
<li>Set the root password.</li>
<li>Create any initial users,  set their passwords and write their SSH keys.</li>
<li>Delete OVH cloud-init SSH configuration override.</li>
<li>Configure operating system backups with borg.</li>
<li>Set the timezone.</li>
<li>Ensure all other packages are up to date.</li>
</ul>
<p>For the purposes of the example Ansible (and examples below), the domain is iris.com, operating mail on mx.iris.com<sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup>.</p>
<p>With the base installation done, it was time to get started on the mail specific services. Often, people will start with the MTA followed by the MDA for installation. This makes sense in many cases.</p>
<p>I took a slightly different approach, this is because I wanted Dovecot to act as the authentication provider for users. We achieve this by leveraging the Simple Authentication and Security Layer (SASL) framework. SASL will take care of authenticating users accordingly.</p>
<p>If we walk the dependency chain for installation there are a few prerequisites for Dovecot to work:</p>
<ul>
<li>The vmail structure.</li>
<li>The database.</li>
<li>SSL certificates for listening services (IMAPs).</li>
</ul>
<p>To cover all the tasks, I created a new role (<code>mailserver</code>) in Ansible which is available in the example repoistory.</p>
<p>The mailserver task incorporates subtasks for each of the mail components needed in order for the mailserver to work.</p>
<p><code>tasks/main.yml</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>---</span> 
</span></span><span><span>- <span>include_tasks</span>: packages.yml
</span></span><span><span>- <span>include_tasks</span>: vmail-user.yml
</span></span><span><span>- <span>include_tasks</span>: firewall.yml
</span></span><span><span>- <span>include_tasks</span>: letsencrypt.yml
</span></span><span><span>- <span>include_tasks</span>: database.yml
</span></span><span><span>- <span>include_tasks</span>: dovecot.yml
</span></span><span><span>- <span>include_tasks</span>: postfix.yml</span></span></code></pre></div>
</div>
<p>As you can see, it configures mail packages, sets up vmail, configures the firewall for immediate effect, creates TLS certificates, creates the database and then configures the Postfix / Dovecot combination.</p>
<p>The `tasks/packages,yml`` task ensures all required packages are installed.</p>
<p>Once packages are installed, it configures the vmail configuration. Whilst the server won’t have a user account for each user on the OS itself, it will still need to store their mail on disk (in the Maildir format). This is done under <code>/var/vmail</code>. The <code>vmail.yml</code> tasks file creates a vmail user (to reduce requirements for privileged users running processes) and ensures the <code>/var/vmail</code> is appropriately created:</p>
<p><code>tasks/vmail.yml</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>---</span> 
</span></span><span><span><span># Ensure user / group are created. </span>
</span></span><span><span>- <span>name</span>: Add Vmail Group 
</span></span><span><span>  <span>group</span>: 
</span></span><span><span>    <span>name</span>: vmail 
</span></span><span><span>    <span>gid</span>: <span>5000</span> 
</span></span><span><span>    <span>system</span>: <span>yes</span> 
</span></span><span><span>    <span>state</span>: present
</span></span><span><span>
</span></span><span><span>- <span>name</span>: Add Vmail User 
</span></span><span><span>  <span>user</span>: 
</span></span><span><span>    <span>name</span>: vmail 
</span></span><span><span>    <span>uid</span>: <span>5000</span> 
</span></span><span><span>    <span>group</span>: vmail 
</span></span><span><span>    <span>shell</span>: /usr/sbin/nologin 
</span></span><span><span>    <span>system</span>: <span>yes</span> 
</span></span><span><span>    <span>state</span>: present
</span></span><span><span>
</span></span><span><span><span># Create /var/vmail and assign ownership to vmail user / group.</span>
</span></span><span><span>- <span>name</span>: Create /var/vmail
</span></span><span><span>  <span>ansible.builtin.file</span>: 
</span></span><span><span>    <span>path</span>: /var/vmail 
</span></span><span><span>    <span>owner</span>: vmail 
</span></span><span><span>    <span>group</span>: vmail 
</span></span><span><span>    <span>mode</span>: <span>&#39;0770&#39;</span> 
</span></span><span><span>    <span>state</span>: directory</span></span></code></pre></div>
</div>
<p>Next, it ensures FirewallD (the firewall manager for Fedora) enables the following ports with immediate effect:</p>
<table>
<thead>
<tr>
<th>Port</th>
<th>Purpose</th>
<th>Service</th>
</tr>
</thead>
<tbody>
<tr>
<td>25/TCP</td>
<td>SMTP(s) for receiving email for users.</td>
<td>Postfix</td>
</tr>
<tr>
<td>80/TCP</td>
<td>Let’s Encrypt HTTP challenge.</td>
<td>Certbot</td>
</tr>
<tr>
<td>465/TCP</td>
<td>TLS based email submission by users.</td>
<td>Postfix</td>
</tr>
<tr>
<td>993/TCP</td>
<td>IMAPS (IMAP over TLS).</td>
<td>Dovecot</td>
</tr>
</tbody>
</table>
<p>Let’s Encrypt<sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup> is a free, automated and open certificate authority (CA). Previously, securing services with TLS / SSL was in some ways prohibitive due to the cost involved in obtaining a TLS certificate for your website or service. Let’s Encrypt is a public service that removes this limitation and enables any service to ensure robust, secure communications by ensuring a complete certificate chain on most major operating systems.</p>
<p>As outlined in the above table, there are three key services to secure with Transport Layer Security - SMTP with STARTTLS, email Submissions and IMAP access.</p>
<p>The <code>letsencrypt.yml</code> uses the Let’s Encrypt provided certbot utility to request a new certificate for <code>mx.iris.com</code> (as defined in the ansible vars) and complete the host / response (verification) challenge over HTTP.</p>
<p><code>tasks/letsencrypt.yml</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>---</span>
</span></span><span><span>- <span>name</span>: Generate certificate for host alias 
</span></span><span><span>  <span>ansible.builtin.shell</span>: 
</span></span><span><span>    <span>cmd</span>: <span>&#34;certbot certonly --standalone --non-interactive --agree-tos --no-eff-email --email {{ certbot_email }} --domains {{ mailserver_alias }}&#34;</span> 
</span></span><span><span>    <span>creates</span>: <span>&#34;/etc/letsencrypt/live/{{ mailserver_alias }}/fullchain.pem&#34;</span></span></span></code></pre></div>
</div>
<p>Next, there is a requirement to create the mailserver database and populate the tables with some initial data. The database task I wrote for this is a little more complex than the others in the mailserver role. In summary, it performs the following:</p>
<ol>
<li>Create the database mailserver.</li>
<li>Create a database user and associated password for the mailserver database.</li>
<li>Create 3 database tables in mailserver - <code>domains</code>, <code>users</code> and <code>aliases</code>.</li>
<li>For each domain defined in the <code>vars/mailserver.yml</code> file, create a domains table entry.</li>
<li>For each test user defined in the <code>vars/mailserver.yml</code>:
<ul>
<li>Look up their initial password from the ansible vault and hash it.</li>
<li>Insert test user into the users table.</li>
</ul>
</li>
<li>For each alias defined in the mailserver.yml, create the aliases table entry.</li>
<li>Finally, we’re going to ensure database backups occur at 3am every day.</li>
</ol>
<p>The tasks file also relies on some additional data read from the <code>vars/mailserver.yml</code> file. This file defines 3 key items:</p>
<ul>
<li>The domains we are going to host.</li>
<li>The test users.</li>
<li>Any user aliases to add.</li>
</ul>
<p>If using the example Ansible repository, you’ll want to edit that first.</p>
<p><code>vars/mailserver.yml</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>---</span> 
</span></span><span><span><span>domains_to_add</span>: 
</span></span><span><span>  - { <span>domain</span>: <span>&#39;iris.com }
</span></span></span><span><span><span>  
</span></span></span><span><span><span>users_to_add:
</span></span></span><span><span><span>  - { domain: &#39;</span><span>iris.com&#39;, email: &#39;user@iris.com&#39;, password</span>: <span>&#39;{{ user_mail_password }}&#39;</span> }
</span></span><span><span>
</span></span><span><span><span>aliases_to_add</span>: 
</span></span><span><span>  - { <span>domain: &#39;iris.com&#39;, source: &#39;root@iris.com&#39;, destinations</span>: <span>&#39;user@iris.com&#39;</span> }
</span></span><span><span>  - { <span>domain: &#39;iris.com&#39;, source: &#39;postmaster@iris.com&#39;, destinations</span>: <span>&#39;user@iris.com&#39;</span> }</span></span></code></pre></div>
</div>
<p><code>tasks/database.yml</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>---</span> 
</span></span><span><span>- <span>include_vars</span>: mailserver.yml
</span></span><span><span>
</span></span><span><span><span># Ensure MariaDB is running. </span>
</span></span><span><span>- <span>name</span>: Ensure MariaDB Is Running 
</span></span><span><span>  <span>ansible.builtin.service</span>: 
</span></span><span><span>    <span>name</span>: mariadb 
</span></span><span><span>    <span>state</span>: started 
</span></span><span><span>    <span>enabled</span>: <span>true</span>
</span></span><span><span>
</span></span><span><span><span># Create the Database.</span>
</span></span><span><span>- <span>name</span>: Setup the mail database 
</span></span><span><span>  <span>ansible.builtin.mysql_db</span>:
</span></span><span><span>    <span>name</span>: mailserver 
</span></span><span><span>    <span>state</span>: present
</span></span><span><span>
</span></span><span><span><span># Create a user for Postfix / Dovecot to use. </span>
</span></span><span><span>- <span>name</span>: Create mail user for the database 
</span></span><span><span>  <span>ansible.builtin.mysql_user</span>: 
</span></span><span><span>    <span>name</span>: mailserver 
</span></span><span><span>    <span>password</span>: <span>&#34;{{ mailserver_password }}&#34;</span> 
</span></span><span><span>    <span>priv</span>: <span>&#34;mailserver.*:ALL&#34;</span> 
</span></span><span><span>    <span>host</span>: localhost 
</span></span><span><span>    <span>state</span>: present
</span></span><span><span>
</span></span><span><span><span># Create 3 tables: </span>
</span></span><span><span><span># - Domains (id, name)</span>
</span></span><span><span><span># - Users (id, domain_id, password, email)</span>
</span></span><span><span><span># - Aliases (id, domain_id, source, destinations)</span>
</span></span><span><span>- <span>name</span>: Create tables
</span></span><span><span>  <span>ansible.builtin.mysql_query</span>:
</span></span><span><span>    <span>login_user</span>: mailserver
</span></span><span><span>    <span>login_password</span>: <span>&#34;{{ mailserver_password }}&#34;</span>
</span></span><span><span>    <span>login_db</span>: mailserver
</span></span><span><span>    <span>query</span>: 
</span></span><span><span>    - <span>&#34;CREATE TABLE IF NOT EXISTS domains (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL UNIQUE);&#34;</span>
</span></span><span><span>    - <span>&#34;CREATE TABLE IF NOT EXISTS users (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, domain_id INT NOT NULL, password VARCHAR(106) NOT NULL, email VARCHAR(120) NOT NULL UNIQUE, FOREIGN KEY (domain_id) REFERENCES domains(id) ON DELETE CASCADE);&#34;</span>
</span></span><span><span>    - <span>&#34;CREATE TABLE IF NOT EXISTS aliases (id INT(11) PRIMARY KEY AUTO_INCREMENT, domain_id INT(11) NOT NULL, source VARCHAR(120) NOT NULL UNIQUE, destinations VARCHAR(255) NOT NULL, FOREIGN KEY (domain_id) REFERENCES domains(id) );&#34;</span>
</span></span><span><span>    <span>single_transaction</span>: <span>true</span> 
</span></span><span><span>
</span></span><span><span><span># For each of our domains, add them to the database.</span>
</span></span><span><span>- <span>name</span>: Add domains to the database 
</span></span><span><span>  <span>ansible.builtin.mysql_query</span>: 
</span></span><span><span>    <span>login_user</span>: mailserver
</span></span><span><span>    <span>login_password</span>: <span>&#34;{{ mailserver_password }}&#34;</span>
</span></span><span><span>    <span>login_db</span>: mailserver
</span></span><span><span>    <span>query</span>: &gt;<span>
</span></span></span><span><span><span>      INSERT INTO domains (name)
</span></span></span><span><span><span>      SELECT &#39;{{ item.domain }}&#39;
</span></span></span><span><span><span>      WHERE NOT EXISTS (SELECT * FROM domains WHERE name = &#39;{{ item.domain }}&#39;);</span>      
</span></span><span><span>  <span>loop</span>: <span>&#34;{{ domains_to_add }}&#34;</span>
</span></span><span><span>
</span></span><span><span><span># For each of our users, generate a password hash and add them to the database.</span>
</span></span><span><span>- <span>name</span>: generate BLF password hashes
</span></span><span><span>  <span>command</span>: doveadm pw -s BLF-CRYPT -p &#34;{{ item.password }}&#34;
</span></span><span><span>  <span>register</span>: hashed_passwords 
</span></span><span><span>  <span>loop</span>: <span>&#34;{{ users_to_add }}&#34;</span>
</span></span><span><span>  <span>no_log</span>: <span>true</span>
</span></span><span><span>
</span></span><span><span>- <span>name</span>: Insert user into the database with the hashed password 
</span></span><span><span>  <span>ansible.builtin.mysql_query</span>: 
</span></span><span><span>    <span>login_user</span>: mailserver
</span></span><span><span>    <span>login_password</span>: <span>&#34;{{ mailserver_password }}&#34;</span>
</span></span><span><span>    <span>login_db</span>: mailserver
</span></span><span><span>    <span>query</span>: &gt;<span>
</span></span></span><span><span><span>      INSERT IGNORE INTO users (domain_id, password, email)
</span></span></span><span><span><span>      SELECT domains.id, &#39;{{ item.1.stdout }}&#39;, &#39;{{ item.0.email }}&#39;
</span></span></span><span><span><span>      FROM domains
</span></span></span><span><span><span>      WHERE domains.name = &#39;{{ item.0.domain }}&#39;;</span>      
</span></span><span><span>  <span>loop</span>: <span>&#34;{{ users_to_add | zip(hashed_passwords.results) }}&#34;</span>
</span></span><span><span>  <span>no_log</span>: <span>true</span>
</span></span><span><span>
</span></span><span><span><span># For each alias, add them to the database.</span>
</span></span><span><span>- <span>name</span>: Add aliases to the database 
</span></span><span><span>  <span>ansible.builtin.mysql_query</span>: 
</span></span><span><span>    <span>login_user</span>: mailserver
</span></span><span><span>    <span>login_password</span>: <span>&#34;{{ mailserver_password }}&#34;</span>
</span></span><span><span>    <span>login_db</span>: mailserver
</span></span><span><span>    <span>query</span>: &gt;<span>
</span></span></span><span><span><span>      INSERT IGNORE INTO aliases (domain_id, source, destinations)
</span></span></span><span><span><span>      SELECT domains.id, &#39;{{ item.source }}&#39;, &#39;{{ item.destinations }}&#39;
</span></span></span><span><span><span>      FROM domains
</span></span></span><span><span><span>      WHERE domains.name = &#39;{{ item.domain }}&#39;;</span>      
</span></span><span><span>  <span>loop</span>: <span>&#34;{{ aliases_to_add }}&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Ensure backups</span>
</span></span><span><span>- <span>name</span>: Create database backup script 
</span></span><span><span>  <span>ansible.builtin.template</span>: 
</span></span><span><span>    <span>src</span>: mysql-backup-sh.j2
</span></span><span><span>    <span>dest</span>: /usr/local/sbin/mysql-backup.sh
</span></span><span><span>    <span>owner</span>: root
</span></span><span><span>    <span>group</span>: root
</span></span><span><span>    <span>mode</span>: <span>&#39;0750&#39;</span>
</span></span><span><span>
</span></span><span><span>- <span>name</span>: Schedule database backup daily at 3am
</span></span><span><span>  <span>ansible.builtin.cron</span>: 
</span></span><span><span>    <span>name</span>: <span>&#34;MySQL Backup&#34;</span> 
</span></span><span><span>    <span>minute</span>: <span>0</span>
</span></span><span><span>    <span>hour</span>: <span>3</span>
</span></span><span><span>    <span>job</span>: <span>&#34;/usr/local/sbin/mysql-backup.sh&#34;</span>
</span></span><span><span>    <span>user</span>: root</span></span></code></pre></div>
</div>
<p>After successful execution the database mailserver now exists with the following tables:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# mysql
</span></span><span><span>Welcome to the MariaDB monitor.  Commands end with ; or \g.
</span></span><span><span>Your MariaDB connection id is 1895
</span></span><span><span>Server version: 10.5.22-MariaDB MariaDB Server
</span></span><span><span><span>
</span></span></span><span><span><span></span>Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.
</span></span><span><span><span>
</span></span></span><span><span><span></span>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
</span></span><span><span><span>
</span></span></span><span><span><span></span>MariaDB [(none)]&gt; use mailserver;
</span></span><span><span>Reading table information for completion of table and column names
</span></span><span><span>You can turn off this feature to get a quicker startup with -A
</span></span><span><span><span>
</span></span></span><span><span><span></span>Database changed
</span></span><span><span>MariaDB [mailserver]&gt; show tables;
</span></span><span><span>+----------------------+
</span></span><span><span>| Tables_in_mailserver |
</span></span><span><span>+----------------------+
</span></span><span><span>| aliases              |
</span></span><span><span>| domains              |
</span></span><span><span>| users                |
</span></span><span><span>+----------------------+
</span></span><span><span>3 rows in set (0.000 sec)
</span></span><span><span><span>
</span></span></span><span><span><span></span>MariaDB [mailserver]&gt; describe domains;
</span></span><span><span>+-------+-------------+------+-----+---------+----------------+
</span></span><span><span>| Field | Type        | Null | Key | Default | Extra          |
</span></span><span><span>+-------+-------------+------+-----+---------+----------------+
</span></span><span><span>| id    | int(11)     | NO   | PRI | NULL    | auto_increment |
</span></span><span><span>| name  | varchar(50) | NO   | UNI | NULL    |                |
</span></span><span><span>+-------+-------------+------+-----+---------+----------------+
</span></span><span><span>2 rows in set (0.001 sec)
</span></span><span><span><span>
</span></span></span><span><span><span></span>MariaDB [mailserver]&gt; describe users;
</span></span><span><span>+-----------+--------------+------+-----+---------+----------------+
</span></span><span><span>| Field     | Type         | Null | Key | Default | Extra          |
</span></span><span><span>+-----------+--------------+------+-----+---------+----------------+
</span></span><span><span>| id        | int(11)      | NO   | PRI | NULL    | auto_increment |
</span></span><span><span>| domain_id | int(11)      | NO   | MUL | NULL    |                |
</span></span><span><span>| password  | varchar(106) | NO   |     | NULL    |                |
</span></span><span><span>| email     | varchar(120) | NO   | UNI | NULL    |                |
</span></span><span><span>+-----------+--------------+------+-----+---------+----------------+
</span></span><span><span>4 rows in set (0.001 sec)
</span></span><span><span><span>
</span></span></span><span><span><span></span>MariaDB [mailserver]&gt; describe aliases;
</span></span><span><span>+--------------+--------------+------+-----+---------+----------------+
</span></span><span><span>| Field        | Type         | Null | Key | Default | Extra          |
</span></span><span><span>+--------------+--------------+------+-----+---------+----------------+
</span></span><span><span>| id           | int(11)      | NO   | PRI | NULL    | auto_increment |
</span></span><span><span>| domain_id    | int(11)      | NO   | MUL | NULL    |                |
</span></span><span><span>| source       | varchar(120) | NO   | UNI | NULL    |                |
</span></span><span><span>| destinations | varchar(255) | NO   |     | NULL    |                |
</span></span><span><span>+--------------+--------------+------+-----+---------+----------------+
</span></span><span><span>4 rows in set (0.001 sec)
</span></span></code></pre></div>
</div>
<div>
<h3><i></i>  Lock It Down</h3> 
<p><em>MariaDB (and MySQL) includes a helpful hardening script called <code>mariadb-secure-installation</code>. Be sure to manually run this script and lock down the MariaDB instance before going into production.
</em></p>
</div>
<p>With the foundational services in place, it was now possible to configure Dovecot to act as the MDA. For our Dovecot Ansible task, it generates and writes the configuration files which define the following:</p>
<ul>
<li>dovecot.conf: The base configuration.</li>
<li>conf.d/10-master.conf: Define the service listeners (IMAPS, LMTP, Auth Socket).</li>
<li>conf.d/10-mail.conf: Define mail settings (Maildir configuration with vmail).</li>
<li>conf.d/10-auth.conf: Instruct Dovecot to use the SQL for virtual users SASL.</li>
<li>conf.d/10-ssl.conf: Configure SSL certificate locations, Ciphers and Protocols.</li>
<li>dovecot-sql.conf.ext: SQL queries for auth.</li>
</ul>
<p>After writing the files, the Dovecot service will restart. After running the task I was able to a) verify sockets for IMAPS, LMTP and AUTH and b) test authentication with my test user.</p>
<div>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# netstat -anp | grep dovecot
</span></span><span><span>tcp        0      0 0.0.0.0:993             0.0.0.0:*               LISTEN      77669/dovecot
</span></span><span><span>tcp6       0      0 :::993                  :::*                    LISTEN      77669/dovecot
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     393918   58849/master         private/dovecot
</span></span><span><span>[...]
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     496904   77669/dovecot        /run/dovecot/lmtp
</span></span><span><span>[...]
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     496907   77669/dovecot        /var/spool/postfix/private/dovecot-lmtp
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     496972   77669/dovecot        /var/spool/postfix/private/auth
</span></span><span><span>unix  2      [ ]         DGRAM      CONNECTED     496869   77669/dovecot
</span></span><span><span>[...]
</span></span></code></pre></div>
</div>
<p>I validated auth by connecting  with OpenSSL’s built in client and sending a login string (<code>a login user@iris.com generate-a-random-password</code>):</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# openssl s_client -connect 127.0.0.1:993 -quiet
</span></span><span><span>Can&#39;t use SSL_get_servername
</span></span><span><span>depth=2 C = US, O = Internet Security Research Group, CN = ISRG Root X1
</span></span><span><span>verify return:1
</span></span><span><span>depth=1 C = US, O = Let&#39;s Encrypt, CN = R3
</span></span><span><span>verify return:1
</span></span><span><span>depth=0 CN = mx.iris.com
</span></span><span><span>verify return:1
</span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>* OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE LITERAL+ AUTH=PLAIN] Dovecot ready.
</span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>a login user@iris.com generate-a-random-password
</span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>a OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SNIPPET=FUZZY PREVIEW=FUZZY PREVIEW STATUS=SIZE SAVEDATE LITERAL+ NOTIFY SPECIAL-USE] Logged in      
</span></span></code></pre></div>
</div>
<p>As shown ‘a OK’ (great foresight by the protocol developers of IMAP<sup id="fnref:16"><a href="#fn:16" role="doc-noteref">16</a></sup>) demonstrates successful user authentication via Dovecot SASL.
With confirmation auth is working, it means I could now get to the pointy end of the stick and deploy the MTA.</p>

<p><code>
<em>&#34;Shout out to the 11% of people self-hosting email. Brave souls.&#34; -- /u/essjay2009</em>
</code>
</p>
<p>Any systems engineer will tell you that it’s often a wonder that anything works at all. As we’ve previously discussed, the internet is a chaotic, messy and dangerous place. It’s with some surprise then, as to how generally reliable email routing and inter-system delivery really is.
For this, we thank good MTAs and the SMTP protocol which, while butchered and extended, remains unchanged in its nature for as long as SMTP has existed.</p>
<p>In establishing the MTA, I wanted Postfix to achieve a number of key tasks, including:</p>
<ul>
<li>Listening for inbound email from other systems for our domain.</li>
<li>Determine if a (virtual) user exists.</li>
<li>Queueing incoming messages for spam processing and delivery to the MDA.</li>
<li>Queue processing via spam mitigation capabilities.</li>
<li>Rejecting the bad ones.</li>
<li>Securely accepting outbound emails from users MUAs and queueing them for processing.</li>
<li>Determine where to send the user originated message.</li>
<li>Strip certain heads to preserve privacy of the user.</li>
<li>Securely deliver the message to the target desitnation.</li>
</ul>
<p>There are a lot of moving parts and there’s plenty that can go wrong. To assist with reducing mistakes, I focused on keeping it as simple as possible and make as few modifications to the base configuration as possible.</p>
<p>The Postfix configuration matches the default file structure as outlined by the Fedora distribution with some modifications as required. It roughly looks like the following:</p>
<ul>
<li>master.conf: Define the service listeners and processes.</li>
<li>main.conf: Define the internal configuration, mail delivery instructions and TLS/SSL configuration.</li>
<li>mysql-{aliases,domains,users}.conf: SQL instructions for the virtual users.</li>
<li>smtp_header_checks: Regex file to strip headers for privacy.</li>
</ul>
<p>Similarly to the Dovecot configuration, rather than outline the entire configuration in the Ansible role, the following are some of the key configuration directives:</p>
<p><code>postfix/master.conf</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span># Define our listeners for SMTP</span>
</span></span><span><span>smtp      inet  n       -       y       -       -       smtpd
</span></span><span><span>smtpd     pass  -       -       y       -       -       smtpd
</span></span><span><span>
</span></span><span><span><span># Secure SMTP service configuration</span>
</span></span><span><span>smtps     inet  n       -       y       -       -       smtpd
</span></span><span><span>  -o syslog_name=postfix/smtps
</span></span><span><span>  -o smtpd_tls_wrappermode=yes
</span></span><span><span>  -o smtpd_sasl_auth_enable=yes
</span></span><span><span>  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
</span></span><span><span>  -o smtpd_tls_security_level=encrypt
</span></span><span><span>
</span></span><span><span><span># Submission service configuration</span>
</span></span><span><span>submission inet n       -       y       -       -       smtpd
</span></span><span><span>  -o syslog_name=postfix/submission
</span></span><span><span>  -o smtpd_tls_security_level=encrypt
</span></span><span><span>  -o smtpd_sasl_auth_enable=yes
</span></span><span><span>  -o smtpd_tls_auth_only=yes
</span></span><span><span>  -o smtpd_reject_unlisted_recipient=no
</span></span><span><span>  -o smtpd_client_restrictions=$mua_client_restrictions
</span></span><span><span>  -o smtpd_helo_restrictions=$mua_helo_restrictions
</span></span><span><span>  -o smtpd_sender_restrictions=$mua_sender_restrictions
</span></span><span><span>  -o smtpd_recipient_restrictions=
</span></span><span><span>  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
</span></span><span><span>  -o milter_macro_daemon_name=ORIGINATING
</span></span><span><span>
</span></span><span><span><span># Define our listeners for LMTP</span>
</span></span><span><span>dovecot   unix  -       n       n       -       -       lmtp</span></span></code></pre></div>
</div>
<p><code>postfix/main.conf</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span># Server configuration </span>
</span></span><span><span>myhostname = {{mailserver_alias}}
</span></span><span><span>mydomain = {{mailserver_domain}}
</span></span><span><span>myorigin = $mydomain
</span></span><span><span>inet_interfaces = all
</span></span><span><span>mydestination = $myhostname, localhost.$mydomain, localhost
</span></span><span><span>alias_maps = hash:/etc/aliases
</span></span><span><span>
</span></span><span><span><span># Configure our virtual mail accounts </span>
</span></span><span><span>virtual_transport = lmtp:unix:private/dovecot-lmtp
</span></span><span><span>virtual_mailbox_domains = mysql:/etc/postfix/mysql-domains.cf
</span></span><span><span>virtual_mailbox_maps = mysql:/etc/postfix/mysql-users.cf
</span></span><span><span>virtual_alias_maps = mysql:/etc/postfix/mysql-aliases.cf
</span></span><span><span>
</span></span><span><span>virtual_mailbox_base = /var/vmail
</span></span><span><span>virtual_uid_maps = static:5000
</span></span><span><span>virtual_gid_maps = static:5000
</span></span><span><span>virtual_mailbox_limit = 512000000
</span></span><span><span>
</span></span><span><span><span># Configure Dovecot as our SASL authentication provider. </span>
</span></span><span><span>smtpd_sasl_type = dovecot
</span></span><span><span>smtpd_sasl_path = private/auth
</span></span><span><span>smtpd_sasl_auth_enable = yes
</span></span><span><span>smtpd_sasl_security_options = noanonymous
</span></span><span><span>smtpd_tls_auth_only = yes
</span></span><span><span>disable_vrfy_command = yes
</span></span><span><span>
</span></span><span><span><span># Ensure hardened TLS/SSL services with valid certificates. </span>
</span></span><span><span>smtpd_tls_security_level = may
</span></span><span><span>smtpd_tls_auth_only = yes
</span></span><span><span>smtpd_use_tls = yes
</span></span><span><span>smtp_tls_protocols = !SSLv2, !SSLv3
</span></span><span><span>smtpd_tls_protocols = !SSLv2, !SSLv3
</span></span><span><span>smtp_tls_ciphers = high
</span></span><span><span>smtpd_tls_ciphers = high
</span></span><span><span>smtp_tls_exclude_ciphers = aNULL, MD5
</span></span><span><span>smtpd_tls_exclude_ciphers = aNULL, MD5
</span></span><span><span>smtp_tls_note_starttls_offer = yes
</span></span><span><span>smtpd_tls_received_header = yes
</span></span><span><span>smtpd_tls_session_cache_timeout = 3600s
</span></span><span><span>tls_random_source = dev:/dev/urandom
</span></span><span><span>smtpd_tls_mandatory_ciphers = high
</span></span><span><span>smtpd_tls_mandatory_exclude_ciphers = aNULL, MD5
</span></span><span><span>smtpd_tls_mandatory_protocols = !SSLv2, !SSLv3, !TLSv1, !TLSv1.1, !TLSv1.2
</span></span><span><span>
</span></span><span><span>smtpd_tls_cert_file=/etc/letsencrypt/live/{{mailserver_alias}}/fullchain.pem
</span></span><span><span>smtpd_tls_key_file=/etc/letsencrypt/live/{{mailserver_alias}}/privkey.pem
</span></span><span><span>smtpd_tls_CAfile=/etc/letsencrypt/live/{{mailserver_alias}}/chain.pem
</span></span><span><span>
</span></span><span><span><span># Configure restrictions on email sending (prevent open replay)</span>
</span></span><span><span>smtpd_sasl_security_options = noanonymous
</span></span><span><span>smtpd_tls_auth_only = yes
</span></span><span><span>smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache
</span></span><span><span>
</span></span><span><span>smtpd_relay_restrictions = permit_mynetworks permit_sasl_authenticated defer_unauth_destination
</span></span><span><span>smtpd_client_restrictions = permit_mynetworks
</span></span><span><span>
</span></span><span><span>smtpd_helo_required = yes
</span></span><span><span>smtpd_helo_restrictions = 
</span></span><span><span>    permit_mynetworks, 
</span></span><span><span>    permit_sasl_authenticated, 
</span></span><span><span>    reject_invalid_helo_hostname, 
</span></span><span><span>    reject_non_fqdn_helo_hostname, 
</span></span><span><span>    reject_unknown_helo_hostname
</span></span><span><span>
</span></span><span><span>smtpd_recipient_restrictions =
</span></span><span><span>    permit_mynetworks,
</span></span><span><span>    permit_sasl_authenticated,
</span></span><span><span>    reject_invalid_hostname,
</span></span><span><span>    reject_unknown_recipient_domain,
</span></span><span><span>    reject_unauth_destination,</span></span></code></pre></div>
</div> 
<p>Finally, the Ansible playbook undertakes one additional step which is to remove <code>Received</code> and <code>X-Originating-IP</code> headers from outbound messages. These headers often contain potentially sensitive information for some users including their RFC1918 IP and external origin IP when sending email via Postfix.</p>
<p>The role task writes <code>/etc/postfix/smtp_header_checks</code> and then calls <code>postmap /etc/postfix/smtp_header_checks</code> which creates an indexed version (<code>/etc/postfix/smtp_header_checks.db</code>) for processing by Postfix:</p>
<p><code>postfix/smtp_header_checks</code></p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>/^Received</span>: .*/     IGNORE
</span></span><span><span><span>/^X-Originating-IP</span>: .*/     IGNORE</span></span></code></pre></div>
</div>
<p>With everything going well during playbook execution, I ended up with a smooth set of running Postfix services:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# netstat -anp | grep -i master
</span></span><span><span>tcp        0      0 0.0.0.0:465             0.0.0.0:*               LISTEN      179551/master
</span></span><span><span>tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      179551/master
</span></span><span><span>tcp6       0      0 :::465                  :::*                    LISTEN      179551/master
</span></span><span><span>tcp6       0      0 :::25                   :::*                    LISTEN      179551/master
</span></span><span><span>unix  3      [ ]         STREAM     CONNECTED     879468   179551/master
</span></span><span><span>[...]
</span></span><span><span><span>
</span></span></span><span><span><span></span>[root@mx-iris ~]# netstat -anp | grep -i postfix
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     704606   167617/dovecot       /var/spool/postfix/private/dovecot-lmtp
</span></span><span><span>unix  2      [ ACC ]     STREAM     LISTENING     704673   167617/dovecot       /var/spool/postfix/private/auth
</span></span></code></pre></div>
</div>
<p>With Postfix running I could then verify user authentication by calling the SMTP Submission service as the test user. <code>AUTH PLAIN</code> expects the format <code>[null byte][username][null byte][password]</code>. To test, first generate this string on the command line and then provide it during the session. For example:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# <span>echo</span> -ne <span>&#39;\0user@iris.com\0generate-a-random-password&#39;</span> | base64
</span></span><span><span>AHVzZXJAaXJpcy5jb20AZ2VuZXJhdGUtYS1yYW5kb20tcGFzc3dvcmQ=
</span></span></code></pre></div>
</div>
<p>We can now send the base64 string via the <code>AUTH PLAIN</code> statement:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>$ openssl s_client -connect localhost:465 -crlf -quiet
</span></span><span><span>Can&#39;t use SSL_get_servername
</span></span><span><span>depth=2 C = US, O = Internet Security Research Group, CN = ISRG Root X1
</span></span><span><span>verify return:1
</span></span><span><span>depth=1 C = US, O = Let&#39;s Encrypt, CN = R3
</span></span><span><span>verify return:1
</span></span><span><span>depth=0 CN = mx.iris.com
</span></span><span><span>verify return:1
</span></span><span><span>220 ESMTP - Notice: This is an experimental service on iris.com
</span></span><span><span>EHLO localhost
</span></span><span><span>250-mx.iris.com
</span></span><span><span>250-PIPELINING
</span></span><span><span>250-SIZE 10240000
</span></span><span><span>250-ETRN
</span></span><span><span>250-AUTH PLAIN
</span></span><span><span>250-ENHANCEDSTATUSCODES
</span></span><span><span>250-8BITMIME
</span></span><span><span>250-DSN
</span></span><span><span>250-SMTPUTF8
</span></span><span><span>250 CHUNKING
</span></span><span><span>AUTH PLAIN AHVzZXJAaG9zdC5jb20AZ2VuZXJhdGUtYS1yYW5kb20tcGFzc3dvcmQ=                                                                                              
</span></span><span><span>235 2.7.0 Authentication successful               
</span></span></code></pre></div>
</div>
<p>With authentication confirmed, I could now test sending email to myself. I configured Mozilla Thunderbird with a fresh profile (manual) and the following server settings:</p>
<p><b>IMAP Server:</b></p>
<ul>
<li>Server Type: IMAP Mail Server</li>
<li>Server Name: mx.iris.com</li>
<li>User Name: <a href="mailto:user@iris.com">user@iris.com</a></li>
<li>Port: 993</li>
<li>Connection Security: SSL/TLS</li>
<li>Authentication Method: Normal password</li>
</ul>
<p><b>SMTP Server:</b></p>
<ul>
<li>Description: <a href="mailto:user@iris.com">user@iris.com</a></li>
<li>Server Name: mx.iris.com</li>
<li>Port: 465</li>
<li>Connection Security: SSL/TLS</li>
<li>Authentication Method: Normal password</li>
<li>Username: <a href="mailto:user@iris.com">user@iris.com</a></li>
</ul>

<p><code>
<em>&#34;As someone who self-hosts email, my advice is to not self-host email.&#34; -- /u/Prawny</em>
</code>
</p>
<p>With a functional mailserver up and running a number of the original objectives had been met. However, I still had the significant challenge of spam mitigation to address.</p>
<p>It’s hard to measure via exact figures, but spam and phishing attacks make  up a significant portion of emails online<sup id="fnref:17"><a href="#fn:17" role="doc-noteref">17</a></sup>. The job now was to try and reduce that for the end users I’m hosting.</p>
<p>When it comes to spam mitigation, no single approach works best. Spam killing is generally achieved through a variety of methods including community domain blocklists, policy enforcement (DMARC, SPF and DKIM), content scanning (fuzzy hashing and regular expressions) and statistical analysis (Bayes classification and machine learning).</p>
<p>I wanted to leverage as many of the approaches as possible to maximise the chances of catching both spam and phishing attempts against users. When looking for open software to do the job two primary contenders stood out - SpamAssassin and Rspamd.</p>
<p>I would love to say I ran an objective comparison of the two capabilities but truth be told in a prior life I was responsible for administration of SpamAssassin and didn’t enjoy the experience. As a result, Rspamd<sup id="fnref:18"><a href="#fn:18" role="doc-noteref">18</a></sup> became the solution of choice for this project.</p>
<div>
<h3><i></i>  Complex features means complex code</h3> 
<p><em>Complex features almost always means a complex code base. Rspamd brings a huge number of powerful features to administrators but at a cost: a complex code base. Be careful when enabling features and where possible understanding each feature is expanding the potential attack profile of your services.
</em></p>
</div>
<p>At time of writing, there really has not been enough volume of traffic to truly understand the effectiveness of the anti-spam measures. The observed spam making it through generally via compromised mail accounts of legitimate domains and users or popular mail delivery platforms such as Amazon SES or Mailgun. For these instances, the mail comes through with SPF and DKIM pass results.  I have deployed the Bayes classification and neural network features provided by rspamd which are currently in training and hope they help alleviate the success rate of spam into users inboxes.</p>
<p>In addition to checking spam inbound, rpsamd is configured to DKIM sign outbound messages to increase the likelihood of delivery into major provides such as Google.</p>
<p>Like the Dovecot and Postfix configuration, rspamd supports splitting configuration files and configuration file overrides. The configuration is written to the <code>local.d/</code> configuration folder for the bits we wish to customise. The configuration roughly looks like the following:</p>
<ul>
<li><em>dkim_signing.conf</em>: Configure DKIM signing.</li>
<li><em>dmarc.conf</em>: DMARC configuration.</li>
<li><em>milter.conf</em>: Define the mail filter (milter) configuration for Postfix to call.</li>
<li><em>milter_headers.conf</em>: Inject spam score information into mail headers.</li>
<li><em>multimap.conf</em>: Configure the X-Spam-Flag header.</li>
<li><em>neural.conf</em>: Define the neural learning function.</li>
<li><em>rbl.conf</em>: The realtime blackhole list configuration.</li>
<li><em>redis.conf</em>: Configure redis for Neural and Bayes functions.</li>
<li><em>worker-controller.inc</em>: Configure passwords for the worker process.</li>
</ul>
<p>The majority of rspamd features will work well out of the box or with minor tuning to the configuration. The primary exception to this is the DKIM signing functionality.</p>
<p>When it comes to policy frameworks for email, there are three key frameworks which most mail providers will acknowledge:</p>
<ul>
<li>
<p>Sender Policy Framework (SPF)<sup id="fnref:19"><a href="#fn:19" role="doc-noteref">19</a></sup> is used to reduce the likelihood of spoofing being successful for mail domains. It can be considered as a kind of server authorisation protocol which is defined via DNS.</p>
</li>
<li>
<p>DomainKeys Identified Mail (DKIM)<sup id="fnref:20"><a href="#fn:20" role="doc-noteref">20</a></sup> leverages public / private key infrastructure to sign emails. If we consider SPF to be authorisation, DKIM is the authentication of messages. DKIM signed messages can be validated via DNS records.</p>
</li>
<li>
<p>Domain-based Message Authentication, Reporting, and Conformance (DMARC)<sup id="fnref:21"><a href="#fn:21" role="doc-noteref">21</a></sup> is not just a long name. DMARC let’s mail operators define how mail servers should behave in the event of a SPF or DKIM failure (someone spoofing mail).  This includes not only the behaviour but where to report violations to. Like all good policy frameworks, this too is configured via DNS records that we will look at below.</p>
</li>
</ul>
<p>In order to deliver email to other mail providers without being marked as spam, I ideally needed to implement all three policy frameworks with the mail server.</p>
<p>For SPF, it’s as simple as defining a DNS TXT record for each domain such as the following:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>v=spf1 a:mx.iris.com ip6:2402:dead:beaf:4242::0000 mx -all
</span></span></code></pre></div>
</div>
<p>In short, this record defines a SPF version 1 record and defines the MX DNS entries, the host mx.iris.com and a specific IPv6 address as authorised to send mail on a iris.com’s behalf. If any attempt doesn’t match those 3 defined methods, the SPF fails.</p>
<p>Having SPF pass will work for the majority of providers to avoid getting marked as spam, however, DKIM is now increasingly required. During initial testing of the server I found numerous instances where my mail was marked as spam even though SPF clearly passed. To resolve this, I decided to bite the bullet and implement DKIM for the outbound domains.</p>
<p>To support DKIM, there are generally three key steps required:</p>
<ol>
<li>Generate a private key for the domain.</li>
<li>Configure the MTA to sign messages as they egress the system.</li>
<li>Configure a DNS record with the public key information so remote systems can verify the signature on a piece of message.</li>
</ol>
<p>This is a rather in depth process, but one that rspamd makes very accessible. In fact, really simple.  First, I generated a DKIM key for each domain using the rspamadm utility. The three bits of detail we need to provide are the domain (iris.com), the RSA key size and the selector. The selector is just an identifier and can be anything, for the purposes of my setup I used <code>sig1</code> as the selector:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@mx-iris ~]# rspamadm dkim_keygen -d iris.com -k sig1 -b <span>2048</span>
</span></span><span><span>mail._domainkey IN TXT ( &#34;v=DKIM1; k=rsa; &#34;
</span></span><span><span>        &#34;p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2DtOYvGbJRugjJ/WbGzbxHyqXG6duvlhUeBhU/hOn16bTABlcamwKzV/Tmcv84YgxyaCI7NXJBOYn87i1bzJwfnosPD55gDrdYZ/meqKBYN7a1brrCC3V8piQ3fjoeR3ejfbR9Rd/OBYSAnIKahSHqigKRWTo9kdBe5LIeDPrgGV98pEXmQpoauLqFy5fEqMZEoSHJOkiPGGI3+LK&#34;
</span></span><span><span>        &#34;t0yLjOjqzcEHh0tWdH2T8Z7lrZY4ugMXcLN0vtTng/pa49tS+q4RPa27B/dw8qRiKKR5edv2eSoVQWVMJRY/58r7316NVeqwEHqo8JR6bgR0V2/NjCFZ+sAo63X6sFDa4E32QIDAQAB&#34;
</span></span><span><span>) ;
</span></span></code></pre></div>
</div>
<p>With the key generated, it’s then important to ensure the sig1._domainkey.iris.com TXT DNS record is configured correctly. For example:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[root@trappist-1 ~]# dig +short sig1._domainkey.sd6.net.nz TXT
</span></span><span><span>&#34;v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2DtOYvGbJRugjJ/WbGzbxHyqXG6duvlhUeBhU/hOn16bTABlcamwKzV/Tmcv84YgxyaCI7NXJBOYn87i1bzJwfnosPD55gDrdYZ/meqKBYN7a1brrCC3V8piQ3fjoeR3ejfbR9Rd/OBYSAnIKahSHqigKRWTo9kdBe5LIeDPrgGV98pEXmQpoauLqFy5fEqMZEoSHJOkiPGGI3+LK&#34; &#34;t0yLjOjqzcEHh0tWdH2T8Z7lrZY4ugMXcLN0vtTng/pa49tS+q4RPa27B/dw8qRiKKR5edv2eSoVQWVMJRY/58r7316NVeqwEHqo8JR6bgR0V2/NjCFZ+sAo63X6sFDa4E32QIDAQAB&#34;
</span></span></code></pre></div>
</div>
<p>Two further notes on DKIM. The first, you will note that the DNS record is split in two. Like SMTP, DNS is an extremely old protocol and when developed it was envisioned that it would not have to store more than 255 bytes in a TXT record. This doesn’t work well with lengthy public keys, so the clever solution was to split the records and reassemble when required for signing validation.</p>
<p>Secondly, it should be noted that I deliberately have not automated with Ansible. DKIM is finicky at the best of times and I believe it is a task best  done by hand to ensure clean key generation, public key capture, DNS record creation and ultimately timely testing of any changes with third-party systems.</p>
<p>The last step is to configure Postfix to pass messages to the rspam provided milter upon message recept via SMTP. To do that, I added the following configuration directives to the Postfix main.cf:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span># Configure rspamd <span>for</span> spam checking 
</span></span><span><span>smtpd_milters = inet:localhost:11332
</span></span><span><span>non_smtpd_milters = $smtpd_milters
</span></span><span><span>milter_mail_macros = i {mail_addr} {client_addr} {client_name} {auth_authen}
</span></span><span><span>milter_protocol = 6
</span></span></code></pre></div>
</div>

<p><code>
<em>&#34;I&#39;ve been hosting email on our friends+family server for twenty-three years, and agree, it&#39;s not for the faint of heart.&#34; -- /u/ttkciar</em>
</code>
</p>
<p>At this point things were looking pretty good. I had a mail server providing MTA and MDA services for virtual users. Inbound and outbound message delivery was working. Rspamd was checking inbound messages with a variety of anti-spam and anti-phishing functions as well as signing our messages for DKIM on the way out the door.</p>
<p>Not bad for a $5/month VPS.</p>
<p>As happy as I was, I still had one final hardening step to undertake - brute force mitigation. Whilst there is no webmail access to target with phishing, any place where authentication occurs is a great place to undertake brute force attacks to guess a user’s password.</p>
<p>Fail2ban<sup id="fnref:22"><a href="#fn:22" role="doc-noteref">22</a></sup> is a free and open source project which enables brute force attack mitigation via log monitoring. In short, it monitors log files for ongoing authentication attacks and when it detects one, it blocks the attacking IP by leveraging IPTables firewalls. To leverage fail2ban I had ansible create two new configuration files:</p>
<p><code>jail.d/01-dovecot.conf</code></p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[dovecot]
</span></span><span><span>enabled = true
</span></span><span><span>port    = imap,imaps
</span></span><span><span>filter  = dovecot
</span></span><span><span>logpath = /var/log/maillog
</span></span><span><span>maxretry = 5
</span></span></code></pre></div>
</div>
<p><code>jail.d/01-postfix.conf</code></p>
<div>
<div><pre tabindex="0"><code data-lang="bash-session"><span><span>[postfix]
</span></span><span><span>enabled = true
</span></span><span><span>port    = smtp,ssmtp
</span></span><span><span>filter  = postfix
</span></span><span><span>logpath = /var/log/maillog
</span></span><span><span>maxretry = 5
</span></span></code></pre></div>
</div>
<p>The server has been in operation with ‘production’ workloads for a few weeks now and in general, it is performing very well.</p>
<p>The choice of Fedora has applied SELinux contexts to our key processes by default (Dovecot, Postfix, MariaDB, Rspamd) and I have basic firewalling and are leveraging fail2ban to prevent brute forcing of user accounts via our SMTP and IMAP services.</p>
<p>Spam mitigation appears to be effective while still being trained to tackle some of the harder edge cases and messages from the server are successfully arriving in inboxes on services such as Gmail, iCloud, ProtonMail and M365.</p>
<p>Finally, the majority of the solution (with exception to DKIM signing) implemented as code via Ansible which makes the solution reproducible in the event of catastrophic VPS issues.</p>
<p>At the start of this essay I said I wanted the following capability:</p>
<center><em>Build a self-hosted email server that provides mail services which can reliably deliver emails to the major providers (Gmail, Proton, iCloud, M365) without being canned like spam.</em></center>
<p>I am very happy to report that I met this objective and in a reasonably stable state.</p>
<p>I feel compelled to point out that the purpose of this essay has not been to convince you to self-host email, nor convert you to unsupported open source platforms due to idealism. It was simply to see if it is achievable for those who want to give it a go for their own reasons and have some fun along the way.</p>
<p>If you do decide to pick up the challange of self-hosting email then good luck on your self-hosting journey! Please be sure to let me know if you found this essay helpful at all in your adventures.</p>

<p><code>
<em>&#34;Yes, it&#39;s possible. But it&#39;s not very practical.&#34; -- /u/swayuser</em>
</code>
</p>
<h3>Acknowledgements</h3>
<p>I would like to thank all those (Vanessa, Justin, Aaron and Mark) who took the time to review an early pass of this essay. It’s a lot of work for a niche project so I really appreciate it.</p>
<p>To the /r/selfhosted community: stay curious! While often seen as a silly or time wasteful effort, I believe that the importance of open systems matters and find your projects inspirational. Taking control of your own data, learning and playing is powerful and should be celebrated. Keep fighting the good fight.</p>
<p>To Jeff Geerling for his excellent book.</p>
<p>Finally, to the open source developers, writers and community members for all the software mentioned in this essay (Fedora, Postfix, Dovecot, MariaDB, Rspamd, fail2ban, SELinux) my heartfelt thank you for keeping software open.</p>
<h3>Footnotes</h3>


        </div></main>
    </div></div>
  </body>
</html>
