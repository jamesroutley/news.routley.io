<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bugs.ruby-lang.org/issues/18462">Original</a>
    <h1>Proposal to merge WASI based WebAssembly support</h1>
    
    <div id="readability-page-1" class="page"><div>
  

<p>This is an initial port of WASI based WebAssembly support.</p>

<p>The upstreaming PR on ruby/ruby is here: <a href="https://github.com/ruby/ruby/pull/5407">https://github.com/ruby/ruby/pull/5407</a></p>

<h2>Background<a href="#Background">¶</a></h2>

<p>For example, CRuby already supports WebAssembly target by Emscripten, but Emscripten heavily depends on JavaScript to emulate some missing features in WebAssembly itself.</p>

<p>In short the WASI is an effort to define a standard set of syscalls for WebAssembly modules, allowing WebAssembly modules to not only be portable across architectures but also be portable across environments implementing this standard set of system calls. The environments includes non JS environments, Edge Computing platforms, IoT devices, and so on.</p>

<p>This is a proposal ticket to support WASI based WebAssembly target.</p>

<p>This is a part of Ruby Association Grant project</p>

<h2>Lexicon<a href="#Lexicon">¶</a></h2>

<ul>
<li><a href="https://wasi.dev">WASI</a>: A system call interface for WebAssembly</li>
<li><a href="https://github.com/WebAssembly/wasi-libc">wasi-libc</a>: A libc implementation for WebAssembly programs built on top of WASI system calls.</li>
</ul>

<h2>Current Limitation of WebAssembly and WASI<a href="#Current-Limitation-of-WebAssembly-and-WASI">¶</a></h2>

<h3>Threads<a href="#Threads">¶</a></h3>

<p>Currently WebAssembly has no threads, and WASI doesn&#39;t provide any API to create a thread, but they are <a href="https://github.com/WebAssembly/threads/blob/main/proposals/threads/Overview.md">on the roadmap</a>. This means <code>Thread.new</code> doesn&#39;t work on this target, and it raises <code>ENOSUP</code> for now.</p>

<h3>Register operations<a href="#Register-operations">¶</a></h3>

<p>Current WebAssembly doesn&#39;t allow to touch the program counter, but they are also <a href="https://github.com/WebAssembly/stack-switching">on the roadmap</a>.</p>

<p>And also WebAssembly has function local infinite registers, but there is no way to scan the values in a call stack for now.</p>

<h2>Patch Overview<a href="#Patch-Overview">¶</a></h2>

<p>This patch is a set of minor changes:</p>

<h3>Adapt to wasi-libc API<a href="#Adapt-to-wasi-libc-API">¶</a></h3>

<p>wasi-libc is almost compatible with other libc implementations, but it doesn&#39;t have some functions.</p>

<h3>Add no thread variant<a href="#Add-no-thread-variant">¶</a></h3>

<p>As mentioned above, WebAssembly has no thread, so this patch adds a thread_none.c, which is a sibling of thread_win32.c and thread_pthread.c. This implementation does nothing around preemptive context switching because there is no native thread.</p>

<h3>Emulate setjmp/longjmp, coroutine, and register scan by Asyncify<a href="#Emulate-setjmplongjmp-coroutine-and-register-scan-by-Asyncify">¶</a></h3>

<p>As mentioned above, WebAssembly has no context switching feature, but there is an userland technique to pause and resume a WebAssembly process by binary transformation.</p>

  </div></div>
  </body>
</html>
