<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hanickadot/shorty">Original</a>
    <h1>C&#43;&#43;: terser (shorter) lambda == SHORTY (ab-use?)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This library is intended to give terser syntax than C++&#39;s lambdas, not replace C++ with lazy DSL.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import shorty;
using namespace shorty::literals;

// you no longer need to remember if it&#39;s `std::less` or `std::greater`
std::ranges::sort(subject, $lhs &gt; $rhs);

// filter only even
subject | std::views::filter(($i % 2) == 0);

// zip together and transform
std::views::zip(A,B,C,D) | std::views::transform($a * $b + $c * $d);

// call external function
auto pythagorean = $&lt;sqrt&gt;($a * $a + $b * $b); // or $call&lt;sqrt&gt;;
pythagorean(3.0, 4.0) == 5.0;

// casting
auto to_int = $&lt;int&gt;($0); // or $cast&lt;int&gt;;
to_int(4.3) == 4; 

// remap by index
auto indices = std::vector&lt;int&gt;{...};
auto mapping = indices | $(data)[$i];"><pre>import shorty;
<span>using</span> <span>namespace</span> <span>shorty</span>::literals<span>;</span>

<span><span>//</span> you no longer need to remember if it&#39;s `std::less` or `std::greater`</span>
<span>std::ranges::sort</span>(subject, $lhs &gt; $rhs);

<span><span>//</span> filter only even</span>
subject | std::views::filter(($i % <span>2</span>) == <span>0</span>);

<span><span>//</span> zip together and transform</span>
<span>std::views::zip</span>(A,B,C,D) | std::views::transform($a * $b + $c * $d);

<span><span>//</span> call external function</span>
<span>auto</span> pythagorean = $&lt;sqrt&gt;($a * $a + $b * $b); <span><span>//</span> or $call&lt;sqrt&gt;;</span>
<span>pythagorean</span>(<span>3.0</span>, <span>4.0</span>) == 5.0;

<span><span>//</span> casting</span>
<span>auto</span> to_int = $&lt;<span>int</span>&gt;($<span>0</span>); <span><span>//</span> or $cast&lt;int&gt;;</span>
<span>to_int</span>(<span>4.3</span>) == 4; 

<span><span>//</span> remap by index</span>
<span>auto</span> indices = std::vector&lt;<span>int</span>&gt;{...};
<span>auto</span> mapping = indices | $(data)[$i];</pre></div>

<p dir="auto">If shorty callable gets only one argument and the argument is <code>tuple_like</code> then it&#39;s automatically unwrapper. Same applies to any lazy calls.</p>
<p dir="auto">By default arguments are accessible using <code>$0</code>...<code>$9</code> syntax (for first 10) or <code>$arg&lt;N&gt;</code>. But also you can use following special arguments:</p>
<ul dir="auto">
<li><code>$lhs</code> and <code>$rhs</code> for binary callables (it limits them to two arguments)</li>
<li><code>$it</code> for first and only argument, which is also compatible with <code>std::input_or_output_iterator</code></li>
<li><code>$a</code> ... <code>$f</code> for first 6 arguments but names instead of numbers (can&#39;t be mixed with other types of arguments)</li>
<li><code>$x</code>, <code>$y</code>, <code>$z</code> for first 3 arguments (again can&#39;t be mixed with other types of arguments)</li>
<li><code>$i</code>, <code>$n</code>, <code>$k</code>, <code>$in</code> ... for first and only argument (can&#39;t be mixed too)</li>
</ul>

<ul dir="auto">
<li><code>$argc</code> for getting number of arguments as <code>size_t</code></li>
<li><code>$args</code> to get all arguments as a tuple</li>
</ul>

<ul dir="auto">
<li><code>$(v)</code> or <code>$ref(v)</code> capture by reference (or const reference, depending on const qualifier of <code>v</code>)</li>
<li><code>$value(v)</code>, <code>$val(v)</code>, or <code>$copy(v)</code> capture by copy</li>
<li><code>$fixed&lt;v&gt;</code> or <code>$const&lt;v&gt;</code> capture by CNTTP (only for structural types)</li>
</ul>

<ul dir="auto">
<li><code>$&lt;callable&gt;(args...)</code> or <code>$call&lt;callable&gt;(args...)</code> call <code>callable</code> with arguments <code>args</code></li>
<li><code>$&lt;CallableType&gt;(args...)</code> or <code>$call&lt;CallableType&gt;(args...)</code> call new instance of type <code>CallableType</code> with arguments <code>args</code></li>
</ul>

<ul dir="auto">
<li><code>$&lt;T&gt;(expr)</code> or <code>$cast&lt;T&gt;(expr)</code> will <code>static_cast</code> expression result into <code>T</code></li>
</ul>

<ul dir="auto">
<li><code>($a, $b, $c)</code> - will make <code>tuple&lt;auto,auto,auto&gt;</code></li>
<li><code>($0, $1)</code> - will make <code>tuple&lt;auto,auto&gt;</code></li>
</ul>

<ul dir="auto">
<li><code>$a += 2</code> will add 2 to <code>$a</code> and return resul</li>
<li><code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> all works too</li>
</ul>
<hr/>
<p dir="auto">Special thanks (and a bit of hate) to an <a href="https://bsky.app/profile/kaballo86.bsky.social" rel="nofollow">anonymous Argentinian</a> for nerd-snipping into this.</p>
</article></div></div>
  </body>
</html>
