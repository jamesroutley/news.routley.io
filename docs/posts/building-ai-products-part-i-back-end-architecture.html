<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://philcalcado.com/2024/12/14/building-ai-products-part-i.html">Original</a>
    <h1>Building AI Products–Part I: Back-End Architecture</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>

  

  
  <article>
      <p>In 2023, we launched an AI-powered Chief of Staff for engineering leaders—an assistant that unified information across team tools and tracked critical project developments. Within a year, we attracted 10,000 users, <a href="https://outropy.ai/blog/2024-04-19-outropy_vs_slack_ai/">outperforming even deep-pocketed incumbents such as Salesforce and Slack AI</a>. Here is an early demo:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/8mr5eZNXDlo?si=-IIK5uO5cTN9FFhi" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>By May 2024, we realized something interesting: while our AI assistant was gaining traction, there was overwhelming demand for the technology we built to power it. Engineering leaders using the platform were reaching out non-stop to ask not about the tool but how we made our agents work so reliably at scale and be, you know, <em>actually useful</em>. This led us to pivot to <a href="https://outropy.ai/">Outropy</a>, a developer platform that enables software engineers to build AI products.</p>

<p>Building with Generative AI at breakneck pace while the industry was finding its footing taught us invaluable lessons—lessons that now form the core of the Outropy platform. While LinkedIn overflows with thought leaders declaring every new research paper a “game changer,” few explain what the game actually is. This series aims to change that.</p>

<p>This three-part series will cover:</p>

<ul>
  <li>How we built the AI agents powering the assistant</li>
  <li>How we constructed and operate our inference pipelines</li>
  <li>The AI-specific tools and techniques that made it all work</li>
</ul>

<p>This order is intentional. So much content out there fixates on choosing the best reranker or chasing the latest shiny technology, and few discuss how to build useful AI software. This is a report from the trenches, not the ivory tower.</p>

<h3 id="structuring-an-ai-application">Structuring an AI Application</h3>

<p>Working with AI presents exciting opportunities and unique frustrations for a team like ours, with decades of experience building applications and infrastructure.</p>

<p>AI’s stochastic (probabilistic) nature fundamentally differs from traditional deterministic software development—but that’s only part of the story. With years of experience handling distributed systems and <a href="https://nighthacks.com/jag/res/Fallacies.html">their inherent uncertainties</a>, we’re no strangers to unreliable components.</p>

<p>The biggest open questions lie in structuring GenAI systems for long-term evolution and operation, moving beyond the quick-and-dirty prompt chaining that suffices for flashy demos.</p>

<p>In my experience, there are two major types of components in a GenAI system:</p>

<ul>
  <li><strong>Inference Pipelines:</strong> A deterministic sequence of operations that transforms inputs through one or more AI models to produce a specific output. Think of RAG pipelines generating answers from documents—each step follows a fixed path despite the AI’s probabilistic nature.</li>
  <li><strong>Agents:</strong> Autonomous software entities that maintain state while orchestrating AI models and tools to accomplish complex tasks. These agents can reason about their progress and adjust their approach across multiple steps, making them suitable for longer-running operations.</li>
</ul>

<p>Our journey began with <a href="https://www.youtube.com/watch?v=ePFEpU5crN0&amp;ab_channel=PhilCal%C3%A7ado">a simple Slack bot</a>. This focused approach let us explore GenAI’s possibilities and iterate quickly without getting bogged down in architectural decisions. During this period, we only used distinct inference pipelines and tied their results together manually.</p>

<p>This approach served us well until we expanded our integrations and features. As the application grew, our inference pipelines became increasingly complex and brittle, struggling to reconcile data from different sources and formats while maintaining coherent semantics.</p>

<p>This complexity drove us to adopt a <em>multi-agentic system</em>.</p>

<h3 id="what-are-agents-really">What are agents, really?</h3>

<p>The industry has poured billions into AI agents, yet most discussions focus narrowly on <a href="https://en.wikipedia.org/wiki/Robotic_process_automation">RPA</a>-style, no-code and low-code automation tools. Yes, frameworks like CrewAI, AutoGen, Microsoft Copilot Studio, and Salesforce’s Agentforce serve an important purpose—they give business users the same power that shell scripts give Linux admins. But just like you wouldn’t build a production system in Bash, these frameworks are just scratching the surface of what agents can be.</p>

<p>The broader concept of agents has a rich history in academia and AI research, offering much more interesting possibilities for product development. Still, as a tiny startup on a tight deadline, rather than get lost in theoretical debates, we distilled practical traits that guided our implementation:</p>

<ul>
  <li><strong>Semi-autonomous:</strong> Functions independently with minimal supervision, making local decisions within defined boundaries.</li>
  <li><strong>Specialized:</strong> Masters specific tasks or domains rather than attempting general-purpose intelligence.</li>
  <li><strong>Reactive:</strong> Responds intelligently to requests and environmental changes, maintaining situational awareness.</li>
  <li><strong>Memory-driven:</strong> Maintains and leverages both immediate context and historical information to inform decisions.</li>
  <li><strong>Decision-making:</strong> Analyzes situations, evaluates options, and executes actions aligned with objectives.</li>
  <li><strong>Tool-using:</strong> Effectively employs various tools, systems, and APIs to accomplish tasks.</li>
  <li><strong>Goal-oriented:</strong> Adapts behavior and strategies to achieve defined objectives while maintaining focus.</li>
</ul>

<p>While these intelligent components are powerful, we quickly learned that not everything needs to be an agent. Could we have built our Slackbot and productivity tool connectors using agents? Sure, but the traditional design patterns worked perfectly well, and our limited resources were better spent elsewhere. The same logic applied to standard business operations—user management, billing, permissions, and other commodity functions worked better with conventional architectures.</p>

<p>This meant that we had the following <a href="https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html#idm46407728082304">layered architecture</a> inside our application:</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-mono.png" alt=""/></p>

<h3 id="agents-are-not-microservices">Agents are not Microservices</h3>

<p>I’ve spent the last decade deep in microservices—from pioneering work at ThoughtWorks to helping underdogs like SoundCloud, DigitalOcean, SeatGeek, and Meetup punch above their weight. So naturally, that’s where we started with our agent architecture.</p>

<p>Initially, we implemented agents as <a href="https://martinfowler.com/eaaCatalog/serviceLayer.html">a service layer</a> with traditional request/response cycles:</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-agents-service-layer.png" alt=""/></p>

<p>One of the biggest appeals of this architecture was that, even if we expected our application to be a monolith for a long time, it creates an easier path to extracting services as needed and benefit from <em>horizontal scalability</em> when the time comes.</p>

<p>Unfortunately, the more we went down the path, the more obvious it became that stateless microservices and AI agents just don’t play nice together. Microservices are all about splitting a particular feature into small units of work that need minimal context to perform the task at hand. The same traits that make agents powerful create a significant impedance mismatch with these expectations:</p>

<ul>
  <li><strong>Stateful Operation</strong>: Agents must maintain rich context across interactions, including conversation history and planning states. This fundamentally conflicts with microservices’ stateless nature and complicates scaling and failover.</li>
  <li><strong>Non-deterministic Behavior</strong>: Unlike traditional services, agents are basically state machines with unbounded states. They behave completely differently depending on context and various probabilistic responses. This breaks core assumptions about caching, testing, and debugging.</li>
  <li><strong>Data-Intensive with Poor Locality</strong>: Agents process massive amounts of data through language models and embeddings, with poor data locality. This contradicts microservices’ efficiency principle.</li>
  <li><strong>Unreliable External Dependencies</strong>: Heavy reliance on external APIs such as LLMs, embedding services, and tool endpoints creates complex dependency chains with unpredictable latency, reliability, and costs.</li>
  <li><strong>Implementation Complexity</strong>: The combination of prompt engineering, planning algorithms, and tool integrations creates debugging challenges that compound with distribution.</li>
</ul>

<p>Not only did this impedance mismatch cause a lot of pain while writing and maintaining the code, but agentic systems are so far away from the ubiquitous <a href="https://12factor.net/">12-factor</a> model that attempting to leverage existing microservice tooling became an exercise in fitting square pegs into round holes.</p>

<h3 id="agents-are-more-like-objects">Agents are more like objects</h3>

<p>If microservices weren’t the right fit, another classic software engineering paradigm offered a more natural abstraction for agents: object-oriented programming.</p>

<p>Agents naturally align with OOP principles: they maintain encapsulated state (their memory), expose methods (their tools and decision-making capabilities via inference pipelines), and communicate through message passing. <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">This mirrors Alan Kay’s original vision</a>:</p>

<blockquote>
  <p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.</p>
</blockquote>

<p><img src="https://philcalcado.com/img/building-ai-products-i/uml.png" alt=""/></p>

<p>We’ve been in the industry long enough to remember the nightmares of distributed objects and the fever dreams of CORBA and J2EE. Yet, objects offered us a pragmatic way to quickly iterate on our product and defer the scalability question until we actually need to solve that.</p>

<p>We evolved our agents from <a href="https://martinfowler.com/bliki/EvansClassification.html">stateless Services to Entities</a>, giving them distinct identities and lifecycles. This meant each user or organization maintained their own persistent agent instances, managed through <a href="https://philcalcado.com/2010/12/23/how_to_write_a_repository.html">Repositories</a> in our database.</p>

<p>This drastically simplified our function signatures by eliminating the need to pass extensive context as arguments on every agent call. It also lets us leverage battle-tested tools like SQLAlchemy and Pydantic to build our agents, while enabling unit tests with stubs/mocks instead of complicated integration tests.</p>

<h3 id="implementing-agentic-memory">Implementing Agentic Memory</h3>

<p>Agents’ memories can be as simple as a single value to as complicated as keeping track of historical information since the beginning of times. In our assistant, we have both types and more.</p>

<p>For simple, narrow-focused agents such as the “Today’s Priorities” agents had to remember nothing more than a list of high-priority things they were monitoring and eventually taking action, such as sending a notification if they weren’t happy with the progress. Others, like our “Org Chart Keeper” had to keep track of all interactions between everyone in the organizations and use that to infer reporting lines and teams people belonged to.</p>

<p>The agents with simpler persistence needs would usually just store their data on a dedicated table using <a href="https://docs.sqlalchemy.org/en/20/orm/">SQLAlchemy’s ORM</a>. This obviously wasn’t an option for the more complicated memory needs, so we had to apply a different model</p>

<p>After some experimentation, we adopted <a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> with <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a>. In essence, every state change—whether creating a meeting or updating team members—was represented as a <em>Command</em>, a discrete event recorded chronologically—much like a database <a href="https://en.wikipedia.org/wiki/Transaction_log">transaction log</a>. The current state of any object could then be reconstructed by replaying all its associated events in sequence.</p>

<p>While this approach has clear benefits, replaying events solely to respond to a query is slow and cumbersome, especially when most queries focus on the current state rather than historical data. To address, CQRS suggests that we maintain a continuously updated, query-optimized representation of the data, similar to materialized views in a relational database. This ensured quick reads without sacrificing the advantages of event sourcing. We started off storing events and query models in Postgres, planning to move them to DynamoDB when we started having issues.</p>

<p>One big challenge in this model is that only an agent knows what matters to them. For example, if a user would change cancel a scheduled meeting, which agents should care about this event? The scheduling agent for sure, but if this meeting was about a specific project you might also want the project management agent to know about it as it might impact the roadmap.</p>

<p>Rather than building an all-knowing router to dispatch events to the right agents—risking the creation of a <a href="https://en.wikipedia.org/wiki/God_object">God object</a>—we took inspiration from <a href="https://developers.soundcloud.com/blog/building-products-at-soundcloud-part-1-dealing-with-the-monolith">my experience at SoundCloud</a>. There, we developed a semantic event bus enabling interested parties to publish and observe events for relevant entities:</p>

<blockquote>
  <p>Soon enough, we realized that there was a big problem with this model; as our microservices needed to react to user activity. The push-notifications system, for example, needed to know whenever a track had received a new comment so that it could inform the artist about it.  […] over several iterations we developed a model called Semantic Events, where changes in the domain objects result in a message being dispatched to a broker and consumed by whichever microservice finds the message interesting.</p>
</blockquote>

<p><img src="https://philcalcado.com/img/building-ai-products-i/semantic-events.png" alt=""/></p>

<p>Following this model, all state-change events were posted to an event bus that agents could subscribe to. Each agent filtered out irrelevant events independently, removing the need for external systems to know what they cared about. Since we were working within a single monolith at the time, we implemented a straightforward <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a> using <a href="https://docs.sqlalchemy.org/en/20/orm/events.html">SQLAlchemy’s native event system</a>, with plans to eventually migrate to <a href="https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/">DynamoDB Streams</a>.</p>

<p>Inside our monolith, the architecture looked like this:</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/memory1.png" alt=""/></p>

<p>Managing both the ORM approach for simpler objects and CQRS for more complex needs grew increasingly cumbersome. Small refactorings or shared logic across all agents became harder than necessary. Ultimately, we decided the simplicity of ORM wasn’t worth the complexity of handling two separate persistence models. We converted all agents to the CQRS style but retained ORM for non-agentic components.</p>

<h3 id="handling-events-in-natural-language">Handling Events in Natural Language</h3>

<p>CQRS and its supporting tools excel with well-defined data structures. At SoundCloud, events like <em>UploadTrack</em> or <em>CreateTrackComment</em> were straightforward and unambiguous. AI systems, however, present a very different challenge.</p>

<p>Most AI systems deal with the uncertainty of natural language. This makes the process of consolidating the Commands into a “materialized view” hard. For example, what events correspond to someone posting a Slack message like <em>“I am feeling sick and can’t come to the office tomorrow, can we reschedule the project meeting?”</em></p>

<p>We started with the naive approach most agentic systems use: running every message through an inference pipeline to extract context, make decisions, and take actions via tool calling. This approach faced two problems: first, reliably doing all this work in a single pipeline is hard even with frontier models—more on this in part II. Second, we ran into the God object problem discussed earlier—our logic was spread across many agents, and no single pipeline could handle everything.</p>

<p>One option involved sending each piece of content—Slack messages, GitHub reviews, Google Doc comments, emails, calendar event descriptions…—to every agent for processing. While this was straightforward to implement via our event bus, each agent would need to run its inference pipeline for every piece of content. This would offer all sorts of performance and cost issues due to frequent calls to LLMs and other models, especially considering that the vast majority of content wouldn’t be relevant to a particular agent.</p>

<p>We wrestled with this problem for a while, exploring some initially promising but ultimately unsuccessful attempts at <a href="https://www.mathworks.com/discovery/feature-extraction.html">Feature Extraction</a> using simpler ML models instead of LLMs. That said, I believe this approach can work well in constrained domains—indeed, we use it in Outropy to route requests within the platform.</p>

<p>Our solution built on <a href="https://arxiv.org/pdf/2312.06648">Tong Chen’s Proposition-Based Retrieval research</a>. We already <a href="https://www.linkedin.com/posts/pcalcado_ai-vs-human-readability-the-unnecessary-activity-7275345861222535168-3fIB?utm_source=share&amp;utm_medium=member_desktop">used this approach to ingest structured content like CSV file</a>s, where instead of directly embedding it into a vector database, we first use an LLM to generate natural language factoids about the content. While these factoids add no new information, their natural language format makes vector similarity search much more effective than the original spreadsheet-like structure.</p>

<p>Our solution was to use an LLM to generate propositions for every message, structured according to a format inspired by <a href="https://github.com/amrisi/amr-guidelines/blob/master/amr.md">Abstract Meaning Representation</a>, a technique from natural language processing.</p>

<p>This way, if user <em>Bob</em> sends a message like <em>“I am feeling sick and can’t come to the office tomorrow, can we reschedule the project meeting?”</em> on the <code>#project-lavender</code> channel we would get structured propositions such as:</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/amr.jpg" alt=""/></p>

<p>Naturally, we had to carefully batch messages and discussions to minimize costs and latency. This necessity became a major driver behind developing Outropy’s automated pipeline optimization using Reinforcement Learning.</p>

<h3 id="scaling-to-10000-users">Scaling to 10,000 Users</h3>

<p>As mentioned a few times, Throughout this whole process, it was very important to us to minimize the amount of time and energy invested in technical topics unrelated to learning about our users and how to use AI to build products.</p>

<p>We kept our assistant as a single component, with a single code base and a single container image that we deployed using AWS Elastic Container Service. Our agents were simple Python classes using SQLAlchemy and Pydantic, and we relied on FastAPI and asyncio’s excellent features to handle the load. Keeping things simple allowed us to make massive progress on the product side, to a point we went from 8 to 2,000 users in about two months.</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-mono.png" alt=""/></p>

<p>That’s when things started breaking down. Our personal daily briefings—our flagship feature—went from taking minutes to hours per user. We’d trained our assistant to learn each user’s login time and generate reports an hour before, ensuring fresh updates. But as we scaled, we had to abandon this personalization and batch process everything at midnight, hoping reports would be ready when users logged in.</p>

<p>As an early startup, growth had to continue, so we needed a quick solution. We implemented organization-based sharding with a simple configuration file: smaller organizations shared a container pool, while those with thousands of users got dedicated resources. This isolation allowed us to keep scaling while maintaining performance across our user base.</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-shards.png" alt=""/></p>

<p>This simple change gave us breathing room by preventing larger accounts from blocking smaller ones. We also added priority processing, deprioritizing inactive users and those we learned were away from work.</p>

<p>While sharding gave us parallelism, we quickly hit the fundamental scaling challenges of GenAI systems. Traditional microservices can scale horizontally because their external API calls are mostly for data operations. But in AI systems, these slow and unpredictable third-party API calls are your critical path. They make the core decisions, and this means everything is blocked until you get a response.</p>

<p>Python’s async features proved invaluable here. We restructured our agent-model interactions using <a href="https://refactoring.guru/design-patterns/chain-of-responsibility">Chain of Responsibility</a>, which let us properly separate CPU-bound and IO-bound work. Combined with some classic systems tuning—increasing container memory and <code>ulimit</code> for more open sockets—we saw our request backlog start to plummet.</p>

<p><a href="https://platform.openai.com/docs/guides/rate-limits">OpenAI rate limits</a> became our next bottleneck. We responded with a token budgeting system that <a href="https://dagster.io/glossary/data-backpressure">applied backpressure</a> while hardening our LLM calls with exponential backoffs, caching, and fallbacks. Moving the heaviest processing to off-peak hours gave us extra breathing room.</p>

<p>Our final optimization on the architectural: moving from OpenAI’s APIs to Azure’s GPT deployments. The key advantage was <a href="https://learn.microsoft.com/en-us/azure/ai-services/openai/quotas-limits">Azure’s per-deployment quotas</a>, unlike OpenAI’s organization-wide limits. This let us scale by load-balancing across multiple deployments. To manage the shared quota, we extracted our GPT calling code into a dedicated service rather than adding distributed locks</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-gpt-proxy.png" alt=""/></p>

<h3 id="the-zero-one-infinity-rule">The Zero-one-infinity rule</h3>

<p>One of my favorite adages in computer science is <a href="https://en.wikipedia.org/wiki/Zero_one_infinity_rule">“There are only three numbers: zero, one, and infinity.”</a> In software engineering, this manifests as having either zero modules, a monolith, or an arbitrary and always-growing number. As such, extracting the <code>GPTProxy</code> as our first remote service paved the way for similar changes.</p>

<p>The most obvious opportunity to simplify our monolith and squeeze more performance from the system was extracting the logic that pulled data from our users’ connected productivity tools. The extraction was straightforward, except for one challenge: our event bus needed to work across services. We kept using SQLAlchemy’s event system, but replaced our simple observer loop with a proper <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">pub/sub</a> implementation using Postgres as a queue.</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-int-worker.png" alt=""/></p>

<p>This change dramatically simplified things—we should have done it from the start. It isolated a whole class of errors to a single service, making debugging easier, and let developers run only the components they were working on.</p>

<p>Encouraged by this success, we took the next logical step: extracting our agents and inference pipelines into their own component.</p>

<p><img src="https://philcalcado.com/img/building-ai-products-i/arch-agents-worker.png" alt=""/></p>

<p>This is where my familiar service extraction playbook stopped working. I’ll cover the details of our inference pipelines in the next article, but first, let’s talk about how we distributed our agents.</p>

<h3 id="agents-as-distributed-objects">Agents as Distributed Objects</h3>

<p>As successful as we were with modeling agents as objects, we’d always been wary of distributing them. My ex-colleague <a href="https://martinfowler.com/bliki/FirstLaw.html">Martin Fowler’s First Law of Distributed Objects</a> puts it best: <strong>don’t</strong>.</p>

<p>Still, I think that <a href="https://martinfowler.com/articles/distributed-objects-microservices.html">Martin’s “exception” for microservices</a> applies just as well for agents:</p>

<blockquote>
  <p>[My objection is that] although you can encapsulate many things behind object boundaries, you can’t encapsulate the remote/in-process distinction. An in-process function call is fast and always succeeds […] Remote calls, however, are orders of magnitude slower, and there’s always a chance that the call will fail due to a failure in the remote process or the connection.</p>
</blockquote>

<p>The problem with the distributed objects craze of the 90s was its promise that fine-grained operations—like iterating through a list of <code>user</code> objects and setting <code>is_enabled</code> to false—could work transparently across processes or servers. Microservices and agents avoid this trap by exposing coarse-grained APIs specifically designed for remote calls and error scenarios.</p>

<p>We kept modeling our agents as objects even as we distributed them, just using <a href="https://en.wikipedia.org/wiki/Data_transfer_object">Data Transfer Objects</a> for their APIs instead of domain model objects. This worked well since not everything needs to be an object. Inference pipelines, for instance, are a poor candidate for object orientation and benefit from different abstractions.</p>

<p>At this stage, our system consisted of multiple instances of a few docker images on ECS. Each container exposed FastAPI HTTP endpoints, with some continuously polling our event bus.</p>

<p>This model broke down when we added backpressure and <a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/application-resiliency-patterns">resilience patterns</a> to our agents. We faced new challenges: what happens when the third of five LLM calls fails during an agent’s decision process? Should we retry everything? Save partial results and retry just the failed call? When do we give up and error out?”</p>

<p>Rather than build a custom orchestrator from scratch, we started exploring existing solutions to this problem.</p>

<p>We first looked at ETL tools like Apache Airflow. While great for data engineering, Airflow’s focus on stateless, scheduled tasks wasn’t a good fit for our agents’ stateful, event-driven operations.</p>

<p>Being in the AWS ecosystem, we looked at Lambda and other serverless options. But while serverless has evolved significantly, it’s still optimized for stateless, short-lived tasks—the opposite of what our agents need.</p>

<p>I’d heard great things about Temporal from my previous teams at DigitalOcean. It’s built for long-running, stateful workflows, offering the durability and resilience we needed out of the box. The multi-language support was a bonus, as we didn’t want to be locked into Python for every component.</p>

<p>After a quick experiment, we were sold. We migrated our agents to run all their computations through Temporal workflows.</p>

<p>Temporal’s core abstractions mapped perfectly to our object-oriented agents. It splits work between side-effect-free workflows and flexible activities. We implemented our agents’ main logic as Workflows, while tool and API interactions—like AI model calls—became Activities. This structure let Temporal’s runtime handle retries, durability, and scalability automatically.</p>

<p>The framework wasn’t perfect though. Temporal’s Python SDK felt like a second-class citizen—even using standard libraries like Pydantic was a challenge, as the framework favors data classes. We had to build quite a few converters and exception wrappers, but ultimately got everything working smoothly.</p>

<p>Temporal Cloud was so affordable we never considered self-hosting. It just works—no complaints. For local development and builds, we use their Docker image, which is equally reliable. We were so impressed that Temporal became core to both our inference pipelines and Outropy’s evolution into a developer platform!</p>

<p>Stay tuned for a deeper dive into Temporal and inference pipelines in the next installment of this series!</p>

  </article>

</div>

      </div>
    </div></div>
  </body>
</html>
