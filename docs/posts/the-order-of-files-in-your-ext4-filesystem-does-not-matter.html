<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thewisenerd.com/blog/ext4-readdir/">Original</a>
    <h1>The order of files in your ext4 filesystem does not matter</h1>
    
    <div id="readability-page-1" class="page">
<a href="https://vrklovespaper.substack.com/">home</a>
<header id="title-block-header">

<p>2025-04-06</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#tldr" id="toc-tldr">tl;dr</a></li>
<li><a href="#red-herring---buildah-squashing-layers-by-default" id="toc-red-herring---buildah-squashing-layers-by-default">1. red
herring - buildah squashing layers by default</a></li>
<li><a href="#red-herring---overlayfs-layer-order" id="toc-red-herring---overlayfs-layer-order">2. red herring - overlayfs
layer order</a></li>
<li><a href="#getting-side-tracked-with-layer-extraction" id="toc-getting-side-tracked-with-layer-extraction">3. getting
side-tracked with layer extraction</a></li>
<li><a href="#the-oh-f-sync-moment" id="toc-the-oh-f-sync-moment">4. the
oh “f-(sync)” moment</a></li>
<li><a href="#hex-editing-block-image-files" id="toc-hex-editing-block-image-files">5. hex-editing block image
files</a></li>
<li><a href="#closing-thoughts" id="toc-closing-thoughts">6. closing
thoughts?</a>
<ul>
<li><a href="#wait-what-actually-broke-though" id="toc-wait-what-actually-broke-though">6.1. wait, what actually broke
though?</a></li>
</ul></li>
</ul>
</nav>
<p>the title is a cheeky reference to something at the front page of the
orange site today<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>i don’t want to be misleading here; glob order in bash is
“alphanumeric”-ish.</p>
<p>this is more about documenting a wierd bug we encountered recently
after a node image patch update, which in-turn caused a multi-hour
outage since we could not get ahead of it in time.</p>
<p>we have JVM workloads on production, with dockerfiles that look like
this.</p>
<pre><code>CMD [&#34;java&#34;, &#34;-cp&#34;, &#34;/jars/*&#34;, &#34;-server&#34;, ..., &#34;com.acmecorp.app.Application&#34;]</code></pre>
<p>the wildcard here, is not a glob, since the thing is not running in a
bash shell. the actual argument value the JVM receives is
<code>&#34;/jars/*&#34;</code>, and in turn decides to be helpful, and expand
the wildcard anyway<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>in posix systems, this happens to use the <code>readdir</code>
syscall<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<h2 id="tldr">tl;dr</h2>
<ul>
<li><code>overlayfs</code> delegates <code>readdir</code> to the
underlying filesystem</li>
<li>the underlying filesystem happened to be an <code>ext4</code></li>
<li><code>ext4</code> readdir optimizes by caching the entries of a
directory in a “hashed b-tree” with a specific “directory hash
seed”</li>
<li>the directory hash seed changed with the node image patch update,
causing the jar order in the classpath to change, causing an uncaught
throwable leading to “stuck” application initialization</li>
</ul>
<p>the rest of the blog is about how i went about trying to figure out
how we got here.</p>
<h2 id="red-herring---buildah-squashing-layers-by-default">1. red
herring - buildah squashing layers by default</h2>
<p>with a recent overhaul a couple years ago of our CI/CD setup (from
Jenkins to GHA), and a couple other reasons, we switched from
<code>docker</code> to <code>buildah</code> for building the container
images, and we noticed that some of the <code>buildah</code> built
images would not start up.</p>
<p>we were copying the files into the container image in a specific
order, to possibly save bandwidth with ‘shared’ layers. this involved
copying jars in a specific order of “volatility” (bottom-to-top);</p>
<ol type="1">
<li>the specific project jars</li>
<li>internal dependencies’ jars</li>
<li>kotlin stdlib, and dependencies’ jars</li>
<li>other dependency jars</li>
</ol>
<p>the intent was that layers 3 and 4 would “rarely” change, and surely
this should help a bunch with bandwidth given the SHAs would be
consistent.</p>
<p>upon investigation, we identified that a critical configuration file
was being read from a jar that was not “specific project jar”, and this
in-turn was causing the application startup to misbehave.</p>
<p>as an immediate fix, the corresponding fix was made, adding
<code>--layers</code> to the <code>buildah bud</code> step.</p>
<blockquote>
<p>“buildah by default does not cache layers during building of the
image, and hence ends up squashing the layers. When using wildcard to
set the classpath for java, the order of listing the jars changes and
hence causes jars other than the project jar to have higher priority in
the class path.</p>
</blockquote>
<blockquote>
<p>This PR implements usage of the –layers flag , which re-enables
caching of layers and fixes the issues with classpath jar
priorities.”</p>
</blockquote>
<p>little did we realize that this didn’t do much; but it seemed to fix
the issue of the configuration file being picked up from the incorrect
jar; and we went our merry way.</p>
<h2 id="red-herring---overlayfs-layer-order">2. red herring - overlayfs
layer order</h2>
<p>this was an understanding gap, where i had always been under the
impression that a <code>readdir</code> over an overlayfs, then the
iteration order would follow the order of the overlayfs directory
stacking order.</p>
<p><em>sidenote: containers use overlayfs and basically “stack” the
image layers on top of one-another; and they use something called
“white-outs” to handle deletion. one of the reasons why, if there’s a
lot of white-outs, it’s terrible from a perf standpoint, and squashing
layers is supposedly better for performance, or something, idk.</em></p>
<p>performing the most basic of tests, made me realize this is not the
case. the only guarantee is that an “upper” layer’s files will override
the “lower” layer’s files, but nothing about the iteration order of
overlayfs layers.</p>
<p>this can be easily proven by the following example</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>uname</span> <span>-r</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span># 6.1.0-18-amd64</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> l0 l1 l2 work merged</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>for</span> d <span>in</span> l0 l1 l2<span>;</span> <span>do</span> <span>for</span> file <span>in</span> <span>$(</span><span>seq</span> 10 12<span>)</span><span>;</span> <span>do</span> <span>touch</span> <span>$d</span>/<span>$d</span>-<span>$file</span><span>;</span> <span>done</span><span>;</span> <span>done</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>sudo</span> mount <span>-t</span> overlay overlay <span>-o</span> lowerdir=./l0:./l1,upperdir=./l2,workdir=./work ./merged/</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>ls</span> <span>-1U</span> ./merged/ <span># list unsorted, basically think readdir</span></span></code></pre></div>
<p>my previous understanding, or at least the understanding as per the
“fix” we put in the previous section, was that the order expected here
is <code>l2,l1,l0</code>,</p>
<p>but the actual output, of <code>ls -1U ./merged/</code> is,
<code>l1,l2,l0</code>.</p>
<pre><code>l1-11
l1-10
l1-12
l2-10
l2-12
l2-11
l0-10
l0-12
l0-11</code></pre>
<p>safe to say, while overlayfs guarantees that <code>upper</code>
directories’ files shall overwrite the <code>lower</code> directories
files, it does not guarantee that the directory traversal order shall be
the same way.</p>
<p>around here, I validated that a segment of <code>ls -1U</code> on the
merged “overlayfs” folder matched the <code>ls -1U</code> order on a
“lower” directory on the underlying ” ext4”, and decided to focus my
efforts on figuring out what was happening there.</p>
<h2 id="getting-side-tracked-with-layer-extraction">3. getting
side-tracked with layer extraction</h2>
<p>thinking that the layer extraction logic could’ve changed (why??), i
got to trying to get the exact tar blobs from the image.</p>
<p>this involved,</p>
<ol type="1">
<li>getting an auth token for Azure Container Registry, and exchanging
it for a token for the specific container image</li>
<li>fetching the manifest for the image
<code>/v2/{repo}/manifests/{version}</code></li>
<li>iterating over the layers <code>.fsLayers[].blobSum</code> and
fetching the tar blobs</li>
</ol>
<p>fetching the tar blob, and replicating the containerd layer
extraction logic<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> (just the golang native
<code>&#34;archive/tar&#34;</code> bits), the subsequent <code>ls -1U</code>
output was basically the same, when running on the same nodepool.</p>
<p>was the inode order different? nope. sequential inodes, per order in
the tar archive.</p>
<h2 id="the-oh-f-sync-moment">4. the oh “f-(sync)” moment</h2>
<p>thinking, what if fsync is re-ordering blocks when flushing unwritten
blocks to disk, i enabled tracing but the logs were too much.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>echo</span> 1 <span>&gt;</span> /sys/kernel/debug/tracing/events/ext4/enable</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>cat</span> /sys/kernel/debug/tracing/trace <span># too noisy,</span></span></code></pre></div>
<p>all i had were log lines, which i did not understand, and i was not
able to effectively filter the log lines for my specific operations
(because shared root disk). not in the mood to sit and figure out ebpf,
i decided to create a loopback device and <code>| grep</code> for that
specific loopback device instead.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>cat</span> /sys/kernel/debug/tracing/trace <span>|</span> <span>grep</span> <span>-v</span> <span>&#39;dev 8,1&#39;</span> </span></code></pre></div>
<p>running the same <code>tar</code> extraction golang program inside
the loopback device, the <code>ls -1U</code> order turned out different.
wtf. re-ran the extraction in another folder, the order was the
same;</p>
<p>creating another loopback device, the <code>ls -1U</code> order
changed yet again.</p>
<p>so, within a filesystem, the <code>ls -1U</code> order is consistent
after extraction.</p>
<h2 id="hex-editing-block-image-files">5. hex-editing block image
files</h2>
<p>with <code>debugfs disk.img</code>, and running <code>stats</code>,
there were just two possibly changing parameters, the “Filesystem UUID”,
and a “Directory Hash Seed”.</p>
<p>the file system UUID could be easily specified at
<code>mkfs.ext4</code> with the <code>-U</code> parameter,</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>mkfs.ext4</span> <span>-U</span> {uuid} disk2.img</span></code></pre></div>
<p>but alas, running the tar extraction test, on two ext4 partitions
with the same UUID, still had different <code>ls -1U</code> order.</p>
<p>so, deciding to go after the “Directory Hash Seed” next, I realized
there was no easy way to set this parameter with <code>mkfs.ext4</code>,
so finding the offset of the directory hash seed and hex-editing it in
the block file was “the only way forward”.</p>
<p>this was “accomplished” with a pretty dumb combination of
<code>xxd</code>, <code>grep -ob</code> and
<code>printf | dd</code>.</p>
<p>the <code>ext4</code> header blocks also have a crc checksum, which
<code>debugfs</code> cribs about; but it also gives you the “expected”
value, so removing that “error” is just another hex edit away.</p>
<p>mounting the newly modified disk image, and re-running the tar
extraction test, the order matched!</p>
<h2 id="closing-thoughts">6. closing thoughts?</h2>
<p>I had perused the ext4 <code>readdir</code> implementation<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> somewhere when dealing with
overlayfs delegating <code>readdir</code> to the underlying filesystem,
but reading is reading, and reading is lossy.</p>
<p>ext4 has this thingy called “h-tree indexing” and that is something
that needs to be specifically enabled, and as far as i’d checked, did
NOT have them enabled.</p>
<p>i was assuming that <code>is_dx_dir</code> would exit pretty much
immediately, but upon closer examination (after hex-editing block image
files, ofc), i realize that <code>is_dx_dir</code> and
<code>ext4_dx_dir</code> are pretty much the happy-path, since the
<code>is_dx_dir</code> impl is “exclude-specific” and not
“include-specific”.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>int</span> ext4_readdir<span>(</span><span>struct</span> file <span>*</span>file<span>,</span> <span>struct</span> dir_context <span>*</span>ctx<span>)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>is_dx_dir<span>(</span>inode<span>))</span> <span>{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        err <span>=</span> ext4_dx_readdir<span>(</span>file<span>,</span> ctx<span>);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span>if</span> <span>(</span>err <span>!=</span> ERR_BAD_DX_DIR<span>)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span>return</span> err<span>;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span>// ...</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span></code></pre></div>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>/**</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span> * is_dx_dir() - check if a directory is using htree indexing</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span> * </span><span>@inode:</span><span> directory inode</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span> *</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span> * Check if the given dir-inode refers to an htree-indexed directory</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span> * (or a directory which could potentially get converted to use htree</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span> * indexing).</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span> *</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span> * Return 1 if it is a dx dir, 0 if not</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span> */</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>int</span> is_dx_dir<span>(</span><span>struct</span> inode <span>*</span>inode<span>)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> super_block <span>*</span>sb <span>=</span> inode<span>-&gt;</span>i_sb<span>;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>ext4_has_feature_dir_index<span>(</span>inode<span>-&gt;</span>i_sb<span>)</span> <span>&amp;&amp;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span>((</span>ext4_test_inode_flag<span>(</span>inode<span>,</span> EXT4_INODE_INDEX<span>))</span> <span>||</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>         <span>((</span>inode<span>-&gt;</span>i_size <span>&gt;&gt;</span> sb<span>-&gt;</span>s_blocksize_bits<span>)</span> <span>==</span> <span>1</span><span>)</span> <span>||</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>         ext4_has_inline_data<span>(</span>inode<span>)))</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>1</span><span>;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>0</span><span>;</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>actually having a debugger to step through the kernel functions
would’ve been helpful, but that’s an adventure for another day.</p>
<h3 id="wait-what-actually-broke-though">6.1. wait, what actually broke
though?</h3>
<p>we had three Bouncy Castle “provider” dependencies, which were on a
single overlayfs layer.</p>
<pre><code>bcprov-jdk14-1.38.jar
bcprov-jdk15on-1.55.jar
bcprov-jdk18on-1.75.jar</code></pre>
<p>there was a client library that needed a Bouncy Castle “provider”
with a version “jdk15”+ as the client initialization used specific
properties from a class, and those properties were only available in
“jdk15”+.</p>
<p>up until the node image update, we “fortunately” had node images with
directory hash seeds ordering “jdk15” or “jdk18” <em>before</em>
“jdk14”.</p>
<p>after the node image patch update, the directory seed caused “jdk14”
to be hashed with a value, causing it to come up earlier than “jdk15” or
“jdk18” in <code>readdir</code>.</p>
<p>and this caused an uncaught “NoSuchFieldError” in an initializer
thread, causing the client initialization to “get stuck”. newer pods
thus, could not initialize.</p>
<p>bye now.</p>
<section id="footnotes" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1"><p><a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/OpenSSHConfigOrderMatters">The
order of files in /etc/ssh/sshd_config.d/ matters (and may surprise
you)</a><a href="#fnref1" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://github.com/openjdk/jdk8u-dev/blob/d358ad0639a433254938d85e94c13921a4254e07/jdk/src/share/bin/wildcard.c#L410"><code>JLI_WildcardExpandClasspath</code></a><a href="#fnref2" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://github.com/openjdk/jdk8u-dev/blob/d358ad0639a433254938d85e94c13921a4254e07/jdk/src/share/bin/wildcard.c#L201"><code>WildcardIterator_next</code>
&gt; <code>readdir</code></a><a href="#fnref3" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://github.com/containerd/containerd/blob/b22a302a75d9a7d7955780e54cc5b32de6c8525d/pkg/archive/tar.go#L188">containerd/pkg/archive/tar.go</a><a href="#fnref4" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://github.com/torvalds/linux/blob/v6.14/fs/ext4/dir.c#L126">fs/ext4/dir.c</a><a href="#fnref5" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<hr/>
<a href="https://vrklovespaper.substack.com/">home</a>


</div>
  </body>
</html>
