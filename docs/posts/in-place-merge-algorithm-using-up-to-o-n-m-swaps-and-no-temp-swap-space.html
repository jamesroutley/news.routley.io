<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gvelim.github.io/CSX0003RUST/merge_in_place.html">Original</a>
    <h1>In-place merge algorithm using up to O(n&#43;m) swaps and no temp swap space</h1>
    
    <div id="readability-page-1" class="page">
        <!-- Provide site root to javascript -->
        

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            
            
        </nav>

        <div id="page-wrapper">

            <div class="page">
                
                

                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        
<h2 id="general-approach"><a href="#general-approach">General Approach</a></h2>
<p>In an &#34;In place&#34; merge of two ordered arrays it is always required to maintain a pivot between merged and unmerged sub-arrays as we go over the process of</p>
<ol>
<li>Use comparison indexes <code>(c,j)</code> to find the smallest element between (a) the left and (b) right ordered arrays</li>
<li>Swap the next smallest element of the left and right sub-arrays against a pivot position <code>(p)</code></li>
<li>Repeat until we&#39;ve exhausted comparing and swapping of all elements</li>
</ol>
<pre><code>Start                               Finish
==============================     ==========================
Left array       Right array       Ordered elements across arrays
+---+---+---+    +---+---+---+     +---+---+---+  +---+---+---+
| 1 | 3 | 5 | &lt;&gt; | 2 | 4 | 6 | =&gt;  | 1 | 2 | 3 |  | 4 | 5 | 6 |
+---+---+---+    +---+---+---+     +---+---+---+  +---+---+---+
  c                j

Generic Approach of using a pivot to separate 
&#34;merged&#34; from &#34;yet to be merged&#34; regions
=============================================

         | left        Right  |
         | [c]         [j]    |
+---+---+|+---+---+   +---+---+ 
| 1 | 2 ||| 3 | 5 |   | 4 | 6 | 
+---+---+|+---+---+   +---+---+ 
Merged   |     Unmerged region  
region   p: Pivot
</code></pre>
<h2 id="challenge"><a href="#challenge">Challenge</a></h2>
<h3 id="taking-a-naive-first-step"><a href="#taking-a-naive-first-step">Taking a naive first step</a></h3>
<p>By trying to swap the smallest element of the two arrays with the pivot we quickly realise that things are getting out of control very soon. For example,</p>
<pre><code>                              c  j  p   [c] &gt; [j]  Action
 c/p             j            =======   =========  ========================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1  1    1     2   left swap(c,p) incr(c,p)
     c/p         j                  
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1  2    3     2   right swap(j,p) incr(j,p)
      c   p          j                   
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  2  2  3    2!!   4   Fail: We lost control here! 2 isn&#39;t part of the left array
</code></pre>
<p>At this stage our partitioned region is left of <code>p</code> and equal to <code>[1,2]</code> while the unmerged region is <code>[(5!!,3),(4,6)]</code> which is clearly <strong><em>out-of-order</em></strong> and the result from then on is unpredictable. During the 2nd iteration, the left comparison index <code>[c]</code> points to a <code>2</code> rather <code>3</code> which is now at the 4th position in the right array, or the 2nd position in the unmerged partition.
Therefore, we need to find a way to maintain a solid comparison index reference <code>[c]</code> for the left array while we iterate through</p>
<h2 id="problem-solution"><a href="#problem-solution">Problem Solution</a></h2>
<h3 id="canceling-the-rotation-during-right-swaps"><a href="#canceling-the-rotation-during-right-swaps">Canceling the Rotation during right swaps</a></h3>
<p>It becomes obvious that during the right swap operation our left array is rotated left as seen below</p>
<pre><code>                              c  j  p   [c] &gt; [j]  Action
 c/p             j            =======   =========  ========================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1  1    1     2   left swap(c,p) incr(c,p)
     c/p         j                   
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1  2    3     2   right swap(j,p) incr(j,p)
      c   p          j                  
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  &lt;-- Here instead of [3,5] we have [5,3]
</code></pre>
<p>Moreover, the partition point <code>[p]</code> more or less points to the where the left comparison index <code>[c]</code> should have been, that is, the unmerged partition. Let&#39;s try this time with</p>
<ul>
<li>reverting the rotation effect after each right swap hence bringing the left unmerged part back to order</li>
<li>using <code>[c]</code> as both the partition and the left comparison index</li>
</ul>
<pre><code>                              c  j    [c] &gt; [j]  Action
  c              j            ====    =========  ============================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1     1     2   No swap, just incr(c)
      c          j                   
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1     3     2   right swap(j,c), incr(c,j)
          c          j 
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  3  2               rotate right by 1, from c to j excluded 
          c          j                   
[ 1 , 2 ,(3 ]  [ 5),(4 , 6)]  3  2     3     4   No swap, just incr(c)
                 c   j                   
[ 1 , 2 , 3 ]  [(5),(4 , 6)]  4  2     5     4   right swap(j,c), incr(c,j)
                     c   j                   
[ 1 , 2 , 3 ]  [ 4 ,(5),(6)]  5  3               rotate right by 1, from c to j excluded 
                     c   j                   
[ 1 , 2 , 3 ]  [ 4 ,(5),(6)]  5  3     5     6   No swap, just incr(c) 
                        c/j                   
[ 1 , 2 , 3 ]  [ 4 , 5 ,(6)]  6  3               c == j (!) nothing more to compare... we&#39;ve finished !!
</code></pre>
<p>Nice! It works, but only on paper. Although we overcame the conflict between pivot <code>[p]</code> and left comparison index <code>[c]</code> the obvious issues here is that our indexing across the two arrays is broken. Definitely <code>6 == 3</code> isn&#39;t correct, because <code>[c]</code> has to operate in both arrays while <code>[j]</code> operates solely in the right array.</p>
<p>However, we do know that mergesort, performs merge on memory adjacent array segments hence this can be mitigated by reconstructing the parent array out of the two fragments so that, <code>working array = *left_array[0] .. *left_array[0] + (left_array.len() + right_array.len())</code></p>
<pre><code>Left Array    Right Array
+---+---+---+ +---+---+---+     
| 2 | 4 | 6 | | 1 | 3 | 5 |   Adjacent array segments
+---+---+---+ +---+---+---+     
  |   |   |    |   |   |
+---+---+---+---+---+---+     
|&amp;2 |&amp;4 |&amp;6 |&amp;1 |&amp;3 |&amp;5 |   Memory reconstructed and operated as a continuous array i.e.
+---+---+---+---+---+---+   we recast a slice with start pointer left_array[0] 
  c           j             and length = left (len + right len)*sizeof()

</code></pre>
<p>Let&#39;s repeat the example but through the memory reconstructed array.</p>
<pre><code>                           c  j    [c] &gt; [j]  Action
  c           j            ====    =========  ============================
[(1 , 3 , 5),(2 , 4 , 6)]  1  4     1     2   No swap, just incr(c)
      c       j                   
[ 1 ,(3 , 5),(2 , 4 , 6)]  2  4     3     2   right swap(j,c), incr(c,j)
          c       j 
[ 1 , 2 ,(5 , 3),(4 , 6)]  3  5               rotate right by 1, from c to j excluded
          c       j                   
[ 1 , 2 ,(3 , 5), 4 , 6)]  3  5     3     4   No swap, just incr(c)
              c   j                   
[ 1 , 2 , 3 ,(5),(4 , 6)]  4  6     5     4   right swap(j,c), incr(c,j)
                  c   j                   
[ 1 , 2 , 3 , 4 ,(5),(6)]  5  6               rotate right by 1, from c to j excluded 
                  c   j                   
[ 1 , 2 , 3 , 4 ,(5),(6)]  5  6     5     6   no swap, just incr(c) 
                     c/j                   
[ 1 , 2 , 3 , 4 , 5 , 6 ]  6  6               c == j (!) nothing more to compare... we&#39;ve finished !!
</code></pre>
<p>So far so good. We have a working approach that however is dependent on adjacent-to-memory arrays for achieving the rotations</p>
<p>However, there are some things we need to be aware of</p>
<ol>
<li>Rotations won&#39;t work between non-adjacent arrays without additional code complexity to deal with the gap</li>
<li>Rotation will be computationally significant against large datasets</li>
</ol>
<p>So can we do better without need for rotations and non-adjacent to memory arrays ?</p>
<p>It appears that we can. <code>Virtual Slice</code> &amp; <code>Index Reflector</code> come to the rescue.</p>
<h2 id="virtual-slice---continuous-access-over-array-fragments"><a href="#virtual-slice---continuous-access-over-array-fragments">Virtual Slice - continuous access over array fragments</a></h2>
<p>A <code>VirtualSlice</code> is composed out of one or more array fragments, adjacent to memory or not, and enables transparently operating over the <strong>attached</strong> array fragments.</p>
<pre><code>Left Array       Right Array
+---+---+---+    +---+---+---+     
| 2 | 4 | 6 | &lt;&gt; | 1 | 3 | 5 |   Non-adjacent array segments
+---+---+---+    +---+---+---+     
  c       ^        j
          |__
       ...  | ...
+----+----+----+----+----+----+
| &amp;2 | &amp;4 | &amp;6 | &amp;1 | &amp;3 | &amp;5 |  Array of mutable references : Virtual Slice
+----+----+----+----+----+----+  i.e. &amp;2 = pointer/reference to left array[0]
 p/c             j
</code></pre>
<p>The VirtualSlice enables transparent operation over the array fragments, hence enable us to retain index consistency, we still need to tackle eliminating the costly rotations. For more detail go to the <a href="https://gvelim.github.io/CSX0003RUST/merge_sequencial_access.html">internals and sequential access section</a> </p>
<h2 id="index-reflector---from-absolute-to-derived-indexing"><a href="#index-reflector---from-absolute-to-derived-indexing">Index Reflector - from absolute to derived indexing</a></h2>
<p>We know that <code>[c]</code> and <code>[p]</code> indexes are getting mixed up, as right swaps tend to move <code>[c]</code> non-sequentially causing left merge to go <strong><em>out-of-order</em></strong>.</p>
<p>What if we could somehow, had a way such that when incrementing <code>c</code> by <code>1</code>, <code>c</code> points to the next in &#34;logical order&#34; element of the left array, 100% of the times and irrelevant of where <code>[c]</code> is positioned within the VirtualSlice ?</p>
<p>This is where the <code>IndexReflector</code> comes handy. The <em>Index Reflector</em> becomes the <strong>absolute reference</strong> in terms of the <strong>ordered sequence</strong> that <code>c</code> &amp; <code>j</code> indexes have to follow and irrelevant of the non-sequential movement of <code>[c]</code> caused by every right swap.</p>
<pre><code>Left Array       Right Array
+---+---+---+    +---+---+---+     
| 2 | 4 | 6 | &lt;&gt; | 1 | 3 | 5 |   Non-adjacent array segments
+---+---+---+    +---+---+---+     
          ^       
          |_
       ...  | ...
+----+----+----+----+----+----+
| &amp;2 | &amp;4 | &amp;6 | &amp;1 | &amp;3 | &amp;5 |  Virtual Slice with derived indexes
+----+----+----+----+----+----+  c&#39; = Index Reflector[c], j&#39; = Index Reflector[j]
 p/c&#39;        |   j&#39;    |    |
         ... | ...     |    |
+----+----+----+----+----+----+
| 1  | 2  | 3  | 4  | 5  | 6  |  Index Reflector captures VirtualSlice&#39;s elements latest  positions against their starting position
+----+----+----+----+----+----+  i.e. if IndexReflector[3] == 4, it would imply that VirtualSlice[4] was in the 3rd position
 p&#39;/c            j               [p&#39;] = x, such that Index Reflector[x] == p, where x E {c..j} 
                                 i.e. if p == 3 given IndexReflector[x] == 3, then p&#39; == 5 if IndexReflector[5] == 3

</code></pre>
<p>In the diagram above, the Index Reflector holds the <strong>starting position</strong> of the VirtualSlice elements. Order Comparison indexes <code>[c]</code> and <code>[j]</code> are operated against the index reflector and are <strong>projected</strong> over to VirtualSlice as <code>[c&#39;]</code> and <code>[j&#39;]</code> using the transformations described in the diagram.</p>
<p>Reversely, Pivot index <code>[p]</code> is operated on the VirtualSlice and is projected over the Index Reflector as <code>[p&#39;]</code> using the transformation provided in the diagram.</p>
<p>Let&#39;s see how this is going to work; pay attention to the non-sequencial movements of <code>c&#39;</code> and <code>p&#39;</code>.</p>
<pre><code>Phase 1: Merge the two arrays until a comparison index goes out of bounds 

Left Arr      Rght Arr       VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                             c&#39;/p          j&#39;                  c/p&#39;         j                  [c&#39;] &gt; [j&#39;]
[ 5, 6, 7] &lt;&gt; [ 1, 2, 3, 4]  [(5 , 6 , 7),(1 , 2 , 3 , 4)]    [(1 , 2 , 3),(4 , 5 , 6 , 7)]      5      1     swap(j&#39;, p), swap(j, p&#39;), incr(p,j)
                                   p       c&#39;  j&#39;               c   p&#39;          j                             
[ 1, 6, 7] &lt;&gt; [ 5, 2, 3, 4]  [ 1 ,(6 , 7 , 5),(2 , 3 , 4)]    [(4 , 2 , 3),(1 , 5 , 6 , 7)]      5      2     swap(j&#39;, p), swap(j, p&#39;), incr(p,j) 
                                       p   c&#39;      j&#39;           c       p&#39;          j                             
[ 1, 2, 7] &lt;&gt; [ 5, 6, 3, 4]  [ 1 , 2 ,(7 , 5 , 6),(3 , 4)]    [(4 , 5 , 3),(1 , 2 , 6 , 7)]      5      3     swap(j&#39;, p), swap(j, p&#39;), incr(p,j)
                                          c&#39;/p         j&#39;      c/p&#39;                     j                             
[ 1, 2, 3] &lt;&gt; [ 5, 6, 7, 4]  [ 1 , 2 , 3 ,(5 , 6 , 7),(4)]    [(4 , 5 , 6),(1 , 2 , 3 , 7)]      5      4     swap(j&#39;, p), swap(j, p&#39;), incr(p,j)
                                               p       c&#39;  j&#39;   c   p&#39;                       j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 4)]      x      x     &lt;-- j&#39;/j got out of bounds ! Phase 1 completed
</code></pre>
<p>We ran-out of right array elements (<code>j</code>is over bound), which means anything below <code>[p]</code> is merged and anything including and above <code>[p]</code> just needs to be carried over. But we cannot complete as we have <strong><em>out-of-order</em></strong> elements in the unmerged partition.</p>
<p>Index Reflector to the rescue!</p>
<p>The index reflector tells us exactly what we need to do to complete the work. if you look at <code>[c .. left_array.len()]</code> / <code>[7,5,6]</code> in the index reflector, it tells us</p>
<ol>
<li>next comes the 7th element from virtual slice,</li>
<li>then the 5th element from virtual slice, and</li>
<li>finally, the 6th element from virtual slice</li>
</ol>
<p>So if we get the remainder from the VirtualSlice <code>[6,7,5]</code> and apply the above steps we&#39;ll get <code>[5,6,7]</code>. Nice !! Let&#39;s see it in action.</p>
<pre><code>Phase 2: Finishing off the remainder unmerged partition

Left Arr      Right Arr      VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                                               p       c&#39;  j&#39;   c   p&#39;                       j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 4)]      x      x     swap(c&#39;, p), swap(c, p&#39;) incr(i,c)
                                                   p   c&#39;  j&#39;       c   p&#39;                   j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 7, 6]  [ 1 , 2 , 3 , 4 , 5 ,(7 , 6)]    [(5 , 7 , 6),(1 , 2 , 3 , 4)]      x      x     swap(c&#39;, p), swap(c, p&#39;) incr(i,c)
                                                     c&#39;/p  j&#39;          c/p&#39;                  j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 6, 7]  [ 1 , 2 , 3 , 4 , 5 , 6 ,(7)]    [(5 , 6 , 7),(1 , 2 , 3 , 4)]      x      x     &lt;-- We finished ! c&#39; and p are both on the last position
</code></pre>
<p>Phase 2 is now complete. <strong>As if by magic</strong> everything is now in position and ordered after <code>O(n+m)</code> iterations</p>
<h2 id="useful-index-reflector-properties"><a href="#useful-index-reflector-properties">Useful Index Reflector Properties</a></h2>
<ol>
<li>At completion the Index Reflector <strong>reflects</strong> the final position per element and given its starting order i.e the 4th element in VirtualSlice ends up in the 1st position, the 1st in the 5th, and so on</li>
</ol>
<pre><code>  Left Arr      Right Arr      VirtualSlice                     Index Reflector                  
  =========     ===========    =============================    =============================    
                               c&#39;/p          j&#39;                  c/p&#39;         j                  
  [ 5, 6, 7] &lt;&gt; [ 1, 2, 3, 4]  [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]    [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]      
  ...
  ...
                                                        p/c&#39; j&#39;          c/p&#39;                  j                             
  [ 1, 2, 3] &lt;&gt; [ 4, 5, 6, 7]  [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]    [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]      
</code></pre>
<ol start="2">
<li><code>[c]</code> index is bound by <code>[0 .. left array.len]</code> range</li>
<li><code>[p&#39;]</code> index is bound by <code>[c .. left array.len]</code> range</li>
<li>Always <code>[j&#39;] == [j]</code></li>
</ol>
<h2 id="optimisations--other-uses"><a href="#optimisations--other-uses">Optimisations &amp; other uses</a></h2>
<ol>
<li>Given the non-sequential movement of <code>p&#39;</code> and for less than 500 elements we can map <code>p -&gt; p&#39;</code> by searching serially within the <code>[c .. left_array.len()]</code> range. However, this approach and under larger sets, has O(n^2) performance hence an alternative is to forward pre-calculate <code>p&#39;</code> during each swap. This eliminates the nested search loop which results to 10x increase of performance (current implementation)</li>
<li>Given the 4th property we can reduce the Index Reflector to <code>left_array.len()</code> reducing the memory requirementsfrom 2(n+m) to (2n+m) in case of mergesort</li>
<li>In addition to 4th property and given the arrays are adjacent the VirtualSlice becomes a pointer to a reconstructed parent array hence the overall memory impact becomes O(n) * sizeof(usize)</li>
<li>Given the 1st property we can
<ol>
<li>Develop a &#34;sort mask array&#34; through which we can access the source array segments in order and without the need of permanently mutating them
<ol>
<li><a href="https://gvelim.github.io/CSX0003RUST/merge_lazy.html">VirtualSlice::merge_shallow</a></li>
</ol>
</li>
<li>Such &#34;sort mask&#34; can be imposed or &#34;played onto&#34; the source segments hence mutating them only when is needed
<ol>
<li><a href="https://gvelim.github.io/CSX0003RUST/merge_lazy.html">VirtualSlice::impose_shallow_merge</a></li>
</ol>
</li>
</ol>
</li>
</ol>

                    </main>

                    <nav aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="https://gvelim.github.io/CSX0003RUST/merge.html" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i></i>
                            </a>
                            <a rel="next" href="https://gvelim.github.io/CSX0003RUST/merge_sequencial_access.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i></i>
                            </a>
                        
                    </nav>
                </div>
            </div>

            <nav aria-label="Page navigation">
                    <a rel="prev" href="https://gvelim.github.io/CSX0003RUST/merge.html" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i></i>
                    </a>
                    <a rel="next" href="https://gvelim.github.io/CSX0003RUST/merge_sequencial_access.html" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i></i>
                    </a>
            </nav>

        </div>

        
        
        
        
        
        
        

        <!-- Custom JS scripts -->
    

</div>
  </body>
</html>
