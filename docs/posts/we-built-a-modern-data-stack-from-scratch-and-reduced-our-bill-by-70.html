<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jchandra.com/posts/data-infra/">Original</a>
    <h1>We built a modern data stack from scratch and reduced our bill by 70%</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Building and managing a data platform that is both scalable and cost-effective is a challenge many organizations face. We managed an extensive data lake with a lean data team and reduced our <code>Infra Cost by 70%</code>.</p><p>This article explores how we built it and the lessons we learned. Hopefully, some of these insights will be useful (or at least interesting!) for your own data platform projects, regardless of your team size.</p><h2>Our Data Landscape<span><a href="#our-data-landscape" aria-label="Anchor">#</a></span></h2><p>We are a fintech startup helping SMEs raise capital from our platform where we provide diverse financial products ranging from Term Loan, Revenue Based Financing to Syndication, we face one unique data challenge: <strong>Our data comes from everywhere</strong>.</p><p>Our clients often manage their financial information in different ways, leading to data sources ranging from the structured data in our MongoDB and PostgreSQL databases to the semi-structured data found in marketplaces, Google Sheets, and various payment platforms.</p><p>Storing the data was only part of the equation. We needed to process and analyse it at scale, transform it into actionable intelligence that drive key business decisions. Our data and BI analysts play a crucial role in this process, requiring robust data tooling to effectively access, analyze, and visualize the data. From lead generation and risk analysis to payment alerting and reconciliation, data is at the heart of our operations, and our data platform needs to support these critical workflows throughout the entire application lifecycle.</p><h2>Our Initial Data Platform<span><a href="#our-initial-data-platform" aria-label="Anchor">#</a></span></h2><figure><img loading="lazy" src="https://jchandra.com/images/Initial_Data_Infra.png" alt="Initial Data Platform"/></figure><p>Our initial data platform was built on a foundation of tools that addressed our early-stage needs, but quickly became insufficient as we scaled. Data ingestion was primarily handled by Hevo, which leveraged Debezium Slots for capturing CDC events from our databases and direct integration with Google Sheets. While Hevo simplified initial data capture, its data transformation capabilities were limited, primarily offering basic functionality like data key deletion and value formatting.</p><p>Revenue data from marketplaces was ingested through an RPA-driven process, with data being directly ingested into Google BigQuery (GBQ) as raw dumps. While this approach was simpler, it came with high costs, as GBQ is priced based on the amount of data queried. Given that the data sizes for each table were in the order of 200-500GBs, the costs quickly escalated.</p><p>Furthermore, a significant portion of queries were executed directly against our live OLTP tables. This direct querying increased the load on our production databases, impacting performance and further contributing to cost increases.</p><p>In the early days, with a smaller team and less data, these engineering decisions were pragmatic and likely solved the immediate problems. However, as our company grew and data demands increased, it became clear that this solution was not scalable and could not meet our evolving requirements. This realization led to the creation of a new data team, with myself and my manager, Aankesh <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, tasked with building a more robust and scalable data platform. We needed a platform that could handle the volume, variety, and complexity of our data, while also providing the necessary tools for efficient analysis and decision-making.</p><h2>Our New Data Platform<span><a href="#our-new-data-platform" aria-label="Anchor">#</a></span></h2><p>We implemented an ELT stack for our new data platform, leveraging cheap storage to prioritize raw data ingestion and subsequent in-warehouse transformations. We also strategically reused existing software components where they weren’t being fully utilized, further optimizing our development efforts.</p><p>The platform’s development was segmented into two layers: Data Ingestion and Storage &amp; Compute.</p><h3>Data Ingestion Layer<span><a href="#data-ingestion-layer" aria-label="Anchor">#</a></span></h3><figure><img loading="lazy" src="https://jchandra.com/images/Data_Ingestion.png" alt="Data Ingestion"/></figure><ul><li><strong>Debezium:</strong> Implemented for capturing CDC events from PostgreSQL and MongoDB, enabling real-time data replication.</li><li><strong>Airflow:</strong> Utilized to orchestrate manual data ingestion from sources like Google Sheets and CSV files.</li><li><strong>Kafka &amp; Kafka Connect:</strong><ul><li>Formed the core of our streaming data pipeline.</li><li>Leveraged custom Single Message Transforms (SMTs) for specialized transformations.</li><li>Self-managed and hosted Kafka Connect cluster for fine-grained control.</li><li>Utilized <strong>managed Confluent Cloud</strong> for our Kafka Connect cluster, leveraging our existing infrastructure used for application pub-sub systems.</li></ul></li><li><strong>Sink Connectors:</strong> Employed Kafka Connect Sink Connectors to deliver data to downstream destinations, including:<ul><li>File storage (S3).</li><li>PostgreSQL for data replication.</li></ul></li></ul><h3>Storage &amp; Compute Layer<span><a href="#storage--compute-layer" aria-label="Anchor">#</a></span></h3><figure><img loading="lazy" src="https://jchandra.com/images/Data_Platform.png" alt="Data Processing"/></figure><ul><li><strong>Data Storage</strong><ul><li>All raw data, ingested from our diverse sources, is persisted in file storage (S3) in Parquet format. This choice offers significant advantages: Parquet’s columnar storage optimizes query performance, and S3 provides cost-effective and highly durable storage.</li></ul></li><li><strong>Data Transformation and Quality</strong><ul><li>Airflow orchestrates dbt runs, enabling us to build modular, testable, and maintainable data transformation pipelines. dbt’s transformation logic, expressed as SQL, simplifies the process and allows for version control.</li><li>Great Expectations is integrated into our pipelines to ensure comprehensive data validation checks at every stage. This helps us detect and address data quality issues early, preventing downstream errors.</li><li>dbt docs are used for good documentations. This allows for data lineage tracking, and helps downstream consumers discover and understand the datasets we curate for them.</li></ul></li><li><strong>Ad-Hoc Analysis</strong><ul><li>Depending on dataset size and query patterns, we also leverage DuckDB for ad-hoc analysis and rapid prototyping. DuckDB’s in-process, embeddable nature allows for fast, interactive querying, particularly for smaller datasets or exploratory analysis.</li></ul></li><li><strong>Medallion Architecture: Organizing Data for Consumption</strong><ul><li>We implemented a medallion architecture (Bronze, Silver, Gold) to organize our data for optimal consumption.</li><li>The Bronze layer stores raw data, the Silver layer contains cleaned and conformed data, and the Gold layer provides business-ready datasets.</li><li>The Gold layer is further refined to create fine-grained datasets tailored to specific data access patterns. This approach minimizes data scanning during queries, significantly optimizing query performance, especially for frequently accessed data.</li></ul></li></ul><p>To enable efficient data discovery and querying:</p><ul><li><strong>Data Discovery: Data Indexing and Metastore</strong><ul><li>AWS Glue crawlers automatically index data in S3, updating metadata as new data arrives.</li><li>The AWS Glue Data Catalog serves as our Hive Metastore, providing a centralized repository for metadata. This allows Trino to efficiently locate and access data across our data lake.</li></ul></li><li><strong>Querying and Visualization</strong><ul><li>Trino is integrated with the Hive Metastore for distributed querying, enabling us to query data across our data lake using standard SQL. Trino’s ability to federate queries across multiple data sources provides flexibility.</li><li>Metabase is linked to Trino, providing a user-friendly data visualization layer. This empowers our data and BI teams to create interactive reports and dashboards, driving data-driven decisions throughout the organization.</li></ul></li></ul><h2>Analyzing the Cost Reduction<span><a href="#analyzing-the-cost-reduction" aria-label="Anchor">#</a></span></h2><p>Our cost reduction was realized through maximizing the utilization of our current infrastructure and transitioning away from expensive managed services.</p><table><thead><tr><th>Old Data Platform</th><th>New Architecture</th></tr></thead><tbody><tr><td>Hevo: 300~500$</td><td>Connect Cluster : ~150$</td></tr><tr><td>GBQ : ~750$</td><td>Airflow: ~160$</td></tr><tr><td>Postgres: 1000$</td><td>Trino: ~160$</td></tr><tr><td></td><td>Glue: ~10$</td></tr><tr><td>Total: ~2200$ <del>*</del></td><td>Total: ~460$ <del>*</del></td></tr></tbody></table><p><del>*</del> All costs are monthly.</p><hr/><h3>Acknowledgments<span><a href="#acknowledgments" aria-label="Anchor">#</a></span></h3><p>I would like to thank my stunning data team and managers - Aankesh, Deepak and Prashant for enabling the team</p></div></div></div>
  </body>
</html>
