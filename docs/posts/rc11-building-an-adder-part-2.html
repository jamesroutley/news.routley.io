<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC11/">Original</a>
    <h1>RC11. Building an Adder, Part 2</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-05-30T00:00:00-07:00">May 30, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          3 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>Today we’re going to bring our adder across the finish line.</p>

<p><a href="https://www.datadoodad.com/recurse%20center/RC10/">Last time</a> we derived a full adder that required six gates in the end:</p>
<ul>
  <li>2 <code>XOR</code> gates</li>
  <li>2 <code>OR</code> gates</li>
  <li>2 <code>AND</code> gates</li>
</ul>

<p><a href="https://www.datadoodad.com/recurse%20center/RC06/">As I demo’ed in another post</a>, each of these gates can be derived from <code>NAND</code> gates exclusively.</p>
<ul>
  <li>An <code>OR</code> gate can be built from 3 <code>NAND</code> gates,</li>
  <li>an <code>AND</code> from 2,</li>
  <li>and an <code>XOR</code> – by far the most expensive of all – from 9 <code>NAND</code> gates, which can easily be reduced to 5.</li>
</ul>

<p>That means our full adder would need 20 <code>NAND</code> gates. But after drawing it out, I noticed a few opportunities for savings and eventually got it down to 15 <code>NAND</code>s. Maybe it can be simplified further, I’m not sure.</p>

<p>Anyway. 15 <code>NAND</code> gates, then. But that’s just for adding two bits and a carry bit. Fun fact: If we want to add two 16-bit integers, we’d need 240 <code>NAND</code> gates!</p>

<p>Well, we’re not insane, so we’re going to make do with the <code>Full Adder</code> abstraction, of which we need one for each bit – i.e., 16 are needed for adding 16-bit integers. Even that’s a lot, though, so here’s how it’d all look for a 4-bit adder:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC11_4bitadder.jpg" alt="4-bit Adder Schematic"/></p>

<p>What’s happening here is that the Least Significant Bits (the bits in the 1’s place, or bits \(a_0\) and \(b_0\)) get passed into the <code>a</code> and <code>b</code> inputs of the first adder. Because there’s no carry bit for the first adder, we can pull \(c_0\) to ground. This first adder has the two outputs we expect: our least signficant sum bit \(y_0\) and carry bit \(c_1\), which belongs with the next most significant bit in the 2’s place.</p>

<p>Speaking of: Next we indeed move on to the next most significant bits – the bits in the 2’s place, or bits \(a_1\) and \(b_1\), which we pass to the <code>a</code> and <code>b</code> inputs of the second adder along with the \(c_1\) carry bit output from the first adder. This second adder spits out a sum bit for the 2’s place, \(y_1\) and a carry bit for the 4’s place, \(c_2\).</p>

<p>On and on we go. The input bits from the 4’s place, \(a_2\) and \(b_2\), go to adder number 3, which give us sum bit \(y_2\) and carry bit \(c_3\), then then the input bits from the 8’s place, \(a_3\) and \(b_3\), go to adder number 4, which gives us sum bit \(y_3\) and carry bit \(c_4\), which actually becomes our overflow sum bit \(y_4\) since there’s no more adders left.</p>

<p>If we want to add 8-bit integers or 16-bit integers, well, we just need more adders chained along! But that’s the main idea.</p>


<ul>
  <li>Did some pairing on a string problem from CTCI</li>
  <li>Had a few good coffee chats, including with a recurser about their workflow with Obsidian (a markdown knowledge manager) and Anki (a flashcard software). Very impressed but not sure I have the discipline for Anki. However, I was very curious about Obsidian, since I’ve been keen to move away from DevonThink, which suited me during the days of dissertation research but not feels a little heavy-weight and opaque. Still, I’m not sure that moving to Obsidian is the answer right now, as attractive as writing in markdown is. So, kicking that can down the road.</li>
  <li>Did a linked list cycle detection problem in the Neetcode group</li>
  <li>Paired with a fellow nand2tetris groupie where we hammed out an ALU, which will be the subject of my next blog post. It was genuinely a surprise when our ALU suddenly worked, really a fun and productive collaborative effort.</li>
</ul>


          

        

        
      </section>

      

      

      
  <nav>
    
      <a href="https://www.datadoodad.com/recurse%20center/RC10/" title="RC10. Building an Adder
">Previous</a>
    
    
      <a href="#">Next</a>
    
  </nav>

    </div></div>
  </body>
</html>
