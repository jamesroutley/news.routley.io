<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/copper-project/copper-rs/wiki/Copper-Release-Log">Original</a>
    <h1>Show HN: Copper – Open-source robotics in Rust with deterministic log replay</h1>
    
    <div id="readability-page-1" class="page"><div data-view-component="true">          <div id="wiki-body">
              <div>
                

<ul>
<li>
<p><strong>Deterministic Log Replay</strong>: Copper can now replay a log through your code in a deterministic fashion ie. if your tasks are deterministic, it will always output the same output from the same input! See the balancebot-resim for example.</p>
</li>
<li>
<p><strong>Aligner Task <a href="https://github.com/copper-project/copper-rs/pull/114">#114</a>:</strong> Added an aligner task that synchronizes multiple inputs by aligning matching time windows, facilitating coordinated data processing. This is particularly useful for sensor fusion.</p>
</li>
<li>
<p>❗ <strong>Lifecycle Trait Removal <a href="https://github.com/copper-project/copper-rs/pull/115">#115</a>:</strong> Removed the lifecycle trait to simplify task implementation and decouple passed types, streamlining the codebase. To build a minimum task a user needed to implement one method from the CuTaskLifecycle trait (new) and at least the process method from they flavor of tasks. This was forcing the implementation of 2 mandatory traits which is not necessary or useful for the user. Now we moved all the lifecycle methods in the tasks trait to only have to implement 2 traits (the task and Freezable, the serialization of its state)</p>
</li>
</ul>

<ul>
<li>
<p><strong>Named Output Mapping on CopperLists <a href="https://github.com/copper-project/copper-rs/pull/121">#121</a>:</strong> Implemented mapping of Copperlist indices to named outputs from tasks, allowing users to access task outputs symbolically without relying on execution order.</p>
</li>
<li>
<p><strong>CuTimeRange Introduction <a href="https://github.com/copper-project/copper-rs/pull/106">#106</a>:</strong> Introduced <code>CuTimeRange</code> to represent messages containing multiple Time of Validity (TOV) instances, such as sequences of images or IMU measurements.</p>
</li>
<li>
<p><strong>Windows Compatibility <a href="https://github.com/copper-project/copper-rs/pull/110">#110</a>:</strong> Enhanced compatibility by adding a mock for <code>cu_ads7883</code>, enabling compilation on Windows platforms.</p>
</li>
<li>
<p><strong>Dependency Updates <a href="https://github.com/copper-project/copper-rs/pull/104">#104</a>:</strong> Performed a general dependency bump post-release to incorporate the latest improvements and fixes.</p>
</li>
</ul>

<ul>
<li>
<p><strong>BalanceBot Simulation Stability <a href="https://github.com/copper-project/copper-rs/pull/118">#118</a>:</strong> Resolved a core dump issue on exit for <code>balancebot-sim</code> by enforcing specific graphics backends, ensuring clean termination.</p>
</li>
<li>
<p><strong>CuCompactStr Serialization <a href="https://github.com/copper-project/copper-rs/pull/119">#119</a>:</strong> Fixed serialization and deserialization issues with <code>CuCompactStr</code> to ensure correct data handling.</p>
</li>
<li>
<p><strong>Project Generation Fix <a href="https://github.com/copper-project/copper-rs/pull/120">#120</a>:</strong> Addressed issues in project generation by adding <code>crate::</code> for <code>cumsgs</code> generation, ensuring correct module resolution.</p>
</li>
<li>
<p><strong>Unused Code Cleanup <a href="https://github.com/copper-project/copper-rs/pull/121">#121</a>:</strong> Removed unused imports and methods to maintain code cleanliness and reduce potential maintenance overhead.</p>
</li>
<li>
<p><strong>Test Stability <a href="https://github.com/copper-project/copper-rs/pull/107">#107</a>:</strong> Ignored hardware-dependent tests and added <code>test --workspace</code> to CI/CD to enhance test reliability across different environments.</p>
</li>
</ul>
<hr/>


<ul>
<li>
<strong>Iceoryx2 Support <a href="https://github.com/copper-project/copper-rs/pull/87">#87</a>:</strong> Introduced Iceoryx2 support. Iceoryx2 is the successor to Iceoryx in pure Rust. The Copper support included a source component to receive messages, a sink component to send messages.</li>
<li>
<strong>Hesai XT32 Support <a href="https://github.com/copper-project/copper-rs/pull/101">#101</a>:</strong> Added the preliminary support for the Hesai XT32. If you have the actual HW handy, feel free to provide us the feedback!</li>
<li>
<strong>First standard Lidar Message Design <a href="https://github.com/copper-project/copper-rs/pull/99">#99</a>:</strong> For now in SOA out or the lidar sensors it allows SIMD optimizations for the first operations that are usually a frame transform.</li>
</ul>

<ul>
<li>
<strong>Variable-Length SoAs <a href="https://github.com/copper-project/copper-rs/pull/100">#100</a>:</strong> Improved <code>SoA</code> (Structure of Arrays) to support variable lengths on top of their fixed size in the Copper List.</li>
<li>
<strong>CI Improvements <a href="https://github.com/copper-project/copper-rs/pull/98">#98</a>:</strong> Integrated clippy warnings into CI, thanks to <a href="https://github.com/makeecat">makeecat</a>
</li>
</ul>

<ul>
<li>
<strong>BalanceBot Simulation Reset <a href="https://github.com/copper-project/copper-rs/pull/86">#86</a>:</strong> Improved the <code>reset_sim</code> functionality for the balance bot. Thanks to <a href="https://github.com/makeecat">makeecat</a>.</li>
<li>
<strong>Publishing Fixes <a href="https://github.com/copper-project/copper-rs/pull/103">#103</a>:</strong> Resolved various publishing issues and added dry-run validations to avoid disruptions.</li>
</ul>
<hr/>


<ul>
<li>
<strong>Simulation API Support</strong>: With sim-mode=true in the main Copper macro, Copper will generate for you all the callbacks at all the tasks states it is going through (Start, Preprocess, Process, etc...). Combined with the already mockable Clock it allows a very easy integration with a virtual environment.</li>
<li>
<strong>BalanceBot Simulation <a href="https://github.com/copper-project/copper-rs/pull/69">#69</a>:</strong>  Built on that and leveraging Bevy and Avian3D for realistic motion dynamics, we made a little demo of our little real world demonstrator. The real world code and the sim code are 100% identical.</li>
<li>
<strong>Config Embedding <a href="https://github.com/copper-project/copper-rs/pull/78">#78</a>:</strong> Embedded the default <code>copperconfig.ron</code> directly into the Copper executable, simplifying deployment for the main case (just one executable to copy and that&#39;s it!!). If the file is present, it will take precedence over the embedded version. We also do log the actual config used in the logs so you can come back to it in doubt.</li>
</ul>

<ul>
<li>
<strong>Cross-Platform Compatibility for Mocking <a href="https://github.com/copper-project/copper-rs/pull/75">#75</a>:</strong> Enhanced feature flags to better support various platforms, particularly macOS, enabling testing with mocked hardware dependencies. The full repo now compile under CI/CD on MacOS and Linux (previously it we could only compile and test the Core)</li>
</ul>

<ul>
<li>
<strong>Terminal Restoration <a href="https://github.com/copper-project/copper-rs/pull/73">#73</a>:</strong> Fixed issues with terminal states not restoring properly upon exit, preventing corruption and enhancing the overall stability of simulator sessions.</li>
<li>
<strong>Print Output Cleanup <a href="https://github.com/copper-project/copper-rs/pull/80">#80</a>:</strong> Streamlined console logging to minimize redundant or unnecessary print statements, making debugging output more manageable.</li>
<li>
<strong>Git LFS Migration <a href="https://github.com/copper-project/copper-rs/pull/76">#76</a>:</strong> Moved heavy assets to a CDN to mitigate GitHub LFS limitations, reducing operational overhead and streamlining asset distribution.</li>
</ul>

<ul>
<li>
<strong>Asset CDN Integration <a href="https://github.com/copper-project/copper-rs/pull/35">#35</a>:</strong> Transitioned assets to a content delivery network to avoid the super costly Github LFS.</li>
<li>
<strong>Improved Documentation <a href="https://github.com/copper-project/copper-rs/pull/82">#82</a>:</strong> Expanded and refined documentation across modules, enhancing clarity for new users and developers.</li>
</ul>

<ul>
<li>
<strong>Logging Value Enhancements <a href="https://github.com/copper-project/copper-rs/pull/80">#80</a>:</strong> Fine-tuned value logging to increase logging granularity and simplify troubleshooting in complex simulation states.</li>
<li>
<strong>Feature Flag Revamp <a href="https://github.com/copper-project/copper-rs/pull/75">#75</a>:</strong> Restructured feature flags to better support debugging and cross-platform configurations, especially for macOS compatibility.</li>
</ul>
<hr/>

<p>A Minor release with 2 new components and some fixes.</p>

<ul>
<li>
<p>New cu-pid task: this is the first algorithm we publish. It is from the balancebot, a generalized PID controller logic you can reuse in your projects, see the readme in the crate.</p>
</li>
<li>
<p>New cu-consolemon monitoring: this is a TUI for Copper showing the information exposed by the new monitoring interface released in 0.3.0.</p>
</li>
</ul>

<ul>
<li>Added <code>Mul</code> to <code>CuDuration</code> for easy time offset computations.</li>
</ul>

<ul>
<li>
<strong>Tree Reorganization</strong>:
<ul>
<li>Major reorganization of the repository structure for improved clarity and maintainability.</li>
</ul>
</li>
</ul>

<ul>
<li>
<strong>Logging Fixes</strong>:
<ul>
<li>Resolved an issue where <code>OnceLock</code> was not releasing the unified logger, preventing a clean shutdown of the logger.</li>
<li>Addressed an issue with a double close in the logger during shutdown.</li>
</ul>
</li>
</ul>
<hr/>

<p>This alpha release introduces substantial improvements to the Copper framework&#39;s monitoring capabilities and API flexibility.</p>

<ul>
<li>
<strong>New multisource and optional input API</strong>: The Copper engine now supports multiple and optional inputs/outputs (see PR #44).</li>
</ul>
<p>This is a <strong>breaking change</strong>.</p>
<p>Now you can link 2 tasks to one in the RON file like this:</p>
<div data-snippet-clipboard-copy-content="
    tasks: [
        (
            id: &#34;balpos&#34;,
            type: &#34;cu_ads7883::ADS7883&#34;,
        ),
        (
            id: &#34;railpos&#34;,
            type: &#34;cu_rp_encoder::Encoder&#34;,
        ),
        (
            id: &#34;pidctrl&#34;,
            type: &#34;pidtask::PIDTask&#34;,
            config: {
               [...]
            },
        ),
        (
            id: &#34;motor&#34;,
            type: &#34;cu_rp_sn754410::SN754410&#34;,
            [...]
        ),
     ],
    cnx: [
        //                    vvvvvvvvvv   same dest!
        (src: &#34;balpos&#34;,   dst: &#34;pidctrl&#34;,   msg: &#34;cu_ads7883::ADSReadingPayload&#34;),
        (src: &#34;railpos&#34;,  dst: &#34;pidctrl&#34;,   msg: &#34;cu_rp_encoder::EncoderPayload&#34;),
        (src: &#34;pidctrl&#34;,  dst: &#34;motor&#34;,   msg: &#34;cu_rp_sn754410::MotorPayload&#34;),
    ],
)
"><pre>    <span>tasks</span>: [
        (
            <span>id</span>: <span>&#34;balpos&#34;</span>,
            <span>type</span>: <span>&#34;cu_ads7883::ADS7883&#34;</span>,
        ),
        (
            <span>id</span>: <span>&#34;railpos&#34;</span>,
            <span>type</span>: <span>&#34;cu_rp_encoder::Encoder&#34;</span>,
        ),
        (
            <span>id</span>: <span>&#34;pidctrl&#34;</span>,
            <span>type</span>: <span>&#34;pidtask::PIDTask&#34;</span>,
            <span>config</span>: {
               [...]
            },
        ),
        (
            <span>id</span>: <span>&#34;motor&#34;</span>,
            <span>type</span>: <span>&#34;cu_rp_sn754410::SN754410&#34;</span>,
            [...]
        ),
     ],
    <span>cnx</span>: [
        <span>//                    vvvvvvvvvv   same dest!</span>
        (<span>src</span>: <span>&#34;balpos&#34;</span>,   <span>dst</span>: <span>&#34;pidctrl&#34;</span>,   <span>msg</span>: <span>&#34;cu_ads7883::ADSReadingPayload&#34;</span>),
        (<span>src</span>: <span>&#34;railpos&#34;</span>,  <span>dst</span>: <span>&#34;pidctrl&#34;</span>,   <span>msg</span>: <span>&#34;cu_rp_encoder::EncoderPayload&#34;</span>),
        (<span>src</span>: <span>&#34;pidctrl&#34;</span>,  <span>dst</span>: <span>&#34;motor&#34;</span>,   <span>msg</span>: <span>&#34;cu_rp_sn754410::MotorPayload&#34;</span>),
    ],
)
</pre></div>
<p>To help you manage the types that are generated, we are giving a set of macros to help you matching the correct input / output types:</p>
<div data-snippet-clipboard-copy-content="impl&lt;&#39;cl&gt; CuTask&lt;&#39;cl&gt; for PIDTask {
    // This tasks takes 2 inputs!
    // They are given in the order of task declaration
    // the input_msg! macro build a (&amp;CuMsg&lt;ADSReadingPayload&gt;, &amp;CuMsg&lt;EncoderPayload&gt;) tuple under the hood.
    // it also works with 1 input and then you will get a straight &amp;CuMsg&lt;&gt; immutable ref.
    // For technical Rust reasons, you need to explicitely tie the lifetime (&#39;cl means copperlist if you are curious: the internal structure of copper for messages)
    type Input = input_msg!(&#39;cl, ADSReadingPayload, EncoderPayload);

    // same thing but as an output this is a &amp;mut CuMsg&lt;MotorPayload&gt;
    type Output = output_msg!(&#39;cl, MotorPayload);

    fn process(
        &amp;mut self,
        clock: &amp;RobotClock,
        input: Self::Input,  // here this is now straight the input type, it is a little simpler.
        output: Self::Output,
    ) -&gt; CuResult&lt;()&gt; {
        let (bal_pos, rail_pos) = input;  // you can unpack the tuple directly those are resp. &amp;CuMsg&lt;ADSReadingPayload&gt; and &amp;CuMsg&lt;EncoderPayload&gt;
        let bal_tov = bal_pos.metadata.tov.expect(&#34;we should have had a message here!&#34;);  // the messages are now optional depending on the context they could be expected or really optional.
        // we have a new method called set_payload for the output
        output.set_payload(MotorPayload { power: 0.0 }); // If you don&#39;t do that it will send away a message with a None payload"><pre><span>impl</span><span>&lt;</span><span>&#39;</span>cl<span>&gt;</span> <span>CuTask</span><span>&lt;</span><span>&#39;</span>cl<span>&gt;</span> <span>for</span> <span>PIDTask</span> <span>{</span>
    <span>// This tasks takes 2 inputs!</span>
    <span>// They are given in the order of task declaration</span>
    <span>// the input_msg! macro build a (&amp;CuMsg&lt;ADSReadingPayload&gt;, &amp;CuMsg&lt;EncoderPayload&gt;) tuple under the hood.</span>
    <span>// it also works with 1 input and then you will get a straight &amp;CuMsg&lt;&gt; immutable ref.</span>
    <span>// For technical Rust reasons, you need to explicitely tie the lifetime (&#39;cl means copperlist if you are curious: the internal structure of copper for messages)</span>
    <span>type</span> <span>Input</span> = <span>input_msg</span><span>!</span><span>(</span><span>&#39;</span>cl, <span>ADSReadingPayload</span>, <span>EncoderPayload</span><span>)</span><span>;</span>

    <span>// same thing but as an output this is a &amp;mut CuMsg&lt;MotorPayload&gt;</span>
    <span>type</span> <span>Output</span> = <span>output_msg</span><span>!</span><span>(</span><span>&#39;</span>cl, <span>MotorPayload</span><span>)</span><span>;</span>

    <span>fn</span> process<span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span>
        <span>clock</span><span>:</span> <span>&amp;</span><span>RobotClock</span><span>,</span>
        <span>input</span><span>:</span> <span>Self</span><span>::</span><span>Input</span><span>,</span>  <span>// here this is now straight the input type, it is a little simpler.</span>
        <span>output</span><span>:</span> <span>Self</span><span>::</span><span>Output</span><span>,</span>
    <span>)</span> -&gt; <span>CuResult</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>(</span>bal_pos<span>,</span> rail_pos<span>)</span> = input<span>;</span>  <span>// you can unpack the tuple directly those are resp. &amp;CuMsg&lt;ADSReadingPayload&gt; and &amp;CuMsg&lt;EncoderPayload&gt;</span>
        <span>let</span> bal_tov = bal_pos<span>.</span><span>metadata</span><span>.</span><span>tov</span><span>.</span><span>expect</span><span>(</span><span>&#34;we should have had a message here!&#34;</span><span>)</span><span>;</span>  <span>// the messages are now optional depending on the context they could be expected or really optional.</span>
        <span>// we have a new method called set_payload for the output</span>
        output<span>.</span><span>set_payload</span><span>(</span><span>MotorPayload</span> <span>{</span> <span>power</span><span>:</span> <span>0.0</span> <span>}</span><span>)</span><span>;</span> <span>// If you don&#39;t do that it will send away a message with a None payload</span></pre></div>
<ul>
<li>
<strong>Monitoring System</strong>: The monitoring framework is now fully integrated, allowing real-time stats collection and cumulative statistics (see PRs #49, #50, and #51). We can imagine complex decision trees happening at that stage for complex robots and various degraded modes.</li>
</ul>
<p>The monitoring component is really similar to a task, but with specialized callbacks:</p>
<div data-snippet-clipboard-copy-content="// This is in the RON file, just add a monitor entry like this:

    tasks: [
        (
            id: &#34;task0&#34;,
            type: &#34;tasks::ExampleSrc&#34;,
        ),
        [...]
     ],
    cnx: [
        (src: &#34;task0&#34;, dst: &#34;task1&#34;, msg: &#34;i32&#34;),
        [...]
    ],
    monitor: (type: &#34;ExampleMonitor&#34;)  // here, add a config entry if necessary
)"><pre><span>// This is in the RON file, just add a monitor entry like this:</span>

    <span>tasks</span>: [
        (
            <span>id</span>: <span>&#34;task0&#34;</span>,
            <span>type</span>: <span>&#34;tasks::ExampleSrc&#34;</span>,
        ),
        [...]
     ],
    <span>cnx</span>: [
        (<span>src</span>: <span>&#34;task0&#34;</span>, <span>dst</span>: <span>&#34;task1&#34;</span>, <span>msg</span>: <span>&#34;i32&#34;</span>),
        [...]
    ],
    <span>monitor</span>: (<span>type</span>: <span>&#34;ExampleMonitor&#34;</span>)  <span>// here, add a config entry if necessary</span>
)</pre></div>
<div data-snippet-clipboard-copy-content="struct ExampleMonitor {
    tasks: &amp;&#39;static [&amp;&#39;static str], // We give you the task ordinal to task id mapping (so it is stable as long as you don&#39;t change your task ids.
}

impl CuMonitor for ExampleMonitor {
    // We pass you the config you gave in the RON file exactly like for the tasks.
    fn new(_config: Option&lt;&amp;ComponentConfig&gt;, taskids: &amp;&#39;static [&amp;str]) -&gt; CuResult&lt;Self&gt; {
        Ok(ExampleMonitor { tasks: taskids })
    }

    fn start(&amp;mut self, clock: &amp;_RobotClock) -&gt; CuResult&lt;()&gt; {
        // callbacked when all the tasks, start called.
    }

    fn process_copperlist(&amp;self, msgs: &amp;[&amp;CuMsgMetadata]) -&gt; CuResult&lt;()&gt; {
        // This is callbacked at the end of the processing of a copper list (basically near when the CL is getting serialized to disk after a success. 
        // The metadata gives you all the timings you need to check if your robot is still behaving nominally.
        for t in msgs.iter().enumerate() {
            let (taskid, metadata) = t;
            debug!(&#34;Task: {} -&gt; {}&#34;, taskid, metadata);
        }
        Ok(())
    }

    fn process_error(&amp;self, taskid: usize, step: CuTaskState, error: &amp;CuError) -&gt; Decision {
        // This is called back if any task reports an error at any step (start, process, ...)
        // You can then match that taskid and compute a decision for your robot: Abort, Ignore, Shutdown (see the cu28/monitoring.rs file for semantic details. 
        Decision::Ignore
    }

    fn stop(&amp;mut self, clock: &amp;_RobotClock) -&gt; CuResult&lt;()&gt; {
        // call when the stack is stopping
        Ok(())
    }
}"><pre><span>struct</span> <span>ExampleMonitor</span> <span>{</span>
    <span>tasks</span><span>:</span> <span>&amp;</span><span>&#39;</span>static <span>[</span><span>&amp;</span><span>&#39;</span>static <span>str</span><span>]</span><span>,</span> <span>// We give you the task ordinal to task id mapping (so it is stable as long as you don&#39;t change your task ids.</span>
<span>}</span>

<span>impl</span> <span>CuMonitor</span> <span>for</span> <span>ExampleMonitor</span> <span>{</span>
    <span>// We pass you the config you gave in the RON file exactly like for the tasks.</span>
    <span>fn</span> <span>new</span><span>(</span><span>_config</span><span>:</span> <span>Option</span><span>&lt;</span><span>&amp;</span><span>ComponentConfig</span><span>&gt;</span><span>,</span> <span>taskids</span><span>:</span> <span>&amp;</span><span>&#39;</span>static <span>[</span><span>&amp;</span><span>str</span><span>]</span><span>)</span> -&gt; <span>CuResult</span><span>&lt;</span><span>Self</span><span>&gt;</span> <span>{</span>
        <span>Ok</span><span>(</span><span>ExampleMonitor</span> <span>{</span> <span>tasks</span><span>:</span> taskids <span>}</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>start</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>clock</span><span>:</span> <span>&amp;</span><span>_RobotClock</span><span>)</span> -&gt; <span>CuResult</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
        <span>// callbacked when all the tasks, start called.</span>
    <span>}</span>

    <span>fn</span> <span>process_copperlist</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>msgs</span><span>:</span> <span>&amp;</span><span>[</span><span>&amp;</span><span>CuMsgMetadata</span><span>]</span><span>)</span> -&gt; <span>CuResult</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
        <span>// This is callbacked at the end of the processing of a copper list (basically near when the CL is getting serialized to disk after a success. </span>
        <span>// The metadata gives you all the timings you need to check if your robot is still behaving nominally.</span>
        <span>for</span> t <span>in</span> msgs<span>.</span><span>iter</span><span>(</span><span>)</span><span>.</span><span>enumerate</span><span>(</span><span>)</span> <span>{</span>
            <span>let</span> <span>(</span>taskid<span>,</span> metadata<span>)</span> = t<span>;</span>
            <span>debug</span><span>!</span><span>(</span><span>&#34;Task: {} -&gt; {}&#34;</span>, taskid, metadata<span>)</span><span>;</span>
        <span>}</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>process_error</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>taskid</span><span>:</span> <span>usize</span><span>,</span> <span>step</span><span>:</span> <span>CuTaskState</span><span>,</span> <span>error</span><span>:</span> <span>&amp;</span><span>CuError</span><span>)</span> -&gt; <span>Decision</span> <span>{</span>
        <span>// This is called back if any task reports an error at any step (start, process, ...)</span>
        <span>// You can then match that taskid and compute a decision for your robot: Abort, Ignore, Shutdown (see the cu28/monitoring.rs file for semantic details. </span>
        <span>Decision</span><span>::</span><span>Ignore</span>
    <span>}</span>

    <span>fn</span> <span>stop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>clock</span><span>:</span> <span>&amp;</span><span>_RobotClock</span><span>)</span> -&gt; <span>CuResult</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
        <span>// call when the stack is stopping</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span></pre></div>


<ul>
<li>Real-time cumulative stats for <code>CuDurations</code>. See cu29/monitoring.rs we built an histogramming feature for timings this is super useful for monitoring components. Here is the list of everything you get it is not only pretty comprehensive but it is fixed size on memory so it should be pretty swift for any real time monitoring needs or UIs.</li>
</ul>
<div data-snippet-clipboard-copy-content="    // on the CuDurationStatistics struct
    pub fn min(&amp;self) -&gt; CuDuration;
    pub fn max(&amp;self) -&gt; CuDuration;
    pub fn mean(&amp;self) -&gt; CuDuration 
    pub fn percentile(&amp;self, percentile: f64) -&gt; CuDuration;
    pub fn stddev(&amp;self) -&gt; CuDuration;
    pub fn jitter_min(&amp;self) -&gt; CuDuration;
    pub fn jitter_max(&amp;self) -&gt; CuDuration;
    pub fn jitter_mean(&amp;self) -&gt; CuDuration;
    pub fn jitter_stddev(&amp;self) -&gt; CuDuration;
    pub fn jitter_percentile(&amp;self, percentile: f64) -&gt; CuDuration;"><pre>    <span>// on the CuDurationStatistics struct</span>
    <span>pub</span> <span>fn</span> <span>min</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>max</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>mean</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span></span> 
    <span>pub</span> <span>fn</span> <span>percentile</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>percentile</span><span>:</span> <span>f64</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>stddev</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>jitter_min</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>jitter_max</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>jitter_mean</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>jitter_stddev</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span>
    <span>pub</span> <span>fn</span> <span>jitter_percentile</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>percentile</span><span>:</span> <span>f64</span><span>)</span> -&gt; <span>CuDuration</span><span>;</span></pre></div>

<ul>
<li>
<strong>Serialization / Deserialization Bug on Value</strong> (#42). A code reformat shuffled the serialization IDs Oo.</li>
</ul>

<ul>
<li>
<p><strong>Virtual Output for Sinks</strong> (#53):</p>
<ul>
<li>before that there was no mean to monitor sinks (or hacks you might have seen on the incoming message). Now the stack behind the scene generates a () empty message for each sink you you get the perf number cleanly for them even if they don&#39;t output anything.</li>
</ul>
</li>
<li>
<p><strong>Balance Bot Demo</strong> (#46):</p>
<ul>
<li>a more complete example of a real robot demo we will bring at conferences.</li>
</ul>
</li>
</ul>

<ul>
<li>And a bunch of cleanup / doc improments.</li>
</ul>
<hr/>

<p>We are pleased to announce the release of Copper v0.2.3, which includes several new features, enhancements, and bug fixes. Below is a summary of the key changes in this release:</p>

<ul>
<li>
<strong>SN754410 Driver Support <a href="https://github.com/copper-project/copper-rs/pull/40">#40</a>:</strong> Added a new driver for the SN754410 motor driver. This driver allows easy integration with motor control applications, providing robust support for H-bridge motor control on a wide range of systems. <em>This driver is fully compatible with the BalanceHAT.</em>
</li>
<li>
<strong>ADS7883 Driver <a href="https://github.com/copper-project/copper-rs/pull/39">#39</a>:</strong> Introduced a driver for the ADS7883, a 12-bit SPI ADC. This addition includes comprehensive documentation in the README to facilitate setup and integration. <em>The ADS7883 driver is also compatible with the BalanceHAT.</em>
</li>
</ul>

<ul>
<li>
<strong>macOS Development Support <a href="https://github.com/copper-project/copper-rs/pull/25">#25</a>:</strong> Copper can now be developed on macOS! The CI/CD pipeline has been updated to support macOS, ensuring cross-platform compatibility for all users.</li>
<li>
<strong>cu29_clock Enhancements <a href="https://github.com/copper-project/copper-rs/pull/32">#32</a>:</strong> Added a division feature to the cu29_clock, allowing more granular time management and synchronization within the Copper runtime.</li>
<li>
<strong>Structured Log Index File in Debug Mode <a href="https://github.com/copper-project/copper-rs/pull/30">#30</a>:</strong> Removed the requirement for an index file in debug mode within struct_log, simplifying the debugging process ie. only the config and the executable needs to be deployed for the debug build and you get a standard debug text logging.</li>
<li>
<strong>Logging Slabs Addition <a href="https://github.com/copper-project/copper-rs/pull/24">#24</a>:</strong> The current unified logger works with big memory mapped files. Initially we thought we could rely on the mmap resize feature of the kernel api but it just doesn&#39;t work. We are reverting into building &#34;slabs&#34;, ie dividing the data logger into large files. Those files can be concatenated and read or directly read from the log exporter.</li>
</ul>

<ul>
<li>
<strong>Compilation Feedback Adjustments <a href="https://github.com/copper-project/copper-rs/pull/33">#33</a>:</strong> Moved compilation feedback from standard output to standard error to better align with conventional logging practices.</li>
<li>
<strong>Flush and Core Dump Fixes <a href="https://github.com/copper-project/copper-rs/pull/29">#29</a>:</strong> Resolved issues where changes after a section flush could cause a core dump, improving the stability of the logging system.</li>
</ul>

<ul>
<li>
<strong>CI/CD Pipeline Enhancements <a href="https://github.com/copper-project/copper-rs/pull/25">#25</a>:</strong> Added macOS support to the CI/CD pipeline, ensuring better cross-platform compatibility.</li>
<li>
<strong>Removed &#39;Continue on Error&#39; in CI/CD <a href="https://github.com/copper-project/copper-rs/pull/36">#36</a>:</strong> Addressed a CI/CD issue where the pipeline was green while failing Oo.</li>
</ul>
<div><h4>Refactoring and Internal Changes</h4><a id="user-content-refactoring-and-internal-changes" aria-label="Permalink: Refactoring and Internal Changes" href="#refactoring-and-internal-changes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul>
<li>
<p><strong>Unified Logger Refactor <a href="https://github.com/copper-project/copper-rs/pull/27">#27</a>:</strong> Refactored the Unified Logger to introduce a dual-slab logging system, improving performance and eliminating the need for remap/resize operations.</p>
</li>
<li>
<p><strong>Runtime Loop Enhancements <a href="https://github.com/copper-project/copper-rs/pull/21">#21</a>:</strong> Added a new notion of loops in the runtime plan, setting the stage for more flexible and powerful runtime behavior.</p>
</li>
</ul>
<hr/>
<p><em>If you&#39;re looking to build your own interfacing with the SN754410 or ADS7883 drivers, we share detailed connectivity schematics with a Raspberry Pi to help you get started.</em></p>
<p>We recommend updating to this latest version to take advantage of these improvements. As always, please refer to the updated documentation and release notes for detailed information on how to integrate these changes into your projects.</p>
<p>If you have any questions or need further assistance, feel free to reach out to our support team.</p>

              </div>

          </div>
</div></div>
  </body>
</html>
