<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.cmyr.net/blog/gui-framework-ingredients.html">Original</a>
    <h1>So you want to write a GUI framework (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>

        

        <p>Through several <a href="https://www.reddit.com/r/rust/comments/o99zj1/what_do_you_think_will_emerge_as_the_dominant/">recent discussions</a> of <a href="https://news.ycombinator.com/item?id=27782337">GUI programming in Rust</a>,
I have been left with the impression that the term ‘GUI’ means significantly
different things to different people.</p>

<p>I would like to try and clarify this point somewhat, first by describing some of
the different things that people refer to as GUI frameworks/toolkits, and then
by exploring in detail the necessary components of one of these, the classic
desktop GUI framework.</p>

<p>Although this post is not especially specific to Rust, it does have its genesis
in Rust: it is largely informed by my experience working on <a href="https://docs.rs/druid">Druid</a>, a Rust
GUI toolkit of the desktop variety.</p>

<p>Once we have a shared understanding of the problem, we will be better situated
to talk about the status of this work in Rust, which will be the topic of a
<a href="http://www.cmyr.net/blog/rust-gui-infra.html">follow-up post</a>.</p>



<h2 id="what-we-talk-about-when-we-talk-about-gui">What we talk about when we talk about GUI</h2>

<p>A GUI framework can be a lot of different things, with different use cases
and different deployment targets. A framework intended for building embedded
applications is not going to also trivially work on the desktop; a framework for
building desktop applications is not going to trivially work on the web.</p>

<p>Regardless of the specifics, there is one major dividing line to recognize, and
this is whether or not a framework is expected to <em>integrate closely into an
existing platform or environment</em>.</p>

<p>On one side of this line, then, are tools for building games, embedded
applications, and (to a lesser degree) web apps. In this world, you are
responsible for providing almost everything your applications will need, and you
will be interacting closely with the underlying hardware: accepting raw input
events, and outputting your UI to some sort of buffer or surface. (The web is
different; here the browser vendors have done that integration work for you.)</p>

<p>On the other side of this line are tools for building traditional desktop
applications. In <em>this</em> world, you must integrate tightly into a large number of
existing platform APIs, design patterns, and conventions, and it is this
integration that is the source of most of your design complexity.</p>

<h3 id="games-and-embedded-guis">Games and embedded GUIs</h3>

<p>Before we start digging into all the integrations expected of a desktop
application framework, let’s talk briefly about the first case.</p>

<p>Games and GUI for embedded applications (think of the infotainment system in the
back of a taxi, or the interface on a medical device) are different from desktop
GUIs in a number of ways, most of which can be thought of in terms
of system integration: games and embedded applications don’t have to do as much of
it. In general, a game or an embedded application is a self-contained world;
there is a single ‘window’, and the application is responsible for drawing
everything in it. The application doesn’t need to worry about menus or
sub-windows; it doesn’t need to worry about the <a href="https://raphlinus.github.io/ui/graphics/2020/09/13/compositor-is-evil.html">compositor</a>, or integrating with
the <a href="https://github.com/linebender/druid/pull/1636">platform’s IME</a> system. Although they maybe <em>should</em>, they often don’t
support <a href="https://harfbuzz.github.io/complex-scripts.html">complex scripts</a>. They can ignore rich text editing. They likely don’t need
to support <a href="https://github.com/WICG/local-font-access">font enumeration</a> or <a href="https://www.figma.com/blog/when-fonts-fall/">fallback</a>. They often ignore accessibility.</p>

<p>Of course, they do have additional challenges of their own. Embedded
applications have to think much more carefully about resource constraints, and
may need to <a href="https://lupyuen.github.io/articles/porting-druid-rust-widgets-to-pinetime-smart-watch">avoid allocation</a> altogether. When they <em>do</em> need
features like complex scripts or text input, they have to implement these
features on their own, without being able to rely on anything provided by the
system.</p>

<p>Games are similar, and additionally have their own unique performance concerns
and considerations that I am not qualified to talk about in any real detail.</p>

<p>Games and embedded are certainly interesting domains. Embedded in particular is
a place where I think Rust GUI could really make a lot of sense, for many of the
same reasons that Rust generally has a <a href="https://www.rust-lang.org/what/embedded">strong value proposition</a>
for embedded use.</p>

<p>It is unlikely, however, that a project that is intended for game or embedded
development is going to tackle the whole list of capabilities we expect in
desktop applications.</p>

<h2 id="anatomy-of-a-native-desktop-application">Anatomy of a ‘native desktop application’</h2>

<p>The principal distinguishing feature of a desktop application is its close
integration into the platform. Unlike a game or an embedded application, a
desktop application is expected to interoperate intimately with the host OS, as
well as with other software.</p>

<p>I’d like to try and go through some of the major required integration points,
and some of the possible approaches available for providing them.</p>

<h3 id="windowing">Windowing</h3>

<p>An application has to instantiate and manage windows. The API should allow for
customization of window appearance and behaviour, including things like whether
the window is resizeable, whether it has a titlebar, etc. The API should allow
for multiple windows, and it should also support modal and child-windows in a
way that respects platform conventions. This means supporting both
<a href="https://developer.apple.com/documentation/appkit/nsapplication/1428418-beginmodalsession#">application-modal</a> windows (for instance alerts that steal focus from the entire
application until dealt with) as well as <a href="https://developer.apple.com/documentation/appkit/nswindow/1419653-beginsheet">window-modal</a> windows (an alert that
steals focus from a given window until dealt with). Modal windows are used to
implement a large number of common features, including open/save dialogs (which
may be special-cased by the platform) alerts, confirmation dialogs, as well as
standard UI elements such as combo boxes and other drop-down menus (think a list
of completions for a text field).</p>

<p>The API must allow subwindows to be positioned precisely, relative to the
position of the parent window. For instance in the case of a combo box, when
showing the list of options you may wish to draw the currently selected item at
the same baseline position used when the list is closed, as in macOS:</p>



<p>Similarly, there needs to be an API that provides information about screens and
the positions of windows within them, so that a combo box can be positioned
appropriately to use available space: if the box is at the bottom of the screen
it should position the popup above itself, and otherwise below.</p>

<h4 id="tabs">Tabs</h4>

<p>You’re also going to want to support tabs. You should be able to drag a tab out
of a tab group to create a new window, as well as drag tabs between windows.
Ideally you would like use the platform’s native tabbing infrastructure, but…
that’s complicated. The browsers all roll their own implementations, and this is
probably for a good reason. You would <em>like</em> to respect the user’s preferences
around tabs (macOS let’s the user choose to open new windows as tabs,
system-wide) but that will be an additional complication. I forgive you if you
skip it, but if your framework sees much use you’re going to get someone
reporting it as a bug every month until you die, and they aren’t wrong.</p>

<div>


<video id="tabs-video" width="656" height="226" controls="">

    <source src="/assets/desktop_gui/safari_tabs.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>

<p>Difference and appearance between &#34;native&#34; tabs (in
Safari) with custom implementations in Chrome and Firefox.</p>
</div>



<p>Closely related to windows are menus; a desktop application should respect
platform conventions around window and application menus. On Windows (the
operating system family) menus are a component of the window. On macOS, the menu
is a property of the application, which is updated to reflect the commands
available for the active window. On linux, things are slightly less clear cut.
If you’re using GTK then there are both window and application menus, although
the latter <a href="https://developer.gnome.org/ApplicationMenu/">are deprecated</a>. If you’re directly targeting x11 or
wayland, you’ll need to implement menus on your own, and you can theoretically
do whatever you want, although the easy path is Windows-style window menus.</p>

<p>Generally there are <a href="https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-bar-menus/">explicit</a> <a href="https://docs.microsoft.com/en-us/windows/win32/uxguide/cmd-menus#standard-menus">conventions</a> around what
menus you should provide, and what commands should be present in them; a
well-behaved desktop application should respect these conventions.</p>

<h4 id="painting">Painting</h4>

<p>To draw the content of your app, you need (at least) a basic 2D graphics API.
This should provide the ability to fill and stroke paths (with colors, including
transparency, as well as with radial and linear gradients), to lay out text, to
draw images, to define clip regions, and to apply transformations. Ideally your
API also provides a few more advanced features such as blend modes and blurs,
for things like drop shadows.</p>

<p>These APIs exist, in subtly different form, on the various platforms. on macOS,
there is <a href="https://developer.apple.com/documentation/coregraphics">CoreGraphics</a>, on windows <a href="https://docs.microsoft.com/en-us/windows/win32/direct2d/direct2d-portal">Direct2D</a>, and on linux there is <a href="https://www.cairographics.org">Cairo</a>. One
approach, then, is to present a common API abstraction over top of these
platform APIs, puttying over the rough edges and filling in the gaps. (This is
the approach we have currently taken, with the <a href="https://docs.rs/piet">piet</a> library.)</p>

<p>This does have its downsides. These API are different enough (especially in
trickier areas, <a href="https://www.cmyr.net/blog/piet-text-work.html">such as text</a>) that designing a good abstraction
can be challenging, and requires some jumping through hoops. Subtly different
platform behaviour can cause rendering irregularities.</p>

<p>It would be simpler to just use the same renderer everywhere. One option might
be something like <a href="https://skia.org">Skia</a>, the rendering engine used in Chrome and Firefox.
This has the advantage of portability and consistency, at the cost of binary
size and compile time costs; a Rust binary using <a href="https://github.com/rust-skia/rust-skia">skia-safe</a> crate has a
baseline size of about 17M for a release build (my methodology wasn’t great for
this, but I think it’s a reasonable baseline.)</p>

<p>Skia is still a fairly traditional software renderer, although it does now have
significant GPU support. Ultimately, though, the most exciting prospects are
those that move even more of the rendering task to the GPU.</p>

<p>An initial challange here is the diversity of APIs for GPU programming, even for
identical hardware. The same physical GPU can be interfaced with via <a href="https://developer.apple.com/metal/">Metal</a>
on Apple platforms, <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide">DirectX</a> on Windows, and <a href="https://www.vulkan.org">Vulkan</a> on many other
platforms. Making code portable across these platforms requires either duplicate
implementations, some form of <a href="https://github.com/KhronosGroup/MoltenVK">cross compilation</a> or else an
<a href="https://github.com/gfx-rs/wgpu/tree/master/wgpu-hal">abstraction layer</a>. The problem with these latter cases is that it is
genuinely hard to write an abstraction that provides adequate control of
advanced GPU features (such as the compute capabilities) across subtly different
low-level APIs.</p>

<p>Once you’ve figured out how you want to talk to the hardware, you then need to
figure out how to efficiently and correctly rasterize 2D scenes on the GPU.
This is also probably more complicated than you might initially suspect. Since
GPUs are good at drawing 3D scenes, and since 3D scenes seem “more complicated”
than 2D scenes, it may feel like a natural conclusion that GPUs should handle 2D
trivially. They do not. The rasterization techniques used in 3D are poorly
suited to 2D tasks like clipping to vector paths or antialiasing, and those that
produce the best results have the worst performance. Worse, these traditional
techniques can start to perform very badly in 2D once there are lots of blend
groups or clip regions involved, since each needs its own temporary buffer and
draw call.</p>

<p>There is some promising new
work (such as <a href="https://github.com/linebender/piet-gpu">piet-gpu</a>) that use <a href="https://anteru.net/blog/2018/intro-to-compute-shaders/">compute shaders</a> and can
draw scenes in the 2D imaging model with smoothly consistent performance. This
is an area of active research. One potential limitation is that compute shaders
are a relatively new feature, and are only available in GPUs made in the last
five-or-so years. Other renderers, including <a href="https://github.com/servo/webrender">WebRender</a> as used by Firefox,
use more traditional techniques and have wider compatibility.</p>

<p>In any case, you have options, all with various trade-offs, and none of them
clearly the winner.</p>

<h4 id="animation">Animation</h4>

<p>Oh, also: whatever approach you choose, you are going to also need to provide an
ergonomic, performant animation API. It’s worth thinking about this early; it will be
annoying to try and add it in later.</p>

<h4 id="text">Text</h4>

<p>Regardless of how you paint, you are going to need to <a href="https://gankra.github.io/blah/text-hates-you/">render text</a>.
A GUI framework should at the very least support rich text, complex scripts, text
layout (including things like line breaking, alignment, and justification,
and ideally things like line-breaking within arbitrary paths). You need to
support emoji. You also need to support <a href="https://lord.io/text-editing-hates-you-too/">text editing</a>,
including support for right-to-left and <a href="https://en.wikipedia.org/wiki/Bidirectional_text">BiDi</a>. Suffice to say that this is a
very large undertaking. Realistically, you have two options: either you bundle
<a href="https://github.com/harfbuzz/harfbuzz">HarfBuzz</a>, or you use the platform text APIs: <a href="https://developer.apple.com/documentation/coretext">CoreText</a> on macOS,
<a href="https://docs.microsoft.com/en-us/windows/win32/directwrite/direct-write-portal">DirectWrite</a> on Windows, and likely <a href="https://pango.gnome.org">Pango</a> + HarfBuzz on linux. There are a
few other alternatives, including some promising Rust projects (such as
<a href="https://github.com/yeslogic/allsorts">Allsorts</a>, <a href="https://github.com/RazrFalcon/rustybuzz">rustybuzz</a>, and <a href="https://github.com/dfrg/swash">swash</a>) but none of these are quite complete
enough to fully replace HarfBuzz or the platform text APIs just yet.</p>

<h4 id="the-compositor">The compositor</h4>

<p>2D graphics are a major part of the drawing that might be done by a desktop
application, but they are not the <em>only</em> part. There are two other common cases
worth mentioning: video, and 3D graphics. In both of these cases, we want to
be able to take advantage of available hardware: for video, the hardware
<a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC_products_and_implementations#Decoding">H.264 decoder</a>, and for 3D the GPU.
What this comes down to is instructing the operating system to
embed a video or 3D view in some region of our window, and this means
interacting with the <a href="https://raphlinus.github.io/ui/graphics/2020/09/13/compositor-is-evil.html">compositor</a>. The compositor is the component of the
operating system that is responsible for taking display data from various
sources (different windows from different programs, video playback, GPU output)
and assembling it into a coherent picture of your desktop.</p>

<p>Perhaps the best way to think about why this matters to us is to think about
interactions with scrolling. If you have a scrollable view, and that view
contains a video, you would like to have the video move in sync with the view’s
other content when the view is scrolled. This is harder than it sounds. You
can’t just define a region of your window and embed a video in it; you need to
somehow tell the OS to move the video in sync with your scrolling.</p>

<h4 id="web-views">Web views</h4>

<p>Let’s not forget these: sooner or later, someone is going to want to display
some HTML (or an actual website!) within their application. We’d <em>really</em> rather
not bundle an entire browser engine to accomplish this, but making use of a
platform webview <em>also</em> implicates the compositor and overall significantly
complicates our lives. Maybe your users don’t really need that web view after
all? In any case, something to think about.</p>

<h3 id="handling-input">Handling input</h3>

<p>Once you have figured out how to manage windows and how you are going to draw
your content, you need to handle user input. We can roughly divide input into
<em>pointer</em>, <em>keyboard</em>, and <em>other</em>, where <em>other</em> is stuff like joysticks,
gamepads, and other <a href="https://en.wikipedia.org/wiki/USB_human_interface_device_class">HID devices</a>. We will ignore this last
category, except to say that this would be nice to have, but doesn’t need to be
a priority.
Finally, there are input events that originate from system accessibility
features; we will deal with these when we talk about accessibility.</p>

<p>For both pointer and keyboard events, there is a relatively easy approach, and
then there is a principled, correct approach that is significantly harder to get
right.</p>

<h4 id="pointer-input">Pointer input</h4>

<p>For pointer events, the easy approach is to present an API that sends mouse events,
and then sends trackpad events in a way that makes them look like mouse events:
ignoring multiple touches, pressure, or other features of touch gestures that
do not have obvious analogs to the mouse. The <em>hard</em> approach is to implement
some equivalent of the web’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent">PointerEvent</a> API, where you are able to fully
represent information on multi-touch (both from a trackpad as well as a
touch-sensitive display) and stylus input events.</p>

<p>Doing pointer events the easy way is…okay, assuming you can also provide
events for common trackpad gestures like pinch-to-zoom and two-finger-scroll,
without which your framework is going to immediately frustrate many users.
And while the number of applications that need or want to do advanced gesture recognition
or which expect to handle stylus input is fairly low, they certainly
exist, and a desktop application framework that does not support these cases is
fundamentally limited.</p>

<h4 id="keyboard-input">Keyboard input</h4>

<p>The situation is worse for keyboard input, in two ways: here the hard case is
both harder to do <em>and</em> doing it the ‘easy way’ is fundamentally limiting; going
the easy route means your framework is essentially useless for much of the world’s
population.</p>

<p>The easy way, for keyboard input, is very easy: the keys of a keyboard
are generally associated with a character or string, and when the user presses a key,
you can take that string and smush it in at the cursor position in the active
text field. This works <em>reasonably</em> well for unilingual English text, and
slightly-less-well-but-at-least-sort-of
for general <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1</a> languages plus scripts that behave similarly to latin, such
as Greek or Cyrillic or Turkish.
Unfortunately (but not coincidentally) a large number of programmers mostly just
type ASCII, but much of the world does not. Serving <em>these</em> users requires
integrating with the platform text input and IME system, a problem that has the unfortunate
property of being both fundamentally necessary and incredibly fiddly.</p>

<p>IME stands for <a href="https://en.wikipedia.org/wiki/Input_method">Input Method Editor</a>, and is a catch-all term for the platform
specific mechanisms that convert keyboard events into text. This process is
fairly trivial for most European languages and scripts, where at most you
may need to insert an accented vowel, but it is much more complicated for the
east-Asian languages (Chinese, Japanese, and Korean, or collectively, CJK) as
well as for various other <a href="https://harfbuzz.github.io/complex-scripts.html">complex scripts</a>.</p>

<div>
<video controls="" width="446" height="282">

    <source src="/assets/desktop_gui/ime.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>
<p>Using a Japanese IME on macOS</p>
</div>

<p>Let’s stick to CJK, for the purpose of this example. In these scripts, keyboard
events do not correspond directly to input; instead <a href="https://github.com/linebender/druid/pull/1636">keyboard events are composed</a>
together into input text as you you type, but that text may change significantly
between keystrokes, and the changes can affect not just the current character
but also text that has previously been entered.</p>

<p>This is complicated in a number of ways. Firstly, it means that the interaction
between a given text field and the IME is <em>bidirectional</em>: the IME needs to be
able to both modify the contents of the textbox, but it also needs to be able to
query the current contents of the textbox, in order to have the appropriate
context with which to interpret events. Similarly, it needs to be notified of
changes in the cursor position or selection state; the same key-press may
produce different output based on the surrounding text. Secondly, we also need
to keep the IME up-to-date on the position of the textbox on the screen, since
the IME often presents a ‘candidate’ window of possible inputs for the active
sequence of keyboard events. Finally (and not like <em>actually</em> finally, just that
I’m three thousand words in to this and not nearly done yet) implementing IME in
a cross-platform way is significantly complicated by the differences in the
underlying platform APIs; macOS requires editable text fields to
<a href="https://developer.apple.com/documentation/appkit/nstextinputclient">implement a protocol</a>, and then lets the text field handle accepting
and applying changes from the IME, whereas the <a href="https://docs.microsoft.com/en-us/windows/win32/intl/input-method-manager-reference">Windows API</a> uses a
<a href="https://docs.microsoft.com/en-us/windows/win32/api/imm/nf-imm-immgetcontext">lock and release</a> mechanism; designing an abstraction over both
of these approaches is an additional layer of complexity.</p>

<p>There’s one additional complication related to text input: on macOS,
you need to support the <a href="https://www.hcs.harvard.edu/~jrus/site/system-bindings.html">Cocoa Text System</a>, which allows the user
to specify system-wide keybindings that can issue a variety of text editing and
navigation commands.</p>

<p>To summarize: handling input correctly is a lot of work, and if you don’t do it
your framework is basically a toy.</p>

<h3 id="accessibility">Accessibility</h3>

<p>A desktop application framework has to support native accessibility APIs, and
should ideally do this in a way that does not require special thought or work
from the application developer. Accessibility is a catchall term for a large
number of assistive technologies; the most crucial being support for
<a href="https://www.youtube.com/watch?v=Jao3s_CwdRU">screen readers</a> and assisted navigation. Screen reader support means
interoperating with platform APIs that describe the structure and contents of
your application, and <a href="https://developer.apple.com/videos/play/wwdc2021/10120/">assisted navigation</a> means providing a method of moving
between elements on the screen linearly, allowing elements to be highlighted,
described and activated in turn using a keyboard or joystick.</p>

<p>In addition to these core features, your framework should also respect the
user’s system-level preferences regarding things like text size, reduced color
contrast, and reduced animation. Related, but not accessibility, exactly: you
would like to support dark mode, as well as things like a user-chosen accent
colour.</p>

<h3 id="internationalization-and-localization">Internationalization and Localization</h3>

<p>Your framework should support internationalization. The most obvious component
of this is localization of strings, but it also includes things like mirroring
interfaces in right-to-left locales. Additionally, information like times,
dates, currency units, calendar units, names, sequences, and general
<a href="https://developer.apple.com/videos/play/wwdc2020/10160/">formatting of numerical data</a> should respect the user’s
locale. If this is not a problem you have thought about before, then it is
almost certainly more complicated than you imagine. But don’t worry:
<a href="https://www.unicode.org/reports/tr35/">there’s a standard</a>. All you need to do is implement it.</p>

<h3 id="other-common-features">Other common features</h3>

<ul>
  <li><strong>Copy/paste &amp; drag-and-drop</strong>: These overlap, although drag-and-drop is more
complicated. For copy/paste, you want to support not just text, but also other
<a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats">standard formats</a>, and additionally you need to
support user defined formats. For paste, you need to let the user inspect the
clipboard, see the available formats, and retrieve the data. Fun fact: on
macOS and Windows the API to retrieve data from the clipboard is synchronous,
and on x11 it is async. Have fun. For drag and drop, hopefully you can reuse
some of the work you did when you reimplemented window tabs?</li>
  <li><strong>Printing</strong>: <em>printing</em>? Who needs <em>printing</em>?? Well: your users, unfortunately.
Don’t worry, it’s probably not that hard.</li>
  <li>App resumption and window restoration: you’re going to want to remember where
the user’s windows were, and put them back when you relaunch. I hope they
didn’t unplug a monitor.</li>
  <li><strong>Assets and app packaging</strong>: You’re going to want to let the user bundle up their
application. This means doing things like generating your app’s
<a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html">manifest</a>, validating required assets like app icons, and
localization data, and making these things available at runtime per the
conventions of the target platform.</li>
  <li><strong>Async</strong> You <em>do</em> have nice ergonomic async support, don’t you?</li>
</ul>

<h4 id="and-other-less-common-features">And other less common features</h4>

<p>In addition to all of the features that are shared across most desktop
environments, there are also platform-specific features to be thought about:
some of these are stylistic things, like APIs to add
<a href="https://developer.apple.com/documentation/appkit/nsvisualeffectview">transparency or vibrancy</a> to some part of your window; or
support for adding a <a href="https://developer.apple.com/design/human-interface-guidelines/macos/extensions/menu-bar-extras/">menu bar extra</a> or working with <a href="https://docs.microsoft.com/en-us/windows/win32/shell/taskbar-extensions">task bar extensions</a>,
or <a href="https://developer.apple.com/design/human-interface-guidelines/macos/system-capabilities/quick-look/">quick look</a>, or implementing a <a href="https://docs.microsoft.com/en-us/windows/win32/shell/control-panel-applications">control panel item</a>,
or any number of other things. Your framework should at least make these things
<em>possible</em>. At the very least, you should provide opportunities for the user to
drop down and work with the platform APIs directly, so that they
have some escape hatch available for when they really need to achieve something
that you haven’t foreseen (or gotten around to yet).</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>That feels like a reasonable place to stop; there are certainly things I’ve
overlooked, but I hope I’ve touched on the most significant ones. Once you have
an idea of the things you need to support and implement, you can start thinking
about how to fit it all together.</p>

<h3 id="designing-cross-platform-apis">Designing cross-platform APIs</h3>

<p>One of the more subtle and interesting challenges of designing your GUI
framework is designing the API. Here, you face a very particular problem: you
are attempting to design an API that provides a common interface for a set of
underlying platform APIs that are fundamentally different.</p>

<p>A nice example is around your application’s menus. As mentioned earlier, linux
and Windows generally expect a menu bar to exist on your app’s individual
windows, whereas macOS has a single menu bar that is a component of the desktop
environment, and which becomes your application menu when your application is
active.</p>

<p>To handle this naively, you might have separate ‘application’ and ‘window’
menus, and then you might have conditional code to update one or the other
based on conditional compilation or runtime checks. This ends up being a lot of
duplicate code, however, and it will be easy to get wrong. In this particular
case, I think there is a fairly clear, fairly simple API that works on both
platforms. In your framework, you treat menus as being a property of the window:
on Windows and Linux this is actually the case, so that’s fine, and then on
macOS you set the application menu to be the menu of the currently active
window, changing it as needed when windows gain or lose active status.</p>

<p>This is a fairly clean example, and many other APIs are not so clear cut. In
general, designing these cross-platform APIs is a process of carefully reading
through and experimenting with the platform-specific APIs, and then trying to
identify the set of shared features and functionality that you can express in
the abstraction above; and when no cleanly shared set of features exist, it
means coming up with some <em>other</em> API that can at least be implemented in terms
of what is provided by the platform.</p>

<h3 id="the-seduction-of-the-web-view">The seduction of the web view</h3>

<p>All of this platform complexity, with all of its subtle design flaws, missing
documentation, and mysterious bugs, has already been worked around successfully
by a few major cross-platform GUI frameworks: the major browsers,
Chrome, Firefox, and (increasingly) Edge. (Safari doesn’t need to worry about this,
because it isn’t cross-platform.)</p>

<p>The browsers have had to figure all of this out: the child windows, the text
input, the <em>accessibility</em>,
the font fallback, the compositor, the performant painting, the drag and drop…it’s
all there.</p>

<p>If you’d like to do something cross-platform, then, there is a very natural and
very understandable impulse to reach for web technologies, either by creating a
real web app that runs in the browser, or else by leaning on the browser engine
and using it to render your UI in a native window, à la <a href="https://www.electronjs.org">Electron</a>. This does
come with obvious drawbacks, particularly around performance (on various axes,
such as application size and memory consumption) as well as ‘look and feel’ (on
which we’ll expand shortly) but it sure does make life a lot simpler, and the
more time I spend working on projects in this space, the more sympathetic I
become to folks who choose the browser side of this trade-off.</p>

<h3 id="on-native-look-and-feel">On “native look and feel”</h3>

<p>Something that comes up frequently in discussions of cross-platform GUI work is
a collection of things I’ll refer to as “native look and feel”. This is vague,
and I think it’s helpful to split it in two: <em>native behaviour and convention</em>,
and <em>native appearance</em> (although these can overlap.)</p>

<p><strong>Native behaviour</strong> refers to many of the things we have already discussed, and
some other things besides. Some examples would be scroll behaviour: does your
application respect the user’s scroll preferences? Does your application have
the same acceleration curves when scrolling as the default platform scroll
views? Does your application handle standard system keyboard shortcuts, for
instance for maximizing or hiding a window? Does IME work? This extends to other
less obvious conventions, as well: does the application store user data in the
locations that are conventional to the current platform? Does it use the system
file open/save dialogs? Does it show expected menus, containing expected menu
items?</p>

<p>These things are more important on some platforms than on others. On the Mac, in
particular, getting these behavioural details correct is important: the Mac more
than other platforms is designed around <a href="https://developer.apple.com/design/human-interface-guidelines/">specific conventions</a>, and Mac
application developers have historically been diligent about respecting these.
This in turn has helped create a community of users who value these conventions
and are <a href="https://www.sketch.com/blog/2020/10/26/part-of-your-world-why-we-re-proud-to-build-a-truly-native-mac-app/">sensitive to them</a>, and breaking from them is bound to
<a href="https://daringfireball.net/linked/2020/03/20/mac-assed-mac-apps">upset this cohort</a>.
On Windows, things are slightly more relaxed; there has historically been a
greater diversity of software on Windows, and Microsoft has never been quite as
dogmatic as Apple has been about how an application should look and behave.</p>

<p><strong>Native appearance</strong> refers more to how an application looks. Do your buttons
look like native buttons? Do they have the same sizing and gradients? Do you
more generally use the controls a platform expects for a given interaction, for
instance preferring a checkbox on desktop but a toggle on mobile?</p>

<p>This is additionally complicated by the fact that ‘native appearance’ changes
between not just platforms but also OS releases, to the point where looking
‘native’ on a given machine would require runtime detection of the OS version.</p>

<p>While all of this is <em>possible</em>, it is starting to add a huge amount of
additional work, and for a modestly staffed project this can be hard to justify.
For that reason, I am personally forgiving of a project that moves away from
trying to do pixel-perfect replication of the platform’s built-in widgets, in
favour of just trying to do something tasteful and coherent, while providing the
tools necessary for the framework’s users to style things as needed.</p>

<h3 id="fin">Fin</h3>

<p>I hope this catalog has helped at least vaguely define the scope of the problem.
None of the things I have described here are impossible, but doing them all, and
doing them <em>well</em>, is quite a bit of work.</p>

<p>This last point is worth ending on: for this work to be useful, it is not enough
that it <em>exist</em>. If you would like people to use your framework, you are going
to have to make it attractive to them: providing a good API that is easy to use,
that is idiomatic in the host language, that is well documented, and that lets
them solve their actual problems.</p>


      </article>

    </div></div>
  </body>
</html>
