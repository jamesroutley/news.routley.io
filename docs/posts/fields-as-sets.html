<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/fields-as-sets/">Original</a>
    <h1>fields as sets</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, February 13, 2023</em></p><p>Today, let&#39;s look at how relationships between <code>sig</code>s in <a href="https://bytes.zone/projects/learning-alloy/">Alloy</a> work.</p><p>Say, for example, you&#39;re modeling database tables (<a href="https://bytes.zone/posts/modeling-database-tables-in-alloy/">as I have previously</a>) and want to represent the relationship between people and their favorite flavor of ice cream:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Person {
</span><span>  favoriteIceCream</span><span>: lone</span><span> Flavor,
</span><span>}
</span><span>
</span><span>sig</span><span> Flavor {}
</span></code></pre><p>You can ask Alloy for examples of this, and it will show you a bunch of different ways <code>Person</code> and <code>Flavor</code> can be related. For example, here&#39;s an instance where there are three distinct people who each like a different flavor:</p><p><img src="https://bytes.zone/images/three-people-three-flavors.png" alt="an Alloy instance describing three people, each with a distinct favorite ice cream flavor. The people and flavors are not connected otherwise."/></p><p>The <code>favoriteIceCream</code> relationship here can be used in a bunch of interesting ways. For example, if we want to assert (contrary to our use of <code>lone</code>) that everybody has a favorite ice cream flavor, we&#39;d do it like this:</p><pre><code><span>check NobodyDoesntLikeIceCream {
</span><span>  all p: Person | some p.favoriteIceCream
</span><span>}
</span></code></pre><p>Alloy finds a counterexample for this (since we used <code>lone</code>, which means some people don&#39;t have a favorite flavor of ice cream), but it demonstrates the first usage of the relation: looking up fields as if they were methods or attribute accesses in an object-oriented language. <code>x.fieldName</code> will always work basically like you might have already intuited.</p><p>Relations can do more than this, though, since they&#39;re actually secretly sets of tuples. If you load up the instance above in Alloy and examine it in the table view, you&#39;ll see that it&#39;s defined something like this:</p><table><thead><tr><th><code>this/Person</code></th><th><code>favoriteIceCream</code></th></tr></thead><tbody><tr><td><code>Person$0</code></td><td><code>Flavor$2</code></td></tr><tr><td><code>Person$1</code></td><td><code>Flavor$1</code></td></tr><tr><td><code>Person$2</code></td><td><code>Flavor$2</code></td></tr></tbody></table><p>This looks suspiciously like a table in a database, right? Well, good news: it basically works that way too!</p><p>What <code>.</code> does under the hood is essentially equivalent to a SQL join: it selects rows matching a pattern on the left and gives you access to the equivalent rows on the right.</p><p>The cool thing about <code>.</code> is that it can do this with a set in either position. Even though it <em>looks like</em> you&#39;re using a single value with <code>p.favoriteIceCream</code>, <code>p</code> is actually a subset of peopleâ€”it just happens to be one with only one member.</p><p>So what other sets can you do this to? Well, if we add a <code>children</code> field like this:</p><pre><code><span>sig Person {
</span><span>  children: set Person,
</span><span>  favoriteIceCream: lone Flavor,
</span><span>}
</span></code></pre><p>We could look at some parent <code>p</code> and get the ice cream flavors they&#39;d need to buy for their children with <code>p.children.favoriteIceCream</code>, or their grandchildren with <code>p.children.children.favoriteIceCream</code>. Chaining works in the way you&#39;d expect, except with set semantics instead of having to do loops or list comprehensions.</p><p>We could also get the set of reachable ice cream flavors by using the whole set of <code>Person</code> on the left: <code>Person.favoriteIceCream</code>. We could also get the sad, lonely flavors that nobody loves with <code>Flavor - Person.favoriteIceCream</code>.</p><p>That&#39;s not all you can do, though. The <code>~</code> operator flips a relation around: if <code>favoriteIceCream</code> is a mapping from <code>Person</code> to <code>Flavor</code>, <code>~favoriteIceCream</code> is one from <code>Flavor</code> to <code>Person</code>. We can then do the same tricks as above. For example, we can find out who doesn&#39;t like ice cream at all by doing <code>Person - Flavor.~favoriteIceCream</code> (since that will be all the people, minus the people who have a favorite ice cream set.)</p><p>For me, realizing that basically everything is a set, and that <code>~</code> and <code>.</code> worked set-wise unlocked a lot of uses for Alloy that I hadn&#39;t considered before. I hope reading this helped you, too!</p><p>By the way, we haven&#39;t even gone over all the interesting things you can do: <a href="https://alloy.readthedocs.io">Hillel Wayne&#39;s documentation site</a> has a big section on <a href="https://alloy.readthedocs.io/en/latest/language/sets-and-relations.html#sets-and-relations">sets and relations</a> that&#39;s worth a read if you&#39;d like to learn more.</p></article></div>
  </body>
</html>
