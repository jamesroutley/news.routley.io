<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://death.andgravity.com/f-re">Original</a>
    <h1>The unreasonable effectiveness of f-strings and re.verbose</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>

<p>... in which we look at one or two ways to make life easier
when working with Python regular expressions.</p>
<p>tl;dr: <strong>You can compose verbose regular expressions using f‍-‍strings.</strong></p>
<p>Here&#39;s a real-world example – instead of this:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>pattern</span> <span>=</span> <span>r</span><span>&#34;((?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?)(.*?)(?=(?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?(?![^\w\s])|$)&#34;</span>
</code></pre></div>
</td></tr></tbody></table>
<p>... do this:</p>
<table><tbody><tr><td><div><pre><code><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>code</span> <span>=</span> <span>r</span><span>&#34;&#34;&#34;</span>
<span>[A-Z]*H  # prefix</span>
<span>\d+      # digits</span>
<span>[a-z]*   # suffix</span>
<span>&#34;&#34;&#34;</span>

<span>multicode</span> <span>=</span> <span>fr</span><span>&#34;&#34;&#34;</span>
<span>(?: \( \s* )?               # maybe open paren and maybe space</span>
<span>{</span><span>code</span><span>}</span><span>                      # one code</span>
<span>(?: \s* \+ \s* </span><span>{</span><span>code</span><span>}</span><span> )*    # maybe followed by other codes, plus-separated</span>
<span>(?: \s* [\):+] )?           # maybe space and maybe close paren or colon or plus</span>
<span>&#34;&#34;&#34;</span>

<span>pattern</span> <span>=</span> <span>fr</span><span>&#34;&#34;&#34;</span>
<span>( </span><span>{</span><span>multicode</span><span>}</span><span> )             # code (capture)</span>
<span>( .*? )                     # message (capture): everything ...</span>
<span>(?=                         # ... up to (but excluding) ...</span>
<span>    </span><span>{</span><span>multicode</span><span>}</span><span>             # ... the next code</span>
<span>        (?! [^\w\s] )       # (but not when followed by punctuation)</span>
<span>    | $                     # ... or the end</span>
<span>)</span>
<span>&#34;&#34;&#34;</span>
</code></pre></div>
</td></tr></tbody></table>
<details>
<summary>
For comparison, the same pattern without f‍-‍strings (click to expand).
</summary>
<table><tbody><tr><td><div><pre><code><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>pattern</span> <span>=</span> <span>r</span><span>&#34;&#34;&#34;</span>
<span>(                       # code (capture)</span>
<span>    # BEGIN multicode</span>

<span>    (?: \( \s* )?       # maybe open paren and maybe space</span>

<span>    # code</span>
<span>    [A-Z]*H  # prefix</span>
<span>    \d+      # digits</span>
<span>    [a-z]*   # suffix</span>

<span>    (?:                 # maybe followed by other codes,</span>
<span>        \s* \+ \s*      # ... plus-separated</span>

<span>        # code</span>
<span>        [A-Z]*H  # prefix</span>
<span>        \d+      # digits</span>
<span>        [a-z]*   # suffix</span>
<span>    )*</span>

<span>    (?: \s* [\):+] )?   # maybe space and maybe close paren or colon or plus</span>

<span>    # END multicode</span>
<span>)</span>

<span>( .*? )                 # message (capture): everything ...</span>

<span>(?=                     # ... up to (but excluding) ...</span>
<span>    # ... the next code</span>

<span>    # BEGIN multicode</span>

<span>    (?: \( \s* )?       # maybe open paren and maybe space</span>

<span>    # code</span>
<span>    [A-Z]*H  # prefix</span>
<span>    \d+      # digits</span>
<span>    [a-z]*   # suffix</span>

<span>    (?:                 # maybe followed by other codes,</span>
<span>        \s* \+ \s*      # ... plus-separated</span>

<span>        # code</span>
<span>        [A-Z]*H  # prefix</span>
<span>        \d+      # digits</span>
<span>        [a-z]*   # suffix</span>
<span>    )*</span>

<span>    (?: \s* [\):+] )?   # maybe space and maybe close paren or colon or plus</span>

<span>    # END multicode</span>

<span>        # (but not when followed by punctuation)</span>
<span>        (?! [^\w\s] )</span>

<span>    # ... or the end</span>
<span>    | $</span>
<span>)</span>

<span>&#34;&#34;&#34;</span>
</code></pre></div>
</td></tr></tbody></table>
<p>It&#39;s better than the non-verbose one,
but even with careful formatting and comments,
the repetition makes it pretty hard to follow
– and wait until you have to change something!</p>
</details>
<p>Read on for details and some caveats.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Formatted string literals (<a href="https://docs.python.org/3/glossary.html#term-f-string">f‍-‍strings</a>) were added in Python 3.6,
and provide a way to embed expressions inside string literals,
using a syntax similar to that of <a href="https://docs.python.org/3/library/stdtypes.html#str.format">str.format()</a>:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>name</span> <span>=</span> <span>&#34;world&#34;</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt; </span><span>&#34;Hello, </span><span>{name}</span><span>!&#34;</span><span>.</span><span>format</span><span>(</span><span>name</span><span>=</span><span>name</span><span>)</span>
<span>&#39;Hello, world!&#39;</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt; </span><span>f</span><span>&#34;Hello, </span><span>{</span><span>name</span><span>}</span><span>!&#34;</span>
<span>&#39;Hello, world!&#39;</span>
</code></pre></div>
<p>Verbose regular expressions (<a href="https://docs.python.org/3/library/re.html#re.VERBOSE">re.VERBOSE</a>) have been around since forever,
and allow writing regular expressions
with non-significant whitespace and comments:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>text</span> <span>=</span> <span>&#34;H1 code (AH2b+EUH3) fancy code&#34;</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt; </span><span>code</span> <span>=</span> <span>r</span><span>&#34;[A-Z]*H\d+[a-z]*&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>code</span><span>,</span> <span>text</span><span>)</span>
<span>[&#39;H1&#39;, &#39;AH2b&#39;, &#39;EUH3&#39;]</span>
<span>&gt;&gt;&gt;</span>
<span>&gt;&gt;&gt; </span><span>code</span> <span>=</span> <span>r</span><span>&#34;&#34;&#34;</span>
<span>... </span><span>[A-Z]*H  # prefix</span>
<span>... </span><span>\d+      # digits</span>
<span>... </span><span>[a-z]*   # suffix</span>
<span>... </span><span>&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>code</span><span>,</span> <span>text</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;H1&#39;, &#39;AH2b&#39;, &#39;EUH3&#39;]</span>
</code></pre></div>
<h2 id="the-one-weird-trick">The &#34;one weird trick&#34;</h2>
<p>Once you see it, it&#39;s obvious
– you can use f‍-‍strings to compose regular expressions:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>multicode</span> <span>=</span> <span>fr</span><span>&#34;&#34;&#34;</span>
<span>... </span><span>(?: \( )?         # maybe open paren</span>
<span>... </span><span>{</span><span>code</span><span>}</span><span>            # one code</span>
<span>... </span><span>(?: \+ </span><span>{</span><span>code</span><span>}</span><span> )*  # maybe other codes, plus-separated</span>
<span>... </span><span>(?: \) )?         # maybe close paren</span>
<span>... </span><span>&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>multicode</span><span>,</span> <span>text</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;H1&#39;, &#39;(AH2b+EUH3)&#39;]</span>
</code></pre></div>
<p>It&#39;s so obvious, it only took me three years to do it
after I started using Python 3.6+,
despite using both features during all that time.</p>
<p>Of course, there&#39;s any number of libraries
for building regular expressions;
the benefit of this is that it has zero dependencies,
and zero extra things you need to learn.</p>




<h2 id="caveats">Caveats</h2>
<h3 id="hashes-and-spaces-need-to-be-escaped">Hashes and spaces need to be escaped</h3>
<p>Because a hash is used to mark the start of a comment,
and spaces are mostly ignored,
you have to represent them in some other way.</p>
<p>The documentation of <a href="https://docs.python.org/3/library/re.html#re.VERBOSE">re.VERBOSE</a> is quite helpful:</p>
<blockquote>
<p>When a line contains a <code>#</code> that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such <code>#</code> through the end of the line are ignored.</p>
</blockquote>
<p>That is, this won&#39;t work as the non-verbose version:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+#\d+&#34;</span><span>,</span> <span>&#34;1#23a&#34;</span><span>)</span>
<span>[&#39;1#23&#39;]</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+ # \d+&#34;</span><span>,</span> <span>&#34;1#23a&#34;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1&#39;, &#39;23&#39;]</span>
</code></pre></div>
<p>... but these will:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+ [#] \d+&#34;</span><span>,</span> <span>&#34;1#23a&#34;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1#23&#39;]</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+ \# \d+&#34;</span><span>,</span> <span>&#34;1#23a&#34;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1#23&#39;]</span>
</code></pre></div>
<p>The same is true for spaces:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+ [ ] \d+&#34;</span><span>,</span> <span>&#34;1 23a&#34;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1 23&#39;]</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;\d+ \  \d+&#34;</span><span>,</span> <span>&#34;1 23a&#34;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1 23&#39;]</span>
</code></pre></div>

<p>When composing regexes,
ending a pattern on the same line as a comment
might accidentally comment the following line in the enclosing pattern:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>one</span> <span>=</span> <span>&#34;1 # comment&#34;</span>
<span>&gt;&gt;&gt; </span><span>onetwo</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>one</span><span>}</span><span> 2&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>onetwo</span><span>,</span> <span>&#39;0123&#39;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;1&#39;]</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>onetwo</span><span>)</span>
<span>1 # comment 2</span>
</code></pre></div>
<p>This can be avoided by always ending the pattern on a new line:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>one</span> <span>=</span> <span>&#34;&#34;&#34;</span><span>\</span>
<span>... </span><span>1 # comment</span>
<span>... </span><span>&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>onetwo</span> <span>=</span> <span>f</span><span>&#34;&#34;&#34;</span><span>\</span>
<span>... </span><span>{</span><span>one</span><span>}</span><span> 2</span>
<span>... </span><span>&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>onetwo</span><span>,</span> <span>&#39;0123&#39;</span><span>,</span> <span>re</span><span>.</span><span>VERBOSE</span><span>)</span>
<span>[&#39;12&#39;]</span>
</code></pre></div>
<p>While a bit cumbersome,
in real life most patterns would span multiple lines anyway,
so it&#39;s not really an issue.</p>
<p>(Note that this is only needed if you use comments.)</p>
<h3 id="brace-quantifiers-need-to-be-escaped">Brace quantifiers need to be escaped</h3>
<p>Because f‍-‍strings already use braces for replacements,
to represent brace quantifiers you must double the braces:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>&#34;m</span><span>{2}</span><span>&#34;</span><span>,</span> <span>&#34;entire mm but only two of mmm&#34;</span><span>)</span>
<span>[&#39;mm&#39;, &#39;mm&#39;]</span>
<span>&gt;&gt;&gt; </span><span>letter</span> <span>=</span> <span>&#34;m&#34;</span>
<span>&gt;&gt;&gt; </span><span>pattern</span> <span>=</span> <span>f</span><span>&#34;</span><span>{</span><span>letter</span><span>}</span><span>{{</span><span>2</span><span>}}</span><span>&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>pattern</span><span>,</span> <span>&#34;entire mm but only two of mmm&#34;</span><span>)</span>
<span>[&#39;mm&#39;, &#39;mm&#39;]</span>
</code></pre></div>
<h3 id="i-don-t-control-the-flags">I don&#39;t control the flags</h3>
<p>Maybe you&#39;d like to use verbose regexes,
but don&#39;t control the flags passed to the <a href="https://docs.python.org/3/library/re.html">re</a> functions
(for example, because you&#39;re passing the regex to an API).</p>
<p>Worry not! The regular expression <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax">syntax</a> supports inline flags:</p>
<blockquote>
<dl>
<dt><code>(?aiLmsux)</code></dt>
<dd>(One or more letters [...]) The group matches the empty string; the letters set the corresponding flags: [...] <a href="https://docs.python.org/3/library/re.html#re.VERBOSE">re.X</a> (verbose), for the entire regular expression. [...] This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the <a href="https://docs.python.org/3/library/re.html#re.compile">re.compile()</a> function. Flags should be used first in the expression string.</dd>
<dt><code>(?aiLmsux-imsx:...)</code></dt>
<dd>[...] The letters set or remove the corresponding flags [...] for the part of the expression. [...]</dd>
</dl>
</blockquote>
<p>So, you can do this:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>onetwo</span> <span>=</span> <span>&#34;&#34;&#34;</span><span>\</span>
<span>... </span><span>(?x)</span>
<span>... </span><span>1 # look, ma</span>
<span>... </span><span>2 # no flags</span>
<span>... </span><span>&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>onetwo</span><span>,</span> <span>&#39;0123&#39;</span><span>)</span>
<span>[&#39;12&#39;]</span>
</code></pre></div>
<p>... or this:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>onetwo</span> <span>=</span> <span>&#34;&#34;&#34;</span><span>\</span>
<span>... </span><span>(?x:</span>
<span>... </span><span>    1 # verbose until the close paren</span>
<span>... </span><span>)2&#34;&#34;&#34;</span>
<span>&gt;&gt;&gt; </span><span>re</span><span>.</span><span>findall</span><span>(</span><span>onetwo</span><span>,</span> <span>&#39;0123&#39;</span><span>)</span>
<span>[&#39;12&#39;]</span>
</code></pre></div>
<hr/>
<p>That&#39;s it for now.</p>
<p><strong>Learned something new today?</strong> Share this with others, it really helps!</p>

<h3 id="bonus-i-don-t-use-python">Bonus: I don&#39;t use Python</h3>
<p>Lots of other languages support the inline verbose flag, too!
You can build a pattern in whichever language is more convenient,
and use it in any other one. Languages like...</p>
<p>C (with <a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">PCRE</a> – and by extension, C++, PHP, and many others):</p>
<div><pre data-lang="Bash"><span></span><code><span>echo</span> <span>&#39;0123&#39;</span> <span>|</span> pcregrep -o <span>&#39;(?x)</span>
<span>1 2  # such inline</span>
<span>&#39;</span>
</code></pre></div>

<details>
<summary>
... yeah, the C version is actually really long, click to expand.
</summary>
<div><pre data-lang="C"><span></span><code><span>char</span><span> </span><span>*</span><span>pattern</span><span> </span><span>=</span><span></span>
<span>    </span><span>&#34;(?x)</span><span>\n</span><span>&#34;</span><span></span>
<span>    </span><span>&#34;1 2  # much verbose</span><span>\n</span><span>&#34;</span><span></span>
<span>;</span><span></span>
<span>char</span><span> </span><span>*</span><span>subject</span><span> </span><span>=</span><span> </span><span>&#34;0123&#34;</span><span>;</span><span></span>
<span>int</span><span> </span><span>subject_length</span><span> </span><span>=</span><span> </span><span>strlen</span><span>(</span><span>subject</span><span>);</span><span></span>

<span>int</span><span> </span><span>errornumber</span><span>;</span><span></span>
<span>PCRE2_SIZE</span><span> </span><span>erroroffset</span><span>;</span><span></span>

<span>pcre2_code</span><span> </span><span>*</span><span>re</span><span> </span><span>=</span><span> </span><span>pcre2_compile</span><span>(</span><span></span>
<span>    </span><span>(</span><span>PCRE2_SPTR</span><span>)</span><span>pattern</span><span>,</span><span></span>
<span>    </span><span>PCRE2_ZERO_TERMINATED</span><span>,</span><span></span>
<span>    </span><span>0</span><span>,</span><span></span>
<span>    </span><span>&amp;</span><span>errornumber</span><span>,</span><span></span>
<span>    </span><span>&amp;</span><span>erroroffset</span><span>,</span><span></span>
<span>    </span><span>NULL</span><span></span>
<span>);</span><span></span>

<span>pcre2_match_data</span><span> </span><span>*</span><span>match_data</span><span> </span><span>=</span><span> </span><span>pcre2_match_data_create_from_pattern</span><span>(</span><span>re</span><span>,</span><span> </span><span>NULL</span><span>);</span><span></span>

<span>pcre2_match</span><span>(</span><span></span>
<span>    </span><span>re</span><span>,</span><span></span>
<span>    </span><span>(</span><span>PCRE2_SPTR</span><span>)</span><span>subject</span><span>,</span><span></span>
<span>    </span><span>subject_length</span><span>,</span><span></span>
<span>    </span><span>0</span><span>,</span><span></span>
<span>    </span><span>0</span><span>,</span><span></span>
<span>    </span><span>match_data</span><span>,</span><span></span>
<span>    </span><span>NULL</span><span></span>
<span>);</span><span></span>

<span>PCRE2_SIZE</span><span> </span><span>*</span><span>ovector</span><span> </span><span>=</span><span> </span><span>pcre2_get_ovector_pointer</span><span>(</span><span>match_data</span><span>);</span><span></span>
<span>PCRE2_SPTR</span><span> </span><span>substring_start</span><span> </span><span>=</span><span> </span><span>(</span><span>PCRE2_SPTR</span><span>)</span><span>subject</span><span> </span><span>+</span><span> </span><span>ovector</span><span>[</span><span>0</span><span>];</span><span></span>
<span>size_t</span><span> </span><span>substring_length</span><span> </span><span>=</span><span> </span><span>ovector</span><span>[</span><span>1</span><span>]</span><span> </span><span>-</span><span> </span><span>ovector</span><span>[</span><span>0</span><span>];</span><span></span>
<span>printf</span><span>(</span><span>&#34;%.*s</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>(</span><span>int</span><span>)</span><span>substring_length</span><span>,</span><span> </span><span>(</span><span>char</span><span> </span><span>*</span><span>)</span><span>substring_start</span><span>);</span><span></span>
</code></pre></div>

</details>
<p>C#:</p>
<div><pre data-lang="C#"><span></span><code><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>new</span><span> </span><span>Regex</span><span>(</span><span>@&#34;(?x)</span>
<span>1 2  # wow</span>
<span>&#34;</span><span>).</span><span>Match</span><span>(</span><span>&#34;0123&#34;</span><span>));</span><span></span>
</code></pre></div>

<p>grep (only the GNU one):</p>
<div><pre data-lang="Bash"><span></span><code><span>echo</span> <span>&#39;0123&#39;</span> <span>|</span> grep -Po <span>&#39;(?x) 1 2  # no line&#39;</span>
</code></pre></div>

<p>Java (and by extension, lots of JVM languages, like Scala):</p>
<div><pre data-lang="Java"><span></span><code><span>var</span> <span>p</span> <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>
    <span>&#34;(?x)\n&#34;</span> <span>+</span>
    <span>&#34;1 2  # much class\n&#34;</span>
<span>);</span>
<span>var</span> <span>m</span> <span>=</span> <span>p</span><span>.</span><span>matcher</span><span>(</span><span>&#34;0123&#34;</span><span>);</span>
<span>m</span><span>.</span><span>find</span><span>();</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>));</span>
</code></pre></div>

<p>Perl:</p>
<div><pre data-lang="Perl"><span></span><code><span>&#34;0123&#34;</span> <span>=~</span><span> /(?x)(</span>
<span>1 2  # no scare</span>
<span>)/</span><span>;</span>
<span>print</span> <span>$1</span> <span>.</span> <span>&#34;\n&#34;</span><span>;</span>
</code></pre></div>

<p>PostgreSQL:</p>
<div><pre data-lang="PostgreSQL SQL dialect"><span></span><code><span>select</span><span> </span><span>substring</span><span>(</span><span></span>
<span>  </span><span>&#39;0123&#39;</span><span> </span><span>from</span><span></span>
<span>    </span><span>$$(?x)</span>
<span>    1 2  # such declarative</span>
<span>    $$</span><span></span>
<span>);</span><span></span>
</code></pre></div>

<p>Ruby:</p>
<div><pre data-lang="Ruby"><span></span><code><span>puts</span> <span>/(?x)</span>
<span>1 2  # nice</span>
<span>/</span><span>.</span><span>match</span><span>(</span><span>&#39;0123&#39;</span><span>)</span>
</code></pre></div>

<p>Rust:</p>
<div><pre data-lang="Rust"><span></span><code><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>new</span><span>(</span><span></span>
<span>    </span><span>r&#34;(?x)</span>
<span>    1 2  # much safe</span>
<span>    &#34;</span><span></span>
<span>).</span><span>unwrap</span><span>();</span><span></span>
<span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>re</span><span>.</span><span>find</span><span>(</span><span>&#34;0123&#34;</span><span>).</span><span>unwrap</span><span>().</span><span>as_str</span><span>());</span><span></span>
</code></pre></div>

<p>Swift:</p>
<div><pre data-lang="Swift"><span></span><code><span>let</span> <span>string</span> <span>=</span> <span>&#34;0123&#34;</span>
<span>let</span> <span>range</span> <span>=</span> <span>string</span><span>.</span><span>range</span><span>(</span>
    <span>of</span> <span>:</span> <span>&#34;&#34;&#34;</span>
<span>    (?x)</span>
<span>    1 2  # omg hi</span>
<span>    &#34;&#34;&#34;</span><span>,</span>
    <span>options</span> <span>:</span> <span>.</span><span>regularExpression</span>
<span>)</span>
<span>print</span><span>(</span><span>string</span><span>[</span><span>range</span><span>!])</span>
</code></pre></div>

<p>Notable languages that don&#39;t support inline verbose flags out of the box:</p>
<ul>
<li>C (regex.h – POSIX regular expressions)</li>
<li>C++ (regex)</li>
<li>Go (regexp)</li>
<li>Javascript</li>
<li>Lua</li>
</ul>













</div>
</div></div>
  </body>
</html>
