<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://melatonin.dev/blog/implementing-marios-stack-blur-15-times-in-cpp/">Original</a>
    <h1>Implementing Mario&#39;s Stack Blur 15 times in C&#43;&#43; (with tests and benchmarks)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This post walks through implementing <a href="https://underdestruction.com/2004/02/25/stackblur-2004/">Mario Klingemann’s Stack Blur algorithm</a>, a CPU image blurring algorithm. It’s the post I wish I had while building <a href="https://github.com/sudara/melatonin_blur">my vectorized C++ blur for the JUCE framework</a>.</p>



<p>Go <a href="#the-part-where-i-test-implement-and-benchmark-15-stack-blur-implementations">straight to the implementation section</a>, or check out the <a href="https://github.com/sudara/melatonin_blur#more-benchmarks">Benchmarks</a>.</p>



<h2 id="why-cpu-blurring-and-what-is-stack-blur"><a id="why-cpu-blurring-and-what-is-stack-blur" href="#why-cpu-blurring-and-what-is-stack-blur"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Why CPU blurring and what is Stack Blur?</h2>



<p>There are still times and places in 2023 where access to the GPU isn’t available or is convoluted. In these cases, Stack Blur is used (quite widely) for efficiently blurring images on the CPU. </p>



<p>In my case, I’m building cross-platform audio plugins with the <a href="http://juce.com">JUCE framework</a>. OpenGL is available, but deprecated and crusty on macOS. And it’s a can of worms I’d prefer not to open when all I want are some drop shadows and inner shadows (so I don’t have to use image strips like it’s the 1990s).</p>



<p>This is an example of a slider control in my synth:</p>



<figure><img decoding="async" src="https://melatonin.dev/wp-content/uploads/2023/11/281777535-1b84cad0-6044-444a-a2bd-ac8d33142eb9-1.gif" alt=""/><figcaption>2 inner shadows for the background track. </figcaption></figure>



<p>It’s vector-only and “brought to life” via 10 drop shadows and inner shadows that provide depth and lighting. There are up to 10 of these on a page, animating at 60 frames per second, along with lots of other UI. So they need to be <em>fast</em>.</p>



<p>A true gaussian image blur is quite expensive: CPU time scales up with both image size and radii. That makes the Stack Blur algorithm a perfect fit for places where GPU access is limited or unavailable.</p>



<p>Gaussian is a fancy synonym for a “normal distribution”. That’s statistics jargon for “bell curve-like”. In our context, to get a nice blur, we want each pixel to be affected by all the closest pixels surrounding it. The “influence” from these neighboring pixels tapers off like a bell curve. </p>



<figure><img decoding="async" width="1024" height="412" src="https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-1024x412.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-1024x412.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-710x286.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-150x60.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-768x309.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x-1536x618.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.40@2x.jpg 1680w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>A pixel’s value is distributed across the blur radius in a way that tapers</figcaption></figure>



<p>Before describing what the algorithm does, I’ll walk through some fundamental concepts.</p>



<h2 id="single-channel-stack-blur"><a id="single-channel-stack-blur" href="#single-channel-stack-blur"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Single Channel Stack Blur</h2>



<p>We’ll start by handling an image format that’s a single color, or <strong>single channel</strong>. Single channel images are what’s used under the hood to make drop shadows. Each pixel is just one value: brightness (later composited with a specified color).</p>



<p>Our brightness pixel values go from <code>0</code> to <code>255</code>. So  each pixel is stored as 8 bits. (In C++ this would be the <code>uint8_t</code> or <code>unsigned char</code>).</p>



<p>Here’s what our image might look like with some arbitrary values: </p>



<figure><img decoding="async" width="1024" height="639" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x-1024x639.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x-1024x639.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x-481x300.jpg 481w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x-150x94.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x-768x479.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.07@2x.jpg 1080w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h2 id="the-stack-blur-queue-concept"><a id="the-stack-blur-queue-concept" href="#the-stack-blur-queue-concept"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>The Stack Blur Queue concept</h2>



<p>In the world of image convolution (for example, gaussian blurring) there’s a 2D <strong>matrix</strong> that slides over the image. It uses fancy dot product magic [insert some hand waving] to calculate the result of the center pixel. </p>



<figure><img decoding="async" loading="lazy" width="902" height="552" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45@2x.jpg 902w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45@2x-490x300.jpg 490w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45@2x-150x92.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45@2x-768x470.jpg 768w" sizes="(max-width: 902px) 100vw, 902px"/><figcaption>The 2D matrix has to slide over every single pixel</figcaption></figure>



<p>GPUs are <em>great</em> at parallelizing this kind of convolution. CPUs not so much.</p>



<p>Stack Blur is different. It operates one row (or column) at a time (simulating 1D convolution) using weighted sums. Instead of living the fancy matrix life, we’re chilling with a humble array of values that Mario called the <strong>queue</strong> (in image convolution it’s usually referred to as a <strong>kernel</strong>).</p>



<figure><img decoding="async" loading="lazy" width="1024" height="518" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x-1024x518.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x-1024x518.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x-593x300.jpg 593w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x-150x76.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x-768x388.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-2@2x.jpg 1068w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>We’ll use the queue/kernel surrounding the pixel to perform some magic 🪄 to calculate the blurred value for the center pixel. In the illustration above, we’re calculating the blur value the center pixel (<code>255</code>) using the 5 pixels in the queue. We’ll get into the <em>exactly how</em> a bit later.</p>



<p>Because we always need a pixel at the center of the queue (the one we are blurring), our queue size is always odd-numbered. That means we can think in terms of a blurred pixel having a <strong>radius</strong>. </p>



<p>In our example, the radius is <code>2</code>: we have 2 pixels on either side of the center pixel. Specifying radius is also how people normally specify blur when designing for the web and in design programs such as Figma:</p>



<figure><img decoding="async" loading="lazy" width="476" height="392" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.46@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.46@2x.jpg 476w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.46@2x-364x300.jpg 364w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.46@2x-150x124.jpg 150w" sizes="(max-width: 476px) 100vw, 476px"/><figcaption>“Blur” = radius size in Figma</figcaption></figure>



<p>Our total queue size is double the radius plus our center pixel. <code>queueSize = radius*2 + 1</code> or <code>5</code>.</p>



<p>When we want to process the next pixel, we slide our queue across the row of pixel values in the image. The queue <em>gains</em> the pixel from the right hand side and loses the leftmost pixel:</p>



<figure><img decoding="async" loading="lazy" width="932" height="536" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.21@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.21@2x.jpg 932w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.21@2x-522x300.jpg 522w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.21@2x-150x86.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.21@2x-768x442.jpg 768w" sizes="(max-width: 932px) 100vw, 932px"/></figure>



<p>You can also imagine this process from the queue’s point of view, as Mario illustrates:</p>



<figure><img decoding="async" loading="lazy" width="948" height="422" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.58@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.58@2x.jpg 948w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.58@2x-674x300.jpg 674w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.58@2x-150x67.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.58@2x-768x342.jpg 768w" sizes="(max-width: 948px) 100vw, 948px"/></figure>



<h2 id="stack-blur-queue-implementation"><a id="stack-blur-queue-implementation" href="#stack-blur-queue-implementation"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Stack Blur Queue Implementation</h2>



<p>Let’s keep looking at things from the queue’s point of view. </p>



<p>With a radius of <code>2</code>, we have a queue size of <code>5</code>. That means technically we only need 5 pieces of memory for our queue. We’ll give each piece of memory a 0-based index, just to be clear going forward.</p>



<figure><img decoding="async" loading="lazy" width="846" height="286" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-3@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-3@2x.jpg 846w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-3@2x-710x240.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-3@2x-150x51.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.45-3@2x-768x260.jpg 768w" sizes="(max-width: 846px) 100vw, 846px"/></figure>



<p>When a new value comes onto the queue, the leftmost value is removed.  The other values then all move left one spot to make room for the incoming value.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="511" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x-1024x511.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x-1024x511.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x-602x300.jpg 602w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x-150x75.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x-768x383.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24@2x.jpg 1404w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Our <code>255</code> center pixel moves from index <code>2</code> to index <code>1</code>.</figcaption></figure>



<p>This is trivial to implement with something like <code>std::deque</code> in C++:</p>



<pre><code>queue.pop_front(); // get rid of leftmost pixel
queue.push_back (incomingValue); // add new pixel</code></pre>



<p>However, it’s also inefficient. Each time the queue slides, <em>every</em> value in the queue has to change position in memory. This is a lot of work to do per-pixel. It scales up poorly for larger radii. </p>



<h2 id="circular-buffer-implementation"><a id="circular-buffer-implementation" href="#circular-buffer-implementation"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Circular Buffer Implementation</h2>



<p>The efficient thing to do is implement a <strong>circular buffer</strong>, sometimes called a <strong>ring buffer</strong>. It’s often called a <strong>FIFO</strong> (First In, First Out) by audio programmers.</p>



<p>The trick is to abstract our queue from its physical memory by using another variable, such as <code>queueIndex</code>. This index will specify where our new fancy <em>virtual queue </em>starts.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="483" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x-1024x483.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x-1024x483.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x-636x300.jpg 636w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x-150x71.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x-768x362.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.31@2x.jpg 1034w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>When we move to the next pixel, instead all the values shifting left, we’ll just increment the index and move it one spot over to the right.</p>



<figure><img decoding="async" loading="lazy" width="844" height="418" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.08@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.08@2x.jpg 844w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.08@2x-606x300.jpg 606w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.08@2x-150x74.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.08@2x-768x380.jpg 768w" sizes="(max-width: 844px) 100vw, 844px"/></figure>



<p>Conveniently, the incoming pixel can replace the pixel at old queue index, which is now the end of our virtual queue.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="447" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x-1024x447.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x-1024x447.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x-688x300.jpg 688w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x-150x65.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x-768x335.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.59@2x.jpg 1426w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Now, when we want to read our full queue, we can now start at <code>queueIndex</code> and read the next 5 pixels, wrapping back to the beginning when we hit the end of the memory block. This wrapping back to the 0 index is why it’s called a circular/ring buffer.</p>



<h2 id="stacking-the-bricks"><a id="stacking-the-bricks" href="#stacking-the-bricks"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Stacking the Bricks</h2>



<p>Let’s get into the magic. ✨</p>



<p>We want to emulate a smooth gaussian blur in which a pixel is <em>more</em> affected by its closest neighbors.</p>



<p>Mario’s accomplishes this with a concept he calls a <a href="https://www.youtube.com/watch?v=CJQU22Ttpwc">stack</a>. He notes<strong> the stack isn’t a real structure</strong> (in terms of memory or even implementation). The goal is just to give a heavier weight to the center pixel in the queue. And taper the influence off as we move away from the center. </p>



<p>To illustrate, let’s assign some unique pixel values to our simple queue:</p>



<figure><img decoding="async" loading="lazy" width="738" height="326" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-2@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-2@2x.jpg 738w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-2@2x-679x300.jpg 679w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-2@2x-150x66.jpg 150w" sizes="(max-width: 738px) 100vw, 738px"/></figure>



<p>To calculate the blur for the center pixel, we could just take the average of all pixels in the queue: <code>(1+2+3+4+5) / 5</code> (which just happens to equal <code>3</code>, lulz). This is exactly how a <a href="https://en.wikipedia.org/wiki/Box_blur#:~:text=The%20box%20blur%20is%20a,Accumulation.">Box Blur</a> is implemented. Unfortunately Box Blur is both inefficient <em>and</em> doesn’t look great.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="419" src="https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-1024x419.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-1024x419.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-710x290.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-150x61.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-768x314.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-1536x628.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Adobe-Photoshop-2023-2023-11-10.47@2x-2048x837.jpg 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Box Blur (left) has streaking artifacts, especially at the edges. Gaussian blur (right) appears smooth.</figcaption></figure>



<p>So how can we give additional emphasis to the pixels around the center to make it more smooth and bell-curve-y? Well, one idea is to make a copy of the queue, reduce the diameter and include this new layer in our calculations. And keep stacking layers until we’re left with a single center pixel layer:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="427" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-1024x427.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-1024x427.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-710x296.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-150x63.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-768x320.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x-1536x640.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00@2x.jpg 1636w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Welcome to Stack Blur. It “stacks” smaller and smaller virtual queues on top of each other, which gives heavier weight to pixels closest to the center of the queue. </p>



<p>Ironically, in this example <code>(1+2+2+3+3+3+4+4+5) / 9</code> actually ends up equalling <code>3</code> again! All that hard work for nothing :). Don’t rage quit and close the browser yet, here’s a better example:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="425" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-1024x425.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-1024x425.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-710x295.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-150x62.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-768x319.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x-1536x638.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.02-3@2x.jpg 1768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The average of the <strong>queue</strong> is <code>(0+0+9+0+0)/5</code>  = <code>1.8</code>. But the average of the <strong>stack</strong> is <code>(0+0+0+9+9+9+0+0+0)/9</code> = <code>3</code>. So the result is skewed towards our higher center pixel value. </p>



<h2 id="stack-blur-implementation"><a id="stack-blur-implementation" href="#stack-blur-implementation"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Stack Blur Implementation </h2>



<p>Remember: the stack isn’t real. Keeping all those extra pixel values around would be too much bookkeeping and number crunching. Instead, we’ll implement a moving average, a sum that we will call <code>stackSum</code>.</p>



<p>How do we alter the <code>stackSum</code> when the queue moves? When we look closely, the stack seems to gain and lose a <em>bunch</em> of different values. </p>



<p>It’s easiest to think the state both <em>before</em> and <em>after</em> the queue moves.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="893" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-1024x893.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-1024x893.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-344x300.jpg 344w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-150x131.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-768x670.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x-1536x1339.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.44@2x.jpg 1764w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>The values in the stack differ quite a bit from each other before/after!</figcaption></figure>



<p>It seems like we can find our answer on the edges of the stack</p>



<figure><img decoding="async" loading="lazy" width="1024" height="430" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-1024x430.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-1024x430.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-710x298.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-150x63.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-768x323.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x-1536x645.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-2@2x.jpg 1838w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Say hi to our friends <code>1+2+3</code> and <code>4+5+6</code> at the “edges” of the stack.</figcaption></figure>



<p><code>sumOut</code> is everything we’ll remove from the stack each iteration. In our, example it is <code>1+2+3</code>. </p>



<p><code>sumIn</code> is what we need to add to the stack. In our example it’s <code>4+5+6</code>.</p>



<p>But wait! The stack is all in our head, maaaaan. So how exactly do we get the actual values? Let’s take a closer look at our queue:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="254" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-1024x254.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-1024x254.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-710x176.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-150x37.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-768x191.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x-1536x381.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.10@2x.jpg 1660w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Oh it’s our old friends <code>1+2+3</code> and <code>4+5+6</code></figcaption></figure>



<p>Oh wait, it’s right there in the queue. But again, we can’t constantly be summing individual pixels. So <code>sumIn</code> and <code>sumOut</code> are <em>also</em> running sums. That way, all we have to do on each move is:</p>



<ul>
<li>add and subtract a number from <code>sumIn</code> and <code>sumOut</code></li>



<li>modify <code>stackSum</code> by adding <code>sumIn</code> and removing <code>sumOut</code></li>
</ul>



<h2 id="implementing-each-stack-move"><a id="implementing-each-stack-move" href="#implementing-each-stack-move"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Implementing each stack move</h2>



<p>There are different ways of implementing this, but if we’re optimizing for tracking and storing the fewest number of pixels, here’s a good workflow:</p>



<ul>
<li>Calculate the blur for the current center pixel with <code>stackSum</code> / <code>stackSize</code></li>



<li>Remove <code>sumOut</code> from <code>stackSum</code></li>



<li>Before moving, <code>sumOut</code> loses the leftmost pixel (or the pixel at <code>queueIndex</code>): <code>1</code></li>



<li>We move the queue, adding the incoming <code>6</code> and removing the old and tired <code>1</code></li>



<li><code>sumIn</code> gains the incoming new pixel <code>6</code></li>



<li>After moving, <code>sumOut</code> gains the incoming <code>4</code>, which is the the new center pixel (at <code>queueIndex + radius</code>)</li>



<li><code>sumIn</code> loses that same new center pixel <code>4</code> </li>
</ul>



<figure><img decoding="async" loading="lazy" width="1024" height="393" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-1024x393.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-1024x393.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-710x272.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-150x58.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-768x295.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x-1536x590.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.00-2@2x.jpg 1678w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>We only have to care about the leftmost, the middle and the incoming pixel of the queue</figcaption></figure>



<p>You can see a code implementation <a href="https://github.com/sudara/melatonin_blur/blob/main/melatonin/implementations/naive.h#L72-L109">here</a>. That certainly <strong>feels</strong> like more work than “adding and subtracting a value from the queue”. But it’s also surprisingly few instructions for a lot of heavy lifting. And most importantly, the number of instructions per pixel stays constant, no matter how large the radius gets.</p>



<h2 id="literal-edge-cases"><a id="literal-edge-cases" href="#literal-edge-cases"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Literal Edge Cases</h2>



<p>What to do when the pixel we want to calculate is at the edge of an image? This is pretty important — the edge is where we’re starting from! We’ll have to invent some numbers for the leftmost pixel and for <code>sumIn</code> and <code>sumOut</code>, won’t we?</p>



<figure><img decoding="async" loading="lazy" width="1024" height="557" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x-1024x557.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x-1024x557.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x-551x300.jpg 551w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x-150x82.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x-768x418.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.26@2x.jpg 1114w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Most implementations pre-populate the left side of the queue with the leftmost pixel value. So our example imaginary stack would initialize like this:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="654" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x-1024x654.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x-1024x654.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x-469x300.jpg 469w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x-150x96.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x-768x491.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.52-2@2x.jpg 1108w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p><code>sumOut</code> starts with the sum of the 6 highlighted pixels (<code>6</code> here).</p>



<p><code>sumIn</code> can be initialized with the remaining pixels from the stack (value of <code>7</code>).</p>



<p>We do the exact same thing when approaching the right edge, reusing that last pixel to fill the queue as needed.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="602" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x-1024x602.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x-1024x602.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x-510x300.jpg 510w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x-150x88.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x-768x452.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-23.20@2x.jpg 1054w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This works fine, but does create a bias towards those edge pixels. The “influence” of the edge pixels creates what’s called edge bleed. </p>



<p>For a more accurate blur, <a href="https://rustrepo.com/repo/a-fast-iterative-correct-approach-to-stackblur-resulting-in-a-very-smooth-and-highquality-output-with-no-edge-bleeding">some implementations</a> will vary the denominator (aka, vary the stack size) for the edge pixels. Varying the denominator with our radius of <code>5</code>, the stacks for the first two pixels would look like this:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="431" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-1024x431.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-1024x431.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-710x300.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-150x63.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-768x324.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x-1536x647.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-22.24-3@2x.jpg 1714w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>First pixel blur value is 1.44 with fixed stack size of 9 vs 1.66 with “dynamic” stack size of 6</figcaption></figure>



<h2 id="horizontal-and-vertical-stack-blur-passes"><a id="horizontal-and-vertical-stack-blur-passes" href="#horizontal-and-vertical-stack-blur-passes"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Horizontal and Vertical Stack Blur passes</h2>



<p>Like the Box Blur algorithm, we want to approximate a 2D gaussian kernel blur. We do that by running 2 passes over the image: one horizontal and one vertical. The vertical pass operates on the <em>result</em> of the horizontal pass, compounding the blur.</p>



<p><a href="https://observablehq.com/@jobleonard">Job van der Zwan</a> has a post on Stack Blur with <a href="https://observablehq.com/@jobleonard/mario-klingemans-stackblur">a great interactive (!) visualization</a> of how sliding the stack in two passes ends up simulating a gaussian-esque 2D kernel.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="533" src="https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-1024x533.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-1024x533.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-577x300.jpg 577w, https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-150x78.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-768x399.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x-1536x799.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/09/Arc-2023-09-23.11@2x.jpg 1884w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h2 id="multi-channei-images"><a id="multi-channei-images" href="#multi-channei-images"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Multi-channeI images</h2>



<p>Luckily, dealing with multi-channel images is conceptually identical to single channel images.</p>



<p>At the low level, most images on consumer operating systems are stored in a native interleaved pixel format. That just means: each of the 8-bit values for Red, Green, Blue, Alpha (transparency) that comprise “one pixel” are stored together in memory (into a 32-bit space).</p>



<p>There are <a href="https://github.com/sudara/melatonin_blur#a-juce-image-is-stored-premultiplied">important implementation details</a> around scary sounding things like “little endian” storage of pixel values and “premultiplied alpha”. But basically, the pixels are packed together in a <code>BGRA</code> order on Windows and MacOS. </p>



<h2 id="why-does-stack-blur-work-though"><a id="why-does-stack-blur-work-though" href="#why-does-stack-blur-work-though"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Why does Stack Blur work, though? </h2>



<p>If we look at our stack and pay attention to the columns, we might start to understand how exactly the stack gives weight to the pixel values. In our example, the center pixel shows up 3 times, the pixel on either side 2 times and the edge pixels once.</p>



<figure><img decoding="async" loading="lazy" width="992" height="580" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.53@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.53@2x.jpg 992w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.53@2x-513x300.jpg 513w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.53@2x-150x88.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.53@2x-768x449.jpg 768w" sizes="(max-width: 992px) 100vw, 992px"/><figcaption>We can see that the queue center value <code>3</code> is being added <code>radius + 1</code> times.</figcaption></figure>



<p>What if we just try to do something with these weights? Here are the weights for the stack above:</p>



<figure><img decoding="async" loading="lazy" width="792" height="254" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.37@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.37@2x.jpg 792w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.37@2x-710x228.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.37@2x-150x48.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.37@2x-768x246.jpg 768w" sizes="(max-width: 792px) 100vw, 792px"/><figcaption>Weights, relative to <code>stackSize</code></figcaption></figure>



<p>We can normalize the weights by dividing by the <code>stackSize</code>. That would let us apply them to directly to pixel values.</p>



<figure><img decoding="async" loading="lazy" width="734" height="210" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.14@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.14@2x.jpg 734w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.14@2x-710x203.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.14@2x-150x43.jpg 150w" sizes="(max-width: 734px) 100vw, 734px"/><figcaption>Weights, normalized</figcaption></figure>



<p>Interesting! Notice that the full value <code>(9/9</code>) of a pixel is distributed across all 5 places where the pixel is relevant! We can finally sorta understand how Stack Blur <em>blurs</em>.</p>



<p>This kernel of abstract pixel weights seems… interesting. Can we just use it somehow? Yes, but we’d have to multiply the kernel against the queue value by value. And a <code>queueSize</code> number of multiplications per pixel doesn’t sound too ideal…</p>



<p>Plus, isn’t this starting to smell a bit like an expensive convolution kernel we’re trying to avoid? 🙈</p>



<h2 id="the-part-where-i-test-implement-and-benchmark-15-stack-blur-implementations"><a id="the-part-where-i-test-implement-and-benchmark-15-stack-blur-implementations" href="#the-part-where-i-test-implement-and-benchmark-15-stack-blur-implementations"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>The part where I test, implement and benchmark 15 Stack Blur implementations </h2>



<figure><a href="https://github.com/sudara/melatonin_blur#more-benchmarks"><img decoding="async" src="https://user-images.githubusercontent.com/472/281777318-0cb16190-bce7-4d9a-8a7c-d15846946354.jpg" alt="Figma - 2023-11-09 42@2x"/></a></figure>



<p>I wanted to make sure I was getting the fastest performance possible. I don’t want to worry about hundreds of drop shadows suddenly making my synth perform worse (especially on Windows).</p>



<p>As I keep saying, Stack Blur’s primary optimization is ensuring there are the same number of operation per pixel when the radii scales. But my real life usage (using drop and inner shadows to build UI), radii are usually in the 4-36px range. So perhaps the algorithm is over-optimized for radii size?</p>



<p>Also, the original Stack Blur algorithm was made for an environment without access to SIMD or Intel/Apple vector libraries (Javascript, in 2004). Vector processing and SIMD options have come a long way since then.</p>



<p>These days there are some fancy and fast libraries for convolution in C++, such as <a href="https://melatonin.dev/blog/using-intel-performance-primitives-ipp-with-juce-and-cmake/">Apple’s Accelerate and Intel’s IPP</a>.  Surely these vendor libraries have some tricks up their own sleeve? Sure, maybe a full blown vector accelerated gaussian blur will be too expensive (spoiler: it is), but what if we do two passes of <code>vector x matrix</code>  convolution?</p>



<p>Well, fast forward a couple weeks and 20+ <a href="https://github.com/sudara/melatonin_blur/tree/main/melatonin/implementations">implementations</a> later (and counting) and yes: both Apple and Intel’s vector libraries are quite a bit faster for Single Channel Images. <a href="https://github.com/sudara/melatonin_blur#more-benchmarks">Full benchmarks here</a>. </p>



<figure><img decoding="async" loading="lazy" width="1024" height="664" src="https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-1024x664.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-1024x664.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-463x300.jpg 463w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-150x97.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-768x498.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x-1536x996.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.50@2x.jpg 1592w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Interestingly, you can clearly see Stack Blur’s stability across radius size</figcaption></figure>



<p>The long story: For the most image and radii sizes, vendor libraries (employing SIMD, etc under the hood) outperform Stack Blur, especially as the image dimensions scale up. </p>



<p>Starting with macOS 11.0, Apple has <a href="https://developer.apple.com/documentation/accelerate/3546606-vimagesepconvolve_planar8?language=objc">vImageSepConvolve</a> for separated passes, which basically beats stack blur in a couple lines of code.</p>



<p>Intel’s offerings were less exciting. I have a <a href="https://github.com/sudara/melatonin_blur/blob/main/melatonin/implementations/ipp.h">graveyard</a> of failed Intel attempts to use things like <code>ippiFilterSeparable</code>, their separable kernel offering. Pretty sure it’s doing 2D convolution under the hood, because performance is killed by larger radii.</p>



<p>I did write a <a href="https://github.com/sudara/melatonin_blur/blob/main/melatonin/implementations/ipp_vector.h">fast single channel vector IPP Stack Blur</a> which performs decently:</p>



<figure><img decoding="async" src="https://user-images.githubusercontent.com/472/281778384-ce0dc3c7-3d30-413e-af3a-77b741c6c1fe.jpg" alt=""/></figure>



<p> It “rotates” the queue so that you have <code>n</code> vectors where <code>n</code> is your queue size and they are filled with the entire column (for the horizontal pass) or row (for the vertical pass).</p>



<figure><img decoding="async" loading="lazy" width="1024" height="525" src="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-1024x525.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-1024x525.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-585x300.jpg 585w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-150x77.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-768x394.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x-1536x788.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.10@2x.jpg 1634w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>However, it turns out that the <a href="https://github.com/FigBug/Gin/blob/master/modules/gin_graphics/images/gin_imageeffects_stackblur.cpp">C++ Stack Blur implementation I’ve been using</a> is already <em>very</em> optimized.</p>



<p>There are also cases where Stack Blur outperforms everything I tried (I still haven’t found an algorithm faster than it for ARGB images on Windows).</p>



<p>So, can I use hundreds of CPU made drop shadows to build my UI? Yes. <strong>The real trick is to render the shadow once and cache it for future repaints</strong>. That brings shadow repainting time down to almost raw image compositing levels. Getting fast initial paints is still worth it though! Especially for anything animating. At least what I tell myself to sleep well at night 🙂 </p>



<figure><img decoding="async" loading="lazy" width="1024" height="391" src="https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-1024x391.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-1024x391.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-710x271.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-150x57.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-768x294.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x-1536x587.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Microsoft-Excel-2023-11-10.01@2x.jpg 2004w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h2 id="other-stack-blur-optimizations"><a id="other-stack-blur-optimizations" href="#other-stack-blur-optimizations"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Other Stack Blur optimizations</h2>



<p>One obvious optimization for drop shadows in particular is that the larger the image dimensions, the less of the image is actually relevant to the end result. In other words, content is drawn on top of the drop shadow, so we don’t care about the middle. Only the edges need to be blurred. Someone in the comments can probably provide a formula for this.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="854" src="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x-1024x854.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x-1024x854.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x-360x300.jpg 360w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x-150x125.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x-768x641.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.07@2x.jpg 1244w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>This modal has dimensions of 370×450 pixels. It’s over 120k pixels, but only about 1/5th of it needs to be rendered (the 16px blur along the edges) </figcaption></figure>



<p>A Stack Blur optimization for this is what I call the “Martin optimization,” named after my father-in-law. I sat down with him and my wife (both extremely logical thinkers who  play code optimizing video games!) and asked them how they’d optimize the algorithm. One of his insights was that if the values in the queue were all the same <em><strong>and</strong></em> the next incoming pixel was that same value, it’s a no-op: the algorithm can be skipped for the incoming pixel.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="422" src="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-1024x422.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-1024x422.jpg 1024w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-710x292.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-150x62.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-768x316.jpg 768w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x-1536x632.jpg 1536w, https://melatonin.dev/wp-content/uploads/2023/11/Figma-2023-11-10.03@2x.jpg 1632w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>When rendering drop shadows to a graphics context, the inside rectangle of the single color filled path can also be clipped out, saving compositing time.</p>



<h2 id="further-exploring-the-convolutional-roots"><a id="further-exploring-the-convolutional-roots" href="#further-exploring-the-convolutional-roots"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Further exploring the convolutional roots</h2>



<p>Another interesting tangent my wife and I went on:</p>



<p>If we focus on the <strong>relative</strong> weight of a pixel as it moves through the queue, we can see the first time the pixel enters the queue, its weight is <code>1/9</code>. When it moves, the weight doubles to <code>2/9</code>, then it’s multiplied by <code>3/2</code> to for a weight of <code>3/9</code>. As it moves into the right side of the kernel, it shrinks, first by <code>2/3</code> and then by <code>1/2</code>.</p>



<figure><img decoding="async" loading="lazy" width="846" height="502" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.39@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.39@2x.jpg 846w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.39@2x-506x300.jpg 506w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.39@2x-150x89.jpg 150w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.39@2x-768x456.jpg 768w" sizes="(max-width: 846px) 100vw, 846px"/></figure>



<p>So we could look at the multipliers that describe a single pixel’s “journey” through the queue:</p>



<figure><img decoding="async" loading="lazy" width="744" height="278" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.55@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.55@2x.jpg 744w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.55@2x-710x265.jpg 710w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-25.55@2x-150x56.jpg 150w" sizes="(max-width: 744px) 100vw, 744px"/></figure>



<p>We can then normalize for any queue size by scaling the rightmost pixel upon entry to the queue. For our <code>stackSize</code> of 9, let’s have it scale the incoming pixel by <code>1/9</code>:</p>



<figure><img decoding="async" loading="lazy" width="704" height="212" src="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.32@2x.jpg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.32@2x.jpg 704w, https://melatonin.dev/wp-content/uploads/2023/09/Figma-2023-09-24.32@2x-150x45.jpg 150w" sizes="(max-width: 704px) 100vw, 704px"/></figure>



<p>This looks promising! But what can we do with it? Using it against the queue would save us from 4 add/subtracts per queue move and having to read and write to <code>sumIn</code> and <code>sumOut</code> — but we gain 5 multiplies (and more as the radius scales up).</p>



<p>Well, the answer is I have no idea how this could be useful. Please let me know in the comments if you have ideas 🙂 </p>



<h2 id="stack-blur-implementations-and-resources"><a id="stack-blur-implementations-and-resources" href="#stack-blur-implementations-and-resources"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.67848 13.8743C9.91634 14.1126 10.1834 14.3198 10.4733 14.4909L11.9851 12.9787C11.6462 12.889 11.3373 12.7109 11.0897 12.4627L10.9612 12.3344C10.7759 12.1491 10.6289 11.929 10.5286 11.6867C10.4283 11.4445 10.3767 11.1849 10.3767 10.9227C10.3767 10.6605 10.4283 10.4008 10.5286 10.1586C10.6289 9.91638 10.7759 9.69628 10.9612 9.51088L14.4888 5.98184C14.8633 5.60792 15.3708 5.39793 15.8999 5.39793C16.429 5.39793 16.9365 5.60792 17.311 5.98184L17.4394 6.1101C17.6247 6.2955 17.7717 6.5156 17.872 6.75783C17.9723 7.00007 18.0239 7.2597 18.0239 7.52189C18.0239 7.78408 17.9723 8.04371 17.872 8.28594C17.7717 8.52818 17.6247 8.74828 17.4394 8.93367L16.3114 10.0615C16.539 10.6424 16.6555 11.2609 16.655 11.8849C16.6548 12.1211 16.638 12.3571 16.6047 12.591L18.8506 10.3453C19.599 9.59644 20.0195 8.58085 20.0195 7.52189C20.0195 6.46292 19.599 5.44733 18.8506 4.69853L18.7221 4.57005C17.9737 3.82125 16.9585 3.40057 15.9 3.40057C14.8415 3.40057 13.8263 3.82125 13.0778 4.57005L9.55027 8.0993C8.80179 8.84811 8.3813 9.8637 8.3813 10.9227C8.3813 11.9816 8.80179 12.9972 9.55027 13.746L9.67848 13.8743ZM5.14887 19.3032L5.27729 19.4317C6.02635 20.1794 7.0413 20.5994 8.09945 20.5994C9.15761 20.5994 10.1726 20.1794 10.9216 19.4317L14.4492 15.9025C14.8198 15.5317 15.1138 15.0916 15.3145 14.6071C15.5151 14.1227 15.6183 13.6035 15.6183 13.0791C15.6183 12.5547 15.5151 12.0355 15.3145 11.5511C15.1138 11.0666 14.8198 10.6265 14.4492 10.2557L14.321 10.1275C14.0831 9.88919 13.816 9.68201 13.5261 9.51087L12.0144 11.023C12.3532 11.1129 12.6622 11.291 12.91 11.5391L13.0382 11.6675C13.2235 11.8529 13.3705 12.073 13.4708 12.3152C13.5711 12.5574 13.6227 12.817 13.6227 13.0792C13.6227 13.3414 13.5711 13.601 13.4708 13.8432C13.3705 14.0854 13.2235 14.3055 13.0382 14.4909L9.51064 18.0201C9.13608 18.394 8.62862 18.6039 8.09956 18.6039C7.5705 18.6039 7.06304 18.394 6.68848 18.0201L6.56006 17.8917C6.18634 17.5169 5.97646 17.0092 5.97646 16.4799C5.97646 15.9505 6.18634 15.4428 6.56006 15.0681L7.68737 13.9403C7.45981 13.3594 7.34327 12.7408 7.34379 12.1169C7.34402 11.8808 7.36067 11.645 7.39365 11.4112L5.14887 13.6565C4.40039 14.4053 3.9799 15.4209 3.9799 16.4799C3.9799 17.5388 4.40039 18.5544 5.14887 19.3032Z" fill="#B7BBBB"></path>
            </svg></a>Stack Blur Implementations and Resources</h2>



<ul>
<li>My <a href="https://github.com/sudara/melatonin_blur">C++ implementations for the JUCE framework</a></li>



<li><a href="https://underdestruction.com/2004/02/25/stackblur-2004/">Mario’s original implementation notes</a></li>



<li><a href="https://rustrepo.com/repo/a-fast-iterative-correct-approach-to-stackblur-resulting-in-a-very-smooth-and-highquality-output-with-no-edge-bleeding">Blog post about solving the edge problem with varying the denominator</a></li>



<li>Job van der Zwan’s <a href="https://observablehq.com/@jobleonard/mario-klingemans-stackblur">modern JS implementation with great visualizations</a></li>



<li>LoganDark’s <a href="https://github.com/LoganDark/stackblur-iter">Rust implementation</a> which solves edge bleed </li>
</ul>


</div></div>
  </body>
</html>
