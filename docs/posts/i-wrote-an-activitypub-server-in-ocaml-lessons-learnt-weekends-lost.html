<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gopiandcode.uk/logs/log-writing-activitypub.html">Original</a>
    <h1>I Wrote an Activitypub Server in OCaml: Lessons Learnt, Weekends Lost</h1>
    
    <div id="readability-page-1" class="page"><div id="text-orgedb9df0">
<p>
Every journey begins with a single step, and for me, the <a href="https://codeberg.org/gopiandcode/OCamlot/commit/9f764c41dbf65d5b21ad81b403caacd072868045">first step</a>
for this project was setting up a basic registration and
authentication mechanism for the server.
</p>

<p>
After careful deliberation, I ended up using OCaml&#39;s <a href="https://aantron.github.io/dream/">Dream</a> web
framework for my implementation — it&#39;s a modern web-server library
for OCaml, and its idiomatic interface should feel quite familiar to
anyone who&#39;s used web frameworks in other languages:
</p>
<div>
<pre><span>Dream.</span>run <span>@@</span> <span>Dream.</span>router [
  <span>(* </span><span>... authentication ...</span><span> *)</span>
  <span>Dream.</span>get <span>&#34;/register&#34;</span> handle_register_get;
  <span>(* </span><span>...</span><span> *)</span>

  <span>(* </span><span>... user routes ...</span><span> *)</span>
  <span>Dream.</span>get <span>&#34;/user/:username&#34;</span> handle_actor_get;
  <span>Dream.</span>get <span>&#34;/user/:username/inbox&#34;</span> handle_inbox_get;
  <span>(* </span><span>...</span><span> *)</span>

  <span>(* </span><span>static</span><span> *)</span>
  <span>Dream.</span>get <span>&#34;/static/**&#34;</span> <span>@@</span> <span>Dream.</span>static <span>&#34;static&#34;</span>;
  <span>(* </span><span>...</span><span> *)</span>
]
</pre>
</div>
<p>
My initial iteration of the server had basic routes for
authentication, login and registration, viewing users and serving
static files (as above).  Most of the endpoints at this time were actually just
stubs — the only component that was properly implemented was the
login and registration flows, which mostly consisted of code taken
from the respective tutorials from the Dream documentation.
</p>

<p>
While most of this scaffolding was fairly standard and didn&#39;t
require much thought, something that <i>did</i> give some hassle was in
selecting an appropriate representation of the users of the system.
The challenge arose from the generality of the Activitypub
specification itself, which isn&#39;t too clear on what particular
information an &#34;account&#34; must or should have.
In particular, examples in the Activitypub specification mostly talks
about the content of messages being sent between servers, providing
examples as below:
</p>
<div>
<pre>{
  <span>&#34;@context&#34;</span>: [<span>&#34;https://www.w3.org/ns/activitystreams&#34;</span>,
               {<span>&#34;@language&#34;</span>: <span>&#34;ja&#34;</span>}],
  <span>&#34;type&#34;</span>: <span>&#34;Person&#34;</span>,
  <span>&#34;id&#34;</span>: <span>&#34;https://kenzoishii.example.com/&#34;</span>,
  <span>&#34;following&#34;</span>: <span>&#34;https://kenzoishii.example.com/following.json&#34;</span>,
  <span>&#34;followers&#34;</span>: <span>&#34;https://kenzoishii.example.com/followers.json&#34;</span>,
  <span>&#34;liked&#34;</span>: <span>&#34;https://kenzoishii.example.com/liked.json&#34;</span>,
  <span>&#34;inbox&#34;</span>: <span>&#34;https://kenzoishii.example.com/inbox.json&#34;</span>,
  <span>&#34;outbox&#34;</span>: <span>&#34;https://kenzoishii.example.com/feed.json&#34;</span>,
  <span>&#34;preferredUsername&#34;</span>: <span>&#34;kenzoishii&#34;</span>,
  <span>&#34;name&#34;</span>: <span>&#34;石井健蔵&#34;</span>,
  <span>&#34;summary&#34;</span>: <span>&#34;この方はただの例です&#34;</span>,
  <span>&#34;icon&#34;</span>: [
    <span>&#34;https://kenzoishii.example.com/image/165987aklre4&#34;</span>
  ]
}
</pre>
</div>
<p>
Given this message and then reading their descriptions, there&#39;s a
reverse engineering process to decipher the actual information that
has to be maintained within the implementation itself — for example,
for a local user, the <code>liked</code>, <code>inbox</code> and <code>outbox</code> fields can probably be
derived from the user&#39;s username.
</p>

<p>
In the end, I settled on the following datatype as the basic
representation of users in my system, choosing the fields through a
process of trial and error and looking at the internal data types of
other Activitypub implementations:
</p>
<div>
<pre><span>type</span> <span>t</span> = {
  id: int64;                                   <span>(* </span><span>UNIQUE Id of user</span><span> *)</span>
  username: string;                            <span>(* </span><span>username (fixed)</span><span> *)</span>
  password_hash: string;                       <span>(* </span><span>password (hash)</span><span> *)</span>
  display_name: string option;                 <span>(* </span><span>display name</span><span> *)</span>
  about: string option;                        <span>(* </span><span>about text</span><span> *)</span>
  pubkey: <span>X509.Public_key.</span>t;                   <span>(* </span><span>public key</span><span> *)</span>
  privkey: <span>X509.Private_key.</span>t;                 <span>(* </span><span>private key</span><span> *)</span>
}
</pre>
</div>
<p>
Here, the fields I settled upon were: 1) <b>id</b>, an internal integer
identifier to identify local users, 2) <b>username</b>, a string representing
the handle of a user (i.e. @gopiandcode), 3) <b><b>password hash</b></b>, hashed
password, as expected, 4) <b>display name</b>, a string used as the display
name of the user, 5) <b>about</b>, the about-me information for a user, 6)
<b>pubkey</b> and 7) <b>privkey</b>, the public and private key of the user.
</p>


<p>
The Activitypub-specific fields were the private and public keys, which
are required to sign Activitypub messages, and the username, display
name and about fields, which correspond to possible fields in the
Activitypub <code>Person</code> object type.
</p>

<p>
Overall, the fields ended up being quite similar to most other
Activitypub implementations that I could find in the wild (<a href="https://github.com/rustodon/rustodon/blob/master/src/db/models/account.rs#L24">Rustodon</a>,
<a href="https://git.pleroma.social/pleroma/pleroma/-/blob/develop/lib/pleroma/user.ex#L90">Pleroma</a>, <a href="https://humungus.tedunangst.com/r/honk/v/tip/f/honk.go#40">Honk</a>, <a href="https://github.com/mastodon/mastodon/blob/main/db/schema.rb#L143">Mastodon</a>, etc.), so it seems a little wasteful that the
specification itself doesn&#39;t really give any hints about this and
leaves implementors to independently derive this design  themselves.
</p>
</div></div>
  </body>
</html>
