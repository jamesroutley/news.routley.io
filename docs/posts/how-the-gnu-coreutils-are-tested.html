<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pixelbeat.org/docs/coreutils-testing.html">Original</a>
    <h1>How the GNU coreutils are tested</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
                <div>
<p>

Detailed here are some of the tools and techniques we use to test
the <a href="https://www.gnu.org/software/coreutils">GNU coreutils project</a>,
which should present some useful ways to automate the use of tools like
<a href="#gdb">gdb</a>, <a href="#strace">strace</a>, <a href="#valgrind">valgrind</a>, sed, grep, or the coreutils themselves etc.,
either for testing or for other applications. We also describe
general techniques like using timeouts in a robust and performant way.


</p><h2 id="framework">Test framework</h2>
<p><a href="https://www.gnu.org/software/automake/manual/html_node/Tests.html#Tests">automake&#39;s test framework</a>
is used, including &#34;color-tests&#34; and &#34;parallel-tests&#34;,
which supports running generic test scripts.
Our test scripts are generally <b>shell scripts</b>, which makes a lot of sense
since the coreutils themselves are designed to be used from shell,
and therefore we get a lot of secondary testing from the ancillary operations
to the primary commands being tested in each script.

</p><p>
Generally one invokes the test suite with <SPAN>make check</SPAN>,
either when developing or after the build step when building coreutils for your system.
You can also run individual tests when debugging/developing like</p>

<p>Note the GNU coreutils test suite is useful independently from the coreutils project
(with some caveats), since the utilities under test are identified using the $PATH.
That allows one to swap in other implementations of these utilities,
to test conformity to the GNU coreutils implementation.</p>


<h2 id="performance">Performance</h2><p>
It&#39;s important to have a test suite that runs in a reasonable amount of time
to increase the chances of tests being run and that they don&#39;t impact
developer flow too much. To that end we support running tests in parallel,
and also categorize tests to &#34;EXPENSIVE&#34; and &#34;VERY_EXPENSIVE&#34; which are
not normally run.

</p><p>Parallel testing neatly leverages make&#39;s parallel support and
is enabled with <SPAN>make -j $(nproc) check</SPAN>.
One just has to be wary to split large tests to more granular ones.
Note <SPAN>$(nproc)</SPAN> is about the right level of
parallelism for these tests, with diminishing returns beyond that.
Current performance and test counts on a <b>40 core</b> system are:

</p><pre>$ nproc
<b>40</b>
$ time make -j $(nproc) check <a href="#gnulib">SUBDIRS=.</a>
<b>13s</b>
 # TOTAL: 590
 # PASS:  483
 # SKIP:  107
</pre>
<pre># time make -j $(nproc) check
<b>21s</b> including these additional <a href="#gnulib">gnulib</a> tests
 # TOTAL: 311
 # PASS:  292
 # SKIP:  19
</pre>
<pre># time make -j $(nproc) check RUN_EXPENSIVE_TESTS=yes
<b>1m22.244s</b> for 9 extra expensive tests
# time make -j $(nproc) check \
  RUN_EXPENSIVE_TESTS=yes RUN_VERY_EXPENSIVE_TESTS=yes
<b>6m2.051s</b> for 10 extra very expensive tests
 # SKIP:  55
</pre><p>

To maintain accuracy and reliability in these tests
at this level of performance can be tricky,
and we detail various techniques below to achieve that.

</p><h3 id="backoff">Truncated exponential backoff</h3><p>
It can be quite tricky to test asynchronous code without introducing large
delays that slow down the test suite. A very useful technique we&#39;ve used
to avoid that is through the use of the
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=v8.5-149-gc52d220">retry_delay_</a>
function, which tries an operation with an initial small timeout which usually suffices,
but if not, will retry the operation with an increasing timeout.

</p><p>
<i>retry_delay_</i> is used for operations that require a delay to <i>pass</i>.
For operations that <i>fail</i> after a timeout, i.e. tests that are protected
against hanging, we use the <a href="https://www.gnu.org/software/coreutils/timeout">timeout</a> command
with a value of <a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=dd2253f">10s</a>,
before a test is failed.
</p>


<h2 id="responsiveness">Responsive idempotence</h2><p>
This is the idea that you can run without stateful side effects on the system,
and that you can kill the run within a reasonable amount of time also without side effects.

</p><p>Each test runs in its own directory, which is removed when finished.
SIGINT, and SIGTERM are handled appropriately so the clean up happens
for Ctrl-C or if the test suite is otherwise terminated.
Sometimes we need to take explicit action to be responsive to Ctrl-C.
For example one very expensive sort(1) test
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=dd2253f">uses timeout --foreground to be responsive</a>.
Also in some cases we need to be careful to <i>not</i> be too responsive to signals,
like where we disable SIGTTOU for some tests, or
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=5669986">disable suspension</a>
in isolated cases to avoid false positive failures due to timeouts.
</p><p>

For asynchronous tests we need to
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=9069f4e">explicitly cleanup background processes</a>
so that
</p><ul>
<li>Stray processes aren&#39;t left on the system
</li><li>Files aren&#39;t held open causing &#34;silly rename&#34; deletion issues on NFS
</li><li>Partitions used to run the tests from can be unmounted
</li></ul>

<p>
Handling asynchronous cases is generally tricky; for example when fixing a
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=v8.20-115-g71ab11e">subtle test race</a>
we also noticed
<a href="https://lists.gnu.org/archive/html/bug-bash/2013-02/msg00020.html">a race in bash</a> which was subsequently fixed.
</p>

<p id="rm-root">
Generally any of these tests have the potential to cause side effects on the system,
but some are downright scary and dangerous. For example the
<a href="https://github.com/coreutils/coreutils/blob/master/tests/rm/r-root.sh">
<SPAN>rm --no-preserve-root -r &#39;/&#39;</SPAN> test</a>,
is worth reviewing to see the many protections and techniques in place there,
including chickening out entirely if running as root,
<a href="#gdb">using gdb</a> to limit calls to unlink(), and
also <a href="#LD_PRELOAD">using LD_PRELOAD</a> to verify and limit calls.

</p><h2 id="system-tools">System tools</h2>
<p>
<b>loopback mounts</b> are used to test various file systems,
given the focus of coreutils on files (having assimilated the fileutils project),
and the general <a href="http://www.alexcalderwood.blog/talks/linux_and_python/page13.html">file abstraction</a> of UNIX itself.
We use generated file systems to ensure extents are supported,
or to test global SELinux mount options for example.
</p>

<p><b>/dev/full</b> is a very useful device to simulate a full file system,
and returns ENOSPC for any system call that might return that.
In my experience with general system flakiness with a real full file system,
lots of software could do with testing with this device.
</p>

<p id="LD_PRELOAD"><b>LD_PRELOAD wrappers</b> are a handy technique to replace
functionality in shared library routines.  We take the simpler
approach of limiting building our shared library wrappers to
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/init.cfg#L590-L598">gcc with particular options</a>,
as there is a large disparity between shared library details
on various systems, as indicated by the complexity of libtool for example.
We use wrappers for example, to provide <a href="#rm-root">protection</a> for dangerous syscalls, or to
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/rm/rm-readdir-fail.sh">simulate partial failure</a>.
Note sometimes <a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/rm/rm-readdir-fail.sh#L30-L33">special care</a> is needed to support both 32bit and 64bit systems.
</p>

<p id="gdb">
<b>gdb</b> can be quite awkward to automate robustly, but we use it
in a couple of places to verify a fix for a race by
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/tail-2/inotify-race.sh">running shell script at a breakpoint</a>,
or to provide <a href="#rm-root">protection</a> by limiting dangerous system calls by
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/rm/r-root.sh">python scripting at a breakpoint</a>.
Note because of inlining, breakpoints must be set on a line rather than a routine,
noting that some systems provide both
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=v8.21-185-g0427808">inline and non-inline functions</a>
in the same binary, so setting a breakpoint doesn&#39;t necessarily mean that it will be hit.
Note also we avoid sending signals directly to gdb due do
<a href="https://git.sv.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=v8.23-186-gfe02153">its SIGTERM and SIGCONT handling</a>.
</p>

<p id="strace">
<b>strace</b> is used to <a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/ls/stat-free-color.sh">check a syscall is not called</a> and
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/tail-2/inotify-rotate-resources.sh">synchronize operation on a syscall</a>.
</p>

<p>
<b>glibc</b> has a feature to return &#34;random&#34; data for heap allocations
which helps detect heap issues that would otherwise be undetected
due to the allocated memory often being zero by default.
That&#39;s enabled though setting the <SPAN>MALLOC_PERTURB_</SPAN> environment variable.
</p>

<p id="valgrind">
<b>valgrind</b> is an amazing tool and before release we
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/READMe-valgrind">run all utilities with valgrind</a>.
More often we use a more performant and integrated subset of these tests
by enabling <acronym title="AddressSanitizer">ASAN</acronym> in the build.
Some tests use valgrind explicitly, when verifying specific memory corruption fixes, or to explicitly
<a href="https://github.com/coreutils/coreutils/blob/25c7c0db/tests/misc/shuf-reservoir.sh">ensure no memory leaks</a>.
Note the leak checking needs to set an appropriate <SPAN>--leak-check</SPAN> level
depending on whether we&#39;re doing a development build which deallocates memory in more cases,
or a standard build which avoids redundant deallocations right before the process terminates.
</p>

<p>
<b>chroot</b> is part of coreutils so we both test this tool
and use it to test others under particular user credentials.
There are various commands to set an effective user id, but we use
<SPAN>chroot --userspec</SPAN> to provide and implicitly test that functionality.
Previously we had used a non installed wrapper to provide this, but implemented
it within chroot to avoid that maintenance overhead, and provide this useful functionality more generally.
</p>

<p>
<b>ulimit</b> is used to run tests under constrained memory conditions,
and we&#39;ve support for <a href="https://github.com/coreutils/coreutils/blob/25c7c0db/init.cfg#L190-L220">determining the base memory limit</a>
for a command, which is then used to set the appropriate memory limits with ulimit for the commands under test.
That allows us to set both tight and robust limits.
</p>

<h2 id="portability">Portability</h2><p>
The GNU coreutils support a large variety of systems,
with the differences between them often being handled transparently
by the <a href="https://www.gnu.org/software/gnulib/">gnulib project</a>.
</p><!-- google_ad_section_start(weight=ignore) -->
        

        
        
<!-- google_ad_section_end -->

                </div>
</div></div>
  </body>
</html>
