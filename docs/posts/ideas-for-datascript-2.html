<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/datascript-2/">Original</a>
    <h1>Ideas for DataScript 2</h1>
    
    
        
        
        
        
        
        <p>No, I am not working on second version. This is just a list of ideas based on 8 years developing DataScript and 3 years building web-applications with it full-time.</p>

<p>Maybe you’ll find inspiration in these? Feel free to borrow anything you like!</p>

<h2 id="uuids-for-entity-ids">UUIDs for entity IDs</h2>

<p>Makes it easier to generate new IDs in distributed environment without consulting central authority.</p>

<h2 id="attribute-ids">Attribute IDs</h2>

<p>Right now attributes are stored as keywords in DataScript. This is inefficient both for storage (CLJS creates different keywords each time, CLJ interns them) and for comparison.</p>

<p>Integer IDs are fast to compare and compact to store. Keyword ↔︎ id translation could be done transparently to user (Datomic fails to do that in some cases, need to check if could be avoided).</p>

<h2 id="optimized-b-trees">Optimized B-Trees</h2>

<p>Right now B-Trees store datoms (JS objects/POJOs), which leads to crazy amount of pointer chasing during binary searches.</p>

<p>E.g. to access attribute, you first go to datom, then to <code class="language-plaintext highlighter-rouge">a</code> field, which points to keyword. In CLJS, keyword is an object which points to two strings: namespace and name. Each string itself is probably a pointer. You get the idea.</p>

<p>It will probably be much more efficient if entity ID and attribute ID would be stored directly in B-Tree array, without any need to go anywhere. This will make EAVT and AEVT indexes way faster, and those are responsible for majority of use-cases.</p>

<h2 id="transaction-ids">Transaction IDs</h2>

<p>In Datomic, each datom is branded with transaction ID when it was created. They are used in full history DB view to filter out past from the future.</p>

<p>DataScript doesn’t have that, so TX serves no real purpose. Same for <code class="language-plaintext highlighter-rouge">added</code> flag: it’s barely needed.</p>

<h2 id="entities-without-cache">Entities without cache</h2>

<p>Entities (object-like view into database) are caching attributes right now, copied from Datomic.</p>

<p>It feels like it’s unnecessary: you can just store a pointer into EAVT index and scan/binary search every time somebody asks for attribute. EAVT is a cache in some sense.</p>

<h2 id="no-queries">No queries</h2>

<p>I know this is controvertial. Query engine amounts for a lot of complexity in DataScript, and it’s very convenient to use. I have a feeling a lot of people are attracted to DataScript because they want to use queries.</p>

<p>Well, it surprised me as well that in 3 years of full-time web app development with DataScript I haven’t used a single query.</p>

<p>I guess if you build UI with a database, you don’t need queries that much. What you need is a graph database: get this object and follow this relation to another object/collection.</p>

<p>Another reason why I don’t like queries is performance. Index scans are the same, but converting form raw datoms into relations takes time, building set (removing duplicates) takes time, etc. I find it faster to use direct index access for simple stuff.</p>

<p>Performance for simple queries could be solved, I think. But the general viability of queries (despite their attractivenes) is under question.</p>

<h2 id="recursive-walking">Recursive walking</h2>

<p>What saddens me the most in DataScript/Datomic is that rules are often used to do simple recursive walking. Like, go all the way up or all the way down the tree through these relations until a condition is met. Some examples:</p>

<ul>
  <li>Go all the way up through <code class="language-plaintext highlighter-rouge">:entity/parent</code> until <code class="language-plaintext highlighter-rouge">(= (:entity/type %) :document)</code></li>
  <li>Do breadth-first search recusrive through <code class="language-plaintext highlighter-rouge">:entity/children</code> and collect <code class="language-plaintext highlighter-rouge">:entity/text</code></li>
</ul>

<p>You don’t really need a Datalog semantic there: building sets, joining and all that. But people still use it because it’s the only thing they got.</p>

<p>So maybe a collection of convenient recursive walk functions could do instead?</p>

<h2 id="ordering">Ordering</h2>

<p>We need a good built-in way to order stuff. Not sure how API would look like, but we need that. Order in UI is very important.</p>

<h2 id="reactive-updates">Reactive updates</h2>

<p>Re-rendering your whole application is great (and it worked very well for us). But I always want to be more efficient. Since we won’t have queries, how about subscribing to individual entity updates?</p>

<p>I have a feeling this could be done even today, without modifying DataScript even, but designing it from the beginning might work out even better.</p>

<p>The simplest API I’m thinking is like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(d/subscribe conn e a v callback)
</code></pre></div></div>

<p>where any of <code class="language-plaintext highlighter-rouge">e</code>, <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">v</code> could be <code class="language-plaintext highlighter-rouge">nil</code>. E.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(d/subscribe conn 100 nil nil callback)
</code></pre></div></div>

<p>means you want any changes in any attributes for entity 100.</p>

<p>This API is simple, could be implemented efficiently, could get you a long way (hopefully).</p>

<h2 id="persistence">Persistence</h2>

<p>As experience shows, even in browser DataScript databases could grow quite large. Which means it’ll be great to have:</p>

<ul>
  <li>Lazy loading segments from a persistent storage/network</li>
  <li>Append to transaction log</li>
  <li>Rebuild indexes once in a while</li>
</ul>

<p>Would be cool to have file system / SQLite / IndexedDB storages for starters.</p>

<h2 id="async-api">Async API</h2>

<p>The reason DataScript doesn’t have persistence yet is because all DataScript APIs are synchronous, and IndexedDB APIs are asynchronous.</p>

<p>For persistence to work, you need to make all APIs to be async, too (not on a server, of course, but in JS, which makes me sad).</p>

<h2 id="replication">Replication</h2>

<p>Client-to-server, server-to-server, client-to-firebase, client-to-Datomic, client-to-client.</p>

<p>The idea is simple: if you run DataScript on both client and server, it would be cool if they could talk to each other directly and you don’t have to implement sync layer yourself.</p>

<p>You don’t want to do it yourself: there’s a lot of edge cases and failure modes that are tricky to get right.</p>

<p>The main obstacle here is API: how would subscriptions look like? How to start/cancel them? How to track which datom came from which subscription? How to clean up unneded data?</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is a dump of raw ideas I had collected over the years in case I ever decide to start DataScript over.</p>

<p>If you have more—don’t hesitate to reach out! I’d be glad to hear them out.</p>

        
      
  </body>
</html>
