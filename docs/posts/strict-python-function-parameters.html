<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sethmlarson.dev/blog/strict-python-function-parameters">Original</a>
    <h1>Strict Python function parameters</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>
            <center>
                
                <span>Blogging about Python and the Internet</span>
            </center>
        </p>
        
    </div><div>
    <div>
        <h2>Strict Python function parameters</h2>
        <center>Published 2022-01-23 — <span>❤︎</span> Subscribe for more via <a href="https://tinyletter.com/sethmlarson">the newsletter</a> or <a href="https://sethmlarson.dev/feed">RSS</a></center>
    </div>
</div><div>
    <div>
        <p><strong>What do you think about when writing a new function in Python?</strong> The function name, parameter names, optional/required parameters, and default arguments are all on the list. Here is a simple Python function that has all these covered:</p>

<div><pre><span></span><code><span>def</span> <span>process_data</span><span>(</span><span>data</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;ascii&#34;</span><span>):</span>
   <span># Fancy data processing here!</span>
</code></pre></div>

<p>However, there&#39;s one aspect many programmers have an opinion about but don&#39;t realize can be encoded into the function definition: <strong>How should callers specify each argument to the function?</strong> For the above function you&#39;d likely document the following usages:</p>

<div><pre><span></span><code><span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>)</span>

<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>
</code></pre></div>

<p>You don&#39;t need to specify <code>data=</code> for readers to infer what the first argument is likely to be. The parameter name is hinted by the function name: <code>process_data()</code>. On the other hand the <code>encoding</code> parameter isn&#39;t obvious if you only see the argument value. Given this I would recommend using a keyword argument for <code>encoding</code>.</p>

<p>The above decisions make sense to me having written lots of Python, but what about beginners to Python or the library? <strong>Function parameters don&#39;t explain &#34;how&#34; to pass arguments.</strong> Whether an argument is passed as a positional argument or keyword argument is <em>usually</em> up to the caller. Below are all the ways to specify the same parameters, but many are likely not what the author intended:</p>

<div><pre><span></span><code><span># All positional parameters, tougher to</span>
<span># infer the parameter for &#39;utf-8&#39;.</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>&#34;utf-8&#34;</span><span>)</span>

<span># Using `data` as keyword argument, but</span>
<span># not as clean as &#34;data&#34; term is duplicated.</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>

<span># All keyword parameters but encoding</span>
<span># and data are flip-flopped.</span>
<span>process_data</span><span>(</span><span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>,</span> <span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
</code></pre></div>

<p>If the code is widespread enough you&#39;re almost guaranteed that <a href="https://xkcd.com/1172">someone is using your code in a way you didn&#39;t intend</a>. Let&#39;s see two Python features you can use to avoid this problem: </p>

<h2>Keyword-only parameters</h2>

<p><a href="https://www.python.org/dev/peps/pep-3102">PEP 3102</a> introduced this language feature in 2006 for Python 3.0 and later. Despite being in a ecosystem without Python 2 for two years I&#39;m surprised how little I see this feature.</p>

<p>Defining a parameter as being &#34;keyword-only&#34; looks like this:</p>

<div><pre><span></span><code><span>def</span> <span>process_data</span><span>(</span><span>data</span><span>,</span> <span>*</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;ascii&#34;</span><span>):</span> <span>...</span>
</code></pre></div>

<p>Notice the <code>*</code> between <code>data</code> and <code>encoding</code>? The asterisk means that <strong>all parameters to the right in the function signature can&#39;t be passed as positional arguments</strong>. These parameters are now &#34;keyword-only&#34;.</p>

<p>Now that the <code>encoding</code> parameter is a keyword-only how does the list of potential usages change?</p>

<div><pre><span></span><code><span># The way you want users to use the function:</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>

<span># Raises a TypeError:</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>&#34;utf-8&#34;</span><span>)</span>

<span># What way can (and will) use the function:</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>,</span> <span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
</code></pre></div>

<p>It&#39;s a small improvement but there&#39;s more we can do!</p>

<h2>Positional-only parameters</h2>

<p><a href="https://www.python.org/dev/peps/pep-0570">PEP 570</a> introduced another feature for specifying how to pass arguments. This feature landed in Python 3.8 so you may not be able to use it in projects supporting Python 3.7 <a href="https://endoflife.date/python">until mid-2023</a>.</p>

<p>You can define &#34;positional-only&#34; argument in Python like so:</p>

<div><pre><span></span><code><span>def</span> <span>process_data</span><span>(</span><span>data</span><span>,</span> <span>/</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;ascii&#34;</span><span>):</span> <span>...</span>
</code></pre></div>

<p>The <code>/</code> in the function signature means that all parameters to the left of the <code>/</code> are positional-only. Positional-only parameters can&#39;t be passed a keyword argument:</p>

<div><pre><span></span><code><span># This will raise a TypeError:</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
</code></pre></div>

<p>Many functions in the standard library don&#39;t follow the typical rules for parameters.  The example used in PEP 570 is the <a href="https://docs.python.org/3/library/functions.html#pow"><code>pow()</code> function</a>. When called with keyword arguments <code>pow()</code> will fail because the underlying C implementation only accepts positional arguments:</p>

<div><pre><span></span><code><span># The `help()` output for `pow()` used</span>
<span># the `/` character even before Python</span>
<span># 3.8 implemented PEP 570:</span>
<span>&gt;&gt;&gt;</span> <span>help</span><span>(</span><span>pow</span><span>)</span>
<span>...</span>
<span>pow</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>=</span><span>None</span><span>,</span> <span>/</span><span>)</span>
<span>...</span>

<span>&gt;&gt;&gt;</span> <span>pow</span><span>(</span><span>x</span><span>=</span><span>5</span><span>,</span> <span>y</span><span>=</span><span>3</span><span>)</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
<span>TypeError</span><span>:</span> <span>pow</span><span>()</span> <span>takes</span> <span>no</span> <span>keyword</span> <span>arguments</span>
</code></pre></div>

<h2>Putting it all together</h2>

<p>You can use both positional-only and keyword-only arguments together in the same function signature:</p>

<div><pre><span></span><code><span>def</span> <span>process_data</span><span>(</span><span>data</span><span>,</span> <span>/</span><span>,</span> <span>*</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;ascii&#34;</span><span>):</span> <span>...</span>
</code></pre></div>

<p>And now with <code>data</code> being positional-only and <code>encoding</code> keyword-only let&#39;s look at how our function can be used:</p>

<div><pre><span></span><code><span># The way you want users to use the function:</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>

<span># Raises a TypeError:</span>
<span>process_data</span><span>(</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>&#34;utf-8&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>)</span>
<span>process_data</span><span>(</span><span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>,</span> <span>data</span><span>=</span><span>b</span><span>&#34;input&#34;</span><span>)</span>
</code></pre></div>

<p><strong>Success!!</strong> 🎉 Your function now only allows specifying arguments as intended.</p>

<h2>Strict signatures are superior!</h2>

<p>So why go through this extra bit of trouble? You could read the &#34;motivation&#34; sections of <a href="https://www.python.org/dev/peps/pep-3102/#rationale">PEP 3102</a> and <a href="https://www.python.org/dev/peps/pep-0570/#motivation">PEP-570</a> for some of the reasons why these features are useful. Below are a few reasons that I think are important from an API design perspective:</p>

<h3>Less to consider when your function changes</h3>

<p>Here&#39;s a real-life example I had to handle with the <a href="https://github.com/elastic/elasticsearch-py">Elasticsearch Python client</a>. We have an API method called <code>get()</code> which fetches a document from Elasticsearch by its ID. The function signature was going to change in v8.0.0 due to the <code>doc_type</code> parameter being deprecated server-side in v7.0.0 and scheduled for removal in v8.0.0.</p>

<div><pre><span></span><code><span># Function signature in v7.16.0</span>
<span>def</span> <span>get</span><span>(</span><span>index</span><span>,</span> <span>id</span><span>,</span> <span>doc_type</span><span>=</span><span>None</span><span>,</span> <span>params</span><span>=</span><span>None</span><span>,</span> <span>...</span><span>):</span> <span>...</span>

<span># Function signature in v8.0.0</span>
<span>def</span> <span>get</span><span>(</span><span>index</span><span>,</span> <span>id</span><span>,</span> <span>params</span><span>=</span><span>None</span><span>,</span> <span>...</span><span>):</span> <span>...</span>
</code></pre></div>

<p>If the <code>doc_type</code> parameter were removed without mitigation, code using <code>get()</code> would change between v7.16 and v8.0.0:</p>

<div><pre><span></span><code><span>client</span><span>.</span><span>get</span><span>(</span><span>&#34;1&#34;</span><span>,</span> <span>&#34;2&#34;</span><span>,</span> <span>&#34;3&#34;</span><span>)</span>

<span># In 7.16.0 the above arguments will</span>
<span># be assigned like so:</span>

<span># {index=1, id=2, doc_type=3}</span>

<span># In 8.0.0 (if not mitigated) the above</span>
<span># arguments would be assigned like so:</span>

<span># {index=1, id=2, params=3} (not good!)</span>
</code></pre></div>

<p>We started emitting a <code>DeprecationWarning</code> whenever <code>doc_type</code> was used, but warnings are opt-in and can be missed. So in addition to deprecating parameters we decided to deprecate using positional arguments and require using only keyword arguments for all Elasticsearch API methods in v8.0.0. <strong>Now parameters can be added and removed without considering the parameters&#39; position in previous versions.</strong></p>

<p>This change also meant the API generator logic could be greatly simplified because the generator no longer needed to account for the order parameters were previously generated with.</p>

<p><strong>There&#39;s additional API freedoms when using positional-only arguments too.</strong> Recall the <code>process_data()</code> function defined above:</p>

<div><pre><span></span><code><span>def</span> <span>process_data</span><span>(</span><span>data</span><span>,</span> <span>/</span><span>,</span> <span>*</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>):</span> <span>...</span>
</code></pre></div>

<p>If you now wanted the <code>data</code> parameter to accept either a single <code>bytes</code> instance or a list of <code>bytes</code> instances you might want to rename the parameter to better represent the accepted types. <strong>If <code>data</code> is a positional-only parameter then you can rename the parameter without breaking anyone</strong>. Without being a positional-only argument you risk breaking users specifying <code>data</code> with a keyword argument:</p>

<div><pre><span></span><code><span># You can rename &#39;data&#39; -&gt; &#39;data_or_list&#39;</span>
<span># without breaking anyone&#39;s code.</span>
<span>def</span> <span>process_data</span><span>(</span><span>data_or_list</span><span>,</span> <span>/</span><span>,</span> <span>*</span><span>,</span> <span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>):</span> <span>...</span>
</code></pre></div>

<p>For more information there&#39;s an <a href="https://www.python.org/dev/peps/pep-0570/#id27">&#34;Empowering Library Authors&#34; section in PEP 570</a> that details other cases.</p>

<h3>Consistency between documentation and usage</h3>

<p>Ideally documentation will pick a single way of using each function and be consistent within itself. <strong>Why not require users to use functions as they are documented?</strong> If urllib3 was being written today the function signature for <code>request()</code> might look like this with <code>method</code> and <code>url</code> being positional-only and all other parameters being keyword-only:</p>

<div><pre><span></span><code><span>def</span> <span>request</span><span>(</span><span>method</span><span>,</span> <span>url</span><span>,</span> <span>/</span><span>,</span> <span>*</span><span>,</span> <span>headers</span><span>=</span><span>None</span><span>,</span> <span>...</span><span>):</span> <span>...</span>
</code></pre></div>

<p>This function is found <em>everywhere</em>, even across other HTTP client libraries like Requests and aiohttp, so is likely to be understandable to users who have never used urllib3.</p>

<div><pre><span></span><code><span># We&#39;re used to seeing this everywhere:</span>
<span>request</span><span>(</span><span>&#34;GET&#34;</span><span>,</span> <span>&#34;https://example.com&#34;</span><span>,</span> <span>headers</span><span>=</span><span>{</span><span>...</span><span>})</span>

<span># These aren&#39;t as immediately recognizable:</span>
<span>request</span><span>(</span><span>method</span><span>=</span><span>&#34;GET&#34;</span><span>,</span> <span>url</span><span>=</span><span>&#34;https://example.com&#34;</span><span>)</span>
<span>request</span><span>(</span><span>&#34;GET&#34;</span><span>,</span> <span>&#34;https://example.com&#34;</span><span>,</span> <span>{</span><span>...</span><span>})</span>
</code></pre></div>

<p>By having a strict function signature we can ensure code written by users will look recognizable to future readers.</p>

    </div>
</div></div>
  </body>
</html>
