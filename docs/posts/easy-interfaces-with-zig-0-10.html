<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zig.news/kristoff/easy-interfaces-with-zig-0100-2hc5">Original</a>
    <h1>Easy Interfaces with Zig 0.10</h1>
    
    <div id="readability-page-1" class="page"><div>

          <div data-article-id="423" id="article-body">
            <p>This release of Zig introduces a new language feature that makes creating interface types much more ergonomic. </p>

<h2>
  <a name="about-interfaces" href="#about-interfaces">
  </a>
  About interfaces
</h2>

<p>Zig doesn&#39;t have a built-in interface type, like higher-level languages do. One of the reasons for this choice is the fact that people who use interfaces most of the time care about modeling the program in a way that they like, but usually don&#39;t care much for how the system works behind the scenes. </p>

<p>In Zig we always care about what the machine ends up doing and, when it comes to interfaces, there are <a href="https://www.youtube.com/watch?v=AHc4x1uXBQE">multiple approaches</a> with different tradeoffs, each equally valid and with its own preferred use cases.</p>

<h2>
  <a name="interfaces-based-on-tagged-unions" href="#interfaces-based-on-tagged-unions">
  </a>
  Interfaces based on tagged unions
</h2>

<p>The most straight-forward way of creating an interface types is by creating a tagged union of its possible concrete implementations. It&#39;s not the right choice in all cases, but it&#39;s usually good enough for simple programs. </p>

<p>Let&#39;s say that we have a <code>Cat</code> and a <code>Dog</code> and we want to be able to use them through a common interface.<br/>
</p>

<div>
<pre><code><span>const</span> <span>Cat</span> <span>=</span> <span>struct</span> <span>{</span>
   <span>pub</span> <span>fn</span> <span>talk</span><span>()</span> <span>void</span> <span>{</span>
      <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;meow!&#34;</span><span>,</span> <span>.</span><span>{});</span>
   <span>}</span>
<span>};</span>

<span>const</span> <span>Dog</span> <span>=</span> <span>struct</span> <span>{</span> 
   <span>pub</span> <span>fn</span> <span>talk</span><span>()</span> <span>void</span> <span>{</span>
      <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;bark!&#34;</span><span>,</span> <span>.</span><span>{});</span>
  <span>}</span>
<span>};</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>Before, you had to do this in Zig:<br/>
</p>

<div>
<pre><code><span>const</span> <span>Animal</span> <span>=</span> <span>union</span><span>(</span><span>enum</span><span>){</span>
   <span>cat</span><span>:</span> <span>Cat</span><span>,</span>
   <span>dog</span><span>:</span> <span>Dog</span><span>,</span>

   <span>pub</span> <span>fn</span> <span>talk</span><span>(</span><span>self</span><span>:</span> <span>Animal</span><span>)</span> <span>void</span> <span>{</span>
      <span>switch</span> <span>(</span><span>self</span><span>)</span> <span>{</span>
         <span>.</span><span>cat</span> <span>=&gt;</span> <span>|</span><span>cat</span><span>|</span> <span>cat</span><span>.</span><span>talk</span><span>(),</span>
         <span>.</span><span>dog</span> <span>=&gt;</span> <span>|</span><span>dog</span><span>|</span> <span>dog</span><span>.</span><span>talk</span><span>(),</span>
      <span>}</span>
   <span>}</span>
<span>};</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>As you can see, the point where static dispatch connects with dynamic dispatch is explicitly marked in the implementation of <code>Animal.talk</code>. In that function (which can be statically dispatched when called on an instance of <code>Animal</code>) you can see how switching on the active case calls the right implementation, based on the value of the tag (runtime-known, thus dynamic).</p>

<p>This is very nice, but it has the downside of being a bit too verbose. Imagine an interface with 100 concrete types and 10 methods part of the interface. That&#39;s a lot of redundancy!</p>

<p>Thankfully, starting from Zig 0.10.0 you can do this:<br/>
</p>

<div>
<pre><code><span>const</span> <span>Animal</span> <span>=</span> <span>union</span><span>(</span><span>enum</span><span>){</span>
   <span>cat</span><span>:</span> <span>Cat</span><span>,</span>
   <span>dog</span><span>:</span> <span>Dog</span><span>,</span>

   <span>pub</span> <span>fn</span> <span>talk</span><span>(</span><span>self</span><span>:</span> <span>Animal</span><span>)</span> <span>void</span> <span>{</span>
      <span>switch</span> <span>(</span><span>self</span><span>)</span> <span>{</span>
         <span>inline</span> <span>else</span> <span>=&gt;</span> <span>|</span><span>case</span><span>|</span> <span>case</span><span>.</span><span>talk</span><span>(),</span>
      <span>}</span>
   <span>}</span>
<span>};</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>What&#39;s happening here is that <code>inline else</code> inside a switch behaves in a similar way to <code>inline for</code> or <code>inline while</code>. </p>

<p>In an inlined loop, the loop itself is unrolled at comptime and replaced with the result, like so:<br/>
</p>

<div>
<pre><code><span>const</span> <span>nums</span> <span>=</span> <span>[</span><span>_</span><span>]</span><span>usize</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>};</span>

<span>var</span> <span>accumulator</span><span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>;</span>
<span>inline</span> <span>for</span> <span>(</span><span>nums</span><span>)</span> <span>|</span><span>n</span><span>|</span> <span>{</span>
   <span>accumulator</span> <span>+=</span> <span>n</span><span>;</span>
<span>}</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>After comptime, the program basically becomes:<br/>
</p>

<div>
<pre><code><span>const</span> <span>nums</span> <span>=</span> <span>[</span><span>_</span><span>]</span><span>usize</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>};</span>

<span>var</span> <span>accumulator</span><span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>;</span>
<span>accumulator</span> <span>+=</span> <span>1</span><span>;</span>
<span>accumulator</span> <span>+=</span> <span>2</span><span>;</span>
<span>accumulator</span> <span>+=</span> <span>3</span><span>;</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<p>Inside a switch, <code>inline else</code> produces many branches, each based on a possible value of the enum tag, effectively acting as a shortcut to produce the original code, where each tag value had its own case.</p>

<p>This works because in an <code>inline else</code> we&#39;re able to use comptime ducktyping to call <code>talk()</code> on each concrete implementation. It obviously wouldn&#39;t work as seamlessly if instead the implementations had methods like <code>.meow()</code> and <code>.bark()</code>.</p>

<p>That said, if you happen to have an odd implementation that you want to handle manually, you can still add a dedicated case:<br/>
</p>

<div>
<pre><code><span>const</span> <span>Animal</span> <span>=</span> <span>union</span><span>(</span><span>enum</span><span>){</span>
   <span>cat</span><span>:</span> <span>Cat</span><span>,</span>
   <span>dog</span><span>:</span> <span>Dog</span><span>,</span>
   <span>snake</span><span>:</span> <span>Snake</span><span>,</span>

   <span>pub</span> <span>fn</span> <span>talk</span><span>(</span><span>self</span><span>:</span> <span>Animal</span><span>)</span> <span>void</span> <span>{</span>
      <span>switch</span> <span>(</span><span>self</span><span>)</span> <span>{</span>
         <span>.</span><span>snake</span> <span>=&gt;</span> <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;Ssss~~~&#34;</span><span>,</span> <span>.</span><span>{}),</span>
         <span>inline</span> <span>else</span> <span>=&gt;</span> <span>|</span><span>case</span><span>|</span> <span>case</span><span>.</span><span>talk</span><span>(),</span>
      <span>}</span>
   <span>}</span>
<span>};</span>
</code></pre>
<div>
<p>
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</p>
</div>
</div>



<h2>
  <a name="wait-shouldnt-raw-cat-endraw-and-raw-dog-endraw-inherit-from-animal" href="#wait-shouldnt-raw-cat-endraw-and-raw-dog-endraw-inherit-from-animal">
  </a>
  Wait shouldn&#39;t <code>Cat</code> and <code>Dog</code> <em>inherit</em> from Animal???
</h2>

<p>Oh no! Did I just use an OOP example to show interfaces? Have I learned nothing from my university Java <em>classes</em>? </p>

<p>If you had that reaction, you might want to take some time to explicitly free your thought process from OOP-isms. OOP is an approach to modeling solutions that relies on dynamic dispatch. That&#39;s why sometimes inheritance overlaps with interfaces.</p>

<p>In Zig it&#39;s not idiomatic to go bonkers with interfaces just to conform to a solution modeling approach. If you&#39;re using interfaces it should be because you <strong>need</strong> dynamic dispatch and the truth is that, a lot of the time, you just don&#39;t need it.</p>

<p>I personally think it&#39;s fine to think in OOP terms when using a language (and ecosystem) that models things that way. But I also think that it&#39;s a mistake to do so in a language like Zig where the priorities are different. Same with trying to shoehorn functional programming in Zig.</p>


          </div>

        </div></div>
  </body>
</html>
