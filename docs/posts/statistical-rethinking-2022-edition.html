<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rmcelreath/stat_rethinking_2022">Original</a>
    <h1>Statistical Rethinking (2022 Edition)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>When I first learned about it, DNS didn‚Äôt seem like it should be THAT
complicated. Like, there are DNS records, they‚Äôre stored on a server, what‚Äôs
the big deal?</p>
<p>But with DNS, reading about how it works in a textbook doesn‚Äôt prepare you for
the sheer volume of different ways DNS can break your system in practice. It‚Äôs
not just caching problems!</p>
<p>So I <a href="https://twitter.com/b0rk/status/1481265429897261058">asked people on Twitter</a> for
example of DNS problems they‚Äôve run into, especially DNS problems that <strong>didn‚Äôt
initially appear to be DNS problems</strong>. (the popular ‚Äúit‚Äôs always DNS‚Äù meme)</p>
<p>I‚Äôm not going to discuss how to solve or avoid any of these problems in this
post, but I‚Äôve linked to webpages discussing the problem where I could find
them.</p>
<h3 id="problem-slow-network-requests">problem: slow network requests</h3>
<p>Your network requests are a little bit slower than expected, and it‚Äôs actually
because your DNS resolver is slow for some reason. This might be because the
resolver is under a lot of load, or it has a memory leak, or something else.</p>
<p>I‚Äôve run into this before with my router‚Äôs DNS forwarder ‚Äì all of my DNS
requests were slow, and I restarted my router and that fixed the problem.</p>
<h3 id="problem-dns-timeouts">problem: DNS timeouts</h3>
<p>A couple of people mentioned network requests that were taking 2+ seconds or 30
seconds because of DNS queries that were timing out. This is sort of the same
as ‚Äúslow requests‚Äù, but it‚Äôs worse because queries can take several seconds to
time out.</p>
<p>Sophie Haskins has a great blog post <a href="https://blog.sophaskins.net/blog/misadventures-with-kube-dns/">Misadventures with Kube DNS</a> about DNS
timeouts with Kubernetes.</p>
<h3 id="problem-ndots">problem: ndots</h3>
<p>A few people mentioned a specific issue where Kubernetes sets <code>ndots:5</code> in its <code>/etc/resolv.conf</code></p>
<p>Here‚Äôs an example /etc/resolv.conf from <a href="https://pracucci.com/kubernetes-dns-resolution-ndots-options-and-why-it-may-affect-application-performances.html">Kubernetes pods /etc/resolv.conf ndots:5 option and why it may negatively affect your application performances</a>.</p>
<pre><code>nameserver 100.64.0.10
search namespace.svc.cluster.local svc.cluster.local cluster.local eu-west-1.compute.internal
options ndots:5
</code></pre>
<p>My understanding is that if this is your <code>/etc/resolv.conf</code> and you look up
<code>google.com</code>, your application will call the C <code>getaddrinfo</code> function, and
<code>getaddrinfo</code> will:</p>
<ol>
<li>look up <code>google.com.namespace.svc.cluster.local.</code></li>
<li>look up <code>google.com.svc.cluster.local.</code></li>
<li>look up <code>google.com.cluster.local.</code></li>
<li>look up <code>google.com.eu-west-1.compute.internal.</code></li>
<li>look up <code>google.com.</code></li>
</ol>
<p>Basically it checks if <code>google.com</code> is actually a subdomain of everything on the <code>search</code> line.</p>
<p>So every time you make a DNS query, you need to wait for 4 DNS queries to fail
before you can get to the actual real DNS query that succeeds.</p>
<h3 id="problem-dns-servers-that-return-nxdomain-instead-of-noerror">problem: DNS servers that return NXDOMAIN instead of NOERROR</h3>
<p>Here‚Äôs a problem that I ran into once, where nginx couldn‚Äôt resolve a domain.</p>
<ul>
<li>I set up nginx to use a specific DNS server to resolve DNS queries</li>
<li>when visiting the domain, nginx made 2 queries, one for an <code>A</code> record, and one for an <code>AAAA</code> record</li>
<li>the DNS server returned a <code>NXDOMAIN</code> reply for the <code>A</code> query</li>
<li>nginx decided ‚Äúok, that domain doesn‚Äôt exist‚Äù, and gave up</li>
<li>the DNS server returned a successful reply for the <code>AAAA</code> query</li>
<li>nginx ignored the <code>AAAA</code> record because it had already given up</li>
</ul>
<p>The problem was that the DNS server should have returned <code>NOERROR</code> ‚Äì that
domain <em>did</em> exist, it was just that there weren‚Äôt any <code>A</code> records for it. I
reported the bug, they fixed it, and that fixed the problem.</p>
<p>I‚Äôve implemented this bug myself too, so I understand why it happens ‚Äì it‚Äôs
easy to think ‚Äúthere aren‚Äôt any records for this query, I should return an
<code>NXDOMAIN</code> error‚Äù.</p>
<h3 id="problem-negative-dns-caching">problem: negative DNS caching</h3>
<p>If you visit a domain before creating a DNS record for it, the <strong>absence</strong> of
the record will be cached. This is very surprising the first time your run into
it ‚Äì I only learned about this last year!</p>
<p>The TTL for cache entry is the TTL of the domain‚Äôs SOA record ‚Äì for example
for <code>jvns.ca</code>, it‚Äôs an hour.</p>
<h3 id="problem-nginx-caching-dns-records-forever">problem: nginx caching DNS records forever</h3>
<p>If you put this in your nginx config:</p>
<pre><code>location / {
    proxy_pass https://some.domain.com;
}
</code></pre>
<p>then nginx will resolve <code>some.domain.com</code> once on startup and never again. This
is especially dangerous if the IP address for <code>some.domain.com</code> changes
infrequently, because it might keep happily working for months and then
suddenly break at 2am one day.</p>
<p>There are pretty well-known ways to fix this and this post isn‚Äôt about nginx so
I won‚Äôt get into it, but it‚Äôs surprising the first time you run into it.</p>
<p>Here‚Äôs a <a href="https://medium.com/driven-by-code/dynamic-dns-resolution-in-nginx-22133c22e3ab">blog post</a> with a story of how this happened to someone with an AWS load balanacer.</p>
<h3 id="problem-java-caching-dns-records-forever">problem: Java caching DNS records forever</h3>
<p>Same thing, but for Java: <a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-jvm-ttl.html">Apparently</a>
depending on how you configure Java, ‚Äúthe JVM default TTL [might be] set so
that it will never refresh DNS entries until the JVM is restarted.‚Äù</p>
<p>I haven‚Äôt run into this myself but I asked a friend about it who writes more
Java than me and they told me that it‚Äôs happened to them.</p>
<p>Of course, literally any software could have this problem of caching DNS
records forever, but the main cases I‚Äôve heard of in practice are nginx and
Java.</p>
<h3 id="problem-that-entry-in-etc-hosts-you-forgot-about">problem: that entry in /etc/hosts you forgot about</h3>
<p>Another variant on caching issues: entries in <code>/etc/hosts</code> that override your
usual DNS settings!</p>
<p>This is extra confusing because <code>dig</code> ignores <code>/etc/hosts</code>, so everything SEEMS
like it should be fine (‚Äù<code>dig whatever.com</code> is working!‚Äú).</p>
<h3 id="problem-your-email-isn-t-being-sent-is-going-to-spam">problem: your email isn‚Äôt being sent / is going to spam</h3>
<p>The way email is sent and validated is through DNS (MX records, SPF records,
DKIM records), so a lot of email problems are DNS problems.</p>
<h3 id="problem-internationalized-domain-names-don-t-work">problem: internationalized domain names don‚Äôt work</h3>
<p>You can register domain names with non-ASCII characters or emoji like <a href="https://üí©.la/">https://üí©.la</a>.</p>
<p>The way this works with DNS is that <code>üí©.la</code> gets translated into <code>xn--ls8h.la</code> with an encoding called ‚Äúpunycode‚Äù.</p>
<p>But even though there‚Äôs a clear standard for how they should work with DNS, a lot of software doesn‚Äôt handle internationalized domain names well!
There‚Äôs a fun story about this in Julian Squires‚Äô great talk <a href="https://www.youtube.com/watch?v=UE-fJjMasec">The emoji that Killed Chrome!!</a>.</p>
<h3 id="problem-tcp-dns-is-blocked-by-a-firewall">problem: TCP DNS is blocked by a firewall</h3>
<p>A couple of people mentioned that some firewalls allow UDP port 53 but not TCP
port 53. But large DNS queries need to use TCP port 53, so this can cause weird
intermittent problems that are hard to debug.</p>
<h3 id="problem-musl-doesn-t-support-tcp-dns">problem: musl doesn‚Äôt support TCP DNS</h3>
<p>A lot of applications use libc‚Äôs <code>getaddrinfo</code> to make DNS queries. musl is an
alternative to <code>glibc</code> that‚Äôs used in Alpine Docker container which doesn‚Äôt
support TCP DNS. This can cause problems if you make DNS queries where the
response would be too big to fit inside a regular DNS UDP packet (512 bytes).</p>
<p>I‚Äôm still a bit fuzzy on this so I might have it wrong, but my understanding of how this can break is:</p>
<ol>
<li>musl‚Äôs getaddrinfo makes a DNS query</li>
<li>the DNS server notices that the response is too big to fit in a single DNS response packet</li>
<li>the DNS server returns an <strong>empty</strong> truncated response, expecting that the client will retry by making a TCP DNS query</li>
<li><code>musl</code> does not support TCP so it does not retry</li>
</ol>
<p>A blog post about this: <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">DNS resolution issue in Alpine Linux</a></p>
<h3 id="problem-round-robin-dns-doesn-t-work-with-getaddrinfo">problem: round robin DNS doesn‚Äôt work with <code>getaddrinfo</code></h3>
<p>One way you could approach load balancing is to use ‚Äúround robin DNS‚Äù. The idea
is that every time you make a DNS query, you get a different IP address.
Apparently this works if you use <code>gethostbyname</code> to make DNS queries, but it
does not work if you use <code>getaddrinfo</code> because <code>getaddrinfo</code> sorts the IP
responses it receives.</p>
<p>So you could run into an upsetting problem if you switch from <code>gethostbyname</code> to <code>getaddrinfo</code> behind the scenes without realising that this will break your DNS load balancing.</p>
<p>This is especially insidious because you might not realize that you‚Äôre
switching to <code>gethostbyname</code> to <code>getaddrinfo</code> at all ‚Äì if you‚Äôre not writing a
C program, those functions calls are hidden inside some library. So it could be
part of a seemingly innocuous upgrade.</p>
<p>Here are a couple of pages discussing this:</p>
<ul>
<li><a href="https://groups.google.com/g/consul-tool/c/AGgPjrrkw3g">getaddrinfo breaks round robin DNS</a></li>
<li><a href="https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/">getaddrinfo with round robin DNS and happy eyeballs</a></li>
</ul>
<h3 id="problem-a-race-condition-when-starting-a-service">problem: a race condition when starting a service</h3>
<p>A problem someone <a href="https://mobile.twitter.com/omatskiv/status/1481305175440646148">mentioned</a>
with Kubernetes DNS: they had 2 containers which started simultaneously and
immediately tried to resolve each other. But the DNS lookup failed because the
Kubernetes DNS change hadn‚Äôt happened yet, and then the failure was cached so
it kept failing.</p>
<h3 id="that-s-all">that‚Äôs all!</h3>
<p>I‚Äôve definitely missed some important DNS problems here, so I‚Äôd love to hear
what I‚Äôve missed. I‚Äôd also love links to blog posts that write up examples of
these problems ‚Äì I think it‚Äôs really useful to see how the problem
specifically manifests in practice and how people debugged it.</p>
</div></div>
  </body>
</html>
