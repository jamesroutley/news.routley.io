<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/saulshanabrook/saulshanabrook/discussions/34">Original</a>
    <h1>EGraph Interactive Visualizer Research</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>As developers, we use databases all the time. But how do they work? In this series, we&#39;ll try to answer that question by building our own SQLite-compatible database from scratch.</p>
<p>Source code examples will be provided in Rust, but you are encouraged to follow along using your language of choice, as we won&#39;t be relying on many language-specific features or libraries.</p>
<p>As an introduction, we&#39;ll implement the simplest version of the <code>tables</code> command, which lists the names of all the tables in a database. While this looks simple, we&#39;ll see that it requires us to make our first deep dive into the SQLite file format.</p>
<p>The complete source code is available on <a target="_blank" href="https://github.com/geoffreycopin/rqlite/tree/16e2dbe95a420d1d88ad2555552c2072206d2308">Github</a>.</p>
<h2 id="heading-building-the-test-database">Building the test database</h2>
<p>To keep things as simple as possible, let&#39;s build a minimalistic test database:</p>
<pre><code>sqlite3 minimal_test.db
sqlite&gt; create table table1(id <span>integer</span>);
sqlite&gt; create table table2(id <span>integer</span>);
sqlite&gt; .<span>exit</span>
</code></pre>
<p>This creates a database with two tables, <code>table1</code> and <code>table2</code>, each with a single column, <code>id</code>. We can verify this by running the <code>tables</code> command in the SQLite shell:</p>
<pre><code>sqlite3 minimal_test.db
sqlite&gt; .tables
table1  table2
sqlite&gt; .<span>exit</span>
</code></pre>
<h2 id="heading-bootstrapping-the-project">Bootstrapping the project</h2>
<p>Let&#39;s start by creating a new Rust project. We&#39;ll use the <code>cargo add</code> to add our only dependency for now, <code>anyhow</code>:</p>
<pre><code>cargo new rsqlite
<span>cd</span> rsqlite
cargo add anyhow
</code></pre>
<h2 id="heading-the-sqlite-file-format">The SQLite file format</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1721572171598/5c4195b6-5472-4ba1-826d-d8f5b6660527.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>SQLite databases are stored in a single file, the format of which is documented in the <a target="_blank" href="https://www.sqlite.org/fileformat.html">SQLite File Format Specification</a>. The file is divided into pages, with each page having the same size: a power of 2, between 512 and 65536 bytes. The first 100 bytes of the first page contain the database header, which includes information such as the page size and the file format version. In this first part, we&#39;ll only be interested in the page size. Pages can be of different types, but for this first article, we&#39;ll only be interested in <code>table btree leaf</code> pages, which store the actual table data.</p>
<p>Our first task will be to implement a <code>Pager</code> struct that reads and caches pages from the database file. But before we do, we&#39;ll have to read the page size from the database header. Let&#39;s start by defining our <code>Header</code> struct:</p>
<pre><code><span>// src/page.rs</span>
<span>#[derive(Debug, Copy, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>DbHeader</span></span> {
    <span>pub</span> page_size: <span>u32</span>,
}
</code></pre>
<p>The header starts with the magic string <code>SQLite format 3\0</code>, followed by the page size encoded as a big-endian 2-byte integer at offset 16. With this information, we can implement a function that reads the header from a buffer:</p>
<pre><code><span>// src/pager.rs</span>
<span>pub</span> <span>const</span> HEADER_SIZE: <span>usize</span> = <span>100</span>;
<span>const</span> HEADER_PREFIX: &amp;[<span>u8</span>] = <span>b&#34;SQLite format 3\0&#34;</span>;
<span>const</span> HEADER_PAGE_SIZE_OFFSET: <span>usize</span> = <span>16</span>;

<span>const</span> PAGE_MAX_SIZE: <span>u32</span> = <span>65536</span>;

<span>pub</span> <span><span>fn</span> <span>parse_header</span></span>(buffer: &amp;[<span>u8</span>]) -&gt; anyhow::<span>Result</span>&lt;page::DbHeader&gt; {
    <span>if</span> !buffer.starts_with(HEADER_PREFIX) {
        <span>let</span> prefix = <span>String</span>::from_utf8_lossy(&amp;buffer[..HEADER_PREFIX.len()]);
        anyhow::bail!(<span>&#34;invalid header prefix: {prefix}&#34;</span>);
    }

    <span>let</span> page_size_raw = read_be_word_at(buffer, HEADER_PAGE_SIZE_OFFSET);
    <span>let</span> page_size = <span>match</span> page_size_raw {
        <span>1</span> =&gt; PAGE_MAX_SIZE,
        n <span>if</span> n.is_power_of_two() =&gt; n <span>as</span> <span>u32</span>,
        _ =&gt; anyhow::bail!(<span>&#34;page size is not a power of 2: {}&#34;</span>, page_size_raw),
    };

    <span>Ok</span>(page::Header { page_size })
}

<span><span>fn</span> <span>read_be_word_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>u16</span> {
    <span>u16</span>::from_be_bytes(input[offset..offset + <span>2</span>].try_into().unwrap())
}
</code></pre>
<p>As the maximum page size cannot be represented as a 2-byte integer, a page size of 1 is use to represent the maximum page size.</p>

<h2 id="heading-decoding-table-b-tree-leaf-pages">Decoding Table B-tree leaf pages</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1721571943115/f84ad91d-d3a3-462e-8f2b-1b1975badb1a.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>Now that we have the minimum information we need to read pages from the disk, let&#39;s explore the content of a <code>table btree-leaf</code> page. <code>table btree-leaf</code> pages start with an 8-byte header, followed by an sequence of &#34;cell pointers&#34; containing the offset of every cell in the page. The cells contain the table data, and we can think of them as key-value pairs, where the key is a 64-bits integer encoded as a <a target="_blank" href="https://carlmastrangelo.com/blog/lets-make-a-varint">varint</a> (the <code>rowid</code>) and the value is an arbitrary sequence of bytes representing the row data. The header contains the following fields:</p>
<ul>
<li><p><code>page_type</code>: byte representing the page type. For <code>table btree-leaf</code> pages, this is 0x0D.</p>
</li>
<li><p><code>first_freeblock</code>: 2-byte integer representing the offset of the first free block in the page, or zero if there is no freeblock.</p>
</li>
<li><p><code>cell_count</code>: 2-byte integer representing the number of cells in the page.</p>
</li>
<li><p><code>cell_content_offset</code>: 2-byte integer representing the offset of the first cell.</p>
</li>
<li><p><code>fragmented_bytes_count</code>: 1-byte integer representing the number of fragmented free bytes in the page (we won&#39;t make use of it for now).</p>
</li>
</ul>
<p>We&#39;ll start by defining a <code>Page</code> enum representing a parsed page, along with the necessary structs to represent the page header and the cell pointers:</p>
<pre><code><span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>enum</span> <span>Page</span></span> {
    TableLeaf(TableLeafPage),
}

<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>TableLeafPage</span></span> {
    <span>pub</span> header: PageHeader,
    <span>pub</span> cell_pointers: <span>Vec</span>&lt;<span>u16</span>&gt;,
    <span>pub</span> cells: <span>Vec</span>&lt;TableLeafCell&gt;,
}

<span>#[derive(Debug, Copy, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>PageHeader</span></span> {
    <span>pub</span> page_type: PageType,
    <span>pub</span> first_freeblock: <span>u16</span>,
    <span>pub</span> cell_count: <span>u16</span>,
    <span>pub</span> cell_content_offset: <span>u32</span>,
    <span>pub</span> fragmented_bytes_count: <span>u8</span>,
}

<span>#[derive(Debug, Copy, Clone)]</span>
<span>pub</span> <span><span>enum</span> <span>PageType</span></span> {
    TableLeaf,
}

<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>TableLeafCell</span></span> {
    <span>pub</span> size: <span>i64</span>,
    <span>pub</span> row_id: <span>i64</span>,
    <span>pub</span> payload: <span>Vec</span>&lt;<span>u8</span>&gt;,
}
</code></pre>
<p>The corresponding parsing functions are quite straightforward. Note the offset handling in <code>parse_page</code>: since the first page contains the database header, we start parsing the page at offset 100.</p>
<pre><code><span>/// pager.rs</span>
<span>const</span> PAGE_LEAF_HEADER_SIZE: <span>usize</span> = <span>8</span>;
<span>const</span> PAGE_FIRST_FREEBLOCK_OFFSET: <span>usize</span> = <span>1</span>;
<span>const</span> PAGE_CELL_COUNT_OFFSET: <span>usize</span> = <span>3</span>;
<span>const</span> PAGE_CELL_CONTENT_OFFSET: <span>usize</span> = <span>5</span>;
<span>const</span> PAGE_FRAGMENTED_BYTES_COUNT_OFFSET: <span>usize</span> = <span>7</span>;

<span><span>fn</span> <span>parse_page</span></span>(buffer: &amp;[<span>u8</span>], page_num: <span>usize</span>) -&gt; anyhow::<span>Result</span>&lt;page::Page&gt; {
    <span>let</span> ptr_offset = <span>if</span> page_num == <span>1</span> { HEADER_SIZE <span>as</span> <span>u16</span> } <span>else</span> { <span>0</span> };

    <span>match</span> buffer[<span>0</span>] {
        PAGE_LEAF_TABLE_ID =&gt; parse_table_leaf_page(buffer, ptr_offset),
        _ =&gt; <span>Err</span>(anyhow::anyhow!(<span>&#34;unknown page type: {}&#34;</span>, buffer[<span>0</span>])),
    }
}

<span><span>fn</span> <span>parse_table_leaf_page</span></span>(buffer: &amp;[<span>u8</span>], ptr_offset: <span>u16</span>) -&gt; anyhow::<span>Result</span>&lt;page::Page&gt; {
    <span>let</span> header = parse_page_header(buffer)?;

    <span>let</span> content_buffer = &amp;buffer[PAGE_LEAF_HEADER_SIZE..];
    <span>let</span> cell_pointers = parse_cell_pointers(content_buffer, header.cell_count <span>as</span> <span>usize</span>, ptr_offset);

    <span>let</span> cells = cell_pointers
        .iter()
        .map(|&amp;ptr| parse_table_leaf_cell(&amp;buffer[ptr <span>as</span> <span>usize</span>..]))
        .collect::&lt;anyhow::<span>Result</span>&lt;<span>Vec</span>&lt;page::TableLeafCell&gt;&gt;&gt;()?;

    <span>Ok</span>(page::Page::TableLeaf(page::TableLeafPage {
        header,
        cell_pointers,
        cells,
    }))
}


<span><span>fn</span> <span>parse_page_header</span></span>(buffer: &amp;[<span>u8</span>]) -&gt; anyhow::<span>Result</span>&lt;page::PageHeader&gt; {
    <span>let</span> page_type = <span>match</span> buffer[<span>0</span>] {
        <span>0x0d</span> =&gt; page::PageType::TableLeaf,
        _ =&gt; anyhow::bail!(<span>&#34;unknown page type: {}&#34;</span>, buffer[<span>0</span>]),
    };

    <span>let</span> first_freeblock = read_be_word_at(buffer, PAGE_FIRST_FREEBLOCK_OFFSET);
    <span>let</span> cell_count = read_be_word_at(buffer, PAGE_CELL_COUNT_OFFSET);
    <span>let</span> cell_content_offset = <span>match</span> read_be_word_at(buffer, PAGE_CELL_CONTENT_OFFSET) {
        <span>0</span> =&gt; <span>65536</span>,
        n =&gt; n <span>as</span> <span>u32</span>,
    };
    <span>let</span> fragmented_bytes_count = buffer[PAGE_FRAGMENTED_BYTES_COUNT_OFFSET];

    <span>Ok</span>(page::PageHeader {
        page_type,
        first_freeblock,
        cell_count,
        cell_content_offset,
        fragmented_bytes_count,
    })
}


<span><span>fn</span> <span>parse_cell_pointers</span></span>(buffer: &amp;[<span>u8</span>], n: <span>usize</span>, ptr_offset: <span>u16</span>) -&gt; <span>Vec</span>&lt;<span>u16</span>&gt; {
    <span>let</span> <span>mut</span> pointers = <span>Vec</span>::with_capacity(n);
    <span>for</span> i <span>in</span> <span>0</span>..n {
        pointers.push(read_be_word_at(buffer, <span>2</span> * i) - ptr_offset);
    }
    pointers
}

<span><span>fn</span> <span>parse_table_leaf_cell</span></span>(<span>mut</span> buffer: &amp;[<span>u8</span>]) -&gt; anyhow::<span>Result</span>&lt;page::TableLeafCell&gt; {
    <span>let</span> (n, size) = read_varint_at(buffer, <span>0</span>);
    buffer = &amp;buffer[n <span>as</span> <span>usize</span>..];

    <span>let</span> (n, row_id) = read_varint_at(buffer, <span>0</span>);
    buffer = &amp;buffer[n <span>as</span> <span>usize</span>..];

    <span>let</span> payload = buffer[..size <span>as</span> <span>usize</span>].to_vec();

    <span>Ok</span>(page::TableLeafCell {
        size,
        row_id,
        payload,
    })
}

<span><span>fn</span> <span>read_varint_at</span></span>(buffer: &amp;[<span>u8</span>], <span>mut</span> offset: <span>usize</span>) -&gt; (<span>u8</span>, <span>i64</span>) {
    <span>let</span> <span>mut</span> size = <span>0</span>;
    <span>let</span> <span>mut</span> result = <span>0</span>;

    <span>while</span> size &lt; <span>8</span> &amp;&amp; buffer[offset] &gt;= <span>0b1000_0000</span> {
        result |= ((buffer[offset] <span>as</span> <span>i64</span>) &amp; <span>0b0111_1111</span>) &lt;&lt; (<span>7</span> * size);
        offset += <span>1</span>;
        size += <span>1</span>;
    }

    result |= (buffer[offset] <span>as</span> <span>i64</span>) &lt;&lt; (<span>7</span> * size);

    (size + <span>1</span>, result)
}
</code></pre>
<p>To read a varint, we copy the 7 least significant bits of each byte to the result, as long as the most significant bit is set. As the maximum length of a varint is 9 bytes, we stop after reading 8 bytes to avoid potential overflows.</p>
<p>We can finally implement the pager itself. For now, it only loads and caches pages without any eviction policy:</p>
<pre><code><span>// pager.rs</span>
<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>Pager</span></span>&lt;I: Read + Seek = std::fs::File&gt; {
    input: I,
    page_size: <span>usize</span>,
    pages: HashMap&lt;<span>usize</span>, page::Page&gt;,
}

<span>impl</span>&lt;I: Read + Seek&gt; Pager&lt;I&gt; {
    <span>pub</span> <span><span>fn</span> <span>new</span></span>(input: I, page_size: <span>usize</span>) -&gt; <span>Self</span> {
        <span>Self</span> {
            input,
            page_size,
            pages: HashMap::new(),
        }
    }

    <span>pub</span> <span><span>fn</span> <span>read_page</span></span>(&amp;<span>mut</span> <span>self</span>, n: <span>usize</span>) -&gt; anyhow::<span>Result</span>&lt;&amp;page::Page&gt; {
        <span>if</span> <span>self</span>.pages.contains_key(&amp;n) {
            <span>return</span> <span>Ok</span>(<span>self</span>.pages.get(&amp;n).unwrap());
        }

        <span>let</span> page = <span>self</span>.load_page(n)?;
        <span>self</span>.pages.insert(n, page);
        <span>Ok</span>(<span>self</span>.pages.get(&amp;n).unwrap())
    }

    <span><span>fn</span> <span>load_page</span></span>(&amp;<span>mut</span> <span>self</span>, n: <span>usize</span>) -&gt; anyhow::<span>Result</span>&lt;page::Page&gt; {
        <span>let</span> offset = HEADER_SIZE + n.saturating_sub(<span>1</span>) * <span>self</span>.page_size;

        <span>self</span>.input
            .seek(SeekFrom::Start(offset <span>as</span> <span>u64</span>))
            .context(<span>&#34;seek to page start&#34;</span>)?;

        <span>let</span> <span>mut</span> buffer = <span>vec!</span>[<span>0</span>; <span>self</span>.page_size];
        <span>self</span>.input.read_exact(&amp;<span>mut</span> buffer).context(<span>&#34;read page&#34;</span>)?;

        parse_page(&amp;buffer, n)
    }
}
</code></pre>
<h2 id="heading-records">Records</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1721683662504/a35ea5c9-4215-4385-9dc3-3c7779f8af0b.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>We now have a way to read pages, and to access the pages cells. But how to decode the values of the cells? Each cell contains the value of a row in the table, encoded using the <a target="_blank" href="https://www.sqlite.org/fileformat2.html#record_format">SQLite record format</a>. The record format is quite simple: a record consists of a header, followed by a sequence of field values. The header starts with a varint representing the byte size of the headerm followed by a sequence of varints -one per column- determining the type of each column according to the following table:</p>
<ul>
<li><p>0: NULL</p>
</li>
<li><p>1: 8-bits signed integer</p>
</li>
<li><p>2: 16-bits signed integer</p>
</li>
<li><p>3: 24-bits signed integer</p>
</li>
<li><p>4: 32-bits signed integer</p>
</li>
<li><p>5: 48-bits signed integer</p>
</li>
<li><p>6: 64-bits signed integer</p>
</li>
<li><p>7: 64-bits IEEE floating point number</p>
</li>
<li><p>8: value is the integer 0</p>
</li>
<li><p>9: value is the integer 1</p>
</li>
<li><p>10 &amp; 11: reserved for internal use</p>
</li>
<li><p>n with n even and n &gt; 12: BLOB of size (n - 12) / 2</p>
</li>
<li><p>n with n odd and n &gt; 13: text of size (n - 13) / 2</p>
</li>
</ul>
<p>We now have all the informations we need to parse and represent record&#39;s headers:</p>
<pre><code><span>// src/cursor.rs</span>
<span>#[derive(Debug, Copy, Clone)]</span>
<span>pub</span> <span><span>enum</span> <span>RecordFieldType</span></span> {
    Null,
    I8,
    I16,
    I24,
    I32,
    I48,
    I64,
    Float,
    Zero,
    One,
    <span>String</span>,
    Blob,
}

<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>RecordField</span></span> {
    <span>pub</span> offset: <span>usize</span>,
    <span>pub</span> field_type: RecordFieldType,
}

<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>struct</span> <span>RecordHeader</span></span> {
    <span>pub</span> fields: <span>Vec</span>&lt;RecordField&gt;,
}

<span><span>fn</span> <span>parse_record_header</span></span>(<span>mut</span> buffer: &amp;[<span>u8</span>]) -&gt; anyhow::<span>Result</span>&lt;RecordHeader&gt; {
    <span>let</span> (varint_size, header_length) = crate::pager::read_varint_at(buffer, <span>0</span>);
    buffer = &amp;buffer[varint_size <span>as</span> <span>usize</span>..header_length <span>as</span> <span>usize</span>];

    <span>let</span> <span>mut</span> fields = <span>Vec</span>::new();
    <span>let</span> <span>mut</span> current_offset = header_length <span>as</span> <span>usize</span>;

    <span>while</span> !buffer.is_empty() {
        <span>let</span> (discriminant_size, discriminant) = crate::pager::read_varint_at(buffer, <span>0</span>);
        buffer = &amp;buffer[discriminant_size <span>as</span> <span>usize</span>..];

        <span>let</span> (field_type, field_size) = <span>match</span> discriminant {
            <span>0</span> =&gt; (RecordFieldType::Null, <span>0</span>),
            <span>1</span> =&gt; (RecordFieldType::I8, <span>1</span>),
            <span>2</span> =&gt; (RecordFieldType::I16, <span>2</span>),
            <span>3</span> =&gt; (RecordFieldType::I24, <span>3</span>),
            <span>4</span> =&gt; (RecordFieldType::I32, <span>4</span>),
            <span>5</span> =&gt; (RecordFieldType::I48, <span>6</span>),
            <span>6</span> =&gt; (RecordFieldType::I64, <span>8</span>),
            <span>7</span> =&gt; (RecordFieldType::Float, <span>8</span>),
            <span>8</span> =&gt; (RecordFieldType::Zero, <span>0</span>),
            <span>9</span> =&gt; (RecordFieldType::One, <span>0</span>),
            n <span>if</span> n &gt;= <span>12</span> &amp;&amp; n % <span>2</span> == <span>0</span> =&gt; {
                <span>let</span> size = ((n - <span>12</span>) / <span>2</span>) <span>as</span> <span>usize</span>;
                (RecordFieldType::Blob(size), size)
            }
            n <span>if</span> n &gt;= <span>13</span> &amp;&amp; n % <span>2</span> == <span>1</span> =&gt; {
                <span>let</span> size = ((n - <span>13</span>) / <span>2</span>) <span>as</span> <span>usize</span>;
                (RecordFieldType::<span>String</span>(size), size)
            }
            n =&gt; anyhow::bail!(<span>&#34;unsupported field type: {}&#34;</span>, n),
        };

        fields.push(RecordField {
            offset: current_offset,
            field_type,
        });

        current_offset += field_size;
    }

    <span>Ok</span>(RecordHeader { fields })
}
</code></pre>
<p>To make it easier to work with records, we&#39;ll define a <code>Value</code> type, representing field values and a <code>Cursor</code> struct that uniquely identifies a record within a database file. The <code>Cursor</code> will expose a <code>field</code> method, returning the value of the record&#39;s n-th field:</p>
<pre><code><span>// src/value.rs</span>
<span>use</span> std::borrow::Cow;

<span>#[derive(Debug, Clone)]</span>
<span>pub</span> <span><span>enum</span> <span>Value</span></span>&lt;<span>&#39;p</span>&gt; {
    Null,
    <span>String</span>(Cow&lt;<span>&#39;p</span>, <span>str</span>&gt;),
    Blob(Cow&lt;<span>&#39;p</span>, [<span>u8</span>]&gt;),
    Int(<span>i64</span>),
    Float(<span>f64</span>),
}

<span>impl</span>&lt;<span>&#39;p</span>&gt; Value&lt;<span>&#39;p</span>&gt; {
    <span>pub</span> <span><span>fn</span> <span>as_str</span></span>(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;<span>str</span>&gt; {
        <span>if</span> <span>let</span> Value::<span>String</span>(s) = <span>self</span> {
            <span>Some</span>(s.as_ref())
        } <span>else</span> {
            <span>None</span>
        }
    }
}
</code></pre>
<pre><code><span>// src/cursor.rs</span>
<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Cursor</span></span>&lt;<span>&#39;p</span>&gt; {
    header: RecordHeader,
    pager: &amp;<span>&#39;p</span> <span>mut</span> Pager,
    page_index: <span>usize</span>,
    page_cell: <span>usize</span>,
}

<span>impl</span>&lt;<span>&#39;p</span>&gt; Cursor&lt;<span>&#39;p</span>&gt; {
    <span>pub</span> <span><span>fn</span> <span>field</span></span>(&amp;<span>mut</span> <span>self</span>, n: <span>usize</span>) -&gt; <span>Option</span>&lt;Value&gt; {
        <span>let</span> record_field = <span>self</span>.header.fields.get(n)?;

        <span>let</span> payload = <span>match</span> <span>self</span>.pager.read_page(<span>self</span>.page_index) {
            <span>Ok</span>(Page::TableLeaf(leaf)) =&gt; &amp;leaf.cells[<span>self</span>.page_cell].payload,
            _ =&gt; <span>return</span> <span>None</span>,
        };

        <span>match</span> record_field.field_type {
            RecordFieldType::Null =&gt; <span>Some</span>(Value::Null),
            RecordFieldType::I8 =&gt; <span>Some</span>(Value::Int(read_i8_at(payload, record_field.offset))),
            RecordFieldType::I16 =&gt; <span>Some</span>(Value::Int(read_i16_at(payload, record_field.offset))),
            RecordFieldType::I24 =&gt; <span>Some</span>(Value::Int(read_i24_at(payload, record_field.offset))),
            RecordFieldType::I32 =&gt; <span>Some</span>(Value::Int(read_i32_at(payload, record_field.offset))),
            RecordFieldType::I48 =&gt; <span>Some</span>(Value::Int(read_i48_at(payload, record_field.offset))),
            RecordFieldType::I64 =&gt; <span>Some</span>(Value::Int(read_i64_at(payload, record_field.offset))),
            RecordFieldType::Float =&gt; <span>Some</span>(Value::Float(read_f64_at(payload, record_field.offset))),
            RecordFieldType::<span>String</span>(length) =&gt; {
                <span>let</span> value = std::<span>str</span>::from_utf8(
                    &amp;payload[record_field.offset..record_field.offset + length],
                ).expect(<span>&#34;invalid utf8&#34;</span>);
                <span>Some</span>(Value::<span>String</span>(Cow::Borrowed(value)))
            }
            RecordFieldType::Blob(length) =&gt; {
                <span>let</span> value = &amp;payload[record_field.offset..record_field.offset + length];
                <span>Some</span>(Value::Blob(Cow::Borrowed(value)))
            }
            _ =&gt; <span>panic!</span>(<span>&#34;unimplemented&#34;</span>),
        }
    }
}

<span><span>fn</span> <span>read_i8_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    input[offset] <span>as</span> <span>i64</span>
}

<span><span>fn</span> <span>read_i16_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    <span>i16</span>::from_be_bytes(input[offset..offset + <span>2</span>].try_into().unwrap()) <span>as</span> <span>i64</span>
}

<span><span>fn</span> <span>read_i24_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    (<span>i32</span>::from_be_bytes(input[offset..offset + <span>3</span>].try_into().unwrap()) &amp; <span>0x00FFFFFF</span>) <span>as</span> <span>i64</span>
}

<span><span>fn</span> <span>read_i32_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    <span>i32</span>::from_be_bytes(input[offset..offset + <span>4</span>].try_into().unwrap()) <span>as</span> <span>i64</span>
}

<span><span>fn</span> <span>read_i48_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    <span>i64</span>::from_be_bytes(input[offset..offset + <span>6</span>].try_into().unwrap()) &amp; <span>0x0000FFFFFFFFFFFF</span>
}

<span><span>fn</span> <span>read_i64_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>i64</span> {
    <span>i64</span>::from_be_bytes(input[offset..offset + <span>8</span>].try_into().unwrap())
}

<span><span>fn</span> <span>read_f64_at</span></span>(input: &amp;[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>f64</span> {
    <span>f64</span>::from_be_bytes(input[offset..offset + <span>8</span>].try_into().unwrap())
}
</code></pre>
<p>To simplify iteration over a page&#39;s records, we&#39;ll also implement a <code>Scanner</code> struct that wraps a page and allows us to get a <code>Cursor</code> for each record:</p>
<pre><code><span>// src/cursor.rs</span>
<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Scanner</span></span>&lt;<span>&#39;p</span>&gt; {
    pager: &amp;<span>&#39;p</span> <span>mut</span> Pager,
    page: <span>usize</span>,
    cell: <span>usize</span>,
}

<span>impl</span>&lt;<span>&#39;p</span>&gt; Scanner&lt;<span>&#39;p</span>&gt; {
    <span>pub</span> <span><span>fn</span> <span>new</span></span>(pager: &amp;<span>&#39;p</span> <span>mut</span> Pager, page: <span>usize</span>) -&gt; Scanner&lt;<span>&#39;p</span>&gt; {
        Scanner {
            pager,
            page,
            cell: <span>0</span>,
        }
    }
    <span>pub</span> <span><span>fn</span> <span>next_record</span></span>(&amp;<span>mut</span> <span>self</span>) -&gt; <span>Option</span>&lt;anyhow::<span>Result</span>&lt;Cursor&gt;&gt; {
        <span>let</span> page = <span>match</span> <span>self</span>.pager.read_page(<span>self</span>.page) {
            <span>Ok</span>(page) =&gt; page,
            <span>Err</span>(e) =&gt; <span>return</span> <span>Some</span>(<span>Err</span>(e)),
        };

        <span>match</span> page {
            Page::TableLeaf(leaf) =&gt; {
                <span>let</span> cell = leaf.cells.get(<span>self</span>.cell)?;

                <span>let</span> header = <span>match</span> parse_record_header(&amp;cell.payload) {
                    <span>Ok</span>(header) =&gt; header,
                    <span>Err</span>(e) =&gt; <span>return</span> <span>Some</span>(<span>Err</span>(e)),
                };

                <span>let</span> record = Cursor {
                    header,
                    pager: <span>self</span>.pager,
                    page_index: <span>self</span>.page,
                    page_cell: <span>self</span>.cell,
                };

                <span>self</span>.cell += <span>1</span>;

                <span>Some</span>(<span>Ok</span>(record))
            }
        }
    }
}
</code></pre>
<h2 id="heading-table-descriptions">Table descriptions</h2>
<p>With most of the leg work out of the way, we can get back to our original goal: listing tables. SQLite stores the schema of a database in a special table called <code>sqlite_master</code>. The schema for the <code>sqlite_master</code> table is as follows:</p>
<pre><code><span>CREATE</span> <span>TABLE</span> sqlite_schema(
  <span>type</span> <span>text</span>,
  <span>name</span> <span>text</span>,
  tbl_name <span>text</span>,
  rootpage <span>integer</span>,
  <span>sql</span> <span>text</span>
);
</code></pre>
<p>Theses columns are used as follows:</p>
<ul>
<li><p><code>type</code>: the type of the schema object. For tables, this will always be <code>table</code>.</p>
</li>
<li><p><code>name</code>: the name of the schema object.</p>
</li>
<li><p><code>tbl_name</code>: the name of the table the schema object is associated with. In the case of tables, this will be the same as <code>name</code>.</p>
</li>
<li><p><code>rootpage</code>: root page of the table, we&#39;ll use it later to read the table&#39;s content.</p>
</li>
<li><p><code>sql</code>: the SQL statement used to create the table.</p>
</li>
</ul>
<p>Since our simple database only handles basic schemas for now, we can assume that the entire schema fits in the first page of our database file. In order to list the tables in the database, we&#39;ll need to:</p>
<ul>
<li><p>initialize the pager with the database file</p>
</li>
<li><p>create a <code>Scanner</code> for the first page</p>
</li>
<li><p>iterate over the records, and print the value of the <code>name</code> field (at index 1) for each record.</p>
</li>
</ul>
<p>First, we&#39;ll define a <code>Db</code> struct to hold our global state:</p>
<pre><code><span>// src/db.rs</span>
<span>use</span> std::{io::Read, path::Path};

<span>use</span> anyhow::Context;

<span>use</span> crate::{cursor::Scanner, page::DbHeader, pager, pager::Pager};

<span>pub</span> <span><span>struct</span> <span>Db</span></span> {
    <span>pub</span> header: DbHeader,
    pager: Pager,
}

<span>impl</span> Db {
    <span>pub</span> <span><span>fn</span> <span>from_file</span></span>(filename: <span>impl</span> <span>AsRef</span>&lt;Path&gt;) -&gt; anyhow::<span>Result</span>&lt;Db&gt; {
        <span>let</span> <span>mut</span> file = std::fs::File::open(filename.as_ref()).context(<span>&#34;open db file&#34;</span>)?;

        <span>let</span> <span>mut</span> header_buffer = [<span>0</span>; pager::HEADER_SIZE];
        file.read_exact(&amp;<span>mut</span> header_buffer)
            .context(<span>&#34;read db header&#34;</span>)?;

        <span>let</span> header = pager::parse_header(&amp;header_buffer).context(<span>&#34;parse db header&#34;</span>)?;

        <span>let</span> pager = Pager::new(file, header.page_size <span>as</span> <span>usize</span>);

        <span>Ok</span>(Db { header, pager })
    }

    <span>pub</span> <span><span>fn</span> <span>scanner</span></span>(&amp;<span>mut</span> <span>self</span>, page: <span>usize</span>) -&gt; Scanner {
        Scanner::new(&amp;<span>mut</span> <span>self</span>.pager, page)
    }
}
</code></pre>
<p>The implementation of a basic REPL supporting the <code>tables</code> and <code>tables</code> commands is straightforward:</p>
<pre><code><span>use</span> std::io::{stdin, BufRead, Write};

<span>use</span> anyhow::Context;

<span>mod</span> cursor;
<span>mod</span> db;
<span>mod</span> page;
<span>mod</span> pager;
<span>mod</span> value;

<span><span>fn</span> <span>main</span></span>() -&gt; anyhow::<span>Result</span>&lt;()&gt; {
    <span>let</span> database = db::Db::from_file(std::env::args().nth(<span>1</span>).context(<span>&#34;missing db file&#34;</span>)?)?;
    cli(database)
}

<span><span>fn</span> <span>cli</span></span>(<span>mut</span> db: db::Db) -&gt; anyhow::<span>Result</span>&lt;()&gt; {
    print_flushed(<span>&#34;rqlite&gt; &#34;</span>)?;

    <span>let</span> <span>mut</span> line_buffer = <span>String</span>::new();

    <span>while</span> stdin().lock().read_line(&amp;<span>mut</span> line_buffer).is_ok() {
        <span>match</span> line_buffer.trim() {
            <span>&#34;.exit&#34;</span> =&gt; <span>break</span>,
            <span>&#34;.tables&#34;</span> =&gt; display_tables(&amp;<span>mut</span> db)?,
            _ =&gt; {
                <span>println!</span>(<span>&#34;Unrecognized command &#39;{}&#39;&#34;</span>, line_buffer.trim());
            }
        }

        print_flushed(<span>&#34;\nrqlite&gt; &#34;</span>)?;

        line_buffer.clear();
    }

    <span>Ok</span>(())
}

<span><span>fn</span> <span>display_tables</span></span>(db: &amp;<span>mut</span> db::Db) -&gt; anyhow::<span>Result</span>&lt;()&gt; {
    <span>let</span> <span>mut</span> scanner = db.scanner(<span>1</span>);

    <span>while</span> <span>let</span> <span>Some</span>(<span>Ok</span>(<span>mut</span> record)) = scanner.next_record() {
        <span>let</span> type_value = record
            .field(<span>0</span>)
            .context(<span>&#34;missing type field&#34;</span>)
            .context(<span>&#34;invalid type field&#34;</span>)?;

        <span>if</span> type_value.as_str() == <span>Some</span>(<span>&#34;table&#34;</span>) {
            <span>let</span> name_value = record
                .field(<span>1</span>)
                .context(<span>&#34;missing name field&#34;</span>)
                .context(<span>&#34;invalid name field&#34;</span>)?;

            <span>print!</span>(<span>&#34;{} &#34;</span>, name_value.as_str().unwrap());
        }
    }

    <span>Ok</span>(())
}

<span><span>fn</span> <span>print_flushed</span></span>(s: &amp;<span>str</span>) -&gt; anyhow::<span>Result</span>&lt;()&gt; {
    <span>print!</span>(<span>&#34;{}&#34;</span>, s);
    std::io::stdout().flush().context(<span>&#34;flush stdout&#34;</span>)
}
</code></pre>
<h2 id="heading-conclusion">Conclusion</h2>
<p>The first part of our SQLite-compatible database is now complete. We can read the database header, parse table btree-leaf pages and decode records, but we still have a long way to go before we can support rich queries. In the next part, we&#39;ll learn how to parse the SQL language and make our first strides towards implementing the <code>SELECT</code> statement!</p>
</div></div></div>
  </body>
</html>
