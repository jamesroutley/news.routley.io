<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uber.com/blog/migrating-from-dynamodb-to-ledgerstore/">Original</a>
    <h1>Migrating Uber&#39;s ledger data from DynamoDB to LedgerStore</h1>
    
    <div id="readability-page-1" class="page"><div data-baseweb="block">


<p>Last week, we explored <span><a href="https://www.uber.com/blog/how-ledgerstore-supports-trillions-of-indexes/" target="_blank" rel="noreferrer noopener">LedgerStore</a></span> (LSG) – Uber’s append-only, ledger-style database. This week, we’ll dive into how we migrated Uber’s business-critical ledger data to LSG. We’ll detail how we moved more than a trillion entries (making up a few petabytes of data) transparently and without causing disruption, and we’ll discuss what we learned during the migration. </p>


<p><h3 id="h-history">History</h3></p>


<p>Gulfstream is Uber’s payment platform. It was <span><a href="https://www.uber.com/blog/payments-platform" target="_blank" rel="noreferrer noopener">launched in 2017</a></span> using DynamoDB for storage. At Uber’s scale, DynamoDB became expensive. Hence, we started keeping only 12 weeks of data (i.e., hot data) in DynamoDB and started using Uber’s blobstore, TerraBlob, for older data (i.e., cold data). TerraBlob is similar to AWS S3.</p>


<p>For a long-term solution, we wanted to use <span><a href="https://www.uber.com/blog/dynamodb-to-docstore-migration/" target="_blank" rel="noreferrer noopener">LSG</a></span>. It was purpose-built for storing payment-style data. Its key features are:</p>


<div><ul><li>It is verifiably immutable (i.e., you can check that records have not been altered using cryptographic signatures)</li>


<li>Tiered storage to manage cost (the hot data is kept at a place that is best to serve requests and cold data is stored at a place that is optimized for storage)</li>


<li>Better lag for eventually consistent secondary indexes</li>
</ul></div>


<p>So, by 2021, Gulfstream was using a combination of DynamoDB, TerraBlob, and LSG to store data.</p>


<div><ul><li>DynamoDB for the last 12 weeks of data</li>


<li>TerraBlob, Uber’s internal blob store, for cold data</li>


<li>LSG, where we were writing data, and wanted to migrate to it</li>
</ul></div>


<hr aria-hidden="true" role="separator"/>


<p><h2 id="h-why-migrate">Why Migrate?</h2></p>


<p>LSG is better suited for storing ledger-style data because of its immutability. The recurring cost savings by moving to LSG were significant.</p>


<p>Going from three to a single storage would simplify the code and design of the Gulfstream services responsible for interacting with storage and creating indexes. This in turn makes it easy to understand and maintain the services.</p>


<p>LSG promised shorter indexing lag (i.e., time between when a record is written and its secondary index is created). Additionally, it would give us faster network latency because it was running on-premises within Uber’s data centers.</p>


<hr aria-hidden="true" role="separator"/>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;hash&#34;:&#34;703dd30b-2e89-49b2-83e7-b9fd8c309db0&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><img alt="Image" src="https://lh7-us.googleusercontent.com/ImSq9jhPp_-uGFsvBU0tmJA1MiY42lmKUH1fLoNJ036l2w7W9uLx89xRnBO30l7lRkHXQ0XQv_flDWeZB0pfRyYzczFfayP_Vi4j217OZt8fG5WxpM2FKdt3lB34s0emy0gp6nUKNfS2q7MR5z8ZUbc" loading="lazy"/><figcaption>Figure 1: Data flow before and after the migration</figcaption></figure></div>

<hr aria-hidden="true" role="separator"/>


<p><h2 id="h-nature-of-data-amp-associated-risk">Nature of Data &amp; Associated Risk</h2></p>


<p>The data we were migrating is all of Uber’s ledger data for all of Uber’s business since 2017:</p>


<div><ul><li>Immutable records – 1.2 PB compressed size</li>


<li>Secondary indexes – 0.5 PB uncompressed size</li>
</ul></div>


<p>Immutable records should not be modified. So, for all practical purposes, once we have written a record, it can’t be changed. We do have the flexibility of modifying secondary index data for correcting problems.</p>


<p><h2 id="h-checks">Checks</h2></p>


<p>To ensure that the backfill is correct and acceptable in all respects, we need to check that we can handle the current traffic and the data that is not being accessed currently is correct. The criteria for this was:</p>


<div><ul><li>Completeness: All the records were backfilled.</li>


<li>Correctness: All the records were correct.</li>


<li>Load: LSG should be able to handle current load.</li>


<li>Latency: The P99 latency of LSG was within acceptable bounds.</li>


<li>Lag: The secondary indexes are created in the background. We want to make sure that the delay of the index creation process was within acceptable limits.</li>
</ul></div>


<p>The checks were done using a combination of <em>shadow validation</em> and <em>offline validation</em>.</p>


<p><h3 id="h-shadow-validation">Shadow Validation</h3></p>


<p>This compares the response that we had been returning before migration with the one that we would return with the LSG as data source. This helps us ensure that our current traffic will be disrupted by neither data migration issues nor code bugs. We wanted our backfill to be at least 99.99% complete and correct as measured by shadow validation. We also had a 99.9999% upper bound for the same. The reason for having an upper bound are:</p>


<div><ul><li>When migrating historical data, there are always data corruption issues. Sometimes this is because data was not written correctly during the initial development time of the service. It is also possible to see data corruption because of scale. As an example, S3 gives 11 nines of durability guarantee then you can expect 10 corruptions in 1 trillion records.</li>


<li>Indexes are eventually consistent, which means that some records will appear after a few seconds. So, the shadow validation will flag them as missing. This is a false positive that shows up at a large scale.</li>


<li>For 6 nines, you have to look at data of 100 million comparisons to give any results with good confidence. This means if your shadow validation is comparing 1,000 records/second, then you need to wait for a bit more than one day just to collect sufficient data. With 7 nines, you will have to wait 12 days. In practical terms this would slow the project to a halt.</li>


<li>With a well-defined upper bound, you are not forced to look at every potential issue that you suspect. Say if the occurrence of a problem is 1/10 of the upper bound, you need not even investigate it.</li>


<li>With 6 nines, we could end up with slightly more than 1 million corrupt records.  Even though 6 nines of confirmed correctness could mean a real cost to the company, the savings generated by this project outweighed the potential cost.</li>
</ul></div>


<p>During shadow validation you are essentially duplicating production traffic on LSG. So by monitoring LSG, we can verify that it can handle our production traffic while meeting our latency and lag requirements. It gives us good confidence in the code that we wrote for accessing the data from LSG. Additionally, it also gives us some confidence about completeness and correctness of data, particularly with data that is currently being accessed. We developed a single generic shadow validation code that was reused multiple times for different parts of the migration.</p>


<p>During the migration process we found latency and lag issues because of multiple bugs in different parts and fixed them.</p>


<div><ul><li>Partition key optimization for better distribution of index data</li>


<li>Index issues causing scan of the record instead of point lookup</li>
</ul></div>


<p>Unfortunately, live shadow validation can’t give strong guarantees about our corpus of rarely-accessed historical data.</p>


<p><h3 id="h-offline-validation-amp-incremental-backfill">Offline Validation &amp; Incremental Backfill</h3></p>


<p>This compares complete data from the LSG with the data dump from DynamoDB. Because of various data issues, you have to skip over bad records to ensure that your backfill can go through. Additionally, there can be bugs in the backfill job itself. Offline validation ensures that the data backfill has happened correctly and it covers complete data. This has to be done in addition to shadow validation because live traffic tends to access only recent data. So, if there are any problems lurking in the cold data that is infrequently accessed, it will not be caught by shadow validation. </p>


<p>The key challenge in offline validation is size of data. The biggest data that we tackled was 70 TB compressed (estimated 300 TB uncompressed) in size and we compared 760 billion records in a single job. This type of Apache Spark<sup>TM</sup> job requires data shuffling and <span><a href="https://www.uber.com/blog/ubers-highly-scalable-and-distributed-shuffle-as-a-service/">Distributed Shuffle as a Service for Spark</a></span> combined with Dynamic Resource Allocation and Speculative Execution let us do exactly that at a reasonable speed under resource constraints.</p>


<p>Offline validation found missing records and its output was used for incremental backfill. We iterated between offline validation and backfill to ensure that all the records were written. </p>


<hr aria-hidden="true" role="separator"/>


<p><h2 id="h-backfill-issues">Backfill Issues</h2></p>


<p>Every backfill is risky. We used Uber’s internal offering of Apache Spark for the backfills. Here are the different problems that we encountered and how we handled them.</p>


<p><h3 id="h-scalability">Scalability</h3></p>


<p>You want to start at a small scale and scale up gradually till you hit the limit of the system. If you just blindly push beyond this point then you are effectively creating a DDoS attack on your own systems. At this point, you want to find the bottleneck, address it, and then scale up your job. Most of the time it’s just a matter of scaling up downstream services, other times it can be something more complex. In either case, you don’t want to scale your backfill job beyond the capability of the bottleneck of the system. It’s a good idea to scale up in small increments and monitor closely after each scale-up.</p>


<p><h3 id="h-incremental-backfills">Incremental Backfills</h3></p>


<p>When you try to backfill 3 years’ worth of data in say 3 months, you are generating traffic that puts 10x the normal traffic load and the system may not be able to cope with this traffic. As an example, you will need 120 days to backfill 100B records at 10K/sec rate when your production normally handles 1K/sec rate. So, you can expect the system to get overloaded. If there is even a remote chance of the backfill job causing an ongoing problem, you must shut it down. So, it is unrealistic to expect that a backfill job can run from start to finish in one go, and therefore you have to run backfills incrementally.</p>


<p>A simple and effective way to do this is to break the backfill into small batches that can be done one by one, such that each batch can complete within a few minutes. Since your job may shut down in the middle of a batch, it has to be idempotent. Every time you complete a batch you want to dump the statistics (such as records read, records backfilled, etc.) to a file. As your backfill continues, you can aggregate numbers from them to check the progress.</p>


<p>If you can delete or update existing records, it lowers the risk and cost of mistakes and code bugs during the backfill.</p>


<p><h3 id="h-rate-control">Rate Control</h3></p>


<p>To backfill safely, you want to make sure that your backfill job behaves consistently. So, your job should have rate control that can be easily tweaked to scale up or scale down. In Java/Scala you can use Guava’s RateLimiter.</p>


<p><h3 id="h-dynamic-rate-control">Dynamic Rate Control</h3></p>


<p>In some cases, you may be able to go faster when there is less production traffic. For this you need to monitor the current state of the system and see if it’s ok to go faster. We adjusted RPS on the lines of <span><a href="https://en.wikipedia.org/wiki/Additive_increase/multiplicative_decrease" target="_blank" rel="noreferrer noopener">additive increase/multiplicative decrease</a></span>. We still had an upper bound on the traffic for safety.</p>


<p><h3 id="h-emergency-stop">Emergency Stop</h3></p>


<p>The migration process needs the ability to stop backfill quickly in case there is an outage or even suspicion of overload. Any backfill during an outage has to be stopped as both a precaution and as a potential source of noise. Even post-outage, systems tend to get extra load as systems recover. Having the ability to stop backfill also helps debug scale-related issues.</p>


<p><h3 id="h-size-of-data-file">Size of Data File</h3></p>


<p>When dumping data, keep the size of the files to around 1GB with 10x flexibility on both sides. If the size of the file is too big, you run into issues such as <span><a href="https://kb.databricks.com/cloud/s3-part-number-limit.html" target="_blank" rel="noreferrer noopener">MultiPart limitation of different tools</a></span>. If your file size is small, then you have too many files and even listing them will take significant time. You may even start hitting ARGMAX limit of when running commands in a shell. This becomes significant enough to make sure that every time you do something with data it has been applied to all files and not just some of them.</p>


<p><h3 id="h-fault-tolerance">Fault Tolerance</h3></p>


<p>All backfill jobs need some kind of data transformation. When you do this you inevitably run into data quality/corruption issues. You can’t stop the backfill job every time this happens because such bad records tend to be randomly distributed. But you can’t ignore them as well because it might also be because of a code bug. To deal with this, you dump problematic records separately and monitor statistics. If the failure rate is high then you can stop the backfill manually, fix the problem, and continue. Otherwise, let the backfill continue and look at the failures in parallel.</p>


<p>Another reason for records not getting written is RPC timeout. You can retry for this, but at some point, you have to give up and move ahead irrespective of the reason to make sure you can make progress.</p>


<p><h3 id="h-logging">Logging</h3></p>


<p>It is tempting to log during backfill to help with debugging and monitor progress, but this may not be possible because of the pressure that it will put on the logging infrastructure. Even if you can keep logs, there will be too much log data to keep around. The solution is to use a rate limiter to limit the amount of logs that you are producing. You need to rate limit only the parts that produce most of the logs. You can even choose to log all the errors if they happen infrequently.</p>


<hr aria-hidden="true" role="separator"/>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;hash&#34;:&#34;6d90d20e-65e3-4303-a9ac-c681f3d302bf&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><img alt="Image" src="https://lh7-us.googleusercontent.com/xWcB-v0gyFB4920hZx1tevZiHiSLhUKPvA7TZMvkCN6bsEmh5bZiTcZ0xYumbfjsgsG6Oz-Xnl85XeLhD4ofUc07poJ1OnsB4WlNCEyZzYmY9kuvfgCkSxzC4nSvqcBEmYQvANytw4oOyXA4wyQDias" loading="lazy"/></figure></div>

<hr aria-hidden="true" role="separator"/>


<p><h2 id="h-mitigating-risk">Mitigating Risk</h2></p>


<p>In addition to analyzing data from different validation and backfill stats we also were conservative with the rollout of LSG. We rolled it out over a few weeks and with go-aheads from on-call engineers of the major callers of our service. We initially rolled out with fallback (i.e., if the data was not found in LSG, we would try to fetch it from DynamoDB). We looked at the fallback logs before we removed the fallback. For every record that was flagged as missing in the fallback logs we checked LSG to make sure that it was not really missing. Even after that we kept the DynamoDB data around for a month before we stopped writing data to it, took a final backup, and dropped the table.</p>


<hr aria-hidden="true" role="separator"/>


<div><figure data-wp-block="{&#34;align&#34;:&#34;center&#34;,&#34;hash&#34;:&#34;27cf8a8b-813e-42c1-bc2a-41d62125a0d0&#34;,&#34;alt&#34;:&#34;&#34;}" data-wp-block-name="core/image"><img alt="Image" src="https://lh7-us.googleusercontent.com/P7cnF5dxZX7H5rA82nfZgC1ICBQX7Q928jAexep0GBSR39-B2kDw44hHTtEQQuBNmqw9ZeFz_KYY39uqlUBSEErrb2XWhWagcpWKrsb8tiDX_6CYfOXACQst7Wak7mIewxy4WvI3gW3Vza3altpn0Tc" loading="lazy"/><figcaption>Figure 2: LSG Rollout</figcaption></figure></div>

<hr aria-hidden="true" role="separator"/>





<p>In this article, we covered the migration of massive amounts of business-critical money data from one datastore to another. We covered different aspects of the migration, including criteria for migration, checks, backfill issues, and safety. We were able to do this migration over two years without any downtime or outages during or after the migration.</p>


<p><h3 id="h-acknowledgments">Acknowledgments</h3></p>


<p>Thanks to Amit Garg and Youxian Chen for helping us migrate the data from TerraBlob to LSG. Thanks to Jaydeepkumar Chovatia, Kaushik Devarajaiah, and Rashmi Gupta from the LSG team for supporting us throughout this work. Thanks to Menghan Li for migrating data for <span><a href="https://www.uber.com/en-EG/blog/cashless-payments-with-uber-cash/" target="_blank" rel="noreferrer noopener">Uber Cash</a></span>’s ledger.</p>





<p>Amazon Web Services, AWS, and the Powered by AWS logo are trademarks of Amazon.com, Inc. or its affiliates.</p>


<p>Apache®, Apache SparkTM, and SparkTM are either registered trademarks or trademarks of the Apache Software Foundation in the United States and/or other countries. No endorsement by The Apache Software Foundation is implied by the use of these marks.</p>
</div></div>
  </body>
</html>
