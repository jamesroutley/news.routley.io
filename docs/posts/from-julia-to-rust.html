<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://miguelraz.github.io/blog/juliatorust/index.html">Original</a>
    <h1>From Julia to Rust</h1>
    
    <div id="readability-page-1" class="page"><div><h3 id="from_julia_to_rust"><a href="#from_julia_to_rust">From Julia to Rust üó∫ </a></h3> <p>I&#39;ve been more serious about learning Rust recently, after dragging on with passive learning for a while. My first real programming language was Julia, and I know other Julians interested in Rust. I&#39;ve written this article for those people in mind, because Rust and Julia are good performance sparring partners, but Rust has a different mindset and tradeoffs that are worth considering.</p> <p>I hope you enjoy it.</p> <p><a href="https://www.youtube.com/watch?v=drvAftwsTlU">TLDR:</a></p> <blockquote> <p>&#34;It is important to draw wisdom from many different places. If you take it from only one place, it becomes rigid and stale.&#34;</p> <p>‚ÄìUncle Iroh</p> </blockquote> <hr/> <h3 id="why_rust"><a href="#why_rust">Why Rust? ü§∑ </a></h3> <p>There are 3 talks that sold me on Rust being worth learning, the first is <a href="https://www.youtube.com/watch?v=A3AdN7U24iU">by Carol Nichols</a> and the <a href="https://www.youtube.com/watch?v=cUrggIAPJEs">second is a lecture by Ryan Eberhardt and Armin Nanavari</a>. The first talks about how about ~70% of all bugs from the big tech corporations are from memory safety and that trains used to not have emergency brakes. The second explains how sytems programming codebases already impose the invariants of resource ownership on the coders - but that reasoning can be horribly error prone, tedious, and automated.</p> <p>That&#39;s the point of technology! To not have to worry about the previous generations problems because we figured out a way to offload that thinking to a machine. </p> <p>The third talk that really sold me on Rust was <a href="https://www.usenix.org/conference/enigma2021/presentation/gaynor">Alex Gaynor&#39;s</a>. It&#39;s bad enough that a bank or a school web site could crash because of memory bugs, but once you take into account the fact that not even the best programmers in the world (sorted by salaries, roughly) can ship safe code, you start to despair a little. Then you hear about the incredibly battle-tested libraries like <a href="https://www.helpnetsecurity.com/2021/01/27/cve-2021-3156/">sudo </a> and, as the moral argument goes, you are likely going to put vulnerable people in harm&#39;s way if you keep shipping a broken tool. I buy the urgency of that argument more and more when journalists or human rights advocates get targeted by state actors due to a trivial (but buried) C mistake.</p> <p>So that&#39;s the spiel for jumping on the Rust train when I argue with myself in the shower. What&#39;s the Rust&#39;s philosophy?</p> <hr/> <h3 id="informal_introductions_-_tales_of_two_languages"><a href="#informal_introductions_-_tales_of_two_languages">Informal introductions - tales of two languages üìö </a></h3> <p>I will now give 2 hand-wavy historical rehashings of the origins of both languages.</p> <p>You might know Julia&#39;s origin story - there were a gajillion DSLs for scientific computing, BLAS is a mess but implements polymorphism through namespacing for performance needs, and other libraries re-implemented a poor man&#39;s version of multiple dispatch because of the performance constraints. If you add a clever JIT to multiple dispatch capabilites, you can get ~C performance with ease if types can be inferred, and fortunately you can build a general programming language around that paradigm and those trade offs. Eventually, they baptized the language to honor the one true queen of <a href="https://youtu.be/lZb2JKhf-mk?t=208">algorithms</a>.</p> <p>Rust comes from a different place: Some years ago in Mozilla, Graydon Hoare and the team got fed up with systems programming and the C/C++ tool chain. They were working on a language that allowed for programmers to be productive in low-level systems, harness concurrency performance without the foot-bazookas, and avoid errors during run time. At first they had different systems for handling the previous problems, until the team pieced together that an ownership system, with a borrow checker at compile time, could kill 2 birds with one stone. Eventually, they named the language after the <a href="https://en.wikipedia.org/wiki/Rust_(fungus)">fungus</a>.</p> <p>Recap: Julians were sick of unreusable code, niche DSLs and hacky polymorphism. With multiple dispatch as the central design feature they solved those problems. Rustaceans were sick of the C/C++ minefields and trying to keep all the invariants of large, error-prone codebases in their head. The idea of ownership and a borrow checker to know those errors <em>at compile time</em> and be data-race free is what&#39;s got them to where they are now.</p> <p>There&#39;s obviously important details missing on both stories - you can get it from proper historians if you like, this is a brief and informal introduction. I will however, mention the other big Rustian idea of affine types when I talk about how they get a version of generic code we&#39;ve come to know and love in Julia land. Spoiler alert: you can get generic code if you pay the price of a Julia runtime, and that&#39;s not something Rustaceans want. If you want generics at compile time, you have to &#34;prove&#34; to the compiler that your types are constrained to some extent, and you relay that information by tacking on affine types to your code.</p> <p>That&#39;s enough of an intro, here&#39;s the table of contents.</p>  <hr/> <h3 id="handy_learning_materials"><a href="#handy_learning_materials">Handy learning materials üçéüêõ </a></h3> <p>If for some reason you&#39;ve already decided that learning Rust is a worthy endeavour, here&#39;s my list of resources to learn. I think they are a good resource to follow in approximate order, but use whatever works, and if it doesn&#39;t, skip it.</p> <ul> <li><p><a href="https://www.rust-lang.org/">The Rust book</a>: Click the link to get started with installation and IDE setup. It pays to read it at least once cover to cover and not fret about coming back to the thorny bits.</p> </li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens">VSCode Error Lens</a> and <a href="https://github.com/rust-analyzer/rust-analyzer">Rustanalyzer</a>: The quicker the feedback loop you get from the compiler, the sooner you can spot mistakes and keep going. These aren&#39;t mandatory but it&#39;s the easiest way to make the feedback loop faster.</p> </li><li><p><a href="https://tourofrust.com/TOC_en.html">Tour of Rust</a>: Also has good examples.</p> </li><li><p><a href="https://cheats.rs/">cheat.rs</a>: A cheat sheet for all the new syntax, priceless.</p> </li><li><p><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by example</a>: Always good for a quick MWE.</p> </li><li><p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust docs</a>: Their version of the Julia manual. Make sure to click the <code>[+]</code> to see how the code drops down. I still spend time looking at the iterators page.</p> </li><li><p>Courses and exercises:</p> <ul> <li><p><a href="https://exercism.io/my/tracks">Exercism</a>: If you want to get into some guided learning, Exercisms is great, but focuses too much on strings at the beginning for my liking. Make sure to look at the community solutions when you&#39;re done.</p> </li><li><p><a href="https://fasterthanli.me/series/advent-of-code-2020/part-1">Advent of Code 2020 by Amos</a>: This was my first &#34;get your hands dirty&#34; with Rust experience. Other articles by Amos are great and friendly too, but this series was useful for figuring out a Rustian workflow and design thinking.</p> </li><li><p><a href="https://reberhardt.com/blog/2020/10/05/designing-a-new-class-at-stanford-safety-in-systems-programming.html#lectures">Ryan Eberhardt Stanford course</a>: University course that gets you up and running with systems programming constraints and problem solving. I&#39;m not its target audience but it was great for understanding Rust&#39;s domain.</p> </li><li><p><a href="https://github.com/jzarnett/ece459">Jeff Zarnett programming for performance course repo</a>, with a <a href="https://www.youtube.com/watch?v=BE64OK7l20k&amp;list=PLFCH6yhq9yAHnjKmB9RLA2Qdk3XhphqrN">full youtube playlist</a>: Another good course for stepping in directly into high performance computing - not done with it yet, but the professor is friendly and enthusiastic.</p> </li><li><p><a href="https://github.com/rust-lang/rustlings">Rustlings</a>: I found some exercises too hard the first time I picked up the Rust book. Your Mileage May Vary but I did them solo and suffered. I would recommend pairing up with a buddy before attempting all of it.</p> </li></ul> </li><li><p><a href="https://rust-unofficial.github.io/too-many-lists/">Too many linked lists</a>: Another great walkthrough once you feel more comfortable reading and writing Rust.</p> </li><li><p>Jon Gjengset&#39;s streams: Jon Gjengset is a well-known Rust community member and has amazing quality streams - if you want to see a proficient Rustacean code, this is a good place to start.</p> <ul> <li><p><a href="https://www.youtube.com/watch?v=h4RkCyJyXmM&amp;t=2455s">sorting algos stream</a>: More friendly to beginners if you know your sorts.</p> </li><li><p><a href="https://www.youtube.com/watch?v=rMGWeSjctlY">multicore and atomics</a>: Gets into the weeds about all the pain that Rust can save you when you&#39;re implementing low-level tricky concurrency.</p> </li></ul> </li></ul> <hr/> <p>Alright, so you&#39;re set up to go on a learning journey. What&#39;s Rust look like anyway when compared to Julia?</p> <h3 id="what_does_generic_rustian_code_look_like"><a href="#what_does_generic_rustian_code_look_like">What does generic Rustian code look like? üîç </a></h3> <p>We love composability and multiple dispatch, so let&#39;s look at a short example of how to get the good ol&#39; Julia bang-for-buck, with a 1D point:</p> <pre><code><span>import</span> Base: +
<span>struct</span> Point{T&lt;:<span>Real</span>}
    val::T
<span>end</span>

+(x::Point{T}, y::Point{T}) <span>where</span> T&lt;:<span>Real</span> = Point{T}(x.val + y.val)
a = Point{<span>Int32</span>}(<span>1</span>)
b = Point{<span>Int32</span>}(<span>2</span>)
a + b 
c = Point{<span>Float32</span>}(<span>1.0</span>)
d = Point{<span>Float32</span>}(<span>2.0</span>)
c + d </code></pre> <p>So, in Julia land, how do I get generic code? </p> <p>I make sure to not use any explicit types and let the dispatch system do the rest. You use functions like <code>zero(...)</code>, <code>eltype(...)</code>. With the dispatches, I add them to the appropriate subtype with <code>where T&lt;:Foo</code>. If I define the appropriate methods, the others get composed atop of them , so I don&#39;t need to define <code>+=</code> once I&#39;ve defined <code>+</code>. Duck type all the way - when something errors at runtime because I forgot a case (like the fact there&#39;s no type promotion rules above) I just write a function per call I missed and keep hacking on.</p> <p>Setup a simple type hierarchy, define some functions on your types without using them explicitly, profit from not rewriting all the code, plug and chug as you run into errors or perf hits, look at docstrings in the REPL to help you out. Happy life.</p> <p>Let&#39;s look at the rust example:</p> <pre><code><span>use</span> std::ops::Add;

<span>#[derive(Clone, Copy, Debug, PartialEq)]</span>
<span>struct</span> <span>Point</span>&lt;T&gt; {
    val: T
}

<span>impl</span>&lt;T: Add&lt;Output = T&gt;&gt; Add <span>for</span> <span>Point</span>&lt;T&gt; {
    <span>type</span> <span>Output</span> = <span>Self</span>;
    
    <span>fn</span> <span>add</span>(<span>self</span>, b: <span>Self</span>) <span>-&gt;</span> <span>Self</span>::Output {
        <span>Self</span> { val: <span>self</span>.val + b.val }
    }
}

<span>fn</span> <span>main</span>() {
    <span>let</span> <span>a</span> = Point::&lt;<span>i32</span>&gt;{val: <span>1</span>};
    <span>let</span> <span>b</span> = Point::&lt;<span>i32</span>&gt;{val: <span>2</span>};
    
    <span>let</span> <span>c</span> = Point::&lt;<span>f32</span>&gt;{val: <span>1.0</span>};

    <span>println!</span>(<span>&#34;{:?}&#34;</span>, a + b);
    <span>println!</span>(<span>&#34;{:?}&#34;</span>, c == c);
}</code></pre> <p>In Rust Land, how do I get a similar generic code?</p> <p>I worked on like half of this code and then had to <a href="https://doc.rust-lang.org/std/ops/trait.Add.html">look it up</a>. You can run it in the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e3dd98c60fa0cdebb5f1a582599d3b0d">Rust Playground here</a>. Avid readers will notice the following: </p> <ol> <li><p>Damn, that&#39;s a lot of boilerplate. üò£ </p> </li><li><p>To get generics, you need a <code>struct</code> for your type, an <code>impl&lt;T&gt; $TRAIT for Point&lt;T&gt;</code> block where the <code>add</code> function is defined, and type annotations like <code>Self::Output</code>, <code>Add&lt;Output = T&gt;</code>.</p> </li><li><p>There&#39;s a sort of &#34;name spacing&#34; with the turbo fish operator: <code>::&lt;this one!&gt;</code>. We don&#39;t get functions that can share names but differ in behaviour. Bummer. (We get this in Julia with some nicer outer constructors, but I think it takes from the thrust of the argument.)</p> </li><li><p>The <code>println!</code> function is different - it&#39;s a macro, and it runs at parse time, also like Julia&#39;s macros. The chars inside the <code>{:?}</code> signal that we want debug printing, that we got above with the <code>#[derive(Debug)]</code>. Rust doesn&#39;t know how to print new structs if you don&#39;t define it, <a href="https://discourse.julialang.org/t/is-julias-way-of-oop-superior-to-c-python-why-julia-doesnt-use-class-based-oop/52058/84?u=miguelraz">which, as Framespoints out, is one of the problems solved by multiple dispatch </a>.</p> </li><li><p>Oh, those <code>#[things(above_the_struct)]</code> are also macros. I still don&#39;t know how they&#39;re different, but they seem to affect how the compiler interacts with the crate too. Since some traits (like the ones for copying or printing) are so boilerplate heavy and predictable, you can get some behaviour for &#34;free&#34; if you add the right <code>#[derive(...)]</code> stuff in the declaration. That&#39;s how the <code>c == c</code> works actually, it&#39;s due to the <code>PartialEq</code>.</p> </li></ol> <p>The main workflow feels like this: </p> <p>Slap a <code>&lt;T&gt;</code> in front of your struct and the fields you want it to be generic over. Look up the functions needed for each trait in the documentation. Setup a brief test case. Doesn&#39;t compile? See what <code>rustc</code> says and try and tack it on some traits; maybe you missed an affine type with <code>impl&lt;T: Foo&gt;</code> or the <code>Self::Output</code> - the compiler guides you through patching up your code. If you&#39;re asking for some generic behaviour, the compiler will complain and you&#39;ll have to add another trait implementation so that <em>it is damn sure</em> you&#39;re allowed to continue.</p> <p>I also chose a particularly easy example: there&#39;s no associated data (like a string) in my <code>Point&lt;T&gt;</code>, so I don&#39;t need to prove to the compiler that my data doesn&#39;t outlive its uses - those are <code>lifetimes</code>, and they can get hairy, fast, but you&#39;ll run into them eventually. I also don&#39;t know how easily you could handle multiple generic types and the compile time penalties associated with them.</p> <p>There&#39;s more syntax up front compared to Julia, and not just because we&#39;re writing library code here. Pythonistas can pick up Julia within a few hours and be productive. Rust has a lot more surface area to cover in learning the language: references, traits, impls, enums, lifetimes, pattern matching with <code>match</code>, macros, cargo flags for configuration, ownership and borrowing, Send and Sync...</p> <p>Whodathunkit, Garbage Collectors let you worry about other things for a small runtime price. They might not be right for every use case but they&#39;re a solid investment.</p> <hr/> <h3 id="rustian_projects_of_interest"><a href="#rustian_projects_of_interest">Rustian projects of interest ü•á </a></h3> <p>There&#39;s a steep wall to climb when starting out with Rust - however, they&#39;ve nailed the user experience for learning tough stuff. I think it was Esteban Kuber who said something along the lines of &#34;We weren&#39;t missing a sufficiently smart compiler, but a more empathetic one&#34;.</p> <p>Alright, so what&#39;s the view from the top look like? Like Julia, Rust is an incumbent in a crowded space, so how has it punched above it&#39;s weight against the established candidates? </p> <p>Here&#39;s a list of all the projects that I&#39;ve found particularly of note to Julians.</p> <ul> <li><p><a href="https://github.com/rayon-rs/rayon">rayon</a> is the original reason I got interested in Rust. Check their <a href="https://github.com/rayon-rs/rayon#parallel-iterators-and-more">hello world</a> - the promise is that if you are using iterators, you can swap (mostly) <code>iter()</code> for <code>par_iter()</code> and at compile time you can know if your code will run in parallel. That&#39;s just about the friendliest user interface to parallelism besides <code>Threads.@threads</code>, and with some additional guarantees - a small update loop is easy to keep the invariants in your head, but it really pays when the Rust compiler catches a concurrency bug that spanned multiple files, modules and data structures. Cool tech note: Rayon uses the <a href="https://youtu.be/gof_OEv71Aw?t=1184">same idea for work stealing thread scheduler</a> that Julia&#39;s parallel task run time system uses (inspired by Cilk, get it? &#39;Cuz Rayon is a fake silk? Ha...). </p> </li><li><p><a href="https://github.com/tokio-rs/tokio">tokio</a> deserves a mention as well for its capabilities for asynchronous programming, but I am not familiar enough with it to comment on it. Rust people get excited about it though! </p> </li></ul> <p><em>NB</em>: It is non-trivial to compose <code>rayon</code> and <code>tokio</code> codes.</p> <ul> <li><p><a href="https://egraphs-good.github.io/">egg</a> and related projects like <a href="https://herbie.uwplse.org/">herbie</a>: A wicked fast egraph matching engine - a great competitor and inspiration for the Symbolics.jl ecosystem.</p> </li><li><p><a href="https://github.com/mmtk/mmtk-core">MMtk and GCs</a>: Garbage Collectors are a family of algorithms that share behaviour, and different strategies can be built atop of tweakable parameters. The promise for building a configurable, performant and battle-tested back-end for Garbage Collectors is alive with this project by Steve Blackburn and gang. If you haven&#39;t heard of <a href="https://www.youtube.com/watch?v=73djjTs4sew&amp;t=914s">Immix</a> or <a href="https://github.com/RedlineResearch/floorplan">Floorplan</a>, enjoy the rabbithole. If you&#39;re new to GCs, <a href="https://www.cs.cornell.edu/courses/cs6120/2020fa/lesson/10/">this is a good starting point</a> for seasoned Julians.</p> </li><li><p><a href="https://zaiste.net/posts/shell-commands-rust/">Rust CLI</a>: Rust people feel comfortable working in the terminal, and they&#39;ve taken that user experience Very Seriously and have a top notch performance and user experience for their command line CLIs. Here&#39;s a few of my favorites - you only need to <code>cargo install foo</code> and they should be properly installed on your system.</p> <ul> <li><p><a href="https://github.com/BurntSushi/ripgrep">rg</a>: SIMDified grep replacemnt tool (for some use cases). Includes colors!</p> </li><li><p><a href="https://github.com/sharkdp/bat">bat</a>: cat clone with tons more built-in syntax highlighting.</p> </li><li><p><a href="https://github.com/bootandy/dust">dust</a>: visualize disk space used by folders.</p> </li><li><p><a href="https://lib.rs/crates/typeracer">typeracer</a>: fun typing game.</p> </li><li><p><a href="https://lib.rs/crates/zoxide">taskwarrior-tui</a>: Todo tracker.</p> </li><li><p><a href="https://lib.rs/crates/zoxide">zoxide</a>: directory autojumper. I don&#39;t really do <code>cd ../..</code> climbing around anymore I just do <code>z foo</code> a couple of times and that usually guesses right.</p> </li><li><p><a href="https://github.com/zellij-org/zellij">zellij</a>: Terminal multiplexer with friendly UX. Young and promising.</p> </li></ul> </li><li><p><a href="https://github.com/plasma-umass/coz">coz</a>: Invaluable tool for <em>causal profiling</em>. <a href="https://youtu.be/r-TLSBdHe1A?t=2182">Emery Berger&#39;s</a> presentation alone is worth knowing about this project. I reeeeeally want to nerdsnipe someone to port this to Julia.</p> </li><li><p><a href="https://sled.rs/perf#e-prime-and-precise-language">sled&#39;s</a> approach to benchmarking and databases is top-notch. Also worthy of note is the same author&#39;s <code>rio</code> crate, which is a Rust interface for the <code>io_uring</code> linux kernel module, which can significantly speed up asynchronous programming. There&#39;s some WIP PRs for landing this for <code>libuv</code>, Julia&#39;s thread runtime backend, and that effort <a href="https://github.com/libuv/libuv/pull/2322">is close to wrapping up</a>.</p> </li><li><p><a href="https://www.lpalmieri.com/posts/2019-02-23-scientific-computing-a-rust-adventure-part-0-vectors/">Scientific Computing in Rust</a>: A <em>must</em> to dive straight into linear algebra.</p> </li><li><p><a href="https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/">Taking ML to production with Rust</a>: A sister article to the one above.</p> </li><li><p><a href="https://github.com/ejmahler/RustFFT">Rust FFT</a>: They beat FFTW in some cases with this one, so it seems worthwhile to take a look üëÄ .</p> </li><li><p><a href="https://github.com/rusty-fast-solvers/rusty-green-kernel">Green function evaluation kernels</a>: Newer package, but I&#39;d like to see how special functions pan out in Rust land.</p> </li><li><p><a href="https://docs.rs/polars/0.12.1/polars/">Polars</a>: A highly tuned dataframes implementation for some use cases. They&#39;ve topped the charts in some of the <a href="https://h2oai.github.io/db-benchmark/">H20ai benchmarks</a>, so they&#39;ve definitely got technical chops. (They beat DataFrames.jl because of a sparsification trick which is a bit non-trivial to implement, but there&#39;s not necessarily an impediment to matching their speed.)</p> </li><li><p><a href="https://github.com/tokio-rs/loom">Loom</a>: a model checker for atomic primitives, sister project to <code>tokio</code>. I think Julia is a more natural fit for this approach given the ease of operator overloading and it will be great to try something similar once Jameson&#39;s atomics PR lands.</p> </li><li><p><a href="https://www.stateright.rs/">Stateright</a>: distributed systems model checker with a graphic user interface.</p> </li><li><p><a href="https://github.com/xldenis/creusot">Creusot</a>: Add some macros to your Rust code, and have it formally verified by Why3.</p> </li><li><p><a href="https://altsysrq.github.io/proptest-book/proptest/getting-started.html">proptest</a>: Configure strategies for exploring type instantiations to fuzz your tests, shrink the cases, and automatically track regressions. Impressive stuff!</p> </li><li><p><a href="https://gleam.run/">Gleam</a> and <a href="https://github.com/lumen/lumen">Lumen</a>: Gleam is a Rust backend for an Erlang based language and Lumen is a Rewritten-in-Rust implementation of the ErlangVM, BEAM. Erlang is a concurrency monster, and their actor based model is scalable as hell for certain workloads. I&#39;m glad to see Julia start to step into that domain with <a href="https://github.com/JuliaActors/Actors.jl">Actors.jl</a>. This seems to be the <em>right way</em> to abstract for fault tolerance workloads.</p> </li></ul> <p>There&#39;s oodles more. Check out <a href="https://www.crates.io">crates.io</a> or <a href="https://lib.rs">lib.rs</a> if you want to explore more (this is their community based JuliaHub equivalent).</p> <p>I&#39;ll make a special note of <a href="https://github.com/google/evcxr">evcxr</a>, a Rust REPL. For now, I don&#39;t think it&#39;s profitable to use Rust with a REPL-like workflow. I&#39;m too used to that in Julia, and that works well there, but I think there&#39;s a risk of digging yourself into a &#34;Everything must be a REPL&#34; mentality and cutting yourself off from learning opportunities. In Rust land, I don&#39;t mind doing as the Rustaceans do and learning to do things around a command line, navigating compiler errors and configuring flags and features for certain behaviours or deployment options. Since that&#39;s the package that I wanted to learn when I bought into Rust, I don&#39;t mind adapting into that mindset. I still wish them all the best and hope they can make the best possible Rust REPL - I&#39;d love to be wrong on this down the road.</p> <hr/> <h3 id="optimization_walkthroughs"><a href="#optimization_walkthroughs">Optimization walkthroughs üèÉ </a></h3> <p>If you want to dive deep into nitty gritty performance fundamentals, these are the best guides I found for explaining the tradeoffs, gotchas, mental model, and engineering for those tasty, tasty flops.</p> <ol> <li><p><a href="http://www.frankmcsherry.org/assets/COST.pdf">COST paper</a>: Maybe doesn&#39;t fit here but this is one of my favorite papers and everyone should read it.</p> </li><li><p><a href="https://parallel-rust-cpp.github.io/">Comparing parallel Rust and C++</a></p> </li><li><p><a href="https://deterministic.space/high-performance-rust.html">Cheap tricks</a></p> </li><li><p><a href="https://nnethercote.github.io/perf-book/">The Rust performance Book</a></p> </li><li><p><a href="https://likebike.com/posts/How_To_Write_Fast_Rust_Code.html">How to write Fast Rust code</a></p> </li><li><p><a href="http://troubles.md/posts/rustfest-2018-workshop/">Fastware Workshope</a></p> </li></ol> <hr/> <h3 id="papercuts_and_sharp_edges"><a href="#papercuts_and_sharp_edges">Papercuts and sharp edges ‚úÇ </a></h3> <p>So Rust is &#34;worth learning&#34;, but these are roadblocks that I faced and would warn others about to save them some grief.</p> <ul> <li><p>You can learn another hobby waiting for Rust projects to compile. The price for compile-time guarantees/being the designated driver in the codebase is offloading more work to the compiler. They&#39;re working on leveraging concurrency for speeding up the pipeline, and it&#39;s gotten better. Let&#39;s just say they also suffer from TTFP üòâ .</p> </li><li><p>Learn to run your code with <code>cargo run --release</code> <a href="https://deterministic.space/high-performance-rust.html">and other tricks</a>. This is the equivalent to running your Julia code with globals (or <code>-O0</code> flags), and it&#39;s an easy gotcha. This will not change in Rust.</p> </li><li><p>Rust people keep saying they have no Garbage Collector, *when they have a Region Based Garbage Collector**. It&#39;s all fun and games until they have to implement those linked lists...</p> </li></ul> <p>(<em>NB</em>: After posting in <a href="https://news.ycombinator.com/item?id=27407268">HackerNews</a>, Steve Klabnik has pointed out that the term <code>region based</code> is technical jargon in Programming Language Theory Literature as seen in section <a href="https://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf">2 of this paper</a> on Cyclone&#39;s memory model.) (<em>NB2</em>: <code>kibwen</code> on HN pointed out that the term <code>garbage collection</code> implies dynamic memory management, whereas Rust&#39;s ownership system allows for lifetimes to be determined statically. In that sense, I&#39;m wrong except for when users opt-in to using <code>Rc</code>s and the like. Glad to be corrected!)</p> <ul> <li><p>Don&#39;t add crates manually! Install <code>cargo-add</code>, use it to manage crate dependencies. That and some other tricks are great from doing the <code>AdventOfCode2020</code> from the article above.</p> </li><li><p>For numerics, install <code>ndarray</code> and <code>num_traits</code>. Linear Algebra and numerics where not a primary focus of Rust when starting out as they where with Julia.</p> </li><li><p>Benchmarking with <code>@btime</code> is painless, <code>criterion</code> is your best Rustian bet.</p> </li><li><p>Setup your <code>rust-analyzer</code> and <code>error lens</code> plugins on VSCode or IDE asap, you&#39;ll thank me later. Rust-land expects you to be in constant dialogue with the compiler, and making that iteration cycle as ergonomic as possible will yield dividends in the long run. What we don&#39;t get from accessing help docs in the REPL, Rust people keep a terminal tab handy where they run <code>cargo watch -c</code> and get continuous feedback from the compiler.</p> </li><li><p>You CAN&#39;T index into a String in Rust with ints! <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars">Instead</a> use slices like <code>&amp;str[1..] == str[2:end]</code> or iterators like <code>str.chars()</code>, if I may riff on Rust and Julia syntax in the equality just there.</p> </li><li><p>Reading from <code>stdin</code> is a pain as a newcomer. I wanted to try out some competitive coding exercises and reading from <code>stdin</code> was waaaay too rough for me at first. Eventually I cobbled this template up <a href="https://gist.github.com/miguelraz/d0341e9fee8c728baa99fd6fe86c1be1">link here</a> so that you don&#39;t struggle if you want to try a couple of CodeForces problems.</p> </li><li><p>Not having a generic <code>rand</code> is just painful. So painful. This is my easiest workaround so far for generating a vector of <code>n</code> random entries:</p> </li></ul> <pre><code><span>let</span> <span>n</span> = <span>100</span>;
<span>use</span> rand::distributions::Standard;
<span>use</span> rand::prelude::*;
<span>thread_rng</span>().<span>sample_iter</span>(&amp;Standard).<span>take</span>(n).<span>collect</span>()</code></pre> <p>(Oh, and <code>rand</code> isn&#39;t part of the stdlib so that&#39;s another papercut).</p> <blockquote> <ul> <li><p>There is no <code>@code_native</code> and friends in Rust - your best bet is to use the Rust Playground and click on the <code>...</code> to have it emit the total assembly. This only works for the top 100 most popular crates though. You can <code>cargo run --release -- --emit=llvm-ir/asm</code> and then fish the results out of <code>target/</code>, but that&#39;s unwieldy - why does no one have a CLI for this yet?</p> </li></ul> </blockquote> <p><em>NB</em>: <code>u/Schnatsel</code> has kindly pointed me towards <code>cargo-asm</code>. The interface is not as nice as <code>@code_XXX</code>, but I think I&#39;m satisfied with this. Thanks a ton!</p> <ul> <li><p>Another multiple dispatch gripe: having to implement <code>Display</code> traits for new structs feels like pulling teeth, and this initial type signature seems inscrutable as a beginner:</p> </li></ul> <pre><code><span>use</span> std::fmt;

<span>struct</span> <span>Point</span> {
    x: <span>i32</span>,
    y: <span>i32</span>,
}

<span>impl</span> <span>fmt</span>::Display <span>for</span> <span>Point</span> {
    <span>fn</span> <span>fmt</span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> fmt::<span>Result</span> {
        <span>write!</span>(f, <span>&#34;({}, {})&#34;</span>, <span>self</span>.x, <span>self</span>.y)
    }
}</code></pre> <ul> <li><p>Rust does NOT look like math and that hurts my little physicist heart. <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/niklaus_simulates_hydrodynamics.html">Look at this story of a hydrodynamics simulator code</a> vs anything in the DiffEq verse that is user facing or from ApproxFun.jl, or Turing.jl, or ... anything else. Even the linear algebra from <code>ndarray</code> is painful to understand unless you are comfortable in Rust, and all the <code>i as usize</code> conversions are a huge eye sore.</p> </li><li><p>Many of your functions will be faster if you annotate them with <code>#[inline]</code>.</p> </li></ul> <hr/> <h3 id="things_i_wish_id_known_earlier"><a href="#things_i_wish_id_known_earlier">Things I wish I&#39;d known earlier üëì </a></h3> <p>These could have helped me settle down into a more productive workflow sooner. Get a buddy that knows Rust to see you code to figure most of these out.</p> <ol> <li><p>If you can, avoid the examples with Strings and &amp;str. Yes, they&#39;re a great motivation for systems people for all the gnarly use-after free and double-free and memory-leak examples - stick with numerical algorithms first, to get the gist of ownership, try and do some exercisms with iterators and Strings will be much easier to get after that. I don&#39;t think it&#39;s worth worrying about at first unless your target is systems.</p> </li><li><p>The preferred way of &#34;whipping up an example in the REPL&#34;/getting a MWE is to <code>cargo new foo</code>, mucking about and then <code>cargo run --release</code> or using the Rust Playground.</p> </li><li><p>If you&#39;re using an expansive test suite, <code>cargo test --test-threads 8</code> and <code>cargo test --quiet</code> are helpful flags.</p> </li><li><p>For loops are not idiomatic in Rust - writing Fortran-ey code instead of iterators will lead to pain and slower loops. Spending time reading the examples in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">the iterator docs</a> and the community solutions in the exercisms will help a lot.</p> </li><li><p>Just clone everything when you are starting out to get around most borrow checker shenanigans - worry about allocations later, Rust is usually fast enough.</p> </li><li><p>In the following function, the types of <code>v</code> and <code>w</code> are a <code>slice</code> of <code>Int32</code>s, which are different from <code>Vec&lt;32&gt;</code>. Read the Scientific Computing link above to see a nice table of the differences. An array like <code>[f32; 4]</code> includes the size as part of the type, a slice like <code>[f32]</code> does not. Diving into linear algebra means being familiar with many <code>to_array()</code>, <code>to_slice()</code>, <code>from_array()</code>, and <code>from_slice()</code> cases.</p> </li></ol> <pre><code><span>fn</span> <span>dot</span>(v: &amp;[<span>i32</span>], w: &amp;[<span>i32</span>]) <span>-&gt;</span> <span>i32</span> {...}</code></pre>
<ol start="6">
<li><p>Including docs and tests in the same file as your implementation is idiomatic - even the IDEs support clicking on the <code>#[test]</code> line and having that run. Julia has a nice workflow for test driven development out-of-the-box - Rust gives you some of those guarantees by... conversing with the compiler.</p>

</li><li><p>Rust has something similar to the concept of <code>type piracy</code>: they&#39;re called the <code>orphan rules</code>, as explained by <a href="https://blog.mgattozzi.dev/orphan-rules/">this Michael Gattozzi</a> post:</p>

</li></ol>
<blockquote>
<p>Recently at work I managed to hit the Orphan Rules implementing some things for an internal crate. Orphan Rules you say? These are ancient rules passed down from the before times (pre 1.0) that have to do with trait coherence. Mainly, if you and I both implement a trait from another crate on the same type in another crate and we compile the code, which implementation do we use?</p>
</blockquote>
<ol start="8">
<li><p>Rust is not as centralized with online communication as Julia is around Slack/Zulip/Discourse. Their version of <code>#appreciation</code> channels is to go on twitter and tell <code>@ekuber</code> what a joy the compilers errors are. There&#39;s tons of people on their Discord, and everywhere.</p>

</li></ol>
<hr/>
<h3 id="appreciation_of_rust_things"><a href="#appreciation_of_rust_things">Appreciation of Rust things ü¶Ä  </a></h3>
<p>These are things the Rust people have nailed down.</p>
<ol>
<li><p>Ferris the crab is too cute.</p>

</li><li><p>Rust people take uwu-ification very, VERY seriously. <a href="https://github.com/Daniel-Liu-c0deb0t/uwu">The uwu</a> project uses SIMD to uwu-ify strings for <a href="https://twitter.com/twent_weznowor">great artistic value</a>. Julia and Rust both draw me because they make me feel more powerful when I code with them than I think I should be.</p>

</li><li><p>Governance: The Rust foundation and strong community conduct codes. Given the blow ups that have happened with open source communities recently from short-sighted governance or hate reactionaries tanking projects, this is a welcome sight that will probably pay off for decades to come.</p>

</li><li><p>Compiler error messages are second to none. Definitely check out <code>clippy</code> too and follow the hints. <code>cargo fmt</code> will also format all your crate so that Rust code is almost always a unified reading experience.</p>

</li><li><p><a href="https://rustbeginners.github.io/awesome-rust-mentors/">Awesome mentors</a>. This is a project maintained <code>Jane Lusby</code> and other volunteers. I&#39;ve gotten world-class mentorship from kind, patient and friendly Rust folks. Shoutout to <code>Jubilee</code> for her great wisdom and patience and the rest of the <code>stdsimd</code> gang.</p>

</li><li><p>They also poke the LLVM crowd to improve the compilation times, which is great.</p>

</li><li><p>They&#39;re doc deployment system is unified, polished, and friendly. Inline docs and tests are also great.</p>

</li><li><p><code>cargo</code> is a joy compared to <code>Make</code> hell. <code>Pkg</code> is somewhat inspired by it, so that rocks.</p>

</li></ol>
<hr/>
<h3 id="what_rust_can_bring_to_julia"><a href="#what_rust_can_bring_to_julia">What Rust can bring to Julia ‚öí </a></h3>
<ol>
<li><p>A model of governance. The Rust community is at least 10x the size of Julia, and it&#39;s unclear that adding more hats to the same <code>TruckFactorCritical</code> people would help. That said, it&#39;d be better to have those conversations sooner rather than later, and building bridges with Rust people seems wise in the long term. I don&#39;t think that Rust is the closest model to look up to given the other projects under the NumFocus umbrella that we can learn from, but I don&#39;t see what is lost from learning from them.</p>

</li><li><p>Less vulnerable software in the world is a good thing. Oxidization is great! Sometimes. I don&#39;t think any Julia internals will oxidize in the short term, but it would be an interesting experiment to say the least.</p>

</li><li><p><a href="https://www.youtube.com/watch?v=rAF8mLI0naQ&amp;t=947s">Error handling</a>: Multiple dispatch may prove advantageous in this domain, and it hasn&#39;t been as much of a priority as it has in Rust. Perhaps that merits some careful rethinking for future Julia versions.</p>

</li><li><p>Awesome Julia mentors, I think we need this.</p>

</li></ol>
<hr/>
<h3 id="acknowledgments"><a href="#acknowledgments">Acknowledgments üôåüèª </a></h3>
<ul>
<li><p>Thanks to <code>Jubilee</code> for feedback on this post and the following corrections: </p>
<ul>
<li><p>Rust does not necessarily have an RC GC but a <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">region based GC</a>. You can opt into the RC GC with <code>Arc</code> and <code>Rc</code> types.</p>

</li><li><p>Technically Rust doesn&#39;t have linear types but <a href="https://gankra.github.io/blah/linear-rust/">affine types</a>.</p>

</li><li><p>Tokio&#39;s story is not as simple as I had made it out to be so I cut some comments</p>

</li></ul>

</li><li><p><code>Alex Weech</code> helpfully suggested refactoring the original Julia Point code to be more similar to the Rust example.</p>

</li><li><p><code>Daniel Men√©ndez</code> helpfully suggested adding <code>crates.io</code> or <code>lib.rs</code></p>

</li><li><p>Thanks to <code>oliver</code> I also read about this post by Chris Lattner, author of LLVM, on the dangers of <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">undefined behaviour</a>, to really scare you out of thinking you know what C is doing under the hood.</p>

</li><li><p><code>Zamalek1</code> on HN also provided useful feedback on precise academese: Rust is definitely a memory managed language, but that&#39;s been hoisted to compile time.</p>

</li><li><p>Thanks to <code>u/Schnatsel</code> for pointing me to a broken url here and to <code>cargo-asm</code>.</p>

</li><li><p>Thanks to <code>ministatsdev</code> for the string iterator nit.</p>

</li></ul>

</div></div>
  </body>
</html>
