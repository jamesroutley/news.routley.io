<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/python-abc/">Original</a>
    <h1>Crimes with Python&#39;s pattern matching</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>One of my favorite little bits of python is <code>__subclasshook__</code>. Abstract Base Classes with <code>__subclasshook__</code> can define what counts as a subclass of the ABC, even if the target doesn’t know about the ABC. For example:</p>
<div><pre><code data-lang="python"><span></span><span>class</span> <span>PalindromicName</span><span>(ABC):</span>
   
  <span>@classmethod</span>
  <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>C):</span>
    <span>name</span> <span>=</span> <span>C</span><span>.</span><span>__name__</span><span>.</span><span>lower()</span>
    <span>return</span> <span>name[::</span><span>-</span><span>1</span><span>]</span> <span>==</span> <span>name</span>

<span>class</span> <span>Abba</span><span>:</span>
  <span>...</span>

<span>class</span> <span>Baba</span><span>:</span>
  <span>...</span>

<span>&gt;&gt;&gt;</span> <span>isinstance(Abba(),</span> <span>PalindromicName)</span>
<span>True</span>
<span>&gt;&gt;&gt;</span> <span>isinstance(Baba(),</span> <span>PalindromicName)</span>
<span>False</span>
</code></pre></div>

<p>You can do some weird stuff with this. Back in 2019 I used it to create <a href="https://www.hillelwayne.com/negatypes/">non-monotonic types</a>, where something counts as a <code>NotIterable</code> if it <em>doesn’t</em> have the <code>__iter__</code> method. There wasn’t anything too diabolical you could do with this: nothing in Python really interacted with ABCs, limiting the damage you could do with production code.</p>

<p>Then Python 3.10 <a href="https://www.python.org/dev/peps/pep-0634/">added pattern matching</a>.</p>

<p><img src="https://c.tenor.com/_pj7e4VKqDoAAAAC/elmo-burning.gif" alt=""/></p>

<h3 id="a-quick-overview-of-pattern-matching">A quick overview of pattern matching</h3>

<p>From the <a href="https://www.python.org/dev/peps/pep-0636/">pattern matching tutorial</a>:</p>
<div><pre><code data-lang="py"><span></span><span>match</span> <span>command</span><span>.</span><span>split():</span>
    <span>case</span> <span>[</span><span>&#34;quit&#34;</span><span>]:</span>
        <span>print(</span><span>&#34;Goodbye!&#34;</span><span>)</span>
        <span>quit_game()</span>
    <span>case</span> <span>[</span><span>&#34;look&#34;</span><span>]:</span>
        <span>current_room</span><span>.</span><span>describe()</span>
    <span>case</span> <span>[</span><span>&#34;get&#34;</span><span>,</span> <span>obj]:</span>
        <span>character</span><span>.</span><span>get(obj,</span> <span>current_room)</span>
</code></pre></div>

<p>You can match on arrays, dictionaries, and custom objects. To support matching objects, Python uses <code>isinstance(obj, class)</code>, which checks</p>

<ol>
<li>If <code>obj</code> is of type <code>class</code></li>
<li>If <code>obj</code> is a transitive subtype of <code>class</code></li>
<li>If <code>class</code> is an ABC and defines a <code>__subclasshook__</code> that matches the type of <code>obj</code>.</li>
</ol>

<p>That made me wonder if ABCs could “hijack” a pattern match. Something like this:</p>
<div><pre><code data-lang="py"><span></span><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span>

<span>class</span> <span>NotIterable</span><span>(ABC):</span>

    <span>@classmethod</span>
    <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>C):</span>
        <span>return</span> <span>not</span> <span>hasattr(C,</span> <span>&#34;__iter__&#34;</span><span>)</span>

<span>def</span> <span>f</span><span>(x):</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>NotIterable():</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is not iterable&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is iterable&#34;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>f(</span><span>10</span><span>)</span>
    <span>f(</span><span>&#34;string&#34;</span><span>)</span>
    <span>f([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>])</span>
</code></pre></div>

<p>But surely Python clamps down on this chicanery, right?</p>

<pre><code>$ py10 abc.py
10 is not iterable
string is iterable
[1, 2, 3] is iterable
</code></pre>

<p>Oh.</p>

<p>Oh my.</p>

<h3 id="making-it-worse">Making it worse</h3>

<p>Pattern matching can also <a href="https://www.python.org/dev/peps/pep-0636/#adding-a-ui-matching-objects">destructure object fields</a>:</p>
<div><pre><code data-lang="py"><span></span><span>match</span> <span>event</span><span>.</span><span>get():</span>
    <span>case</span> <span>Click(position</span><span>=</span><span>(x,</span> <span>y)):</span>
        <span>handle_click_at(x,</span> <span>y)</span>
</code></pre></div>

<p>We can only get the field <em>after</em> we’ve decided the object. We can’t match “any object that has the <code>foo</code> field”… unless we use ABCs.</p>
<div><pre><code data-lang="python"><span></span><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span>
<span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>from</span> <span>math</span> <span>import</span> <span>sqrt</span>

<span>class</span> <span>DistanceMetric</span><span>(ABC):</span>

    <span>@classmethod</span>
    <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>C):</span>
        <span>return</span> <span>hasattr(C,</span> <span>&#34;distance&#34;</span><span>)</span>

<span>def</span> <span>f</span><span>(x):</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>DistanceMetric(distance</span><span>=</span><span>d):</span>
            <span>print(d)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is not a point&#34;</span><span>)</span>

<span>@dataclass</span>
<span>class</span> <span>Point2D</span><span>:</span>
    <span>x:</span> <span>float</span>
    <span>y:</span> <span>float</span>

    <span>@property</span>
    <span>def</span> <span>distance</span><span>(self):</span>
        <span>return</span> <span>sqrt(self</span><span>.</span><span>x</span><span>**</span><span>2</span> <span>+</span> <span>self</span><span>.</span><span>y</span><span>**</span><span>2</span><span>)</span>

<span>@dataclass</span>
<span>class</span> <span>Point3D</span><span>:</span>
    <span>x:</span> <span>float</span>
    <span>y:</span> <span>float</span>
    <span>z:</span> <span>float</span>

    <span>@property</span>
    <span>def</span> <span>distance</span><span>(self):</span>
        <span>return</span> <span>sqrt(self</span><span>.</span><span>x</span><span>**</span><span>2</span> <span>+</span> <span>self</span><span>.</span><span>y</span><span>**</span><span>2</span> <span>+</span> <span>self</span><span>.</span><span>z</span><span>**</span><span>2</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>f(Point2D(</span><span>10</span><span>,</span> <span>10</span><span>))</span>
    <span>f(Point3D(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>))</span>
    <span>f([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>])</span>
</code></pre></div>

<pre><code>14.142135623730951
10.488088481701515
[1, 2, 3] is not a point
</code></pre>

<p>It gets better! While the ABC decides the match, the object decides the destructuring, meaning we can do stuff like this:</p>
<div><pre><code data-lang="py"><span></span><span>def</span> <span>f</span><span>(x):</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>DistanceMetric(z</span><span>=</span><span>3</span><span>):</span>
            <span>print(</span><span>f&#34;A point with a z-coordinate of 3&#34;</span><span>)</span>
        <span>case</span> <span>DistanceMetric(z</span><span>=</span><span>z):</span>
            <span>print(</span><span>f&#34;A point with a z-coordinate that&#39;s not 3&#34;</span><span>)</span>
        <span>case</span> <span>DistanceMetric():</span>
            <span>print(</span><span>f&#34;A point without a z-coordinate&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is not a point&#34;</span><span>)</span>
</code></pre></div>

<h3 id="combinators">Combinators</h3>

<p>The pattern matching is flexible but also fairly limited. It can only match on an object’s type, meaning we have to make a separate ABC for each thing we want to test. Fortunately, there’s a way around this. Python is dynamically typed. 99% of the time this just means “you don’t need static types if you’re okay with things crashing at runtime”. But it <em>also</em> means that type information exists at runtime, and that <strong>types can be created at runtime</strong>.</p>

<p>Can we use this for pattern matching? Let’s try it:</p>
<div><pre><code data-lang="py"><span></span><span>def</span> <span>Not</span><span>(cls):</span>
    <span>class</span> <span>_Not</span><span>(ABC):</span>
        <span>@classmethod</span>
        <span>def</span> <span>__subclasshook__</span><span>(_,</span> <span>C):</span>
            <span>return</span> <span>not</span> <span>issubclass(C,</span> <span>cls)</span>
    <span>return</span> <span>_Not</span>

<span>def</span> <span>f</span><span>(x):</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>Not(DistanceMetric)():</span> 
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is not a point&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is a point&#34;</span><span>)</span>
</code></pre></div>

<p><code>Not</code> is a function that takes a class, defines a <em>new</em> ABC, sets the hook for that ABC to “anything that’s not the class”, and then returns that ABC.</p>

<p>We try this and…</p>

<pre><code>    case Not(DistanceMetric)():
                            ^
SyntaxError: expected &#39;:&#39;
</code></pre>

<p>It’s an error! We’ve finally hit the limits of pattern matching on ABCs. Then again, it’s “just” a syntax error. Maybe it would work if we tweak the syntax a little?</p>
<div><pre><code data-lang="diff"><span></span><span>+   n = Not(DistanceMetric)</span><span></span>
<span> </span>   match x:<span></span>
<span>-       case Not(DistanceMetric)(): </span><span></span>
<span>+       case n(): </span><span></span>
</code></pre></div>

<pre><code>PlanePoint(x=10, y=10) is a point
SpacePoint(x=5, y=6, z=7) is a point
[1, 2, 3] is not a point
</code></pre>

<p>Success! And just to test that this is composable, let’s write an <code>And</code>.</p>
<div><pre><code data-lang="py"><span></span><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span>
<span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>from</span> <span>collections.abc</span> <span>import</span> <span>Iterable</span>

<span>def</span> <span>Not</span><span>(cls):</span>
    <span>class</span> <span>_Not</span><span>(ABC):</span>
        <span>@classmethod</span>
        <span>def</span> <span>__subclasshook__</span><span>(_,</span> <span>C):</span>
            <span>return</span> <span>not</span> <span>issubclass(C,</span> <span>cls)</span>
    <span>return</span> <span>_Not</span>

<span>def</span> <span>And</span><span>(cls1,</span> <span>cls2):</span>
    <span>class</span> <span>_And</span><span>(ABC):</span>
        <span>@classmethod</span>
        <span>def</span> <span>__subclasshook__</span><span>(_,</span> <span>C):</span>
            <span>return</span> <span>issubclass(C,</span> <span>cls1)</span> <span>and</span> <span>issubclass(C,</span> <span>cls2)</span>
    <span>return</span> <span>_And</span>


<span>def</span> <span>f</span><span>(x):</span>
    <span>n</span> <span>=</span> <span>And(Iterable,</span> <span>Not(str))</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>n():</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is a non-string iterable&#34;</span><span>)</span>
        <span>case</span> <span>str():</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is a string&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is a string or not-iterable&#34;</span><span>)</span>


<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>f(</span><span>&#34;abc&#34;</span><span>)</span>
    <span>f([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>])</span>
</code></pre></div>

<p>This works as “”“expected”“”.</p>

<h3 id="caching-rules-everything-around-me">Caching Rules Everything Around Me</h3>

<p>This got me thinking: what if <code>__subclasshook__</code> wasn’t a pure function? Could I make an ABC that matched the <em>first</em> value of each type passed in, but not subsequent ones?</p>
<div><pre><code data-lang="py"><span></span><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span>

<span>class</span> <span>OneWay</span><span>(ABC):</span>
    <span>seen_classes</span> <span>=</span> <span>set()</span>

    <span>@classmethod</span>
    <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>C):</span>
        <span>print(</span><span>f&#34;trying {</span><span>C</span><span>}&#34;</span><span>)</span>
        <span>if</span> <span>C</span> <span>in</span> <span>cls</span><span>.</span><span>seen_classes:</span>
            <span>return</span> <span>False</span>
        <span>cls</span><span>.</span><span>seen_classes</span> <span>|=</span> <span>{C}</span>
        <span>return</span> <span>True</span>




<span>def</span> <span>f</span><span>(x):</span>
    <span>match</span> <span>x:</span>
        <span>case</span> <span>OneWay():</span>
            <span>print(</span><span>f&#34;{</span><span>x</span><span>} is a new class&#34;</span><span>)</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>print(</span><span>f&#34;we&#39;ve seen {</span><span>x</span><span>}&#39;s class before&#34;</span><span>)</span>


<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
    <span>f(</span><span>&#34;abc&#34;</span><span>)</span>
    <span>f([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>])</span>
    <span>f(</span><span>&#34;efg&#34;</span><span>)</span>
</code></pre></div>

<p>Sadly, this was all for naught.</p>

<pre><code>trying &lt;class &#39;str&#39;&gt;
abc is a new class
trying &lt;class &#39;list&#39;&gt;
[1, 2, 3] is a new class
efg is a new class
</code></pre>

<p>It looks like <code>__subclasshook__</code> caches the results for a given type check. CPython assumes that people don’t want to shove side effects into esoteric corners of the language. Show’s how much <em>they</em> know.</p>

<p>We can still have fun with side effects, though. This ABC lets through every-other type.</p>
<div><pre><code data-lang="python"><span></span><span>class</span> <span>FlipFlop</span><span>(ABC):</span>
    <span>flag</span> <span>=</span> <span>False</span>

    <span>@classmethod</span>
    <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>_):</span>
        <span>cls</span><span>.</span><span>flag</span> <span>=</span> <span>not</span> <span>cls</span><span>.</span><span>flag</span>
        <span>return</span> <span>cls</span><span>.</span><span>flag</span>
</code></pre></div>

<p>And this ABC asks the user what it should do for each type.</p>
<div><pre><code data-lang="python"><span></span><span>class</span> <span>Ask</span><span>(ABC):</span>
    <span>first_class</span> <span>=</span> <span>None</span>

    <span>@classmethod</span>
    <span>def</span> <span>__subclasshook__</span><span>(cls,</span> <span>C):</span>
        <span>choice</span> <span>=</span> <span>input(</span><span>f&#34;hey should I let {</span><span>C</span><span>} though [y/n]  &#34;</span><span>)</span>
        <span>if</span> <span>choice</span> <span>==</span> <span>&#39;y&#39;</span><span>:</span>
            <span>print(</span><span>&#34;okay we&#39;ll pass em through&#34;</span><span>)</span>
            <span>return</span> <span>True</span>
        <span>return</span> <span>False</span>
</code></pre></div>

<p>Try them in a pattern match. They both work!</p>

<h2 id="should-i-use-this">Should I use this?</h2>

<p>God no.</p>

<p>The pattern matching feature is, on the whole, pretty reasonably designed, and people will expect it to behave in reasonable ways. Whereas <code>__subclasshook__</code> is <em>extremely</em> dark magic. This kind of chicanery <em>might</em> have a place in the dark beating heart of a complex library, certainly not for any code your coworkers will have to deal with.</p>

<p>So yeah, you didn’t learn anything useful. I just like horrible things ¯\_(ツ)_/¯</p>

<p><em>Thanks to <a href="https://twitter.com/PredragGruevski">Predrag Gruevski</a> for feedback. Title is from <a href="https://christine.website/blog/gonads-2022-04-24">Crimes with Go Generics</a>.</em></p>

<p><em>I shared an early verison of this post on my <a href="https://buttondown.email/hillelwayne/">weekly newsletter</a> where I announce new blog posts and write additional essays. If you enjoyed this, <a href="https://buttondown.email/hillelwayne/">why not subscribe</a>?</em></p>


</div>

    



  </article></div>
  </body>
</html>
