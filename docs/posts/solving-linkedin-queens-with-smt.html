<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/solving-linkedin-queens-with-smt/">Original</a>
    <h1>Solving LinkedIn Queens with SMT</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                June 12, 2025
                
                
            </date>
            

            

            
            <h2>
                For sure easier than solving it in SAT!
            </h2>
            

            

            
            
            <h3>No newsletter next week</h3>
<p>I’ll be speaking at <a href="https://systemsdistributed.com/" target="_blank">Systems Distributed</a>. My talk isn&#39;t close to done yet, which is why this newsletter is both late and short. </p>

<p>The article <a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/" target="_blank">Modern SAT solvers: fast, neat and underused</a> claims that SAT solvers<sup id="fnref:SAT"><a href="#fn:SAT">1</a></sup> are &#34;criminally underused by the industry&#34;. A while back on the newsletter I asked &#34;why&#34;: how come they&#39;re so powerful and yet nobody uses them? Many experts responded saying the reason is that encoding SAT kinda sucked and they rather prefer using tools that compile to SAT. </p>
<p>I was reminded of this when I read <a href="https://ryanberger.me/posts/queens/" target="_blank">Ryan Berger&#39;s post</a> on solving “LinkedIn Queens” as a SAT problem. </p>
<p>A quick overview of Queens. You’re presented with an NxN grid divided into N regions, and have to place N queens so that there is exactly one queen in each row, column, and region. While queens can be on the same diagonal, they <em>cannot</em> be adjacently diagonal.</p>
<p>(Important note: Linkedin “Queens” is a variation on the puzzle game <a href="https://starbattle.puzzlebaron.com/" target="_blank">Star Battle</a>, which is the same except the number of stars you place in each row/column/region varies per puzzle, and is usually two. This is also why &#39;queens&#39; don’t capture like chess queens.)</p>
<p><img alt="An image of a solved queens board. Copied from https://ryanberger.me/posts/queens" src="https://assets.buttondown.email/images/96f6f923-331f-424d-8641-fe6753e1c2ca.png?w=960&amp;fit=max"/></p>
<p>Ryan solved this by writing Queens as a SAT problem, expressing properties like &#34;there is exactly one queen in row 3&#34; as a large number of boolean clauses. <a href="https://ryanberger.me/posts/queens/" target="_blank">Go read his post, it&#39;s pretty cool</a>. What leapt out to me was that he used <a href="https://cvc5.github.io/" target="_blank">CVC5</a>, an <strong>SMT</strong> solver.<sup id="fnref:SMT"><a href="#fn:SMT">2</a></sup> SMT solvers are &#34;higher-level&#34; than SAT, capable of handling more data types than just boolean variables. It&#39;s a lot easier to solve the problem at the SMT level than at the SAT level. To show this, I whipped up a short demo of solving the same problem in <a href="https://github.com/Z3Prover/z3/wiki" target="_blank">Z3</a> (via the <a href="https://pypi.org/project/z3-solver/" target="_blank">Python API</a>).</p>
<p><a href="https://gist.github.com/hwayne/c5de7bc52e733995311236666bedecd3" target="_blank">Full code here</a>, which you can compare to Ryan&#39;s SAT solution <a href="https://github.com/ryan-berger/queens/blob/master/main.py" target="_blank">here</a>. I didn&#39;t do a whole lot of cleanup on it (again, time crunch!), but short explanation below.</p>
<h3>The code</h3>
<div><pre><span></span><code><span>from</span><span> </span><span>z3</span><span> </span><span>import</span> <span>*</span> <span># type: ignore</span>
<span>from</span><span> </span><span>itertools</span><span> </span><span>import</span> <span>combinations</span><span>,</span> <span>chain</span><span>,</span> <span>product</span>
<span>solver</span> <span>=</span> <span>Solver</span><span>()</span>
<span>size</span> <span>=</span> <span>9</span> <span># N</span>
</code></pre></div>
<p>Initial setup and modules. <code>size</code> is the number of rows/columns/regions in the board, which I&#39;ll call <code>N</code> below.</p>
<div><pre><span></span><code><span># queens[n] = col of queen on row n</span>
<span># by construction, not on same row</span>
<span>queens</span> <span>=</span> <span>IntVector</span><span>(</span><span>&#39;q&#39;</span><span>,</span> <span>size</span><span>)</span> 
</code></pre></div>
<p>SAT represents the queen positions via N² booleans: <code>q_00</code> means that a Queen is on row 0 and column 0, <code>!q_05</code> means a queen <em>isn&#39;t</em> on row 0 col 5, etc. In SMT we can instead encode it as N integers: <code>q_0 = 5</code> means that the queen on row 0 is positioned at column 5. This immediately enforces one class of constraints for us: we don&#39;t need any constraints saying &#34;exactly one queen per row&#34;, because that&#39;s embedded in the definition of <code>queens</code>!</p>
<p>(Incidentally, using 0-based indexing for the board was a mistake on my part, it makes correctly encoding the regions later really painful.)</p>
<p>To actually make the variables <code>[q_0, q_1, …]</code>, we use the Z3 affordance <code>IntVector(str, n)</code> for making <code>n</code> variables at once.</p>
<div><pre><span></span><code><span>solver</span><span>.</span><span>add</span><span>([</span><span>And</span><span>(</span><span>0</span> <span>&lt;=</span> <span>i</span><span>,</span> <span>i</span> <span>&lt;</span> <span>size</span><span>)</span> <span>for</span> <span>i</span> <span>in</span> <span>queens</span><span>])</span>
<span># not on same column</span>
<span>solver</span><span>.</span><span>add</span><span>(</span><span>Distinct</span><span>(</span><span>queens</span><span>))</span>
</code></pre></div>
<p>First we constrain all the integers to <code>[0, N)</code>, then use the <em>incredibly</em> handy <code>Distinct</code> constraint to force all the integers to have different values. This guarantees at most one queen per column, which by the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank">pigeonhole principle</a> means there is exactly one queen per column.</p>
<div><pre><span></span><code><span># not diagonally adjacent</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>size</span><span>-</span><span>1</span><span>):</span>
    <span>q1</span><span>,</span> <span>q2</span> <span>=</span> <span>queens</span><span>[</span><span>i</span><span>],</span> <span>queens</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]</span>
    <span>solver</span><span>.</span><span>add</span><span>(</span><span>Abs</span><span>(</span><span>q1</span> <span>-</span> <span>q2</span><span>)</span> <span>!=</span> <span>1</span><span>)</span>
</code></pre></div>
<p>One of the rules is that queens can&#39;t be adjacent. We already know that they can&#39;t be horizontally or vertically adjacent via other constraints, which leaves the diagonals. We only need to add constraints that, for each queen, there is no queen in the lower-left or lower-right corner, aka <code>q_3 != q_2 ± 1</code>. We don&#39;t need to check the top corners because if <code>q_1</code> is in the upper-left corner of <code>q_2</code>, then <code>q_2</code> is in the lower-right corner of <code>q_1</code>!</p>
<p>That covers everything except the &#34;one queen per region&#34; constraint. But the regions are the tricky part, which we should expect because we vary the difficulty of queens games by varying the regions.</p>
<div><pre><span></span><code><span>regions</span> <span>=</span> <span>{</span>
        <span>&#34;purple&#34;</span><span>:</span> <span>[(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>3</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>4</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>5</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>6</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>7</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>8</span><span>),</span>
                   <span>(</span><span>1</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>2</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>3</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>4</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>5</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>6</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>7</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>8</span><span>,</span> <span>0</span><span>),</span>
                   <span>(</span><span>1</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>8</span><span>,</span> <span>1</span><span>)],</span>
        <span>&#34;red&#34;</span><span>:</span> <span>[(</span><span>1</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>2</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>2</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>3</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>4</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>5</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>6</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>6</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>7</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>7</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>8</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>8</span><span>,</span> <span>3</span><span>),],</span>
        <span># you get the picture</span>
        <span>}</span>

<span># Some checking code left out, see below</span>
</code></pre></div>
<p>The region has to be manually coded in, which is a huge pain.</p>
<p>(In the link, some validation code follows. Since it breaks up explaining the model I put it in the next section.)</p>
<div><pre><span></span><code><span>for</span> <span>r</span> <span>in</span> <span>regions</span><span>.</span><span>values</span><span>():</span>
    <span>solver</span><span>.</span><span>add</span><span>(</span><span>Or</span><span>(</span>
        <span>*</span><span>[</span><span>queens</span><span>[</span><span>row</span><span>]</span> <span>==</span> <span>col</span> <span>for</span> <span>(</span><span>row</span><span>,</span> <span>col</span><span>)</span> <span>in</span> <span>r</span><span>]</span>
        <span>))</span>
</code></pre></div>
<p>Finally we have the region constraint. The easiest way I found to say &#34;there is exactly one queen in each region&#34; is to say &#34;there is a queen in region 1 and a queen in region 2 and a queen in region 3&#34; etc.&#34; Then to say &#34;there is a queen in region <code>purple</code>&#34; I wrote &#34;<code>q_0 = 0</code> OR <code>q_0 = 1</code> OR … OR <code>q_1 = 0</code> etc.&#34; </p>
<p>Why iterate over every position in the region instead of doing something like <code>(0, q[0]) in r</code>? I tried that but it&#39;s not an expression that Z3 supports.</p>
<div><pre><span></span><code><span>if</span> <span>solver</span><span>.</span><span>check</span><span>()</span> <span>==</span> <span>sat</span><span>:</span>
    <span>m</span> <span>=</span> <span>solver</span><span>.</span><span>model</span><span>()</span>
    <span>print</span><span>([(</span><span>l</span><span>,</span> <span>m</span><span>[</span><span>l</span><span>])</span> <span>for</span> <span>l</span> <span>in</span> <span>queens</span><span>])</span>
</code></pre></div>
<p>Finally, we solve and print the positions. Running this gives me:</p>
<div><pre><span></span><code><span>[(</span><span>q__0</span><span>,</span> <span>0</span><span>),</span> <span>(</span><span>q__1</span><span>,</span> <span>5</span><span>),</span> <span>(</span><span>q__2</span><span>,</span> <span>8</span><span>),</span> 
 <span>(</span><span>q__3</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>q__4</span><span>,</span> <span>7</span><span>),</span> <span>(</span><span>q__5</span><span>,</span> <span>4</span><span>),</span> 
 <span>(</span><span>q__6</span><span>,</span> <span>1</span><span>),</span> <span>(</span><span>q__7</span><span>,</span> <span>3</span><span>),</span> <span>(</span><span>q__8</span><span>,</span> <span>6</span><span>)]</span>
</code></pre></div>
<p>Which is the correct solution to the queens puzzle. I didn&#39;t benchmark the solution times, but I imagine it&#39;s considerably slower than a raw SAT solver. <a href="https://github.com/audemard/glucose" target="_blank">Glucose</a> is really, really fast.</p>
<p>But even so, solving the problem with SMT was a lot <em>easier</em> than solving it with SAT. That satisfies me as an explanation for why people prefer it to SAT.</p>
<h3>Sanity checks</h3>
<p>One bit I glossed over earlier was the sanity checking code. I <em>knew for sure</em> that I was going to make a mistake encoding the <code>region</code>, and the solver wasn&#39;t going to provide useful information abut what I did wrong.  In cases like these, I like adding small tests and checks to catch mistakes early, because the solver certainly isn&#39;t going to catch them!</p>
<div><pre><span></span><code><span>all_squares</span> <span>=</span> <span>set</span><span>(</span><span>product</span><span>(</span><span>range</span><span>(</span><span>size</span><span>),</span> <span>repeat</span><span>=</span><span>2</span><span>))</span>
<span>def</span><span> </span><span>test_i_set_up_problem_right</span><span>():</span>
    <span>assert</span> <span>all_squares</span> <span>==</span> <span>set</span><span>(</span><span>chain</span><span>.</span><span>from_iterable</span><span>(</span><span>regions</span><span>.</span><span>values</span><span>()))</span>

    <span>for</span> <span>r1</span><span>,</span> <span>r2</span> <span>in</span> <span>combinations</span><span>(</span><span>regions</span><span>.</span><span>values</span><span>(),</span> <span>2</span><span>):</span>
        <span>assert</span> <span>not</span> <span>set</span><span>(</span><span>r1</span><span>)</span> <span>&amp;</span> <span>set</span><span>(</span><span>r2</span><span>),</span> <span>set</span><span>(</span><span>r1</span><span>)</span> <span>&amp;</span> <span>set</span><span>(</span><span>r2</span><span>)</span>
</code></pre></div>
<p>The first check was a quick test that I didn&#39;t leave any squares out, or accidentally put the same square in both regions. Converting the values into sets makes both checks a lot easier. Honestly I don&#39;t know why I didn&#39;t just use sets from the start, sets are great.</p>
<div><pre><span></span><code><span>def</span><span> </span><span>render_regions</span><span>():</span>
    <span>colormap</span> <span>=</span> <span>[</span><span>&#34;purple&#34;</span><span>,</span>  <span>&#34;red&#34;</span><span>,</span> <span>&#34;brown&#34;</span><span>,</span> <span>&#34;white&#34;</span><span>,</span> <span>&#34;green&#34;</span><span>,</span> <span>&#34;yellow&#34;</span><span>,</span> <span>&#34;orange&#34;</span><span>,</span> <span>&#34;blue&#34;</span><span>,</span> <span>&#34;pink&#34;</span><span>]</span>
    <span>board</span> <span>=</span> <span>[[</span><span>0</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>size</span><span>)]</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>size</span><span>)]</span> 
    <span>for</span> <span>(</span><span>row</span><span>,</span> <span>col</span><span>)</span> <span>in</span> <span>all_squares</span><span>:</span>
        <span>for</span> <span>color</span><span>,</span> <span>region</span> <span>in</span> <span>regions</span><span>.</span><span>items</span><span>():</span>
            <span>if</span> <span>(</span><span>row</span><span>,</span> <span>col</span><span>)</span> <span>in</span> <span>region</span><span>:</span>
                <span>board</span><span>[</span><span>row</span><span>][</span><span>col</span><span>]</span> <span>=</span> <span>colormap</span><span>.</span><span>index</span><span>(</span><span>color</span><span>)</span><span>+</span><span>1</span>

    <span>for</span> <span>row</span> <span>in</span> <span>board</span><span>:</span>
        <span>print</span><span>(</span><span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>map</span><span>(</span><span>str</span><span>,</span> <span>row</span><span>)))</span>

<span>render_regions</span><span>()</span>
</code></pre></div>
<p>The second check is something that prints out the regions. It produces something like this:</p>
<div><pre><span></span><code>111111111
112333999
122439999
124437799
124666779
124467799
122467899
122555889
112258899
</code></pre></div>
<p>I can compare this to the picture of the board to make sure I got it right. I guess a more advanced solution would be to print emoji squares like 🟥 instead.</p>
<p>Neither check is quality code but it&#39;s throwaway and it gets the job done so eh.</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            



        </div></div>
  </body>
</html>
