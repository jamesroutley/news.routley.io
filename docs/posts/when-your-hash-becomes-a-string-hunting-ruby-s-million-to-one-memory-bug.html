<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mensfeld.pl/2025/11/ruby-ffi-gc-bug-hash-becomes-string/">Original</a>
    <h1>When Your Hash Becomes a String: Hunting Ruby&#39;s Million-to-One Memory Bug</h1>
    
    <div id="readability-page-1" class="page"><div>
			
				
<p>Every developer who maintains Ruby gems knows that sinking feeling when a user reports an error that shouldn&#39;t be possible. Not &#34;difficult to reproduce&#34;, but truly impossible according to everything you know about how your code works.</p>
<p>That&#39;s exactly what hit me when <a href="https://github.com/karafka/karafka/">Karafka</a> user&#39;s error tracker logged 2,700 identical errors in a single incident:</p>
<pre><code>NoMethodError: undefined method &#39;default&#39; for an instance of String
vendor/bundle/ruby/3.4.0/gems/karafka-rdkafka-0.22.2-x86_64-linux-musl/lib/rdkafka/consumer/topic_partition_list.rb:112 FFI::Struct#[]</code></pre>
<p>The error was because something was calling <code>#default</code> on a String. I had never used a <code>#default</code> method anywhere in <a href="https://github.com/karafka/karafka/">Karafka</a> or <a href="https://github.com/karafka/rdkafka-ruby">rdkafka-ruby</a>. Suddenly, there were 2,700 reports in rapid succession until the process restarted and everything went back to normal.</p>
<p>The user added casually: &#34;No worry, no harm done since this hasn&#39;t occurred on prod yet.&#34;</p>
<p><strong>Yet</strong>. That word stuck with me.</p>
<p>Something had to change. Fast.</p>
<p><strong>TL;DR</strong>: FFI &lt; 1.17.0 has missing write barriers that cause Ruby&#39;s GC to free internal Hashes, allowing them to be replaced by other objects at the same memory address. Rare but catastrophic.</p>
<h2><span id="the-impossible-error">The Impossible Error</span></h2>
<p>I opened the rdkafka-ruby code at line 112:</p>
<pre><code>native_tpl[:cnt].times do |i|
  ptr = native_tpl[:elems] + (i * Rdkafka::Bindings::TopicPartition.size)
  elem = Rdkafka::Bindings::TopicPartition.new(ptr)

  # Line 112 - Where everything exploded
  if elem[:partition] == -1</code></pre>
<p>The crash happened when accessing <code>elem[:partition]</code>. But <code>elem</code> is an <code>FFI::Struct</code> - a foreign function interface structure that bridges Ruby and C code and partition was declared as an integer:</p>
<pre><code>class TopicPartition &lt; FFI::Struct
  layout :topic, :string,
         :partition, :int32,
         :offset, :int64,
         :metadata, :pointer,
         :metadata_size, :size_t,
         :opaque, :pointer,
         :err, :int,
         :_private, :pointer
end</code></pre>
<p>I dove into FFI&#39;s internals to understand what was happening. FFI doesn&#39;t use many Hashes, neither in Ruby nor in its C extension - there are only a few critical data structures. The most important one is <code>rbFieldMap</code>, an internal Hash that every struct layout maintains to store field definitions. When you access <code>elem[:partition]</code>, FFI looks up <code>:partition</code> in this Hash to find the field&#39;s type, offset, and size.</p>
<p>This Hash is the heart of the FFI&#39;s struct system. Without it, FFI can&#39;t map field names to their C memory locations.</p>
<p>Why would it be calling <code>default</code> on a String?</p>
<p>I searched the entire codebase. No calls to <code>#default</code> anywhere in my code. I checked FFI&#39;s Ruby code. No calls to <code>#default</code> there either.</p>
<p>But <code>#default</code> is a Hash method. Ruby&#39;s Hash implementation calls <code>hash#default</code> when you access a key that might not exist.</p>
<p>I stared at the backtrace. After billions of messages processed successfully, something in FFI&#39;s internals had fundamentally broken. An internal Hash that should contain field definitions was somehow... a String.</p>
<h2><span id="chasing-shadows-the-musl-hypothesis">Chasing Shadows: The musl Hypothesis</span></h2>
<p>The gem was precompiled: <code>karafka-rdkafka-0.22.2-x86_64-linux-musl</code>. That suffix made me immediately suspicious. The user was running <code>ruby:3.4.5-alpine</code> in Docker, which uses musl libc instead of glibc.</p>
<p>I&#39;ve debugged enough production issues to know that precompiled gems and Alpine Linux make a notorious combination. Different libc versions, different struct alignment assumptions, different CPU architecture quirks.</p>
<p>&#34;This has to be musl,&#34; I thought. I spent some time building diagnostic scripts:</p>
<pre><code>require &#39;ffi&#39;

# Check FFI integer type sizes
module Test
  extend FFI::Library

  class IntTest &lt; FFI::Struct
    layout :a, :int
  end

  class Int32Test &lt; FFI::Struct
    layout :a, :int32
  end
end

int_size = Test::IntTest.size
int32_size = Test::Int32Test.size

puts &#34;FFI :int size: #{int_size} bytes&#34;
puts &#34;FFI :int32 size: #{int32_size} bytes&#34;
puts &#34;Match: #{int_size == int32_size ? &#39;Yes&#39; : &#39;No&#39;}&#34;</code></pre>
<p>The response came back:</p>
<pre><code>FFI :int size: 4 bytes
FFI :int32 size: 4 bytes
Match: Yes</code></pre>
<p>The sizes matched. That ruled out basic type mismatches. But maybe alignment?</p>
<p>I sent another diagnostic to check struct padding:</p>
<pre><code># Check actual struct field offsets
module AlignTest
  extend FFI::Library

  class WithInt &lt; FFI::Struct
    layout :topic, :pointer, :partition, :int32, :offset, :int64,
           :metadata, :pointer, :metadata_size, :size_t, :opaque, :pointer,
           :err, :int, :_private, :pointer
  end

  class WithInt32 &lt; FFI::Struct
    layout :topic, :pointer, :partition, :int32, :offset, :int64,
           :metadata, :pointer, :metadata_size, :size_t, :opaque, :pointer,
           :err, :int32, :_private, :pointer
  end
end

err_offset_int = AlignTest::WithInt.offset_of(:err)
err_offset_int32 = AlignTest::WithInt32.offset_of(:err)
puts &#34;Struct alignment: :err offset #{err_offset_int} vs #{err_offset_int32}&#34;</code></pre>
<p>Response:</p>
<pre><code>Struct alignment: :err offset 48 vs 48</code></pre>
<p>Perfect alignment. Now let&#39;s check the actual compiled struct from the gem:</p>
<pre><code>actual_size = Rdkafka::Bindings::TopicPartition.size
actual_err_offset = Rdkafka::Bindings::TopicPartition.offset_of(:err)
puts &#34;Actual gem struct: size=#{actual_size}, err_offset=#{actual_err_offset}&#34;

expected_size = 64
expected_err_offset = 48
puts &#34;Expected: size=#{expected_size}, err_offset=#{expected_err_offset}&#34;</code></pre>
<p>Response:</p>
<pre><code>Actual gem struct: size=64, err_offset=48
Expected: size=64, err_offset=48</code></pre>
<p>Everything matched.</p>
<p>Every &#34;obvious&#34; explanation had failed. The struct definitions were perfect. The memory layout was correct. There was no ABI mismatch, no musl-specific quirk, no CPU architecture issue.</p>
<p>And yet the <code>undefined method &#39;default&#39; for an instance of String</code>occurred.</p>
<h2><span id="the-moment-everything-stopped-making-sense">The Moment Everything Stopped Making Sense</span></h2>
<p>I went back to that error message with fresh eyes. Why <code>default</code> specifically?</p>
<p>In Ruby, when you access a Hash with <code>hash[key]</code>, the implementation can call <code>hash.default</code> to check for a default value if the key doesn&#39;t exist. So if FFI is trying to call <code>#default</code> on a String, this would mean that<code>rbFieldMap</code> - the internal Hash that stores field definitions - is actually a String.</p>
<p>Sounds crazy, but wait! What if there was a case where Ruby could replace a Hash with a String at runtime? Not corrupt the Hash&#39;s data, but literally <strong>free</strong> the Hash and allocate a String in the same memory location?</p>
<p>That would explain everything. The C code would still have a pointer to memory address <code>0x000078358a3dfd28</code>, thinking it points to a Hash. But Ruby&#39;s GC would have freed that Hash, and the memory allocator could create a String at the exact same address. The pointer would be valid. The memory would contain valid data. Just... the wrong type of data.</p>
<ul>
<li>Not corrupted.</li>
<li>Not misaligned.</li>
<li>Not reading wrong offsets.</li>
</ul>
<p>An object changing type at runtime. That shouldn&#39;t be possible unless... I searched FFI&#39;s GitHub issues and found <a href="https://github.com/ffi/ffi/issues/1079">#1079</a>: &#34;Crash with <code>[BUG] try to mark T_NONE object</code>&#34; - about segfaults, not this specific error. But buried in the comments, <a href="https://github.com/KJTsanaktsidis">KJ</a> mentioned &#34;missing write barriers&#34; in FFI&#39;s C extension.</p>
<p>A write barrier is a mechanism that tells Ruby&#39;s garbage collector about references between objects. When C code stores a Ruby object pointer without using <code>RB_OBJ_WRITE</code>, the GC doesn&#39;t know that reference exists. The GC can then free the object, thinking nothing needs it anymore.</p>
<p>That&#39;s when it clicked. If FFI&#39;s <code>rbFieldMap</code> Hash was being freed by the GC, then Ruby could allocate a String in that exact memory location.</p>
<p>But first, I needed to understand the #1079 issue better. I wrote a simple reproduction:</p>
<pre><code>require &#39;ffi&#39;

puts &#34;Ruby: #{RUBY_VERSION} | FFI: #{FFI::VERSION}&#34;

# Enable aggressive GC to trigger the bug faster
GC.stress = 0x01 | 0x04

i = 0

loop do
  i += 1

  # Create transient struct class that immediately goes out of scope
  struct_class = Class.new(FFI::Struct) do
    layout :field1, :int32,
           :field2, :int64,
           :field3, :pointer,
           :field4, :string,
           :field5, :double,
           :field6, :uint8,
           :field7, :uint32,
           :field8, :pointer
  end

  instance = struct_class.new
  instance[:field1] = rand
  instance[:field2]
  # ... access various fields

  field = struct_class.layout[:field5]
  field.offset
  field.size

  print &#34;.&#34; if i % 1000 == 0
end</code></pre>
<p>This reproduced the #1079 segfaults beautifully - the &#34;T_NONE object&#34; errors where the GC frees objects so aggressively that Ruby tries to access null pointers.</p>
<pre><code>rb_obj_info_dump: 
/3.4.0/gems/ffi-1.16.3/lib/ffi/struct_layout_builder.rb:171: [BUG] try to mark T_NONE object
ruby 3.4.7 (2025-10-08 revision 7a5688e2a2) +PRISM [x86_64-linux]

-- Control frame information -----------------------------------------------
c:0044 p:---- s:0246 e:000245 CFUNC  :initialize
c:0043 p:---- s:0243 e:000242 CFUNC  :new
c:0042 p:0033 s:0236 e:000235 METHOD /gems/3.4.0/gems/ffi-1.16.3/lib/ffi/struct_layout_builder.rb:171</code></pre>
<p>But my production bug wasn&#39;t a segfault. It was a <strong>magical transformation</strong>. The timing had to be different.</p>
<p>With <code>GC.stress = true</code>, the GC runs after every possible allocation. That causes immediate segfaults because objects get freed before Ruby can even allocate new objects in their memory slots.</p>
<p>But for a Hash to <strong>become</strong> a String, you need:</p>
<ol>
<li>GC to run and free the Hash</li>
<li><strong>Time to pass</strong> between the free and the next access</li>
<li>Ruby to allocate a String in that exact memory slot</li>
<li>Code to try accessing the &#34;Hash&#34; that&#39;s now a String</li>
</ol>
<p>
I couldn&#39;t use <code>GC.stress</code>. I needed natural GC timing with precise memory pressure.
</p>
<h2><span id="down-the-rabbit-hole">Down the Rabbit Hole</span></h2>
<p>I dove deeper into FFI&#39;s C extension code. In <code>ext/ffi_c/StructLayout.c</code>, I found the vulnerable code:</p>
<pre><code>static VALUE
struct_layout_initialize(VALUE self, VALUE fields, VALUE size, VALUE align)
{
    StructLayout* layout;
    // ... initialization code ...

    layout-&gt;rbFieldMap = rb_hash_new();  // ‚Üê NO WRITE BARRIER
    layout-&gt;rbFields = rb_ary_new();
    layout-&gt;rbFieldNames = rb_ary_new();

    // Without RB_OBJ_WRITE, the GC doesn&#39;t know about these references!
    // ...
}</code></pre>
<p>When FFI creates a struct layout, it allocates three Ruby objects:</p>
<ul>
<li>a Hash for field lookups,</li>
<li>an Array of fields,</li>
<li>and an Array of field names.</li>
</ul>
<p>It stores pointers to these objects in a C struct.</p>
<p>But it didn&#39;t use <code>RB_OBJ_WRITE</code> to register these references with Ruby garbage collector in FFI 1.16.3.</p>
<p>From the GC&#39;s perspective, the following is happening:</p>
<ol>
<li>A Hash is allocated at memory address <code>0x000078358a3dfd28</code>.</li>
<li>No Ruby code stores a reference to this memory address (as far as the GC can see).</li>
<li>The struct class goes out of scope.</li>
<li>The GC thinks: &#34;Nobody needs this Hash anymore&#34;.</li>
<li>The GC frees the memory.</li>
<li>Ruby allocates a String at the address <code>0x000078358a3dfd28</code>.</li>
<li>FFI&#39;s C code still has the pointer, thinking it points to a Hash.</li>
<li><strong>Boom</strong>: <code>undefined method &#39;default&#39; for String</code>.</li>
</ol>
<p>
The fix in FFI 1.17.0 added proper write barriers:
</p>
<pre><code>static VALUE
struct_layout_initialize(VALUE self, VALUE fields, VALUE size, VALUE align)
{
    StructLayout* layout;
    // ... initialization code ...

    RB_OBJ_WRITE(self, &amp;layout-&gt;rbFieldMap, rb_hash_new());  // ‚Üê FIXED!
    RB_OBJ_WRITE(self, &amp;layout-&gt;rbFields, rb_ary_new());
    RB_OBJ_WRITE(self, &amp;layout-&gt;rbFieldNames, rb_ary_new());

    // Now the GC knows: &#34;self owns these objects, don&#39;t free them&#34;
    // ...
}</code></pre>
<p>This single macro call, <code>RB_OBJ_WRITE</code>, tells Ruby&#39;s garbage collector: &#34;This C struct holds a reference to this Ruby object. Don&#39;t free it while the struct is alive.&#34;</p>
<p>Without it, you have a use-after-free vulnerability where C thinks that it has a valid pointer, but Ruby has freed the memory and reused it for something else entirely.</p>
<h2><span id="building-the-perfect-trap">Building the Perfect Trap</span></h2>
<p>Understanding the bug wasn&#39;t enough. I needed to reproduce it. Not the #1079 segfaults - the specific case where a Hash becomes something else.</p>
<p>The requirements were precise:</p>
<ul>
<li>Thousands of transient struct class definitions that go out of scope.</li>
<li>Natural memory pressure to trigger GC (not <code>GC.stress</code> which causes segfaults).</li>
<li>Time between GC and field access for Ruby to allocate new objects.</li>
<li>Multi-threaded execution to increase memory churn.</li>
<li>Constant struct creation to maximize the replacement window.</li>
</ul>
<p>Here&#39;s what I have built:</p>
<pre><code>#!/usr/bin/env ruby

require &#39;ffi&#39;

# Unbuffer stdout so we see output immediately
$stdout.sync = true
$stderr.sync = true

2.times do
  Thread.new do
    loop do
      # Create an array to hold references temporarily
      # This creates more allocation pressure
      arr = []

      # Allocate many strings rapidly
      5000.times do
        arr &lt;&lt; rand.to_s * 100
        arr &lt;&lt; Time.now.to_s
        arr &lt;&lt; &#34;test string #{rand(10000)}&#34;
      end
    end
  end
end

sleep(0.1)

# Keep all struct instances here so we can access them later
garbage_strings = []

ars = Array.new(5) do |round|
  Thread.new do
    round_instances = []

    10000.times do |i|
      # Create a new struct class - this creates an rbFieldMap
      klass = Class.new(FFI::Struct) do
        layout :partition, :int32,
               :offset, :int64,
               :metadata, :pointer,
               :err, :int32,
               :value, :int64
      end

      # Create instance from this class
      ptr = FFI::MemoryPointer.new(klass.size)
      instance = klass.new(ptr)
      instance[:partition] = round * 100 + i
      instance[:offset] = (round * 100 + i) * 1000
      instance[:err] = 0

      round_instances &lt;&lt; instance
    end

    round_instances.each_with_index do |instance, i|
      begin
        partition = instance[:partition]
        offset = instance[:offset]
        err = instance[:err]
      rescue NoMethodError =&gt; e
        puts &#34;\n&#34; + &#34;=&#34; * 60
        puts &#34;üêõ BUG REPRODUCED! üêõ&#34;
        puts &#34;=&#34; * 60
        puts &#34;Error: #{e.message}&#34;
        puts &#34;\nBacktrace:&#34;
        puts e.backtrace[0..10]
        exit 1
      end
    end

    # Clear old strings to increase memory churn
    if garbage_strings.size &gt; 50_000
      garbage_strings.shift(25_000)
    end
  end
end

ars.each(&amp;:join)</code></pre>
<p>Key differences from typical FFI tests:</p>
<ul>
<li><strong>No GC.stress</strong> (it would cause segfaults, not object replacement)</li>
<li><strong>Multiple threads</strong> creating memory pressure simultaneously</li>
<li><strong>Natural GC timing</strong> from memory allocation patterns</li>
<li><strong>Time gap</strong> between struct creation and field access</li>
<li><strong>Transient classes</strong> that go out of scope immediately</li>
</ul>
<p>I wrapped it in a Docker container with memory constraints:</p>
<pre><code>FROM ruby:3.4.5-alpine

RUN apk add --no-cache build-base

RUN gem install ffi -v 1.16.3

WORKDIR /app
COPY poc.rb .

CMD [&#34;ruby&#34;, &#34;poc.rb&#34;]</code></pre>
<p>Then I created a bash script to run it in a loop, filtering for the specific error:</p>
<pre><code>#!/bin/bash

run_count=0
log_dir=&#34;./logs&#34;
mkdir -p &#34;$log_dir&#34;

echo &#34;Building Docker image...&#34;
docker build -t ffi-bug-poc .

echo &#34;Running POC in a loop until bug is reproduced...&#34;
echo &#34;Looking for exit code 1 with &#39;undefined&#39; in output&#34;
echo

while true; do
  run_count=$((run_count + 1))
  timestamp=$(date +%Y%m%d_%H%M%S)
  log_file=&#34;${log_dir}/run_${run_count}_${timestamp}.log&#34;

  echo -n &#34;Run #${run_count} at $(date +%H:%M:%S)... &#34;

  # Run with memory constraints to increase GC pressure
  docker run --rm \
    --memory=512m \
    --memory-swap=0m \
    ffi-bug-poc &gt; &#34;$log_file&#34; 2&gt;&amp;1

  exit_code=$?

  # Filter: only care about exit code 1 with &#34;undefined&#34; in output
  # Ignore segfaults (exit 139) - those are from #1079
  if [ $exit_code -eq 1 ] &amp;&amp; grep -qi &#34;undefined&#34; &#34;$log_file&#34;; then
    echo &#34;&#34;
    echo &#34;üêõ BUG REPRODUCED on run #${run_count}! üêõ&#34;
    cat &#34;$log_file&#34;
    exit 0
  elif [ $exit_code -eq 0 ]; then
    echo &#34;completed successfully (no bug)&#34;
    rm &#34;$log_file&#34;
  else
    echo &#34;exit code $exit_code (segfault) - continuing...&#34;
  fi

  sleep 0.1
done</code></pre>
<p>I hit Enter and watched the terminal:</p>
<pre><code>Building Docker image...
Running POC in a loop until bug is reproduced...
Looking for exit code 1 with &#39;undefined&#39; in output

Run #1 at 14:32:15... completed successfully (no bug)
Run #2 at 14:32:18... completed successfully (no bug)
Run #3 at 14:32:21... exit code 139 (segfault) - continuing...
Run #4 at 14:32:24... completed successfully (no bug)</code></pre>
<p>Lots of segfaults - those were the #1079 issue. I was hunting for the specific <code>undefined method</code> error.</p>
<p>After realizing I needed even more memory churn, I opened multiple terminals and ran the loop script several times in parallel. Within minutes:</p>
<pre><code>Run #23 at 15:18:42... exit code 139 (segfault) - continuing...
Run #24 at 15:18:45... completed successfully (no bug)
Run #25 at 15:18:48... 

============================================================
üêõ BUG REPRODUCED! üêõ
============================================================
Error: undefined method &#39;default&#39; for an instance of String

Backtrace:
  poc.rb:82:in `[]&#39;
  poc.rb:82:in `block (2 levels) in &lt;main&gt;&#39;
  poc.rb:80:in `each&#39;
  poc.rb:80:in `each_with_index&#39;
  poc.rb:80:in `block in &lt;main&gt;&#39;
  &lt;internal:numeric&gt;:237:in `times&#39;
  poc.rb:50:in `&lt;main&gt;&#39;
============================================================</code></pre>
<p><strong>There!</strong></p>
<p>Not a segfault. Not the T_NONE error from #1079. There it is, the exact error from production: <code>undefined method &#39;default&#39; for an instance of String</code></p>
<p>An FFI internal Hash had been freed by the GC and replaced by a String object in the same memory location!</p>
<h2><span id="the-microsecond-window">The Microsecond Window</span></h2>
<p>Here&#39;s what happens in those microseconds when the bug triggers:</p>
<p><a href="https://cdn.mensfeld.pl/wp-content/uploads/2025/11/flow.svg"><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20520%20780%22%3E%3C%2Fsvg%3E" alt="" width="520" height="780" data-src="https://cdn.mensfeld.pl/wp-content/uploads/2025/11/flow.svg"/></a></p>
<p>The Hash didn&#39;t get corrupted. It ceased to exist. A String was born in its place, wearing the Hash&#39;s memory address like a stolen identity.</p>
<h2><span id="what-this-means-for-rubys-memory-model">What This Means for Ruby&#39;s Memory Model</span></h2>
<p>This bug reveals something fundamental about how Ruby manages memory at the lowest level.</p>
<p><strong>Objects don&#39;t have permanent identities.</strong> They&#39;re data structures at the memory addresses. When the garbage collector frees memory, Ruby will reuse it. If you&#39;re holding a C pointer to that address without proper write barriers, you&#39;re now pointing at whatever Ruby decided to create there next.</p>
<ul>
<li>Your Hash can become a String.  </li>
<li>Your Array can become an Integer.  </li>
<li>Your carefully constructed object can transform into something completely different.</li>
</ul>
<p>No warning. No error. Just different methods that make no sense.</p>
<p>It&#39;s like coming home to find a stranger living in your house, wearing your clothes, answering to your name. And when you say &#34;but you&#39;re supposed to respond to <code>default</code>,&#34; they look at you confused: &#34;I&#39;m a String. I don&#39;t have that method.&#34;</p>
<p>This is why write barriers exist. They&#39;re not optional extras for C extension authors. They&#39;re how you tell the garbage collector: &#34;I&#39;m holding a reference. Don&#39;t free this. Without them, you have use-after-free bugs that can manifest as objects changing identity at runtime.</p>
<h2><span id="the-fix-and-the-future">The Fix and The Future</span></h2>
<p>If you&#39;re using FFI &lt; 1.17.0, the fix is straightforward:</p>
<pre><code># Gemfile
gem &#39;ffi&#39;, &#39;~&gt; 1.17.0&#39;</code></pre>
<p>That&#39;s it. Upgrade and the bug goes from million-to-one to zero.</p>
<p>The fix made by KJ adds proper write barriers throughout FFI&#39;s C codebase. The garbage collector now knows not to free <code>rbFieldMap</code> while it&#39;s still needed. Your Hashes stay Hashes. Your Strings stay Strings. Reality remains consistent.</p>
<p>But here&#39;s why this matters beyond just FFI users.</p>
<h3><span id="why-one-in-a-million">Why One in a Million?</span></h3>
<p>This bug requires perfect timing:</p>
<ol>
<li>
<p><strong>Create transient struct CLASS definitions</strong> (not just instances):</p>
<ul>
<li>Normal code: Defines classes once at startup, reuse forever.</li>
<li>My stress test: 50,000 transient classes immediately going out of scope.</li>
</ul>
</li>
<li>
<p><strong>Precise GC timing</strong> (not too aggressive, not too passive)</p>
<ul>
<li>Too aggressive: Segfaults from accessing freed memory.</li>
<li>Too passive: Hash never gets freed.</li>
<li>Just right: Hash freed, time passes, String allocated in same spot.</li>
</ul>
</li>
<li>
<p><strong>Multi-threaded execution</strong> creating memory churn:</p>
<ul>
<li>Increases chances of timing alignment.</li>
<li>Multiple allocation/deallocation cycles.</li>
</ul>
</li>
<li>
<p><strong>The exact microsecond window</strong> where:</p>
<ul>
<li>Struct class becomes unreachable.</li>
<li>GC runs and collects <code>rbFieldMap</code>.</li>
<li>Ruby allocates a String in that exact memory slot.</li>
<li>Code tries to access a struct field.</li>
</ul>
</li>
</ol>
<p>
In typical production Karafka processing:
</p>
<ul>
<li>You define 10-20 struct classes at startup.</li>
<li>They live for the entire process lifetime.</li>
<li>Natural GC cycles with moderate pressure.</li>
<li>The window is measured in microseconds across billions of operations.</li>
</ul>
<p><strong>~1 in 1,000,000 process restarts</strong></p>
<p>But in high-churn environments:</p>
<ul>
<li>Kubernetes pods restarting frequently.</li>
<li>Serverless functions with thousands of cold starts daily.</li>
<li><strong>The rare becomes inevitable</strong>.</li>
</ul>
<p>That&#39;s how a million-to-one bug causes 2,700 errors in production. Not because it&#39;s common, but because when timing finally aligns, it stays aligned. The corrupted state persists until a restart, causing every subsequent operation to fail.</p>
<h2><span id="lessons-from-the-hunt">Lessons From the Hunt</span></h2>
<p>After spending days debugging what seemed impossible, here&#39;s what stayed with me:</p>
<ul>
<li>
<p><strong>Sometimes the obvious answer is wrong.</strong> I spent a lot of time convinced this was a musl issue. Every diagnostic came back green. Sizes matched. Offsets matched. Alignment matched. Everything. Matched. But the bug wasn&#39;t in the data layout - it was in object identity.</p>
</li>
<li>
<p><strong>The timing of GC matters as much as whether GC happens.</strong> <code>GC.stress</code> finds immediate use-after-free (segfaults). Natural GC timing finds delayed reuse (object transformations). They&#39;re different symptoms of the same root cause, requiring different reproduction strategies.</p>
</li>
<li>
<p><strong>Million-to-one bugs are real, not theoretical.</strong> They happen during initialization and restart, not runtime. When they trigger, they cascade - 2,500 errors from one root cause. In high-restart environments, rare becomes routine.</p>
</li>
<li>
<p><strong>Diagnostic scripts can test the wrong layer.</strong> My scripts verified static struct layouts perfectly. But they couldn&#39;t detect that FFI&#39;s internal Hash could be freed by GC and replaced by a String at runtime. The tests passed because they checked structure, not behavior.</p>
</li>
<li>
<p><strong>Patience and persistence matter.</strong> Groing from the impossible theory to a reproducible bug took days of work. Building the elegant #1079 reproduction helped me understand the timing requirements. Manual write barrier removal showed me the difference between immediate and delayed failures. Multi-threaded stress tests with process farms compressed million-to-one odds into minutes.</p>
</li>
</ul>
<p>Initially, I blamed myself. I guess, that&#39;s what maintainership feels like sometimes. You own the stack, even when the bug is deeper than your code.</p>
<p>The fix was already in FFI 1.17.0 when this incident happened. The user just hadn&#39;t upgraded yet. Sometimes the &#34;impossible&#34; error you&#39;re debugging has already been solved. You just don&#39;t know it yet.</p>
<h2><span id="acknowledgments">Acknowledgments</span></h2>
<p>The root cause - missing write barriers in FFI &lt; 1.17.0 - was fixed in <a href="https://github.com/ffi/ffi/issues/1079">FFI issue #1079</a> by KJ, who has been my invaluable rubber duck throughout this debugging journey.</p>
<h2><span id="the-bottom-line">The Bottom Line</span></h2>
<p>If you&#39;re running FFI &lt; 1.17.0 in production - especially in high-restart environments like Kubernetes, ECS, or serverless platforms - upgrade today. The bug may be one in a million restarts, but at scale, million-to-one odds aren&#39;t odds at all.</p>
<p>They&#39;re inevitabilities waiting to happen.</p>
<p>And somewhere, right now, a developer is staring at an error log showing many identical crashes, running every diagnostic script they have, seeing all green checkmarks, and thinking: &#34;That&#39;s impossible. Everything matches.&#34;</p>
<p>But it&#39;s not impossible.</p>
<p>It&#39;s just waiting for the right microsecond.</p>

				
			</div></div>
  </body>
</html>
