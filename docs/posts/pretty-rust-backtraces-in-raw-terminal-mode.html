<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://werat.dev/blog/pretty-rust-backtraces-in-raw-terminal-mode/">Original</a>
    <h1>Pretty Rust backtraces in raw terminal mode</h1>
    
    <div id="readability-page-1" class="page"><div><article><header><time datetime="2023-02-24T13:00:00+01:00">February 24, 2023</time></header><p>In my efforts to get better at Rust I‚Äôve recently been working on a terminal-based roguelike game ü¶Ä. One of the first things terminal-based applications (e.g. games, text editors, tools like <code>top</code>) do at startup is switch the terminal into <a href="https://en.wikipedia.org/wiki/Terminal_mode">raw mode</a>. This article is about a short journey of how-do-I-get-a-pretty-panic-backtrace-when-my-terminal-is-in-raw-mode.</p><p><img src="https://werat.dev/blog/pretty-rust-backtraces-in-raw-terminal-mode/backtrace.png" alt="roguelike" width="1684" height="1186"/></p><h2 id="i-just-want-a-pretty-backtrace">I just want a pretty backtrace
<a href="#i-just-want-a-pretty-backtrace">#</a></h2><p>In raw mode the terminal doesn‚Äôt do any ‚Äúprocessing‚Äù of the input (so you can handle ‚Äúraw‚Äù keystrokes) and doesn‚Äôt echo the pressed keys to stdout (so you get full control over the output). Switching the terminal mode is done via functions from <a href="https://man7.org/linux/man-pages/man3/termios.3.html">termios.h</a> and I highly recommend reading a very comprehensive article <a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">‚ÄúEntering raw mode‚Äù</a> about working with terminal attributes. I didn‚Äôt want to do the low-level work myself, so I used a popular crate <a href="https://github.com/redox-os/termion"><code>termion</code></a> (~2k stars, ~90k ‚Äúused by‚Äù) to do it for me:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> <span>std</span>::<span>io</span>::{<span>stdout</span>, <span>Write</span>};
</span></span><span><span><span>use</span> <span>termion</span>::<span>raw</span>::<span>IntoRawMode</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>, <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>, <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>}
</span></span></code></pre></div><p>The function <code>into_raw_mode()</code> returns <code>RawTerminal&lt;T&gt;</code>, which is a convenience wrapper to switch the terminal back to the <a href="https://en.wikipedia.org/wiki/Terminal_mode">cooked mode</a> when the program ends. <code>RawTerminal</code> implements the <code>Drop</code> trait and <a href="https://gitlab.redox-os.org/redox-os/termion/-/blob/f2b8517c3185d8a6384109c7309589aa9ad48b49/src/raw.rs#L43-47">restores the original terminal attributes</a> when the object is destroyed.</p><p>Works exactly as expected. However there‚Äôs a minor inconvenience here. By default whenever a Rust program panics the crash handler prints an error message (and possibly the backtrace) to the standard output. Let‚Äôs see how it looks like for our program:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>    <span>..</span>.
</span></span><span><span>    <span>panic!</span>(<span>&#34;Whoops&#34;</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>&gt;</span> <span>cargo</span> <span>run</span>
</span></span><span><span><span>Hello</span>
</span></span><span><span>     <span>world</span>
</span></span><span><span>          <span>thread</span> <span>&#39;</span><span>main</span><span>&#39;</span> <span>panicked</span> <span>at</span> <span>&#39;</span><span>Whoops</span><span>&#39;</span>, <span>src</span><span>/</span><span>main</span>.<span>rs</span>:<span>10</span>:<span>5</span>
</span></span><span><span>                                                              <span>note</span>: <span>run</span> <span>with</span> <span>`</span><span>RUST_BACKTRACE</span><span>=</span><span>1</span><span>`</span> <span>environment</span> <span>variable</span> <span>to</span> <span>display</span> <span>a</span> <span>backtrace</span>
</span></span></code></pre></div><p>Whoops, the panic message is distorted. There‚Äôs a problem ‚Äì the terminal is in the raw mode, but the panic handler doesn‚Äôt know that. It naively prints the backtrace line by line and doesn‚Äôt explicitely move the cursor to the beginning of the line after the <code>\n</code> character (because why would it?). This means that each line slides further and further making the whole output barely readable.</p><p>Conveniently <code>RawTerminal&lt;T&gt;</code> has a method to disable the raw mode ‚Äì <code>suspend_raw_mode()</code>. If we could call it before printing the backtrace, that would solve our problem. There‚Äôs a function in the Rust standard library to override the default panic behaviour ‚Äì <code>std::panic::set_hook()</code>, so piece of cake?</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>, <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>, <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>panic!</span>(<span>&#34;Whoops&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>Unfortunately, this code doesn‚Äôt compile:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>error<span>[</span>E0382<span>]</span>: borrow of moved value: <span>`</span>stdout<span>`</span>
</span></span><span><span>  --&gt; src/main.rs:13:5
</span></span><span><span>   |
</span></span><span><span><span>5</span>  |     <span>let</span> mut <span>stdout</span> <span>=</span> stdout<span>()</span>.into_raw_mode<span>()</span>.unwrap<span>()</span>;
</span></span><span><span>   |         ---------- move occurs because <span>`</span>stdout<span>`</span> has <span>type</span> <span>`</span>RawTerminal&lt;Stdout&gt;<span>`</span>, which does not implement the <span>`</span>Copy<span>`</span> trait
</span></span><span><span>...
</span></span><span><span><span>8</span>  |     std::panic::set_hook<span>(</span>Box::new<span>(</span>move |info| <span>{</span>
</span></span><span><span>   |                                   ----------- value moved into closure here
</span></span><span><span><span>9</span>  |         stdout.suspend_raw_mode<span>()</span>.unwrap<span>()</span>;
</span></span><span><span>   |         ------ variable moved due to use in closure
</span></span><span><span>...
</span></span><span><span><span>13</span> |     writeln!<span>(</span>stdout, <span>&#34;Hello&#34;</span><span>)</span>.unwrap<span>()</span>;
</span></span><span><span>   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move
</span></span><span><span>   |
</span></span><span><span>   <span>=</span> note: this error originates in the macro <span>`</span>writeln<span>`</span> <span>(</span>in Nightly builds, run with -Z macro-backtrace <span>for</span> more info<span>)</span>
</span></span></code></pre></div><p>It makes sense, <code>RawTerminal&lt;T&gt;</code> is not copyable, so it has to be moved into the closure. This means the <code>stdout</code> variable is no longer valid after that and we can‚Äôt use it for <code>writeln!()</code>. We need to wrap the terminal object in <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. <code>Arc&lt;T&gt;</code> (without mutex) won‚Äôt work because it doesn‚Äôt allow mutable references to underlying data. For interior mutability we use <code>Mutex</code> (instead of typical <code>RefCell</code>) because <code>set_hook</code> <a href="https://doc.rust-lang.org/std/panic/fn.set_hook.html">requires the argument to be <code>Sync + Send</code></a>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>stdout</span> <span>=</span> <span>Arc</span>::<span>new</span>(<span>Mutex</span>::<span>new</span>(<span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>()));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>let</span> <span>cls_stdout</span> <span>=</span> <span>Arc</span>::<span>clone</span>(<span>&amp;</span><span>stdout</span>);
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>cls_stdout</span>.<span>lock</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>.<span>lock</span>().<span>unwrap</span>(), <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>stdout</span>.<span>lock</span>().<span>unwrap</span>(), <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>panic!</span>(<span>&#34;Whoops&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>Now this works great!</p><div><pre tabindex="0"><code data-lang="sh"><span><span>&gt; cargo run
</span></span><span><span>Hello
</span></span><span><span>     world
</span></span><span><span>
</span></span><span><span>thread <span>&#39;main&#39;</span> panicked at <span>&#39;Whoops&#39;</span>, src/main.rs:19:5
</span></span><span><span>note: run with <span>`</span><span>RUST_BACKTRACE</span><span>=</span>1<span>`</span> environment variable to display a backtrace
</span></span></code></pre></div><p>However, this solution has two significant problems. Can you spot them?</p><h3 id="problem-1----dont-panic">Problem #1 ‚Äì don‚Äôt panic
<a href="#problem-1----dont-panic">#</a></h3><p>What happens if the program doesn‚Äôt panic? It turns out the panic hook <a href="https://github.com/rust-lang/rust/blob/267cd1d2c5abf5f0d825822a4179ba807b69ffb4/library/std/src/panicking.rs#L96">is stored in a static variable</a> and according to the <a href="https://doc.rust-lang.org/reference/items/static-items.html">Rust specification</a>, ‚Äústatic items do not call <code>drop()</code> at the end of the program‚Äù. Consider the following example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Foo</span> {}
</span></span><span><span>
</span></span><span><span><span>impl</span> <span>Drop</span> <span>for</span> <span>Foo</span> {
</span></span><span><span>    <span>fn</span> <span>drop</span>(<span>&amp;</span><span>mut</span> <span>self</span>) {
</span></span><span><span>        <span>println!</span>(<span>&#34;Dropping Foo!&#34;</span>);
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>foo</span> <span>=</span> <span>Arc</span>::<span>new</span>(<span>Mutex</span>::<span>new</span>(<span>Foo</span> {}));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>hook_foo</span> <span>=</span> <span>Arc</span>::<span>clone</span>(<span>&amp;</span><span>foo</span>);
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>let</span> <span>_</span> <span>=</span> <span>&amp;</span><span>hook_foo</span>;
</span></span><span><span>    }));
</span></span><span><span>}
</span></span></code></pre></div><p>This program <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0ed2871afbdfff6cf759fe2ee064667b">runs and prints nothing</a>. The panic hook holds a reference to the <code>Foo</code> object via <code>Arc</code>, which prevents it from being dropped. In our case this means that the terminal stays in the raw mode even after the program exits:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>&gt; cargo run
</span></span><span><span>Hello
</span></span><span><span>     world
</span></span><span><span>
</span></span><span><span>          &gt; <span>echo</span> <span>&#34;one\ntwo\nthree&#34;</span>
</span></span><span><span>one
</span></span><span><span>   two
</span></span><span><span>      three
</span></span></code></pre></div><p>Now this is annoying! After all <em>not</em> panicking is normal behaviour, it should definitely work as expected.</p><p>A simple fix for this is to use a weak reference instead or a strong one. Weak references are not counted by <code>Arc</code> when deciding whether it‚Äôs time to destroy the underlying object, so the panic hook won‚Äôt keep the <code>RawTerminal</code> alive.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span><span>let</span> <span>weak_stdout</span> <span>=</span> <span>Arc</span>::<span>downgrade</span>(<span>&amp;</span><span>stdout</span>);
</span></span><span><span><span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>    <span>if</span> <span>let</span> <span>Some</span>(<span>arc_stdout</span>) <span>=</span> <span>weak_stdout</span>.<span>upgrade</span>() {
</span></span><span><span>        <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>arc_stdout</span>.<span>lock</span>().<span>unwrap</span>() {
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    }
</span></span><span><span>    <span>default_panic</span>(<span>info</span>);
</span></span><span><span>}));
</span></span></code></pre></div><h3 id="problem-2----all-my-locks-are-dead">Problem #2 ‚Äì all my locks are dead
<a href="#problem-2----all-my-locks-are-dead">#</a></h3><p>What happens if the program panics while <code>stdout</code> is locked? In this case the panic hook will deadlock.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>stdout</span> <span>=</span> <span>Arc</span>::<span>new</span>(<span>Mutex</span>::<span>new</span>(<span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>()));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>let</span> <span>hook_stdout</span> <span>=</span> <span>Arc</span>::<span>clone</span>(<span>&amp;</span><span>stdout</span>);
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>// 3. This is a deadlock -- the lock on `hook_stdout` is being held in step 2
</span></span></span><span><span><span></span>        <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>hook_stdout</span>.<span>lock</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>
</span></span><span><span>    <span>// 1. Lock the output once as an optimization ^_^
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> <span>o</span> <span>=</span> <span>stdout</span>.<span>lock</span>().<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>o</span>, <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>o</span>, <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>// 2. Panic while still holding the lock on `stdout`
</span></span></span><span><span><span></span>    <span>panic!</span>(<span>&#34;Whoops&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>This can be solved by using a reentrant mutex instead of a regular <code>Mutex</code>. Unfortunately Rust standard library doesn‚Äôt have one (even though <a href="https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/library/std/src/io/stdio.rs#L553">stdout/stderr are using one internally</a>), so we‚Äôd have to use something like <code>parking_lot::ReentrantMutex</code> from the <a href="https://github.com/Amanieu/parking_lot"><code>parking_lot</code></a> crate.</p><p>But even though reentrant mutex solves the problem of <em>locking</em> the underlying object multiple times, it exposes a more fundamental issue ‚Äì we‚Äôre trying to have two mutable references at the same time (one at the source of the panic, another in the panic hook), which goes against Rust philosophy. That‚Äôs why <code>parking_lot::ReentrantMutex</code> doesn‚Äôt allow taking mutable references to the underlying object. We can wrap our terminal object in <code>RefCell</code>, but that will have the same problem as the regular mutex. If the panic happens while we‚Äôre holding a mutable reference via <code>bottow_mut()</code> the panic hook will fail:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>stdout</span> <span>=</span> <span>Arc</span>::<span>new</span>(<span>ReentrantMutex</span>::<span>new</span>(<span>RefCell</span>::<span>new</span>(
</span></span><span><span>        <span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>(),
</span></span><span><span>    )));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>let</span> <span>hook_stdout</span> <span>=</span> <span>Arc</span>::<span>clone</span>(<span>&amp;</span><span>stdout</span>);
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>let</span> <span>guard</span> <span>=</span> <span>hook_stdout</span>.<span>lock</span>();
</span></span><span><span>        <span>// 3. This will panic, the mutable reference already exists in step 2
</span></span></span><span><span><span></span>        <span>let</span> <span>mut</span> <span>stdout</span> <span>=</span> <span>guard</span>.<span>borrow_mut</span>();
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>guard</span> <span>=</span> <span>stdout</span>.<span>lock</span>();
</span></span><span><span>    <span>// 1. Get the mutable reference once as an optimization ^_^
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> <span>o</span> <span>=</span> <span>guard</span>.<span>borrow_mut</span>();
</span></span><span><span>    <span>writeln!</span>(<span>o</span>, <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    <span>writeln!</span>(<span>o</span>, <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>// 2. Panic while still holding a mutable reference on `stdout`
</span></span></span><span><span><span></span>    <span>panic!</span>(<span>&#34;Whoops&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>We could call <code>borrow_mut()</code> on every call, but that‚Äôs no different from calling <code>lock()</code> on the Mutex ¬Ø\_(„ÉÑ)_/¬Ø</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>writeln!</span>(<span>stdout</span>.<span>lock</span>().<span>unwrap</span>(), <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span><span>writeln!</span>(<span>stdout</span>.<span>lock</span>().<span>unwrap</span>(), <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span><span>// vs
</span></span></span><span><span><span></span>
</span></span><span><span><span>let</span> <span>o</span> <span>=</span> <span>stdout</span>.<span>lock</span>();
</span></span><span><span><span>writeln!</span>(<span>o</span>.<span>borrow_mut</span>(), <span>&#34;Hello&#34;</span>).<span>unwrap</span>();
</span></span><span><span><span>writeln!</span>(<span>o</span>.<span>borrow_mut</span>(), <span>&#34;world&#34;</span>).<span>unwrap</span>();
</span></span></code></pre></div><p>In my opinion a more practical solution is to use <code>Mutex::try_lock()</code> in the panic hook instead. If the lock is already held for whatever reason (which really should be a very rare situation and possibly a logical bug), then just give up and print an ugly backtrace:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>    <span>if</span> <span>let</span> <span>Ok</span>(<span>ref</span> <span>mut</span> <span>stdout</span>) <span>=</span> <span>hook_stdout</span>.<span>try_lock</span>() {
</span></span><span><span>        <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>        <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        <span>println!</span>(<span>&#34;Sorry, RawTerminal is already locked, can&#39;t do anything about it :(&#34;</span>);
</span></span><span><span>    }
</span></span><span><span>    <span>default_panic</span>(<span>info</span>);
</span></span><span><span>}));
</span></span><span><span>
</span></span><span><span><span>&gt;</span> <span>cargo</span> <span>run</span>
</span></span><span><span><span>Hello</span>
</span></span><span><span>     <span>world</span>
</span></span><span><span>          <span>Sorry</span>, <span>RawTerminal</span> <span>is</span> <span>already</span> <span>locked</span>, <span>can</span><span>&#39;</span><span>t</span> <span>do</span> <span>anything</span> <span>about</span> <span>it</span> :(
</span></span><span><span>                                                                             <span>thread</span> <span>&#39;</span><span>main</span><span>&#39;</span> <span>panicked</span> <span>at</span> <span>&#39;</span><span>Whoops</span><span>&#39;</span>, <span>src</span><span>/</span><span>main</span>.<span>rs</span>:<span>28</span>:<span>5</span>
</span></span><span><span>                                                                                                                                 <span>note</span>: <span>run</span> <span>with</span> <span>`</span><span>RUST_BACKTRACE</span><span>=</span><span>1</span><span>`</span> <span>environment</span> <span>variable</span> <span>to</span> <span>display</span> <span>a</span> <span>backtrace</span>
</span></span></code></pre></div><h2 id="recap">Recap
<a href="#recap">#</a></h2><p>Here‚Äôs the final solution that incorporates the fixes for both problems. It avoids the deadlock and properly returns the terminal back to the cooked mode regardless of whether the application panicked or not.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> <span>stdout</span> <span>=</span> <span>Arc</span>::<span>new</span>(<span>Mutex</span>::<span>new</span>(<span>stdout</span>().<span>into_raw_mode</span>().<span>unwrap</span>()));
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>let</span> <span>weak_stdout</span> <span>=</span> <span>Arc</span>::<span>downgrade</span>(<span>&amp;</span><span>stdout</span>);
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>if</span> <span>let</span> <span>Some</span>(<span>stdout</span>) <span>=</span> <span>weak_stdout</span>.<span>upgrade</span>() {
</span></span><span><span>            <span>if</span> <span>let</span> <span>Ok</span>(<span>ref</span> <span>mut</span> <span>stdout</span>) <span>=</span> <span>stdout</span>.<span>try_lock</span>() {
</span></span><span><span>                <span>stdout</span>.<span>suspend_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>                <span>stdout</span>.<span>write</span>(<span>b&#34;</span><span>\n</span><span>&#34;</span>).<span>unwrap</span>();
</span></span><span><span>            } <span>else</span> {
</span></span><span><span>                <span>println!</span>(<span>&#34;Sorry, RawTerminal is already locked, can&#39;t do anything about it :(&#34;</span>);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>    <span>..</span>.
</span></span><span><span>}
</span></span></code></pre></div><h2 id="is-this-the-best-we-can-do">Is this the best we can do?
<a href="#is-this-the-best-we-can-do">#</a></h2><p>The more I thought about it, the more I got convinced that this particular situation shouldn‚Äôt have this many pitfalls. After all we don‚Äôt really <em>need</em> to have exclusive access to the <code>Stdout</code> object in order to switch it to the raw mode and back. A little bit of <code>unsafe</code> can help us out, but here‚Äôs another observation ‚Äì do we even need to have an abstraction like <code>RawTerminal&lt;T&gt;</code>?</p><p>Would we ever have two different instances of <code>RawTerminal&lt;T&gt;</code> switching into the raw mode independently? Not really. Even <code>termion</code> agrees with us ‚Äì it <a href="https://gitlab.redox-os.org/redox-os/termion/-/blob/f2b8517c3185d8a6384109c7309589aa9ad48b49/src/sys/unix/attr.rs#L8">hardcodes <code>stdout</code> file descriptor</a> when working with terminal attributes. Although <code>RawTerminal</code> is defined as <code>RawTerminal&lt;T: Write&gt;</code>, in practice it‚Äôs basically <code>RawTerminal&lt;Stdout&gt;</code>. Given that it‚Äôs essentially a singleton, a better interface might look like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>enable_raw_mode</span>();
</span></span><span><span><span>fn</span> <span>disable_raw_mode</span>();
</span></span></code></pre></div><p>Another popular crate <a href="https://github.com/crossterm-rs/crossterm"><code>crossterm</code></a> (~2k stars, ~20k ‚Äúused by‚Äù) provides exactly this API, so let‚Äôs try it out. We still need to set the panic hook, but the whole thing is much simpler as there‚Äôs no need for reference counters or locks:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> <span>crossterm</span>::<span>terminal</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>terminal</span>::<span>enable_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>default_panic</span> <span>=</span> <span>std</span>::<span>panic</span>::<span>take_hook</span>();
</span></span><span><span>    <span>std</span>::<span>panic</span>::<span>set_hook</span>(<span>Box</span>::<span>new</span>(<span>move</span> <span>|</span><span>info</span><span>|</span> {
</span></span><span><span>        <span>_</span> <span>=</span> <span>terminal</span>::<span>disable_raw_mode</span>();
</span></span><span><span>        <span>println!</span>();
</span></span><span><span>        <span>default_panic</span>(<span>info</span>);
</span></span><span><span>    }));
</span></span><span><span>
</span></span><span><span>    <span>..</span>.
</span></span><span><span>
</span></span><span><span>    <span>terminal</span>::<span>disable_raw_mode</span>().<span>unwrap</span>();
</span></span><span><span>}
</span></span></code></pre></div><p>Much better! In my game I‚Äôm actually using very few things from <code>termion</code>, because native terminal is only one of two ‚Äúfrontends‚Äù (the other one is <a href="https://xtermjs.org/"><code>xterm.js</code></a> + WASM). Switching to <code>crossterm</code> took less time than investigating the issue and writing this article üòú At least I hope you were entertained!</p><h2 id="links">Links
<a href="#links">#</a></h2><ol><li><a href="https://thevaluable.dev/guide-terminal-shell-console">https://thevaluable.dev/guide-terminal-shell-console</a></li><li><a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html</a></li></ol><hr/><p>Discuss this article on <a href="https://lobste.rs/s/sdh7y9/pretty_rust_backtraces_raw_terminal_mode">lobste.rs</a> or <a href="https://news.ycombinator.com/item?id=34929507">HackerNews</a> or <a href="https://www.reddit.com/r/rust/comments/11av0ju/pretty_rust_backtraces_in_raw_terminal_mode/">Reddit</a></p><hr/></article></div></div>
  </body>
</html>
