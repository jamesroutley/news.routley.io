<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/commandline/case-study-how-many-colors-are-too-many-colors-for-windows-terminal/">Original</a>
    <h1>How many colors are too many colors for Windows Terminal?</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            May 4th, 2022</p><!-- .entry-meta -->
        
<p>A group of users were trying to implement a simple, terminal-based video game and found the performance under Windows Terminal to be entirely unsuitable for such a task. The performance issue could be replicated by repeatedly drawing a “rainbow” and measuring how many frames per second (FPS) we can achieve. The one below has 20 distinct colors and could be drawn at around 30 FPS on my Surface Book with an Intel i7-6700HQ CPU. However, if we draw the same rainbow with 21 or more distinct colors it would drop down to less than 10 FPS. This drop is consistent and doesn’t get worse even with thousands of distinct colors.</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow.png"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA7AQMAAAC39L01AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEElEQVQokWNgGAWjYBSQDgADOgABJ37adQAAAABJRU5ErkJggg==" alt="Screenshot of a rainbow drawn in Windows Terminal" width="1986" height="1162" data-srcset="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow.png 1986w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow-300x176.png 300w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow-1024x599.png 1024w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow-768x449.png 768w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wt_rainbow-1536x899.png 1536w" sizes="(max-width: 1986px) 100vw, 1986px"/></a></p>
<h2 id="initial-investigation-with-windows-performance-analyzer">Initial investigation with Windows Performance Analyzer</h2>
<p>Initially the culprit wasn’t immediately obvious of course. Does the performance drop because we’re misusing Direct2D or DirectWrite? Does our virtual terminal (VT) sequence parser have any issues with quickly processing colors? We usually begin any performance investigations with <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-analyzer" rel="noreferrer noopener" target="_blank">Windows Performance Analyzer</a> (WPA). It requires us to create an “.etl” trace file, which we can be done using <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="noreferrer noopener" target="_blank">Windows Performance Recorder</a> (WPR).</p>
<p>The “Flame by Process” view inside WPA is my personal favorite. In a flame graph each horizontal bar represents a specific function call. The widths of the bars correspond to the total CPU time spent within that function, including time spent in all functions it calls recursively. This makes it trivial to visually spot changes between two flame graphs of the same application, or to find outliers which are easily visible as overly wide bars.</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph.png"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Flamegraph of Windows Terminal showing CPU usage when drawing 20 and 21 colors respectively" width="2500" height="1360" data-srcset="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph.png 2500w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph-300x163.png 300w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph-1024x557.png 1024w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph-768x418.png 768w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph-1536x836.png 1536w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_wpa_flamegraph-2048x1114.png 2048w" sizes="(max-width: 2500px) 100vw, 2500px"/></a></p>
<blockquote>
<p>To replicate this investigation, you’ll need to install <a href="https://github.com/microsoft/terminal/releases/tag/v1.12.10393.0" rel="noreferrer noopener" target="_blank">Windows Terminal 1.12</a> as well as a tool, called <a href="https://github.com/lhecker/rainbowbench" rel="noreferrer noopener" target="_blank">rainbowbench</a>. After compiling rainbowbench with cmake and your favorite compiler, you should run the commands <code>rainbowbench 20</code> and <code>rainbowbench 21</code> for at least 10 seconds each inside Windows Terminal. Make sure to have Windows Performance Recorder (WPR) running and recording a performance trace for you during that time. Afterwards you can open the .etl file with Windows Performance Analyzer (WPA). Within the menu bar you can tell WPA to “Load Symbols” for you.</p>
</blockquote>
<p>On the left side in the image above we can see the CPU usage of our text rendering thread when it’s continuously redrawing the same 20 distinct colors and on the right side if we draw 21 colors instead. Thanks to the flame graph we can immediately spot that a drastic change in behavior inside Direct2D must have taken place and that the likely culprit is a function called <code>TextLookupTableAtlas::Fill6x5ContrastRow</code> inside Direct2D. An “atlas” in a graphical application is usually referring to a <a href="https://en.wikipedia.org/wiki/Texture_atlas" rel="noreferrer noopener" target="_blank">texture atlas</a> and considering how Direct2D uses the GPU for rendering by default, this is likely code dealing with a texture atlas on the GPU. Luckily several tools already exist with which we can easily debug applications running on the GPU.</p>
<h2 id="pix-and-renderdoc-debug-graphical-performance-issues-with-ease">PIX and RenderDoc – Debug graphical performance issues with ease</h2>
<p><a href="https://devblogs.microsoft.com/pix/download/" rel="noreferrer noopener" target="_blank">PIX</a> is an application similar to the venerable open-source project <a href="https://renderdoc.org/" rel="noreferrer noopener" target="_blank">RenderDoc</a>, both of which are tremendously helpful to debug and understand graphical performance issues like this one.</p>
<p>While PIX offers support for packaged applications like Windows Terminal (which PIX refers to as “UWP”) and a large number of helpful metrics out of the box, I found it easier to generate the following visualizations using RenderDoc. Both applications work almost identical however, which makes it easy to switch between them.</p>
<blockquote>
<p>Windows Terminal ships with a modern version of <code>conhost.exe</code>, called <code>OpenConsole.exe</code>, featuring several enhancements not present in conhost.exe, one of which are alternative rendering engines. You can find and run OpenConsole.exe from inside Windows Terminal’s application package, or from one of <a href="https://github.com/microsoft/terminal/releases" rel="noreferrer noopener" target="_blank">Terminal’s release archives</a>. Afterwards you can create a DWORD key at <code>HKEY_CURRENT_USER\Console\UseDx</code> and assign it the value 0 to get the classic GDI text renderer, 1 for the standard Direct2D renderer and 2 for the new Direct3D engine which solves this issue. This trick is helpful for RenderDoc, which doesn’t support packaged applications like Windows Terminal.</p>
</blockquote>
<p>Simply drag and drop an executable onto RenderDoc and “Launch” it. Afterwards snapshots can be “captured” and retroactively analyzed and debugged.</p>
<div id="gallery-1"><figure>
			<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch.png"><img width="2560" height="1392" data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Screenshot of the Launch Application dialog in RenderDoc" data-srcset="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch.png 2560w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch-300x163.png 300w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch-1024x557.png 1024w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch-768x418.png 768w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch-1536x835.png 1536w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_launch-2048x1114.png 2048w" sizes="(max-width: 2560px) 100vw, 2560px"/></a>
			</p></figure><figure>
			<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture.png"><img width="2560" height="1392" data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Screenshot of the captured snapshots in RenderDoc" data-srcset="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture.png 2560w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture-300x163.png 300w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture-1024x557.png 1024w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture-768x418.png 768w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture-1536x835.png 1536w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_capture-2048x1114.png 2048w" sizes="(max-width: 2560px) 100vw, 2560px"/></a>
			</p></figure>
		</div>

<p>Opening a capture will show the draw commands Direct2D executed on the GPU on the left side. Selecting the “Texture Viewer” will initially yield nothing, but as it turns out certain events in the “Output” tab, like <code>DrawIndexedInstanced</code>, will seemingly present us with the state of our renderer in the middle of execution. Furthermore the “Input” tab contains a texture called “D2D Internal: Grayscale Lookup Table”:</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer.png"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Screenshot of the Texture Viewer in RenderDoc" width="2560" height="1392" data-srcset="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer.png 2560w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer-300x163.png 300w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer-1024x557.png 1024w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer-768x418.png 768w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer-1536x835.png 1536w, https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_texture_viewer-2048x1114.png 2048w" sizes="(max-width: 2560px) 100vw, 2560px"/></a></p>
<p>The existence of such a “lookup table” seems highly relevant to our finding that anything over 20 colors slows down our application dramatically and seems related to our problematic <code>TextLookupTableAtlas::Fill6x5ContrastRow</code> function we found using WPA. What if the table’s size is limited? Simply scrolling through all events already confirms our suspicion. The table gets filled with new colors hundreds of times every frame, because it can’t fit 21 colors into a table that only fits 20:</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_rainbow_21.gif"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_rainbow_21.gif" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Video of RenderDoc" width="1080" height="587"/></a></p>
<p>If we limit our test application to 20 distinct colors, the table’s contents stay constant:</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_rainbow_20.gif"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_renderdoc_rainbow_20.gif" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA2AQMAAAALaq7rAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGQBAAL0AAG+v0fLAAAAAElFTkSuQmCC" alt="Video of RenderDoc" width="1080" height="587"/></a></p>
<p>So, as it turns out our terminal is running into a corner case for Direct2D: It’s only optimized to handle up to 20 distinct colors in the general case (as of April 2022). Direct2D’s approach isn’t a coincidence either, as the use of a fixed lookup table for colorization reduces its computational complexity and power draw, especially on the older hardware it was originally written for. Additionally, most applications, websites, etc. stay below this limit and if they do happen to exceed it, more often than not, the text is static and doesn’t need to be redrawn 60 times a second. In comparison, it’s not uncommon to see a terminal-based application doing exactly that.</p>
<h2 id="solving-the-issue-with-more-aggressive-caching">Solving the issue with more aggressive caching</h2>
<p>The solution is trivial: We simply create our own, much larger color lookup table and provide it to Direct2D! Unfortunately we can’t just tell Direct2D to use our custom cache. In fact, relying on its rendering logic at all would be problematic here, since the maximum amount of performant colors would always remain finite. As such, we’ll have to write our own custom text renderer after all.</p>
<blockquote>
<p><strong>Update May 9, 2022:</strong> This article was originally published without giving proper credit where it is due. We would like to thank Joe Wilm of <a href="https://github.com/alacritty/alacritty" rel="noreferrer noopener" target="_blank">Alacritty</a> for establishing modern GPU terminal rendering, Christian Parpart of <a href="https://github.com/contour-terminal/contour" rel="noreferrer noopener" target="_blank">Contour</a> for the continued support and advice, and Tom Szilagyi for <a href="https://tomscii.sig7.se/2020/11/How-Zutty-works" rel="noreferrer noopener" target="_blank">describing the idea previously</a>. Special thanks to Casey Muratori for <a href="https://github.com/microsoft/terminal/issues/10362#issuecomment-862822530" rel="noreferrer noopener" target="_blank">suggesting this approach</a> and Mārtiņš Možeiko for <a href="https://github.com/microsoft/terminal/issues/10461#issuecomment-864444814" rel="noreferrer noopener" target="_blank">providing a reference HLSL shader</a>. I deeply apologize to everyone mentioned. Additionally, a wording mistake was corrected in the previous paragraph.</p>
</blockquote>
<p>Turning fonts and the glyphs they contain into actual rasterized images is generally very expensive, which is why implementing a “glyph cache” of sorts will be critical for performance. A primitive way to cache a glyph would be to draw it into a tiny texture when we first encounter it. Whenever we encounter it again, we can reference the cached texture instead. Just like Direct2D with its lookup table atlas for colorization we can use our own <a href="https://en.wikipedia.org/wiki/Texture_atlas" rel="noreferrer noopener" target="_blank">texture atlas</a> for caching glyphs. Instead of drawing 1000 glyphs into 1000 tiny textures, we’ll just allocate one huge texture and subdivide it into a grid of 1000 glyph cells.</p>
<p>Now let’s say we have a tiny terminal of just 6 by 2 cells and want to draw some colored “Hello, World!” text. We already know the first step is to build up a texture atlas of our glyphs:</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_cpu.svg"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_cpu.svg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyAQMAAACQ++z9AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGgCAAK8AAGBAoNpAAAAAElFTkSuQmCC" alt="Flow chart for glyph extraction and caching on the CPU" width="459" height="395" role="img"/></a></p>
<p>After replacing the characters and their glyphs in our terminal with references into our texture atlas, we’re left with a “metadata buffer” that is the same size as the terminal and still stores the color information. The texture atlas contains only the deduplicated and uncolored rasterized glyph textures. But wait a minute… Can’t we just flip this around to get back the original input? And that’s exactly how our GPU shader works:</p>
<p><a href="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_gpu.svg"><img data-src="https://devblogs.microsoft.com/commandline/wp-content/uploads/sites/33/2022/08/atlasengine_gpu.svg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyAQMAAACQ++z9AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGgCAAK8AAGBAoNpAAAAAElFTkSuQmCC" alt="Flow chart for composition on the GPU" width="459" height="395" role="img"/></a></p>
<p>By writing a primitive pixel shader, we can copy our glyphs from the atlas texture to the display output directly on the GPU. If we ignore more advanced topics like <a href="https://en.wikipedia.org/wiki/Alpha_compositing#Gamma_correction" rel="noreferrer noopener" target="_blank">gamma-correctness</a> or <a href="https://en.wikipedia.org/wiki/ClearType" rel="noreferrer noopener" target="_blank">ClearType</a>, colorizing the glyphs is just a matter of multiplying our glyph’s alpha mask with any color we want them to be. And our metadata buffer stores both, the index of the glyph we want to copy for each grid cell and the color it’s supposed to be.</p>
<h2 id="result">Result</h2>
<p>The exact performance benefit of this approach depends heavily on the hardware it runs on. Generally, however we found it to be at least on par with our previous Direct2D-based renderer while avoiding any limitations regarding glyph colorization.</p>
<p>We measured the performance with the following hardware:</p>
<ul>
<li>CPU: AMD Ryzen 9 5950X</li>
<li>GPU: NVIDIA RTX 3080 FE</li>
<li>RAM: 64GB 3200 MHz CL16</li>
<li>Display: 3840×2160 @ 60 Hz</li>
</ul>
<p>We’ve measured CPU and GPU usage based on the values shown in the Task Manager, as that’s what users will most likely check first when encountering performance issues. Additionally, the total GPU power draw was measured as it’s the best indicator for potential power savings, independent of frequency scaling, etc.</p>
<table>

<thead>
<tr>
<th>
      </th>
<th>
      </th>
<th>
        CPU (%)
      </th>
<th>
        GPU (%)
      </th>
<th>
        GPU (Watt)
      </th>
<th>
        FPS
      </th>
</tr>
</thead>
<tbody>
<tr>
<td>
        DxEngine
      </td>
<td>
        Cursor blinking
      </td>
<td>
        0.0%
      </td>
<td>
        0.1%
      </td>
<td>
        17W
      </td>
<td>
      </td>
</tr>
<tr>
<td>
        DxEngine
      </td>
<td>
        ≤ 20 colors
      </td>
<td>
        1.5%
      </td>
<td>
        7.0%
      </td>
<td>
        24W
      </td>
<td>
        60
      </td>
</tr>
<tr>
<td>
        DxEngine
      </td>
<td>
        ≥ 21 colors
      </td>
<td>
        5.5%
      </td>
<td>
        27%
      </td>
<td>
        27W
      </td>
<td>
        30
      </td>
</tr>
<tr>
<td>
      </td>
<td>
      </td>
<td>
      </td>
<td>
      </td>
<td>
      </td>
<td>
      </td>
</tr>
<tr>
<td>
        AtlasEngine
      </td>
<td>
        Cursor blinking
      </td>
<td>
        0.0%
      </td>
<td>
        0.0%
      </td>
<td>
        17W
      </td>
<td>
      </td>
</tr>
<tr>
<td>
        AtlasEngine
      </td>
<td>
        ≤ 20 colors
      </td>
<td>
        0.6%
      </td>
<td>
        0.3%
      </td>
<td>
        21W
      </td>
<td>
        ≥60
      </td>
</tr>
<tr>
<td>
        AtlasEngine
      </td>
<td>
        ≥ 21 colors
      </td>
<td>
        0.6%
      </td>
<td>
        0.3%
      </td>
<td>
        21W
      </td>
<td>
        ≥60
      </td>
</tr>
</tbody>
</table>
<p>“DxEngine” is the internal name for our previous, Direct2D-based text renderer and “AtlasEngine” for the new renderer. According to these measurements the new renderer not just reduces CPU and GPU usage in general, but also makes it independent of the content that’s being drawn.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Direct2D implements text rendering using a built-in texture atlas to cache rasterized glyphs and a lookup-table for coloring those glyphs. The latter exists, because it reduces the computational cost of coloring glyphs, but unfortunately, as a trade-off, requires an upper limit of distinct colors it can hold at a time. Once you exceed this limit by drawing highly colored text, Direct2D is forced to remove some to make space for new ones, which can lead to an excessive amount of time being spent on updating the lookup-table, causing a steep drop in performance.</p>
<p>This issue isn’t much of a problem for most applications, since text is usually rather static, or doesn’t exceed the upper limit in the first place, but for Terminals we routinely see applications coloring their entire background in block characters, animating text at &gt;60 FPS, etc., where this starts to be a problem.</p>
<p>Our new renderer is specifically written with modern hardware in mind and exclusively supports drawing monospace text in a rectangular grid. The former allows us to take advantage of today’s GPUs with their performant calculations, good support for conditionals and branches and relatively large memories. That way we can safely increase performance by caching more data and perform glyph colorization without lookup-tables, despite the added computational cost. And by only supporting rectangular grids of monospace text, we’re able to dramatically simplify the implementation, offsetting the added computational cost and matching or even exceeding the performance and efficiency of our previous Direct2D-based renderer.</p>
<p>The initial implementation can be seen in pull request <a href="https://github.com/microsoft/terminal/pull/11623" rel="noreferrer noopener" target="_blank">#11623</a>. The pull request is quite complex, but the most relevant parts can be found in the <code>renderer/atlas</code> subdirectory. The “parser”, or “CPU-side” part of the engine, can be found inside <code>AtlasEngine.cpp</code> as <code>AtlasEngine::_flushBufferLine</code> and the pixel shader, or “GPU-side”, in <code>shader_ps.hlsl</code>.</p>
<p>Since then, several improvements have been added. The current state at the time of writing can be found <a href="https://github.com/microsoft/terminal/tree/ad2358dc35ccbf8d11d8cef83440c24d08f9d234/src/renderer/atlas" rel="noreferrer noopener" target="_blank">here</a>. It includes a gamma-correct implementation of Direct2D’s and DirectWrite’s text blending algorithm inside the 3 files named “dwrite”, as well as an implementation for ClearType blending as a GPU shader. An independent demonstration for this can be seen in the <a href="https://github.com/lhecker/dwrite-hlsl" rel="noreferrer noopener" target="_blank">dwrite-hlsl</a> demo project.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
