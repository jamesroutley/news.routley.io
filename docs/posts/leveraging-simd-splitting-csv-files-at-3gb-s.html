<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.tinybird.co/2021/12/14/simd/">Original</a>
    <h1>Leveraging SIMD: Splitting CSV Files at 3Gb/S</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content"> <div> <article itemscope="" itemtype="http://schema.org/BlogPosting">  <div id="post-content" itemprop="articleBody"> <h2 id="the-problem"> The problem <a href="#the-problem">¶</a> </h2> <p>When dealing with large files, for example files that don’t fit on RAM, splitting the file in chunks is a must.</p> <p>Some data formats like NDJSON can be trivially split, as all <code>\n</code> bytes are line separators. However, CSV can have newlines within quotes, which don’t indicate a new row, but a newline in the row’s field.</p> <p>There are two kinds of solutions to the problem of finding a splitting point in a CSV file:</p> <ul> <li>Read it. By simply reading the file, we can distinguish between <code>\n</code> bytes that are within quotes and the ones that aren’t, and that are points in which we can split the CSV. With encodings that preserve the ASCII code, like UTF-8, for the special characters we’ll be able to avoid extra state and code.</li> <li>Statistical solutions. By going directly to the point in which we want to split the file, and by reading some bytes around it, we can guess a good splitting point. This solution is naturally faster, as you need to process less bytes, but it can return wrong splitting points too.</li> </ul> <p>We decided to go with the first approach to favor correctness over speed. However, speed is very important to us, how much faster can we make it?</p> <h2 id="speed-wins"> Speed wins <a href="#speed-wins">¶</a> </h2> <p>Our first implementation was a python-based parser. We tested its correct behavior, but we certainly saw that performance with this approach was a no-go.</p> <h3 id="hello-c"> Hello, C <a href="#hello-c">¶</a> </h3> <p>Python performance can be very limitting, but the good thing about Python is that C code can be integrated easily on simple problems like this one.</p> <p>We ported the Python implementation to C and called it using CFFI. This single optimization, without any other improvement, increased performance by two orders of magnitude, reaching now the 1GB/s barrier.</p> <h3 id="simple-is-faster"> Simple is faster <a href="#simple-is-faster">¶</a> </h3> <p>We were quite happy about the 1GB/s initial implementation, but we knew we could do better. We started optimizing the algorithm. The first version was based on a single complex loop. The optimized version was simpler, and had a nested loop to deal with the quoted fields.</p> <p>Initial implementation.</p> <div><div><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td> <td><pre><span>while</span> <span>(</span><span>pos</span> <span>&lt;</span> <span>buffer_size</span><span>)</span> <span>{</span>

    <span>if</span> <span>(</span><span>buffer_text_encoded</span><span>[</span><span>pos</span><span>]</span> <span>==</span> <span>escapechar</span><span>)</span> <span>{</span>
        <span>next_special_char_found</span> <span>=</span> <span>escapechar</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>buffer_text_encoded</span><span>[</span><span>pos</span><span>]</span> <span>==</span> <span>new_line</span><span>)</span> <span>{</span>
        <span>next_special_char_found</span> <span>=</span> <span>new_line</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>buffer_text_encoded</span><span>[</span><span>pos</span><span>]</span> <span>==</span> <span>quotechar</span><span>)</span> <span>{</span>
        <span>next_special_char_found</span> <span>=</span> <span>quotechar</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>next_special_char_found</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>parsing_state</span> <span>==</span> <span>estate_normal</span> <span>&amp;&amp;</span> <span>next_special_char_found</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>pos</span> <span>=</span> <span>pos</span> <span>+</span> <span>1</span><span>;</span>
        <span>continue</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>next_special_char_found</span> <span>==</span> <span>escapechar</span> <span>||</span> <span>next_special_char_found</span> <span>==</span> <span>quotechar</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>parsing_state</span> <span>!=</span> <span>estate_possible_escape_found</span><span>)</span> <span>{</span>
            <span>state_previous_to_escape_char_found</span> <span>=</span> <span>parsing_state</span><span>;</span>
            <span>parsing_state</span> <span>=</span> <span>estate_possible_escape_found</span><span>;</span>
            <span>pos</span> <span>=</span> <span>pos</span> <span>+</span> <span>1</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>parsing_state</span> <span>=</span> <span>state_previous_to_escape_char_found</span><span>;</span>
            <span>pos</span> <span>=</span> <span>pos</span> <span>+</span> <span>1</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>parsing_state</span> <span>==</span> <span>estate_possible_escape_found</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>state_previous_to_escape_char_found</span> <span>==</span> <span>estate_normal</span><span>)</span> <span>{</span>
            <span>parsing_state</span> <span>=</span> <span>estate_quoted_text</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>parsing_state</span> <span>=</span> <span>estate_normal</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>parsing_state</span> <span>==</span> <span>estate_normal</span> <span>&amp;&amp;</span> <span>next_special_char_found</span> <span>==</span> <span>new_line</span><span>)</span> <span>{</span>
        <span>last_unescaped_new_line_found</span> <span>=</span> <span>pos</span><span>;</span>
        <span>pos</span> <span>=</span> <span>pos</span> <span>+</span> <span>1</span><span>;</span>
        <span>continue</span><span>;</span>
    <span>}</span>

    <span>pos</span> <span>=</span> <span>pos</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>Optimized implementation.</p> <div><div><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> <td><pre><span>for</span> <span>(</span><span>long</span> <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>buffer_size</span><span>;</span> <span>i</span><span>++</span><span>){</span>
    <span>if</span> <span>(</span><span>b</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>escapechar</span><span>){</span>
        <span>i</span><span>++</span><span>;</span>
        <span>continue</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>b</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>quotechar</span><span>){</span>
        <span>do</span><span>{</span>
            <span>i</span><span>++</span><span>;</span>
        <span>}</span> <span>while</span> <span>(((</span><span>b</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>quotechar</span><span>)</span> <span>||</span> <span>(</span><span>b</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>quotechar</span> <span>&amp;&amp;</span> <span>b</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>==</span> <span>escapechar</span><span>))</span> <span>&amp;&amp;</span> <span>i</span> <span>&lt;</span> <span>buffer_size</span><span>);</span>
        <span>continue</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>b</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
        <span>last_newline</span> <span>=</span> <span>i</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="simd"> SIMD <a href="#simd">¶</a> </h4> <p>This implementation was quite fast, but we still thought we could go a step further. This optimized version seemed very difficult to improve, as it just performed three quick comparisons per byte on the happy path.</p> <p>Improving the time it took to process each byte seemed almost impossible, and actually, we didn’t do that. Instead, we processesed multiple bytes per iteration.</p> <p>All modern x86 CPUs include SIMD instructions like SSE and AVX. These instructions allow the processor to work on multiple registers in parallel, improving throughput.</p> <p>This is how our last version looks like:</p> <div><div><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td> <td><pre><span>__m128i</span> <span>sse_newline</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;\n&#39;</span><span>);</span>
<span>__m128i</span> <span>sse_quotechar</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>quotechar</span><span>);</span>
<span>__m128i</span> <span>sse_escapechar</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>escapechar</span><span>);</span>
<span>int</span> <span>max_simd</span> <span>=</span> <span>buffer_size</span> <span>-</span> <span>16</span><span>;</span> <span>// avoid reading past the buffer end due to SIMD</span>
<span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>buffer_size</span><span>;</span> <span>i</span><span>++</span><span>){</span>
    <span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>max_simd</span><span>;</span> <span>i</span> <span>+=</span> <span>16</span><span>){</span>
        <span>// Load 16 bytes of the CSV in the SSE registers</span>
        <span>__m128i</span> <span>*</span><span>sse_p</span> <span>=</span> <span>(</span><span>__m128i</span> <span>*</span><span>)</span><span>&amp;</span><span>buffer</span><span>[</span><span>i</span><span>];</span>
        <span>__m128i</span> <span>sse_a</span> <span>=</span> <span>_mm_loadu_si128</span><span>(</span><span>sse_p</span><span>);</span>
        <span>// compare the 16 bytes to quotechar, and compact the result in the first 16 bits of mask_quoted</span>
        <span>int</span> <span>mask_quoted</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>_mm_cmpeq_epi8</span><span>(</span><span>sse_quotechar</span><span>,</span> <span>sse_a</span><span>));</span>
        <span>// compare against the newline</span>
        <span>int</span> <span>mask_newline</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>_mm_cmpeq_epi8</span><span>(</span><span>sse_newline</span><span>,</span> <span>sse_a</span><span>));</span>
        <span>int</span> <span>mask</span> <span>=</span> <span>mask_quoted</span> <span>|</span> <span>mask_newline</span><span>;</span>
        <span>if</span> <span>(</span><span>escapechar</span><span>){</span>
            <span>// compare against the escapechar</span>
            <span>mask</span> <span>|=</span> <span>_mm_movemask_epi8</span><span>(</span><span>_mm_cmpeq_epi8</span><span>(</span><span>sse_escapechar</span><span>,</span> <span>sse_a</span><span>));</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>mask</span> <span>!=</span> <span>0</span><span>){</span>
            <span>// there is at least one special character in the 16 bytes</span>
            <span>if</span> <span>(</span><span>mask</span> <span>==</span> <span>mask_quoted</span><span>){</span>
                <span>// the only special characters are quotes</span>
                <span>// we simply can count the number of quotes</span>
                <span>// the quoting state will change if this count is an odd number</span>
                <span>int</span> <span>quotes</span> <span>=</span> <span>__builtin_popcount</span><span>(</span><span>mask_quoted</span><span>);</span>
                <span>state</span> <span>=</span> <span>(</span><span>state</span> <span>+</span> <span>quotes</span><span>)</span> <span>%</span> <span>2</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>mask</span> <span>==</span> <span>mask_newline</span><span>)</span> <span>{</span>
                <span>// the only special characters are newlines</span>
                <span>if</span> <span>(</span><span>state</span> <span>==</span> <span>NORMAL</span><span>)</span> <span>{</span>
                    <span>// and we were outside quotes</span>
                    <span>// the last bit set to &#39;1&#39; in the mask indicates where the last line was found</span>
                    <span>last_new_line_found</span> <span>=</span> <span>i</span> <span>+</span> <span>(</span><span>31</span> <span>-</span> <span>__builtin_clz</span><span>(</span><span>mask</span><span>));</span>
                <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// there is a complex combination of special characters</span>
                <span>// however, we can advance `i` by the number of initial bits on the mask that are set</span>
                <span>// to &#39;0&#39;</span>
                <span>i</span> <span>+=</span> <span>__builtin_ctz</span><span>(</span><span>mask</span><span>);</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>buffer</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>quotechar</span><span>){</span>
        <span>state</span> <span>=</span> <span>!</span><span>state</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>state</span> <span>==</span> <span>NORMAL</span> <span>&amp;&amp;</span> <span>buffer</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
        <span>last_new_line_found</span> <span>=</span> <span>i</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>buffer</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>escapechar</span><span>)</span> <span>{</span>
        <span>i</span><span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>Used compiler intrinsics:</p> <ul> <li> <code>__m128i _mm_set1_epi8(unsigned char c)</code>. Returns a 16-byte SSE group of registers with all bytes filled with c.</li> <li> <code>__m128i _mm_loadu_si128(__m128i const* mem_addr)</code>. Returns a 16-byte SSE group of registers with bytes copied from <code>mem_addr</code>.</li> <li> <code>__m128i _mm_cmpeq_epi8 (__m128i a, __m128i b)</code>. Returns a 16-byte SSE group of registers, comparing for equality the bytes of <code>a</code> and <code>b</code>. Each returned byte is set to <code>0xFF</code> if the corresponding bytes of <code>a</code> and <code>b</code> are equal, <code>0</code> otherwise.</li> <li> <code>int _mm_movemask_epi8 (__m128i a)</code>. Compacts the 16 bytes of <code>a</code> by taking the most significand bit of each byte in <code>a</code>, returning a 16-bit sized mask.</li> <li> <code>int __builtin_popcount(unsigned int x)</code>. Counts the number of bits in <code>x</code> set to <code>1</code>.</li> <li> <code>int __builtin_clz(unsigned int x)</code>. Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.</li> <li> <code>int __builtin_ctz (unsigned int x)</code>. Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.</li> </ul> <p>See also <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movemask_epi8&amp;ig_expand=4335,910,908,4836" target="_blank" rel="noopener noreferrer">Intel’s</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" target="_blank" rel="noopener noreferrer">gcc’s</a> docs.</p> <p>This is certainly a more complex version, but thanks to SSE, it works at 3GB/s!</p> <p>Want to help us solve these problems? <a href="https://www.tinybird.co/about#join-us" target="_blank" rel="noopener noreferrer">Join us!</a></p> </div>  </article>  </div> </div></div>
  </body>
</html>
