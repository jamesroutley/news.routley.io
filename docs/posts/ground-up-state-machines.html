<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://miccah.io/posts/ground-up-state-machines.html">Original</a>
    <h1>Ground Up: State Machines</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    





<p>Welcome to a series of posts cleverly titled <strong><em>Ground Up</em></strong>,
where I explain computing concepts from the ground up! We’ll explore
how computers work starting with transistors and going from there.
This post specifically covers finite state machines.</p>

<ul>
  <li><a href="https://www.livescience.com/posts/ground-up-bits.html">Part 1: Bits</a></li>
  <li><a href="https://www.livescience.com/posts/ground-up-gates.html">Part 2: Gates</a></li>
  <li><a href="https://www.livescience.com/posts/ground-up-memory.html">Part 3: Memory</a></li>
  <li><strong><em>Part 4: State Machines</em></strong></li>
</ul>

<h2 id="state-machines">State Machines</h2>
<p>Finite state machines (FSMs) are a way to model solutions to problems. It
describes the system as a machine that changes state in reaction to
inputs to produce the appropriate outputs. There are two common types of
finite state machines: <strong>Moore</strong> machines and <strong>Mealy</strong> machines. Moore
machines define the outputs soley on the current state, while Mealy
machines define the outputs on the current state <em>and</em> input values.</p>

<p>FSMs are used in a variety of useful products and services, such as
combination locks, traffic lights, and elevators. Even part of a CPU
uses a finite state machine for parsing and executing instructions,
which is why we are learning about them.</p>

<h2 id="multiplexers">Multiplexers</h2>
<p>There is one important logic gate missing from our tool belt that will
be very helpful in implementing a FSM: the multiplexer (MUX). I will leave
the implementation details as an exercise to the reader and simply provide
the truth table and schematic symbol.</p>

<div>
<table>
  <thead>
    <tr>
      <th>A</th>
      <th>B</th>
      <th>S<sub>0</sub></th>
      <th>Z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>X</code></td>
      <td><code>X</code></td>
      <td><code>0</code></td>
      <td><code>A</code></td>
    </tr>
    <tr>
      <td><code>X</code></td>
      <td><code>X</code></td>
      <td><code>1</code></td>
      <td><code>B</code></td>
    </tr>
  </tbody>
</table>
<p><img src="https://www.livescience.com/assets/kb/gates/MUX.svg"/>
</p></div>

<p>Essentially, the output <strong>Z</strong> is set to <strong>A</strong> if <strong>S<sub>0</sub></strong> is <code>0</code> and <strong>B</strong> if <strong>S<sub>0</sub></strong> is <code>1</code>.</p>

<h2 id="designing-a-fsm">Designing a FSM</h2>
<p>At this point in our journey, we have enough components to build a state
machine circuit. We can store the current state in memory and use logic
gates to determine the outputs.  In this post, we will make a combination
lock, where the user must input three numbers in the correct order to
unlock the lock.</p>

<p><img src="https://www.livescience.com/assets/ground-up/lock.png" alt="lock-fsm"/></p>

<p>This FSM is a Moore machine with 4 states: <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and
<strong>Unlock</strong>. The text on the arrows are known as state transitions.
The diagram describes what happens when an input is received in each
state. Notice that the correct combination is <code>301</code> to reach the
<strong>Unlock</strong> state. There is also a <em>Reset</em> input that will immediately
reset the machine to the initial state.</p>

<p><strong>Note:</strong> <code>!x</code> in the diagram indicates negation. It is a short-hand that
means any input besides <code>x</code>.</p>

<p>Because this is a Moore machine, we must define the output as a function
of the state. We only have one output: <em>Locked</em>.</p>

<table>
  <thead>
    <tr>
      <th>Current State</th>
      <th>Locked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>A</strong></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><strong>B</strong></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><strong>C</strong></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><strong>Unlock</strong></td>
      <td><code>0</code></td>
    </tr>
  </tbody>
</table>

<h2 id="implementing-a-fsm">Implementing a FSM</h2>
<p>Now comes the technical nitty-gritty part. We need to build the FSM
with the building blocks we have. We have four states that we need to
remember, which can be encoded in two bits (<code>00</code> <code>01</code> <code>10</code> <code>11</code>). We
will need a few button inputs as well: <code>0</code> <code>1</code> <code>2</code> <code>3</code> and <code>Reset</code>. Let’s
make a truth table to help visualize the state transitions.</p>

<table>
  <thead>
    <tr>
      <th>S</th>
      <th>B<sub>0</sub></th>
      <th>B<sub>1</sub></th>
      <th>B<sub>2</sub></th>
      <th>B<sub>3</sub></th>
      <th>R</th>
      <th> </th>
      <th>S’</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>A</strong></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td><code>1</code></td>
      <td><code>0</code></td>
      <td> </td>
      <td><strong>B</strong></td>
    </tr>
    <tr>
      <td><strong>A</strong></td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td> </td>
      <td><strong>A</strong></td>
    </tr>
    <tr>
      <td><strong>B</strong></td>
      <td><code>1</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td> </td>
      <td><strong>C</strong></td>
    </tr>
    <tr>
      <td><strong>B</strong></td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td> </td>
      <td><strong>A</strong></td>
    </tr>
    <tr>
      <td><strong>C</strong></td>
      <td><code>0</code></td>
      <td><code>1</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td><code>0</code></td>
      <td> </td>
      <td><strong>Unlock</strong></td>
    </tr>
    <tr>
      <td><strong>C</strong></td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td> </td>
      <td><strong>A</strong></td>
    </tr>
    <tr>
      <td><strong>Unlock</strong></td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td><code>0</code></td>
      <td> </td>
      <td><strong>Unlock</strong></td>
    </tr>
    <tr>
      <td><strong>Unlock</strong></td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td>_</td>
      <td><code>1</code></td>
      <td> </td>
      <td><strong>A</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Note:</strong> <code>_</code> indicates “do not care” and was chosen instead of <code>X</code>
to reduce clutter.</p>

<p>The last puzzle piece is to think about the timing. How will we determine
when a button is pressed or not to advance the state? I think the simplest
solution is to <strong>OR</strong> all the input buttons together to determine when a button
is pressed, so let’s go with that.</p>

<p>Instructions: toggle the inputs to see how the circuit reacts.</p>

<div>
<div>
<table id="lockTable">
    <tbody><tr>
        <th><label>B<sub>0</sub></label></th>
        <th><label>B<sub>1</sub></label></th>
        <th><label>B<sub>2</sub></label></th>
        <th><label>B<sub>3</sub></label></th>
        <th><label>R</label></th>
        <th>S</th>
        <th>Locked</th>
    </tr>
    <tr>
        <td><code>0</code></td>
        <td><code>0</code></td>
        <td><code>0</code></td>
        <td><code>0</code></td>
        <td><code>0</code></td>
        <td><code>A</code></td>
        <td><code>1</code></td>
    </tr>
</tbody></table>
</div>


<canvas id="lock" resize=""></canvas>
</div>

<h2 id="conclusion">Conclusion</h2>
<p>Using boolean logic and a bit of memory, we were able to create a simple
finite state machine. We utilized a multiplexer to switch between the input
combinations based on the current state in order to determine the next state.
FSMs deterministically model solutions to problems in a manageable way,
and are a very useful concept in both hardware and software domains.</p>

<p>As always if any parts were unclear, please feel free to contact me.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
