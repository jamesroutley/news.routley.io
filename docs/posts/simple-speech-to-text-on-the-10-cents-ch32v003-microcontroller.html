<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/brian-smith-github/ch32v003_stt">Original</a>
    <h1>Simple Speech-to-Text on the &#39;10 Cents&#39; CH32V003 Microcontroller</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This program will read audio from an analog microphone
and distinguish between the spoken digits &#39;zero&#39; to &#39;nine&#39;,
logging the results over a serial link.</p>
<p dir="auto">I use a MAX4466 electret microphone amplifier board connected to
a CH32V003 development board, along with a WCH-LinkE adaptor for both programming
the chip and acting as a UART-to-USB converter to read the output.</p>

<p dir="auto">The code is based on the excellent <a href="https://github.com/cnlohr/ch32v003fun">ch32v003fun</a>
library, and should be compiled in a similar way to the examples there.
(i.e. this directory should be added to the &#39;examples/&#39; directory
alongside the others)</p>

<table>
<thead>
<tr>
<th>Link-E Adaptor</th>
<th>CH32V003 Dev Board</th>
</tr>
</thead>
<tbody>
<tr>
<td>3V3</td>
<td>VCC</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>SWDIO/TMS</td>
<td>PD1</td>
</tr>
<tr>
<td>RX</td>
<td>PD5</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>MAX4466 Microphone</td>
<td>CH32V003 Dev Board</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>VCC</td>
<td>VCC</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>OUT</td>
<td>PD4</td>
</tr>
</tbody>
</table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/brian-smith-github/ch32v003_stt/blob/main/ch32v003_with_max4466_mic.jpg"><img src="https://github.com/brian-smith-github/ch32v003_stt/raw/main/ch32v003_with_max4466_mic.jpg" alt="test"/></a></p>

<p dir="auto">I&#39;m getting about 90% accuracy identifying spoken digits with the code
as it stands. As with all R&amp;D, there&#39;s always scope for improvement.</p>

<p dir="auto">In training/ there is a stripped-down ch32v003 program to just dump
8-bit raw audio samples over the serial link, and a desktop-linux program
to read that data and do training of spoken words, simulating the
integer-pipeline used in the main code for the audio processing.</p>
<p dir="auto">In misc/ are C programs that generate:</p>
<ul dir="auto">
<li>the FFT &#39;twiddles&#39; integer sin/cos tables used in the FFT function
(twiddles_RES13.h)</li>
<li>the FFT-to-Mel matrix, (mel_mx.h)</li>
<li>the discrete-cosine-transform matrix  (dctm_20x8_8bit.h)</li>
<li>the  codebook.h spoken-numbers codebook. (codebook.h)</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto">Only have 16K storage and 2K RAM available, not much room for lookup tables,
codebooks and matrices for processing. (the binary is currenty about 10K)</p>
</li>
<li>
<p dir="auto">The ADC on the CH32V003 is only 10-bit as opposed to the usual 16-bit
(or even 12-bit) minimum for good quality audio.
This is compensated for somewhat  by 8x oversampling/averaging.
I can feed the sampled audio into the &#39;Whisper&#39; STT application
and get accurate general transcription done, so the quality is certainly
&#39;good enough&#39;.</p>
</li>
<li>
<p dir="auto">No I2S support so using a higher-quality digital microphone is not an option.</p>
</li>
<li>
<p dir="auto">No floating-point support, all code must use integer/fixed-point math</p>
</li>
<li>
<p dir="auto">No hardware-multiply or hardware-divide - so audio processing routines have
to be lean and fast to run within the 48MHz / 100fps timing constraints</p>
</li>
</ul>

<p dir="auto">The code uses traditional (allbeit pared down)  MFCC feature extraction,
and simply compares buffered tensors of samples against pre-recorded
spoken digits to get a &#39;best match&#39;.</p>
<p dir="auto">A timer is set up to generate an interrupt around 50,000/sec. On receiving
an interrupt, the ADC is read and the next sample convertion started.
8 consecutive samples are averaged to generate a ~6400 samples/sec audio stream.</p>
<p dir="auto">Every 64 samples (10ms), a 128-wide FFT of a buffer of the last 128 samples is
performed and 20 mel-scale frequency bins are calculated from that. The
mel bin energies  are converted to log2-scale.
Finally an 8-bin cepstrum is calculated via a DCT of the 20 log-mel bins.</p>
<p dir="auto">When the &#39;energy&#39; of a frame (sum of all mel levels) is above a threshold, it is added to a &#39;word&#39;
buffer, otherwise a count of &#39;silence&#39; frames is increased.</p>
<p dir="auto">When enough &#39;silence&#39; frames have passed to signify the end of a spoken
sample, its length is warped to exactly 16 frames and compared to a
lookup table of previously stored word samples, and the closest match
is reported.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">How it compares to more common speech-to-text systems</h2><a id="user-content-how-it-compares-to-more-common-speech-to-text-systems" aria-label="Permalink: How it compares to more common speech-to-text systems" href="#how-it-compares-to-more-common-speech-to-text-systems"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>
<p dir="auto">Usually 16,000 samples/sec audio is used (high fidelity), however to
reduce the audio processing required, only 6400 samples/sec audio is used here.
This is still high enough quality for accurate transcription
(the top speech formants are at around 3200Hz, everything above that is redundant
in terms of recognition).
This makes each 10ms slice of audio exactly 64 samples.</p>
</li>
<li>
<p dir="auto">Heavy pre-emphasis used (1.0 i.e. subtract the previous sample from
the current one. This mostly removes spectral tilt, and completely removes
any DC level in the signal.</p>
</li>
<li>
<p dir="auto">20ms frames are used, compared to 25ms found elsewhere (Vosk,Whisper).  Standard 10ms
step/100fps processing is maintained though. This allows for 128-sample FFT
to be used - FFT alogrithm is optimal at power-of-2 widths, and potentially would
allow for 100% faster FFT by taking advantage of the symmetry of the algo.
The narrow-framesize is compensated for by:</p>
</li>
<li>
<p dir="auto">no windowing used. Usually the signal has a Hann window applied to  the signal before FFT, this step is skipped to avoid &#39;bookending&#39; the  narrow signal.
Not windowing raises the noise-floor of the FFT output, but noise-floor removal
of the output mel bins is done to compensate.</p>
</li>
<li>
<p dir="auto">Only 20 mel bins calculated. Usually 40 (Vosk) or even 80 mel-scale bins
(Whisper) are used these days.</p>
</li>
<li>
<p dir="auto">extreme (probably overly so) compression via DCT to 8 cepstrum bins to
minimise the final frame dimensions.</p>
</li>
</ul>

<p dir="auto">Maybe the basis for a low-complexity/low-power/low-cost/always-on wakeword engine?</p>

<p dir="auto">New versions of the CH32 line of chips is due soon, improving the ADC to 12-bit and adding hardware-multiply instructions which would speed up the FFT and
matrix-multiply routines in the code significantly, and improve
accuracy in the processing.</p>

<p dir="auto">I dunno, I like a challenge. ðŸ˜€  Doing something traditionally associated with
high-end processing on a 10-cent low-end microcontroller is always going to be
a stretch.</p>
</article></div></div>
  </body>
</html>
