<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://varun.ca/metaballs/">Original</a>
    <h1>Metaballs (2017)</h1>
    
    <div id="readability-page-1" class="page"><article><header><time datetime="2017-10-16T00:00:00.000Z" color="neutral.2" font-size="1" font-family="systemSans">16th October, 2017</time></header><p font-family="systemSans" color="neutral.0" font-size="2,3">Metaballs, not to be confused with meatballs, are organic looking squishy gooey blobs. From a mathematical perspective they are an iso-surface. They are rendered using equations such as <code>f(x,y,z) = r / ((x - x<sub>0</sub>)<sup>2</sup> + (y - y<sub>0</sub>)<sup>2</sup> + (z - z<sub>0</sub>)<sup>2</sup>)</code>. Jamie Wong has a fantastic <a href="http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">tutorial</a> on rendering metaballs with canvas.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">We can replicate the metaball effect using CSS &amp; SVG by applying both <a href="https://css-tricks.com/shape-blobbing-css/" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">blur and contrast filters</a> to an element. For example in Chris Gannon‚Äôs Bubble Slider below.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">I discovered another approach to creating this metaball effect from <a href="http://paperjs.org/examples/meta-balls" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Paper.js examples</a>. Back in the days of Scriptographer <a href="http://shspage.com" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Hiroyuki Sato</a> created a script for generating gooey blobs in Adobe Illustrator. Unlike the previous techniques this does not render pixels or rely on filters. Instead it connects two circles with a membrane. Which means that the we can generate the entire blob as a path. For the Amoeba CodePen I followed exactly this technique.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">In this blog post I am going break down the steps required to generate the metaball. We are going to go through a function called <code>metaball</code> which generates the black shaded path that you see below. This consists of the connector plus a part of the second circle.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">To figure out where the connector touches the two circles we start by locating two tangents that touch both circles. This is the widest the connector can be. BTW I‚Äôm focusing on the case when the circles are not overlapping first.</p><svg height="200" width="100%" preserveAspectRatio="xMidYMid slice" viewBox="0 0 1200 1200"><g fill="none" stroke="#333" stroke-width="6"><circle cx="487.5" cy="600" r="96"></circle><circle cx="712.5" cy="600" r="72"></circle></g><g stroke-width="8"><g stroke="#5E2CA5"><path d="M497.74 695.452L720.18 671.589"></path><path d="M497.74 504.548L720.18 528.411"></path><path d="M0 0L0 0"></path><path d="M0 0L0 0"></path></g><g fill="#fff" stroke="#FF41B4"><circle cx="497.74" cy="695.452" r="8"></circle><circle cx="497.74" cy="504.548" r="8"></circle><circle cx="720.18" cy="671.589" r="8"></circle><circle cx="720.18" cy="528.411" r="8"></circle></g></g></svg><p font-family="systemSans" color="neutral.0" font-size="2,3">We can calculate the maximum angle of spread using:</p><div data-language="js"><pre><code><span>const</span> maxSpread <span>=</span> Math<span>.</span><span>acos</span><span>(</span><span>(</span>radius1 <span>-</span> radius2<span>)</span> <span>/</span> d<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">Why? This took me a while to figure out. I could attempt to explain here, but you are probably better of seeing the step-by-step illustration in this <a href="http://www.mathopenref.com/consttangentsext.html" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">external tangents to two given circles</a> guide.</p><svg height="200" width="100%" font-family="code" preserveAspectRatio="xMidYMid slice" viewBox="0 0 1200 1200"><g fill="none" stroke="#333" stroke-width="6"><circle cx="487.5" cy="600" r="96"></circle><circle cx="712.5" cy="600" r="72"></circle></g><path fill="#fff" d="M495 585H615V615H495z"></path><text x="500" y="605" font-size="20">max-spread</text><g stroke-width="8"><g stroke="#5E2CA5" stroke-linecap="round"><path d="M497.74 695.452L720.18 671.589"></path><path d="M497.74 504.548L720.18 528.411"></path><path d="M487.5 600L497.74 695.452"></path><path d="M487.5 600L497.74 504.548"></path></g><g fill="#fff" stroke="#FF41B4"><circle cx="497.74" cy="695.452" r="8"></circle><circle cx="497.74" cy="504.548" r="8"></circle><circle cx="720.18" cy="671.589" r="8"></circle><circle cx="720.18" cy="528.411" r="8"></circle></g></g></svg><p font-family="systemSans" color="neutral.0" font-size="2,3">This is the maximum possible spread that the connector can have. We can control spread amount by multiplying it with a factor called <code>v</code>. The Paper.js code has <code>v = 0.5</code>. That seems to work well.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The spread for the smaller circle is <code>(Math.PI - maxSpread) * v</code>. This is because the sum of the opposite angles of a polygon is 180¬∞.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Next we need to find the location of those four points. We know the centre of the circles (<code>center1</code> &amp; <code>center2</code>) and the radii (<code>radius1</code> &amp; <code>radius2</code>). Therefore, we will only be dealing in terms of angles and then use polar coordinates to convert it into <code>(x, y)</code> values later.</p><div data-language="js"><pre><code><span>const</span> angleBetweenCenters <span>=</span> <span>angle</span><span>(</span>center2<span>,</span> center1<span>)</span><span>;</span>
<span>const</span> maxSpread <span>=</span> Math<span>.</span><span>acos</span><span>(</span><span>(</span>radius1 <span>-</span> radius2<span>)</span> <span>/</span> d<span>)</span><span>;</span>


<span>const</span> angle1 <span>=</span> angleBetweenCenters <span>+</span> maxSpread <span>*</span> v<span>;</span>
<span>const</span> angle2 <span>=</span> angleBetweenCenters <span>-</span> maxSpread <span>*</span> v<span>;</span>

<span>const</span> angle3 <span>=</span> angleBetweenCenters <span>+</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>)</span><span>;</span>
<span>const</span> angle4 <span>=</span> angleBetweenCenters <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">The angles need to be measured clockwise. Therefore, for the second circle we take that into account by subtracting from <code>Math.PI</code>. We add <code>angleBetweenCenters</code> to all because the circles can be moving diagonally too. Then convert polar coords to cartesian.</p><div data-language="js"><pre><code>
<span>const</span> p1 <span>=</span> <span>getVector</span><span>(</span>center1<span>,</span> angle1<span>,</span> radius1<span>)</span><span>;</span>
<span>const</span> p2 <span>=</span> <span>getVector</span><span>(</span>center1<span>,</span> angle2<span>,</span> radius1<span>)</span><span>;</span>
<span>const</span> p3 <span>=</span> <span>getVector</span><span>(</span>center2<span>,</span> angle3<span>,</span> radius2<span>)</span><span>;</span>
<span>const</span> p4 <span>=</span> <span>getVector</span><span>(</span>center2<span>,</span> angle4<span>,</span> radius2<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">To convert the trapezium shaped connector into a curved one we need to add handles to all four points. The next part of the process is to figure out the location of the handles.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The handle for a particular point should be aligned to the tangent to the circle at that point. Again we‚Äôll use polar coords to locate the handle. This time however, it will be relative to the point itself.</p><svg height="200" width="100%" font-family="code" font-weight="bold" preserveAspectRatio="xMidYMid slice" viewBox="0 0 1200 1200"><g fill="#fff" stroke="#aaa" stroke-width="6"><circle cx="487.5" cy="600" r="96"></circle><circle cx="712.5" cy="600" r="64" stroke="none"></circle><path d="M560.049 662.87c49.574-44.91 73.566-39.439 110.538-14.504a64 64 0 100-96.732c-36.972 24.935-60.964 30.406-110.538-14.504"></path></g><path fill="#fff" stroke="#aaa" stroke-dasharray="5, 5" stroke-width="4" d="M540 600a25 25 0 00-16.225-31.435L487.5 600z"></path><g stroke-width="8"><g stroke="#5E2CA5"><path d="M560.049 537.13L609.623 582.04"></path><path stroke="#A463F2" d="M560.049 537.13L487.5 600"></path><path stroke="#aaa" stroke-dasharray="5, 5" stroke-width="4" d="M300 600L900 600"></path></g><g fill="#fff" stroke="#FF41B4"><circle cx="487.5" cy="600" r="8" stroke="#FFA3D7"></circle><circle cx="560.049" cy="537.13" r="8"></circle><circle cx="609.623" cy="582.04" r="8"></circle></g></g><g font-size="40"><text x="450" y="615">A</text><text x="575" y="530">B</text><text x="625" y="600">C</text><text x="500" y="620" font-size="20">angle 1</text></g></svg><p font-family="systemSans" color="neutral.0" font-size="2,3">The lines AB and BC are perpendicular because AB is radial and BC is a tangent to the circle. Therefore, the angle for the handle 1 is <code>angle1 - Math.PI / 2</code>. Similarly we can calculate the angles for the other three handles.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The length of the handle is relative to the radius of the circle they originate from times the factor <code>d2</code>. For example, the length of handle 1 is <code>radius1 * d2</code>. We can now calculate the location of the handles like so:</p><div data-language="js"><pre><code><span>const</span> totalRadius <span>=</span> radius1 <span>+</span> radius2<span>;</span>

<span>const</span> d2 <span>=</span> Math<span>.</span><span>min</span><span>(</span>v <span>*</span> handleSize<span>,</span> <span>dist</span><span>(</span>p1<span>,</span> p3<span>)</span> <span>/</span> totalRadius<span>)</span><span>;</span>

<span>const</span> r1 <span>=</span> radius1 <span>*</span> d2<span>;</span>
<span>const</span> r2 <span>=</span> radius2 <span>*</span> d2<span>;</span>

<span>const</span> h1 <span>=</span> <span>getVector</span><span>(</span>p1<span>,</span> angle1 <span>-</span> <span>HALF_PI</span><span>,</span> r1<span>)</span><span>;</span>
<span>const</span> h2 <span>=</span> <span>getVector</span><span>(</span>p2<span>,</span> angle2 <span>+</span> <span>HALF_PI</span><span>,</span> r1<span>)</span><span>;</span>
<span>const</span> h3 <span>=</span> <span>getVector</span><span>(</span>p3<span>,</span> angle3 <span>+</span> <span>HALF_PI</span><span>,</span> r2<span>)</span><span>;</span>
<span>const</span> h4 <span>=</span> <span>getVector</span><span>(</span>p4<span>,</span> angle4 <span>-</span> <span>HALF_PI</span><span>,</span> r2<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">We have all the points üôåüèΩ Time to construct the SVG path. The path is made of three sections: curve from <code>point 1</code> to <code>point 3</code>, arc of <code>radius2</code> from <code>point 3</code> to <code>point 4</code> and curve from <code>point 4</code> to <code>point 2</code>.</p><div data-language="js"><pre><code><span>function</span> <span>metaballToPath</span><span>(</span><span>p1<span>,</span> p2<span>,</span> p3<span>,</span> p4<span>,</span> h1<span>,</span> h2<span>,</span> h3<span>,</span> h4<span>,</span> escaped<span>,</span> r</span><span>)</span> <span>{</span>
  <span>return</span> <span>[</span>
    <span>&#39;M&#39;</span><span>,</span> p1<span>,</span>
    <span>&#39;C&#39;</span><span>,</span> h1<span>,</span> h3<span>,</span> p3<span>,</span>
    <span>&#39;A&#39;</span><span>,</span> r<span>,</span> r<span>,</span> <span>0</span><span>,</span> escaped <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>,</span> <span>0</span><span>,</span> p4<span>,</span>
    <span>&#39;C&#39;</span><span>,</span> h4<span>,</span> h2<span>,</span> p2<span>,</span>
  <span>]</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><h3 id="circle-overlap" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#circle-overlap" aria-label="circle overlap permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Circle Overlap</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">We have a gooey metaball! But you‚Äôll notice that path gets all weird and twisty when the circles start to overlapping. We are going to fix this by expanding the spread in proportion to how much the circles are overlapping.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The spread expansion will be controlled using the angles <code>u1</code> and <code>u2</code>. We can calculate these using the <a href="https://en.wikipedia.org/wiki/Law_of_cosines" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">law of cosines</a>.</p><p height="200"><svg height="200" width="100%" font-family="code" font-weight="bold" preserveAspectRatio="xMidYMid slice" transform="scale(1.5)" viewBox="0 0 1200 1200"><g fill="none" stroke="#aaa" stroke-width="4"><circle cx="487.5" cy="600" r="96"></circle><circle cx="630" cy="600" r="64"></circle></g><g stroke-width="4"><g stroke="#A463F2"><path d="M630 600L487.5 600"></path><path d="M487.5 600L577 562"></path><path d="M577 562L630 600"></path></g><g fill="#fff" stroke="#FF41B4"><circle cx="487.5" cy="600" r="4"></circle><circle cx="630" cy="600" r="4"></circle><circle cx="577" cy="562" r="4"></circle></g></g><g font-size="20"><text x="450" y="575">radius1</text><text x="575" y="620">d</text><text x="625" y="575">radius2</text><text x="525" y="595" font-size="15">u1</text><text x="590" y="595" font-size="15">u2</text></g></svg></p><div data-language="js"><pre><code>u1 <span>=</span> Math<span>.</span><span>acos</span><span>(</span>
  <span>(</span>radius1 <span>*</span> radius1 <span>+</span> d <span>*</span> d <span>-</span> radius2 <span>*</span> radius2<span>)</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> radius1 <span>*</span> d<span>)</span>
<span>)</span><span>;</span>

u2 <span>=</span> Math<span>.</span><span>acos</span><span>(</span>
  <span>(</span>radius2 <span>*</span> radius2 <span>+</span> d <span>*</span> d <span>-</span> radius1 <span>*</span> radius1<span>)</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> radius2 <span>*</span> d<span>)</span>
<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">But what shall we do with these ü§î To be honest I‚Äôm not entirely sure how this works. What I do know is that it expands the spread as the circles get closer and then collapses it once circle 2 is completely inside circle 1.</p><div data-language="js"><pre><code><span>const</span> angle1 <span>=</span> angleBetweenCenters <span>+</span> u1 <span>+</span> <span>(</span>maxSpread <span>-</span> u1<span>)</span> <span>*</span> v<span>;</span>
<span>const</span> angle2 <span>=</span> angleBetweenCenters <span>-</span> <span>(</span>u1 <span>+</span> <span>(</span>maxSpread <span>-</span> u1<span>)</span> <span>*</span> v<span>)</span><span>;</span>
<span>const</span> angle3 <span>=</span>
  angleBetweenCenters <span>+</span> Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>;</span>
<span>const</span> angle4 <span>=</span>
  angleBetweenCenters <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">And one final change to account for overlapping circles. The length of the handles will also be proportional to the distance between the circles.</p><div data-language="js"><pre><code>
<span>const</span> totalRadius <span>=</span> radius1 <span>+</span> radius2<span>;</span>
<span>const</span> d2Base <span>=</span> Math<span>.</span><span>min</span><span>(</span>v <span>*</span> handleSize<span>,</span> <span>dist</span><span>(</span>p1<span>,</span> p3<span>)</span> <span>/</span> totalRadius<span>)</span><span>;</span>

<span>const</span> d2 <span>=</span> d2Base <span>*</span> Math<span>.</span><span>min</span><span>(</span><span>1</span><span>,</span> <span>(</span>d <span>*</span> <span>2</span><span>)</span> <span>/</span> <span>(</span>radius1 <span>+</span> radius2<span>)</span><span>)</span><span>;</span>

<span>const</span> r1 <span>=</span> radius1 <span>*</span> d2<span>;</span>
<span>const</span> r2 <span>=</span> radius2 <span>*</span> d2<span>;</span></code></pre></div><h2 id="conclusion" font-family="systemSans" color="neutral.0" font-size="4,5" font-weight="7"><a href="#conclusion" aria-label="conclusion permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Conclusion</h2><p font-family="systemSans" color="neutral.0" font-size="2,3">And here is the final result and the entire code snippet for <code>metaball</code>. Try forking it and playing around with different values of <code>handleSize</code> and <code>v</code>. See how they impact the shape of the connector. There are so many amazing little details in these 70 lines of code. Fascinating work by Hiroyuki Sato. I learnt so much from it!</p><div data-language="js"><pre><code>
<span>function</span> <span>metaball</span><span>(</span>
  <span>radius1<span>,</span>
  radius2<span>,</span>
  center1<span>,</span>
  center2<span>,</span>
  handleSize <span>=</span> <span>2.4</span><span>,</span>
  v <span>=</span> <span>0.5</span></span>
<span>)</span> <span>{</span>
  <span>const</span> <span>HALF_PI</span> <span>=</span> Math<span>.</span><span>PI</span> <span>/</span> <span>2</span><span>;</span>
  <span>const</span> d <span>=</span> <span>dist</span><span>(</span>center1<span>,</span> center2<span>)</span><span>;</span>
  <span>const</span> maxDist <span>=</span> radius1 <span>+</span> radius2 <span>*</span> <span>2.5</span><span>;</span>
  <span>let</span> u1<span>,</span> u2<span>;</span>

  
  
  
  <span>if</span> <span>(</span>
    radius1 <span>===</span> <span>0</span> <span>||</span>
    radius2 <span>===</span> <span>0</span> <span>||</span>
    d <span>&gt;</span> maxDist <span>||</span>
    d <span>&lt;=</span> Math<span>.</span><span>abs</span><span>(</span>radius1 <span>-</span> radius2<span>)</span>
  <span>)</span> <span>{</span>
    <span>return</span> <span>&#39;&#39;</span><span>;</span>
  <span>}</span>

  
  <span>if</span> <span>(</span>d <span>&lt;</span> radius1 <span>+</span> radius2<span>)</span> <span>{</span>
    u1 <span>=</span> Math<span>.</span><span>acos</span><span>(</span>
      <span>(</span>radius1 <span>*</span> radius1 <span>+</span> d <span>*</span> d <span>-</span> radius2 <span>*</span> radius2<span>)</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> radius1 <span>*</span> d<span>)</span>
    <span>)</span><span>;</span>
    u2 <span>=</span> Math<span>.</span><span>acos</span><span>(</span>
      <span>(</span>radius2 <span>*</span> radius2 <span>+</span> d <span>*</span> d <span>-</span> radius1 <span>*</span> radius1<span>)</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> radius2 <span>*</span> d<span>)</span>
    <span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    
    u1 <span>=</span> <span>0</span><span>;</span>
    u2 <span>=</span> <span>0</span><span>;</span>
  <span>}</span>

  
  <span>const</span> angleBetweenCenters <span>=</span> <span>angle</span><span>(</span>center2<span>,</span> center1<span>)</span><span>;</span>
  <span>const</span> maxSpread <span>=</span> Math<span>.</span><span>acos</span><span>(</span><span>(</span>radius1 <span>-</span> radius2<span>)</span> <span>/</span> d<span>)</span><span>;</span>
  
  <span>const</span> angle1 <span>=</span> angleBetweenCenters <span>+</span> u1 <span>+</span> <span>(</span>maxSpread <span>-</span> u1<span>)</span> <span>*</span> v<span>;</span>
  <span>const</span> angle2 <span>=</span> angleBetweenCenters <span>-</span> u1 <span>-</span> <span>(</span>maxSpread <span>-</span> u1<span>)</span> <span>*</span> v<span>;</span>
  <span>const</span> angle3 <span>=</span>
    angleBetweenCenters <span>+</span> Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>;</span>
  <span>const</span> angle4 <span>=</span>
    angleBetweenCenters <span>-</span> Math<span>.</span><span>PI</span> <span>+</span> u2 <span>+</span> <span>(</span>Math<span>.</span><span>PI</span> <span>-</span> u2 <span>-</span> maxSpread<span>)</span> <span>*</span> v<span>;</span>

  
  <span>const</span> p1 <span>=</span> <span>getVector</span><span>(</span>center1<span>,</span> angle1<span>,</span> radius1<span>)</span><span>;</span>
  <span>const</span> p2 <span>=</span> <span>getVector</span><span>(</span>center1<span>,</span> angle2<span>,</span> radius1<span>)</span><span>;</span>
  <span>const</span> p3 <span>=</span> <span>getVector</span><span>(</span>center2<span>,</span> angle3<span>,</span> radius2<span>)</span><span>;</span>
  <span>const</span> p4 <span>=</span> <span>getVector</span><span>(</span>center2<span>,</span> angle4<span>,</span> radius2<span>)</span><span>;</span>

  
  <span>const</span> totalRadius <span>=</span> radius1 <span>+</span> radius2<span>;</span>
  <span>const</span> d2Base <span>=</span> Math<span>.</span><span>min</span><span>(</span>v <span>*</span> handleSize<span>,</span> <span>dist</span><span>(</span>p1<span>,</span> p3<span>)</span> <span>/</span> totalRadius<span>)</span><span>;</span>
  
  <span>const</span> d2 <span>=</span> d2Base <span>*</span> Math<span>.</span><span>min</span><span>(</span><span>1</span><span>,</span> <span>(</span>d <span>*</span> <span>2</span><span>)</span> <span>/</span> <span>(</span>radius1 <span>+</span> radius2<span>)</span><span>)</span><span>;</span>

  
  <span>const</span> r1 <span>=</span> radius1 <span>*</span> d2<span>;</span>
  <span>const</span> r2 <span>=</span> radius2 <span>*</span> d2<span>;</span>

  
  <span>const</span> h1 <span>=</span> <span>getVector</span><span>(</span>p1<span>,</span> angle1 <span>-</span> <span>HALF_PI</span><span>,</span> r1<span>)</span><span>;</span>
  <span>const</span> h2 <span>=</span> <span>getVector</span><span>(</span>p2<span>,</span> angle2 <span>+</span> <span>HALF_PI</span><span>,</span> r1<span>)</span><span>;</span>
  <span>const</span> h3 <span>=</span> <span>getVector</span><span>(</span>p3<span>,</span> angle3 <span>+</span> <span>HALF_PI</span><span>,</span> r2<span>)</span><span>;</span>
  <span>const</span> h4 <span>=</span> <span>getVector</span><span>(</span>p4<span>,</span> angle4 <span>-</span> <span>HALF_PI</span><span>,</span> r2<span>)</span><span>;</span>

  
  <span>return</span> <span>metaballToPath</span><span>(</span>p1<span>,</span> p2<span>,</span> p3<span>,</span> p4<span>,</span> h1<span>,</span> h2<span>,</span> h3<span>,</span> h4<span>,</span> d <span>&gt;</span> radius1<span>,</span> radius2<span>)</span><span>;</span>
<span>}</span>


<span>function</span> <span>metaballToPath</span><span>(</span><span>p1<span>,</span> p2<span>,</span> p3<span>,</span> p4<span>,</span> h1<span>,</span> h2<span>,</span> h3<span>,</span> h4<span>,</span> escaped<span>,</span> r</span><span>)</span> <span>{</span>
  <span>return</span> <span>[</span>
    <span>&#39;M&#39;</span><span>,</span> p1<span>,</span>
    <span>&#39;C&#39;</span><span>,</span> h1<span>,</span> h3<span>,</span> p3<span>,</span>
    <span>&#39;A&#39;</span><span>,</span> r<span>,</span> r<span>,</span> <span>0</span><span>,</span> escaped <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>,</span> <span>0</span><span>,</span> p4<span>,</span>
    <span>&#39;C&#39;</span><span>,</span> h4<span>,</span> h2<span>,</span> p2<span>,</span>
  <span>]</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>;</span>
<span>}</span></code></pre></div></article></div>
  </body>
</html>
