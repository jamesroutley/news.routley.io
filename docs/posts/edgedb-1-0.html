<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.edgedb.com/blog/edgedb-1-0">Original</a>
    <h1>Show HN: EdgeDB 1.0</h1>
    
    <div id="readability-page-1" class="page"><div><div><div>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<section data-section-id="edgedb-1-0" id="edgedb-1-0">
<!-- -->
<p>Check out the discussion of this post on
                <a href="https://news.ycombinator.com/item?id=30290225">Hacker News</a>.</p>
<p>Today, after several years of building (and a long list of prereleases) we are
            extremely proud to announce the release of EdgeDB 1.0, the first open source,
            graph-relational database! üéä</p>
<p>A brief Q&amp;A is in order.</p>
<p><em>What are the killer features?</em></p>
<ul>
<li>
<p>Modern, lean query language designed to surpass SQL in expressive power;</p>
</li>
<li>
<p>Rich type system;</p>
</li>
<li>
<p>A declarative schema which lets you express inheritance, computed properties,
                    functions, complex constraints (and, in the near future, access control
                    rules);</p>
</li>
<li>
<p>A builtin migration system that can reason and diff schemas automatically
                    or interactively;</p>
</li>
<li>
<p>Powered by PostgreSQL.</p>
</li>
</ul>
<p><em>What is a graph-relational database?</em></p>
<p>EdgeDB is built on an <em>extension</em> of the relational data model that we call
            the <em>graph-relational model</em>.  This model completely eliminates the
            object-relational impedance mismatch while retaining the solid basis of
            and performance of the classic relational model.  This makes EdgeDB an
            ideal database for application development.</p>
<p><em>Why do we need a new kind of database?</em></p>
<p>The developer experience of using the existing databases is not good enough
            anymore.  We should not continue wasting our productivity with a database
            API architecture from the last century.  There has been <em>amazing</em> progress
            in database backend implementations in the last two decades, but it absolutely
            languishes behind an interface that was designed in an era of mainframes.
            We want to fix this and move the database API and developer experience into the
            era of modern application development.</p>
<p><em>How does it work?</em></p>
<p>EdgeDB reimplements the entire database frontend: the protocol, the query
            language, schema definition, client libraries and tools.  The backend is
            PostgreSQL, but EdgeDB will run it for you, and you don‚Äôt have to know
            it‚Äôs even there.</p>
<div data-section-id="we-shall-do-better-than-sql" id="we-shall-do-better-than-sql">

<p>A lot of words have already been written on the inadequacies of SQL, both
                by <a href="https://www.edgedb.com/blog/we-can-do-better-than-sql">us</a> and <a href="https://www.scattered-thoughts.net/writing/against-sql/">others</a>.  Let‚Äôs just say that
                we can and <em>must</em> try to do better to move forward as the industry.  EdgeQL
                is an attempt to do just that.  We are not pretending that it‚Äôs an easy thing
                to do.  It‚Äôs an enormous undertaking.  In some sense, building a new SQL
                database from scratch is a safer bet than recasting PostgreSQL with a new data
                model and a new query language.  However, we are already starting to see this
                bet paying off with overwhelmingly positive feedback from early users of
                EdgeQL, as well as our better-than-expected experience of embedding EdgeQL
                natively into TypeScript.</p>
<p>If you are not familiar with EdgeQL yet, here‚Äôs the executive summary:</p>
<ul>
<li>
<p>built on graph-relational model: data relationships are a
                        first class concept, no verbose joins necessary;</p>
</li>
<li>
<p>inherently composable: everything is an expression and there is only
                        one class of values;</p>
</li>
<li>
<p>supports straightforward navigation and manipulation of non-trivial
                        graphs of data.</p>
</li>
</ul>
<p>Because a picture is worth a thousand words, let‚Äôs look at an example query.</p>
<p><b>Task</b>: get a set of movies where Zendaya played a role, and for every
                such movie calculate the average review score, and also retrieve the list
                of top 5 actors in the order of credits.</p>
<p>Here‚Äôs how such query can be written in EdgeQL:</p>
<div><div><div><pre><span><span>select</span>
  Movie {
    title,
    rating <span>:=</span> math::<span>mean</span>(.ratings.score)
    actors: {
      name
    } <span>order</span> <span>by</span> <span>@credits_order</span>
      <span>limit</span> <span>5</span>,
  }
<span>filter</span>
  <span>&#34;Zendaya&#34;</span> <span>in</span> .actors.name</span></pre></div></div></div>
<p>And here‚Äôs a standard SQL formulation:</p>
<div><div><div><pre><span><span>SELECT</span>
  title<span>,</span>
  Actors<span>.</span>name <span>AS</span> actor_name<span>,</span>
  <span>(</span><span>SELECT</span> <span>avg</span><span>(</span>score<span>)</span>
   <span>FROM</span> Movie_Reviews
   <span>WHERE</span> movie_id <span>=</span> Movie<span>.</span>id<span>)</span> <span>AS</span> rating
<span>FROM</span>
  Movie
  <span>CROSS</span> <span>JOIN</span> LATERAL <span>(</span>
    <span>SELECT</span> name
    <span>FROM</span>
      Movie_Actors
      <span>INNER</span> <span>JOIN</span> Person
        <span>ON</span> Movie_Actors<span>.</span>person_id <span>=</span> Person<span>.</span>id
      <span>WHERE</span> Movie_Actors<span>.</span>movie_id <span>=</span> Movie<span>.</span>id
      <span>ORDER</span> <span>BY</span> Movie_Actors<span>.</span>credits_order
      <span>FETCH</span> <span>FIRST</span> <span>5</span> <span>ROWS</span> ONLY
   <span>)</span> <span>AS</span> Actors
<span>WHERE</span>
  <span>&#39;Zendaya&#39;</span> <span>IN</span> <span>(</span>
    <span>SELECT</span> Person<span>.</span>name
    <span>FROM</span>
      Movie_Actors
      <span>INNER</span> <span>JOIN</span> Person
        <span>ON</span> Movie_Actors<span>.</span>person_id <span>=</span> Person<span>.</span>id
  <span>)</span></span></pre></div></div></div>
<p>The queries aren‚Äôt exactly equivalent as the SQL query doesn‚Äôt actually
                select actors as a nested collection, but we‚Äôre willing to overlook that here.
                The difference in query text size is striking, and that‚Äôs just one level of
                nesting.</p>
</div>
<div data-section-id="the-true-source-of-truth" id="the-true-source-of-truth">

<p>Applications today are no longer monoliths operating on a single machine.
                Instead, they are deployed onto vast swarms of network nodes as services,
                APIs, and serverless functions.  All those components need to coordinate
                and agree on what is true and what isn‚Äôt, which state is valid and which
                isn‚Äôt, and, importantly, who gets access to what.  In other words, it‚Äôs best
                to have some common, consistent source of truth about the state of the
                overall system under concurrent load.  Database servers are very good at that,
                but only if yours and database‚Äôs view on what‚Äôs ‚Äúcorrect‚Äù align well.</p>
<p>The last point, of course, is what this is all about: if you communicate your
                model and your data invariants to the database properly and keep it that way,
                the database will happily solve the majority of your data correctness and
                data security problems.</p>
</div>
<div data-section-id="not-just-a-database-server" id="not-just-a-database-server">

<p>Our mission to provide developers with awesome database superpowers does not
                stop with the database server.</p>
<p>We understand that even the best database implementation can be hopelessly
                hobbled by a bad database client.  This is why we wrote (and will continue
                writing) full-featured first-party database client implementations for common
                programming languages (currently available for Python,
                JavaScript/TypeScript/Deno, and Go).  Alas, it‚Äôs impossible to write a
                client for <em>every</em> language at once, so we provide exhaustive documentation for
                client implementers, as well as common conformance test suites.</p>
<p>Although a lot more pleasant than SQL, writing EdgeQL queries as strings in
                code is not an optimal experience.  Fortunately, EdgeQL is designed to be
                an easy <em>compilation target</em> and thus our goal is to provide no-compromise
                way of expressing EdgeQL queries using the syntax and idioms of your
                programming language.  Alongside EdgeDB 1.0 today we announce the native
                Javascript/Typescript query builder.</p>
<p>Here‚Äôs the movie query from earlier expressed in pure TypeScript:</p>
<div><div><div><pre><span> e<span>.</span><span>select</span><span>(</span>
   e<span>.</span>Movie<span>,</span> <span>(</span>movie<span>)</span> <span>=&gt;</span> <span>(</span><span>{</span>
     title<span>:</span> <span>true</span><span>,</span>
     rating<span>:</span> e<span>.</span>math<span>.</span><span>mean</span><span>(</span>movie<span>.</span>reviews<span>.</span>score<span>)</span><span>,</span>
     <span>actors</span><span>:</span> <span>(</span>actor<span>)</span> <span>=&gt;</span> <span>(</span><span>{</span>
       name<span>:</span> <span>true</span><span>,</span>
       order_by<span>:</span> actor<span>[</span><span>&#34;@credits_order&#34;</span><span>]</span><span>,</span>
       limit<span>:</span> <span>5</span><span>,</span>
     <span>}</span><span>)</span><span>,</span>
     filter<span>:</span> e<span>.</span><span>op</span><span>(</span><span>&#34;Zendaya&#34;</span><span>,</span> <span>&#34;in&#34;</span><span>,</span> movie<span>.</span>actors<span>.</span>name<span>)</span>
  <span>}</span><span>)</span>
<span>)</span></span></pre></div></div></div>
<p>Remarkably, it follows the original EdgeQL query structure and is almost
                the same size.  In return you get a fully typechecked query backend by
                type definitions autogenerated by introspecting your schema.  We are very
                happy how this turned out, and it‚Äôs proof that EdgeQL integrates into modern
                languages well, further reducing cognitive overhead.</p>
<p>Last but not least is our comprehensive CLI, which goes far beyond a REPL and
                traditional database client commands, and includes commands to easily install
                and manage local database instances (and, soon, managed cloud instances),
                interactively create and apply database migrations, and much more.</p>
</div>
<div data-section-id="cloud-ready-database-apis" id="cloud-ready-database-apis">

<p>The vast scale of modern application deployments requires that inelastic
                computing resources are managed <em>very</em> carefully.  Until cloud-native databases
                reach complete functional and performance parity with traditional databases,
                we will have to contend with the fact that the database is a scarce resource.
                Unfortunately, traditional RDBMS make this job much harder due to two factors:</p>
<ul>
<li>
<p>legacy client/server protocols require unnecessary server roundtrips
                        due to being too chatty or too dumb,</p>
</li>
<li>
<p>SQL is very bad at fetching and updating linked data, so multiple
                        sequential queries are frequently needed, ORMs sometimes make this worse.</p>
</li>
</ul>
<p>What the above means is that even simple operations frequently require multiple
                slow trips over the network while the database server is potentially holding
                onto precious connection slots or data locks, reducing the availability of
                the entire system.</p>
<p>With the knowledge of the above, EdgeDB comes prepared.  EdgeQL allows
                combining a practically arbitrary number of fetching or <em>mutating</em> operations
                into a single query. Our client/server protocol is designed to minimize the
                number of server roundtrips: commonly only one request/response event is
                needed.</p>
<p>EdgeDB provides serializable transaction isolation, and, because it‚Äôs the only
                way to correctly interact with the database concurrently, it‚Äôs the only option.
                Serializable isolation means that the server will sometimes refuse to accept
                your transaction and will ask you to retry it.  Another (less common) condition
                is when the server connection suddenly drops mid-transaction either due to
                failover or network flakiness.  All those conditions are completely recoverable
                and normal in a distributed environment, and so all EdgeDB client bindings
                have APIs that are designed to perform automatic transaction retries.</p>
</div>
<div data-section-id="future" id="future">

<p>The 1.0 release is a major milestone for us. We now have a stable
                foundation to continue our quest of building a true next generation
                database!  In other words, it‚Äôs just the beginning.</p>

<p>We plan to adopt a faster release cycle,
                with EdgeDB 2.0 targeted in just a few months.  We are working on
                a cloud service with some ambitious features that will go well beyond
                just giving you an IP address to connect to.</p>
<p>Buckle up, we are going to have one hell of a ride!</p>
<p>We‚Äôd like to thank our community of early adopters who helped us with
                feedback, early testing, and provided the much needed encouragement.
                Join us on GitHub, give us a star, but most importantly check out EdgeDB!</p>
<p><b>We can‚Äôt wait to see what you build with EdgeDB! ‚ù§Ô∏è</b></p>
<!-- -->
<!-- -->
</div>
</section>
</div></div></div></div>
  </body>
</html>
