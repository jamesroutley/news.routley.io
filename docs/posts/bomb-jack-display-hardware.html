<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/martinpiper/BombJack/blob/master/README.md">Original</a>
    <h1>Bomb Jack display hardware</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text">
<ul dir="auto">
<li>Main social media: <a href="https://mastodon.social/@martin_piper" rel="nofollow">https://mastodon.social/@martin_piper</a></li>
<li>Don&#39;t have a Mastodon account? Click here for an invitation link: <a href="https://mastodon.social/invite/nuGxMC8z" rel="nofollow">https://mastodon.social/invite/nuGxMC8z</a></li>
<li>Itch IO project page: <a href="https://martin-piper.itch.io/bomb-jack-display-hardware" rel="nofollow">https://martin-piper.itch.io/bomb-jack-display-hardware</a></li>
<li>YouTube channel: <a href="https://www.youtube.com/c/MartinPiper6502" rel="nofollow">https://www.youtube.com/c/MartinPiper6502</a></li>
<li>Buy me a ko-fi: <a href="https://ko-fi.com/martinpiper0750" rel="nofollow">https://ko-fi.com/martinpiper0750</a></li>
<li>Bluesky: <a href="https://bsky.app/profile/martinpiper.bsky.social" rel="nofollow">https://bsky.app/profile/martinpiper.bsky.social</a></li>
<li>Twitter links: <a href="https://twitter.com/MartinPiper" rel="nofollow">https://twitter.com/MartinPiper</a> <a href="https://twitter.com/hashtag/RetroTTLVideoCard" rel="nofollow">https://twitter.com/hashtag/RetroTTLVideoCard</a> <a href="https://twitter.com/hashtag/RetroTTL" rel="nofollow">https://twitter.com/hashtag/RetroTTL</a></li>
<li>Threads: <a href="https://www.threads.net/@martinpiper1187" rel="nofollow">https://www.threads.net/@martinpiper1187</a></li>
<li>Mostly using these tags: #MegaWang #RetroTTL #RetroTTLVideoCard #C64 #Commodore64 #electronics</li>
</ul>
<p dir="auto">This started life as a working schematic for the video display portion of the original Bomb Jack arcade hardware. Why bother, you&#39;re probably asking? Well if you have to ask then perhaps you&#39;re not the right audience. :)</p>
<p dir="auto">The version 1.0 of this work was approximately interface pin and chip compatible with the original hardware schematic. Now since V2.0 the hardware has progressed to add extra features not present in the original, such as:</p>
<ul dir="auto">
<li>Addressable RAM instead of ROMs</li>
<li>Extra display blanking capability</li>
<li>Tile X/Y pixel scroll</li>
<li>64x64 Tile X/Y offset, useful for fast hardware scrolling</li>
<li>Full screen height sprites</li>
<li>Background &#34;mode7&#34; screen that allows per-pixel affine transformation</li>
<li>Background colour select (Can be rapidly updated during the frame for plasma effects)</li>
</ul>

<p dir="auto">This project started when old retro arcade hardware was being discussed. In the back of my mind was the often fabled &#34;Mega games&#34; by Imagine Software which were planned to use extra hardware on the Spectrum and Commodore 64 to augment the machine&#39;s capabilities. Since this hardware uses TTL logic available back from the same time period I was wondering exactly how much extra graphical grunt could have been engineered and interfaced with these old 8-bit computers.</p>
<p dir="auto">Truth be told, the Imagine hardware was pretty much just extra RAM <a href="https://www.gamesthatwerent.com/gtw64/mega-games/" rel="nofollow">https://www.gamesthatwerent.com/gtw64/mega-games/</a> but this was a fun project to see how far the arcade hardware was pushing the limits of board size and signal complexity.</p>
<p dir="auto">I was looking at Bomb Jack boards on ebay and pondering how they had enough fill-rate to draw 24 16x16 sprites and have the option for some to use 32x32 mode as well. A friend and I were discussing the clock speed and fill-rate while trying to deduce the operation of the hardware just by inspecting the hand drawn schematics, as you do.</p>
<p dir="auto">In the end to get some clarity on the sprite plotting specifically I started to transcribe what was thought to be the sprite logic portion of the schematic into Proteus, since it can simulate digital electronics really well.</p>
<p dir="auto">Interestingly the Amiga computer, with its custom chips, was designed and prototyped using breadboards: <a href="https://arstechnica.com/gadgets/2007/08/a-history-of-the-amiga-part-3/" rel="nofollow">https://arstechnica.com/gadgets/2007/08/a-history-of-the-amiga-part-3/</a></p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Digital display and audio simulation</h2><a id="user-content-digital-display-and-audio-simulation" aria-label="Permalink: Digital display and audio simulation" href="#digital-display-and-audio-simulation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The arcade hardware uses resistor ladders to convert 4x3 bit RGB+H+V sync digital signals into analog, this is a typical model for the period. I later updated the design to use 15 bit colour with 16x16 palette entries. Since the simulation software is optimised for digital model it makes sense to have a digital display driver simulation that accepts digital signals. Hence I created this Proteus VSM module: <a href="https://github.com/martinpiper/DigitalDisplay">https://github.com/martinpiper/DigitalDisplay</a></p>
<p dir="auto">This simulation can also be used to debug failures in original boards, since disabling chips or signals in the simulation can produce similar output display artefacts. For example disabling one of the scan line RAM chips (4A/4B/4C/4D) produces alternate pixels and bright lines, similar to the original hardware.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Why not use a CPLD or FPGA?</h2><a id="user-content-why-not-use-a-cpld-or-fpga" aria-label="Permalink: Why not use a CPLD or FPGA?" href="#why-not-use-a-cpld-or-fpga"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Good question! For my thinking, it is a question of what level to want to teach. In software eningeering there are numerous languages, C/C++, Python, Java, Forth, Pascal, etc. There is also machine code and usually some form of assembler mnemonic language which directly maps to machine code, the user accessible low-level language used by a particular CPU. Below that there can be microcode which is often not user accesible, this tends to control the internal state of a CPU. As a software engineer, I see value in using higher level languages, but often use low-level assembler when I want to optimise.</p>
<p dir="auto">A FPGA or CPLD, while it deals with logical operations, is usually programmed via a higher level language (VHDL or Verilog or similar) abstraction above the low-level logic cells actually used by the device, often (not always) the same code can be compiled for subtly different devices with minimal changes.</p>
<p dir="auto">7400-series discrete logic, specifically 74LS series logic used in this project, can be considered to be low-level, analogous to using machine code or assembler. There is a lower level, which is using discrete transistors to create logic cells, like NAND, OR, NOT, etc. but that really is a low level more like microcode.</p>
<p dir="auto">The use of high level or low-level programming is a contextual decision, often my knowledge of low-level architecture and performace informs my decision making processes when using high level languages. While it is certainly possible to code an application entirely with only high level language knowledge, it is an advantage to know low-level architecture to help debug hopefully rare performance or error situations.</p>
<p dir="auto">All that said, I believe that knowing how to engineer a solution using low-level discrete logic is an advantage, in other words it helps to improve the use of higher level CPLD or FPGA engineering to know lower level architecture. This is why this project exists, to help teach how to solve engineering problems using low-level discrete logic.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Developer technical details</h2><a id="user-content-developer-technical-details" aria-label="Permalink: Developer technical details" href="#developer-technical-details"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To produce the test data run: BDD6502\ForUnitTests.bat</p>
<p dir="auto">If you have Proteus setup with the digital display model, you should see a screen that looks somewhat like this when starting the simulation:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://cceckman.com/martinpiper/BombJack/blob/master/Capture.PNG?raw=true"><img src="https://cceckman.com/martinpiper/BombJack/raw/master/Capture.PNG?raw=true" alt="Screenshot" title="Screenshot"/></a></p>
<p dir="auto">The new hardware scrolling registers also work well:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://cceckman.com/martinpiper/BombJack/blob/master/output/debug.gif?raw=true"><img src="https://cceckman.com/martinpiper/BombJack/raw/master/output/debug.gif?raw=true" alt="animation" title="animation" data-animated-image=""/></a></p>
<p dir="auto">The hardware supports sprite multiplexing and stacking, giving the option of having more than eight colours in sprites:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://cceckman.com/martinpiper/BombJack/blob/master/output/debug2.gif?raw=true"><img src="https://cceckman.com/martinpiper/BombJack/raw/master/output/debug2.gif?raw=true" alt="animation" title="animation2" data-animated-image=""/></a></p>
<p dir="auto">Many thanks to <a href="https://opengameart.org/content/rpg-town-pixel-art-assets" rel="nofollow">https://opengameart.org/content/rpg-town-pixel-art-assets</a> and <a href="https://opengameart.org/content/colored-16x16-fantasy-tileset" rel="nofollow">https://opengameart.org/content/colored-16x16-fantasy-tileset</a> for the game art.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">High level schematic sheets</h3><a id="user-content-high-level-schematic-sheets" aria-label="Permalink: High level schematic sheets" href="#high-level-schematic-sheets"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Proteus sheet numbers correspond to the original schematic page numbers as written in the bottom right hand corner of each page. The layout of this schematic roughly matches the layout of the original schematic. So for example the analog RGB resistor ladders are on &#34;Root sheet 8&#34; in the top right of the sheet, as in the original schematic page 8 layout.</p>
<ol dir="auto">
<li>Logic analyser, virtual video display model, expansion bus header, data generator
<ol dir="auto">
<li>Memory selection logic based on external address bus</li>
<li>VSMDD2 is a replacement for the Proteus data generators because they have a 1024 byte limit. Proteus VSM project source: <a href="https://github.com/martinpiper/DigitalData">https://github.com/martinpiper/DigitalData</a></li>
<li>EXPANSIONBUS, EXPANSIONBUS2 and EXPANSIONBUS3 all relate to the C64 user port to 24 bit address logic in the project: UserPortTo24BitAddress.pdsprj</li>
</ol>
</li>
<li>Headers, the original schematic has dip switch logic</li>
<li>Video timing
<ol dir="auto">
<li>Horizontal video signal generation</li>
<li>Vertical video signal generation</li>
<li>HBLANK and VBLANK signal generation</li>
</ol>
</li>
<li>Sprite logic - Part 1
<ol dir="auto">
<li>Sprite RAM register access logic, timing with the external address/data bus and video internal timings</li>
<li>Temporary storage for sprite position, palette and frame</li>
<li>Bit plane access and bit shifters for output pixels to scan RAM</li>
<li>32x32 sprite selection registers and comparison</li>
<li>Various signal timings generated for sprite loading, tile and colour fetch etc</li>
</ol>
</li>
<li>Sprite logic - Part 2
<ol dir="auto">
<li>Dual scan line RAM buffers</li>
<li>Transparent pixel test logic based on inverted pixel temporary storage and selection with NOR check</li>
<li>Pixel writing to RAM based on 16 pixel chunks and position register contents</li>
<li>Logic for timing of pixel reads for possible video display, plus clearing of data just read</li>
</ol>
</li>
<li>Character screen RAM with associated colour screen
<ol dir="auto">
<li>Associated external bus interface logic</li>
<li>Bit plane reads and pixel shifters</li>
<li>Output pixel logic for possible video display</li>
</ol>
</li>
<li>16x16 tile background picture logic
<ol dir="auto">
<li>Logic for selection of appropriate picture, based on high address lines</li>
<li>Bit plane reads and pixel shifters</li>
<li>Output pixel logic for possible video display, or disable background logic</li>
</ol>
</li>
<li>Output pixel pipeline and palette lookup
<ol dir="auto">
<li>Pixel transparency test from background, character screen and sprites</li>
<li>Palette RAMs with external bus logic</li>
<li>Final pixel latching logic and palette RAM lookup</li>
<li>Output digital to analog conversion using resistor ladders</li>
<li>Analog RGB and associated sync signal output header</li>
</ol>
</li>
<li>Mode7 calculation
<ol dir="auto">
<li>Register addressing and latches</li>
<li>dx, dxy, dy, dyx calculation</li>
<li>xorg, yorg addition</li>
</ol>
</li>
<li>Mode7 pixel logic
<ol dir="auto">
<li>Background colour latch, transparent pixel detection</li>
<li>Interleaved blocks (for RAM timing) mode7 screen access, feeding into tile access, H &amp; V flip logic</li>
</ol>
</li>
<li>Scaled sprite logic - Part 1
<ol dir="auto">
<li>Register memory</li>
<li>Sprite extent and scan line detection</li>
<li>Sprite flipping</li>
</ol>
</li>
<li>Scaled sprite logic - Part 2
<ol dir="auto">
<li>Scanline - Two alternating banks</li>
<li>Sprite definition RAM</li>
</ol>
</li>
<li>Vector logic
<ol dir="auto">
<li>Register logic - Bank display and kill</li>
<li>Scan RAM banks - Two banks</li>
</ol>
</li>
<li>Pixel data combiner (merge layer) logic
<ol dir="auto">
<li>2-1 pixel data combiners - Two blocks</li>
</ol>
</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">How to access the hardware</h3><a id="user-content-how-to-access-the-hardware" aria-label="Permalink: How to access the hardware" href="#how-to-access-the-hardware"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In the original hardware, used in the Bombjack arcade game, the Z80 data and its address bus was partially connected to the hardware with a couple of address windows at $9000 to $9fff (perhaps a bit wider than that), this was mostly write RAM as far as the Z80 was concerned. It was sprite registers, some control registers, palette and char screen RAM. The rest of the video internal memory was ROM, and could not be addressed by the Z80. The Z80 would have to time writes to the video address space (RAM) during the VBLANK when the video hardware was not expecting to read RAM to avoid contention.</p>
<p dir="auto">For this updated hardware, the C64 (or a Z80) sends data bytes via the user port (parallel transfer, so it&#39;s fast, one clock cycle to write), with some control signals, to write to a 24 bit address space in the hardware. This is usually accomplished by the UserPortTo24BitAddress.pdsprj (or better) project. Basically a control signal resets the internal state, the next three bytes are the address to write, then next bytes are consecutively written to the address space until the internal state is reset again. There is a signal from the hardware to the C64 via the user port for screen refresh (VBLANK) which is read as an NMI (CIA2 FLAG pin) request on the C64. This means there is no bus contention with the C64 memory bus to the hardware. Writes to hardware RAM take precedence over what the hardware is reading from the RAM, this ensures data is written without contention. Writes to the hardware which involve RAM, rather than register latches, should usually be timed to coincide with VBLANK or HBLANK to avoid visual glitches. Each layer (chars, tiles, sprites etc) provides information on any RAM timing constraints.</p>

<p dir="auto">Note: Most control registers can be updated at any point during the frame and the next pixel will reflect the change.</p>
<p dir="auto">0x9000			Chars control register
</p>
<p dir="auto">0x9c00-0x9dff	Palette RAM</p>
<p dir="auto">0x9e00	0x10	Use background colour
0x20	Enable display
0x80	BorderY shrink</p>
<p dir="auto">0x9e08	Layer priority select, for each layer select the input header pixel input
Default should be: %11100100 = 0xe4
i.e. Back most layer	= %11 (3)
Next layer closer		= %10 (2)
Then next closest		= %01 (1)
Then front most layer	= %00 (0)</p>
<p dir="auto">0x9e09	0xlg	Setup nybble extents for overscan to enable the border (g = greater than, and l = less than) in 8 pixel steps
Overscan mode is always on, so this needs to be set to sensible values
Sensible wide value for this is $29 which hides the left edge (including 16x16 tiles) and brings in the right edge in slightly
This gives a 320 pixel wide screen, displaying a full width of 40 8x8 characters</p>
<p dir="auto">0x9e0a	Video layer enable flags. These are passed through the VideoX connectors. Each layer has the option of reading their enable flag and taking appropriate action.
Bits	Action				Default layer assigned to this connector (can be changed)		Replaces logic
0x01	Enable layer 1		Sprites (or Sprites2)											0x9a00 Upper nybble: $10 = Enable sprite output (6S SPREN)
0x02	Enable layer 2		Chars															0x9000 Chars control register	0x02	Chars screen disable
0x04	Enable layer 3		Tiles															0x9e00	0x10	Enable tiles
0x08	Enable layer 4		Background or mode7												0xa015	: Flags	:	0 : Enable display</p>
<p dir="auto">0x9e0b	Background colour
If the final pixel is transparent and 0x9e00 0x10 is set, then the palette information is read from this colour value
If the final pixel is transparent and 0x9e00 0x10 is not set, then the palette information is read from the last layer colour value</p>
<p dir="auto">0x9e0c	Palette bank number
See: kBus24Bit_VideoLayer_ExpandedPalettes</p>
<p dir="auto">Sprite 32x32 size select
0x9a00 start index of 32x32 sprites
0x9a01 end index of 32x32 sprites (exclusive)
So 0,0 = no 32x32 sprites
0,8 means indexes 2 to 7 (exclusive) are 32x32
Maximum number in both is 0xf</p>
<p dir="auto">At 0x9800 - 0x985f each sprite is described by 4 bytes:</p>
<div data-snippet-clipboard-copy-content="Byte 0:
	The tile code for the sprite, used to look up the sprite’s image bitplanes in the tile ROMs
	(MAME Emu documentation is wrong, bit 7 has nothing to do with selecting double size mode)

Byte 1: HVFMCCCC
	Bit 7: H : If set, the sprite is horizontally flipped
	Bit 6: V : If set, the sprite is vertically flipped
	Bit 5: F : If set, the sprite is full screen height. The sprite data will repeat.
	Bit 4: MSBX
	Bits 3..0: C : 4 bits to provide the colour value for the tile decoder

Byte 2: The sprite’s Y position on screen
Byte 3: The sprite’s X position on screen"><pre><code>Byte 0:
	The tile code for the sprite, used to look up the sprite’s image bitplanes in the tile ROMs
	(MAME Emu documentation is wrong, bit 7 has nothing to do with selecting double size mode)

Byte 1: HVFMCCCC
	Bit 7: H : If set, the sprite is horizontally flipped
	Bit 6: V : If set, the sprite is vertically flipped
	Bit 5: F : If set, the sprite is full screen height. The sprite data will repeat.
	Bit 4: MSBX
	Bits 3..0: C : 4 bits to provide the colour value for the tile decoder

Byte 2: The sprite’s Y position on screen
Byte 3: The sprite’s X position on screen
</code></pre></div>
<p dir="auto">0x9200 Sprites2 registers
Sprites support X and Y flips with X &amp; Y repeating patterns</p>
<div data-snippet-clipboard-copy-content="Byte 0: Palette | 0x10 = MSBX | 0x20 = MSBY | 0x40 = flipX | 0x80 = flipY
Byte 1: Y pos
Byte 2: Y size (in screen pixels, regardless of scale) (0 = end of list)
Byte 3: X pos
Byte 4: X scale extent (uses internal coordinates)
Byte 5: Y inv scale (*32)
Byte 6: X inv scale (*32)
Byte 7: Sprite frame (index) | 0x40 = halfX | 0x80 = halfY"><pre><code>Byte 0: Palette | 0x10 = MSBX | 0x20 = MSBY | 0x40 = flipX | 0x80 = flipY
Byte 1: Y pos
Byte 2: Y size (in screen pixels, regardless of scale) (0 = end of list)
Byte 3: X pos
Byte 4: X scale extent (uses internal coordinates)
Byte 5: Y inv scale (*32)
Byte 6: X inv scale (*32)
Byte 7: Sprite frame (index) | 0x40 = halfX | 0x80 = halfY
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Tile and sprite data layout</h4><a id="user-content-tile-and-sprite-data-layout" aria-label="Permalink: Tile and sprite data layout" href="#tile-and-sprite-data-layout"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">16x16 pixel tile and sprite data is stored in 8x8 cells and in memory order:
01
23</p>
<p dir="auto">For 32x32 sprites, this arrangement is expanded in memory as:
0145
2367
89cd
abef</p>

<p dir="auto">Mode7 borrows its name from the graphics mode on the Super NES video game console. <a href="https://en.wikipedia.org/wiki/Mode_7" rel="nofollow">https://en.wikipedia.org/wiki/Mode_7</a></p>
<p dir="auto">0xa000 - 0xa011	: Sets of 24 bit (8 byte) registers in l/h/hh order. There are 8 bits of accuracy, i.e. numbers are multiplied by 256.0f</p>

<p dir="auto">Each pixel on the layer is accessed using the accumulated results of these registers, this means it is possible to have per-pixel transformations combining translation, scaling, reflection, rotation, and shearing.
It is possible to update these registers per scanline, or per pixel, and generate even more complex results. Register values are latched and used immediately, so timing the update of the three bytes must be considered.</p>
<p dir="auto">Note: The internal accumulated values, x/xy/y/yx are not accessible via registers and are reset only by _EHSYNC and _EVSYNC</p>
<p dir="auto">For each horizontal pixel (on +ve 6MHz):</p>
<div data-snippet-clipboard-copy-content="x += dx
yx += dyx

xo = x + xy + xorg
yo = y + yx + yorg"><pre><code>x += dx
yx += dyx

xo = x + xy + xorg
yo = y + yx + yorg
</code></pre></div>
<p dir="auto">For each scanline (on +ve _EHSYNC):</p>

<p dir="auto">For each scanline (on _EHSYNC):</p>

<p dir="auto">For each frame (on _EVSYNC):</p>

<p dir="auto">All of the above is one way to progressively calculate xo,yo using addition. In other words:</p>
<div data-snippet-clipboard-copy-content="xo = (dx*x) + (dxy*y) + xorg
yo = (dy*y) + (dyx*x) + yorg"><pre><code>xo = (dx*x) + (dxy*y) + xorg
yo = (dy*y) + (dyx*x) + yorg
</code></pre></div>
<p dir="auto">During the coordinate (xo,yo) to screen transformation: bits 8-11 are used to lookup the tile pixel, bits 12-18 for the x screen tile index position, bits 12-17 for the y screen tile index position.</p>
<p dir="auto">Note: The full, but hidden by borders, screen resolution is 384x264 pixels.</p>
<p dir="auto">0xa014	: Background colour, any pixel index of zero in the mode7 tile data will show the background colour
0xa015	: Flags	:	0 : Enable X update, or reset to 0
1 : Enable XY update, or reset to 0
2 : Enable Y update, or reset to 0
3 : Enable YX update, or reset to 0</p>

<p dir="auto">Current audio hardware has 4 voices, each using 11 bytes. Extra bytes are used for <em>currently unused byte</em> and voice active bit masks after the voice registers.</p>
<p dir="auto">Each voice register layout is as follows:
byte	register
0		volume
1/2		address lo/hi
3/4		length lo/hi
5/6		rate lo/hi
7/8		loop address lo/hi
9/10	loop length lo/hi</p>
<p dir="auto">The sample frequency in hertz to voice rate conversion, using internal 4MHz clock, is:  (4096 * hertz) / 25000</p>

<p dir="auto">The original schematic uses a 6MHz clock for all the video hardware, as denoted by the &#34;6MHz&#34; signal line. The clocking can be found on &#34;Root sheet 1&#34; just about the logic analyser.</p>
<p dir="auto">To help debug timing issues, especially with RAMs, the schematic should be simulated at 6MHz. However the Proteus simulation can use 1MHz on this signal line, I kept the naming of the line the same as the original schematic however. This is due to the default RAM write timings for ICs 4A/4B/4C/4D being too tight. This means the digital display driver will detect ~10fps, not ~60fps as per the original design. It does however make the debug single step time easier to think about since it&#39;s not divided by 6MHz...</p>
<p dir="auto">With VIDCLK = 2M</p>
<p dir="auto">Logic analyser:
Display scale 0.2u
Capture Resolution 0.2u</p>
<p dir="auto">Remember to use:</p>
<div data-snippet-clipboard-copy-content="System-&gt;Set Animation Options
	Single Step Time: 250n
	500n For debugging full clock cycle and pixel clock"><pre><code>System-&gt;Set Animation Options
	Single Step Time: 250n
	500n For debugging full clock cycle and pixel clock
</code></pre></div>

<p dir="auto">The Z80 CPU from the original schematic is not included, it was clocked independently and has its own RAM, except for the video hardware interfaces and isn&#39;t needed for the video simulation.</p>

<p dir="auto">The Z80 data write signals are mocked using a simulator pattern generator VSMDD2, this is separate to the main video schematic and the generator is excluded from the PCB layout.</p>
<p dir="auto">As per the original design all writes to the video hardware should be carefully timed to coincide with the VBLANK or other safe write blanking periods. This is because the video hardware is almost always reading the RAM during the visible portion of the frame. Writing to the sprite registers outside the VBLANK will especially produce nasty looking effects on the screen. This RAM sharing model is quite common is old arcade and console hardware.</p>
<p dir="auto">The original hardware has been expanded to include RAMs where the ROMs were located. These are addressed by an combination of EXPANSIONBUS3 to select the groups of RAMs and the EXPANSIONBUS group selector. It is entirely possible to write more than one group at a time by enabling multiple output bits in EXPANSIONBUS3.</p>
<p dir="auto">For EBBS = $01 the RAM address select lines are from $8000 until $b800 in steps of $800</p>
<table>
<thead>
<tr>
<th>EXPANSIONBUS3</th>
<th>Group</th>
<th>EXPANSIONBUS address</th>
<th>Behaviour</th>
</tr>
</thead>
<tbody>
<tr>
<td>$01</td>
<td>Audio registers</td>
<td>$8000 11 bytes/voice</td>
<td>Audio registers</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9000</td>
<td>Char screen control</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9001/2</td>
<td>Char screen X scroll</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9003/4</td>
<td>Char screen Y scroll</td>
</tr>
<tr>
<td>$01</td>
<td>Sprite2 registers</td>
<td>$9200-$92ff</td>
<td>Sprite2 registers</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9800   $60 bytes</td>
<td>Sprite registers</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9c00   $200 bytes</td>
<td>Palette GR XB 2 bytes per entry</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9e00</td>
<td>Background image enable and borders</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9e01/2</td>
<td>Background image XL/XH pixel scroll</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9e03/4</td>
<td>Background image YL/YH pixel scroll</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9e07</td>
<td>Background colour select</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9e08</td>
<td>Layer priority select</td>
</tr>
<tr>
<td>$01</td>
<td>Original RAMs</td>
<td>$9a00-$9a01</td>
<td>Start/end 32x32 sprite index 0-f only</td>
</tr>
<tr>
<td>$01</td>
<td>Extension mode7 registers</td>
<td>$a000-$a017</td>
<td>Mode7 registers</td>
</tr>
<tr>
<td>$01</td>
<td>Vectors</td>
<td>$a100   1 byte</td>
<td>Vectors display bank</td>
</tr>
<tr>
<td>$01</td>
<td>Combiner</td>
<td>$a200   4 bytes</td>
<td>Combiner display bank</td>
</tr>
<tr>
<td>Note: APU and vectors are by default using the same EBBS in the schematics</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$02</td>
<td>APU</td>
<td>$8000   8KB</td>
<td>APU memory bank 0 instruction</td>
</tr>
<tr>
<td>$02</td>
<td>APU</td>
<td>$4000   8KB</td>
<td>APU memory bank 1 data</td>
</tr>
<tr>
<td>$02</td>
<td>APU</td>
<td>$2000   8KB</td>
<td>APU bank 2 registers</td>
</tr>
<tr>
<td>$02</td>
<td>Vectors</td>
<td>$0000   16KB</td>
<td>Vectors bank 0 data</td>
</tr>
<tr>
<td>$02</td>
<td>Vectors</td>
<td>$8000   16KB</td>
<td>Vectors bank 1 data</td>
</tr>
<tr>
<td>Note: Audio and Sprites2 are by default using the same EBBS in the schematics</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$04</td>
<td>Audio memory</td>
<td>$0000-$ffff</td>
<td>Audio sample memory</td>
</tr>
<tr>
<td>$04</td>
<td>Sprites2 data</td>
<td>$2000   8KB++</td>
<td>Sprites2 bit planes</td>
</tr>
<tr>
<td>$80</td>
<td>Background 16x16 Root sheet 7</td>
<td>$2000   8KB</td>
<td>Tiles and colours into 4P7R</td>
</tr>
<tr>
<td>$80</td>
<td>Char screen</td>
<td>$4000   8KB</td>
<td>Chars into U258</td>
</tr>
<tr>
<td>$80</td>
<td>Char screen colours</td>
<td>$8000   8KB</td>
<td>Chars colours into U137</td>
</tr>
<tr>
<td>$40</td>
<td>Background 16x16 Root sheet 7</td>
<td>$2000   8KB</td>
<td>Tiles bit plane 0 into 8R7R</td>
</tr>
<tr>
<td>$40</td>
<td>Background 16x16 Root sheet 7</td>
<td>$4000   8KB</td>
<td>Tiles bit plane 1 into 8N7R</td>
</tr>
<tr>
<td>$40</td>
<td>Background 16x16 Root sheet 7</td>
<td>$8000   8KB</td>
<td>Tiles bit plane 2 into 8L7R</td>
</tr>
<tr>
<td>$20</td>
<td>Char screen 8x8 Root sheet 6</td>
<td>$2000   8KB</td>
<td>Char data bit plane 0 into 8K6R</td>
</tr>
<tr>
<td>$20</td>
<td>Char screen 8x8 Root sheet 6</td>
<td>$4000   8KB</td>
<td>Char data bit plane 1 into 8H6R</td>
</tr>
<tr>
<td>$20</td>
<td>Char screen 8x8 Root sheet 6</td>
<td>$8000   8KB</td>
<td>Char data bit plane 2 into 8E6R</td>
</tr>
<tr>
<td>$10</td>
<td>Sprite data Root sheet 4</td>
<td>$2000   8KB</td>
<td>Sprite bit plane 0 into 7JR</td>
</tr>
<tr>
<td>$10</td>
<td>Sprite data Root sheet 4</td>
<td>$4000   8KB</td>
<td>Sprite bit plane 1 into 7LR</td>
</tr>
<tr>
<td>$10</td>
<td>Sprite data Root sheet 4</td>
<td>$8000   8KB</td>
<td>Sprite bit plane 2 into 7MR</td>
</tr>
<tr>
<td>$08</td>
<td>Mode7 Root sheet 10</td>
<td>$2000   8KB</td>
<td>Mode7 screen data 128x64 tile index</td>
</tr>
<tr>
<td>$08</td>
<td>Mode7 Root sheet 10</td>
<td>$4000   8KB</td>
<td>Mode7 tile data 32 of 16x16 tiles</td>
</tr>
<tr>
<td>$08</td>
<td>Mode7 Root sheet 10</td>
<td>$8000   8KB</td>
<td>Mode7 tile data 32 of 16x16 tiles</td>
</tr>
</tbody>
</table>
<ul dir="auto">
<li>
<p dir="auto">Using the pattern file: TestData.txt</p>
<p dir="auto">The sprite writes particularly have various configurations for sprite displays, these are commented in/out depending on the desired patterns</p>
<p dir="auto">** Comment: Spread out all over the screen</p>
<p dir="auto">This includes background screen setup, char screen data setup and sprite palette, frames and position setup.
It provides good variation of sprites, palettes etc across the full range of screen coordinates. This is useful for testing expected masking logic and general visual integrity.</p>
<p dir="auto">** Comment: Top left all the same</p>
<p dir="auto">This sets all sprites to be in the top left of the screen, it is useful to testing maximum pixel write through and sprite selection logic scenarios. The background is disabled and char screen uses transparent chars. This leaves just the sprite plane outputting pixels.
Setting a logic break on RV[0..8] = 0xe8 will allow the simulation timing and scan line RAM contents to be inspected in detail.
The timing of sprite pixel writes into scan RAM 4A/4B and pixel reads from scan RAM 4C/4D with its clear to $ff can be seen whilst single stepping. Note the values for the RV and RH bus lines just below the video display.</p>
<p dir="auto">** Comment: X pos group</p>
<div data-snippet-clipboard-copy-content="  This regularly spaces the sprites with the same X pos +/-4 pixels. Useful for debugging."><pre><code>  This regularly spaces the sprites with the same X pos +/-4 pixels. Useful for debugging.
</code></pre></div>
<p dir="auto">** Comment: Y pos group</p>
<div data-snippet-clipboard-copy-content="  This regularly spaces the sprites with the same Y pos +/-4 pixels. Useful for debugging."><pre><code>  This regularly spaces the sprites with the same Y pos +/-4 pixels. Useful for debugging.
</code></pre></div>
</li>
<li>
<p dir="auto">Using the pattern file: TestData2.txt</p>
<p dir="auto">Using the ImageToBitplane tool Run/Debug Configuration: Main all conv
Using GenerateData configuration: Debug2</p>
<p dir="auto">This demonstrates stacked multiplexed sprites over a 16x16 tiled background.</p>
<p dir="auto">Using the ImageToBitplane tool Run/Debug Configuration: Main old bridge RGB 0 0 0 palette opt rgbfactor 32</p>
<p dir="auto">This demonstrates a detailed background picture with 32 palettes of 8 entries each.</p>
<p dir="auto">Using the ImageToBitplane tool Run/Debug Configuration: Main mode7 &#34;map_9 - mode7 test.png&#34;
And enabling the data load at: ; Write Mode7 registers
This will demonstrate how the mode7 export with flipped tile detection works</p>
</li>
</ul>

<div data-snippet-clipboard-copy-content="Counting from 0 (in computer terms), the first visible display line is 17 and the last visible line is 240, and with the Y border shrink it is 224.

_EHSYNC continues its pulses on every line, even when _EVSYNC is low
Positive edge of _EHSYNC indicates start of the line
Negative edge of _EVSYNC indicates start of the frame

Positive edge of VBLANK indicates the bottom of the visible screen edge
Note: EXTWANTIRQ = _VBLANK which triggers on the negative edge at raster $f0

RV = vertical raster line number
	$f8-$ff	lo _EVSYNC
	$00-$ff	hi _EVSYNC
		$10		lo VBLANK
		$e0		lo FINALENABLEPIXELS with bordery flag
		$f0		hi VBLANK
RH = horizontal pixel clock
	Full raster line starts at $0 to $17e
		In reality, RH $0 occurs for two clocks, each subsequent pixel advances with one clock, up to a maximum of $17e
	Giving 384 pixel clocks per line
	Maximum visible portion (when _EHSYNC = 1) is $000 to $15f
	_EHSYNC = 0 (HBLANK portion of the display where nothing is visible) is $160 to $17e (plus the first half of the next $000)

SREAD = Sprite register address (lo byte, also maps to ISAB[0..6] in the schematic)

Line RH starts at $000
$000	SREAD $00
		Begin sprite 0 register reads
		1V*. H
		lo to hi _EHSYNC (in second clock for $000)
$002	SREAD $01
$004	SREAD $02
$006	SREAD $03
$008 	SREAD $00 to $03 again
$008H	OV0/1/2 LHH OC0/1/2/3 HLHL from M0-M7
$008L	All L no data from $008H clocked into pixel output latch at 5E2
$009H	Pixel data is latched into 5E2
$009H	Begin sprite 0 pixel writes
		U77 First pixel written
$00aH	U77 Second pixel written
$00a	Pixels start arriving at the real video output, resistor ladders
		Pixel also cleared to $ff in U78
$010	SREAD $04 same 4x2 repeating pattern every 2 pixels
		Begin sprite 1 register reads
		Meaning 16 pixels elapse for each sprite
$012	lo to hi FINALENABLEPIXELS (with overscan $29)
$0c0	SREAD $30 same 4x2 pattern as above
$152	hi to lo FINALENABLEPIXELS (with overscan $29)
$160	lo _EHSYNC
$17e	hi _EHSYNC (into first half of $000)
$17e	SREAD $7f
Loops back to $000 again and RV increment


The file &#34;BombJack\RecordingRHSprAddr.txt&#34; contains recorded address and RH values from Root Sheet 4 device VSMDD5.
This clearly shows (sparse extracts)
	Recording		Index	Address	@RH
	d$00000000		0		$00		$000
	d$00100040		4		$10		$040
	d$00200080		8		$20		$080
	d$003000c0		12		$30		$0c0
	d$00400100		16		$40		$100
	d$00500140		20		$50		$140"><pre><code>Counting from 0 (in computer terms), the first visible display line is 17 and the last visible line is 240, and with the Y border shrink it is 224.

_EHSYNC continues its pulses on every line, even when _EVSYNC is low
Positive edge of _EHSYNC indicates start of the line
Negative edge of _EVSYNC indicates start of the frame

Positive edge of VBLANK indicates the bottom of the visible screen edge
Note: EXTWANTIRQ = _VBLANK which triggers on the negative edge at raster $f0

RV = vertical raster line number
	$f8-$ff	lo _EVSYNC
	$00-$ff	hi _EVSYNC
		$10		lo VBLANK
		$e0		lo FINALENABLEPIXELS with bordery flag
		$f0		hi VBLANK
RH = horizontal pixel clock
	Full raster line starts at $0 to $17e
		In reality, RH $0 occurs for two clocks, each subsequent pixel advances with one clock, up to a maximum of $17e
	Giving 384 pixel clocks per line
	Maximum visible portion (when _EHSYNC = 1) is $000 to $15f
	_EHSYNC = 0 (HBLANK portion of the display where nothing is visible) is $160 to $17e (plus the first half of the next $000)

SREAD = Sprite register address (lo byte, also maps to ISAB[0..6] in the schematic)

Line RH starts at $000
$000	SREAD $00
		Begin sprite 0 register reads
		1V*. H
		lo to hi _EHSYNC (in second clock for $000)
$002	SREAD $01
$004	SREAD $02
$006	SREAD $03
$008 	SREAD $00 to $03 again
$008H	OV0/1/2 LHH OC0/1/2/3 HLHL from M0-M7
$008L	All L no data from $008H clocked into pixel output latch at 5E2
$009H	Pixel data is latched into 5E2
$009H	Begin sprite 0 pixel writes
		U77 First pixel written
$00aH	U77 Second pixel written
$00a	Pixels start arriving at the real video output, resistor ladders
		Pixel also cleared to $ff in U78
$010	SREAD $04 same 4x2 repeating pattern every 2 pixels
		Begin sprite 1 register reads
		Meaning 16 pixels elapse for each sprite
$012	lo to hi FINALENABLEPIXELS (with overscan $29)
$0c0	SREAD $30 same 4x2 pattern as above
$152	hi to lo FINALENABLEPIXELS (with overscan $29)
$160	lo _EHSYNC
$17e	hi _EHSYNC (into first half of $000)
$17e	SREAD $7f
Loops back to $000 again and RV increment


The file &#34;BombJack\RecordingRHSprAddr.txt&#34; contains recorded address and RH values from Root Sheet 4 device VSMDD5.
This clearly shows (sparse extracts)
	Recording		Index	Address	@RH
	d$00000000		0		$00		$000
	d$00100040		4		$10		$040
	d$00200080		8		$20		$080
	d$003000c0		12		$30		$0c0
	d$00400100		16		$40		$100
	d$00500140		20		$50		$140
</code></pre></div>

<div data-snippet-clipboard-copy-content="A sprite in 16x16 mode, with a Y register value of 224, which uses internal inverted logic, will have a calculated sprite Y coordinate of 256 - 224 = 32, this will be the last calculated scan line of the sprite. The result of the scan line calculation will be rendered and visible on the next scan line 33.
15 scan lines above calculated scan line 32 is the first calculated scan line of the sprite, in this example scan line 17, and the next scan line 18 is the first visible scan line of the sprite.


Assume the sprite scan line RAM has been cleared by a previous scan rendering all the pixels and clearing the values of $ff.
	Old revision: The weak pull-up resisters connected to the RAM output help to clear the RAM values to $ff
		These are overidden by any pull down logic 0 from the RAM or the input 74258 demultiplexors
	New revision: Uses digital logic to switch between $ff and input values as needed. This is much more stable than using pull-up resistors which needed to be tuned for the actual TTL chips used.
For each sprite the index, colour, X and Y pos are read
	After a successful Y pos test with the vertical raster position...
		The sprite data counter is set with the X position of the sprite, then for 16 (or 32) pixels
		The data in the scan line RAM is read on _6MHz = 0
		On +ve edge _6MHz this read value is latched by 2C/2D 2B/2A, and inverted for output
		The value is then tested for transparency with 1C:B or 1C:C 3-input NOR gates
		If it is transparent, the value from the input pixel from the current sprite is output by 3C/3D 3B/3A by the 74258 demultiplexors, which inverts the information. This could be a transparent pixel with its colour, or an opaque pixel with its colour.
		If it is not transparent, an opaque sprite pixel exists for this position, then the value just read from the RAM is selected by the 74258 demultiplexors, inverted and written back to the RAM
		In effect, the first opaque (non-transparent) pixel from the sprite written to the scan line RAM has priority and the rest of the pixels from sprites are ignored


Timing enabling or disabling the sprite display and updating sprite registers allows multiplexing. See: kBus24Bit_VideoLayer_XPos_SpriteIndex_*
The sprite scan line schedule, which renders each sprite in 16 pixel chunks, can be syncronised to the video pixel clock, or overclocked.
When syncronised to the video pixel clock each 16x16 sprite takes 16 pixels to process. If the sprite clock is overclocked, the scan schedule will correspondingly contract by the ratio of video clock to sprite clock. In other words each sprite will take fewer than 16 pixels to process.
Overclocking the sprite pixel clock will alter the timing for sprite multiplexing: kBus24Bit_VideoLayer_XPos_SpriteIndex_*


Remember, the scanline before a sprite is visible/displayed on the screen is the actual scanline used for rendering the sprite data.
	The x position of the sprite does not affect its rendering timing in the scanline, only the sprite register address used affects its rendering schedule time, see: Raster line schedule"><pre><code>A sprite in 16x16 mode, with a Y register value of 224, which uses internal inverted logic, will have a calculated sprite Y coordinate of 256 - 224 = 32, this will be the last calculated scan line of the sprite. The result of the scan line calculation will be rendered and visible on the next scan line 33.
15 scan lines above calculated scan line 32 is the first calculated scan line of the sprite, in this example scan line 17, and the next scan line 18 is the first visible scan line of the sprite.


Assume the sprite scan line RAM has been cleared by a previous scan rendering all the pixels and clearing the values of $ff.
	Old revision: The weak pull-up resisters connected to the RAM output help to clear the RAM values to $ff
		These are overidden by any pull down logic 0 from the RAM or the input 74258 demultiplexors
	New revision: Uses digital logic to switch between $ff and input values as needed. This is much more stable than using pull-up resistors which needed to be tuned for the actual TTL chips used.
For each sprite the index, colour, X and Y pos are read
	After a successful Y pos test with the vertical raster position...
		The sprite data counter is set with the X position of the sprite, then for 16 (or 32) pixels
		The data in the scan line RAM is read on _6MHz = 0
		On +ve edge _6MHz this read value is latched by 2C/2D 2B/2A, and inverted for output
		The value is then tested for transparency with 1C:B or 1C:C 3-input NOR gates
		If it is transparent, the value from the input pixel from the current sprite is output by 3C/3D 3B/3A by the 74258 demultiplexors, which inverts the information. This could be a transparent pixel with its colour, or an opaque pixel with its colour.
		If it is not transparent, an opaque sprite pixel exists for this position, then the value just read from the RAM is selected by the 74258 demultiplexors, inverted and written back to the RAM
		In effect, the first opaque (non-transparent) pixel from the sprite written to the scan line RAM has priority and the rest of the pixels from sprites are ignored


Timing enabling or disabling the sprite display and updating sprite registers allows multiplexing. See: kBus24Bit_VideoLayer_XPos_SpriteIndex_*
The sprite scan line schedule, which renders each sprite in 16 pixel chunks, can be syncronised to the video pixel clock, or overclocked.
When syncronised to the video pixel clock each 16x16 sprite takes 16 pixels to process. If the sprite clock is overclocked, the scan schedule will correspondingly contract by the ratio of video clock to sprite clock. In other words each sprite will take fewer than 16 pixels to process.
Overclocking the sprite pixel clock will alter the timing for sprite multiplexing: kBus24Bit_VideoLayer_XPos_SpriteIndex_*


Remember, the scanline before a sprite is visible/displayed on the screen is the actual scanline used for rendering the sprite data.
	The x position of the sprite does not affect its rendering timing in the scanline, only the sprite register address used affects its rendering schedule time, see: Raster line schedule
</code></pre></div>

<p dir="auto">The Advanced Processing Unit is an optimised raster and data transfer processor that can execute several instructions at the same time.
It is able to precisely wait for raster H&amp;V positions, transfer data, and perform simple comparisons based on internal data with conditional executions based on the results of the comparison.
This significantly reduces load on the CPU and the amount of memory the CPU needs, allowing the CPU to transfer data when it can.</p>
<p dir="auto">There is significant logic internally that allows data to be processed: <a href="https://docs.google.com/presentation/d/1Tb4B5-INhH2oiOSG4jfb3BfGGtdT9jPvyWoryOIJNzo/edit?usp=sharing" rel="nofollow">https://docs.google.com/presentation/d/1Tb4B5-INhH2oiOSG4jfb3BfGGtdT9jPvyWoryOIJNzo/edit?usp=sharing</a></p>

<p dir="auto">There is a PCB layout design included in the Proteus workspace file. It is deliberately and mostly blank with the exception of adding placement for the external address/data/RW lines, clock, external VBLANK (for IRQ triggering) and video signals output header and the associated resistor ladders. The dual sprite bit plane pull-up resistors are also placed near the edge of the sprites board. The sprite resistors and RAMs are placed to maintain an aesthetic symmetry to the board.</p>
<p dir="auto">There are six boards in the layout:
Video generation
Character screen
Sprites
Scaled sprites
Tiles
Mode7</p>
<p dir="auto">Previous versions used one large board, but this turned out to be expensive to produce and difficult to get quotations for. Apparently the companies I contacted were not that happy to produce large boards in small numbers. The design was changed to use four smaller boards, this reduces cost if someone wanted to just fabricate the video and character screen. Another benefit is that the layers can be changed and connected in different orders. This allows customisations, for example by having three sprites boards (layers 1 to 3) and one tile board (layer 4), giving a total of 72 sprites and tiles.</p>
<p dir="auto">The layout is configured with a six layer standard signal and power plane setup, using the technology template &#34;All PCB Six Layer 1.58532mm.LTF&#34; file. The layout will correctly populate with the auto-placer and default placement options, choose all then schedule before starting. It will then correctly route, again using the default router options. This is so placement can be mostly left to the optimiser while maintaining output video signal lines via the resistor placement.</p>
<p dir="auto">An entire place and route on a decent machine will take approximately 2 hours and result in an output image like:
<a target="_blank" rel="noopener noreferrer" href="https://cceckman.com/martinpiper/BombJack/blob/master/Layout1.PNG?raw=true"><img src="https://cceckman.com/martinpiper/BombJack/raw/master/Layout1.PNG?raw=true" alt="Layout" title="Layout"/></a>
<a target="_blank" rel="noopener noreferrer" href="https://cceckman.com/martinpiper/BombJack/blob/master/Layout2.PNG?raw=true"><img src="https://cceckman.com/martinpiper/BombJack/raw/master/Layout2.PNG?raw=true" alt="Tracks" title="Tracks"/></a></p>
<p dir="auto">The protoype boards have been built and documented here: <a href="https://www.youtube.com/playlist?list=PLAAYJEX1JbCPFzQDl8KOoVQR9_Us1lB46" rel="nofollow">https://www.youtube.com/playlist?list=PLAAYJEX1JbCPFzQDl8KOoVQR9_Us1lB46</a> or this project page: <a href="https://martin-piper.itch.io/bomb-jack-display-hardware" rel="nofollow">https://martin-piper.itch.io/bomb-jack-display-hardware</a></p>
<p dir="auto">I use Proteus simulation and PCB design: <a href="https://www.labcenter.com/" rel="nofollow">https://www.labcenter.com/</a>
And PCBWay PCB manufacture: <a href="https://pcbway.com/g/Xr8ZrI" rel="nofollow">https://pcbway.com/g/Xr8ZrI</a>
( Using the PCBWay referral link gives you a discount and also helps me reduce the cost of my next board. )</p>

<ul dir="auto">
<li><a href="https://github.com/mamedev/mame/blob/master/src/mame/drivers/bombjack.cpp">https://github.com/mamedev/mame/blob/master/src/mame/drivers/bombjack.cpp</a></li>
<li><a href="https://floooh.github.io/2018/10/06/bombjack.html" rel="nofollow">https://floooh.github.io/2018/10/06/bombjack.html</a></li>
<li><a href="https://www.arcade-museum.com/game_detail.php?game_id=7180" rel="nofollow">https://www.arcade-museum.com/game_detail.php?game_id=7180</a></li>
</ul>
</article></div></section></div></div></div></div>
  </body>
</html>
