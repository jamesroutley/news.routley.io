<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/buffdb/buffdb">Original</a>
    <h1>BuffDB is a Rust library to simplify multi-plexing on edge devices</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
<a href="https://discord.com/channels/1267505649198305384/1267505649969795136" rel="nofollow"><img width="250" alt="image" src="https://camo.githubusercontent.com/03c84b033133f8ac95df6378d19573c4d6091ea6aada7c94c6d19fa24ba3cf24/68747470733a2f2f73696d2e6275696c642f6173736574732f696d616765732f696d61676530322e706e673f763d6433303066613764" data-canonical-src="https://sim.build/assets/images/image02.png?v=d300fa7d"/></a>
</p>

<p dir="auto">buffdb is experimental software. Join buffdb’s <a href="https://discord.gg/4Pzv6sB8" rel="nofollow">Discord</a> for help and
have a look at <a href="https://github.com/buffdb/buffdb/issues/11" data-hovercard-type="issue" data-hovercard-url="/buffdb/buffdb/issues/11/hovercard">things that don’t work yet</a>. Many basic
things are not yet decided.</p>
<p dir="auto">BuffDB is a lightweight, high-performance persistence layer for gRPC written in Rust. When using the
SQLite backend and dynamic linking, the binary is <strong>under 2 MiB</strong>. It is designed to be used in
environments where bandwidth is limited and performance is critical. Protobuf is the messaging
format of choice, but other formats are planned.</p>
<p dir="auto">To add BuffDB to your Rust project, run <code>cargo add buffdb</code>.</p>

<p dir="auto">Using auto-generated code from the protobuf definition, we can interact with the server in many
languages. The following example demonstrates how to interact with the server in TypeScript. The
server is assumed to be running on port 50051. See the <code>examples</code> directory for demos in other
languages.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import * as grpc from &#34;@grpc/grpc-js&#34;;
import * as protoLoader from &#34;@grpc/proto-loader&#34;;
import type { ProtoGrpcType as BlobType } from &#34;./proto/blob&#34;;
import type { StoreResponse } from &#34;./proto/buffdb/blob/StoreResponse&#34;;

const proto = grpc.loadPackageDefinition(
    protoLoader.loadSync(&#34;../../proto/blob.proto&#34;)
) as unknown as BlobType;

const blob_client = new proto.buffdb.blob.Blob(
    &#34;[::1]:50051&#34;,
    grpc.credentials.createInsecure()
);
const get = blob_client.Get();
const store = blob_client.Store();

// Be sure to set up the listeners before writing data!

get.on(&#34;data&#34;, (data) =&gt; console.log(&#34;received data from GET: &#34;, data));
get.on(&#34;end&#34;, () =&gt; console.log(&#34;stream GET ended&#34;));

const blob_ids: number[] = [];
store.on(&#34;data&#34;, (raw_id: StoreResponse) =&gt; {
    const id = (raw_id.id as protoLoader.Long).toNumber();
    console.log(&#34;received data from STORE: &#34;, id);
    blob_ids.push(id);
});
store.on(&#34;end&#34;, () =&gt; console.log(&#34;stream STORE ended&#34;));

store.write({ bytes: Buffer.from(&#34;abcdef&#34;), metadata: &#34;{ offset: 6 }&#34; });
store.write({ bytes: Buffer.from(&#34;ghijkl&#34;) });

store.end();

// Give the store time to finish its operations before asking for data back.
// We could also do this in the callback of other events to be certain that it&#39;s been inserted.
setTimeout(() =&gt; {
    for (const id of blob_ids) {
        console.log(`requesting ${id}`);
        get.write({ id });
    }
    get.end();
}, 100);"><pre><span>import</span> <span>*</span> <span>as</span> <span>grpc</span> <span>from</span> <span>&#34;@grpc/grpc-js&#34;</span><span>;</span>
<span>import</span> <span>*</span> <span>as</span> <span>protoLoader</span> <span>from</span> <span>&#34;@grpc/proto-loader&#34;</span><span>;</span>
<span>import</span> <span>type</span> <span>{</span> <span>ProtoGrpcType</span> <span>as</span> <span>BlobType</span> <span>}</span> <span>from</span> <span>&#34;./proto/blob&#34;</span><span>;</span>
<span>import</span> <span>type</span> <span>{</span> <span>StoreResponse</span> <span>}</span> <span>from</span> <span>&#34;./proto/buffdb/blob/StoreResponse&#34;</span><span>;</span>

<span>const</span> <span>proto</span> <span>=</span> <span>grpc</span><span>.</span><span>loadPackageDefinition</span><span>(</span>
    <span>protoLoader</span><span>.</span><span>loadSync</span><span>(</span><span>&#34;../../proto/blob.proto&#34;</span><span>)</span>
<span>)</span> <span>as</span> <span>unknown</span> <span>as</span> <span>BlobType</span><span>;</span>

<span>const</span> <span>blob_client</span> <span>=</span> <span>new</span> <span>proto</span><span>.</span><span>buffdb</span><span>.</span><span>blob</span><span>.</span><span>Blob</span><span>(</span>
    <span>&#34;[::1]:50051&#34;</span><span>,</span>
    <span>grpc</span><span>.</span><span>credentials</span><span>.</span><span>createInsecure</span><span>(</span><span>)</span>
<span>)</span><span>;</span>
<span>const</span> <span>get</span> <span>=</span> <span>blob_client</span><span>.</span><span>Get</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>store</span> <span>=</span> <span>blob_client</span><span>.</span><span>Store</span><span>(</span><span>)</span><span>;</span>

<span>// Be sure to set up the listeners before writing data!</span>

<span>get</span><span>.</span><span>on</span><span>(</span><span>&#34;data&#34;</span><span>,</span> <span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;received data from GET: &#34;</span><span>,</span> <span>data</span><span>)</span><span>)</span><span>;</span>
<span>get</span><span>.</span><span>on</span><span>(</span><span>&#34;end&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;stream GET ended&#34;</span><span>)</span><span>)</span><span>;</span>

<span>const</span> <span>blob_ids</span>: <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>store</span><span>.</span><span>on</span><span>(</span><span>&#34;data&#34;</span><span>,</span> <span>(</span><span>raw_id</span>: <span>StoreResponse</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>id</span> <span>=</span> <span>(</span><span>raw_id</span><span>.</span><span>id</span> <span>as</span> <span>protoLoader</span><span>.</span><span>Long</span><span>)</span><span>.</span><span>toNumber</span><span>(</span><span>)</span><span>;</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;received data from STORE: &#34;</span><span>,</span> <span>id</span><span>)</span><span>;</span>
    <span>blob_ids</span><span>.</span><span>push</span><span>(</span><span>id</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>store</span><span>.</span><span>on</span><span>(</span><span>&#34;end&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;stream STORE ended&#34;</span><span>)</span><span>)</span><span>;</span>

<span>store</span><span>.</span><span>write</span><span>(</span><span>{</span> <span>bytes</span>: <span>Buffer</span><span>.</span><span>from</span><span>(</span><span>&#34;abcdef&#34;</span><span>)</span><span>,</span> <span>metadata</span>: <span>&#34;{ offset: 6 }&#34;</span> <span>}</span><span>)</span><span>;</span>
<span>store</span><span>.</span><span>write</span><span>(</span><span>{</span> <span>bytes</span>: <span>Buffer</span><span>.</span><span>from</span><span>(</span><span>&#34;ghijkl&#34;</span><span>)</span> <span>}</span><span>)</span><span>;</span>

<span>store</span><span>.</span><span>end</span><span>(</span><span>)</span><span>;</span>

<span>// Give the store time to finish its operations before asking for data back.</span>
<span>// We could also do this in the callback of other events to be certain that it&#39;s been inserted.</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>id</span> <span>of</span> <span>blob_ids</span><span>)</span> <span>{</span>
        <span>console</span><span>.</span><span>log</span><span>(</span><span>`requesting <span><span>${</span><span>id</span><span>}</span></span>`</span><span>)</span><span>;</span>
        <span>get</span><span>.</span><span>write</span><span>(</span><span>{</span> id <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>get</span><span>.</span><span>end</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>100</span><span>)</span><span>;</span></pre></div>
<p dir="auto">This example is present in <code>examples/typescript</code>. To run it, you need to have Node.js installed. Run
<code>npm i</code> to install the dependencies and <code>npm run exec</code> to run the example.</p>


<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Backend</th>
<th>Support status</th>
<th>Raw query support</th>
<th>Feature flag (vendored)</th>
<th>CLI flag</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLite</td>
<td>Full support</td>
<td>✅</td>
<td><code>sqlite</code> (<code>vendored-sqlite</code>)</td>
<td><code>-b sqlite</code></td>
</tr>
<tr>
<td>DuckDB</td>
<td>Partial</td>
<td>✅</td>
<td><code>duckdb</code> (<code>vendored-duckdb</code>)</td>
<td><code>-b duckdb</code></td>
</tr>
<tr>
<td>RocksDB</td>
<td>Partial</td>
<td>❌</td>
<td>(<code>vendored-rocksdb</code>) only</td>
<td><code>-b rocksdb</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Blockers for full DuckDB support include <a href="https://github.com/duckdb/duckdb-rs/issues/368" data-hovercard-type="issue" data-hovercard-url="/duckdb/duckdb-rs/issues/368/hovercard">duckdb/duckdb-rs#368</a>,
but other issues are necessary to have best performance.</p>
<p dir="auto">By default, all backends are included and vendored. To exclude a backend, use the
<code>--no-default-features</code> flag with cargo and re-enable the desired backend with <code>--features</code>. <strong>If
you encounter unexpected errors, consider using a vendored backend.</strong></p>

<p dir="auto">To run the server, you need to <a href="https://rustup.rs/" rel="nofollow">have Rust installed</a>. Then, with the repository
cloned, you can run</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo run --all-features -- run"><pre>cargo run --all-features -- run</pre></div>
<p dir="auto">This will start the server on <code>[::1]:50051</code>, storing the key-value pairs in <code>kv_store.db</code> and
the blob data in <code>blob_store.db</code>. All three can be configured with command line flags:
<code>--addr</code>, <code>--kv-store</code>, and <code>--blob-store</code> respectively.</p>
<p dir="auto">To build with optimizations enabled, run <code>cargo build --all-features --release</code>. The resulting
binary will be located at <code>target/release/buffdb</code>. It is statically linked (excluding the backends
depending on flags), so it can be moved anywhere on your file system without issue.</p>
<p dir="auto">Prefer to handle the gRPC server yourself? <code>buffdb</code> can be used as a library as well!</p>

<p dir="auto">You can use <code>buffdb help</code> to see the commands and flags permitted. The following operations are
currently supported:</p>
<ul dir="auto">
<li><code>buffdb run [ADDR]</code>, starting the server. The default address is <code>[::1]:50051</code>.</li>
<li><code>buffdb kv get &lt;KEY&gt;</code>, printing the value to stdout.</li>
<li><code>buffdb kv set &lt;KEY&gt; &lt;VALUE&gt;</code>, setting the value.</li>
<li><code>buffdb kv delete &lt;KEY&gt;</code>, deleting the value.</li>
<li><code>buffdb kv eq [KEYS]...</code>, exiting successfully if the values for all provided keys are equal.
Exits with an error code if any two values are not equal.</li>
<li><code>buffdb kv not-eq [KEYS]...</code>, exiting successfully if the values for all provided keys are
unique. Exits with an error code if any two values are equal.</li>
<li><code>buffdb blob get &lt;ID&gt;</code>, printing the data to stdout. Note that this is arbitrary bytes!</li>
<li><code>buffdb blob store &lt;FILE&gt; [METADATA]</code>, storing the file (use <code>-</code> for stdin) and printing the ID
to stdout. Metadata is optional.</li>
<li><code>buffdb blob update &lt;ID&gt; data &lt;FILE&gt;</code>, updating the data of the blob. Use <code>-</code> for stdin. Metadata
is unchanged.</li>
<li><code>buffdb blob update &lt;ID&gt; metadata [METADATA]</code>, updating the metadata of the blob. Data is
unchanged. Omitting <code>[METADATA]</code> will set the metadata to null.</li>
<li><code>buffdb blob update &lt;ID&gt; all &lt;FILE&gt; [METADATA]</code>, updating both the data and metadata of the blob.
For <code>&lt;FILE&gt;</code>, use <code>-</code> for stdin. Omitting <code>[METADATA]</code> will set the metadata to null.</li>
<li><code>buffdb blob delete &lt;ID&gt;</code>, deleting the blob.</li>
<li><code>buffdb blob eq-data [IDS]...</code>, exiting successfully if the blobs for all provided IDs are equal.
Exits with an error code if any two blobs are not equal.</li>
<li><code>buffdb blob not-eq-data [IDS]...</code>, exiting successfully if the blobs for all provided IDs are
unique. Exits with an error code if any two blobs are equal.</li>
</ul>
<p dir="auto">Commands altering a store will exit with an error code if the key/id does not exist. An exception
to this is updating the metadata of a blob to be null, as it is not required to exist beforehand.</p>
<p dir="auto">All commands for <code>kv</code> and <code>blob</code> can use <code>-s</code>/<code>--store</code> to specify which store to use. The defaults
are <code>kv_store.db</code> and <code>blob_store.db</code> respectively. To select a backend, use <code>-b</code>/<code>--backend</code>. The
default varies by which backends are enabled.</p>

<p dir="auto">Run <code>cargo add buffdb tonic tokio futures</code> to add the necessary dependencies. Then you can execute
the following code, which is placed in <code>src/main.rs</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="use buffdb::backend::Sqlite;
use buffdb::kv::{Key, KeyValue, Value};
use tonic::{Request, IntoRequest};
use futures::{stream, StreamExt as _};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut client = buffdb::transitive::kv_client::&lt;_, Sqlite&gt;(&#34;kv_store.db&#34;).await?;
    client
        .set(stream::iter([KeyValue {
            key: &#34;key_set&#34;.to_owned(),
            value: &#34;value_set&#34;.to_owned(),
        }]))
        .await?
        .into_inner();

    let mut stream = client
        .get(stream::iter([Key {
            key: &#34;key_get&#34;.to_owned(),
        }]))
        .await?
        .into_inner();
    let Value { value } = stream.next().await.unwrap()?;
    assert_eq!(value, &#34;value_get&#34;);

    Ok(())
}"><pre><span>use</span> buffdb<span>::</span>backend<span>::</span><span>Sqlite</span><span>;</span>
<span>use</span> buffdb<span>::</span>kv<span>::</span><span>{</span><span>Key</span><span>,</span> <span>KeyValue</span><span>,</span> <span>Value</span><span>}</span><span>;</span>
<span>use</span> tonic<span>::</span><span>{</span><span>Request</span><span>,</span> <span>IntoRequest</span><span>}</span><span>;</span>
<span>use</span> futures<span>::</span><span>{</span>stream<span>,</span> <span>StreamExt</span> <span>as</span> _<span>}</span><span>;</span>

<span>#<span>[</span>tokio<span>::</span>main<span>]</span></span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> -&gt; <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Box</span><span>&lt;</span><span>dyn</span> std<span>::</span>error<span>::</span><span>Error</span><span>&gt;</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>mut</span> client = buffdb<span>::</span>transitive<span>::</span><span>kv_client</span><span>::</span><span>&lt;</span><span>_</span><span>,</span> <span>Sqlite</span><span>&gt;</span><span>(</span><span>&#34;kv_store.db&#34;</span><span>)</span><span>.</span><span>await</span>?<span>;</span>
    client
        <span>.</span><span>set</span><span>(</span>stream<span>::</span><span>iter</span><span>(</span><span>[</span><span>KeyValue</span> <span>{</span>
            <span>key</span><span>:</span> <span>&#34;key_set&#34;</span><span>.</span><span>to_owned</span><span>(</span><span>)</span><span>,</span>
            <span>value</span><span>:</span> <span>&#34;value_set&#34;</span><span>.</span><span>to_owned</span><span>(</span><span>)</span><span>,</span>
        <span>}</span><span>]</span><span>)</span><span>)</span>
        <span>.</span><span>await</span>?
        <span>.</span><span>into_inner</span><span>(</span><span>)</span><span>;</span>

    <span>let</span> <span>mut</span> stream = client
        <span>.</span><span>get</span><span>(</span>stream<span>::</span><span>iter</span><span>(</span><span>[</span><span>Key</span> <span>{</span>
            <span>key</span><span>:</span> <span>&#34;key_get&#34;</span><span>.</span><span>to_owned</span><span>(</span><span>)</span><span>,</span>
        <span>}</span><span>]</span><span>)</span><span>)</span>
        <span>.</span><span>await</span>?
        <span>.</span><span>into_inner</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> <span>Value</span> <span>{</span> value <span>}</span> = stream<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>await</span><span>.</span><span>unwrap</span><span>(</span><span>)</span>?<span>;</span>
    <span>assert_eq</span><span>!</span><span>(</span>value, <span>&#34;value_get&#34;</span><span>)</span><span>;</span>

    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span></pre></div>
<p dir="auto">This project is inspired by conversations with Michael Cahill, Professor of Practice, School of
Computer Science, University of Sydney</p>

<p dir="auto">This project was inspired by our many edge customers of ours dealing with the challenges associated
with low-bandwidth and high performance. We hope that we can build a solution that is helpful for
teams tageting edge computing environments.</p>
<p dir="auto">Today, buffdb’s primary focus is speed: we try to ensure some level of durability for which we pay a
performance penalty, but our goal is to eventually be faster than any other embedded database.</p>

<ul dir="auto">
<li>Reducing the overhead of serialization/deserialization.</li>
<li>Ensuring consistent data formats between local storage and network communication.</li>
<li>Providing faster read/write operations compared to JSON or XML.</li>
<li>Compact Data Storage: ProtoBufs can significantly reduce the size of stored data.</li>
<li>Interoperability: Seamless integration between the app’s local storage and backend systems.</li>
</ul>

<ul dir="auto">
<li>Offline Data Access: For apps that need to function offline (e.g., note-taking apps, games,
fieldwork, airline, collaborative documents, etc.).</li>
<li>IoT: For managing device configurations and states locally before syncing with cloud servers.</li>
</ul>
</article></div></div>
  </body>
</html>
