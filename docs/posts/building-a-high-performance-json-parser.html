<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dave.cheney.net/paste/gophercon-sg-2023.html">Original</a>
    <h1>Building a high performance JSON parser</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Now we can tell which characters are tokens and which are simply whitespace, let’s step up a level and talk about scanning.</p>
<div>
<div>
<pre><code data-lang="go"><span>// Next returns a []byte referencing the the next lexical token in the stream.</span>
<span>// The []byte is valid until Next is called again.</span>
<span>// If the stream is at its end, or an error has occured, Next returns a zero</span>
<span>// length []byte slice.</span>
<span>//</span>
<span>// A valid token begins with one of the following:</span>
<span>//</span>
<span>//	{ Object start</span>
<span>//	[ Array start</span>
<span>//	} Object end</span>
<span>//	] Array End</span>
<span>//	, Literal comma</span>
<span>//	: Literal colon</span>
<span>//	t JSON true</span>
<span>//	f JSON false</span>
<span>//	n JSON null</span>
<span>//	&#34; A string, possibly containing backslash escaped entites.</span>
<span>//	-, 0-9 A number</span>
<span>func</span> <span>(</span><span>s</span> <span>*</span><span>Scanner</span><span>)</span> <span>Next</span><span>()</span> <span>[]</span><span>byte</span> <span>{</span>
	<span>s</span><span>.</span><span>br</span><span>.</span><span>release</span><span>(</span><span>s</span><span>.</span><span>offset</span><span>)</span> <span>// release the previous token</span>
	<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>0</span>

	<span>c</span> <span>:=</span> <span>s</span><span>.</span><span>token</span><span>()</span> <span>// align to the next token</span>
	<span>length</span> <span>:=</span> <span>0</span>
	<span>switch</span> <span>c</span> <span>{</span>
	<span>case</span> <span>ObjectStart</span><span>,</span> <span>ObjectEnd</span><span>,</span> <span>Colon</span><span>,</span> <span>Comma</span><span>,</span> <span>ArrayStart</span><span>,</span> <span>ArrayEnd</span><span>:</span>
		<span>length</span> <span>=</span> <span>1</span>
		<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>1</span>
	<span>case</span> <span>True</span><span>:</span>
		<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;true&#34;</span><span>)</span>
		<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
	<span>case</span> <span>False</span><span>:</span>
		<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;false&#34;</span><span>)</span>
		<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
	<span>case</span> <span>Null</span><span>:</span>
		<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;null&#34;</span><span>)</span>
		<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
	<span>case</span> <span>String</span><span>:</span>
		<span>length</span> <span>=</span> <span>parseString</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>)</span>
		<span>if</span> <span>length</span> <span>&lt;</span> <span>2</span> <span>{</span>
			<span>return</span> <span>nil</span>
		<span>}</span>
		<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
	<span>case</span> <span>0</span><span>:</span>
		<span>// eof</span>
		<span>return</span> <span>nil</span>
	<span>default</span><span>:</span>
		<span>length</span> <span>=</span> <span>s</span><span>.</span><span>parseNumber</span><span>()</span>
		<span>if</span> <span>length</span> <span>&lt;</span> <span>0</span> <span>{</span>
			<span>return</span> <span>nil</span>
		<span>}</span>
	<span>}</span>
	<span>return</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()[</span><span>:</span><span>length</span><span>]</span>
<span>}</span></code></pre>
</div>
</div>
<p>This is the core loop of <code>Scanner.Next</code>.
<code>Scanner.Next</code> skips over any intermediate whitespace, determines the token from the first character in the window, then continues to read until the token is read or we hit the end of the input.</p>
<p>Let’s look at how <code>token</code> works, then we’ll talk about some optimisations</p>
<div>
<div>
<pre><code data-lang="go"><span>// token positions the scanner at the next token in the stream</span>
<span>// and returns the first byte of the token.</span>
<span>func</span> <span>(</span><span>s</span> <span>*</span><span>Scanner</span><span>)</span> <span>token</span><span>()</span> <span>byte</span> <span>{</span>
	<span>w</span> <span>:=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()</span>
	<span>for</span> <span>{</span>
		<span>for</span> <span>_</span><span>,</span> <span>c</span> <span>:=</span> <span>range</span> <span>w</span> <span>{</span>
			<span>if</span> <span>whitespace</span><span>[</span><span>c</span><span>]</span> <span>{</span>
				<span>s</span><span>.</span><span>offset</span><span>++</span>
				<span>continue</span>
			<span>}</span>

			<span>// release whitespace</span>
			<span>s</span><span>.</span><span>br</span><span>.</span><span>release</span><span>(</span><span>s</span><span>.</span><span>offset</span><span>)</span>
			<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>0</span>
			<span>return</span> <span>c</span>
		<span>}</span>
		<span>if</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>extend</span><span>()</span> <span>==</span> <span>0</span> <span>{</span>
			<span>// eof</span>
			<span>return</span> <span>0</span>
		<span>}</span>
		<span>w</span> <span>=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()[</span><span>s</span><span>.</span><span>offset</span><span>:</span><span>]</span>
	<span>}</span>
<span>}</span></code></pre>
</div>
</div>
<div>
<ul>
<li>
<p>We start by getting the current window from the <code>byteReader</code>.
This is a <code>[]byte</code> slice of all the data that is yet to be read.</p>
</li>
<li>
<p>We’re looking for the first non whitespace character.
If the character is a whitespace we increment <code>s.offset</code> to ignore the character and loop around.</p>
</li>
<li>
<p>If we do find a non whitespace character, we release <code>s.offset</code> characters from the front of the window.
Now the start of the window is properly aligned with the first character of the token.</p>
</li>
<li>
<p>It turns out that we also get the first character of the token for free, it’s in <code>c</code>, so we can return that as a hint to <code>Scanner.Next</code>.</p>
</li>
<li>
<p>If we run out of characters without hitting a token then we called <code>extend()</code> to grow the window.</p>
</li>
<li>
<p>If we couldn’t grow, then we’ve run out of input and haven’t got a token, so give up.</p>
</li>
<li>
<p>Otherwise update <code>w</code> with a new window.</p>
</li>
</ul>
</div>
<p>Some things to note:</p>
<div>
<ul>
<li>
<p>Note the lack of error handling, it’s not part of the inner loop, it only happens when we have to read more data from the underlying reader via <code>extend</code>. <sup>[<a id="_footnoteref_4" href="#_footnotedef_4" title="View footnote.">4</a>]</sup></p>
</li>
<li>
<p><code>extend</code> hides the process of reading into, growing, refilling the buffer, etc. The makes the caller--<code>Scanner.token</code>--simpler; if there is data in the window, process it, extend if you need too. If you can’t extend, give up.</p>
</li>
<li>
<p><code>release</code> is similar, it shrinks the start of the window to exclude data that no longer care about.</p>
</li>
<li>
<p><code>extend</code> is not in the hot path, so there is no need to optimise it, its performance is a function of the buffer it is given.
In practice an initial buffer of 8k is sufficient.</p>
</li>
</ul>
</div>
<p>Let’s talk about the performance of this code.</p>
<div>
<div>
<pre><code>name                     time/op
Scanner/canada-16         4.41ms ± 2%
Scanner/citm_catalog-16   2.55ms ± 3%
Scanner/twitter-16        1.03ms ± 1%
Scanner/code-16           4.21ms ± 1%
Scanner/example-16        21.4µs ± 1%
Scanner/sample-16          822µs ± 1%

name                     speed
Scanner/canada-16        510MB/s ± 2%
Scanner/citm_catalog-16  677MB/s ± 3%
Scanner/twitter-16       615MB/s ± 1%
Scanner/code-16          461MB/s ± 1%
Scanner/example-16       608MB/s ± 1%
Scanner/sample-16        837MB/s ± 1%</code></pre>
</div>
</div>
<p>Comparing the performance of <code>Scanner.Next</code> to our whitespace benchmark we can see that we’re between 1/4 and 2/5ths of our baseline.</p>
<p>Let’s talk about improvements we can make to the code.
Note the amount of work being spent to keep <code>s.offset</code> up to date.
We know that <code>s.offset</code> is set to 0 just before <code>Scanner.Next</code> calls this function, and we set <code>s.offset</code> to zero on the way out of the function, so the changes we make to <code>s.offset</code> within the function are invisible—​it’s zero on entry, and zero on exit.</p>
<p>We can rewrite the function to keep a local <code>offset</code> value, which has an impressive effect on <code>token</code>.</p>
<div>
<div>
<pre><code data-lang="go"><span>func</span> <span>(</span><span>s</span> <span>*</span><span>Scanner</span><span>)</span> <span>token</span><span>()</span> <span>byte</span> <span>{</span>
	<span>w</span> <span>:=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()</span>
	<span>offset</span> <span>:=</span> <span>0</span>
	<span>for</span> <span>{</span>
		<span>for</span> <span>_</span><span>,</span> <span>c</span> <span>:=</span> <span>range</span> <span>w</span> <span>{</span>
			<span>if</span> <span>whitespace</span><span>[</span><span>c</span><span>]</span> <span>{</span>
				<span>offset</span><span>++</span>
				<span>continue</span>
			<span>}</span>

			<span>// release whitespace</span>
			<span>s</span><span>.</span><span>br</span><span>.</span><span>release</span><span>(</span><span>offset</span><span>)</span>
			<span>return</span> <span>c</span>
		<span>}</span>
		<span>if</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>extend</span><span>()</span> <span>==</span> <span>0</span> <span>{</span>
			<span>// eof</span>
			<span>return</span> <span>0</span>
		<span>}</span>
		<span>w</span> <span>=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()[</span><span>offset</span><span>:</span><span>]</span>
	<span>}</span>
<span>}</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code>name                     old time/op    new time/op    delta
Scanner/canada-16          4.39ms ± 1%    4.43ms ± 4%     ~     (p=1.000 n=5+5)
Scanner/citm_catalog-16    2.52ms ± 1%    1.80ms ± 4%  -28.46%  (p=0.008 n=5+5)
Scanner/twitter-16         1.03ms ± 2%    0.95ms ± 3%   -7.41%  (p=0.008 n=5+5)
Scanner/code-16            4.24ms ± 2%    4.18ms ± 1%     ~     (p=0.095 n=5+5)
Scanner/example-16         21.4µs ± 1%    18.9µs ± 2%  -11.68%  (p=0.008 n=5+5)
Scanner/sample-16           828µs ± 2%     528µs ± 2%  -36.24%  (p=0.008 n=5+5)

name                     old speed      new speed      delta
Scanner/canada-16         512MB/s ± 1%   509MB/s ± 4%     ~     (p=1.000 n=5+5)
Scanner/citm_catalog-16   685MB/s ± 1%   958MB/s ± 4%  +39.84%  (p=0.008 n=5+5)
Scanner/twitter-16        616MB/s ± 2%   665MB/s ± 3%   +8.01%  (p=0.008 n=5+5)
Scanner/code-16           458MB/s ± 2%   465MB/s ± 1%     ~     (p=0.095 n=5+5)
Scanner/example-16        608MB/s ± 1%   688MB/s ± 2%  +13.23%  (p=0.008 n=5+5)
Scanner/sample-16         831MB/s ± 2%  1303MB/s ± 2%  +56.84%  (p=0.008 n=5+5)</code></pre>
</div>
</div>
<p>By keeping <code>offset</code> local the compiler avoided those temporary writes back to memory.
The question I have for you is why did this improve some inputs and not others?</p>
<p>The answer is different inputs have different amounts of whitespace.
For example <code>canada</code> only has 33 whitespace characters whereas <code>citm</code> has 1,227,563.</p>
<details>
<summary>Quiz me after the talk why the compiler can’t optimise these writes away.</summary>
<div>
<p>Hint: <code>panic()</code></p>
</div>
</details>
<div>
<h3 id="_inlining"><a href="#_inlining"></a><a href="#_inlining">Inlining</a></h3>
<p>There is a larger improvement we can make for the runtime of this code, and it relates to inlining.
Inlining is the process of automatically (or manually) copying the body of a function into, <em>in line with</em>, its caller.
This avoids the overhead of the function call.</p>
<p>The Go compiler has reasonable support for inlining, but has a number of limitations.</p>
<div>
<div>
<pre><code> % go build -gcflags=-m=2 2&gt;&amp;1 | grep cannot | grep -v decoder
./reader.go:31:6: cannot inline (*byteReader).extend: function too complex: cost 198 exceeds budget 80
./scanner.go:99:6: cannot inline (*Scanner).token: unhandled op FOR
./scanner.go:130:6: cannot inline validateToken: unhandled op FOR
./scanner.go:153:6: cannot inline parseString: unhandled op FOR
./scanner.go:182:6: cannot inline (*Scanner).parseNumber: unhandled op FOR
./scanner.go:56:6: cannot inline (*Scanner).Next: function too complex: cost 476 exceeds budget 80</code></pre>
</div>
</div>
<p>The first is the size of the function, <code>byteReader.extend</code> cannot be inlined because it is too complex.
<sup>[<a id="_footnoteref_5" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>
The second is statements within the function, <code>Scanner.token</code> cannot be inlined because it contains a <code>for</code> statement.</p>
<p>Let’s go back to the constraints:</p>
<div>
<ul>
<li>
<p><code>Scanner.Next</code> is called for each token in the input.</p>
</li>
<li>
<p>This means that <code>Scanner.token</code> is called for each token in the input.</p>
</li>
<li>
<p><code>Scanner.token</code> cannot be automatically inlined into its caller because it is too complex.</p>
</li>
<li>
<p>Therefore we’re paying <em>two</em> function calls per token.</p>
</li>
</ul>
</div>
<p>We can remove one of these by manually inlining <code>Scanner.token</code> into its caller.</p>
<div>
<div>
<pre><code data-lang="go"><span>func</span> <span>(</span><span>s</span> <span>*</span><span>Scanner</span><span>)</span> <span>Next</span><span>()</span> <span>[]</span><span>byte</span> <span>{</span>
	<span>// release the previous token</span>
	<span>s</span><span>.</span><span>br</span><span>.</span><span>release</span><span>(</span><span>s</span><span>.</span><span>offset</span><span>)</span>
	<span>w</span> <span>:=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()</span>
	<span>offset</span> <span>:=</span> <span>0</span>
	<span>for</span> <span>{</span>
		<span>for</span> <span>_</span><span>,</span> <span>c</span> <span>:=</span> <span>range</span> <span>w</span> <span>{</span>
			<span>if</span> <span>whitespace</span><span>[</span><span>c</span><span>]</span> <span>{</span>
				<span>offset</span><span>++</span>
				<span>continue</span>
			<span>}</span>

			<span>// release whitespace</span>
			<span>s</span><span>.</span><span>br</span><span>.</span><span>release</span><span>(</span><span>offset</span><span>)</span>

			<span>length</span> <span>:=</span> <span>0</span>
			<span>switch</span> <span>c</span> <span>{</span>
			<span>case</span> <span>ObjectStart</span><span>,</span> <span>ObjectEnd</span><span>,</span> <span>Colon</span><span>,</span> <span>Comma</span><span>,</span> <span>ArrayStart</span><span>,</span> <span>ArrayEnd</span><span>:</span>
				<span>length</span> <span>=</span> <span>1</span>
				<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>1</span>
			<span>case</span> <span>True</span><span>:</span>
				<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;true&#34;</span><span>)</span>
				<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
			<span>case</span> <span>False</span><span>:</span>
				<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;false&#34;</span><span>)</span>
				<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
			<span>case</span> <span>Null</span><span>:</span>
				<span>length</span> <span>=</span> <span>validateToken</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>,</span> <span>&#34;null&#34;</span><span>)</span>
				<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
			<span>case</span> <span>String</span><span>:</span>
				<span>// string</span>
				<span>length</span> <span>=</span> <span>parseString</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>br</span><span>)</span>
				<span>if</span> <span>length</span> <span>&lt;</span> <span>2</span> <span>{</span>
					<span>return</span> <span>nil</span>
				<span>}</span>
				<span>s</span><span>.</span><span>offset</span> <span>=</span> <span>length</span>
			<span>default</span><span>:</span>
				<span>// ensure the number is correct.</span>
				<span>length</span> <span>=</span> <span>s</span><span>.</span><span>parseNumber</span><span>()</span>
				<span>if</span> <span>length</span> <span>&lt;</span> <span>0</span> <span>{</span>
					<span>return</span> <span>nil</span>
				<span>}</span>
			<span>}</span>
			<span>return</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()[</span><span>:</span><span>length</span><span>]</span>
		<span>}</span>
		<span>if</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>extend</span><span>()</span> <span>==</span> <span>0</span> <span>{</span>
			<span>// eof</span>
			<span>return</span> <span>nil</span>
		<span>}</span>
		<span>w</span> <span>=</span> <span>s</span><span>.</span><span>br</span><span>.</span><span>window</span><span>()[</span><span>offset</span><span>:</span><span>]</span>
	<span>}</span>
<span>}</span></code></pre>
</div>
</div>
<p>The results support our thesis:</p>
<div>
<div>
<pre><code>name                     old time/op    new time/op    delta
Scanner/canada-16          4.36ms ± 1%    3.50ms ± 0%  -19.68%  (p=0.008 n=5+5)
Scanner/citm_catalog-16    1.80ms ± 1%    1.56ms ± 2%  -13.16%  (p=0.008 n=5+5)
Scanner/twitter-16          965µs ± 2%     833µs ± 2%  -13.75%  (p=0.008 n=5+5)
Scanner/code-16            4.15ms ± 1%    3.61ms ± 1%  -12.82%  (p=0.008 n=5+5)
Scanner/example-16         18.9µs ± 2%    16.6µs ± 1%  -12.42%  (p=0.008 n=5+5)
Scanner/sample-16           515µs ± 1%     472µs ± 2%   -8.34%  (p=0.008 n=5+5)

name                     old speed      new speed      delta
Scanner/canada-16         516MB/s ± 1%   642MB/s ± 0%  +24.50%  (p=0.008 n=5+5)
Scanner/citm_catalog-16   960MB/s ± 1%  1105MB/s ± 2%  +15.16%  (p=0.008 n=5+5)
Scanner/twitter-16        654MB/s ± 2%   759MB/s ± 1%  +15.94%  (p=0.008 n=5+5)
Scanner/code-16           468MB/s ± 1%   537MB/s ± 1%  +14.69%  (p=0.008 n=5+5)
Scanner/example-16        689MB/s ± 2%   787MB/s ± 1%  +14.17%  (p=0.008 n=5+5)
Scanner/sample-16        1.33GB/s ± 1%  1.46GB/s ± 1%   +9.11%  (p=0.008 n=5+5)</code></pre>
</div>
</div>
<p>By saving the function call we’ve improved throughput by 9-24%.
The largest improvement comes from <code>canada</code>, which basically contained no whitespace, so the call to <code>Scanner.token</code> almost always returned immediately having done no work!</p>
<p>To recap the major optimisations were:</p>
<div>
<ul>
<li>
<p>Avoiding <code>s.offset</code> updates. They cannot be registerised, CPU has to do a write on every iteration.
<code>s.offset</code> updates reduced from one per byte to one per token.</p>
</li>
<li>
<p><code>Scanner.Next</code> and <code>Scanner.token</code> were effectively one function spread over two.
Each are too large to be inlined, so we’re paying for an extra function call per token.
Manually inlining them increased the indentation depth of the function, but delivered substantial speedups.</p>
</li>
<li>
<p><em>Most</em> JSON contains some whitespace, it’s moderately optimised for human readability.
It turns out, the more whitespace, the faster <code>pkg/json</code> decodes! <code>citm</code> is over 50% of the baseline, <code>sample</code> is nearly 75%.</p>
</li>
</ul>
</div>
<div>
<div>
<p>Take away: Avoiding function calls <em>can</em> improve performance in the hot path.</p>
</div>
</div>
</div>
</div></div>
  </body>
</html>
