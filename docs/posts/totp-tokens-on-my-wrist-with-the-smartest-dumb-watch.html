<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.singleton.io/posts/2022-10-17-otp-on-wrist/">Original</a>
    <h1>TOTP tokens on my wrist with the smartest dumb watch</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

    

    <div>
        <article itemscope="" itemprop="blogPost">
    <div>
        
        <div itemprop="articleBody">
            

<p><img src="https://blog.singleton.io/static/imgs-dumbwatch/watch.png" alt="A Casio F-91W showing my Google TOTP code"/></p>

<p>I recently took delivery of a new replacement logic board for the ubiquitous classic Casio F-91W from <a href="https://joeycastillo.github.io/Sensor-Watch-Documentation/">Sensor Watch</a>. The F-91W needs no introduction. It’s probably the most popular quartz watch in the world with something like <a href="https://spectrum.ieee.org/the-consumer-electronics-hall-of-fame-casio-f91w-wristwatch">90 million</a> total units sold. The Sensor Watch board replaces the F-91W’s original quartz movement with a new ARM Cortex M0+ powered brain. It uses the original LCD display, pushers and piezo-buzzer. The board is programmable and the Sensor Watch project provides a clean and easy to modify set of watchfaces and “complications” (little utility apps). There’s no Bluetooth radio to connect to other devices, but the combination of a lightweight tried-and-true utility watch case, with months long battery life and features you can rebuild at home is surprisingly powerful. In about an hour I was able to: replace the logic board, configure my 2FA secrets for my Google and Github accounts so I could get my most frequently used OTP codes right on my wrist and write a whole new ratemeter watchface for use as a rowing strokemeter or cadence meter! It’s a delight to hack on, and there’s even a wasm based emulator that makes testing on your computer easy and means you can play with my personal build right on this webpage →</p>

<center></center>

<p>Press MODE once to get to the 2FA token face. ALARM now cycles between Google and Github tokens. Don’t worry, I’ve replaced my real TOTP secrets with dummy values. Press MODE again to get to my new ratemeter watchface. Now start pressing ALARM periodically to measure the rate per minute of whatever you’re tracking. The remaining watchfaces in this build cycle through a world clock, a sunrise/sunset calculator, a moon phase indicator, a live read out from the temperature sensor in the watch, 24h setting picker, and time/date set mode. There are a bunch of other cool watchfaces in the Sensor Watch <code>movement</code> source tree including a pulsometer and orrery.</p>

<p>The process of upgrading the F-91W module has been well documented on <a href="https://blog.jgc.org/2022/10/pimping-my-casio-with-oddly-specific.html">John Graham-Cumming’s blog</a> - I also ordered one of those cool orange watches to transfer my board into soon!</p>

<p>Here’s some info on how to get your TOTP secrets into the build and how I built the watchface:</p>

<h2 id="totp-watchface">TOTP watchface</h2>

<p>This watchface generates time based one time passwords (two factor auth codes) allowing you to sign in securely to many popular websites (e.g. Google, Github). Time-based one-time password (TOTP) is a computer algorithm that generates a one-time password (OTP) that uses the current time as a source of uniqueness.</p>

<p>Press the Alarm button to cycle between your configured websites / TOTP secrets.</p>

<p>The watchface supports multiple websites / TOTP secrets, which need to be extracted from TOTP QR codes and added to the source code for the watchface as follows:</p>

<ol>
<li>Obtain a TOTP secret or QR code from the website you want to generate codes for.</li>
<li>If you have just the QR code, <a href="https://stefansundin.github.io/2fa-qr/">Stefan Sundin’s web site</a> will allow you to extract the secret - it will be an alphanumeric string around 32 characters long, which is the TOTP secret encoded in Base32.</li>
<li>To add the secret to the watchface code, you need to convert it to hexadecimal bytes. This <a href="https://cryptii.com/pipes/base32-to-hex">cryptii.com</a> page will allow you to do that conversion. Note you’ll have to enter your TOTP secret in uppercase.</li>
<li>Finally, you’ll need to take the hexadecimal bytes and add them to the TOTP watchface source code and recompile <code>movement</code>:</li>
</ol>

<h3 id="edit-totp-face-c">Edit <code>totp_face.c</code></h3>

<p>You may want to remove the demo keys. Assuming you want to add a key to the end of the list:</p>

<pre><code>static const uint8_t num_keys = 2;
</code></pre>

<p>Add one to the number on this line.</p>

<pre><code>static uint8_t keys[] = {
   // Add the hex bytes for your key
};
</code></pre>

<p>Add the hexadecimal bytes from step 3 to the end of this array, comma separated and each one preceeded by <code>0x</code>. Don’t forget to add a comma after the previous final byte.</p>

<pre><code>static const uint8_t key_sizes[] = {
</code></pre>

<p>Add the size of your secret (the number of hex bytes you just added) to the end of this array.</p>

<pre><code>static const uint32_t timesteps[] = {
</code></pre>

<p>Add another <code>30</code> entry to the end of this array.</p>

<pre><code>static const char labels[][2] = {
</code></pre>

<p>Add a label for your secret… E.g. if it’s for your Google account you might want to add <code>{ &#39;g&#39;, &#39;o&#39; }</code> as a friendly label.</p>

<p>That’s it - enjoy the convenience of TOTP codes on your wrist!</p>

<h2 id="writing-a-new-watchface-ratemeter">Writing a new watchface – ratemeter</h2>

<p>You can find all the code for this watchface in <a href="https://github.com/joeycastillo/Sensor-Watch/pull/101">this pull request</a> I submitted to the main project.</p>

<p>Writing this feature was surprisingly simple - the implementation is pretty much all in this one main loop function.</p>

<pre><code>bool ratemeter_face_loop(movement_event_t event,
                         movement_settings_t *settings,
                         void *context) {
    (void) settings;
    ratemeter_state_t *ratemeter_state = (ratemeter_state_t *)context;
    char buf[14];
</code></pre>

<p>This function needs to handle events for any button presses you want to handle as well as each tick of the clock.</p>

<pre><code>    switch (event.event_type) {
</code></pre>

<p>The tick frequency is something your watchface can request if you want to time intervals or handle an animation or similar.</p>

<p><code>movement</code> provides a utility function called <code>watch_display_string</code> which does its very best to render an alphanumeric string across the various 7+ segment elements on the Casio display. There are lots of foibles trying to map arbitrary strings onto this limited surface, but it’s all very clearly explained in <a href="https://joeycastillo.github.io/Sensor-Watch-Documentation/wig/display.html">the docs</a>.</p>

<p>So, each of the states we care about in turn:</p>

<p><em>When the watchface is activated display “RA” in the day indicators.</em></p>

<pre><code>        case EVENT_ACTIVATE:
            watch_display_string(&#34;ra          &#34;, 0);
            break;
</code></pre>

<p><em>When the MODE button is pressed, move on to the next watchface.</em></p>

<pre><code>        case EVENT_MODE_BUTTON_UP:
            movement_move_to_next_face();
            break;
</code></pre>

<p><em>When the LIGHT button is pressed, turn on the light!</em></p>

<pre><code>        case EVENT_LIGHT_BUTTON_DOWN:
            movement_illuminate_led();
            break;
</code></pre>

<p><em>Now the real business… When the ALARM button is pressed:</em>
1. update the computed rate to display based on the interval between this and the previous button press.
2. reset the tick counter (part of the bespoke state of this watchface which I defined).
3. request a fast tick frequency (this constant is defined as one sixteenth of a second).</p>

<pre><code>        case EVENT_ALARM_BUTTON_DOWN:
            if (ratemeter_state-&gt;ticks != 0) {
                ratemeter_state-&gt;rate =
                    (int16_t)(60.0 / 
                        ((float)ratemeter_state-&gt;ticks /
                         (float)RATEMETER_FACE_FREQUENCY));
            }
            ratemeter_state-&gt;ticks = 0;
            movement_request_tick_frequency(RATEMETER_FACE_FREQUENCY);
            break;
</code></pre>

<p><em>And finally, on every tick…</em>
Update the display to show the current rate or “Hi” if the rate is faster than 500 per minute and “Lo” below once per minute. Plus, increment the tick counter!</p>

<pre><code>        case EVENT_TICK:
            if (ratemeter_state-&gt;rate == 0) {
                watch_display_string(&#34;ra          &#34;, 0);
            } else {
                if (ratemeter_state-&gt;rate &gt; 500) {
                    watch_display_string(&#34;ra      Hi&#34;, 0);
                } else if (ratemeter_state-&gt;rate &lt; 1) {
                    watch_display_string(&#34;ra      Lo&#34;, 0);
                } else {
                    sprintf(buf, &#34;ra  %-3d pn&#34;, ratemeter_state-&gt;rate);
                    watch_display_string(buf, 0);
                }
            }
            ratemeter_state-&gt;ticks++;
            break;
</code></pre>

<p>That’s it - this was both easier and more fun than I expected.</p>

<p>If you enjoyed this, you might like to get your own Sensor Watch from <a href="https://www.oddlyspecificobjects.com/products/sensorwatch/">Oddly Specific Objects</a> - I’m not affiliated with them, I just think what Joey has made here is really cool!</p>

        </div>

        

        


        
    </div>
</article>
    </div>
    </div></div>
  </body>
</html>
