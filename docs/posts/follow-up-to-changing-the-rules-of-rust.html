<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://without.boats/blog/follow-up-to-changing-the-rules-of-rust/">Original</a>
    <h1>Follow up to “Changing the rules of Rust”</h1>
    
    <div id="readability-page-1" class="page"><div><header><nav><a href="https://without.boats/blog">Posts</a>
<a href="https://without.boats/tags">Tags</a></nav></header><main><article><section><p>In <a href="https://without.boats/blog/changing-the-rules-of-rust">my previous post</a>, I described the idea of using an edition mechanism to introduce a new
auto trait. I wrote that the compiler would need to create an “unbreakable firewall” to prevent
using <code>!Leak</code> types from the new edition with code from the old edition that assumes values of all
types can be leaked.</p><p>The response has been pretty optimistic that ensuring this would be possible, even though I wrote in
the post myself that I “despair” over how difficult it was. I’ve received a great example from Ariel
Ben-Yehuda which demonstrates how this problem is more difficult to solve than you would probably
think.</p><p>This example is going to involve four different crates. The first crate, <code>foo</code>, is in the 2024 edition, and
defines a trait with a single generic method:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// crate foo; edition = 2024
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>trait</span><span> </span><span>Foo</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>foo</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>input</span>: <span>T</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The second crate, <code>bar</code>, is in the 2021 edition, depends on <code>foo</code>, and implements that trait for its
own type. Its implementation forgets the argument to that method:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// crate bar; edition = 2021
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Bar</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>foo</span>::<span>Foo</span><span> </span><span>for</span><span> </span><span>Bar</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>foo</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>input</span>: <span>T</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>std</span>::<span>mem</span>::<span>forget</span><span>(</span><span>input</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This code is legal under the firewall rules I listed last time!</p><p>The third crate, <code>baz</code>, is in the 2024 edition. It only depends on <code>foo</code>, not <code>bar</code>, and uses the
trait in a new function, using its own private <code>!Leak</code> type:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// crate baz; edition = 2024
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Baz</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>!</span><span>Leak</span><span> </span><span>for</span><span> </span><span>Baz</span><span> </span><span>{</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>baz</span><span>&lt;</span><span>T</span>: <span>foo</span>::<span>Foo</span><span>&gt;</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>T</span>::<span>foo</span><span>(</span><span>Baz</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>All of the code in <code>foo</code> and <code>baz</code> is in the 2024 edition, and all of it is valid, because none of
it involves a <code>Leak</code> bound or any 2021 edition code. Maybe you can see where this is going..</p><p>A fourth crate, <code>quux</code>, depends on both <code>bar</code> and <code>baz</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// crate quux;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>quux</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>baz</span>::<span>baz</span>::<span>&lt;</span><span>bar</span>::<span>Bar</span><span>&gt;</span><span>()</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This code now leaks a type that doesn’t implement <code>Leak</code>! <code>baz::baz</code> will pass its <code>!Leak</code> type to
<code>bar::Bar::foo</code>, which will leak it. Somewhere, there must be an error. But where?</p><p>Before you start typing your response, consider:</p><ul><li>I avoided saying what edition <code>quux</code> is compiling under. It does not matter. If all of <code>foo</code>,
<code>bar</code>, and <code>baz</code> compiled, it must be <code>quux</code> which doesn’t compile, regardless of what edition
it’s compiled under.</li><li>The error cannot be in <code>foo</code>, because because surely traits with generic methods are not an error
and will not become an error in 2024.</li><li>The error cannot be in <code>baz</code>, because nothing in <code>baz</code> is invalid at all: you instantiated a
generic interface with a type that meets the bounds of that interface.</li><li>Upgrading your crate to a new edition has historically not been considered a breaking change,
except insofar as it raises your MSRV. This is very important for achieving a seamless upgrade
across editions, as everyone will not upgrade at once. If you say the error is in <code>bar</code>, for
example, the implication is that upgrading <code>foo</code> from 2021 to 2024 is a breaking change, because
you can implement both <code>foo</code> and <code>bar</code> exactly as written under edition 2021 today. So the error
cannot be in <code>bar</code>.</li></ul><p>It seems like the error just to be in <code>quux</code>, but none of the types involved in <code>quux</code> have anything
at all to do with <code>Leak</code>. What are the rules you are enforcing to make <code>quux</code> error? And how do you
explain them to users so that they have half a clue what’s going on when they run into this issue in
a practical scenario? Good luck!</p></section></article></main></div></div>
  </body>
</html>
