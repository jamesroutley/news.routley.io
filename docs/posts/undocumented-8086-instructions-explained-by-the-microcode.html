<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/07/undocumented-8086-instructions.html">Original</a>
    <h1>Undocumented 8086 instructions, explained by the microcode</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5516205124640022120" itemprop="description articleBody">



<p>What happens if you give the Intel 8086 processor an instruction that doesn&#39;t exist?
A modern microprocessor (80186 and later) will generate an exception, indicating that an illegal instruction
was executed.
However, early microprocessors didn&#39;t include the circuitry to detect illegal instructions, since the chips didn&#39;t have
transistors to spare. Instead these processors would do <em>something</em>,
but the results weren&#39;t specified.<span id="fnref:6502"><a href="#fn:6502">1</a></span></p>
<p>The 8086 has a number of undocumented instructions.
Most of them are simply duplicates of regular instructions, but a few have unexpected behavior, such as revealing the
values of internal, hidden registers.
In the 8086, most instructions are implemented in microcode, so examining the 8086&#39;s microcode can explain why these instructions
behave the way they do.</p>
<p>The photo below shows the 8086 die under a microscope, with the important functional blocks labeled. The metal layer is visible, while the underlying silicon and polysilicon wiring is mostly hidden.
The microcode ROM and the microcode address decoder are in the lower right.
The Group Decode ROM (upper center) is also important, as it performs the first step of instruction decoding.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version." height="589" src="https://static.righto.com/images/8086-ad-undoc/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version.</p>
<h2>Microcode and 8086 instruction decoding</h2>
<p>You might think that machine instructions are the basic steps that a computer performs.
However, instructions usually require multiple steps inside the processor.
One way of expressing these multiple steps is through microcode, a technique dating back to 1951.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
In other words, microcode forms nother layer between the machine instructions and the hardware.
The main advantage of microcode is that it turns the processor&#39;s control logic into a programming task instead of a difficult logic design task.</p>
<p>The 8086&#39;s <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode ROM</a> holds 512 micro-instructions, each 21 bits wide.
Each micro-instruction performs two actions in parallel. First is a move between a source and a destination, typically registers.
Second is an operation that can range from an arithmetic (ALU) operation to a memory access.
The diagram below shows the structure of a 21-bit micro-instruction, divided into six types.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-ad-undoc/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>When executing a machine instruction, the 8086 performs a decoding step.
Although the 8086 is a 16-bit processor, its instructions are based on bytes. In most cases, the first byte specifies the
opcode, which may be followed by additional instruction bytes.
In other cases, the byte is a &#34;prefix&#34; byte, which changes the behavior of the following instruction.
The first byte is analyzed
by something called the <a href="https://www.righto.com/2023/05/8086-processor-group-decode-rom.html">Group Decode ROM</a>.
This circuit categorizes the first byte of the instruction into about <code>35</code> categories that control how the instruction is
decoded and executed.
One category is &#34;1-byte logic&#34;; this indicates a one-byte instruction or prefix that is simple and implemented by logic circuitry in the 8086.
For instructions in this category, microcode is not involved while
the remaining instructions are implemented in microcode.
Many of these instructions are in the &#34;two-byte ROM&#34; category indicating that the instruction has a second byte
that also needs to be decoded by microcode.
This second byte, called the ModR/M byte, specifies that memory addressing mode or registers that the instruction uses.</p>
<p>The next step is the microcode&#39;s address decoder circuit, which determines where to start executing microcode based on
the opcode.
Conceptually, you can think of the microcode as stored in a ROM, indexed by the instruction opcode and a few sequence bits.
However, since many instructions can use the same microcode, it would be inefficient to store duplicate copies of these routines.
Instead, the microcode address decoder permits multiple instructions to reference the same entries in the ROM.
This decoding circuitry is similar to a PLA (Programmable Logic Array) so it matches bit patterns to determine a particular starting point.
This turns out to be important for undocumented instructions since undocumented instructions often match the pattern for a &#34;real&#34; instruction, making the undocumented instruction an alias.</p>
<p>The 8086 has several internal registers that are invisible to the programmer but are used by the microcode.
Memory accesses use the Indirect (<code>IND</code>) and Operand (<code>OPR</code>) registers; the <code>IND</code> register holds the address in the segment,
while the <code>OPR</code> register holds the data value that is read or written.
Although these registers are normally not accessible by the programmer, some undocumented instructions provide access to these registers, as will be described later.</p>
<p>The Arithmetic/Logic Unit (ALU) performs arithmetic, logical, and shift operations in the 8086.
The ALU uses three internal registers: <code>tmpA</code>, <code>tmpB</code>, and <code>tmpC</code>. An ALU operation requires two micro-instructions.
The first micro-instruction specifies the operation (such as <code>ADD</code>) and the temporary register that holds one argument (e.g. <code>tmpA</code>);
the second argument is always in <code>tmpB</code>.
A following micro-instruction can access the ALU result through the pseudo-register <code>Î£</code> (sigma).</p>
<h3>The ModR/M byte</h3>
<p>A fundamental part of the 8086 instruction format is the ModR/M byte, a byte that specifies addressing for many instructions.
The 8086 has a variety of addressing modes, so the ModR/M byte is somewhat complicated.
Normally it specifies one memory address and one register. The memory address is specified through one of eight addressing
modes (below) along with an optional 8- or 16-bit displacement in the instruction.
Instead of a memory address, the ModR/M byte can also specify a second register.
For a few opcodes, the ModR/M byte selects what instruction to execute rather than a register.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/modrm.png"><img alt="The 8086&#39;s addressing modes. From The register assignments, from MCS-86 Assembly Language Reference Guide." height="220" src="https://static.righto.com/images/8086-ad-undoc/modrm-w250.png" title="The 8086&#39;s addressing modes. From The register assignments, from MCS-86 Assembly Language Reference Guide." width="250"/></a></p>
<p>The implementation of the ModR/M byte plays an important role in the behavior of undocumented instructions.
Support for this byte is implemented in both microcode and hardware.
The various memory address modes above are implemented by microcode subroutines, which compute the appropriate memory address and
perform a read if necessary.
The subroutine leaves the memory address in the <code>IND</code> register, and if a read is performed, the value is in the <code>OPR</code> register.</p>
<p>The hardware hides the ModR/M byte&#39;s selection of memory versus register, by making the value available through the pseudo-register <code>M</code>, while the second register is available through <code>N</code>.
Thus, the microcode for an instruction doesn&#39;t need to know if the value was in memory or a register, or which register was selected.
The Group Decode ROM examines the first byte of the instruction to determine if a ModR/M byte is present, and if a read
is required.
If the ModR/M byte specifies memory, the Translation ROM determines which micro-subroutines to call before handling the
instruction itself.
For more on the ModR/M byte, see my post on <a href="https://www.righto.com/2023/02/8086-modrm-addressing.html">Reverse-engineering the ModR/M addressing microcode</a>.</p>
<h2>Holes in the opcode table</h2>
<p>The first byte of the instruction is a value from <code>00</code> to <code>FF</code> in hex.
Almost all of these opcode values correspond to documented 8086 instructions, but there are a few exceptions, &#34;holes&#34; in the opcode table.
The table below shows the 256 first-byte opcodes for the 8086, from hex <code>00</code> to <code>FF</code>. Valid opcodes for the 8086 are in white;
the colored opcodes are undefined and interesting to examine.
Orange, yellow, and green opcodes were given meaning in the 80186, 80286, and 80386 respectively.
The purple opcode is unusual: it was implemented in the 8086 and later processors but not documented.<span id="fnref:prefixes"><a href="#fn:prefixes">2</a></span>
In this section, I&#39;ll examine the microcode for these opcode holes.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/opcodes.png"><img alt="This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version." height="453" src="https://static.righto.com/images/8086-ad-undoc/opcodes-w450.png" title="This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version." width="450"/></a></p><p>This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version.</p>
<h3><code>D6</code>: <code>SALC</code></h3>
<p>The opcode <code>D6</code> (purple above) performs a well-known but undocumented operation that is typically called <code>SALC</code>, for Set AL to Carry.
This instruction sets the <code>AL</code> register to 0 if the carry flag is 0, and sets the <code>AL</code> register to <code>FF</code> if the carry flag is 1.
The curious thing about this undocumented instruction is that it exists in all x86 CPUs, but Intel didn&#39;t mention it until 2017.
Intel probably put this instruction into the processor deliberately as a <a href="https://en.wikipedia.org/wiki/Fictitious_entry#Copyright_traps">copyright trap</a>.
The idea is that if a company created a copy of the 8086 processor and the processor included the <code>SALC</code> instruction, this
would prove that the company had copied Intel&#39;s microcode and thus had potentially violated Intel&#39;s copyright on the microcode.
This came to light when NEC created improved versions of the 8086, the NEC V20 and V30 microprocessors, and was sued by Intel.
Intel analyzed NEC&#39;s microcode but was disappointed to find that NEC&#39;s chip did not include the hidden instruction, showing
that NEC hadn&#39;t copied the microcode.<span id="fnref:magic-instruction"><a href="#fn:magic-instruction">3</a></span>
Although a Federal judge <a href="https://www.nytimes.com/1989/02/08/business/intel-loses-copyright-case-to-nec.html">ruled</a> in 1989 that NEC hadn&#39;t infringed
Intel&#39;s copyright, the 5-year trial ruined NEC&#39;s market momentum.</p>
<p>The <code>SALC</code> instruction is implemented with three micro-instructions, shown below.<span id="fnref:microcode"><a href="#fn:microcode">4</a></span>
The first micro-instruction jumps if the carry (<code>CY</code>) is set.
If not, the next instruction moves 0 to the AL register. <code>RNI</code> (Run Next Instruction) ends the microcode execution
causing the next machine instruction to run.
If the carry was set, all-ones (i.e. <code>FF</code> hex) is moved to the <code>AL</code> register and RNI ends the microcode sequence.</p>
<pre>           JMPS CY 2 <span><b>SALC</b>: jump on carry</span>
ZERO â AL  RNI       <span>Move 0 to AL, run next instruction</span>
ONES â AL  RNI       <span><b>2:</b>Move FF to AL, run next instruction</span>
</pre>

<h3><code>0F</code>: <code>POP CS</code></h3>
<p>The <code>0F</code> opcode is the first hole in the opcode table.
The 8086 has instructions to push and pop the four segment registers, except opcode <code>0F</code> is undefined where <code>POP CS</code> should be.
This opcode performs <code>POP CS</code> successfully, so the question is why is it undefined?
The reason is that <code>POP CS</code> is essentially useless and doesn&#39;t do what you&#39;d expect, so Intel figured it was best not
to document it.</p>
<p>To understand why <code>POP CS</code> is useless, I need to step back and explain the 8086&#39;s segment registers.
The 8086 has a <code>20</code>-bit address space, but 16-bit registers.
To make this work, the 8086 has the concept of segments: memory is accessed in 64K chunks called segments, which are positioned
in the 1-megabyte address space.
Specifically, there are four segments: Code Segment, Stack Segment, Data Segment, and Extra Segment,
with four segment registers that define the start of the segment: <code>CS</code>, <code>SS</code>, <code>DS</code>, and <code>ES</code>.</p>
<p>An inconvenient part of segment addressing  is that if you want to access more than 64K, you need to change the segment register.
So you might push the data segment register, change it temporarily so you can access a new part of memory, and then pop the old data segment
register value off the stack.
This would use the <code>PUSH DS</code> and <code>POP DS</code> instructions.
But why not <code>POP CS</code>?</p>
<p>The 8086 executes code from the code segment, with the instruction pointer (<code>IP</code>) tracking the location in the code segment.
The main problem with <code>POP CS</code> is that it changes the code segment, but not the instruction pointer, so now you are executing
code at the old offset in a new segment.
Unless you line up your code extremely carefully, the result is that you&#39;re jumping to an unexpected place in memory.
(Normally, you want to change <code>CS</code> and the instruction pointer at the same time, using a <code>CALL</code> or <code>JMP</code> instruction.)</p>
<p>The second problem with <code>POP CS</code> is prefetching.
For efficiency, the 8086 prefetches instructions before they are needed, storing them in an 8-byte prefetch queue.
When you perform a jump, for instance, the microcode flushes the prefetch queue so execution will continue with the
new instructions, rather than the old instructions.
However, the instructions that pop a segment register don&#39;t flush the prefetch buffer.
Thus, <code>POP CS</code> not only jumps to an unexpected location in memory, but it will execute an unpredictable number of instructions
from the old code path.</p>
<p>The <code>POP segment register</code> microcode below packs a lot into three micro-instructions.
The first micro-instruction pops a value from the stack.
Specifically, it moves the stack pointer (<code>SP</code>) to the Indirect (<code>IND</code>) register.
The Indirect register is an internal register, invisible to the programmer, that holds the address offset for memory
accesses.
The first micro-instruction also performs a memory read (<code>R</code>) from the stack segment (<code>SS</code>) and then increments <code>IND</code>
by 2 (<code>P2</code>, plus 2).
The second micro-instruction moves <code>IND</code> to the stack pointer, updating the stack pointer with the new value.
It also tells the microcode engine that this micro-instruction is the next-to-last (<code>NXT</code>) and the next machine instruction
can be started.
The final micro-instruction moves the value read from memory to the appropriate segment register and runs the next instruction.
Specifically, reads and writes put data in the internal <code>OPR</code> (Operand) register.
The hardware uses the register <code>N</code> to indicate the register specified by the instruction.
That is, the value will be stored in the <code>CS</code>, <code>DS</code>, <code>ES</code>, or <code>SS</code> register, depending on the bit pattern in the instruction.
Thus, the same microcode works for all four segment registers.
This is why <code>POP CS</code> works even though <code>POP CS</code> wasn&#39;t explicitly implemented in the microcode; it uses the common code.</p>
<pre>SP â IND  R SS,P2 <span><b>POP sr</b>: read from stack, compute IND plus 2</span>
IND â SP  NXT     <span>Put updated value in SP, start next instruction.</span>
OPR â N   RNI     <span>Put stack value in specified segment register</span>
</pre>

<p>But why does <code>POP CS</code> run this microcode in the first place?
The microcode to execute is selected based on the instruction, but multiple instructions can execute the same microcode.
You can think of the address decoder as pattern-matching on the instruction&#39;s bit patterns, where some of the bits can be ignored.
In this case, the <code>POP sr</code> microcode above is run by any instruction with the bit pattern 000??111, where a question mark
can be either a 0 or a 1.
You can verify that this pattern matches <code>POP ES</code> (<code>07</code>), <code>POP SS</code> (<code>17</code>), and <code>POP DS</code> (<code>1F</code>).
However, it also matches <code>0F</code>, which is why the <code>0F</code> opcode runs the above microcode and performs <code>POP CS</code>.
In other words, to make <code>0F</code> do something other than <code>POP CS</code> would require additional circuitry, so it was easier to
leave the action implemented but undocumented.</p>
<h3><code>60</code>-<code>6F</code>: conditional jumps</h3>
<p>One whole row of the opcode table is unused: values <code>60</code> to <code>6F</code>.
These opcodes simply act the same as <code>70</code> to <code>7F</code>, the conditional jump instructions.</p>
<p>The conditional jumps use the following microcode.
It fetches the jump offset from the instruction prefetch queue (<code>Q</code>) and puts the value into the ALU&#39;s <code>tmpBL</code> register,
the low byte of the <code>tmpB</code> register.
It tests the condition in the instruction (<code>XC</code>) and jumps to the <code>RELJMP</code> micro-subroutine if satisfied.
The <code>RELJMP</code> code (not shown) updates the program counter to perform the jump.</p>
<pre>Q â tmpBL                <span><b>Jcond cb:</b> Get offset from prefetch queue</span>
           JMP XC RELJMP <span>Test condition, if true jump to RELJMP routine</span>
           RNI           <span>No jump: run next instruction</span>
</pre>

<p>This code is executed for any instruction matching the bit pattern <code>011?????</code>, i.e. anything from <code>60</code> to <code>7F</code>.
The condition is specified by the four low bits of the instruction.
The result is that any instruction <code>60</code>-<code>6F</code> is an alias for the corresponding conditional jump <code>70</code>-<code>7F</code>.</p>
<h3><code>C0</code>, <code>C8</code>: <code>RET/RETF imm</code></h3>
<p>These undocumented opcodes act like a return instruction, specifically <code>RET imm16</code> (<a href="https://www.os2museum.com/wp/undocumented-8086-opcodes-part-i/">source</a>).
Specifically, the instruction <code>C0</code> is the same as <code>C2</code>, near return, while <code>C8</code> is the same as <code>CA</code>, far return.</p>
<p>The microcode below is executed for the instruction bits <code>1100?0?0</code>, so it is executed for <code>C0</code>, <code>C2</code>, <code>C8</code>, and <code>CA</code>.
It gets two bytes from the instruction prefetch queue (<code>Q</code>) and puts them in the <code>AX</code> register.
Next, it calls <code>FARRET</code>, which performs either a near return (popping <code>PC</code> from the stack) or a far return (popping <code>PC</code> and <code>CS</code>
from the stack). Finally, it adds the original argument to the <code>SP</code>, equivalent to popping that many bytes.</p>
<pre>Q â tmpAL    ADD tmpA    <span><b>RET/RETF iw:</b> Get word from prefetch, set up ADD</span>
Q â tmpAH    CALL FARRET <span>Call Far Return micro-subroutine</span>
IND â tmpB               <span>Move SP (in IND) to tmpB for ADD</span>
Î£ â SP       RNI         <span>Put sum in Stack Pointer, end</span>
</pre>

<p>One tricky part is that the <code>FARRET</code> micro-subroutine examines bit 3 of the instruction to determine whether it does a near
return or a far return.
This is why documented instruction <code>C2</code> is a near return and <code>CA</code> is a far return.
Since <code>C0</code> and <code>C8</code> run the same microcode, they will perform the same actions, a near return and a far return respectively.</p>
<h3><code>C1</code>: <code>RET</code></h3>
<p>The undocumented <code>C1</code> opcode is identical to the documented <code>C3</code>, near return instruction.
The microcode below is executed for instruction bits <code>110000?1</code>, i.e. <code>C1</code> and <code>C3</code>.
The first micro-instruction reads from the Stack Pointer, incrementing <code>IND</code> by 2.
Prefetching is suspended and the prefetch queue is flushed, since execution will continue at a new location.
The Program Counter is updated with the value from the stack, read into the <code>OPR</code> register.
Finally, the updated address is put in the Stack Pointer and execution ends.</p>
<pre>SP â IND  R SS,P2  <span><b>RET: </b> Read from stack, increment by 2</span>
          SUSP     <span>Suspend prefetching</span>
OPR â PC  FLUSH    <span>Update PC from stack, flush prefetch queue</span>
IND â SP  RNI      <span>Update SP, run next instruction</span>
</pre>

<h3><code>C9</code>: <code>RET</code></h3>
<p>The undocumented <code>C9</code> opcode is identical to the documented <code>CB</code>, far return instruction.
This microcode is executed for instruction bits <code>110010?1</code>, i.e. <code>C9</code> and <code>CB</code>, so <code>C9</code> is identical to <code>CB</code>.
The microcode below simply calls the <code>FARRET</code> micro-subroutine to pop the Program Counter and CS register.
Then the new value is stored into the Stack Pointer.
One subtlety is that <code>FARRET</code> looks at bit 3 of the instruction to switch between a near return and a far return, as
described earlier.
Since <code>C9</code> and <code>CB</code> both have bit 3 set, they both perform a far return.</p>
<pre>          CALL FARRET  <span><b>RETF:</b> call FARRET routine</span>
IND â SP  RNI          <span>Update stack pointer, run next instruction</span>
</pre>

<h3><code>F1</code>: <code>LOCK</code> prefix</h3>
<p>The final hole in the opcode table is <code>F1</code>.
This opcode is different because it is implemented in logic rather than microcode.
The Group Decode ROM indicates that <code>F1</code> is a prefix, one-byte logic, and LOCK.
The Group Decode outputs are the same as <code>F0</code>, so <code>F1</code> also acts as a <code>LOCK</code> prefix.</p>
<h2>Holes in two-byte opcodes</h2>
<p>For most of the 8086 instructions, the first byte specifies the instruction.
However, the 8086 has a few instructions where the second byte specifies the instruction: the <code>reg</code> field of the ModR/M byte provides an opcode extension that selects the instruction.<span id="fnref:extension"><a href="#fn:extension">5</a></span>
These fall into four categories which Intel labeled &#34;Immed&#34;, &#34;Shift&#34;, &#34;Group 1&#34;, and &#34;Group 2&#34;, corresponding to opcodes <code>80</code>-<code>83</code>, <code>D0</code>-<code>D3</code>,
<code>F6</code>-<code>F7</code>, and <code>FE</code>-<code>FF</code>.
The table below shows how the second byte selects the instruction.
Note that &#34;Shift&#34;, &#34;Group 1&#34;, and &#34;Group 2&#34; all have gaps, resulting in undocumented values.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/groups.jpg"><img alt="Meaning of the reg field in two-byte opcodes. From MCS-86 Assembly Language Reference Guide." height="129" src="https://static.righto.com/images/8086-ad-undoc/groups-w600.jpg" title="Meaning of the reg field in two-byte opcodes. From MCS-86 Assembly Language Reference Guide." width="600"/></a></p>
<p>These sets of instructions are implemented in two completely different ways.
The &#34;Immed&#34; and &#34;Shift&#34; instructions run microcode in the standard way, selected by the first byte.
For a typical arithmetic/logic instruction such as <code>ADD</code>, bits 5-3 of the first instruction byte are latched into the <code>X</code> register to indicate
which ALU operation to perform.
The microcode specifies a generic ALU operation, while the <code>X</code> register controls whether the operation is an <code>ADD</code>, <code>SUB</code>, <code>XOR</code>, or
so forth.
However, the Group Decode ROM indicates that for the special &#34;Immed&#34; and &#34;Shift&#34; instructions, the <code>X</code> register latches the bits
from the <em>second</em> byte.
Thus, when the microcode executes a generic ALU operation, it ends up with the one specified in the second byte.<span id="fnref:alu"><a href="#fn:alu">6</a></span></p>
<p>The &#34;Group 1&#34; and &#34;Group 2&#34; instructions (<code>F0</code>-<code>F1</code>, <code>FE</code>-<code>FF</code>), however, run different microcode for each instruction.
Bits 5-3 of the second byte replace bits 2-0 of the instruction before executing the microcode.
Thus, <code>F0</code> and <code>F1</code> act as if they are opcodes in the range <code>F0</code>-<code>F7</code>, while <code>FE</code> and <code>FF</code> act as if they are opcodes in the range <code>F8</code>-<code>FF</code>.
Thus, each instruction specified by the second byte can have its own microcode, unlike the &#34;Immed&#34; and &#34;Shift&#34; instructions.
The trick that makes this work is that all the &#34;real&#34; opcodes in the range <code>F0</code>-<code>FF</code> are implemented in logic, not microcode,
so there are no collisions.</p>
<h3>The hole in &#34;Shift&#34;: <code>SETMO</code>, <code>D0</code>..<code>D3/6</code></h3>
<p>There is a &#34;hole&#34; in the list of shift operations when the second byte has the bits <code>110</code> (6).
(This is typically expressed as <code>D0/6</code> and so forth; the value after the slash is the opcode-selection bits in the ModR/M byte.)
Internally, this value selects the ALU&#39;s <code>SETMO</code> (Set Minus One) operation, which simply returns <code>FF</code> or <code>FFFF</code>, for a byte or word operation respectively.<span id="fnref:setmo"><a href="#fn:setmo">7</a></span></p>
<p>The microcode below is executed for 1101000? bit patterns patterns (D0 and D1).
The first instruction gets the value from the <code>M</code> register and sets up the ALU to do whatever operation was
specified in the instruction (indicated by <code>XI</code>).
Thus, the same microcode is used for all the &#34;Shift&#34; instructions, including <code>SETMO</code>.
The result is written back to <code>M</code>. If no writeback to memory is required (<code>NWB</code>), then <code>RNI</code> runs the next instruction, ending
the microcode sequence.
However, if the result is going to memory, then the last line writes the value to memory.</p>
<pre>M â tmpB  XI tmpB, NXT  <span><b>rot rm, 1</b>: get argument, set up ALU</span>
Î£ â M     NWB,RNI F     <span>Store result, maybe run next instruction</span>
          W DS,P0 RNI   <span>Write result to memory</span>
</pre>

<p>The D2 and D3 instructions (1101001?) perform a variable number of shifts, specified by the <code>CL</code> register, so they use different microcode (below).
This microcode loops the number of times specified by <code>CL</code>, but the control flow is a bit tricky to avoid shifting if
the intial counter value is 0.
The code sets up the ALU to pass the counter (in <code>tmpA</code>) unmodified the first time (<code>PASS</code>) and jumps to <b>4</b>, which
updates the counter and sets up the ALU for the shift operation (<code>XI</code>).
If the counter is not zero, it jumps back to <b>3</b>, which performs the previously-specified shift and sets up
the ALU to decrement the counter (<code>DEC</code>).
This time, the code at <b>4</b> decrements the counter.
The loop continues until the counter reaches zero. The microcode stores the result as in the previous microcode.</p>
<pre>ZERO â tmpA               <span><b>rot rm,CL</b>: 0 to tmpA</span>
CX â tmpAL   PASS tmpA    <span>Get count to tmpAL, set up ALU to pass through</span>
M â tmpB     JMPS 4       <span>Get value, jump to loop (4)</span>
Î£ â tmpB     DEC tmpA F   <span><b>3</b>: Update result, set up decrement of count</span>
Î£ â tmpA     XI tmpB      <span><b>4</b>: update count in tmpA, set up ALU</span>
             JMPS NZ 3    <span>Loop if count not zero</span>
tmpB â M     NWB,RNI      <span>Store result, maybe run next instruction</span>
             W DS,P0 RNI  <span>Write result to memory</span>
</pre>

<h3>The hole in &#34;group 1&#34;: <code>TEST</code>, <code>F6/1</code> and <code>F7/1</code></h3>
<p>The <code>F6</code> and <code>F7</code> opcodes are in &#34;group 1&#34;, with the specific instruction specified by bits 5-3 of the second byte.
The second-byte table showed a hole for the <code>001</code> bit sequence.
As explained earlier, these bits replace the low-order bits of the instruction, so <code>F6</code> with 001 is processed as if it were
the opcode <code>F1</code>.
The microcode below matches against instruction bits <code>1111000?</code>, so <code>F6/1</code> and <code>F7/1</code> have the same effect as <code>F6/0</code> and <code>F7/1</code> respectively,
that is, the byte and word <code>TEST</code> instructions.</p>
<p>The microcode below gets one or two bytes from the prefetch queue (<code>Q</code>); the <code>L8</code> condition tests if the operation is
an 8-bit (i.e. byte) operation and skips the second micro-instruction.
The third micro-instruction ANDs the argument and the fetched value.
The condition flags (<code>F</code>) are set based on the result, but the result itself is discarded.
Thus, the <code>TEST</code> instruction tests a value against a mask, seeing if any bits are set.</p>
<pre>Q â tmpBL    JMPS L8 2     <span><b>TEST rm,i:</b> Get byte, jump if operation length = 8</span>
Q â tmpBH                  <span>Get second byte from the prefetch queue</span>
M â tmpA     AND tmpA, NXT <span><b>2:</b> Get argument, AND with fetched value</span>
Î£ â no dest  RNI F         <span>Discard result but set flags.</span>
</pre>

<p>I explained the processing of these &#34;Group 3&#34; instructions in more detail in my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode article</a>.</p>
<h3>The hole in &#34;group 2&#34;: <code>PUSH</code>, <code>FE/7</code> and <code>FF/7</code></h3>
<p>The <code>FE</code> and <code>FF</code> opcodes are in &#34;group 2&#34;, which has a hole for the <code>111</code> bit sequence in the second byte.
After replacement, this will be processed as the <code>FF</code> opcode, which matches the pattern <code>1111111?</code>.
In other words, the instruction will be processed the same as the <code>110</code> bit pattern, which is <code>PUSH</code>.
The microcode gets the Stack Pointer, sets up the ALU to decrement it by 2.
The new value is written to <code>SP</code> and <code>IND</code>. Finally, the register value is written to stack memory.</p>
<!--
For some reason, the [8086 undocumented instructions](https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions) page on Wikipedia doesn't list FE-FF.
-->

<pre>SP â tmpA  DEC2 tmpA   <span><b>PUSH rm</b>: set up decrement SP by 2</span>
Î£ â IND                <span>Decremented SP to IND</span>
Î£ â SP                 <span>Decremented SP to SP</span>
M â OPR    W SS,P0 RNI <span>Write the value to memory, done</span>
</pre>

<h3><code>82</code> and <code>83</code> &#34;Immed&#34; group</h3>
<p>Opcodes <code>80</code>-<code>83</code> are the &#34;Immed&#34; group, performing one of eight arithmetic operations, specified in the ModR/M byte.
The four opcodes differ in the size of the values: opcode <code>80</code> applies an 8-bit immediate value to an 8-bit register, <code>81</code> applies a 16-bit
value to a 16-bit register, <code>82</code> applies an 8-bit value to an 8-bit register, and <code>83</code> applies an 8-bit value to a 16-bit register.
The opcode 82 has the strange situation that <a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_instructions_that_are_widely_available_across_many_x86_CPUs_include">some sources</a> say it is undocumented, but it shows up in some Intel documentation as a valid bit combination (e.g. below).
Note that <code>80</code> and <code>82</code> have the  8-bit to 8-bit action, so the <code>82</code> opcode is redundant.</p>
<p><a href="https://static.righto.com/images/8086-ad-undoc/adc.png"><img alt="ADC is one of the instructions with opcode 80-83. From the 8086 datasheet, page 27." height="34" src="https://static.righto.com/images/8086-ad-undoc/adc-w600.png" title="ADC is one of the instructions with opcode 80-83. From the 8086 datasheet, page 27." width="600"/></a></p><p>ADC is one of the instructions with opcode 80-83. From the <a href="https://www.electro-tech-online.com/datasheets/8086_intel.pdf">8086 datasheet</a>, page 27.</p>
<p>The microcode below is used for all four opcodes.
If the ModR/M byte specifies memory, the appropriate micro-subroutine is called to compute the effective address in <code>IND</code>,
and fetch the byte or word into <code>OPR</code>.
The first two instructions below get the two immediate data bytes from the prefetch queue; for an 8-bit operation, the second byte
is skipped.
Next, the second argument <code>M</code> is loaded into tmpA and the desired ALU operation (<code>XI</code>) is configured.
The result <code>Î£</code> is stored into the specified register <code>M</code> and the operation may terminate with <code>RNI</code>.
But if the ModR/M byte specified memory, the following write micro-operation saves the value to memory.</p>
<pre>Q â tmpBL  JMPS L8 2    <span><b>alu rm,i</b>: get byte, test if 8-bit op</span>
Q â tmpBH               <span>Maybe get second byte</span>
M â tmpA   XI tmpA, NXT <span><b>2</b>: </span>
Î£ â M      NWB,RNI F    <span>Save result, update flags, done if no memory writeback</span>
           W DS,P0 RNI  <span>Write result to memory if needed</span>
</pre>

<p>The tricky part of this is the <code>L8</code> condition, which tests if the operation is 8-bit.
You might think that bit 0 acts as the byte/word bit in a nice, orthogonal way, but the 8086 has a bunch of special cases.
Bit 0 of the instruction typically selects between a byte and a word operation, but there are a bunch of special cases.
The Group Decode ROM creates a signal indicating if bit 0 should be used as the byte/word bit.
But it generates a second signal indicating that an instruction should be forced to operate on bytes, for instructions
such as <code>DAA</code> and <code>XLAT</code>.
Another Group Decode ROM signal indicates that bit 3 of the instruction should select byte or word; this
is used for the <code>MOV</code> instructions with opcodes Bx.
Yet another Group Decode ROM signal indicates that inverted bit 1 of the instruction should select byte or word;
this is used for a few opcodes, including <code>80</code>-<code>87</code>.</p>
<p>The important thing here is that for the opcodes under discussion (<code>80</code>-<code>83</code>), the <code>L8</code> micro-condition uses <em>both</em> bits 0 and 1
to determine if the instruction is 8 bits or not.
The result is that only opcode <code>81</code> is considered 16-bit by the <code>L8</code> test, so it is the only one that uses two immediate bytes
from the instruction.
However, the register operations use only bit 0 to select a byte or word transfer.
The result is that opcode <code>83</code> has the unusual behavior of using an 8-bit immediate operand with a 16-bit register.
In this case, the 8-bit value is sign-extended to form a 16-bit value. That is, the top bit of the 8-bit value fills
the entire upper half of the 16-bit value,
converting an 8-bit signed value to a 16-bit signed value (e.g. -1 is <code>FF</code>, which becomes <code>FFFF</code>).
This makes sense for arithmetic operations, but not much sense for logical operations.</p>
<p>Intel documentation is inconsistent about which opcodes are listed for which instructions.
Intel opcode maps generally define opcodes <code>80</code>-<code>83</code>.
However, lists of specific instructions show opcodes <code>80</code>, <code>81</code>, and <code>83</code> for arithmetic operations but only <code>80</code> and <code>81</code> for logical operations.<span id="fnref:immed"><a href="#fn:immed">8</a></span>
That is, Intel omits the redundant <code>82</code> opcode as well as omitting logic operations that perform sign-extension (<code>83</code>).</p>
<h3>More <code>FE</code> holes</h3>
<p>For the &#34;group 2&#34; instructions, the <code>FE</code> opcode performs a byte operation while <code>FF</code> performs a word operation.
Many of these operations don&#39;t make sense for bytes: <code>CALL</code>, <code>JMP</code>, and <code>PUSH</code>.
(The only instructions supported for <code>FE</code> are <code>INC</code> and <code>DEC</code>.) But what happens if you use the unsupported instructions?
The remainder of this section examines those cases and shows that the results are not useful.</p>
<h4><code>CALL</code>: <code>FE/2</code></h4>
<p>This instruction performs an indirect subroutine call within a segment, reading the target address from the memory location specified by the ModR/M byte.</p>
<p>The microcode below is a bit convoluted because the code falls through into the shared <code>NEARCALL</code> routine, so there is
some unnecessary register movement.
Before this microcode executes, the appropriate ModR/M micro-subroutine will read the target address from memory.
The code below copies the destination address from <code>M</code> to <code>tmpB</code> and stores it into the PC later in the code
to transfer execution.
The code suspends prefetching, corrects the PC to cancel the offset from prefetching, and flushes the prefetch queue.
Finally, it decrements the SP by two and writes the old PC to the stack.</p>
<pre>M â tmpB    SUSP        <span><b>CALL rm</b>: read value, suspend prefetch</span>
SP â IND    CORR        <span>Get SP, correct PC</span>
PC â OPR    DEC2 tmpC   <span>Get PC to write, set up decrement</span>
tmpB â PC   FLUSH       <span><b>NEARCALL</b>: Update PC, flush prefetch</span>
IND â tmpC              <span>Get SP to decrement</span>
Î£ â IND                 <span>Decremented SP to IND</span>
Î£ â SP      W SS,P0 RNI <span>Update SP, write old PC to stack</span>
</pre>

<p>This code will mess up in two ways when executed as a byte instruction.
First, when the destination address is read from memory, only a byte will be read, so the destination address will be corrupted.
(I think that the behavior here depends on the bus hardware. The 8086 will ask for a byte from memory but will
read the word that is placed on the bus.
Thus, if memory returns a word, this part may operate correctly.
The 8088&#39;s behavior will be different because of its 8-bit bus.)
The second issue is writing the old PC to the stack because only a byte of the PC will be written.
Thus, when the code returns from the subroutine call, the return address will be corrupt.</p>
<h4><code>CALL</code>: <code>FE/3</code></h4>
<p>This instruction performs an indirect subroutine call between segments, reading the target address from the memory location specified by the ModR/M byte.</p>
<pre>IND â tmpC  INC2 tmpC    <span><b>CALL FAR rm</b>: set up IND+2</span>
Î£ â IND     R DS,P0      <span>Read new CS, update IND</span>
OPR â tmpA  DEC2 tmpC    <span>New CS to tmpA, set up SP-2</span>
SP â tmpC   SUSP         <span><b>FARCALL</b>: Suspend prefetch</span>
Î£ â IND     CORR         <span><b>FARCALL2</b>: Update IND, correct PC</span>
CS â OPR    W SS,M2      <span>Push old CS, decrement IND by 2</span>
tmpA â CS   PASS tmpC    <span>Update CS, set up for NEARCALL</span>
PC â OPR    JMP NEARCALL <span>Continue with NEARCALL</span>
</pre>

<p>As in the previous <code>CALL</code>, this microcode will fail in multiple ways when executed in byte mode.
The new CS and PC addresses will be read from memory as bytes, which may or may not work.
Only a byte of the old CS and PC will be pushed to the stack.</p>
<h4><code>JMP</code>: <code>FE/4</code></h4>
<p>This instruction performs an indirect jump within a segment, reading the target address from the memory location specified by the ModR/M byte.
The microcode is short, since the ModR/M micro-subroutine does most of the work.
I believe this will have the same problem as the previous <code>CALL</code> instructions, that it will attempt to read a byte from
memory instead of a word.</p>
<pre>        SUSP       <span><b>JMP rm</b>: Suspend prefetch</span>
M â PC  FLUSH RNI  <span>Update PC with new address, flush prefetch, done</span>
</pre>

<h4><code>JMP</code>: <code>FE/5</code></h4>
<p>This instruction performs an indirect jump between segments, reading the new PC and CS values from the memory location specified by the ModR/M byte.
The ModR/M micro-subroutine reads the new PC address. This microcode increments <code>IND</code> and suspends prefetching.
It updates the PC, reads the new CS value from memory, and updates the CS.
As before, the reads from memory will read bytes instead of words, so this code will not meaningfully work in byte mode.</p>
<pre>IND â tmpC  INC2 tmpC   <span><b>JMP FAR rm</b>: set up IND+2</span>
Î£ â IND     SUSP        <span>Update IND, suspend prefetch</span>
tmpB â PC   R DS,P0     <span>Update PC, read new CS from memory</span>
OPR â CS    FLUSH RNI   <span>Update CS, flush prefetch, done</span>
</pre>

<h4><code>PUSH</code>: <code>FE/6</code></h4>
<p>This instruction pushes the register or memory value specified by the ModR/M byte.
It decrements the SP by 2 and then writes the value to the stack.
It will write one byte to the stack but decrements the SP by 2,
so one byte of old stack data will be on the stack along with the data byte.</p>
<pre>SP â tmpA  DEC2 tmpA    <span><b>PUSH rm</b>: Set up SP decrement </span>
Î£ â IND                 <span>Decremented value to IND</span>
Î£ â SP                  <span>Decremented value to SP</span>
M â OPR    W SS,P0 RNI  <span>Write the data to the stack</span>
</pre>

<h2>Undocumented instruction values</h2>
<p>The next category of undocumented instructions is where the first byte indicates a valid instruction, but
there is something wrong with the second byte.</p>
<h3><code>AAM</code>: ASCII Adjust after Multiply</h3>
<p>The <code>AAM</code> instruction is a fairly obscure one, designed to support binary-coded decimal
arithmetic (BCD).
After multiplying two BCD digits, you end up with a binary value between 0 and <code>81</code> (0Ã0 to 9Ã9).
If you want a BCD result, the <code>AAM</code> instruction converts this binary value to BCD, for instance splitting <code>81</code> into the
decimal digits 8 and 1, where the upper digit is <code>81</code> divided by <code>10</code>, and the lower digit is <code>81</code> modulo <code>10</code>.</p>
<p>The interesting thing about <code>AAM</code> is that the 2-byte instruction is <code>D4</code> <code>0A</code>. You might notice that hex <code>0A</code> is <code>10</code>, and this
is not a coincidence.
There wasn&#39;t an easy way to get the value <code>10</code> in the microcode, so instead they made the instruction
provide that value in the second byte.
The undocumented (but well-known) part is that if you provide a value other than <code>10</code>, the instruction will convert the binary input into
digits in that base. For example, if you provide 8 as the second byte, the instruction returns the value divided by 8
and the value modulo 8.</p>
<p>The microcode for <code>AAM</code>, below, sets up the registers.  calls
the <code>CORD</code> (Core Division) micro-subroutine to perform the division,
and then puts the results into <code>AH</code> and <code>AL</code>.
In more detail, the <code>CORD</code> routine divides <code>tmpA/tmpC</code> by <code>tmpB</code>, putting the <em>complement</em> of the quotient in <code>tmpC</code> and leaving the remainder in <code>tmpA</code>.
(If you want to know how CORD works internally, see my <a href="https://www.righto.com/2023/04/reverse-engineering-8086-divide-microcode.html">division post</a>.)
The important step is that the <code>AAM</code> microcode gets the divisor from the prefetch queue (<code>Q</code>).
After calling <code>CORD</code>, it sets up the ALU to perform a 1&#39;s complement of <code>tmpC</code> and puts the result (<code>Î£</code>) into <code>AH</code>.
It sets up the ALU to pass <code>tmpA</code> through unchanged, puts the result (<code>Î£</code>) into <code>AL</code>, and updates the flags accordingly (<code>F</code>).</p>
<pre>Q â tmpB                    <span><b>AAM:</b> Move byte from prefetch to tmpB</span>
ZERO â tmpA                 <span>Move 0 to tmpA</span>
AL â tmpC    CALL CORD      <span>Move AL to tmpC, call CORD.</span>
             COM1 tmpC      <span>Set ALU to complement</span>
Î£ â AH       PASS tmpA, NXT <span>Complement AL to AH</span>
Î£ â AL       RNI F          <span>Pass tmpA through ALU to set flags</span>
</pre>

<p>The interesting thing is why this code has undocumented behavior.
The 8086&#39;s microcode only has support for the constants 0 and all-1&#39;s (<code>FF</code> or <code>FFFF</code>), but the microcode needs to divide by <code>10</code>.
One solution would be to implement an additional micro-instruction and more circuitry to provide the constant <code>10</code>, but every
transistor was precious back then.
Instead, the designers took the approach of simply putting the number <code>10</code> as the second byte of the instruction and loading the
constant from there.
Since the <code>AAM</code> instruction is not used very much, making the instruction two bytes long wasn&#39;t much of a drawback.
But if you put a different number in the second byte, that&#39;s the divisor the microcode will use.
(Of course you could add circuitry to verify that the number is <code>10</code>, but then the implementation is no longer simple.)</p>
<p>Intel could have documented the full behavior, but that creates several problems.
First, Intel would be stuck supporting the full behavior into the future.
Second, there are corner cases to deal with, such as divide-by-zero.
Third, testing the chip would become harder because all these cases would need to be tested.
Fourth, the documentation would become long and confusing.
It&#39;s not surprising that Intel left the full behavior undocumented.</p>
<h3><code>AAD</code>: ASCII Adjust before Division</h3>
<p>The <code>AAD</code> instruction is analogous to <code>AAM</code> but used for BCD division.
In this case, you want to divide a two-digit BCD number by something, where the BCD digits are in <code>AH</code> and <code>AL</code>.
The <code>AAD</code> instruction converts the two-digit BCD number to binary by computing <code>AH</code>Ã<code>10+AL</code>, before you perform
the division.</p>
<p>The microcode for <code>AAD</code> is shown below. The microcode sets up the registers, calls the multiplication micro-subroutine
<code>CORX</code> (Core Times), and
then puts the results in <code>AH</code> and <code>AL</code>.
In more detail, the multiplier comes from the instruction prefetch queue <code>Q</code>.
The <code>CORX</code> routine multiples <code>tmpC</code> by <code>tmpB</code>, putting the result in <code>tmpA/tmpC</code>.
Then the microcode adds the low BCD digit (<code>AL</code>) to the product (<code>tmpB + tmpC</code>), putting the sum (<code>Î£</code>) into <code>AL</code>,
clearing <code>AH</code> and setting the status flags <code>F</code> appropriately.</p>
<p>One interesting thing is that the second-last micro-instruction jumps to <code>AAEND</code>, which is the last
micro-instruction of the <code>AAM</code> microcode above.
By reusing the micro-instruction from <code>AAM</code>, the microcode is one micro-instruction shorter, but
the jump adds one cycle to the execution time.
(The CORX routine is used for integer multiplication; I discuss the internals in <a href="https://www.righto.com/2023/03/8086-multiplication-microcode.html">this post</a>.)</p>
<pre>Q â tmpC              <span><b>AAD:</b> Get byte from prefetch queue.</span>
AH â tmpB   CALL CORX <span>Call CORX</span>
AL â tmpB   ADD tmpC  <span>Set ALU for ADD</span>
ZERO â AH   JMP AAEND <span>Zero AH, jump to AAEND</span>
i
...
Î£ â AL      RNI F     <span><b>AAEND:</b> Sum to AL, done.</span>
</pre>

<p>As with <code>AAM</code>, the constant <code>10</code> is provided in the second byte of the instruction.
The microcode accepts any value here, but values other than <code>10</code> are undocumented.</p>
<h3><code>8C</code>, <code>8E</code>: MOV sr</h3>
<p>The opcodes <code>8C</code> and <code>8E</code> perform a <code>MOV</code> register to or from the specified segment register, using the register specification
field in the ModR/M byte.
There are four segment registers and three selection bits, so an invalid segment register can be specified.
However, the hardware that decodes the register number ignores instruction bit 5 for a segment register. Thus,
specifying a segment register 4 to 7 is the same as specifying a segment register 0 to 3.
For more details, see my article on <a href="https://www.righto.com/2023/03/8086-register-codes.html">8086 register codes</a>.</p>
<h2>Unexpected <code>REP</code> prefix</h2>
<h3><code>REP IMUL</code> / <code>IDIV</code></h3>
<p>The <code>REP</code> prefix is used with string operations to cause the operation to be repeated across a block of memory.
However, if you use this prefix with an <code>IMUL</code> or <code>IDIV</code> instruction, it has the unexpected behavior
of negating the product or the quotient (<a href="https://www.reenigne.org/blog/8086-microcode-disassembled/">source</a>).</p>
<p>The reason for this behavior is that the string operations use an internal flag called <code>F1</code> to indicate that a <code>REP</code>
prefix has been applied.
The multiply and divide code reuses this flag to track the sign of the input values, toggling <code>F1</code> for each negative value.
If <code>F1</code> is set, the value at the end is negated. (This handles &#34;two negatives make a positive.&#34;)
The consequence is that the <code>REP</code> prefix puts the flag in the 1 state when the multiply/divide starts, so the computed sign
will be wrong at the end and the result is the negative of the expected result.
The microcode is fairly complex, so I won&#39;t show it here; I explain it in detail in <a href="https://www.righto.com/2023/03/8086-multiplication-microcode.html">this blog post</a>.</p>
<h3><code>REP RET</code></h3>
<p><a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions">Wikipedia</a> lists
<code>REP RET</code> (i.e. <code>RET</code> with a <code>REP</code> prefix) as a way to implement a two-byte return instruction.
This is kind of trivial; the <code>RET</code> microcode (like almost every instruction) doesn&#39;t use the <code>F1</code> internal flag,
so the <code>REP</code> prefix has no effect.</p>
<h3><code>REPNZ MOVS/STOS</code></h3>
<p><a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions">Wikipedia</a> mentions that
the use of the <code>REPNZ</code> prefix (as opposed to <code>REPZ</code>) is undefined with string operations other than <code>CMPS/SCAS</code>.
An internal flag called <code>F1Z</code> distinguishes between the <code>REPZ</code> and <code>REPNZ</code> prefixes.
This flag is only used by <code>CMPS/SCAS</code>. Since the other string instructions ignore this flag, they will ignore the
difference between <code>REPZ</code> and <code>REPNZ</code>.
I wrote about string operations in more detail in <a href="https://www.righto.com/2023/04/8086-microcode-string-operations.html">this post</a>.</p>
<h2>Using a register instead of memory.</h2>
<p>Some instructions are documented as requiring a memory operand. However, the ModR/M byte can specify a register.
The behavior in these cases can be highly unusual, providing access to hidden registers.
Examining the microcode shows how this happens.</p>
<h3><code>LEA reg</code></h3>
<p>Many instructions have a ModR/M byte that indicates the memory address that the instruction should use, perhaps through
a complicated addressing mode.
The <code>LEA</code> (Load Effective Address) instruction is different: it doesn&#39;t access the memory location but returns the address itself.
The undocumented part is that the ModR/M byte can specify a register instead of a memory location. In that case,
what does the <code>LEA</code> instruction do? Obviously it can&#39;t return the address of a register, but it needs to return something.</p>
<p>The behavior of <code>LEA</code> is explained by how the 8086 handles the ModR/M byte.
Before running the microcode corresponding to the instruction, the microcode engine calls a short micro-subroutine
for the particular addressing mode.
This micro-subroutine puts the desired memory address (the effective address) into the <code>tmpA</code> register.
The effective address is copied to the <code>IND</code> (Indirect) register and the value is loaded from memory if needed.
On the other hand, if the ModR/M byte specified a register instead of memory, no micro-subroutine is called.
(I explain ModR/M handling in more detail in <a href="https://www.righto.com/2023/02/8086-modrm-addressing.html">this article</a>.)</p>
<p>The microcode for <code>LEA</code> itself is just one line. It stores the effective address in the <code>IND</code> register into the specified destination register, indicated by <code>N</code>.
This assumes that the appropriate ModR/M micro-subroutine was called before this code, putting the effective address into <code>IND</code>.</p>
<pre>IND â N   RNI  <span><b>LEA</b>: store IND register in destination, done</span>
</pre>

<p>But if a register was specified instead of a memory location, no ModR/M micro-subroutine gets called.
Instead, the <code>LEA</code> instruction will return whatever value was left
in <code>IND</code> from before, typically the previous memory location that was accessed.
Thus, <code>LEA</code> can be used to read the value of the <code>IND</code> register, which is normally hidden from the programmer.</p>
<h3><code>LDS reg</code>, <code>LES reg</code></h3>
<p>The <code>LDS</code> and <code>LES</code> instructions load a far pointer from memory into the specified segment register and general-purpose register.
The microcode below assumes that the appropriate ModR/M micro-subroutine has set up <code>IND</code> and read the first value into <code>OPR</code>.
The microcode updates the destination register, increments <code>IND</code> by 2, reads the next value, and updates <code>DS</code>.
(The microcode for <code>LES</code> is a copy of this, but updates <code>ES</code>.)</p>
<pre>OPR â N               <span><b>LDS</b>: Copy OPR to dest register</span>
IND â tmpC  INC2 tmpC <span>Set up incrementing IND by 2</span>
Î£ â IND     R DS,P0   <span>Update IND, read next location</span>
OPR â DS    RNI       <span>Update DS</span>
</pre>

<p>If the <code>LDS</code> instruction specifies a register instead of memory, a micro-subroutine will not be called, so <code>IND</code> and <code>OPR</code>
will have values from a previous instruction.
<code>OPR</code> will be stored in the destination register, while the <code>DS</code> value will be read from the address <code>IND+2</code>.
Thus, these instructions provide a mechanism to access the hidden <code>OPR</code> register.</p>
<h3><code>JMP FAR rm</code></h3>
<p>The <code>JMP FAR rm</code> instruction normally jumps to the far address stored in memory at the location indicated by the ModR/M byte.
(That is, the ModR/M byte indicates where the new PC and CS values are stored.)
But, as with <code>LEA</code>, the behavior is undocumented if the ModR/M byte specifies a register, since a register doesn&#39;t hold
a four-byte value.</p>
<p>The microcode explains what happens.
As with <code>LEA</code>, the code expects a micro-subroutine to put the address into the <code>IND</code> register.
In this case, the micro-subroutine also loads the value at that address (i.e. the destination <code>PC</code>) into tmpB.
The microcode increments <code>IND</code> by 2 to point to the <code>CS</code> word in memory and reads that into <code>CS</code>.
Meanwhile, it updates the <code>PC</code> with <code>tmpB</code>.
It suspends prefetching and flushes the queue, so instruction fetching will restart at the new address.</p>
<pre>IND â tmpC  INC2 tmpC   <span><b>JMP FAR rm</b>: set up to add 2 to IND</span>
Î£ â IND     SUSP        <span>Update IND, suspend prefetching</span>
tmpB â PC   R DS,P0     <span>Update PC with tmpB. Read new CS from specified address</span>
OPR â CS    FLUSH RNI   <span>Update CS, flush queue, done</span>
</pre>

<p>If you specify a register instead of memory, the micro-subroutine won&#39;t get called.
Instead, the program counter will be loaded with whatever value was in <code>tmpB</code> and the <code>CS</code> segment register will
be loaded from the memory location two bytes after the location that <code>IND</code> was referencing.
Thus, this undocumented use of the instruction gives access to the otherwise-hidden <code>tmpB</code> register.</p>
<h2>The end of undocumented instructions</h2>
<p>Microprocessor manufacturers soon realized that undocumented instructions were a problem, since
programmers find them and often use them.
This creates an issue for future processors, or even revisions of the current processor:
if you eliminate an undocumented instruction, previously-working code that used the instruction will break,
and it will seem like the new processor is faulty.</p>
<p>The solution was for processors to detect undocumented instructions and prevent them from executing.
By the early 1980s, processors had enough transistors (thanks to Moore&#39;s law) that they could include
the circuitry to block unsupported instructions.
In particular, the 80186/80188 and the 80286 generated a trap of type 6 when an unused opcode was executed,
blocking use of the instruction.<span id="fnref:186"><a href="#fn:186">9</a></span>
This trap is also known as #UD (Undefined instruction trap).<span id="fnref:fault"><a href="#fn:fault">10</a></span></p>
<h2>Conclusions</h2>
<p>The 8086, like many early microprocessors, has undocumented instructions but no traps to stop them from executing.<span id="fnref:references"><a href="#fn:references">11</a></span>
For the 8086, these fall into several categories.
Many undocumented instructions simply mirror existing instructions.
Some instructions are implemented but not documented for one reason or another, such as <code>SALC</code> and <code>POP CS</code>.
Other instructions can be used outside their normal range, such as <code>AAM</code> and <code>AAD</code>.
Some instructions are intended to work only with a memory address, so specifying a register can have
strange effects such as revealing the values of the hidden <code>IND</code> and <code>OPR</code> registers.</p>
<p>Keep in mind that my analysis is based on transistor-level simulation and examining the microcode; I haven&#39;t verified the behavior on a
physical 8086 processor. Please let me know if you see any errors in my analysis or undocumented instructions that I have
overlooked.
Also note that the behavior could change between different versions of the 8086; in particular, some versions by different manufacturers
(such as the NEC V20 and V30) are known to be different.</p>
<p>I plan to write more about the 8086, so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="7318161d001b1a01011a1515331c1f17110a0716005d0003121016">[emailÂ protected]</span></a>
and Bluesky as <a href="https://staging.bsky.app/profile/righto.com">@righto.com</a> so you can follow me there too.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
