<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lupyuen.github.io/articles/fb?1">Original</a>
    <h1>NuttX RTOS for PinePhone: Framebuffer</h1>
    
    <div id="readability-page-1" class="page">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    
    
    
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    
    <nav id="TOC"><ul>
<li><a href="#framebuffer-demo">1 Framebuffer Demo</a><ul></ul></li>
<li><a href="#framebuffer-interface">2 Framebuffer Interface</a><ul></ul></li>
<li><a href="#render-grey-screen">3 Render Grey Screen</a><ul></ul></li>
<li><a href="#render-blocks">4 Render Blocks</a><ul></ul></li>
<li><a href="#render-circle">5 Render Circle</a><ul></ul></li>
<li><a href="#render-rectangle">6 Render Rectangle</a><ul></ul></li>
<li><a href="#lvgl-graphics-library">7 LVGL Graphics Library</a><ul></ul></li>
<li><a href="#pinephone-framebuffer-driver">8 PinePhone Framebuffer Driver</a><ul>
<li><a href="#ram-framebuffer">8.1 RAM Framebuffer</a><ul></ul></li>
<li><a href="#framebuffer-operations">8.2 Framebuffer Operations</a><ul></ul></li>
<li><a href="#initialise-framebuffer">8.3 Initialise Framebuffer</a><ul></ul></li>
<li><a href="#get-video-plane">8.4 Get Video Plane</a><ul></ul></li>
<li><a href="#get-video-info">8.5 Get Video Info</a><ul></ul></li>
<li><a href="#get-plane-info">8.6 Get Plane Info</a><ul></ul></li>
<li><a href="#update-area">8.7 Update Area</a><ul></ul></li></ul></li>
<li><a href="#mystery-of-the-missing-pixels">9 Mystery of the Missing Pixels</a><ul></ul></li>
<li><a href="#fix-missing-pixels">10 Fix Missing Pixels</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>1 Jan 2023</em></p>
<p><img src="https://lupyuen.github.io/images/fb-title.jpg" alt="Apache NuttX Framebuffer App on Pine64 PinePhone"/></p>
<p>Suppose we‚Äôre running <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>‚Ä¶</p>
<p>How will we create <strong>Graphical Apps</strong> for NuttX? (Pic above)</p>
<p>Today we‚Äôll learn about the‚Ä¶</p>
<ul>
<li>
<p><strong>Framebuffer Interface</strong> that NuttX provides to our apps for rendering graphics</p>
</li>
<li>
<p>What‚Äôs inside the <strong>Framebuffer Driver</strong> for PinePhone</p>
</li>
<li>
<p>Mystery of the <strong>Missing Framebuffer Pixels</strong> and how we solved it (unsatisfactorily)</p>
</li>
<li>
<p>Creating NuttX Apps with the <strong>LVGL Graphics Library</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/fb-run.png" alt="NuttX Framebuffer App running on PinePhone"/></p>
<p><a href="https://gist.github.com/lupyuen/474b0546f213c25947105b6a0daa7c5b"><em>NuttX Framebuffer App running on PinePhone</em></a></p>

<p>Our <strong>Demo Code</strong> for today comes (mostly) from this Example App‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c"><strong>NuttX Framebuffer Driver Example</strong></a></li>
</ul>
<p><em>How do we build the app?</em></p>
<p>To enable the app in our NuttX Project‚Ä¶</p>

<p>And select‚Ä¶</p>
<div><pre><code>Application Configuration &gt; Examples &gt; Framebuffer Driver Example</code></pre></div>
<p>Save the configuration and exit <code>menuconfig</code>.</p>
<p>Look for this line: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L343-L346">apps/examples/fb/fb_main.c</a></p>

<p>And change it to‚Ä¶</p>

<p>Because our PinePhone Framebuffer Driver doesn‚Äôt support overlays yet.</p>
<p>Then build NuttX with‚Ä¶</p>

<p>Before we run the demo, let‚Äôs look at the code‚Ä¶</p>

<p><em>What‚Äôs inside the app?</em></p>
<p>We begin with the <strong>Framebuffer Interface</strong> that NuttX provides to our apps for rendering graphics.</p>
<p>To call the Framebuffer Interface, our app <strong>opens the Framebuffer Driver</strong> at <strong>/dev/fb0</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L314-L337">fb_main.c</a></p>
<div><pre><code>#include &lt;nuttx/video/fb.h&gt;
#include &lt;nuttx/video/rgbcolors.h&gt;

// Open the Framebuffer Driver
int fd = open(&#34;/dev/fb0&#34;, O_RDWR);

// Quit if we failed to open
if (fd &lt; 0) { return; }</code></pre></div>
<p>Next we fetch the <strong>Framebuffer Characteristics</strong>, which will tell us the Screen Size (720 x 1440) and Pixel Format (ARGB 8888)‚Ä¶</p>
<div><pre><code>// Get the Characteristics of the Framebuffer
struct fb_videoinfo_s vinfo;
int ret = ioctl(          // Do I/O Control...
  fd,                     // File Descriptor of Framebuffer Driver
  FBIOGET_VIDEOINFO,      // Get Characteristics
  (unsigned long) &amp;vinfo  // Framebuffer Characteristics
);

// Quit if FBIOGET_VIDEOINFO failed
if (ret &lt; 0) { return; }</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/video/fb.h#L472-L488">(<strong>fb_videoinfo_s</strong> is defined here)</a></p>
<p>Then we fetch the <strong>Plane Info</strong>, which describes the <strong>RAM Framebuffer</strong> that we‚Äôll use for drawing: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L391-L400">fb_main.c</a></p>
<div><pre><code>// Get the Plane Info
struct fb_planeinfo_s pinfo;
ret = ioctl(              // Do I/O Control...
  fd,                     // File Descriptor of Framebuffer Driver
  FBIOGET_PLANEINFO,      // Get Plane Info
  (unsigned long) &amp;pinfo  // Returned Plane Info
);

// Quit if FBIOGET_PLANEINFO failed
if (ret &lt; 0) { return; }</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/video/fb.h#L488-L505">(<strong>fb_planeinfo_s</strong> is defined here)</a></p>
<p>To access the RAM Framebuffer, we <strong>map it to a valid address</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L420-L440">fb_main.c</a></p>
<div><pre><code>// Map the Framebuffer Address
void *fbmem = mmap(  // Map the address of...
  NULL,              // Hint (ignored)
  pinfo.fblen,       // Framebuffer Size
  PROT_READ | PROT_WRITE,  // Read and Write Access
  MAP_SHARED | MAP_FILE,   // Map as Shared Memory
  fd,  // File Descriptor of Framebuffer Driver               
  0    // Offset for Memory Mapping
);

// Quit if we failed to map the Framebuffer Address
if (fbmem == MAP_FAILED) { return; }</code></pre></div>
<p>This returns <strong>fbmem</strong>, a pointer to the RAM Framebuffer.</p>
<p>Let‚Äôs blast some pixels to the RAM Framebuffer‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-demo2.jpg" alt="Render Grey Screen"/></p>

<p><em>What‚Äôs the simplest thing we can do with our Framebuffer?</em></p>
<p>Let‚Äôs fill the <strong>entire Framebuffer with Grey</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/fb/examples/fb/fb_main.c#L541-L562">fb_main.c</a></p>
<div><pre><code>// Fill entire framebuffer with grey
memset(        // Fill the buffer...
  fbmem,       // Framebuffer Address
  0x80,        // Value
  pinfo.fblen  // Framebuffer Size
);</code></pre></div>
<p>(We‚Äôll explain in a while why this turns grey)</p>
<p>After filling the Framebuffer, we <strong>refresh the display</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/fb/examples/fb/fb_main.c#L548-L562">fb_main.c</a></p>
<div><pre><code>// Area to be refreshed
struct fb_area_s area = {
  .x = 0,  // X Offset
  .y = 0,  // Y Offset
  .w = pinfo.xres_virtual,  // Width
  .h = pinfo.yres_virtual   // Height
};

// Refresh the display
ioctl(  // Do I/O Control...
  fd,   // File Descriptor of Framebuffer Driver
  FBIO_UPDATE,           // Refresh the Display
  (unsigned long) &amp;area  // Area to be refreshed
);</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/video/fb.h#L505-L515">(<strong>fb_area_s</strong> is defined here)</a></p>
<p>If we skip this step, we‚Äôll see <strong>missing pixels</strong> in our display.</p>
<p>(More about this below)</p>
<p>Remember to <strong>close the Framebuffer</strong> when we‚Äôre done: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L469-L474">fb_main.c</a></p>
<div><pre><code>// Unmap the Framebuffer Address
munmap(        // Unmap the address of...
  fbmem,       // Framebuffer Address
  pinfo.fblen  // Framebuffer Size
);

// Close the Framebuffer Driver
close(fd);</code></pre></div>
<p>When we run this, PinePhone turns grey! (Pic above)</p>
<p>To understand why, let‚Äôs look inside the Framebuffer‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de2-fb.jpg" alt="PinePhone Framebuffer"/></p>
<p><em>Why did PinePhone turn grey when we filled it with <code>0x80</code>?</em></p>
<p>Our Framebuffer has <strong>720 x 1440 pixels</strong>. Each pixel has <strong>32-bit ARGB 8888</strong> format (pic above)‚Ä¶</p>
<ul>
<li><strong>Alpha</strong> (8 bits)</li>
<li><strong>Red</strong> (8 bits)</li>
<li><strong>Green</strong> (8 bits)</li>
<li><strong>Blue</strong> (8 bits)</li>
</ul>
<p>(Alpha has no effect, since this is the Base Layer and there‚Äôs nothing underneath)</p>
<p>When we fill the Framebuffer with <code>0x80</code>, we‚Äôre setting Alpha (unused), <strong>Red, Green and Blue to <code>0x80</code></strong>.</p>
<p>Which produces the grey screen.</p>
<p>Let‚Äôs do some colours‚Ä¶</p>
<p>(Alpha Channel looks redundant, but it will be used when we support Overlays)</p>
<p><img src="https://lupyuen.github.io/images/fb-demo3.jpg" alt="Render Blocks"/></p>

<p>This is how we render the <strong>Blue, Green and Red Blocks</strong> in the pic above: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/fb/examples/fb/fb_main.c#L564-L601">fb_main.c</a></p>
<div><pre><code>// Fill framebuffer with Blue, Green and Red Blocks
uint32_t *fb = fbmem;  // Access framebuffer as 32-bit pixels
const size_t fblen = pinfo.fblen / 4;  // 4 bytes per pixel

// For every pixel...
for (int i = 0; i &lt; fblen; i++) {

  // Colors are in ARGB 8888 format
  if (i &lt; fblen / 4) {
    // Blue for top quarter.
    // RGB24_BLUE is 0x0000 00FF
    fb[i] = RGB24_BLUE;

  } else if (i &lt; fblen / 2) {
    // Green for next quarter.
    // RGB24_GREEN is 0x0000 FF00
    fb[i] = RGB24_GREEN;

  } else {
    // Red for lower half.
    // RGB24_RED is 0x00FF 0000
    fb[i] = RGB24_RED;
  }
}

// Omitted: Refresh the display with ioctl(FBIO_UPDATE)</code></pre></div>
<p>Everything is hunky dory for chunks of pixels! Let‚Äôs set individual pixels by row and column‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-demo4.jpg" alt="Render Circle"/></p>

<p>This is how we render the Green Circle in the pic above: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/fb/examples/fb/fb_main.c#L603-L651">fb_main.c</a></p>
<div><pre><code>// Fill framebuffer with Green Circle
uint32_t *fb = fbmem;  // Access framebuffer as 32-bit pixels
const size_t fblen = pinfo.fblen / 4;  // 4 bytes per pixel

const int width  = pinfo.xres_virtual;  // Framebuffer Width
const int height = pinfo.yres_virtual;  // Framebuffer Height

// For every pixel row...
for (int y = 0; y &lt; height; y++) {

  // For every pixel column...
  for (int x = 0; x &lt; width; x++) {

    // Get pixel index
    const int p = (y * width) + x;

    // Shift coordinates so that centre of screen is (0,0)
    const int half_width  = width  / 2;
    const int half_height = height / 2;
    const int x_shift = x - half_width;
    const int y_shift = y - half_height;

    // If x^2 + y^2 &lt; radius^2, set the pixel to Green.
    // Colors are in ARGB 8888 format.
    if (x_shift*x_shift + y_shift*y_shift &lt;
        half_width*half_width) {
      // RGB24_GREEN is 0x0000 FF00
      fb[p] = RGB24_GREEN;

    } else {  // Otherwise set to Black
      // RGB24_BLACK is 0x0000 0000
      fb[p] = RGB24_BLACK;
    }
  }
}

// Omitted: Refresh the display with ioctl(FBIO_UPDATE)</code></pre></div>
<p>Yep we have full control over every single pixel! Let‚Äôs wrap up our demo with some mesmerising rectangles‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-demo1.jpg" alt="Render Rectangles"/></p>

<p>When we run the <a href="https://lupyuen.github.io/articles/fb#framebuffer-demo"><strong>NuttX Framebuffer App</strong></a>, we‚Äôll see a stack of Color Rectangles. (Pic above)</p>
<p>We <strong>render each Rectangle</strong> like so: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L450-L469">fb_main.c</a></p>
<div><pre><code>// Rectangle to be rendered
struct fb_area_s area = {
  .x = 0,  // X Offset
  .y = 0,  // Y Offset
  .w = pinfo.xres_virtual,  // Width
  .h = pinfo.yres_virtual   // Height
}

// Render the rectangle
draw_rect(&amp;state, &amp;area, color);

// Omitted: Refresh the display with ioctl(FBIO_UPDATE)</code></pre></div>
<p><a href="https://github.com/apache/nuttx-apps/blob/master/examples/fb/fb_main.c#L89-L114">(<strong>draw_rect</strong> is defined here)</a></p>
<p>The pic below shows the output of the Framebuffer App <strong><code>fb</code></strong> when we run it on PinePhone‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-run.png" alt="NuttX Framebuffer App running on PinePhone"/></p>
<p><a href="https://gist.github.com/lupyuen/474b0546f213c25947105b6a0daa7c5b">(See the Complete Log)</a></p>
<p>And we‚Äôre all done with Circles and Rectangles on PinePhone! Let‚Äôs talk about Graphical User Interfaces‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-lvgl.jpg" alt="LVGL on NuttX on PinePhone"/></p>

<p><em>Rendering graphics pixel by pixel sounds tedious‚Ä¶</em></p>
<p><em>Is there a simpler way to render Graphical User Interfaces?</em></p>
<p>Yep just call the <a href="https://docs.lvgl.io/master/intro/index.html"><strong>LVGL Graphics Library</strong></a>! (Pic above)</p>
<p>To build the <strong>LVGL Demo App</strong> on NuttX‚Ä¶</p>

<p>Select these options‚Ä¶</p>
<ul>
<li>
<p>Enable ‚Äú<strong>Application Configuration</strong> &gt; <strong>Examples</strong> &gt; <strong>LVGL Demo</strong>‚Äù</p>
</li>
<li>
<p>Enable ‚Äú<strong>Application Configuration</strong> &gt; <strong>Graphics Support</strong> &gt; <strong>Light and Versatile Graphics Library (LVGL)</strong>‚Äù</p>
</li>
<li>
<p>Under ‚Äú<strong>LVGL</strong> &gt; <strong>Graphics Settings</strong>‚Äù</p>
<ul>
<li>Set <strong>Horizontal Resolution</strong> to <strong>720</strong></li>
<li>Set <strong>Vertical Resolution</strong> to <strong>1440</strong></li>
<li>Set <strong>DPI</strong> to <strong>200</strong> (or higher)</li>
</ul>
</li>
<li>
<p>Under ‚Äú<strong>LVGL</strong> &gt; <strong>Color settings</strong>‚Äù</p>
<ul>
<li>Set <strong>Color Depth</strong> to <strong>32</strong></li>
</ul>
</li>
</ul>
<p>Save the configuration and exit <code>menuconfig</code>. Rebuild NuttX‚Ä¶</p>

<p>Boot NuttX on PinePhone. At the NSH Command Prompt, enter‚Ä¶</p>

<p>We‚Äôll see the Graphical User Interface as shown in the pic above!</p>
<p><em>But it won‚Äôt respond to our touch right?</em></p>
<p>Yeah we haven‚Äôt started on the <a href="https://lupyuen.github.io/articles/pio#touch-panel"><strong>I2C Touch Input Driver</strong></a> for PinePhone.</p>
<p>Maybe someday LVGL Touchscreen Apps will run OK on PinePhone!</p>
<p><em>What‚Äôs inside the LVGL App?</em></p>
<p>Here‚Äôs how it works‚Ä¶</p>
<ul>
<li>
<p><strong>Main Function</strong> (Event Loop) of the LVGL App is here: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/lvgldemo/lvgldemo.c#L109-L238">lvgldemo.c</a></p>
</li>
<li>
<p>Main Function calls the <strong>NuttX Framebuffer Interface</strong> here: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/lvgldemo/fbdev.c#L351-L469">fbdev.c</a></p>
</li>
<li>
<p><strong>LVGL Widgets</strong> are created here: <a href="https://github.com/lvgl/lv_demos/blob/v7.3.0/src/lv_demo_widgets/lv_demo_widgets.c#L108-L203">lv_demo_widgets.c</a></p>
<p><a href="https://docs.lvgl.io/master/widgets/index.html">(See the docs for <strong>LVGL Widgets</strong>)</a></p>
</li>
<li>
<p><strong>LVGL Version</strong> supported by NuttX is <strong>7.3.0</strong>. <a href="https://github.com/apache/nuttx-apps/blob/master/graphics/lvgl/Kconfig#L13-L17">(See this)</a></p>
</li>
</ul>
<p>Now we talk about the internals of our Framebuffer Driver‚Ä¶</p>

<p><em>We‚Äôve seen the Framebuffer Interface for NuttX Apps‚Ä¶</em></p>
<p><em>What‚Äôs inside the Framebuffer Driver for PinePhone?</em></p>
<p>Let‚Äôs talk about the <strong>internals of our Framebuffer Driver</strong> for PinePhone‚Ä¶</p>
<ul>
<li>
<p><strong>RAM Framebuffer</strong> that‚Äôs mapped to the LCD Display over Direct Memory Access (DMA)</p>
</li>
<li>
<p>How our Framebuffer Driver is <strong>started by NuttX Kernel</strong></p>
</li>
<li>
<p><strong>Framebuffer Operations</strong> exposed by our driver</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Complete Display Driver for PinePhone"/></p>
<p><a href="https://lupyuen.github.io/articles/dsi3#complete-display-driver-for-pinephone"><em>Complete Display Driver for PinePhone</em></a></p>
<h2 id="ram-framebuffer"><a href="#ram-framebuffer">8.1 RAM Framebuffer</a></h2>
<p>Inside PinePhone‚Äôs Allwinner A64 SoC are the <strong>Display Engine</strong> and <strong>Timing Controller TCON0</strong>. (Pic above)</p>
<p>Display Engine and TCON0 will blast pixels from the <strong>RAM Framebuffer</strong> to the LCD Display, over Direct Memory Access (DMA).</p>
<p><a href="https://lupyuen.github.io/articles/de3">(More about Display Engine and TCON0)</a></p>
<p>Here‚Äôs our <strong>RAM Framebuffer</strong>: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L131-L242">pinephone_display.c</a></p>
<div><pre><code>// Frame Buffer for Display Engine 
// Fullscreen 720 x 1440 (4 bytes per XRGB 8888 pixel)
// PANEL_WIDTH is 720
// PANEL_HEIGHT is 1440
static uint32_t g_pinephone_fb0[  // 32 bits per pixel
  PANEL_WIDTH * PANEL_HEIGHT      // 720 x 1440 pixels
];</code></pre></div>
<p>(Memory Protection is not turned on yet, so <a href="https://lupyuen.github.io/articles/fb"><strong>mmap</strong></a> returns the actual address of <strong>g_pinephone_fb0</strong> to NuttX Apps for rendering)</p>
<p>We describe <strong>PinePhone‚Äôs LCD Display</strong> like so (pic below)‚Ä¶</p>
<div><pre><code>// Video Info for PinePhone
// (Framebuffer Characteristics)
// PANEL_WIDTH is 720
// PANEL_HEIGHT is 1440
static struct fb_videoinfo_s g_pinephone_video = {
  .fmt       = FB_FMT_RGBA32,  // Pixel format (XRGB 8888)
  .xres      = PANEL_WIDTH,    // Horizontal resolution in pixel columns
  .yres      = PANEL_HEIGHT,   // Vertical resolution in pixel rows
  .nplanes   = 1,  // Color planes: Base UI Channel
  .noverlays = 2   // Overlays: 2 Overlay UI Channels
};</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/video/fb.h#L472-L488">(<strong>fb_videoinfo_s</strong> is defined here)</a></p>
<p>(We‚Äôre still working on the Overlays)</p>
<p>We tell NuttX about our RAM Framebuffer with this <strong>Plane Info</strong>‚Ä¶</p>
<div><pre><code>// Color Plane for Base UI Channel:
// Fullscreen 720 x 1440 (4 bytes per XRGB 8888 pixel)
static struct fb_planeinfo_s g_pinephone_plane = {
  .fbmem        = &amp;g_pinephone_fb0,         // Framebuffer Address
  .fblen        = sizeof(g_pinephone_fb0),  // Framebuffer Size
  .stride       = PANEL_WIDTH * 4,  // Length of a line (4-byte pixel)
  .display      = 0,   // Display number (Unused)
  .bpp          = 32,  // Bits per pixel (XRGB 8888)
  .xres_virtual = PANEL_WIDTH,   // Virtual Horizontal resolution
  .yres_virtual = PANEL_HEIGHT,  // Virtual Vertical resolution
  .xoffset      = 0,  // X Offset from virtual to visible
  .yoffset      = 0   // Y Offset from virtual to visible
};</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/video/fb.h#L488-L505">(<strong>fb_planeinfo_s</strong> is defined here)</a></p>
<p><img src="https://lupyuen.github.io/images/de2-fb.jpg" alt="PinePhone Framebuffer"/></p>
<h2 id="framebuffer-operations"><a href="#framebuffer-operations">8.2 Framebuffer Operations</a></h2>
<p>Our Framebuffer Driver supports these <strong>Framebuffer Operations</strong>: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L116-L131">pinephone_display.c</a></p>
<div><pre><code>// Vtable for Frame Buffer Operations
static struct fb_vtable_s g_pinephone_vtable = {

  // Basic Framebuffer Operations
  .getvideoinfo    = pinephone_getvideoinfo,
  .getplaneinfo    = pinephone_getplaneinfo,
  .updatearea      = pinephone_updatearea,

  // TODO: Framebuffer Overlay Operations
  .getoverlayinfo  = pinephone_getoverlayinfo,
  .settransp       = pinephone_settransp,
  .setchromakey    = pinephone_setchromakey,
  .setcolor        = pinephone_setcolor,
  .setblank        = pinephone_setblank,
  .setarea         = pinephone_setarea
};</code></pre></div>
<p>We haven‚Äôt implemented the Overlays, so let‚Äôs talk about the <strong>first 3 operations</strong>‚Ä¶</p>
<ul>
<li>
<p>Get Video Info</p>
</li>
<li>
<p>Get Plane Info</p>
</li>
<li>
<p>Update Area</p>
</li>
</ul>
<p>But before that we need to initialise the Framebuffer and return the Video Plane‚Ä¶</p>
<h2 id="initialise-framebuffer"><a href="#initialise-framebuffer">8.3 Initialise Framebuffer</a></h2>
<p>At Startup, NuttX Kernel calls <strong>up_fbinitialize</strong> to initialize the Framebuffer‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lcd#complete-display-driver"><strong>‚ÄúComplete Display Driver‚Äù</strong></a></li>
</ul>
<p><strong>up_fbinitialize</strong> comes from our Framebuffer Driver (LCD Driver)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L652-L801"><strong>up_fbinitialize (Initialise Framebuffer)</strong></a></p>
<p>(Called by <a href="https://github.com/apache/nuttx/blob/master/drivers/video/fb.c#L795-L805"><strong>fb_register</strong></a> and <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L79-L93"><strong>pinephone_bringup</strong></a>)</p>
</li>
</ul>
<p>Then NuttX Kernel interrogates our Framebuffer Driver‚Ä¶</p>
<h2 id="get-video-plane"><a href="#get-video-plane">8.4 Get Video Plane</a></h2>
<p>NuttX Kernel calls our Framebuffer Driver to discover the <strong>Framebuffer Operations</strong> supported by our driver.</p>
<p>This is how we return the Framebuffer Operations: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L801-L833">pinephone_display.c</a></p>
<div><pre><code>// Get the Framebuffer Object for the supported operations
struct fb_vtable_s *up_fbgetvplane(
  int display,  // Display Number should be 0
  int vplane    // Video Plane should be 0
) {
  // Return the supported Framebuffer Operations
  return &amp;g_pinephone_vtable;
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/fb#framebuffer-operations">(We‚Äôve seen <strong>g_pinephone_vtable</strong> earlier)</a></p>
<p>Now it gets interesting: NuttX Kernel and NuttX Apps will call the operations exposed by our Framebuffer Driver‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lcd-title.jpg" alt="Test Pattern on NuttX for PinePhone"/></p>
<h2 id="get-video-info"><a href="#get-video-info">8.5 Get Video Info</a></h2>
<p>Remember <strong>FBIOGET_VIDEOINFO</strong> for fetching the Framebuffer Characteristics?</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/fb#framebuffer-interface"><strong>‚ÄúFramebuffer Interface‚Äù</strong></a></li>
</ul>
<p>The first operation exposed by our Framebuffer Driver returns the <strong>Video Info</strong> that contains our Framebuffer Characteristics: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L349-L395">pinephone_display.c</a></p>
<div><pre><code>// Get the Video Info for our Framebuffer
// (ioctl Entrypoint: FBIOGET_VIDEOINFO)
static int pinephone_getvideoinfo(
  struct fb_vtable_s *vtable,   // Framebuffer Driver
  struct fb_videoinfo_s *vinfo  // Returned Video Info
) {
  // Copy and return the Video Info
  memcpy(vinfo, &amp;g_pinephone_video, sizeof(struct fb_videoinfo_s));

  // Keep track of the stages during startup:
  // Stage 0: Initialize driver at startup
  // Stage 1: First call by apps
  // Stage 2: Subsequent calls by apps
  // We erase the framebuffers at stages 0 and 1. This allows the
  // Test Pattern to be displayed for as long as possible before erasure.
  static int stage = 0;
  if (stage &lt; 2) {
    stage++;
    memset(g_pinephone_fb0, 0, sizeof(g_pinephone_fb0));
    memset(g_pinephone_fb1, 0, sizeof(g_pinephone_fb1));
    memset(g_pinephone_fb2, 0, sizeof(g_pinephone_fb2));
  }
  return OK;
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/fb#ram-framebuffer">(We‚Äôve seen <strong>g_pinephone_video</strong> earlier)</a></p>
<p>This code looks interesting: We‚Äôre trying to show the <strong>Startup Test Pattern</strong> for as long as possible. (Pic above)</p>
<p>Normally NuttX Kernel will erase our Framebuffer at startup. But with the logic above, our Test Pattern will be visible until the <strong>first app call</strong> to our Framebuffer Driver.</p>
<p><a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L855-L978">(Test Pattern is rendered by <strong>pinephone_display_test_pattern</strong>)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L79-L93">(Which is called by <strong>pinephone_bringup</strong> at startup)</a></p>
<h2 id="get-plane-info"><a href="#get-plane-info">8.6 Get Plane Info</a></h2>
<p>Earlier we‚Äôve seen <strong>FBIOGET_PLANEINFO</strong> that fetches the RAM Framebuffer‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/fb#framebuffer-interface"><strong>‚ÄúFramebuffer Interface‚Äù</strong></a></li>
</ul>
<p>This is how we return the <strong>Plane Info</strong> that describes the RAM Framebuffer: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L397-L429">pinephone_display.c</a></p>
<div><pre><code>// Get the Plane Info for our Framebuffer
// (ioctl Entrypoint: FBIOGET_PLANEINFO)
static int pinephone_getplaneinfo(
  struct fb_vtable_s *vtable,   // Framebuffer Driver
  int planeno,  // Plane Number should be 0
  struct fb_planeinfo_s *pinfo  // Returned Plane Info
) {
  // Copy and return the Plane Info
  memcpy(pinfo, &amp;g_pinephone_plane, sizeof(struct fb_planeinfo_s));
  return OK;
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/fb#ram-framebuffer">(We‚Äôve seen <strong>g_pinephone_plane</strong> earlier)</a></p>
<h2 id="update-area"><a href="#update-area">8.7 Update Area</a></h2>
<p>The final operation <strong>updates the display</strong> when there‚Äôs a change to the Framebuffer: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L472-L513">pinephone_display.c</a></p>
<div><pre><code>// Update the Display when there is a change to the Framebuffer
// (ioctl Entrypoint: FBIO_UPDATE)
static int pinephone_updatearea(
  struct fb_vtable_s *vtable,   // Framebuffer Driver
  const struct fb_area_s *area  // Updated area of Framebuffer
) {
  // Mystery Code...</code></pre></div>
<p>This operation is invoked when NuttX Apps call <strong>FBIO_UPDATE</strong>, as we‚Äôve seen earlier‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/fb#render-grey-screen"><strong>‚ÄúRender Grey Screen‚Äù</strong></a></li>
</ul>
<p>The code inside looks totally baffling, but first let‚Äôs talk about a mysterious rendering problem‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-test2.jpg" alt="Missing Pixels in PinePhone Image"/></p>

<p>When we tested our Framebuffer Driver for the very first time, we discovered <strong>missing pixels</strong> in the rendered image (pic above)‚Ä¶</p>
<ul>
<li>
<p>Inside the Yellow Box is supposed to be an <strong>Orange Box</strong></p>
</li>
<li>
<p>Inside the Orange Box is supposed to be a <strong>Red Box</strong></p>
</li>
<li>
<p>We see bits of <strong>Orange and Red Pixels</strong></p>
<p><a href="https://lupyuen.github.io/images/fb-title.jpg">(Compare with the pic below)</a></p>
</li>
</ul>
<p><em>Maybe we didn‚Äôt render the pixels correctly?</em></p>
<p><em>Or maybe the RAM Framebuffer got corrupted?</em></p>
<p>When we slowed down the rendering, we see the <strong>missing pixels magically appear</strong> later in a curious pattern‚Ä¶</p>
<ul>
<li><a href="https://www.youtube.com/shorts/WD5AJj7Rz5U"><strong>Watch the Demo on YouTube</strong></a></li>
</ul>
<p>According to the video, the pixels are actually <strong>written correctly</strong> to the RAM Framebuffer.</p>
<p>But the pixels at the lower half don‚Äôt get pushed to the display until the <strong>next screen update.</strong></p>
<p><em>Maybe it‚Äôs a problem with Framebuffer DMA / Display Engine / Timing Controller TCON0?</em></p>
<p>Yeah there seems to be a lag between the writing of pixels to RAM Framebuffer, and the pushing of pixels to the display over DMA / Display Engine / Timing Controller TCON0.</p>
<p>We found an unsatisfactory workaround for the lag in rendering pixels‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-title.jpg" alt="Fixed Missing Pixels in PinePhone Image"/></p>

<p>In the previous section we saw that there was a <strong>lag pushing pixels from the RAM Framebuffer</strong> to the PinePhone Display.</p>
<p>(Over DMA / Display Engine / Timing Controller TCON0)</p>
<p>Can we overcome this lag by <strong>copying the RAM Framebuffer to itself</strong>, forcing the display to refresh?</p>
<p>This sounds very strange, but yes it works!</p>
<p>From <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_display.c#L472-L513">pinephone_display.c</a>:</p>
<div><pre><code>// Update the Display when there is a change to the Framebuffer
// (ioctl Entrypoint: FBIO_UPDATE)
static int pinephone_updatearea(
  struct fb_vtable_s *vtable,   // Framebuffer Driver
  const struct fb_area_s *area  // Updated area of framebuffer
) {
  // Access Framebuffer as bytes
  uint8_t *fb = (uint8_t *)g_pinephone_fb0;
  const size_t fbsize = sizeof(g_pinephone_fb0);

  // Copy the Entire Framebuffer to itself,
  // to fix the missing pixels.
  // Not sure why this works.
  for (int i = 0; i &lt; fbsize; i++) {

    // Declare as volatile to prevent compiler optimization
    volatile uint8_t v = fb[i];
    fb[i] = v;
  }
  return OK;
}</code></pre></div>
<p>With the code above, the Red, Orange and Yellow Boxes are now rendered correctly in our NuttX Framebuffer Driver for PinePhone. (Pic above)</p>
<p><em>Who calls pinephone_updatearea?</em></p>
<p>After writing the pixels to the RAM Framebuffer, NuttX Apps will call <strong>ioctl(FBIO_UPDATE)</strong> to update the display.</p>
<p>This triggers <strong>pinephone_updatearea</strong> in our NuttX Framebuffer Driver: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/pixel/examples/fb/fb_main.c#L265-L274">fb_main.c</a></p>
<div><pre><code>// Omitted: NuttX App writes pixels to RAM Framebuffer

// Update the Framebuffer
#ifdef CONFIG_FB_UPDATE
  ret = ioctl(    // I/O Control
    state-&gt;fd,    // File Descriptor for Framebuffer Driver
    FBIO_UPDATE,  // Update the Framebuffer
    (unsigned long)((uintptr_t)area)  // Updated area
  );
#endif</code></pre></div>
<p><em>Instead of copying the entire RAM Framebuffer, can we copy only the updated screen area?</em></p>
<p>Probably, we need more rigourous testing.</p>
<p><em>But how do we really fix this?</em></p>
<p>We need to <a href="https://developer.arm.com/documentation/den0013/d/Caches/Invalidating-and-cleaning-cache-memory"><strong>flush the CPU Cache</strong></a>, and verify that our Framebuffer has been mapped with the right attributes.</p>
<p>(Thanks to <a href="https://twitter.com/BarryNolte/status/1609003505699766272"><strong>Barry Nolte</strong></a>, <a href="https://twitter.com/suarezvictor/status/1608643410906472448?s=20&amp;t=gFese-aeWGonGShw9vtNyg"><strong>Victor Suarez Rovere</strong></a> and <a href="https://twitter.com/crzwdjk/status/1608661469591384064?s=20&amp;t=gFese-aeWGonGShw9vtNyg"><strong>crzwdjk</strong></a> for the tips!)</p>
<p><a href="https://news.ycombinator.com/item?id=34186806">(Commenters on Hacker News also think it‚Äôs a CPU Cache issue)</a></p>
<p><em>How do other PinePhone operating systems handle this?</em></p>
<p>See this‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#fix-missing-pixels-in-pinephone-image"><strong>‚ÄúFix Missing Pixels in PinePhone Image‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/fb-lvgl2.jpg" alt="LVGL on NuttX on PinePhone"/></p>

<p>Now that we can render Graphical User Interfaces with <a href="https://docs.lvgl.io/master/intro/index.html"><strong>LVGL Graphics Library</strong></a>‚Ä¶ It‚Äôs time to build the <a href="https://lupyuen.github.io/articles/pio#touch-panel"><strong>NuttX Touch Input Driver</strong></a> for PinePhone!</p>
<p>The NuttX Community is now adding support for <a href="https://github.com/apache/nuttx/pull/8009"><strong>I2C on Allwinner A64 SoC</strong></a>, which will be super helpful for our I2C Touch Input Driver. Stay Tuned!</p>
<p>Meanwhile please check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3"><strong>‚ÄúNuttX RTOS for PinePhone: MIPI Display Serial Interface‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de3"><strong>‚ÄúNuttX RTOS for PinePhone: Display Engine‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lcd"><strong>‚ÄúNuttX RTOS for PinePhone: LCD Panel‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=34186806"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/zzl0rq/nuttx_rtos_for_pinephone_framebuffer/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/fb.md"><strong>lupyuen.github.io/src/fb.md</strong></a></p>

    

</div>
  </body>
</html>
