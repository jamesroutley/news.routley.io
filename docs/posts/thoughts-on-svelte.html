<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tyhopp.com/notes/thoughts-on-svelte">Original</a>
    <h1>Thoughts on Svelte</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <time datetime="2023-03-27">2023-03-27</time>
        <p>Over the span of a month I built a <a href="https://github.com/tyhopp/t-rss-reader">personal RSS reader</a>.</p>
<p>For the web client I used <a href="https://svelte.dev/">Svelte</a> and <a href="https://kit.svelte.dev/">SvelteKit</a>, mostly as a way to evaluate whether I&#39;d use the tools in larger projects.</p>
<p>Here are my thoughts on Svelte.</p>
<h2 id="tldr">TL;DR</h2>
<p>I enjoyed the Svelte experience on the whole. Highlights are the component format, built-in stores, and the event dispatcher API. Lowlights are reactive statements (<code>$</code>), <code>await</code> blocks, and built-in transition and animation APIs.</p>
<h2 id="component-format">Component format</h2>
<p>Svelte&#39;s component format is my favorite thing about it. When you write <code>.svelte</code> files, your default context is the same as the browser&#39;s: HTML.</p>
<p>This snippet from the <a href="https://svelte.dev/docs#component-format">Svelte docs</a> (with some example markup, JS and CSS added) is illustrative:</p>
<pre><code><span>&lt;<span>script</span>&gt;</span><span>
  
  <span>function</span> <span>add</span>(<span>a, b</span>) {
    <span>return</span> a + b;
  }
</span><span>&lt;/<span>script</span>&gt;</span>


<span>&lt;<span>p</span>&gt;</span>1 + 2 is: {add(1, 2)}<span>&lt;/<span>p</span>&gt;</span>

<span>&lt;<span>style</span>&gt;</span>
  /* styles go here */
  p {
    color: blue;
  }
<span>&lt;/<span>style</span>&gt;</span></code></pre><p>Contrast this with React, where JavaScript is the default context and HTML is interleaved via JSX:</p>
<pre><code><span>import</span> <span>&#39;../some-styles.css&#39;</span>; 

<span>export</span> <span>function</span> <span>SomeComponent</span>(<span></span>) {
  
  <span>function</span> <span>add</span>(<span>a, b</span>) {
    <span>return</span> a + b;
  }

  
  <span>return</span> <span><span>&lt;<span>p</span> <span>className</span>=<span>&#34;some-class&#34;</span>&gt;</span>{`1 + 2 is: ${add(1, 2)}`}<span>&lt;/<span>p</span>&gt;</span></span>;
}</code></pre><p>It&#39;s hard to pin down why this approach is great in real terms. You can&#39;t really say &#34;Svelte&#39;s component format makes our team X times faster when building components than with Y framework&#34; with any certainty.</p>
<p>I think that the component format is a big part of why people say they enjoy working with Svelte. There&#39;s a temptation to explain it as there&#39;s less context switching since the browser thinks about HTML first too, but I&#39;m not sure that holds water. Either way, I like it.</p>
<h2 id="built-in-stores">Built-in stores</h2>
<p>Svelte comes with built-in <a href="https://svelte.dev/docs#run-time-svelte-store">stores</a> as an option for state management.</p>
<p>What should and should not be the concern of a user interface library/framework is a contested topic. I like that Svelte acknowledges that state management is a problem you will probably have and gives you a solution you can use or extend if you want to.</p>
<p>It&#39;s also nice that this solution isn&#39;t strongly linked to the component tree like React context is.</p>
<h2 id="event-dispatcher-api">Event dispatcher API</h2>
<p>Svelte has <a href="https://svelte.dev/docs#run-time-svelte-createeventdispatcher">a built-in API</a> that lets you create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent"><code>CustomEvent</code></a>, dispatch it, and listen for it on parent elements.</p>
<p>It&#39;s difficult to have an answer for the web&#39;s event model in systems that are built on the concept of a unidirectional data flow. By nature, the web&#39;s event model lets data flow upwards.</p>
<p>Svelte acknowledges that you might need to send data up the tree and gives you an API that uses web platform primitives. Thumbs up from me.</p>
<h2 id="reactive-statements">Reactive statements</h2>
<p>I found Svelte&#39;s <a href="https://svelte.dev/docs#component-format-script-3-$-marks-a-statement-as-reactive">reactive statements</a> confusing.</p>
<p>Svelte&#39;s basic reactivity is <a href="https://svelte.dev/docs#component-format-script-2-assignments-are-reactive">based on variable assignments</a>. That I understand. The docs give this example:</p>
<pre><code><span>&lt;<span>script</span>&gt;</span><span>
  <span>let</span> count = <span>0</span>;

  <span>function</span> <span>handleClick</span>(<span></span>) {
    
    
    count = count + <span>1</span>;
  }
</span><span>&lt;/<span>script</span>&gt;</span></code></pre><p>Makes sense to me.</p>
<p>Now, introducing the reactive <code>$</code> label, the docs give this example:</p>
<pre><code><span>&lt;<span>script</span>&gt;</span><span>
  <span>export</span> <span>let</span> title;
  <span>export</span> <span>let</span> person;

  
  
  <span>$</span>: <span>document</span>.<span>title</span> = title;

  <span>$</span>: {
    <span>console</span>.<span>log</span>(<span>`multiple statements can be combined`</span>);
    <span>console</span>.<span>log</span>(<span>`the current title is <span>${title}</span>`</span>);
  }

  
  <span>$</span>: ({ name } = person);

  
  <span>let</span> name2 = name;
</span><span>&lt;/<span>script</span>&gt;</span></code></pre><p>There is a lot going on here, and this is the doc&#39;s first example introducing the topic. Still, if you stare at it for a while it makes sense.</p>
<p>Add to that this gotcha from the <a href="https://svelte.dev/docs#component-format-script-3-$-marks-a-statement-as-reactive">Svelte docs</a>:</p>
<blockquote>
<p>It is important to note that the reactive blocks are ordered via simple static analysis at compile time, and all the compiler looks at are the variables that are assigned to and used within the block itself, not in any functions called by them. This means that yDependent will not be updated when x is updated in the following example:</p>
</blockquote>
<pre><code><span>&lt;<span>script</span>&gt;</span><span>
  <span>let</span> x = <span>0</span>;
  <span>let</span> y = <span>0</span>;

  <span>const</span> <span>setY</span> = (<span>value</span>) =&gt; {
    y = value;
  };

  <span>$</span>: yDependent = y;
  <span>$</span>: <span>setY</span>(x);
</span><span>&lt;/<span>script</span>&gt;</span></code></pre><p>This subtlety led to more than one case where I didn&#39;t understand why a component didn&#39;t update.</p>
<p>In the end I found it was difficult to determine reliably when to reach for the <code>$</code> label. I&#39;d use it in one scenario and it seemed to work like I expect, then throw it at another scenario and it didn&#39;t work like I expect.</p>
<p>So I avoided it altogether. One exception is I did use it to <a href="https://svelte.dev/docs#component-format-script-4-prefix-stores-with-$-to-access-their-values">access store values</a>. Unfortunately, it&#39;s also another use case that overloads <code>$</code>.</p>
<p>The <code>$</code> label is one technical reason why I would be hesitant to adopt Svelte for larger projects. It&#39;s a core part of Svelte that you can&#39;t always avoid, and I think the potential for introducing bugs through it is high to start and very high at scale.</p>
<h2 id="await-blocks">Await blocks</h2>
<p>Svelte gives you <code>{#if ...}</code> and <code>{#each ...}</code> syntax as the primary control flow methods for markup rendering. It also has <code>{#await ...}</code> for <a href="https://svelte.dev/docs#template-syntax-await">deciding what to render based on the state of a Promise</a>.</p>
<p>I like the idea, but in practice I always ended up refactoring it out. There was always something else I needed to do after the Promise resolved or rejected prior to rendering, and I didn&#39;t want to run that logic every time I used the service.</p>
<p>The logic also didn&#39;t belong inline in the rendering code, though. So where does it go?</p>
<p>Rip out <code>{#await ...}</code> and put it in the <code>&lt;script&gt;</code> logic, then use local variables when rendering.</p>
<p>I think it&#39;s not a bad thing that <code>{#await ...}</code> exists in Svelte core, I was just disappointed to find that the elegant use case in the docs is somewhat of a mirage.</p>
<h2 id="transition-and-animation-apis">Transition and animation APIs</h2>
<p>My gripe with Svelte&#39;s <a href="https://svelte.dev/docs#run-time-svelte-transition">transition</a> and <a href="https://svelte.dev/docs#template-syntax-element-directives-animate-fn">animation</a> APIs is that I think they should be a concern of CSS and not Svelte.</p>
<p>Svelte gives you an elegant way to use CSS in your components with <code>&lt;style&gt;</code> tags, why not implement transitions and animations in CSS there?</p>
<p>I very well could have just not found a use case where I was glad for these APIs to exist, fair enough. Until I do, I will question why these not insignificantly complex APIs exist in Svelte&#39;s core.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Well, these are my thoughts on my experience using <a href="https://svelte.dev/">Svelte</a>!</p>
<p>I&#39;d use it again for personal projects, maybe not for large company projects if I was the architect.</p>
<p>I also have thoughts on <a href="https://kit.svelte.dev/">SvelteKit</a>, but I don&#39;t have as much to say since I built an SPA, and so much of SvelteKit seems to be about server-side rendering.</p>
<p>Until next time!</p>

        <hr/>
        <p>Thanks for reading! Go <a href="https://tyhopp.com/">home</a> for more notes.</p>
      </div></div>
  </body>
</html>
