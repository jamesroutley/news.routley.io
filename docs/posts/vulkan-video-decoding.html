<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wickedengine.net/2023/05/07/vulkan-video-decoding/">Original</a>
    <h1>Vulkan Video Decoding</h1>
    
    <div id="readability-page-1" class="page"><div>
					
<p>Recently the Vulkan API received an exciting new feature, which is video decoding, utilizing the built-in fixed function video unit found in many GPUs. This allows to the writing of super fast cross-platform video applications while freeing up the CPU from expensive decoding tasks.</p>



<p>Take a look at an example using real time video decoding with Vulkan in the Wicked Engine game demo:</p>



<figure><div>
<p><span><iframe width="809" height="456" src="https://www.youtube.com/embed/tvGlJjgD-VU?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span></p>
</div></figure>



<p>To give some examples, videos in the game scene is a pretty powerful tool that can provide interesting visuals for a modern city scape, a virtual cinema or TV screens, monitors. Once it’s working, it is very simple to add a video to the objects opposed to making flipbook texture atlases which is a more old school way of doing things, and we also benefit from the video codec’s compression.</p>



<p>Why would you want to have a low level video API and not use an already available library? Because:</p>



<ul>
<li>Take a look at FFMPEG, the most popular and feature complete video library out there: it’s huge, consisting of several DLL files and lots of dependencies.</li>



<li>No interop with other libraries, you only have to use the usual Vulkan graphics objects: buffers for providing compressed data, and textures for uncompressed video frames. You can easily reuse the decoded video as regular textures on your objects.</li>



<li>All your resources can stay fully on GPU, and all the heavy processing is performed on the GPU’s video unit.</li>



<li>You can fully utilize Vulkan synchronization and async queues to have a really low overhead. After all, the video unit is a separate part of the GPU and it makes much sense to run video tasks asynchronously to your main rendering.</li>
</ul>



<p>However, don’t expect a walk in the park if you want to add Vulkan video functionality into your program. If you know anything about Vulkan, you know that usually it is very complicated to do anything and video is no different. It requires deep understanding of the video format that you want to decode. The first two formats that are usable today (in non-beta version) are H264 and H265. So far I have tried the older and more popular H264, so I will detail the process specifically for this.</p>



<p><em>Note: all information here is probably inaccurate, it just shows what I learned while bringing up video decoding for the first time.</em></p>



<h2>Inputs – MP4</h2>



<p>The first thing you need is a H264 video. This most commonly comes from an MP4 file, which is a container format containing the H264 (optionally) and other metadata. You will need to “demux” the MP4 to get the H264 data from it. You can do so with <a rel="noreferrer noopener" href="https://github.com/lieff/minimp4" target="_blank">this single header library called MiniMP4</a>, or rolling one yourself. To check how to use the MiniMP4 demuxer, take a look at <a rel="noreferrer noopener" href="https://github.com/lieff/minimp4/blob/master/minimp4_test.c" target="_blank">their sample</a>, or <a rel="noreferrer noopener" href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiVideo.cpp" target="_blank">my example in Wicked Engine</a> (look for the CreateVideo function).</p>



<h2>Inputs – H264</h2>



<p>From the H264 data, you will have to find Network Abstraction Layer units (NAL units) for the corresponding elements:</p>



<ul>
<li>Picture Parameter Set (PPS)</li>



<li>Sequence Parameter Set (SPS)</li>



<li>Slice Header</li>
</ul>



<p>The NAL units are separated with three (0,0,1) or four (0,0,0,1) bytes, that’s what you need to find, then you must read in the NAL unit header to determine the type of data you will read next. I have created a <a rel="noreferrer noopener" href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/Utility/h264.h" target="_blank">minimal H264 parser header file</a> that only handles these units that can be passed to the Vulkan decoder. My header file is based on the <a rel="noreferrer noopener" href="https://github.com/aizvorski/h264bitstream/" target="_blank">H264 bitstream library</a>, but greatly reduced, rewritten for easier c++ syntax and removed allocations. You can very easily use the h264 parser header file, by creating a Bitstream from a data pointer, then calling read_nal_header(), read_pps(), read_sps() and read_slice_header() functions which will create simple plain old data structures for you to use.</p>



<p>To put it simply, the SPS and PPS structures are descriptions for the whole video, while the Slice Header is a description for a single Slice (basically a video frame). To complicate things, there can be multiple SPS and PPS, and a Slice Header can index them, telling which one to use. To complicate even further, there can be multiple Slice Headers (and Slices) for one video frame, for example when the video is interlaced. In the common case, mostly I have seen videos that are in the simple case, so 1 PPS, 1 SPS and 1 Slice Header per frame so at first you can implement this easy way and then handle more complicated situations later.</p>



<h2>Inputs – Vulkan</h2>



<p>The general idea is that you will put the compressed H264 bitstream in a GPU buffer (VkBuffer object). It is up to you if you put all the frames into one buffer, or upload frames on demand. If you put multiple frames into a buffer, you need to make sure that you put each slice data at a correctly aligned offset. You can find out the offset alignment required from VkVideoCapabilitiesKHR::minBitstreamBufferOffsetAlignment. You must also use an aligned size, that you find from VkVideoCapabilitiesKHR::minBitstreamBufferSizeAlignment. You can get the video capabilities structure by using vkGetPhysicalDeviceVideoCapabilitiesKHR() function if the video extensions are supported by the GPU. </p>



<p>The bitstream buffer will need to be marked with VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR to be usable in video decoding and the creation parameters structure must include a VkVideoProfileListInfoKHR structure in its pNext chain. The profile list must be filled with the video profile information that the buffer will be used with.</p>



<p>One thing that was not evident for me, is that what data exactly you have to provide in the VkBuffer, but after a lot of trying and inspecting the memory of the Nvidia video sample’s buffers, I determined that you have to provide the 0,0,1 NAL start code bytes, followed by NAL unit header, followed by Slice Header and Slice Data. You can throw out the PPS and SPS data, though if they remain in the buffer, the video decoder will consume those without issue. But very importantly, make sure that each unit is separated correctly with the NAL start codes (0,0,1) or (0,0,0,1) byte sequence, otherwise you will most likely get nothing – no result and no errors.</p>



<p>An other thing, is that I was unable to get any results with normal buffers that are in default GPU memory. I had to use host mapped buffers (“upload buffers” in DX12 terminology). These are buffers that are available for CPU writes and GPU reads. The vulkan validation didn’t give any reasons why.</p>



<p>Other than the bitstream buffers, Vulkan requires to fill a lot of description structures:</p>



<ul>
<li>From the PPS, you will need to fill the Vulkan’s StdVideoH264PictureParameterSet and StdVideoH264ScalingLists structures.</li>



<li>From the SPS, you will need to fill the StdVideoH264SequenceParameterSet, StdVideoH264SequenceParameterSetVui and StdVideoH264HrdParameters structures.</li>
</ul>



<p>You will later pass those structures to VkVideoDecodeH264SessionParametersAddInfoKHR, which is passed to the VkVideoDecodeH264SessionParametersCreateInfoKHR when creating the video session. There are also more options for you if you don’t want to provide this at session creation time, but want to update the SPS and PPS later, in this case look for VkVideoSessionParametersUpdateInfoKHR and vkUpdateVideoSessionParametersKHR().</p>



<h2>Video session</h2>



<p>The video session is the video specific main Vulkan object that you need to create. It will require you to query memory requirements with vkGetVideoSessionMemoryRequirementsKHR and then allocate and bind memory appropriately with vkBindVideoSessionMemoryKHR(). Then you will use the VkVideoDecodeH264SessionParametersCreateInfoKHR and VkVideoSessionParametersCreateInfoKHR structures when calling vkCreateVideoSessionParametersKHR(). </p>



<p>The video session is used for internal memory allocations for video coding. When decoding video, you will always need to call:</p>



<ul>
<li>vkCmdBeginVideoCodingKHR()</li>



<li>vkCmdDecodeVideoKHR()</li>



<li>vkCmdEndVideoCodingKHR()</li>
</ul>



<p>vkCmdDecodeVideoKHR() needs to be between the begin/end video coding. Before first use of a video session, you will also have to call vkCmdControlVideoCodingKHR() with the VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR flag (between begin/end video coding commands)</p>



<p>But you also need to specify the decoding outputs for the video coding commands first.</p>



<h2>Outputs – H264</h2>



<p>The H264 video codec is based on the concept of Intra and Predictive frames (and variations on them). Intra frames are full video frames that can be decompressed by themselves, for example the first frame of the video will most likely be an Intra (I) frame. Predictive (P) frames can only be decompressed by referencing other frames, because their data only contains differences to other frames (this means their compressed data is also much smaller). Note, that P-frames can reference not only one, but many other frames. Also, reference frames are not necessarily I-frames, so don’t make those assumptions like I did.</p>



<p>To make having P-frames possible, it is needed to have a buffer of history frames. The SPS structure’s num_ref_frames tells us how many reference frames need to be kept. However, the currently decoded frame can not be used as reference, so we must have a buffer of num_ref_frames + 1 elements. Note that H264 specifies the maximum number of reference frames as 16, so the num_ref_frames can never be larger than this. You can use this knowledge to allocate simple temporary arrays on stack for example, since you know there can be never more than 17 DPB slots (16 reference frames + 1 current frame). The frames are actually textures, so this means we can use a texture array for example with array_size = num_ref_frames + 1. The texture will need to be a YUV420 texture, and Vulkan provides us with the VK_FORMAT_G8_B8R8_2PLANE_420_UNORM for this purpose.</p>



<p>This array texture is called the Decoded Picture Buffer (DPB for short). We must also use the following flags when creating it: VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR. It is possible also to not use a texture array, but individual textures, based on video capabilities and that way we perhaps wouldn’t need to use all the flags on all of them. There might be hardware requirements though that require placing the DPB images into a texture array, so you will need to check those too. I think the VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR flag tells us this in the VkVideoDecodeCapabilitiesKHR if I’m not mistaken.</p>



<p>For every decode operation, we must inform Vulkan about our current DPB state, so which slice we use as current decoded result/destination and which slices will be used as reference images. Managing the DPB state is up to the application, and telling Vulkan is done through the following chained structures:</p>



<ul>
<li>VkVideoReferenceSlotInfoKHR</li>



<li>VkVideoPictureResourceInfoKHR</li>



<li>VkVideoDecodeH264DpbSlotInfoKHR</li>



<li>StdVideoDecodeH264ReferenceInfo</li>
</ul>



<p>All these structures basically tell is the VkImageView of the DPB texture, the array slice, offsets/width/height and some H264 parameters. The StdVideoDecodeH264ReferenceInfo contains the H264 parameters for the DPB slots, most importantly:</p>



<ul>
<li>flags.bottom_field_flag and flags.top_field_flag, both should be set to 1 for progressive (non-interlaced) video frames. This is important and easy to miss, and one of the main reason I have seen video corruption.</li>



<li>FrameNum: this is coming from the slice header’s frame_num value</li>



<li>PicOrderCnt: this is an array of two integers, for progressive frame you must set both to the same value. Calculating this value is a bit complicated, I will describe it below.</li>
</ul>



<p>PicOrderCnt or Picture Order Count is telling us the frame display ordering, because in H264, the frame data order in memory is in the order of decoding, not the displaying. Each slice header contains the pic_order_cnt_lsb value, which must be added to pic_order_cnt_msb to compute the value of PicOrderCnt. But the pic_order_cnt_msb is not available, but must be calculated based on SPS::log2_max_pic_order_cnt_lsb_minus4 and SPS::pic_order_cnt_type.</p>



<p>I give my code example for this, which works okayish for me but it could or could not have some issues (I’ve seen some frame pacing stutter in some videos that I couldn’t figure out yet)</p>


<div><pre title="">// Tracking values declared before iterating slices:
int prev_pic_order_cnt_lsb = 0;
int prev_pic_order_cnt_msb = 0;
int poc_cycle = 0;

// For each slice, do the following:

// Rec. ITU-T H.264 (08/2021) page 77
int max_pic_order_cnt_lsb = 1 &lt;&lt; (sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
int pic_order_cnt_lsb = slice_header-&gt;pic_order_cnt_lsb;

if (pic_order_cnt_lsb == 0)
{
	poc_cycle++;
}

// Rec. ITU-T H.264 (08/2021) page 115
// Also: https://www.ramugedia.com/negative-pocs
int pic_order_cnt_msb = 0;
if (pic_order_cnt_lsb &lt; prev_pic_order_cnt_lsb &amp;&amp; (prev_pic_order_cnt_lsb - pic_order_cnt_lsb) &gt;= max_pic_order_cnt_lsb / 2)
{
	pic_order_cnt_msb = prev_pic_order_cnt_msb + max_pic_order_cnt_lsb; // pic_order_cnt_lsb wrapped around
}
else if (pic_order_cnt_lsb &gt; prev_pic_order_cnt_lsb &amp;&amp; (pic_order_cnt_lsb - prev_pic_order_cnt_lsb) &gt; max_pic_order_cnt_lsb / 2)
{
	pic_order_cnt_msb = prev_pic_order_cnt_msb - max_pic_order_cnt_lsb; // here negative POC might occur
}
else
{
	pic_order_cnt_msb = prev_pic_order_cnt_msb;
}
prev_pic_order_cnt_lsb = pic_order_cnt_lsb;
prev_pic_order_cnt_msb = pic_order_cnt_msb;

// final value of PicOrderCnt:
PicOrderCnt = pic_order_cnt_msb + pic_order_cnt_lsb;
</pre></div>


<p>To learn more about different picture order count types, read this: <a rel="noreferrer noopener" href="https://www.vcodex.com/h264avc-picture-management/" target="_blank">H264 picture management</a>.</p>



<p>So for one thing, you will need the PicOrderCnt to provide the data to Vulkan, but also to determine the correct display order of frames. You basically need to sort the frames by increasing value of PicOrderCnt (POC from now on), but watch out that the value will be occasionally wrap around and reset to zero. You will need to handle that by grouping the frames by POC wrapping cycle. When I detect that POC wrapped, I assign an increased GOP value (stands for Group Of Pictures) to every frame besides the POC value. Then when sorting, I create a priority value for every frame from the GOP and POC values, by putting the GOP value to high 32bits of a 64-bit integer, and POC value to the low 32 bits. For example, If I have a POC sequence like this, this is how the GOP value will be tracked:</p>



<ul>
<li>frame 1: POC 0, GOP 0 &lt;== initialize GOP to 0</li>



<li>frame 2: POC 3, GOP 0</li>



<li>frame 3: POC 1, GOP 0</li>



<li>frame 4: POC 2, GOP 0</li>



<li>frame 5: POC 0, GOP 1 &lt;== POC wrapped to 0, increase GOP</li>



<li>frame 6: POC 2, GOP 1</li>



<li>frame 7: POC 1, GOP 1</li>



<li>frame 8: POC 0, GOP 2 &lt;== POC wrapped to 0, increase GOP</li>



<li>frame 9: POC 1, GOP 2</li>



<li>…</li>
</ul>



<p>Then sorting can be done like this for example:</p>


<div><pre title="">std::vector&lt;size_t&gt; frame_display_order(video-&gt;frames_infos.size());
for (size_t i = 0; i &lt; video-&gt;frames_infos.size(); ++i)
{
	frame_display_order[i] = i;
}
std::sort(frame_display_order.begin(), frame_display_order.end(), [&amp;](size_t a, size_t b) {
	const Video::FrameInfo&amp; frameA = video-&gt;frames_infos[a];
	const Video::FrameInfo&amp; frameB = video-&gt;frames_infos[b];
	int64_t prioA = (int64_t(frameA.gop) &lt;&lt; 32ll) | int64_t(frameA.poc);
	int64_t prioB = (int64_t(frameB.gop) &lt;&lt; 32ll) | int64_t(frameB.poc);
	return prioA &lt; prioB;
});
</pre></div>


<p>After this, the frame_display_order array is sorted by display order priority, and each element contains an index into the original video frames array (video-&gt;frame_infos). The display order for the above sequence looks like this:</p>



<ul>
<li>frame 1</li>



<li>frame 3</li>



<li>frame 4</li>



<li>frame 2</li>



<li>frame 5</li>



<li>frame 7</li>



<li>frame 6</li>



<li>frame 8</li>



<li>frame 9</li>



<li>…</li>
</ul>



<p>Now the trick is that you want to decode the frames in original decoding order, but only display a new frame when the next required display order value is reached, which is always increasing by one when a new frame is displayed. For this, I copy back the display order values to the original video frame infos:</p>


<div><pre title="">for (size_t i = 0; i &lt; frame_display_order.size(); ++i)
{
	video-&gt;frames_infos[frame_display_order[i]].display_order = (int)i;
}
</pre></div>


<p>The other trick is that your DPB (Decoded Picture Buffer array texture) state management can be decoupled from the display ordering to simplify it (at least that’s how I did it). Each time a new frame is decoded, it will be resolved to a new RGB texture, so I keep an other buffer of textures independently from the DPB. Even though the newly decoded frame is resolved into an RGB texture (later I show an example how), it is not displayed yet if it’s not the next displayable one, but kept around until needed. The good thing is that the DPB slot can be reused after this immediately for the next decodable frame (or kept around if it’s needed as a reference).</p>



<p>The simple DPB management scheme I am using goes like this: </p>



<ul>
<li>You start with a DPB array texture with array_size = sps.num_ref_frames + 1</li>



<li>Have a FIFO queue to keep track of reference frames, maximum size is DPB array_size – 1</li>



<li>Track the current DPB slot that’s going to contain decode result, it’s an index that starts from zero</li>



<li>If current frame is an IDR-frame (Intra frame and also a reference), clear the reference frame queue</li>



<li>Decode frame into current DPB slot, while you provide other slot indices to Vulkan that were used as reference</li>



<li>Resolve the current decode result into an RGB texture that will be used for display</li>



<li>If current frame is also a reference frame (if NALHeader::idc &gt; 0) then add this slot as active reference to the queue. If queue is full, remove oldest element (FIFO). Also increase the current slot index because next frame mustn’t overwrite the current slot as it will be used as reference. The next slot index must be wrapped in the range [0, DPB.array_size)</li>



<li>If current frame is not a reference frame, then the current slot can be reused in the next decode operation, there is nothing else to do</li>
</ul>



<p>The scheme above is as you can see a simple FIFO queue that track reference frames and one output decode frame. However the H264 specification also has a “long term reference frame” flag, which this doesn’t handle. Currently I haven’t had a video which uses long term reference frame, thus haven’t tried that yet.</p>



<p>On the Vulkan side, the VkVideoBeginCodingInfoKHR requires you to state all the DPB slots you are going to use in the pReferenceSlots and referenceSlotCount parameters. Don’t confuse this with the DPB references, because these are referring to the  array of VkVideoReferenceSlotInfoKHR parameters, that will not necessarily be all describing a reference image, one of them will also describe the current DPB decode slot. For the current decode slot, you must specify VkVideoReferenceSlotInfoKHR::slotIndex = -1 to tell that this slot is not used as reference, but it will be activated now and used in video coding operations – until vkCmdEndVideoCodingKHR is not called.</p>



<p>Contrast to the VkVideoBeginCodingInfoKHR, in the VkVideoDecodeInfoKHR’s pReferenceSlots and referenceSlotCount you must only include the slots that are used as reference for the decode operation, not the currently written DPB slot that you activate in the VkVideoBeginCodingInfoKHR. Thankfully, messing up here will trigger validation layer messages which can help in the otherwise confusing namings.</p>



<h2>Resolving to RGB</h2>



<p>First, in Vulkan there is an optional hardware feature called sampler <a rel="noreferrer noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_sampler_ycbcr_conversion.html" target="_blank">YcbCr conversion</a> which lets you skip this step and sample from YUV textures directly. My goal was also to support video decoding in DX12, so I decided to not use this, because it is not available there. In this case, you will need to resolve the YUV textures into RGB textures with a shader. As a sidenote, I also generate mipmap chain for video frames, and that is sure to be supported for regular RGB textures.</p>



<p>The before mentioned YUV texture format VK_FORMAT_G8_B8R8_2PLANE_420_UNORM is a multi planar format, meaning it has the luminance part stored separately in memory from the chrominance part. </p>



<ul>
<li>The luminance part is a full resolution 8 bit per pixel image and can be accessed with VK_IMAGE_ASPECT_PLANE_0_BIT. It can be viewed as a shader resource with the VK_FORMAT_R8_UNORM or VK_FORMAT_R8_UINT formats.</li>



<li>The chrominance is a 8+8 bit per pixel image, but the resolution is half of the luminance in both dimensions and can be accessed with VK_IMAGE_ASPECT_PLANE_1_BIT. It can be viewed as shader resource with the VK_FORMAT_R8G8_UNORM or VK_FORMAT_R8G8_UINT formats.</li>
</ul>



<p>I recommend creating the shader resource views as UNORM formats, to gain the ability to use the texture sampling operation, which is especially helpful for the chrominance image – that will be bilinearly sampled because it’s resolution is lower than luminance.</p>



<p>This means that in Vulkan, you will need to create two separate image views for one YUV texture, using two different subresource aspects, and bind those to a shader. Here is a shader snippet that shows you how to declare, sample and convert the luminance and chrominance images to RGB (in HLSL):</p>


<div><pre title="">// Declarations before shader:
Texture2DArray&lt;float&gt; input_luminance : register(t0);
Texture2DArray&lt;float2&gt; input_chrominance : register(t1);
RWTexture2D&lt;unorm float4&gt; output : register(u0); // for example VK_FORMAT_R8G8B8A8_UNORM

// Sampling in shader:
float luminance = input_luminance.SampleLevel(sampler_linear_clamp, uv, 0);
float2 chrominance = input_chrominance.SampleLevel(sampler_linear_clamp, uv, 0);

// Converting:
float C = luminance - 16.0 / 255.0;
float D = chrominance.x - 0.5;
float E = chrominance.y - 0.5;

float r = saturate(1.164383 * C + 1.596027 * E);
float g = saturate(1.164383 * C - (0.391762 * D) - (0.812968 * E));
float b = saturate(1.164383 * C + 2.017232 * D);

// Output to RGB texture:
output[DTid.xy] = float4(r, g, b, 1);
</pre></div>


<p>You can find a reference guide to YUV texture conversions on <a rel="noreferrer noopener" href="https://learn.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering#converting-8-bit-yuv-to-rgb88" target="_blank">Microsoft MSDN</a>.</p>



<h2>Performance</h2>



<p>I was having difficulties getting accurate performance readings, because timestamp query is currently not working on the video decode queue it seems (I’m using Nvidia RTX 2060 laptop GPU). Nvidia Nsight GPU profiler also doesn’t display video decoding information unfortunately. There is a way to time the video queue however, by issuing timestamps in a queue that executes before the video queue, and on that executes after, and the queues are synced with each other. With this method, I see that it takes about 1.8 milliseconds decoding a Full HD (1920 * 1080) H264 video frame, so I can decode 9 Full HD videos while maintaining 60 FPS. For a 4K video (3840 * 2160) it takes 5.2 milliseconds to decode a frame, so it would be possible to run 3 4K videos at once while maintaining 60 FPS on this GPU.</p>



<p>TLDR:</p>



<ul>
<li>Nvidia RTX 2060 (laptop) GPU</li>



<li>1080p (Full HD) video decode: 1.8 ms / frame</li>



<li>2160p (4K) video decode: 5.2 ms / frame</li>
</ul>



<ul>
<li>Nvidia GTX 1070 (desktop) GPU</li>



<li>1080p (Full HD) video decode: 1.7 ms / frame</li>



<li>2160p (4K) video decode: 5.7 ms / frame</li>
</ul>



<p>And remember that you can run the video decoding tasks asynchronously with many other GPU work, for example I am running video decoding in the beginning of the frame while things depth-prepass is rendering on graphics queue, particle and BVH updating is running on compute queue and virtual texture copies are running on the transfer queue. That means much of the video decoding is actually free, until you need one of the queues to wait for decoding results to complete.</p>



<h2>DirectX 12</h2>



<p>I was planning to implement decoding in DX12 which is similarly low level to Vulkan: I also needs to allocate and track DPB resources by user, and provide similar structures describing the SPS, PPS and slice headers. Although it uses a mush lower amount of structures, they are more confusing as they require understanding yet an other specification, the <a rel="noreferrer noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=11323" target="_blank">DXVA for H264</a>, because the DecodeFrame command requires you to provide DXVA structures that describe the video frame. Aside from reading the linked DXVA spec, you can also take a look at the Mesa open source library, specifically <a rel="noreferrer noopener" href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/drivers/d3d12/d3d12_video_dec_h264.cpp" target="_blank">this file that fills the DXVA structures</a>. Sadly, I was unable to get the DX12 decoder up and running, currently I get completely broken result on Intel, and unavoidable crashing on Nvidia, even though I think all parameters are specified correctly.</p>



<h2>Closing</h2>



<p>After spending about a month to bring video decoding to Wicked Engine in Vulkan and DX12, I learned a lot and glad at least Vulkan implementation was successful. I wanted to give up somewhere half way because it was turning out to be a much bigger task than I anticipated. While my implementation has some issues in the beginning like some frame stuttering in some videos, it is already very useful as I can place videos really easily into the game world. You can look at my codes in Wicked Engine:</p>



<ul>
<li><a href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiVideo.cpp" target="_blank" rel="noreferrer noopener">wiVideo</a>: implementation for MP4 video file loading, demuxing, parsing SPS, PPS, SliceHeader, DPB management</li>



<li><a href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiGraphicsDevice_Vulkan.cpp" target="_blank" rel="noreferrer noopener">GraphicsDevice_Vulkan</a>: Vulkan implementations, especially the CreateVideoDecoder() and VideoDecode() functions</li>



<li><a rel="noreferrer noopener" href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiGraphicsDevice_DX12.cpp" target="_blank">GraphicsDevice_DX12</a>: using the same interface as Vulkan, but DX12 implementation</li>



<li><a rel="noreferrer noopener" href="https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/Utility/h264.h" target="_blank">h264.h</a>: minimal h264 parser just to pass video information to decoder</li>
</ul>



<p>Video resources by others:</p>



<ul>
<li><a href="https://youtu.be/R5x6_nBRrv4" target="_blank" rel="noreferrer noopener">Deep dive into Vulkan Video from Vulkanised 2023</a></li>



<li><a rel="noreferrer noopener" href="https://themaister.net/blog/2023/01/05/vulkan-video-shenanigans-ffmpeg-radv-integration-experiments/" target="_blank">Vulkan video shenanigans – FFmpeg + RADV integration experiments by Maister</a></li>



<li><a href="https://lynne.ee/vulkan-video-decoding.html" target="_blank" rel="noreferrer noopener">Vulkan Video Decoding by Lynne</a></li>



<li><a href="https://www.rastergrid.com/blog/multimedia/2021/05/video-compression-basics/" target="_blank" rel="noreferrer noopener">Video Compression Basics by RasterGrid</a></li>
</ul>



<p>Happy video decoding!</p>
					</div></div>
  </body>
</html>
