<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.miguelgrinberg.com/post/python-3-14-is-here-how-fast-is-it">Original</a>
    <h1>Python 3.14 is here. How fast is it?</h1>
    
    <div id="readability-page-1" class="page"><div><p>In November of 2024 I wrote a blog post titled <a href="https://blog.miguelgrinberg.com/post/is-python-really-that-slow">&#34;Is Python Really That Slow?&#34;</a>, in which I tested several versions of Python and noted the steady progress the language has been making in terms of performance.</p>
<p>Today is the 8th of October 2025, just a day after the official release of Python 3.14. Let&#39;s rerun the benchmarks to find out how fast the new version of Python is!</p>
<p><em>Note: If you do  not care about tables and charts with results and just want to read my conclusions, <a href="#conclusions">click here</a> to go to the end of the article</em>.</p>
<h2>A Quick Word On How Misleading Benchmarks Can Be</h2>
<p>Yes, even though I&#39;m going to share the results of my benchmark, I feel I have to warn you again, like I did in the previous article, that generic benchmarks like this one are not really very useful. Running these benchmarks is fun, and that is why I do it, but it is really impossible to build an accurate performance profile of something as complex as the Python interpreter just from running a couple of silly little scripts.</p>
<p>I have designed my tests so that they run only pure Python code, avoiding the use of any dependencies, and in particular any functions that are written in C code. Native code (aside from the Python interpreter itself, that is) is less likely to become faster from one release of Python to the next, so I see no point in including that in the benchmark. But real-world applications do often use a mix of pure Python and native code, be it C, C++ or Rust, so while my test scripts are great to evaluate the performance of pure Python code, I do not consider them to be representative of the applications we normally use.</p>
<p>In short, have a look at my benchmark, but consider it just one data point and not the last word on Python performance!</p>
<h2>The Testing Matrix</h2>
<p>Here is the test matrix that I&#39;ve worked with, with five dimensions:</p>
<ul>
<li>6 Python versions, plus recent versions of Pypy, Node.js and Rust:<ul>
<li><a href="https://www.python.org/">CPython</a> 3.9, 3.10, 3.11, 3.12, 3.13, 3.14</li>
<li><a href="https://pypy.org/">Pypy</a> 3.11</li>
<li><a href="https://nodejs.org/en">Node</a> 24</li>
<li><a href="https://rust-lang.org/">Rust</a> 1.90</li>
</ul>
</li>
<li>3 Python interpreters<ul>
<li>Standard</li>
<li>Just-In-Time (JIT): only for CPython 3.13+</li>
<li>Free-threading (FT): only for CPython 3.13+</li>
</ul>
</li>
<li>2 test scripts<ul>
<li><em>fibo.py</em>: calculates <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci numbers</a>, relying heavily on recursion</li>
<li><em>bubble.py</em>: sorts a list of randomly generated numbers with the <a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a> algorithm, with a lot of iteration, but no recursion</li>
</ul>
</li>
<li>2 threading modes<ul>
<li>Single-threaded</li>
<li>4 threads running independent calculations</li>
</ul>
</li>
<li>2 computers<ul>
<li>Framework laptop running Ubuntu Linux 24.04 (Intel Core i5 CPU)</li>
<li>Mac laptop running macOS Sequoia (M2 CPU)</li>
</ul>
</li>
</ul>
<p>You may think that including Node.js and Rust in my benchmark is an odd choice. Maybe it is, but just the same, I ported the two Python test applications to JavaScript and Rust, so that I can have some reference numbers from outside of the Python ecosystem, just to put things into perspective.</p>
<h2>The Test Scripts</h2>
<p>Below you can see the main logic in <em>fibo.py</em>:</p>
<pre><code>def fibo(n):
    if n &lt;= 1:
        return n
    else:
        return fibo(n-1) + fibo(n-2)
</code></pre>
<p>After running some experiments, I&#39;ve determined that calculating the 40th Fibonacci number with this function took a few seconds on my two laptops, so this is what I used for all the test results I&#39;m sharing below.</p>
<p>Here is the sort function from <em>bubble.py</em>:</p>
<pre><code>def bubble(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
</code></pre>
<p>For this script I also eyeballed what array size to use so that the script took a few seconds to run. I settled on using a list with 10,000 numbers that are randomly generated.</p>
<p>Please do not assume that these are great examples, because they are not. There are more efficient ways to code these functions if the goal was to make them run as fast as possible. But the goal here is not to have fast functions, but to compare how different Python interpreters run the code. I have chosen these functions mainly because one is recursive and the other is not, so that I have two different coding styles in the test set.</p>
<p>The framework that I built for running this benchmark executes each test function three times and reports the average time of the three runs. The complete test scripts along with the benchmark scripts are available on the <a href="https://github.com/miguelgrinberg/pyspeed">GitHub repository</a>.</p>
<h2>Benchmark #1: Fibonacci single-threaded</h2>
<p>Okay, let&#39;s have a look at the first test. For this test I measured the time it took to run <code>fibo(40)</code> in seconds. As I mentioned above, for each data point I ran the code three times and averaged the results.</p>
<p>Here are the numbers in table form:</p>
<table>
<thead>
<tr>
<th>fibo 1 thread</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.9</td>
<td>15.21</td>
<td>13.81</td>
<td>0.45x</td>
</tr>
<tr>
<td>3.10</td>
<td>16.24</td>
<td>14.97</td>
<td>0.42x</td>
</tr>
<tr>
<td>3.11</td>
<td>9.11</td>
<td>9.23</td>
<td>0.71x</td>
</tr>
<tr>
<td>3.12</td>
<td>8.01</td>
<td>8.54</td>
<td>0.78x</td>
</tr>
<tr>
<td>3.13</td>
<td>8.26</td>
<td>8.24</td>
<td>0.79x</td>
</tr>
<tr>
<td>3.14</td>
<td>6.59</td>
<td>6.39</td>
<td>--</td>
</tr>
<tr>
<td>Pypy 3.11</td>
<td>1.39</td>
<td>1.24</td>
<td>4.93x</td>
</tr>
<tr>
<td>Node 24</td>
<td>1.38</td>
<td>1.28</td>
<td>4.88x</td>
</tr>
<tr>
<td>Rust 1.90</td>
<td>0.08</td>
<td>0.10</td>
<td>69.82x</td>
</tr>
</tbody>
</table>
<p>The rightmost column shows the speed ratio against 3.14, so a number smaller than 1 in this column means that the corresponding test was slower than 3.14, and a number above means that it was faster. To calculate these ratios I used the average between the Linux and macOS results.</p>
<p>Sometimes it helps to see the data graphically as well, so here is a chart with the above numbers:</p>
<p><img alt="fibo 1 thread" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-fibo1-all.png"/></p>
<p>What can be learn from these results? We can see that 3.14 has gotten a nice speed improvement over 3.13. It ran close to 27% faster, which is another way of saying that 3.13 ran at about 79% of the speed of 3.14. These results also show that version 3.11 is the point at which Python versions moved from being &#34;very slow&#34; to &#34;not so slow&#34;.</p>
<p>One more detail that isn&#39;t related to Python 3.14 is that Pypy continues to blow my mind. In this test it was a hair faster that Node.js, and almost 5 times faster than 3.14. Impressive, although still quite far away from Rust, which as expected runs circles around everybody else.</p>
<h3>Just-In-Time and Free-Threading Variants</h3>
<p>Starting with Python 3.13, the CPython interpreter comes in three flavors: standard, free-threading (FT) and just-in-time (JIT). The free-threading interpreter disables the global interpreter lock (GIL), a change that promises to unlock great speed gains in multi-threaded applications. The JIT interpreter includes an on-the-fly compiler to native code, which should, in theory, help portions of code that run multiple times get faster by having them compiled to native code only once.</p>
<p>The results I shared above for 3.13 and 3.14 used the standard interpreter, but I also wanted I to see specifically how the other two interpreter variants dealt with my test.  In the next table and chart you can see a comparison of the same test running on the three interpreters under 3.13 and 3.14:</p>
<table>
<thead>
<tr>
<th>fibo 1 thread</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.13</td>
<td>8.26</td>
<td>8.24</td>
<td>0.79x</td>
</tr>
<tr>
<td>3.13 JIT</td>
<td>8.26</td>
<td>8.28</td>
<td>0.78x</td>
</tr>
<tr>
<td>3.13 FT</td>
<td>12.40</td>
<td>12.40</td>
<td>0.52x</td>
</tr>
<tr>
<td>3.14</td>
<td>6.59</td>
<td>6.39</td>
<td>--</td>
</tr>
<tr>
<td>3.14 JIT</td>
<td>6.59</td>
<td>6.37</td>
<td>1.00x</td>
</tr>
<tr>
<td>3.14 FT</td>
<td>7.05</td>
<td>7.27</td>
<td>0.91x</td>
</tr>
</tbody>
</table>
<p><img alt="fibo 1 thread - Interpreter variants" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-fibo1-latest.png"/></p>
<p>And this is a bit disappointing. At least for this test, the JIT interpreter did not produce any significant performance gains, so much that I had to double and triple check that I used a correctly built interpreter with this feature enabled. I do not know much about the internals of the new JIT compiler, but I&#39;m wondering if it cannot deal with this heavily recursive function.</p>
<p>As far as free-threading, I already discovered last year that the interpreter was slow when running single-threaded code. In 3.14 this interpreter appears to still be slower than the standard interpreter, but the difference is much smaller, with free-threading running at just 91% of the speed of the standard interpreter.</p>
<h2>Benchmark #2: Bubble sort single-threaded</h2>
<p>The following results are for the bubble sort benchmark, sorting an array of 10,000 random numbers:</p>
<table>
<thead>
<tr>
<th>bubble 1 thread</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.9</td>
<td>3.77</td>
<td>3.29</td>
<td>0.60x</td>
</tr>
<tr>
<td>3.10</td>
<td>4.01</td>
<td>3.38</td>
<td>0.57x</td>
</tr>
<tr>
<td>3.11</td>
<td>2.48</td>
<td>2.15</td>
<td>0.91x</td>
</tr>
<tr>
<td>3.12</td>
<td>2.69</td>
<td>2.46</td>
<td>0.82x</td>
</tr>
<tr>
<td>3.13</td>
<td>2.82</td>
<td>2.61</td>
<td>0.78x</td>
</tr>
<tr>
<td>3.14</td>
<td>2.18</td>
<td>2.05</td>
<td>--</td>
</tr>
<tr>
<td>Pypy 3.11</td>
<td>0.10</td>
<td>0.14</td>
<td>18.14x</td>
</tr>
<tr>
<td>Node 24</td>
<td>0.43</td>
<td>0.21</td>
<td>6.64x</td>
</tr>
<tr>
<td>Rust 1.90</td>
<td>0.04</td>
<td>0.07</td>
<td>36.15x</td>
</tr>
</tbody>
</table>
<p><img alt="bubble 1 thread" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-bubble1-all.png"/></p>
<p>This test shows a larger discrepancy between my Linux and macOS laptops, but the ratios between versions on each machine are more or less the same. The difference just suggests that Python on the Mac is able to run this test slightly faster.</p>
<p>The 3.14 interpreter is the faster of the CPythons as in the Fibonacci test, but the difference here is smaller than in the previous benchmark, with Python 3.11 clocking in at just 91% of the speed of 3.14. This test also runs slower in 3.12 and 3.13 than in 3.11, an interesting oddity that I also observed in last year&#39;s benchmark.</p>
<p>Pypy this time was 18 times faster than 3.14, and even 3 times faster than Node. I really need to spend some time evaluating Pypy, because it looks amazing.</p>
<h3>Just-In-Time and Free-Threading Variants</h3>
<p>Let&#39;s see how the 3.13 and 3.14 specialized interpreters fared on the bubble sort test. Here is the table and chart with the results:</p>
<table>
<thead>
<tr>
<th>bubble 1 thread</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.13</td>
<td>2.82</td>
<td>2.61</td>
<td>0.78x</td>
</tr>
<tr>
<td>3.13 JIT</td>
<td>2.59</td>
<td>2.44</td>
<td>0.84x</td>
</tr>
<tr>
<td>3.13 FT</td>
<td>4.13</td>
<td>3.75</td>
<td>0.54x</td>
</tr>
<tr>
<td>3.14</td>
<td>2.18</td>
<td>2.05</td>
<td>--</td>
</tr>
<tr>
<td>3.14 JIT</td>
<td>2.03</td>
<td>2.32</td>
<td>0.97x</td>
</tr>
<tr>
<td>3.14 FT</td>
<td>2.66</td>
<td>2.28</td>
<td>0.86x</td>
</tr>
</tbody>
</table>
<p><img alt="bubble 1 thread - Interpreter variants" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-bubble1-latest.png"/></p>
<p>The JIT interpreter appears to be a little bit faster here, but only on the Linux version of Python. On the Mac it was a bit faster for 3.13, but slower for 3.14. The speed differences are also very small, so overall I&#39;m feeling the JIT interpreter needs some more time to mature. It seems the code that I&#39;m using is somehow not able to benefit much from JIT compilation.</p>
<p>The free-threading interpreter also ran slower, but again the difference was much smaller in 3.14 than in 3.13, so this is consistent between the two benchmarks. At this point it does not seem like it would make sense to switch to the free-threading interpreter for regular workloads, but it could be an interesting option when the GIL is really getting in the way, which is only for multi-threaded with big CPU needs.</p>
<h2>Benchmark #3: Fibonacci multi-threaded</h2>
<p>This year I decided to introduce multi-threaded versions of the two test programs, mainly as an excuse to give the free-threading interpreter the chance to shine.</p>
<p>What I did for the multi-threaded Fibonacci test is to start four threads running the same calculation of the 40th Fibonacci. The four threads ran independently of each other, and the two laptops that I&#39;m using have more than four cores, so they should be able to parallelize this test nicely. The time measurement that I used is from the time I launched the first thread to the time all four threads ended.</p>
<p>Here are the results of <em>fibo.py</em> running on 4 threads running on the standard interpreters:</p>
<table>
<thead>
<tr>
<th>fibo 4 threads</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.9</td>
<td>67.87</td>
<td>57.51</td>
<td>0.46x</td>
</tr>
<tr>
<td>3.10</td>
<td>72.42</td>
<td>61.57</td>
<td>0.43x</td>
</tr>
<tr>
<td>3.11</td>
<td>45.83</td>
<td>36.98</td>
<td>0.70x</td>
</tr>
<tr>
<td>3.12</td>
<td>36.22</td>
<td>34.13</td>
<td>0.82x</td>
</tr>
<tr>
<td>3.13</td>
<td>37.20</td>
<td>33.53</td>
<td>0.81x</td>
</tr>
<tr>
<td>3.14</td>
<td>32.60</td>
<td>24.96</td>
<td>--</td>
</tr>
<tr>
<td>Pypy 3.11</td>
<td>7.49</td>
<td>6.84</td>
<td>4.02x</td>
</tr>
</tbody>
</table>
<p><img alt="fibo 4 threads" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-fibo4-all.png"/></p>
<p>Note that I did not run Node and Rust versions of the tests here, since this is a very specific test that only applies to Python&#39;s GIL.</p>
<p>Of course these results do not tell us much. We can see again that my Mac seems a bit faster than my Linux machine, but aside from that things have more or less scaled linearly. For example, the single-threaded Fibonacci test ran in 7 seconds, and here it took 25 on the Mac and 32 on Linux, which is, give or take a 4x scale. This is expected because the GIL does not permit the Python code to parallelize.</p>
<p>Let&#39;s see the detailed results on the 3.13 and 3.14 interpreters:</p>
<table>
<thead>
<tr>
<th>fibo 4 threads</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.13</td>
<td>37.20</td>
<td>33.53</td>
<td>0.81x</td>
</tr>
<tr>
<td>3.13 JIT</td>
<td>37.48</td>
<td>33.36</td>
<td>0.81x</td>
</tr>
<tr>
<td>3.13 FT</td>
<td>21.14</td>
<td>15.47</td>
<td>1.57x</td>
</tr>
<tr>
<td>3.14</td>
<td>32.60</td>
<td>24.96</td>
<td>--</td>
</tr>
<tr>
<td>3.14 JIT</td>
<td>32.58</td>
<td>24.90</td>
<td>1.00x</td>
</tr>
<tr>
<td>3.14 FT</td>
<td>10.80</td>
<td>7.81</td>
<td>3.09x</td>
</tr>
</tbody>
</table>
<p><img alt="fibo 4 threads - Interpreter variants" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-fibo4-latest.png"/></p>
<p>And this is quite nice!</p>
<p>Since we were not expecting anything significant for the JIT interpreter on this test, we can ignore those results. But the free-threading interpreter is showing us how removing the GIL can help with running multiple threads that are CPU hungry.</p>
<p>In Python 3.13 the free-threading interpreter ran about 2.2x faster than the standard interpreter. In 3.14 the performance improvement is about 3.1x. This is an exciting result!</p>
<h2>Benchmark #4: Bubble sort multi-threaded</h2>
<p>To complete this benchmarking exercise, below you can see the results of the bubble sort test running on 4 threads. For this test I had each thread sort 10,000 random numbers. The four threads received copies of the same randomly generated array.</p>
<p>First let&#39;s look at the standard interpreters:</p>
<table>
<thead>
<tr>
<th>bubble 4 threads</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.9</td>
<td>16.14</td>
<td>12.58</td>
<td>0.66x</td>
</tr>
<tr>
<td>3.10</td>
<td>16.12</td>
<td>12.95</td>
<td>0.65x</td>
</tr>
<tr>
<td>3.11</td>
<td>11.43</td>
<td>7.89</td>
<td>0.97x</td>
</tr>
<tr>
<td>3.12</td>
<td>11.39</td>
<td>9.01</td>
<td>0.92x</td>
</tr>
<tr>
<td>3.13</td>
<td>11.54</td>
<td>9.78</td>
<td>0.88x</td>
</tr>
<tr>
<td>3.14</td>
<td>10.55</td>
<td>8.27</td>
<td>--</td>
</tr>
<tr>
<td>Pypy 3.11</td>
<td>0.54</td>
<td>0.59</td>
<td>16.65x</td>
</tr>
</tbody>
</table>
<p><img alt="bubble 4 threads" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-bubble4-all.png"/></p>
<p>These results show no big surprises either. The single-threaded version of this test executed in about 2 seconds on 3.14, and here we have 10 seconds on Linux and 8 seconds on Mac. It&#39;s interesting that on the Linux machine this test took a bit longer than 4x the single-threaded time.</p>
<p>Here are the results with the new interpreters in 3.13 and 3.14:</p>
<table>
<thead>
<tr>
<th>bubble 4 threads</th>
<th>Linux</th>
<th>macOS</th>
<th>vs. 3.14</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.13</td>
<td>11.54</td>
<td>9.78</td>
<td>0.88x</td>
</tr>
<tr>
<td>3.13 JIT</td>
<td>10.90</td>
<td>9.19</td>
<td>0.94x</td>
</tr>
<tr>
<td>3.13 FT</td>
<td>9.83</td>
<td>5.05</td>
<td>1.17x</td>
</tr>
<tr>
<td>3.14</td>
<td>10.55</td>
<td>8.27</td>
<td>--</td>
</tr>
<tr>
<td>3.14 JIT</td>
<td>10.03</td>
<td>9.26</td>
<td>0.98x</td>
</tr>
<tr>
<td>3.14 FT</td>
<td>6.23</td>
<td>3.02</td>
<td>2.03x</td>
</tr>
</tbody>
</table>
<p><img alt="bubble 4 threads - Interpreter variants" src="https://blog.miguelgrinberg.com/static/images/pyspeed2025-bubble4-latest.png"/></p>
<p>And here once again we see a good use case for the free-threading interpreter. For this test the Mac&#39;s free-threading did better than Linux, but on overage 3.14 FT ran about 2x faster than standard 3.14. If you have a multi-threaded application that is CPU heavy, a switch to the free-threading interpreter might be a good idea.</p>
<p>The odd results of the JIT interpreter being slower on the 3.14 Mac interpreter that we&#39;ve seen in the single-threaded bubble sort test have repeated here, so I guess they were not a fluke, but in any case the differences are not big enough to matter, in my opinion. We&#39;ll just have to wait for the JIT interpreter to continue evolving in future releases.</p>
<h2 id="conclusions">Conclusions</h2>

<p>I hope you found my benchmark results interesting. As way of a summary, these are the conclusions that I&#39;m making from these results:</p>
<ul>
<li>CPython 3.14 appears to be the fastest of all the CPythons.</li>
<li>If you can&#39;t upgrade to 3.14 just yet, consider using a release since 3.11, as these are significantly faster than 3.10 and older.</li>
<li>The 3.14 JIT interpreter does not appear to provide any significant gains in speed, at least not with my test scripts.</li>
<li>The 3.14 free-threading interpreter is faster than the standard interpreter for CPU heavy multi-threaded applications, so It is worth a try if your application fits this use case. I wouldn&#39;t recommend using this interpreter for other workloads, as it is still slower for code that is not directly slowed down by the GIL.</li>
<li>Pypy is insanely fast!</li>
</ul>
<p>Have you benchmarked Python 3.14? Let me know in the comments if you have results that are different than mine.</p></div><p>Thank you for visiting my blog! If you enjoyed this article, please consider supporting my work and keeping me caffeinated with a small one-time donation through <a href="https://www.buymeacoffee.com/miguelgrinberg">Buy me a coffee</a>. Thanks!</p></div>
  </body>
</html>
