<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notgull.net/blocking-leaky/">Original</a>
    <h1>Blocking code is a leaky abstraction</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Asynchronous code does not require the rest of your code to be asynchronous.
I can’t say the same for blocking code.</p>

<p><strong>Disclaimer:</strong> I am one of the maintainers for <a href="https://crates.io/crates/smol"><code>smol</code></a>, a small and fast <code>async</code> runtime for Rust.</p>

<p>I’ve been involved in the Rust community for four years at this point. At this
point, I’ve seen a lot of criticism of <code>async</code>. I’ve found it to be an
<a href="https://notgull.net/why-you-want-async/">elegant model for programming</a> that
<a href="https://notgull.net/why-not-threads/">easily outclasses alternatives</a>. I use it
frequently in my own programs when it fits. There are a lot of programs that
would be improved with the presence of <code>async</code>, that don’t use it because
people are scared of it. In fact, many organizations have a “hard ban” on
<code>async</code> code.</p>

<p>Some of this criticism is valid. <code>async</code> code is a little hard to wrap your head around,
but that’s true with many other concepts in Rust, like the borrow checker and
the weekly blood sacrifices. Many popular <code>async</code> libraries are explicitly tied to heavyweight
crates like <a href="https://crates.io/crates/tokio"><code>tokio</code></a> and <a href="https://crates.io/crates/future"><code>futures</code></a>, which aren’t good picks for many types of 
programs. There are also a lot of language features that need to be released for
<code>async</code> to be used without an annoying amount of <code>Box</code>ing <code>dyn</code>amic objects.</p>

<p>There’s one point, though, that I’ve heard quite frequently at this point. I think
it’s misleading. Let’s talk about it.</p>

<h2 id="whats-in-a-leak">What’s in a leak?</h2>

<p>I’ve seen a lot of people say that <code>async</code> is a “leaky abstraction”. What this means
is that the presence of <code>async</code> in a program forces you to bend the program’s
control flow to accommodate it. If you have 100 files in your program, and <em>one</em>
of those files uses <code>async</code>, you have to either write the <em>entire</em> program in
<code>async</code> or resort to bohemian, mind-bending hacks to contain it. Just like an
inlaw moving into your spare bedroom.</p>

<p>I do not mean memory leaks, which is what happens if you fail to free memory that you
allocate. Neither <code>async</code> nor blocking code has a problem with memory leaking intrinsically.</p>

<blockquote>
  <p><img src="https://notgull.net/images/ddog.jpg" alt="Dependency Dog" width="100"/>
<strong>Dependency Dog:</strong> If you want to see a good example of a leaky abstraction, consider <a href="https://developer.apple.com/documentation/appkit">AppKit</a>. Not only is AppKit thread-unsafe to the point where many functions can only safely be called on the <code>main()</code> thread, it forces you into Apple’s terrifying Objective-C model. Basically any program that wants to have working GUI on macOS now needs to interface in Apple’s way, with basically no alternatives.</p>
</blockquote>

<p>I’ve seen the <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">“What Color is Your Function?”</a>
blogpost by Bob Nystrom referenced a lot in these discussions. This blogpost was
originally written with JavaScript’s callbacks in mind. Fair enough. The callback
model is hard to deal with, and its enduring popularity in the Rust ecosystem is something
I have to write a blogpost about. He also mentions <code>async</code>/<code>await</code> as a potential
solution to this problem, although one that he is unsatisfied with, as it still
divides the ecosystem into asynchronous and synchronous halves.</p>

<p>While this blogpost may be correct when it comes to JavaScript and other, higher-level
languages, I believe that Rust stands out in such a way that it’s not true for this language.
In fact, I believe the opposite is true. Non-<code>async</code> code (or “blocking” code)
is the real leaky abstraction.</p>

<h2 id="object-class-safe">Object Class: Safe</h2>

<p>I’d like to discuss how you call blocking code from <code>async</code> code, and vice versa.
That way we can compare.</p>

<p>Let’s make a table to describe how it goes calling functions from one “color” to
another. You can call blocking code from blocking code without any issues. You
can also call asynchronous code from asynchronous code trivially. There is also
a strategy for calling asynchronous code from blocking code that I will go into
shortly. So our table looks like this:</p>

<table>
  <thead>
    <tr>
      <th>→ calls ↓  code</th>
      <th><code>async</code></th>
      <th>blocking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>async</code></td>
      <td>Trivial</td>
      <td>Generally Easy</td>
    </tr>
    <tr>
      <td>blocking</td>
      <td><em>We’ll see…</em></td>
      <td>Trivial</td>
    </tr>
  </tbody>
</table>

<p>Note that not all code fits cleanly into the <code>async</code>/blocking categories. A notorious
example is GUI code, which uses blocking semantics but overall acts a lot like <code>async</code>
code in that it’s not allowed to block. But that’s a topic for another post.</p>

<p>When you write an <code>async</code> function, it returns a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, which represents a
value that will eventually be resolved. There are a lot of things you can do with
a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>. You can race it against another <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, spawn it on an executor,
and any number of other operations. It’s a point I delve deeper into in
<a href="https://notgull.net/why-you-want-async/">this post</a>.</p>

<p>However, one of the simpler operations is to just wait for a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> to
complete. Often, the waiting is done by blocking the current thread. So by
<a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html">“blocking on”</a> the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, we can effectively turn an <code>async</code> function into
a synchronous call.</p>

<div><div><pre><code><span>async</span> <span>fn</span> <span>my_async_code</span><span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span>

<span>fn</span> <span>my_main_blocking_code</span><span>()</span> <span>{</span>
    <span>use</span> <span>futures_lite</span><span>::</span><span>future</span><span>::</span><span>block_on</span><span>;</span>
    <span>block_on</span><span>(</span><span>my_async_code</span><span>());</span>
<span>}</span>
</code></pre></div></div>

<p><a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> takes any <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, whether it’s <code>!Send</code> or not <code>&#39;static</code> or if
it’s about to explode. So literally any <code>async</code> function can be called from
synchronous code.</p>

<p>It’s relatively simple, too. <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> is implemented like this:</p>

<div><div><pre><code><span>pub</span> <span>fn</span> <span>block_on</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>future</span><span>:</span> <span>impl</span> <span>Future</span><span>&lt;</span><span>Output</span> <span>=</span> <span>T</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>T</span><span>{</span>
    <span>// A `Context` with a `Waker` is needed to poll a `Future`.</span>
    <span>let</span> <span>waker</span> <span>=</span> <span>waker_that_blocks_current_thread</span><span>();</span>
    <span>let</span> <span>mut</span> <span>context</span> <span>=</span> <span>Context</span><span>::</span><span>from_waker</span><span>(</span><span>&amp;</span><span>waker</span><span>);</span>

    <span>std</span><span>::</span><span>pin</span><span>::</span><span>pin!</span><span>(</span><span>future</span><span>);</span> <span>// This used to require `unsafe` code, but doesn&#39;t anymore!</span>

    <span>// Poll the future in a loop, blocking the thread while we wait.</span>
    <span>loop</span> <span>{</span>
        <span>match</span> <span>future</span><span>.as_mut</span><span>()</span><span>.poll</span><span>(</span><span>&amp;</span><span>mut</span> <span>context</span><span>)</span> <span>{</span>
            <span>Poll</span><span>::</span><span>Ready</span><span>(</span><span>value</span><span>)</span> <span>=&gt;</span> <span>return</span> <span>value</span><span>,</span>
            <span>Poll</span><span>::</span><span>Pending</span> <span>=&gt;</span> <span>block_thread_until_waker_wakes_us</span><span>(),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<blockquote>
  <p><img src="https://notgull.net/images/ddog.jpg" alt="Dependency Dog" width="100"/>
<strong>Dependency Dog:</strong> The actual <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> is a little more complicated. It has some logic to reuse the <code>waker</code> between function calls, to reduce the overhead to one thread-local key access and nothing else.</p>
</blockquote>

<p>Okay, but what if you don’t want <a href="https://crates.io/crates/futures-lite"><code>futures_lite</code></a> in your dependency tree? <a href="https://crates.io/crates/futures-lite"><code>futures_lite</code></a>
isn’t the heaviest dependency on the block (that’s <a href="https://crates.io/crates/future"><code>futures</code></a>), but it’s still a
non-negligible amount of code. No need to worry! There’s also <a href="https://crates.io/crates/pollster"><code>pollster</code></a>, which
has zero (required) dependencies and consists of less than 100 lines of code.</p>

<div><div><pre><code><span>fn</span> <span>my_main_blocking_code</span><span>()</span> <span>{</span>
    <span>use</span> <span>pollster</span><span>::</span><span>block_on</span><span>;</span>
    <span>block_on</span><span>(</span><span>my_async_code</span><span>());</span>
<span>}</span>
</code></pre></div></div>

<p>So, calling <code>async</code> code from blocking code is easy. Just call <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a>. It’s that simple!</p>

<h2 id="its-not-that-simple">It’s not that simple</h2>

<p>Of course it’s not that simple. I’m sure people familiar with actually calling
<code>async</code> code from blocking code are screaming at the screen right now. So let’s
address that.</p>

<p>There are a substantial number of <code>async</code> crates out there that run on top of
<a href="https://crates.io/crates/tokio"><code>tokio</code></a>. They use <a href="https://crates.io/crates/tokio"><code>tokio</code></a>’s primitives, <a href="https://crates.io/crates/tokio"><code>tokio</code></a>’s executor, and
<a href="https://crates.io/crates/tokio"><code>tokio</code></a>’s I/O semantics. Because of this, they rely on <a href="https://crates.io/crates/tokio"><code>tokio</code></a>’s runtime to
be running in the background. If you try the above strategy for a crate that
relies on <a href="https://crates.io/crates/tokio"><code>tokio</code></a>, it will fail at runtime with a panic.</p>

<p>No need to fear. We can start a <a href="https://crates.io/crates/tokio"><code>tokio</code></a> runtime and let it
peacefully run in the background, forever. The libraries are able to pick up on
this runtime and use it.</p>

<p>In <code>main()</code>, during your program initialization, put this:</p>

<div><div><pre><code><span>use</span> <span>std</span><span>::{</span><span>future</span><span>,</span> <span>thread</span><span>};</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// Create a runtime.</span>
    <span>let</span> <span>rt</span> <span>=</span> <span>tokio</span><span>::</span><span>runtime</span><span>::</span><span>Builder</span><span>::</span><span>new_current_thread</span><span>()</span>
        <span>.enable_all</span><span>()</span>
        <span>.build</span><span>()</span>
        <span>.unwrap</span><span>();</span>

    <span>// Clone a handle to the runtime and send it to another thread.</span>
    <span>thread</span><span>::</span><span>spawn</span><span>({</span>
        <span>let</span> <span>handle</span> <span>=</span> <span>rt</span><span>.handle</span><span>()</span><span>.clone</span><span>();</span>

        <span>// Run the handle on this thread, forever.</span>
        <span>move</span> <span>||</span> <span>handle</span><span>.block_on</span><span>(</span><span>future</span><span>::</span><span>pending</span><span>::</span><span>&lt;</span><span>()</span><span>&gt;</span><span>())</span>
    <span>});</span>

    <span>// &#34;Enter&#34; the runtime and let it sit there.</span>
    <span>let</span> <span>_guard</span> <span>=</span> <span>rt</span><span>.enter</span><span>();</span>

    <span>// Block on any futures.</span>
    <span>pollster</span><span>::</span><span>block_on</span><span>(</span><span>my_async_function</span><span>());</span>
<span>}</span>
</code></pre></div></div>

<p>For any <code>block_on</code> calls in your application, the runtime will already be
available. Note that you will need to call <code>enter()</code> on any new threads that use
<a href="https://crates.io/crates/tokio"><code>tokio</code></a> primitives. Thankfully you can get a <code>Handle</code> to the runtime, which
can be sent to any thread and is also cheaply clonable.</p>

<p>But that’s really it. Once you have the runtime humming away in the background,
<a href="https://crates.io/crates/tokio"><code>tokio</code></a> futures should Just Work!</p>

<p>As an aside, another hitch is that <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> and functions like it are only available on <code>std</code>-enabled
platforms. But the <code>no_std</code> <code>async</code> story is a blogpost for another day.</p>

<h3 id="a-quick-segue-into-tokiomain">A Quick Segue into <code>tokio::main</code></h3>

<p>I’ve seen some people recommend using the <a href="https://docs.rs/tokio/latest/tokio/attr.main.html"><code>tokio::main</code></a> attribute to turn an
<code>async</code> function into a blocking function, then calling that from your real code.
For example:</p>

<div><div><pre><code><span>#[tokio::main(flavor</span> <span>=</span> <span>&#34;current_thread&#34;</span><span>)]</span>
<span>async</span> <span>fn</span> <span>my_async_code</span><span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// `tokio::main` transparently converts `my_async_code` into a blocking function.</span>
    <span>my_async_code</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>It’s a little impressive, if not a little hacky. The <code>async</code> function is turned into
a blocking function using the proc macro.</p>

<p>But… just don’t do this. It means that, every time <code>my_async_code</code> is called, it
spins up a <a href="https://crates.io/crates/tokio"><code>tokio</code></a> runtime, runs the code, then immediately throws that runtime
away. For functions that are called a lot, it really adds up. In addition it makes
the function signature misleading. It’s a blocking function, not an <code>async</code> function!</p>

<h2 id="meanwhile-for-blocking-code">Meanwhile, for blocking code…</h2>

<p>First off, I find <code>async</code> code to be more predictable than blocking code, in a
weird way. Look at this function signature:</p>

<div><div><pre><code><span>async</span> <span>fn</span> <span>my_async_function</span><span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div></div>

<p>What does this tell you? I know that the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> returned by this function
won’t block. I can place it in my executor of choice, or race it against any
other <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>s, without worrying that it will hog the execution loop. By
convention <code>poll()</code> will probably run in a time period close to “instant”,
before yielding and then letting something else take over.</p>

<p>Yes, there are buggy <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>s out there. But well-formed <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>s
complete quickly.</p>

<p>Now look at this function signature:</p>

<div><div><pre><code><span>fn</span> <span>my_function</span><span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div></div>

<p>By looking at this function signature, can you tell how long it will take to run?
Maybe it will complete instantly. Maybe it reads from a file and can potentially
take between a few microseconds to a few <em>whole</em> seconds, depending on the file
system. Maybe it blocks on a network socket. Maybe it processes a bunch of data
in a loop, meaning that for large datasets it could run for a long time.</p>

<p>Yes, you can check the docs. But the docs usually fail to mention <em>any</em> of the
above behavior, even for functions in the standard library. All of this ignores
behavior dependent on generics/traits, too. It doesn’t matter how well-formed it is,
you can’t tell how this function will act.</p>

<p>Often, when writing <code>async</code> programs, I have to be extra sure when I use blocking
functions that I’m not accidentally blocking, which would lock up the entire event
loop. In most cases this requires me to read the entire code of the function
to understand what can go wrong.</p>

<p>If I can’t be sure it won’t block, I’ll need to wrap it in a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> that runs
it on its own isolated thread. <a href="https://crates.io/crates/smol"><code>smol</code></a> provides the <a href="https://crates.io/crates/blocking"><code>blocking</code></a> threadpool to
run code on other threads, while <a href="https://crates.io/crates/tokio"><code>tokio</code></a> has a <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a> function.</p>

<div><div><pre><code><span>use</span> <span>blocking</span><span>::</span><span>unblock</span><span>;</span>

<span>fn</span> <span>my_blocking_function</span><span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span>

<span>async</span> <span>fn</span> <span>my_async_main</span><span>()</span> <span>{</span>
    <span>unblock</span><span>(||</span> <span>my_blocking_function</span><span>())</span><span>.await</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This method comes at a cost. At the very least it’s an allocation for the blocking
task’s state, as well as a few atomic operations to push it and then pop it from some thread
pool’s task queue. At worst it spawns an entire new thread. Compare this to the
cost of <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> which is usually one thread-local access.</p>

<p>But wait! <a href="https://docs.rs/blocking/latest/blocking/fn.unblock.html"><code>unblock</code></a> will send the function to another thread to be run. So,
the function needs to be <code>Send</code> and <code>&#39;static</code>. This strategy doesn’t even work
if the function relies on some kind of thread-unsafe state, like a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.
If the function takes a reference to some data you may need to wrap it in an
<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>&lt;<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>&gt;.</p>

<div><div><pre><code><span>use</span> <span>blocking</span><span>::</span><span>unblock</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>sync</span><span>::{</span><span>Arc</span><span>,</span> <span>Mutex</span><span>};</span>

<span>fn</span> <span>my_blocking_function</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Foo</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>

<span>async</span> <span>fn</span> <span>my_async_main</span><span>()</span> <span>{</span>
    <span>let</span> <span>data</span> <span>=</span> <span>Arc</span><span>::</span><span>new</span><span>(</span><span>Mutex</span><span>::</span><span>new</span><span>(</span><span>/* ... */</span><span>));</span>
    <span>unblock</span><span>({</span>
        <span>let</span> <span>data</span> <span>=</span> <span>data</span><span>.clone</span><span>();</span>
        <span>move</span> <span>||</span> <span>my_blocking_function</span><span>(</span><span>&amp;</span><span>mut</span> <span>data</span><span>.lock</span><span>()</span><span>.unwrap</span><span>())</span>
    <span>})</span><span>.await</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>I know this is a common complain with <a href="https://crates.io/crates/tokio"><code>tokio</code></a>’s style of <code>async</code>/<code>await</code>, but
it’s just as bad the other way as well.</p>

<p>For the record, you can call <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a> with any kind of borrowed data, with no
hassles.</p>

<div><div><pre><code><span>async</span> <span>fn</span> <span>my_async_code</span><span>(</span><span>foo</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Foo</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>

<span>fn</span> <span>my_main_blocking_code</span><span>()</span> <span>{</span>
    <span>use</span> <span>futures_lite</span><span>::</span><span>future</span><span>::</span><span>block_on</span><span>;</span>

    <span>let</span> <span>mut</span> <span>data</span> <span>=</span> <span>/* ... */</span><span>;</span>
    <span>block_on</span><span>(</span><span>my_async_code</span><span>(</span><span>&amp;</span><span>mut</span> <span>data</span><span>));</span> <span>// This works!</span>
<span>}</span>
</code></pre></div></div>

<p>In order to avoid these issues I often have to segment out code that might block
into their own sections. This lets me avoid the overhead of <a href="https://docs.rs/blocking/latest/blocking/fn.unblock.html"><code>unblock</code></a> for each
function as a bonus.</p>

<div><div><pre><code><span>fn</span> <span>some_blocking_segment</span><span>(</span><span>mut</span> <span>data</span><span>:</span> <span>Foo</span><span>)</span> <span>{</span>
    <span>do_something</span><span>(</span><span>&amp;</span><span>mut</span> <span>data</span><span>);</span>
    <span>data</span><span>.postprocess</span><span>();</span>
    <span>print_the_data</span><span>(</span><span>&amp;</span><span>data</span><span>);</span>
<span>}</span>

<span>async</span> <span>fn</span> <span>my_async_main</span><span>()</span> <span>{</span>
    <span>// This doesn&#39;t work if `Foo` is `!Send`.</span>
    <span>let</span> <span>data</span> <span>=</span> <span>/* ... */</span><span>;</span>
    <span>unblock</span><span>(</span>
        <span>move</span> <span>||</span> <span>my_blocking_function</span><span>(</span><span>&amp;</span><span>mut</span> <span>data</span><span>.lock</span><span>()</span><span>.unwrap</span><span>())</span>
    <span>})</span><span>.await</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>However this requires me to re-architect parts of my code into these segments. It gets
difficult to interweave further <code>async</code> code into this sub-section as well. Yes,
I can call <code>async</code> functions from <a href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.block_on.html"><code>block_on</code></a>, but I’d really prefer to <code>.await</code> on it.</p>

<p>Say, doesn’t this seem very… <em>leaky</em>, to you?</p>

<h2 id="lets-fix-this">Let’s Fix This</h2>

<p>I don’t like to bring up a problem without also mentioning a possible solution.
I mentioned documentation above; it would be nice if there was some kind of
indicator that a function blocked.</p>

<div><div><pre><code><span>/// Does a thing.</span>
<span>/// </span>
<span>/// # Blocking</span>
<span>/// </span>
<span>/// This function will block the first time it is called, as it is reading from</span>
<span>/// `/dev/random` to seed the random number generator.</span>
<span>fn</span> <span>my_blocking_function</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Foo</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div></div>

<p>It would be a Herculean effort, and I don’t think it’s a sustainable approach.
If you’re writing a higher level library, it would be a lot to ask to check if
your dependency’s dependency’s dependency maybe reads from a socket.</p>

<p>From a language standpoint, it would be nice if there was some kind of <code>#[blocking]</code>
attribute to indicate that a function blocked, like so:</p>

<div><div><pre><code><span>#[blocking]</span>
<span>fn</span> <span>my_blocking_function</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Foo</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div></div>

<p>Maybe there could even be some kind of tree-traversal to see if you were calling a
<code>#[blocking]</code> function from <code>async</code> code, and then raise a warning. Unfortunately I’m
unsure if this would work either. There are function that might block once and never again,
or functions that only block under specific circumstances that the Rust compiler
can’t predict. Not to mention, it would be difficult to solve the problem of data
being processed in a tight loop.</p>

<p>So, I don’t know. There are some clever people on the language design team, so maybe
they have better ideas.</p>

<h2 id="parting-shots">Parting Shots</h2>

<p>Frankly, I don’t think <code>async</code> code is leaky at all, and the ways that it does leak
are largely due to library problems. Meanwhile blocking code leaks by its fundamental design.
I hope you found this helpful and that it might remove some reservations about using
<code>async</code> code in the future.</p>


  </div></div>
  </body>
</html>
