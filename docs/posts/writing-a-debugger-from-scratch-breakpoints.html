<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-5/">Original</a>
    <h1>Writing a debugger from scratch: Breakpoints</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>(New to this series? Consider starting from <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-1">part 1</a>)</p><p>At the end of the <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-4">last post</a>, we started to get some interesting functionality with the ability to resolve addresses to names in a module. This was the last functionality missing before we could implement breakpoints! This part adds the ability for DbgRs to set hardware breakpoints.</p><p>The code for this post is in the <a href="https://github.com/TimMisiak/dbgrs/tree/part5">part5 branch on github</a>. You can also view the <a href="https://github.com/TimMisiak/dbgrs/compare/part4...part5">changes from part4</a>. If you see any mistakes or ways to improve the code, feel free to <a href="https://github.com/TimMisiak/dbgrs/issues">create issues</a> on the GitHub repo or submit a PR.</p><p>I’ve been trying to keep DbgRs as simple as possible, avoiding extra architectural layers to keep the concepts as clear and concise as possible, but now that it has grown a bit, we need a little bit of cleanup to keep things easy to understand. I’ll just cover these changes briefly and then we’ll get to breakpoints.</p><p>The biggest change is that I moved all of the code dealing with <a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugeventex">WaitForDebugEventEx</a> into a new file, <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/event.rs">event.rs</a>. A single public function allows waiting for the next debug event, and returns a new <code>DebugEvent</code> enum instead of the raw win32 <code>DEBUG_EVENT</code> type.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>enum</span> <span>DebugEvent</span> {
</span></span><span><span>    Exception{first_chance: <span>bool</span>, exception_code: <span>i32</span>},
</span></span><span><span>    CreateProcess{exe_name: Option<span>&lt;</span>String<span>&gt;</span>, exe_base: <span>u64</span>},
</span></span><span><span>    CreateThread{thread_id: <span>u32</span>},
</span></span><span><span>    ExitThread{thread_id: <span>u32</span>},
</span></span><span><span>    LoadModule{module_name: Option<span>&lt;</span>String<span>&gt;</span>, module_base: <span>u64</span>},
</span></span><span><span>    OutputDebugString(String),
</span></span><span><span>    ExitProcess,
</span></span><span><span>    Other(String)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>EventContext</span> {
</span></span><span><span>    <span>pub</span> process_id: <span>u32</span>,
</span></span><span><span>    <span>pub</span> thread_id: <span>u32</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>wait_for_next_debug_event</span>(mem_source: <span>&amp;</span><span>dyn</span> MemorySource) -&gt; (EventContext, DebugEvent) {
</span></span><span><span>    <span>//...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>As a result, the <code>main_debugger_loop</code> function is a bit smaller and can focus on the core debugger loop logic.</p><p>The other change is that I’ve added a file called <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/util.rs">util.rs</a> which has some common helpers for win32 structures, including a thin <code>AutoClosedHandle</code> wrapper for <code>HANDLE</code> and the <code>AlignedContext</code> struct that wraps the win32 <code>CONTEXT</code>. Additionally, this includes some constants that are missing from the windows-rs crate.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[repr(align(16))]</span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>AlignedContext</span> {
</span></span><span><span>    <span>pub</span> context: <span>CONTEXT</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>AutoClosedHandle</span>(<span>pub</span> <span>HANDLE</span>);
</span></span></code></pre></div><p>When setting a breakpoint, it’s expected that you can use the name of a function, and not just the address. So to start, we need to add the capability for resolving a name to an address. Previously, we had the <code>resolve_address_to_name</code> function in <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/name_resolution.rs#L56">name_resolution.rs</a>, so we’ll add the corresponding <code>resolve_name_to_address</code> function there as well.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>fn</span> <span>resolve_name_to_address</span>(sym: <span>&amp;</span><span>str</span>, process: <span>&amp;</span><span>mut</span> Process) -&gt; Result<span>&lt;</span><span>u64</span>, String<span>&gt;</span> {
</span></span><span><span>    <span>match</span> sym.chars().position(<span>|</span>c<span>|</span> c <span>==</span> <span>&#39;!&#39;</span>) {
</span></span><span><span>        None <span>=&gt;</span> {
</span></span><span><span>            <span>// Search all modules
</span></span></span><span><span><span></span>            Err(<span>&#34;Not yet implemented&#34;</span>.to_string())
</span></span><span><span>        },
</span></span><span><span>        Some(pos) <span>=&gt;</span> {
</span></span><span><span>            <span>let</span> module_name <span>=</span> <span>&amp;</span>sym[<span>..</span>pos];
</span></span><span><span>            <span>let</span> func_name <span>=</span> <span>&amp;</span>sym[pos <span>+</span> <span>1</span><span>..</span>];
</span></span><span><span>            <span>if</span> <span>let</span> Some(module) <span>=</span> process.get_module_by_name_mut(module_name) {
</span></span><span><span>                <span>if</span> <span>let</span> Some(addr) <span>=</span> resolve_function_in_module(module, func_name) {
</span></span><span><span>                    Ok(addr)
</span></span><span><span>                } <span>else</span> {
</span></span><span><span>                    Err(format!(<span>&#34;Could not find </span><span>{}</span><span> in module </span><span>{}</span><span>&#34;</span>, func_name, module_name))
</span></span><span><span>                }
</span></span><span><span>            } <span>else</span> {
</span></span><span><span>                Err(format!(<span>&#34;Could not find module </span><span>{}</span><span>&#34;</span>, module_name))
</span></span><span><span>            }
</span></span><span><span>        },
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>For now, we’ll take only the fully qualified name in <code>module.dll!functionName</code> <a aria-describedby="footnote-label" href="#fully-qualified">form</a>, and allow only exact matches.</p><p>Using this function, we can add symbols to our evaluation grammar in <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/command.rs#L26">command.rs</a></p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>#[rust_sitter::language]</span>
</span></span><span><span>    <span>pub</span> <span>enum</span> <span>EvalExpr</span> {
</span></span><span><span>        Number(<span>#[rust_sitter::leaf(pattern = r</span><span>&#34;(\d+|0x[0-9a-fA-F]+)&#34;</span><span>, transform = parse_int)]</span> <span>u64</span>),
</span></span><span><span>        Symbol(<span>#[rust_sitter::leaf(pattern = r</span><span>&#34;(([a-zA-Z0-9_@#.]+!)?[a-zA-Z0-9_@#.]+)&#34;</span><span>, transform = parse_sym)]</span> String),
</span></span></code></pre></div><p>In order to evaluate symbols, the <code>evaluate_expression</code> function now needs a context that it can use to evaluate symbols against. For this, we’ll just pass in a structure with a reference to the <code>Process</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>struct</span> <span>EvalContext</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> {
</span></span><span><span>    <span>pub</span> process: <span>&amp;</span><span>&#39;a</span> <span>mut</span> Process,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>evaluate_expression</span>(expr: <span>EvalExpr</span>, context: <span>&amp;</span><span>mut</span> EvalContext) -&gt; Result<span>&lt;</span><span>u64</span>, String<span>&gt;</span> {
</span></span></code></pre></div><p>Note that it also returns a <code>Result</code> now because the name resolution can fail. Most of the function is unchanged besides passing the context through, and it now handles <code>EvalExpr::Symbol</code> by passing it to <code>name_resolution::resolve_to_address</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>match</span> expr {
</span></span><span><span>        EvalExpr::Number(x) <span>=&gt;</span> Ok(x),
</span></span><span><span>        EvalExpr::Add(x, _, y) <span>=&gt;</span> Ok(evaluate_expression(<span>*</span>x, context)<span>?</span> <span>+</span> evaluate_expression(<span>*</span>y, context)<span>?</span>),
</span></span><span><span>        EvalExpr::Symbol(sym) <span>=&gt;</span> {
</span></span><span><span>            resolve_name_to_address(<span>&amp;</span>sym, context.process)
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>We can verify this is working by simply evaluating a symbol to an address and making sure it resolves back to the same symbol.</p><pre tabindex="0"><code>&gt; ? ntdll.dll!NtMapViewOfSection+0x14
 = 0x7FFE7360F154
[11254] ntdll.dll!NtMapViewOfSection+0x14
&gt; ln 0x7FFE7360F154
ntdll.dll!NtMapViewOfSection+0x14
[11254] ntdll.dll!NtMapViewOfSection+0x14
</code></pre><p>Success!</p><p>With the new functionality in the expression evaluator to evaluate symbols, we can add the commands for setting, clearing, and listing breakpoints. First, we add the breakpoint commands to the command grammar in <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/command.rs#L15">command.rs</a></p><div><pre tabindex="0"><code data-lang="rust"><span><span>        SetBreakpoint(<span>#[rust_sitter::leaf(text = </span><span>&#34;bp&#34;</span><span>)]</span> (), Box<span>&lt;</span>EvalExpr<span>&gt;</span>),
</span></span><span><span>        ListBreakpoints(<span>#[rust_sitter::leaf(text = </span><span>&#34;bl&#34;</span><span>)]</span> ()),
</span></span><span><span>        ClearBreakpoint(<span>#[rust_sitter::leaf(text = </span><span>&#34;bc&#34;</span><span>)]</span> (), Box<span>&lt;</span>EvalExpr<span>&gt;</span>),
</span></span></code></pre></div><p>The implementation of these commands need something to talk to, so we’ll create a new structure called BreakpointManager that keeps track of the breakpoints that should be set in the process, and create this at the start of the <a href="https://github.com/TimMisiak/dbgrs/blob/part5/src/main.rs#L81">main_debugger_loop</a></p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main_debugger_loop</span>(process: <span>HANDLE</span>) {
</span></span><span><span>    <span>let</span> <span>mut</span> breakpoints <span>=</span> BreakpointManager::new();
</span></span></code></pre></div><p>We’ll get to the implementation of <code>BreakpointManager</code> in a minute, but first we can just see the simple implementation of <code>bp</code>, <code>bl</code>, and <code>bc</code> calling into the breakpoint manager.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>let</span> cmd <span>=</span> command::read_command();
</span></span><span><span>    <span>//...
</span></span></span><span><span><span></span>    <span>match</span> cmd {
</span></span><span><span>        <span>//...
</span></span></span><span><span><span></span>        CommandExpr::SetBreakpoint(_, expr) <span>=&gt;</span> {
</span></span><span><span>            <span>if</span> <span>let</span> Some(addr) <span>=</span> eval_expr(expr) {
</span></span><span><span>                breakpoints.add_breakpoint(addr);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        CommandExpr::ListBreakpoints(_) <span>=&gt;</span> {
</span></span><span><span>            breakpoints.list_breakpoints(<span>&amp;</span><span>mut</span> process);
</span></span><span><span>        }
</span></span><span><span>        CommandExpr::ClearBreakpoint(_, expr) <span>=&gt;</span> {
</span></span><span><span>            <span>if</span> <span>let</span> Some(id) <span>=</span> eval_expr(expr) {
</span></span><span><span>                breakpoints.clear_breakpoint(id <span>as</span> <span>u32</span>);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span></code></pre></div><p>The <code>BreakpointManager</code> contains the list of the breakpoints that have been requested by the user. It has functions for adding a breakpoint at a specified address, removing a breakpoint given its ID, and listing the breakpoints for the user.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Breakpoint</span> {
</span></span><span><span>    addr: <span>u64</span>,
</span></span><span><span>    id: <span>u32</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>BreakpointManager</span> {
</span></span><span><span>    breakpoints: Vec::<span>&lt;</span>Breakpoint<span>&gt;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>impl</span> BreakpointManager {
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> <span>add_breakpoint</span>(<span>&amp;</span><span>mut</span> self, addr: <span>u64</span>) {
</span></span><span><span>        self.breakpoints.push(Breakpoint{addr, id: <span>self</span>.get_free_id()});
</span></span><span><span>        self.breakpoints.sort_by(<span>|</span>a, b<span>|</span> a.id.cmp(<span>&amp;</span>b.id));
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> <span>list_breakpoints</span>(<span>&amp;</span>self, process: <span>&amp;</span><span>mut</span> Process) {
</span></span><span><span>        <span>for</span> bp <span>in</span> self.breakpoints.iter() {
</span></span><span><span>            <span>if</span> <span>let</span> Some(sym) <span>=</span> name_resolution::resolve_address_to_name(bp.addr, process) {
</span></span><span><span>                println!(<span>&#34;</span><span>{:3}</span><span> </span><span>{:#018x}</span><span> (</span><span>{}</span><span>)&#34;</span>, bp.id, bp.addr, sym)
</span></span><span><span>            } <span>else</span> {
</span></span><span><span>                println!(<span>&#34;</span><span>{:3}</span><span> </span><span>{:#018x}</span><span>&#34;</span>, bp.id, bp.addr)
</span></span><span><span>            }            
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> <span>clear_breakpoint</span>(<span>&amp;</span><span>mut</span> self, id: <span>u32</span>) {
</span></span><span><span>        self.breakpoints.retain(<span>|</span>x<span>|</span> x.id <span>!=</span> id)
</span></span><span><span>    }
</span></span></code></pre></div><p>We can test these commands to make sure breakpoints are tracked correctly, although we still need to apply the breakpoints to the target process before they’ll do anything.</p><pre tabindex="0"><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
LoadDll: 7FF7E7420000   hello.exe
[5A70] 0x00007ffdaed4aa40
&gt; g
LoadDll: 7FFDAECF0000   ntdll.dll
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bp ntdll.dll!RtlUserThreadStart
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bl
  0 0x00007ffdaed4aa40 (ntdll.dll!RtlUserThreadStart)
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bc 0
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bl
[5A70] ntdll.dll!RtlUserThreadStart
&gt; 
</code></pre><p>Finally, we can get to the fun part where we apply the breakpoints to a process. There are two types of breakpoints, software breakpoints and hardware breakpoints. Of the two, hardware breakpoints are less complicated, so we’ll start with those. On x86 processors the hardware breakpoints are controlled via the <a href="https://wiki.osdev.org/CPU_Registers_x86-64#Debug_Registers">“Debug Registers”</a>. There are four hardware breakpoints available on current CPUs. Debug registers DR0 through DR3 are used to specify the address of the breakpoint. Register DR6 is a status register to determine when a breakpoint is hit. And DR7 is a control register to specify the attributes of each hardware breakpoint. Note that there are a number of fields packed together in DR7, so we’ll use a little helper to set these fields.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// Helper function to set a value at a specific bit offset.
</span></span></span><span><span><span></span><span>fn</span> <span>set_bits</span><span>&lt;</span>T: <span>PrimInt</span><span>&gt;</span>(val: <span>&amp;</span><span>mut</span> T, set_val: <span>T</span>, start_bit: <span>usize</span>, bit_count: <span>usize</span>) {
</span></span><span><span>    <span>// First, mask out the relevant bits
</span></span></span><span><span><span></span>    <span>let</span> max_bits <span>=</span> std::mem::size_of::<span>&lt;</span>T<span>&gt;</span>() <span>*</span> <span>8</span>;
</span></span><span><span>    <span>let</span> mask: <span>T</span> <span>=</span> T::max_value() <span>&lt;&lt;</span> (max_bits <span>-</span> bit_count);
</span></span><span><span>    <span>let</span> mask: <span>T</span> <span>=</span> mask <span>&gt;&gt;</span> (max_bits <span>-</span> <span>1</span> <span>-</span> start_bit);
</span></span><span><span>    <span>let</span> inv_mask <span>=</span> <span>!</span>mask;
</span></span><span><span>
</span></span><span><span>    <span>*</span>val <span>=</span> <span>*</span>val <span>&amp;</span> inv_mask;
</span></span><span><span>    <span>*</span>val <span>=</span> <span>*</span>val <span>|</span> (set_val <span>&lt;&lt;</span> (start_bit <span>+</span> <span>1</span> <span>-</span> bit_count));
</span></span><span><span>}
</span></span></code></pre></div><p>To manipulate these registers, we’ll use the <code>GetThreadContext</code>/<code>SetThreadContext</code> functions to set the registers to the state needed for the requested breakpoints. Note that the debug registers are maintained for each thread separately, so we could theoretically set different breakpoints for each thread, or filter a breakpoint to a specific thread. That functionality won’t be implemented in DbgRs for now, and we’ll just apply the same breakpoints to all threads. To start, we’ll loop over all of the threads in the process and retrieve each thread’s context:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>pub</span> <span>fn</span> <span>apply_breakpoints</span>(<span>&amp;</span><span>mut</span> self, process: <span>&amp;</span><span>mut</span> Process, resume_thread_id: <span>u32</span>, _memory_source: <span>&amp;</span><span>dyn</span> MemorySource) {
</span></span><span><span>
</span></span><span><span>        <span>for</span> thread_id <span>in</span> process.iterate_threads() {
</span></span><span><span>            <span>let</span> <span>mut</span> ctx: <span>AlignedContext</span> <span>=</span> <span>unsafe</span> { std::mem::zeroed() };
</span></span><span><span>            ctx.context.ContextFlags <span>=</span> <span>CONTEXT_ALL</span>;            
</span></span><span><span>            <span>let</span> thread <span>=</span> AutoClosedHandle(<span>unsafe</span> {
</span></span><span><span>                OpenThread(
</span></span><span><span>                    <span>THREAD_GET_CONTEXT</span> <span>|</span> <span>THREAD_SET_CONTEXT</span>,
</span></span><span><span>                    <span>FALSE</span>,
</span></span><span><span>                    <span>*</span>thread_id,
</span></span><span><span>                )
</span></span><span><span>            });
</span></span><span><span>            <span>let</span> ret <span>=</span> <span>unsafe</span> { GetThreadContext(thread.handle(), <span>&amp;</span><span>mut</span> ctx.context) };
</span></span></code></pre></div><p>We’ll then loop over the requested breakpoints. We need to set four pieces of information for each one. The three fields to set are the LEN (length), RW (access type), and LE (local enable) configuration for each breakpoint. We’ll set the <a aria-describedby="footnote-label" href="#execute-len">LEN to 0</a>, which indicates 1 byte. We’ll set RW to 0, which means “break on instruction execution” (we would use a value of 1 indicate break on read or a value of 3 to indicate break on read or write). Finally, we’ll set the “local enable” bit to 1 indicating that the breakpoint should be enabled.</p><p><img src="https://www.timdbg.com/dr7.png" alt="DR7 layout"/></p><div><pre tabindex="0"><code data-lang="rust"><span><span>
</span></span><span><span>    <span>for</span> idx <span>in</span> <span>0</span><span>..</span><span>4</span> {
</span></span><span><span>        <span>if</span> self.breakpoints.len() <span>&gt;</span> idx {
</span></span><span><span>            
</span></span><span><span>            <span>// The DR7_* variables are a set of constants with the correct offsets and sizes for each
</span></span></span><span><span><span></span>            <span>// field of DR7.
</span></span></span><span><span><span></span>            set_bits(<span>&amp;</span><span>mut</span> ctx.context.Dr7, <span>0</span>, <span>DR7_LEN_BIT</span>[idx], <span>DR7_LEN_SIZE</span>);
</span></span><span><span>            set_bits(<span>&amp;</span><span>mut</span> ctx.context.Dr7, <span>0</span>, <span>DR7_RW_BIT</span>[idx], <span>DR7_RW_SIZE</span>);
</span></span><span><span>            set_bits(<span>&amp;</span><span>mut</span> ctx.context.Dr7, <span>1</span>, <span>DR7_LE_BIT</span>[idx], <span>1</span>);
</span></span></code></pre></div><p>The appropriate DR0-DR3 value will be set to the address of the resolved breakpoint.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>
</span></span><span><span>            <span>match</span> idx {
</span></span><span><span>                <span>0</span> <span>=&gt;</span> ctx.context.Dr0 <span>=</span> self.breakpoints[idx].addr,
</span></span><span><span>                <span>1</span> <span>=&gt;</span> ctx.context.Dr1 <span>=</span> self.breakpoints[idx].addr,
</span></span><span><span>                <span>2</span> <span>=&gt;</span> ctx.context.Dr2 <span>=</span> self.breakpoints[idx].addr,
</span></span><span><span>                <span>3</span> <span>=&gt;</span> ctx.context.Dr3 <span>=</span> self.breakpoints[idx].addr,
</span></span><span><span>                _ <span>=&gt;</span> (),
</span></span><span><span>            }
</span></span></code></pre></div><p>Finally, we’ll make sure to disable any breakpoints that we are not using. Note that the code assumes that the debugger “owns” the debug registers and that the target process is not using them in any way. This is typically true, but there are cases where the target process will be using the debug registers for its own purpose, or are manipulated as an anti-debugging technique. To keep things simple, we won’t worry about that and just clear the local enable (LE) bit.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>        } <span>else</span> {
</span></span><span><span>            <span>// Disable any breakpoints that we aren&#39;t using.
</span></span></span><span><span><span></span>            set_bits(<span>&amp;</span><span>mut</span> ctx.context.Dr7, <span>0</span>, <span>DR7_LE_BIT</span>[idx], <span>1</span>);
</span></span><span><span>            <span>break</span>;
</span></span><span><span>        }    
</span></span><span><span>    }
</span></span></code></pre></div><p>This new function, <code>apply_breakpoints</code>, will be called from the <code>main_debugger_loop</code> right before we call <code>ContinueDebugEvent</code>. That will ensure that we set up all thread contexts with the correct breakpoint state. Note that because Windows sends a debug event for thread creation, we’ll have an opportunity to set the breakpoint state for all new threads that are created.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    breakpoints.apply_breakpoints(<span>&amp;</span><span>mut</span> process, event_context.thread_id, mem_source.as_ref());
</span></span><span><span>    
</span></span><span><span>    <span>unsafe</span> {
</span></span><span><span>        ContinueDebugEvent(
</span></span><span><span>            event_context.process_id,
</span></span><span><span>            event_context.thread_id,
</span></span><span><span>            continue_status,
</span></span><span><span>        );
</span></span><span><span>    }
</span></span></code></pre></div><p>When the CPU tries to execute an instruction that is marked with a debug register, it generates a debug exception (#DB) as a <a href="https://wiki.osdev.org/Exceptions">fault</a> (It’s important to note this is a fault, and not a trap. More on that later). Windows delivers this to a debugger as an exception event with exception code 0x80000004. The thread context will also have a flag set in DR6 indicating which breakpoint was hit. We’ll add some code in the exception event handler letting the breakpoint manager check if a breakpoint was hit.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>        <span>match</span> debug_event {
</span></span><span><span>            DebugEvent::Exception { first_chance, exception_code } <span>=&gt;</span> {
</span></span><span><span>                <span>//...
</span></span></span><span><span><span></span>                <span>if</span> <span>let</span> Some(bp_index) <span>=</span> breakpoints.was_breakpoint_hit(<span>&amp;</span>ctx.context) {
</span></span><span><span>                    println!(<span>&#34;Breakpoint </span><span>{}</span><span> hit&#34;</span>, bp_index);
</span></span><span><span>                    <span>// It&#39;s important to use DBG_CONTINUE with ContinueDebugEvent or else the breakpoint will be treated
</span></span></span><span><span><span></span>                    <span>// as an exception to be handled by the target process.
</span></span></span><span><span><span></span>                    continue_status <span>=</span> <span>DBG_CONTINUE</span>;
</span></span><span><span>                }
</span></span><span><span>                <span>//...
</span></span></span></code></pre></div><p>The breakpoint manager will just check DR6 to see if any of the bits were set that correspond to a hardware breakpoint triggering.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>pub</span> <span>fn</span> <span>was_breakpoint_hit</span>(<span>&amp;</span>self, thread_context: <span>&amp;</span><span>CONTEXT</span>) -&gt; Option<span>&lt;</span><span>u32</span><span>&gt;</span> {
</span></span><span><span>        <span>for</span> idx <span>in</span> <span>0</span><span>..</span>self.breakpoints.len() {
</span></span><span><span>            <span>if</span> get_bit(thread_context.Dr6, <span>DR6_B_BIT</span>[idx]) {
</span></span><span><span>                <span>return</span> Some(idx <span>as</span> <span>u32</span>);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        None
</span></span><span><span>    }
</span></span></code></pre></div><p>Remember how I mentioned that hardware breakpoints trigger debug exceptions as a <a aria-describedby="footnote-label" href="#debug-fault">fault</a>? That’s important because a “fault” exception triggers <em>before</em> the instruction has a chance to execute. That lets us examine state before the instruction executes, which is what we want for a debugger. But since it is a fault, resuming the execution of the program just causes the program to break in again! On some architectures, this might be complicated to get past, but on x86 we simply have to set the “resume flag”, which is one of the bits in the EFlags registers that often gets overlooked. The resume flag causes the processor to ignore instruction breakpoints for a single instruction execution. It is set back to 0 right after the debug registers would have been checked, which makes it a convenient tool for resuming execution. We’ll set this flag on whatever thread caused the debugger to break in, regardless of whether the breakpoint has hit or not. (Some debuggers will only set RF when a breakpoint was hit). We’ll set the resume flag inside the <code>apply_breakpoints</code> function, since it’s already manipulating the register contexts of all threads.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>if</span> <span>*</span>thread_id <span>==</span> resume_thread_id {
</span></span><span><span>        set_bits(<span>&amp;</span><span>mut</span> ctx.context.EFlags, <span>1</span>, <span>EFLAG_RF</span>, <span>1</span>);
</span></span><span><span>    }
</span></span></code></pre></div><h2 id="testing-it-out">Testing it out</h2><p>Now that we can set a breakpoint, apply a breakpoint, and handle a breakpoint exception, we’re ready to test out the new breakpoint functionality. To do that, we’ll just continue execution until kernelbase is loaded, and then set a breakpoint on kernelbase!GetLastError, which is a very frequently used function that should get called almost immediately.</p><pre tabindex="0"><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
LoadDll: 7FF7E7420000   hello.exe
[5CF8] 0x00007ffdaed4aa40
&gt; g
LoadDll: 7FFDAECF0000   ntdll.dll
[5CF8] ntdll.dll!RtlUserThreadStart
&gt; g
LoadDll: 7FFDAD6E0000   C:\Windows\System32\KERNEL32.DLL
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
LoadDll: 7FFDAC0A0000   C:\Windows\System32\KERNELBASE.dll
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; bp kernelbase.dll!GetLastError
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
Breakpoint 0 hit
[5CF8] C:\Windows\System32\KERNELBASE.dll!GetLastError
&gt; 
</code></pre><p>It works! It’s almost starting to feel like a real debugger. A few very important things are left though. To start with, we can’t see the functions that are on the call stack. Viewing the stack is probably the single most important analysis feature of a debugger. So that’s likely where we’re going next.</p><p>I hope you found this post interesting and informative! Have a question or suggestion? Let me know! You can find me on <a href="https://twitter.com/timmisiak">Twitter</a>, <a href="https://dbg.social/@tim">Mastodon</a>, and <a href="https://bsky.app/profile/timdbg.com">Bluesky</a>.</p></div></article></div></div>
  </body>
</html>
