<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cj.rs//blog/git-ls-files-is-faster-than-fd-and-find/">Original</a>
    
    <div id="readability-page-1" class="page"><div><h2 id="tldr">TLDR</h2>
<p>In the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/">Linux Git repository</a>:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>hyperfine</span> <span>--export-markdown</span> /tmp/tldr.md <span>--warmup</span> <span>10</span> <span>&#39;git ls-files&#39;</span> <span>&#39;find&#39;</span> <span>&#39;fd --no-ignore&#39;</span>
</code></pre></div><table>
<thead>
<tr>
<th>Command</th>
<th>Mean [ms]</th>
<th>Min [ms]</th>
<th>Max [ms]</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>16.9 ± 0.5</td>
<td>16.3</td>
<td>18.2</td>
<td>1.00</td>
</tr>
<tr>
<td><code>find</code></td>
<td>93.1 ± 0.7</td>
<td>92.4</td>
<td>95.7</td>
<td>5.52 ± 0.16</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>85.8 ± 7.5</td>
<td>81.1</td>
<td>111.3</td>
<td>5.08 ± 0.47</td>
</tr>
</tbody>
</table>
<p><code>git ls-files</code> is more than <em>5 times faster</em> than both <code>fd --no-ignore</code> and <code>find</code>!</p>
<h2 id="introduction">Introduction</h2>
<p>In my <a href="https://cj.rs/blog/my-setup/nvim-0-5/">editor</a> I changed my mapping to open files from <code>fd</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> to <code>git ls-files</code><sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> and I noticed it felt faster after the change. But that’s intriguing, given <code>fd</code>’s goal to be <a href="https://github.com/sharkdp/fd#benchmark">very fast</a>. Git on the other hand is primarily a source code management system (SCM), it’s main business<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> is not to help you list your files! Let’s run some benchmarks to make sure.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>Is <code>git ls-files</code> actually faster than <code>fd</code> or is that just an illusion? In our benchmark, we will use:</p>
<ul>
<li><code>fd</code> 8.2.1</li>
<li><code>git</code> 2.33.0</li>
<li><code>find</code> 4.8.0</li>
<li><code>hyperfine</code> 1.11.0</li>
</ul>
<p>We run the benchmarks with disk-cache filled, we are not measuring the cold cache case. That’s because in your editor, you may use the commands mentioned multiple times and would benefit from cache. The results are similar for an in memory repo, which confirms cache filling.</p>
<p>Also, you work on those files, so they should be in cache to a degree. We also make sure to be on a quiet PC, with CPU power-saving deactivated. Furthermore, the CPU has 8 cores with hyper-threading, so <code>fd</code> uses 8 threads. Last but not least, unless otherwise noted, the files in the repo are only the ones committed, for instance, no build artefacts are present.</p>
<h3 id="a-test-git-repository">A Test Git Repository</h3>
<p>We first need a Git repository. I’ve chosen to clone<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/">linux kernel repo</a> because it is a fairly big one and a <a href="https://github.blog/2020-12-22-git-clone-a-data-driven-study-on-cloning-behaviors/">reference</a> for Git performance measurements. This is important to ensure searches take a non-trivial amount of time: as hyperfine rightfully points out, short run times (less than 5 ms) are more difficult to accurately compare.</p>
<div><pre tabindex="0"><code data-lang="fish"><span>git</span> clone <span>--depth</span> <span>1</span> <span>--recursive</span> ssh://<a href="https://cj.rs/cdn-cgi/l/email-protection" data-cfemail="f89f918cb89f918c908d9ad69b9795">[email protected]</a>/torvalds/linux.git ~/ghq/github.com/torvalds/linux
<span>cd</span> ~/ghq/github.com/torvalds/linux
</code></pre></div><h4 id="choosing-the-commands">Choosing the commands</h4>
<p>We want to evaluate <code>git ls-files</code> versus <code>fd</code> and <code>find</code>. However, getting exactly the same list of file is not a trivial task:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Output lines</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>72219</td>
</tr>
<tr>
<td><code>find</code></td>
<td>77039</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>76705</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden</code></td>
<td>77038</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>72363</td>
</tr>
</tbody>
</table>
<p>After some more tries, it turns out that this command gives exactly<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> the same output as <code>git ls-files</code>:</p>
<pre><code>fd --no-ignore --hidden --exclude .git --type file --type symlink
</code></pre><p>It is a fairly complicated command, with various criteria on the files to print and that could translate to an unfair advantage to <code>git ls-files</code>. Consequently, we will also use the simpler examples in the table above.</p>
<h3 id="hyperfine">Hyperfine</h3>
<p><a href="https://github.com/sharkdp/hyperfine">Hyperfine</a> is a great tool to compare various commands: it has a colored and markdown output, attempts to detect outliers, tunes the number of run… Here is an <a href="https://asciinema.org/">asciinema</a><sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> showing its output<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>:</p>
<asciinema-player src="./hyperfine.cast" cols="103" rows="32" preload="1" loop="true" speed="4"></asciinema-player>



<h3 id="first-results">First Results</h3>
<p>For our first benchmark, on an SSD with <a href="https://en.wikipedia.org/wiki/Btrfs">btrfs</a>, with commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ad347abe4a9876b1f65f408ab467137e88f77eb4"><code>ad347abe4a…</code></a> checked out, we run:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>hyperfine</span> <span>--export-markdown</span> /tmp/<span>1</span>.md <span>--warmup</span> <span>10</span> <span>&#39;git ls-files&#39;</span> <span>\
</span><span></span>    <span>&#39;find&#39;</span> <span>&#39;fd --no-ignore&#39;</span> <span>&#39;fd --no-ignore --hidden&#39;</span> <span>&#39;fd&#39;</span> <span>\
</span><span></span>    <span>&#39;fd --no-ignore --hidden --exclude .git --type file --type symlink&#39;</span>
</code></pre></div><p>This yields the following results:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Mean [ms]</th>
<th>Min [ms]</th>
<th>Max [ms]</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>16.9 ± 0.6</td>
<td>16.3</td>
<td>19.2</td>
<td>1.00</td>
</tr>
<tr>
<td><code>find</code></td>
<td>93.2 ± 0.5</td>
<td>92.5</td>
<td>94.8</td>
<td>5.50 ± 0.19</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>86.6 ± 7.8</td>
<td>80.5</td>
<td>115.7</td>
<td>5.11 ± 0.49</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden</code></td>
<td>121.0 ± 6.2</td>
<td>112.3</td>
<td>132.3</td>
<td>7.14 ± 0.44</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>231.6 ± 22.3</td>
<td>200.8</td>
<td>272.5</td>
<td>13.68 ± 1.40</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code></td>
<td>80.9 ± 5.0</td>
<td>77.5</td>
<td>95.3</td>
<td>4.78 ± 0.34</td>
</tr>
</tbody>
</table>
<p>As mentioned in the TL;DR, <code>git ls-files</code> is at least 5 times faster than its closest competitor! Let’s find out why that is.</p>
<h2 id="how-does-git-store-files-in-a-repository">How Does Git Store Files in a Repository</h2>
<p>To try to understand where this performance advantage of <code>git ls-files</code> comes from, let’s look into how files are stored in a repository. This is a quick overview, you can find more details about Git’s storage internals in <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">this section of the Pro Git book</a>.</p>
<h3 id="git-objects">Git Objects</h3>
<p>Git builds its own internal representation of the file system tree in the repository:</p>
<figure>
<img loading="lazy" src="https://cj.rs//blog/git-ls-files-is-faster-than-fd-and-find/data-model-2.png" alt="From the Pro Git book, written by Scott Chacon and Ben Straub and published by Apress, licensed under the Creative Commons Attribution Non Commercial Share Alike 3.0 license, copyright 2021."/> <figcaption>
Internal Git representation of the filesystem tree<p>From the Pro Git book, written by Scott Chacon and Ben Straub and published by Apress, licensed under the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution Non Commercial Share Alike 3.0</a> license, copyright 2021.</p>
</figcaption>
</figure>
<p>In the figure above, each tree object contains a list of folder or names and references to these (among other things). This representation is then stored by its hash in the <code>.git</code> folder, like so:</p>
<pre><code>.git/objects
├── 65
│  └── 107a3367b67e7a50788f575f73f70a1e61c1df
├── e6
│  └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
├── f0
│  └── f1a67ce36d6d87e09ea711c62e88b135b60411
├── info
└── pack
</code></pre><p>As a result, to list the content of a folder, it seems Git has to access the corresponding tree object, stored in a file contained in a folder with the beginning of the hash. But doing that for the currently checked out files all the time would be slow, especially for frequently used commands like <code>git status</code>. Fortunately, git also maintains an <em>index</em> for files in the current working directory.</p>
<h3 id="git-index">Git Index</h3>
<p>This <a href="https://git-scm.com/docs/index-format">index</a>, lists (among other things) each file in the repository with file-system metadata like last modification time. More details and examples are provided <a href="https://medium.com/hackernoon/understanding-git-index-4821a0765cf">here</a>.</p>
<p>So, it seems that the index has everything <code>ls-files</code> requires. Let’s check it is used by <code>ls-files</code></p>
<h2 id="strace">Strace</h2>
<p>Let’s ensure that <code>ls-files</code> uses only the index, without scanning many files in the repo or the <code>.git</code> folder. That would explain its performance advantage, as reading a file is cheaper than traversing many folders. To this end, we’ll use <code>strace</code><sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> like so:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>strace</span> <span>-e</span> !write git ls<span>-files</span><span>&gt;</span>/dev/null <span>2</span><span>&gt;</span>/tmp/a
</code></pre></div><p>It turns out the <a href="https://git-scm.com/docs/index-format"><code>.git/index</code></a> is read:</p>
<pre><code>openat(AT_FDCWD, &#34;.git/index&#34;, O_RDONLY) = 3
</code></pre><p>And we are not reading objects in the <code>.git</code> folder or files in the repository. A quick check of Git’s source code <a href="https://github.com/git/git/blob/33be431c0c7284c1adf0fe49f7838dbc8aee6ea9/builtin/ls-files.c#L761">confirms</a> this. We now have an explanation for the speed <code>git ls-files</code> displays in our benchmarks!</p>
<h2 id="other-scenarios">Other Scenarios</h2>
<p>However, listing file in a fully committed repository is not the most common case when you work on your code: as you make changes, a larger portion of the files are changed or added. How does <code>git ls-files</code> compare in these other scenarios?</p>
<h3 id="with-changes">With Changes</h3>
<p>When there are changes to some files, we shouldn’t see any significant performance difference: the index is still usable directly to get the names of the files in the repository, we don’t really care about whether their content changed.</p>
<p>To check this, let’s change all the C files in the kernel sources (using some <a href="https://fishshell.com/">fish</a> shell scripting):</p>
<div><pre tabindex="0"><code data-lang="fish"><span>for</span> <span>f</span> <span>in</span> <span>(</span><span>fd</span> <span>-e</span> c<span>)</span>
  <span>echo</span> <span>1</span> <span>&gt;&gt;</span> <span>$f</span>
<span>end</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="fish"><span>hyperfine</span> <span>--export-markdown</span> /tmp/<span>2</span>.md <span>--warmup</span> <span>10</span> <span>&#39;git ls-files&#39;</span> <span>&#39;find&#39;</span> <span>&#39;fd --no-ignore&#39;</span> <span>\
</span><span></span>  <span>&#39;fd --no-ignore --hidden --exclude .git --type file --type symlink&#39;</span>
</code></pre></div><table>
<thead>
<tr>
<th>Command</th>
<th>Mean [ms]</th>
<th>Min [ms]</th>
<th>Max [ms]</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>16.8 ± 0.5</td>
<td>16.3</td>
<td>18.9</td>
<td>1.00</td>
</tr>
<tr>
<td><code>find</code></td>
<td>93.5 ± 0.7</td>
<td>92.7</td>
<td>95.5</td>
<td>5.55 ± 0.17</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>86.1 ± 7.3</td>
<td>80.9</td>
<td>112.6</td>
<td>5.12 ± 0.46</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code></td>
<td>80.8 ± 6.6</td>
<td>77.8</td>
<td>115.0</td>
<td>4.80 ± 0.42</td>
</tr>
</tbody>
</table>
<p>We see the same numbers as before and it is again consistent with <a href="https://github.com/git/git/blob/33be431c0c7284c1adf0fe49f7838dbc8aee6ea9/builtin/ls-files.c#L761">ls-files source code</a>.</p>
<p>Run <code>git checkout -f @</code> after this to remove the changes made to the files.</p>
<h3 id="with-new-files-and--o">With New Files and <code>-o</code></h3>
<p>With yet uncommitted files, there are two sub-cases:</p>
<ul>
<li>either files were created and added (with <code>git add</code>): then the files are in index and reading the index is enough for <code>ls-files</code>, like above,</li>
<li>files were created but not added: these files are not present in the index, but without the <code>-o</code> flag, <code>ls-files</code> won’t output them either, so it can still use the index, as before.</li>
</ul>
<p>So the only case that needs further investigations is the use of <code>-o</code>. Since we don’t have baseline results yet for <code>-o</code>, let’s first see how it compares without any unadded new files.</p>
<h4 id="without-any-unadded-new-files-baseline">Without any Unadded New Files (Baseline)</h4>
<p>When we haven’t added any new files in the repository:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>hyperfine</span> <span>--export-markdown</span> /tmp/<span>3</span>.md <span>--warmup</span> <span>10</span> <span>&#39;git ls-files&#39;</span> <span>&#39;git ls-files -o&#39;</span> <span>&#39;find&#39;</span> <span>\
</span><span></span>  <span>&#39;fd --no-ignore&#39;</span> <span>&#39;fd --no-ignore --hidden --exclude .git --type file --type symlink&#39;</span>
</code></pre></div><table>
<thead>
<tr>
<th>Command</th>
<th>Mean [ms]</th>
<th>Min [ms]</th>
<th>Max [ms]</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>16.7 ± 0.5</td>
<td>16.1</td>
<td>17.9</td>
<td>1.00</td>
</tr>
<tr>
<td><code>git ls-files -o</code></td>
<td>69.1 ± 0.7</td>
<td>67.8</td>
<td>70.8</td>
<td>4.12 ± 0.12</td>
</tr>
<tr>
<td><code>find</code></td>
<td>94.3 ± 0.5</td>
<td>93.4</td>
<td>95.3</td>
<td>5.63 ± 0.16</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>86.6 ± 7.0</td>
<td>80.8</td>
<td>106.0</td>
<td>5.17 ± 0.44</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code></td>
<td>80.8 ± 7.4</td>
<td>77.9</td>
<td>118.0</td>
<td>4.82 ± 0.46</td>
</tr>
</tbody>
</table>
<p>That suggests that <code>git ls-files -o</code> is performing some more work besides “just” reading the index. With <code>strace</code>, we see lines like:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>strace</span> <span>-e</span> !write git ls<span>-files</span> <span>-o</span><span>&gt;</span>/dev/null <span>2</span><span>&gt;</span>/tmp/a
…
<span>openat</span><span>(</span><span>AT_FDCWD</span>, <span>&#34;Documentation/&#34;</span>, O_RDONLY<span>|</span><span>O_NONBLOCK</span><span>|</span><span>O_CLOEXEC</span><span>|</span><span>O_DIRECTORY</span><span>)</span> <span>=</span> <span>4</span>
<span>newfstatat</span><span>(</span><span>4</span>, <span>&#34;&#34;</span>, <span>{</span><span>st_mode</span><span>=</span>S_IFDIR<span>|</span><span>0755</span>, <span>st_size</span><span>=</span><span>1446</span>, ...<span>}</span>, AT_EMPTY_PATH<span>)</span> <span>=</span> <span>0</span>
<span>getdents64</span><span>(</span><span>4</span>, 0x55df0a6e6890 /* <span>99</span> entries */, <span>32768</span><span>)</span> <span>=</span> <span>3032</span>
…
</code></pre></div><h4 id="with-unadded-new-files">With Unadded New Files</h4>
<p>Let’s add some files now:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>for</span> <span>f</span> <span>in</span> <span>(</span><span>seq</span> <span>1</span> <span>1000</span><span>)</span>
  <span>touch</span> <span>$f</span>
<span>end</span>
</code></pre></div><p>And compare with our baseline:</p>
<div><pre tabindex="0"><code data-lang="fish"><span>hyperfine</span> <span>--export-markdown</span> /tmp/<span>4</span>.md <span>--warmup</span> <span>10</span> <span>&#39;git ls-files&#39;</span> <span>&#39;git ls-files -o&#39;</span> <span>&#39;find&#39;</span> <span>\
</span><span></span>  <span>&#39;fd --no-ignore&#39;</span> <span>&#39;fd --no-ignore --hidden --exclude .git --type file --type symlink&#39;</span>
</code></pre></div><table>
<thead>
<tr>
<th>Command</th>
<th>Mean [ms]</th>
<th>Min [ms]</th>
<th>Max [ms]</th>
<th>Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git ls-files</code></td>
<td>16.8 ± 0.5</td>
<td>16.1</td>
<td>18.0</td>
<td>1.00</td>
</tr>
<tr>
<td><code>git ls-files -o</code></td>
<td>69.9 ± 1.2</td>
<td>68.1</td>
<td>72.6</td>
<td>4.17 ± 0.14</td>
</tr>
<tr>
<td><code>find</code></td>
<td>94.5 ± 0.6</td>
<td>93.4</td>
<td>96.3</td>
<td>5.64 ± 0.17</td>
</tr>
<tr>
<td><code>fd --no-ignore</code></td>
<td>86.8 ± 7.5</td>
<td>81.5</td>
<td>114.4</td>
<td>5.18 ± 0.48</td>
</tr>
<tr>
<td><code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code></td>
<td>81.0 ± 4.5</td>
<td>78.6</td>
<td>96.3</td>
<td>4.83 ± 0.31</td>
</tr>
</tbody>
</table>
<p>There is little to no statically significant difference to our baseline, which highlights that much of the time is spent on things relatively independent of the number of files processed. It’s also worth noting that there is relatively little speed difference between <code>git ls-files -o</code> and <code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code>.</p>
<p>Using <code>strace</code>, we can establish that all commands but <code>git ls-files</code> were reading all files in the repository. By comparing the <code>strace</code> outputs of <code>git ls-files -o</code> and <code>fd --no-ignore --hidden --exclude .git --type file --type symlink</code> (the two commands that print the same file list), we can see that they make similar system calls for each file in the repository. How to explain the (small) time difference between the two? I haven’t found convincing reasons in git source code for this case. It might be that the use of the <code>index</code> gives <code>ls-files</code> a head start.</p>
<h2 id="conclusions">Conclusions</h2>
<p>I’m now using <code>git ls-files</code> in my <a href="https://cj.rs/blog/my-setup/nvim-0-5/">keyboard driven text editor</a> instead of <code>fd</code> or <code>find</code>. It is faster, although the perceived difference described in the Introduction is probably due to spikes in latency on a cold cache. The selection of files is also narrowed down with <code>ls-files</code> to the ones I care about. That’s said, I’ve still kept the <code>fd</code>-based file listing as a fallback, as sometimes I’m not in a Git repository.</p>
<p>After all, Git is already building an index, why not use it to speed up your jumping from file to file!</p>

</div></div>
  </body>
</html>
