<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2024/06/13/special-values/">Original</a>
    <h1>Item 36: Use a Distinct Type for Special Values</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>This is a sample item from Chapter 4 of the second edition of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;item  use a distinct type for special values&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);">Effective TypeScript</a>, which was <a href="https://effectivetypescript.com/2024/05/21/second-edition/">released</a> in May of 2024. It discusses a common mistake in TypeScript code: using <code>&#34;&#34;</code>, <code>0</code>, or <code>-1</code> to represent special cases like missing data. By modeling these cases with a distinct type, you help TypeScript guide you towards writing more correct code. If you like what you read, consider <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;item  use a distinct type for special values&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);">buying a copy</a> of the book!</em></p>
<p>JavaScript&#39;s <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split" onclick="return trackOutboundLink(&#39;item  use a distinct type for special values&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split&#39;, event);">string <code>split</code> method</a> is a handy way to break a string around a delimiter:</p>
<pre data-type="programlisting">&gt; <strong>&#39;abcde&#39;.split(&#39;c&#39;)</strong>
[ &#39;ab&#39;, &#39;de&#39; ] </pre>

<p>Let&#39;s write something like <code>split</code>, but for arrays. Here&#39;s an attempt:</p>
<figure><div><pre><code><span><span>function</span> <span>splitAround</span>&lt;<span>T</span>&gt;(<span>vals: <span>readonly</span> T[], val: T</span>): [<span>T</span>[], <span>T</span>[]] </span>{</code></pre></div></figure>

<p>This works as you&#39;d expect:</p>
<pre data-type="programlisting">&gt; <strong>splitAround([1, 2, 3, 4, 5], 3)</strong>
[ [ 1, 2 ], [ 4, 5 ] ]</pre>

<p>If you try to <code>splitAround</code> an element that&#39;s not in the list, however, it does something quite unexpected:</p>
<pre data-type="programlisting">&gt; <strong>splitAround([1, 2, 3, 4, 5], 6)</strong>
[ [ 1, 2, 3, 4 ], [ 1, 2, 3, 4, 5 ] ]</pre>

<p>While it&#39;s not entirely clear what the function <em>should</em> do in this case, it&#39;s definitely not that! How did such simple code result in such strange behavior?</p>
<p>The root issue is that <code>indexOf</code> returns <code>-1</code> if it can&#39;t find the element in the array. This is a special value: it indicates a failure rather than success. But <code>-1</code> is just an ordinary <code>number</code>. You can pass it to the Array <code>slice</code> method and you can do arithmetic on it. When you pass a negative number to <code>slice</code>, it interprets it as counting back from the end of the array. And when you add <code>1</code> to <code>-1</code>, you get <code>0</code>. So this evaluates as:</p>
<figure><div><pre><code>[vals.slice(<span>0</span>, -<span>1</span>), vals.slice(<span>0</span>)]<br/></code></pre></div></figure>

<p>The first <code>slice</code> returns all but the last element of the array, and the second <code>slice</code> returns a complete copy of the array.</p>
<p>This behavior is a bug. Moreover, it&#39;s unfortunate that TypeScript wasn&#39;t able to help us find this problem. The root issue was that <code>indexOf</code> returned <code>-1</code> when it couldn&#39;t find the element, rather than, say <code>null</code>. Why is that?</p>
<p>Without hopping in a time machine and visiting the Netscape offices in 1995, it&#39;s hard to know the answer for sure. But we can speculate! JavaScript was heavily influenced by Java, and <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-int-" onclick="return trackOutboundLink(&#39;item  use a distinct type for special values&#39;, &#39;https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-int-&#39;, event);">its <code>indexOf</code> has this same behavior</a>. In Java (and C), a function can&#39;t return a primitive <em>or</em> null. Only objects (or pointers) are nullable. So this behavior may derive from a technical limitation in Java that JavaScript does not share.</p>
<p>In JavaScript (and TypeScript), there&#39;s no problem having a function return a <code>number</code> or <code>null</code>. So we can wrap <code>indexOf</code>:</p>
<figure><div><pre><code><span><span>function</span> <span>safeIndexOf</span>&lt;<span>T</span>&gt;(<span>vals: <span>readonly</span> T[], val: T</span>): <span>number</span> | <span>null</span> </span>{</code></pre></div></figure>

<p>If we plug that into our original definition of <code>splitAround</code>, we immediately get two type errors:</p>
<figure><div><pre><code><span><span>function</span> <span>splitAround</span>&lt;<span>T</span>&gt;(<span>vals: <span>readonly</span> T[], val: T</span>): [<span>T</span>[], <span>T</span>[]] </span>{</code></pre></div></figure>

<p>This is exactly what we want! There are always two cases to consider with <code>indexOf</code>. With the built-in version, TypeScript can&#39;t distinguish them, but with the wrapped version, it can. And it sees here that we&#39;ve only considered the case where the array contained the value.</p>
<p>The solution is to handle the other case explicitly:</p>
<figure><div><pre><code><span><span>function</span> <span>splitAround</span>&lt;<span>T</span>&gt;(<span>vals: <span>readonly</span> T[], val: T</span>): [<span>T</span>[], <span>T</span>[]] </span>{</code></pre></div></figure>

<p>Whether this is the right behavior is debatable, but at least TypeScript has forced us to have that debate!</p>
<p>The root problem with the first implementation was that <code>indexOf</code> had two distinct cases, but the return value in the special case (<code>-1</code>) had the same type as the return value in the regular case (<code>number</code>). This meant that from TypeScript&#39;s perspective there was just a single case, and it wasn&#39;t able to detect that we didn&#39;t check for <code>-1</code>.</p>
<p>This situation comes up frequently when you&#39;re designing types. Perhaps you have a type for describing merchandise:</p>
<figure><div><pre><code><span>interface</span> Product {</code></pre></div></figure>

<p>Then you realize that some products have an unknown price. Making this field optional or changing it to <code>number|null</code> might require a migration and lots of code changes, so instead you introduce a special value:</p>
<figure><div><pre><code><span>interface</span> Product {</code></pre></div></figure>

<p>You ship it to production. A week later your boss is irate and wants to know why you&#39;ve been crediting money to customer cards. Your team works to roll back the change and you&#39;re tasked with writing the postmortem. In retrospect, it would have been much easier to deal with those type errors!</p>
<p>Choosing in-domain special values like <code>-1</code>, <code>0</code>, or <code>&#34;&#34;</code> is similar in spirit to turning off <code>strictNullChecks</code>. When <code>strictNullChecks</code> is off, you can assign <code>null</code> or <code>undefined</code> to any type:</p>
<figure><div><pre><code></code></pre></div></figure>

<p>This lets a huge class of bugs slip through the type checker because TypeScript doesn&#39;t distinguish between <code>number</code> and <code>number|null</code>. <code>null</code> is a valid value in all types. When you enable <code>strictNullChecks</code>, TypeScript <em>does</em> distinguish between these types and it&#39;s able to detect a whole host of new problems. When you choose an in-domain special value like <code>-1</code>, you&#39;re effectively carving out a non-strict niche in your types. Expedient, yes, but ultimately not the best choice.</p>
<p><code>null</code> and <code>undefined</code> may not always be the right way to represent special cases since their exact meaning may be context dependent. If you&#39;re modeling the state of a network request, for example, it would be a bad idea to use <code>null</code> to mean an error state and <code>undefined</code> to mean a pending state. Better to use a tagged union to represent these special states more explicitly.</p>
<h3 id="Things-to-Remember"><a href="#Things-to-Remember" title="Things to Remember"></a>Things to Remember</h3><ul>
<li>Avoid special values that are assignable to regular values in a type. They will reduce TypeScript&#39;s ability to find bugs in your code.</li>
<li>Prefer <code>null</code> or <code>undefined</code> as a special value instead of <code>0</code>, <code>-1</code>, or <code>&#34;&#34;</code>.</li>
<li>Consider using a tagged union rather than <code>null</code> or <code>undefined</code> if the meaning of those values isn&#39;t clear.</li>
</ul>

          </div></div>
  </body>
</html>
