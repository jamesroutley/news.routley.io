<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasp.sh/blog/2025/05/28/how-to-run-cron-jobs-in-postgress-without-extra-infrastructure">Original</a>
    <h1>How to run cron jobs in Postgres without extra infrastructure</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><p>I had the pleasure to spend nearly 3 years working on live video infrastructure at TV2 Norway. As you know, when it comes to infrastructure, time <em>IS</em> money. Everything needs to be just-in-time, especially when it comes to provisioning costly components like encoders. For example, if there&#39;s a major live sports match scheduled, you want to ensure the streaming infrastructure is set up just minutes before kickoff, and torn down shortly after the final whistle blows.</p><p>The fact is, scheduling is synonymous with infrastructure complexity. But sometimes you&#39;re just working on your trusty little Node app, and all you really need is something simple ‚Äî like sending a daily reminder to users about today&#39;s coding challenge. That&#39;s exactly the kind of lightweight scheduling we&#39;ll dive into in this article.</p><h2 id="scheduling-jobs-with-wasp-and-pgboss">Scheduling Jobs with Wasp and PgBoss<a href="#scheduling-jobs-with-wasp-and-pgboss" aria-label="Direct link to Scheduling Jobs with Wasp and PgBoss" title="Direct link to Scheduling Jobs with Wasp and PgBoss">‚Äã</a></h2><h3 id="what-is-pgboss">What is PgBoss?<a href="#what-is-pgboss" aria-label="Direct link to What is PgBoss?" title="Direct link to What is PgBoss?">‚Äã</a></h3><p><a href="https://github.com/timgit/pg-boss" target="_blank" rel="noopener noreferrer">PgBoss</a> is a job queue built on <a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer">PostgreSQL</a>. It leverages the database&#39;s reliability, transactional safety, and scalability to manage background jobs efficiently. Unlike Redis-based queues, PgBoss doesn&#39;t require additional infrastructure ‚Äî just Postgres, which is a great fit if you&#39;re already using it as your database.</p><div><figure><img alt="Like a boss" src="https://wasp.sh/img/cron-jobs/boss.webp"/><figcaption></figcaption></figure></div><p><strong>Key features:</strong></p><ul><li><strong>Transactional safety</strong> ‚Äì jobs are stored in Postgres, ensuring they survive crashes.</li><li><strong>Retries &amp; timeouts</strong> ‚Äì failed jobs can be automatically retried.</li><li><strong>Scheduling</strong> ‚Äì supports both delayed and recurring (CRON) jobs.</li><li><strong>No extra infrastructure</strong> - only Postgres needed.</li></ul><h3 id="why-wasp-makes-it-even-better">Why Wasp Makes It Even Better<a href="#why-wasp-makes-it-even-better" aria-label="Direct link to Why Wasp Makes It Even Better" title="Direct link to Why Wasp Makes It Even Better">‚Äã</a></h3><p><a href="https://wasp.sh/" target="_blank" rel="noopener noreferrer">Wasp</a> is a full-stack framework for React &amp; Node.js that simplifies web app development by handling boilerplate for you. When combined with PgBoss, Wasp provides:</p><ul><li><strong>Declarative job definitions</strong> ‚Äì define jobs directly in your Wasp config.</li><li><strong>Everything just works</strong> ‚Äì no need to manually set up workers or queues.</li><li><strong>Type safety</strong> ‚Äì jobs are type-checked, reducing runtime errors.</li></ul><p>NOTE: Since PgBoss runs in the same process as your Wasp app, CPU-heavy jobs can impact API responsiveness. For high-load scenarios, consider offloading to a dedicated worker process. </p><p><strong>When Should You Consider a Different Solution?</strong></p><p>For most side projects and early-stage startups, this setup will work perfectly fine. As a rule of thumb, if you&#39;re processing less than 1000 jobs per day or your jobs are mostly lightweight operations (like sending emails or updating records), you can stick with this solution.</p><p>However, you might want to consider a dedicated job processing system when:</p><ul><li>Your jobs take more than a few seconds to complete.</li><li>You&#39;re processing thousands of jobs per day.</li><li>Your jobs involve heavy computational tasks (like image processing or data analysis).</li><li>You need to scale job processing independently from your main application</li></ul><p>A dedicated system means running your jobs on a separate server or process, isolated from your main application. This prevents long-running jobs from affecting your app&#39;s performance.</p><p>But remember: premature optimization is the root of all evil. Start with this simple solution, and only upgrade when you have concrete evidence that you need something more robust.</p><p><strong>We&#39;ll look at two use cases:</strong></p><ol><li>One-time scheduled jobs (e.g., send a reminder email at a specific time).</li><li>Recurring  (CRON) jobs (e.g., daily digest emails).</li></ol><p>We are going to use the <a href="https://github.com/wasp-lang/tennis-score-app" target="_blank" rel="noopener noreferrer">Wasp Tennis Score</a> example app to demonstrate the functionality.</p><div><figure><img alt="The main interface of our tennis score tracking app" src="https://wasp.sh/img/cron-jobs/image.webp"/><figcaption>The main interface of our tennis score tracking app</figcaption></figure></div><p>This is a neat little tennis score tracking app we&#39;ve built. Think of it like this: you&#39;re running a tennis tournament and need to keep track of who&#39;s winning. The judges can punch in scores as the matches happen, and everyone watching can see the results.</p><p>To run the app, you&#39;ll need to clone the repo, create a new <code>.env.server</code> file (copy <code>example.env.server</code> as a starting point), populate it with the required values and execute the sequence of commands listed in the <a href="https://github.com/wasp-lang/tennis-score-app?tab=readme-ov-file#running-it-locally" target="_blank" rel="noopener noreferrer">README file here.</a></p><p><strong>Requirements:</strong></p><ul><li><a href="https://nodejs.org/en" target="_blank" rel="noopener noreferrer">Node.js</a> ‚â•20 installed ‚Äî I recommend using <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer">nvm</a>.</li><li>A <a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer">Postgres</a> database connection URL ‚Äî but in our case for development you can just use <code>wasp db start</code>.</li><li><a href="https://developers.google.com/identity/protocols/oauth2" target="_blank" rel="noopener noreferrer">Google OAuth</a> credentials (Client ID and Client Secret)</li><li><a href="https://www.mailgun.com/" target="_blank" rel="noopener noreferrer">Mailgun</a> config (API Key, Domain, API Url)</li></ul><h2 id="how-to-create-scheduled-jobs-with-wasp">How to Create Scheduled Jobs with Wasp<a href="#how-to-create-scheduled-jobs-with-wasp" aria-label="Direct link to How to Create Scheduled Jobs with Wasp" title="Direct link to How to Create Scheduled Jobs with Wasp">‚Äã</a></h2><p>After cloning the repository, you can check out the working example implementation of the scheduled job feature by running the following command:</p><div><div><pre tabindex="0"><code><span><span>git</span><span> checkout scheduled_job_added</span><br/></span></code></pre></div></div><p>Start the app with <code>wasp start</code> and authenticate with Google.  </p><p>You&#39;ll be met with a UI that displays a list of tennis matches. Ongoing (i.e. Live) matches on the top and Completed Matches below.</p><p>In the header you will find a &#34;Schedule Summary Email&#34; button. That button is configured to send you a summary of the previous day&#39;s matches to your email.</p><div><figure><img alt="The logged-in interface of our tennis scoring app" src="https://wasp.sh/img/cron-jobs/image1.webp"/><figcaption>The logged-in interface of our tennis scoring app</figcaption></figure></div><p>Click the button and check the email address linked to your Google account. You should see something similar to the screenshot below.</p><div><figure><img alt="Email summary screenshot" src="https://wasp.sh/img/cron-jobs/image2.webp"/><figcaption>Email summary screenshot</figcaption></figure></div><p>Since this is a new account without any record of previous day&#39;s matches, the summary will be empty.</p><p>By default, the feature sends the email immediately for easier testing and development. I&#39;ll walk you through the implementation below.</p><p>Two resources in the <code>main.wasp</code> file do the heavy lifting for us: an <code>action</code> and a <code>job</code>.</p><div><div><pre tabindex="0"><code><span><span>// main.wasp</span><br/></span><span><span></span><br/></span><span><span>action scheduleEmailSummary {</span><br/></span><span><span>  fn: import { scheduleSummaryEmail } from &#34;@src/matches/operations&#34;,</span><br/></span><span><span>  entities: [Match]</span><br/></span><span><span>}</span><br/></span><span><span></span><br/></span><span><span>job sendEmailSummaryJob {</span><br/></span><span><span>  executor: PgBoss,</span><br/></span><span><span>  perform: {</span><br/></span><span><span>    fn: import { sendEmailSummary } from &#34;@src/workers/schedule&#34;,</span><br/></span><span><span>  },</span><br/></span><span><span>  entities: [Match]</span><br/></span><span><span>}</span><br/></span></code></pre></div></div><p>The <code>sendEmailSummary</code> job retrieves matches, converts the results into a human-readable format, and delivers the email through Mailgun.</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>export</span><span> </span><span>const</span><span> sendEmailSummary</span><span>:</span><span> </span><span>SendEmailSummaryJob</span><span>&lt;</span><span>Input</span><span>,</span><span> </span><span>void</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>(</span><span></span><br/></span><span><span>  </span><span>{</span><span> email </span><span>}</span><span>,</span><span></span><br/></span><span><span>  context</span><br/></span><span><span></span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> matches </span><span>=</span><span> </span><span>await</span><span> context</span><span>.</span><span>entities</span><span>.</span><span>Match</span><span>.</span><span>findMany</span><span>(</span><span>{</span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> </span><span>{</span><span> textContent</span><span>,</span><span> htmlContent </span><span>}</span><span> </span><span>=</span><span> </span><span>generateMatchSummary</span><span>(</span><span>matches</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> summary </span><span>=</span><span> </span><span>await</span><span> emailSender</span><span>.</span><span>send</span><span>(</span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    text</span><span>:</span><span> textContent</span><span>,</span><span></span><br/></span><span><span>    html</span><span>:</span><span> htmlContent</span><span>,</span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>The <code>scheduleEmailSummary</code> action on the other hand controls <em>when</em> the code associated with the job should be executed</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>export</span><span> </span><span>const</span><span> </span><span>scheduleEmailSummary</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>(</span><span>_</span><span>,</span><span> context</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span>const</span><span> </span><span>{</span><span> email </span><span>}</span><span> </span><span>=</span><span> context</span><span>.</span><span>user</span><span></span><br/></span><span><span>  </span><br/></span><span><span>  </span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> sendAt </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>(</span><span>)</span><span>.</span><span>toISOString</span><span>(</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span>await</span><span> sendEmailSummaryJob</span><span>.</span><span>delay</span><span>(</span><span>sendAt</span><span>)</span><span>.</span><span>submit</span><span>(</span><span>{</span><span></span><br/></span><span><span>    email</span><span>,</span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>As you can see above, the <code>sendAt</code> variable determines the job&#39;s execution time. Just provide a date to the <code>delay()</code> function, and the job will execute at that specified time.</p><p>This is the meat and potatoes of the functionality, the only thing left is to decide when are you going to run the <code>scheduleEmailSummary</code> action.</p><p>I chose to simply hook it up to a button click listener, but you can let your imagination run wild and call it from wherever you want in the code.</p><p>You can find the current implementation in the <code>IndexPage.tsx</code> file.</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>import</span><span> </span><span>{</span><span> scheduleEmailSummary </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;wasp/client/operations&#39;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>const</span><span> </span><span>handleScheduleSummaryEmailClick</span><span> </span><span>=</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>scheduleEmailSummary</span><span>(</span><span>)</span><span></span><br/></span><span><span>    </span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>    </span><span>}</span><span>)</span><span></span><br/></span><span><span>    </span><span>.</span><span>catch</span><span>(</span><span>(</span><span>error</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>    </span><span>}</span><span>)</span><span></span><br/></span><span><span>    </span><span>.</span><span>finally</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>    </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>&lt;</span><span>button</span><span></span><br/></span><span><span>  </span><span>onClick</span><span>=</span><span>{</span><span>handleScheduleSummaryEmailClick</span><span>}</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span></span><span>&gt;</span><br/></span></code></pre></div></div><p>That&#39;s all it takes ‚Äî just a few lines of code to set up lightweight job scheduling. This implementation demonstrates the core functionality, but you can easily customize it to match your specific needs.</p><h3 id="finding-this-article-useful">Finding this article useful?<a href="#finding-this-article-useful" aria-label="Direct link to Finding this article useful?" title="Direct link to Finding this article useful?">‚Äã</a></h3><p><a href="https://wasp.sh/" target="_blank" rel="noopener noreferrer">Wasp</a>¬†team is working hard to create content like this, not to mention building a modern, open-source React/NodeJS framework.</p><p>The easiest way to show your support is just to star Wasp repo! üêù Click on the button below to give Wasp a star and show your support!</p><p><img loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/axqiv01tl1pha9ougp21.gif" alt="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/axqiv01tl1pha9ougp21.gif"/></p><h2 id="how-to-create-cron-jobs-with-wasp">How to Create CRON Jobs with Wasp<a href="#how-to-create-cron-jobs-with-wasp" aria-label="Direct link to How to Create CRON Jobs with Wasp" title="Direct link to How to Create CRON Jobs with Wasp">‚Äã</a></h2><p>If that seemed easy, you&#39;re going to like what comes next. </p><p>Setting up a recurring job is even simpler than a scheduled job, because we don&#39;t need an <code>action</code> to execute it. We can simply define the interval in the <code>job</code> declaration.</p><div><figure><img alt="Classified by the relevant authorities as a life-hack" src="https://wasp.sh/img/cron-jobs/image3.webp"/><figcaption>Classified by the relevant authorities as a life-hack</figcaption></figure></div><p>Define your job like this:</p><div><div><pre tabindex="0"><code><span><span>// main.wasp</span><br/></span><span><span></span><br/></span><span><span>job sendEmailSummaryJob {</span><br/></span><span><span>  executor: PgBoss,</span><br/></span><span><span>  perform: {</span><br/></span><span><span>    fn: import { sendEmailSummary } from &#34;@src/workers/cron&#34;,</span><br/></span><span><span>  },</span><br/></span><span><span>  schedule: { cron: &#34;0 8 * * *&#34; }, // &lt;-- Notice the `cron` expression here</span><br/></span><span><span>  entities: [Match]</span><br/></span><span><span>}</span><br/></span></code></pre></div></div><p>The <code>import</code> statement connects to the function that will run according to the specified <code>cron</code> schedule. Here&#39;s how the function works:</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>export</span><span> </span><span>const</span><span> sendEmailSummary</span><span>:</span><span> </span><span>SendEmailSummaryJob</span><span>&lt;</span><span>{</span><span>}</span><span>,</span><span> </span><span>void</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>(</span><span></span><br/></span><span><span>  _</span><span>,</span><span></span><br/></span><span><span>  context</span><br/></span><span><span></span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> usersWithSummaryEnabled </span><span>=</span><span> </span><span>await</span><span> context</span><span>.</span><span>entities</span><span>.</span><span>User</span><span>.</span><span>findMany</span><span>(</span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> matches </span><span>=</span><span> </span><span>await</span><span> context</span><span>.</span><span>entities</span><span>.</span><span>Match</span><span>.</span><span>findMany</span><span>(</span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>  </span><span>}</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>const</span><span> </span><span>{</span><span> textContent</span><span>,</span><span> htmlContent </span><span>}</span><span> </span><span>=</span><span> </span><span>generateMatchSummary</span><span>(</span><span>matches</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> user </span><span>of</span><span> usersWithSummaryEnabled</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>await</span><span> emailSender</span><span>.</span><span>send</span><span>(</span><span>{</span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>      </span><span></span><br/></span><span><span>      to</span><span>:</span><span> user</span><span>.</span><span>email</span><span>,</span><span></span><br/></span><span><span>      text</span><span>:</span><span> textContent</span><span>,</span><span></span><br/></span><span><span>      html</span><span>:</span><span> htmlContent</span><span>,</span><span></span><br/></span><span><span>    </span><span>}</span><span>)</span><span></span><br/></span><span><span>  </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>That&#39;s it! Your function will now execute automatically according to the schedule you specified in the <code>cron</code> expression.</p><p>To receive game summaries in your email, go to your Profile page and enable them using the toggle switch under Settings as shown in the screenshot below.</p><div><figure><img alt="Profile settings page with email summary toggle" src="https://wasp.sh/img/cron-jobs/image4.webp"/><figcaption>Profile settings page with email summary toggle</figcaption></figure></div><h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">‚Äã</a></h2><p>As we&#39;ve seen, scheduling doesn&#39;t have to mean spiraling into infrastructure complexity ‚Äî especially when you&#39;re looking for a lightweight solution.</p><p>Whether you&#39;re queuing up daily digests, reminders, or any time-based workflow, the setup is refreshingly simple:</p><ul><li>Define a <code>job</code> in your Wasp config.</li><li>Use <code>.delay()</code> for specific future times.</li><li>Use <code>cron</code> for recurring schedules.</li></ul><p>That&#39;s it! No need to spin up external services or maintain a separate job runner infrastructure.</p><p>So if your app needs a simple scheduling feature, let Wasp and PgBoss keep track of the clocks ticking.</p><p>GLHF!</p></div></div>
  </body>
</html>
