<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chuniversiteit.nl/papers/svelte-is-fast">Original</a>
    <h1>Svelte is that fast</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you search online, you’ll find countless benchmarks claiming to compare the
performance of various JavaScript frameworks with each other. More often than
not, the benchmarks are overly simplistic and fail to reflect real-world
scenarios. In other cases, they compare apples and oranges, for instance by
pitting a fully fledged framework against a lightweight library that cover only
a small subset of the framework’s functionality.</p>
<p>Right now, I’m at that point in my career again where I am starting development
on a new web application and need to choose the “right” JavaScript framework.
This time, I decided to look for academic studies on the performance of
JavaScript frameworks and sadly, didn’t find as many as I had hoped. I did come
across one particular study that compares Angular, React, Vue, Svelte and Blazor
with each other. Its main drawback is that the comparison was done in 2021 – a
lifetime ago in tech terms – but I think it’s still worth reading.</p>
<p>Before I dive into the summary, I want to share something I found mildly amusing.
The paper is published in the Journal of Web Engineering, and if you visit its
website, you’ll notice it includes <code>/index.php/</code> in the URL. I’m not sure why.
Is it a deliberate choice? Or is it a sign of questionable web engineering?</p>

<p>It is estimated that up to 97% of websites today use JavaScript, with more than
80% also relying on a library or framework. JavaScript is often used to manage
UI state changes within single page applications, allowing users to interact
without reloading the entire page. While this can be done manually via the DOM
API, it’s often error prone.</p>
<div><h2 id="theory">Theory</h2><p><span><a href="#theory" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
<p>Modern web frameworks wrap the DOM API and provide a custom declarative syntax.
This means that application code can simply describe the desired UI state, and
the framework automatically generates the necessary DOM API calls to reflect
that state in the browser.</p>
<p>When using the DOM API directly, the amount of script execution required to
update the UI scales linearly with the complexity of the change. However, when
DOM API calls are generated dynamically by a framework, the framework must first
determine exactly which updates are necessary, introducing additional overhead.
Furthermore, the chosen rendering strategy can greatly affect the number of DOM
API calls made. A bad strategy may result in noticeable delays even for small
updates, which is why it makes sense to compare the strategies used by major
JavaScript frameworks.</p>
<div><h3 id="javascript-versus-webassembly">JavaScript versus WebAssembly</h3><p><span><a href="#javascript-versus-webassembly" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
<p>The study looks at five popular frameworks: Angular, React, Vue, Svelte, and
Blazor. All are JavaScript-based except for Blazor, which uses WebAssembly.
Blazor applications are written in C# and run in a .NET runtime compiled to
WebAssembly. Because WebAssembly modules lack direct access to the DOM, they
rely on an additional JavaScript interoperability layer, which can introduce
extra overhead.</p>
<table><thead><tr><th>Framework</th>
<th>Version</th></tr></thead><tbody><tr><td>Angular</td>
<td>11.2.3</td></tr><tr><td>React</td>
<td>17.0.1</td></tr><tr><td>Vue</td>
<td>3.0.7</td></tr><tr><td>Svelte</td>
<td>3.35.0</td></tr><tr><td>Blazor</td>
<td>5.0.3</td></tr></tbody></table>
<div><h3 id="virtual-dom-versus-data-bindings">Virtual DOM versus data bindings</h3><p><span><a href="#virtual-dom-versus-data-bindings" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
<p>All five frameworks follow some variant of the Model-View-ViewModel (MVVM)
pattern. In MVVM, developers define components that bind an application’s data
sources to views, so that changes in the data are automatically reflected in the
UI.</p>
<p>Each framework continuously tries to keep the state of the DOM tree synchronised
with the state of the component tree defined in application code. This is done
using two distinct methods.</p>
<p>The first method, known as virtual DOM (vDOM)-based rendering, is used in React,
Vue, and Blazor. It works by comparing the two trees and calculating the minimum
set of changes needed to transform one into the other. This generally has a time
complexity of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span><span>n</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span>)</span></span></span></span></span>, but can often be simplified to <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span>n</span><span>)</span></span></span></span></span> by making
assumptions that usually apply in browser applications.</p>
<p>The second method is used by Angular and Svelte. Here, there is no separate step
for calculating all required changes to the DOM. Instead, each component
directly updates its corresponding section of the DOM by tracking the values of
its data bindings.</p>
<p>From a performance standpoint, using a virtual DOM can introduce overhead not
present in a binding-based rendering strategy.</p>
<div><h3 id="creating-versus-updating">Creating versus updating</h3><p><span><a href="#creating-versus-updating" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
<p>All of the reviewed frameworks perform DOM updates within a render loop that
walks through the component tree. The cost of this render loop depends on the
size of the input and fixed costs.</p>
<p>A render loop involves two types of work: creating new elements and updating
existing ones. Creating elements is generally straightforward and costs the same
for each framework, regardless of rendering strategy.</p>
<p>Updating existing elements is where the rendering strategy makes a noticeable
difference. Angular, for example, always walks through the entire component tree,
resulting in a lot of unnecessary work when only a small part of the tree needs
updating. React and Blazor walk only through the subtree of the component that
initiates the render loop, which is usually more efficient but may still require
some unnecessary work for descendants whose output has not changed. Vue and
Svelte, on the other hand, process only “dirty” components whose output has
changed. This requires the framework to track which components are dirty. Vue
does this at runtime, Svelte handles it at compile time.</p>
<p>Finally, component output can be classified as either static or dynamic content,
with static content remaining unchanged after the component’s initial render.
Frameworks that can optimise for static content may have a performance advantage
over those that cannot.</p>
<div><h2 id="practice">Practice</h2><p><span><a href="#practice" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
<p>Several benchmarks were conducted using Angular, React, Vue, Svelte and Blazor.
The authors found significant differences in performance between the frameworks,
especially as input size increased.
<label><span>Svelte emerges as the clear winner</span><span> (side note: </span><span>For the record, I have never used
Svelte myself, but based on these results I might just finally give it a
try.</span><span>)</span></label>, outperforming the others across literally every benchmark.</p>
<p>Svelte is the fastest framework when creating <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span> static elements, while React
is generally among the slowest:</p>
<table><thead><tr><th><i>n</i></th>
<th>Angular (ms)</th>
<th>React (ms)</th>
<th>Vue (ms)</th>
<th>Svelte (ms)</th>
<th>Blazor (ms)</th></tr></thead><tbody><tr><td>100</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>3</td></tr><tr><td>500</td>
<td>9</td>
<td>9</td>
<td>3</td>
<td>2</td>
<td>8</td></tr><tr><td>1000</td>
<td>16</td>
<td>11</td>
<td>6</td>
<td>3</td>
<td>13</td></tr><tr><td>5000</td>
<td>85</td>
<td>77</td>
<td>28</td>
<td>14</td>
<td>61</td></tr><tr><td>10000</td>
<td>177</td>
<td>200</td>
<td>47</td>
<td>24</td>
<td>123</td></tr><tr><td>25000</td>
<td>844</td>
<td>956</td>
<td>95</td>
<td>63</td>
<td>371</td></tr><tr><td>50000</td>
<td>2520</td>
<td>3559</td>
<td>173</td>
<td>98</td>
<td>964</td></tr></tbody></table>
<p>Svelte is also the fastest when creating <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span> components arranged as a binary
tree. However, in this case, Blazor is the slowest by a considerable margin:</p>
<table><thead><tr><th><i>n</i></th>
<th>Angular (ms)</th>
<th>React (ms)</th>
<th>Vue (ms)</th>
<th>Svelte (ms)</th>
<th>Blazor (ms)</th></tr></thead><tbody><tr><td>128</td>
<td>20</td>
<td>7</td>
<td>16</td>
<td>3</td>
<td>17</td></tr><tr><td>512</td>
<td>75</td>
<td>32</td>
<td>53</td>
<td>10</td>
<td>59</td></tr><tr><td>1024</td>
<td>120</td>
<td>55</td>
<td>84</td>
<td>22</td>
<td>128</td></tr><tr><td>4096</td>
<td>216</td>
<td>137</td>
<td>223</td>
<td>83</td>
<td>485</td></tr><tr><td>8192</td>
<td>297</td>
<td>233</td>
<td>313</td>
<td>142</td>
<td>966</td></tr><tr><td>16384</td>
<td>469</td>
<td>394</td>
<td>485</td>
<td>233</td>
<td>1870</td></tr><tr><td>32768</td>
<td>774</td>
<td>733</td>
<td>897</td>
<td>482</td>
<td>3644</td></tr></tbody></table>
<p>When updating the root component of a tree with <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span> components, <label><span>we clearly
see how Vue and Svelte benefit from binding-based rendering strategies</span><span> (side note: </span><span>Blazor’s
results are particularly interesting here as well…</span><span>)</span></label>:</p>
<table><thead><tr><th><i>n</i></th>
<th>Angular (ms)</th>
<th>React (ms)</th>
<th>Vue (ms)</th>
<th>Svelte (ms)</th>
<th>Blazor (ms)</th></tr></thead><tbody><tr><td>128</td>
<td>3</td>
<td>7</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr><tr><td>512</td>
<td>12</td>
<td>23</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr><tr><td>1024</td>
<td>14</td>
<td>42</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>2</td></tr><tr><td>4096</td>
<td>32</td>
<td>92</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr><tr><td>8192</td>
<td>32</td>
<td>92</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr><tr><td>16384</td>
<td>43</td>
<td>211</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>2</td></tr><tr><td>32768</td>
<td>103</td>
<td>379</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr></tbody></table>
<p>When updating a leaf component in a component tree of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span> components, Angular is
the only framework that lags slightly behind. This is because it performs the
same amount of work regardless of what has actually changed:</p>
<table><thead><tr><th><i>n</i></th>
<th>Angular (ms)</th>
<th>React (ms)</th>
<th>Vue (ms)</th>
<th>Svelte (ms)</th>
<th>Blazor (ms)</th></tr></thead><tbody><tr><td>128</td>
<td>3</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>1</td></tr><tr><td>512</td>
<td>13</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>1</td></tr><tr><td>1024</td>
<td>14</td>
<td>1</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>1</td></tr><tr><td>4096</td>
<td>33</td>
<td>4</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>3</td></tr><tr><td>8192</td>
<td>33</td>
<td>3</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>5</td></tr><tr><td>16384</td>
<td>44</td>
<td>5</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>4</td></tr><tr><td>32768</td>
<td>104</td>
<td>4</td>
<td>&lt;1</td>
<td>&lt;1</td>
<td>8</td></tr></tbody></table>
<p>Finally, the table below shows the script execution time when updating the
entire component tree of <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span> components, where each component contains
primarily static content:</p>
<table><thead><tr><th><i>n</i></th>
<th>Angular (ms)</th>
<th>React (ms)</th>
<th>Vue (ms)</th>
<th>Svelte (ms)</th>
<th>Blazor (ms)</th></tr></thead><tbody><tr><td>128</td>
<td>4</td>
<td>34</td>
<td>20</td>
<td>2</td>
<td>28</td></tr><tr><td>256</td>
<td>8</td>
<td>44</td>
<td>32</td>
<td>3</td>
<td>60</td></tr><tr><td>512</td>
<td>17</td>
<td>66</td>
<td>42</td>
<td>5</td>
<td>101</td></tr><tr><td>1024</td>
<td>27</td>
<td>101</td>
<td>72</td>
<td>10</td>
<td>250</td></tr><tr><td>2048</td>
<td>29</td>
<td>235</td>
<td>91</td>
<td>20</td>
<td>502</td></tr><tr><td>4096</td>
<td>44</td>
<td>289</td>
<td>149</td>
<td>54</td>
<td>1020</td></tr><tr><td>8192</td>
<td>238</td>
<td>841</td>
<td>311</td>
<td>80</td>
<td>2013</td></tr></tbody></table>
<p>Overall, the results are in line with what would be expected given the
characteristics of each rendering strategy.</p>
<p>The WebAssembly-based Blazor shows significantly worse performance than its
JavaScript-based competitors. However, from these benchmarks alone it’s
impossible to determine whether this is due to Blazor itself or a fundamental
limitation of using WebAssembly for this purpose.</p>
<p>Meanwhile, Svelte demonstrates three key characteristics that likely contribute
most to improved performance:</p>
<ul>
<li>The use of a reactivity system to automatically detect dirty components</li>
<li>An optimising compiler that generates component update code which ignores
static content</li>
<li>A binding-based rendering approach rather than a virtual DOM</li>
</ul>
<div><h2 id="summary">Summary</h2><p><span><a href="#summary" title="Copy link to heading" tabindex="-1"> <img src="https://chuniversiteit.nl/images/static/link.svg" alt="Link"/></a></span></p></div>
</div></div>
  </body>
</html>
