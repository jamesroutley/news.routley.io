<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bsdly.blogspot.com/2022/09/a-few-of-my-favorite-things-about.html">Original</a>
    <h1>A Few of My Favorite Things About the OpenBSD Packet Filter Tools</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8910085227874085099" itemprop="description articleBody">
<p>
<i>The <a href="https://www.openbsd.org/">OpenBSD</a> packet filter PF was introduced a little more than 20 years ago as part of <a href="https://www.openbsd.org/30.html">OpenBSD 3.0</a>. We&#39;ll take a short tour of PF features and tools that I have enjoyed using.</i>
</p><blockquote><p><b>NOTE: </b>If you are more of a <i>slides</i> person, the condensate for a <a href="http://semibug.org/">SEMIBUG</a> user group meeting is available <a href="https://home.nuug.no/~peter/pf_favorite/">here</a>. A version without trackers but “classical” formatting is available <a href="https://nxdomain.no/~peter/better_off_with_pf.html">here</a>.
</p></blockquote><p>
At the time the OpenBSD project introduced its new packet filter subsystem in 2001, I was nowhere near the essentially full time OpenBSD user I would soon become. I did however quickly recognize that even what was later dubbed <i>“the working prototype”</i> was reported to perform better in most contexts than the code it replaced.  
</p><p>
The reason PF&#39;s predecessor needed to be replaced has been covered extensively by myself and others elsewhere, so I&#39;ll limit myself to noting that the reason was that several somebodies finally read and understood the code&#39;s license and decided that it was not in fact open source in any acceptable meaning of the term.
</p><p>
  Anyway the initial PF release was very close in features and syntax to the code it replaced. And even at that time, the config syntax was a lot more human readable than the alternative I had been handling up to then, which was Linux&#39; IPtables. The less is said about IPtables, the better.
</p><p>
  But soon visible improvements in user friendliness, or at least admin friendliness, started turning up. With OpenBSD 3.2, the separate <a href="http://man.openbsd.org/OpenBSD-3.1/nat.conf"><tt>/etc/nat.conf</tt></a> network adress translation configuration file moved to the attic and the NAT and redirection options moved into the main PF config file <a href="http://man.openbsd.org/pf.conf"><tt>/etc/pf.conf</tt></a>.
</p><p>
  The next version, OpenBSD 3.3, saw the ALTQ queueing configuration move into <tt>pf.conf</tt> as well, and the previously separate <a href="http://man.openbsd.org/OpenBSD-3.2/altq.conf"><tt>altq.conf</tt></a> file became obsolete. What did not change, however, was the syntax, which was to remain just bothersome enough that many of us put off playing with traffic shaping until some years later. Other PF news in that release included <i>anchors</i>, or named sub-rulesets, as well as <i>tables</i>, described as <i>&#34;a very efficient way for large address lists in rules&#34;</i> and the initial release of <a href="https://man.openbsd.org/spamd">spamd(8)</a>, the spam deferral daemon.
  </p><p>
More on all of these things later, I will not bore you with a detailed history of PF features introduced or changed in OpenBSD over the last twenty-some years.
  </p><h2>PF Rulesets: The Basics</h2>
  <p>
    So how do we go about writing that <i>perfect</i> firewall config?
  </p><p>
    I could go on about that at length, and I have been known to on occasion, but let us start with the simplest possible, yet <i>absolutely secure</i> PF ruleset:
  </p><p>
    <code>
      block
    </code>
    </p><p>
    With that in place, you are totally secure. No traffic will pass.
  </p><p>
    Or as they say in the trade, you have virtually unplugged yourself from the rest of the world.
  </p><p>
    By way of getting ahead of ourselves, that particular ruleset will expand to the following:
  </p><p>
    <code>
      block drop all
      </code>
</p><p>
    But we are getting ahead of ourselves.
  </p><p>
    To provide you with a few tools and some context, these are the basic building blocks of a PF rule:
  </p><p>
    <b>verb</b> <i>criteria</i> <b>action</b> ... options
  </p><p>
    Here are a few sample rules to put it into context, all lifted from configurations I have put into production:
  </p><p>
    <code>
      pass in on egress proto tcp to egress port ssh
    </code>
  </p><p>
    This first sample says that if a packet arrives on the <i>egress</i> — an interface belonging to the group of interfaces that has a default route — and that packet is a TCP packet with a destination service <i>ssh</i>, let the packet pass to the interfaces belonging to the <i>egress</i> interface group.
  </p><p>
    Yes, when you write PF rulesets, you do not necessarily need to write port numbers for services and memorize what services hide behind port 80, 53 or 443. The common or standard services are known to the rules parsing part of <a href="https://man.openbsd.org/pfctl">pfctl(8)</a>, generally with the service names you can look up in the <tt><a href="https://man.openbsd.org/services">/etc/services</a></tt> file.
  </p><p>
    The interface groups concept is as far as I know an <a href="https://www.openbsd.org/">OpenBSD</a> innovation. You can put interfaces into logical groups and reference the group name in PF configurations. A few default interface groups exist without you doing anything, <i>egress</i> is one, another common one is <i>wlan</i> where all configured WiFi interfaces are members by default. Keep in mind that you can create your own interface groups — set them up using <tt><a href="https://man.openbsd.org">ifconfig(8)</a></tt> — and refer to them in your rules.
  </p><p>
<code>
  match out on egress nat-to egress
</code>
  </p><p>
    This one <i>match</i>es outbound traffic, again on <i>egress</i> (which in the simpler cases consists of one interface) and applies the <i>nat-to</i> action on the packets, transforming them so that the next hops all the way to the destination will see packets where the source address is equal to the <i>egress</i> interface&#39;s address. If your network runs IPv4 and you have only one routeable address assigned, you will more than likely have something like this configured on your Internet-facing gateway.
  </p><p>
    It is worth noting that early PF versions did not have the <i>match</i> verb. After a few years of PF practice, developers and practitioners alike saw the need for a way to apply actions such as <i>nat-to</i> or other transformations without making a decision on whether to pass or block the traffic. The <tt>match</tt> keyword arrived in <a href="https://www.openbsd.org/46.html">OpenBSD 4.6</a> and in retrospect seems like a prelude to more extensive changes that followed over the next few releases.
  </p><p>
    Next up is a variation on the initial <i>absolutely secure</i> ruleset.
    </p><p>
<code>
  block all
</code>
  </p><p>
    I will tell you now so you will not be surprised later: If you had made a configuration with those three rules in that order, your configuration would be functionally the same as the one word one we started with. This is because in PF configurations, the rules are <b>evaluated</b> from top to bottom, and the <i>last</i> matching rule wins.
  </p>  <p>
    The only escape from this progression is to insert a <i>quick</i> modifier after the verb, as in</p><p>
    <tt>pass quick from (self)</tt>
</p><p>
  which will stop evaluation when a packet matches the criteria in the <i>quick</i> rule. Please use sparingly if at all.
  </p><p>
    There is a specific reason why PF behaves like this. The system that PF replaced in OpenBSD had the top to bottom, last match wins logic, and the developers did not want to break existing configurations too badly during the transition away from the old system.
  </p><p>
    So in practice you would put them in this order for a more functional setup,
  </p><pre><code>  block all
  match out on egress nat-to egress
  pass in on egress proto tcp to egress port ssh
    </code></pre>
  <p>
     but likely supplemented by a few other items.
  </p><p>
    For those supplementing items, we can take a look at some of the PF features that can help you write readable and maintainable rulesets. And while a readable ruleset is not automatically a more secure one, readability certainly helps spot errors in your logic that could put the systems and users in your care in reach of potential threats.
  </p><p>
    To help that readability, it is important to be aware of these features:
  </p><p>
    <b>Options</b>: General configuration options that set the parameters for the ruleset, such as
</p><pre><code>  set limit states 100000
  set debug debug
  set loginterface dc0
  set timeout tcp.first 120 
  set timeout tcp.established 86400 
  set timeout { adaptive.start 6000, adaptive.end 12000 }
  </code></pre>
<p>
  If the meaning of some of those do not seem terribly obvious to you at this point, that&#39;s fine. They are all extensively documented in the <a href="https://man.openbsd.org/pf.conf">pf.conf</a> man page.
  </p><p>
    <b>Macros</b>: Content that will expand in place, such as lists of services, interface names or other items you feel useful. Some examples along with rules that use them: 
</p><pre><code>  ext_if = &#34;kue0&#34; 
  all_ifs = &#34;{&#34; $ext_if lo0 &#34;}&#34; 
  pass out on $ext_if from any to any 
  pass in  on $ext_if proto tcp from any to any port 25
  </code></pre><p>
  Keep in mind that if your macros expand to lists of either ports or IP addresses, the macro expansion will create several rules to cover your definitions in the ruleset that is eventually loaded.
  </p><p>
    <b>Tables</b>: Data structures that are specifically designed to store IP addresses and networks. Originally devised to be a more efficient way to store IP addresses than macros that contained IP addresses and expanded to several rules that needed to be evaluated separately. Rules can refer to tables so the rule will match any member of the table.
  </p><pre><code>  table &lt;badhosts&gt; persist counters file &#34;/home/peter/badhosts&#34;
  # ...
  block from &lt;badhosts&gt;
      </code></pre><p>
    Here the table is loaded from a file. You can also initialize a table in <tt><a href="https://man.openbsd.org/pf.conf">pf.conf</a></tt> itself, and you can even manipulate table contents from the command line without reloading the rules:
  </p><p>
    <code>
  $ doas pfctl -t badhosts -T add 192.0.2.11 2001:db8::dead:beef:baad:f00d
    </code>
  </p><p>
    In addition, several of the daemons in the OpenBSD base system such as <tt><a href="https://man.openbsd.org/spamd">spamd</a></tt>, <tt><a href="https://man.openbsd.org/bgpd">bgpd</a></tt> and <tt><a href="https://man.openbsd.org/dhcpd">dhcpd</a></tt> can be set up to interact with your PF rules.
    </p><p>
    <b>Rules</b>: The rules with the <i>verbs</i>, <i>criteria</i> and <i>actions</i> that determine how your system handles network traffic.
</p><p>
  A very simple and reasonable baseline is one that blocks all incoming traffic but allows all traffic initiated on the local system:
  <code></code></p><pre><code>  block
  pass from (self)
      </code></pre><p>
The <tt>pass</tt> rule lets our traffic pass to elsewhere, and since PF is a stateful firewall by default, return traffic for the connections the local system sends out will be allowed back.
  </p><p>
  You probably noticed the configuration here references something called <tt>(self)</tt>.
  </p><p>
    The string <tt>self</tt> is a default macro which expands to all configured local interfaces on the host. Here, <tt>self</tt> is set inside parentheses <tt>()</tt> which indicates that one or more of the interfaces in <tt>self</tt> may have dynamically allocated addresses and that PF will detect any changes in the configured interface IP addresses.
</p><p>
  This exact ruleset expanded to this on my laptop in my home network at one point:
</p><pre><code> $ doas pfctl -vnf /etc/pf.conf
   block drop all
   pass inet6 from ::1 to any flags S/SA
   pass on lo0 inet6 from fe80::1 to any flags S/SA
   pass on iwm0 inet6 from fe80::a2a8:cdff:fe63:abb9 to any flags S/SA
   pass inet6 from 2001:470:28:658:a2a8:cdff:fe63:abb9 to any flags S/SA
   pass inet6 from 2001:470:28:658:8c43:4c81:e110:9d83 to any flags S/SA
   pass inet from 127.0.0.1 to any flags S/SA
   pass inet from 192.168.103.126 to any flags S/SA</code></pre><p>
  The <tt><a href="https://man.openbsd.org/pfctl">pfctl</a></tt> command here says to <b>v</b>erbosely <i>parse</i> but do <b>n</b>ot load rules from the <b>f</b>ile <tt><a href="https://man.openbsd.org/pf.conf">/etc/pf.conf</a></tt>.
    </p><p>
      This shows what the <i>loaded</i> ruleset will be, after any macro expansions or optimizations. 
    </p><p>
      For that exact reason, it is <b>strongly</b> recommended to review the output of <tt>pfctl -vnf</tt> on any configuration you write before loading it as your running configuration.
    </p><p>
      If you look closely at that command output, you will see both the <tt>inet</tt> and <tt>inet6</tt> keywords. These designate IPv4 and IPv6 addresses respectively. PF since the earliest days has supported both, and if you do not specify which address family your rule applies to, it will apply to both.
    </p><p>
      But this has all been on a boring single host configuration. In my experience, the more interesting settings for PF use is when the configuration is for a host that handles traffic for other hosts, as a <i>gateway</i> or other intermediate host.
    </p><p>
      To forward traffic to and from other hosts, you need to enable forwarding. You can do that from the command line:
</p><pre><code> # sysctl net.inet.ip.forwarding=1 
 # sysctl net.inet6.ip6.forwarding=1
	</code></pre><p>
      But you will want to make the change permanent by putting the following lines in your <tt><a href="https://man.openbsd.org/sysctl.conf">/etc/sysctl.conf</a></tt> so the change survives reboots.
</p><pre><code>  net.inet.ip.forwarding=1 
  net.inet6.ip6.forwarding=1
	</code></pre><p>
With these settings in place, a configuration (<tt><a href="https://man.openbsd.org/pf.conf">/etc/pf.conf</a></tt>) like this might make sense if your system has two network interfaces that are both of the <a href="https://man.openbsd.org/bge">bge</a> kind:
</p><pre><code>  ext_if=bge0
  int_if=bge1
  client_out = &#34;{ ftp-data ftp ssh domain pop3, imaps nntp https }&#34;
  udp_services = &#34;{ domain ntp }&#34;
  icmp_types = &#34;echoreq unreach&#34;
  match out on egress inet nat-to ($ext_if)
  block
  pass inet proto icmp all icmp-type $icmp_types keep state
  pass quick proto { tcp, udp } to port $udp_services keep state
  pass proto tcp from $int_if:network to port $client_out
  pass proto tcp to self port ssh
	</code></pre><p>
  Your network likely differs in one or more ways from this example. See the references at the end for a more thorough treatment of all these options.
    </p><p>
  And once again, please do use the readability features of the PF syntax to keep you sane and safe.
    </p><h2>A Configuration That Learns From Network Traffic Seen and Adapts To Conditions</h2>
<p>
  With PF, you can create a network that learns. Fairly early in PF&#39;s history it occured to the developers that the network stack collects and keeps track of information about the traffic it sees, which could then be acted upon if the software became able to actively monitor the data and act on specified changes. So the <i>state tracking options</i> entered the <a href="http://man.openbsd.org/pf.conf"><tt>pf.conf</tt></a> repertoire in their initial form with the <a href="https://www.openbsd.org/37.html">OpenBSD 4.7</a> release. 
</p><p>
  A common use case is when you run an SSH service or really any kind of listening service with the option to log in, you will see some number of failed authentication attempts that generate noise in the logs. The password guessing, or as some of us say, password groping, can turn to be pretty annoying even if the miscreants do not actually manage to compromise any of your systems. So to eliminate noise in our logs we turn to the data that is anyway available in  the state table, to track the state of active connections, and to act on limits you define such as number of connections from a single host over a set number of seconds.
</p><p>
The action could be to add the source IP that tripped the limit to a table. Additional rules could then subject the members of that table to special treatment. Since that time, my internet-facing rule sets have tended to include variations on
</p><pre><code>  table &lt;bruteforce&gt; persist
  block quick from &lt;bruteforce&gt;
  pass inet proto tcp from any to $localnet port $tcp_services \
        flags S/SA keep state \
	(max-src-conn 100, max-src-conn-rate 15/5, \
         overload &lt;bruteforce&gt; flush global)
	</code></pre><p>
which means that any host that tries more than 100 simultaneous connections or more than 15 new connections over 5 seconds are added to the table and blocked, with any existing connections terminated.
</p><p>
  It is a good practice to let table entries in such setups expire eventually. How long entries stay is entirely up to you.
  </p><p>
    At first I set expiry at 24 hours, but with password gropers like those caught by this rule being what they are, I switched a few years ago to at four weeks at first, then upped again a few months later to six weeks. Groperbots tend to stay broken for that long. And since they target any service you may be running, state tracking options with overload tables can be useful in a lot of non-SSH contexts as well.
  </p><p>
    A point that observers often miss is that with this configuration, you have a firewall that <i>learns</i> from the traffic it sees and <i>adapts</i> to network conditions. 
</p><p>
  It is also worth noting that state tracking actions can be applied to all TCP traffic and that they can be useful for essentially all services.
</p><p>
  The <i>buzzwordability</i> potential in the learning configurations is enormous, and I for one fail to see how the <i>big names</i> have failed to copy or imitate this feature and <i>greytrapping</i> which we will look at later, and capitalize on products with those features.
</p><p>
  The article <i><a href="https://bsdly.blogspot.com/2017/04/forcing-password-gropers-through.html">Forcing the password gropers through a smaller hole with OpenBSD&#39;s PF queues</a></i> has a few suggestions on how to handle noise sources with various other services. More on queues in a few moments.
</p><h2>The Adaptive Firewall and the Greytrapping Game </h2>
<p>
  At the risk of showing my age, I must admit that I have more or less always run a mail service. Once TCP/IP networking became available in some form for even small businesses and individuals during the early 1990s, once you were connected, it was simply one of those things you would do. Setting up an SMTP service (initially wrestling with <tt>sendmail</tt> and it legendary <tt>sendmail.cf</tt> configuration file) with accompanying pop3 and/or imap service was the done thing.
</p><p>
  Over time the choice of mail server software changed, we introduced content filtering to beat the rise of the trashy, spam mail spams and, since the majority of clients ran <i>that</i> operating system mail-borne malware. But even with state of the art content filtering <i>some</i> unwanted messages would make it into users&#39; inboxes often enough to be annoying.
</p><p>
  So when <a href="https://www.openbsd.org/33.html">OpenBSD 3.3</a> shipped with the initial version of <a href="https://man.openbsd.org/spamd">spamd</a> it was quite a relief for people of my job category, even if that only would load lists of known bad senders&#39; IP addresses and stutter at them one byte per second until the other side gave up.
</p><p>
  Later versions introduced <i><a href="https://en.wikipedia.org/wiki/Greylisting_(email)">greylisting</a></i> — answering SMTP connections from previously unknown senders with a temporary local error code and only accepting delivery if the same host tried again — which reduced the load on the content filtering machines significantly, and the real fun started with the introduction of <i><a href="https://home.nuug.no/~peter/pf/en/spamd.greytrapping.html">greytrapping</a></i> in the version of <a href="https://man.openbsd.org/spamd">spamd(8)</a> that shipped with <a href="https://www.openbsd.org/33.html">OpenBSD 3.7</a>.
</p><p>
  <i>Greytrapping</i> is yet another adaptive or learning feature. The system identifies bad actors by comparing the destination email address in incoming SMTP traffic from unknown or already greylisted hosts with a list of <i>known invalid</i> addresses in the domains the site serves.  The <a href="https://man.openbsd.org/spamdb">spamdb(8)</a> command was extended to add features to add addresses to and delete from the spamtrap list.
  </p><p>
    Greytrapping was an extremely welcome new feature, and I adopted it eagerly. Soon after the feature became available, I set up for greytrapping. The spamtrap addresses were the ones initially addresses I fished out of my mail server logs — from entries produced by bounce messages that themselves turned out to be undeliverable at our end since the recipient did not exist — and after a few weeks I started publishing both the list of spamtraps <i>and</i> an hourly dump of currently trapped IP addresses.
  </p><p>
    The setup is amazingly easy. On a typical gateway in front of a mail server you instrument your <a href="http://man.openbsd.org/pf.conf"><tt>/etc/pf.conf</tt></a> with a few lines, usually at the top,
  </p><pre><code>  table &lt;spamd-white&gt; persist
  table &lt;nospamd&gt; persist file &#34;/etc/mail/nospamd&#34;
  pass in on egress proto tcp to any port smtp \
        divert-to 127.0.0.1 port spamd
  pass in on egress proto tcp from &lt;nospamd&gt; to any port smtp
  pass in log on egress proto tcp from &lt;spamd-white&gt; to any port smtp
  pass out log on egress proto tcp to any port smtp
    </code></pre>
  <p>
    Here we even suck in a file that contains the IP addresses of hosts that should not be subjected to the <tt>spamd</tt> treatment.
  </p><p>
    In addition you will need to set up with the correct options for <a href="https://man.openbsd.org/spamd">spamd(8)</a> and <a href="https://man.openbsd.org/spamd">spamdlogd(8)</a> in your <tt><a href="https://man.openbsd.org/rc.conf">/etc/rc.conf.local</a></tt>:
  </p><pre><code>  spamd_flags=&#34;-v -G 2:8:864 -n &#34;mailwalla 17.25&#34; -c 1200 -C /etc/mail/fullchain.pem -K /etc/mail/privkey.pem -w 1 -y em1 -Y em1 -Y 158.36.191.225&#34;
  spamdlogd_flags=&#34;-i em1 -Y 158.36.191.225&#34;
      </code></pre><p>
    The IP address here designates a sync partner, check out the <a href="https://man.openbsd.org/spamd">spamd(8)</a> man page for the other options. If you&#39;re interested, you can get the gory details of running a setup with several mail exchangers in the <i><a href="https://bsdly.blogspot.com/2012/05/in-name-of-sane-email-setting-up-spamd.html">In The Name Of Sane Email: Setting Up OpenBSD&#39;s spamd(8) With Secondary MXes In Play - A Full Recipe</a></i> article.
  </p><p>
    You probably do not need to edit the configuration file <a href="https://man.openbsd.org/spamd.conf"><tt>/etc/mail/spamd.conf</tt></a> much, but do look up the man page and possibly references to the <a href="https://www.bsdly.net/~peter/traplist.shtml">bsdly.net blocklist</a>. Finally, reload your PF configuration, start the daemons <a href="https://man.openbsd.org/spamd">spamd(8)</a> and <a href="https://man.openbsd.org/spamd">spamdlogd(8)</a> using <a href="https://man.openbsd.org/rcctl">rcctl</a>, set up a <a href="https://man.openbsd.org/crontab">crontab(5)</a> line to run <a href="https://man.openbsd.org/spamd-setup">spamd-setup(8)</a> at reasonable intervals to fetch updated blocklists.
  </p><p>
    The number of trapped addresses in the <a href="https://www.bsdly.net/~peter/traplist.shtml">hourly dump</a> has been anything from a few hundred in the earliest days, later in the thousands and even at times in the hundreds of thousands. For the last couple of years the number has generally been in the mid to low four digits, with each host typically hanging around longer to try delivery to an ever expanding number of invalid addresses in their database.
  </p><p>
    Just a few weeks ago, the list of <i>“imaginary friends”</i> rolled past 300,000 entries. The article <i><a href="https://bsdly.blogspot.com/2022/09/the-things-spammers-believe-tale-of.html">The Things Spammers Believe - A Tale of 300,000 Imaginary Friends</a></i> tells the story with copious links to earlier articles and other resources, while <i><a href="https://bsdly.blogspot.com/2013/04/maintaining-publicly-available.html">Maintaining A Publicly Available Blacklist - Mechanisms And Principles</a></i> details the work involved in maintaining a blocklist that is offered to the public.
  </p><p>
It&#39;s been good fun, with a liberal helping of bizarre as the number of spamtraps grew, sometimes with truly weird contents.
  </p><h2>Traffic Shaping You Can Actually Understand</h2>
  <p>
    You&#39;ve heard it before: <i>Traffic shaping is hard. Hard to do and hard to understand.</i>
  </p><p>
    Traditionally traffic shaping was available on all BSDs in the form of ALTQ, a codebase that its developers labeled experimental and contained implementations of several different traffic shaping algorithms. One central problem was that the configuration syntax was inelegant at best, even after the system was merged into the PF configuration.
  </p><p>
    In OpenBSD, which runs development on a strict six month release cycle, the code that would eventually replace ALTQ was introduced gradually over several releases.
  </p><p>
    The first feature to be introduced was always-on, settable priorities with the keyword <tt>prio</tt>.
  </p><p>
    A random example shows that this configuration prioritises <tt>ssh</tt> traffic above most others (the default is 3):
    </p><p>
    <code>
      pass proto tcp to port ssh set prio 6
    </code>
    </p><p>
      While this configuration makes an attempt at speeding up TCP traffic by assigning a higher priority to lowdelay packets, typically ACKs:
    </p><pre><code>  match out on $ext_if proto tcp from $ext_if set prio (3, 7)
  match in  on $ext_if proto tcp to $ext_if set prio (3, 7)
	</code></pre><p>
Next up, the <i>newqueue</i> code did away with the multiple algorithms approach and settled on the <i><a href="https://en.wikipedia.org/wiki/Hierarchical_fair-service_curve">Hierarchical fair-service curve</a></i> (HFSC) as the most flexible option that would even make it possible to emulate or imitate the alternative shaping algorithms from the ALTQ experiment. 
</p><p>
  HFSC queues are defined on an interface with a hierarchy of child queues, where only the “leaf” queues can be assigned traffic. We take a look at a static allocation first:
</p><pre><code>  queue main on $ext_if bandwidth 20M
    queue defq parent main bandwidth 3600K default
    queue ftp parent main bandwidth 2000K
    queue udp parent main bandwidth 6000K
    queue web parent main bandwidth 4000K
    queue ssh parent main bandwidth 4000K
      queue ssh_interactive parent ssh bandwidth 800K
      queue ssh_bulk parent ssh bandwidth 3200K
    queue icmp parent main bandwidth 400K
  </code></pre><p>
  You then tie in the queue assignment, here with <tt>match</tt> rules
</p><pre><code>  match log quick on $ext_if proto tcp to port ssh \
        queue (ssh_bulk, ssh_interactive)
  match in quick on $ext_if proto tcp to port ftp queue ftp
  match in quick on $ext_if proto tcp to port www queue http
  match out on $ext_if proto udp queue udp
  match out on $ext_if proto icmp queue icmp
  </code></pre><p>
  which is definitely the way to add queueing to an existing configuration, and in my view also a good practice for configuration structure reasons. But you can also tack on <tt>queue this_or_that_queue</tt> at the end of <tt>pass</tt> rules.
</p><p>
  There are two often forgotten facts about HFSC traffic shaping I would like to mention:
</p><p>
  Traffic shaping is more often than not a matter of prioritizing which traffic you drop packets for, and no shaping at all takes place before the traffic volume approaches one or more of the limits set by the queue definitions.
</p><p>
  One of the beautiful things about modern HFSC queueing is that you can build in flexibility, like this:
</p><pre><code>  queue rootq on $ext_if bandwidth 20M
    queue main parent rootq bandwidth 20479K min 1M max 20479K qlimit 100
    queue qdef parent main bandwidth 9600K min 6000K max 18M default
    queue qweb parent main bandwidth 9600K min 6000K max 18M
    queue qpri parent main bandwidth 700K min 100K max 1200K
    queue qdns parent main bandwidth 200K min 12K burst 600K for 3000ms
    queue spamd parent rootq bandwidth 1K min 0K max 1K qlimit 300
  </code></pre><p><code>
  </code>
  The min and max values are core to that flexibility. Subordinate queues can &#39;borrow&#39; bandwidth up to their own max values within the allocation of the parent queue. The combined max queue bandwidth can exceed the root queue&#39;s bandwith and still be valid. However the allocation will always top out at the allocated or the actual physical limits of the interface the queue is configured on.
  </p><p>
For bursty services such as DNS in our example you can allow <tt>burst</tt> for a specified time where the allocation can exceed the queue&#39;s <tt>max</tt> value, still within the limits set on the parent queue.
	</p><p>
Finally, the <tt>qlimit</tt> sets the size of the queue&#39;s holding buffer. A larger buffer <i>may</i> lead to delays since it packets may be kept longer in the buffer before sending on their way out to the world.
	</p><p>
	  And if you noticed the name of that final, tiny queue, you probably have guessed correctly what it was for. The traffic from hosts that were caught in the <tt>spamd</tt> net was really horrible, as this <tt>systat queues</tt> display shows:
	  </p><pre><code> 1 users Load 2.56 2.27 2.28                                      skapet.bsdly.net 20:55:50
 QUEUE                BW SCH  PRI    PKTS   BYTES   DROP_P   DROP_B QLEN BOR SUS  P/S   B/S
 rootq on bge0       20M                0       0        0        0    0            0     0
  main               20M                0       0        0        0    0            0     0
   qdef               9M          6416363   2338M      136    15371    0          462 30733
   qweb               9M           431590 144565K        0        0    0          0.6   480
   qpri               2M          2854556 181684K        5      390    0           79  5243
   qdns             100K           802874  68379K        0        0    0          0.6    52
  spamd               1K           596022  36021K  1177533 72871514  299            2   136
	    </code></pre><p>
It was good, clean fun. And that display did give me a feeling of <i>Mission accomplished</i>.
</p><p>
  There are several other tools in the PF toolset such as <a href="https://man.openbsd.org/carp">carp(4)</a> based redundancy for highly available service, <a href="">relayd(8)</a> for load balancing, application delivery and general network trickery, PF logs and the fact that <a href="https://man.openbsd.org/tcpdump">tcpdump(8)</a> is your friend, and several others that I have enjoyed using but I decided to skip since this was supposed to be a user group talk and a somewhat dense article.
</p><p>
  I would encourage you to explore those topics further via the literature listed under the <i>Resources</i> heading for more on these.
</p><h2>Who Else Uses PF Today?</h2>
<p>
  PF originated in OpenBSD, but word of the new subsystem reached other projects quickly and there was considerable interest from the very start.  Over the years, PF has been ported from the original <a href="https://www.openbsd.org/">OpenBSD</a> to the other BSDs and a few other systems, including
</p><ul>
<li><a href="https://www.freebsd.org">FreeBSD</a></li>

<li><a href="https://www.netbsbsd.org">NetBSD</a></li>

<li><a href="https://www.dragonflybsd.org">DragonFlyBSD</a></li>

<li><a href="https://www.apple.com">Apple</a>&#39;s MacOSX, IOS (via <a href="https://www.freebsd.org">FreeBSD</a>)</li>

<li>Blackberry (via <a href="https://www.netbsbsd.org">NetBSD</a>)</li>

<li><a href="https://www.oracle.com">Oracle</a>, in <a href="http://www.oracle.com/us/products/servers-storage/solaris/solaris11/overview/index.html">Solaris</a> 11.3 as one of two options, from <i>Solaris 12</i> the <a href="https://marc.info/?l=openbsd-tech&amp;m=142822852613581&amp;w=2">only packet filter</a>, replacing IPF. Also see this <a href="http://bsdly.blogspot.ca/2015/04/solaris-admins-for-glimpse-of-your.html">blog post</a> by yours truly.
</li></ul>
<p>
  Other than Oracle with their port to Solaris, most ports of the PF subsystem happened before the OpenBSD 4.7 NAT rewrite, and for that reason they have kept the previous syntax intact.
</p><p>
  There may very well be others. There is no duty to actually advertise the fact that you have incorporated BSD licensed code in your product.
</p><p>
  If you find other products using PF or other <a href="https://www.openbsd.org/">OpenBSD</a> code in the wild, I am interested in hearing from you about it. Please comment or send email to <a href="mailto:nix@nxdomain.no">nix at nxdomain dot no</a>.
</p><h2>Resources for Further Exploration</h2>
<p>
  <a href="https://www.openbsd.org/faq/pf/index.html">The PF User&#39;s Guide</a>
</p><p>
  <a href="https://nostarch.com/pf3">The Book of PF</a> by Peter N. M. Hansteen
</p><p>
  <a href="https://nostarch.com/openbsd2e">Absolute OpenBSD</a> by Michael Lucas
</p><p>
  <a href="https://home.nuug.no/~peter/eurobsdcon2022/">Network Management with the OpenBSD Packet Filter toolset</a>, by Peter N. M. Hansteen, Massimiliano Stucchi and Tom Smyth (A PF tutorial, this is the <a href="https://2022.eurobsdcon.org">EuroBSDCon 2022</a> edition). An earlier, even more extensive set of slides can be found in the <a href="https://home.nuug.no/~peter/pf/newest/">2016-vintage PF tutorial</a>.
</p><p>
  <a href="https://bsdly.blogspot.com/">That Grumpy BSD Guy</a> Blog posts by Peter N. M. Hansteen
</p><p>
<a href="https://undeadly.org/">OpenBSD Journal</a> News items about <a href="https://www.openbsd.org">OpenBSD</a>, generally short with references to material elsewhere.
</p>

</div></div>
  </body>
</html>
