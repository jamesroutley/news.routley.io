<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mindhub365.com/sql/postgresql-streaming-replication-wal-what-it-is-and-how-to-configure-one/">Original</a>
    <h1>PostgreSQL Streaming Replication (WAL); What It Is and How to Configure One</h1>
    
    <div id="readability-page-1" class="page"><div>
                <div>

                    
                    <p><img src="https://db32393711be2a93bcb07d997ff0daed.r2.cloudflarestorage.com/mindhub365/media/images/pg_replication.2e16d0ba.fill-800x400.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=e42d293f04f4efad131e9fdee77b8f02%2F20241012%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20241012T182013Z&amp;X-Amz-Expires=3600&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=cacccdfe796ab911be1306139fa84374747641feb44fc877799ba9d794de2127" alt=""/>
                    </p>

                    
                        
                            <h2 data-block-key="hwpsk">What is Streaming replication in PostgreSQL?</h2><p data-block-key="fgj4a">Streaming replication in PostgreSQL is an efficient method for maintaining a near real-time replica of a primary database on one or more standby servers. The primary server continuously sends Write-Ahead Log (WAL) records to standby servers as they are generated, ensuring minimal latency in the replication process. This approach is designed to enhance high availability and scalability, allowing read queries to be offloaded to standby servers, thereby reducing the load on the primary server. Streaming replication supports both synchronous and asynchronous modes, enabling flexibility in balancing data consistency with performance. The process involves the standby server connecting to the primary, requesting WAL streaming, and applying the received records to its own copy of the database. This method provides faster failover and reduces the risk of data loss compared to file-based log shipping, making it ideal for geographically distributed environments.</p>
                        
                    
                        
                            <h2 data-block-key="hwpsk">How Is Streaming Replication Done?</h2><p data-block-key="aj56m">Streaming replication works by continuously transferring Write-Ahead Log (WAL) data from the primary server to the standby server in real-time, keeping the standby&#39;s database nearly identical to the primary. This can be used for master failover or for using replicas to handle read operations, allowing your system to scale by orders of magnitude.</p>
                        
                    
                        
                            <h2 data-block-key="hwpsk">Lets Start With PostgreSQL Configuration Files And Where To Find Them?</h2><p data-block-key="7so5c">PostgreSQL configuration files play a crucial role in managing the settings and behavior of the database server. The primary configuration file, `postgresql.conf`, contains most server settings and can be found in different locations depending on the operating system, such as `/etc/postgresql/&lt;version&gt;/main/postgresql.conf` on Debian/Ubuntu and `/var/lib/pgsql/&lt;version&gt;/data/postgresql.conf` on Red Hat/CentOS. Another key file is `pg_hba.conf`, which controls client authentication by defining how clients can connect to the server.</p><p data-block-key="efnfs">This file is typically located in the same directory as `postgresql.conf`. Additionally, `pg_ident.conf` is used for username mapping but is less commonly utilized. For versions prior to PostgreSQL 12, `recovery.conf` was used for configuring standby servers, but its contents have since been moved into `postgresql.conf` and `postgresql.auto.conf`, which stores configuration parameters set by `ALTER SYSTEM` commands.</p><p data-block-key="8qha4">The exact locations of these files can vary based on the operating system, installation method, and PostgreSQL version. To locate these files, the SQL command `SHOW config_file;` can be used within a PostgreSQL instance.</p>
                        
                    
                        
                            
<pre><code id="target-element-current">postgres=# SHOW config_file;
               config_file                
------------------------------------------
 /var/lib/postgresql/data/postgresql.conf</code></pre>

                        
                    
                        
                            <h2 data-block-key="hwpsk">List Of Configuration Files And For What They Are Used</h2><p data-block-key="b6umi"><b><code>postgresql.conf</code></b></p><ul><li data-block-key="c4os6">Primary configuration file</li><li data-block-key="bjfoq">Contains most server settings</li><li data-block-key="3ntgd">Typical locations:<ul><li data-block-key="c2dki"><code>/etc/postgresql/&lt;version&gt;/main/</code> (Debian/Ubuntu)</li><li data-block-key="fl9h7"><code>/var/lib/pgsql/&lt;version&gt;/data/</code> (Red Hat/CentOS)</li><li data-block-key="jd86"><code>C:\Program Files\PostgreSQL&lt;version&gt;\data</code> (Windows)</li></ul></li></ul><p data-block-key="2gkcs"><b><code>pg_hba.conf</code></b><br/></p><ul><li data-block-key="1rdoh">Controls client authentication</li><li data-block-key="69q6v">Defines how clients are allowed to connect to the server</li><li data-block-key="1tjue">Usually in the same directory as <code>postgresql.conf<br/></code></li></ul><p data-block-key="7su52"><b><code>pg_ident.conf</code></b><br/></p><ul><li data-block-key="3evfm">Used for user name mapping</li><li data-block-key="3618f">Often in the same directory as <code>postgresql.conf</code></li><li data-block-key="d1an1">Less commonly used<br/></li></ul><p data-block-key="dkmuq"><b><code>recovery.conf</code></b><b> (for versions prior to 12)</b><br/></p><ul><li data-block-key="9ga5o">Used to configure standby servers and recovery settings</li><li data-block-key="7oqqd">In PostgreSQL 12 and later, its contents are moved into <code>postgresql.conf</code> and <code>postgresql.auto.conf</code></li><li data-block-key="9s5k6"><b><code>postgresql.auto.conf</code></b><br/></li><li data-block-key="4en3k">Stores configuration parameters set by <code>ALTER SYSTEM</code> commands</li><li data-block-key="3c43s">Automatically managed by PostgreSQL</li><li data-block-key="9g5ad">In the same directory as <code>postgresql.conf<br/></code></li></ul><p data-block-key="bb60n"><b>The exact locations can vary depending on:</b><br/></p><ul><li data-block-key="e3au9">Operating system</li><li data-block-key="390u7">Installation method</li><li data-block-key="er3nh">PostgreSQL version</li></ul>
                        
                    
                        
                            <h2 data-block-key="oqs8q">Examples of WAL (Write ahead logs) And How They Look Like</h2><p data-block-key="bik2g">you can see them using <code>pg_waldump</code> command:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">pg_waldump /var/lib/postgresql/data/pg_wal/000000010000000000000001</code></pre>

                        
                    
                        
                            
<pre><code id="target-element-current">...
rmgr: Standby     len (rec/tot):     42/    42, tx:       1738, lsn: 0/01938698, prev 0/01938668, desc: LOCK xid 1738 db 5 rel 18065 
rmgr: Heap        len (rec/tot):    203/   203, tx:       1738, lsn: 0/019386C8, prev 0/01938698, desc: INSERT off: 12, flags: 0x00, blkref #0: rel 1663/5/1259 blk 25
rmgr: Btree       len (rec/tot):     64/    64, tx:       1738, lsn: 0/01938798, prev 0/019386C8, desc: INSERT_LEAF off: 394, blkref #0: rel 1663/5/2662 blk 4
rmgr: Btree       len (rec/tot):    112/   112, tx:       1738, lsn: 0/019387D8, prev 0/01938798, desc: INSERT_LEAF off: 110, blkref #0: rel 1663/5/2663 blk 1
rmgr: Btree       len (rec/tot):     64/    64, tx:       1738, lsn: 0/01938848, prev 0/019387D8, desc: INSERT_LEAF off: 229, blkref #0: rel 1663/5/3455 blk 4
rmgr: Heap2       len (rec/tot):    176/   176, tx:       1738, lsn: 0/01938888, prev 0/01938848, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [36], blkref #0: rel 1663/5/1249 blk 113
rmgr: Btree       len (rec/tot):     80/    80, tx:       1738, lsn: 0/01938938, prev 0/01938888, desc: INSERT_LEAF off: 61, blkref #0: rel 1663/5/2658 blk 28
rmgr: Btree       len (rec/tot):     64/    64, tx:       1738, lsn: 0/01938988, prev 0/01938938, desc: INSERT_LEAF off: 319, blkref #0: rel 1663/5/2659 blk 18
rmgr: Heap        len (rec/tot):    197/   197, tx:       1738, lsn: 0/019389C8, prev 0/01938988, desc: INSERT off: 23, flags: 0x00, blkref #0: rel 1663/5/2610 blk 11
rmgr: Btree       len (rec/tot):     64/    64, tx:       1738, lsn: 0/01938A90, prev 0/019389C8, desc: INSERT_LEAF off: 200, blkref #0: rel 1663/5/2678 blk 1
rmgr: Btree       len (rec/tot):     64/    64, tx:       1738, lsn: 0/01938AD0, prev 0/01938A90, desc: INSERT_LEAF off: 180, blkref #0: rel 1663/5/2679 blk 2
rmgr: Heap2       len (rec/tot):     85/    85, tx:       1738, lsn: 0/01938B10, prev 0/01938AD0, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [132], blkref #0: rel 1663/5/2608 blk 26
rmgr: Btree       len (rec/tot):     72/    72, tx:       1738, lsn: 0/01938B68, prev 0/01938B10, desc: INSERT_LEAF off: 233, blkref #0: rel 1663/5/2673 blk 20
rmgr: Btree       len (rec/tot):     72/    72, tx:       1738, lsn: 0/01938BB0, prev 0/01938B68, desc: INSERT_LEAF off: 43, blkref #0: rel 1663/5/2674 blk 12
rmgr: XLOG        len (rec/tot):     49/   209, tx:       1738, lsn: 0/01938BF8, prev 0/01938BB0, desc: FPI , blkref #0: rel 1663/5/18065 blk 1 FPW
rmgr: XLOG        len (rec/tot):     49/   137, tx:       1738, lsn: 0/01938CD0, prev 0/01938BF8, desc: FPI , blkref #0: rel 1663/5/18065 blk 0 FPW
rmgr: Heap        len (rec/tot):    188/   188, tx:       1738, lsn: 0/01938D60, prev 0/01938CD0, desc: INPLACE off: 12, blkref #0: rel 1663/5/1259 blk 25
rmgr: Transaction len (rec/tot):    242/   242, tx:       1738, lsn: 0/01938E20, prev 0/01938D60, desc: COMMIT 2024-10-02 21:47:28.453226 UTC; inval msgs: catcache 55 catcache 54 catcache 7 catcache 6 catcache 32 catcache 55 catcache 54 relcache 18065 relcache 17640 snapshot 2608 relcache 17640 relcache 18065
rmgr: Storage     len (rec/tot):     42/    42, tx:          0, lsn: 0/01938F18, prev 0/01938E20, desc: CREATE base/5/18066
rmgr: Standby     len (rec/tot):     42/    42, tx:       1739, lsn: 0/01938F48, prev 0/01938F18, desc: LOCK xid 1739 db 5 rel 18066 
rmgr: Heap        len (rec/tot):    203/   203, tx:       1739, lsn: 0/01938F78, prev 0/01938F48, desc: INSERT off: 13, flags: 0x00, blkref #0: rel 1663/5/1259 blk 25
rmgr: Btree       len (rec/tot):     64/    64, tx:       1739, lsn: 0/01939048, prev 0/01938F78, desc: INSERT_LEAF off: 395, blkref #0: rel 1663/5/2662 blk 4
rmgr: Btree       len (rec/tot):    104/   104, tx:       1739, lsn: 0/01939088, prev 0/01939048, desc: INSERT_LEAF off: 116, blkref #0: rel 1663/5/2663 blk 1
rmgr: Btree       len (rec/tot):     64/    64, tx:       1739, lsn: 0/019390F0, prev 0/01939088, desc: INSERT_LEAF off: 230, blkref #0: rel 1663/5/3455 blk 4
rmgr: Heap2       len (rec/tot):    176/   176, tx:       1739, lsn: 0/01939130, prev 0/019390F0, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [37], blkref #0: rel 1663/5/1249 blk 113
rmgr: Btree       len (rec/tot):     72/    72, tx:       1739, lsn: 0/019391E0, prev 0/01939130, desc: INSERT_LEAF off: 62, blkref #0: rel 1663/5/2658 blk 28
rmgr: Btree       len (rec/tot):     64/    64, tx:       1739, lsn: 0/01939228, prev 0/019391E0, desc: INSERT_LEAF off: 320, blkref #0: rel 1663/5/2659 blk 18
rmgr: Heap        len (rec/tot):    197/   197, tx:       1739, lsn: 0/01939268, prev 0/01939228, desc: INSERT off: 24, flags: 0x00, blkref #0: rel 1663/5/2610 blk 11
rmgr: Btree       len (rec/tot):     64/    64, tx:       1739, lsn: 0/01939330, prev 0/01939268, desc: INSERT_LEAF off: 201, blkref #0: rel 1663/5/2678 blk 1
rmgr: Btree       len (rec/tot):     64/    64, tx:       1739, lsn: 0/01939370, prev 0/01939330, desc: INSERT_LEAF off: 181, blkref #0: rel 1663/5/2679 blk 2
rmgr: Heap2       len (rec/tot):     85/    85, tx:       1739, lsn: 0/019393B0, prev 0/01939370, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [133], blkref #0: rel 1663/5/2608 blk 26
rmgr: Btree       len (rec/tot):     72/    72, tx:       1739, lsn: 0/01939408, prev 0/019393B0, desc: INSERT_LEAF off: 234, blkref #0: rel 1663/5/2673 blk 20
rmgr: Btree       len (rec/tot):     72/    72, tx:       1739, lsn: 0/01939450, prev 0/01939408, desc: INSERT_LEAF off: 44, blkref #0: rel 1663/5/2674 blk 12
rmgr: XLOG        len (rec/tot):     49/   205, tx:       1739, lsn: 0/01939498, prev 0/01939450, desc: FPI , blkref #0: rel 1663/5/18066 blk 1 FPW
rmgr: XLOG        len (rec/tot):     49/   137, tx:       1739, lsn: 0/01939568, prev 0/01939498, desc: FPI , blkref #0: rel 1663/5/18066 blk 0 FPW
rmgr: Heap        len (rec/tot):    188/   188, tx:       1739, lsn: 0/019395F8, prev 0/01939568, desc: INPLACE off: 13, blkref #0: rel 1663/5/1259 blk 25
rmgr: Transaction len (rec/tot):    242/   242, tx:       1739, lsn: 0/019396B8, prev 0/019395F8, desc: COMMIT 2024-10-02 21:47:28.457807 UTC; inval msgs: catcache 55 catcache 54 catcache 7 catcache 6 catcache 32 catcache 55 catcache 54 relcache 18066 relcache 17640 snapshot 2608 relcache 17640 relcache 18066
...</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">Let me break down some key aspects of this WAL output</p><p data-block-key="7vq74">- Structure: Each line represents a WAL record, containing information about database operations.</p><p data-block-key="pjg8">- Components of each record:</p><ul><li data-block-key="apuc9">- rmgr: Resource manager (e.g., Heap, Btree, Transaction)</li><li data-block-key="auf3d">- len: Length of the record</li><li data-block-key="61vch">- tx: Transaction ID</li><li data-block-key="fbgsu">- lsn: Log Sequence Number</li><li data-block-key="6k0cr">- prev: Previous LSN</li><li data-block-key="3bgic">- desc: Description of the operation</li><li data-block-key="a4ats"></li></ul><p data-block-key="fpq3c">- Types of operations visible:</p><ul><li data-block-key="d6foc">- INSERT operations (Heap and Btree)</li><li data-block-key="fukup">- MULTI_INSERT operations (Heap2)</li><li data-block-key="fqjr5">- COMMIT transactions</li><li data-block-key="4uoqu">- File operations (CREATE)</li><li data-block-key="59h3u">- Full Page Writes (FPW)</li></ul><p data-block-key="b1bko">- Specific examples:</p><ul><li data-block-key="hfnp">- Table inserts: `rmgr: Heap len (rec/tot): 203/203, tx: 1738, lsn: 0/019386C8, prev 0/01938698, desc: INSERT off: 12, flags: 0x00, blkref #0: rel 1663/5/1259 blk 25`</li><li data-block-key="2nr4r">- Index updates: `rmgr: Btree len (rec/tot): 64/ 64, tx: 1738, lsn: 0/01938798, prev 0/019386C8, desc: INSERT_LEAF off: 394, blkref #0: rel 1663/5/2662 blk 4`</li><li data-block-key="cosq2">- Transaction commit: `rmgr: Transaction len (rec/tot): 242/ 242, tx: 1738, lsn: 0/01938E20, prev 0/01938D60, desc: COMMIT 2024-10-02 21:47:28.453226 UTC;`</li></ul><p data-block-key="dosoi">This WAL output provides a detailed view of the database operations, allowing for analysis of transaction flow, data modifications, and system activities. It&#39;s particularly useful for understanding database behavior, troubleshooting, and in some cases, for point-in-time recovery.</p>
                        
                    
                        
                            <h2 data-block-key="oqs8q">How to work with them using docker</h2>
                        
                    
                        
                            <p data-block-key="oqs8q">In <b><code>postgresql.conf</code></b>, specific settings are crucial for enabling streaming replication. These settings control how the master and replica instances communicate and synchronize. You will need to modify this configuration for both the master and the replica. Here is the snippet from postgresql.conf related to streaming replication:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">...
# REPLICATION
#------------------------------------------------------------------------------

# - Sending Servers -

# Set these on the primary and on any standby that will send replication data.

#max_wal_senders = 10           # max number of walsender processes
                                # (change requires restart)
#max_replication_slots = 10     # max number of replication slots
                                # (change requires restart)
#wal_keep_size = 0              # in megabytes; 0 disables
#max_slot_wal_keep_size = -1    # in megabytes; -1 disables
#wal_sender_timeout = 60s       # in milliseconds; 0 disables
#track_commit_timestamp = off   # collect timestamp of transaction commit
                                # (change requires restart)

# - Primary Server -

# These settings are ignored on a standby server.

#synchronous_standby_names = &#39;&#39; # standby servers that provide sync rep
                                # method to choose sync standbys, number of sync standbys,
                                # and comma-separated list of application_name
                                # from standby(s); &#39;*&#39; = all

# - Standby Servers -

# These settings are ignored on a primary server.

#primary_conninfo = &#39;&#39;                  # connection string to sending server
#primary_slot_name = &#39;&#39;                 # replication slot on sending server
#hot_standby = on                       # &#34;off&#34; disallows queries during recovery
                                        # (change requires restart)
#max_standby_archive_delay = 30s        # max delay before canceling queries
                                        # when reading WAL from archive;
                                        # -1 allows indefinite delay
#max_standby_streaming_delay = 30s      # max delay before canceling queries
                                        # when reading streaming WAL;
                                        # -1 allows indefinite delay
#wal_receiver_create_temp_slot = off    # create temp slot if primary_slot_name
                                        # is not set
#wal_receiver_status_interval = 10s     # send replies at least this often
                                        # 0 disables
#hot_standby_feedback = off             # send info from standby to prevent
                                        # query conflicts
#wal_receiver_timeout = 60s             # time that receiver waits for
                                        # communication from primary
                                        # in milliseconds; 0 disables
#wal_retrieve_retry_interval = 5s       # time to wait before retrying to
                                        # retrieve WAL after a failed attempt
#recovery_min_apply_delay = 0           # minimum delay for applying changes during recovery

# - Subscribers -
# These settings are ignored on a publisher.

#max_logical_replication_workers = 4    # taken from max_worker_processes
                                        # (change requires restart)
#max_sync_workers_per_subscription = 2  # taken from max_logical_replication_workers
#max_parallel_apply_workers_per_subscription = 2        # taken from max_logical_replication_workers
...</code></pre>

                        
                    
                        
                            <h2 data-block-key="oqs8q">Let&#39;s Dive Into Docker Compose Example</h2><p data-block-key="ft3k9">What you will need is:</p><ul><li data-block-key="4oav0"><code>init-master.sh:</code></li><li data-block-key="3dfgd"><code>init-replica.sh</code></li><li data-block-key="f1vlf"><code>start-replica.sh</code></li><li data-block-key="birf0"><code>docker-compose.yml</code></li></ul>
                        
                    
                        
                            <p data-block-key="oqs8q">init-master.sh:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">#!/bin/bash
set -e

psql -v ON_ERROR_STOP=1 --username &#34;$POSTGRES_USER&#34; --dbname &#34;$POSTGRES_DB&#34; &lt;&lt;-EOSQL
  CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD &#39;replicatorpass&#39;;
  SELECT pg_create_physical_replication_slot(&#39;replica_slot&#39;);
EOSQL

cat &gt;&gt; ${PGDATA}/postgresql.conf &lt;&lt;EOF
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
hot_standby = on
EOF

cat &gt;&gt; ${PGDATA}/pg_hba.conf &lt;&lt;EOF
host replicat</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">sets up a PostgreSQL master for replication. It connects to the PostgreSQL server using the provided environment variables for username and database, then creates a replication user (`replicator`) with the necessary permissions. It also creates a replication slot (`replica_slot`) to track the replication process. Next, the script configures PostgreSQL by appending settings to `postgresql.conf`, enabling WAL (Write-Ahead Logging) for replication, setting up replication slots, and enabling hot standby for read-only queries. It also updates `pg_hba.conf` to allow the replication user to connect.</p>
                        
                    
                        
                            <p data-block-key="oqs8q">init-replica.sh</p>
                        
                    
                        
                            
<pre><code id="target-element-current">#!/bin/bash
set -e

echo &#34;Waiting for master to be ready...&#34;
until PGPASSWORD=mypassword psql -h postgres_master -U myuser -d mydb -c &#39;\l&#39; &gt;/dev/null 2&gt;&amp;1; do
  echo &#34;Still waiting...&#34;
  sleep 1
done
echo &#34;Master is ready. Attempting to take base backup...&#34;

# Stop PostgreSQL if it&#39;s running
pg_ctl -D &#34;$PGDATA&#34; -m fast -w stop || true

# Remove existing data directory contents
rm -rf $PGDATA/*

PGPASSWORD=replicatorpass pg_basebackup -h postgres_master -D ${PGDATA} -U replicator -v -P --wal-method=stream

echo &#34;Base backup completed. Configuring replica...&#34;

cat &gt;&gt; ${PGDATA}/postgresql.conf &lt;&lt;EOF
hot_standby = on
EOF

cat &gt; ${PGDATA}/postgresql.auto.conf &lt;&lt;EOF
primary_conninfo = &#39;host=postgres_master port=5432 user=replicator password=replicatorpass application_name=replica1&#39;
EOF

touch ${PGDATA}/standby.signal

echo &#34;Replica configuration complete.&#34;</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">prepares a PostgreSQL replica to connect to the master and start replication. It waits until the master is fully up and running by continuously checking the connection to the master database. Once the master is ready, it stops the local PostgreSQL instance (if running), removes existing data, and performs a base backup from the master using `pg_basebackup`. After the backup is complete, it configures the replica by enabling `hot_standby` for read-only queries and setting the connection info for the master (including host, user, and password). Finally, it signals PostgreSQL that this instance should act as a standby by creating the `standby.signal` file.</p>
                        
                    
                        
                            <p data-block-key="oqs8q">start-replica.sh</p>
                        
                    
                        
                            
<pre><code id="target-element-current">#!/bin/bash
set -e

# Run the init-replica.sh script
/docker-entrypoint-initdb.d/init-replica.sh

# Start PostgreSQL
exec docker-entrypoint.sh postgres</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">is used to start a PostgreSQL replica in a Docker container. It first runs the `init-replica.sh` script to handle the initialization and setup of the replication process. After initializing the replica, the script starts PostgreSQL using the default Docker entrypoint (`docker-entrypoint.sh`) with `postgres` as the argument to run the PostgreSQL service inside the container. The `set -e` ensures that the script exits immediately if any command returns a non-zero status (i.e., on error).</p>
                        
                    
                        
                            <p data-block-key="oqs8q">docker-compose.yml</p>
                        
                    
                        
                            
<pre><code id="target-element-current">services:
  postgres_master:
    image: postgres:14
    container_name: postgres_master
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
    volumes:
      - ./pgdata_master:/var/lib/postgresql/data
      - ./init-master.sh:/docker-entrypoint-initdb.d/init-master.sh
    ports:
      - &#34;5432:5432&#34;

  postgres_replica:
    image: postgres:14
    container_name: postgres_replica
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
    volumes:
      - ./pgdata_replica:/var/lib/postgresql/data
      - ./init-replica.sh:/docker-entrypoint-initdb.d/init-replica.sh
      - ./start-replica.sh:/start-replica.sh
    ports:
      - &#34;5433:5432&#34;
    depends_on:
      - postgres_master
    command: [&#34;/start-replica.sh&#34;]</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">Make the scripts executable (init-master.sh, init-replica.sh, start-replica.sh) with:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">chmod +x ....scripts</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">And when you run</p>
                        
                    
                        
                            
<pre><code id="target-element-current">docker-compose up -d</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">You should see this output:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">Attaching to postgres_master, postgres_replica
postgres_master   | The files belonging to this database system will be owned by user &#34;postgres&#34;.
postgres_master   | This user must also own the server process.
postgres_master   | 
postgres_master   | The database cluster will be initialized with locale &#34;en_US.utf8&#34;.
postgres_master   | The default database encoding has accordingly been set to &#34;UTF8&#34;.
postgres_master   | The default text search configuration will be set to &#34;english&#34;.
postgres_master   | 
postgres_master   | Data page checksums are disabled.
postgres_master   | 
postgres_master   | fixing permissions on existing directory /var/lib/postgresql/data ... ok
postgres_master   | creating subdirectories ... ok
postgres_master   | selecting dynamic shared memory implementation ... posix
postgres_master   | selecting default max_connections ... 100
postgres_master   | selecting default shared_buffers ... 128MB
postgres_master   | selecting default time zone ... Etc/UTC
postgres_master   | creating configuration files ... ok
postgres_master   | running bootstrap script ... ok
postgres_replica  | Waiting for master to be ready...
postgres_replica  | Still waiting...
postgres_master   | performing post-bootstrap initialization ... ok
postgres_master   | initdb: warning: enabling &#34;trust&#34; authentication for local connections
postgres_master   | You can change this by editing pg_hba.conf or using the option -A, or
postgres_master   | --auth-local and --auth-host, the next time you run initdb.
postgres_master   | syncing data to disk ... ok
postgres_master   | 
postgres_master   | 
postgres_master   | Success. You can now start the database server using:
postgres_master   | 
postgres_master   |     pg_ctl -D /var/lib/postgresql/data -l logfile start
postgres_master   | 
postgres_master   | waiting for server to start....2024-10-10 19:12:07.091 UTC [49] LOG:  starting PostgreSQL 14.9 (Debian 14.9-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
postgres_master   | 2024-10-10 19:12:07.095 UTC [49] LOG:  listening on Unix socket &#34;/var/run/postgresql/.s.PGSQL.5432&#34;
postgres_master   | 2024-10-10 19:12:07.106 UTC [50] LOG:  database system was shut down at 2024-10-10 19:12:06 UTC
postgres_master   | 2024-10-10 19:12:07.114 UTC [49] LOG:  database system is ready to accept connections
postgres_master   |  done
postgres_master   | server started
postgres_master   | CREATE DATABASE
postgres_master   | 
postgres_master   | 
postgres_master   | /usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/init-master.sh
postgres_master   | CREATE ROLE
postgres_master   |  pg_create_physical_replication_slot 
postgres_master   | -------------------------------------
postgres_master   |  (replica_slot,)
postgres_master   | (1 row)
postgres_master   | 
postgres_master   | 
postgres_master   | waiting for server to shut down....2024-10-10 19:12:07.384 UTC [49] LOG:  received fast shutdown request
postgres_master   | 2024-10-10 19:12:07.389 UTC [49] LOG:  aborting any active transactions
postgres_master   | 2024-10-10 19:12:07.392 UTC [49] LOG:  background worker &#34;logical replication launcher&#34; (PID 56) exited with exit code 1
postgres_master   | 2024-10-10 19:12:07.392 UTC [51] LOG:  shutting down
postgres_master   | 2024-10-10 19:12:07.419 UTC [49] LOG:  database system is shut down
postgres_master   |  done
postgres_master   | server stopped
postgres_master   | 
postgres_master   | PostgreSQL init process complete; ready for start up.
postgres_master   | 
postgres_master   | 2024-10-10 19:12:07.527 UTC [1] LOG:  starting PostgreSQL 14.9 (Debian 14.9-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
postgres_master   | 2024-10-10 19:12:07.527 UTC [1] LOG:  listening on IPv4 address &#34;0.0.0.0&#34;, port 5432
postgres_master   | 2024-10-10 19:12:07.527 UTC [1] LOG:  listening on IPv6 address &#34;::&#34;, port 5432
postgres_master   | 2024-10-10 19:12:07.533 UTC [1] LOG:  listening on Unix socket &#34;/var/run/postgresql/.s.PGSQL.5432&#34;
postgres_master   | 2024-10-10 19:12:07.540 UTC [69] LOG:  database system was shut down at 2024-10-10 19:12:07 UTC
postgres_master   | 2024-10-10 19:12:07.552 UTC [1] LOG:  database system is ready to accept connections
postgres_replica  | Master is ready. Attempting to take base backup...
postgres_replica  | pg_ctl: cannot be run as root
postgres_replica  | Please log in (using, e.g., &#34;su&#34;) as the (unprivileged) user that will
postgres_replica  | own the server process.
postgres_replica  | pg_basebackup: initiating base backup, waiting for checkpoint to complete
postgres_replica  | pg_basebackup: checkpoint completed
postgres_replica  | pg_basebackup: write-ahead log start point: 0/2000028 on timeline 1
postgres_replica  | pg_basebackup: starting background WAL receiver
postgres_replica  | pg_basebackup: created temporary replication slot &#34;pg_basebackup_78&#34;
postgres_replica  |     0/34859 kB (0%), 0/1 tablespace (...lib/postgresql/data/backup_label)
postgres_replica  | 27884/34859 kB (79%), 0/1 tablespace (.../postgresql/data/base/16384/1247)
postgres_replica  | 34868/34868 kB (100%), 0/1 tablespace (...ostgresql/data/global/pg_control)
postgres_replica  | 34868/34868 kB (100%), 1/1 tablespace                                         
postgres_replica  | pg_basebackup: write-ahead log end point: 0/2000100
postgres_replica  | pg_basebackup: waiting for background process to finish streaming ...
postgres_replica  | pg_basebackup: syncing data to disk ...
postgres_replica  | pg_basebackup: renaming backup_manifest.tmp to backup_manifest
postgres_replica  | pg_basebackup: base backup completed
postgres_replica  | Base backup completed. Configuring replica...
postgres_replica  | Replica configuration complete.
postgres_replica  | 
postgres_replica  | PostgreSQL Database directory appears to contain a database; Skipping initialization
postgres_replica  | 
postgres_replica  | 2024-10-10 19:12:08.283 UTC [1] LOG:  starting PostgreSQL 14.9 (Debian 14.9-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
postgres_replica  | 2024-10-10 19:12:08.284 UTC [1] LOG:  listening on IPv4 address &#34;0.0.0.0&#34;, port 5432
postgres_replica  | 2024-10-10 19:12:08.284 UTC [1] LOG:  listening on IPv6 address &#34;::&#34;, port 5432
postgres_replica  | 2024-10-10 19:12:08.290 UTC [1] LOG:  listening on Unix socket &#34;/var/run/postgresql/.s.PGSQL.5432&#34;
postgres_replica  | 2024-10-10 19:12:08.299 UTC [39] LOG:  database system was interrupted; last known up at 2024-10-10 19:12:07 UTC
postgres_replica  | 2024-10-10 19:12:08.394 UTC [39] LOG:  entering standby mode
postgres_replica  | 2024-10-10 19:12:08.400 UTC [39] LOG:  redo starts at 0/2000028
postgres_replica  | 2024-10-10 19:12:08.403 UTC [39] LOG:  consistent recovery state reached at 0/2000100
postgres_replica  | 2024-10-10 19:12:08.404 UTC [1] LOG:  database system is ready to accept read-only connections
postgres_replica  | 2024-10-10 19:12:08.426 UTC [43] LOG:  started streaming WAL from primary at 0/3000000 on timeline 1</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">Now let&#39;s verify the setup...</p><p data-block-key="3cims">Connect to the master:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">docker exec -it postgres_master psql -U myuser -d mydb</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">and check replication status</p>
                        
                    
                        
                            
<pre><code id="target-element-current">SELECT pid, usename, application_name, client_addr FROM pg_stat_replication;</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">The output will be:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">pid |  usename   | application_name | client_addr 
-----+------------+------------------+-------------
  79 | replicator | replica1         | 172.20.0.3
(1 row)</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">Now lets check the replica</p>
                        
                    
                        
                            
<pre><code id="target-element-current">docker exec -it postgres_replica psql -U myuser -d mydb</code></pre>

                        
                    
                        
                            <p data-block-key="oqs8q">The query and the output:</p>
                        
                    
                        
                            
<pre><code id="target-element-current">mydb=# SELECT pg_is_in_recovery();
 pg_is_in_recovery 
-------------------
 t
(1 row)</code></pre>

                        
                    
                        
                            <p data-block-key="j19th">And with these changes, every modification made on the primary server will be reflected on the replica server in real-time. While this article is a bit lengthy, it’s important to showcase the entire configuration process and outputs. This helps to provide a comprehensive view of the many moving parts involved and gives you a better understanding of what’s happening &#34;under the hood.&#34;</p>
                        
                    
                        
                            <p data-block-key="j19th">Understanding how PostgreSQL streaming replication works and configuring it correctly can greatly enhance your system’s performance and resilience. Whether you’re preparing for failover scenarios or distributing read loads across replicas, these configurations ensure your database infrastructure is ready to scale and perform reliably. Hopefully, this article has demystified the process and given you clearer insight into how replication operates behind the scenes.</p>
                        
                    
                </div>
            </div></div>
  </body>
</html>
