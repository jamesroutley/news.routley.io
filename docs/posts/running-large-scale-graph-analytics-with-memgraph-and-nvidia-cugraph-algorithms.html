<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.nvidia.com/blog/running-large-scale-graph-analytics-with-memgraph-and-nvidia-cugraph-algorithms/">Original</a>
    <h1>Running Large-Scale Graph Analytics with Memgraph and Nvidia CuGraph Algorithms</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>With the latest Memgraph Advanced Graph Extensions (MAGE) release, you can now run GPU-powered graph analytics from Memgraph in seconds, while working in Python.  Powered by NVIDIA cuGraph, the following graph algorithms will now execute on GPU: </p>



<ul><li>PageRank (graph analysis)</li><li>Louvain (community detection)</li><li>Balanced Cut (clustering)</li><li>Spectral Clustering (clustering)</li><li>HITS (hubs versus authorities analytics)</li><li>Leiden (community detection)</li><li>Katz centrality</li><li>Betweenness centrality</li></ul>



<p>This tutorial will show you how to use PageRank graph analysis and Louvain community detection to analyze a Facebook dataset containing 1.3 million relationships.</p>



<p>By the end of the tutorial, you will know how to:</p>



<ul><li>Import data inside Memgraph using Python</li><li>Run analytics on large scale graphs and get fast results</li><li>Run analytics on NVIDIA GPUs from Memgraph</li></ul>



<h2>Tutorial prerequisites</h2>



<p>To follow this graph analytics tutorial, you will need an NVIDIA GPU, driver, and container toolkit. Once you have successfully installed the <a href="https://www.nvidia.co.uk/Download/index.aspx?lang=en-uk" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">NVIDIA GPU driver</a> and container toolkit, you must also install the following four tools:</p>



<ul><li><a href="https://docs.docker.com/get-docker/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Docker</a> for running <code>mage-cugraph</code> image</li><li><a href="https://jupyter.org/install#jupyterlab" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Jupyter</a> for analyzing the graph data</li><li><a href="https://pypi.org/project/gqlalchemy/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">GQLAlchemy</a> to connect Memgraph with Python</li><li><a href="https://memgraph.com/lab" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph Lab</a> for visualizing the graph</li></ul>



<p>The next section walks you through installing and setting up these tools for the tutorial. </p>



<h3>Docker</h3>



<p>Docker is used to install and run the <code>mage-cugraph</code> Docker image. There are three steps involved in setting up and running the Docker image: </p>



<ol><li>Download Docker</li><li>Download the tutorial data</li><li>Run the Docker image, giving it access to the tutorial data</li></ol>



<p><strong>1. Download Docker</strong></p>



<p>You can install Docker by visiting the <a href="https://docs.docker.com/get-docker/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Docker</a> webpage and following the instructions for your operating system. </p>



<p><strong>2. Downloading the tutorial data</strong></p>



<p>Before running the <code>mage-cugraph</code> Docker image, first download the data that will be used in the tutorial. This allows you to give the Docker image access to the tutorial dataset when run.  </p>



<p>To download the data, use the following commands to clone the <a href="https://github.com/memgraph/jupyter-memgraph-tutorials" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer"><strong>jupyter-memgraph-tutorials</strong></a> GitHub repo, and move it to the <code>jupyter-memgraph-tutorials/cugraph-analytics</code> folder:</p>



<pre><code>Git clone https://github.com/memgraph/jupyter-memgraph-tutorials.git
Cd jupyter-memgraph-tutorials/cugraph-analytics</code></pre>



<p><strong>3. Run the Docker image</strong></p>



<p>You can now use the following command to run the Docker image and mount the workshop data to the <code>/samples</code> folder:</p>



<pre><code>docker run -it -p 7687:7687 -p 7444:7444 --volume /data/facebook_clean_data/:/samples mage-cugraph</code></pre>



<p>When you run the Docker container, you should see the following message:</p>



<pre><code>You are running Memgraph vX.X.X
To get started with Memgraph, visit https://memgr.ph/start</code></pre>



<p>With the mount command executed, the <code>CSV</code> files needed for the tutorial will be located inside the <code>/samples</code> folder within the Docker image, where Memgraph will find them when needed.</p>



<h3><strong>Jupyter notebook</strong></h3>



<p>Now that Memgraph is running, install Jupyter<strong>.</strong> This tutorial uses JupyterLab<strong>,</strong> and you can install it with the following command:</p>



<pre><code>pip install jupyterlab</code></pre>



<p>Once JupyterLab is installed, launch it with the following command:</p>



<pre><code>jupyter lab</code></pre>



<h3><strong>GQLAlchemy </strong></h3>



<p>Use<strong> </strong><a href="https://memgraph.com/docs/gqlalchemy/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">GQLAlchemy</a>, an Object Graph Mapper (OGM), to connect to Memgraph and also execute queries in Python. You can think of Cypher as SQL for graph databases. It contains many of the same language constructs such as Create, Update, and Delete. </p>



<p><a href="https://cmake.org/download/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Download CMake</a> on your system, and then you can install GQLAlchemy with pip:</p>



<pre><code>pip install gqlalchemy</code></pre>



<h3><strong>Memgraph Lab </strong></h3>



<p>The last prerequisite you need to install is <a href="https://memgraph.com/lab" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph Lab</a>. You will use it to create data visualizations upon connecting to Memgraph. Learn <a href="https://memgraph.com/docs/memgraph-lab/installation" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">how to install Memgraph Lab</a> as a desktop application for your operating system.</p>



<p>With Memgraph Lab installed, you should now <a href="https://memgraph.com/docs/memgraph-lab/connect-to-memgraph#connecting-to-memgraph" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">connect to your Memgraph database</a>. </p>



<p>At this point, you are finally ready to:</p>



<ul><li>Connect to Memgraph with GQLAlchemy</li><li>Import the dataset</li><li>Run graph analytics in Python</li></ul>



<h2>Connect to Memgraph with GQLAlchemy</h2>



<p>First, position yourself in the <a href="https://github.com/memgraph/jupyter-memgraph-tutorials/blob/main/cugraph-analytics/cugraph_analytics.ipynb" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Jupyter notebook</a>. The first three lines of code will import <code>gqlalchemy</code>, connect to Memgraph database instance via <code>host:127.0.0.1</code> and <code>port:7687</code>, and clear the database. Be sure to start with a clean slate.</p>



<pre><code>from gqlalchemy import Memgraph
memgraph = Memgraph(&#34;127.0.0.1&#34;, 7687)
memgraph.drop_database()
</code></pre>



<p>Import the dataset from CSV files. </p>



<p>Next, you will perform <a href="https://memgraph.com/docs/mage/query-modules/cpp/pagerank" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">PageRank</a> and Louvain community detection using Python.</p>



<h2>Import data</h2>



<p>The <a href="https://snap.stanford.edu/data/gemsec-Facebook.html" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Facebook dataset</a> consists of eight CSV files, each having the following structure:</p>



<pre><code>node_1,node_2
0,1794
0,3102
0,16645
</code></pre>



<p>Each record represents an edge connecting two nodes.  Nodes represent the pages, and relationships are mutual likes among them. </p>



<p>There are eight distinct types of pages (Government, Athletes, and TV shows, for example). Pages have been reindexed for anonymity, and all pages have been verified for authenticity by Facebook. </p>



<p>Since Memgraph imports queries faster when data has indices, create them for all the nodes with the label <code>Page</code> on the <code>id</code> property.</p>



<pre><code>memgraph.execute(
    &#34;&#34;&#34;
    CREATE INDEX ON :Page(id);
    &#34;&#34;&#34;
)
</code></pre>



<p>Docker already has container access to the data used in this tutorial, so you can list through the local files in the <code>./data/facebook_clean_data/</code> folder. By concatenating both the file names and the <code>/samples/</code> folder, you can determine their paths. Use the concatenated file paths to load data into Memgraph.</p>



<pre><code>import os
from os import listdir
from os.path import isfile, join
csv_dir_path = os.path.abspath(&#34;./data/facebook_clean_data/&#34;)
csv_files = [f&#34;/samples/{f}&#34; for f in listdir(csv_dir_path) if isfile(join(csv_dir_path, f))]</code></pre>



<p>Load all CSV files using the following query:</p>



<pre><code>for csv_file_path in csv_files:
    memgraph.execute(
        f&#34;&#34;&#34;
        LOAD CSV FROM &#34;{csv_file_path}&#34; WITH HEADER AS row
        MERGE (p1:Page {{id: row.node_1}}) 
        MERGE (p2:Page {{id: row.node_2}}) 
        MERGE (p1)-[:LIKES]-&gt;(p2);
        &#34;&#34;&#34;
    )
</code></pre>



<p>For more information about importing CSV files with LOAD CSV see the <a href="https://memgraph.com/docs/memgraph/import-data/load-csv-clause" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph documentation</a>.</p>



<p>Next, use PageRank and Louvain community detection algorithms with Python to determine which pages in the network are most important, and to find all the communities in a network.</p>



<h2>PageRank importance analysis</h2>



<p>To identify important pages in a Facebook dataset, you will execute PageRank. Learn about different <a href="https://memgraph.com/docs/mage/query-modules/cuda/cugraph#cugraphpagerank" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">algorithm settings</a> that can be set when calling PageRank.</p>



<p>Note that you will also find other algorithms integrated within <code>MAGE</code>. Memgraph should help with the process of running graph analytics on large-scale graphs. Find other <a href="https://memgraph.com/categories/tutorials" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph tutorials</a> on how to run these analytics.</p>



<p><code>MAGE</code> is integrated to simplify executing PageRank. The following query will first execute the algorithm, and then create and set the <code>rank</code> property of each node to the value that the <code>cugraph.pagerank</code> algorithm returns.</p>



<p>The value of that property will then be saved as a variable <code>rank</code>. Note that this (and all tests presented here) were executed on an NVIDIA GeForce GTX 1650 Ti, and Intel Core i5-10300H CPU at 2.50GHz with 16GB RAM, and returned results in around four seconds.  </p>



<pre><code> memgraph.execute(
        &#34;&#34;&#34;
        CALL cugraph.pagerank.get() YIELD node,rank
        SET node.rank = rank;
        &#34;&#34;&#34;
    )
</code></pre>



<p>Next, retrieve ranks  using the following Python call:</p>



<pre><code>results =  memgraph.execute_and_fetch(
        &#34;&#34;&#34;
        MATCH (n)
        RETURN n.id as node, n.rank as rank
        ORDER BY rank DESC
        LIMIT 10;
        &#34;&#34;&#34;
    )
for dict_result in results:
    print(f&#34;node id: {dict_result[&#39;node&#39;]}, rank: {dict_result[&#39;rank&#39;]}&#34;)

node id: 50493, rank: 0.0030278728385218327
node id: 31456, rank: 0.0027350282311318468
node id: 50150, rank: 0.0025153975342989345
node id: 48099, rank: 0.0023413620866201052
node id: 49956, rank: 0.0020696403564964
node id: 23866, rank: 0.001955167533390466
node id: 50442, rank: 0.0019417018181751462
node id: 49609, rank: 0.0018211204462452515
node id: 50272, rank: 0.0018123518843272954
node id: 49676, rank: 0.0014821440895415787

</code></pre>



<p>This code returns 10 nodes with the highest rank score. Results are available in a dictionary form.</p>



<p>Now, it is time to visualize results with <a href="https://memgraph.com/lab" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph Lab</a>. In addition to creating beautiful visualizations powered by <a href="https://d3js.org/" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">D3.js</a> and our <a href="https://memgraph.com/docs/memgraph-lab/graph-style-script-language" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Graph Style Script language</a>, you can use Memgraph Lab to:</p>



<ul><li><a href="https://memgraph.com/docs/memgraph-lab/connect-to-memgraph#executing-queries" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Query graph database</a> and write your graph algorithms in Python or C++ or even Rust</li><li>Check Memgraph Database Logs</li><li>Visualize graph schema</li></ul>



<p>Memgraph Lab comes with a variety of pre-built datasets to help you get started. Open Execute Query view in Memgraph Lab and run the following query:</p>



<pre><code>MATCH (n)
WITH n
ORDER BY n.rank DESC
LIMIT 3
MATCH (n)&lt;-[e]-(m)
RETURN *;
</code></pre>



<p>The first part of this query will <code>MATCH</code> all the nodes. The second part of the query will <code>ORDER</code> nodes by their <code>rank</code> in descending order.</p>



<p>For the first three nodes, obtain all pages connected to them. We need the <code>WITH</code> clause to connect the two parts of the query. Figure 1 shows the PageRank query results.</p>



<div><figure><img loading="lazy" width="727" height="581" src="https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1.png" alt="Generated graph for visualization of grouped PageRank results" srcset="https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1.png 727w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-300x240.png 300w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-625x499.png 625w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-144x115.png 144w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-375x300.png 375w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-113x90.png 113w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-362x289.png 362w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/antonio-1-138x110.png 138w" sizes="(max-width: 727px) 100vw, 727px"/><figcaption><em>Figure 1. PageRank results visualized in Memgraph Lab</em></figcaption></figure></div>



<p>The next step is learning how to use Louvain community detection to find communities present in the graph.</p>



<h2>Community detection with Louvain</h2>



<p>The Louvain algorithm measures the extent to which the nodes within a community are connected, compared to how connected they would be in a random network. </p>



<p>It also recursively merges communities into a single node and executes the modularity clustering on the condensed graphs. This is one of the most popular community detection algorithms.</p>



<p>Using Louvain, you can find the number of communities within the graph.  First execute Louvain and save the<code> cluster_id</code> as a property for every node:</p>



<pre><code>memgraph.execute(
    &#34;&#34;&#34;
    CALL cugraph.louvain.get() YIELD cluster_id, node
    SET node.cluster_id = cluster_id;
    &#34;&#34;&#34;
)
</code></pre>



<p>To find the number of communities, run the following code:</p>



<pre><code>results =  memgraph.execute_and_fetch(
        &#34;&#34;&#34;
        MATCH (n)
        WITH DISTINCT n.cluster_id as cluster_id
        RETURN count(cluster_id ) as num_of_clusters;
        &#34;&#34;&#34;
    )
# we will get only 1 result
result = list(results)[0]

#don&#39;t forget that results are saved in a dict
print(f&#34;Number of clusters: {result[&#39;num_of_clusters&#39;]}&#34;)

Number of clusters: 2664
</code></pre>



<p>Next, take a closer look at some of these communities. For example, you may find nodes that belong to one community, but are connected to another node that belongs in the opposing community. Louvain attempts to minimize the number of such nodes, so you should not see many of them. In Memgraph Lab, execute the following query:</p>



<pre><code>MATCH  (n2)&lt;-[e1]-(n1)-[e]-&gt;(m1)
WHERE n1.cluster_id != m1.cluster_id AND n1.cluster_id = n2.cluster_id
RETURN *
LIMIT 1000;
</code></pre>



<p>This query will <code>MATCH</code> node <code>n1</code> and its relationship to two other nodes <code>n2</code> and <code>m1</code> with the following parts, respectively: <code>(n2)&lt;-[e1]-(n1)</code> and <code>(n1)-[e]-&gt;(m1)</code>. Then, it will filter out only those nodes <code>WHERE</code> <code>cluster_id</code> of <code>n1</code> and <code>n2</code> is not the same as the <code>cluster_id</code> of node <code>m1</code>.</p>



<p>Use <code>LIMIT 1000</code> to show only 1,000 of such relationships, for visualization simplicity.</p>



<p>Using <a href="https://memgraph.com/docs/memgraph-lab/graph-style-script-language" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Graph Style Script</a> in Memgraph Lab, you can style your graphs to, for example, represent different communities with different colors. Figure 2 shows the Louvain query results. </p>



<div><figure><img loading="lazy" width="729" height="641" src="https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2.png" alt="Generated graph visualization of the Louvain query results " srcset="https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2.png 729w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-300x264.png 300w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-625x550.png 625w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-131x115.png 131w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-341x300.png 341w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-102x90.png 102w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-362x318.png 362w, https://developer-blogs.nvidia.com/wp-content/uploads/2022/08/Antonio-2-125x110.png 125w" sizes="(max-width: 729px) 100vw, 729px"/><figcaption><em>Figure 2. Louvain results visualized in Memgraph Lab</em><br/></figcaption></figure></div>



<h2>Summary</h2>



<p>And there you have it: millions of nodes and relationships imported using Memgraph and analyzed using cuGraph PageRank and Louvain graph analytics algorithms. With GPU-powered graph analytics from Memgraph, powered by NVIDIA cuGraph, you are able to explore massive graph databases and carry out inference without having to wait for results. You can find more tutorials covering a variety of techniques on the <a href="https://memgraph.com/categories/tutorials" data-wpel-link="external" target="_blank" rel="nofollow external noopener noreferrer">Memgraph website</a>.</p>
</div></div>
  </body>
</html>
