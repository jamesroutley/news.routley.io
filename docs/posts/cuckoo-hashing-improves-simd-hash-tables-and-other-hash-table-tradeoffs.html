<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://reiner.org/cuckoo-hashing">Original</a>
    <h1>Cuckoo hashing improves SIMD hash tables (and other hash table tradeoffs)</h1>
    
    <div id="readability-page-1" class="page"><div id="maincontent">
  
  <p>There are many options when designing a hash table. Cuckoo hashing is a curious design that is popular in academia, but unused in some of industry’s most popular designs, such as Google’s <a href="https://abseil.io/blog/20180927-swisstables">Swiss Tables</a> and Meta’s <a href="https://engineering.fb.com/2019/04/25/developer-tools/f14/">F14 tables</a>. Cuckoo hashing is often avoided because it has worse memory system performance and is beaten by SIMD-accelerated probing.</p>
  <p>This doesn’t have to be the case! With careful engineering, you can combine SIMD-accelerated probing with cuckoo hashing to beat the standard implementations in many scenarios.</p>
  <h2 id="benchmark-highlights">Benchmark highlights</h2>
  <p>Adding cuckoo hashing to a strong baseline is typically close to neutral for performance on low load factors<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>, and greatly improves performance on high load factors. We show performance across the range of load factors used by Swiss Tables.</p>
  <p>For different use cases the best baseline design may also differ; in each case we take the best baseline design and then add cuckoo hashing.</p>
  <p>Successful lookups on u64 keys and values, <a href="#large-out-of-cache-tables-successful-lookups">“Direct SIMD”</a> baseline:</p>
  <p><svg id="lookup-success" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350m-490 -47.139999999999986h490m-490 -47.150000000000006h490m-490 -47.140000000000015h490m-490 -47.139999999999986h490m-490 -47.14h490m-490 -47.150000000000006h490m-490 -47.14h490" fill="none" stroke="#ccc" stroke-width="1"></path><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="151.58" y="350">50%</text><text x="280.53" y="350">62.5%</text><text x="409.47" y="350">75%</text><text x="538.42" y="350">87.5%</text></g><g><text x="100" y="350">0</text><text x="100" y="302.86">5</text><text x="100" y="255.71">10</text><text x="100" y="208.57">15</text><text x="100" y="161.43">20</text><text x="100" y="114.29">25</text><text x="100" y="67.14">30</text><text x="100" y="20">35</text></g><path style="stroke:#1a365d" d="M151.58 325.49L280.53 318.89L409.47 302.86L538.42 276.46"></path><path style="stroke:#e53e3e" d="M151.58 325.49L280.53 320.77L409.47 311.34L538.42 299.09"></path><path style="stroke:#38a169" d="M151.58 324.54L280.53 323.6L409.47 323.6L538.42 322.66"></path><path style="stroke:#1a365d" d="M151.58 190.66L280.53 162.37L409.47 119.94L538.42 49.23"></path><path style="stroke:#e53e3e" d="M151.58 178.4L280.53 163.31L409.47 144.46L538.42 122.77"></path><path style="stroke:#38a169" d="M151.58 161.43L280.53 161.43L409.47 161.43L538.42 161.43"></path><g transform="translate(120 40)"><rect x="0" y="0" width="200" height="4em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><line x1="15" y1="1em" x2="40" y2="1em" style="stroke:#1a365d" stroke-width="1"></line><text x="55" y="1em">Baseline</text><line x1="15" y1="2em" x2="40" y2="2em" style="stroke:#e53e3e" stroke-width="1"></line><text x="55" y="2em">Branchy cuckoo</text><line x1="15" y1="3em" x2="40" y2="3em" style="stroke:#38a169" stroke-width="1"></line><text x="55" y="3em">Branchless cuckoo</text></g><text x="345" y="350">Load factor</text><text x="30" y="185" transform="rotate(-90 30 185)">Lookup time (ns)</text><text x="254.73684210526315" y="293.42857142857144" style="text-anchor: middle;">In cache (512 KiB)</text><text x="440.42105263157896" y="189.71428571428572" style="text-anchor: middle;">Out of cache (512 MiB)</text></svg></p>
  <p>Failed lookups on u64 keys and values, <a href="#large-out-of-cache-tables-failed-lookups">“Indirect SIMD”</a> baseline:</p>
  <p><svg id="lookup-failure" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350m-490 -55h490m-490 -55h490m-490 -55h490m-490 -55h490m-490 -55h490m-490 -55h490" fill="none" stroke="#ccc" stroke-width="1"></path><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="151.58" y="350">50%</text><text x="280.53" y="350">62.5%</text><text x="409.47" y="350">75%</text><text x="538.42" y="350">87.5%</text></g><g><text x="100" y="350">0</text><text x="100" y="295">5</text><text x="100" y="240">10</text><text x="100" y="185">15</text><text x="100" y="130">20</text><text x="100" y="75">25</text><text x="100" y="20">30</text></g><path style="stroke:#1a365d" d="M151.58 319.2L280.53 310.4L409.47 284L538.42 179.5"></path><path style="stroke:#e53e3e" d="M151.58 318.1L280.53 310.4L409.47 290.6L538.42 242.2"></path><path style="stroke:#38a169" d="M151.58 306L280.53 300.5L409.47 293.9L538.42 289.5"></path><path style="stroke:#1a365d" d="M151.58 226.8L280.53 214.7L409.47 180.6L538.42 50.8"></path><path style="stroke:#e53e3e" d="M151.58 222.4L280.53 210.3L409.47 189.4L538.42 144.3"></path><path style="stroke:#38a169" d="M151.58 193.8L280.53 182.8L409.47 174L538.42 165.2"></path><g transform="translate(120 40)"><rect x="0" y="0" width="200" height="4em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><line x1="15" y1="1em" x2="40" y2="1em" style="stroke:#1a365d" stroke-width="1"></line><text x="55" y="1em">Baseline</text><line x1="15" y1="2em" x2="40" y2="2em" style="stroke:#e53e3e" stroke-width="1"></line><text x="55" y="2em">Branchy cuckoo</text><line x1="15" y1="3em" x2="40" y2="3em" style="stroke:#38a169" stroke-width="1"></line><text x="55" y="3em">Branchless cuckoo</text></g><text x="345" y="350">Load factor</text><text x="30" y="185" transform="rotate(-90 30 185)">Lookup time (ns)</text><text x="254.73684210526315" y="284" style="text-anchor: middle;">In cache (512 KiB)</text><text x="296" y="163" style="text-anchor: middle;">Out of cache (512 MiB)</text></svg></p>
  <p>Insertions on u64 keys and values, “Indirect SIMD” baseline:</p>
  <p><svg id="cuckoo-insertion-performance" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350m-490 -60h490m-490 -60h490m-490 -60h490m-490 -60h490m-490 -60h490" fill="none" stroke="#ccc" stroke-width="1"></path><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="154.44" y="350">50%</text><text x="290.56" y="350">62.5%</text><text x="426.67" y="350">75%</text><text x="562.78" y="350">87.5%</text></g><g><text x="100" y="350">0</text><text x="100" y="290">10</text><text x="100" y="230">20</text><text x="100" y="170">30</text><text x="100" y="110">40</text><text x="100" y="50">50</text></g><path style="stroke:#1a365d" d="M154.44 325.4L290.56 324.2L426.67 323L562.78 278"></path><path style="stroke:#e53e3e" d="M154.44 326.6L290.56 324.2L426.67 327.2L562.78 327.8"></path><path style="stroke:#1a365d" d="M154.44 221L290.56 214.4L426.67 197L562.78 159.2"></path><path style="stroke:#e53e3e" d="M154.44 221.6L290.56 213.8L426.67 203L562.78 174.8"></path><g transform="translate(120 40)"><rect x="0" y="0" width="200" height="3em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><line x1="15" y1="1em" x2="40" y2="1em" style="stroke:#1a365d" stroke-width="1"></line><text x="55" y="1em">Baseline</text><line x1="15" y1="2em" x2="40" y2="2em" style="stroke:#e53e3e" stroke-width="1"></line><text x="55" y="2em">Cuckoo</text></g><text x="345" y="350">Load factor</text><text x="30" y="185" transform="rotate(-90 30 185)">Insertion time (ns)</text><text x="317.77777777777777" y="302" style="text-anchor: middle;">In cache (512 KiB)</text><text x="317.77777777777777" y="188" style="text-anchor: middle;">Out of cache (512 MiB)</text></svg></p>
  <p><a href="https://github.com/reinerp/cuckoo-hashing-benchmark">Benchmarks are available</a>. No library release is available yet, but perhaps in future.</p>
  <h2 id="what-is-cuckoo-hashing">What is cuckoo hashing?</h2>
  <p>All hash tables we consider use <em>open addressing</em>, where keys are stored in a flat array. The designs differ in the <em>probe sequence</em>: which elements, and in what order, we search during a lookup.</p>
  <p>Baseline SIMD hash tables such as Swiss Tables use <em>SIMD quadratic probing</em>. This starts searching from a position determined by the hash function, searches 4–16 consecutive keys in parallel with SIMD, then steps by 1 and searches, then steps by 2 and searches, then 3, and so on:</p>
  <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="35 0 770 150">
  <rect width="20" height="20" x="40" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="60" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="80" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="100" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="120" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="140" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="160" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="180" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="200" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="220" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="240" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="260" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="280" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="300" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="320" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="340" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="360" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="380" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="400" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="420" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="440" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="460" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="480" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="500" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="520" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="540" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="560" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="580" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="600" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="620" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="640" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="660" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="680" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="700" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="720" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="740" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  
  <!-- Ellipsis to indicate continuation -->
  <circle cx="770" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="780" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="790" cy="50" r="3" fill="#1a365d"></circle>
  
  <!-- Hash arrow pointing up -->
  <defs>
    <marker id="arrowhead" markerWidth="5" markerHeight="3.5" refX="4" refY="1.75" orient="auto">
      <polygon points="0 0, 5 1.75, 0 3.5" fill="#1a365d"></polygon>
    </marker>
    <marker id="arrowhead-start" markerWidth="5" markerHeight="3.5" refX="1" refY="1.75" orient="auto">
      <polygon points="5 0, 0 1.75, 5 3.5" fill="#1a365d"></polygon>
    </marker>
  </defs>
  
  <!-- SIMD width arrow -->
  <line x1="160" y1="30" x2="240" y2="30" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="200" y="20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">SIMD width</text>
  
  <!-- Upward arrow for hash -->
  <line x1="160" y1="120" x2="160" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="160" y="135" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">hash</text>
  
  <!-- Curved arrows for steps -->
  <!-- Step by 1: (160, 60) to (240, 60) -->
  <path d="M 160 60 Q 200 80 240 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <text x="200" y="85" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">step by 1</text>
  
  <!-- Step by 2: (240, 60) to (400, 60) -->
  <path d="M 240 60 Q 320 80 400 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <text x="320" y="85" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">step by 2</text>
  
  <!-- Step by 3: (400, 60) to (640, 60) -->
  <path d="M 400 60 Q 520 80 640 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <text x="520" y="85" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">step by 3</text>
  
  <!-- Half-arrow: (640, 60) to (760, 70) -->
  <path d="M 640 60 Q 700 70 760 70" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
</svg>
</p>
  <p>The search continues until either the matching key is found, or an empty entry in the array is found<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
  <p>In cuckoo hashing, we use <em>two</em> hash functions<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>, do a single SIMD search at each of those positions, and then stop:</p>
  <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="35 0 770 150">
  <rect width="20" height="20" x="40" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="60" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="80" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="100" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="120" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="140" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="160" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="180" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="200" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="220" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="240" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="260" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="280" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="300" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="320" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="340" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="360" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="380" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="400" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="420" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="440" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="460" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="480" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="500" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="520" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="540" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="560" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="580" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="600" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="620" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="640" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="660" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="680" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="700" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="720" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="740" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  
  <!-- Ellipsis to indicate continuation -->
  <circle cx="770" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="780" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="790" cy="50" r="3" fill="#1a365d"></circle>
  
  <!-- Hash arrow pointing up -->
  <defs>
    <marker id="arrowhead" markerWidth="5" markerHeight="3.5" refX="4" refY="1.75" orient="auto">
      <polygon points="0 0, 5 1.75, 0 3.5" fill="#1a365d"></polygon>
    </marker>
    <marker id="arrowhead-start" markerWidth="5" markerHeight="3.5" refX="1" refY="1.75" orient="auto">
      <polygon points="5 0, 0 1.75, 5 3.5" fill="#1a365d"></polygon>
    </marker>
  </defs>

  <!-- SIMD width arrow -->
  <line x1="200" y1="30" x2="280" y2="30" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="240" y="20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">SIMD width</text>

  <!-- Upward arrow for hash 0 -->
  <line x1="200" y1="120" x2="200" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="200" y="135" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">hash 0</text>
  
  <!-- Upward arrow for hash 1 -->
  <line x1="580" y1="120" x2="580" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="580" y="135" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">hash 1</text>
  
</svg>
</p>
  <p>The advantage of cuckoo hashing is that we search only a small fixed number of positions during lookups. The surprising fact about cuckoo hashing is that this probe sequence even works! What if I try to insert a new key and all 8 candidate entries are already full?</p>
  <p>The answer: to make space for the new key, you can kick out any of the 8 candidate entries, and move them to one of their 4 alternative locations. For example, here are the alternatives for the entries in the “hash 0” bucket:</p>
  <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="35 0 770 150">
  <rect width="20" height="20" x="40" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="60" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="80" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="100" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="120" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="140" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="160" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="180" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="200" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="220" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="240" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="260" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="20" height="20" x="280" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="300" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="320" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="340" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="360" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="380" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="400" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="420" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="440" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="460" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="480" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="500" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="520" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="540" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="560" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="580" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="600" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="620" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="640" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="660" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="680" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="700" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="20" height="20" x="720" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  <rect width="20" height="20" x="740" y="40" style="stroke:#1a365d;fill:#7ab1e5"></rect>
  
  <!-- Ellipsis to indicate continuation -->
  <circle cx="770" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="780" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="790" cy="50" r="3" fill="#1a365d"></circle>
  
  <!-- Hash arrow pointing up -->
  <defs>
    <marker id="arrowhead" markerWidth="5" markerHeight="3.5" refX="4.5" refY="1.75" orient="auto">
      <polygon points="0 0, 5 1.75, 0 3.5" fill="#1a365d"></polygon>
    </marker>
    <marker id="arrowhead-start" markerWidth="5" markerHeight="3.5" refX="0.5" refY="1.75" orient="auto">
      <polygon points="5 0, 0 1.75, 5 3.5" fill="#1a365d"></polygon>
    </marker>
  </defs>

  <!-- Upward arrow for hash 0 -->
  <line x1="200" y1="120" x2="200" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="200" y="135" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">hash 0</text>
  
  <path d="M 210 40 Q 125 0 40 40" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <path d="M 230 40 Q 475 0 720 40" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <path d="M 250 40 Q 295 0 340 40" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <path d="M 270 40 Q 415 -20 560 40" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  
  
</svg>
</p>
  <p>If you still don’t find space in any of the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">8\times 4=32</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>8</span><span></span><span>×</span><span></span></span><span><span></span><span>4</span><span></span><span>=</span><span></span></span><span><span></span><span>32</span></span></span></span> alternative entries, look in <em>their</em> alternatives, and then <em>their</em> alternatives, and so on, in a fanout-4 tree. Once you find an empty location, you can perform a chain of moves—each entry moving to one of its alternative locations—to ultimately make space for the inserted key. With high probability this process completes almost immediately, with just 0 or 1 moves on almost all keys.</p>
  <h2 id="when-and-why-does-cuckoo-hashing-win">When and why does cuckoo hashing win?</h2>
  <p>
  <em>In brief</em>: for in-cache tables, cuckoo hashing wins by avoiding branch mispredictions. For out-of-cache tables, large buckets mitigates cuckoo hashing’s disadvantage in memory locality, and then its shorter probe length allows it to win.
  </p>
  <h4 id="small-in-cache-tables">Small (in-cache) tables</h4>
  <p>Quadratic probing performs two equality tests and branches per SIMD probe:</p>
  <pre><code>while (true) {
  if (&lt;key matches anything in group&gt;) {
    return &lt;key found&gt;;
  }
  if (&lt;anything in group is empty&gt;) {
    return &lt;key not found&gt;;
  }
  &lt;go to next group&gt;
}</code></pre>
  <p>The branches are necessary in quadratic probing because we don’t know in advance how many probes to perform, and at least one of the branches is difficult to predict: it’s nearly random which keys will be at probe position 0 versus probe position 1.</p>
  <p>With cuckoo probing we know there are at most two probes, so we can unroll the loop, skip the check for empty, and optionally make the entire process branchless by using <a href="https://www.felixcloutier.com/x86/cmovcc">conditional move</a> or <a href="https://developer.arm.com/documentation/ddi0602/2021-12/Base-Instructions/CSEL--Conditional-Select-">conditional select</a> instructions<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>. The probing becomes:</p>
  <pre><code>&lt;check for match in group 0&gt;
&lt;check for match in group 1&gt;
&lt;return&gt;</code></pre>
  <p>For small tables that fit in the CPU cache, the savings in branch mispredictions and in instruction count make cuckoo hashing a win.</p>
  <h4 id="large-out-of-cache-tables-failed-lookups">Large (out-of-cache) tables, failed lookups</h4>
  <p>For large tables that don’t fit in the CPU cache, cache line fetches become a more important consideration than branch mispredictions or instruction count. The branchless cuckoo implementation fetches a cache line for each of group 0 and group 1, whereas the branchy cuckoo implementation fetches either 1 or 2 cache lines depending on whether the search terminated after the first or second group. Thus the branchy implementation pays a branch mispredict (sometimes) in order to save a cache line fetch (sometimes). At lower load factors this leads to the branchy implementation beating the branchless implementation.</p>
  <p>Whereas in cuckoo hashing the second probe is almost always on a different cache line than its first probe, in quadratic probing they are often on the same cache line, since quadratic probing designs the first two probes to be adjacent. Depending on the layout of the hash table, this can sometimes save cache line traffic. We’ll consider the layouts that we found to be best across different workloads.</p>
  <p>One popular design is the <em>Indirect SIMD</em> design from Google’s Swiss Tables, in which there is an array of 1-byte tags and a separate array of (key, value) payloads. SIMD probing is performed on the tag array, and then any matches on the tag array are confirmed by a second (non-SIMD) test against the payload array:</p>
  <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="-50 -40 570 250">

  <text x="-10" y="53">Tag array</text>
  <text x="-10" y="143">Payload array</text>


  <circle cx="110" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="120" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="130" cy="50" r="3" fill="#1a365d"></circle>

  <rect width="4" height="20" x="140" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="144" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="148" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="152" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="156" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="160" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="164" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="168" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="172" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="176" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="180" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="184" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="188" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="192" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="196" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="200" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="204" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="208" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="212" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="216" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="220" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="224" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="228" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="232" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="236" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="240" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="244" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="248" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="252" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="256" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="260" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="264" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="268" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="272" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="276" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="280" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="284" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="288" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="292" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="296" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="300" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="304" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="308" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="312" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="316" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="320" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="324" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="328" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="332" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="336" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="340" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="344" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="348" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="352" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="356" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="360" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="364" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="368" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="372" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="376" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="380" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="4" height="20" x="384" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="388" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="4" height="20" x="392" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <circle cx="406" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="416" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="426" cy="50" r="3" fill="#1a365d"></circle>






  <!-- Hash arrow pointing up -->
  <defs>
    <marker id="arrowhead" markerWidth="5" markerHeight="3.5" refX="4" refY="1.75" orient="auto">
      <polygon points="0 0, 5 1.75, 0 3.5" fill="#1a365d"></polygon>
    </marker>
    <marker id="arrowhead-start" markerWidth="5" markerHeight="3.5" refX="1" refY="1.75" orient="auto">
      <polygon points="5 0, 0 1.75, 5 3.5" fill="#1a365d"></polygon>
    </marker>
  </defs>

  <!-- Cache line arrow -->
  <line x1="140" y1="-10" x2="396" y2="-10" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="200" y="-20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">Cache line</text>
  
  <!-- SIMD width arrow -->
  <line x1="160" y1="30" x2="224" y2="30" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="200" y="20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">SIMD width</text>
  
  <!-- Upward arrow for hash -->
  <line x1="160" y1="90" x2="160" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="160" y="105" text-anchor="middle">hash</text>
  
  <!-- Curved arrows for steps -->
  <path d="M 160 60 Q 192 80 224 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  <path d="M 224 60 Q 288 80 384 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  
  <!-- Half-arrow: (640, 60) to (760, 70) -->
  <path d="M 384 60 Q 400 70 426 70" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>



  <circle cx="110" cy="140" r="3" fill="#1a365d"></circle>
  <circle cx="120" cy="140" r="3" fill="#1a365d"></circle>
  <circle cx="130" cy="140" r="3" fill="#1a365d"></circle>
  <rect width="32" height="20" x="140" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="172" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="204" y="130" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="236" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="268" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="300" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="332" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="364" y="130" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <circle cx="406" cy="140" r="3" fill="#1a365d"></circle>
  <circle cx="416" cy="140" r="3" fill="#1a365d"></circle>
  <circle cx="426" cy="140" r="3" fill="#1a365d"></circle>

  <text x="156" y="146" text-anchor="middle" fill="#1a365d">K</text>
  <text x="188" y="146" text-anchor="middle" fill="#1a365d">V</text>
  <text x="220" y="146" text-anchor="middle" fill="#1a365d">K</text>
  <text x="252" y="146" text-anchor="middle" fill="#1a365d">V</text>
  <text x="284" y="146" text-anchor="middle" fill="#1a365d">K</text>
  <text x="316" y="146" text-anchor="middle" fill="#1a365d">V</text>
  <text x="348" y="146" text-anchor="middle" fill="#1a365d">K</text>
  <text x="380" y="146" text-anchor="middle" fill="#1a365d">V</text>

  <line x1="208" y1="60" x2="204" y2="130" stroke="#1a365d" stroke-width="1" stroke-dasharray="3,3"></line>
  <line x1="212" y1="60" x2="268" y2="130" stroke="#1a365d" stroke-width="1" stroke-dasharray="3,3"></line>

  <!-- Upward arrow for hash -->
  <line x1="220" y1="180" x2="220" y2="150" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="220" y="195" text-anchor="middle">Confirm tag match against real key</text>
</svg>
</p>
  <p>The Indirect SIMD design performs very well for failed lookups (where the key isn’t present in the table), because they can typically be serviced entirely by the tag array without fetching the payload array<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Under quadratic probing for Indirect SIMD layout, probe lengths of 1–2 can typically be handled with just one cache line fetch. Under cuckoo probing for Indirect SIMD layout, probe length 2 requires two cache line fetches, which is worse than for quadratic probing<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
  <p>Because of the extra cache line fetches at probe length 2, this (failed lookups for out-of-cache tables) is the worst case for cuckoo hashing: it only starts to pull ahead as load factors grow past 75%. When the load factors are large, quadratic probing starts to require long probe sequences whereas cuckoo hashing keeps them to at most 2:</p>
  <p><svg id="probe-lengths-miss" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="131.96" y="350">1</text><text x="167.46" y="350">2</text><text x="202.97" y="350">3</text><text x="238.48" y="350">4</text><text x="273.99" y="350">5</text><text x="309.49" y="350">6</text><text x="345" y="350">7</text><text x="380.51" y="350">8</text><text x="416.01" y="350">9</text><text x="451.52" y="350">10</text><text x="487.03" y="350">11</text><text x="522.54" y="350">12</text><text x="558.04" y="350">13</text></g><g><text x="100" y="350">0</text><text x="100" y="295">10</text><text x="100" y="240">20</text><text x="100" y="185">30</text><text x="100" y="130">40</text><text x="100" y="75">50</text><text x="100" y="20">60</text></g><rect x="117.75500000000001" y="106.24" width="14.204999999999998" height="243.76" fill="#1a365d" stroke="none"></rect><rect x="153.255" y="254.52" width="14.205000000000013" height="95.47999999999999" fill="#1a365d" stroke="none"></rect><rect x="188.765" y="278.57" width="14.205000000000013" height="71.43" fill="#1a365d" stroke="none"></rect><rect x="224.27499999999998" y="304.66" width="14.205000000000013" height="45.339999999999975" fill="#1a365d" stroke="none"></rect><rect x="259.785" y="319.92" width="14.204999999999984" height="30.079999999999984" fill="#1a365d" stroke="none"></rect><rect x="295.285" y="330.14" width="14.204999999999984" height="19.860000000000014" fill="#1a365d" stroke="none"></rect><rect x="330.795" y="336.8" width="14.204999999999984" height="13.199999999999989" fill="#1a365d" stroke="none"></rect><rect x="366.305" y="340.62" width="14.204999999999984" height="9.379999999999995" fill="#1a365d" stroke="none"></rect><rect x="401.805" y="343.38" width="14.204999999999984" height="6.6200000000000045" fill="#1a365d" stroke="none"></rect><rect x="437.315" y="345.52" width="14.204999999999984" height="4.480000000000018" fill="#1a365d" stroke="none"></rect><rect x="472.825" y="346.77" width="14.204999999999984" height="3.230000000000018" fill="#1a365d" stroke="none"></rect><rect x="508.335" y="347.56" width="14.204999999999984" height="2.4399999999999977" fill="#1a365d" stroke="none"></rect><rect x="543.8349999999999" y="348.34" width="14.205000000000041" height="1.660000000000025" fill="#1a365d" stroke="none"></rect><rect x="131.96" y="86.92" width="14.205000000000013" height="263.08" fill="#e53e3e" stroke="none"></rect><rect x="167.46" y="63.08" width="14.205000000000013" height="286.92" fill="#e53e3e" stroke="none"></rect><g transform="translate(410 40)"><rect x="0" y="0" width="160" height="3em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><rect x="15" y="0.7em" width="25" height="0.6em" fill="#1a365d" stroke="none"></rect><text x="55" y="1em">Quadratic</text><rect x="15" y="1.7em" width="25" height="0.6em" fill="#e53e3e" stroke="none"></rect><text x="55" y="2em">Cuckoo</text></g><text x="345" y="350">Probe length</text><text x="65" y="185" transform="rotate(-90 65 185)">% of operations</text></svg></p>
  <h4 id="large-out-of-cache-tables-successful-lookups">Large (out-of-cache) tables, successful lookups</h4>
  <p>For out-of-cache successful lookups, the Indirect SIMD design of the previous section is not optimal: it requires a minimum of two cache misses per lookup: one for the tag array and one for the payload array. There are better layouts which reduce this to just one in the best case.</p>
  <p>For integer keys, I found the best layout to be the <em>Direct SIMD</em> layout, with each cache line containing an array of keys and an array of values<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>:</p>
  <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -40 570 160">

  <!-- Hash arrow pointing up -->
  <defs>
    <marker id="arrowhead" markerWidth="5" markerHeight="3.5" refX="4" refY="1.75" orient="auto">
      <polygon points="0 0, 5 1.75, 0 3.5" fill="#1a365d"></polygon>
    </marker>
    <marker id="arrowhead-start" markerWidth="5" markerHeight="3.5" refX="1" refY="1.75" orient="auto">
      <polygon points="5 0, 0 1.75, 5 3.5" fill="#1a365d"></polygon>
    </marker>
  </defs>

  <!-- Cache line arrow -->
  <line x1="140" y1="-10" x2="396" y2="-10" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="200" y="-20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">Cache line</text>
  
  <!-- SIMD width arrow -->
  <line x1="140" y1="30" x2="268" y2="30" stroke="#1a365d" stroke-width="2" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead)"></line>
  <text x="200" y="20" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#1a365d">SIMD width</text>
  
  <!-- Upward arrow for hash -->
  <line x1="140" y1="90" x2="140" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"></line>
  <text x="140" y="105" text-anchor="middle">hash</text>
  
  <!-- Curved arrows for steps -->
  <path d="M 140 60 Q 268 80 396 60" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
  
  <!-- Half-arrow: (640, 60) to (760, 70) -->
  <path d="M 396 60 Q 460 70 524 70" stroke="#1a365d" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>



  <circle cx="46" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="56" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="66" cy="50" r="3" fill="#1a365d"></circle>
  <rect width="32" height="20" x="76" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="108" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="140" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="172" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="204" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="236" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="268" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="300" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="332" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="364" y="40" style="stroke:#1a365d;fill:#e6f3ff"></rect>
  <rect width="32" height="20" x="396" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="428" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <rect width="32" height="20" x="460" y="40" style="stroke:#1a365d;fill:#2156a5"></rect>
  <circle cx="502" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="512" cy="50" r="3" fill="#1a365d"></circle>
  <circle cx="522" cy="50" r="3" fill="#1a365d"></circle>

  <text x="92" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="124" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="156" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="188" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="220" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="252" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="284" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="316" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="348" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="380" y="56" text-anchor="middle" fill="#1a365d">V</text>
  <text x="416" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="444" y="56" text-anchor="middle" fill="#fff">K</text>
  <text x="476" y="56" text-anchor="middle" fill="#fff">K</text>

</svg>
</p>
  <p>The advantage of Direct SIMD layout is that probe-length-1 lookups can be serviced with just one cache line fetch. The disadvantage relative to Indirect SIMD layout is that only a small number of keys can be fit into a cache line: for u64 keys and values, we can only fit 4 keys per cache line, whereas the Indirect SIMD layout fits 64 keys per cache line. For short enough probe lengths, Direct SIMD layout wins, but for very long probe lengths, Indirect SIMD layout wins. Overall, Direct SIMD layout tends to win on successful lookups but lose on failed lookups<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a>, and this is true for both quadratic probing and cuckoo probing.</p>
  <p>Within the context of Direct SIMD layout, cuckoo hashing is a large improvement over quadratic probing, because of the sensitivity of Direct SIMD to probe length. It wins at almost all load factors, by keeping probe lengths short<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a>:</p>
  <p><svg id="probe-lengths-hit" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="156.54" y="350">1</text><text x="219.36" y="350">2</text><text x="282.18" y="350">3</text><text x="345" y="350">4</text><text x="407.82" y="350">5</text><text x="470.64" y="350">6</text><text x="533.46" y="350">7</text></g><g><text x="100" y="350">0</text><text x="100" y="284">20</text><text x="100" y="218">40</text><text x="100" y="152">60</text><text x="100" y="86">80</text><text x="100" y="20">100</text></g><rect x="131.41" y="83.82" width="25.129999999999995" height="266.18" fill="#1a365d" stroke="none"></rect><rect x="194.23000000000002" y="318.31" width="25.129999999999995" height="31.689999999999998" fill="#1a365d" stroke="none"></rect><rect x="257.05" y="336.61" width="25.129999999999995" height="13.389999999999986" fill="#1a365d" stroke="none"></rect><rect x="319.87" y="343.14" width="25.129999999999995" height="6.860000000000014" fill="#1a365d" stroke="none"></rect><rect x="382.69" y="345.67" width="25.129999999999995" height="4.329999999999984" fill="#1a365d" stroke="none"></rect><rect x="445.51" y="347.34" width="25.129999999999995" height="2.660000000000025" fill="#1a365d" stroke="none"></rect><rect x="508.33000000000004" y="348.34" width="25.129999999999995" height="1.660000000000025" fill="#1a365d" stroke="none"></rect><rect x="156.54" y="87.98" width="25.129999999999995" height="262.02" fill="#e53e3e" stroke="none"></rect><rect x="219.36" y="282.02" width="25.129999999999995" height="67.98000000000002" fill="#e53e3e" stroke="none"></rect><g transform="translate(410 40)"><rect x="0" y="0" width="160" height="3em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><rect x="15" y="0.7em" width="25" height="0.6em" fill="#1a365d" stroke="none"></rect><text x="55" y="1em">Quadratic</text><rect x="15" y="1.7em" width="25" height="0.6em" fill="#e53e3e" stroke="none"></rect><text x="55" y="2em">Cuckoo</text></g><text x="345" y="350">Probe length</text><text x="65" y="185" transform="rotate(-90 65 185)">% of operations</text></svg></p>
  <h2 id="side-benefits-of-cuckoo-probing">Side benefits of cuckoo probing</h2>
  <p>Cuckoo probing brings several practical benefits besides just performance.</p>
  <p>Cuckoo hashing supports arbitrary table sizes, rather than being restricted to power-of-2 table sizes like quadratic probing<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a>. Depending on the number of elements being stored, this can save up to 2× the memory footprint.</p>
  <p>For power-of-2-sized cuckoo tables, the table size can be doubled very efficiently in a completely branchless way without any search process, as follows. When growing the table size from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span></span></span></span> to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">2N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span>N</span></span></span></span>, take all elements that were stored in bucket <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> and store them in either bucket <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">B+N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>+</span><span></span></span><span><span></span><span>N</span></span></span></span> according to the newly unmasked hash bit. Since bucket <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> hadn’t overflowed before, neither bucket <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> nor <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">B+N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>+</span><span></span></span><span><span></span><span>N</span></span></span></span> will overflow afterwards, and so no search is required. This rehashing operation is extremely efficient: you can grow the table with <code>realloc</code> (avoiding the need to have <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">3N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span>N</span></span></span></span> memory live simultaneously) and then do a streaming pass over the buckets, with perfect memory system performance for hardware prefetchers (memory is accessed sequentially) and cache line locality (the working set is just two cache lines).</p>
  <p>Deleted elements in quadratic probing must leave <a href="https://research.cs.vt.edu/AVresearch/hashing/deletion.php">“tombstone”</a> entries in their place, rather than emptying out the element. This increases probe lengths, and if too many tombstones accumulate the table may need to be rebuilt from scratch to clear out the tombstones. Cuckoo probing does not require tombstones.</p>
  <p>Cuckoo hash tables are a great <em>wire format</em> for sending dictionaries. Both JSON and <a href="https://protobuf.dev/programming-guides/proto3/#maps">protocol buffers</a> natively support sending dictionaries. As part of deserializing, the receiver must do the work of building the hash table. Typically the sender has already done that work! Why can’t the sender send the exact hash table they had built? With quadratic probing, this opens you up to a <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">denial-of-service attack</a> by a malicious sender: they could construct the hash table such that probe lengths are extremely long and every query takes an extremely long time. With cuckoo probing, this is impossible: probes are bounded at length 2 by construction. Directly sending cuckoo tables on the wire seems plausible and efficient for binary serialization formats like <a href="https://capnproto.org/">Cap’n Proto</a> or <a href="https://flatbuffers.dev/">FlatBuffers</a>.</p>
  <h2 id="conclusion">Conclusion</h2>
  <p>Depending on the use case, different hash table layouts are optimal: whether you prioritize successful lookups versus failed lookups versus inserts; how much you are willing to spend memory to save time; whether you table is in cache or out of cache. Generally we find that, in cases where you care about memory footprint somewhat, i.e. for load factors larger than 50%, the best choice tends to be one that uses cuckoo hashing.</p>
  <p>In many real-world scenarios, the simpler algorithm beats the more complex algorithm. Cuckoo hashing appears to be a case where the more complex algorithm is actually worthwhile, provided it is engineered carefully.</p>
  <h2 id="appendix-engineering-a-high-performance-cuckoo-probing-scheme">Appendix: engineering a high-performance cuckoo probing scheme</h2>
  <p>Cuckoo hashing is more complex than quadratic probing, and you have to get several details right in order to make cuckoo probing competitive in performance with the best hash tables.</p>
  <h4 id="unaligned-buckets">Unaligned buckets</h4>
  <p>When performing SIMD probing, it is natural to start the probing at a position that is a multiple of the SIMD width, e.g. such that all SIMD loads are aligned on 16-element boundaries. This divides the table into 16-element “buckets”, and is known as a bucketed hash table. This is simple but typically not optimal.</p>
  <p>For both quadratic probing and cuckoo probing it is typically better to allow SIMD probes to be unaligned, determined by the initial hash code. This reduces “clustering” effects and lowers average probe length:</p>
  <p><svg id="probe-lengths-cuckoo-aligned-vs-unaligned" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="257.5" y="350">1</text><text x="432.5" y="350">2</text></g><g><text x="100" y="350">0</text><text x="100" y="284">20</text><text x="100" y="218">40</text><text x="100" y="152">60</text><text x="100" y="86">80</text><text x="100" y="20">100</text></g><rect x="187.5" y="94.31" width="70" height="255.69" fill="#1a365d" stroke="none"></rect><rect x="362.5" y="275.69" width="70" height="74.31" fill="#1a365d" stroke="none"></rect><rect x="257.5" y="113.94" width="70" height="236.06" fill="#e53e3e" stroke="none"></rect><rect x="432.5" y="256.06" width="70" height="93.94" fill="#e53e3e" stroke="none"></rect><g transform="translate(370 40)"><rect x="0" y="0" width="200" height="3em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><rect x="15" y="0.7em" width="25" height="0.6em" fill="#1a365d" stroke="none"></rect><text x="55" y="1em">Unaligned cuckoo</text><rect x="15" y="1.7em" width="25" height="0.6em" fill="#e53e3e" stroke="none"></rect><text x="55" y="2em">Aligned cuckoo</text></g><text x="345" y="350">Probe length</text><text x="65" y="185" transform="rotate(-90 65 185)">% of operations</text></svg></p>
  <p><svg id="probe-lengths-quadratic-aligned-vs-unaligned" width="640" height="400" viewBox="0 0 640 400" xmlns="http://www.w3.org/2000/svg"><path d="M590 350h-490v-330" fill="none" stroke="black" stroke-width="1"></path><g><text x="150.11" y="350">1</text><text x="205.8" y="350">2</text><text x="261.48" y="350">3</text><text x="317.16" y="350">4</text><text x="372.84" y="350">5</text><text x="428.52" y="350">6</text><text x="484.2" y="350">7</text><text x="539.89" y="350">8</text></g><g><text x="100" y="350">0</text><text x="100" y="308.75">10</text><text x="100" y="267.5">20</text><text x="100" y="226.25">30</text><text x="100" y="185">40</text><text x="100" y="143.75">50</text><text x="100" y="102.5">60</text><text x="100" y="61.25">70</text><text x="100" y="20">80</text></g><rect x="127.83500000000001" y="44.24" width="22.275000000000006" height="305.76" fill="#1a365d" stroke="none"></rect><rect x="183.525" y="293.54" width="22.275000000000006" height="56.45999999999998" fill="#1a365d" stroke="none"></rect><rect x="239.205" y="323.27" width="22.275000000000006" height="26.730000000000018" fill="#1a365d" stroke="none"></rect><rect x="294.88500000000005" y="338.34" width="22.274999999999977" height="11.660000000000025" fill="#1a365d" stroke="none"></rect><rect x="350.565" y="344" width="22.274999999999977" height="6" fill="#1a365d" stroke="none"></rect><rect x="406.245" y="346.81" width="22.274999999999977" height="3.1899999999999977" fill="#1a365d" stroke="none"></rect><rect x="461.925" y="348.42" width="22.274999999999977" height="1.579999999999984" fill="#1a365d" stroke="none"></rect><rect x="517.615" y="349.25" width="22.274999999999977" height="0.75" fill="#1a365d" stroke="none"></rect><rect x="150.11" y="60.75" width="22.275000000000006" height="289.25" fill="#e53e3e" stroke="none"></rect><rect x="205.8" y="281.84" width="22.275000000000006" height="68.16000000000003" fill="#e53e3e" stroke="none"></rect><rect x="261.48" y="322.62" width="22.274999999999977" height="27.379999999999995" fill="#e53e3e" stroke="none"></rect><rect x="317.16" y="336.9" width="22.274999999999977" height="13.100000000000023" fill="#e53e3e" stroke="none"></rect><rect x="372.84" y="342.73" width="22.274999999999977" height="7.269999999999982" fill="#e53e3e" stroke="none"></rect><rect x="428.52" y="346.15" width="22.274999999999977" height="3.8500000000000227" fill="#e53e3e" stroke="none"></rect><rect x="484.2" y="348.03" width="22.274999999999977" height="1.9700000000000273" fill="#e53e3e" stroke="none"></rect><rect x="539.89" y="349.04" width="22.274999999999977" height="0.9599999999999795" fill="#e53e3e" stroke="none"></rect><g transform="translate(340 40)"><rect x="0" y="0" width="230" height="3em" fill="#fff" stroke="#ccc" stroke-width="1"></rect><rect x="15" y="0.7em" width="25" height="0.6em" fill="#1a365d" stroke="none"></rect><text x="55" y="1em">Unaligned quadratic</text><rect x="15" y="1.7em" width="25" height="0.6em" fill="#e53e3e" stroke="none"></rect><text x="55" y="2em">Aligned quadratic</text></g><text x="345" y="350">Probe length</text><text x="65" y="185" transform="rotate(-90 65 185)">% of operations</text></svg></p>
  <p>For cuckoo hashing there is partial <a href="https://arxiv.org/pdf/1707.06855">theoretical validation</a> of this approach.</p>
  <p>Caveats: unaligned probing has slightly worse insertion times than aligned probing, mostly because the tricks of the following section do not apply. Additionally, unaligned probing is only compatible with Indirect SIMD layout.</p>
  <h4 id="producing-two-hash-functions">Producing two hash functions</h4>
  <p>An overhead of cuckoo hashing is that you must evaluate two hash functions rather than one, and evaluating hash functions can be expensive. Here are a few options, which are all fast and work well in practice, even though they somewhat violate the “hash function independence” assumptions required by the cuckoo hashing theory.</p>
  <p>If you prioritize lookup performance over insertion performance, the fastest choice is to compute the second hash function from the first by <code>hash1 = hash0.rotate_left(32)</code>. This takes just 1 instruction and 1 clock cycle on most current CPUs.</p>
  <p>If you care about insertion performance and you are using the Indirect SIMD table layout, you’d like to be able to switch between the two hash functions using only the single byte in the tag array, without consulting the metadata array. A good choice recommended by the <a href="https://www.cs.cmu.edu/~dga/papers/memc3-nsdi2013.pdf">MemC3 paper</a> is by XOR: <code>hash1 = hash0 ^ hash(tag)</code>, where <code>tag</code> is the 1-byte tag. As the paper notes, this construction allows you to go from the current bucket <code>b</code> of an entry to the alternate bucket <code>b2</code> by <code>b2 = b ^ hash(tag)</code>, without needing to know whether <code>b</code> is <code>hash0</code> or <code>hash1</code>. Many options for computing <code>hash(tag)</code> work, so long as they produce 64-bit outputs rather than 8-bit outputs. A simple option is to compute <code>hash(tag)</code> by lookup in a static <code>256 x u64</code> table populated at compile time with random numbers. Another option is <code>tag * MUL</code> for some randomly generated odd number <code>MUL</code>.</p>
  <p>If you are using Direct SIMD layout rather than Indirect SIMD layout, you have the whole key available. A simple option is then <code>hash1 = hash0 ^ hash0.rotate_left(32)</code>. You can move between buckets <code>b</code> and <code>b2</code> by <code>b2 = b ^ hash(key).rotate_left(32)</code>.</p>
  <p>The previous two approaches rely on power-of-2 table size for the “XOR trick” to work. This trick can be generalized to arbitrary table size with a few more instructions. Let <code>N</code> be the table size. Mathematically we’d like to compute</p>
  <pre><code>hash1 = (multiply_high(tag_hash, bucket_count) - hash0) % bucket_count</code></pre>
  <p>To avoid the expensive modulo (<code>%</code>) operator, we instead lower it to a predicated subtraction; the whole snippet executes in just <a href="https://rust.godbolt.org/z/vb64vq14G">4 fast instructions on x86-64 and AArch64</a>.</p>
  <h4 id="efficient-search-during-insertion">Efficient search during insertion</h4>
  <p>When inserting into a cuckoo table and there’s no free space in either bucket, you need to search for a sequence of element moves to make space. The main strategies from the literature are (a) “random walk”: randomly pick an element to evict and recurse, or (b) “breadth first search”: consider evicting <em>all</em> elements in parallel, recursively. Much of the literature tends to imply that random walk is faster in practice, because the search process state can be kept in CPU registers, whereas breadth first search requires maintaining a BFS queue in memory. However, consistent with the <a href="https://www.cs.princeton.edu/~mfreed/docs/cuckoo-eurosys14.pdf">second libcuckoo paper</a>, we find that breadth first search is faster. As the paper notes, breadth first search allows fetching many buckets in parallel (improving memory level parallelism), whereas random walk amounts to following a linked list and offers zero memory level parallelism.</p>
  <p>The only necessary search state is a BFS queue of bucket pointers. Parent pointers of the search tree don’t need to be explicitly stored; they can be recovered by index arithmetic similar to binary heaps, by observing that the BFS queue stores (two interleaved) level-ordered complete N-ary trees of buckets. Given that the breadth first search almost always terminates within 1–4 nodes of search, the most important optimization for the search is ensuring the setup time is minimized. Using a stack-allocated uninitialized BFS queue achieves that; this makes BFS much less attractive on managed languages like Java that don’t support this functionality.</p>
  <p>In addition to being faster, BFS also can sustain higher load factors than random walk does. This saves memory.</p>
  
  </div></div>
  </body>
</html>
