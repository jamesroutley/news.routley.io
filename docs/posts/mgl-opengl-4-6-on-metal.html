<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/openglonmetal/MGL">Original</a>
    <h1>MGL â€“ OpenGL 4.6 on Metal</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">

<p dir="auto">This is a start for porting OpenGL 4.6 on top of Metal, most of it is functional and has been tested. The tests are functional, not coverage tests so they test the functionality of a path not all the possible permutations.</p>
<h2 dir="auto"><a id="user-content-so-far-the-following-parts-of-opengl-work" aria-hidden="true" href="#so-far-the-following-parts-of-opengl-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>So far the following parts of OpenGL work</h2>
<ul dir="auto">
<li>Vertex Arrays</li>
<li>Buffers</li>
<li>Textures</li>
<li>Programs
<ul dir="auto">
<li>Shaders
<ul dir="auto">
<li>Vertex</li>
<li>Fragment</li>
<li>Compute</li>
</ul>
</li>
</ul>
</li>
<li>Samplers</li>
<li>Alpha Blending</li>
<li>Depth and Stencil Testing</li>
<li>Framebuffer Objects</li>
<li>Drawbuffers</li>
<li>Most of the draw calls</li>
<li>Elements / Instancing and such</li>
<li>Uniforms (partially)</li>
<li>UBOs</li>
</ul>
<h2 dir="auto"><a id="user-content-glfw-support" aria-hidden="true" href="#glfw-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>GLFW support</h2>
<p dir="auto">I modified a version of GLFW to work with MGL, it replaces the default MacOS OpenGL contexts. The changes are included in the repository and should build correctly with the MGL xcode project.</p>
<p dir="auto">(additional notes from conversy/MGL repo: the modified GLFW version is not mandatory, see below).</p>
<h2 dir="auto"><a id="user-content-mapping-opengl-onto-metal" aria-hidden="true" href="#mapping-opengl-onto-metal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Mapping OpenGL onto Metal</h2>
<p dir="auto">I mapped as much of the functionality of Metal I could into OpenGL 4.6, it&#39;s surprising how much I was able to map directly from OpenGL state to Metal. But I suppose Metal evolved to meet market requirements and since OpenGL was in place the same features existed just in another form.</p>
<p dir="auto">Not all of the functionality for OpenGL is available, but I didn&#39;t build this for conformance I just wanted to program OpenGL on the MacOS platform.</p>
<p dir="auto">Metal Hiearchy</p>
<div data-snippet-clipboard-copy-content="Command Queue
    Command Buffer
        Render Pipeline State &lt;- created with RenderPipelineDescriptor
            Render Encoder  &lt;-- created with RenderPassDescriptor
                RenderPassDescriptor
                    colorAttachments
                        pixelFormat
                        sourceRGBBlendFactor
                        sourceAlphaBlendFactor
                        destinationRGBBlendFactor
                        destinationAlphaBlendFactor
                        alphaBlendOperation
                        writeMask
                    depthAttachment
                        pixelFormat
                    stencilAttachment
                        pixelFormat
                    visibilityResultBuffer
                    renderTargetArrayLength
                    defaultRasterSampleCount
                    samplePositions
                    renderTargetWidth
                    renderTargetHeight

                
            DirectState for Render Encoder
                Vertex Function
                Fragment Function
                Vertex Descriptor
                Vertex Buffers
                Vertex Textures
                Viewport
                FrontFacingWinding
                CullMode
                DepthClipMode
                DepthBias
                ScissorRect
                TriangleFillMode
                Fragment Buffers
                Fragment Textures
                Fragment Samplers
                BlendColor
                StencilReferenceValue
                VisibilityResultMode
                ColorStoreMode
                DepthStoreMode
                DepthStoreAction
                StencilStoreAction
                DepthStoreActionOptions
                StencilStoreActionOptions
                
            Descriptor State used to change render ecoder
                Depth Stencil State &lt;- created with DepthStencil Descriptor
                    DepthStencilPipeline Descriptor
                        DepthStencil Descriptor
                            readMask
                            writeMask
                            depthCompareFunction
                            depthWriteEnabled
                            stencilCompareFunction
                            stencilFailureOperation
                            depthFailureOperation
                            depthStencilPassOperation
                            frontFaceStencil &lt;- created wtih StencilDescriptor
                            backFaceStencil &lt;- created wtih StencilDescriptor"><pre><code>Command Queue
    Command Buffer
        Render Pipeline State &lt;- created with RenderPipelineDescriptor
            Render Encoder  &lt;-- created with RenderPassDescriptor
                RenderPassDescriptor
                    colorAttachments
                        pixelFormat
                        sourceRGBBlendFactor
                        sourceAlphaBlendFactor
                        destinationRGBBlendFactor
                        destinationAlphaBlendFactor
                        alphaBlendOperation
                        writeMask
                    depthAttachment
                        pixelFormat
                    stencilAttachment
                        pixelFormat
                    visibilityResultBuffer
                    renderTargetArrayLength
                    defaultRasterSampleCount
                    samplePositions
                    renderTargetWidth
                    renderTargetHeight

                
            DirectState for Render Encoder
                Vertex Function
                Fragment Function
                Vertex Descriptor
                Vertex Buffers
                Vertex Textures
                Viewport
                FrontFacingWinding
                CullMode
                DepthClipMode
                DepthBias
                ScissorRect
                TriangleFillMode
                Fragment Buffers
                Fragment Textures
                Fragment Samplers
                BlendColor
                StencilReferenceValue
                VisibilityResultMode
                ColorStoreMode
                DepthStoreMode
                DepthStoreAction
                StencilStoreAction
                DepthStoreActionOptions
                StencilStoreActionOptions
                
            Descriptor State used to change render ecoder
                Depth Stencil State &lt;- created with DepthStencil Descriptor
                    DepthStencilPipeline Descriptor
                        DepthStencil Descriptor
                            readMask
                            writeMask
                            depthCompareFunction
                            depthWriteEnabled
                            stencilCompareFunction
                            stencilFailureOperation
                            depthFailureOperation
                            depthStencilPassOperation
                            frontFaceStencil &lt;- created wtih StencilDescriptor
                            backFaceStencil &lt;- created wtih StencilDescriptor
</code></pre></div>
<h2 dir="auto"><a id="user-content-parsing-the-opengl-46-xml-spec" aria-hidden="true" href="#parsing-the-opengl-46-xml-spec"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parsing the OpenGL 4.6 XML spec</h2>
<p dir="auto">In the beginning I used ezxml to parse the gl.xml file for all the enums and functions, then printed out one giant file with all the functions. I then used the same parser to create the dispatch tables and data structures. As each functional part was built I separated blocks of functions into these functions like buffers / textures / shaders / programs.</p>
<h2 dir="auto"><a id="user-content-spirv-to-metal" aria-hidden="true" href="#spirv-to-metal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SPIRV to Metal</h2>
<p dir="auto">I really couldn&#39;t have done this project without all the SPIRV support from Khronos, once I found out I could translate GLSL into Metal using some of the SPIRV tools this project became a reality. There are some parts in GLSL that Metal just doesn&#39;t support like Geometry Shaders, I think the way forward on support for Geometry Shaders is to translate the vertex and geometry shaders into LLVM from SPIRV then execute the results from processing them on the CPU through a passthrough vertex shader in the pipeline. Some parts of the GLSL spec probably won&#39;t map to Metal but more testing and exposure to developers will show what works and what doesn&#39;t/</p>
<h2 dir="auto"><a id="user-content-opengl-functions-and-how-they-work" aria-hidden="true" href="#opengl-functions-and-how-they-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>OpenGL functions and how they work</h2>
<p dir="auto">Each OpenGL function starts in gl_core.c</p>
<div dir="auto" data-snippet-clipboard-copy-content="void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels)
{
    GLMContext ctx = GET_CONTEXT();

    ctx-&gt;dispatch.tex_image2D(ctx, target, level, internalformat, width, height, border, format, type, pixels);
}"><pre><span>void</span> <span>glTexImage2D</span>(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, <span>const</span> <span>void</span> *pixels)
{
    GLMContext ctx = <span>GET_CONTEXT</span>();

    ctx-&gt;<span>dispatch</span>.<span>tex_image2D</span>(ctx, target, level, internalformat, width, height, border, format, type, pixels);
}</pre></div>
<p dir="auto">glTexImage2D calls into a dispatch table which lands on a mgl equivalent</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mglTexImage2D(GLMContext ctx, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels) {
    Texture *tex;
    GLuint face;
    GLboolean is_array;
    GLboolean proxy;

    face = 0;
    is_array = false;
    proxy = false;

    switch(target)
    {
        case GL_TEXTURE_2D:
            break;

        case GL_PROXY_TEXTURE_2D:
        case GL_PROXY_TEXTURE_CUBE_MAP:
            proxy = true;
            break;

        case GL_PROXY_TEXTURE_1D_ARRAY:
            is_array = true;
            proxy = true;
            break;

        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
            face = target - GL_TEXTURE_CUBE_MAP_POSITIVE_X;
            break;

        case GL_PROXY_TEXTURE_RECTANGLE:
            proxy = true;
            ERROR_CHECK_RETURN(level==0, GL_INVALID_OPERATION);
            break;

        case GL_TEXTURE_RECTANGLE:
            ERROR_CHECK_RETURN(level==0, GL_INVALID_OPERATION);
            break;

        default:
            ERROR_RETURN(GL_INVALID_ENUM);
    }

    ERROR_CHECK_RETURN(level &gt;= 0, GL_INVALID_VALUE);

    // verifyFormatType sets the error
    ERROR_CHECK_RETURN(verifyInternalFormatAndFormatType(ctx, internalformat, format, type), 0);

    ERROR_CHECK_RETURN(width &gt;= 0, GL_INVALID_VALUE);
    ERROR_CHECK_RETURN(height &gt;= 0, GL_INVALID_VALUE);

    ERROR_CHECK_RETURN(border == 0, GL_INVALID_VALUE);

    tex = getTex(ctx, 0, target);

    ERROR_CHECK_RETURN(tex, GL_INVALID_OPERATION);

    tex-&gt;access = GL_READ_ONLY;

    createTextureLevel(ctx, tex, face, level, is_array, internalformat, width, height, 1, format, type, (void *)pixels, proxy);
}"><pre><span>void</span> <span>mglTexImage2D</span>(GLMContext ctx, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, <span>const</span> <span>void</span> *pixels) {
    Texture *tex;
    GLuint face;
    GLboolean is_array;
    GLboolean proxy;

    face = <span>0</span>;
    is_array = <span>false</span>;
    proxy = <span>false</span>;

    <span>switch</span>(target)
    {
        <span>case</span> GL_TEXTURE_2D:
            <span>break</span>;

        <span>case</span> GL_PROXY_TEXTURE_2D:
        <span>case</span> GL_PROXY_TEXTURE_CUBE_MAP:
            proxy = <span>true</span>;
            <span>break</span>;

        <span>case</span> GL_PROXY_TEXTURE_1D_ARRAY:
            is_array = <span>true</span>;
            proxy = <span>true</span>;
            <span>break</span>;

        <span>case</span> GL_TEXTURE_CUBE_MAP_POSITIVE_X:
        <span>case</span> GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
        <span>case</span> GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
        <span>case</span> GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
        <span>case</span> GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
        <span>case</span> GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
            face = target - GL_TEXTURE_CUBE_MAP_POSITIVE_X;
            <span>break</span>;

        <span>case</span> GL_PROXY_TEXTURE_RECTANGLE:
            proxy = <span>true</span>;
            <span>ERROR_CHECK_RETURN</span>(level==<span>0</span>, GL_INVALID_OPERATION);
            <span>break</span>;

        <span>case</span> GL_TEXTURE_RECTANGLE:
            <span>ERROR_CHECK_RETURN</span>(level==<span>0</span>, GL_INVALID_OPERATION);
            <span>break</span>;

        <span>default</span>:
            <span>ERROR_RETURN</span>(GL_INVALID_ENUM);
    }

    <span>ERROR_CHECK_RETURN</span>(level &gt;= <span>0</span>, GL_INVALID_VALUE);

    <span><span>//</span> verifyFormatType sets the error</span>
    <span>ERROR_CHECK_RETURN</span>(<span>verifyInternalFormatAndFormatType</span>(ctx, internalformat, format, type), <span>0</span>);

    <span>ERROR_CHECK_RETURN</span>(width &gt;= <span>0</span>, GL_INVALID_VALUE);
    <span>ERROR_CHECK_RETURN</span>(height &gt;= <span>0</span>, GL_INVALID_VALUE);

    <span>ERROR_CHECK_RETURN</span>(border == <span>0</span>, GL_INVALID_VALUE);

    tex = <span>getTex</span>(ctx, <span>0</span>, target);

    <span>ERROR_CHECK_RETURN</span>(tex, GL_INVALID_OPERATION);

    tex-&gt;<span>access</span> = GL_READ_ONLY;

    <span>createTextureLevel</span>(ctx, tex, face, level, is_array, internalformat, width, height, <span>1</span>, format, type, (<span>void</span> *)pixels, proxy);
}</pre></div>
<p dir="auto">The mgl function checks input parameters then modifies the OpenGL state and marks it dirty. I use macros for error checking parameters... because I got sick of writing.</p>
<div dir="auto" data-snippet-clipboard-copy-content="if (expr == false) {
  set error
  return;
}"><pre><span>if</span> (expr == <span>false</span>) {
  set error
  <span>return</span>;
}</pre></div>
<h2 dir="auto"><a id="user-content-common-use-of-code-for-most-opengl-calls" aria-hidden="true" href="#common-use-of-code-for-most-opengl-calls"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Common use of code for most OpenGL calls</h2>
<p dir="auto">Most functions are like mglTexImage2D, there a lot of common entry points which check parameters then call a function like createTextureLevel() which is used by all the TexImage calls to do the actual work.</p>
<h2 dir="auto"><a id="user-content-opengl-state-translated-to-metal-using-gldrawarrays-as-an-example" aria-hidden="true" href="#opengl-state-translated-to-metal-using-gldrawarrays-as-an-example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>OpenGL state translated to Metal using glDrawArrays as an example</h2>
<p dir="auto">All state changes are evaluated on direct commands, these are commands that will issue a command to the GPU for things like drawing primitives, copying data or executing compute kernels.</p>
<p dir="auto">Looking at glDrawArrays..</p>
<p dir="auto">glDrawArrays lands on mglDrawArrays which does parameter testing and calls the Objective C interface through a jump table in the context. This lands you in MGLRenderere.m</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mglDrawArrays(GLMContext ctx, GLenum mode, GLint first, GLsizei count)
{
    ERROR_CHECK_RETURN(check_draw_modes(mode), GL_INVALID_ENUM);

    ERROR_CHECK_RETURN(count &gt; 1, GL_INVALID_VALUE);

    ERROR_CHECK_RETURN(validate_vao(ctx), GL_INVALID_VALUE);

    ERROR_CHECK_RETURN(validate_program(ctx), GL_INVALID_VALUE);

    ctx-&gt;mtl_funcs.mtlDrawArrays(ctx, mode, first, count);
}"><pre><span>void</span> <span>mglDrawArrays</span>(GLMContext ctx, GLenum mode, GLint first, GLsizei count)
{
    <span>ERROR_CHECK_RETURN</span>(<span>check_draw_modes</span>(mode), GL_INVALID_ENUM);

    <span>ERROR_CHECK_RETURN</span>(count &gt; <span>1</span>, GL_INVALID_VALUE);

    <span>ERROR_CHECK_RETURN</span>(<span>validate_vao</span>(ctx), GL_INVALID_VALUE);

    <span>ERROR_CHECK_RETURN</span>(<span>validate_program</span>(ctx), GL_INVALID_VALUE);

    ctx-&gt;<span>mtl_funcs</span>.<span>mtlDrawArrays</span>(ctx, mode, first, count);
}</pre></div>
<p dir="auto">Which lands you in Objective C land, we do a C interface call to Objecitve C here</p>
<div dir="auto" data-snippet-clipboard-copy-content="void mtlDrawArrays(GLMContext glm_ctx, GLenum mode, GLint first, GLsizei count)
{
    // Call the Objective-C method using Objective-C syntax
    [(__bridge id) glm_ctx-&gt;mtl_funcs.mtlObj mtlDrawArrays: glm_ctx mode: mode first: first count: count];
}"><pre><span>void</span> <span>mtlDrawArrays</span>(GLMContext glm_ctx, GLenum mode, GLint first, GLsizei count)
{
    <span><span>//</span> Call the Objective-C method using Objective-C syntax</span>
    [(__bridge id) glm_ctx-&gt;<span>mtl_funcs</span>.<span>mtlObj</span> mtlDrawArrays: glm_ctx mode: mode first: first count: count];
}</pre></div>
<p dir="auto">And now we speak Objective C</p>
<div dir="auto" data-snippet-clipboard-copy-content="-(void) mtlDrawArrays: (GLMContext) ctx mode:(GLenum) mode first: (GLint) first count: (GLsizei) count
{
    MTLPrimitiveType primitiveType;

    RETURN_ON_FAILURE([self processGLState: true]);

    primitiveType = getMTLPrimitiveType(mode);
    assert(primitiveType != 0xFFFFFFFF);

     [_currentRenderEncoder drawPrimitives: primitiveType
                              vertexStart: first
                              vertexCount: count];
}"><pre>-(<span>void</span>) mtlDrawArrays: (GLMContext) ctx mode:(GLenum) mode first: (GLint) first count: (GLsizei) count
{
    MTLPrimitiveType primitiveType;

    <span>RETURN_ON_FAILURE</span>([self processGLState: <span>true</span>]);

    primitiveType = <span>getMTLPrimitiveType</span>(mode);
    <span>assert</span>(primitiveType != <span>0xFFFFFFFF</span>);

     [_currentRenderEncoder drawPrimitives: primitiveType
                              vertexStart: first
                              vertexCount: count];
}</pre></div>
<h2 dir="auto"><a id="user-content-processglstate-does-all-the-state-mapping-from-opengl-to-metal" aria-hidden="true" href="#processglstate-does-all-the-state-mapping-from-opengl-to-metal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>processGLState does all the state mapping from OpenGL to Metal</h2>
<p dir="auto">On OpenGL drawing calls the OpenGL state is processed for any dirty state in processGLState, you have to do this before each draw command to ensure changed state is captured into Metal.</p>
<p dir="auto">State is transferred from OpenGL to Metal state using a Metal command queue with a MTLRenderCommandEncoder. Occasionally a new MTLRenderCommandEncoder will need to be built if the state changes need to modify the MTLRenderPipelineState so neRenderEncoder is called to create a new encoder with the current OpenGL state.</p>
<p dir="auto">Most of the work is done in MGLRenderer.m, at first it can look like a giant piece of code. But it&#39;s simple once you figure out the mapping process.</p>

<p dir="auto">You have to bind all the buffers and textures to Metal, there are mapping operations you need to do to transfer OpenGL buffers / textures to Metal. Since all of this is driven by the GLSL shader in 4.5 which requires you to map your bindings and locations</p>
<p dir="auto">An example vertex shader defines a vertex buffer object at location 0 and a uniform buffer at binding 0.  These are not the same location, but relative to the type.</p>
<div data-snippet-clipboard-copy-content="const char* vertex_shader =
GLSL(450 core,
     layout(location = 0) in vec3 position;

     layout(binding = 0) uniform matrices
     {
         mat4 rotMatrix;
     };

     void main() {
        gl_Position = rotMatrix * vec4(position, 1.0);
     }
);"><pre><code>const char* vertex_shader =
GLSL(450 core,
     layout(location = 0) in vec3 position;

     layout(binding = 0) uniform matrices
     {
         mat4 rotMatrix;
     };

     void main() {
        gl_Position = rotMatrix * vec4(position, 1.0);
     }
);
</code></pre></div>
<p dir="auto">Each binding point in OpenGL is a 2D array one for each type, like GL_ARRAY_BUFFER</p>
<div data-snippet-clipboard-copy-content="glBindBuffer(GL_ARRAY_BUFFER, vbo);"><pre><code>glBindBuffer(GL_ARRAY_BUFFER, vbo);
</code></pre></div>
<p dir="auto">Indexes an array like</p>
<div data-snippet-clipboard-copy-content="buffers[GL_ARRAY_BUFFER].buffer = vbo"><pre><code>buffers[GL_ARRAY_BUFFER].buffer = vbo
</code></pre></div>
<p dir="auto">So internal to processGLState the vertex buffer array is taken apart, buffers and attributes mapped then we walk through uniforms / textures through their binding points in the GL state and map these to Metal state.</p>
<p dir="auto">Once you walk a glDrawArrays call through processGLState, you will get a jist of how this all works.</p>
<h2 dir="auto"><a id="user-content-build" aria-hidden="true" href="#build"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Build</h2>
<p dir="auto">See BUILD.md</p>
<h2 dir="auto"><a id="user-content-where-to-start" aria-hidden="true" href="#where-to-start"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Where to start</h2>
<p dir="auto">Use the Xcode MGL project to build your own tests and projects... start by building test_mgl_glfw, this is a chunk of test code I used to get most of the functionality up and running. Xcode has all the debugging tools and won&#39;t leave you wondering WTF is that assert about, throwing your hands up and walking away without learning anything about the internals of OpenGL or contributing to this project.</p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">I updated most of the immutible objects to allocate metal object up front, this is how to avoid the deferred allocation used in OpenGL and increase performance. The performance on simple tests using a FBO / draw element instance / uniform update in a simple test I wrote is negligiable.. you had to run the loop over 100,000,000 times to extract any difference.
So.. it should be good.</p>
<h2 dir="auto"><a id="user-content-missing-functions" aria-hidden="true" href="#missing-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Missing functions</h2>
<p dir="auto">There are a lot of missing functions, if you open up XCode and look at the project you will see many functions defined and laid out but are just bracketed around an assert(0); If you want functionality just work with the XCode project with test_mgl_glfw.. pick a test like test_2d_array_textures and walk through each function using the debugger and you will get a gist on how it all works.
This is the best way to start adding functionality, until you open it up it will remain a black box. From there just read the GL spec for the function you need, add it in bits by building a test for it and verifying the functionality.</p>
<h2 dir="auto"><a id="user-content-why-the-focus-on-46-functionality" aria-hidden="true" href="#why-the-focus-on-46-functionality"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why the focus on 4.6 functionality?</h2>
<p dir="auto">OpenGL is huge, and the effort was intended capture 4.6 functionality rather than try to implement it all (and that includes a lot of 3.x functionality). This is a good path to embed functionality into the base then add in all the older functionality later using the paths you want rather than hacking apart older paths to make modern OpenGL functionality.</p>
<h2 dir="auto"><a id="user-content-contributing" aria-hidden="true" href="#contributing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributing</h2>
<p dir="auto">If you want to contribute that would be great, it&#39;s all written in C.. in the same style all of the OpenGL framework from Apple was written in. If you don&#39;t like the coding style, don&#39;t change it. Just follow the same coding style and put your efforts into testing and functionality.</p>
<p dir="auto">We really need people to contribute to the functionality and testing rather than trying to just build MGL and see if it works with their application. If you can write C code you can probably figure out how MGL works and contribute.</p>
<p dir="auto">Its a great way to learn the internals of OpenGL and Metal at the same time, and if you are a college student.. or even an expirienced coder its going to look great on a resume that you actually did work on OpenGL internals and its not just a black box to you. A typical driver for a graphics driver will have hundreds of thousands of lines of code and its all state driven regardless of what they say about new interfaces like Metal or Vulkan, because hardware doesn&#39;t match these interfaces directly you have to evaluate state like OpenGL does but at a more abstract level.</p>
<h2 dir="auto"><a id="user-content-future" aria-hidden="true" href="#future"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Future</h2>
<p dir="auto">I will continue to implement functionality as needed, I had a goal of implementing OpenGL 4.6 functional paths for buffers, textures, shaders (vertex, fragment, and compute shaders) to release it. Now that that is done my own application uses it and it works fine. But more tests and bugs need to written to bring it to a stage that it can be just compiled and distributed with a Makefile.</p>
<h2 dir="auto"><a id="user-content-questions" aria-hidden="true" href="#questions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Questions?</h2>
<p dir="auto">You can reach me at <a href="mailto:sandstormsoftware@gmail.com">sandstormsoftware@gmail.com</a> for more information, it would be great to see this used by others and developed into a full fledged project anyone can use.</p>
<p dir="auto">Cheers</p>
<p dir="auto">Mike</p>
</article>
          </div></div>
  </body>
</html>
