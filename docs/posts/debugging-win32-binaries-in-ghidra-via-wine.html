<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://john-millikin.com/debugging-win32-binaries-in-ghidra-via-wine">Original</a>
    <h1>Debugging Win32 Binaries in Ghidra via Wine</h1>
    
    <div id="readability-page-1" class="page"><div><h2 slot="title">Building a simple Win32 binary on Linux</h2><p>If you&#39;ve already got a Win32 binary you&#39;re interested in analyzing, you can skip this step.</p><p>For the purposes of testing and writing blog posts, it&#39;s useful to have a simple &#34;hello world&#34; binary that doesn&#39;t have much fancy stuff going on. This is the code to a minimal Win32 console program:</p><blog-code syntax="c"><pre>#include &lt;windows.h&gt;

static const char message[] = &#34;Hello, world!\n&#34;;
static const int message_len = sizeof(message);

int __stdcall mainCRTStartup(void) {
    HANDLE stdout = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD bytes_written;
    WriteFile(stdout, message, message_len, &amp;bytes_written, NULL);
    return 0;
}</pre></blog-code><p>To compile a <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a> binary in Linux you can either use Wine to install the <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK</a>, or use a cross-compiler. The Windows SDK is a bit of a pain to install since it&#39;s distributed as an ISO image full of installer wizards, so I choose the second option. For cross-compilation I prefer to use Clang and LLD whenever possible since they&#39;re &#34;native&#34; cross-compilers, which means that (unlike GNU GCC/LD) their target platform can be selected at runtime.</p><blog-code syntax="commands"><pre>WINE=&#34;${HOME}/.opt/wine-7.15&#34;
clang -target i386-pc-win32 -O2 -c \
#   -isystem &#34;${WINE}&#34;/include/wine/windows \
#   -isystem &#34;${WINE}&#34;/include/wine/msvcrt \
#   hello-win32.c
ld.lld -flavor link \
#   /out:hello-win32.exe \
#   /nxcompat:no \
#   /subsystem:console \
#   /defaultlib:kernel32 \
#   hello-win32.o</pre></blog-code><p>If you don&#39;t have a copy of <tt>kernel32.lib</tt> from the Windows SDK, a usable substitute can be generated from <a href="https://gitlab.winehq.org/wine/wine/-/blob/wine-7.15/dlls/kernel32/kernel32.spec"><tt>kernel32.spec</tt></a> in Wine&#39;s source tree.</p><blog-code syntax="commands"><pre>WINE_SRC=&#34;${HOME}/src/third_party/winehq.org/wine-7.15&#34;
&#34;${WINE}&#34;/bin/winebuild --def \
#   -E &#34;${WINE_SRC}&#34;/dlls/kernel32/kernel32.spec \
#   -o kernel32.def
llvm-dlltool -m i386 -k -d kernel32.def -l kernel32.lib</pre></blog-code><p>Double-check that the executable works:</p><blog-code syntax="commands"><pre>wine hello-win32.exe
# Hello, world!</pre></blog-code></div><div><h2 slot="title">Debugging with gdbserver.exe</h2><p>First, install both Linux and Windows builds of <a href="https://www.sourceware.org/gdb/">GDB</a>, configured with <tt>--target=i686-w64-mingw32</tt>. On Ubuntu an appropriate build of GDB can be installed with <tt>apt install gdb-mingw-w64 gdb-mingw-w64-target</tt>.</p><p>The <tt>gdbserver.exe</tt> process will run &#34;inside&#34; Wine, and use Windows debugging APIs to control the binary being debugged. It listens on a TCP socket implementing the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">GDB remote serial protocol</a>.</p><blog-code syntax="commands"><pre>wine /usr/share/win32/gdbserver.exe localhost:10000 ./hello-win32.exe
# Listening on port 10000</pre></blog-code><p>The <tt>i686-w64-mingw32-gdb</tt> process runs in the Linux environment, and provides a REPL that can control the &#34;remote&#34; gdbserver. This process is necessary because Ghidra doesn&#39;t directly speak the GDB serial protocol, it controls GDB through the text UI. Before starting up Ghidra, verify that the GDB bits are working:</p><blog-code syntax="commands"><pre>/usr/bin/i686-w64-mingw32-gdb</pre></blog-code><blog-code syntax="commands" prompt="(gdb)"><pre>file ~/ghidra/hello-win32.exe
# Reading symbols from ~/ghidra/hello-win32.exe...
# (No debugging symbols found in ~/ghidra/hello-win32.exe)
target extended-remote :10000
# Remote debugging using :10000
# Reading C:/windows/system32/ntdll.dll from remote target...
# warning: File transfers from remote targets can be slow. Use &#34;set sysroot&#34; to access files locally instead.
# Reading C:/windows/system32/kernel32.dll from remote target...
# Reading C:/windows/system32/kernelbase.dll from remote target...
# 0x7bc7eb01 in ?? ()</pre></blog-code></div><div><h2 slot="title">Shimming the GDB memory map</h2><p>There&#39;s two problems we&#39;re facing here:</p><ul><li>First, we need to get access to the <tt>/proc/{pid}/maps</tt> file corresponding to the target process, parse it, and render output that matches what Ghidra expects from GDB.</li><li>Second, the gdbserver is running inside Wine and therefore uses Windows process IDs. There&#39;s no way to query the Linux process ID for a Windows process; such an API obviously doesn&#39;t exist in Windows, and Wine developers have declined to implement it as an extension.</li></ul><p>The memory map parsing/formatting sounds tricky but is actually pretty straightforward because the format of <tt>info proc maps</tt> is <i>almost</i> the same as what GDB provides, and Ghidra doesn&#39;t care about the differences. The <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">GDB Python API</a> can be used to define a new <tt>remote-proc-mappings</tt> command, which reads <tt>/proc/{pid}/maps</tt> for any process in accessible to the remote gdbserver.</p><blog-code syntax="python"><pre>import contextlib
import os
import threading

@contextlib.contextmanager
def pipe_fds():
    r_fd, w_fd = os.pipe()
    r_file = os.fdopen(r_fd, mode=&#34;rb&#34;)
    w_file = os.fdopen(w_fd, mode=&#34;wb&#34;)
    try:
        yield (r_file, w_file)
    finally:
        r_file.close()
        w_file.close()

class ReadThread(threading.Thread):
    def __init__(self, reader):
        super(ReadThread, self).__init__()
        self.__r = reader
        self.bytes = None

    def run(self):
        self.bytes = bytearray(self.__r.read())

def reformat_line(raw_line):
    split = raw_line.decode(&#34;utf-8&#34;).split(None, 5)
    # split[0] range
    # split[1] mode
    # split[2] offset
    # split[3] major_minor
    # split[4] inode
    # split[5] object name
    start_addr_s, end_addr_s = split[0].split(&#34;-&#34;)
    start_addr = int(start_addr_s, 16)
    end_addr = int(end_addr_s, 16)
    if len(split) == 6:
        objfile = split[5]
    else:
        objfile = &#34;&#34;
    return &#34;0x{:X} 0x{:X} 0x{:X} 0x{:X} {} {}\n&#34;.format(
        start_addr, end_addr,
        end_addr - start_addr,
        int(split[2], 16),
        split[1],
        objfile,
    )

class RemoteProcMappings(gdb.Command):
    def __init__(self):
        super(RemoteProcMappings, self).__init__(&#34;remote-proc-mappings&#34;, gdb.COMMAND_STATUS)

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)
        if len(argv) != 1:
            gdb.write(&#34;usage: remote-proc-mappings PID\n&#34;, gdb.STDERR)
            return

        remote_pid = int(argv[0])

        with pipe_fds() as (r_file, w_file):
            read_thread = ReadThread(reader = r_file)
            read_thread.start()
            maps_path = &#34;/proc/{}/maps&#34;.format(remote_pid)
            pipe_writer_path = &#34;/dev/fd/{}&#34;.format(w_file.fileno())
            gdb.execute(&#34;remote get {} {}&#34;.format(maps_path, pipe_writer_path))
            w_file.close()
            read_thread.join()
            raw_bytes = read_thread.bytes

        for raw_line in raw_bytes.split(b&#34;\n&#34;):
            if raw_line:
                gdb.write(reformat_line(raw_line))

RemoteProcMappings()</pre></blog-code><p>Next we need the Linux PID. Luckily(?) Wine allows Win32 binaries to directly invoke Linux syscalls via the <a href="https://john-millikin.com/unix-syscalls/#linux-i386-interrupt"><tt>INT 0x80</tt></a> instruction, so a straightforward approach is to inject a <tt>linux_getpid()</tt> function into the target process&#39;s address space and then use GDB&#39;s <tt>call</tt> command to run it.</p><p>Many Windows binaries have executable stacks (<tt>/nxcompat:no</tt>), which makes this super easy:</p><blog-code syntax="shell"><pre>define getpid-linux-i386
  # MOV eax,20 [SYS_getpid]
  # INT 0x80
  # RET
  set $linux_getpid = {int (void)}($esp-7)
  set {unsigned char[8]}($linux_getpid) = {\
    0xB8, 0x14, 0x00, 0x00, 0x00, \
    0xCD, 0x80, \
    0xC3 \
  }
  output $linux_getpid()
  echo \n
end</pre></blog-code><p>If the above command causes a segfault then the binary was probably compiled with <tt>/nxcompat</tt>, which places the stack in a non-executable mapping. Luckily(?) again, Windows processes map their <tt>.text</tt> segment to a fixed offset (by default <tt>0x401000</tt>), so you can use Ghidra to locate some function padding or an unused error branch or whatever and write the getpid stub there:</p><blog-code syntax="shell"><pre>define getpid-linux-i386
  # MOV eax,20 [SYS_getpid]
  # INT 0x80
  # RET
  set $linux_getpid = {int (void)}0x401020
  set {unsigned char[8]}($linux_getpid) = {\
    0xB8, 0x14, 0x00, 0x00, 0x00, \
    0xCD, 0x80, \
    0xC3 \
  }
  output $linux_getpid()
  echo \n
end</pre></blog-code><p>With these two custom commands defined, it&#39;s now possible to override <tt>info proc mappings</tt> to (1) find the Linux pid, and (2) report its memory mappings to Ghidra.</p><blog-code syntax="shell"><pre>source ~/ghidra/getpid-linux-i386.gdb
source ~/ghidra/remote-proc-mappings.py

define info proc mappings
  python
remote_pid = gdb.execute(&#34;getpid-linux-i386&#34;, to_string=True).strip()
gdb.execute(&#34;remote-proc-mappings {}&#34;.format(remote_pid))
  end
end</pre></blog-code><p>Put that into a <tt>wine-win32.gdb</tt> file and source it from Ghidra&#39;s GDB interpreter panel. Note that to make Ghidra happy the <tt>info proc mappings</tt> command must be overridden before connecting to the remote gdbserver.</p><p>Since they&#39;re regular GDB commands, they can also be used from the command line:</p><blog-code syntax="commands" prompt="(gdb)"><pre>file ~/ghidra/hello-win32.exe
# Reading symbols from ~/ghidra/hello-win32.exe...
# (No debugging symbols found in ~/ghidra/hello-win32.exe)
source ~/ghidra/wine-win32.gdb
target extended-remote :10000
# Remote debugging using :10000
# Reading C:/windows/system32/ntdll.dll from remote target...
# warning: File transfers from remote targets can be slow. Use &#34;set sysroot&#34; to access files locally instead.
# Reading C:/windows/system32/kernel32.dll from remote target...
# Reading C:/windows/system32/kernelbase.dll from remote target...
# 0x7bc7eb01 in ?? ()
getpid-linux-i386
# 1872324
</pre></blog-code><p>When loaded into Ghidra&#39;s GDB session, the trace recording works and the dynamic analysis functionality (Dynamic panel, Regions panel, etc) work as expected.</p><p><a href="https://john-millikin.com/by-sha256/c85f6e19edfbd2f162f2bb97008663619a26fc7e3f315c80bfe2fa9e59522db1/06_record-with-getpid.png"><img src="https://john-millikin.com/by-sha256/c85f6e19edfbd2f162f2bb97008663619a26fc7e3f315c80bfe2fa9e59522db1/06_record-with-getpid.png"/></a></p><p>Ghidra is able to disassemble code injected at runtime. Here, the Dynamic panel shows our <tt>linux_getpid</tt> code injected at 0x401020.</p><p><a href="https://john-millikin.com/by-sha256/5a31c22dceb78e7175acd1890b7f3d8adc281a2e2392ed0e6c3f83a63ad1061b/07_dynamic-view.png"><img src="https://john-millikin.com/by-sha256/5a31c22dceb78e7175acd1890b7f3d8adc281a2e2392ed0e6c3f83a63ad1061b/07_dynamic-view.png"/></a></p></div></div>
  </body>
</html>
