<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/sql-join/">Original</a>
    <h1>SQL Join Flavors</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><div><header></header><p>There is more to SQL joins than you might think. Let&#39;s explore them a bit.</p><p>We&#39;ll use two simple tables: <code>companies</code> and <code>jobs</code> they offer.</p><p>There are three completely fictional companies — Hoogle, Emazon and Neta — that offer a surprisingly small number of jobs:</p><pre tabindex="0"><code>  jobs                                   companies
┌────────┬─────────┬──────────────┐    ┌─────────┬───────────┐
│ job_id │ comp_id │   job_name   │    │ comp_id │ comp_name │
├────────┼─────────┼──────────────┤    ├─────────┼───────────┤
│ 1      │ 10      │ Data Analyst │    │ 10      │ Hoogle    │
│ 2      │ 20      │ Go Developer │    │ 20      │ Emazon    │
│ 3      │ 20      │ ML Engineer  │    │ 30      │ Neta      │
│ 4      │ 99      │ UI Designer  │    └─────────┴───────────┘
└────────┴─────────┴──────────────┘
</code></pre><p><em>(swipe left to see the companies)</em></p><p>Hoogle is interested in Data analysts. Emazon is hiring Go developers and ML engineers. Neta is not hiring at all. And some unknown company with id <code>99</code> is desperately looking for a UI designer.</p><p>Now let&#39;s join!</p><ul><li><a href="#qualified-join">Qualified join</a></li><li><a href="#natural-join">Natural join</a></li><li><a href="#cross-join">Cross join</a></li><li><a href="#partitioned-join">Partitioned join</a></li><li><a href="#lateral-join">Lateral join</a></li><li><a href="#summary">Summary</a></li></ul><h2 id="qualified-join">Qualified join</h2><p>&#34;Qualified join&#34; is a umbrella term for the most common types of joins: <code>inner</code>, <code>left</code>, <code>right</code> and <code>full</code>. If you haven&#39;t heard of these or have forgotten what they do, I suggest you check out the <a href="https://antonz.org/sql-cheatsheet/">SQL Cheat Sheet</a>.</p><p>A qualified join connects records from two datasets into one, according to the matching criteria you specify. Here is how it looks like in general:</p><pre tabindex="0"><code>table [join-type] JOIN table join-specification
</code></pre><p>A <code>table</code> is not necessarily a table per se. It can be a view, a subquery, or basically any table-like structure. But we&#39;ll call it &#34;table&#34; for brevity.</p><p>A <code>join-type</code> is one of the following:</p><div><div><figure><img src="https://antonz.org/sql-join/qualified-1.png" alt="Join types"/><figcaption>Four join types ought to be enough for anybody.</figcaption></figure></div></div><ul><li><code>inner</code> includes only matching rows from <em>both</em> tables.</li><li><code>left</code> includes matching rows from both tables and non-matching rows from the <em>left</em> table.</li><li><code>right</code> includes matching rows from both tables and non-matching rows from the <em>right</em> table.</li><li><code>full</code> includes matching rows from both tables and non-matching rows from <em>both</em> tables.</li></ul><p>There is also an optional <code>outer</code> keyword for left, right, and full joins, which changes nothing (as if SQL wasn&#39;t complex enough):</p><pre tabindex="0"><code>LEFT OUTER  = LEFT
RIGHT OUTER = RIGHT
FULL OUTER  = FULL
</code></pre><p>Oh, and the entire <code>join-type</code> can also be omitted. By default, every join is an <code>inner</code> join.</p><p>A <code>join-specification</code> defines the matching criteria. It comes in two flavors.</p><div><div><figure><img src="https://antonz.org/sql-join/qualified-2.png" alt="Join specification"/><figcaption>Join &#34;on&#34; specific columns or &#34;using&#34; a common one? Make your choice, adventurer.</figcaption></figure></div></div><p>The first one uses the <code>on</code> keyword, which you&#39;ve probably seen a thousand times. For example, let&#39;s select jobs with corresponding company names:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>
</span></span><span><span>  <span>join</span> <span>companies</span> <span>on</span> <span>jobs</span>.<span>comp_id</span> <span>=</span> <span>companies</span>.<span>comp_id</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>The second <code>join-specification</code> flavor is less known. It employs the <code>using</code> keyword and works only if the column we are joining on has the same name in both tables:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>
</span></span><span><span>  <span>join</span> <span>companies</span> <span>using</span>(<span>comp_id</span>);
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>While we can use any comparison operator with <code>on</code>, <code>using</code> only checks for equality.</p><p>Nice!</p><h2 id="natural-join">Natural join</h2><p>A natural join is like a qualified join with <code>using</code>, except that we don&#39;t specify matching column names at all:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>
</span></span><span><span>  <span>natural</span> <span>join</span> <span>companies</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>A natural join finds <em>all</em> pairs of columns with the same name and uses them as join criteria.</p><p>Similar to <code>using</code>, a natural join only checks for equality. And just like a qualified join, a natural join can be either inner (default), left, right, or full:</p><pre tabindex="0"><code>table NATURAL [join-type] JOIN table
</code></pre><div><div><figure><img src="https://antonz.org/sql-join/natural.png" alt="Natural join"/><figcaption>A natural join is like an automatic, heartless &#34;using&#34;. Pretty unnatural, if you ask me.</figcaption></figure></div></div><p>Using natural joins is almost always a bad idea. Imagine we have a <code>name</code> column in both tables:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>create</span> <span>table</span> <span>jobs</span> (
</span></span><span><span>  <span>job_id</span> <span>integer</span> <span>primary</span> <span>key</span>,
</span></span><span><span>  <span>comp_id</span> <span>integer</span>,
</span></span><span><span>  <span>name</span> <span>text</span>
</span></span><span><span>);
</span></span><span><span>
</span></span><span><span><span>create</span> <span>table</span> <span>if</span> <span>not</span> <span>exists</span> <span>companies</span> (
</span></span><span><span>  <span>comp_id</span> <span>integer</span> <span>primary</span> <span>key</span>,
</span></span><span><span>  <span>name</span> <span>text</span>
</span></span><span><span>);
</span></span></code></pre></div><p>Completely valid design. However, a natural join between <code>jobs</code> and <code>companies</code> would return an empty result, because it implicitly matches on the following condition:</p><pre tabindex="0"><code>jobs.comp_id = companies.comp_id and jobs.name = companies.name
</code></pre><p>So I&#39;d take qualified join with <code>using</code> over natural join any day.</p><h2 id="cross-join">Cross join</h2><p>The third and final variation of join is a cross join, also known as a Cartesian join:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>
</span></span><span><span>  <span>cross</span> <span>join</span> <span>companies</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>A cross join completely ignores column values. It joins <em>every</em> row from the left table (N rows) with <em>every</em> row from the right table (M rows), resulting in N×M rows.</p><div><div><figure><img src="https://antonz.org/sql-join/cross.png" alt="Cross join"/><figcaption>A separate name for the least used type of join. That makes sense! Or not. Ask the SQL committee.</figcaption></figure></div></div><p>A cross join can be useful if you need to generate all pairs of values from two tables, such as all &#34;size-color&#34; combinations for a product. Not so useful in our jobs example, I suppose.</p><p>A cross join is equivalent to a full outer join without a matching criteria:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>
</span></span><span><span>  <span>full</span> <span>join</span> <span>companies</span> <span>on</span> <span>true</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>Sometimes you will see a cross join written this way:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span> <span>job_name</span>, <span>comp_name</span>
</span></span><span><span><span>from</span> <span>jobs</span>, <span>companies</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>While this query doesn&#39;t use the <code>join</code> keyword at all, it is exactly the same cross join.</p><h2 id="partitioned-join">Partitioned join</h2><p>Didn&#39;t I say earlier that there are only three variations of joins — qualified join, cross join, and natural join? Well, yes.</p><p>But here is a thing. Remember our qualified join specification?</p><pre tabindex="0"><code>table [join-type] JOIN table join-specification
</code></pre><p>According to the SQL standard, the <code>table</code> here can be a <em>partitioned join</em> table (not related to <a href="https://www.postgresql.org/docs/current/ddl-partitioning.html">table partitioning</a> in any way!):</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span> ...
</span></span><span><span><span>from</span> <span>table_x</span> <span>partition</span> <span>by</span> (<span>col_1</span>, <span>col_2</span>, ...)
</span></span><span><span>  <span>join</span> <span>table_y</span> <span>on</span> ...
</span></span><span><span>;
</span></span></code></pre></div><p>Let&#39;s say we have <code>products</code> and their <code>sales</code> over time:</p><pre tabindex="0"><code>  sales                                          products
┌────┬────────────┬────────────┬──────────┐    ┌────┬───────┐
│ id │  sale_dt   │ product_id │ quantity │    │ id │ name  │
├────┼────────────┼────────────┼──────────┤    ├────┼───────┤
│ 1  │ 2023-06-01 │ 10         │ 30       │    │ 10 │ Alpha │
│ 2  │ 2023-06-01 │ 20         │ 60       │    │ 20 │ Beta  │
│ 3  │ 2023-06-01 │ 30         │ 90       │    │ 30 │ Gamma │
│ 4  │ 2023-06-02 │ 20         │ 60       │    └────┴───────┘
│ 5  │ 2023-06-03 │ 10         │ 30       │
│ 6  │ 2023-06-03 │ 30         │ 90       │
└────┴────────────┴────────────┴──────────┘
</code></pre><p><em>(swipe left to see the products)</em></p><p>Let&#39;s select sales with corresponding product names:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>sale_dt</span>, <span>products</span>.<span>name</span>, <span>quantity</span>
</span></span><span><span><span>from</span> <span>sales</span>
</span></span><span><span>   <span>join</span> <span>products</span> <span>on</span> <span>sales</span>.<span>product_id</span> <span>=</span> <span>products</span>.<span>id</span>
</span></span><span><span><span>order</span> <span>by</span> <span>sale_dt</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>So far so good. But what I&#39;d like to see here is how <em>each</em> of the products performed on <em>each</em> day (when there was at least one sale). Including zero sales for some of the products:</p><pre tabindex="0"><code>┌────────────┬───────┬──────────┐
│  sale_dt   │ name  │ quantity │
├────────────┼───────┼──────────┤
│ 2023-06-01 │ Alpha │ 30       │
│ 2023-06-01 │ Beta  │ 60       │
│ 2023-06-01 │ Gamma │ 90       │
│ 2023-06-02 │ Alpha │ 0        │
│ 2023-06-02 │ Beta  │ 60       │
│ 2023-06-02 │ Gamma │ 0        │
│ 2023-06-03 │ Alpha │ 30       │
│ 2023-06-03 │ Beta  │ 0        │
│ 2023-06-03 │ Gamma │ 90       │
└────────────┴───────┴──────────┘
</code></pre><p>There is no way I can accomplish this without additional tricks. Unless I use a partitioned join.</p><div><div><figure><img src="https://antonz.org/sql-join/partitioned.png" alt="Join types"/><figcaption>A partitioned join works independently within each partition.</figcaption></figure></div></div><p>A partitioned join tells the database engine to perform the join independently within each of the partitions we have defined for a table. So if we partition <code>sales</code> by date:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>sale_dt</span>, <span>name</span>, <span>quantity</span>
</span></span><span><span><span>from</span> <span>sales</span> <span>partition</span> <span>by</span> (<span>sale_dt</span>)
</span></span><span><span>  <span>right</span> <span>join</span> <span>products</span> <span>on</span> <span>sales</span>.<span>product_id</span> <span>=</span> <span>products</span>.<span>id</span>
</span></span><span><span><span>order</span> <span>by</span> <span>sale_dt</span>, <span>name</span>;
</span></span></code></pre></div><p>Then the database engine will independently join sales and products for <code>2023-06-01</code>, then for <code>2023-06-02</code>, then for <code>2023-06-03</code>, and finally union the results. This will give us the exact result we wanted (except for <code>null</code>s instead of zeros):</p><pre tabindex="0"><code>┌────────────┬───────┬──────────┐
│  sale_dt   │ name  │ quantity │
├────────────┼───────┼──────────┤
│ 2023-06-01 │ Alpha │ 30       │
│ 2023-06-01 │ Beta  │ 60       │
│ 2023-06-01 │ Gamma │ 90       │
│ 2023-06-02 │ Alpha │ (null)   │
│ 2023-06-02 │ Beta  │ 60       │
│ 2023-06-02 │ Gamma │ (null)   │
│ 2023-06-03 │ Alpha │ 30       │
│ 2023-06-03 │ Beta  │ (null)   │
│ 2023-06-03 │ Gamma │ 90       │
└────────────┴───────┴──────────┘
</code></pre><p>I have to say that this is a rather strange feature. I&#39;m surprised it&#39;s in the standard at all (probably something to do with Oracle having it). Other vendors besides Oracle have never implemented partitioned joins, and I can&#39;t blame them.</p><p>Anyway, I just wanted you to know about it so you could share my burden of unnecessary SQL knowledge.</p><p>In case you were wondering (I know you weren&#39;t), here&#39;s how to solve the problem without partitioned joins:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>-- select distinct dates
</span></span></span><span><span><span></span><span>with</span> <span>dates</span> <span>as</span> (
</span></span><span><span>  <span>select</span> <span>distinct</span> <span>sale_dt</span>
</span></span><span><span>  <span>from</span> <span>sales</span>
</span></span><span><span>)
</span></span><span><span><span>-- cross join dates with products
</span></span></span><span><span><span>-- to get all the date-product pairs,
</span></span></span><span><span><span>-- then join them with sales data
</span></span></span><span><span><span></span><span>select</span>
</span></span><span><span>  <span>dates</span>.<span>sale_dt</span>,
</span></span><span><span>  <span>name</span>, <span>quantity</span>
</span></span><span><span><span>from</span> <span>dates</span>
</span></span><span><span>  <span>cross</span> <span>join</span> <span>products</span>
</span></span><span><span>  <span>left</span> <span>join</span> <span>sales</span> <span>on</span> <span>sales</span>.<span>sale_dt</span> <span>=</span> <span>dates</span>.<span>sale_dt</span>
</span></span><span><span>    <span>and</span> <span>sales</span>.<span>product_id</span> <span>=</span> <span>products</span>.<span>id</span>
</span></span><span><span><span>order</span> <span>by</span> <span>dates</span>.<span>sale_dt</span>, <span>name</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sql"></codapi-snippet><p>Easy-peasy.</p><h2 id="lateral-join">Lateral join</h2><p>SQL is a strange beast. While the standard includes the partitioned join (which no one but Oracle supports), it also lacks the widely supported <em>lateral</em> join.</p><p>A lateral join (as opposed to a traditional join) allows you to use correlated subqueries. We&#39;ll see what that means in a moment.</p><pre tabindex="0"><code>  sales                                          products
┌────┬────────────┬────────────┬──────────┐    ┌────┬───────┐
│ id │  sale_dt   │ product_id │ quantity │    │ id │ name  │
├────┼────────────┼────────────┼──────────┤    ├────┼───────┤
│ 1  │ 2023-06-01 │ 10         │ 30       │    │ 10 │ Alpha │
│ 2  │ 2023-06-01 │ 20         │ 60       │    │ 20 │ Beta  │
│ 3  │ 2023-06-01 │ 30         │ 90       │    │ 30 │ Gamma │
│ 4  │ 2023-06-02 │ 20         │ 60       │    └────┴───────┘
│ 5  │ 2023-06-03 │ 10         │ 30       │
│ 6  │ 2023-06-03 │ 30         │ 90       │
└────┴────────────┴────────────┴──────────┘
</code></pre><p><em>(swipe left to see the products)</em></p><p>Let&#39;s go back to our products/sales example and see how each product sold on June 2nd:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>&#39;2023-06-02&#39;</span> <span>as</span> <span>sale_dt</span>, <span>name</span>, <span>sales</span>.<span>quantity</span>
</span></span><span><span><span>from</span> <span>products</span>
</span></span><span><span>  <span>left</span> <span>join</span> <span>sales</span> <span>on</span> <span>products</span>.<span>id</span> <span>=</span> <span>sales</span>.<span>product_id</span>
</span></span><span><span>  <span>and</span> <span>sales</span>.<span>sale_dt</span> <span>=</span> <span>&#39;2023-06-02&#39;</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="postgres.sql"></codapi-snippet><p>Now let&#39;s say we want to see product sales for all days (just like we did with the partitioned join). It would be nice to select distinct dates with a subquery and join it with the product/sales subquery from above:</p><div><div><figure><img src="https://antonz.org/sql-join/lateral.png" alt="Lateral join"/><figcaption>The product/sales subquery references the sales date from the dates subquery.
We can say that the product/sales subquery is <em>correlated</em> with the dates subquery.</figcaption></figure></div></div><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>d</span>.<span>sale_dt</span>, <span>ps</span>.<span>name</span>, <span>ps</span>.<span>quantity</span>
</span></span><span><span><span>from</span>
</span></span><span><span>  (<span>select</span> <span>distinct</span> <span>sale_dt</span> <span>from</span> <span>sales</span>) <span>as</span> <span>d</span>
</span></span><span><span>  <span>join</span> (
</span></span><span><span>    <span>select</span> <span>d</span>.<span>sale_dt</span>, <span>name</span>, <span>sales</span>.<span>quantity</span>
</span></span><span><span>    <span>from</span> <span>products</span>
</span></span><span><span>      <span>left</span> <span>join</span> <span>sales</span> <span>on</span> <span>products</span>.<span>id</span> <span>=</span> <span>sales</span>.<span>product_id</span>
</span></span><span><span>      <span>and</span> <span>sales</span>.<span>sale_dt</span> <span>=</span> <span>d</span>.<span>sale_dt</span>
</span></span><span><span>  ) <span>as</span> <span>ps</span> <span>on</span> <span>true</span>
</span></span><span><span><span>order</span> <span>by</span> <span>sale_dt</span>, <span>name</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="postgres.sql"></codapi-snippet><p>Nah. We can&#39;t reference the <code>sale_dt</code> column provided by the preceding <code>d</code> subquery in the <code>ps</code> subquery. Unless we use a lateral join, which allows just that:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>select</span>
</span></span><span><span>  <span>d</span>.<span>sale_dt</span>, <span>ps</span>.<span>name</span>, <span>ps</span>.<span>quantity</span>
</span></span><span><span><span>from</span>
</span></span><span><span>  (<span>select</span> <span>distinct</span> <span>sale_dt</span> <span>from</span> <span>sales</span>) <span>as</span> <span>d</span>
</span></span><span><span>  <span>join</span> <span>lateral</span> (
</span></span><span><span>    <span>select</span> <span>d</span>.<span>sale_dt</span>, <span>name</span>, <span>sales</span>.<span>quantity</span>
</span></span><span><span>    <span>from</span> <span>products</span>
</span></span><span><span>      <span>left</span> <span>join</span> <span>sales</span> <span>on</span> <span>products</span>.<span>id</span> <span>=</span> <span>sales</span>.<span>product_id</span>
</span></span><span><span>      <span>and</span> <span>sales</span>.<span>sale_dt</span> <span>=</span> <span>d</span>.<span>sale_dt</span>
</span></span><span><span>  ) <span>as</span> <span>ps</span> <span>on</span> <span>true</span>
</span></span><span><span><span>order</span> <span>by</span> <span>sale_dt</span>, <span>name</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="postgres.sql"></codapi-snippet><p>The <code>d</code> subquery selects the dates, while the <code>ps</code> subquery joins with it on the <code>sale_dt</code> column to select the product sales for that date. All thanks to the lateral join. Nice!</p><p>You may be wondering about the <code>on true</code> join condition. Thing is, the actual join on <code>sale_dt</code> already happens inside the <code>ps</code> subquery, so we don&#39;t need to repeat it outside. Try changing <code>on true</code> to <code>d.sale_dt = ps.sale_dt</code> and see that nothing changes.</p><p>Lateral joins are supported by PostgreSQL, MySQL and Oracle. MS SQL Server does not support them per se, but provides the same functionality with <code>cross apply</code> (= <code>join lateral</code>) and <code>outer apply</code> (= <code>left join lateral</code>) syntax.</p><h2 id="summary">Summary</h2><p>There are three variations of joins defined in the SQL standard:</p><ul><li>qualified join (= using specific match critera),</li><li>natural join (= automatic match critera),</li><li>cross join (= full outer join with no specific match critera).</li></ul><div><div><figure><img src="https://antonz.org/sql-join/joins.png" alt="SQL Joins"/><figcaption>&#34;SQL Standard in Pictures&#34; would be an absolute hit, wouldn&#39;t it?</figcaption></figure></div></div><p>A qualified join comes in four types: <code>inner</code>, <code>left</code>, <code>right</code>, and <code>full</code>.</p><div><div><figure><img src="https://antonz.org/sql-join/join-type.png" alt="Join type"/></figure></div></div><p>It also provides <code>on</code> and <code>using</code> flavors of matching criteria.</p><div><div><figure><img src="https://antonz.org/sql-join/join-spec.png" alt="Join specification"/></figure></div></div><p>Most vendors support them all, with the notable exception of MS SQL Server, which doesn&#39;t know anything about <code>using</code> and natural joins.</p><p>There is also a <code>partition by</code> join feature, supported by Oracle only. And a <code>lateral</code> feature that is not in the standard, but is supported by PostgreSQL, MySQL and Oracle (and MS SQL Server with a different syntax).</p><p>Oh, and MySQL doesn&#39;t support <code>full</code> joins. Just because.</p><p>That&#39;s it!</p><p>──</p><p>P.S. Interested in mastering advanced SQL? Check out my book — <a href="https://antonz.org/sql-window-functions-book">SQL Window Functions Explained</a></p><p><em><a href="https://antonz.org/subscribe/"><i></i> <strong>Subscribe</strong></a>
to keep up with new posts.</em></p></div></div></article></div></div></div>
  </body>
</html>
