<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.more-magic.net/posts/crunch.html">Original</a>
    <h1>Crunch – a Scheme compiler with a minimal runtime</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><i>NOTE: This is another guest post by <a href="http://call-with-current-continuation.org/">Felix Winkelmann</a>, the founder and one of the current maintainers of CHICKEN Scheme.</i></p><a href="#introduction">
<h3 id="introduction">Introduction</h3></a>
<p>Hi! This post is about a new project of mine, called &#34;CRUNCH&#34;, a compiler for a statically typed subset of  the programming language <a href="https://www.scheme-reports.org">Scheme</a>, specifically, the <a href="https://r7rs.org/">R7RS (small)</a> standard.</p>
<p>The compiler runs on top of the <a href="https://www.call-cc.org/">CHICKEN</a> Scheme system and produces portable C99 that can then be compiled and executed on any platform that has a decent C compiler.</p>
<p>So, why another Scheme implementation, considering that there already exists such a large number of interpreters and compilers for this language? What motivated me was the emergence of the <a href="https://prescheme.org">PreScheme restoration project</a>, a modernisation of <a href="https://prescheme.org/papers/prescheme.pdf">&#34;PreScheme&#34;</a>, a statically typed compiler for Scheme that is used in the <a href="https://www.s48.org">Scheme48</a> implementation. The original PreScheme was embedded into S48 and was used to generate the virtual machine that is targeted by the latter system. Andrew Whatson couragously started a project to port PreScheme to modern R7RS Scheme systems (PreScheme is written in Scheme, of course) with the intention of extending it and keep the quite sophisticated and interesting compiler alive.</p>
<p>The announcement of the project and some of the reactions that it spawned made me realize that there seems to be a genuine demand for a statically typed high-performance compiler for Scheme (even if just for a subset) that would close a gap in the spectrum of Scheme systems currently available.</p>
<p>There are compilers and interpreters for all sorts of platforms, ranging from tiny, minimal interpreters to state-of-the-art compilers, targeting about every imaginable computer system. But most Schemes need relatively complex runtime systems, have numerous dependencies, or have slow performance, which is simply due to the powerful semantics of the language: dynamic typing, automatic memory management (garbage collection), first class continuations, etc. which all have a cost in terms of overhead.</p>
<p>What is needed is a small, portable compiler that generates more or less &#34;natural&#34; C code with minimal dependencies and runtime system that supports at least the basic constructs of the language and that puts an emphasis on producing efficient code, even if some of the more powerful features of Scheme are not available. Such a system would be perfect for writing games, virtual machines, or performance-sensitive libraries for other programs where you still want to use a high-level language to master the task of implementing complex algorithms, while keeping as close to C/C++ as possible. Another use is as a tool to write bare-metal code for embedded systems, device drivers and kernels for operating systems.</p>
<p>There are some high-performance compilers like <a href="https://www-sop.inria.fr/mimosa/fp/Bigloo/bigloo.html">Bigloo</a> or <a href="https://github.com/barak/stalin">Stalin</a>. But the former still needs a non-trivial runtime-system and the latter is brittle and not actively maintained. Also, one doesn&#39;t necessarily need support for the full Scheme language and if one is willing the drop the requirement of dynamic typing, a lot of performance can be gained while still having a relatively simple compiler implementation. Even without continuations, dynamic typing, the full numeric tower and general tail call optimization, the powerful metaprogramming facilities of Scheme and the clear and simple syntax make it a useful notation for many uses that require a high level of abstraction. Using <a href="https://en.wikipedia.org/wiki/Type_inference">type inference</a> mostly avoids having to annotate a source program with type information and thus allows creating code still is to a large part standard Scheme code that can (with a little care) be tested on a normal Scheme system before compiling it to more efficient native code.</p><a href="#history">
<h3 id="history">History</h3></a>
<p>There was a <a href="https://anonymous:@code.call-cc.org/svn/chicken-eggs/release/4/crunch/">previous extension</a> for CHICKEN, also called &#34;crunch&#34;, that compiled to C++, used a somewhat improvised type-inferencing algorithm and was severely restricted. It was used to allow embedding statically typed code into normal CHICKEN Scheme programs. The new CRUNCH picks up this specific way of use, but is a complete reimplementation that targets C99, has a more sophisticated type system, offers some powerful optimizations and has the option to create standalone programs or separately compilable C modules.</p><a href="#installation">
<h3 id="installation">Installation</h3></a>
<p>CRUNCH is only available for the new major release of CHICKEN (version 6). You will need to build and install a development snapshot containing the sources of this release, which is still unofficial and under development:</p>
<pre><tt> $ wget https://code.call-cc.org/dev-snapshots/2024/12/09/chicken-6.0.0pre1.tar.gz
 $ tar xfz chicken-6.0.0pre1.tar.gz
 $ cd chicken-6.0.0pre1
 $ ./configure --prefix &lt;install location&gt;
 $ make
 $ make install
 $ &lt;install location&gt;/bin/chicken-install -test crunch</tt></pre>
<p>CHICKEN has minimal dependencies (a C compiler, <tt>sh(1)</tt> and GNU <tt>make(1)</tt>), so don&#39;t be put off to give it a try.</p><a href="#basic-operation-and-usage">
<h3 id="basic-operation-and-usage">Basic Operation and Usage</h3></a>
<p>CRUNCH can be used as a batch compiler, translating Scheme to standalone C programs or can be used at compile time for embedded fragments of Scheme code, automatically creating the necessary glue to use the compiled code from CHICKEN Scheme. The compiler itself is also exposed as a library function, making various scenarios possible where you want to programmatically convert Scheme into native code.</p>
<p>There are four modes of using CRUNCH:</p>
<p>1. Embedding:</p>
<pre><tt><span>(<span>import crunch</span>)</span>
<span>(<span>crunch
  <span>(<span><i><span>define</span></i> <span>(<span>stuff arg</span>)</span> ...</span>)</span> </span>)</span>
<span>(<span>stuff 123</span>)</span></tt></pre>
<p>2. Standalone:</p>
<pre><tt> $ cat hello.scm
 (define (main) (display &#34;Hello world\n&#34;))
 $ chicken-crunch hello.scm -o hello.c
 $ cc hello.c $(chicken-crunch -cflags -libs)
 $ ./a.out</tt></pre>
<p>3. Wrap compiled code in Scheme stubs to use it from CHICKEN:</p>
<pre><tt> $ cat fast-stuff.scm
 (module fast-stuff (do-something)
   (import (scheme base))
   (define (do-something) ...))

 $ cat use-fast-stuff.scm
 (import fast-stuff)
 (fast-wait)

 $ chicken-crunch -emit-wrappers wrap.scm -J fast-stuff.scm -o fast-stuff.c
 $ csc -s wrap.scm fast-stuff.c -o wrap.so
 $ csc use-fast-stuff.scm -o a.out</tt></pre>
<p>4. Using CRUNCH as a library:</p>
<pre><tt>#;1&gt; <span>(<span>import <span>(<span>crunch compiler</span>)</span></span>)</span>
#;2&gt; <span>(<span>crunch
       &#39;<span>(<span>begin <span>(<span><i><span>define</span></i> <span>(<span>main</span>)</span> <span>(<span>display <span>&#34;Hello world</span><span>\n</span><span>&#34;</span></span>)</span></span>)</span>
       &#39;<span>(<span>output-file <span>&#34;out.c&#34;</span></span>)</span> </span>)</span></span></span></tt></pre><a href="#module-system-and-integration-into-chicken">
<h3 id="module-system-and-integration-into-chicken">Module system and integration into CHICKEN</h3></a>
<p>CRUNCH uses the module system and syntactic metaprogramming facilities of CHICKEN. Syntax defined in CHICKEN modules can be used in CRUNCH code and vice versa. CRUNCHed code can produce &#34;import libraries&#34;, like in CHICKEN to provide separate compilation of modules.</p>
<p>Modules compiled by CRUNCH may only export procedures and a standalone program is expected to export a procedure called <tt>main</tt>. This simplifies interfacing to C and makes callbacks from C into Scheme straightforward.</p>
<p>As in PreScheme, toplevel code is evaluated at compile time. Most assigned values can be accessed in compiled code.</p>
<pre><tt><span>(<span><i><span>define</span></i> sines
  <span>(<span>list-&gt;f64vector
    <span>(<span>list-tabulate 360
      <span>(<span><i><span>lambda</span></i> <span>(<span>n</span>)</span> <span>(<span>sin <span>(<span>/ <span>(<span>* n π</span>)</span> 180</span>)</span></span>)</span></span>)</span> </span>)</span> </span>)</span> </span>)</span></tt></pre><a href="#restrictions">
<h3 id="restrictions">Restrictions</h3></a>
<p>A number of significant restrictions apply to Scheme code compiled with CRUNCH:</p>
<ul>
<li>No support for multiple values</li>
<li>No support for first class continuations</li>
<li>Tail calls can only be optimized into loops for local procedure calls or calls that can be inlined</li>
<li>Closures (procedures capturing free variables) are not supported</li>
<li>Procedures can have no &#34;rest&#34; argument</li>
<li>Imported global variables can not be modified</li>
<li>Currently only 2-argument arithmetic and comparison operators are supported</li>
<li>It must be possible to eliminate all free variables via inlining and lambda-lifting</li></ul>
<p>This list looks quite severe but it should be noted that a large amount of idiomatic Scheme code can still be compiled that way. Also, CRUNCH does not attempt to be a perfect replacement for a traditional Scheme system, it merely tries to provide an efficient programming system for domains where performance and interoperability with native code are of high importance.</p>
<p>Datums are restricted to the following types:</p>
<ul>
<li>basic types: integer, float, complex, boolean, char, pointer</li>
<li>procedure types</li>
<li>strings</li>
<li>vectors of any of the basic types, and vectors for specific numeric types</li>
<li>structs and unions</li></ul>
<p>Note the absence of pairs, lists and symbols. Structures and unions are representations of the equivalent C object and can be passed by value or by pointer.</p><a href="#the-runtime-system">
<h3 id="the-runtime-system">The Runtime System</h3></a>
<p>The runtime system required to run compiled code is minimal and contained in a single C header file. CRUNCH supports UNICODE and the code for UNICODE-aware case conversions and some other non-trivial operations is provided in a separate C file. UNICODE support is optional and can be disabled.</p>
<p>No garbage collector is needed. Non-atomic data like strings and vectors are managed using reference counting without any precautions taken to avoid circular data, which is something that is unlikely to happen by accident with the data types currently supported.</p><a href="#optimizations">
<h3 id="optimizations">Optimizations</h3></a>
<p>CRUNCH provides a small number of powerful optimizations to ensure decent performance and to allow more or less idiomatic Scheme code to be compiled. The type system is not fully polymorphic, but allows overloading of many standard procedures to handle generic operations that accept a number of different argument types. Additionally, a &#34;monomorphization&#34; optimization is provided that clones user procedures that are called with different argument types. Standard procedures that accept procedures are often expanded inline which further increases the opportunities for inlining of procedure calls - this reduces the chance of having &#34;free&#34; variables, which the compiler must be able to eliminate as it doesn&#39;t support closures. Aggressively moving lexically bound variables to toplevel (making them globals) can further reduce the amount of free variables.</p>
<p>Procedures that are called only once are inlined at the call site (&#34;integrated&#34;). Fully general inlining is not supported, we leave that to the C compiler. Integrated procedures that call themselves recursively in tail position are turned into loops.</p>
<p>A crucial transformation to eliminate free variables is &#34;lambda lifting&#34;, which passes free variables as extra arguments to procedures that do not escape and whose argument list can be modified by the compiler without interfering with user code:</p>
<pre><tt><span>(<span><i><span>let</span></i> <span>(<span><span>(<span>x 123</span>)</span></span>)</span>
    <span>(<span><i><span>define</span></i> <span>(<span>foo y</span>)</span> <span>(<span>+ x y</span>)</span></span>)</span>
    <span>(<span>foo 99</span>)</span> </span>)</span>

  ~&gt;

<span>(<span><i><span>let</span></i> <span>(<span><span>(<span>x 123</span>)</span></span>)</span>
    <span>(<span><i><span>define</span></i> <span>(<span>foo y x</span>)</span> <span>(<span>+ x y</span>)</span></span>)</span>
    <span>(<span>foo 99 x</span>)</span> </span>)</span></tt></pre>
<p>Monomorphization duplicates procedures called with arguments of (potentially) different types:</p>
<pre><tt><span>(<span><i><span>define</span></i> <span>(<span>inc x</span>)</span> <span>(<span>+ x 1</span>)</span></span>)</span>
<span>(<span>foo <span>(<span>inc 123</span>)</span> <span>(<span>inc 99.0</span>)</span></span>)</span>

~&gt;

<span>(<span><i><span>define</span></i> inc
  <span>(<span>%variant
    <span>(<span><i><span>lambda</span></i> <span>(<span>x&#39;int</span>)</span> <span>(<span>+ x&#39;int 1</span>)</span></span>)</span> 	    <span>(<span><i><span>lambda</span></i> <span>(<span>x&#39;float</span>)</span> <span>(<span>+ x&#39;float 1</span>)</span></span>)</span></span>)</span></span>)</span>)	<span>(<span>foo <span>(<span>inc&#39;int 123</span>)</span> <span>(<span>inc&#39;float 99.0</span>)</span></span>)</span></tt></pre>
<p>Certain higher-order primitives are expanded inline:</p>
<pre><tt><span>(<span>vector-for-each
  v
  <span>(<span><i><span>lambda</span></i> <span>(<span>x</span>)</span> ...</span>)</span> </span>)</span>

~&gt;   
<span>(<span><i><span>let</span></i> <i><span>loop</span></i> <span>(<span><span>(<span>i 0</span>)</span></span>)</span>
  <span>(<span>unless <span>(<span>&gt;= i <span>(<span>vector-length v</span>)</span></span>)</span>
    <span>(<span><i><span>let</span></i> <span>(<span><span>(<span>x <span>(<span>vector-ref v i</span>)</span></span>)</span></span>)</span> ... <span>(<span><i><span>loop</span></i> <span>(<span>+ i 1</span>)</span></span>)</span></span>)</span> </span>)</span> </span>)</span></tt></pre>
<p>A final pass removes unused variables and procedure arguments and code that has no side effects and has unused results.</p>
<p>Together these transformations can get you far enough to write relatively complex Scheme programs while ensuring the generated C code is tight, and with a little effort, easy to understand (in case you need to verify the translation) and (hopefully) does what it is intended to do.</p><a href="#performance">
<h3 id="performance">Performance</h3></a>
<p>Code compiled with CRUNCH should be equivalent to a straightforward translation of the Scheme code to C. Scalar values are not tagged nor boxed and are represented with the most fitting underlying C type. There is no extra overhead introduced by the translation, with the following exceptions:</p>
<ul>
<li>Vector- and string accesses perform bound checks (these can be disabled)</li>
<li>Using vectors and strings will add some reference counting overhead</li></ul>
<p>If you study the generated code you will encounter many useless variable assignments and some unused values in statement position, these will be removed by the C compiler, also unexported procedures are declared static and so can also very often be inlined by the C compiler leading to little or no overhead.</p><a href="#the-debugger">
<h3 id="the-debugger">The Debugger</h3></a>
<p>For analyzing type errors, a static debugger is included, that presents a graphical user interface. When the <tt>-debug</tt> option is given, a <a href="https://tcl.tk/">Tcl/Tk</a> script is invoked in a subprocess that shows the internal node tree and can be used to examine the transformed code and the types of sub-expressions, together with the corresponding source code line (if available). Should the compilation abort with an error, the shown node-tree is the state of the program at the point where the error occurred.</p><a href="#differences-to-prescheme">
<h3 id="differences-to-prescheme">Differences to PreScheme</h3></a>
<p>CRUNCH is inspired by and very similar to PreScheme, but has a number of noteworthy differences. CRUNCH tries to be as conformant to R7RS (small) as possible and handles UNICODE characters and strings. It also is tightly integrated into CHICKEN, allowing nearly seamless embedding of high-performance code sections. Macros and top-level code can take full advantage of the full CHICKEN Scheme language and its ecosystem of extension libraries.</p>
<p>PreScheme supports multiple values, while CRUNCH currently does not.</p>
<p>PreScheme uses explicit allocation and deallocation for compound data objects, while CRUNCH utilizes reference counting, removing the need to manually clean up resources.</p>
<p>I&#39;m not too familiar with the PreScheme compiler itself, but I assume it provides more sophisticated optimizations, as it does convert to Static Single Assignment form (SSA), so it is to be expected that the effort to optimise the code is quite high. On the other hand, modern C compilers already provide a multitude of powerful optimizations, so it is not clear how many advantages lower-level optimizations will bring.</p><a href="#future-plans">
<h3 id="future-plans">Future Plans</h3></a>
<p>There is a lot of room for improvements. Support of multiple vales would be nice, and not too hard to implement, but will need to follow a convention that should not too awkward to use on the C side. Also, the support for optional arguments is currently quite weak; the ability to specify default values is something that needs to be added.</p>
<p>Primitives for many POSIX libc system calls and library functions should be straightforward to use in CRUNCH code, at least the operations provided by the <tt>(chicken file posix)</tt> module.</p>
<p>What would be particularly nice would be if the compiler detects state machines - mutually recursive procedures that call each other in tail position.</p>
<p>Other targets are possible, like GPUs. I don&#39;t know anything about that, so if you are interested and think you can contribute, please don&#39;t hesitate to contact me.</p><a href="#disclaimer">
<h3 id="disclaimer">Disclaimer</h3></a>
<p>CRUNCH is currently alpha-software. It certainly contains numerous bugs and shortcomings that will hopefully be found and corrected as the compiler is used. If you are interested, I invite you to give it a try. Contact <a href="http://call-with-current-continuation.org/me.html">me</a> directly or join the <tt>#chicken</tt> IRC channel on <a href="https://libera.chat">Libera.chat</a>, if you have questions, want to report bugs, if you would like to suggest improvements or if you just want to know more about it.</p>
<p>All feedback is very welcome!</p><a href="#links">
<h3 id="links">Links</h3></a>
<p>The <a href="http://wiki.call-cc.org/eggref/6/crunch">CRUNCH manual</a> can be found at the CHICKEN wiki, the source code repository is <a href="https://anonymous@code.call-cc.org/svn/chicken-eggs/release/6/crunch/">here</a>.</p></div></div>
  </body>
</html>
