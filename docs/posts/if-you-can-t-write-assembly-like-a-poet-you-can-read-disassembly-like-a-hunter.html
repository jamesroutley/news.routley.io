<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wordsandbuttons.online/you_dont_have_to_learn_assembly_to_read_disassembly.html">Original</a>
    <h1>If you can&#39;t write assembly like a poet, you can read disassembly like a hunter</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p>This is <a href="https://wordsandbuttons.online/index.html">Words and Buttons Online</a> — a collection of interactive <a href="https://wordsandbuttons.online/all_tutorials.html">#tutorials</a>, <a href="https://wordsandbuttons.online/all_demos.html">#demos</a><a>, and </a><a href="https://wordsandbuttons.online/all_quizzes.html">#quizzes</a> about <a href="https://wordsandbuttons.online/all_mathematics.html">#mathematics</a>, <a href="https://wordsandbuttons.online/all_algorithms.html">#algorithms</a> and <a href="https://wordsandbuttons.online/all_programming.html">#programming</a>.</p>
	
	<p>
Reading disassembly is more like reading tracks than reading a book. To read a book you have to know the language. Reading tracks, although it gets better with skills and experience, mostly requires attentiveness and imagination.
	</p>
<img src="https://raw.githubusercontent.com/akalenuk/wordsandbuttons/master/pages/img/traces.jpg"/>
	
	<p>
Most of the time we read disassembly only to answer one simple question: <i>does the compiler do what we expect it to do</i>? In 3 simple exercises, I’ll show you that often enough you too can answer this question even if you have no previous knowledge of assembly. I’ll use C++ as a source language, but what I’m trying to show is more or less universal, so it doesn’t matter if you write in C or Swift, C# or Rust. If you compile to any kind of machine code — you can benefit from understanding your compiler.
	</p>
	<h2>
1. <span id="index_compile_time_computation">Compile-time computation</span>
	</h2>
	<p>
Any decent compiler tries to make your binary code not only correct but fast. This means doing as little work in runtime as possible. Sometimes it can even conduct the whole computation in compile-time, so your machine code will only contain the precomputed answer.
	</p>
	<p>
This source code defines the number of bits in a byte and returns the size of <span>int</span> in bits.
	</p>
	<div>
	<pre>static int BITS_IN_BYTE = 8;

int main() {
    return sizeof(int)*BITS_IN_BYTE;
}
</pre>
	</div>
	<p>
The compiler knows the size of an <span>int</span>. Let&#39;s say for the target platform it is 4 bytes. We also set the number of bits in a byte explicitly. Since all we want is a simple multiplication, and both numbers are known during the compilation, a compiler can simply compute the resulting number itself instead of generating the code that computes the same number each time it&#39;s being run.
	</p>
	<p>
Although, this is not something guaranteed by the standard. A compiler may or may not provide this optimization.
	</p>
	<p>
Now look at two possible disassemblies for this source code and decide what variant does compile-time computation and what doesn’t.
	</p>
	<table><tbody><tr>
	<td>
	<pre id="code_1_1">BITS_IN_BYTE:
  .long 8
main:
  mov eax, DWORD PTR BITS_IN_BYTE[rip]
  cdqe
  sal eax, 2
  ret</pre>
	</td>
	<td>
	<pre id="code_1_2">main:
  mov eax, 32
  ret</pre>
	</td></tr></tbody></table>
	
	

	<h2>
2. <span id="index_function_inlining">Function inlining</span>
	</h2>
	<p>
Calling a function implies some overhead by preparing input data in a particular order; then starting the execution from another piece of memory; then preparing output data; and then returning back.
	</p>
	<p>
Not that it is all too slow but if you only want to call a function once, you don’t have to <i>actually call</i> the function. It just makes sense to copy or “inline” the function&#39;s body to the place it is called from and skip all the formalities. Compilers can often do this for you so you don&#39;t even have to bother.
	</p>
	<p>
If the compiler makes such an optimization, this code:
	</p>
	<div>
	<pre><i>inline</i> int square(int x)  {
    return x * x;
}


int main(int argc, char** argv)  {
    return square(argc);
}
</pre>
	</div>
	<p>
Virtually becomes this:
	</p>
	<div>
	<pre><i>// not really a source code, just explaining the idea</i>
int main(int argc, char** argv)  {
    return argc * argc;
}
	</pre>
	</div>
	<p>
But the standard does not promise that all the functions marked as <span>inline</span> shall get inlined. It&#39;s more a suggestion than a directive.
	</p>
	<p>
Now look at these two disassembly variants below and choose the one where the function gets inlined after all.
	</p>
	<table><tbody><tr>
	<td>
	<pre id="code_2_1">main:
  imul edi, edi
  mov eax, edi
  ret</pre>
	</td>
	<td>
	<pre id="code_2_2">square(int):
  imul edi, edi
  mov eax, edi
  ret
main:
  sub rsp, 8
  call square(int)
  add rsp, 8
  ret</pre>
	</td></tr></tbody></table>
	
	

	<h2>
3. <span id="index_loop_unrolling">Loop unrolling</span>
	</h2>
	<p>
Just like calling functions, going in loops implies some overhead. You have to increment the counter; then compare it against some number; then jump back to the loop&#39;s beginning.
	</p>
	<p>
Compilers know that in some contexts it is more effective to unroll the loop. It means that some piece of code will actually be repeated several times in a row instead of messing with the counter comparison and jumping here and there.
	</p>
	<p>
Let&#39;s say we have this piece of code:
	</p>
	<div>
	<pre>int main(int argc, char**) {
    int result = 1;
    for(int i = 0; i &lt; 3; ++i)
        result *= argc;
    return result;
}
	</pre>
	</div>
	<p>
The compiler has all the reasons to unroll such a simple loop, but it might as well choose not to.
	</p>
	<p>
Which disassembly has the unrolled loop?
	</p>
	<table><tbody><tr>
	<td>
	<pre id="code_3_1">main:
  mov eax, 1
  mov ecx, 3
.LBB0_1:
  imul eax, edi
  dec ecx
  jne .LBB0_1
  ret</pre>
	</td>
	<td>
	<pre id="code_3_2">main:
  mov eax, edi
  imul eax, edi
  imul eax, edi
  ret</pre>
	</td></tr></tbody></table>
	
	

	<h2>
Conclusion
	</h2>
	<p>
You can argue that these examples were deliberately simplified. That these are not some real-life examples. This is true to some degree. I refined them to be more demonstrative. But conceptually they are all taken from my own practice.
	</p>
	<p>
Using static dispatch instead of dynamic made my image processing pipeline up to 5 times faster. Repairing broken inlining helped to win back 50% of the performance for an edge-to-edge distance function. And changing the counter type to enable loop unrolling won me about 10% performance gain on matrix transformations, which is not much, but since all it took to achieve was simply changing <span>short int</span> to <span>size_t</span> in one place, I think of it as a good return of investment.
	</p>
	<p>
Apparently, old versions of MSVC fail to unroll loops with counters of non-native type. Who would have thought? Well, even if you know this particular quirk, you can&#39;t possibly know every other quirk of every compiler out there, so looking at disassembly once in a while might be good for you.
	</p>
	<p>
And you don&#39;t even have to spend years learning every assembly dialect. Reading disassembly is often easier than it looks. <a href="https://godbolt.org/">Try it</a>.
	</p>


	
	
	</div></div>
  </body>
</html>
