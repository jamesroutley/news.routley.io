<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2023-12-01-why-are-go-heaps-confusing/">Original</a>
    <h1>Why are Golang heaps so complicated</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>Heaps are commonly used to partially sort a set. Every
insertion/deletion from the set is followed by a &#34;fixup&#34; to restore
either min-heap or max-heap integrity. For example, a max-heap can be
represented as a binary tree where every parent is &#34;greater&#34; than its
children. It usually takes a small number of swaps to &#34;fixup&#34; a tree to
restore the max-heap property after an insertion or deletion. Even
though all of the set elements are not globally ordered, the &#34;biggest&#34;
value is always at the top of a max-heap. As a result, heaps have a
<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)#Applications">variety of practical
applications</a>.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/657e409024a97c85797c4e740fb4bd24/1acf3/max-max-heap.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="max-heap" title="" src="https://www.dolthub.com/blog/static/657e409024a97c85797c4e740fb4bd24/ad12c/max-max-heap.png" srcset="/blog/static/657e409024a97c85797c4e740fb4bd24/a48b3/max-max-heap.png 214w,
/blog/static/657e409024a97c85797c4e740fb4bd24/47730/max-max-heap.png 428w,
/blog/static/657e409024a97c85797c4e740fb4bd24/ad12c/max-max-heap.png 856w,
/blog/static/657e409024a97c85797c4e740fb4bd24/7a18f/max-max-heap.png 1284w,
/blog/static/657e409024a97c85797c4e740fb4bd24/1acf3/max-max-heap.png 1596w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>

<p>Heaps can be implemented as binary trees with nodes and pointers, but
most programming languages provide default heap implementations for
lists.</p>
<p>I personally found the standard library heap confusing when I started
using Golang.</p>
<p>This is what I was used to coming from Python:</p>
<div data-language="python"><pre><code>h <span>=</span> <span>[</span><span>]</span>
<span>&gt;&gt;</span><span>&gt;</span> heappush<span>(</span>h<span>,</span> <span>(</span><span>5</span><span>,</span> <span>&#39;write code&#39;</span><span>)</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> heappush<span>(</span>h<span>,</span> <span>(</span><span>7</span><span>,</span> <span>&#39;release product&#39;</span><span>)</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> heappush<span>(</span>h<span>,</span> <span>(</span><span>1</span><span>,</span> <span>&#39;write spec&#39;</span><span>)</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> heappush<span>(</span>h<span>,</span> <span>(</span><span>3</span><span>,</span> <span>&#39;create tests&#39;</span><span>)</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> heappop<span>(</span>h<span>)</span>
<span>(</span><span>1</span><span>,</span> <span>&#39;write spec&#39;</span><span>)</span></code></pre></div>
<p>For comparison, here is the equivalent code in Go adapted from the
<a href="https://pkg.go.dev/container/heap"><code>container/heap</code> docs</a>: (<a href="https://go.dev/play/p/UVxCyRMeLsW">run
here</a>):</p>
<div data-language="go"><pre><code><span>import</span> <span>(</span>
	<span>&#34;container/heap&#34;</span>
	<span>&#34;fmt&#34;</span>
<span>)</span>


<span>type</span> Tuple <span>struct</span> <span>{</span>
	i <span>int</span>
	s <span>string</span>
<span>}</span>


<span>type</span> TupleHeap <span>[</span><span>]</span>Tuple

<span>func</span> <span>(</span>h TupleHeap<span>)</span> <span>Len</span><span>(</span><span>)</span> <span>int</span> <span>{</span> <span>return</span> <span>len</span><span>(</span>h<span>)</span> <span>}</span>
<span>func</span> <span>(</span>h TupleHeap<span>)</span> <span>Less</span><span>(</span>i<span>,</span> j <span>int</span><span>)</span> <span>bool</span> <span>{</span>
	<span>if</span> h<span>[</span>i<span>]</span><span>.</span>i <span>!=</span> h<span>[</span>j<span>]</span><span>.</span>i <span>{</span>
		<span>return</span> h<span>[</span>i<span>]</span><span>.</span>i <span>&lt;</span> h<span>[</span>j<span>]</span><span>.</span>i
	<span>}</span>
	<span>return</span> h<span>[</span>i<span>]</span><span>.</span>s <span>&lt;</span> h<span>[</span>j<span>]</span><span>.</span>s
<span>}</span>
<span>func</span> <span>(</span>h TupleHeap<span>)</span> <span>Swap</span><span>(</span>i<span>,</span> j <span>int</span><span>)</span> <span>{</span> h<span>[</span>i<span>]</span><span>,</span> h<span>[</span>j<span>]</span> <span>=</span> h<span>[</span>j<span>]</span><span>,</span> h<span>[</span>i<span>]</span> <span>}</span>
<span>func</span> <span>(</span>h <span>*</span>TupleHeap<span>)</span> <span>Push</span><span>(</span>x any<span>)</span> <span>{</span>
	
	
	<span>*</span>h <span>=</span> <span>append</span><span>(</span><span>*</span>h<span>,</span> x<span>.</span><span>(</span>Tuple<span>)</span><span>)</span>
<span>}</span>

<span>func</span> <span>(</span>h <span>*</span>TupleHeap<span>)</span> <span>Pop</span><span>(</span><span>)</span> any <span>{</span>
	old <span>:=</span> <span>*</span>h
	n <span>:=</span> <span>len</span><span>(</span>old<span>)</span>
	x <span>:=</span> old<span>[</span>n<span>-</span><span>1</span><span>]</span>
	<span>*</span>h <span>=</span> old<span>[</span><span>0</span> <span>:</span> n<span>-</span><span>1</span><span>]</span>
	<span>return</span> x
<span>}</span>



<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	h <span>:=</span> <span>&amp;</span>TupleHeap<span>{</span><span>}</span>
	heap<span>.</span><span>Init</span><span>(</span>h<span>)</span>
	heap<span>.</span><span>Push</span><span>(</span>h<span>,</span> Tuple<span>{</span>i<span>:</span> <span>5</span><span>,</span> s<span>:</span> <span>&#34;write code&#34;</span><span>}</span><span>)</span>
	heap<span>.</span><span>Push</span><span>(</span>h<span>,</span> Tuple<span>{</span>i<span>:</span> <span>7</span><span>,</span> s<span>:</span> <span>&#34;release product&#34;</span><span>}</span><span>)</span>
	heap<span>.</span><span>Push</span><span>(</span>h<span>,</span> Tuple<span>{</span>i<span>:</span> <span>1</span><span>,</span> s<span>:</span> <span>&#34;write spec&#34;</span><span>}</span><span>)</span>
	heap<span>.</span><span>Push</span><span>(</span>h<span>,</span> Tuple<span>{</span>i<span>:</span> <span>3</span><span>,</span> s<span>:</span> <span>&#34;create tests&#34;</span><span>}</span><span>)</span>
	fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;%d &#34;</span><span>,</span> heap<span>.</span><span>Pop</span><span>(</span>h<span>)</span><span>)</span>


<span>}</span></code></pre></div>
<p>I used heaps for several engine optimizations recently, and 3 years
later I still find Go heaps confusing. So I took sometime to research
why.</p>

<p>One thing that stands out about <code>collections/heap</code> is that it is broadly
generic but requires a lot of boilerplate. <code>heap.Interface</code> supports
binary heaps, array heaps, disk-backed heaps, with any user supported
type.</p>
<p>Much of Golang&#39;s standard library aims to be maximally simple, so this
design feature is unsurprising. <code>sort</code>, for example, is a similar
standard library package whose interfaces are similarly generic. One key
difference is that <code>sort.Ints</code> and <code>sort.Strings</code> provide defaults that
remove boilerplate for the most common cases.</p>
<p>Maximally flexible but good defaults sounds ideal. Why doesn&#39;t heap
support simple defaults?</p>

<p>We have documented in the past how <a href="https://www.dolthub.com/blog/2023-10-20-golang-pitfalls-3/">slices have sharp
edges</a>. Part
of why slices are confusing is that they are implicit pointers to
underlying storage arrays. One of Nick&#39;s main criticisms in that blog is
how array mutations can have unpredictable effects on memory. A similar
problem plagues the space of heap implementations.</p>
<p>To illustrate, here are two different <code>append</code> functions. One uses a
default slice pointer, and one uses a pointer to a slice pointer (<a href="https://go.dev/play/p/gE4g4IJillA">run
here</a>).</p>
<div data-language="go"><pre><code><span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	arr <span>:=</span> <span>[</span><span>]</span><span>int</span><span>{</span><span>1</span><span>,</span> <span>2</span><span>}</span>
	<span>append1</span><span>(</span>arr<span>,</span> <span>3</span><span>)</span>
	fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;#%v\n&#34;</span><span>,</span> arr<span>)</span> 
	<span>append2</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>3</span><span>)</span>
	fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;#%v\n&#34;</span><span>,</span> arr<span>)</span> 
<span>}</span>

<span>func</span> <span>append1</span><span>(</span>arr <span>[</span><span>]</span><span>int</span><span>,</span> v <span>int</span><span>)</span> <span>{</span>
	arr <span>=</span> <span>append</span><span>(</span>arr<span>,</span> v<span>)</span>
<span>}</span>

<span>func</span> <span>append2</span><span>(</span>arr <span>*</span><span>[</span><span>]</span><span>int</span><span>,</span> v <span>int</span><span>)</span> <span>{</span>
	<span>*</span>arr <span>=</span> <span>append</span><span>(</span><span>*</span>arr<span>,</span> v<span>)</span>
<span>}</span></code></pre></div>
<p>Without going too deep into the details, slice pointers act like any
other value type when passed to a function <sup id="fnref-1"><a href="#fn-1">1</a></sup>. Mutating the underlying
array creates a new slice pointer. If that slice pointer was passed by
value, all of the changes are restricted to the inner closure (by
contrast, in-place modifying an array through a slice pointer maintains
the integrity of the original reference). If the same slice pointer is
passed by reference, the outer slice address is updated to the new
array.</p>
<p>This is important for <code>heap</code> implementations because it limits the
design space. We either need:</p>
<ol>
<li>
<p>An indirection layer that maintains the newest pointer when we modify memory</p>
</li>
<li>
<p>Return new references when we modify memory, or</p>
</li>
<li>
<p>Operate explicitly on pointers to slices so the original references remain valid</p>
</li>
</ol>

<p>The first option, chosen by the Go standard library, outlines a
minimal possible interface that abstracts unnecessary sorting details
but forces a user to acknowledge and maintain the slice indirection:</p>
<div data-language="go"><pre><code><span>type</span> IntHeap <span>[</span><span>]</span><span>int</span>

<span>type</span> Interface <span>interface</span> <span>{</span>
	sort<span>.</span>Interface
	<span>Push</span><span>(</span>x any<span>)</span> 
	<span>Pop</span><span>(</span><span>)</span> any   
<span>}</span></code></pre></div>
<p>Instead of passing a pointer of a pointer, we add a concrete type to
make the additional reference explicit. This makes it easy for
<code>heap.Interface</code> to highlight the slice&#39;s edges while supporting
implementation flexibility.</p>

<p>The second option, returning and tracking updated slice pointers for
each heap operation, is one way to implement a heap that handles <code>[]int</code>
defaults:</p>
<div data-language="go"><pre><code><span>var</span> h <span>[</span><span>]</span><span>int</span>
h <span>=</span> heap<span>.</span><span>Push</span><span>(</span>h<span>,</span> x<span>)</span>
h<span>,</span> y <span>:=</span> heap<span>.</span><span>Pop</span><span>(</span>h<span>)</span></code></pre></div>
<p>Immutable updates force us to continuously track the newest heap
ref. We also lose the ability to do the sort of context management,
locking, and concurrency control that we usually use in production.
Given that Go often designs around in-place updating central objects, I
am not surprised the standard library avoided this.</p>

<p>The third pattern passes slice pointers to heap functions, similar to
how the standard library
<a href="https://pkg.go.dev/encoding/json"><code>encoding/json</code></a> passes string
pointers for JSON deserialization. I forked the standard library and
implemented this last design to convince myself that it works <sup id="fnref-2"><a href="#fn-2">2</a></sup>:</p>
<div data-language="go"><pre><code>	h <span>:=</span> <span>[</span><span>]</span><span>int</span><span>{</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>}</span>
	<span>Init</span><span>(</span><span>&amp;</span>h<span>)</span>
	<span>Push</span><span>(</span><span>&amp;</span>h<span>,</span> <span>3</span><span>)</span>
	min <span>:=</span> <span>Pop</span><span>(</span><span>&amp;</span>h<span>)</span></code></pre></div>
<p>This package supports both <code>heap.Interface</code> and built-in <code>Comparable</code>
slices (<code>[]int</code> and <code>[]string</code> for starters). The downside is that
unsupported types panic (alternatively, heap functions could
deviate from the standard library interface and return an <code>error</code>).</p>
<p>Arguably the biggest downside of the last approach is combining the
dynamic and static interfaces into one package. If something goes wrong
in the wrapper I would be even more confused than before doing all of
this!</p>

<p>After I originally posted this article, one of the <code>r/golang</code> mods
<a href="https://www.reddit.com/user/jerf/">jerf</a> pointed out a nice
<a href="https://github.com/lispad/go-generics-tools">package</a> that makes it
easy to heap sort built-in types:</p>
<div data-language="go"><pre><code>    h <span>:=</span> binheap<span>.</span>EmptyMaxHeap<span>[</span><span>int</span><span>]</span><span>(</span><span>)</span>
    h<span>.</span><span>Push</span><span>(</span><span>5</span><span>)</span>
    h<span>.</span><span>Push</span><span>(</span><span>7</span><span>)</span>
    h<span>.</span><span>Push</span><span>(</span><span>1</span><span>)</span>
    h<span>.</span><span>Push</span><span>(</span><span>3</span><span>)</span>
    min <span>:=</span> h<span>.</span><span>Pop</span><span>(</span><span>)</span> </code></pre></div>
<p>Another user named <a href="https://www.reddit.com/user/twek/">twek</a> found an
old <a href="https://github.com/golang/go/issues/47632">proposal from 2021</a> with
a similar interface design. He was nice enough to create an <a href="https://go.dev/play/p/4tP6OVcKrma">example
implementation sandbox</a> for others to
try if you are interested in running it yourself!</p>
<p>This diverges a bit from the current standard library by combining the helper
methods and the <code>heap.Interface</code> into one. A heap implementation can
standardize <code>Push()</code>, <code>Pop()</code>, and <code>Swap()</code> for all slices. And the
generic object statically captures the <code>comparable</code> type&#39;s <code>Less()</code>.
The result is zero effort heaps for all built in types!</p>
<p>The same strategy also makes it easy to heap sort
arbitrary slices with an initialization callback similar to
<code>sort.Slice</code> (<a href="https://go.dev/play/p/EbLcZhHjsDF">run
here</a>:</p>
<div data-language="go"><pre><code><span>import</span> <span>(</span>
	<span>&#34;fmt&#34;</span>

	<span>&#34;github.com/lispad/go-generics-tools/binheap&#34;</span>
<span>)</span>

<span>type</span> Struct <span>struct</span> <span>{</span>
	Idx         <span>int</span>
	Description <span>string</span>
<span>}</span>

<span>func</span> <span>(</span>s Struct<span>)</span> <span>LessThan</span><span>(</span>r Struct<span>)</span> <span>bool</span> <span>{</span>
	<span>if</span> s<span>.</span>Idx <span>&lt;</span> r<span>.</span>Idx <span>{</span>
		<span>return</span> <span>true</span>
	<span>}</span>
	<span>if</span> s<span>.</span>Idx <span>&gt;</span> r<span>.</span>Idx <span>{</span>
		<span>return</span> <span>false</span>
	<span>}</span>
	<span>return</span> s<span>.</span>Description <span>&lt;</span> r<span>.</span>Description
<span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	h <span>:=</span> binheap<span>.</span>EmptyHeap<span>[</span>Struct<span>]</span><span>(</span><span>func</span><span>(</span>a<span>,</span> b Struct<span>)</span> <span>bool</span> <span>{</span> <span>return</span> a<span>.</span><span>LessThan</span><span>(</span>b<span>)</span> <span>}</span><span>)</span>
	h<span>.</span><span>Push</span><span>(</span>Struct<span>{</span><span>5</span><span>,</span> <span>&#34;write code&#34;</span><span>}</span><span>)</span>
	h<span>.</span><span>Push</span><span>(</span>Struct<span>{</span><span>7</span><span>,</span> <span>&#34;release product&#34;</span><span>}</span><span>)</span>
	h<span>.</span><span>Push</span><span>(</span>Struct<span>{</span><span>1</span><span>,</span> <span>&#34;write spec&#34;</span><span>}</span><span>)</span>
	h<span>.</span><span>Push</span><span>(</span>Struct<span>{</span><span>3</span><span>,</span> <span>&#34;create tests&#34;</span><span>}</span><span>)</span>
	fmt<span>.</span><span>Println</span><span>(</span>h<span>.</span><span>Pop</span><span>(</span><span>)</span><span>)</span>
<span>}</span></code></pre></div>

<p>At the end of the day, the way slices work makes Golang&#39;s heaps a bit
more confusing than other languages. Peeling back the curtain a bit
helped me understand the design space given Golang&#39;s language
limitations. The active community on <code>r/golang</code> helped provide me with
more context and better implementations than I could find on my own. The generics
solution<sup id="fnref-3"><a href="#fn-3">3</a></sup> uses a slightly different design than the standard library,
but is a simple abstraction and removes most of the boilerplate compared
to <code>container/heap</code> today. I linked the open proposal below if you are
interested in following the Go core team&#39;s thoughts[^4].</p>
<p>I am sure I missed some things in the process of doing this writeup,
whether previous design discussions or other blogs regarding this topic.
If you have comments our questions feel free to reach out to us on
<a href="https://twitter.com/dolthub">Twitter</a>,
<a href="https://discord.gg/gqr7K4VNKe">Discord</a>, and
<a href="https://github.com/dolthub/go-mysql-server">GitHub</a>!</p>
<p><a href="https://github.com/lispad/go-generics-tools">here</a>
[^4] Proposal to add generics implementation to go standard library
<a href="https://github.com/golang/go/issues/47632">here</a></p>
</div></div>
  </body>
</html>
