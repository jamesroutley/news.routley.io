<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://community.arm.com/arm-community-blogs/b/infrastructure-solutions-blog/posts/container-runtimes-wasmedge-arm">Original</a>
    <h1>Container Runtimes and WasmEdge benchmarking on Arm</h1>
    
    <div id="readability-page-1" class="page"><div id="fragment-25364" data-reflow="_p_content,_p_singlecolumn,1,1,12">
<div>





<div>
			<div><p><span>In this blog, I would like to introduce some runtimes on Arm64 platform. Especially, I give you a benchmarking on WasmEdge and Runc, to show you the advantage of Wasm compared with container. Arm consistently makes contribution to open-source projects. </span><span>We actively participate in the following cloud-native projects that focus on enabling, optimizing performance, and implementing continuous integration and deployment on the Arm64 platform.</span><span> </span></p>
<h2 id="mcetoc_1gvh5tkbq0">Runtimes </h2>
<p>A Container runtime<span> is software that is responsible for running containers. Runc is a widely applied runtime and is used by</span> <span>Containerd and Docker by default. There are some other runtimes, such as Crun</span><span>, R</span><span>unsc, and Kata containers. Here is the responsibility of a runtime:</span><span> </span></p>
<ul>
<li><span>Consuming the container mount point </span><span> </span></li>
<li><span>Consuming the container metadata (can also be a manually crafted config.json for testing)</span><span> </span></li>
<li><span>Communicating with the kernel to start containerized processes (clone system call)</span><span> </span></li>
<li><span>Setting up cgroups</span><span>, </span><span>SELinux Policy, App Armor rules</span><span> </span></li>
</ul>
<p><span>Each runtime has its own adapted areas, like lightweight applications or a Secure environment.</span><span> </span></p>
<h3 id="mcetoc_1gvh5tkbq1">Kata Container </h3>
<p><span>Kata Container is a secure container runtime that uses hardware virtualization technology as an additional layer of defense. This allows it to provide stronger workload isolation while still being lightweight and performing like regular containers.</span></p>
<p><span><span><img alt=" Kata Container Architecture" src="https://community.arm.com/resized-image/__size/700x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/ARM2570.-Update-More-Blog-Images_5F00_ST1_2D00_V3.png"/><span></span></span><span lang="JA-JP"></span></span></p>
<p><span><span><span lang="FR-FR"><span>Image </span><span>source</span><span> :</span></span><span lang="JA-JP"><span> </span></span><a title="Kata Container Architecture" href="https://katacontainers.io/learn/"><span><span lang="FR-FR"><span>https://katacontainers.io/learn/</span></span></span></a><span lang="JA-JP"></span><span> </span></span></span></p>
<p><span>Moreover, we change the default Virtual Machine Monitor (VMM) from Qemu to Cloud Hypervisor. Compared to</span> <span>Qemu, Cloud Hypervisor is more lightweight and Secure. It is because Cloud Hypervisor has minimal emulated devices and is implemented in Rust to avoid many common security issues.</span><span> </span></p>
<p><span>For more details, please refer to </span><a title="Kata Containers" href="https://katacontainers.io/"><span>https://katacontainers.io/</span></a><span> and </span><a title="Cloud Hypervisor" href="https://www.cloudhypervisor.org/"><span>https://www.cloudhypervisor.org/</span></a>.<span> </span></p>
<h3 id="mcetoc_1gvh5tkbq2">gVisor </h3>
<p><span>gVisor is an application kernel, written in Go, that implements a substantial portion of the Linux system call interface. It provides an extra layer of isolation between running applications and the host operating system. It takes advantage of KVM to keep the isolation of memory and CPU between container and host. It also has an application kernel that handles most syscalls in user space</span><span>,</span><span> and only a limited number of syscalls would pass to the host kernel. This reduces the attack surface.</span><span> </span></p>
<p><span><span><img alt=" gVisor Architecture" src="https://community.arm.com/resized-image/__size/700x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/ARM2570.-Update-More-Blog-Images_5F00_ST1_2D00_V4.png"/><span></span></span><span lang="JA-JP"></span></span></p>
<p>Image Source: <a title="gVisor Networking Security" href="https://gvisor.dev/blog/2020/04/02/gvisor-networking-security/">https://gvisor.dev/blog/2020/04/02/gvisor-networking-security/</a> </p>
<p><span>For more details, please refer to</span> <a title="gVisor" href="https://gvisor.dev/"><span>https://gvisor.dev/</span></a>.<span> </span></p>
<h3 id="mcetoc_1gvh5tkbq3">WasmEdge </h3>
<p><span>WasmEdge</span> <span> is a lightweight, high-performance, and extensible </span><a title="WebAssembly" href="https://webassembly.org/"><span>WebAssembly</span></a><span> runtime for cloud-native, edge, and decentralized applications.</span></p>
<p><span><span><img alt=" Container eco-system" src="https://community.arm.com/resized-image/__size/540x459/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/ARM2570.-Update-More-Blog-Images_5F00_ST1_2D00_V5.png"/><span></span></span><span lang="JA-JP"></span></span></p>
<p><span><span><span lang="FR-FR"><span>Image </span><span>source:</span></span><span lang="JA-JP"><span> </span></span></span></span><span><span><a title="WasmEdge in Kubernetes" href="https://wasmedge.org/book/en/use_cases/kubernetes.html"><span><span lang="FR-FR"><span>https://wasmedge.org/book/en/use_cases/kubernetes.html</span></span></span></a></span></span><em><span><span><span> </span></span></span></em></p>
<p><span>WasmEdge uses WebAssembly and WASI. I would not go deep into these two technologies but a general introduction. </span><span> </span></p>
<ul>
<li><span>WebAssembly (abbreviated </span>Wasm<span>) is a binary instruction format for a stack-based virtual machine. </span><span> </span><span> </span></li>
</ul>
<ul>
<li><span>A memory-safe, sandboxed </span><a title="Webassembly Execution environment" href="https://webassembly.org/docs/semantics/#linear-memory"><span>execution environment</span></a><span> </span></li>
<li><span>Program languages, like rust, c and Golang, </span><span>can be compiled into the Wasm binary format </span><span>that is compatible across all these platforms</span><span> </span></li>
</ul>
<ul>
<li><span>WASI is a modular system interface for WebAssembly</span><span>. </span><span>Wasm app interacts with a host kernel through WASI.</span><span> </span></li>
</ul>
<p><span>For more details, please refer to</span> <a title="WasmEdge Introduction" href="https://wasmedge.org/book/en/"><span>https://wasmedge.org/book/en/</span></a><span>, </span><a title="WASI" href="https://github.com/WebAssembly/WASI"><span>https://github.com/WebAssembly/WASI</span></a><span>, and </span><a title="WebAssembly" href="https://webassembly.org/"><span>https://webassembly.org/.</span></a><span> </span></p>
<p><span>Generally speaking, compared with container technology, Wasm has several pros.</span><span> </span></p>
<ul>
<li>Smaller binary size and memory footprint  
<ul>
<li>Some libraries can be shared between Wasm binary. </li>
</ul>
</li>
<li>Faster start time  
<ul>
<li>Do not have some startup works in container technology, like creating namespace, cgroup, and so forth. </li>
</ul>
</li>
<li>Less relay on host kernel  
<ul>
<li>Container technology needs namespace, cgroup, filesystem, and so forth, but Wasm does not need them.  </li>
</ul>
</li>
</ul>
<p><span>However, as an unmatured technology, it does have some drawbacks:</span><span> </span></p>
<ul>
<li>WASI only supports limited syscalls, many applications are not able to migrate to Wasm </li>
<li>Security of it still needs to be verified </li>
<li>Many import features are still unimplied. <a title="WebAssembly Proposals" href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a> </li>
</ul>
<p><span>These advantages make Wasm quite fit for Serverless and edge computing, which is sensitive to image size or startup time.</span><span> </span></p>
<h3 id="mcetoc_1gvh5tkbq4">A micro-benchmark between WasmEdge and Runc </h3>
<p><span>We do three benchmarks to illustrate the advantage between</span> <span>WasmEdge and Runc, all benchmarks are done on Arm64 server. Here is some information about the testing platform.</span><span> </span></p>
<table>
<tbody>
<tr>
<td><span> </span></td>
<td><span> </span></td>
</tr>
<tr>
<td><span>CPU </span><span> </span></td>
<td><span>Ampere(TM) Altra(TM) Processor</span><span> </span></td>
</tr>
<tr>
<td><span>kernel </span><span> </span></td>
<td><span>5.17.0</span><span> </span></td>
</tr>
<tr>
<td><span>runc</span><span> </span><span> </span></td>
<td><span>1.1.4</span><span> </span></td>
</tr>
<tr>
<td><span>WasmEdge</span><span> </span><span> </span></td>
<td><span>0.11.0</span><span> </span></td>
</tr>
</tbody>
</table>
<p>The first test <span>verifies the size between normal rust binary (it is used by normal container) and Wasm binary. The following is the code.</span><span> </span></p>
<pre data-mode="text">fn main() { 

  println!(&#34;hello&#34;); 

} </pre>
<p><span><span lang="EN-US"><span>The normal rust binary is 1.8MB while the </span><span>W</span><span>asm</span><span> binary is only 0.8MB.</span></span><span> </span></span></p>
<p><span><span><span><img alt=" Rust helloworld image size" src="https://community.arm.com/resized-image/__size/600x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/pastedimage1679645221436v4.png"/><span></span></span><span lang="JA-JP"></span></span></span></p>
<p><span><span><span><span><span lang="EN-US"><span>The second test</span></span><span lang="EN-US"><span> is repeat start the </span><span>helloworld</span><span> image that is, </span><span>runc</span><span> and </span><span>W</span><span>asm</span><span>E</span><span>dge</span><span> for 1, 10, 100, 500, 1000 and 1500 times. As you can see in the second image, the boot time for </span><span>W</span><span>asm</span><span> is around 25% of that for normal container.</span></span><span> </span></span></span></span></span></p>
<p><span><span><span><span><span><span><img alt=" Runc vs Wasm Boot time" src="https://community.arm.com/resized-image/__size/600x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/pastedimage1679645247459v5.png"/><span></span></span><span lang="JA-JP"></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span lang="EN-US"><span>The third test</span></span><span lang="EN-US"><span> is runs in parallel by starting</span><span> </span><span>several</span></span><span lang="JA-JP"><span> </span></span><span lang="EN-US"><span>helloworld</span><span> images and making them sleep for a while, then count the memory usage. As you can see in the third image, the memory footprint of 1500 </span><span>W</span><span>asm</span><span> is 25% less than that of 1500 normal containers.</span></span><span> </span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span><span><img alt=" Runc VS WASM memory footprint" src="https://community.arm.com/resized-image/__size/600x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-38-67/pastedimage1679645281100v6.png"/><span></span></span><span lang="JA-JP"></span></span></span></span></span></span></span></span></span></p>
<h2 id="mcetoc_1gvh5tkbq5">Summary</h2>
<p><span>In this blog, we give you a general introduction of runtimes, and shows you the benchmark of image size, boot time and memory footprint between runc and WasmEdge</span><span>. </span><span> </span></p>
<p><span>Here is a table for summaries runtimes in following dimensions, image size, boot time, security, difficulty of app development, project maturity and adapted environment to evaluate.</span><span> </span></p>
<table>
<tbody>
<tr>
<td><span> </span></td>
<td><span>runc</span><span> </span></td>
<td><span>Kata/gVisor</span><span> </span></td>
<td><span>WasmEdge</span><span> </span></td>
</tr>
<tr>
<td><span>image size</span><span> </span></td>
<td><span>normal</span><span> </span></td>
<td><span>normal</span><span> </span></td>
<td><span>small</span><span> </span></td>
</tr>
<tr>
<td><span>Bootup time</span><span> </span></td>
<td><span>normal</span><span> </span></td>
<td><span>slow</span><span> </span></td>
<td><span>fast</span><span> </span></td>
</tr>
<tr>
<td><span>Security </span><span> </span></td>
<td><span>normal</span><span> </span></td>
<td><span>high</span><span> </span></td>
<td><span>unknown</span><span> </span></td>
</tr>
<tr>
<td><span>Difficulty of App development</span><span> </span></td>
<td><span>normal</span><span> </span></td>
<td><span>normal (debugging within the container is a problem)</span><span> </span></td>
<td><span>high</span><span> </span></td>
</tr>
<tr>
<td><span>Project maturity</span><span> </span></td>
<td><span>high</span><span> </span></td>
<td><span>high</span><span> </span></td>
<td><span>low</span><span> </span></td>
</tr>
<tr>
<td><span>adapted environment</span><span> </span></td>
<td><span>Normal usage</span><span> </span></td>
<td><span>Strong isolation needed</span><span> </span></td>
<td><span>Boot time or memory size sensitive</span><span> </span></td>
</tr>
</tbody>
</table>
<p><span>If you are interested in these runtimes, you can visit their official websites to obtain more detailed information.</span></p>
<p><span>WasmEdge: <a title="WasmEdge Introduction" href="https://wasmedge.org/">https://wasmedge.org/<br/></a></span><span>WebAssembly: <a title="WebAssembly" href="https://webassembly.org/">https://webassembly.org/.</a> <br/></span><span>Kata Containers: <a title="Kata Containers" href="https://katacontainers.io/">https://katacontainers.io/<br/></a></span><span>Cloud Hypervisor: <a title="Cloud Hypervisor" href="https://www.cloudhypervisor.org/">https://www.cloudhypervisor.org/</a>. <br/></span><span>gVisor:</span><span><a title="gVisor" href="https://gvisor.dev/">https://gvisor.dev/</a><span>.</span><span> </span></span></p></div>
				</div>
		</div>

</div></div>
  </body>
</html>
