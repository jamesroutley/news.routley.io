<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stategraph.dev/blog/why-we-chose-ocaml">Original</a>
    <h1>We chose OCaml to write Stategraph</h1>
    
    <div id="readability-page-1" class="page"><article>
        

        

<p><span data-category-url="/blog/category/ocaml">OCaml</span>
    <span data-category-url="/blog/category/type-systems">Type Systems</span>
    <span data-category-url="/blog/category/functional-programming">Functional Programming</span>
    <span data-category-url="/blog/category/infrastructure">Infrastructure</span>
    <span data-category-url="/blog/category/stategraph">Stategraph</span>
</p>


        <p><span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
                Josh Pollara
            </span>
            <span>•</span>
            <span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                November 6th, 2025
            </span>
        </p>

        <section aria-labelledby="tldr-h">
            <strong id="tldr-h">TL;DR</strong>
            <div role="region" aria-label="Terminal output: TL;DR">
                
                <div>
                    <p><span>$</span> cat why-ocaml.tldr</p>
                    <p>• Stategraph manages Terraform state, so correctness isn&#39;t optional</p>
                    <p>• Strongly-typed data structures catch field errors at compile time</p>
                    <p>• Type-safe SQL queries prevent schema drift before deployment</p>
                    <p>• Immutability by default eliminates race conditions</p>
                    <p>• PPX generates correct JSON serialization automatically</p>
                </div>
            </div>
        </section>

        <p>We&#39;re building infrastructure that manages other people&#39;s infrastructure. State corruption can&#39;t be &#34;rare.&#34; It has to be impossible. That&#39;s why we chose OCaml.</p>

        <p><img src="https://stategraph.dev/blog/why-we-chose-ocaml/ocaml-logo.svg" alt="OCaml logo"/>
            <img src="https://stategraph.dev/blog/why-we-chose-ocaml/ocaml-logo-dark.svg" alt="OCaml logo"/>
        </p>

        <p>Stategraph stores Terraform state as a dependency graph in PostgreSQL with resource-level locking. The challenge isn&#39;t building a database-backed state store. The challenge is ensuring that concurrent operations can never corrupt state, even with concurrent operations/users, that database schema changes break the build instead of production, and that JSON transformations are correct.</p>

        <p>We chose OCaml because its type system catches entire categories of bugs at compile time that would require extensive testing and still slip through in other languages.</p>

        <div>
            <h2>Type-safe data structures</h2>

            <p>Here&#39;s a scenario every infrastructure engineer has seen. Two Terraform operations run concurrently and both read a resource in an <code>active</code> state. One updates it while the other destroys it. Without proper coordination, you risk marking the resource as <code>destroyed</code> in state while it&#39;s still being modified in the cloud.</p>

            <p>Most systems handle this defensively with locks and runtime validation, but race conditions are hard to test and the resulting state corruption usually appears in production, not CI.</p>

            <p>Stategraph tackles this in two ways. Immutability and database-level locking prevent concurrent writes from corrupting state, while OCaml&#39;s type system makes the underlying data structures themselves safer by construction. Resources, outputs, and instances are all defined as strongly-typed records, so you can&#39;t access a field that doesn&#39;t exist or mix up field types. The compiler enforces correctness before anything runs.</p>

            <div role="region" aria-label="Type-safe resource definitions">
                
                <div>
                    <p>type t = {</p>
                    <p>  lineage : string;</p>
                    <p>  outputs : Outputs.t option;</p>
                    <p>  resources : Resources.t;</p>
                    <p>  serial : int;</p>
                    <p>  terraform_version : string;</p>
                    <p>  version : int;</p>
                    <p>}</p>
                </div>
            </div>

            <p>If you try to access <code>state.versions</code> (typo) instead of <code>state.version</code>, you get a compiler error. If you try to assign a string to <code>serial</code>, you get a compiler error. If you forget to handle <code>None</code> in the outputs field, you get a compiler error with exhaustiveness checking.</p>

            <p>This extends throughout the codebase. Every Terraform resource type, every state transition, and every database record is strongly typed. The compiler catches entire categories of bugs at compile time, like accessing non-existent fields, missing null checks, or database schema mismatches.</p>
        </div>

        <div>
            <h2>The database schema drift problem</h2>

            <p>You&#39;re iterating on your database schema by renaming a column, changing a type, or adding a constraint. In most languages, you update the schema, deploy the migration, and hope you caught all the queries that reference the old structure. You didn&#39;t because a query somewhere references the old column name. It works in dev with the old schema but crashes in staging with the new schema.</p>

            <p>Stategraph uses typed SQL where every query declares explicit types for its parameters and return values. When you change a query&#39;s type signature, every call site in the codebase must be updated to match, and the compiler enforces this.</p>

            <div role="region" aria-label="Type-checked database queries">
                
                <div>
                    <p>let insert_resource_sql () =</p>
                    <p>  Pgsql_io.Typed_sql.(</p>
                    <p>    sql</p>
                    <p>    // Ret.bigint</p>
                    <p>    /^ &#34;INSERT INTO resources (state_id, mode, type, name,</p>
                    <p>        provider_id, module_) VALUES ($state_id, $mode,</p>
                    <p>        $type, $name, $provider_id, $module_) RETURNING id&#34;</p>
                    <p>    /% Var.uuid &#34;state_id&#34;</p>
                    <p>    /% Var.text &#34;mode&#34;</p>
                    <p>    /% Var.text &#34;type&#34;</p>
                    <p>    /% Var.text &#34;name&#34;</p>
                    <p>    /% Var.uuid &#34;provider_id&#34;</p>
                    <p>    /% (Var.option @@ Var.text &#34;module_&#34;))</p>
                </div>
            </div>

            <p>This query expects specific types. The <code>state_id</code> must be a UUID, <code>mode</code> must be text, and <code>module_</code> is optional text. The return value is typed as <code>bigint</code>. If you try to pass a string where a UUID is expected, you get a compiler error. If you forget to handle the optional return value, you get a compiler error.</p>

            <p>When you update a query to match a new schema, the type system ensures every place that calls that query gets updated too. You can&#39;t deploy code where query definitions and their usage are out of sync.</p>
        </div>

        <div>
            <h2>JSON transformations that can&#39;t lose data</h2>

            <p>Stategraph ingests Terraform state as JSON, normalizes it into a graph, stores it in PostgreSQL, and reconstructs it back to JSON when Terraform requests it. Every transformation is a place where data can get lost or corrupted, whether from a field you forgot to serialize, a nested structure you flattened incorrectly, or a type that doesn&#39;t round-trip.</p>

            <p>Testing can catch some of this, and round-trip tests help, but you&#39;re fundamentally relying on test coverage. Missed cases show up when someone&#39;s Terraform state comes back missing a field.</p>

            <p>OCaml has a feature called PPX (preprocessor extensions) that generates serialization code automatically. You define the type, and the serializer is generated from the type definition.</p>

            <div role="region" aria-label="Automatic JSON serialization">
                
                <div>
                    <p>type aws_instance = {</p>
                    <p>  instance_id : string;</p>
                    <p>  instance_type : string;</p>
                    <p>  ami : string;</p>
                    <p>  availability_zone : string option;</p>
                    <p>  tags : (string * string) list;</p>
                    <p>} [@@deriving yojson]</p>
                    
                    
                    
                </div>
            </div>

            <p>When you add a field, the serializer is regenerated. When you change a type, the serializer is regenerated. If you forget to handle a case, the exhaustiveness checker catches it at compile time. You don&#39;t write serialization tests because the type system guarantees serialization is correct.</p>

            <p>This is how Stategraph handles Terraform&#39;s resource types. Every AWS resource, every GCP resource, every Azure resource is an OCaml type with automatic JSON serialization. We don&#39;t write serialization code. We don&#39;t test round-trips manually. The type system handles it.</p>
        </div>

        <div>
            <h2>Race conditions prevented by default</h2>

            <p>Terraform operations are inherently concurrent. Multiple users apply changes, CI pipelines run in parallel, and drift detection scans resources continuously. Coordinating all of this without data races requires careful mutex management and defensive programming, and it&#39;s easy to get wrong.</p>

            <p>OCaml provides immutability by default, so you can&#39;t accidentally share mutable state between concurrent operations because there is no mutable state by default. When you want to modify something, you create a new version explicitly. This eliminates entire categories of race conditions.</p>

            <p>One operation can&#39;t corrupt another operation&#39;s view of state because state is immutable by default. When combined with PostgreSQL&#39;s row-level locking at the database layer, concurrent operations compose correctly without manual mutex management or defensive copying.</p>
        </div>

        <div>
            <h2>Error handling with discipline</h2>

            <p>Type safety is only half of what makes Stategraph robust. The other half is discipline in how we use those types.</p>

            <p>We encode errors as variants and exhaustively match every case. We never use a catch-all &#34;else&#34; clause that matches everything. When we add a new error to the system, the compiler tells us every place we aren&#39;t handling it. This is how robust systems are built. Systems can fail in far more ways than they succeed, and the compiler ensures we handle all of them.</p>

            <p>This discipline extends throughout the codebase. Every error case is explicit. Every state transition is enumerated. Every optional value is handled. The type system gives us the tools, but discipline is what turns those tools into reliability.</p>
        </div>

        <div>
            <h2>The difference in practice</h2>

            <p><img src="https://stategraph.dev/blog/why-we-chose-ocaml/runtime-vs-compile-time-dark.svg" alt="Diagram comparing runtime validation where bugs are found in production versus compile-time safety where bugs are prevented by the compiler"/>
                
            </p>

            <p>The same categories of bugs. Different places to catch them.</p>
        </div>

        

        <div>
            <h2>Production systems that can&#39;t afford bugs</h2>

            <p>This isn&#39;t academic type theory. Production systems use OCaml for exactly this reason.</p>

            <p>At <a href="https://terrateam.io" target="_blank" rel="noopener">Terrateam</a>, we process thousands of concurrent Terraform operations daily, managing infrastructure for hundreds of organizations where a state corruption bug would cascade across every customer. We&#39;re built on OCaml, and the type system catches bugs at compile time that would be production incidents in other languages.</p>

            <p>Jane Street trades billions daily on OCaml infrastructure. Their trading systems handle concurrent market data and execute trades with zero tolerance for race conditions or undefined behavior. They chose OCaml because correctness isn&#39;t optional.</p>

            <div>
                <h4>Pattern Recognition</h4>
                <p>Systems that absolutely cannot fail choose languages where certain failures are impossible, not just unlikely. Testing finds bugs, but types prevent entire categories of bugs from existing.</p>
            </div>
        </div>

        <div>
            <h2>But who knows OCaml?</h2>

            <p>This is the most common objection, and OCaml developers are rare. This is true.</p>

            <p>But here&#39;s what we&#39;ve found. Engineers who understand distributed systems, type systems, and correctness learn OCaml quickly. The learning curve from Rust, Haskell, or even TypeScript with advanced types is gentler than you&#39;d expect because the concepts transfer even if the syntax is unfamiliar.</p>

            <p>More importantly, OCaml codebases are stable. We&#39;re not debugging race conditions or chasing down production crashes from schema drift. We&#39;re not writing extensive test suites for serialization edge cases. We&#39;re building features while the type system handles the category of bugs that would otherwise consume engineering time.</p>

            <p>When you encode correctness in types, maintenance gets easier instead of harder. New engineers spend less time understanding implicit invariants and more time writing code the compiler verifies.</p>
        </div>

        <div>
            <h2>Correctness as a feature</h2>

            <p>We&#39;re building Stategraph to manage Terraform state for infrastructure that runs production applications. State corruption has to be impossible instead of unlikely. Invalid state transitions need to be prevented by the compiler instead of caught by tests. Schema drift needs to break the build instead of production.</p>

            <p>That&#39;s what OCaml gives us. It provides a type system that makes entire categories of bugs impossible instead of just unlikely. The compiler proves properties about our code that testing can only approximate.</p>

            <p>OCaml&#39;s compile-time guarantees are why we use it to build Stategraph.</p>
        </div>


    </article></div>
  </body>
</html>
