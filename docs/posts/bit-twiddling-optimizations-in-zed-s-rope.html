<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/zed-decoded-rope-optimizations-part-1">Original</a>
    <h1>Bit-twiddling optimizations in Zed&#39;s Rope</h1>
    
    <div id="readability-page-1" class="page"><div><section></section><section><article><p>A couple of weeks ago I came across one of Antonio&#39;s PRs, titled &#34;<a href="https://github.com/zed-industries/zed/pull/19913">Speed up
point translation in the Rope</a>&#34; — now who doesn&#39;t stop to take a
closer look at a PR with that title?</p>
<p>The description already lives up to the title. It contains benchmark results
telling me that a method on our Rope named <code>point_to_offset</code> is now up to 70%
faster. 70%! Throughput increased by 250%. (I can&#39;t remember but I&#39;m sure I made
one of those impressed whistling sounds when I saw those numbers.)</p>
<p>Then there&#39;s the code. I scrolled through the diff and with the fourth move of
the mouse wheel I landed on this snippet and stopped:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>#[inline(always)]</span></span>
<span data-line=""><span>fn</span><span> nth_set_bit_u64</span><span>(</span><span>v</span><span>: </span><span>u64</span><span>, </span><span>mut</span><span> n</span><span>: </span><span>u64</span><span>) -&gt; </span><span>u64</span><span> {</span></span>
<span data-line=""><span>    let</span><span> v</span><span> = </span><span>v</span><span>.</span><span>reverse_bits</span><span>();</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> s</span><span>: </span><span>u64</span><span> = </span><span>64</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Parallel bit count intermediates</span></span>
<span data-line=""><span>    let</span><span> a</span><span> = </span><span>v</span><span> - ((</span><span>v</span><span> &gt;&gt; </span><span>1</span><span>) &amp; (</span><span>u64</span><span>::MAX / </span><span>3</span><span>));</span></span>
<span data-line=""><span>    let</span><span> b</span><span> = (</span><span>a</span><span> &amp; (</span><span>u64</span><span>::MAX / </span><span>5</span><span>)) + ((</span><span>a</span><span> &gt;&gt; </span><span>2</span><span>) &amp; (</span><span>u64</span><span>::MAX / </span><span>5</span><span>));</span></span>
<span data-line=""><span>    let</span><span> c</span><span> = (</span><span>b</span><span> + (</span><span>b</span><span> &gt;&gt; </span><span>4</span><span>)) &amp; (</span><span>u64</span><span>::MAX / </span><span>0x11</span><span>);</span></span>
<span data-line=""><span>    let</span><span> d</span><span> = (</span><span>c</span><span> + (</span><span>c</span><span> &gt;&gt; </span><span>8</span><span>)) &amp; (</span><span>u64</span><span>::MAX / </span><span>0x101</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Branchless select</span></span>
<span data-line=""><span>    let</span><span> t</span><span> = (</span><span>d</span><span> &gt;&gt; </span><span>32</span><span>) + (</span><span>d</span><span> &gt;&gt; </span><span>48</span><span>);</span></span>
<span data-line=""><span>    s</span><span> -= (</span><span>t</span><span>.</span><span>wrapping_sub</span><span>(</span><span>n</span><span>) &amp; </span><span>256</span><span>) &gt;&gt; </span><span>3</span><span>;</span></span>
<span data-line=""><span>    n</span><span> -= </span><span>t</span><span> &amp; (</span><span>t</span><span>.</span><span>wrapping_sub</span><span>(</span><span>n</span><span>) &gt;&gt; </span><span>8</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // [...]</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>Okay, okay, okay — &#34;Parallel bit count intermediates&#34;, &#34;Branchless select&#34; in a
PR that results in a 75% speed up — I&#39;m in. I need to know the whole story. No
way this won&#39;t be interesting.</p>
<p>So I asked Antonio what&#39;s up with the bit twiddling and he not only offered to
walk me through the optimizations he made, but also said we should pair and
add yet another optimization to make the Rope even faster when handling tabs.</p>
<p>And — lucky me — that&#39;s exactly what we did. We recorded the whole pairing
session, so you can watch it too, and now I&#39;ll share with you everything I
learned about bit twiddling optimizations on our Rope so far.</p>
<!-- -->
<div><div><p><b>Companion Video</b>: <!-- -->Rope Optimizations, Part 1</p><p>The 1.5hr companion video is the full pairing session in which Antonio and Thorsten first walk through these new optimizations on the Rope and then add another one to index tabs.</p><p>Watch the video here: <a href="https://youtu.be/9Ys9lpOyv08">https://youtu.be/9Ys9lpOyv08</a></p></div><p><a href="https://youtu.be/9Ys9lpOyv08"><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/thumbnail.jpg" width="230" height="150"/></a></p></div>
<h2 id="speeding-up-point-translation">Speeding up Point translation</h2>
<p>First, we let&#39;s take a look at how Antonio sped up &#34;point translation&#34; in the
Rope and what that even means.</p>
<p>If you&#39;ve read our post on <a href="https://zed.dev/blog/zed-decoded-rope-sumtree">Rope &amp; SumTree</a> you already know this:
our <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">Rope</a> is not a <em>real</em> Rope but a SumTree in a trench coat and looked
roughly like this before Antonio made his changes:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>struct</span><span> Rope</span><span> {</span></span>
<span data-line=""><span>    chunks</span><span>: </span><span>SumTree</span><span>&lt;</span><span>Chunk</span><span>&gt;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>struct</span><span> Chunk</span><span>(</span><span>ArrayString</span><span>&lt;</span><span>128</span><span>&gt;);</span></span></code></pre></div></figure>
<p>It&#39;s a B-tree of <code>Chunk</code>s and a <code>Chunk</code> is nothing more than a stack-allocated
string with a maximum length of 128 bytes.</p>
<p>And that&#39;s already all the background you need — our Rope is a B-tree of
128-byte strings.</p>
<h3 id="the-problem">The Problem</h3>
<p>So what&#39;s point translation? Expressed in code, it&#39;s roughly equivalent to this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>struct</span><span> Point</span><span> {</span></span>
<span data-line=""><span>    row</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>    column</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>impl</span><span> Rope</span><span> {</span></span>
<span data-line=""><span>    fn</span><span> offset_to_point</span><span>(&amp;</span><span>self</span><span>, </span><span>offset</span><span>: </span><span>usize</span><span>) -&gt; </span><span>Point</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>Point translation means: take an arbitrary offset into a string (represented
as a Rope) and translate it into a <code>Point</code> — the row and column your cursor
would land on if moved to the given offset.</p>
<p>As you can imagine, this method is a popular one in a text editor. Zed gets
offsets from all kinds of sources and has to turn them into lines and columns —
hundreds if not thousands of times per second when you&#39;re moving around a file
and editing.</p>
<p>Now imagine how you would implement that <code>offset_to_point</code> method.</p>
<p>Conceptually, what you&#39;d have to do is to go through each character in the file,
count the newlines and characters you come across, and stop once you are at your
offset. Then you know which line you are on.</p>
<p>And that&#39;s exactly what our Rope did, too.</p>
<p>If you called <code>rope.offset_to_point(7234)</code>, the Rope would traverse its
<code>SumTree</code> to find the <code>Chunk</code> that contains offset <code>7234</code> and then, on that
<code>Chunk</code>, it would call <code>offset_to_point</code> again. And <em>that</em> method, on <code>Chunk</code>,
looked pretty similar to this piece of code:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>fn</span><span> offset_to_point</span><span>(</span><span>text</span><span>: &amp;</span><span>str</span><span>, </span><span>offset</span><span>: </span><span>usize</span><span>) -&gt; </span><span>Point</span><span> {</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> point</span><span> = </span><span>Point</span><span> { </span><span>row</span><span>: </span><span>0</span><span>, </span><span>column</span><span>: </span><span>0</span><span> };</span></span>
<span data-line=""><span>    for</span><span> (</span><span>ix</span><span>, </span><span>ch</span><span>) </span><span>in</span><span> text</span><span>.</span><span>char_indices</span><span>() {</span></span>
<span data-line=""><span>        if</span><span> ix</span><span> == </span><span>offset</span><span> {</span></span>
<span data-line=""><span>            break</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        if</span><span> ch</span><span> == </span><span>&#39;</span><span>\n</span><span>&#39;</span><span> {</span></span>
<span data-line=""><span>            point</span><span>.column = </span><span>0</span><span>;</span></span>
<span data-line=""><span>            point</span><span>.row += </span><span>1</span><span>;</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            point</span><span>.column += </span><span>1</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    point</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>It&#39;s straightforward: set up a counter in the form of a <code>Point</code>, loop through all the
characters in the 128-byte string, and keep track of newlines as you come across
them.</p>
<p>But that&#39;s also the problem, right there: while the <code>Rope</code> can get us to the
right Chunk in <code>O(log(n))</code>, we still have to loop through 128 characters and
count the newlines manually — like cavemen.</p>
<p>Now you might say that 128 characters isn&#39;t a lot and what harm comes from a
little loop like that, but remember: we&#39;re talking about a text editor that
supports multiple cursors and talks to multiple language servers at once — this
loop gets executed so often, it&#39;s hot to the touch. We want it to be as
fast as possible.</p>
<p>And that&#39;s exactly what Antonio achieved.</p>
<h3 id="the-optimization">The Optimization</h3>
<p>What Antonio figured out is that instead of looping through 128 characters every
time we need find a newline, we can do it once and remember where they are,
effectively building an index of the <code>Chunk</code>.</p>
<p>And all we need for such an index is a <code>u128</code>.</p>
<p>A <code>u128</code> is Rust&#39;s 128-bit unsigned integer type and, hey, 128 — that&#39;s exactly
how many bytes are in a <code>Chunk</code>.</p>
<p>A single <code>u128</code> is enough to remember whether a given byte in a
<code>Chunk</code> has a certain property or not. For example, we could set a bit in a
<code>u128</code> at a given position to 1 if the corresponding byte in the <code>Chunk</code> is a
newline character. Or we could flip bits to remember how many bytes a character
takes up — which can be more than one with UTF-8 and emojis.</p>
<p>That&#39;s what that Antonio&#39;s PR did. Our <code>Chunk</code> now looks like this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>struct</span><span> Chunk</span><span> {</span></span>
<span data-line=""><span>    chars</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""><span>    chars_utf16</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""><span>    newlines</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""> </span>
<span data-line=""><span>    text</span><span>: </span><span>ArrayString</span><span>&lt;</span><span>128</span><span>&gt;,</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>But how does that work? And what does it buy us? Is that really better than
looping through the characters?</p>
<p>To illustrate the idea, let&#39;s focus on newlines only and use a <code>u8</code> instead of a
<code>u128</code> — less bits to show and count, same principle.</p>
<h4 id="indexing-newlines-in-a-u8">Indexing newlines in a <code>u8</code></h4>
<p>Say we have the following text:</p>

<p>We can use the following code to index the positions of the newline characters
in a <code>u8</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>fn</span><span> main</span><span>() {</span></span>
<span data-line=""><span>    let</span><span> text</span><span> = </span><span>&#34;ab</span><span>\n</span><span>cd</span><span>\n</span><span>ef&#34;</span><span>;</span></span>
<span data-line=""><span>    let</span><span> newlines</span><span> = </span><span>newline_mask</span><span>(</span><span>text</span><span>);</span></span>
<span data-line=""><span>    // ...</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>fn</span><span> newline_mask</span><span>(</span><span>text</span><span>: &amp;</span><span>str</span><span>) -&gt; </span><span>u8</span><span> {</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> newlines</span><span>: </span><span>u8</span><span> = </span><span>0</span><span>;</span></span>
<span data-line=""><span>    for</span><span> (</span><span>char_ix</span><span>, </span><span>c</span><span>) </span><span>in</span><span> text</span><span>.</span><span>char_indices</span><span>() {</span></span>
<span data-line=""><span>        newlines</span><span> |= ((</span><span>c</span><span> == </span><span>&#39;</span><span>\n</span><span>&#39;</span><span>) </span><span>as</span><span> u8</span><span>) &lt;&lt; </span><span>char_ix</span><span>;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    newlines</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>When we run this, we end up with a <code>newlines</code> bitmask that looks like this:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/newlines_mask.png" alt=""/></figure></div>
<p><code>newlines</code> now tells us that the 3rd and 6th characters in <code>text</code> are newlines.
Sweet. Now with <code>newlines</code> in hand, back to our original problem: translating an
offset into a <code>Point</code>.</p>
<p>How does <code>newlines</code> help with that?</p>
<p>Say our <code>offset</code> is <code>4</code> and say our text is <code>&#34;ab\ncd\nef&#34;</code>. We want to know what
line and column the character <code>d</code> is on.</p>
<p>Here&#39;s how we can use <code>newlines</code> to find out:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>struct</span><span> Point</span><span> { </span><span>row</span><span>: </span><span>u8</span><span>, </span><span>column</span><span>: </span><span>u8</span><span> }</span></span>
<span data-line=""> </span>
<span data-line=""><span>fn</span><span> offset_to_point</span><span>(</span><span>newlines</span><span>: </span><span>u8</span><span>, </span><span>offset</span><span>: </span><span>usize</span><span>) -&gt; </span><span>Point</span><span> {</span></span>
<span data-line=""><span>    let</span><span> mask</span><span> = </span><span>if</span><span> offset</span><span> == MAX_LEN {</span></span>
<span data-line=""><span>        u8</span><span>::MAX</span></span>
<span data-line=""><span>    } </span><span>else</span><span> {</span></span>
<span data-line=""><span>        (</span><span>1</span><span>u8</span><span> &lt;&lt; </span><span>offset</span><span>) - </span><span>1</span></span>
<span data-line=""><span>    };</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> row</span><span> = (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>count_ones</span><span>() </span><span>as</span><span> u8</span><span>;</span></span>
<span data-line=""><span>    let</span><span> newline_ix</span><span> = </span><span>u8</span><span>::BITS - (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>leading_zeros</span><span>();</span></span>
<span data-line=""><span>    let</span><span> column</span><span> = (</span><span>offset</span><span> - </span><span>newline_ix</span><span> as</span><span> usize</span><span>) </span><span>as</span><span> u8</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    Point</span><span> { </span><span>row</span><span>, </span><span>column</span><span> }</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>We first create a <code>mask</code> that has all the bits set to <code>1</code> up until the offset
we&#39;re interested in:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/offset_mask.png" alt=""/></figure></div>
<p>Then we take that <code>mask</code> and bitwise-and it with the <code>newlines</code> we passed in:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/newlines_bitand_mask.png" alt=""/></figure></div>
<p>That leaves only the newline-bits up to the offset we&#39;re interested in being
set. Now, to find out which line our offset is on, all we have to do is to count
the number of remaining bits set to <code>1</code>. That&#39;s this line:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>let</span><span> row</span><span> = (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>count_ones</span><span>() </span><span>as</span><span> u8</span><span>;</span><span> // row = 1</span></span></code></pre></div></figure>
<p>That&#39;s the row the offset is on — <code>1</code> in our case. It&#39;s zero-indexed, meaning
that when talking to a human and not a computer, we&#39;d say that the character <code>d</code>
is on line 2.</p>
<p>The next step is to figure out the column. To do that, we need to calculate the
distance between the <code>offset</code> we&#39;re interested in and the last newline
character, because that <em>is</em> what a column is: the number of characters from the
last newline.</p>
<p>This line first gives us the position of the newline closest to our offset:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>let</span><span> newline_ix</span><span> = </span><span>u8</span><span>::BITS - (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>leading_zeros</span><span>();</span></span></code></pre></div></figure>
<p>In our case, <code>newline_ix</code> is <code>3</code>:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/newline_ix.png" alt=""/></figure></div>
<p>Then we plug that into the next line:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>let</span><span> column</span><span> = (</span><span>offset</span><span> - </span><span>newline_ix</span><span> as</span><span> usize</span><span>) </span><span>as</span><span> u8</span><span>;</span></span></code></pre></div></figure>
<p>Which gives us the column <code>1</code>.</p>
<p>The result: offset <code>4</code> in <code>ab\ncd\nef</code> translates to <code>Point { row: 1, column: 1 }</code> — second line, second column.</p>
<h3 id="the-beauty-of-it">The Beauty of It</h3>
<p>Take a look at these two lines from above again:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>let</span><span> row</span><span> = (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>count_ones</span><span>() </span><span>as</span><span> u8</span><span>;</span></span>
<span data-line=""><span>let</span><span> newline_ix</span><span> = </span><span>u8</span><span>::BITS - (</span><span>newlines</span><span> &amp; </span><span>mask</span><span>).</span><span>leading_zeros</span><span>();</span></span></code></pre></div></figure>
<p><code>count_ones()</code> and <code>leading_zeros()</code> — sounds an awful lot like there might be
some looping going on to count those ones and zeros, right?</p>
<p>But no, that&#39;s the beautiful part! <code>count_ones</code> and <code>leading_zeros</code> are both
implemented with a single CPU instructions. No loop necessary. Turns out CPUs
are pretty good with zeros and ones.</p>
<p>And it&#39;s not just that we reduced the number of instructions, we also have less
<em>branch</em> instructions now and <a href="https://en.algorithmica.org/hpc/pipelining/branchless/">branchless
programming</a> can often
lead to tremendous speed-ups in hot loops.</p>
<p>If we put both versions of <code>offset_to_point</code> — one with a loop and one with the
bitmask — into <a href="https://gist.github.com/mrnugget/b22583bf832b9ae23e85bd198e98d54e">micro-benchmark</a> and use an actual <code>u128</code> instead of
an <code>u8</code> to make the results more pronounced, we can see how much faster the
loop-less, branch-less version is:</p>
<div><pre><code>Running benches/benchmark.rs (target/release/deps/benchmark-21888b29446a33c0)

offset_to_point_u128/loop_version
                   time:   [56.914 ns 57.001 ns 57.096 ns]

offset_to_point_u128/mask_version
                   time:   [1.0478 ns 1.0501 ns 1.0529 ns]
</code></pre></div>
<p><code>57ns</code> with the loop and <code>1ns</code> with the bitmask — 57x faster. Impressed
whistling sound.</p>
<p>Of course, all the disclaimers about micro-benchmarks apply and in our
production code the results aren&#39;t that drastic, but very, very good
nonetheless: the 70% speed-up I mentioned at the start is real.</p>
<h2 id="indexing-tabs">Indexing Tabs</h2>
<p>Fascinated and motivated by all of this, Antonio and I then set out to add the
same index for tabs.</p>
<p>&#34;Tabs?&#34;, you might say, &#34;I don&#39;t use tabs.&#34; Yes, you don&#39;t, but Zed doesn&#39;t know
that and still has to check whether you have tabs at the start of your lines in
order to display them correctly.</p>
<p>And tabs are tricky. You can&#39;t display tabs like other characters. Tabs
are... dynamic, for the lack of a better word.</p>
<p>How the string <code>\t\tmy function</code> is displayed depends on what <a href="https://zed.dev/docs/configuring-zed#tab-size">tab size you have
configured</a>: if the tab size is
four, then <code>\t\t</code> should be displayed as eight spaces. If it&#39;s two, it&#39;s four spaces.</p>
<p>&#34;Poor text editor developers&#34;, you might be thinking, &#34;they have to multiply
numbers.&#34; Appreciate the compassion, but, listen, that&#39;s not all.</p>
<p>Consider this piece of text:</p>

<p>With a tab size of 4 and hard tabs enabled, it should be displayed like this:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-optimizations-part-1/tabs.png" alt=""/></figure></div>
<p>That&#39;s right — the first tab in the first line only takes up two spaces, the
others all take up four spaces.</p>
<p>You see: tabs are tricky and, as it turns out, also costly.</p>
<p>In a performance profile, Antonio saw that we spend a lot of time figuring out
where and how many tabs there are in a given file. A <em>lot</em> of time.</p>
<p>So what we did in our pairing session was to add an index for tabs that works
just like the index for newlines:</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>struct</span><span> Chunk</span><span> {</span></span>
<span data-line=""><span>    chars</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""><span>    chars_utf16</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""><span>    newlines</span><span>: </span><span>u128</span><span>,</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // We added this field:</span></span>
<span data-line=""><span>    tabs</span><span>: </span><span>u128</span></span>
<span data-line=""> </span>
<span data-line=""><span>    text</span><span>: </span><span>ArrayString</span><span>&lt;</span><span>128</span><span>&gt;,</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>Does it make Zed faster?</p>
<p>We&#39;ll see. This time we only added the index, but we haven&#39;t actually changed
the code the higher layers to use it yet. We&#39;ll do that in the next Zed
Decoded episode.</p>
<p>Until then, watch the full pairing session in the <a href="https://youtu.be/9Ys9lpOyv08">companion
video</a> to see how all the nuts and bolts are put into place.</p><hr/></article></section></div></div>
  </body>
</html>
