<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taylor.town/elm-2023">Original</a>
    <h1>Why I Use Elm in 2023</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<img src="https://taylor.town/elm-mario.png" alt="elm mario example code"/>
</p>
<p>
<img src="https://taylor.town/elm-debug.png" alt="elm debugger"/>
</p>

<p>
If you look at some of my <a href="https://taylor.town/about#projects">recent projects</a>, you’ll notice I enjoy building lean websites with pure HTML+CSS.</p>
<p>
But building UIs in HTML+CSS can be untenable. When making complex frontend experiences, I reach for <a href="https://elm-lang.org">Elm</a>. Here’s why:</p>
<ol start="7" reversed="reversed">
<li>
<a href="#packages">community packages that work</a> </li>
<li>
<a href="#performance">great performance</a> </li>
<li>
<a href="#tooling">solid tooling</a> </li>
<li>
<a href="#simplicity">minimal cognitive overhead</a> </li>
<li>
<a href="#predictability">extreme predictability</a> </li>
<li>
<a href="#types">fearless refactoring</a> </li>
<li>
<a href="#design">incredible API design</a> </li>
</ol>

<h2 id="packages">
7. Community Packages That Work</h2>
<p>
Modern web development seems hellish for some organizations.</p>
<p>
For the past 10 years, I’ve watched teams struggle against NPM packages. I’ve been part of multiple migrations between <a href="https://momentjs.com">moment.js</a>, <a href="https://moment.github.io/luxon/#/">Luxon</a>, and <a href="https://github.com/iamkun/dayjs">day.js</a>. React applications drown in <a href="https://fe-tool.com/awesome-react-state-management">state management libraries</a> that perpetually break something important. And don’t get me started on <a href="https://fe-tool.com/awesome-react-hook">React hooks</a>.</p>
<p>
Every package on NPM seems (1) inundated with breaking changes or (2) completely abandoned. Codebase upgrades are terrifying after your team finds the perfect <code>package.lock</code> that works for everybody.</p>
<p>
The poor quality of NPM also leaks into the devops-side of frontend. Every Webpack/Babel/Vite/EsBuild/Parcel ecosystem feels like a delicate mess on stilts. I’ve witness countless engineering hours wasted on JS source maps, polyfills, and build errors.</p>
<p>
Outside of React, the situation seems equally bleak. Frontend frameworks in JS, Python, Elixir, etc. look riddled with similar quality problems. There’s a lot of software out there, so please <a href="https://taylor.town/cdn-cgi/l/email-protection#2a424f4646456a5e4b53464558045e455d44">email me</a> if there are any ecosystems I should reconsider.</p>
<p>
<a href="https://package.elm-lang.org">Elm’s packages</a> are generally well-documented, focused, appropriately named, and bug-free. But don’t take my word for it – pick any of these packages at random and see the quality for yourself:</p>
<table>
<thead>
<tr>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/elm-explorations/test/latest/">elm-explorations/test</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/elm-explorations/webgl/latest/">elm-explorations/webgl</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/">rtfeldman/elm-css</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/rtfeldman/elm-hex/latest/">rtfeldman/hex</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/lukewestby/elm-http-builder/latest/">lukewestby/elm-http-builder</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/mdgriffith/elm-codegen/latest/">mdgriffith/elm-codegen</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/mdgriffith/elm-style-animation/latest/">mdgriffith/elm-style-animation</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/">mdgriffith/elm-ui</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/w0rm/elm-physics/latest/">w0rm/elm-physics</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/BrianHicks/elm-csv/latest/">BrianHicks/elm-csv</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/terezka/elm-charts/latest/">terezka/elm-charts</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/tesk9/accessible-html/latest/">tesk9/accessible-html</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/robinheghan/elm-phone-numbers/latest/">robinheghan/elm-phone-numbers</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/ianmackenzie/elm-geometry/latest/">ianmackenzie/elm-geometry</a> </td>
</tr>
<tr>
<td>
<a href="https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/">ianmackenzie/elm-units</a> </td>
</tr>
</tbody>
</table>
<h2 id="performance">
6. Great Performance</h2>
<p>
<a href="https://engineering.rakuten.today/post/elm-at-rakuten/">This piece from Rakuten</a> matches my own experiences with Elm:</p>
<blockquote>
<ul>
<li>
The performances of Elm applications are among the fastest. Internally Elm uses the concept of a virtual DOM, similar to React. The speed of the Elm virtual DOM is comparable to Svelte, which uses a different mechanism to update the DOM. </li>
<li>
The Elm compiler produces smaller assets compared to other frameworks. Among the various optimizations to achieve this result, there is the dead code elimination with granularity to the single function that works across the entire ecosystem. If you import a large package and use only one of the functions contained, the compiler will ensure that only that function ends up in your generated code. </li>
<li>
The Elm compiler per se is also fast. Our bigger codebase contains ~66,500 lines of Elm code, and it compiles incrementally in 0.3 seconds and from scratch in 2.5 seconds. </li>
</ul>
</blockquote>
<p>
I want to add that Elm’s virtual DOM will obviously be strictly worse than an equivalent optimized vanilla JS program. But for modern browsers, Elm seems to offer the best balance of developer ergonomics and runtime speed.</p>

<p>
Writing <a href="https://github.com/elm-tooling/elm-language-server">Elm in Neovim</a> is wonderful. Everything feels snappy regardless of file sizes: types hints, tests, errors, autoformatting, and recompilation.</p>
<p>
Thanks to the speedy and simple Elm compiler, I can keep my tooling extremely simple during development. Here’s my entire live webdev setup:</p>
<pre><code>http-server dist \
&amp; watch -p &#34;**/*.elm&#34; -c &#34;elm make src/Main.elm --debug --output=dist/elm.js&#34;</code></pre>
<p>
Debugging is straightforward. When my code behaves strangely, I use Elm’s time-travelling debugger to inspect the model at each state-change. From there, pure functions make errors obvious.</p>
<h2 id="simplicity">
4. Minimal Cognitive Overhead</h2>
<p>
Most languages are too powerful for my palate.</p>
<p>
Don’t get me wrong – I love Rust and many other languages! But sometimes they’re just too much for me.</p>
<p>
When writing Rust or JS or Haskell or Python or Lisp, I’m overwhelmed by opportunity. Should I make this generic? Should I use classes or structs? Immutable or mutable? Macros? Functional or imperative array manipulation?</p>
<p>
I try to please compilers and coworkers and customers, but all are disappointed. Give me a woodshop and I’m lost, but give me a simple chisel and I intuitively know what to do. There’s a certain freedom in restricted toolsets.</p>
<p>
Languages like Go and Elm spurn extravagance. They resist overcomplication. They force me to solve real problems instead of fighting compiler errors and stylistic differences.</p>
<p>
Furthermore, consistent code makes portable mental-models. Go and Elm codebases tend to be extremely readable.</p>
<h2 id="predictability">
3. Extreme Predictability</h2>
<p>
I like shiny new features <em>and</em> predictability.</p>
<p>
Unfortunately, there are tradeoffs. For compiler teams, bug-hunting steals time from feature-development.</p>
<p>
I can live with landmines if they don’t change positions. Releasing patches reduces predictability. If a bug has a known workaround, I want the devs to focus all efforts on their next release instead of old errors.</p>
<p>
But I’m also a patient person who loves ambitious visions. I would rather wait years for tightly-integrated featuresets than months for haphazard improvements.</p>
<p>
Elm 0.19.1 has been the latest version since 2019. I’ve heard rumors of some new stuff coming in 2023, which is super exciting, but 0.19.1 remains wonderfully stable. I’ll be happy with future releases as long as they’re predictable, holistically designed, and relatively infrequent.</p>

<h2 id="types">
2. Fearless Refactoring</h2>
<p>
When it comes to building software, my first guesses are generally wrong.</p>
<p>
In most languages, changing things is a brutal process. I tend to live with my mistakes because refactoring is too tiresome.</p>
<p>
With Elm, I experiment and change everything with little resistance. As long as I watch wildcard matches in my <code>case</code> statements, the compiler quickly guides me back to a working program from any change.</p>
<p>
Theoretically, all static type systems should be able to do this, but they just don’t. I don’t know why, but my major changes in Haskell/Rust/Go always end up with unintended results. Elm’s error messages are really in a class of their own, and it has nothing to do with pretty formatting.</p>
<h2 id="design">
1. Incredible API Design</h2>
<p>
Elm’s mental models made me a better programmer.</p>
<p>
If you haven’t already, take some time to browse Elm’s 1st-party libraries: <a href="https://package.elm-lang.org/packages/elm/core/latest/">core</a>, <a href="https://package.elm-lang.org/packages/elm/html/latest/">html</a>, <a href="https://package.elm-lang.org/packages/elm/json/latest/">json</a>, <a href="https://package.elm-lang.org/packages/elm/browser/latest/">browser</a>, <a href="https://package.elm-lang.org/packages/elm/url/latest/">url</a>, <a href="https://package.elm-lang.org/packages/elm/http/latest/">http</a>, <a href="https://package.elm-lang.org/packages/elm/bytes/latest/">bytes</a>, <a href="https://package.elm-lang.org/packages/elm/file/latest/">file</a>, <a href="https://package.elm-lang.org/packages/elm/parser/latest/">parser</a>, <a href="https://package.elm-lang.org/packages/elm/random/latest/">random</a>, <a href="https://package.elm-lang.org/packages/elm/regex/latest/">regex</a>, and <a href="https://package.elm-lang.org/packages/elm/time/latest/">time</a>.</p>
<p>
All the main libraries contain gems. They’re easy yet strict; simple yet powerful.</p>
<p>
For example, consider the <a href="https://package.elm-lang.org/packages/elm/parser/latest/">parser</a> library. Parser pipelines are delightful to use, and teach you to think in terms of non-backtracking flows. When you’re ready, you can upgrade to <code>Parser.Advanced</code> for extra contextual powers, but the complexity doesn’t get in the way when you don’t need it.</p>
<p>
Even if you never seriously use Elm, study its libraries and build some toys with them. There’s plenty of wisdom to glean from its careful design.</p>
</div></div>
  </body>
</html>
