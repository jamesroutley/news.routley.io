<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/why-stick-to-emacs-blog">Original</a>
    <h1>I Keep Blogging with Emacs</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
Every time I look at someone’s simple static site generation setup for their
blog, I feel a pang of envy. I’m sure I could make a decent blogging engine in
2,000 lines of code, and it would be something I’d understand, be proud over,
able to extend, and willing to share with others.
</p>

<p>
Instead, I write these articles in Org mode, and use mostly the standard Org
publishing functions to export them to <abbr>html</abbr>. This is <a href="https://entropicthoughts.com/long-hiatus-emacs-upgrades.html">sometimes brittle</a>, but
most annoyingly, I don’t understand it. I have been asked for details on how my
publishing flow works, but the truth is I have no idea what happens when I run
the <code>org-publish-current-file</code> command.
</p>

<p>
I could find out by tracing the evaluation of the Lisp code that runs on export,
but I won’t, because just the <abbr>html</abbr> exporting code (<code>ox-html.el</code>) is 5,000
lines of complexity. The general exporting framework (<code>ox-publish.el</code> and
<code>ox.el</code>) is 8,000 lines. The framework depends on Org parsing code
(<code>org-element.el</code>) which is at least another 9,000 lines. This is over 20,000
lines of complexity I’d need to contend with.
</p>

<p>
It might seem like a no-brainer to just write that 2,000 line custom static
generator and use that instead.
</p>

<hr/>

<p>
Except one thing: Babel.
</p>

<p>
Any lightweight markup format (like Markdown or ReStructuredText or whatever)
allows for embedding code blocks, but Org, through Babel, can <i>run</i> that code on
export, and then display the output in the published document, <i>even when the
output is a table or an image</i>. It supports sessions that lets code reuse
definitions from earlier code blocks. It allows for injecting variables from the
markup into the code, and vice versa. As a bonus, Org doesn’t require a
JavaScript syntax highlighter, because it generates inline styles in the source
code.
</p>

<p>
It does this for a large number of languages, although I mainly use it with R
for drawing plots. Being able to do this is incredibly convenient, because it
makes it trivial to <a href="https://entropicthoughts.com/intention-to-treat-experiments.html">draft data, illustrations, and text at the same time</a>,
adjusting both until the article coheres. Having tried it, I cannot see myself
living without it.
</p>

<hr/>

<p>
A simple 2,000 line blogging engine would be a fun weekend project. Mirroring
the features of Babel I use would turn it into a multi-month endeavour for
someone with limited time such as myself. Not going to happen, and I will
continue to beat myself up for overcomplicating my publishing workflow.
</p>

            </div></div>
  </body>
</html>
