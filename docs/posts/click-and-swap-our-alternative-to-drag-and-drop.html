<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.contentsquare.com/2021/click-and-swap-alternative-to-drag-and-drop/">Original</a>
    <h1>Click and Swap, our alternative to Drag and Drop</h1>
    
    <div id="readability-page-1" class="page"><div><div><div> <div>  <div><p>At <a href="https://www.contentsquare.com" rel="nofollow noopener noreferrer" target="_blank">Contentsquare</a>, we gather hundreds of metrics about user interactions on the websites of our customers. Having all this information can easily become cumbersome and hard to exploit. To make user experience more intuitive and practical, and to enable customer collaboration, we created the <strong>workspace module</strong>.</p>
<p>Workspace is a place for personalisation and collaboration. It allows customers to create dashboards to visualize metrics related to their websites. A dashboard is composed of <strong>widgets</strong> which represent different visualization types (single numeric value, line chart or page visualizations) and widgets are added to a dashboard using a drag and drop system.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/6dc45ba-1140.png" alt="Contentsquare&#39;s Workspace module" title="Contentsquare&#39;s Workspace module"/> <figcaption>Contentsquare&#39;s Workspace module</figcaption></figure>
<p>The workspace module also enables collaboration between customers via sharing. A customer can spend time building a dashboard and then easily share it with specific people or with their entire company using a single click, enabling them to quickly access the data visualisation and thus save time.</p>
<p>Although the workspace module was working perfectly, we kept getting feedbacks from customers about the layout organization of dashboards. The drag and drop system was making it hard for customers to place a widget at a very specific position or to relocate a widget. This happens especially with a large number of widgets: the layout often breaks with some unexpected behavior and widgets a user did not intend to move can be moved accidentally.</p>
<p>After multiple sessions and back and forths between the product manager, the designers and the users to observe their behavior interacting with the module, we came to the conclusion that the problem was the drag and drop behavior and that it needed to be replaced with a new technology.</p>
<p>The designers searched for inspiration by looking at any digital interface that has the “relocating an element” behavior and came up with a few proposals that were discussed, challenged and improved by the developers and the product manager. They aimed for the right balance between desirability, viability and feasibility.
During this period, several iterations of a prototype were made to have a concrete vision of what we wanted to do and also to have feedback from some selected customers which were later taken into consideration to improve the current prototype.</p>
<p>The result was an arrow based movement system, or <strong>click and swap</strong>. On hover on any widget, four directional arrows allow for movement. A movement can result in either the widget getting moved to a certain location if it is free (no other widget occupying that position) or it getting swapped with another widget. The movements are dictated by a movement strategy, which we will explain more precisely later on this article.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/a25598a-1140.png" alt="Workspace&#39;s arrow based system" title="Workspace&#39;s arrow based system"/> <figcaption>Workspace&#39;s arrow based system</figcaption></figure>
<h2 id="technical-solution"><a href="#technical-solution" aria-hidden="true" tabindex="-1"><span></span></a>Technical solution</h2>
<p>Before starting the implementation of our own grid layout library (that we baptised without thinking too much “the grid library”), we started by identifying the technical problems we had with the drag and drop library we were using (in addition to all the user experience issues we mentionned earlier). We used this as a guide to get to a more easy to use solution that is more tailored to our needs:</p>
<ul>
<li><strong>It had too many configuration options</strong>: it is tempting to make a generic library that accepts each and every configuration possible, but if you can do everything, it means you are probably not the best at anything. So the level of genericity had to be more reasonable.</li>
<li><strong>It was not very declarative</strong>: many configuration options needed to be done programmatically (by manipulating the grid DOM&#39;s instance) and by digging into low-level details. It would have been much easier to use if it was done in a declarative way. So we needed to raise the level of declarative programming.</li>
<li><strong>It was not framework-agnostic</strong>: The library we were using was <a href="https://angular.io/" rel="nofollow noopener noreferrer" target="_blank">Angular</a> specific so if we ever wanted to use the same system in another App with another framework (and we sure do work with a lot of frameworks), it would have required us to find an implementation specific to the framework (or make our own). So we had to make something framework-agnostic.</li>
</ul>
<p>Let’s start with the last point, the framework-agnostic part. You might already be familiar with the concept of <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow noopener noreferrer" target="_blank">Web Components</a>. If not, and to put it simply, it is a standard allowing developers to create custom elements that work natively on the browser without any framework or library.</p>
<p>It is of course possible to build Web Components from scratch, but it is easier to go with a framework that does all the heavy lifting for you. In our case we went with <a href="https://stenciljs.com/" rel="nofollow noopener noreferrer" target="_blank">Stencil</a>. This article is not specific to Stencil so we will not go much into details about the different pros of this framework, but the main reasons for our choice were:</p>
<ul>
<li>Every component is compiled into a Web Component by default (no framework runtime is needed)</li>
<li>We are already using it for our design system internal library</li>
</ul>
<h3 id="solution-design"><a href="#solution-design" aria-hidden="true" tabindex="-1"><span></span></a>Solution design</h3>
<h4 id="overview"><a href="#overview" aria-hidden="true" tabindex="-1"><span></span></a>Overview</h4>
<p>The main idea we had in mind while designing the solution is to have a plug and play component that is easy to use, while giving the possibility to customize it if the user wants to have a reasonably customized version of the grid.</p>
<p>The final product looks like this:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>grid-wrapper</span> <span>edit-mode</span><span><span>=</span><span>&#34;</span>true<span>&#34;</span></span><span>&gt;</span></span>
    <span><span><span>&lt;</span>grid-item</span> <span>item-id</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>x</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>y</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>rows</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>cols</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span><span>&gt;</span></span>
      
    <span><span><span>&lt;/</span>grid-item</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>grid-item</span> <span>item-id</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>x</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>y</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>rows</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>cols</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span><span>&gt;</span></span>
      
    <span><span><span>&lt;/</span>grid-item</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>grid-wrapper</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
</code></pre></div>
<p>The above code is sufficient to do the following:</p>
<ul>
<li>Divide the available space into a grid layout of 4 equally sized columns (4 columns is our opinionated choice in case no <em>columns</em> attribute is specified)</li>
<li>Place the items inside the grid according to their <em>x</em> and <em>y</em> coordinates</li>
<li>Size the items according to the their rows and cols attributes, in case an item spans over multiple lines or columns</li>
<li>Show directional arrows on top of the grid items on hover allowing the user to move them around</li>
<li>Show <strong>(+)</strong> buttons on empty spaces to allow the user to add more items to the grid</li>
<li>Show <strong>(+)</strong> buttons between items to allow the user to add items between grid items</li>
</ul>
<p>With this tiny code, the display can look like this:
</p><figure><img src="https://engineering.contentsquare.com/_nuxt/img/4ff68e4-1140.png" alt="Grid display example" title="The direction arrows only appear on hover"/> <figcaption>The direction arrows only appear on hover</figcaption></figure>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/4807116-1140.png" alt="Grid display example" title="A + button appears when hovering an empty cell"/> <figcaption>A + button appears when hovering an empty cell</figcaption></figure>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/ad74a5a-1140.png" alt="Grid display example" title="The second item has been moved to the right"/> <figcaption>The second item has been moved to the right</figcaption></figure>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/dca248c-1140.png" alt="Grid display example" title="Hovering between items makes another + button appear"/> <figcaption>Hovering between items makes another + button appear</figcaption></figure>
<p><strong>NB:</strong> The directional arrows and the <strong>(+)</strong> butttons are only shown when the <em>edit-mode</em> attribute is set to <em>true</em>, otherwise they are hidden.</p>
<p>For users who want further customization, they can achieve so by overriding the <em>grid-wrapper</em> attributes: responsiveness, edit-mode, number of columns, gaps, each unit width/height, all of this can be overriden.</p>
<h4 id="technical-details"><a href="#technical-details" aria-hidden="true" tabindex="-1"><span></span></a>Technical details</h4>
<p>Let’s take a look again at the basic grid example we saw earlier:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>grid-wrapper</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>grid-item</span> <span>item-id</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>x</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>y</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>rows</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>cols</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span><span>&gt;</span></span>
      
    <span><span><span>&lt;/</span>grid-item</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>grid-item</span> <span>item-id</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>x</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>y</span><span><span>=</span><span>&#34;</span>0<span>&#34;</span></span> <span>rows</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span> <span>cols</span><span><span>=</span><span>&#34;</span>1<span>&#34;</span></span><span>&gt;</span></span>
      
    <span><span><span>&lt;/</span>grid-item</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>grid-wrapper</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
</code></pre></div>
<p>The first thing that we needed to do is to make the <em>grid-wrapper</em> aware of its children so it can manage them. Each <em>grid-item</em> should notify the <em>grid-wrapper</em> when it is added to or removed from the DOM.
For this, we used the <code>connectedCallback</code> native to Web Components, and because everything is a Web Component in Stencil (so <em>grid-item</em> is also a Web Component), this callback is triggered every time a <em>grid-item</em> is added to the DOM. The same thing applies when a <em>grid-item</em> is removed from the DOM, its <code>disconnectedCallback</code> is triggered.</p>
<p>This behaviour can be seen in the schema below, each time a <em>grid-item</em> is added it notifies the parent (<em>grid-wrapper</em>) passing to it its attributes (mainly position, dimensions, and a reference to its HTML element). This will allow the <em>grid-wrapper</em> to construct a <em>State</em>.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/d5d9e82-1006.png" alt="A grid-item registering itself" title="A grid-item registering itself within the grid-wrapper"/> <figcaption>A grid-item registering itself within the grid-wrapper</figcaption></figure>
<p>The state is a 2D matrix allowing us to represent the elements on the grid with their positions and dimensions. It contains object representations of the grid items positioned on the matrix based on their positions on the view. It is our model.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/4ea8edc-1140.png" alt="Constructing the state" title="Constructing the state"/> <figcaption>Constructing the state</figcaption></figure>
<p>The state is directly linked to the view, each time it changes it triggers a re-render of the view. This allows us to handle grid items movements efficiently.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/49416f1-1140.png" alt="State change triggers re-rendering" title="State change triggers re-rendering"/> <figcaption>State change triggers re-rendering</figcaption></figure>
<p>Because everything is handled through a state machine, one could even redefine what should happen when an element is moved, added or resized. In our case, we think that when an element is moved on top of an existing one then they should swap, but maybe you would prefer them to be pushed? By writing your own movement strategy function you can override the default behavior to suit your needs. The same goes for the adding strategy (to append elements to the grid) and the resize strategy. The strategies are pluggable functions that take the current state of the grid as a parameter, plus any necessary information, and produce a new state.</p>
<p>Let’s take the movement strategy as an example. The schema below represents a use-case where we want to move a <em>grid-item</em> up by clicking on its “up” direction arrow.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/0703d13-1140.png" alt="Moving a grid-item flow" title="Moving a gid-item flow"/> <figcaption>Moving a gid-item flow</figcaption></figure>
<p>Each time an element wants to move, it sends an event to the <em>grid-wrapper</em> containing the item ID and the direction to which it wants to move to. The <em>grid-wrapper</em> calls its movement strategy via the method: <code>ComputeProjectedStateStrategy(currentState, itemToMove, direction) =&gt; newState</code></p>
<p>This method calculates what will be the next state (projected state) if we indeed move this item to the top. The projected state can be <code>null</code> to indicate that a movement in this direction is not possible.</p>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/0ff5760-1140.png" alt="Moving an item triggers re-rendering" title="Moving an item triggers re-rendering"/> <figcaption>Moving an item triggers re-rendering</figcaption></figure>
<p>The same logic goes for the other strategies. If a user wants to implement a different movement strategy, all that is needed is to provide a method with the same signature as <code>ComputeProjectedStateStrategy</code>.</p>
<h3 id="testing"><a href="#testing" aria-hidden="true" tabindex="-1"><span></span></a>Testing</h3>
<p>We tried to focus our tests on the most important part of the system, that is the state of the grid, thus we tested all possible use-cases on moving or resizing items.</p>
<p>Knowing that each action (move or resize) results in a new <em>GridState</em>, we splitted our unit tests to check only one action at a time instead of chaining multiple actions on a given single test (the output of one action could be the input of a new unit test). So, we constructed lists of test cases respecting the following interfaces:</p>
<div><pre><code>{
 description: string;
 action: {
   itemId: string; // id of item being moved/resized
   direction: Direction; // target direction of the move
   size: number; // requested size
 };
 initial: GridState;
 expected: GridState;
}
</code></pre></div>
<p>Finally, we run our <code>ComputeProjectedState</code> strategy on the <strong>initial</strong> state and expect to correctly compute the next state as <strong>expected</strong>.</p>
<p>Knowing that it would be a headache to debug failing tests, if any, we bootstrapped a small Stencil app that, given the same tests lists, renders the <strong>initial</strong>, <strong>result</strong> vs <strong>expected</strong> state for each test, while highlighting, at the top section of the app, the test description, the item color being moved/resize and the direction of the move / the requested size.
</p><figure><img src="https://engineering.contentsquare.com/_nuxt/img/4e7542a-1140.png" alt="Example: test moving light-blue item to the right" title="Example: test moving light-blue item to the right"/> <figcaption>Example: test moving light-blue item to the right</figcaption></figure>
<figure><img src="https://engineering.contentsquare.com/_nuxt/img/1c3595c-1140.png" alt="Example: test resizing light-green item to 3 cols" title="Example: test resizing light-green item to 3 cols"/> <figcaption>Example: test resizing light-green item to 3 cols</figcaption></figure>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true" tabindex="-1"><span></span></a>Conclusion</h2>
<p>What started as a revamp became a lightweight generic grid library. Our composition-based approach consisting of offering a very simple declarative API to the developer and allowing custom behavior injection paid off. It made the developer experience very smooth and opened the door for the library to be used within other teams. Using a framework-agnostic approach by exposing the library as a Web Component was also a huge enabler for this.</p>
<p>All this would not have been possible without a tight collaboration of all the actors within the team. All players contributed to a continuous improvement loop: designers provided prototypes, developers challenged them and the whole team tested them. It provided precious feedback that helped us get to a mature solution. The resulting product offers a much-improved user experience compared to what we had before, and the customer feedbacks are very positive.</p></div></div> </div> </div></div></div>
  </body>
</html>
