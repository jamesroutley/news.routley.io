<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tkdodo.eu/blog/the-useless-use-callback">Original</a>
    <h1>The Useless UseCallback</h1>
    
    <div id="readability-page-1" class="page"><div id="skip-nav"><p><time>28.07.2025</time> ‚Äî <a href="https://tkdodo.eu/blog/tags/react">React</a>, <a href="https://tkdodo.eu/blog/tags/java-script">JavaScript</a>, <a href="https://tkdodo.eu/blog/tags/use-callback">useCallback</a>, <a href="https://tkdodo.eu/blog/tags/performance">Performance</a> ‚Äî <span>5<!-- --> min read</span></p><section><span>
      <span></span>
  <img alt="a man holds his head while sitting on a sofa" title="a man holds his head while sitting on a sofa" src="https://tkdodo.eu/blog/static/df8b0abb50f00e0c72e018df409e0d8f/bbe0c/useless.jpg" srcset="/blog/static/df8b0abb50f00e0c72e018df409e0d8f/46946/useless.jpg 240w,/blog/static/df8b0abb50f00e0c72e018df409e0d8f/55489/useless.jpg 480w,/blog/static/df8b0abb50f00e0c72e018df409e0d8f/bbe0c/useless.jpg 640w" sizes="(max-width: 640px) 100vw, 640px" loading="lazy" decoding="async"/>
    </span><ul><li><a href="https://tkdodo.eu/blog/the-uphill-battle-of-memoization">#1: The Uphill Battle of Memoization</a></li><li><b>#2: The Useless useCallback</b></li></ul><hr/><p>I thought I&#39;d written enough about memoization by now, but I feel there is one pattern I&#39;m seeing a lot lately that makes me think otherwise. So today, I want to look at <code>useCallback</code>, and to some extent <code>useMemo</code>, in situations where I think they are totally pointless.</p><h2 id="why-memoize">Why memoize?<a href="#why-memoize" aria-label="why memoize permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>There&#39;s usually only two reasons to create a memoized version of a function with <code>useCallback</code> or a value with <code>useMemo</code>:</p><h3 id="performance-optimization">Performance optimization<a href="#performance-optimization" aria-label="performance optimization permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>Something is slow, and slow is usually bad. Ideally, we&#39;d make it faster, but we can&#39;t always do that. Instead, we can try to do that slow thing less often.</p><p>In React, a lot of the time, the slow thing is re-rendering of a sub-tree, so we&#39;d like to ideally avoid that if we think it&#39;s &#34;not necessary&#34;.</p><p>That&#39;s why we sometimes wrap components in <code>React.memo</code>, which is <a href="https://tkdodo.eu/blog/the-uphill-battle-of-memoization">an uphill battle</a> mostly not worth fighting, but still, it&#39;s a thing that exists.</p><p>If we pass a function or a non-primitive value to a memoized component, we need to make sure that references to those are <span>stable</span>. That&#39;s because React compares the props of a memoized component with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noreferrer noopener">Object.is</a> to check if it can skip rendering that sub-tree. So if the reference isn&#39;t stable, e.g. because it&#39;s newly created in each render, our memoization &#34;breaks&#34;:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>function</span><span> </span><span>Meh</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>return</span><span> </span><span>(</span><span></span></p><p><span>3</span><span>    </span><span>&lt;</span><span>MemoizedComponent</span><span></span></p><p><span>4</span><span>      </span><span>value</span><span>=</span><span>{</span><span>{</span><span> hello</span><span>:</span><span> </span><span>&#39;world&#39;</span><span> </span><span>}</span><span>}</span><span></span></p><p><span>5</span><span>      </span><span>onChange</span><span>=</span><span>{</span><span>(</span><span>result</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;result&#39;</span><span>)</span><span>}</span><span></span></p><p><span>6</span><span>    </span><span>/&gt;</span><span></span></p><p><span>7</span><span>  </span><span>)</span><span></span></p><p><span>8</span><span></span><span>}</span><span></span></p><p><span>9</span><span>
</span></p><p><span>10</span><span></span><span>function</span><span> </span><span>Okay</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>11</span><span>  </span><span>const</span><span> value </span><span>=</span><span> </span><span>useMemo</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>(</span><span>{</span><span> hello</span><span>:</span><span> </span><span>&#39;world&#39;</span><span> </span><span>}</span><span>)</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>12</span><span>  </span><span>const</span><span> onChange </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span>(</span><span>result</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>result</span><span>)</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>13</span><span>
</span></p><p><span>14</span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>MemoizedComponent</span><span> </span><span>value</span><span>=</span><span>{</span><span>value</span><span>}</span><span> </span><span>onChange</span><span>=</span><span>{</span><span>onChange</span><span>}</span><span> </span><span>/&gt;</span><span></span></p><p><span>15</span><span></span><span>}</span></p></code></pre></div><p>Yes, sometimes the computation inside <code>useMemo</code> itself is slow, and we memoize to avoid those recomputations. Those <code>useMemo</code> calls are perfectly fine, too, but I don&#39;t think they are the majority of use-cases.</p><h3 id="prevent-effects-from-firing-too-often">Prevent effects from firing too often<a href="#prevent-effects-from-firing-too-often" aria-label="prevent effects from firing too often permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>If not passed as a prop to a memoized component, chances are our memoized value gets eventually passed as a dependency to an effect (sometimes through some layers of custom hooks).</p><p>Effect dependencies follow the same rules as <code>React.memo</code> - they are compared one by one with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noreferrer noopener">Object.is</a> to see if the effect needs to re-run. So if we are not careful about memoizing the effect&#39;s dependencies, it might run on every render.</p><hr/><p>Now, if we think for a bit, we might notice that the two scenarios are actually exactly the same. They try to avoid something from happening by keeping <span>the same reference</span> around through caching. So the common reason to apply <code>useCallback</code> or <code>useMemo</code> is just:</p><p><span><p>I need referential stability.</p></span></p><p>I think we could all use some stability in our lives, so what&#39;s the cases where striving for stability is, as I said initially, pointless?</p><h2 id="1-no-memo---no-perf-gains">1. No memo - no perf gains<a href="#1-no-memo---no-perf-gains" aria-label="1 no memo   no perf gains permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>Let&#39;s take the example from above and change a tiny thing:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>function</span><span> </span><span>Okay</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> value </span><span>=</span><span> </span><span>useMemo</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>(</span><span>{</span><span> hello</span><span>:</span><span> </span><span>&#39;world&#39;</span><span> </span><span>}</span><span>)</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>3</span><span>  </span><span>const</span><span> onChange </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span>(</span><span>result</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>result</span><span>)</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>4</span><span>
</span></p><p><span>5</span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>Component</span><span> </span><span>value</span><span>=</span><span>{</span><span>value</span><span>}</span><span> </span><span>onChange</span><span>=</span><span>{</span><span>onChange</span><span>}</span><span> </span><span>/&gt;</span><span></span></p><p><span>6</span><span></span><span>}</span></p></code></pre></div><p>Can you spot the difference? Exactly - we are not passing <code>value</code> and <code>onChange</code> to a memoized component anymore - it&#39;s just a regular functional react component now. I see this happening a lot when values get, at the end, passed to React built-in components:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>function</span><span> </span><span>MyButton</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> onClick </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span></span></p><p><span>3</span><span>    </span><span>(</span><span>event</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>event</span><span>.</span><span>currentTarget</span><span>.</span><span>value</span><span>)</span><span>,</span><span></span></p><p><span>4</span><span>    </span><span>[</span><span>]</span><span></span></p><p><span>5</span><span>  </span><span>)</span><span></span></p><p><span>6</span><span>
</span></p><p><span>7</span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>button</span><span> </span><span>onClick</span><span>=</span><span>{</span><span>onClick</span><span>}</span><span> </span><span>/&gt;</span><span></span></p><p><span>8</span><span></span><span>}</span></p></code></pre></div><p>Here, memoizing <code>onClick</code> achieves <em>nothing</em>, as <code>button</code> doesn&#39;t care if <code>onClick</code> is referentially stable or not.</p><p>So if your custom component is not memoized, it hopefully doesn&#39;t care about referential stability either!</p><p>Hold on - but what if that <code>Component</code> uses those props internally for a <code>useEffect</code>, or to create further memoized values that are then passed to a memoized component for its own children? I might break something if I remove those memoizations now!</p><p>That brings us right to the second point:</p><h2 id="2-using-props-as-dependencies">2. Using props as dependencies<a href="#2-using-props-as-dependencies" aria-label="2 using props as dependencies permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>Adding non-primitive <code>props</code> you get passed into your component to internal dependency arrays is rarely right, because this component has no control over the referential stability of those props. A common example is:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>function</span><span> </span><span>OhNo</span><span>(</span><span>{</span><span> onChange </span><span>}</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> handleChange </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span>(</span><span>e</span><span>:</span><span> </span><span>React</span><span>.</span><span>ChangeEvent</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>3</span><span>    </span><span>trackAnalytics</span><span>(</span><span>&#39;changeEvent&#39;</span><span>,</span><span> e</span><span>)</span><span></span></p><p><span>4</span><span>    onChange</span><span>?.</span><span>(</span><span>e</span><span>)</span><span></span></p><p><span>5</span><span>  </span><span>}</span><span>,</span><span> </span><span>[</span><span>onChange</span><span>]</span><span>)</span><span></span></p><p><span>6</span><span>
</span></p><p><span>7</span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>SomeMemoizedComponent</span><span> </span><span>onChange</span><span>=</span><span>{</span><span>handleChange</span><span>}</span><span> </span><span>/&gt;</span><span></span></p><p><span>8</span><span></span><span>}</span></p></code></pre></div><p>This <code>useCallback</code> is likely useless, or at best, it depends on how consumers will use this component. In all likeliness, there is a call-side that just invokes an inline function:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>&lt;</span><span>OhNo</span><span> </span><span>onChange</span><span>=</span><span>{</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> props</span><span>.</span><span>doSomething</span><span>(</span><span>)</span><span>}</span><span> </span><span>/&gt;</span></p></code></pre></div><p>This is an innocent usage. There is nothing wrong with it. In fact, it&#39;s great. It co-locates what it wants to do with the event handler. It avoids extracting things to the top of the file with the gnarly <code>handleChange</code> naming.</p><p>The only way a developer who writes this code could know that it breaks some memoization is if they drill down into the component to see how the props are being used. That&#39;s horrible.</p><p>Other ways to fix this include a &#34;we memoize everything all the time&#34; policy, or to have strictly enforced naming convention like a &#34;mustBeMemoized&#34; prefix for props that need to be referentially stable. Both of these aren&#39;t great.</p><h3 id="a-real-life-example">A Real Life Example<a href="#a-real-life-example" aria-label="a real life example permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>Since I&#39;m working on the <a href="https://github.com/getsentry/sentry" target="_blank" rel="noreferrer noopener">sentry codebase</a> now, which is open source üéâ, I have a lot of real life usages to link towards. One situation that I found is our <a href="https://github.com/getsentry/sentry/blob/94f19a20bd5680ddc86b3e139853c3d505182b43/static/app/utils/useHotkeys.tsx" target="_blank" rel="noreferrer noopener">useHotkeys</a> custom hook. The important bits look something like this:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>export</span><span> </span><span>function</span><span> </span><span>useHotkeys</span><span>(</span><span>hotkeys</span><span>:</span><span> </span><span>Hotkey</span><span>[</span><span>]</span><span>)</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> onKeyDown </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>...</span><span>,</span><span> </span><span>[</span><span>hotkeys</span><span>]</span><span>)</span><span></span></p><p><span>3</span><span>
</span></p><p><span>4</span><span>  </span><span>useEffect</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>5</span><span>    </span><span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>6</span><span>
</span></p><p><span>7</span><span>    </span><span>return</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>8</span><span>      </span><span>document</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>9</span><span>    </span><span>}</span><span></span></p><p><span>10</span><span>  </span><span>}</span><span>,</span><span> </span><span>[</span><span>onKeyDown</span><span>]</span><span>)</span><span></span></p><p><span>11</span><span></span><span>}</span></p></code></pre></div><p>This custom hook takes an Array of <code>hotkeys</code> as input, and then creates a memoized <code>onKeyDown</code> function, which is passed to an effect. The function is clearly memoized to prevent the effect from firing too often, but the <code>hotkeys</code> being an Array means consumers must memoize them manually.</p><p>I set out to find all usages of <code>useHotkeys</code>, and was positively surprised to see that <a href="https://github.com/getsentry/sentry/blob/a80e48ce659dea903e4d9594420cde019b33b757/static/app/views/issueDetails/streamline/hooks/useCopyIssueDetails.tsx#L161-L172" target="_blank" rel="noreferrer noopener">all but one</a> of them memoize the input. However, that&#39;s not the whole story, because if we look deeper, things still tend to fall apart. Let&#39;s take, for example, <a href="https://github.com/getsentry/sentry/blob/97130081986520a2035882249b5670189d859dda/static/app/components/events/eventTagsAndScreenshot/screenshot/modal.tsx#L86" target="_blank" rel="noreferrer noopener">this usage</a>:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>const</span><span> paginateHotkeys </span><span>=</span><span> </span><span>useMemo</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>return</span><span> </span><span>[</span><span></span></p><p><span>3</span><span>    </span><span>{</span><span> match</span><span>:</span><span> </span><span>&#39;right&#39;</span><span>,</span><span> </span><span>callback</span><span>:</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>paginateItems</span><span>(</span><span>1</span><span>)</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>4</span><span>    </span><span>{</span><span> match</span><span>:</span><span> </span><span>&#39;left&#39;</span><span>,</span><span> </span><span>callback</span><span>:</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>paginateItems</span><span>(</span><span>-</span><span>1</span><span>)</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>5</span><span>  </span><span>]</span><span></span></p><p><span>6</span><span></span><span>}</span><span>,</span><span> </span><span>[</span><span>paginateItems</span><span>]</span><span>)</span><span></span></p><p><span>7</span><span>
</span></p><p><span>8</span><span></span><span>useHotkeys</span><span>(</span><span>paginateHotkeys</span><span>)</span></p></code></pre></div><p><code>useHotKeys</code> passes <code>paginateHotkeys</code>, which is memoized, but it depends on <code>paginateItems</code>. Where does that come from? Well, it&#39;s another <code>useCallback</code> that <a href="https://github.com/getsentry/sentry/blob/97130081986520a2035882249b5670189d859dda/static/app/components/events/eventTagsAndScreenshot/screenshot/modal.tsx#L77" target="_blank" rel="noreferrer noopener">depends on</a> <code>screenshots</code> and <code>currentAttachmentIndex</code>. And where does <code>screenshots</code> come from?</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>const</span><span> screenshots </span><span>=</span><span> attachments</span><span>.</span><span>filter</span><span>(</span><span>(</span><span>{</span><span> name </span><span>}</span><span>)</span><span> </span><span>=&gt;</span><span></span></p><p><span>2</span><span>  name</span><span>.</span><span>includes</span><span>(</span><span>&#39;screenshot&#39;</span><span>)</span><span></span></p><p><span>3</span><span></span><span>)</span></p></code></pre></div><p>It&#39;s a non-memoized <code>attachments.filter</code> function, which will always create a new Array, which breaks all the downstream memoizations. With that, they all become useless. <code>paginateItems</code>, <code>paginateHotkeys</code>, <code>onKeyDown</code>. Three memoizations that are guaranteed to re-run every render as if we hadn&#39;t written them at all!</p><hr/><p>I hope this example shows why I&#39;m passionately against applying memoizations. In my experience, it breaks way too often. It&#39;s not worth it. And it adds so much overhead and complexity to all the code we have to read.</p><p>The fix here isn&#39;t to memoize <code>screenshots</code> too. That would just shift the responsibility to <code>attachments</code>, which is a prop to the component. At all the three call-sides, we would be at least two levels away from where the actual memoization is needed (<code>useHotkeys</code>). This becomes a nightmare to navigate, and eventually, no one will dare to remove a single memoization because we can&#39;t know what it&#39;s actually doing.</p><p>If anything, we have to outsource all of this to <a href="https://react.dev/learn/react-compiler" target="_blank" rel="noreferrer noopener">a compiler</a>, which is great once we have it working everywhere. But until then, we have to find patterns to work around the limitation of needing referential stability:</p><h3 id="the-latest-ref-pattern">The Latest Ref Pattern<a href="#the-latest-ref-pattern" aria-label="the latest ref pattern permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>I wrote about <a href="https://tkdodo.eu/blog/refs-events-and-escape-hatches#the-latest-ref">this pattern before</a>; what we do is we basically store the value we want to gain imperative access to inside our effect in a ref, and then update the value with another effect that purposefully runs on every render:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>export</span><span> </span><span>function</span><span> </span><span>useHotkeys</span><span>(</span><span>hotkeys</span><span>:</span><span> </span><span>Hotkey</span><span>[</span><span>]</span><span>)</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> hotkeysRef </span><span>=</span><span> </span><span>useRef</span><span>(</span><span>hotkeys</span><span>)</span><span></span></p><p><span>3</span><span>
</span></p><p><span>4</span><span>  </span><span>useEffect</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>5</span><span>    hotkeysRef</span><span>.</span><span>current </span><span>=</span><span> hotkeys</span></p><p><span>6</span><span>  </span><span>}</span><span>)</span><span></span></p><p><span>7</span><span>
</span></p><p><span>8</span><span>  </span><span>const</span><span> onKeyDown </span><span>=</span><span> </span><span>useCallback</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>...</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>9</span><span>
</span></p><p><span>10</span><span>  </span><span>useEffect</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>11</span><span>    </span><span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>12</span><span>
</span></p><p><span>13</span><span>    </span><span>return</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>14</span><span>      </span><span>document</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>15</span><span>    </span><span>}</span><span></span></p><p><span>16</span><span>  </span><span>}</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>17</span><span></span><span>}</span></p></code></pre></div><p>Then, we can use the <code>hotkeysRef</code> inside our effect without having to add it to the dependency array and without having to worry about <a href="https://tkdodo.eu/blog/hooks-dependencies-and-stale-closures">stale closures</a> that we could run into if we just ignored the linter.</p><p>React Query also uses this pattern for keeping track of the latest options being passed in, e.g. in the <a href="https://github.com/TanStack/query/blob/dfbda9de66230e67b7e1c2f07e24eb5859ea14cb/packages/react-query-persist-client/src/PersistQueryClientProvider.tsx#L29-L31" target="_blank" rel="noreferrer noopener">PersistQueryClientProvider</a> or in <a href="https://github.com/TanStack/query/blob/34eedd601c7b19ac6a9fb8ab9c1ec0b600c2b95f/packages/react-query/src/useMutationState.ts#L53-L55" target="_blank" rel="noreferrer noopener">useMutationState</a>, so I&#39;d say it&#39;s a tried an true pattern. Imagine if the library would need consumers to memoize their <code>options</code> manually...</p><h3 id="useeffectevent">UseEffectEvent<a href="#useeffectevent" aria-label="useeffectevent permalink"><svg aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill="currentcolor" fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>More good news: React has realized that oftentimes, we need imperative access to the latest value of something during a reactive effect without explicitly re-triggering it, so they are going to add this pattern for exactly this use-case as a first class primitive, <a href="https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event" target="_blank" rel="noreferrer noopener">useEffectEvent</a>.</p><p>Once that ships, we can refactor the code towards:</p><div data-language="tsx"><pre data-linenumber="true"><code><p><span>1</span><span>export</span><span> </span><span>function</span><span> </span><span>useHotkeys</span><span>(</span><span>hotkeys</span><span>:</span><span> </span><span>Hotkey</span><span>[</span><span>]</span><span>)</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>const</span><span> onKeyDown </span><span>=</span><span> </span><span>useEffectEvent</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>...</span><span>)</span><span></span></p><p><span>3</span><span>
</span></p><p><span>4</span><span>  </span><span>useEffect</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>5</span><span>    </span><span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>6</span><span>
</span></p><p><span>7</span><span>    </span><span>return</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>8</span><span>      </span><span>document</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> onKeyDown</span><span>)</span><span></span></p><p><span>9</span><span>    </span><span>}</span><span></span></p><p><span>10</span><span>  </span><span>}</span><span>,</span><span> </span><span>[</span><span>]</span><span>)</span><span></span></p><p><span>11</span><span></span><span>}</span></p></code></pre></div><p>This would make <code>onKeyDown</code> <em>not</em> reactive, it would get able to always &#34;see&#34; the latest values of <code>hotkeys</code>, and it would be referentially stable between renders. The best of all worlds, without having to write a single useless <code>useCallback</code> or <code>useMemo</code>.</p><hr/><p>That&#39;s it for today. Feel free to reach out to me on <a href="https://bsky.app/profile/tkdodo.eu" target="_blank" rel="noreferrer noopener">bluesky ü¶ã</a>
if you have any questions, or just leave a comment below. ‚¨áÔ∏è</p><div><div><div><p>Like the monospace font in the code blocks?</p></div></div><a href="https://bytes.dev/?r=dom" target="_blank" rel="noopener noreferrer"></a></div></section></div></div>
  </body>
</html>
