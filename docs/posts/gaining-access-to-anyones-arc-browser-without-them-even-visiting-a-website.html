<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kibty.town/blog/arc/">Original</a>
    <h1>Gaining access to anyones Arc browser without them even visiting a website</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>we start at the homepage of arc. where i first landed when i first heard of it. i snatched a download and started analysing, the first thing i realised was that arc requires an account to use, why do they require an account?</p>
<h2>introducing arcs cloud features</h2>
<p>so i boot up my mitmproxy instance and i sign up, and i see that they are using firebase for authentication, but no other requests, are they really just using firebase only for authentication?</p>
<p>after poking around for a bit, i discovered that there was a arc featured called easels, easels are a whiteboard like interface, and you can share them with people, and they can view them on the web. when i clicked the share button however, there was no requests in my mitmproxy instance, so whats happening here?</p>
<h2>hacking objective-c based firebase apps</h2>
<p>from previous experience hacking an IOS based app, i immediately had a hunch on what this was, firestore.</p>
<p>firestore is a database-as-a-backend service that allows for developers to not care about writing a backend, and instead write database security rules and make users directly access the database.</p>
<p>this has <a href="https://env.fail/posts/firewreck-1">of course sparked a lot of services having insecure or insufficient security rules</a> and since researching that, i would like to call myself a firestore expert.</p>
<p>firestore has a tendency to not abide by the system proxy settings in the Swift SDK for firebase, so going off my hunch, i wrote a frida script to dump the relevant calls.</p>
<pre><code><span>var</span> documentWithPath =
  <span>ObjC</span>.<span>classes</span>.<span>FIRCollectionReference</span>[<span>&#34;- documentWithPath:&#34;</span>];
<span>var</span> queryWhereFieldIsEqualTo =
  <span>ObjC</span>.<span>classes</span>.<span>FIRQuery</span>[<span>&#34;- queryWhereField:isEqualTo:&#34;</span>];
<span>var</span> collectionWithPath = <span>ObjC</span>.<span>classes</span>.<span>FIRFirestore</span>[<span>&#34;- collectionWithPath:&#34;</span>];

<span>function</span> <span>getFullPath</span>(<span>obj</span>) {
  <span>if</span> (obj.<span>path</span> &amp;&amp; <span>typeof</span> obj.<span>path</span> === <span>&#34;function&#34;</span>) {
    <span>return</span> obj.<span>path</span>().<span>toString</span>();
  }
  <span>return</span> obj.<span>toString</span>();
}

<span>var</span> queryStack = [];

<span>function</span> <span>logQuery</span>(<span>query</span>) {
  <span>var</span> queryString = <span>`firebase.<span>${query.type}</span>(&#34;<span>${query.path}</span>&#34;)`</span>;
  query.<span>whereClauses</span>.<span>forEach</span>(<span>(<span>clause</span>) =&gt;</span> {
    queryString += <span>`.where(&#34;<span>${clause.fieldName}</span>&#34;, &#34;==&#34;, &#34;<span>${clause.value}</span>&#34;)`</span>;
  });
  <span>console</span>.<span>log</span>(queryString);
}

<span>Interceptor</span>.<span>attach</span>(documentWithPath.<span>implementation</span>, {
  <span>onEnter</span>: <span>function</span> (<span>args</span>) {
    <span>var</span> parent = <span>ObjC</span>.<span>Object</span>(args[<span>0</span>]);
    <span>var</span> docPath = <span>ObjC</span>.<span>Object</span>(args[<span>2</span>]).<span>toString</span>();
    <span>var</span> fullPath = <span>getFullPath</span>(parent) + <span>&#34;/&#34;</span> + docPath;
    <span>var</span> query = { <span>type</span>: <span>&#34;doc&#34;</span>, <span>path</span>: fullPath, <span>whereClauses</span>: [] };
    queryStack.<span>push</span>(query);
    <span>logQuery</span>(query);
  },
});

<span>Interceptor</span>.<span>attach</span>(collectionWithPath.<span>implementation</span>, {
  <span>onEnter</span>: <span>function</span> (<span>args</span>) {
    <span>var</span> collectionPath = <span>ObjC</span>.<span>Object</span>(args[<span>2</span>]).<span>toString</span>();
    <span>var</span> query = { <span>type</span>: <span>&#34;collection&#34;</span>, <span>path</span>: collectionPath, <span>whereClauses</span>: [] };
    queryStack.<span>push</span>(query);
  },
});

<span>Interceptor</span>.<span>attach</span>(queryWhereFieldIsEqualTo.<span>implementation</span>, {
  <span>onEnter</span>: <span>function</span> (<span>args</span>) {
    <span>var</span> fieldName = <span>ObjC</span>.<span>Object</span>(args[<span>2</span>]).<span>toString</span>();
    <span>var</span> value = <span>ObjC</span>.<span>Object</span>(args[<span>3</span>]).<span>toString</span>();

    <span>if</span> (queryStack.<span>length</span> &gt; <span>0</span>) {
      <span>var</span> currentQuery = queryStack[queryStack.<span>length</span> - <span>1</span>];
      currentQuery.<span>whereClauses</span>.<span>push</span>({ <span>fieldName</span>: fieldName, <span>value</span>: value });
    }
  },
  <span>onLeave</span>: <span>function</span> (<span>retval</span>) {},
});

<span>var</span> executionMethods = [
  <span>&#34;- getDocuments&#34;</span>,
  <span>&#34;- addSnapshotListener:&#34;</span>,
  <span>&#34;- getDocument&#34;</span>,
  <span>&#34;- addDocumentSnapshotListener:&#34;</span>,
  <span>&#34;- getDocumentsWithCompletion:&#34;</span>,
  <span>&#34;- getDocumentWithCompletion:&#34;</span>,
];

executionMethods.<span>forEach</span>(<span>function</span> (<span>methodName</span>) {
  <span>if</span> (<span>ObjC</span>.<span>classes</span>.<span>FIRQuery</span>[methodName]) {
    <span>Interceptor</span>.<span>attach</span>(<span>ObjC</span>.<span>classes</span>.<span>FIRQuery</span>[methodName].<span>implementation</span>, {
      <span>onEnter</span>: <span>function</span> (<span>args</span>) {
        <span>if</span> (queryStack.<span>length</span> &gt; <span>0</span>) {
          <span>var</span> query = queryStack.<span>pop</span>();
          <span>logQuery</span>(query);
        }
      },
    });
  }
});

<span>function</span> <span>formatFirestoreData</span>(<span>data</span>) {
  <span>if</span> (data.<span>isKindOfClass_</span>(<span>ObjC</span>.<span>classes</span>.<span>NSDictionary</span>)) {
    <span>let</span> result = {};
    data.<span>enumerateKeysAndObjectsUsingBlock_</span>(
      <span>ObjC</span>.<span>implement</span>(<span>function</span> (<span>key, value</span>) {
        result[key.<span>toString</span>()] = value.<span>toString</span>();
      })
    );
    <span>return</span> <span>JSON</span>.<span>stringify</span>(result);
  }
  <span>return</span> data.<span>toString</span>();
}

<span>var</span> documentMethods = [
  { <span>name</span>: <span>&#34;- updateData:completion:&#34;</span>, <span>type</span>: <span>&#34;update&#34;</span> },
  { <span>name</span>: <span>&#34;- updateData:&#34;</span>, <span>type</span>: <span>&#34;update&#34;</span> },
  { <span>name</span>: <span>&#34;- setData:completion:&#34;</span>, <span>type</span>: <span>&#34;set&#34;</span> },
  { <span>name</span>: <span>&#34;- setData:&#34;</span>, <span>type</span>: <span>&#34;set&#34;</span> },
];

documentMethods.<span>forEach</span>(<span>function</span> (<span>method</span>) {
  <span>if</span> (<span>ObjC</span>.<span>classes</span>.<span>FIRDocumentReference</span>[method.<span>name</span>]) {
    <span>Interceptor</span>.<span>attach</span>(
      <span>ObjC</span>.<span>classes</span>.<span>FIRDocumentReference</span>[method.<span>name</span>].<span>implementation</span>,
      {
        <span>onEnter</span>: <span>function</span> (<span>args</span>) {
          <span>var</span> docRef = <span>ObjC</span>.<span>Object</span>(args[<span>0</span>]);
          <span>var</span> data = <span>ObjC</span>.<span>Object</span>(args[<span>2</span>]);
          <span>var</span> fullPath = <span>getFullPath</span>(docRef);
          <span>var</span> formattedData = <span>formatFirestoreData</span>(data);
          <span>console</span>.<span>log</span>(
            <span>`firebase.doc(&#34;<span>${fullPath}</span>&#34;).<span>${method.type}</span>(<span>${formattedData}</span>)`</span>
          );
        },
      }
    );
  } <span>else</span> {
    <span>console</span>.<span>log</span>(<span>&#34;Warning: &#34;</span> + method.<span>name</span> + <span>&#34; not found&#34;</span>);
  }
});
</code></pre>
<p>hacky script, but it works. so i launched arc with the script loaded on startup and this is what i got:</p>
<pre><code>firebase.<span>doc</span>(<span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
firebase.<span>doc</span>(
  <span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12/stringValues/autoArchiveTimeThreshold&#34;</span>
);
firebase.<span>doc</span>(<span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
firebase.<span>doc</span>(
  <span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12/stringValues/autoArchiveLittleArcTimeThreshold&#34;</span>
);
firebase.<span>doc</span>(<span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
firebase.<span>doc</span>(
  <span>&#34;preferences/UvMIUnuxJ2h0E47fmZPpHLisHn12/stringValues/autoArchiveTimeThresholdsPerProfile&#34;</span>
);
firebase.<span>doc</span>(<span>&#34;users/UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
firebase
  .<span>collection</span>(<span>&#34;user_referrals&#34;</span>)
  .<span>where</span>(<span>&#34;inviter_id&#34;</span>, <span>&#34;==&#34;</span>, <span>&#34;UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
firebase
  .<span>collection</span>(<span>&#34;boosts&#34;</span>)
  .<span>where</span>(<span>&#34;creatorID&#34;</span>, <span>&#34;==&#34;</span>, <span>&#34;UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>);
</code></pre>
<p>sick. so it looks like arc stores some preferences in firestore, along with a basic user object, referrals and boosts</p>
<h2>what the hell are arc boosts</h2>
<p>arc boosts are a way for users to customize websites, by blocking elements, changing fonts, colors, and even using their own custom css and js.</p>
<p><strong>do you see where this is going?</strong>, so, i manually logged into my account using my dummy page to test firebase accounts, and executed the exact same query to get my boosts:</p>
<p><img src="https://kibty.town/files/img/posts/arc/firebase-query-1.png" alt=""/></p>
<p>cool, let me create a simple boost on google.com</p>
<p><img src="https://kibty.town/files/img/posts/arc/firebase-query-2.png" alt=""/></p>
<p>hey! theres our boost, lets try changing some parameters around.</p>
<p>i see that it queries by <code>creatorID</code>, and we cant <em>query</em> a different creator ID than the original, but what if we update our own boost to have another users id?</p>
<p>well, i tried it with another account of mine, and this way the result when i went to google.com on the other computer (the victim one)</p>
<p><img src="https://kibty.town/files/img/posts/arc/alert-popup.png" alt=""/></p>
<p><strong>what the fuck? it works?</strong></p>
<h3>quick recap</h3>
<ul>
<li>arc boosts can contain arbitrary javascript</li>
<li>arc boosts are stored in firestore</li>
<li>the arc browser gets which boosts to use via the <code>creatorID</code> field</li>
<li><strong>we can arbitrarily chage the <code>creatorID</code> field to any user id</strong></li>
</ul>
<p>thus, if we were to find a way to easily get someone elses user id, we would have a full attack chain</p>
<h2>getting another users id</h2>
<h3>user referrals</h3>
<p>when someone referrs you to arc, or you referr someone to arc, you automatically get their user id in the <code>user_referrals</code> table, which means you could just ask someone for their arc invite code and they&#39;d likely give it</p>
<h3>published boosts</h3>
<p>you can share arc boosts (only if they don&#39;t have js in them) with other people, and arc has a <a href="https://arc.net/boosts">public site</a> with boosts, and boostSnapshots (published boosts) contain the user id of the creator.</p>
<h3>user easels</h3>
<p>arc has a feature called easels, which are basically whiteboards, you can share easels, and this also allows you to get someones user id.</p>
<h2>putting it together</h2>
<p>this would be the final attack chain:</p>
<ul>
<li>obtain the user id of the victim via one of the mentioned methods</li>
<li>create a malicious boost with whatever payload you want on your own account</li>
<li>update the boost <code>creatorID</code> field to the targets</li>
<li>whenever the victim visits the targeted website, they will get compromised</li>
</ul>
<p>the browser company normally <s>does not do bug bounties</s> (update: see at the end of post), but for this catastrophic of a vuln, they decided to award me with <strong>$2,000</strong> USD</p>
<p>the timeline for the vulnerability:</p>
<ul>
<li><strong>aug 25 5:48pm</strong>: got initial contact over signal (encrypted) with arc co-founder hursh</li>
<li><strong>aug 25 6:02pm</strong>: vulnerability poc executed on hursh&#39;s arc account</li>
<li><strong>aug 25 6:13pm</strong>: added to slack channel after details disclosed over encrypted format</li>
<li><strong>aug 26 9:41pm</strong>: vulnerability patched, bounty awarded</li>
<li><strong>sep 6 7:49pm</strong>: cve assigned (CVE-2024-45489)</li>
</ul>
<h2>rce on priviliged pages</h2>
<p>while poking around, i saw that boosts actually execute for other protocols aswell (even though you cant create them in the client), so someone could create a boost targeting the page <code>settings</code>, and it would execute on <code>chrome://settings</code>, which allows further escalation of priviliges.</p>
<h2>privacy concerns</h2>
<p>while researching, i saw some data being sent over to the server, like this query everytime you visit a site:</p>
<pre><code>firebase
  .<span>collection</span>(<span>&#34;boosts&#34;</span>)
  .<span>where</span>(<span>&#34;creatorID&#34;</span>, <span>&#34;==&#34;</span>, <span>&#34;UvMIUnuxJ2h0E47fmZPpHLisHn12&#34;</span>)
  .<span>where</span>(<span>&#34;hostPattern&#34;</span>, <span>&#34;==&#34;</span>, <span>&#34;www.google.com&#34;</span>);
</code></pre>
<p>the <code>hostPattern</code> being the site you visit, this is against <a href="https://arc.net/privacy">arc&#39;s privacy policy</a> which clearly states arc does not know which sites you visit.</p>
<h2>update</h2>
<p>in light of these vulnerabilities and to introduce new features arc is switching off of firebase. additionally, <a href="https://arc.net/blog/CVE-2024-45489-incident-response">arc has published their own write-up</a> addressing these issues</p>
<p>a tldr version would be:</p>
<ul>
<li>confirming they had fixed the issue</li>
<li>they are adding a feature to disable boosts in the client, preventing this vulnerability from happening on people that do not use boosts</li>
<li>they are doing an audit of their current firebase ACL rules internally</li>
<li>they have estabilished proper protocols for security issues</li>
</ul>
<p>additionally, from internal discussions with arc they are also:</p>
<ul>
<li>are fixing the mentioned privacy concerns in the v1.61.1 update</li>
<li>moving off firebase for new features and products</li>
<li>they are doing a external security audit for this version</li>
<li>are starting a bug bounty program for further vulnerabilities</li>
</ul>
</div></article></div>
  </body>
</html>
