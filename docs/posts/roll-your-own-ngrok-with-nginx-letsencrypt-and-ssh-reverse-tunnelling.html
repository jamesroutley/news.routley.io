<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jerrington.me/posts/2019-01-29-self-hosted-ngrok.html">Original</a>
    <h1>Roll your own Ngrok with Nginx, Letsencrypt, and SSH reverse tunnelling</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on January 29, 2019
    
</p>

<p>Ngrok is a fantastic tool for creating a secure tunnel from the public web to a machine behind NAT or a firewall. Sadly, it costs money and it’s proprietary. If you’re a developer, odds are that you’re already renting a server in the public cloud, so why not roll your own ngrok?</p>
<p>It turns out that you can do it using free, off-the-shelf tools, with no sophisticated scripting required! In this article, I’ll show you how.</p>
<h2 id="step-1.-configuring-nginx">Step 1. Configuring Nginx</h2>
<p>Use a server block like this, so that incoming HTTP connections to <code>tunnel.yourdomain</code> are reverse proxied into the application listening on port <code>3333</code>.</p>
<pre><code>server {
    server_name tunnel.yourdomain;

    access_log /var/log/nginx/$host;

    location / {
	    proxy_pass http://localhost:3333/;
	    proxy_set_header X-Real-IP $remote_addr;
	    proxy_set_header Host $host;
	    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
	    proxy_redirect off;
    }

    error_page 502 /50x.html;
    location = /50x.html {
	    root /usr/share/nginx/html;
    }
}</code></pre>
<p>With this configuration in place, suppose I visited <code>tunnel.yourdomain</code>. Nginx will receive the connection, and see that it should reverse proxy it. It will effectively pass the connection on to whatever application is listening on port <code>3333</code>. Currently, there is nothing listening on this port, so we will get a <code>502 Bad Gateway</code> or <code>404 Not Found</code> error from Nginx.</p>
<p>Let’s fix that.</p>
<h2 id="step-2.-using-an-ssh-reverse-tunnel">Step 2. Using an SSH reverse tunnel</h2>
<p>SSH reverse tunnelling port <code>N</code> to port <code>K</code> means making sshd listen on port <code>N</code> and effectively transfer incoming connections over the SSH connection to the SSH client. The SSH client will then transfer the connection to the application listening on port <code>K</code> on the client machine.</p>
<p>Here’s the command to run on your client machine: <code>ssh -R N:localhost:K yourdomain</code></p>
<p>An interactive session on your server should begin; while it is open, the reverse tunnel from port <code>N</code> to port <code>K</code> is active, and sshd will allow connections originating only from <code>localhost</code>, i.e. your server.</p>
<p>Choosing <code>N</code> = <code>3333</code> will make it so Nginx reverse proxies incoming connections on <code>tunnel.yourdomain</code> into sshd, over the SSH connection, and into the application running on your local machine on port <code>K</code>.</p>
<p>To test this out, on your local machine, in one shell run <code>python -m http.server 8888</code> and in another shell run <code>ssh -R 3333:localhost:8888 yourdomain</code>. Visit <code>tunnel.yourdomain</code>. You should see a directory listing for whatever directory you were in when you ran the Python command!</p>
<p>However, there’s a glaring problem with this setup.</p>
<h2 id="step-3.-securing-the-connection-in-the-browser">Step 3. Securing the connection in the browser</h2>
<p>The connection the browser is making to Nginx is at the moment not secure: it was a plain HTTP connection. You can fix this by obtaining a free TLS certificate with Letsencrypt, and using it to secure the connection the browser is making.</p>
<p>There are already excellent tutorials available on setting up Letsencrypt, so I won’t repeat that here. I recommend consulting the ArchWiki article <a href="https://wiki.archlinux.org/index.php/Certbot">here</a>. Letsencrypt is a self-hosters dream-come-true since it is truly a set-it-and-forget-it type of thing. With the appropriate setup, (namely a simple systemd timer,) the certificate you get will renew itself when it its expiry is approaching.</p>
<p>Once you have a certificate, it suffices to adjust the Nginx server block above so it looks like this.</p>
<pre><code>server {
    server_name tunnel.yourdomain;

    access_log /var/log/nginx/$host;
    
    # These three lines are new.
    listen 443 ssl;
    ssl_certificate /path/to/tls/cert/fullchain.pem;
    ssl_certificate_key /path/to/tls/cert/privkey.pem;

    location / {
	    proxy_pass http://localhost:3333/;
	    proxy_set_header X-Real-IP $remote_addr;
	    proxy_set_header Host $host;
	    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
	    proxy_redirect off;
    }

    error_page 502 /50x.html;
    location = /50x.html {
	    root /usr/share/nginx/html;
    }
}</code></pre>
<p>Only <em>three lines</em> need to be added!</p>
<h3 id="conclusion">Conclusion</h3>
<p>With very little setup, we saw how to configure Nginx to act as a reverse proxy, and how to use an SSH reverse tunnel. By combining these off-the-shelf tools, we essentially replicated the core functionality of the fantastic tool Ngrok. Using this double-reverse-proxy technique, web applications running on a machine behind NAT or a firewall can be accessed easily and securely from a public domain or IP address.</p>
<p>If you have any comments or concerns, <a href="https://github.com/tsani/jerrington.me/issues">open an issue</a> on Github.</p>

        </div></div>
  </body>
</html>
