<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ziglang.org/devlog/2026/#2026-02-13">Original</a>
    <h1>Zig ‚Äì io_uring and Grand Central Dispatch std.Io implementations landed</h1>
    
    <div id="readability-page-1" class="page"><p>This page contains a curated list of recent changes to main branch Zig.</p><p>
      This page contains entries for the year <span>2026</span>. Other years are available in
      <a href="https://ziglang.org/devlog/">the Devlog archive page</a>.
    </p><div>
      <div id="2026-02-13">
        <p><span>February 13, 2026</span></p>
        <p>Author: Andrew Kelley</p><p>As we approach the end of the 0.16.0 release cycle, Jacob has been hard at work, bringing <code>std.Io.Evented</code> up to speed with all the latest API changes:</p><ul><li><a href="https://codeberg.org/ziglang/zig/pulls/31158" target="_blank">io_uring implementation</a></li><li><a href="https://codeberg.org/ziglang/zig/pulls/31198" target="_blank">Grand Central Dispatch implementation</a></li></ul><p>Both of these are based on userspace stack switching, sometimes called ‚Äúfibers‚Äù, ‚Äústackful coroutines‚Äù, or ‚Äúgreen threads‚Äù.</p><p>They are now <strong>available to tinker with</strong>, by constructing one‚Äôs application using <code>std.Io.Evented</code>. They should be considered <strong>experimental</strong> because there is important followup work to be done before they can be used reliably and robustly:</p><ul><li><a href="https://codeberg.org/ziglang/zig/issues/31199" target="_blank">better error handling</a></li><li>remove the logging</li><li>diagnose the unexpected performance degradation when using <code>IoMode.evented</code> for the compiler</li><li><a href="https://codeberg.org/ziglang/zig/issues/31200" target="_blank">a couple functions still unimplemented</a></li><li>more test coverage is needed</li><li><a href="https://github.com/ziglang/zig/issues/157" target="_blank">builtin function to tell you the maximum stack size of a given function</a> to make these implementations practical to use when overcommit is off.</li></ul><p>With those caveats in mind, it seems we are indeed reaching the Promised Land, where Zig code can have Io implementations effortlessly swapped out:</p><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>init</span><span>:</span> <span>std</span><span>.</span><span>process</span><span>.</span><span>Init</span><span>.</span><span>Minimal</span><span>)</span> <span>!</span><span>void</span> <span>{</span>
    <span>var</span> <span>debug_allocator</span><span>:</span> <span>std</span><span>.</span><span>heap</span><span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> <span>=</span> <span>.</span><span>init</span><span>;</span>
    <span>const</span> <span>gpa</span> <span>=</span> <span>debug_allocator</span><span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> <span>threaded</span><span>:</span> <span>std</span><span>.</span><span>Io</span><span>.</span><span>Threaded</span> <span>=</span> <span>.</span><span>init</span><span>(</span><span>gpa</span><span>,</span> <span>.</span><span>{</span>
        <span>.</span><span>argv0</span> <span>=</span> <span>.</span><span>init</span><span>(</span><span>init</span><span>.</span><span>args</span><span>)</span><span>,</span>
        <span>.</span><span>environ</span> <span>=</span> <span>init</span><span>.</span><span>environ</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
    <span>defer</span> <span>threaded</span><span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> <span>io</span> <span>=</span> <span>threaded</span><span>.</span><span>io</span><span>(</span><span>)</span><span>;</span>

    <span>return</span> <span>app</span><span>(</span><span>io</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>app</span><span>(</span><span>io</span><span>:</span> <span>std</span><span>.</span><span>Io</span><span>)</span> <span>!</span><span>void</span> <span>{</span>
    <span>try</span> <span>std</span><span>.</span><span>Io</span><span>.</span><span>File</span><span>.</span><span>stdout</span><span>(</span><span>)</span><span>.</span><span>writeStreamingAll</span><span>(</span><span>io</span><span>,</span> <span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<pre><code>$ strace ./hello_threaded
execve(&#34;./hello_threaded&#34;, [&#34;./hello_threaded&#34;], 0x7ffc1da88b20 /* 98 vars */) = 0
mmap(NULL, 262207, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f583f338000
arch_prctl(ARCH_SET_FS, 0x7f583f378018) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
prlimit64(0, RLIMIT_STACK, {rlim_cur=16384*1024, rlim_max=RLIM64_INFINITY}, NULL) = 0
sigaltstack({ss_sp=0x7f583f338000, ss_flags=0, ss_size=262144}, NULL) = 0
sched_getaffinity(0, 128, [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31]) = 8
rt_sigaction(SIGIO, {sa_handler=0x1019d90, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x10328c0}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGPIPE, {sa_handler=0x1019d90, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x10328c0}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
writev(1, [{iov_base=&#34;Hello, World!\n&#34;, iov_len=14}], 1Hello, World!
) = 14
rt_sigaction(SIGIO, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x10328c0}, NULL, 8) = 0
rt_sigaction(SIGPIPE, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x10328c0}, NULL, 8) = 0
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre><p>Swapping out only the I/O implementation:</p><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>init</span><span>:</span> <span>std</span><span>.</span><span>process</span><span>.</span><span>Init</span><span>.</span><span>Minimal</span><span>)</span> <span>!</span><span>void</span> <span>{</span>
    <span>var</span> <span>debug_allocator</span><span>:</span> <span>std</span><span>.</span><span>heap</span><span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> <span>=</span> <span>.</span><span>init</span><span>;</span>
    <span>const</span> <span>gpa</span> <span>=</span> <span>debug_allocator</span><span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> <span>evented</span><span>:</span> <span>std</span><span>.</span><span>Io</span><span>.</span><span>Evented</span> <span>=</span> <span>undefined</span><span>;</span>
    <span>try</span> <span>evented</span><span>.</span><span>init</span><span>(</span><span>gpa</span><span>,</span> <span>.</span><span>{</span>
        <span>.</span><span>argv0</span> <span>=</span> <span>.</span><span>init</span><span>(</span><span>init</span><span>.</span><span>args</span><span>)</span><span>,</span>
        <span>.</span><span>environ</span> <span>=</span> <span>init</span><span>.</span><span>environ</span><span>,</span>
        <span>.</span><span>backing_allocator_needs_mutex</span> <span>=</span> <span>false</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
    <span>defer</span> <span>evented</span><span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> <span>io</span> <span>=</span> <span>evented</span><span>.</span><span>io</span><span>(</span><span>)</span><span>;</span>

    <span>return</span> <span>app</span><span>(</span><span>io</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>app</span><span>(</span><span>io</span><span>:</span> <span>std</span><span>.</span><span>Io</span><span>)</span> <span>!</span><span>void</span> <span>{</span>
    <span>try</span> <span>std</span><span>.</span><span>Io</span><span>.</span><span>File</span><span>.</span><span>stdout</span><span>(</span><span>)</span><span>.</span><span>writeStreamingAll</span><span>(</span><span>io</span><span>,</span> <span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<pre><code>execve(&#34;./hello_evented&#34;, [&#34;./hello_evented&#34;], 0x7fff368894f0 /* 98 vars */) = 0
mmap(NULL, 262215, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f70a4c28000
arch_prctl(ARCH_SET_FS, 0x7f70a4c68020) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
prlimit64(0, RLIMIT_STACK, {rlim_cur=16384*1024, rlim_max=RLIM64_INFINITY}, NULL) = 0
sigaltstack({ss_sp=0x7f70a4c28008, ss_flags=0, ss_size=262144}, NULL) = 0
sched_getaffinity(0, 128, [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31]) = 8
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f70a4c27000
mmap(0x7f70a4c28000, 548864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f70a4ba1000
io_uring_setup(64, {flags=IORING_SETUP_COOP_TASKRUN|IORING_SETUP_SINGLE_ISSUER, sq_thread_cpu=0, sq_thread_idle=1000, sq_entries=64, cq_entries=128, features=IORING_FEAT_SINGLE_MMAP|IORING_FEAT_NODROP|IORING_FEAT_SUBMIT_STABLE|IORING_FEAT_RW_CUR_POS|IORING_FEAT_CUR_PERSONALITY|IORING_FEAT_FAST_POLL|IORING_FEAT_POLL_32BITS|IORING_FEAT_SQPOLL_NONFIXED|IORING_FEAT_EXT_ARG|IORING_FEAT_NATIVE_WORKERS|IORING_FEAT_RSRC_TAGS|IORING_FEAT_CQE_SKIP|IORING_FEAT_LINKED_FILE|IORING_FEAT_REG_REG_RING|IORING_FEAT_RECVSEND_BUNDLE|IORING_FEAT_MIN_TIMEOUT|IORING_FEAT_RW_ATTR|IORING_FEAT_NO_IOWAIT, sq_off={head=0, tail=4, ring_mask=16, ring_entries=24, flags=36, dropped=32, array=2112, user_addr=0}, cq_off={head=8, tail=12, ring_mask=20, ring_entries=28, overflow=44, cqes=64, flags=40, user_addr=0}}) = 3
mmap(NULL, 2368, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_POPULATE, 3, 0) = 0x7f70a4ba0000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_POPULATE, 3, 0x10000000) = 0x7f70a4b9f000
io_uring_enter(3, 1, 1, IORING_ENTER_GETEVENTS, NULL, 8Hello, World!
) = 1
io_uring_enter(3, 1, 1, IORING_ENTER_GETEVENTS, NULL, 8) = 1
munmap(0x7f70a4b9f000, 4096)            = 0
munmap(0x7f70a4ba0000, 2368)            = 0
close(3)                                = 0
munmap(0x7f70a4ba1000, 548864)          = 0
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre><p>Key point here being that the <code>app</code> function is identical between those two snippets.</p><p>Moving beyond Hello World, the Zig compiler itself works fine using <code>std.Io.Evented</code>, both with io_uring and with GCD, but as mentioned above, there is a not-yet-diagnosed performance degradation when doing so.</p><p>Happy hacking,</p><p>Andrew</p>
      </div>
    
      <div id="2026-02-06">
        <p><span>February 06, 2026</span></p>
        <p>Author: Andrew Kelley</p><p>If you have a Zig project with dependencies, two big changes just landed which I think you will be interested to learn about.</p><p>Fetched packages are now stored <em>locally</em> in the <code>zig-pkg</code> directory of the project root (next to your <code>build.zig</code> file).</p><p>For example here are a few results from <a href="https://codeberg.org/awebo-chat/awebo" target="_blank">awebo</a> after running <code>zig build</code>:</p><pre><code>$ du -sh zig-pkg/*
13M    freetype-2.14.1-alzUkTyBqgBwke4Jsot997WYSpl207Ij9oO-2QOvGrOi
20K    opus-0.0.2-vuF-cMAkAADVsm707MYCtPmqmRs0gzg84Sz0qGbb5E3w
4.3M   pulseaudio-16.1.1-9-mk_62MZkNwBaFwiZ7ZVrYRIf_3dTqqJR5PbMRCJzSuLw
5.2M   uucode-0.1.0-ZZjBPvtWUACf5dqD_f9I37VGFsN24436CuceC5pTJ25n
728K   vaxis-0.5.1-BWNV_AxECQCj3p4Hcv4U3Yo1WMUJ7Z2FUj0UkpuJGxQQ
</code></pre><p>It is highly recommended to add this directory to the project-local source control ignore file (e.g. <code>.gitignore</code>). However, by being outside of <code>.zig-cache</code>, it provides the possibility of distributing self-contained source tarballs, which contain all dependencies and therefore can be used to build offline, or for archival purposes.</p><p>Meanwhile, an <em>additional</em> copy of the dependency is cached globally. After filtering out all the unused files based on the <code>paths</code> filter, the contents are recompressed:</p><pre><code>$ du -sh ~/.cache/zig/p/*
2.4M    freetype-2.14.1-alzUkTyBqgBwke4Jsot997WYSpl207Ij9oO-2QOvGrOi.tar.gz
4.0K    opus-0.0.2-vuF-cMAkAADVsm707MYCtPmqmRs0gzg84Sz0qGbb5E3w.tar.gz
636K    pulseaudio-16.1.1-9-mk_62MZkNwBaFwiZ7ZVrYRIf_3dTqqJR5PbMRCJzSuLw.tar.gz
880K    uucode-0.1.0-ZZjBPvtWUACf5dqD_f9I37VGFsN24436CuceC5pTJ25n.tar.gz
120K    vaxis-0.5.1-BWNV_BFECQBbXeTeFd48uTJRjD5a-KD6kPuKanzzVB01.tar.gz
</code></pre><p>The motivation for this change is to make it easier to tinker. Go ahead and edit those files, see what happens. Swap out your package directory with a git clone. Grep your dependencies all together. Configure your IDE to auto-complete based on the <code>zig-pkg</code> directory. <a href="https://codeberg.org/awebo-chat/awebo/issues/61" target="_blank">Run baobab on your dependency tree</a>. Furthermore, by having the global cache have compressed files instead makes it easier to share that cached data between computers. In the future, <a href="https://github.com/ziglang/zig/issues/23236" target="_blank">it is planned to support peer-to-peer torrenting of dependency trees</a>. By recompressing packages into a canonical form, this will allow peers to share Zig packages with minimal bandwidth. I love this idea because it simultaneously provides resilience to network outages, as well as a popularity contest. Find out which open source packages are popular based on number of seeders!</p><p>The second change here is the addition of the <code>--fork</code> flag to <code>zig build</code>.</p><p>In retrospect, it seems so obvious, I don‚Äôt know why I didn‚Äôt think of it since the beginning. It looks like this:</p><pre><code>zig build --fork=[path]
</code></pre><p>This is a <strong>project override</strong> option. Given a path to a source checkout of a project, all packages matching that project across the entire dependency tree will be overridden.</p><p>Thanks to the fact that package content hashes include name and fingerprint, <strong>this resolves before the package is potentially fetched</strong>.</p><p>This is an easy way to temporarily use one or more forks which are in entirely separate directories. You can iterate on your entire dependency tree until everything is working, while using comfortably the development environment and source control of the dependency projects.</p><p>The fact that it is a CLI flag makes it appropriately ephemeral. The moment you drop the flags, you‚Äôre back to using your pristine, fetched dependency tree.</p><p>If the project does not match, an error occurs, preventing confusion:</p><pre><code>$ zig build --fork=/home/andy/dev/mime
error: fork /home/andy/dev/mime matched no mime packages
$
</code></pre><p>If the project does match, you get a reminder that you are using a fork, preventing confusion:</p><pre><code>$ zig build --fork=/home/andy/dev/dvui
info: fork /home/andy/dev/dvui matched 1 (dvui) packages
...
</code></pre><p>This functionality is intended to enhance the workflow of dealing with ecosystem breakage. I already tried it a bit and found it to be quite pleasant to work with. The new workflow goes like this:</p><ol><li>Fail to build from source due to ecosystem breakage.</li><li>Tinker with <code>--fork</code> until your project works again. During this time you can use the actual upstream source control, test suite, <code>zig build test --watch -fincremental</code>, etc.</li><li>Now you have a new option: be selfish and just keep working on your own stuff, or you can proceed to submit your patches upstream.</li></ol><p>‚Ä¶and you can probably skip the step where you switch your <code>build.zig.zon</code> to your fork unless you expect upstream to take a long time to merge your fixes.</p>
      </div>
    
      <div id="2026-02-03">
        <p><span>February 03, 2026</span></p>
        <p>Author: Andrew Kelley</p><p>The Windows operating system provides a large ABI surface area for doing things in the kernel. However, not all ABIs are created equally. As Casey Muratori points out in his lecture, <a href="https://www.youtube.com/watch?v=5IUj1EZwpJY" target="_blank">The Only Unbreakable Law</a>, the organizational structure of software development teams has a direct impact on the structure of the software they produce.</p><p>The DLLs on Windows are organized into a heirarchy, with some of the APIs being high-level wrappers around lower-level ones. For example, whenever you call functions of <code>kernel32.dll</code>, ultimately, the actual work is done by <code>ntdll.dll</code>. You can observe this directly by using ProcMon.exe and examining stack traces.</p><p>What we‚Äôve learned empirically is that the ntdll APIs are generally well-engineered, reasonable, and powerful, but the kernel32 wrappers introduce unnecessary heap allocations, additional failure modes, unintentional CPU usage, and bloat.</p><p>This is why the Zig standard library policy is to <a href="https://codeberg.org/ziglang/zig/issues/31131" target="_blank">Prefer the Native API over Win32</a>. We‚Äôre not quite there yet - we have plenty of calls into kernel32 remaining - but we‚Äôve taken great strides recently. I‚Äôll give you two examples.</p><h2>Example 1: Entropy</h2><p>According to the official documentation, Windows does not have a straightforward way to get random bytes.</p><p><a href="https://github.com/rust-random/rand/issues/111" target="_blank">Many projects including Chromium, boringssl, Firefox, and Rust</a> call <code>SystemFunction036</code> from <code>advapi32.dll</code> because it worked on versions older than Windows 8.</p><p>Unfortunately, starting with Windows 8, the first time you call this function, it dynamically loads <code>bcryptprimitives.dll</code> and calls <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/processprng" target="_blank">ProcessPrng</a>. If loading the DLL fails (for example due to an overloaded system, which we have observed on Zig CI several times), it returns error 38 (from a function that has <code>void</code> return type and is documented to never fail).</p><p>The first thing <code>ProcessPrng</code> does is heap allocate a small, constant number of bytes. If this fails it returns <code>NO_MEMORY</code> in a <code>BOOL</code> (documented behavior is to never fail, and always return <code>TRUE</code>).</p><p><code>bcryptprimitives.dll</code> apparently also runs a test suite every time you load it.</p><p>All that <code>ProcessPrng</code> is <em>really</em> doing is <code>NtOpenFile</code> on <code>&#34;\\Device\\CNG&#34;</code> and reading 48 bytes with <code>NtDeviceIoControlFile</code> to get a seed, and then initializing a per-CPU AES-based CSPRNG.</p><p>So the dependency on <code>bcryptprimitives.dll</code> and <code>advapi32.dll</code> can both be avoided, and the nondeterministic failure and latencies on first RNG read can also be avoided.</p><h2>Example 2: NtReadFile and NtWriteFile</h2><p><code>ReadFile</code> looks like this:</p><pre><code><span>pub</span> <span>extern</span> <span>&#34;kernel32&#34;</span> <span>fn</span> <span>ReadFile</span><span>(</span>
    <span>hFile</span><span>:</span> <span>HANDLE</span><span>,</span>
    <span>lpBuffer</span><span>:</span> <span>LPVOID</span><span>,</span>
    <span>nNumberOfBytesToRead</span><span>:</span> <span>DWORD</span><span>,</span>
    <span>lpNumberOfBytesRead</span><span>:</span> <span>?</span><span>*</span><span>DWORD</span><span>,</span>
    <span>lpOverlapped</span><span>:</span> <span>?</span><span>*</span><span>OVERLAPPED</span><span>,</span>
<span>)</span> <span>callconv</span><span>(</span><span>.</span><span>winapi</span><span>)</span> <span>BOOL</span><span>;</span>
</code></pre>
<p><code>NtReadFile</code> looks like this:</p><pre><code><span>pub</span> <span>extern</span> <span>&#34;ntdll&#34;</span> <span>fn</span> <span>NtReadFile</span><span>(</span>
    <span>FileHandle</span><span>:</span> <span>HANDLE</span><span>,</span>
    <span>Event</span><span>:</span> <span>?</span><span>HANDLE</span><span>,</span>
    <span>ApcRoutine</span><span>:</span> <span>?</span><span>*</span><span>const</span> <span>IO_APC_ROUTINE</span><span>,</span>
    <span>ApcContext</span><span>:</span> <span>?</span><span>*</span><span>anyopaque</span><span>,</span>
    <span>IoStatusBlock</span><span>:</span> <span>*</span><span>IO_STATUS_BLOCK</span><span>,</span>
    <span>Buffer</span><span>:</span> <span>*</span><span>anyopaque</span><span>,</span>
    <span>Length</span><span>:</span> <span>ULONG</span><span>,</span>
    <span>ByteOffset</span><span>:</span> <span>?</span><span>*</span><span>const</span> <span>LARGE_INTEGER</span><span>,</span>
    <span>Key</span><span>:</span> <span>?</span><span>*</span><span>const</span> <span>ULONG</span><span>,</span>
<span>)</span> <span>callconv</span><span>(</span><span>.</span><span>winapi</span><span>)</span> <span>NTSTATUS</span><span>;</span>
</code></pre>
<p>As a reminder, <em>the above function is implemented by calling the below function</em>.</p><p>Already we can see some nice things about using the lower level API. For instance, the <em>real</em> API simply gives us the error code as the return value, while the kernel32 wrapper hides the status code somewhere, returns a <code>BOOL</code> and then requires you to call <code>GetLastError</code> to find out what went wrong. Imagine! Returning a value from a function üåà</p><p>Furthermore, <code>OVERLAPPED</code> is a fake type. The Windows kernel doesn‚Äôt actually know or care about it at all! The actual primitives here are events, APCs, and <code>IO_STATUS_BLOCK</code>.</p><p>If you have a synchronous file handle, then <code>Event</code> and <code>ApcRoutine</code> must be <code>null</code>. You get the answer in the <code>IO_STATUS_BLOCK</code> immediately. If you pass an APC routine here then some old bitrotted 32-bit code runs and you get garbage results.</p><p>On the other hand if you have an asynchronous file handle, then you need to either use an <code>Event</code> or an <code>ApcRoutine</code>. <code>kernel32.dll</code> uses events, which means that it‚Äôs doing extra, unnecessary resource allocation and management just to read from a file. Instead, Zig now passes an APC routine and then calls <code>NtDelayExecution</code>. This integrates seamlessly with cancelation, making it possible to cancel tasks while they perform file I/O, regardless of whether the file was opened in synchronous mode or asynchronous mode.</p><p>For a deeper dive into this topic, please refer to this issue:</p><p><a href="https://codeberg.org/ziglang/zig/issues/31131" target="_blank">Windows: Prefer the Native API over Win32</a></p>
      </div>
    
      <div id="2026-01-31">
        <p><span>January 31, 2026</span></p>
        <p>Author: Andrew Kelley</p><p>Over the past month or so, several enterprising contributors have taken an interest in the <a href="https://codeberg.org/ziglang/zig/issues/30978" target="_blank">zig libc subproject</a>. The idea here is to incrementally delete redundant code, by providing libc functions as Zig standard library wrappers rather than as vendored C source files. In many cases, these functions are one-to-one mappings, such as <code>memcpy</code> or <code>atan2</code>, or trivially wrap a generic function, like <code>strnlen</code>:</p><pre><code><span>fn</span> <span>strnlen</span><span>(</span><span>str</span><span>:</span> <span>[</span><span>*</span><span>:</span><span>0</span><span>]</span><span>const</span> <span>c_char</span><span>,</span> <span>max</span><span>:</span> <span>usize</span><span>)</span> <span>callconv</span><span>(</span><span>.</span><span>c</span><span>)</span> <span>usize</span> <span>{</span>
    <span>return</span> <span>std</span><span>.</span><span>mem</span><span>.</span><span>findScalar</span><span>(</span><span>u8</span><span>,</span> <span>@ptrCast</span><span>(</span><span>str</span><span>[</span><span>0</span><span>..</span><span>max</span><span>]</span><span>)</span><span>,</span> <span>0</span><span>)</span> <span>orelse</span> <span>max</span><span>;</span>
<span>}</span>
</code></pre>
<p>So far, roughly 250 C source files have been deleted from the Zig repository, with 2032 remaining.</p><p>With each function that makes the transition, Zig gains independence from third party projects and from the C programming language, compilation speed improves, Zig‚Äôs installation size is simplified and reduced, and user applications which statically link libc enjoy reduced binary size.</p><p>Additionally, a <a href="https://codeberg.org/ziglang/zig/pulls/31037" target="_blank">recent enhancement</a> now makes zig libc share the Zig Compilation Unit with other Zig code rather than being a separate static archive, linked together later. This is one of the advantages of Zig having an integrated compiler and linker. When the exported libc functions share the ZCU, redundant code is eliminated because functions can be optimized together. It‚Äôs kind of like enabling LTO (Link-Time Optimization) across the libc boundary, except it‚Äôs done properly in the frontend instead of too late, in the linker.</p><p>Furthermore, when this work is combined with the recent <a href="https://codeberg.org/ziglang/zig/issues/30150" target="_blank">std.Io changes</a>, there is potential for users to seamlessly control how libc performs I/O - for example forcing all calls to <code>read</code> and <code>write</code> to participate in an io_uring event loop, even though that code was not written with such use case in mind. Or, <a href="https://codeberg.org/ziglang/zig/pulls/30788" target="_blank">resource leak detection</a> could be enabled for third-party C code. For now this is only a vaporware idea which has not been experimented with, but the idea intrigues me.</p><p>Big thanks to Szabolcs Nagy for <a href="https://wiki.musl-libc.org/libc-test.html" target="_blank">libc-test</a>. This project has been a huge help in making sure that we don‚Äôt regress any math functions.</p><p>As a reminder to our users, now that Zig is transitioning to being the static libc provider, if you encounter issues with the musl, mingw-w64, or wasi-libc libc functionality provided by Zig, <strong>please file bug reports in Zig first</strong> so we don‚Äôt annoy maintainers for bugs that are in Zig, and no longer vendored by independent libc implementation projects.</p><p>The very same day I sat at home writing this devlog like a coward, less than five miles away, <a href="https://www.kptv.com/2026/01/31/live-labor-unions-rally-march-portland-ice-facility-protest/" target="_blank">armed forces who are in my city against the will of our elected officials shot tear gas, unprovoked, at peaceful protestors</a>. Next time I hope to have the courage to join my neighbors, and I hope to not get shot like <a href="https://en.wikipedia.org/wiki/Killing_of_Alex_Pretti" target="_blank">Alex Pretti</a> and <a href="https://en.wikipedia.org/wiki/Killing_of_Ren%C3%A9e_Good" target="_blank">Ren√©e Good</a>.</p>
      </div>
    </div></div>
  </body>
</html>
