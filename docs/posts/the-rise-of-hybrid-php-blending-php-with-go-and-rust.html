<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yekdeveloper.com/p/4-the-rise-of-hybrid-php">Original</a>
    <h1>The Rise of Hybrid PHP: Blending PHP with Go and Rust</h1>
    
    <div id="readability-page-1" class="page"><div> <article><header>  <p>Original - <a href="https://yekdeveloper.com/p/4-the-rise-of-hybrid-php">2025-08-30</a> - <a href="https://yekdeveloper.com/p/4-the-rise-of-hybrid-php"> yeknava </a> - <a href="https://yekdeveloper.com/p/4-the-rise-of-hybrid-php"> 2 minute read </a> </p> </header> <div><p>We used to develop our application as a single DDD monolith (let’s call it the <strong>mother</strong>) with several smaller microservices around it (the <strong>children</strong>) to gain some specific advantages. Most of these microservices were built in <strong>Go</strong>, while the core monolithic service was developed in <strong>PHP 8.3</strong>.</p><p>This stack served us well for a long time. The Go microservices efficiently handled our <strong>high-throughput requests</strong>, and the carefully designed monolith allowed our relatively small backend team to <strong>deliver features quickly and with confidence</strong>. It was a good balance: speed where we needed it most, and stability and productivity everywhere else.</p><p>As many of you may have experienced, <strong>80% of your traffic often targets only 20% of your APIs</strong>—the well-known <strong>Pareto principle</strong>. And unsurprisingly, those hot 20% endpoints are usually the ones where performance matters the most. In the past, our strategies included writing highly optimized code, adding extreme caching layers, or extracting certain parts into Go-based microservices. While effective, these approaches added complexity and operational overhead.</p><p>But now, thanks to new capabilities in the PHP ecosystem and the rise of powerful libraries and runtimes, it’s becoming much easier to <strong>keep more logic inside the monolith</strong> while still achieving excellent performance. Let’s look at a few exciting options:</p><h3>1. FFI (Foreign Function Interface)</h3><p>PHP’s <strong>FFI</strong> feature allows you to call <strong>C code directly from PHP</strong>. This opens the door to system-level operations or performance-critical logic without leaving your PHP project. Of course, you need to be mindful of <strong>context switching costs</strong>, but for the right use cases, it’s a game-changer.</p><h3>2. Rust-Based Extensions</h3><p>If writing raw C isn’t your cup of tea, you can now write PHP extensions in <strong>Rust</strong> (or even <strong>Zig</strong>). This lets you offload heavy, performance-sensitive parts of your application to safe, memory-efficient, compiled code. Rust, in particular, offers <strong>memory safety guarantees</strong> without sacrificing speed, which makes it a great fit for extensions that need to be both reliable and fast.</p><h3>3. Go-Based Extensions with FrankenPHP</h3><p>We’ve recently switched to <strong>FrankenPHP</strong> (after seeing it become officially supported by the PHP Foundation). Running PHP in FrankenPHP’s <strong>worker mode</strong> is impressively fast—sometimes over <strong>4x faster</strong> in our benchmarks compared to traditional setups.</p><p>Even more exciting, a recent release introduced the ability to <strong>write PHP extensions in Go</strong>. This feature is something we are actively exploring because it would let us build high-performance APIs in Go and expose them seamlessly inside our PHP monolith. That way, we can combine the productivity of PHP with the raw speed of Go, without needing to split everything into separate services.</p><h3>But Why Not Just Rewrite Everything in Go or Rust?</h3><p>It’s a fair question—and one we’ve asked ourselves too. There are two main reasons why we don’t simply migrate the entire backend:</p><p>1. <strong>Rewriting is costly.</strong> Many applications are already large and stable. Rewrites are risky, time-consuming, and often introduce more problems than they solve. In most scenarios, a rewrite should be the very last option.</p><p>2. <strong>PHP is still a great fit.</strong> For the majority of the application, PHP does the job well. It’s fast enough, developer-friendly, and supported by a large ecosystem. For those few cases where you truly need <strong>maximum performance</strong>, you can now selectively write parts in Go or Rust as extensions—rather than rewriting the entire system.</p><p>In short, the modern PHP ecosystem gives us the <strong>best of both worlds</strong>: the ability to build quickly and confidently in PHP, while still having powerful options (C, Rust, Go) for performance-critical parts. This hybrid approach lets us stay productive without sacrificing speed where it matters most.</p> </div> </article> </div></div>
  </body>
</html>
