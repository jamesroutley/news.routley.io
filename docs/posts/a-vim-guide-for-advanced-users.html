<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/vim-advanced/">Original</a>
    <h1>A Vim Guide for Advanced Users</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2021/02_vim_advanced/vim-advanced.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2021/02_vim_advanced/vim-advanced.jpg" alt="Vim for advanced users"/></picture><p>Welcome to the third part of this series aimed to help you unleash a power never seen on Earth using the Almighty Vim.</p><p>We’ll see together in this article:</p><ul><li>Some nice keystrokes beginning with <code>g</code>.</li><li>What ranges are and how to use them.</li><li>The quickfix list and the location lists.</li><li>The marvelous substitute command.</li><li>The crazy useful <code>:global</code> (or <code>:g</code>) command.</li><li>What marks are and what you can do with them.</li><li>How to increase and decrease numbers with a single keystroke.</li><li>How to sort text with a nice command.</li></ul><p>But before going into the juicy content of this article, I’ve some recommendations for you, dear reader:</p><ol><li>Fire up your Vim and play around with the commands and keystrokes while reading. It’s the best way for you to remember everything which blew you away. You’ll then be able to be blown away whenever you like for the rest of your life.</li><li>Don’t use a cheatsheet; write your own as you read. It will allow you to come back easily to the commands you find the most useful for <em>your own needs</em>.</li></ol><p>Enough rambling. Let’s begin!</p><h2 id="useful-g-keystrokes">Useful “g” Keystrokes</h2><p>Let’s begin gently with a mixed bag of keystrokes starting with <code>g</code>. There are many of these “g” commands in Vim, and we already saw some of them in the previous articles. Can you recall them?</p><p>You can use these keystrokes in NORMAL mode:</p><ul><li><code>gf</code> - Edit the file located at the filepath under your cursor.<ul><li>You can use <code>CTRL+W CTRL+F</code> to open the file in a new window.</li><li>It can open the URL under your cursor if you have the plugin <code>netrw</code>.</li></ul></li><li><code>gx</code> - Open the file located at the filepath under your cursor.<ul><li>It will use the default application used by your OS for this filetype.</li><li>It works with URLs too. It will open your favorite browser and load the website.</li><li>It only works if you have the plugin <code>netrw</code>.</li></ul></li><li><code>gi</code> - Move to the last insertion you did and switch to INSERT mode.<ul><li>Pretty useful if you stopped your editing to look at some other file.</li><li>It uses marks under the hood: more on that later in this article.</li></ul></li><li><code>gv</code> - Start VISUAL mode and use the selection made during the last VISUAL mode.</li><li><code>gn</code> - Select the match of your last search:<ol><li>Move to the last searched match.</li><li>Switch to VISUAL mode (if you weren’t in VISUAL mode already).</li><li>Select the match.</li><li>You can continue to hit <code>n</code> (or <code>gn</code>) to select the area between the current match and the next match.</li></ol></li><li><code>gI</code> - Insert text at the beginning of the line, no matter what the first characters are.<ul><li>The keystroke <code>I</code> insert text <em>just before the first non-blank characters</em> of the line.</li></ul></li><li><code>ga</code> - Print the <code>a</code>scii value of the character under the cursor in decimal, hexadecimal or octal.</li><li><code>gu</code> - Lowercase using a motion (for example, <code>guiw</code>).</li><li><code>gU</code> - Uppercase using a motion (for example, <code>gUiw</code>).</li></ul><p>To try out <code>gf</code> and <code>gx</code>, you can write for example <code>https://www.google.com/</code> in Vim, place your cursor on it, and hit the keystrokes. Don’t forget the trailing slash in your URL.</p><p>You’ll soon discover an inconvenience with <code>gx</code>: when you use it on a filepath, Vim will hang till you close the file. That’s why I’ve created the following mapping you can add to your <code>.vimrc</code>:</p><pre><code>nnoremap gX :silent :execute
            \ &#34;!xdg-open&#34; expand(&#39;%:p:h&#39;) . &#34;/&#34; . expand(&#34;&lt;cfile&gt;&#34;) &#34; &amp;&#34;&lt;cr&gt;
</code></pre><p>It maps the keystroke <code>gX</code> to use <code>xdg-open</code> with a relative filepath under your cursor. It will open the file with your favorite application <em>in the background</em>. The program <code>xdg-open</code> will only work on Linux-based systems; for MacOS, try <code>open</code> instead.</p><h2 id="ranges">Ranges</h2><p>Now that we’re done with the appetizers, let’s discover the first real dish of our Vim feast: the ranges. You can apply them to many commands, making them terribly powerful.</p><h3 id="basics">Basics</h3><p>In Vim’s help, every command accepting a range will have the string of characters <code>[range]</code> in front of them. Multiple line specifiers are possible, separated by commas <code>,</code>.</p><p>Here are the most interesting ranges you can use:</p><ul><li><code>&lt;number&gt;</code> - Any number <code>&lt;number&gt;</code> in your range refers to a line number.</li><li><code>.</code> - Represent the current line (often the default range).</li><li><code>$</code> - Represent the last line of the current buffer.</li><li><code>%</code> - Represent the entire file (same as <code>1,$</code>).</li><li><code>*</code> - Use the last selection you’ve made during the last VISUAL mode.</li></ul><p>For example, using the command <code>:d</code>:</p><ul><li><code>:1,40d</code> - Delete line 1 to 40 included.</li><li><code>:2,$d</code> - Delete every line from the second one till the end of the file.</li><li><code>:.,$d</code> - Delete every line from the current one till the end of the file.</li><li><code>:%d</code> - Delete every line.</li></ul><p>You can also do some arithmetic with ranges if you want. For example, let’s imagine your cursor is on the line 60: the range <code>.,.+10</code> will be equivalent to the range <code>60,70</code>.</p><h3 id="visual-mode-and-range">Visual Mode and Range</h3><p>If you switch to COMMAND-LINE mode after doing some selection in VISUAL mode, you’ll see these two symbols appearing: <code>&#39;&lt;</code> and <code>&#39;&gt;</code> with a comma <code>,</code> in between. This is a range too!</p><p>The symbols <code>&#39;&lt;</code> represents the first line you’ve selected and <code>&#39;&gt;</code> the last line. Each of these are marks; again, we’ll see more about marks below.</p><p>In practice, the ranges <code>&#39;&lt;,&#39;&gt;</code> and <code>*</code> are synonym, but you’ll have more flexibility with the first. For example, you can execute a command from the first line you’ve selected till the end of the file with the range <code>&#39;&lt;,$</code>.</p><div><div><ul><li><code>:help [range]</code></li><li><code>:help v_:</code></li><li><code>:help &#39;&lt;</code></li><li><code>:help &#39;&gt;</code></li></ul></div></div><h2 id="vims-quickfix-and-location-list">Vim’s Quickfix And Location List</h2><p>Now, let’s talk about a very useful data structure available in Vim, the quickfix list.</p><p>Don’t confuse the quickfix list and the quickfix window: these are two different entities. The first is a data structure, the second can display this data structure.</p><h3 id="quickfix-lists">Quickfix Lists</h3><p>You can think of a quickfix list as a set of positions in one or multiple files.</p><h4 id="basics-1">Basics</h4><p>Let’s take an example: what happens if you run the command <code>:vimgrep hello *</code>?</p><ol><li>It will search the pattern “hello” in every file of your working directory.</li><li>It will populate a quickfix list with every position matching your pattern “hello”.</li><li>It will move your cursor to the first position of the quickfix list.</li></ol><p>If you want to know more about vimgrep and other tools you can search with, I <a href="https://thevaluable.dev/vim-search-find-replace/">wrote an article about that</a>. Other commands (like <code>:make</code> or <code>:grep</code>) also populate automatically a quickfix list.</p><p>Let’s expand the mystery around marks: these positions in the quickfix list are in fact hidden mark!</p><p>The quickfix list is often used to display specific errors in a codebase, often spit out from a compiler or a linter (via the command <code>:make</code> for example), but not only, as we just saw. I call the entries of a quickfix list “positions” to be more general, but sometimes Vim’s help will refer to them as “errors”. Don’t be confused: it’s the same idea.</p><p>Among other conditions, a quickfix list entry needs to have a filename for you to be able to jump to its position. Otherwise, the entry doesn’t point to anything. Difficult to move to anything.</p><h4 id="useful-commands">Useful Commands</h4><p>Here are the commands you can use to navigate through the current quickfix list:</p><ul><li><code>:cl</code> or <code>:clist</code> - Display all valid entries of the current quickfix list. You can add a range as argument (only numbers).</li><li><code>:cc &lt;number&gt;</code> - Move to the <code>&lt;number&gt;</code>th entry of the current quickfix list.</li><li><code>:cnext</code> or <code>:cn</code> - Move to the next entry of the current quickfix list.</li><li><code>:cprevious</code> or <code>:cp</code> - Move to the previous entry of the current quickfix list.</li><li><code>:cfirst</code> or <code>:cfir</code> - Move to the first entry of the current quickfix list.</li><li><code>:clast</code> or <code>:clas</code> - Move to the last entry of the current quickfix list.</li></ul><p>Here are additional commands which make quickfix lists really powerful:</p><ul><li><code>:cdo &lt;cmd&gt;</code> - Execute a command <code>&lt;cmd&gt;</code> on each valid entry of the current quickfix list.</li><li><code>:cexpr &lt;expr&gt;</code> or <code>:cex &lt;expr&gt;</code> - Create a quickfix list using the result of evaluating the Vimscript expression <code>&lt;expr&gt;</code>.</li><li><code>:caddexpr &lt;expr&gt;</code> or <code>:cadde &lt;expr&gt;</code> - Appends the result of evaluating the Vimscript expression <code>&lt;expr&gt;</code> to the current quickfix list.</li></ul><p>If you have no clue how to use the last two commands, you can do for example:</p><ul><li><code>:cex []</code> - Empty the current quickfix list.</li><li><code>:cex system(&#34;&lt;cmd&gt;&#34;)</code> - Populate your quickfix list with any shell command <code>&lt;cmd&gt;</code>. You can try it with <code>ls</code> for example.</li></ul><h3 id="the-quickfix-window">The Quickfix Window</h3><p>What about displaying the current quickfix list in a new buffer? You can do that with the following command:</p><ul><li><code>:copen</code> or <code>:cope</code> - Open a window (with a special buffer) to show the current quickfix list.</li></ul><p>You can only have one quickfix window open. To move to the position of the selected entry of the quickfix list in the quickfix window, hit <code>ENTER</code> or <code>.cc</code>.</p><h3 id="location-lists">Location Lists</h3><p>A location list is similar to a quickfix list, except that the first is local to a window and the second is global to your Vim instance. In other words, you can have multiple location lists available at the same time (one per window open), but you can only have access to one quickfix list.</p><p>The commands for location lists are similar to the ones for the quickfix lists; often, you’ll only have to replace the first <code>c</code> (qui<code>c</code>fix) of the command with <code>l</code> (<code>l</code>ocation).</p><p>For example:</p><ul><li><code>:lli</code> or <code>:llist</code> - Display all valid entries of the current location list. You can add a range as argument (only numbers).</li><li><code>:ll &lt;number&gt;</code> - Move to the entry <code>&lt;number&gt;</code> of the current location list.</li><li><code>:lnext</code> or <code>:lne</code> - Move to the next entry of the current quickfix list.</li></ul><p>To populate your location list you can also use the commands <code>:lvimgrep</code> or <code>:lmake</code> for example.</p><p>Often, Vim users will use the quickfix list for anything related to errors in their codebase, and the location list for search results. But it’s up to you at the end of the day. With Vim, you’re the master of your destiny.</p><div><div><ul><li><code>:help quickfix</code></li><li><code>:help quickfix-window</code></li><li><code>:help location-list</code></li><li><code>:help location-list-window</code></li><li><code>:help expr</code></li><li><code>:help system()</code></li></ul></div></div><h2 id="vims-registers">Vim’s Registers</h2><p>The registers are another big dish in our Vim feast. You can think of registers as places where you can read or write some text. I like to think about them as Vim’s clipboards.</p><h3 id="specifying-a-register">Specifying a Register</h3><p>Here’s a command and a NORMAL mode keystroke to display and <em>specify</em> registers:</p><ul><li><code>:registers</code> or <code>:reg</code> - Display the content of your registers.</li><li><code>&#34;&lt;reg&gt;</code> - This keystroke <em>specifies</em> the register <code>&lt;reg&gt;</code> to be read or written.</li></ul><p>How do you know when the register <code>&lt;reg&gt;</code> is read or written using the keystroke <code>&#34;</code>? It depends of the keystroke you use afterward. For example:</p><ul><li>To write the register <code>a</code>:<ol><li>Hit <code>&#34;a</code> in NORMAL mode to specify what register you want to write on.</li><li>Yank, change, or delete some content (for example by using <code>dd</code> in NORMAL mode) to write it to <code>a</code>.</li></ol></li><li>To read the register <code>a</code>:<ol><li>Hit <code>&#34;a</code> in NORMAL mode to specify what register you want to read.</li><li>Use a put keystroke in NORMAL mode (for example <code>p</code> or <code>P</code>) to spit out the content of the register in your current buffer.</li></ol></li></ul><p>We take the example of register <code>a</code> here, but it will work for any writable register.</p><h3 id="the-types-of-registers">The Types of Registers</h3><p>There are 10 different types of registers in Vim:</p><ol><li><strong>The unnamed register</strong> (<code>&#34;</code>) - Contain the last deleted, changed, or yanked content, <em>even if</em> one register was specified.</li><li><strong>The numbered registers</strong> (from <code>0</code> to <code>9</code>)<ul><li><code>0</code> contains the content of the last yank.</li><li><code>1</code> to <code>9</code> is a stack containing the content you’ve deleted or changed.<ol><li>Each time you delete or change some content, it will be added to the register <code>1</code>.</li><li>The previous content of the register <code>1</code> will be assigned to register <code>2</code>, the previoius content of <code>2</code> to <code>3</code>…</li><li>When something is added to the register <code>1</code>, the content of the register <code>9</code> is lost.</li></ol></li><li>None of these registers are written if you’ve specified one before with the keystroke <code>&#34;</code>.</li></ul></li><li><strong>The small delete register</strong> (<code>-</code>)<ul><li>Contains any deleted or changed content smaller than one line.</li><li>It’s not written if you specified a register with <code>&#34;</code>.</li></ul></li><li><strong>The named registers</strong> (range from <code>a</code> to <code>z</code>)<ul><li>Vim will never write to them if you don’t specify them with the keystroke <code>&#34;</code>.</li><li>You can use the uppercase name of each register to append to it (instead of overwriting it).</li></ul></li><li><strong>The read only registers</strong> (<code>.</code>, <code>%</code> and <code>:</code>)<ul><li><code>.</code> contains the last inserted text.</li><li><code>%</code> contains the name of the current file.</li><li><code>:</code> contains the most recent command line executed.</li></ul></li><li><strong>The alternate buffer register</strong> (<code>#</code>) - Contain the alternate buffer for the current window.</li><li><strong>The expression register</strong> (<code>=</code>) - Store the result of an expression. More about this register below.</li><li><strong>The selection registers</strong> (<code>+</code> and <code>*</code>)<ul><li><code>+</code> is synchronized with the system clipboard.</li><li><code>*</code> is synchronized with the selection clipboard (only on *nix systems).</li></ul></li><li><strong>The black hole register</strong> (<code>_</code>) - Everything written in there will disappear forever.</li><li><strong>The last search pattern register</strong> (<code>/</code>) - This register contains your last search.</li></ol><p>As you can see, even if you don’t specify any register with the keystroke <code>&#34;</code>, the content you delete, change, or yank will automatically overwrite one (or multiple) of them. So if you don’t want the content you write to your registers to be silently overwritten by Vim, <em>always write in the named registers</em>.</p><p>Using a put command without specifying any register will spit the content of the unnamed register by default. But you might have this line in your <code>vimrc</code>:</p><pre><code>clipboard+=unnamedplus
</code></pre><p>In that case, the content you change, delete, or yank will go directly in the unnamed register <em>and</em> the <code>+</code> register. Using put commands will directly output the <code>+</code> register too. Many find it useful (including me) to access your OS clipboard more easily, without the need to specify the <code>+</code> register for reading or writing it.</p><h3 id="appending-a-recording">Appending a Recording</h3><p>We’ve seen in the <a href="https://thevaluable.dev/vim-intermediate/">previous article</a> that you can record your keystrokes using <code>q</code>. Now that you know how to use registers, you can manipulate these keystrokes:</p><ul><li>If you made a mistake during the recording, you can spit the whole register, modify it, and save it back.</li><li>You can append to your recording by using the uppercase variant of your register. For example:<ol><li>Hit <code>qa</code> and record whatever keystrokes you want. Stop the recording by hitting <code>q</code> again.</li><li>You realize that you forgot a couple of keystrokes.</li><li>Execute your keystrokes to be sure you’re at the last position of your recording.</li><li>Hit <code>qA</code> to <em>append</em> to your register <code>a</code>. When you’re done, hit <code>q</code> again.</li></ol></li></ul><p>You’ve just gained even more flexibility for your macros.</p><h3 id="using-registers-in-insert-and-command-line-modes">Using Registers in INSERT and COMMAND LINE modes</h3><p>The magical keystroke <code>&#34;</code> is great for NORMAL mode, but what about spitting the content of a register in INSERT mode or COMMAND LINE mode? For that, you can use <code>CTRL+R &lt;reg&gt;</code> to put the content of register <code>&lt;reg&gt;</code> in your current buffer.</p><p>For example, if you hit <code>CTRL+R %</code> in INSERT mode, you’ll put the content of the register <code>%</code> in your current buffer.</p><h3 id="the-insane-expression-register">The Insane Expression Register</h3><p>If you don’t know the expression register, I’m about to revolution your life. I hope you’re ready.</p><p>Try this:</p><ol><li>Switch to INSERT mode and hit the keystroke <code>CTRL+r =</code>. You’ll move to Vim’s command-line.</li><li>From there, you can type any Vimscript expression you want, like <code>system(&#34;ls&#34;)</code> we saw above, or <code>4+4</code>.</li><li>Hit <code>ENTER</code> to run the expression, and you’ll see the output of the shell command <code>ls</code> directly inserted in your buffer!</li></ol><p>It’s useful to evaluate some custom functions you’ve defined while staying in insert mode. If you use Neovim, you can use the function <code>luaeval()</code> to evaluate some Lua too.</p><h3 id="clearing-a-register">Clearing a Register</h3><p>A last little trick about registers: if you want to empty one, you can do:</p><pre><code>qaq
</code></pre><p>Beginning a recording also deletes everything which is in this register. So you just need to stop the recording by hitting <code>q</code> again to have an empty register.</p><div><div><ul><li><code>:help registers</code></li><li><code>:help clipboard</code></li><li><code>:help clipboard-unnamed</code></li><li><code>:help clipboard-unnamedplus</code></li></ul></div></div><h2 id="the-substitute-commands">The Substitute Commands</h2><p>Let’s continue our ascension to become The Vim God (or Goddess). The substitute command is next on the menu.</p><h3 id="basics-2">Basics</h3><p>If you’re already familiar with the CLI <code>sed</code>, this command will remind you some good old memories.</p><p>A substitution is a way to replace some content with some other content, using a range and a count. The count will decide how many lines is affected by your substitution from the last line of your range.</p><p>Like many other commands, the default range is the current line if you don’t specify it.</p><p>Here’s the pattern of the command itself:</p><pre><code>:s/pattern/replacement/flags
</code></pre><p>What does this mean?</p><ul><li>The <code>pattern</code> is the search you want to match.</li><li>The <code>replacement</code> will replace the <em>first match</em> of the pattern on each line.</li><li>The <code>flag</code> modify the behavior of the command.</li></ul><p>There’s another element, represented here with a slash <code>/</code>: the separator. It doesn’t have to be a slash, it can be any character except:</p><ul><li>An alphanumerical character (a character included in the range <code>a-z</code>, <code>A-Z</code>, and <code>0-9</code>).</li><li>A double quote<code>&#34;</code>.</li><li>A pipe <code>|</code>.</li></ul><p>The <code>replacement</code> is not mandatory: if you omit it, the substitute command will delete the pattern matched.</p><p>You can also run <code>:s</code> without any range, pattern, replacement, flags, or count. In that case, it will repeat the last substitution you’ve done without the flags; you can add new flags (except <code>&amp;</code>) and a count if you want to.</p><p>Let’s see some examples to understand how it works:</p><ul><li><code>:s/pattern/replacement/</code> - Substitute the first occurrence of <code>pattern</code> on the current line with <code>replacement</code>.</li><li><code>:s#pattern#replacement#</code> - Equivalent substitution to the one just above. Handy if you have some URLs in your <code>pattern</code> or your <code>replacement</code>.</li><li><code>:s/pattern/</code> - delete the first occurrence of <code>pattern</code> on the current line.</li><li><code>:s/pattern/replacement/g</code> - Substitute every occurrence of <code>pattern</code> on the current line.</li></ul><p>You can also add a range as prefix and a count as suffix:</p><ul><li><code>:%s/pattern/replacement/</code> - Substitute every <em>first</em> occurrence of <code>pattern</code> on each line of the current buffer.</li><li><code>:%s/pattern/replacement/g</code> - Substitute every occurrence of <code>pattern</code> on each line of the current buffer.</li><li><code>:1,10s/pattern/replacement/</code> - Substitute every <em>first</em> occurrence of <code>pattern</code> on the first ten lines of the current buffer.</li><li><code>:s/pattern/replacement/ 10</code> - Substitute every <em>first</em> occurrence of <code>pattern</code> for the current line and the 10 next lines.</li><li><code>:1,10s/pattern/replacement/ 5</code> - Substitute every <em>first</em> occurrence of <code>pattern</code> on the first ten lines and on the five lines below the last line of the range.</li><li><code>:s g 10</code> - Repeat the last substitution without its flag, and add a new flag <code>g</code>. It will affect the 10 lines after the last line of the last substitute command.</li></ul><h3 id="vims-magical-patterns">Vim’s “Magical” Patterns</h3><p>A <code>pattern</code> in that case is a regular expression. But it’s not the good old regex engine you’re familiar with from high level programming languages. Vim has its own regex engine (actually, it has two!) which can be quite confusing.</p><p>Regexes in Vim are more or less magic. You think I’m kidding? I’m not. Here’s what I find useful to remember:</p><ul><li>To have access to <em>all</em> regex metacharacters, you can prefix your pattern with <code>\v</code> (<code>v</code>ery magic).</li><li>To have access to <em>almost all</em> regex metacharacters (except <code>(</code>, <code>)</code> and <code>|</code>), use the command <code>:sm</code> instead of <code>:s</code> (<code>s</code>ubstitute <code>m</code>agic).</li><li>To have access to <em>none</em> of the metacharacters (except <code>$</code>), use <code>:sno</code> instead of <code>:s</code> (<code>s</code>ubstitute <code>no</code>magic).</li><li>To have access to <em>none</em> of the metacharacters, you can prefix your pattern with <code>\V</code> (<code>V</code>ery nomagic).</li></ul><p>For example, if I want to delete all opening parenthesis in my buffer, I can run one of these three equivalent commands:</p><pre><code>:%s/\V(/
:%sm/(/
:%s/\(/
</code></pre><p>If you know your regex metacharacters, you might wonder what’s the metacharacter <code>~</code>. It’s the latest substituted string in Vim’s world. In fact, you can use many more metacharacters (called <em>atoms</em>) and character classes in your Vim’s regex.</p><p>If don’t know you’re regex metacharacters, <a href="https://www.youtube.com/watch?v=LIVBktatfQI" target="_blank" rel="noopener">I’ve recorded a couple of videos</a> explaining the basics of regular expressions (using grep).</p><p>The <a href="https://thevaluable.dev/vim-adept/">next article</a> in this series dive into Vim’s regexes a bit deeper.</p><h3 id="additional-commands">Additional Commands</h3><p>Here are two other commands I find useful:</p><ul><li><code>:&amp;&amp;</code> - Repeat the last substitute with its flags.</li><li><code>:~</code> - Repeat the last substitute command with the same replacement, but with the last used <em>search</em> pattern.</li></ul><p>For example, let’s say that you execute successively the following in Vim:</p><pre><code>:s/pattern/replacement/
/hello
:~
</code></pre><p>The last command will substitute <code>hello</code> with <code>replacement</code>.</p><p>You can also use these useful keystrokes in NORMAL mode:</p><ul><li><code>&amp;</code> - Repeat the last substitute, without its range and its flags.</li><li><code>g&amp;</code> - Repeat the last substitute with the same flags but without the same range (it’s global), and replace its pattern with the last <em>search</em> pattern.</li></ul><h3 id="the-substitutes-flags">The Substitutes Flags</h3><p>Here are some flags which can be useful:</p><ul><li><code>&amp;</code> - Use the flag(s) from the previous substitute command.</li><li><code>c</code> - Ask you to confirm each substitution.</li><li><code>g</code> - Replace all occurrences in each line (not only the first one).</li><li><code>i</code> - The pattern is case-insensitive.</li><li><code>I</code> - The pattern is case-sensitive.</li><li><code>n</code> - Only report the number of match without substitute.</li></ul><p>You can now substitute like crazy to your heart’s content!</p><div><div><ul><li><code>:help :substitute</code></li><li><code>:help :sm</code></li><li><code>:help :sno</code></li><li><code>:help :s_flags</code></li></ul></div></div><h2 id="the-global-command">The Global Command</h2><p>You don’t have enough? You want even more power? Behold the Holy Global Command! It works similarly to the substitute command, except that it will execute a command instead of replacing a pattern.</p><h3 id="basics-3">Basics</h3><p>Here’s the pattern of the command itself:</p><pre><code>:g/pattern/command
</code></pre><p>You can also prefix it with a range if you want to.</p><p>As an example, let’s imagine that you have the urge to delete all the lines of your current buffer containing the pattern “useless”. To do that, you can run:</p><pre><code>:g/useless/d
</code></pre><p>Nice, but I can give you <em>even more</em> power.</p><h3 id="normal-mode-commands">Normal mode Commands</h3><p>Do you know the command <code>:norm</code>? You can give to it some NORMAL mode keystrokes and it will apply them for you, <em>as if you were hitting them in NORMAL mode</em>. For example, the following will delete the word under the cursor:</p><pre><code>:norm daw
</code></pre><p>Let’s now combine a normal mode command with the global command:</p><pre><code>:g/useless/norm gu$
</code></pre><p>This will lowercase every line containing the pattern <code>useless</code>.</p><p>When I first heard about that, I saw the Universe, the Big Bang, the cycle of creation and destruction. I understood life and death. I became blessed, chanting the power of Vim in every free cities.</p><p>A last tip: <code>:norm</code> use the key mappings you’ve defined. If you only want to use Vim’s default mapping, you can use <code>norm!</code> instead.</p><p>If you write a plugin, <em>always</em> use <code>norm!</code>. You don’t know what mappings have your users.</p><div><div><ul><li><code>:help :global</code></li><li><code>:help :normal</code></li></ul></div></div><h2 id="marks">Marks</h2><p>It’s time to answer the question haunting your incredible mind: what are marks?</p><h3 id="basics-4">Basics</h3><p>You can think of a mark as a specific position in a buffer. To set one, you can use <code>m</code> in NORMAL mode followed by a character in the following ranges:</p><ul><li><code>a-z</code> - These marks are local to one buffer.</li><li><code>A-Z</code> - These marks are global to multiple buffers.</li></ul><p>If you have a “viminfo” file set via the option <code>viminfo</code> in Vim, or if you have a “shada” file set via the option <code>shada</code> in Neovim, these marks are persisted. This means that you can come back to them even if you closed the file.</p><p>If you wonder what are Vim’s options and how to display their values, <a href="https://thevaluable.dev/vim-beginners/">I wrote about it in the first article of this series</a>.</p><p>There are also read-only marks in the range <code>0-9</code>. They are only available when using a <code>viminfo</code> file (for Vim) or a <code>shada</code> file (for Neovim). They store the position of your cursor each time you quit a file: the mark <code>0</code> has the last position, the mark <code>1</code> has the position before the last one, and so on.</p><p>To move to a mark, you can use these keystrokes in NORMAL mode:</p><ul><li><code>&#39;&lt;mark&gt;</code> - Move to the <em>first non-blank character</em> of the line where the mark <code>&lt;mark&gt;</code> was set.</li><li><code>`<mark></mark></code>
- Move to the <em>exact position</em> where the mark <code>&lt;mark&gt;</code> was set.</li><li><code>g&#39; &lt;mark&gt;</code> <code>g` &lt;mark&gt;</code> - Move to the mark <code>&lt;mark&gt;</code> without changing the jump list (I’ve written about the jump list <a href="https://thevaluable.dev/vim-intermediate/">in the previous article of this series</a>).</li></ul><h3 id="useful-commands-1">Useful Commands</h3><p>As you might imagine, there are also some useful commands for displaying or manipulating marks:</p><ul><li><code>:marks</code> - Display the marks set.</li><li><code>:marks &lt;marks&gt;</code> - Display some specific marks <code>&lt;marks&gt;</code>.</li><li><code>:delmarks &lt;mark&gt;</code> or <code>:delm &lt;mark&gt;</code> - Delete the mark <code>&lt;mark&gt;</code>.</li><li><code>:delmarks!</code> or <code>delm!</code> - Delete all the marks in the range <code>a-z</code>.</li></ul><p>For example, <code>:marks &lt;&gt;</code> will display the two marks <code>&lt;</code> and <code>&gt;</code>.</p><p>You can also use marks as ranges. For example:</p><pre><code>:`a,`bs/pattern/replacement/
</code></pre><p>This will substitute the first match of <code>pattern</code> with <code>replacement</code> from the exact position of the mark <code>a</code> to the exact position of the mark <code>b</code>.</p><h3 id="special-marks">Special Marks</h3><p>Let’s now introduce special marks with these keystrokes:</p><ul><li><code>m&lt;</code> or <code>m&gt;</code> - Set the marks <code>&#39;&lt;</code> and <code>&#39;&gt;</code> we saw above. It can be handy for the keystroke <code>gv</code>.</li><li><code>`[</code>
- Move to the first character of the previously changed, deleted, or yanked content.</li><li><code>`]</code>
- Move to the last character of the previously changed, deleted, or yanked content.</li><li><code>``</code>
- Move to the position before the latest jump from the jump list (or where you’ve set it with <code>m&#39;</code> or <code>m`</code>
).</li><li><code>`&#34;</code>
- Move to the position were you’ve closed the current file for the last time.</li><li><code>`^</code>
- Move to the position where you’ve used INSERT mode for the last time (this mark is used by the keystroke <code>gi</code> under the hood).</li></ul><p>For every keystroke described above using <code>`</code>
, you can use <code>&#39;</code> instead with the differences we saw above.</p><h2 id="manipulating-numbers">Manipulating Numbers</h2><p>After these register, substitution, and mark shenanigans, here’s a lighter subject: adding (or subtracting) numbers.</p><p>Here’s a bunch of NORMAL mode keystrokes to do exactly that:</p><ul><li><code>CTRL+a</code> - Increase <em>the first digit or number</em> on the line.</li><li><code>CTRL+x</code> - Decrease <em>the first digit or number</em> on the line.</li></ul><p>You can also use these keystrokes in VISUAL mode:</p><ul><li><code>g CTRL+a</code> - Same as <code>CTRL+a</code> unless you have several lines selected. In that case, the first number of each line will be <em>incremented sequentially</em>.</li><li><code>g CTRL+x</code> - Same as <code>CTRL+x</code> unless you have several lines selected. In that case, the first number of each line will be <em>decremented sequentially</em>.</li></ul><p>To illustrate a bit better the last two keystrokes, let’s say that you have this amazing content in your beloved Vim:</p><pre><code>1. Take some red flowers.
1. Add some eggs.
1. Forget about it and go back to your computer.
</code></pre><p>If you select in VISUAL mode the last two lines and hit <code>g CTRL+a</code>, you’ll get:</p><pre><code>1. Take some red flowers.
2. Add some eggs.
3. Forget about it and go back to your computer.
</code></pre><p>You can also prefix a count to the command to add a precise amount. For example, <code>12 CTRL+a</code> will add 12 to the first number of the current line.</p><p>An important note: these keystrokes can also work on unsigned binary, octal, and hexadecimal numbers, as well as <em>alphabetical characters</em>. Their behaviors depend on the value of the option <code>nrformats</code>. For these keystrokes to behave as described in this article, you shouldn’t have <code>alpha</code> as part of the value of <code>nrformats</code>, or you’ll increment (or decrement) the first <em>alphabetical character</em> of the line.</p><p>Personally, I think it’s better to exclude alphabetical characters, but in any case, I would recommend you to read Vim’s help to learn more about that. As always.</p><div><div><ul><li><code>:help CTRL-A</code></li><li><code>:help CTRL-X</code></li><li><code>:help nrformats</code></li></ul></div></div><h2 id="sorting-text">Sorting Text</h2><p>What about a little dessert? A nice command to sort text directly in Vim, perhaps? Here are the commands:</p><p><code>:sort</code> or <code>:sor</code> - Sort lines depending on a range. If no range is given, all lines are sorted.
<code>:sort!</code> or <code>:sor!</code> - Reverse the order.</p><p>You can add some options to this command. Here are the most useful ones:</p><ul><li><code>i</code> - Ignore Case.</li><li><code>n</code> - Sort depending on the first decimal on the line.</li><li><code>f</code> - Sort depending on the first float on the line.</li><li><code>/pattern/</code> - Sort depending on what comes after the match.</li><li><code>r</code> - Combined with <code>/pattern/</code>, the sort depending on the matching pattern.</li></ul><p>For example, if you have a CSV (with comma <code>,</code> as separator) and you want to sort every line depending on the second column, you can run something like this:</p><pre><code>:sort /[^,]*,/
</code></pre><p>How about sorting the following list depending on the numbers of each line?</p><pre><code>Take some red flowers (1).
Forget about it and go back to your computer (3).
Add some eggs (2).
</code></pre><p>Running <code>:sort n</code> will have the following result:</p><pre><code>Take some red flowers (1).
Add some eggs (2).
Forget about it and go back to your computer (3).
</code></pre><p>As always, there are many subtleties involved here. If you want to dig deeper, you know what you should do: fire up this Vim’s help and enjoy the depth of its infinity!</p><h2 id="are-you-a-vim-master-now">Are You a Vim Master Now?</h2><p>We can now make two assumptions:</p><ol><li>Compared to your old self, you might be more of a master than before.</li><li>Compared to many, you still have a long road ahead of practice and learning.</li></ol><p>But here’s the most important: you shouldn’t care about the second point. Always compare yourself to your past self, not to the others. Continue to walk on your own road, and you’ll get your enlightenment. You’ll then build your own Mouseless Development environment, you’ll move to a comfy cave in the Himalaya, alone, living a life of vow, giving your whole soul to the study of the Almighty Vim.</p><p>What did we learn in this article?</p><ul><li>The letter “g” in Vim is a bit like a magic wand:<ul><li>There are many useful keystrokes which begin with “g”.</li><li>The flag <code>g</code> is often used with the substitute command.</li><li>The global command <code>:g</code> is really powerful to apply a command to some precise content.</li></ul></li><li>Ranges allow you to execute many commands on a bunch of contiguous lines.</li><li>The quickfix list is a global list of positions in different files. You can apply any command to them with <code>:cdo</code>.</li><li>You can see the entries of a quickfix list using the quickfix window.</li><li>Location lists are similar to quickfix lists, except that you can have one location list (and one location window) per window open.</li><li>You can use the substitute command <code>:s</code> to replace a pattern (regex) with a replacement. Prefer <code>:sm</code> if you want to use a regex or <code>:sno</code> if you don’t.</li><li>You can use marks to add some surgical precision in what you want to do.</li></ul><p>To reward your tenacity and resilience for reading the whole article, I’ve a last tip for you: <code>:help ex-cmd-index</code> will list all the commands available in Vim.</p><p>Vim is easy to learn but hard to master: that’s great, because we never stop improving!</p></section></article></div></div>
  </body>
</html>
