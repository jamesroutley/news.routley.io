<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iximiuz.com/en/posts/kubernetes-vs-virtual-machines/">Original</a>
    <h1>Kubernetes reinvented virtual machines in a good sense</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>There are lots of posts trying to show how <strong>simple</strong> it is to get started with Kubernetes. But many of these posts use <strong>complicated</strong> Kubernetes jargon for that, so even those with some prior server-side knowledge might be bewildered. Let me try something different here. Instead of explaining one unfamiliar matter (<em>how to run a web service in Kubernetes?</em>) with another (<em>you just need a manifest, with three sidecars and a bunch of gobbledygook</em>), I&#39;ll try to reveal how Kubernetes is actually a natural development of the good old deployment techniques.</p>
<p>If you already know how to run services using virtual machines, hopefully, you&#39;ll see that there&#39;s not much of a difference in the end. And if you&#39;re totally new to operating services at scale, following through the evolution of the technology might help you as well with the understanding of contemporary approaches.</p>
<p>As usual, this article is not meant to be comprehensive. Rather it&#39;s an attempt to summarize my personal experience and how my understanding of the domain has been forming over the years.</p>
<div><p>Join 2000+ happy subscribers receiving my Cloud Native round-up and get deep technical write-ups from this blog direct into your inbox.</p></div>
 <h2 id="how-to-deploy-services-with-virtual-machines">How to Deploy Services With Virtual Machines</h2>
<p>Back in 2010, when I had just started my career as a software engineer, it was pretty common to deploy applications using virtual (or, sometimes, bare-metal) machines.</p>
<p>You&#39;d take a scratch Linux VM, drop your <del>PHP</del> web app in there, put Nginx or Apache reverse proxy in front of it, and run a bunch of secondary daemons and cronjobs next to it.</p>
<p>Such a machine would represent a single <em>instance of a service</em>, or <strong><em>a box</em></strong> for brevity, and the <em>service</em> itself would be just a named group of identical machines distributed over a network. Depending on the scale of your business, you could have just a few, some tens, hundreds, or even thousands of boxes spread across multiple services serving production traffic.</p>
<div>
    <p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/box-and-service-2000-opt.png" alt="Service - a named group of identical boxes."/></p><p><i>A service&#39;s abstraction hides the app&#39;s complexity behind a single entrypoint.</i></p>
</div>


<h2 id="challenges-of-deploying-services-with-virtual-machines">Challenges of Deploying Services With Virtual Machines</h2>
<p>Often, the size of the machine fleet would define the ways <strong>provisioning</strong> (installing an OS and packages), <strong>scaling</strong> (spawning identical boxes), <strong>service discovery</strong> (hiding a pool of boxes behind a single name), and <strong>deployment</strong> (shipping new versions of code to boxes) were done.</p>
<p>If you were a small <del>and brave</del> company with just <a href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/">a few pet-like boxes</a>, you might find yourself provisioning new boxes seldomly and semi-manually. This would typically mean a <strong>low bus factor</strong> (due to the lack of automation), a <strong>poor security posture</strong> (due to the lack of periodic patches), and potentially <strong>long(er) disaster recovery</strong>. On the bright side, the administration costs would be quite low because scaling wouldn&#39;t be needed, your deployments would be simple (it&#39;s just a few boxes to deliver the code to), and the service discovery would rather be trivial (due to quite static pools of addresses).</p>
<p>For a company with a large herd of boxes, the reality would be somewhat different. A high number of machines would typically lead to a more <strong>frequent need to provision</strong> new boxes (more boxes simply means more breakage). You&#39;d invest in automation (the ROI would be quite high) and end up with <a href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/">many cattle-like boxes</a>. As a by-product of boxes being constantly recreated, you&#39;d increase the bus factor (a script cannot be hit by a bus) and improve the security posture (updates and patches would be applied automatically). On the darker side, <strong>inefficient scaling</strong> (due to uneven daily/yearly traffic distribution), <strong>overly complicated deployments</strong> (delivering code to many boxes quickly is hard), and <strong>fragile service discovery</strong> (have you tried running <a href="https://github.com/hashicorp/consul"><em>consul</em></a> or <a href="https://github.com/apache/zookeeper"><em>zookeeper</em></a> at scale?) would lead to higher operational costs.</p>
<p>The early cloud offerings like Amazon Elastic Compute Cloud (EC2) allowed spinning up (and down) machines faster; machine images made with <em>packer</em> and customized with <em>cloud-init</em> made the provisioning slightly easier; automation tools like <em>puppet</em> and <em>ansible</em> enabled applying infrastructure changes and delivering new versions of software at scale. However, there was still plenty of room for improvement.</p>
<h2 id="what-problems-docker-containers-solve">What Problems Docker Containers Solve</h2>
<p>Back in the day, it was pretty common to have <strong>different production and development environments</strong>. That would lead to situations when an app might work locally on your stuffed Debian machine but fail to start on vanilla CentOS in production due to a missing dependency. Conversely, you may have quite some trouble installing the app&#39;s dependencies locally, but running a pre-provisioned virtual machine per service for development would be infeasible due to high resource requirements.</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/container-2000-opt.png" alt="Container - a box for a single application."/></p><p>The massiveness of virtual machines was a problem even in production. Having a virtual machine per service might lead to <strong>lower than optimal resource utilization</strong> and/or sizable <strong>storage and compute overhead</strong>, but putting multiple services into one box could make them conflict. The <strong>multi-minute startup time</strong> could also use some improvement.</p>
<p><u>The world obviously needed a more lightweight version of the box.</u></p>
<p>And that&#39;s where The Containers came in. Much like VMs that allowed slicing a bare-metal server into several smaller (and cheaper) machines, containers split a single Linux box into tens or even hundreds of isolated environments.</p>
<p>From within a container, it may feel like you&#39;ve got a virtual machine of your own, with your favorite Linux distro. Well, at least at first sight. And from the outside, containers were just regular processes running on the host operating system and sharing its kernel.</p>
<p>ðŸ‘‰ Further reading: <a href="https://iximiuz.com/en/posts/not-every-container-has-an-operating-system-inside/">Not Every Container Has an Operating System Inside</a>.</p>
<p>The ability to pack an application with all its dependencies, including a certain version of the OS userland and libraries, ship it as a container image, and run in a standardized execution environment wherever Docker (or alike) is installed <strong>greatly improved the reproducibility of workloads</strong>.</p>
<p>Due to the lightweight implementation of the container boundaries, the computational <strong>overhead got significantly reduced</strong>, allowing a single production server to run tens of different containers potentially belonging to several (micro)services. At the expense of the reduced security, of course.</p>
<p>The image <strong>storage and distribution also became more efficient</strong>, thanks to the immutable and shared image layers.</p>
<p>ðŸ‘‰ Further reading: <a href="https://iximiuz.com/en/posts/you-dont-need-an-image-to-run-a-container/">You Don&#39;t Need an Image To Run a Container</a>.</p>
<p>To an extent, containers also <strong>changed the way provisioning was done</strong>. With (carelessly written) Dockerfiles and (magical) tools like <a href="https://github.com/google/ko"><em>ko</em></a> and <a href="https://github.com/GoogleContainerTools/jib"><em>Jib</em></a>, the responsibility greatly shifted toward developers, simplifying the requirements for production VMs - from the developer standpoint, you&#39;d just need a Docker- (or later OCI-) compatible runtime to run your app, so you wouldn&#39;t annoy your sysadmin friends with asks to install a certain version of Linux or system packages anymore.</p>
<p>On top of that, containers accelerated the development of alternative ways to run services. There is <a href="https://www.lastweekinaws.com/blog/the-17-ways-to-run-containers-on-aws/">17 ways to run containers on AWS now</a>, with the better part of them being fully serverless, and in simple enough cases, you could just go with Lambda or Fargate and benefit from cattle-like boxes! ðŸŽ‰</p>
<h2 id="what-problems-containers-dont-solve">What Problems Containers Don&#39;t Solve</h2>
<p>Containers turned out to be quite a handy dev tool. It was also simpler and faster to build a container image than to build a VM. Combined with the old organizational problem of how to separate responsibilities between teams efficiently, it led to a significant increase in the average number of services a typical enterprise would have and a similar increase in the number of boxes per service.</p>
<p>And for those of us who didn&#39;t jump on the Fargate/Lambda train, it <strong>complicated scaling, service discovery, and deployments even further</strong>...</p>
<p>The form of containers popularized by Docker was actually pretty deceptive. At first sight, it may look like you got a cheap dedicated VM per instance of your service. However, if such an instance required <em>sidecars</em> (like a local reverse proxy running in front of your web app to terminate TLS connections or a daemon loading secrets and/or warming up caches), you&#39;d instantly feel the <del>pain</del> difference of containers from the virtual machines.</p>
<p><strong>Docker containers have been deliberately designed to <em>contain</em> just one application.</strong> One container - one Nginx; one container - one Python web server; one container - one daemon. The lifecycle of a container would be bound to the lifecycle of that application. And running an init process like <em>systemd</em> as a top-level entrypoint <a href="https://docs.docker.com/config/containers/multi-service_container/">was specifically discouraged</a>.</p>
<p>So, to recreate a VM-box from the diagram at the beginning of this article, you&#39;d need to have three coordinated container-boxes with a shared network stack (well, at least the <em>localhost</em> needs to be the same). And to run two instances of the service, you&#39;d need six containers in two groups by three!</p>
<p>From the scaling standpoint, it means <strong>we would need to scale up (and down) some containers together</strong>. Deployment also would need to happen synchronously. The new version of the web app container simply may start using a new port number and become incompatible with the old version of the reverse proxy container.</p>
<p><u>We clearly missed an abstraction here that would be as lightweight as containers but as expressive as the original VM boxes.</u></p>
<p>Additionally, <strong>containers per se also didn&#39;t provide any means to group boxes into services</strong>. But they contributed to the increase in the headcount of boxes! Docker raced to solve these problems with its Swarm product, but another system won...</p>
<h2 id="kubernetes-solved-it-all-or-not">Kubernetes Solved It All... Or Not?</h2>
<p>Instead of inventing new ways to run containers, Kubernetes designers apparently decided to recreate the good old VM-based service architecture but using containers as building blocks for that. Well, at least this is my take on it.</p>
<p>YMMV, of course, but to me, as someone with prior VM experience, many initial Kubernetes ideas would start looking familiar as soon as I&#39;d get through the new terminology and figure out the analogous concepts.</p>
<h3 id="kubernetes-pods-are-the-new-virtual-machines">Kubernetes Pods Are The New Virtual Machines</h3>
<p>Let&#39;s start with the Pod abstraction. A Pod is the smallest thing you could run in Kubernetes. The simplest Pod definition would look as follows:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.20.1
    ports:
    - containerPort: 80
</code></pre>
<p>At first sight, the above manifest just says what image to run (and how to name it). But notice how the <code>containers</code> attribute is a list! Now, getting back to that <code>nginx + web app</code> example, in Kubernetes, instead of running an extra Pod for the web app container, you can simply put the reverse proxy and the app itself in one box:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: foo-instance-1
spec:
  containers:
  - name: nginx            # &lt;-- sidecar container
    image: nginx:1.20.1
    ports:
    - containerPort: 80
  - name: app              # &lt;-- main container
    image: app:0.3.2
</code></pre>
<p>Pods, however, aren&#39;t just groups of containers. The isolation borders between containers in a Pod are weakened. Much like regular processes running on a VM, containers in a Pod can communicate freely over <code>localhost</code> or using traditional IPC means. At the same time, each container still has an isolated root filesystem keeping the benefits of packaging apps with their dependencies. To me, it looks like an attempt to take the best parts of the VM- and container- worlds at the same time:</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/pod-2000-opt.png" alt="Kubernetes Pod - an abstraction close to the good old virtual machine."/>
</p>

<p>ðŸ‘‰ Further reading: <a href="https://iximiuz.com/en/posts/containers-vs-pods/">Containers vs. Pods - Taking a Deeper Look</a>.</p>
<h3 id="scaling-and-deploying-pods-is-simple">Scaling and Deploying Pods Is Simple</h3>
<p>Now, when we got the new box, how can we run multiple of them to make up a service? In other words, how to do scaling and deployment in Kubernetes?</p>
<p>Turns out, it&#39;s pretty simple, at least in the basic scenarios. Kubernetes introduces a handy abstraction called Deployment. A minimal Deployment definition consists of a name and a Pod template, but it&#39;s also very common to specify the desired number of Pod copies:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: foo-deployment-1
  labels:
    app: foo
spec:
  replicas: 10
  selector:
    matchLabels:
      app: foo
  template:
    metadata:
      labels:
        app: foo
    spec:
      &lt;...Pod definition comes here&gt;
</code></pre>
<p>The great part about Kubernetes is that as a developer, you don&#39;t care about servers (or, Nodes in Kubernetes&#39; terminology). You think and operate in terms of groups of Pods, and they get distributed (and redistributed) across the cluster Nodes automatically:</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/deployment-2000-opt.png" alt="Kubernetes Deployment - a means to replicate Pods."/>
</p>

<p>This makes Kubernetes rather a serverless piece of technology. But at the same time, Pods look and behave much like the familiar VMs from the past (except that you don&#39;t need to manage them), so you can design and reason about your applications in familiar abstractions:</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/node-2000-opt.png" alt="Kubernetes Node - a server constituting the cluster."/>
</p>


<h3 id="built-in-service-discovery-rocks">Built-In Service Discovery Rocks</h3>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/service-2000-opt.png" alt="Kubernetes Service - a named group of Pods."/></p><p>Kubernetes designers definitely knew that it&#39;s not enough to just spin up N copies of a box and call it a service. Clients should be able to access the service using a single (potentially logical) name, and the service discovery system should be able to translate this name into a certain IP address (be it a load balancer fencing the boxes or a certain instance of the service).</p>
<p>In the past, you&#39;d need a separate (and quite demanding) solution for that. However, Kubernetes has this functionality built in, and the default implementation is decent! It can also be extended with a service mesh like <em>Linkerd</em> or <em>Istio</em>, making it even more powerful.</p>
<p>ðŸ‘‰ Further reading: <a href="https://iximiuz.com/en/posts/service-discovery-in-kubernetes/">Service Discovery in Kubernetes</a>.</p>
<p>The only thing you need to turn a group of Pods into a service is to create a Service object (no pun intended).</p>
<p>Here is what a simple Kubernetes Service definition could look like:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: foo
spec:
  selector:
    app: foo
  ports:
    - protocol: TCP
      port: 80
</code></pre>
<p>The above manifest allows accessing any Pods labeled as <code>app=foo</code> (and running in the <code>default</code> namespace) using a DNS name like <code>foo.default.svc.cluster.local</code>. And it&#39;s all without any extra piece of software installed in the cluster!</p>
<p>Notice how the Service definition doesn&#39;t mention Deployments anywhere. Much like Deployment itself, it operates in terms of Pods and labels, and this makes it quite powerful! For instance, good old blue/green or canary deployments in Kubernetes could be achieved by having two Deployment objects running a different version of the app image behind a single Service selecting Pods with a common label:</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/canary-2000-opt.png" alt="A single Kubernetes Service fronting two Deployments."/>
</p>

<p>And now, the funniest part - have you noticed how Kubernetes services are indistinguishable from our old VM-based services? I&#39;m pretty sure it was done intentionally to leverage the existing <em>institutional</em> knowledge, with the whole industry being the institution in this case:</p>
<p><img src="https://iximiuz.com/kubernetes-vs-virtual-machines/vm-service-2000-opt.png" alt="A group of virtual machines constituting a service."/>
</p>

<h3 id="kubernetes-as-a-service">Kubernetes as a Service</h3>
<p>So, is Kubernetes just like VMs, but simpler? Well, yes and no. Paraphrasing <a href="https://twitter.com/kelseyhightower">Kelsey Hightower</a>, we should differentiate between the complexity of driving a car and the complexity of repairing it. Many of us can drive cars, but very few are good at fixing engines. Luckily, there are dedicated shops for that! The same is applicable to Kubernetes.</p>
<p>Running a service using a managed Kubernetes offering like EKS or GKE is indeed similar but much simpler than using VMs. But if you have to maintain the actual servers behind Kubernetes clusters, it becomes a totally different story...</p>
<p>Or <a href="https://matt-rickard.com/dont-use-kubernetes-yet/">maybe you don&#39;t need Kubernetes yet</a>?</p>
<h2 id="summarizing">Summarizing</h2>
<p>Trying to improve the experience of running services on VMs, containers changed the way we package our software, drastically reduced requirements for server provisioning, and enabled alternative ways to deploy our workloads. But on their own, containers didn&#39;t become a solution for running services at scale. An extra layer of orchestration would still be required on top.</p>
<p>Kubernetes, as one of the container-native orchestration systems, recreated the familiar architectural patterns of the past using containers as basic building blocks. Kubernetes also smoothed some of the traditionally rough edges by providing built-in means for scaling, deployment, and service discovery. If you use Kubernetes today, you essentially rely on the same abstractions (<em>instances</em> and <em>services</em>) you&#39;d rely back in the days when VMs were mainstream.</p>
</div><div><p>Join 2000+ happy subscribers receiving my Cloud Native round-up and get deep technical write-ups from this blog direct into your inbox.</p></div></div>
  </body>
</html>
