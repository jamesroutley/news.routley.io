<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openai.com/blog/techniques-for-training-large-neural-networks/">Original</a>
    <h1>Techniques for Training Large Neural Networks</h1>
    
    <div id="readability-page-1" class="page"><article id="post-techniques-for-training-large-neural-networks">

  

  <section>
  <div>
    <section>
      
            
      
      <!--kg-card-begin: markdown--><p>Large neural networks are at the core of many recent advances in AI, but training them is a difficult engineering and research challenge which requires orchestrating a cluster of GPUs to perform a single synchronized calculation. As cluster and model sizes have grown, machine learning practitioners have developed an increasing variety of techniques to parallelize model training over many GPUs. At first glance, understanding these parallelism techniques may seem daunting, but with only a few assumptions about the structure of the computation these techniques become much more clear—at that point, you&#39;re just shuttling around opaque bits from A to B like a network switch shuttles around packets.</p>
<figure id="parallelism">
<div>
<div>
<div>
  <p>Data Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-a.svg"/>
</p></div>
<div>
  <p>Pipeline Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-b.svg"/>
</p></div>
<div>
  <p>Tensor Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-c.svg"/>
</p></div>
<div>
  <p>Expert Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-d.svg"/>
</p></div>
</div>
</div>
<div>
<div>
  <p>Data Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-a.svg"/>
</p></div>
<div>
  <p>Pipeline Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-b.svg"/>
</p></div>
<div>
  <p>Tensor Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-c.svg"/>
</p></div>
<div>
  <p>Expert Parallelism</p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/parallelism-d.svg"/>
</p></div>
</div>
</figure>
<p>An illustration of various parallelism strategies on a three-layer model. Each color refers to one layer and dashed lines separate different GPUs.</p>

<h2 id="no-parallelism">No Parallelism</h2>
<p>Training a neural network is an iterative process. In every iteration, we do a pass forward through a model&#39;s <a href="https://developer.nvidia.com/blog/deep-learning-nutshell-core-concepts/#layer">layers</a> to compute an output for each training example in a batch of data. Then another pass proceeds <a href="https://youtu.be/Ilg3gGewQ5U">backward</a> through the layers, propagating how much each parameter affects the final output by computing a <a href="https://youtu.be/IHZwWFHWa-w">gradient</a> with respect to each parameter. The average gradient for the batch, the parameters, and some per-parameter optimization state is passed to an optimization algorithm, such as <a href="https://arxiv.org/abs/1412.6980">Adam</a>, which computes the next iteration&#39;s parameters (which should have slightly better performance on your data) and new per-parameter optimization state. As the training iterates over batches of data, the model evolves to produce increasingly accurate outputs.</p>
<p>Various parallelism techniques slice this training process across different dimensions, including:</p>
<ul>
<li>Data parallelism—run different subsets of the batch on different GPUs;</li>
<li>Pipeline parallelism—run different layers of the model on different GPUs;</li>
<li>Tensor parallelism—break up the math for a single operation such as a matrix multiplication to be split across GPUs;</li>
<li>Mixture-of-Experts—process each example by only a fraction of each layer.</li>
</ul>
<p>(In this post, we&#39;ll assume that you are using GPUs to train your neural networks, but the same ideas apply to those using any other <a href="https://www.synopsys.com/ai/what-is-an-ai-accelerator.html">neural network accelerator</a>.)</p>
<h2 id="data-parallelism">Data Parallelism</h2>
<p><em>Data Parallel</em> training means copying the same parameters to multiple GPUs (often called &#34;workers&#34;) and assigning different examples to each to be processed simultaneously. Data parallelism alone still requires that your model fits into a single GPU’s memory, but lets you utilize the compute of many GPUs at the cost of storing many duplicate copies of your parameters. That being said, there are strategies to increase the effective RAM available to your GPU, such as temporarily offloading parameters to CPU memory between usages.</p>
<p>As each data parallel worker updates its copy of the parameters, they need to coordinate to ensure that each worker continues to have similar parameters. The simplest approach is to introduce blocking communication between workers: (1) independently compute the gradient on each worker; (2) <a href="https://tech.preferred.jp/en/blog/technologies-behind-distributed-deep-learning-allreduce/">average the gradients across workers</a>; and (3) independently compute the same new parameters on each worker. Step (2) is a blocking average which requires transferring quite a lot of data (proportional to the number of workers times the size of your parameters), which can hurt your training throughput. There are various <a href="https://arxiv.org/abs/1106.5730">asynchronous synchronization schemes</a> to remove this overhead, but they hurt learning efficiency; in practice, people generally stick with the synchronous approach.</p>
<h2 id="pipeline-parallelism">Pipeline Parallelism</h2>
<p>With <em>Pipeline Parallel</em> training, we partition sequential chunks of the model across GPUs. Each GPU holds only a fraction of parameters, and thus the same model consumes proportionally less memory per GPU.</p>
<p>It’s straightforward to split a large model into chunks of consecutive layers. However, there’s a sequential dependency between inputs and outputs of layers, so a naive implementation can lead to a large amount of idle time while a worker waits for outputs from the previous machine to be used as its inputs. These waiting time chunks are known as “bubbles,” wasting the computation that could be done by the idling machines.</p>
<figure id="model-parallelism">
<div>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/forward.svg"/>
    Forward
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/backward.svg"/>
    Backward
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/gradient-update.svg"/>
    Gradient update
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/idle.svg"/>
    Idle
  </p>
</div>
<div><p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/model-parallelism.svg"/>
</p></div>
<p>Illustration of a naive pipeline parallelism setup where the model is vertically split into 4 partitions by layer. Worker 1 hosts model parameters of the first layer of the network (closest to the input), while worker 4 hosts layer 4 (which is closest to the output). “F”, “B”, and “U” represent forward, backward and update operations, respectively. The subscripts indicate on which worker an operation runs. Data is processed by one worker at a time due to the sequential dependency, leading to large “bubbles” of idle time.</p>
</figure>
<p>We can reuse the ideas from data parallelism to reduce the cost of the bubble by having each worker only process a subset of data elements at one time, allowing us to cleverly overlap new computation with wait time. The core idea is to split one batch into multiple microbatches; each microbatch should be proportionally faster to process and each worker begins working on the next microbatch as soon as it’s available, thus expediting the pipeline execution. With enough microbatches the workers can be utilized most of the time with a minimal bubble at the beginning and end of the step. Gradients are averaged across microbatches, and updates to the parameters happen only once all microbatches have been completed.</p>
<p>The number of workers that the model is split over is commonly known as <em>pipeline depth</em>.</p>
<p>During the forward pass, workers only need to send the output (called activations) of its chunk of layers to the next worker; during the backward pass, it only sends the gradients on those activations to the previous worker. There’s a big design space of how to schedule these passes and how to aggregate the gradients across microbatches. <a href="https://arxiv.org/abs/1811.06965">GPipe</a> has each worker process forward and backward passes consecutively and then aggregates gradients from multiple microbatches synchronously at the end. <a href="https://cs.stanford.edu/~matei/papers/2019/sosp_pipedream.pdf">PipeDream</a> instead schedules each worker to alternatively process forward and backward passes.</p>
<figure id="pipeline-parallelism">
<div>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/forward.svg"/>
    Forward
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/backward.svg"/>
    Backward
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/gradient-update.svg"/>
    Update
  </p>
  <p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/idle.svg"/>
    Idle
  </p>
</div>
<div><div>
<h5>GPipe</h5>
<p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/gpipe.svg"/></p><h5>PipeDream</h5>
<p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/pipedream.svg"/>
</p></div></div>
<p>Comparison of GPipe and PipeDream pipelining schemes, using 4 microbatches per batch. Microbatches 1-8 correspond to two consecutive data batches. In the image, “(number)” indicates on which microbatch an operation is performed and the subscript marks the worker ID. Note that PipeDream gets more efficiency by performing some computations with stale parameters.</p>
</figure>
<h2 id="tensor-parallelism">Tensor Parallelism</h2>
<p>Pipeline parallelism splits a model “vertically” by layer. It&#39;s also possible to “horizontally” split certain operations within a layer, which is usually called <em>Tensor Parallel</em> training. For many modern models (such as the <a href="https://jalammar.github.io/illustrated-transformer/">Transformer</a>), the computation bottleneck is multiplying an activation batch matrix with a large weight matrix. <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">Matrix multiplication</a> can be thought of as dot products between pairs of rows and columns; it&#39;s possible to compute independent dot products on different GPUs, or to compute parts of each dot product on different GPUs and sum up the results. With either strategy, we can slice the weight matrix into even-sized “shards”, host each shard on a different GPU, and use that shard to compute the relevant part of the overall matrix product before later communicating to combine the results.</p>
<p>One example is <a href="https://nv-adlr.github.io/MegatronLM">Megatron-LM</a>, which parallelizes matrix multiplications within the Transformer&#39;s self-attention and MLP layers. <a href="https://arxiv.org/abs/2104.04473">PTD-P</a> uses tensor, data, and pipeline parallelism; its pipeline schedule assigns multiple non-consecutive layers to each device, reducing bubble overhead at the cost of more network communication.</p>
<p>Sometimes the input to the network can be parallelized across a dimension with a high degree of parallel computation relative to cross-communication. <a href="https://arxiv.org/abs/2205.05198">Sequence parallelism</a> is one such idea, where an input sequence is split across time into multiple sub-examples, proportionally decreasing peak memory consumption by allowing the computation to proceed with more granularly-sized examples.</p>
<h2 id="mixture-of-experts-moe">Mixture-of-Experts (MoE)</h2>
<p>With the <a href="https://arxiv.org/abs/1701.06538">Mixture-of-Experts (MoE)</a> approach, only a fraction of the network is used to compute the output for any one input. One example approach is to have many sets of weights and the network can choose which set to use via a gating mechanism at inference time. This enables many more parameters without increased computation cost. Each set of weights is referred to as “experts,” in the hope that the network will learn to assign specialized computation and skills to each expert. Different experts can be hosted on different GPUs, providing a clear way to scale up the number of GPUs used for a model.</p>
<figure id="moe">
<div><p><img src="https://cdn.openai.com/techniques-for-training-large-neural-networks/r1/moe.svg"/>
</p></div>
<p>Illustration of a mixture-of-experts (MoE) layer. Only 2 out of the <em>n</em> experts are selected by the gating network. (Image adapted from: <a href="https://arxiv.org/abs/1701.06538">Shazeer et al., 2017</a>)</p>
</figure>
<p><a href="https://arxiv.org/abs/2006.16668">GShard</a> scales an MoE Transformer up to 600 billion parameters with a scheme where only the MoE layers are split across multiple TPU devices and other layers are fully duplicated. <a href="https://arxiv.org/abs/2101.03961">Switch Transformer</a> scales model size to trillions of parameters with even higher sparsity by routing one input to a single expert.</p>
<h2 id="other-memory-saving-designs">Other Memory Saving Designs</h2>
<p>There are many other computational strategies to make training increasingly large neural networks more tractable. For example:</p>
<ul>
<li>
<p>To compute the gradient, you need to have saved the original activations, which can consume a lot of device RAM. <a href="https://arxiv.org/abs/1604.06174"><em>Checkpointing</em></a> (also known as activation recomputation) stores any subset of activations, and recomputes the intermediate ones just-in-time during the backward pass. This saves a lot of memory at the computational cost of at most one additional full forward pass. One can also continually trade off between compute and memory cost by <a href="https://arxiv.org/abs/2205.05198">selective activation recomputation</a>, which is checkpointing subsets of the activations that are relatively more expensive to store but cheaper to compute.</p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1710.03740"><em>Mixed Precision Training</em></a> is to train models using lower-precision numbers (most commonly <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">FP16</a>). Modern accelerators can reach much higher FLOP counts with lower-precision numbers, and you also save on device RAM. With proper care, the resulting model can lose almost no accuracy.</p>
</li>
<li>
<p><em>Offloading</em> is to temporarily offload unused data to the CPU or amongst different devices and later read it back when needed. Naive implementations will slow down training a lot, but sophisticated implementations will pre-fetch data so that the device never needs to wait on it. One implementation of this idea is <a href="https://arxiv.org/abs/1910.02054">ZeRO</a> which splits the parameters, gradients, and optimizer states across all available hardware and materializes them as needed.</p>
</li>
<li>
<p><em>Memory Efficient Optimizers</em> have been proposed to reduce the memory footprint of the running state maintained by the optimizer<!-- (as a baseline, Adam requires two parameters per model parameter)-->, such as <a href="https://arxiv.org/abs/1804.04235">Adafactor</a>.</p>
</li>
<li>
<p><em>Compression</em> also can be used for storing intermediate results in the network. For example, <a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/04/fiddle-gist-isca18.pdf">Gist</a> compresses activations that are saved for the backward pass; <a href="https://openai.com/blog/dall-e/">DALL·E</a> compresses the gradients before synchronizing them.</p>
</li>
</ul>
<hr/>
<p>At OpenAI, we are training and improving large models from the underlying infrastructure all the way to deployment them for real-world problems. If you’d like to put the ideas from this post into practice—especially relevant for our Scaling and Applied Research teams—we’re <a href="https://openai.com/careers/research-engineer/">hiring</a>!</p>

<!--kg-card-end: markdown-->
    </section>
  </div>
</section>
  






</article></div>
  </body>
</html>
