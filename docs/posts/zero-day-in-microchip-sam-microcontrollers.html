<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.recessim.com/view/ATSAM4C32">Original</a>
    <h1>Zero Day in Microchip SAM Microcontrollers</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div>

<h2><span id="Bypassing_Lock_-_Microchip/Atmel_SAM4C32"></span><span id="Bypassing_Lock_-_Microchip.2FAtmel_SAM4C32">Bypassing Lock - Microchip/Atmel SAM4C32</span></h2>
<p>Hash Salehi
</p>
<h3><span id="Introduction">Introduction</span></h3>
<p>This write-up will cover analysis of the <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.microchip.com/en-us/product/atsam4c32">Microchip (ATMEL) SAM4C32</a> microcontroller vulnerability that allows an attacker to gain unlocked JTAG access to a previously locked device. <b>This attack appears to affect many devices</b> (though not all) in the SAM family. It was discovered that essentially the same attack performed by <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.0x01team.com/hw_security/bypassing-microchip-atmel-sam-e70-s70-v70-v71-security/">0x01 Team</a> on the <a href="https://wiki.recessim.com/view/SAM_E70/S70/V70/V71" title="SAM E70/S70/V70/V71">SAM E70/S70/V70/V71</a> works on many SAM processors. <u><b>What&#39;s novel about this write-up is identification of the Reset pin as a side channel</b></u>.
</p><p>While the attack method used was voltage fault injection, I believe EMFI (electromagnetic fault injection) could also be a viable method to bypass security. EMFI generally permits attacks without the need to remove all the capacitors on the power rail. This is helpful when attacking devices where you don&#39;t want to alter the target board.
</p>
<hr/>
<h3><span id="Why_attack_the_SAM4C32?"></span><span id="Why_attack_the_SAM4C32.3F">Why attack the SAM4C32?</span></h3>
<p>The SAM4C32 is used in this <a target="_blank" rel="nofollow noreferrer noopener" href="https://wiki.recessim.com/view/Landis%2BGyr_Residential_Meter#Generation_5_smart_meter_based_on_ARM_Cortex-M_processor_.28FCCID_R7PEG1R1S6.29">Landis+Gyr Generation 5</a> smart meter. I have a <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.youtube.com/playlist?list=PLYlhncU2MojDY9gxU36pxNVkiylGGcbwq">long history</a> analyzing various aspects of these smart meters, previously extracting the firmware from a <a target="_blank" rel="nofollow noreferrer noopener" href="https://wiki.recessim.com/view/Landis%2BGyr_Residential_Meter#Generation_4_based_on_M16C_processor">Generation 4</a> smart meter which uses a <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.renesas.com/en/products/microcontrollers-microprocessors/other-mcus-mpus/m16c-family-mcus-r32c-m32c-m16c?srsltid=AfmBOopYkuccgftgBEKAShsPqJb-QtPUuRWoD_kkJeeiXn4Hu58Gz1gg">Renesas</a> (Mitsubishi) <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.renesas.com/document/dst/m16c62p-group-m16c62p-m16c62pt-datasheet?srsltid=AfmBOoqlOLBwHZgZmybUHh-ZRPPkXlD56RD8bMzujujykzkWiT1B8oPN">M30626FHPGP</a> processor. It is a M16C architecture and the extracted firmware proved challenging to reverse engineer with tools like Binary Ninja and Ghidra.
</p><p>ARM architecture is supported by more RE (reverse engineering) tools and has been analyzed by more people in the RE community. Therefore, I decided to extract the firmware from the SAM4C32 to further my analysis of smart meter technology.
</p>
<hr/>
<h3><span id="Locking_Mechanism">Locking Mechanism</span></h3>
<p>The SAM4C32 makes use of general-purpose non-volatile memory (GPNVM) bits to control locking, boot mode and memory plane selection as seen below.<a href="https://wiki.recessim.com/view/File:ATSAM4C32_Table_8-3.png"><img alt="" src="https://wiki.recessim.com/w/images/2/23/ATSAM4C32_Table_8-3.png" decoding="async" width="916" height="190" data-file-width="916" data-file-height="190"/></a>
</p>
<p><i><b>Below is extracted from Microchip datasheet DS60001717B.</b></i></p><blockquote>
<h4><span id="Security_Bit">Security Bit</span></h4>
<p>The SAM4C features a security bit based on a specific General-purpose NVM bit (GPNVM bit 0). When the security is enabled, any access to the Flash, SRAM, core registers and internal peripherals, either through the SW-DP/JTAG-DP interface or through the Fast Flash Programming Interface, is forbidden. This ensures the confidentiality of the code programmed in the Flash. 
</p><p>This security bit can only be enabled through the command “Set General-purpose NVM Bit 0” of the EEFC User Interface. Disabling the security bit can only be achieved by asserting the ERASE pin at 1, and after a full Flash erase is performed. When the security bit is deactivated, all accesses to the Flash, SRAM, Core registers, Internal Peripherals are permitted.
</p>
<h4><span id="SAM-BA_Boot">SAM-BA Boot</span></h4>
<p>The SAM-BA Boot is a default Boot Program for the master processor (CM4P0) which provides an easy way to program in-situ the onchip Flash memory. The SAM-BA Boot Assistant supports serial communication via the UART0 or USB Port for the SAM4C32. 
</p><p>The SAM-BA Boot provides an interface with SAM-BA Graphic User Interface (GUI). 
</p><p>
The SAM-BA Boot is in ROM and is mapped in Flash at address 0x0 when GPNVM bit 1 is set to 0.</p></blockquote><p>While my attack focused on targeting the security bit GPNVM 0, it may also be possible to target GPNVM1 to enter the boot-loader and extract the flash memory that way. In that case, a JTAG programmer would not be necessary. I have not tested to see if this works as of April 1, 2025.
</p><hr/>
<h3><span id="Reset_vs_Power_Cycle">Reset vs Power Cycle</span></h3>
<p>Some microcontrollers in the SAM series exhibit different behavior on the VDDCORE power rail when they are reset vs power cycled. I have verified the SAM4C32, SAM4S2A and 0x01 Teams <a href="https://wiki.recessim.com/view/SAM_E70/S70/V70/V71" title="SAM E70/S70/V70/V71">SAM E70/S70/V70/V71</a> all exhibit the behavior shown below. My hypothesis is any Microchip SAM series processor that mentions GPNVM in the datasheet is susceptible to this attack.
</p>
<h4><span id="Reset_Capture">Reset Capture</span></h4>
<p>This is my baseline for activity when the SAM4C32 is restarted. The purple reset trace (nRST) is toggled by an external device and we see the yellow VDDCORE activity that results as the chip boots up.
</p>
<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAM4C32_Reset.png"><img alt="" src="https://wiki.recessim.com/w/images/thumb/8/85/ATSAM4C32_Reset.png/612px-ATSAM4C32_Reset.png" decoding="async" width="612" height="359" srcset="/w/images/thumb/8/85/ATSAM4C32_Reset.png/918px-ATSAM4C32_Reset.png 1.5x, /w/images/8/85/ATSAM4C32_Reset.png 2x" data-file-width="1024" data-file-height="600"/></a></p><div><p>VDDCORE (Yellow) fluctuates due to processor activity upon reboot</p></div></div></div>

<h4><span id="Power_Cycle_Capture">Power Cycle Capture</span></h4>
<p>The following images are progressively zoomed in so you can see the activity of the reset line. The first image you can see all three lines going from low to high since we are applying power to the processor. The device controlling the reset line is set to a High-Z state so we can see what the processor is doing.
</p>
<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAM4C32_Power_Cycle_Z0.png"><img alt="" src="https://wiki.recessim.com/w/images/thumb/7/72/ATSAM4C32_Power_Cycle_Z0.png/612px-ATSAM4C32_Power_Cycle_Z0.png" decoding="async" width="612" height="359" srcset="/w/images/thumb/7/72/ATSAM4C32_Power_Cycle_Z0.png/918px-ATSAM4C32_Power_Cycle_Z0.png 1.5x, /w/images/7/72/ATSAM4C32_Power_Cycle_Z0.png 2x" data-file-width="1024" data-file-height="600"/></a></p><div><p>Zoomed out capture of power cycle</p></div></div></div>

<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAM4C32_Power_Cycle_Z1.png"><img alt="" src="https://wiki.recessim.com/w/images/thumb/2/2a/ATSAM4C32_Power_Cycle_Z1.png/612px-ATSAM4C32_Power_Cycle_Z1.png" decoding="async" width="612" height="359" srcset="/w/images/thumb/2/2a/ATSAM4C32_Power_Cycle_Z1.png/918px-ATSAM4C32_Power_Cycle_Z1.png 1.5x, /w/images/2/2a/ATSAM4C32_Power_Cycle_Z1.png 2x" data-file-width="1024" data-file-height="600"/></a></p><div><p>Medium zoom capture of power cycle</p></div></div></div>

<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAM4C32_Power_Cycle_Z2.png"><img alt="" src="https://wiki.recessim.com/w/images/thumb/4/47/ATSAM4C32_Power_Cycle_Z2.png/612px-ATSAM4C32_Power_Cycle_Z2.png" decoding="async" width="612" height="359" srcset="/w/images/thumb/4/47/ATSAM4C32_Power_Cycle_Z2.png/918px-ATSAM4C32_Power_Cycle_Z2.png 1.5x, /w/images/4/47/ATSAM4C32_Power_Cycle_Z2.png 2x" data-file-width="1024" data-file-height="600"/></a></p><div><p>Zoomed in capture of voltage fluctuation seen when processor asserts reset</p></div></div></div>

<hr/>
<h3><span id="Reset_Pin_as_a_Side_Channel">Reset Pin as a Side Channel</span></h3>
<p>The most interesting part of this attack was the discovery that the <i><b>reset pin goes low for the window of time you should insert a glitch</b></i> to bypass security!
</p><p>This seems to be the case for all Microchip/ATMEL SAM chips mentioning GPNVM in their datasheets. I have only verified the SAM4C32, SAM4S2A, and E70/S70/V70/V71 exhibit this behavior however.
</p><p>The time from power-up to reset asserting itself varies by chip. The SAM4C32 takes about 17mS while the SAM4S2A only takes 600uS. 
</p><p>The SAM E70/S70/V70/V71 takes about 1mS as seen below. 
Blue (3.3V), Red (VDDCORE), Green (Reset)
</p>
<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAME70_Power_Cycle.jpg"><img alt="" src="https://wiki.recessim.com/w/images/thumb/b/b3/ATSAME70_Power_Cycle.jpg/600px-ATSAME70_Power_Cycle.jpg" decoding="async" width="600" height="338" srcset="/w/images/thumb/b/b3/ATSAME70_Power_Cycle.jpg/900px-ATSAME70_Power_Cycle.jpg 1.5x, /w/images/b/b3/ATSAME70_Power_Cycle.jpg 2x" data-file-width="1200" data-file-height="675"/></a></p><div><p>Scope capture provided by Waleed at 0x01 Team</p></div></div></div>
<p>I should note that I only discovered this while setting up a different test trying to glitch the processor after resetting it. I like to watch the oscilloscope as I perform glitch attacks to see if any anomalies pop up that could inform future attacks. When I found 0x01 Team&#39;s research and realized I should be power cycling instead of resetting, the scope was already configured to monitor VDDCORE &amp; Reset. 
The first time I power cycled the chip it was clear the reset line activity was correlated in some way with the voltage fluctuation on VDDCORE.
</p>
<hr/>
<h3><span id="Voltage_Fault_Injection">Voltage Fault Injection</span></h3>
<p>The video below shows faults being injected into the VDDCORE supply approaching the voltage fluctuation. When it lands in the correct place on top of the fluctuation the process stops. It stops because JTAG was enabled on the processor and OpenOCD was able to connect halting the glitching script.
</p><p>The triggered traces jump around so much because I am triggering on the rising edge of VCC 3.3V and this rising edge varies for reasons such as the capacitance of the chipwhisperer breakout board being used and the power supply itself.
</p><p><video src="https://wiki.recessim.com/w/images/b/b8/ATSAM4C32_-_Oscilloscope_Glitch_Animation.mov" width="640" height="360" controls=""><a href="https://wiki.recessim.com/view/File:ATSAM4C32_-_Oscilloscope_Glitch_Animation.mov">https://wiki.recessim.com/view/File:ATSAM4C32_-_Oscilloscope_Glitch_Animation.mov</a></video><br/>
</p><p>The image below shows the aggressive glitch parameters used. This value was initially guessed and worked, narrower or wider glitches were not tested.
</p>
<div><div><p><a href="https://wiki.recessim.com/view/File:ATSAM4C32_Glitch_Z2_with_cursors.png"><img alt="" src="https://wiki.recessim.com/w/images/thumb/3/30/ATSAM4C32_Glitch_Z2_with_cursors.png/612px-ATSAM4C32_Glitch_Z2_with_cursors.png" decoding="async" width="612" height="359" srcset="/w/images/thumb/3/30/ATSAM4C32_Glitch_Z2_with_cursors.png/918px-ATSAM4C32_Glitch_Z2_with_cursors.png 1.5x, /w/images/3/30/ATSAM4C32_Glitch_Z2_with_cursors.png 2x" data-file-width="1024" data-file-height="600"/></a></p><div><p>Glitch width approximately 2uS</p></div></div></div>

<hr/>
<h3><span id="JTAG_Access">JTAG Access</span></h3>
<p>OpenOCD in Ubuntu and an ATMEL-ICE programmer were used to connect to the SAM4C32. Microchip Studio IDE in a Windows VM was used to set the security bit, although this functionality appears to be available in OpenOCD I never tested it.
</p><p>When the security bit is bypassed the following commands can be run, shown with their associated output
</p>
<h4><span id="at91sam4_info">at91sam4 info</span></h4>
<pre>&gt; at91sam4 info
    CKGR_MOR: [0x400e0420] -&gt; 0x00000008
	    MOSCXTEN:     0 [0x0000] (main xtal enabled: NO)
	    MOSCXTBY:     0 [0x0000] (main osc bypass: NO)
	    MOSCRCEN:     1 [0x0001] (onchip RC-OSC enabled: YES)
	     MOSCRCF:     0 [0x0000] (onchip RC-OSC freq: 4 MHz)
	    MOSCXTST:     0 [0x0000] (startup clks, time= 0.000000 uSecs)
	     MOSCSEL:     0 [0x0000] (mainosc source: internal RC)
	       CFDEN:     0 [0x0000] (clock failure enabled: NO)
   CKGR_MCFR: [0x400e0424] -&gt; 0x000107a0
	    MAINFRDY:     1 [0x0001] (main ready: YES)
	       MAINF:  1952 [0x07a0] (3.998 Mhz (32.768khz slowclk)
  CKGR_PLLAR: [0x400e0428] -&gt; 0x00003f00
	        DIVA:     0 [0x0000] 
	        MULA:     0 [0x0000] 
	PLLA Freq: (Disabled,mula = 0)
   CKGR_UCKR: [0x400e041c] -&gt; 0x00000000
    PMC_FSMR: [0x400e0470] -&gt; 0x00000000
    PMC_FSPR: [0x400e0474] -&gt; 0x00000000
     PMC_IMR: [0x400e046c] -&gt; 0x00000000
    PMC_MCKR: [0x400e0430] -&gt; 0x00000001
	         CSS:     1 [0x0001] mainosc (3.998 Mhz)
	        PRES:     0 [0x0000] (selected clock)
		Result CPU Freq: 3.998
    PMC_PCK0: [0x400e0440] -&gt; 0x00000000
    PMC_PCK1: [0x400e0444] -&gt; 0x00000000
    PMC_PCK2: [0x400e0448] -&gt; 0x00000000
    PMC_PCSR: [0x400e0418] -&gt; 0x00000000
    PMC_SCSR: [0x400e0408] -&gt; 0x00000003
      PMC_SR: [0x400e0468] -&gt; 0x00030018
 CHIPID_CIDR: [0x400e0740] -&gt; 0xa64d0ee0
	     Version:     0 [0x0000] 
	       EPROC:     7 [0x0007] Cortex-M4
	     NVPSIZE:    14 [0x000e] 2048K bytes
	    NVPSIZE2:     0 [0x0000] none
	    SRAMSIZE:    13 [0x000d] 256K Bytes
	        ARCH:   100 [0x0064] SAM4CxxC (100-pin version)
	      NVPTYP:     2 [0x0002] embedded flash memory
	       EXTID:     1 [0x0001] (exists: YES)
 CHIPID_EXID: [0x400e0744] -&gt; 0x00000000
   rc-osc: 4.000 MHz
  mainosc: 3.998 MHz
     plla: 0.000 MHz
 cpu-freq: 3.998 MHz
mclk-freq: 3.998 MHz
 UniqueId: 0x20000c00 0x01006df3 0x010046af 0x010046b3
</pre>
<h4><span id="reg">reg</span></h4>
<pre>&gt; reg
===== arm v7m registers
(0) r0 (/32): 0x00000000
(1) r1 (/32): 0x00000000
(2) r2 (/32): 0x00000000
(3) r3 (/32): 0x00000000
(4) r4 (/32): 0x00000000
(5) r5 (/32): 0x00000000
(6) r6 (/32): 0x00000000
(7) r7 (/32): 0x00000000
(8) r8 (/32): 0x00000000
(9) r9 (/32): 0x00000000
(10) r10 (/32): 0x00000000
(11) r11 (/32): 0x00000000
(12) r12 (/32): 0x00000000
(13) sp (/32): 0xffffffd8
(14) lr (/32): 0xfffffff9
(15) pc (/32): 0xfffffffe
(16) xPSR (/32): 0x01000003
(17) msp (/32): 0xffffffd8
(18) psp (/32): 0x00000000
(20) primask (/1): 0x00
(21) basepri (/8): 0x00
(22) faultmask (/1): 0x00
(23) control (/3): 0x00
===== Cortex-M DWT registers
</pre>
<h4><span id="at91sam4_gpnvm">at91sam4 gpnvm</span></h4>
<p>Note below GPNVM bit 0 says its current value is 0 due to the glitch, if the processor is reset we lose access and it goes back to 1.
</p>
<pre>&gt; at91sam4 gpnvm                                     
sam4-gpnvm0: 0
sam4-gpnvm1: 1
sam4-gpnvm2: 1
</pre>
<hr/>
<h3><span id="Other_Vulnerable_Devices">Other Vulnerable Devices</span></h3>
<p>Microchip (ATMEL) families
</p><p><a href="https://wiki.recessim.com/view/File:ATMEL_SAM_Family_Overview.jpg"><img alt="ATMEL SAM Family Overview.jpg" src="https://wiki.recessim.com/w/images/thumb/f/ff/ATMEL_SAM_Family_Overview.jpg/650px-ATMEL_SAM_Family_Overview.jpg" decoding="async" width="650" height="397" srcset="/w/images/thumb/f/ff/ATMEL_SAM_Family_Overview.jpg/975px-ATMEL_SAM_Family_Overview.jpg 1.5x, /w/images/thumb/f/ff/ATMEL_SAM_Family_Overview.jpg/1300px-ATMEL_SAM_Family_Overview.jpg 2x" data-file-width="1891" data-file-height="1155"/></a>
</p><p>This list is not exhaustive, there may be more that are vulnerable and do not show up in this main overview of devices provided by Microchip. Only the <b>bold</b> ones are confirmed, the others are assumed vulnerable because the datasheet specifies the use of GPNVM bits for security.
</p>
<ul><li><b>SAM E70/S70/V70/V71</b></li>
<li><b>SAM 4C</b></li>
<li>SAM 4E</li>
<li>SAM 4N</li>
<li><b>SAM 4S</b></li>
<li>SAM G51/G54/G55</li>
<li>SAM 3X/3A</li></ul>
<p>The following datasheets were reviewed and <i><b>did not</b></i> show the use of GPNVM bits for security protection. This does not mean they are secure, but this specific vulnerability may not be present.
</p>
<ul><li>SAM 4L</li>
<li>SAM L10/L11</li>
<li>SAM L21/L22</li>
<li>SAM C20/C21</li>
<li>SAM D10/D11/D21/DA1/D5x/E5x/D20</li></ul>
<hr/>
<h3><span id="Conclusion">Conclusion</span></h3>
<p>Many devices in the Microchip (ATMEL) SAM Family make use of GPNVM bits to secure access to the JTAG debug interface. This protection can be bypassed using voltage glitching allowing full access to the device. It appears this is a low-level hardware bug, likely not patchable in the field.
</p>
<h3><span id="Disclosure">Disclosure</span></h3>
<p>Full disclosure at time of discovery via YouTube. Enjoy!</p>
<!-- 
NewPP limit report
Cached time: 20250402160330
Cache expiry: 86400
Dynamic content: false
Complications: []
[SMW] In‐text annotation parser time: 0.002 seconds
CPU time usage: 0.065 seconds
Real time usage: 0.072 seconds
Preprocessor visited node count: 72/1000000
Preprocessor generated node count: 0/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 125/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key RECESSIM:pcache:idhash:1082-0!canonical and timestamp 20250402160331 and revision id 2943
 -->
</div></div></div>
  </body>
</html>
