<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stack-auth.com/blog/on-javascripts-weirdness">Original</a>
    <h1>On JavaScript&#39;s Weirdness</h1>
    
    <div id="readability-page-1" class="page"><div><div><blockquote>
<p>“JavaScript sucks because <code>&#39;0&#39; == 0</code>!”</p>
<p>- literally everyone ever</p>
</blockquote>
<p>Sure, that part of JavaScript sucks, but every JS setup these days contains a linter that yells at you for code like that.</p>
<p>Instead, I want to talk about some of the weirder quirks of JavaScript — those that are much more insidious than that — the kind of stuff you wouldn&#39;t find on r/ProgrammerHumor or a JS tutorial.</p>
<p>All of them can occur in any JavaScript/ECMAScript environment (so browser, Node.js, etc.), with or without <code>use strict</code> enabled. (If you&#39;re working on legacy projects without strict mode, you should run. And if you don&#39;t know where to: <a href="https://news.ycombinator.com/item?id=42308388">Stack Auth is hiring</a>.)</p>
<h2 id="-1-eval-is-worse-than-you-think">#1. eval is worse than you think</h2>
<p>How silly it would be to think that these two are the same:</p>
<pre><code>function a(s) {
  eval(&#34;console.log(s)&#34;);
}
a(&#34;hello&#34;);  // prints &#34;hello&#34;


function b(s) {
  const evalButRenamed = eval;
  evalButRenamed(&#34;console.log(s)&#34;);
}
b(&#34;hello&#34;);  // Uncaught ReferenceError: s is not defined
</code></pre>
<p>The difference is that the former has access to variables in the current scope, whereas the renamed version can only access the global scope.</p>
<p>Why? Turns out that <a href="https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation">ECMAScript&#39;s definition for function calls</a> has a hardcoded special case, which runs a slightly different algorithm when the function invoked is called <code>eval</code>:</p>
<p><img src="https://stack-auth.com/img/posts/05/eval-spec.png" alt="eval spec"/></p><p>I can&#39;t stress enough how insane it is to have this hack in the specification for <em>every single function call</em>! Although it goes without saying that any half-decent JS engine will optimize it, so while there is no direct performance penalty, it certainly makes build tools &amp; engines more complicated. (As an example, this means that <code>(0, eval)(...)</code> differs from <code>eval(...)</code>, so minifiers must consider this when removing seemingly dead code. Scary!)</p>
<hr/>
<h2 id="-2-js-loops-pretend-their-variables-are-captured-by-value">#2. JS loops pretend their variables are captured by value</h2>
<p>Yes, the title makes no sense, but you&#39;ll see what I mean in just a second. Let&#39;s start with an example:</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i));
}
// prints &#34;0 1 2&#34; — as expected

let i = 0;
for (i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i));
}
// prints &#34;3 3 3&#34; — what?
</code></pre>
<p>Why does it matter where the variable is defined? It&#39;s the same variable either way, right?</p>
<p>In any programming language, when you capture values with a lambda/arrow function, there are two ways to pass variables: By value (copy) or by reference (passing a pointer). Some languages, like C++, let you pick:</p>
<pre><code>// C++ code below:

// capture by value
int byValue = 0;
auto func1 = [byValue] { std::cout &lt;&lt; byValue &lt;&lt; std::endl; };
byValue = 1;
func1();
// prints 0, because the variable&#39;s value is copied

// capture by reference
int byReference = 0;
auto func2 = [&amp;byReference] { std::cout &lt;&lt; byReference &lt;&lt; std::endl; };
byReference = 1;
func2();
// prints 1, because the variable is captured by reference
</code></pre>
<p>That said, most high-level languages (JS, Java, C#, …) capture variables by reference:</p>
<pre><code>let byReference = 0;
const func = () =&gt; console.log(byReference);
byReference = 1;
func();
// prints 1
</code></pre>
<p>More often than not this is what you want, but it&#39;s particularly undesirable in loops. There, it&#39;s common you need to do something with the iterator variable in a callback function:</p>
<pre><code>// C# code below:
for (int i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; {
    Console.WriteLine(i);
  }, 1000 * i);
}
// prints &#34;3 3 3&#34; — probably not what you wanted
</code></pre>
<p>As a &#34;fix&#34;, the ECMAScript standard hacks for-loop variables to have a different behavior, but only if they&#39;re defined in the loop header:</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; {
    console.log(i);
  }, 1000 * i);
}
// prints &#34;0 1 2&#34;

// but it doesn&#39;t work if we factor out the loop variable:
let i = 0;
for (i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; {
    console.log(i);
  }, 1000 * i);
}
// prints &#34;3 3 3&#34;
</code></pre>
<p>I posted about this <a href="https://x.com/n2d4wastaken/status/1869122648661442859">on Twitter</a>, and a bunch of you told me that this &#34;makes sense&#34; if you understand how for-loops &amp; closures are defined in terms of scope in the ECMAScript standard. That&#39;s true, although it&#39;s weird in the sense that it really doesn&#39;t fit most people&#39;s intuition. More precisely, if you want to unroll a for-loop in JavaScript, this would be the spec-compliant way to do it:</p>
<pre><code>// intuitive way to unroll a for-loop (WRONG in JS)
let i = 0;
while (i &lt; 3) {
  // ... for-loop body ...
  i++;
}

// spec-compliant way to unroll a for-loop
let _iteratorVariable = 0;
while (_iteratorVariable &lt; 3) {
  let i = _iteratorVariable;
  // ... for-loop body ...
  i++;
  _iteratorVariable = i;
}
</code></pre>
<p>That said, the fact that nearly no one talks about it is a testament of how those &#34;hacks&#34; can sometimes be very useful. (TypeScript&#39;s type system has plenty of &#34;useful&#34; hacks like these, and I think that&#39;s part of why it&#39;s so popular despite its complexity — some day I should write a post about that.)</p>
<hr/>
<h2 id="-3-that-falsy-object">#3. That falsy object</h2>
<p>Common knowledge is that there are 8 falsy values in JavaScript: <code>false</code>, <code>+0</code>, <code>-0</code>, <code>NaN</code>, <code>&#34;&#34;</code>, <code>null</code>, <code>undefined</code>, and <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">0n</a></code>.</p>
<p>Oops, I lied. There&#39;s actually a ninth one, and it&#39;s an object:</p>
<pre><code>console.log(document.all); // prints HTMLAllCollection [&lt;html&gt;, &lt;head&gt;, ...]
console.log(Boolean(document.all)); // prints false
</code></pre>
<p>I almost didn&#39;t include this one in this post, because it only affects browsers. But it turns out that it&#39;s actually <a href="https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot">specified in the ECMAScript standard</a>, not in the DOM standard (where you&#39;d usually see browser-specific stuff), so I left it in:</p>
<p><img src="https://stack-auth.com/img/posts/05/document-all-spec.png" alt="document.all spec"/></p><p>Why? Because on old versions of Internet Explorer, <code>document.getElementById</code> was not available and instead there was a property called <code>document.all</code>, so a lot of code was written like this:</p>
<pre><code>if (document.all) {  // IE-specific
  // do something with document.all
} else {  // every other browser
  // do something with document.getElementById
}
</code></pre>
<p>To be compatible with IE, other browsers then went on to implement <code>document.all</code> too. However, it&#39;s much slower than <code>document.getElementById</code>, so those browsers decided that <code>document.all</code> should be falsy, in order to make code like the above take the fast path. Don&#39;t we love IE?</p>
<hr/>
<h2 id="-4-graphemes-string-iteration">#4. Graphemes &amp; string iteration</h2>
<p>It&#39;s relatively well-known that strings in JavaScript are UTF-16 encoded, which means that there are low- and high-surrogates. Essentially, it means that some characters take up two UTF-16 code units:</p>
<pre><code>const japanese = &#34;𠮷&#34;;
console.log(japanese.length);  // prints 2
console.log(japanese.charCodeAt(0));  // prints 55362
console.log(japanese.charCodeAt(1));  // prints 57271
</code></pre>
<p>Surrogates always come in groups of two, never more. So, sensibly, if you have <code>n</code> characters, then <code>String.prototype.length</code> will always be between <code>n</code> and <code>2n</code>, depending on how many surrogates there are.</p>
<p>But then what&#39;s the output of this?</p>
<pre><code>const family = &#34;👨‍👩‍👧‍👦‍👨‍👩‍👧‍👦&#34;;  // two family emojis
console.log(family.length);  // prints 23
</code></pre>
<p>If you know Unicode well, you&#39;ll know that surrogates don&#39;t tell the whole story — some characters (particularly emojis) consist of multiple Unicode code points (each of which may be a single UTF-16 code unit, or a surrogate pair).</p>
<p>Now, what if we want to iterate over them?</p>
<pre><code>const family = &#34;👨‍👩‍👧‍👦‍👨‍👩‍👧‍👦&#34;;
let count = 0;
for (const char of family) {
  count++;
}
console.log(count);  // prints 15
</code></pre>
<p>A different number? Clearly something is off here.</p>
<p>Okay, whatever, the new <code>Intl</code> APIs exist for this purpose and they fix this mess. Right?</p>
<pre><code>const family = &#34;👨‍👩‍👧‍👦‍👨‍👩‍👧‍👦&#34;;
const chars = new Intl.Segmenter().segment(family);
console.log([...chars].length);  // prints 1
</code></pre>
<p>Still not 2!</p>
<p>Essentially, there are four sensible notions of &#34;string length&#34;, and JavaScript mixes them all:</p>
<ol>
<li>23, the number of UTF-16 code units (most string functions, such as <code>.length</code>, <code>.split</code>, etc.)</li>
<li>15, the number of Unicode code points (when iterating over strings with <code>for</code>)</li>
<li>2, the number of <em>display characters</em> (may differ based on your browser&#39;s emoji support)</li>
<li>1, the number of <em>extended grapheme clusters</em> (<code>Intl.Segmenter</code>)</li>
</ol>
<p>If we paste the string above into a Unicode analyzer, it will make more sense:</p>
<pre><code>UTF-16:  0x55357  0x56424  0x08205  0x55357  0x56425  0x08205  0x55357  0x56423  0x08205  0x55357  0x56422  0x08205  0x55357  0x56424  0x08205  0x55357  0x56425  0x08205  0x55357  0x56423  0x08205  0x55357  0x56422
            └────────┘        │        └────────┘        │        └────────┘        │        └────────┘        │        └────────┘        │        └────────┘        │        └────────┘        │        └────────┘   
Unicode:       Man    zero-width-joiner  Woman   zero-width-joiner   Girl   zero-width-joiner    Boy           │           Man    zero-width-joiner  Woman   zero-width-joiner   Girl   zero-width-joiner    Boy      
                └─────────────────────────────────────────────────────────────────────────────────┘            │            └─────────────────────────────────────────────────────────────────────────────────┘       
Display:                                               Family                                           zero-width-joiner                                          Family                                             
                                                          └───────────────────────────────────────────────────────────────────────────────────────────────────────────┘                                               
Intl:                                                                                              Extended grapheme cluster                                                                                          
</code></pre>
<p>Essentially, each Unicode code point is exactly one or two UTF-16 code units. Every browser/font has its own rules on how to merge them into display characters, and the extended grapheme cluster algorithm tries to approximate that, but isn&#39;t perfect.</p>
<p>If you&#39;re curious, Henri Sivonen <a href="https://hsivonen.fi/string-length/">wrote this excellent blog post</a> on what other languages do, but sadly no solution is perfect because internationalization is a fundamentally hard problem. Although, I guess you can always just <a href="https://x.com/n2d4wastaken/status/1899277391048179965">get rid of Unicode altogether</a>.</p>
<hr/>
<h2 id="-5-sparse-arrays">#5. Sparse arrays</h2>
<p>You can just repeat commas in arrays to make some of the elements <code>undefined</code>:</p>
<pre><code>const sparse = [1, , , 4];
console.log(sparse[0], sparse[1], sparse[2], sparse[3]);  // prints 1 undefined undefined 4
</code></pre>
<p>Or not?</p>
<pre><code>const sparse = [1, , , 4];
sparse.forEach(e =&gt; console.log(e));  // prints 1 4 — doesn&#39;t print undefined
</code></pre>
<p>Let&#39;s compare it to a normal array:</p>
<pre><code>const dense = [undefined, undefined];
const sparse = [,,];

console.log(dense.length); // prints 2
console.log(sparse.length); // prints 2

console.log(dense); // prints [undefined, undefined]
console.log(sparse); // prints [empty × 2]

console.log(dense.map(x =&gt; 123)); // prints [123, 123]
console.log(sparse.map(x =&gt; 123)); // prints [empty × 2]
</code></pre>
<p>This is called a &#34;sparse array&#34;. The easiest way to understand what&#39;s going on is using <code>Object.entries</code>:</p>
<pre><code>console.log(Object.entries([1, undefined, undefined, 4]));
// prints [
//   [&#39;0&#39;, 1],
//   [&#39;1&#39;, undefined],
//   [&#39;2&#39;, undefined],
//   [&#39;3&#39;, 4]
// ]

console.log(Object.entries([1, , , 4]));
// prints [
//   [&#39;0&#39;, 1],
//   [&#39;3&#39;, 4]
// ]
</code></pre>
<p>JavaScript arrays are really just objects, and array elements are just properties on it. If some of the properties are missing, this completely messes up a lot of the built-in array methods. We call this a sparse array.</p>
<p>That said, you probably shouldn&#39;t use sparse arrays at all. Unfortunately, the <code>Array</code> constructor creates sparse arrays by default, leading to very unnatural code:</p>
<pre><code>const sparse = new Array(4);
console.log(sparse); // prints [empty × 4]

// this one doesn&#39;t work either:
const stillNotDense = new Array(4).map(x =&gt; 123);
console.log(stillNotDense); // prints [empty × 4]

// but you need to do this:
const dense = new Array(4).fill(undefined).map(x =&gt; 123);
console.log(dense); // prints [123, 123, 123, 123]

// or you could write this:
const alsoDense = Array.from({ length: 4 }, () =&gt; 123);
console.log(alsoDense); // prints [123, 123, 123, 123]
</code></pre>
<p>If that doesn&#39;t convince you, sparse arrays also have absolutely atrocious performance. Just don&#39;t use them in your code, ever, and you&#39;ll be fine.</p>
<hr/>
<h2 id="-6-weird-asi-quirks">#6. Weird ASI quirks</h2>
<p>What will this code print? (Hint: It&#39;s not 2 1 4 3.)</p>
<pre><code>function f1(a, b, c, d) {
  [a, b] = [b, a]
  [c, d] = [d, c]
  console.log(a, b, c, d)
}

f1(1, 2, 3, 4)
</code></pre>
<details><summary>Spoiler</summary><p>The result is <code>4 3 3 4</code>.</p></details>
<p>The fact that I am missing semicolons is a good hint at what&#39;s going on. There&#39;s a fairly complicated algorithm called <em>Automatic Semicolon Insertion</em> (ASI) that tries to guess with a bunch of heuristics where they&#39;re supposed to go.</p>
<pre><code>[a, b] = [b, a]
[c, d] = [d, c]

// is interpreted by ASI as:

[a, b] = [b, a][c, d] = [d, c]
              ^  ^
              |  |
              |  comma operator
              |
              array access

// which is the same as:

[a, b] = [4, 3]
[b, a][4] = [4, 3]
</code></pre>
<p>The <a href="https://tc39.es/ecma262/#sec-automatic-semicolon-insertion">exact mechanics of the ASI</a> are out of scope for this post, but in essence, it checks whether there&#39;s a syntax error, and if there is, and there&#39;s a newline right before it, it inserts a semicolon. Hence, if there&#39;s no syntax error, it usually won&#39;t insert a semicolon.</p>
<p>From the perspective of the ECMAScript standardization committee, this rule is quite restrictive. Adding new syntax to the language means that old syntax error may no longer be syntax errors, but because the ASI relies on syntax errors to occur at specific places, every new syntax could potentially break old code. For this purpose, there are special so-called <em>restricted productions</em> in the language, which always insert a semicolon if there&#39;s a newline, even if the code would be syntactically correct otherwise.</p>
<hr/>
<h2 id="et-cetera">Et cetera</h2>
<p>Here is a list of odd behaviors for which I didn&#39;t have enough space to write about:</p>
<ul>
<li>Anything that has to do with <code>==</code> and <code>!=</code></li>
<li>Anything that has to do with type coercion</li>
<li>Anything that has to do with <code>this</code></li>
<li>NaN is not equal to anything</li>
<li>+0 vs. -0</li>
<li>Anything that has to do with floating-point precision, or otherwise stuff that&#39;s covered by IEEE 754</li>
<li><code>typeof null</code> is <code>&#34;object&#34;</code></li>
<li>Anything that uses non-strict mode or <code>var</code></li>
<li>Returning primitive values from constructors</li>
<li>Prototype pollution</li>
<li><code>Array.sort</code> converting numbers to strings</li>
<li>...</li>
</ul>
<p>If you know any quirks I haven&#39;t listed here, I&#39;d love if you could let me know on <a href="https://x.com/n2d4wastaken">Twitter</a> or <a href="https://bsky.app/profile/konsti.xyz">Bluesky</a>. And if you haven&#39;t yet, check out <a href="https://stack-auth.com/blog/oauth-from-first-principles">our blog post on OAuth</a>!</p>
<!-- -->



</div></div></div>
  </body>
</html>
