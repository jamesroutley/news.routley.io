<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://suricrasia.online/blog/turning-a-keyboard-into/">Original</a>
    <h1>Turning a keyboard into a mouse with Libevdev</h1>
    
    <div id="readability-page-1" class="page"><article>



<figure>
	<img src="https://suricrasia.online/blog/turning-a-keyboard-into/keypad.jpg" alt="Cheap USB Keypad"/>
	<p>Cheap USB Keypad</p>
</figure>

<p>This is a short tutorial for using <code>libevdev</code> to capture all input events from a cheap USB keypad, and then using those events to synthesize new events for a virtual mouse device. We will be using C++ with <code>libevdev</code> on linux. On the way we&#39;ll be able to do other things such as launching arbitrary processes on keypress, and make it so the process can still capture input when run as a non-root user. This allows you to turn any keyboard into a macro keyboard with code you wrote yourself!</p>

<p>Although I&#39;m using an external keypad you can theoretically use any device. Just make sure not to grab your real keyboard/mouse, since the code we will write is going to capture <i>all</i> of its inputs, which means you won&#39;t be able to kill the process if you can&#39;t submit a <code>ctrl+c</code>!</p>

<h2>Prerequisites</h2>

<p>The first thing you&#39;ll want to do is make sure <code>libevdev</code> and its headers are installed. You&#39;ll also want to make sure <code>pkg-config</code> is installed so we can automatically generate the required <code>g++</code> arguments to build+link with it. On Debian/Ubuntu this is as simple as:</p>

<div><pre><span></span>sudo<span> </span>apt<span> </span>install<span> </span>libevdev2<span> </span>libevdev-dev<span> </span>pkg-config
</pre></div>


<p>This will be different for other, non-apt distributions.</p>

<h2>Initialization</h2>

<p>In order to initialize <code>libevdev</code>, we need to supply it with a <i>character device</i>. These are files in the directory <code>/dev/input/</code> and follow the pattern <code>event[0-9]+</code>. To start we&#39;ll try opening every one of these in a loop, and use libevdev to get information about it:</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;libevdev/libevdev.h&gt;</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>#include</span><span> </span><span>&lt;string&gt;</span>
<span>#include</span><span> </span><span>&lt;unistd.h&gt;</span>
<span>#include</span><span> </span><span>&lt;fcntl.h&gt;</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>	</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span> </span><span>=</span><span> </span><span>nullptr</span><span>;</span>

<span>	</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>string</span><span> </span><span>path</span><span> </span><span>=</span><span> </span><span>&#34;/dev/input/event&#34;</span><span> </span><span>+</span><span> </span><span>std</span><span>::</span><span>to_string</span><span>(</span><span>i</span><span>);</span>
<span>		</span><span>int</span><span> </span><span>fd</span><span> </span><span>=</span><span> </span><span>open</span><span>(</span><span>path</span><span>.</span><span>c_str</span><span>(),</span><span> </span><span>O_RDWR</span><span>|</span><span>O_CLOEXEC</span><span>);</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>fd</span><span> </span><span>==</span><span> </span><span>-1</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>break</span><span>;</span><span> </span><span>// no more character devices</span>
<span>		</span><span>}</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>libevdev_new_from_fd</span><span>(</span><span>fd</span><span>,</span><span> </span><span>&amp;</span><span>dev</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>std</span><span>::</span><span>string</span><span> </span><span>phys</span><span> </span><span>=</span><span> </span><span>libevdev_get_phys</span><span>(</span><span>dev</span><span>);</span>
<span>			</span><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>libevdev_get_name</span><span>(</span><span>dev</span><span>);</span>

<span>			</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>path</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>			</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;- phys: &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>phys</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>			</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;- name: &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>name</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>			</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>

<span>			</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>		</span><span>}</span>
<span>		</span><span>close</span><span>(</span><span>fd</span><span>);</span>
<span>	</span><span>}</span>
<span>	</span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-1-enumerating-devices.cpp">step-1-enumerating-devices.cpp</a>

<p>You can now build this with the following command:</p>

<div><pre><span></span>g++<span> </span>main.cpp<span> </span>-o<span> </span>main<span> </span><span>`</span>pkg-config<span> </span>--cflags<span> </span>--libs<span> </span>libevdev<span>`</span>
</pre></div>


<p>If you now run <code>sudo ./main</code> you should see it dump out all connected input devices.</p>

<div><pre>/dev/input/event0
- phys: PNP0C0C/button/input0
- name: Power Button

/dev/input/event1
- phys: LNXPWRBN/button/input0
- name: Power Button

/dev/input/event2
- phys: usb-0000:09:00.3-3/input3
- name: Blue Microphones Yeti Stereo Microphone Consumer Control

/dev/input/event3
- phys: usb-0000:02:00.0-9/input0
- name: Logitech USB Optical Mouse
...
</pre></div>

<h2>Grabbing inputs</h2>

<p>The keypad device I am interested in has the somewhat redundant name &#34;Usb KeyBoard Usb KeyBoard&#34;. When we spot this name in our loop, we want to be able to save the <code>struct libevdev*</code> pointer without freeing it. We&#39;ll wrap the enumeration code into a function called <code>find_device_by_name</code> so we can return the <code>struct libevdev*</code> when we find the requested device.</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;libevdev/libevdev.h&gt;</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>#include</span><span> </span><span>&lt;string&gt;</span>
<span>#include</span><span> </span><span>&lt;unistd.h&gt;</span>
<span>#include</span><span> </span><span>&lt;fcntl.h&gt;</span>

<span>struct</span><span> </span><span>libevdev</span><span>*</span><span> </span><span>find_device_by_name</span><span>(</span><span>const</span><span> </span><span>std</span><span>::</span><span>string</span><span>&amp;</span><span> </span><span>requested_name</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span> </span><span>=</span><span> </span><span>nullptr</span><span>;</span>

<span>	</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>string</span><span> </span><span>path</span><span> </span><span>=</span><span> </span><span>&#34;/dev/input/event&#34;</span><span> </span><span>+</span><span> </span><span>std</span><span>::</span><span>to_string</span><span>(</span><span>i</span><span>);</span>
<span>		</span><span>int</span><span> </span><span>fd</span><span> </span><span>=</span><span> </span><span>open</span><span>(</span><span>path</span><span>.</span><span>c_str</span><span>(),</span><span> </span><span>O_RDWR</span><span>|</span><span>O_CLOEXEC</span><span>);</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>fd</span><span> </span><span>==</span><span> </span><span>-1</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>break</span><span>;</span><span> </span><span>// no more character devices</span>
<span>		</span><span>}</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>libevdev_new_from_fd</span><span>(</span><span>fd</span><span>,</span><span> </span><span>&amp;</span><span>dev</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>libevdev_get_name</span><span>(</span><span>dev</span><span>);</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>name</span><span> </span><span>==</span><span> </span><span>requested_name</span><span>)</span><span> </span><span>{</span>
<span>				</span><span>return</span><span> </span><span>dev</span><span>;</span>
<span>			</span><span>}</span>
<span>			</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>			</span><span>dev</span><span> </span><span>=</span><span> </span><span>nullptr</span><span>;</span>
<span>		</span><span>}</span>
<span>		</span><span>close</span><span>(</span><span>fd</span><span>);</span>
<span>	</span><span>}</span>

<span>	</span><span>return</span><span> </span><span>nullptr</span><span>;</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>	</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span> </span><span>=</span><span> </span><span>find_device_by_name</span><span>(</span><span>&#34;Usb KeyBoard Usb KeyBoard&#34;</span><span>);</span>

<span>	</span><span>if</span><span> </span><span>(</span><span>dev</span><span> </span><span>==</span><span> </span><span>nullptr</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Couldn&#39;t find device!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>	</span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-2-find-by-name.cpp">step-2-find-by-name.cpp</a>

<p>For this usecase, it is sufficient to match on the &#34;name&#34; field of the device. However, if you want to capture multiple keyboards of the same make that all have the same name (e.g. if you&#39;re trying to make an <a href="https://www.youtube.com/watch?v=lIFE7h3m40U">emoji keyboard</a>) then you can use the &#34;phys&#34; field to get a more unique value, as it seems to include the USB address.</p>

<p>To capture the events coming from the device, it&#39;s as simple as using the <code>libevdev_grab</code> function and calling <code>libevdev_next_event</code> in a loop.</p>

<div><pre><span></span><span>void</span><span> </span><span>process_events</span><span>(</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span>)</span><span> </span><span>{</span>

<span>	</span><span>struct</span><span> </span><span>input_event</span><span> </span><span>ev</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>	</span><span>int</span><span> </span><span>status</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>	</span><span>auto</span><span> </span><span>is_error</span><span> </span><span>=</span><span> </span><span>[](</span><span>int</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>v</span><span> </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>v</span><span> </span><span>!=</span><span> </span><span>-</span><span>EAGAIN</span><span>;</span><span> </span><span>};</span>
<span>	</span><span>auto</span><span> </span><span>has_next_event</span><span> </span><span>=</span><span> </span><span>[](</span><span>int</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>v</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>;</span><span> </span><span>};</span>
<span>	</span><span>const</span><span> </span><span>auto</span><span> </span><span>flags</span><span> </span><span>=</span><span> </span><span>LIBEVDEV_READ_FLAG_NORMAL</span><span> </span><span>|</span><span> </span><span>LIBEVDEV_READ_FLAG_BLOCKING</span><span>;</span>

<span>	</span><span>while</span><span> </span><span>(</span><span>status</span><span> </span><span>=</span><span> </span><span>libevdev_next_event</span><span>(</span><span>dev</span><span>,</span><span> </span><span>flags</span><span>,</span><span> </span><span>&amp;</span><span>ev</span><span>),</span><span> </span><span>!</span><span>is_error</span><span>(</span><span>status</span><span>))</span><span> </span><span>{</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>!</span><span>has_next_event</span><span>(</span><span>status</span><span>))</span><span> </span><span>continue</span><span>;</span>

<span>		</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Got input_event&#34;</span><span>;</span>
<span>		</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34; type=&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>ev</span><span>.</span><span>type</span><span>;</span>
<span>		</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34; code=&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>ev</span><span>.</span><span>code</span><span>;</span>
<span>		</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34; value=&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>ev</span><span>.</span><span>value</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>	</span><span>}</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>	</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span> </span><span>=</span><span> </span><span>find_device_by_name</span><span>(</span><span>&#34;Usb KeyBoard Usb KeyBoard&#34;</span><span>);</span>

<span>	</span><span>if</span><span> </span><span>(</span><span>dev</span><span> </span><span>==</span><span> </span><span>nullptr</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Couldn&#39;t find device!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>libevdev_grab</span><span>(</span><span>dev</span><span>,</span><span> </span><span>LIBEVDEV_GRAB</span><span>);</span>

<span>	</span><span>process_events</span><span>(</span><span>dev</span><span>);</span>

<span>	</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>	</span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-3-grab-and-dump.cpp">step-3-grab-and-dump.cpp</a>

<p>Those <code>is_error</code> and <code>has_next_event</code> lambdas are an attempt at making the return value handling of <code>libevdev_next_event</code> more readable/concise. The return value is non-negative if an event was captured, otherwise the return value is an error code. However not all error codes are equal—the return value could be <code>-EAGAIN</code> which means you just need to retry. Therefore the while loop&#39;s condition checks if the return value is non-negative or -EAGAIN, and the body is skipped if we got EAGAIN.</p>

<p>Now if we run this code and I press on the keys of the keypad, I get output like this:</p>

<div><pre>Got input_event type=4 code=4 value=458849
Got input_event type=1 code=73 value=1
Got input_event type=0 code=0 value=0
Got input_event type=4 code=4 value=458849
Got input_event type=1 code=73 value=0
</pre></div>

<p>From here, it&#39;s a matter of detective work to determine what the events mean. By pressing on the buttons and observing the outputs, it&#39;s possible to infer the meanings of the fields of the <code>input_event</code> structure. For this keyboard, I figured out that when <code>ev.type == 1</code>, then the <code>code</code> field contains the scancode and the <code>value</code> field represents whether it&#39;s a key up, key down, or autorepeat event.</p>

<p>Since all other events can be ignored, I&#39;ll modify the <code>process_events</code> function to call a secondary function, called <code>process_key</code>, with the scancode and key state. I don&#39;t care about autorepeat events so I will filter those out.</p>

<div><pre><span></span><span>void</span><span> </span><span>process_key</span><span>(</span><span>int</span><span> </span><span>code</span><span>,</span><span> </span><span>bool</span><span> </span><span>is_down</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;scancode= &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>code</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34; is_down=&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>is_down</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>void</span><span> </span><span>process_events</span><span>(</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>struct</span><span> </span><span>input_event</span><span> </span><span>ev</span><span> </span><span>=</span><span> </span><span>{};</span>
<span>	</span><span>int</span><span> </span><span>status</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>	</span><span>auto</span><span> </span><span>is_error</span><span> </span><span>=</span><span> </span><span>[](</span><span>int</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>v</span><span> </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>v</span><span> </span><span>!=</span><span> </span><span>-</span><span>EAGAIN</span><span>;</span><span> </span><span>};</span>
<span>	</span><span>auto</span><span> </span><span>has_next_event</span><span> </span><span>=</span><span> </span><span>[](</span><span>int</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>v</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>;</span><span> </span><span>};</span>
<span>	</span><span>const</span><span> </span><span>auto</span><span> </span><span>flags</span><span> </span><span>=</span><span> </span><span>LIBEVDEV_READ_FLAG_NORMAL</span><span> </span><span>|</span><span> </span><span>LIBEVDEV_READ_FLAG_BLOCKING</span><span>;</span>

<span>	</span><span>while</span><span> </span><span>(</span><span>status</span><span> </span><span>=</span><span> </span><span>libevdev_next_event</span><span>(</span><span>dev</span><span>,</span><span> </span><span>flags</span><span>,</span><span> </span><span>&amp;</span><span>ev</span><span>),</span><span> </span><span>!</span><span>is_error</span><span>(</span><span>status</span><span>))</span><span> </span><span>{</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>!</span><span>has_next_event</span><span>(</span><span>status</span><span>))</span><span> </span><span>continue</span><span>;</span>

<span>		</span><span>if</span><span> </span><span>(</span><span>ev</span><span>.</span><span>type</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>bool</span><span> </span><span>is_up</span><span> </span><span>=</span><span> </span><span>ev</span><span>.</span><span>value</span><span> </span><span>==</span><span> </span><span>0</span><span>;</span>
<span>			</span><span>bool</span><span> </span><span>is_down</span><span> </span><span>=</span><span> </span><span>ev</span><span>.</span><span>value</span><span> </span><span>==</span><span> </span><span>1</span><span>;</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>is_down</span><span> </span><span>||</span><span> </span><span>is_up</span><span>)</span><span> </span><span>{</span><span> </span><span>// excludes autorepeat</span>
<span>				</span><span>process_key</span><span>(</span><span>ev</span><span>.</span><span>code</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>			</span><span>}</span>
<span>		</span><span>}</span>
<span>	</span><span>}</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-4-process-key.cpp">step-4-process-key.cpp</a>

<h2>Running external programs</h2>

<p>Now that we have a function that receives scancodes, we could launch arbitrary commands with the <code>system</code> function. Unfortunately, since we have to run our code as root to capture the keypad input, these commands will also run as root. This is especially a problem if you want to use this to launch X11 apps, since they won&#39;t run as your user and therefore not use your config files.</p>

<p>To get around this, we&#39;ll use <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities</a> to give our program the ability to change its group ID to <code>input</code>. Now we won&#39;t need sudo to run our program!</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;grp.h&gt;</span>
<span>...</span>
<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>	</span><span>auto</span><span> </span><span>grp</span><span> </span><span>=</span><span> </span><span>getgrnam</span><span>(</span><span>&#34;input&#34;</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>grp</span><span> </span><span>==</span><span> </span><span>nullptr</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;getgrnam(</span><span>\&#34;</span><span>input</span><span>\&#34;</span><span>) failed&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>
<span>	</span><span>int</span><span> </span><span>oldgid</span><span> </span><span>=</span><span> </span><span>getgid</span><span>();</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>setgid</span><span>(</span><span>grp</span><span>-&gt;</span><span>gr_gid</span><span>)</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;couldn&#39;t change group to input!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>struct</span><span> </span><span>libevdev</span><span> </span><span>*</span><span>dev</span><span> </span><span>=</span><span> </span><span>find_device_by_name</span><span>(</span><span>&#34;Usb KeyBoard Usb KeyBoard&#34;</span><span>);</span>

<span>	</span><span>if</span><span> </span><span>(</span><span>dev</span><span> </span><span>==</span><span> </span><span>nullptr</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;Couldn&#39;t find device!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>//drop back into old permissions</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>setgid</span><span>(</span><span>oldgid</span><span>)</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;couldn&#39;t switch back to old group!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>libevdev_grab</span><span>(</span><span>dev</span><span>,</span><span> </span><span>LIBEVDEV_GRAB</span><span>);</span>

<span>	</span><span>process_events</span><span>(</span><span>dev</span><span>);</span>

<span>	</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>	</span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-5-group-capabilities.cpp">step-5-group-capabilities.cpp</a>

<div><pre><span></span>sudo<span> </span>setcap<span> </span><span>&#34;cap_setgid=eip&#34;</span><span> </span>./main
./main<span> </span><span>#works!</span>
</pre></div>


<p>Unfortunately, <i>adding</i> the capability to a process still requires sudo, and the capabilities will be stripped away every time you rebuild. However now you can run arbitrary commands on particular keypresses and they will run as your user. Here&#39;s an example:</p>

<div><pre><span></span><span>void</span><span> </span><span>process_key</span><span>(</span><span>int</span><span> </span><span>code</span><span>,</span><span> </span><span>bool</span><span> </span><span>is_down</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;scancode= &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>code</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34; is_down=&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>is_down</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>

<span>	</span><span>if</span><span> </span><span>(</span><span>is_down</span><span> </span><span>&amp;&amp;</span><span> </span><span>code</span><span> </span><span>==</span><span> </span><span>69</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>system</span><span>(</span><span>&#34;xterm &amp;&#34;</span><span>);</span>
<span>	</span><span>}</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-5-group-capabilities.cpp">step-5-group-capabilities.cpp</a>

<p>For me this launches xterm when I press the num lock key on the keypad.</p>

<h2>Creating a virtual mouse</h2>

<p>In addition to providing a way to capture a device, libevdev also allows you to create virtual devices and events. Doing this is fairly straightforward, you create a device with <code>libevdev_new</code> and set its name and properties with the corresponding functions. For this project I will create a virtual mouse and encapsulate it in a class:</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;libevdev/libevdev-uinput.h&gt;</span>
<span>#include</span><span> </span><span>&lt;mutex&gt;</span>

<span>class</span><span> </span><span>VirtualMouse</span><span> </span><span>{</span>
<span>public</span><span>:</span>
<span>	</span><span>struct</span><span> </span><span>libevdev_uinput</span><span>*</span><span> </span><span>m_uinput</span><span> </span><span>=</span><span> </span><span>nullptr</span><span>;</span>
<span>	</span><span>std</span><span>::</span><span>mutex</span><span> </span><span>m_mouseMutex</span><span>;</span>
<span>public</span><span>:</span>
<span>	</span><span>VirtualMouse</span><span>()</span><span> </span><span>{}</span>
<span>	</span><span>~</span><span>VirtualMouse</span><span>()</span><span> </span><span>{</span>
<span>		</span><span>libevdev_uinput_destroy</span><span>(</span><span>m_uinput</span><span>);</span>
<span>	</span><span>}</span>

<span>	</span><span>int</span><span> </span><span>Init</span><span>()</span><span> </span><span>{</span>
<span>		</span><span>struct</span><span> </span><span>libevdev</span><span>*</span><span> </span><span>dev</span><span> </span><span>=</span><span> </span><span>libevdev_new</span><span>();</span>
<span>		</span><span>libevdev_set_name</span><span>(</span><span>dev</span><span>,</span><span> </span><span>&#34;Virtual Mouse&#34;</span><span>);</span>

<span>		</span><span>libevdev_enable_property</span><span>(</span><span>dev</span><span>,</span><span> </span><span>INPUT_PROP_POINTER</span><span>);</span>

<span>		</span><span>libevdev_enable_event_type</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_REL</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_X</span><span>,</span><span> </span><span>nullptr</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_Y</span><span>,</span><span> </span><span>nullptr</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_WHEEL</span><span>,</span><span> </span><span>nullptr</span><span>);</span>

<span>		</span><span>libevdev_enable_event_type</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_KEY</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_KEY</span><span>,</span><span> </span><span>BTN_LEFT</span><span>,</span><span> </span><span>nullptr</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_KEY</span><span>,</span><span> </span><span>BTN_RIGHT</span><span>,</span><span> </span><span>nullptr</span><span>);</span>
<span>		</span><span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span><span> </span><span>EV_KEY</span><span>,</span><span> </span><span>BTN_MIDDLE</span><span>,</span><span> </span><span>nullptr</span><span>);</span>

<span>		</span><span>int</span><span> </span><span>r</span><span> </span><span>=</span><span> </span><span>libevdev_uinput_create_from_device</span><span>(</span><span>dev</span><span>,</span><span> </span><span>LIBEVDEV_UINPUT_OPEN_MANAGED</span><span>,</span><span> </span><span>&amp;</span><span>m_uinput</span><span>);</span>
<span>		</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>
<span>		</span><span>return</span><span> </span><span>r</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>void</span><span> </span><span>Move</span><span>(</span><span>int</span><span> </span><span>rx</span><span>,</span><span> </span><span>int</span><span> </span><span>ry</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>lock_guard</span><span>&lt;</span><span>std</span><span>::</span><span>mutex</span><span>&gt;</span><span> </span><span>guard</span><span>(</span><span>m_mouseMutex</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_X</span><span>,</span><span> </span><span>rx</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_Y</span><span>,</span><span> </span><span>ry</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_SYN</span><span>,</span><span> </span><span>SYN_REPORT</span><span>,</span><span> </span><span>0</span><span>);</span>
<span>	</span><span>}</span>

<span>	</span><span>void</span><span> </span><span>Scroll</span><span>(</span><span>int</span><span> </span><span>rs</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>lock_guard</span><span>&lt;</span><span>std</span><span>::</span><span>mutex</span><span>&gt;</span><span> </span><span>guard</span><span>(</span><span>m_mouseMutex</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_REL</span><span>,</span><span> </span><span>REL_WHEEL</span><span>,</span><span> </span><span>rs</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_SYN</span><span>,</span><span> </span><span>SYN_REPORT</span><span>,</span><span> </span><span>0</span><span>);</span>
<span>	</span><span>}</span>

<span>	</span><span>void</span><span> </span><span>Click</span><span>(</span><span>int</span><span> </span><span>btn</span><span>,</span><span> </span><span>bool</span><span> </span><span>isDown</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>lock_guard</span><span>&lt;</span><span>std</span><span>::</span><span>mutex</span><span>&gt;</span><span> </span><span>guard</span><span>(</span><span>m_mouseMutex</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_KEY</span><span>,</span><span> </span><span>btn</span><span>,</span><span> </span><span>isDown</span><span>);</span>
<span>		</span><span>libevdev_uinput_write_event</span><span>(</span><span>m_uinput</span><span>,</span><span> </span><span>EV_SYN</span><span>,</span><span> </span><span>SYN_REPORT</span><span>,</span><span> </span><span>0</span><span>);</span>
<span>	</span><span>}</span>
<span>};</span>

<span>VirtualMouse</span><span> </span><span>g_mouse</span><span>;</span>
<span>...</span>
<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>...</span>
<span>	</span><span>// must init mouse before we drop permissions</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>g_mouse</span><span>.</span><span>Init</span><span>()</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;couldn&#39;t init mouse!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>

<span>	</span><span>//drop back into old permissions</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>setgid</span><span>(</span><span>oldgid</span><span>)</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>std</span><span>::</span><span>cerr</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;couldn&#39;t switch back to old group!&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>		</span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>	</span><span>}</span>
<span>...</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-6-virtual-mouse-clicks.cpp">step-6-virtual-mouse-clicks.cpp</a>

<p>As you can see, creating a device is a simple—if verbose—process of enabling all the right properties, event types, and event codes. If you wanted to make a keyboard, you need to manually enable every individual scancode you intend to generate an event for.</p>

<p>Now that we have our mouse, we can click its buttons when certain keys of the keypad are pressed:</p>

<div><pre><span></span><span>void</span><span> </span><span>process_key</span><span>(</span><span>int</span><span> </span><span>code</span><span>,</span><span> </span><span>bool</span><span> </span><span>is_down</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>82</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_LEFT</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>96</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_RIGHT</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>83</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_MIDDLE</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-6-virtual-mouse-clicks.cpp">step-6-virtual-mouse-clicks.cpp</a>

<p>Neat!</p>

<h2>Moving the virtual mouse</h2>

<p>What I&#39;d like to do now is move the cursor around when the keypad buttons are used like arrow keys. This is more complicated than simply calling methods on the <code>g_mouse</code> object in <code>process_key</code>, since I want to have acceleration.</p>

<p>What we&#39;ll need is a thread to periodically synthesize and send mouse motion events, as well as a way for that thread to query what keys are currently pressed. To solve the second problem, we&#39;ll create a global <code>std::set&lt;int&gt;</code> variable to store all pressed keys, as well as a mutex to protect it.</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;set&gt;</span>
<span>...</span>
<span>std</span><span>::</span><span>set</span><span>&lt;</span><span>int</span><span>&gt;</span><span> </span><span>g_pressedKeys</span><span>;</span>
<span>std</span><span>::</span><span>mutex</span><span> </span><span>g_pressed_keys_mutex</span><span>;</span>

<span>void</span><span> </span><span>process_key</span><span>(</span><span>int</span><span> </span><span>code</span><span>,</span><span> </span><span>bool</span><span> </span><span>is_down</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>std</span><span>::</span><span>lock_guard</span><span>&lt;</span><span>std</span><span>::</span><span>mutex</span><span>&gt;</span><span> </span><span>guard</span><span>(</span><span>g_pressed_keys_mutex</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>is_down</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>g_pressedKeys</span><span>.</span><span>insert</span><span>(</span><span>code</span><span>);</span>
<span>	</span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>		</span><span>g_pressedKeys</span><span>.</span><span>erase</span><span>(</span><span>code</span><span>);</span>
<span>	</span><span>}</span>

<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>82</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_LEFT</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>96</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_RIGHT</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>	</span><span>if</span><span> </span><span>(</span><span>code</span><span> </span><span>==</span><span> </span><span>83</span><span>)</span><span> </span><span>g_mouse</span><span>.</span><span>Click</span><span>(</span><span>BTN_MIDDLE</span><span>,</span><span> </span><span>is_down</span><span>);</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-7-virtual-mouse-movement.cpp">step-7-virtual-mouse-movement.cpp</a>

<p>Now we can create a thread that periodically checks for pressed keys, and generates an appropriate mouse movement event.</p>

<div><pre><span></span><span>#include</span><span> </span><span>&lt;thread&gt;</span>
<span>#include</span><span> </span><span>&lt;chrono&gt;</span>
<span>#include</span><span> </span><span>&lt;atomic&gt;</span>
<span>#include</span><span> </span><span>&lt;math.h&gt;</span>
<span>...</span>
<span>std</span><span>::</span><span>atomic_bool</span><span> </span><span>g_run_mouse_thread</span><span>;</span>
<span>void</span><span> </span><span>mouse_thread_fn</span><span>(</span><span>void</span><span>*</span><span>)</span><span> </span><span>{</span>
<span>	</span><span>float</span><span> </span><span>rx</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>	</span><span>float</span><span> </span><span>ry</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>	</span><span>const</span><span> </span><span>float</span><span> </span><span>friction</span><span> </span><span>=</span><span> </span><span>0.85</span><span>;</span>
<span>	</span><span>const</span><span> </span><span>float</span><span> </span><span>accel</span><span> </span><span>=</span><span> </span><span>1.2</span><span>/</span><span>friction</span><span>;</span>
<span>	</span><span>while</span><span> </span><span>(</span><span>g_run_mouse_thread</span><span>)</span><span> </span><span>{</span>
<span>		</span><span>float</span><span> </span><span>dx</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>		</span><span>float</span><span> </span><span>dy</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>		</span><span>float</span><span> </span><span>rs</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>		</span><span>{</span>
<span>			</span><span>std</span><span>::</span><span>lock_guard</span><span>&lt;</span><span>std</span><span>::</span><span>mutex</span><span>&gt;</span><span> </span><span>guard</span><span>(</span><span>g_pressed_keys_mutex</span><span>);</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>77</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>rx</span><span> </span><span>+=</span><span> </span><span>accel</span><span>;</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>75</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>rx</span><span> </span><span>-=</span><span> </span><span>accel</span><span>;</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>76</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>ry</span><span> </span><span>+=</span><span> </span><span>accel</span><span>;</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>72</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>ry</span><span> </span><span>-=</span><span> </span><span>accel</span><span>;</span>

<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>78</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>rs</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>			</span><span>if</span><span> </span><span>(</span><span>g_pressedKeys</span><span>.</span><span>count</span><span>(</span><span>14</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>rs</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span>
<span>		</span><span>}</span>

<span>		</span><span>// resize movement vector to be length 1</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>fabs</span><span>(</span><span>dx</span><span>)</span><span>+</span><span>fabs</span><span>(</span><span>dy</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>accel</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>dx</span><span> </span><span>*=</span><span> </span><span>.7</span><span>;</span>
<span>			</span><span>dy</span><span> </span><span>*=</span><span> </span><span>.7</span><span>;</span>
<span>		</span><span>}</span>

<span>		</span><span>rx</span><span> </span><span>+=</span><span> </span><span>dx</span><span>;</span>
<span>		</span><span>ry</span><span> </span><span>+=</span><span> </span><span>dy</span><span>;</span>
<span>		</span><span>rx</span><span> </span><span>*=</span><span> </span><span>friction</span><span>;</span>
<span>		</span><span>ry</span><span> </span><span>*=</span><span> </span><span>friction</span><span>;</span>

<span>		</span><span>if</span><span> </span><span>(</span><span>fabs</span><span>(</span><span>rx</span><span>)</span><span>+</span><span>fabs</span><span>(</span><span>ry</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>g_mouse</span><span>.</span><span>Move</span><span>(</span><span>rx</span><span>,</span><span> </span><span>ry</span><span>);</span>
<span>		</span><span>}</span>
<span>		</span><span>if</span><span> </span><span>(</span><span>fabs</span><span>(</span><span>rs</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>			</span><span>g_mouse</span><span>.</span><span>Scroll</span><span>(</span><span>rs</span><span>);</span>
<span>		</span><span>}</span>
<span>		</span><span>std</span><span>::</span><span>this_thread</span><span>::</span><span>sleep_for</span><span>(</span><span>std</span><span>::</span><span>chrono</span><span>::</span><span>milliseconds</span><span>(</span><span>10</span><span>));</span>
<span>	</span><span>}</span>
<span>}</span>
<span>...</span>
<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>...</span>
<span>	</span><span>g_run_mouse_thread</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>	</span><span>std</span><span>::</span><span>thread</span><span> </span><span>mouse_thread</span><span>(</span><span>mouse_thread_fn</span><span>,</span><span> </span><span>nullptr</span><span>);</span>

<span>	</span><span>libevdev_grab</span><span>(</span><span>dev</span><span>,</span><span> </span><span>LIBEVDEV_GRAB</span><span>);</span>

<span>	</span><span>process_events</span><span>(</span><span>dev</span><span>);</span>

<span>	</span><span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>

<span>	</span><span>g_run_mouse_thread</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>
<span>	</span><span>mouse_thread</span><span>.</span><span>join</span><span>();</span>

<span>	</span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>

<a href="https://suricrasia.online/blog/turning-a-keyboard-into/step-7-virtual-mouse-movement.cpp">step-7-virtual-mouse-movement.cpp</a>

<p>Since we are now using threads, make sure to build with the <code>-pthread</code> argument.</p>

<p>And with that, our quest is a success! Here&#39;s a video of it in action:</p>

<video controls="" width="100%">
  <source src="./demo.mp4" type="video/mp4"/>
  <source src="./demo.webm" type="video/webm"/>
  Download the 
  <a href="https://suricrasia.online/blog/turning-a-keyboard-into/demo.webm">WEBM</a>
  or
  <a href="https://suricrasia.online/blog/turning-a-keyboard-into/demo.mp4">MP4</a>
  video.
</video>

<p>Admittedly it&#39;s very hard to control and it makes my wrists hurt. This could be a problem with the friction/acceleration settings I have, or it could just be this method of input isn&#39;t for me.</p>

<p>Once you have your input grabbing code exactly as you like it, you could install the program to your /usr/bin folder and add it as a startup app in your desktop environment. That way it will run on login and have access to your <code>DISPLAY</code>/<code>WAYLAND_DISPLAY</code> variable, and run any app you desire correctly.</p>

<p>You can find more information about libevdev on its <a href="https://www.freedesktop.org/software/libevdev/doc/0.5/modules.html">API documentation page</a>. You can also find all the code for this blog post on its <a href="https://github.com/blackle/libevdev-examples">github repo</a>.</p>

</article></div>
  </body>
</html>
