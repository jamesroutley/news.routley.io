<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/andyk/ht">Original</a>
    <h1>ht: Headless Terminal</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>ht</code> (short for <em>headless terminal</em>) is a command line program that wraps an arbitrary other binary (e.g. <code>bash</code>, <code>vim</code>, etc.) with a VT100 style terminal interface--i.e. a pseudoterminal client (PTY) plus terminal server--and allows easy programmatic access to the input and output of that terminal (via JSON over stdin/stdout). <code>ht</code> is built in rust and works on MacOS and Linux.</p>

<p dir="auto">Download and use <a href="https://github.com/andyk/ht/releases/latest">the latest binary</a> for your architecture.</p>

<p dir="auto">Building from source requires the <a href="https://www.rust-lang.org/" rel="nofollow">Rust</a> compiler
(1.74 or later), and the <a href="https://doc.rust-lang.org/cargo/" rel="nofollow">Cargo package
manager</a>. If they are not available via your
system package manager then use <a href="https://rustup.rs/" rel="nofollow">rustup</a>.</p>
<p dir="auto">To download the source code, build the binary, and install it in
<code>$HOME/.cargo/bin</code> run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo install --git https://github.com/andyk/termproxy"><pre>cargo install --git https://github.com/andyk/termproxy</pre></div>
<p dir="auto">Then, ensure <code>$HOME/.cargo/bin</code> is in your shell&#39;s <code>$PATH</code>.</p>
<p dir="auto">Alternatively, you can manually download the source code and build the binary
with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/andyk/termproxy
cd termproxy
cargo build --release"><pre>git clone https://github.com/andyk/termproxy
<span>cd</span> termproxy
cargo build --release</pre></div>
<p dir="auto">This produces the binary in <em>release mode</em> (<code>--release</code>) at
<code>target/release/ht</code>. There are no other build artifacts so you can just
copy the binary to a directory in your <code>$PATH</code>.</p>

<p dir="auto">Run <code>ht</code> to start interactive bash shell running in a PTY (pseudo-terminal).</p>
<p dir="auto">To launch a different program (a different shell, another program) run <code>ht &lt;command&gt; &lt;args...&gt;</code>. For example:</p>
<ul dir="auto">
<li><code>ht fish</code> - starts fish shell</li>
<li><code>ht nano</code> - starts nano editor</li>
<li><code>ht nano /etc/fstab</code> - starts nano editor with /etc/fstab opened</li>
</ul>
<p dir="auto">Another way to run a specific program, e.g. <code>nano</code>, is to launch <code>ht</code> without a
command, i.e. use bash by default, and start nano from bash by sending <code>nano\r</code>
(&#34;nano&#34; followed by &#34;return&#34; control character) to the process input. See <a href="#input">input
command</a> below.</p>
<p dir="auto">Default size of the virtual terminal window is 120x40 (cols by rows), which can
be changed with <code>--size</code> argument. For example: <code>ht --size 80x24</code>. The window
size can also be dynamically changed - see <a href="#resize">resize command</a> below.</p>
<p dir="auto">Run <code>ht -h</code> or <code>ht --help</code> to see all available options.</p>

<p dir="auto">Communication with ht is performed via stdin, stdout and stderr.</p>
<p dir="auto">ht uses simple JSON-based protocol for sending commands to its stdin. Each
command must be sent on a separate line and be a JSON object having <code>&#34;type&#34;</code>
field set to one the supported commands (below).</p>
<p dir="auto">ht sends responses (where applicable) to its stdout, as JSON-encoded objects.</p>
<p dir="auto">Diagnostic messages (notices, errors) are printed to stderr.</p>

<p dir="auto"><code>input</code> command allows sending arbitrary input to a process running in the
virtual terminal as if the input was typed on a keyboard.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;type&#34;: &#34;input&#34;, &#34;payload&#34;: &#34;ls\r&#34; }"><pre>{ <span>&#34;type&#34;</span>: <span><span>&#34;</span>input<span>&#34;</span></span>, <span>&#34;payload&#34;</span>: <span><span>&#34;</span>ls<span>\r</span><span>&#34;</span></span> }</pre></div>
<p dir="auto">This command doesn&#39;t produce any output on stdout.</p>

<p dir="auto"><code>getView</code> command allows obtaining a textual view of a terminal window.</p>

<p dir="auto">This command responds with the current view on stdout. The view is a multi-line
string, where each line represents a terminal row.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;view&#34;: &#34;[user@host dir]$                 \n                       \n...&#34; }"><pre>{ <span>&#34;view&#34;</span>: <span><span>&#34;</span>[user@host dir]$                 <span>\n</span>                       <span>\n</span>...<span>&#34;</span></span> }</pre></div>

<p dir="auto"><code>resize</code> command allows resizing the virtual terminal window dynamically by
specifying new width (<code>cols</code>) and height (<code>rows</code>).</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;type&#34;: &#34;resize&#34;, &#34;cols&#34;: 80, &#34;rows&#34;: 24 }"><pre>{ <span>&#34;type&#34;</span>: <span><span>&#34;</span>resize<span>&#34;</span></span>, <span>&#34;cols&#34;</span>: <span>80</span>, <span>&#34;rows&#34;</span>: <span>24</span> }</pre></div>
<p dir="auto">This command doesn&#39;t produce any output on stdout.</p>

<p dir="auto">ht is aimed at programmatic use given its JSON-based API, however one can play
with it by just launching it in a normal desktop terminal emulator and typing in
JSON-encoded commands from keyboard and observing the output on stdout.</p>
<p dir="auto"><a href="https://github.com/hanslub42/rlwrap">rlwrap</a> can be used to wrap stdin in a
readline based editable prompt, which also provides history (up/down arrows).</p>
<p dir="auto">To use <code>rlwrap</code> with <code>ht</code>:</p>


<p dir="auto">All code is licensed under the Apache License, Version 2.0. See LICENSE file for
details.</p>
</article></div></div>
  </body>
</html>
