<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/andyk/ht">Original</a>
    <h1>ht: Headless Terminal</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>ht</code> (short for <em>headless terminal</em>) is a command line program that wraps an arbitrary other binary (e.g. <code>bash</code>, <code>vim</code>, etc.) with a VT100 style terminal interface--i.e. a pseudoterminal client (PTY) plus terminal server--and allows easy programmatic access to the input and output of that terminal (via JSON over stdin/stdout). <code>ht</code> is built in rust and works on MacOS and Linux.</p>

<p dir="auto"><code>ht</code> is useful for programmatically interacting with terminals, which is important for programs that depend heavily on the Terminal as UI. It is useful for testing and for getting AI agents to interact with terminals the way humans do.</p>
<p dir="auto">As the original motiving use case was, I was trying to use LLM agents for coding, and needed something like a headless browser but for terminals.</p>
<p dir="auto">Terminals are one of the oldest and most prolific UI frameworks in all of computing. And they are stateful so, for example, when you use an editor in your terminal, the terminal has to manage state about the cursor location. Without ht, an agent struggles to manage this state directly; with ht, an agent can just observe the terminal like a human does.</p>

<p dir="auto">Download and use <a href="https://github.com/andyk/ht/releases/latest">the latest binary</a> for your architecture.</p>

<p dir="auto">Building from source requires the <a href="https://www.rust-lang.org/" rel="nofollow">Rust</a> compiler
(1.74 or later), and the <a href="https://doc.rust-lang.org/cargo/" rel="nofollow">Cargo package
manager</a>. If they are not available via your
system package manager then use <a href="https://rustup.rs/" rel="nofollow">rustup</a>.</p>
<p dir="auto">To download the source code, build the binary, and install it in
<code>$HOME/.cargo/bin</code> run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo install --git https://github.com/andyk/ht"><pre>cargo install --git https://github.com/andyk/ht</pre></div>
<p dir="auto">Then, ensure <code>$HOME/.cargo/bin</code> is in your shell&#39;s <code>$PATH</code>.</p>
<p dir="auto">Alternatively, you can manually download the source code and build the binary
with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/andyk/ht
cd ht
cargo build --release"><pre>git clone https://github.com/andyk/ht
<span>cd</span> ht
cargo build --release</pre></div>
<p dir="auto">This produces the binary in <em>release mode</em> (<code>--release</code>) at
<code>target/release/ht</code>. There are no other build artifacts so you can just
copy the binary to a directory in your <code>$PATH</code>.</p>

<p dir="auto">Run <code>ht</code> to start interactive bash shell running in a PTY (pseudo-terminal).</p>
<p dir="auto">To launch a different program (a different shell, another program) run <code>ht &lt;command&gt; &lt;args...&gt;</code>. For example:</p>
<ul dir="auto">
<li><code>ht fish</code> - starts fish shell</li>
<li><code>ht nano</code> - starts nano editor</li>
<li><code>ht nano /etc/fstab</code> - starts nano editor with /etc/fstab opened</li>
</ul>
<p dir="auto">Another way to run a specific program, e.g. <code>nano</code>, is to launch <code>ht</code> without a
command, i.e. use bash by default, and start nano from bash by sending <code>nano\r</code>
(&#34;nano&#34; followed by &#34;return&#34; control character) to the process input. See <a href="#input">input
command</a> below.</p>
<p dir="auto">Default size of the virtual terminal window is 120x40 (cols by rows), which can
be changed with <code>--size</code> argument. For example: <code>ht --size 80x24</code>. The window
size can also be dynamically changed - see <a href="#resize">resize command</a> below.</p>
<p dir="auto">Run <code>ht -h</code> or <code>ht --help</code> to see all available options.</p>

<p dir="auto">Communication with ht is performed via stdin, stdout and stderr.</p>
<p dir="auto">ht uses simple JSON-based protocol for sending commands to its stdin. Each
command must be sent on a separate line and be a JSON object having <code>&#34;type&#34;</code>
field set to one the supported commands (below).</p>
<p dir="auto">ht sends responses (where applicable) to its stdout, as JSON-encoded objects.</p>
<p dir="auto">Diagnostic messages (notices, errors) are printed to stderr.</p>

<p dir="auto"><code>input</code> command allows sending arbitrary input to a process running in the
virtual terminal as if the input was typed on a keyboard.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;type&#34;: &#34;input&#34;, &#34;payload&#34;: &#34;ls\r&#34; }"><pre>{ <span>&#34;type&#34;</span>: <span><span>&#34;</span>input<span>&#34;</span></span>, <span>&#34;payload&#34;</span>: <span><span>&#34;</span>ls<span>\r</span><span>&#34;</span></span> }</pre></div>
<p dir="auto">To send control characters (e.g., ctrl-c), include in your input json the ascii control character that the keyboard combo would generate (e.g., \x03 for ctrl-c). So to send control-c to the terminal, send the following JSON message to ht:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;type&#34;: &#34;input&#34;, &#34;payload&#34;: &#34;\x03&#34; }"><pre>{ <span>&#34;type&#34;</span>: <span><span>&#34;</span>input<span>&#34;</span></span>, <span>&#34;payload&#34;</span>: <span><span>&#34;</span><span>\x</span>03<span>&#34;</span></span> }</pre></div>
<p dir="auto">This command doesn&#39;t produce any output on stdout.</p>

<p dir="auto"><code>getView</code> command allows obtaining a textual view of a terminal window.</p>

<p dir="auto">This command responds with the current view on stdout. The view is a multi-line
string, where each line represents a terminal row.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;view&#34;: &#34;[user@host dir]$                 \n                       \n...&#34; }"><pre>{ <span>&#34;view&#34;</span>: <span><span>&#34;</span>[user@host dir]$                 <span>\n</span>                       <span>\n</span>...<span>&#34;</span></span> }</pre></div>

<p dir="auto"><code>resize</code> command allows resizing the virtual terminal window dynamically by
specifying new width (<code>cols</code>) and height (<code>rows</code>).</p>
<div dir="auto" data-snippet-clipboard-copy-content="{ &#34;type&#34;: &#34;resize&#34;, &#34;cols&#34;: 80, &#34;rows&#34;: 24 }"><pre>{ <span>&#34;type&#34;</span>: <span><span>&#34;</span>resize<span>&#34;</span></span>, <span>&#34;cols&#34;</span>: <span>80</span>, <span>&#34;rows&#34;</span>: <span>24</span> }</pre></div>
<p dir="auto">This command doesn&#39;t produce any output on stdout.</p>

<p dir="auto">ht is aimed at programmatic use given its JSON-based API, however one can play
with it by just launching it in a normal desktop terminal emulator and typing in
JSON-encoded commands from keyboard and observing the output on stdout.</p>
<p dir="auto"><a href="https://github.com/hanslub42/rlwrap">rlwrap</a> can be used to wrap stdin in a
readline based editable prompt, which also provides history (up/down arrows).</p>
<p dir="auto">To use <code>rlwrap</code> with <code>ht</code>:</p>


<p dir="auto">Here is <a href="https://docs.google.com/document/d/1L1prpWos3gIYTkfCgeZ2hLScypkA73WJ9KxME5NNbNk/edit" rel="nofollow">the original design doc</a> we used to drive the project development.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Python and Typescript libs</h2><a id="user-content-python-and-typescript-libs" aria-label="Permalink: Python and Typescript libs" href="#python-and-typescript-libs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Here are some experimental versions of a simple Python and Typescript libraries that wrap <code>ht</code>: <a href="https://github.com/andyk/headlong/blob/24e9e5f37b79b3a667774eefa3a724b59b059775/packages/env/htlib.py">htlib.py</a> and a <a href="https://github.com/andyk/headlong/blob/24e9e5f37b79b3a667774eefa3a724b59b059775/packages/env/htlib.ts">htlib.ts</a>.</p>
<p dir="auto">TODO: either pull those into this repo or fork them into their own <code>htlib</code> repo.</p>

<p dir="auto">Would be great to update the interface to return the view with additional color and style information (text color, background, bold/italic/etc) also in a simple JSON format (so no dealing with color-related escape sequence either), and the frontend could render this using HTML (e.g. with styled pre/span tags, similar to how asciinema-player does it) or with SVG.</p>

<p dir="auto">All code is licensed under the Apache License, Version 2.0. See LICENSE file for
details.</p>
</article></div></div>
  </body>
</html>
