<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leahneukirchen.org/blog/archive/2025/12/advent-of-swift.html">Original</a>
    <h1>Advent of Swift</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This year, I decided to use <a href="https://adventofcode.com/">Advent of
Code</a> to learn the language
<a href="https://www.swift.org/">Swift</a>.  Since there were only 12 days of
tasks for 2025, here is my summary of experiences.
Also check out <a href="https://github.com/leahneukirchen/adventofcode2025">my solutions</a>.</p>
<h2>Tooling</h2>
<p>I used Swift 6.2 on Void Linux, which I compiled from scratch since there
were no prebuilt binaries that worked with a Python 3.13 system
(needed for lldb).  It’s possible to bootstrap Swift from just a
clang++ toolchain, so this wasn’t too tedious, but it still required
looking up Gentoo ebuilds how to pass configuration properly.  As an
end user, this should not worry you too much.</p>
<p>Tooling in general is pretty nice: there’s an interpreter and you
can run simple “scripts” directly using <code>swift foo.swift</code>.  Startup
time is short, so this is great for quick experiments.  There’s also a
REPL, but I didn’t try it yet.  One flaw of the interpreter (but
possibly related to my setup) is that there were no useful backtraces
when something crashed.  In this case, I compiled a binary and used
the included <code>lldb</code>, which has good support for Swift.</p>
<p>There’s also a <code>swift-format</code> tool included to format source code.
It uses 2 spaces by default, but most code in the wild uses 4 spaces
curiously.  I’m not sure when that changed.</p>
<p>Since I only write simple programs using a single source file,
I didn’t bother looking at <code>swift-build</code> yet.</p>
<p>By default, programs are linked dynamically against the standard
library and are thus super compact.
Unfortunately, many modern languages today don’t support this properly.
(Statically linking the standard library costs roughly 10MB,
which is fair too.)</p>
<h2>The language</h2>
<p>In general, the language feels modern, comfy, and is easy to pick up.
However, I found some traps as well.</p>
<p>The syntax is inspired by the C family and less symbol-heavy than
Rust’s.  There’s a block syntax akin to Ruby for passing closures.</p>
<p>Error handling can be done using checked exceptions, but there are
also Optional types and Result types like in Rust, and syntactic
shortcuts to make them convenient.</p>
<p>The standard library has many practical functions, e.g. there’s a
function <code>Character.wholeNumberValue</code> that works for any Unicode digit
symbol.
There’s a <code>Sequence</code> abstraction over arrays etc. which has many useful functions
(e.g. <code>split(whereSeparator:)</code>, which many other standard libraries lack).
The standard library is documented well.</p>
<p>The string processing is powerful, but inconvenient when you want to
do things like indexing by offsets or ranges, due to Unicode semantics.
(This is probably a good thing in general.)
I switched to using arrays of code-points for problems that required this.</p>
<p>On <a href="https://adventofcode.com/2025/day/2">Day 2</a>, I tried using regular
expressions, but I found serious performance issues: first I used a
Regexp literal (<code>#/.../#</code>) in a loop, which actually resulted in
creating a new Regexp instance on each iteration; second, Regexp
matching itself is quite slow.  Before I extracted the Regexp into a
constant, the program was 100x as slow as Ruby(!), and after it still
was 3x as slow.  I then rewrote the solution to not use Regexps.</p>
<p>Prefix (and suffix) operators need to “stick” to their expression, so
you can’t write <code>if ! condition</code>.  This is certainly a choice: you can
define custom prefix and suffix operators and parsing them
non-ambiguously is easier, but it’s probably not a thing I would have
done.</p>
<p>Swift functions often use parameter names (probably for compatibility
with Objective-C).  They certainly help readability of the code, but I
think I prefer OCaml’s labeled arguments, which can be reordered and
permit currying.</p>
<p>The language uses value semantics for collections and then optimizes
them using copy-on-write and or by detecting <code>inout</code> parameters (which
are updated in-place).  This is quite convenient when writing code
(e.g <a href="https://github.com/leahneukirchen/adventofcode2025/blob/master/day04.swift#L35">day 4</a>)
Garbage collection is done using reference counting.  However, some
AoC tasks turned out to make heavy use of the garbage collector, where
I’d have expected the compiler to use a callstack or something for
intermediate values.  Substrings are optimized by a custom type
<code>Substring</code>, if you want to write a function to operate on either
strings or substrings, you need to spell this out:</p>
<pre><code>func parse&lt;T&gt;(_ str: T) -&gt; ... where T: StringProtocol
</code></pre>
<p>There’s a library <a href="https://github.com/apple/swift-algorithms">swift-algorithms</a>
adding even more sequence and collection algorithms, which I decided not to use.</p>
<h2>Downsides</h2>
<p>The compiler is reasonably fast for an LLVM-based compiler.  However,
when you manage to create a type checking error, error reporting is
extremely slow, probably because it tries to find any variant that
could possibly work still.  Often, type checking errors are also confusing.</p>
<p>(Error messages unrelated to type checking are good and often really
helpful, e.g. if you accidentally use <code>&#39;&#39;</code>-quotes for strings
or try to use <code>[]</code> as an empty map, it tells you how to do it right.)</p>
<p>Ranges can be inclusive <code>...</code> or right-exclusive <code>..&lt;</code>.  Constructing
a range where the upper boundary is smaller than the lower boundary
results in a fatal error, whereas in other languages it’s just an
empty range.</p>
<p>Some “obvious” things seem to be missing, e.g. tuples of <code>Hashable</code>
values are not <code>Hashable</code> currently (this feature was removed in 2020,
after trying to implement the
<a href="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0283-tuples-are-equatable-comparable-hashable.md">proposal</a>
that introduced it, and no one bothered to fix it yet?), which is
pretty inconvenient.</p>
<p>Likewise, the language has pattern matching for algebraic data types
and tuples, but unfortunately not for arrays/sequences, which is
inconvenient at times.</p>
<p>Since I was just picking up Swift, I had to search stuff online a lot
and read Stack Overflow.  I noticed I found many answers for prior
versions of Swift that changed in the mean time (even for basic tasks).
For a language that’s been around for over 10 years, this seems like
quite some churn.  I hope the language manages to stabilize better and
doesn’t just get new features bolted on continuously.</p>
<p>⁂</p>
<p>In general, using Swift was fun and straight-forward for these programming tasks.
For writing serious applications on non-MacOS systems,
there’s also the question of library availability.
Some parts of the language still feel unfinished or unpolished,
in spite of being around for quite some time.</p>
<p><small>NP: Adrianne Lenker—Promise is a Pendulum</small></p>

</div></div>
  </body>
</html>
