<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.littlepolygon.com/posts/scaffold/">Original</a>
    <h1>Scaffold Level Editor</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>On the latest <a href="https://store.steampowered.com/app/3038700/Nightshift_Galaxy/"><em>Nightshift Galaxy</em></a> weekly dev stream I demonstrated the specialized level editting tool I’m building inside the Unreal Level Editor that I’m calling <strong>Scaffold</strong>.</p>

<p>
  <iframe src="https://www.youtube.com/embed/RDZPNKNbJYc" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<p>I gave an impromptu introduction to my motivations and inspirations live, but on reflection the topic deserves a written deep-dive.</p>
<p>In designing tools I’m guided by three high-level goals:</p>
<ul>
<li><strong>Productivity</strong>. As a solo-developer, I need to automate as much of my workflow as possible, to ensure that I focus on places where my specific skill-set adds value, and avoid labor-intensive tasks that aren’t core to gameplay.</li>
<li><strong>Individuality</strong>. A risk of using a generic game engine, like Unreal or Unity, and common marketplace assets is producing a generic game. By developing unique systems, I can enable unique gameplay that has market differentiation.</li>
<li><strong>Performance</strong>. As an action game with a high skill-ceiling there is no “correctness vs. performance” tradeoff; 60+ FPS is a correctness requirement.  Furthermore, in my experience, to confidently reach a larger audience with midrange commodity devices, one can’t simply chip-away at perf problems in the profiler later – one must architect for it.</li>
</ul>
<p><strong>Scaffold</strong> addresses these goals by exposing (i) an interactive interior design tool that prioritizes power-user hotkeys and hackability, (ii) gameplay systems that supplement Unreal’s built-in collision and navigation with opinionated parallel systems, and (iii) data-structures (inspired by 90s game engines) that are efficient by-construction.</p>
<h2 id="background-convex-decomposition">Background: Convex Decomposition
<span>
    <a href="#background-convex-decomposition">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>To explain the details of the system, we need to first establish some background in <strong>Convex Geometry</strong> that’s relevant to the design. In a nutshell, the convex hull property describes any shape where <em>the straight-line connecting any two points within the shape is also contained in the shape</em>.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/convex.jpg" alt=""/>
<em>Sample Convex Shapes in 2D</em></p>
</span></p><p>This is in contrast to concave shapes that have notches or holes cut out of them.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/concave.jpg" alt=""/>
<em>Sample Concave Shapes in 2D</em></p>
</span></p><p>Most spatial algorithms in games, particularly raytracing and pathfinding, implicitly rely on the convex-hull property by partitioning complex scenes into a network of connected convex-volumes through a process called <strong>Convex Decomposition</strong>.</p>
<p>In this data-structure, the faces of the volumes fall into two categories: <em>Walls</em> that close the outside of the composed shape, and <em>Windows</em> in-between shared internal edges that are logically open.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/wall_window.jpg" alt=""/>
<em>Convex Decomposition</em></p>
</span></p><p>To trace a ray through the scene, we start by identifying which volume contains the origin of the ray (ususally from context). Because of the convex-hull property we know we can extend a straight-line all the way to a point on the edge, which we identify through ray-plane intersection. Then we check if the edge is a “wall,” in which case we’ve successful identified the hit, or a “window,” in which case we go back and repeat the process for the newly-entered volume.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/raycast.jpg" alt=""/>
<em>Raycasting within a Convex Decomposition</em></p>
</span></p><p>This algorithm is <em>local</em> and for volumes with a fixed-capacity for the number of sides has O(1) complexity, relative to the size of the scene, as opposed to a brute-force algorithm which inspects every single wall and therefore has O(n) complexity.</p>
<p>We extend this algorithm to loose-props and moving-actors by associating with each volume a list of primitives, what I call an “object-bucket,” which is searched for a hit before advancing to the far-edge.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/bucket.jpg" alt=""/>
<em>Raycasting with Loose Object “Buckets”</em></p>
</span></p><p>By assigning a fixed-capacity to buckets, this keeps the cost O(1). When we consider that every actor is doing their own traces to move every frame, that gives us something like O(n) total performance complexity, vs. brute force in which every actor is checking every other actor for O(n²) total performance complexity, which is unacceptable for interactive applications.</p>
<p>If the buckets have variable-capacity, we can avoid the “everyone crowds in one volume” edge-case by recursively subdividing buckets spatially and making a tree-like structure. For a uniform-distribution of actors, this has O(log n) trace complexity and O(n × log n) total complexity, which is the typical threshold in game programming for “fixable via perf profiling.”</p>
<h2 id="navigation">Navigation
<span>
    <a href="#navigation">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>Another use-case for convex decomposition is <em>pathfinding</em>. By drawing waypoints in the middle of each “window” we know we can connect them across their shared volumes with straight-lines (again, due to the convex hull property). Furthermore, any actor inside a convex-volume can make their way to any of that volume’s waypoints, and as long as a connected path exists we can draw draw a path between any two points that is free of collision.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/nav.jpg" alt=""/>
<em>Pathfinding on a Convex “Navigation Mesh”</em></p>
</span></p><p>The algorithm to determine the if the path exists is beyond the scope of this writeup, but it’s called the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* Search Algorithm</a> and there’s lots of easily-searchable literature about it online.</p>
<h2 id="collision-and-navigation-in-general-purpose-game-engines">Collision and Navigation in General-Purpose Game Engines
<span>
    <a href="#collision-and-navigation-in-general-purpose-game-engines">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>A wrinkle in understanding how these concepts apply to modern general-purpose game engines, like Unity and Unreal, arises the architecture of their level editors. Both eskew the explicit construction of a spatial decomposition, and instead expose to the designer a simple list of loose objects that are hand-places one-by-one (“Actors” in Unreal, GameObjects&#34; in Unity). Therefore, to apply these algorithms, dynamic data structures are built at run-time, on the game device, based on heuristic, fine-tuned methods.</p>
<p>For collision and raycasting, the spatial partition is built via an invisible lattice of implicitly-linked convex grid-cells (think like the lattice in Minecraft, except each cell has a object-bucket rather than a solid voxel).</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/quadtree.gif" alt=""/>
<em>Here’s a 2D “Quadtree” illustrated. The convex decomposition is limited to boxes and object-buckets, but no true “walls”.</em></p>
</span></p><p>The origin of the ray is determined via quantization, and proceeds in the same way outlined above, except the grid-cells have only “window” edges, so we’re only collision-checking the buckets. The step of quickly filtering via local buckets is described in the literature as “Broad-Phase Collision”.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/octree_cast.jpg" alt=""/>
<em>Tracing a ray through a broadphase spatial partition (greatly simplified).</em></p>
</span></p><p>Because a rectangular grid cell cleanly divides into 8 sub-cells, this lattice data structure is called an “Octree.” Due to its simplicity, Octrees are the most common spatial partitions, but other interesting schemes exist, and the solution in production often has several interesting optimizations that are beyond the scope of this summary – but the principle is the same. Both Unreal and Unity used to rely on the <a href="https://en.wikipedia.org/wiki/PhysX">PhysX</a> library for this task, though Unreal has transitioned to an in-house solution called <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/physics-in-unreal-engine">Chaos</a>.  Another notable solutions are <a href="https://github.com/jrouwe/JoltPhysics">Jolt</a>, which was originally developed for the game <a href="https://en.wikipedia.org/wiki/Horizon_Zero_Dawn">Horizon Zero Dawn</a>, and <a href="https://www.havok.com/havok-physics/">Havok</a>, which has been around a long time, most notably/recently powering Nintendo’s <a href="https://en.wikipedia.org/wiki/The_Legend_of_Zelda:_Breath_of_the_Wild">Breath of the Wild</a>.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/zelda.jpg" alt=""/>
<em>“I’ll just develop my indie game the same way a multimillion dollar company develops theirs” is not exactly a winning strategy.</em></p>
</span></p><p>For navigation, general-purpose engines rely on hand-placed volumes to perform many continuous raycasts on background threads at runtime to asynchronously populate connected “ground shapes” on which pathfinding can be performed. This process is more art than science, and relies on a vast number of fine-tuning parameters that demand continuous designer tweaking for good results. Unreal, in particular, relies on the <a href="https://github.com/recastnavigation/recastnavigation">Recast</a> library for this task.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/recast.png" alt=""/>
<em>Screenshot of the Recast Navigation system, from their official Github page.</em></p>
</span></p><p>The downside of these general-purpose dynamic solutions is that the CPU and RAM requirements are higher than precomputed explicit decompositions, and they’re more likely to exhibit the variable O(n × log n) complexity that demands laborious perf-tuning. Furthermore, they transfer all the work of constructing the patritions to the end-user’s gaming device, rather than allowing static scene data to be “cooked” ahead of time on developer workstations.</p>
<h2 id="looking-forward-by-looking-backward">Looking Forward by Looking Backward
<span>
    <a href="#looking-forward-by-looking-backward">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>They’re workable in a large-team production setting, but in my case they resisted all three of my high-level goals.  Therefore, I began searching for alternatives – not to replace these features whole-cloth, but the supplement them with parallel systems for specific cases where they’re not well-suited.</p>
<p>The fact that in principle they all share a common data structure gave me this feeling that I should be able to make a tool which does “double duty”.</p>
<p>In searching for inspiration I began thinking about mid-90s shooters, which accomplished a lot of what I want on <em>very</em> modest low-power commodity PCs, in particular <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM (1993)</a> and <a href="https://en.wikipedia.org/wiki/Descent_(video_game)">DESCENT (1995)</a>. How did those games work? And could I exploit those legacy techniques to surpass the performance and productivity limitations of the general-purpose solutions?</p>
<h2 id="doom-binary-space-partitioning">DOOM: Binary Space Partitioning
<span>
    <a href="#doom-binary-space-partitioning">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p><span>
<p>
  <iframe src="https://www.youtube.com/embed/e5UD5QQH_as" allowfullscreen="" title="YouTube Video"></iframe>
</p>
<p><em>Playthrough of DOOM, developed by id Software in 1993</em></p>
</span></p><p>Loose objects like demons and bullets are pretty sparse in the original DOOM, with wall-collision accounting for most of the runtime complexity. The DOOM level editor allows for mostly arbitrary placement of walls, but then runs a special decomposition algorithm to break it down into explicit convex-regions called <em>Binary Space Partitioning</em> (BSP).</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/deu.png" alt=""/>
<em>Screenshot of the origin DOOM level editor.</em></p>
</span></p><p>The idea is to pick a wall at random, and subdivide the remaining walls into those that are in-front or behind that wall’s plane (splitting walls that straddle the plane into two parts). For those two subsets you rinse-and repeat until you’ve exhausted all the walls, and what remains at the leaf-nodes of the subdivision are a convex partition of the scene, which can be computed and stored ahead-of-time with level-data.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/bsp_source.gif" alt=""/>
<em>Diagram from Valve’s Source Engine documentation demonstrating convex-decomposition via Binary Space Partitioning.</em></p>
</span></p><p>The original DOOM simplified these BSPs by imposing the restriction that all walls are perfectly vertical, so the partitioning could be mostly 2D, though later versions of <a href="https://en.wikipedia.org/wiki/Quake_(video_game)">Quake</a> and <a href="https://en.wikipedia.org/wiki/Unreal_Tournament">Unreal Tournament</a> used the same technique with sloped geometry, too.</p>
<p>While it’s interesting to study to understand the history of how broad-phase collision developed historically, I didn’t really feel like there was much for me to exploit</p>
<h2 id="descent-convex-by-construction">DESCENT: Convex By-Construction
<span>
    <a href="#descent-convex-by-construction">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>Another interesting case I looked at was Descent, which billed itself as the first “full 3D” shooter with complex volume-filling geometry, as opposed to being mostly-flattened onto the horizontal plane like DOOM.</p>
<p><span>
<p>
  <iframe src="https://www.youtube.com/embed/PwIre2rLHv0" allowfullscreen="" title="YouTube Video"></iframe>
</p>
<p><em>Playthrough of Descent, developed by Interplay in 1995</em></p>
</span></p><p>I better appreciated for how they implemented this by playing around with the mod community’s level editor <a href="https://descent2.de/dle-frames.html">DLE</a>, where levels are built-up from convex “segments” that are each six-sided cuboid hexahedrons. At first glance this seems like a restrictive limitation which would give rise to rectangular chambers, but creative linking across edges and corners can actually give rise to pretty much any shape you want with enough creativity. Additionally, restricting faces to all be quads simplifies how textures and materials are applied, as opposed to having to account for weird triangular topology.</p>
<p><span>
<p><img src="https://blog.littlepolygon.com/posts/scaffold/dle2.jpg" alt=""/>
<em>Screenshot of the Descent Level Editor. It looks like a mesh editor at first glance, but you’re actually editting linked cuboid “segments.”</em></p>
</span></p><p>In 2018 the original original devs reconvened to develop a spiritual successor <a href="https://en.wikipedia.org/wiki/Overload_(video_game)">Overload</a>, with a community <a href="https://store.steampowered.com/app/884970/Overload_Level_Editor/">level-editor</a> and tutorial series which expands on the same ideas in thoughtful ways. What really caught my eye was how they extended the idea of “applying materials” to quad-face to assembling kit-pieces which have a modern, rather than low-poly, look. For example, rock faces have rough geometry that fill-in crevices to give those areas an organic look.</p>
<p><span>
<p>
  <iframe src="https://www.youtube.com/embed/SbznHch0esI" allowfullscreen="" title="YouTube Video"></iframe>
</p>
<p><em>First Video in a Tutorial Series on the Overload Level Editor</em></p>
</span></p><p>Playing with these tools was a big <em>aha</em> moment for me – that by building-up from convex shapes there’s no need to do any kind of “decomposition” like BSPs because the space is partitioned <strong>by-construction</strong>.</p>
<p>I decided to use this as a starting-point and then go in my own direction.</p>
<h2 id="nightshift-galaxy-scaffold">Nightshift Galaxy Scaffold
<span>
    <a href="#nightshift-galaxy-scaffold">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"></path></svg>
    </a>
</span>
</h2><p>Instead of building a completely separate application like the Overload team did, I decided to build inside the Unreal Level Editor. This is a tradeoff – on the one hand it limits the ease of offering modding tools to the community, which is something on my mind. On the other hand, though, it greatly reduced how much I needed to code (since the application-framework/asset-handling/undo systems were already in place), and let me focus on my value-adds, as opposed to re-implementing all the other loose-object handling that Unreal already does perfectly-fine.</p>
<blockquote><p lang="en" dir="ltr">Gamedev Streaming resumes _tomorrow_ at noon, PST. Thinking of doing a demo of the &#34;scaffold&#34; tool I&#39;ve been making for level design, and maybe a little lecture of scene geometry in 3D. <a href="https://twitter.com/hashtag/indiegamedev?src=hash&amp;ref_src=twsrc%5Etfw">#indiegamedev</a> <a href="https://t.co/eaWQEAOSvv">pic.twitter.com/eaWQEAOSvv</a></p>— Max! (@xewlupus) <a href="https://twitter.com/xewlupus/status/1907921527267590149?ref_src=twsrc%5Etfw">April 3, 2025</a></blockquote>



<p><span>
<p><em>Early Sneak-Peak of Scaffold running inside the Unreal Level Editor.</em></p>
</span></p><p>I won’t go into all the boring details, suffice to say for Unreal-heads out there I started with the <em>SplineComponentVisualizer</em> as a reference and built my own tools from there. It took about a week to get a MVP version from about 2500ish lines of code. I have all the basic operations - selection modes for vertices, edges, faces, and “cubs” (my name for convex segment – short for “cubby hole”), basic extrude and bridge options, as well as “stamps” for common shapes like cubes, rings, and cylinders.</p>
<p>For the grey “blockout” walls, I’m using the <em>DynamicMesh</em> object from the <strong>GeometryScripting</strong> extension (though I intend to replace them with instanced decoration kit meshes), and to create “real collision” trigger volumes for each cub I added a <em>CubComponent</em> subtype of <em>PrimitiveComponent</em> by referencing the implementation of <em>ShapeComponent</em> and <em>BoxComponent</em>.</p>
<p>I wrote a “scaffold raytracing” test which, even in it’s simple quick&amp;dirty implementation, is 100x faster than doing ordinary raytraces with Unreal’s built-in collision. It’s not something I was use for player bullets or general-purpose traces, but for specialized batches, like enemy bullet-hell patterns, it opens up a lot of opportunities.</p>
<blockquote><p lang="en" dir="ltr">Post-stream: updated the BulletManager to not only use framerate-independent time, but do sub-frame position sampling for higher-precise patterns. <a href="https://twitter.com/hashtag/ScreenshotSaturday?src=hash&amp;ref_src=twsrc%5Etfw">#ScreenshotSaturday</a> <a href="https://twitter.com/hashtag/shmup?src=hash&amp;ref_src=twsrc%5Etfw">#shmup</a> </p>— Max! (@xewlupus) <a href="https://twitter.com/xewlupus/status/1895887457734062506?ref_src=twsrc%5Etfw">March 1, 2025</a></blockquote>



<p><span>
<p><em>Footage from an earlier bullet-hell experimentation stream.</em></p>
</span></p><p>But the real <em>coup de grâce</em> for me was that, as I expected, Scaffold data also works as a navigation system!  I generate a waypoint for each shared cub-face, and do a quick check to see if the “floor” of the cub is a wall-or-window, and quickly generate a navigation graph that works for both ground-units and aerial units with no extra labor.</p>
<blockquote><p lang="en" dir="ltr">Update from yesterday&#39;s stream -- the Scaffold level editor is now generating nav-data for AI-pathfinding in addition to blockout wall collision. <a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> <a href="https://t.co/qaUStE3V1j">pic.twitter.com/qaUStE3V1j</a></p>— Max! (@xewlupus) <a href="https://twitter.com/xewlupus/status/1908664789943148859?ref_src=twsrc%5Etfw">April 5, 2025</a></blockquote>



<p><span>
<p><em>First test of Aerial Navigation working inside Scaffold.</em></p>
</span></p><p>At this point I’m confident in the direction of the solution, so now I’m fleshing out missing features, and adding more “smart” operations so I can layout spaces faster. The big difference between Nightshift and Descent is that I want to exit Spaceships/Asteroid-Bases/Sewer-Tunnels/Caves/Industrial-Interiors and fly around the outside, too, so I’ll need to start thinking about a “exterior hull” toolset as well. But I want to make a half-dozen maps with validated gameplay, first.</p>
        </div></div>
  </body>
</html>
