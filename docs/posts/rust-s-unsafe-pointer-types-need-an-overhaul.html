<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gankra.github.io/blah/fix-rust-pointers/">Original</a>
    <h1>Rust&#39;s Unsafe Pointer Types Need an Overhaul</h1>
    
    <div id="readability-page-1" class="page"><article>

    
    <header>
    
    <p>March 19th, 2022</p>
<nav id="TOC"><ul>
<li><a href="#background">1 Background</a><ul>
<li><a href="#aliasing">1.1 Aliasing</a><ul></ul></li>
<li><a href="#alias-analysis-and-pointer-provenance">1.2 Alias Analysis and Pointer Provenance</a><ul></ul></li>
<li><a href="#cheri">1.3 CHERI</a><ul></ul></li></ul></li>
<li><a href="#problems">2 Problems</a><ul>
<li><a href="#integer-to-pointer-casts-are-the-devil">2.1 Integer-To-Pointer Casts Are The Devil</a><ul></ul></li>
<li><a href="#references-make-really-strong-assertions">2.2 References Make Really Strong Assertions</a><ul></ul></li>
<li><a href="#offsets-and-places-are-a-mess">2.3 Offsets And Places Are A Mess</a><ul></ul></li></ul></li>
<li><a href="#solutions">3 Solutions</a><ul>
<li><a href="#distinguish-pointers-and-addresses">3.1 Distinguish Pointers And Addresses</a><ul>
<li><a href="#redefining-usize">3.1.1 Redefining usize</a><ul></ul></li>
<li><a href="#replacing-pointer-integer-casts">3.1.2 Replacing Pointer-Integer Casts</a><ul></ul></li></ul></li>
<li><a href="#fixing-places-and-offsets">3.2 Fixing Places and Offsets</a><ul>
<li><a href="#path-offset-syntax">3.2.1 Path Offset Syntax</a><ul></ul></li>
<li><a href="#postfix-deref">3.2.2 Postfix Deref</a><ul></ul></li></ul></li></ul></li>
<li><a href="#thats-all">4 That’s All!</a><ul></ul></li></ul></nav></header>
<p>I think about unsafe pointers in Rust a lot.</p>
<p>I literally wrote the book on <a href="https://doc.rust-lang.org/nightly/nomicon/">unsafe Rust</a>. And the book on <a href="https://rust-unofficial.github.io/too-many-lists/">pointers in Rust</a>. And <a href="https://github.com/rust-lang/rfcs/blob/master/text/1966-unsafe-pointer-reform.md">redesigned the Rust’s pointer APIs</a>. And designed the standard library’s <a href="https://github.com/rust-lang/rust/pull/26955">abstraction for unsafe heap-allocated buffers</a>. And maintain <a href="https://github.com/Gankra/thin-vec/">the alternative Vec layout</a>.</p>
<p>I think about unsafe pointers in Rust <em>a lot</em>, and I absolutely hate them.</p>
<p>Don’t get me wrong, I think all of the above work has made them <em>better</em> but they are still deeply flawed. Actually they’ve gotten a lot <em>worse</em>. Not because the APIs have changed, but because when I was working on this stuff we had too <em>naive</em> of an understanding of how pointers should work. Others have done a lot of great work to expand this understanding, and now the flaws are all the more glaring.</p>
<p>This article is broken up into 3 parts: conceptual background, problems with the current design, and proposed solutions.</p>

<p>This section can be skipped entirely if you know everything about computers.</p>

<p><a href="https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html">Aliasing</a> is a <a href="https://doc.rust-lang.org/nightly/nomicon/aliasing.html">very important concept</a> in compilers and language semantics. At a high-level, it is the study of the <em>observability</em> of modifications to memory. We call it <em>aliasing</em> because the problem is very easy until you can refer to a piece of memory in more than one way. Pointers are just nicknames for memory.</p>
<p>The primary function of alias analysis is as a model for when the compiler can semantically cache memory accesses. This can either mean assuming a value in memory hasn’t been modified <em>or</em> assuming a write to memory isn’t necessary. This is exceptionally important because <em>essentially all program state is semantically in memory</em>. It is literally impossible for a general purpose programming language that does <em>anything</em> on the behalf of the programmer to allow arbitrary reads and writes to memory.</p>
<p>As a hopefully extremely obvious example that we can all agree on, the compiler should be able to assume that the following program will pass <code>1</code> to <code>println!</code>:</p>

<div><pre><code><span>let</span> <span>mut</span> <span>x</span> <span>=</span> <span>0</span>;
<span>let</span> <span>mut</span> <span>y</span> <span>=</span> <span>1</span>;


<span>x</span> <span>=</span> <span>2</span>;

<span>println!</span>(<span>&#34;{y}&#34;</span>);</code></pre></div>
<p>When we talk about alias analysis we usually jump immediately to pointers because that’s the hard part but like, the fact that this has deterministic behaviour is part of your aliasing model! Variables are semantically unaliased until you actually take a reference to them!</p>
<p>This is actually a foundational assumption for putting things in registers, because putting something in a register is caching it. If a compiler can’t decide it’s ok to put values in general purpose registers or spill them to the stack, it’s an assembler <em>at best</em>. We would like to build languages that are higher-level than an assembler!</p>
<p>This is all well and good until we introduce pointers and have to start answering harder questions. For instance, in the following function, can we assume that <code>input</code> and <code>output</code> refer to different regions of memory?</p>

<div><pre><code><span>fn</span> <span>compute</span>(<span>input</span>: <span>&amp;</span><span>u32</span>, <span>output</span>: <span>&amp;mut</span> <span>u32</span>) {
    <span>if</span> <span>*</span><span>input</span> <span>&gt;</span> <span>10</span> {
        <span>*</span><span>output</span> <span>=</span> <span>1</span>;
    }
    <span>if</span> <span>*</span><span>input</span> <span>&gt;</span> <span>5</span> {
        <span>*</span><span>output</span> <span>*</span><span>=</span> <span>2</span>;
    }
}</code></pre></div>
<p>If we can, then the compiler is free to rewrite it as follows:</p>

<div><pre><code><span>fn</span> <span>compute</span>(<span>input</span>: <span>&amp;</span><span>u32</span>, <span>output</span>: <span>&amp;mut</span> <span>u32</span>) {
    <span>let</span> <span>cached_input</span> <span>=</span> <span>*</span><span>input</span>; 
    <span>if</span> <span>cached_input</span> <span>&gt;</span> <span>10</span> {
        
        
        
        
        
        <span>*</span><span>output</span> <span>=</span> <span>2</span>;
    } <span>else</span> <span>if</span> <span>cached_input</span> <span>&gt;</span> <span>5</span> {
        <span>*</span><span>output</span> <span>*</span><span>=</span> <span>2</span>;
    }
}</code></pre></div>
<p>If they <em>do</em> point to the same memory, then the write <code>*output = 1</code> and the read <code>*input &gt; 5</code> would <em>alias</em>. When we perform (potentially) aliasing accesses, the compiler has to conservatively load and store from memory as much as the source code implies.</p>
<p>Now it’s often clumsy to talk about <em>accesses</em> aliasing, so we usually talk about <em>pointers</em> aliasing as a shorthand. So one would reasonably say that <code>input</code> and <code>output</code> are aliased. The reason that the <em>actual</em> model is in terms of <em>accesses</em> and not <em>pointers</em> is because that’s the thing that we care about. We don’t <em>actually</em> care if you pass in two pointers that alias but only use one. Similarly we don’t actually care if two pointers alias but are only used for reads – one read can’t observably <em>effect</em> the other read (this assumption is why memory mapped hardware has to use <code>volatile</code>) </p>
<p>This is also why Rust has such a distinct schism between “unique mutable” references (<code>&amp;mut</code>) and “shared immutable” references (<code>&amp;</code>). It’s fine to make as many copies as you want of pointers that have readonly access, but if you want to actually mutate some memory it’s really important that it isn’t aliased!</p>
<p>(You may notice that this is a simplified model full of lies, if you would like less lies, read my extremely detailed <a href="https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html">discussion of Stacked Borrows</a>.)</p>
<p>Now with all that said, I will use the following shorthands: </p>
<ul>
<li>memory is <strong>anonymous</strong> if the programmer cannot refer to it by name or pointer.</li>
<li>memory is <strong>unaliased</strong> if there is currently only one way to refer to it.</li>
</ul>
<p>Anonymous values are in some sense “completely under the control of the compiler” and can therefore be freely assumed to be unaliased and trusted/modified by the compiler. Unaliased memory cannot be “randomly” modified by something seemingly “unrelated” (we’ll get to what that means in the next section).</p>
<p>Languages can have <em>stricter</em> or <em>weaker</em> aliasing models. A stricter model allows the compiler to do more optimizations but puts heavier restrictions on what the programmer is allowed to do within the confines of the language. Here are some common rules, in vaguely increasing strictness:</p>
<ul>
<li>Callee-saved values pushed to the stack are anonymous (return pointer, frame pointer).</li>
<li>“Scratch” values the compiler spills to the stack are anonymous.</li>
<li>A newly declared variable is unaliased until a reference is taken to it.</li>
<li>The memory returned by <code>malloc</code> is unaliased.</li>
<li>Fields of a struct do not alias eachother (bitfields are made of sadness).</li>
<li>Padding bytes are vaguely anonymous (messy because of memcpy/memset/unions/punning).</li>
<li>Immutable variables are functionally unaliased in that they can never change values.</li>
<li>In Rust, <code>&amp;mut</code> is unaliased (<a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">Stacked Borrows</a>).</li>
<li>In C(++), <code>T*</code> and <code>U*</code> cannot alias if <code>T!=U</code> and neither is <code>char</code> (<a href="https://blog.regehr.org/archives/1307">Strict Aliasing</a>).</li>
</ul>
<p>(I cannot emphasize enough how shorthanded all of this is, the devil is extremely in the details and formally specifying these things in this subject of untold numbers of PhD theses. I am not trying to write a PhD thesis right now. Unless you literally work on a C/C++ Standard Committee or are named Ralf Jung I will not be accepting your Umm Actually’s on these definitions and terms.)</p>
<h2 id="alias-analysis-and-pointer-provenance"><a href="#alias-analysis-and-pointer-provenance">1.2 Alias Analysis and Pointer Provenance</a></h2>
<p>Ok so all of that aliasing stuff is all well and good, but as soon as you take a pointer to something, or copy a pointer, or offset a pointer… that all goes out the window, right? Like you have to assume anything can be aliased by anything else?</p>
<p>No! Aliasing rules are some of the most foundational parts of the language’s semantics and optimizations. If you run afoul of the language’s aliasing rules you have Undefined Behaviour and the miscompilations can be extremely brutal!</p>
<p>But yes, once you start faffing around with pointers things get <em>a lot harder</em> for the compiler, memory model, and programmer. To make aliasing a useful notion once pointers start getting thrown around, memory models very quickly find the need to define two concepts:</p>
<ul>
<li>Allocations</li>
<li>Pointer Provenance</li>
</ul>
<p><em>Allocations</em> abstractly describe things like individual variables and the heap allocations. A freshly created allocation (variable decl, malloc) is always brought into the world unaliased and therefore acts like a <em>sandbox</em> with One True Name – there is no way to access the memory in the sandbox <em>except</em> through the One True Name (that isn’t Undefined Behaviour).</p>
<p>Pointer Provenance describes the way “permission to access an allocation’s sandbox” can be delegated from the One True Name by deriving a new pointer from it or something derived from it. The process of tracking this “chain of custody” from the One True Name to all of its derived pointers is <em>Pointer Provenance</em>.</p>
<p>From a formal memory model perspective, all accesses to an allocation must have <em>provenance</em> tracking back to that allocation. If pointer provenance isn’t satisfied, then that means the programmer broke out of the sandbox or pulled a pointer from the aether that happened to point into some random sandbox. Either way, everything is chaos and nothing makes sense anymore if that’s allowed.</p>
<p>From a compiler optimization perspective, tracking provenance allows the compiler to prove that two accesses don’t alias. If it ever loses track of provenance (i.e. if a pointer is passed to an opaque function) then it just conservatively assumes they <em>do</em> alias. But if the compiler <em>never</em>loses track of all the derived pointers to an allocation, it can have perfect aliasing information and do Some Good Codegen.</p>
<p>This is the fundamental trick compilers apply to all basically impossible problems: have a simple  analysis that can answer your query with “YES”, “NO”, or “MAYBE” and then convert “MAYBE” to “YES” or “NO” based on whichever one is safer. Do these two accesses MAYBE alias? Then YES they alias. Problem Solved.</p>
<p>But once you get low-level enough the compiler needs you to help it out and actually follow some dang rules. This is why the llvm <a href="https://llvm.org/docs/GetElementPtr.html">GetElementPointer (GEP)</a> instruction which computes a pointer offset, is almost always emitted by compilers with the <code>inbounds</code> keyword. The <code>inbounds</code> keyword is basically “I promise this offset won’t break the pointer out of its allocation sandbox and completely trash aliasing and provenance”. Which like, yeah all of your pointer offsets should follow that rule!</p>
<p>Let’s go up a level and look at Rust: any time you do <code>(*ptr).my_field</code> the compiler will emit <code>GEP inbounds</code>. Have you ever wondered why the documentation for <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">ptr::offset</a> and friends is so weird and complicated? Because they lower to <code>GEP inbounds</code> and need to follow its rules! <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset">ptr::wrapping_offset</a> is just <code>GEP</code> without the <code>inbounds</code>. And even <code>wrapping_offset</code> isn’t <em>actually</em> allowed to break provenance:</p>
<blockquote>
<p>Compared to <code>offset</code>, this method basically delays the requirement of staying within the same allocated object: <code>offset</code> is immediate Undefined Behavior when crossing object boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a pointer is dereferenced when it is out-of-bounds of the object it is attached to</p>
</blockquote>

<p>Mea culpa, I spent years calling <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> completely unshippable vaporware! I was pretty confident, but I’ll eat my hat because <a href="https://www.arm.com/architecture/cpu/morello">ARM Morello actually built and shipped a full CHERI-based CPU</a>. Congratulations to everyone who worked on it!</p>
<p>So what is CHERI? I’m not going to get into the nitty-gritty details but roughly speaking it’s a 128-bit architecture. Well actually it’s 129-bit. Well actually it’s 64-bit. <em>Sorry what?</em></p>
<p>Ok so the whole Idea with CHERI is that it actually reifies and implements the “sandboxing” model from the previous section. Every pointer is tagged with extra metadata that the hardware maintains and validates. If you ever break out of your sandbox the hardware will catch it and the OS will presumably kill your process.</p>
<p>I don’t know the full details of the encoding or metadata, but the part we care about is that each pointer contains a compressed <em>slice</em> (range of memory) that it is allowed to point into as well as the <em>actual</em> address that it points to. The slice is that pointer’s sandbox, and all pointers derived from it inherit that sandbox (or less). Whenever you access some memory, the hardware just checks that the pointer is still inside its sandbox.</p>
<p>This metadata isn’t cheap: pointers in CHERI are 128-bits wide, but the effective address space is still at most 64-bit (I don’t know the exact upper bound, all that matters is that addresses <em>fit</em> in 64-bit). Now 128-bit is <em>really</em> bloated, so in C(++) CHERI actually gets help from our old nemesis <a href="https://gankra.github.io/blah/rust-layouts-and-abis/#the-c-integer-hierarchy">The Wobbly C Interger Hierarchy</a>.</p>
<p>C makes a distinction between intptr_t (“a pointer-sized integer”) and ptrdiff_t/size_t (“offset-sized integers”). Under CHERI, intptr_t is 128-bit and ptrdiff_t/size_t are 64-bit. It can do this because the address space is still only 64-bit, so anything that refers to offsets or sizes can still be 64-bit.</p>
<p>Ok so you might have two burning questions at this point: how on earth can this possible work if I can just scribble over a pointer and corrupt its metadata, and why did you say it’s actually 129-bit. As it turns out, those are the same question!</p>
<p>I find the best way to conceptualize this is to think of it like <a href="https://en.wikipedia.org/wiki/ECC_memory">ECC (Error Correction Code) RAM</a>. In ECC RAM, each RAM stick actually has more physically memory than it claims, because it’s transparently using that extra memory to correct or detect random bitflips. So there’s all this extra memory <em>somewhere</em> but as far as a compiler or programmer are concerned, the memory looks perfectly normal and doesn’t have any weird extra bits.</p>
<p>CHERI does the same thing, but the extra 129th bit the hardware is hiding from you is a “metadata is valid” bit. You see, to properly manipulate pointers in CHERI you need to access the memory/registers containing a pointer with specific instructions for that task. If you try to manipulate them some other way (say by memcopying random bytes over it), the hardware will disable the “metadata is valid” bit. Then if you try to use the pointer <em>as</em> a pointer, the hardware will see your metadata can’t be trusted and fault/kill your process.</p>
<p>It’s friggin’ neato!</p>
<p>(A lot of the issues we’ll see with integrating Rust with CHERI will actually look a lot like issues with <em>segmented architectures</em>, but I have never used those so I would just be vaguely gesturing at them and handwaving. Just keep in mind that whenever I refer to CHERI, a similar argument <em>also</em> probably applies to segmenting. So if you care about segmented architectures, you might care about CHERI too!)</p>

<p>Now let’s see how Rust’s current unsafe pointer APIs cause problems for all the background we’ve seen above.</p>

<p>Rust currently says this code is neato and fine:</p>

<div><pre><code>
<span>let</span> <span>mut</span> <span>addr</span> <span>=</span> <span>my_ptr</span> <span>as</span> <span>usize</span>;
<span>addr</span> <span>=</span> <span>addr</span> <span>&amp;</span> <span>!</span><span>0x1</span>; 
<span>let</span> <span>new_ptr</span> <span>=</span> <span>addr</span> <span>as</span> <span>*mut</span> <span>T</span>;
<span>*</span><span>new_ptr</span> <span>+</span><span>=</span> <span>10</span>;</code></pre></div>
<p>This is some pretty bog-standard code for messing with tagged pointers, what’s wrong with that?</p>
<p>Think about the background we just discussed. Think about Pointer Provenance. Think about CHERI.</p>
<p>🙀 aAAaAAaaaAAaAAAAAA 🙀</p>
<p>For this to <em>possibly</em> work with Pointer Provenance and Alias Analysis, that stuff must pervasively infect all integers on the assumption that they <em>might</em> be pointers. This is a huge pain in the neck for people who are trying to actually <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">formally define Rust’s memory model</a>, and for people who are <a href="https://github.com/rust-lang/miri">trying to build sanitizers for Rust that catch UB</a>. (And I assure you it’s just as much a headache for all the LLVM and C(++) people too).</p>
<p>For this to <em>possibly</em> work with CHERI we need to make usize 128-bit (even though the address space is 64-bit) and always manipulate it with “pointer instructions” on the assumption that it <em>might</em> be a pointer in the vein of intptr_t. Yes folks have tried running Rust under CHERI and <a href="https://nw0.github.io/cheri-rust.pdf">that’s exactly what they had to do</a>. It was, Not Good.</p>
<p>Unfortunately for CHERI, Rust actually <em>defines</em> <code>usize</code> to be the same size as a pointer, even though its primary role is to be an offset/size. This is a <em>very</em> reasonable assumption for mainstream platforms, but it runs afoul of CHERI (and segmented architectures)!</p>
<p>If you <em>don’t</em> make usize 128-bit and just try to make it the 64-bit “address” portion, then <code>usize as *mut T</code> is a completely incoherent operation. Promoting an integer to a pointer (or what CHERI calls <em>a capability</em>) requires adding metadata to it. What metadata? What range is this random address possibly valid for? There is literally no way to answer that question!</p>
<p>Now you might be thinking “ok but pointer tagging is a super fundamental thing, are you saying we can’t do that anymore?”. Nope! You can totally still do tagging tricks, but you need to be a bit more careful about it. This is why CHERI actually <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf#page=28">introduces a special operation</a> <code>void* cheri_address_set(void* capability, vaddr_t address)</code> which takes a valid pointer and an address, and creates a new pointer with the same metadata and that address. That will be useful to remember!</p>
<p>Hey! That operation <em>also</em> looks really useful for provenance, doesn’t it? By associating out int-to-ptr operation with an existing pointer we are <em>reestablishing</em> the provenance chain of custody! The new pointer is derived from the old one, and compilers and memory-models can be happy! HMMMM…</p>

<p>In the grand old days of Rust 1.0, we were pretty optimistic about how fast-and-loose we could be with raw pointers. Well, ok we were actually pretty rigorous about pointers by most people’s standards. We largely enforced GEP inbounds semantics, alignment, <a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-zsts.html">carved out how to work with ZSTs</a>, <a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-alloc.html">enforce that allocations can’t be larger than isize::MAX</a>, etc.</p>
<p>But what we played really fast and loose on was <em>aliasing</em> and <em>validity</em>. In Ye Olde conception of Rust, references were kinda just <em>conveniences</em>. Like yes they asserted many things, but not in a <em>compiler optimization</em> kinda way. Just in a “this API guarantees this” kinda way. We all vaguely knew we <em>wanted</em> the optimization-y stuff but no one had spent the energy to work that out.</p>
<p>These days, between <a href="https://github.com/rust-lang/unsafe-code-guidelines">unsafe-code-guidelines</a>, <a href="https://github.com/rust-lang/miri">miri</a> and <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">stacked borrows</a>, a lot of us have now put a lot of thought into this. Miri is especially useful because it lets us “kick the tires” on actual code and check if the semantics we’re interested in are actually obeyed by real unsafe Rust code.</p>
<p>They Weren’t! This is why <a href="https://rust-unofficial.github.io/too-many-lists/fifth.html">the unsafe queue</a> in Learn Rust With Entirely Too Many Linked Lists abruptly comes to a halt for a 4000 word delve into miri and stacked borrows! Even something as boring as a linked queue in Ye Olde Rust had confusing and busted semantics.</p>
<p>(For real read that chapter if you want to understand stacked borrows, I’m not rehashing it here.)</p>
<p>The fundamental issue is that under our modern understanding of Rust, even <em>creating</em> a reference is making an extremely strong validity assertion and has side-effects on the “borrow stack” which in turn changes which references are considered to invalidate or not. For a reference to <code>T</code> this potentially includes:</p>
<ul>
<li>The reference is aligned</li>
<li>The reference is non-null</li>
<li>The pointed-to-memory is allocated and has at least <code>size_of::&lt;T&gt;()</code> bytes.</li>
<li>If T has <a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">invalid values</a>, the pointed-to-memory does not contain one.</li>
</ul>
<p>The upshot of all of this is that <em>generally</em> you should avoid mixing references and unsafe pointers. Unsafe code should generally provide a safe referency-interface at its API boundary, and then internally drop the references and try to stay in unsafe pointer land. This way you minimize the strong assertions you make about your sketchy low-level data structures’ memory.</p>
<p>Ok, simple enough, right?</p>
<h2 id="offsets-and-places-are-a-mess"><a href="#offsets-and-places-are-a-mess">2.3 Offsets And Places Are A Mess</a></h2>
<p>So you’re trying to be responsible and stay in unsafe pointer land and it’s time to offset a pointer. That’s easy, we have ptr::offset/add/sub for that! Let’s just offset to this struct’s field… uh… wait what’s that field’s offset?</p>
<p>Oh Rust just, doesn’t tell me that huh? Well maybe you can do something like</p>


<p>Oh no wait that made a reference. Yes even if you immediately cast it to a raw pointer. How the heck do you take an address without creating a reference? Also is it actually fine for me to use a reference to initialize uninit memory? Sort of, sometimes.</p>
<p>This is a big confusing mess. For a long time we tried to have some kind of “5-second rule” thing where if you converted the reference to a raw pointer “fast enough” then it’s OK but that was pretty clearly untenable for a formal model. So folks came up with <a href="https://github.com/rust-lang/rfcs/blob/master/text/2582-raw-reference-mir-operator.md">a proper RFC for raw addresses</a> and for a long time we’ve had a hacky <a href="https://doc.rust-lang.org/stable/std/ptr/macro.addr_of.html">addr_of macro</a> that lets you do this:</p>


<p>…yeah I hate it too.</p>
<p>And even that didn’t put the nail in the coffin. There was recently <a href="https://lucumr.pocoo.org/2022/1/30/unsafe-rust/">a post by a very experienced rust developer</a> that basically amounted to confused frustration at the current state of affairs with doing this stuff with <a href="https://doc.rust-lang.org/nomicon/unchecked-uninit.html">uninitialized memory</a>. Meanwhile the <em>actual</em> thing proposed in the RFC <a href="https://github.com/rust-lang/rust/issues/64490">has seemingly been stalled out for years</a> because the Experts on this stuff are themselves <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/319">confused by the corner-cases of addr_of</a>.</p>
<p>And to make it even worse, addr_of also makes it really hard to do a thing people <em>still</em> want which is static <a href="https://en.cppreference.com/w/cpp/types/offsetof">offsetof</a>.</p>
<p>It is my assertion that a lot of this boils down to two facts:</p>
<ul>
<li>Dereferencing Pointers Is Fake Nonsense</li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">Places</a> Are Extremely Confusing Magic (Rust’s term for lvalues)</li>
</ul>
<p>Like if we think about what “dereferencing” a pointer is… it’s actually nothing? Like dereferencing a pointer doesn’t actually <em>do</em> a thing. It puts you in “place expression” mode and lets you specify an offset to subfields/indices of the pointee, and then what <em>actually</em> happens is only specified at the end. e.g.</p>

<div><pre><code>(<span>*</span><span>ptr</span>).<span>field1</span>.<span>field2</span>[<span>idx3</span>].<span>field4</span>;      
(<span>*</span><span>ptr</span>).<span>field1</span>.<span>field2</span>[<span>idx3</span>].<span>field4</span> <span>=</span> <span>5</span>;  
<span>&amp;</span>(<span>*</span><span>ptr</span>).<span>field1</span>.<span>field2</span>[<span>idx3</span>].<span>field4</span>      </code></pre></div>
<p>This is certainly <em>familiar</em> syntax but it’s genuinely also kind of magical in the exact same way autoderef is in Rust. That is to say, it makes a kind of sense and honestly you just don’t need to think about the fact that it’s happening <em>in safe Rust code</em> because you know the compiler has your back and will help out if anything goes wrong. But in unsafe Rust code? This stuff is way too fuzzy. I literally can’t tell if the indexing is into a slice or an inline array, or if any of those <code>.</code>s is dereferencing stuff implicitly.</p>
<p>As I said before, when you’re doing unsafe pointer stuff you want to <em>stay</em> in that mode. That is currently <em>impossible</em> with this place-expression design, because as soon as you deref you’re kinda in a weird twilight between safe and unsafe!</p>

<p>Alright and now here is where I start going off the rails and proposing wild overhauls to Rust with almost no regard for “parsing”.</p>
<h2 id="distinguish-pointers-and-addresses"><a href="#distinguish-pointers-and-addresses">3.1 Distinguish Pointers And Addresses</a></h2>
<p>The connection between <code>usize</code> and pointers needs to be completely overhauled, and I would take a chainsaw to it (using proper <a href="https://doc.rust-lang.org/edition-guide/editions/index.html">editions and deprecation periods</a>).</p>
<p>Here’s the high level look at our tasteful chainsawing:</p>
<ul>
<li>Define a distinction between a <em>pointer</em> and an <em>address</em></li>
<li>Redefine usizes as address-sized, which is &lt;= pointer-sized (and usually ==)</li>
<li>Define <code>ptr.addr() -&gt; usize</code> and <code>ptr.with_addr(usize) -&gt; ptr</code> methods</li>
<li>Deprecate <code>usize as ptr</code> and <code>ptr as usize</code></li>
</ul>

<p>First off, those definitions. A pointer is still a pointer as we know it, but we now acknowledge that it points into a specific <em>address space</em>. A pointer also contains an <em>address</em> which is conceptually an offset into this address space. (For all major architectures <em>and</em> CHERI there is only one address space as far as I’m concerned, but it’s potentially worth opening the door for properly talking about pointers in segmented architectures here.)</p>
<p>A usize is large enough to contain all addresses for all address spaces on that platform. For major architectures, that means a <code>usize</code> is still pointer-sized. For CHERI, that means <code>usize</code> can (and should) be a <code>u64</code> and is equivalent to CHERI’s <code>vaddr_t</code>. (Again hopefully this generic definition is useful for segmenting but I’m not going to pretend I know that.)</p>
<p>As a result, someone writing <em>maximally portable</em> Rust must now replace their assumptions:</p>
<p><code>size_of::&lt;usize&gt;() == size_of::&lt;*mut u8&gt;()</code></p>
<p>is now:</p>
<p><code>size_of::&lt;usize&gt;() &lt;= size_of::&lt;*mut u8&gt;()</code></p>
<p>There should probably be a <code>cfg(target_address_size_is_pointer_size)</code> or something to allow people to specify software is incompatible with <em>weird</em> platforms where the strict equality doesn’t hold.</p>

<p>Next off, replacing casts with methods. The following new methods would be added:</p>

<div><pre><code>
<span>impl</span><span>&lt;</span><span>T</span>: <span>?</span><span>Sized</span><span>&gt;</span> <span>*mut</span> <span>T</span> {
    
    
    
    
    
    
    
    
    <span>fn</span> <span>addr</span>(<span>self</span>) -&gt; <span>usize</span>;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <span>fn</span> <span>with_addr</span>(<span>self</span>, <span>addr</span>: <span>usize</span>) -&gt; <span>Self</span>;
}</code></pre></div>
<p>Deprecating the casts may seem extreme, but as far as I’m concerned this is the exact same situation as <a href="https://gankra.github.io/blah/initialize-me-maybe/">when we deprecated mem::uninitialized</a>. The design of these casts is fundamentally broken under both Pointer Provenance and CHERI. Everyone needs to use a better design that actually has a coherent meaning.</p>
<p>Now <em>technically</em> you could keep <code>ptr as usize</code> but I think it’s better to replace both for several reasons:</p>
<ul>
<li>Getting a deprecation warning for both sides of the cast raises a big red flag to <em>everyone</em> doing anything even vaguely dubious with a usize that they have some thinking to do.</li>
<li>You can’t hang documentation off of casts. As I hope this post demonstrates, int-ptr stuff is extremely subtle and hairy, and deserves a lot of detailed documentation!</li>
<li><code>ptr as usize</code> is horribly clunky in practice so destroying it is honestly a mercy. </li>
<li>Straight-up symmetry/aesthetics. It’s weird to only have one!</li>
</ul>
<p>As the documentation notes, the new with_addr method serves several roles:</p>
<ul>
<li>It lets us reconstitute what segment the address goes to (hopefully)</li>
<li>It lets us reconstitute <em>provenance</em> for the purposes of memory models / alias analysis</li>
<li>It lets us reconstitute <em>metadata</em> for the purposes of CHERI (but this is just a reification of provenance)</li>
</ul>
<p>…that it! It just fixes the issue. That’s all you need to fix provenance and CHERI! (And maybe also support segmenting.)</p>
<p>(In reality there might need to be some more special APIs added to satisfy the existing Jank uses of ptr-int conversions, but that really needs to be shaken out on crates.io and with the community.)</p>
<p>Unclear detail: is get_addr/with_addr also necessary/useful for <a href="https://www.qualcomm.com/media/documents/files/whitepaper-pointer-authentication-on-armv8-3.pdf">ARMv8.3 Pointer Authentication</a>? This is a technology that Apple ships and involves some pointers getting signed/obfuscated to make it a bit harder to do memory-safety exploits. I haven’t looked into it enough to know what level of abstraction this “leaks” into. I just know about it because it shows up in minidumps and we have to <a href="https://github.com/rust-minidump/rust-minidump/blob/7eed71e4075e0a81696ccc307d6ac68920de5db5/minidump-processor/src/stackwalker/arm64.rs#L252">hackily try to strip it out</a>.</p>
<h2 id="fixing-places-and-offsets"><a href="#fixing-places-and-offsets">3.2 Fixing Places and Offsets</a></h2>
<p>Ok here’s a two-part combo of syntactic niceties to make it a lot easier to work with unsafe pointers.</p>

<p>Hey Did You Know Rust <a href="https://github.com/rust-lang/reference/pull/1149">Never Actually</a> Removed Tilde (~) From <a href="https://doc.rust-lang.org/nightly/reference/tokens.html#punctuation">The Syntax</a>?</p>
<p>Did you also know that <code>~</code> was one of the things that originally drew me to messing around with Rust back in like 2014, and that I was very sad to learn that it was already being removed?</p>
<p>Well today I get my justice. Today I return <code>~</code> to its position of glory that is <em>deserved</em>.</p>
<p>I am almost <em>certain</em> that I’m going to run afoul of parser ambiguities somewhere here but hey this isn’t a real RFC and I get to make the rules. Maybe it works fine. Maybe it can be fixed in an edition. Let’s find out!</p>
<p>Here is my grand vision that will solve all of Rust’s woes around “staying in unsafe pointer mode” and just generally dealing with offsets: If you write <code>~</code> instead of <code>.</code> it always does a raw pointer offset.</p>
<p>That’s it. Ok that’s not just it but that’s basically the whole idea. Let’s start with some examples:</p>

<div><pre><code>
<span>struct</span> <span>MyType</span> {
    <span>field1</span>: <span>bool</span>,
    <span>field2</span>: <span>Vec</span>,
    <span>field3</span>: [<span>u32</span>; <span>4</span>],
}


<span>let</span> <span>init</span> <span>=</span> <span>unsafe</span> {
    <span>let</span> <span>mut</span> <span>uninit</span> <span>=</span> <span>MaybeUninit</span>::<span>&lt;</span><span>MyType</span><span>&gt;</span><span>::uninit</span>();
    <span>let</span> <span>ptr</span> <span>=</span> <span>uninit</span>.<span>as_mut_ptr</span>();

    <span>ptr</span>~<span>field1</span>.<span>write</span>(<span>true</span>);
    <span>ptr</span>~<span>field2</span>.<span>write</span>(<span>vec!</span>[]);
    <span>ptr</span>~<span>field3</span>~[<span>0</span>].<span>write</span>(<span>7</span>);
    <span>ptr</span>~<span>field3</span>~[<span>1</span>].<span>write</span>(<span>2</span>);
    <span>ptr</span>~<span>field3</span>~[<span>2</span>].<span>write</span>(<span>12</span>);
    <span>ptr</span>~<span>field3</span>~[<span>3</span>].<span>write</span>(<span>88</span>);

    <span>uninit</span>.<span>assume_init</span>();
};


<span>unsafe</span> {
    <span>const</span> <span>MY_FIELD_OFFSET</span>: <span>usize</span> <span>=</span> <span>MyType</span>~<span>field1</span>~[<span>2</span>];
    
    
    <span>let</span> <span>mut</span> <span>uninit</span> <span>=</span> <span>MaybeUninit</span>::<span>&lt;</span><span>MyType</span><span>&gt;</span><span>::uninit</span>();
    <span>let</span> <span>ptr</span> <span>=</span> <span>uninit</span>.<span>as_mut_ptr</span>() <span>as</span> <span>*mut</span> <span>u8</span>;

    
    <span>let</span> <span>field_ptr</span> <span>=</span> <span>ptr</span>.<span>wrapping_add</span>(<span>MY_FIELD_OFFSET</span>) <span>as</span> <span>*mut</span> <span>u32</span>;
}</code></pre></div>
<p>Yes <code>~[idx]</code> is a bit wonky but it’s <em>clear</em> and <em>concise</em> and that’s the most important thing. Note that this is what you would have to do in today’s Rust</p>

<div><pre><code><span>let</span> <span>init</span> <span>=</span> <span>unsafe</span> {
    <span>let</span> <span>mut</span> <span>uninit</span> <span>=</span> <span>MaybeUninit</span>::<span>&lt;</span><span>MyType</span><span>&gt;</span><span>::uninit</span>();
    <span>let</span> <span>ptr</span> <span>=</span> <span>uninit</span>.<span>as_mut_ptr</span>();

    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field1</span>).<span>write</span>(<span>true</span>);
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field2</span>).<span>write</span>(<span>vec!</span>[]);
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field3</span>[<span>0</span>]).<span>write</span>(<span>7</span>);
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field3</span>[<span>1</span>]).<span>write</span>(<span>2</span>);
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field3</span>[<span>2</span>]).<span>write</span>(<span>12</span>);
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field3</span>[<span>3</span>]).<span>write</span>(<span>88</span>);

    <span>uninit</span>.<span>assume_init</span>();
};</code></pre></div>
<p>Or if you’re being clever and trying to leverage the fact that POD types can be initialized without <code>write</code>:</p>

<div><pre><code><span>let</span> <span>init</span> <span>=</span> <span>unsafe</span> {
    <span>let</span> <span>mut</span> <span>uninit</span> <span>=</span> <span>MaybeUninit</span>::<span>&lt;</span><span>MyType</span><span>&gt;</span><span>::uninit</span>();
    <span>let</span> <span>ptr</span> <span>=</span> <span>uninit</span>.<span>as_mut_ptr</span>();

    (<span>*</span><span>ptr</span>).<span>field1</span> <span>=</span> <span>true</span>;
    <span>addr_of!</span>((<span>*</span><span>ptr</span>).<span>field2</span>).<span>write</span>(<span>vec!</span>[]);
    (<span>*</span><span>ptr</span>).<span>field3</span>[<span>0</span>] <span>=</span> <span>7</span>;
    (<span>*</span><span>ptr</span>).<span>field3</span>[<span>1</span>] <span>=</span> <span>2</span>;
    (<span>*</span><span>ptr</span>).<span>field3</span>[<span>2</span>] <span>=</span> <span>12</span>;
    (<span>*</span><span>ptr</span>).<span>field3</span>[<span>3</span>] <span>=</span> <span>88</span>;

    <span>uninit</span>.<span>assume_init</span>();
};</code></pre></div>
<p>What I <em>really</em> like about the ~ version is that:</p>
<ul>
<li>
<p>It’s all postfix just like we learned is Very Good And Nice with <code>.await</code>! Just look at how nasty <code>addr_of!((*ptr).field2).write(vec![])</code> is!</p>
</li>
<li>
<p>Because you <em>stay</em> in raw-pointer mode, it’s much less painful to reach for things like the <code>read</code> and <code>write</code> methods. This makes it just as easy to do more complicated things like <code>read_volatile</code> and doesn’t encourage you to be “clever” and lean on the fact that things happen to be POD. All <code>write</code>s is a very nice kind of <em>mindlessly right</em>.</p>
</li>
<li>
<p>You never have to worry about accidentally tripping over autoderef or any other thing that is nice for safe code but a huge hazard for unsafe code.</p>
</li>
</ul>
<p>I am less passionate about the const offsetof stuff but it <em>seems</em> like it could be made to work and I know people really want that stuff. </p>
<p>Additional notes:</p>
<ul>
<li>It should propagate <code>*const</code> vs <code>*mut</code></li>
<li>I don’t know if it makes sense or is a good idea but maybe you could use <code>~</code> on actual references and non-references (int, struct, array, tuple…) and not just raw pointers?
<ul>
<li>If so, it may be desirable to support <code>val~self</code> as a nicer postfix way to write <code>&amp;mut val as *mut _</code> but this is messy if you support both references and non-references since that would be potentially ambiguous as to whether you want a raw-pointer-to-ref or just raw-pointer.</li>
</ul>
</li>
</ul>

<p>This is the least well-formed idea in here, but as long as we’re cleaning up raw pointers with nice and clean postfix syntax it would be <em>really</em> nice if we also had postfix deref. Note that because of the whole “creating a reference does magic assertions” thing you <em>can’t</em> provide something like a <code>deref(self) -&gt; &amp;T</code> method that actually has the same semantics as <code>*ptr</code>! Dereferencing raw pointers <em>must</em> have first-class syntax.</p>
<p>Consider for instance trying to access some multiply-indirected value.</p>
<p>Today:</p>

<div><pre><code><span>addr_of!</span>((<span>*</span>(<span>*</span>(<span>*</span><span>ptr1</span>).<span>field1</span>.<span>ptr2</span>).<span>ptr3</span>).<span>field4</span>).<span>read</span>()</code></pre></div>
<p>With offset syntax:</p>

<div><pre><code>(<span>*</span>(<span>*</span><span>ptr1</span>~<span>field1</span>~<span>ptr2</span>)~<span>ptr3</span>)~<span>field4</span>.<span>read</span>()</code></pre></div>
<p>With offset syntax and reads (remember, we’re staying in pointer mode, so <code>ptr2.read()</code> is loading <code>ptr2</code> from memory, so we can actually keep just using <code>~</code> syntax):</p>

<div><pre><code><span>ptr1</span>~<span>field1</span>~<span>ptr2</span>.<span>read</span>()~<span>ptr3</span>.<span>read</span>()~<span>field4</span>.<span>read</span>()</code></pre></div>
<p>With postfix deref:</p>

<div><pre><code>
<span>ptr1</span>~<span>field1</span>~<span>ptr2</span>.<span>*</span>~<span>ptr3</span>.<span>*</span>~<span>field4</span>.<span>read</span>()


<span>ptr1</span>~<span>field1</span>~<span>ptr2</span>~<span>*</span>~<span>ptr3</span>~<span>*</span>~<span>field4</span>.<span>read</span>()</code></pre></div>
<p>(I think I independently came up with this <code>.*</code> syntax but I was very happy to learn that Zig <a href="https://ziglang.org/documentation/master/#Pointers">actually has it</a>, and <code>ptr.* += 1</code> is valid Zig syntax!)</p>
<p>The ambiguity issue with <code>.*</code> in Rust is that <code>1.</code> is a valid float literal, so stuff like <code>1. * 1.</code> is valid syntax and dangerously close to <code>1.*.1</code>. I certainly can imagine nasty ambiguities!</p>
<p>One nice thing about the <code>~</code> syntax is that because unary <code>*</code> already binds pretty weakly (which is why we need to do <code>(*ptr).field</code>), if you only need to do one deref, it’s as clean as using normal references:</p>


<p>So actually the more I write this section the less I’m feeling the <em>need</em> for postfix deref, but in my heart-of-hearts I still want it.</p>
<p>Oh also you could imagine wanting <code>.&amp;</code> and <code>.&amp;mut</code> but similar syntax messes probably apply.</p>

<p>Jesus that was a lot.</p>
<p>I think about unsafe pointers in Rust a lot.</p>
<p>I wrote this all in one sitting and I really need dinner.</p>
<p>Head empty only pointers.</p>

    </article></div>
  </body>
</html>
