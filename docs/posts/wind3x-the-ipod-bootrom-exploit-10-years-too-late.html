<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://q3k.org/wInd3x.html">Original</a>
    <h1>WInd3x, the iPod Bootrom exploit 10 years too late</h1>
    
    <div id="readability-page-1" class="page">

<p>
    <i>This is a write-up of the wInd3x bootrom exploit affecting iPod Nanos from 3rd gen to 5th gen. A ready-made tool to use this exploit is available at <a href="https://github.com/freemyipod/wInd3x">github.com/freemyipod/wInd3x</a>.</i>
</p>

<center><img src="https://hachibu.net/posts/2023/the-interview-brew/wInd3x-disk.png" alt="iPod Nano 5G in disk mode with the &#39;do not disconnect&#39; icon replaced with a mac bomb subtitled &#39;wInd3x&#39;."/></center>

<h2>Background</h2>

<p>
    The year is 2020. The End Times are nigh. I discover a funny Australian man on YouTube by the name of Dankpods.
</p>

<p>
    <i>“Hey, iPods are kinda neat! I wanna run Doom on them.”</i>, I said to myself.
</p>

<p>
    I quickly realized that while a lot these old iPods were &#39;liberated&#39;/&#39;hacked&#39; (meaning: you could run your own software on them), a lot of them still weren&#39;t. Meaning, at the time, there was no public way to get code execution on any device newer than the iPod Nano 4G.
</p>

<p>
    I found this a bit surprising. Unacceptable, even. I imagined the security on these devices must have been thoroughly broken, similar to older iPhones (see: checkm8 vuln). 
</p>

<p>
    I mean, could I maybe just port some old iPhone exploits to the iPods? Aren&#39;t they like some sort of proto-XNU or something? Even if not, there must be super hackable, right?
</p>

<h2>iPod Tech Stack</h2>

<p>
    Well, not quite. Let&#39;s review:
</p>

<p>
    <b>Operating system</b>: instead of running iOS/XNU, the iPods run a custom embedded RTOS that doesn&#39;t even have a well-documented name. It&#39;s based around the RTXC microkernel, with an UI stack provided by &#39;Pixo&#39;, a company Apple acquired soon in the product lifecycle. The good thing is that this is not a security-oriented OS and it&#39;s likely to be full of bugs. The bad new is that there&#39;s basically no research into it, no known bugs, nothing.
</p>

<p>
    <b>Boot chain</b>: Everything&#39;s encrypted and signed (we&#39;ll get into that later). The on-die BootROM (similar to the BootROM found in early iPhones and iPod touches) chains into a second stage bootloader in NOR/NAND, which in turn sets up drivers for devices and boots a final payload, be it the main OS or disk mode or diagnostics. Interestingly, the second stage bootloader (and some of the payloads, like the diag tool) are based around EFI firmware volumes / drivers. but that&#39;s a topic for another time.
</p>

<p>
    <b>Hardware</b>: Early devices used PortalPlayer SoCs. The devices I&#39;m interested in (Nano 3G+) use Samsung S5L87xx SoCs, which are a close relative of the S5L89xx early iPhone SoCs. The S5L8720 is used both in the iPod Nano 4G and the iPod Touch 2G, but has a different BootROM. There exist no publicly available datasheets of any of these SoCs.
</p>

<h2>Boot Security Chain</h2>


<p>
    The usual boot flow of the device is as follows:
</p>

<pre>    .---------.
    | BootROM |
    &#39;---------&#39;
         |
         | Verifies
         V
    .-------------------------.
    | Second stage bootloader |
    | (NAND/NOR)              |
    &#39;-------------------------&#39;
        |
        | Selects and Verifies
        |&#39;-------.-------------.
        V        V             V
    .--------. .-----------. .--------.
    | OS     | | Disk Mode | | Diags  |
    | (NAND) | | (NAND)    | | (NAND) |
    &#39;--------&#39; &#39;-----------&#39; &#39;--------&#39;

</pre>

<p>
    The BootROM performs enough hardware bring up to be able to load a second stage from a plain sector of NAND/NOR (depending on the generation of the device), then the second stage bootloader brings up a bunch of other peripherals like the LCD/DMA/DRAM/VICs..., displays the apple logo, and allows the user to select the firmware to be loaded (main firmware, disk mode, or diagnostics) based on keypresses. The firmware is loaded from NAND, but this time going through a full-blown Flash Translation Layer.
</p>

<p>
    Each one of the stages being loaded (except the BootROM itself) is wrapped in an <a href="https://freemyipod.org/wiki/Image1">Image1</a>, which was also used in early iPhone devices. This format has the following security properties:
</p>

<ol>
    <li>The header (excluding its signature field) is hashed with SHA1 and the result is encrypted with a fused per-device-generation key. The result is compared against the signature field. Thus, the header is signed.</li>
    <li>Another field in the header determines whether the body is decrypted using the same key. This is true for all firmware payloads observed in the wild.</li>
    <li>Another field in the header determines whether the body is signed using an X509 PKI system, with the fingerprint hardcoded in the previous boot stage. This is true for all firmware payloads observed in the wild, and is mandatory on devices newer than the Nano 3G.</li>
</ol>

<p>
    Things look slightly different when you want to perform recovery on the device:
</p>

<pre>    .---------.
    | BootROM |
    &#39;---------&#39;
         |
         | Verifies
         V
    .-----------.
    | WTF       |
    | (USB DFU) |
    &#39;-----------&#39;
        |
        | Verifies
        V
    .--------------------.
    | Recovery Disk Mode |
    | (USB DFU)          |
    &#39;--------------------&#39;

</pre>

<p>
    As you can see, when doing recovery, we have a similar split into secondary bootloader stage and firmware, but instead of loading the next stage from local storage, we load it over USB, using the DFU protocol. The second stage bootloader is also called &#39;WTF&#39;, for unknown reasons (its main difference from the standard second stage bootloader is that it defaults to loading the next stage over USB DFU, too).
</p>

<p>
    Now, you might already spot a problem here. We&#39;re running a full-blown USB stack and DFU protocol implementation in early bootloader stages, including the bootrom. That&#39;s Generally A Bad Idea, with many systems&#39; security falling to shoddy USB implementations running at the highest privilege levels. Put a pin in that.
</p>

<h2>Prior Art</h2>

<p>
    Of course, I wasn&#39;t the first person looking to liberate these devices.
</p>

<p>
    First, there was iPodLinux, a port of uClinux (now Linux nommu) to old PortalPlayer-based iPods. These folks paved the way towards the initial research on the file formats involved in the iPod firmware. However, things got kinda stuck when iPods moved over to Samsung-based chips (with the release of the iPod Nano 2 and iPod &#39;Classic&#39;).
</p>

<p>
    Then there was Linux4Nano, now Freemyipod, a collective of people looking to get code exec on the S5L-based devices. In collaboration with the brand new iPhone hacking scene, they managed to find and exploit a but called <a href="https://freemyipod.org/wiki/Pwnage_2.0">&#39;Pwnage 2.0&#39;</a>, another bootrom bug, but in the X509 parsing stack. They then reverse-engineered enough of the devices to allow for a Rockbox port to happen for the iPod Nano 2, and the iPod classic. The Pwnage 2.0 bug worked all the way up to the iPod Nano 4G, then it got patched by Apple. Another bug, in the Notes application, also allowed for code exec up to the iPod Nano 4G, this time at the firmware level.
</p>

<p>
    And now, me. To summarize, I had access to the following:
</p>

<ol>
    <li>Code execution on the Nano 2G (Samsung S5L8701), Nano 3G / iPod Classic (Samsung S5L8702), Nano 4G (Samsung S5L8720) thanks to the Pwnage 2.0 bug.</li>
    <li>BootROM dumps from the above devices</li>
    <li>Decrypted firmware for the above devices</li>
    <li>Some reverse engineering notes left behind by previous generations of hackers.</li>
</ol>

<p>
    Everything from the Nano 5G up was basically fully sealed. No firmware dumps, no code execution. Nothing to really reverse engineer. I decided the best course of action would be to <b>find a new vulnerability in the Nano 4G, and port it to later devices</b>.
</p>

<p>
    <b>So I decided to find new bugs in the Nano 4G BootROM</b>
</p>

<h2>Reverse-engineering the BootROM</h2>

<p>
    The easy part was getting started: just take a binary dump, load it at address 0x2000_0000, and start disassembling at the first bytes.
</p>

<p>
    Making sense of what was going on was a bit more complicated. The BootROM is quite small with basically no human-readable strings to use as guidance. Thankfully, I had some reverse-engineered register/memory area notes from the previous generations of hackers, so I could quickly find out that early memory pokes were things like configuring the PLL and clock tree. A few other &#39;anchors&#39; was code to enable/disable clock gates, schedule AES decryption using the built-in AES peripheral, basically any MMIO register pokes was a good place to start documenting things.
</p>

<p>
    Soon enough, I recovered most of the main functionality of the BootROM. Naturally, all the symbol/struct names below are my own, as the BootROM binary was just that, a binary stripped of all its original symbols.
</p>


<pre>void boot(void)

{
  undefined4 spino;
  char *cnCA;
  DFUBoot dfuBoot;

  State *state = g_State;
  g_State-&gt;vtable = &amp;StateVTable;
                    /* Unknown part of CHIPINFO, bits [3:0]. */
  CHIPINFO chipinfo = read_volatile_4(CHIPID_INFO);
  uint chipinfo_unk = (uint)((int)chipinfo &lt;&lt; 0x1c) &gt;&gt; 0x1e;
  state-&gt;chipinfo_unk = chipinfo_unk;
  if (chipinfo_unk == 1) {
    cnCA = &#34;/CN=Apple Secure Boot Certification Authority&#34;;
  }
  else {
                    /* This is in prod certs. */
    cnCA = &#34;/CN=Apple iPod Certification Authority&#34;;
  }
  state-&gt;cnS5L8720SecureBoot = &#34;/CN=S5L8720 Secure Boot&#34;;
  state-&gt;cnCertificationAuthority = cnCA;
  gstatus_set(0,0);
  int disconnected = boot_otg_try_connect_dfu();
  if (disconnected != 0) goto dfu;
  gpio_configure_input(3,5,0);
  gpio_configure_input(3,6,0);
  gpio_configure_input(3,7,0);
  int gpio5 = gpio_read(3,5);
  int gpio6 = gpio_read(3,6);
  int gpio7 = gpio_read(3,7);
  <b>switch</b>(gpio7 | gpio5 &lt;&lt; 2 | gpio6 &lt;&lt; 1) {
  case 0:
  case 2:
    spino = 0;
    break;
  case 1:
  case 3:
    spino = 1;
    break;
  case 4:
  case 5:
  case 6:
    <b>boot_nand();</b>
  default:
    goto dfu;
  }
  <b>boot_spi(spino);</b>
dfu:
  gpio_configure_unk(0xc,3,1);
  gpio_set_bit(0xc,3,1);
  (*g_State-&gt;vtable-&gt;DFUBootDFUBoot)(&amp;dfuBoot);
  /* setup dfuBoot... */
  (*g_State-&gt;vtable-&gt;DFUBootSetup)(&amp;dfuBoot);
  (*g_State-&gt;vtable-&gt;DFUBootSetupUSB)();
  <b>(*g_State-&gt;vtable-&gt;DFUBootRun)();</b>
  return;
}
</pre>

<p>
    You can see how the BootROM decides, based on some GPIO straps (and likely GPIO comms from some PMIC or the clickwheel) to boot over NAND, NOR(SPI) or over USB.
</p>

<p>
    Inside each boot method handler, there would be some calls to verify the integrity of the loaded IMG1. For example, in boot_nand:
</p>

<pre>undefined4 boot_nand(void)

{
  clkgen_enable_gate(5);
  clkgen_enable_gate(9);
  nand_power_up_maybe();
  nand_reset(0);
  nand_read_maybe(0,0,(int)&amp;hdr);
  bool bVar1 = <b>(*g_State-&gt;vtable-&gt;verify_img_header)(&amp;hdr,AES_KEY_TYPE_GLOBAL);</b>
  if (((bVar1 != false) &amp;&amp; (hdr.field2_0x7 == ASYMMETRIC || hdr.field2_0x7 == ASYMMETRIC_ENCRYPTED))
     &amp;&amp; (hdr.bodySize &lt; 0x24c01)) {
    uint i = 0;
    uint count = hdr.bodySize / 0x600;
    if (hdr.bodySize % 0x600 != 0) {
      count = count + 1;
    }
    if (count != 0) {
      do {
        nand_read_maybe(0,i + 1,(int)(&amp;g_IMG_Payload + i * 0x180));
        i = i + 1;
      } while (i &lt; count);
    }
    <b>int iVar2 = (*g_State-&gt;vtable-&gt;verify_decrypt_image)(&amp;hdr,&amp;g_IMG_Payload,2);</b>
    if (iVar2 != 0) {
      offset = g_State-&gt;img_header_jump_offset;
      gstatus_set(3,0);
      <b>prepare_and_jump((int)&amp;g_IMG_Payload + offset);</b>
    }
  }
  return 0;
}
</pre>

<p>
    You can see a NAND page (?) read, followed by a call to verify_img_header which ensures the header passes the AES(SHA(header), fused_key) == header.sign check. After that, we load a bunch of more NAND pages of the body of the IMG1, and finally we call verify_decrypt_image on the entirety of the loaded image. That in turn performs a signature checking of the body, this time using X509. The loaded payload is expected to have a valid certificate chain appended to its end.
</p>

<p>
    That X509 codepath above is where <a href="https://freemyipod.org/wiki/Pwnage_2.0">&#39;Pwnage 2.0&#39;</a> lives. It&#39;s an extremely dumb vulnerability in a quite clever ASN.1/DER parser. See the linked Wiki article for more details. Needless to say, I did look around the X509 parsing code for more bugs, but I didn&#39;t really find anything. Some of the cert chain logic is quite hairy though, so maybe someone else will have more luck :).
</p>

<p>
    There&#39;s plenty more code in the BootROM, and this was mostly just an example of how such a codebase can look like when you spend dozens of hours pouring over it. This still isn&#39;t perfect, but it&#39;s enough to actually look for bugs.
</p>

<h2>The bug: USB wIndex == magic</h2>

<p>
    Let&#39;s get on with it. What&#39;s the bug I ended up finding? An extremely trivial vulnerability in the USB stack, of course. It was so trivial in fact that I missed it when I was doing a first pass over the codebase.
</p>

<p>
    Deep inside a forest of callbacks, &#39;ops&#39; structures and magical register pokes to a Synopsys USB OTG peripheral, we find a function which actually parses a received SETUP packet:
</p>

<pre>void USB::HandlePendingSetup(void)

{
  usb_device_request *req;
  USBHandler *fptr;
  uint index;
  byte bmRequestType;
  USBState state;

  if (g_State-&gt;ep0state != SETUP) {
    return;
  }
  <b>req = (usb_device_request *)g_State-&gt;ep0_dma;</b>
  state = g_State-&gt;usbState;
                    /* INIT or CONFIGURED */
  if (state &lt; 3) {
LAB_20004e18:
    EP0Stall();
    PrepareRecvBuf();
    return;
  }
  [...]
</pre>

<p>
    The important part is that g_state-&gt;ep0_dma is the memory buffer configured to be populated with a USB packet received on Endpoint 0. That is, these are directly controlled by the attacker. The code assumes this is USB SETUP packet, xtracts the bmRequestType field from it and dispatches on it:
</p>

<pre>  bmRequestType = req-&gt;bmRequestType;
  if ((bmRequestType &amp; 0x60) == 0) {
    /* Type == Standard */
    EP0OutSetupStandard(req);
    PrepareRecvBuf();
    return;
  }
  if ((bmRequestType &amp; 0x60) == 0x20) {
    /* Type == Class */
    [...]
  } else if ((bmRequestType &amp; 0x60) == 0x40) {
    /* Type == Vendor */
    [...]
  } else {
    goto LAB_20004e18;
  }
</pre>

<p>
    Pretty normal stuff. Check if it&#39;s a Standard request, and if so, handle that by a call to EP0OutSetupStandard. If it&#39;s a Class or Vendor request type, handle that too. Otherwise, stall and fail. Let&#39;s zoom into that Class handler:
</p>

<pre>    index = (uint)req-&gt;wIndex[0];
    if (state &lt; CONFIG_0) goto LAB_20004d20;
    if ((bmRequestType &amp; 3) == 0) {
      /* Recipient == Device */
      fptr = (USBHandler *)g_State-&gt;usbHandlers[index].handlerClass;
      goto joined_r0x20004d9c;
    }
    if ((bmRequestType &amp; 3) == 1) {
      if (index == 0) {
        fptr = (USBHandler *)g_State-&gt;usbHandlers[0].handlerClass;
        goto joined_r0x20004d9c;
      }
    }
    [...]
</pre>

<p>
    There it is. The bug&#39;s right there. Can you see it?
</p>

<p>
That&#39;s right. <b>If (bmRequestType &amp; 0x3) == 0, the user-controlled &#39;index&#39; (populated from the lower byte of the wIndex field of the SETUP packet) is used as an index into g_State-&gt;usbHandlers without any boundary checks.</b> Then, the result of that index is executed as a function (not shown here). Oops. The same buggy codepath exists in the Vendor handler, too.
</p>

<p>
    And indeed, if we send a crafted USB SETUP packet to the BootROM in DFU mode with bmRequestType set to 0x20 (passing the two checks above) and wIndex set to 0xff00, <b>we crash the BootROM</b> on the Nano 4G and... Nano 5G! That&#39;s a new device on which we never had code exec before! But let&#39;s first try to exploit this on the Nano 4G, as we have the BootROM dump for that.
</p>

<h2>Exploiting the Nano 4G</h2>

<p>
    At this point we need to familiarize ourselves a bit more with the State structure and its usbHandlers member.
</p>

<pre>typedef struct {
    uint stuff[0x15];
    USBInterfaceHandlers usbHandlers[1];
    // other things afterwards...
} State;

typedef struct {
    USBInterfaceDescriptor *interfaceDescriptor;
    void *onSetConfiguration;
    void *unk;
    void *onSynchFrame;
    void *handlerClass;
    void *handlerVendor;
} USBInterfaceHandlers;
</pre>

<p>
    So effectively, what we can do, is treat some of the fields after usbHandlers in State as a code pointer to jump to. Doing some math, these are offsets 0x64 + (0x1c * n) and 0x68 + (0x1c * n) for N in 0..255.
</p>

<p>
    I&#39;ll spare you the details, but what I found was the following: if you set wIndex to 3 and send a Class request, we&#39;ll treat the uint at offset 184 in the State structure as a code pointer and execute it. And in that offset in State, there&#39;s a counter I called ep0_txbuf_offs.
</p>

<p>
    The BootROM DFU can not only receive an image to run on the device, but also send what it currently has in its buffer. The implementation of it is actually broken, but if you first request N bytes of the image, then time out the read from the host side, ep0_txbuf_offs will contain N-0x40 (ie. the amount of data left to send, minus the first packet size).
</p>

<p>
    There&#39;s some size limits in place, but by scheduling a firmware send from the device, and then sending bmRequest=0x20 and wIndex=3, we can get the device to execute at any address from 0x000 to 0x600. If you know your ARM devices, you&#39;ll also know that these low addresses must contain an interrupt vector for the CPU. That usually means most devices will mirror their current execution medium (in this case the BootROM) into these low addresses, and that&#39;s also the case here.
</p>

<p>
    So, we can execute addresses 0x000 to 0x600 from the BootROM... what now? Well, under address 0x3b0 we find the following:
</p>

<pre>        200003b0 30 ff 2f e1     blx        r0
</pre>

<p>
    This nice little gadget is effectively a trampoline that will continue executing from whatever address is in r0, the first register of the ARM CPU. This register is also used, in the standard ARM ABI, to hold the first argument passsed to a function. And luckily, in USB::HandlePendingSetup, the corrupt fptr is actually called with an argument: ep0_dma.
</p>

<p>
    <b>Well that&#39;s fun! By scheduling a read of 0x3b0+0x40, then performing the wInd3x bug, we&#39;ll start executing the USB SETUP packet as ARM code!</b>
</p>

<p>
    This means it&#39;s time for me to introduce to you to my favourite part of the exploit chain: <b>a polyglot ARM shellcode and USB packet:</b>
</p>

<pre>    0x20 0xfe 0xff 0xea 0x03 0x00 0x00 0x00
</pre>

<p>
    When parsed as a USB SETUP packet, it has a bmRequsetType of 0x20, a bRequest of 0xfe, a wValue of 0xffea, and a wIndex of 3. This means it triggers the wInd3x bug above.
</p>

<p>
    When parsed as ARM code executing from 0x2202e300 (where ep0_dma lives), it&#39;s:
</p>

<pre>$ rasm2 -a arm -b 32 -o 0x2202e300 -D &#34;20feffea03000000&#34;
0x2202e300   4                 20feffea  b 0x2202db88
0x2202e304   4                 03000000  andeq r0, r0, r3
</pre>

<p>
    Incidentally, 0x2202db88 is 136 bytes into the DFU buffer, which is pretty much &#39;unlimited&#39; in size and very easily controlled. <b>We now have stable code exec!</b>
</p>

<p>
    With this, we can start sending the device some &#39;shell&#39;code. On of the earliest things I wrote was proof of concept &#39;send-memory-region-over-USB&#39;. In a future article, we&#39;ll discuss more practical payloads, but for now let&#39;s focus on the reason we&#39;re even here:
</p>

<h2>Exploiting the Nano 5G</h2>

<p>
    We&#39;re now in The Cool Zone. We experimentally confirmed the Nano 5G BootROM is vulnerable to wInd3x due to a crash, but we have absolutely no BootROM dumps to actually craft our exploit as easily as for the Nano 4G. Just trying the same payload doesn&#39;t work either (as expected, the offsets are probably all different due to a recompilation of the BootROM).
</p>

<p>
    First I wanted to check if the first part of the exploit, jumping into the 0x000..0x600 memory by controlling ep0_dma still worked. I was able to come up with a simple &#39;oracle&#39; test: if ep0_dma is 0, then we should jump to address 0x000 which is the reset vector, which should basically restart DFU mode. However, if I set it to 4, then it should jump to 0x004 which is the invalid instruction handler, which I know the Nano 4G BootROM implemented as an infinite loop. That worked, so I knew I could control that part of the execution.
</p>

<p>
    Now, my goal was to find a working &#39;blx r0&#39; gadget somewhere in the first 0x600 bytes. So I bruteforced that, and kept notes:
</p>

<pre>    # 374: stuck
    # 378: returns
    # 37c: restart &lt;- curious
    # 380: returns
    # 384: stuck
    # 388: returns
    # 38c: returns
    # 390: stuck
    # 394: returns
    # 398: returns
    # 39c: stuck
    # 3a0: stuck
    # 3b0: stuck
    # 3b4: stuck
    # 3b8-3fc: return
</pre>

<p>
    One address popped out as having a different behaviour: 0x37c. Everything else either crashed the device (and caused it to be stuck in an infloop) or had no effect (likely hitting a block of code ending with a mov pc, lr). I could now work on my USB/ARM polyglot payload. To my surprise, it worked out of the box: depending on whether I populated the DFU buffer with &#39;loop: b loop&#39; or &#39;bl #0x0&#39; instructions, I got different behaviour.
</p>

<p>
    Now, I could execute code, but I had really no way to get any result out from it, as I didn&#39;t know the address of the USB send buffer to inject data into. Well, almost no way. I could after all, either get the device stuck (by doing an infloop), or restart it (by jumping to 0). That means I could leak, one bit at a time, some data. So I wrote some janky ARM payloads that would calculate a bit from somwhere (eg. looking for some memory pattern, then leaking the Nth bit of the found address) that allowed me to very slowly leak some facts about the BootROM, like where the buffers lived.
</p>

<p>
    ... but in the end, it turns out the buffer addresses for the Nano 5G were exactly the same as for the Nano 4G. So I could pretty much just re-use my old code as was, the only difference being 0x37c instead of 0x3b0 as the &#39;blx r0&#39; trampoline address :).
</p>

<h2>What have we learned?</h2>

<p>
    Don&#39;t put a C implementation of a USB stack in your BootROM, lol.
</p>

<h2>What&#39;s next?</h2>

<p>
    Well, the exploit is pretty stable. I&#39;ve build up some more tooling on top of the bug (subject to a future article here) that allows me to boot customized firmware over USB.
</p>

<p>
    I&#39;ve also made some progress on porting Linux and U-Boot to the Nano 5G:
</p>

<pre>U-Boot 2023.01-rc4-q3k-00055-g7de7e65add (Jan 01 1980 - 00:00:00 +0000)

CPU: Samsung/Apple S5L8730
Model: Apple iPod Nano 5G
DRAM:  64 MiB
Core:  5 devices, 5 uclasses, devicetree: separate
MMC:
Loading Environment from nowhere... OK
In:    serial@3cc00000
Out:   serial@3cc00000
Err:   serial@3cc00000
Net:   No ethernet found.
=&gt; dfu 0 ram 0
s5l87xx_lcd_init: detected LCD type 38f7 (2)
s5l87xx_otgphy: turning on
s5l87xx: ungating usb-otg
s5l87xx: ungating usb2-phy
#DOWNLOAD ... OK
Ctrl+C to exit ...
s5l87xx_otgphy: turning off
=&gt; bootm
## Booting kernel from Legacy Image at 08000000 ...
   Image Name:
   Image Type:   ARM Linux Multi-File Image (uncompressed)
   Data Size:    7189312 Bytes = 6.9 MiB
   Load Address: 08000000
   Entry Point:  08000000
   Contents:
      Image 0: 5722624 Bytes = 5.5 MiB
      Image 1: 1465230 Bytes = 1.4 MiB
      Image 2: 1440 Bytes = 1.4 KiB
   Verifying Checksum ... OK
## Loading init Ramdisk from multi component Legacy Image at 08000000 ...
## Flattened Device Tree from multi component Image at 08000000
   Booting using the fdt at 0x086dade0
Working FDT set to 86dade0
   Loading Multi-File Image
WARNING: legacy format multi component image overwritten
   Loading Ramdisk to 0ae1c000, end 0af81b8e ... OK
   Loading Device Tree to 0ae18000, end 0ae1b59f ... OK
Working FDT set to ae18000

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.2.0-rc3-00024-ge2e3252e9e4e (q3k@mimeomia) (arm-none-eabi-gcc (GNU Arm Embedded Toolchain 10.3-2021.10) 10.3.1 20210824 (release), GNU ld (GNU Arm Embedded Toolchain 10.3-2021.10) 2.36.1.20210621) #15 Thu Jan 12 23:37:12 CET 2023
[    0.000000] CPU: ARMv6-compatible processor [410fb764] revision 4 (ARMv7), cr=00c5387d
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache
[    0.000000] OF: fdt: Machine model: Apple iPod Nano 5G
[...]
[    1.520000] Freeing unused kernel image (initmem) memory: 1024K
[    1.530000] Run /init as init process
Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Saving random seed: [    2.160000] random: dd: uninitialized urandom read (32 bytes read)
OK
Starting network: OK

Welcome to Buildroot
buildroot login:
#

</pre>

<p>
    There&#39;s still some things to figure out though for a <b>Fully Liberated iPod Experience</b>:
</p>

<ol>
    <li>Untethering code execution on the Nano 5G: currently we always have to run our own code over USB.</li>
    <li>Getting code execution on the Nano 6G and 7G, for example by finding a bug in the firmware. They are not susceptible to wInd3x.</li>
    <li>Reverse-engineering more peripherals for the Nano 5G, and finishing the Linux port.</li>
    <li>Writing a Good implementation of the Whimory FTL used in the iPod Nano 3G+.</li>
    <li>A Rockbox port for the Nano 3G, 4G and 5G.</li>
</ol>

<p>
    <b>If you&#39;re curious in seeing regular updates (or even want to help!), join us on the #freemyipod channel on Libera.chat, or on #freemyipod:hackerspace.pl on Matrix.</b> You can also check out the (mostly not dead) <a href="https://freemyipod.org/">Freemyipod Wiki</a>, or take a look at the <a href="https://github.com/freemyipod/wInd3x/">wInd3x tool itself</a>.
</p>

<p>
    And as a prize for making it all the way through this drivel, I&#39;ll leave you with a final curiosity: wInd3x also affects the iPhone 3G (and probably the original iPhone), but I wasn&#39;t yet able to chain together an exploit for them. Wanna be a part of the Useless Old Device 0dayz Scene? :)
</p>


<p>Copyright 2023 Serge Bazanski. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>

<p><i><a href="https://hachibu.net/">Back to q3k.org</a></i>.</p>
</div>
  </body>
</html>
