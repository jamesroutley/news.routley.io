<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shopify.engineering/react-native-new-architecture">Original</a>
    <h1>Migrating to React Native&#39;s New Architecture</h1>
    
    <div id="readability-page-1" class="page"><div id="article-content" itemprop="articleBody"><div><h2><strong>Introduction</strong></h2>
<p><strong>We successfully migrated two of our largest apps, Shopify Mobile and Shopify Point of Sale (POS) to React Native&#39;s </strong><a href="https://reactnative.dev/architecture/landing-page" rel="nofollow noopener noreferrer" target="_blank"><strong>New Architecture</strong></a><strong> while maintaining weekly releases and serving millions of merchants.</strong> This migration involved a complex codebase with hundreds of screens and native modules, extensive custom components, and deep integration with first-party libraries like <a href="https://github.com/shopify/flash-list" rel="nofollow noopener noreferrer" target="_blank">FlashList</a>.</p>
<p><strong>Key outcomes:</strong></p>
<ul>
<li>Maintained development velocity throughout migration</li>
<li>Zero feature development disruption</li>
<li>Identified and solved common migration issues at scale</li>
</ul>
<p>This post shares our migration approach, the key decisions we made, and the lessons we learned so other teams can benefit from our experience. We&#39;ll cover the practical strategies we used to successfully migrate the Shopify mobile app while maintaining development velocity and app stability.</p>
<h2><strong>Migration Strategy: Keeping the Ship Moving</strong></h2>
<h3><strong>Guiding Principles</strong></h3>
<p>Our migration strategy was built on three core principles:</p>
<ol>
<li>
<strong>Minimize code changes first, refactor later</strong>: Make only the minimum necessary code changes to enable the New Architecture. Optimization and refactoring could come after. Migrating as quickly as possible was crucial to stop introducing new code that would break the build process on the new architecture.</li>
<li>
<strong>Maintain dual architecture compatibility during development</strong>: Support both old and new architectures throughout the migration process to enable continuous testing and prevent regressions. Remove old architecture support after shipping.</li>
<li>
<strong>Maintain performance and stability parity</strong>: Ensure the new architecture matched or exceeded the old architecture&#39;s performance and stability, particularly on TTI (time to interactive) metrics and crash free sessions before shipping to production.</li>
</ol>
<h3><strong>Maintaining Development Velocity</strong></h3>
<p><strong>At Shopify, we ship app updates weekly</strong>, making continuous feature development critical during migration. For large apps, pausing development is risky—technical difficulties could delay essential features or bug fixes.</p>
<p>Our approach balanced migration progress with merchant needs:</p>
<ul>
<li>
<strong>Dual architecture testing</strong>: Leveraging <a href="https://shopify.engineering/shopify-tophat-mobile-developer-testing" rel="nofollow noopener noreferrer" target="_blank">TopHat</a>, we generated builds for both architectures on every PR, enabling easy testing without local rebuilds and preventing new architecture breaking changes from merging.</li>
</ul>
<p><img src="https://cdn.shopify.com/s/files/1/0779/4361/files/dualsupport.png?v=1757030967" alt=""/></p>
<ul>
<li>
<strong>Conditional functionality</strong>: For third-party dependencies that did not simultaneously support both architectures on a single version, we used feature flags to conditionally disable functionality in development mode on the new architecture.</li>
</ul>
<p><strong><em>Key insight for library maintainers: </em></strong>Provide a version that supports both architectures. Managing conditional versioning isn&#39;t trivial—dual support significantly eases migration burden. This is why we maintained both architectures in <a href="https://shopify.engineering/flashlist-v2" rel="nofollow noopener noreferrer" target="_blank">FlashList v2</a> alpha versions.</p>
<h2><strong>Technical Deep Dive</strong></h2>
<h3><strong>Migration Process</strong></h3>
<ul>
<li>
<strong>Native Modules Strategy</strong>: We did not migrate any modules to TurboModules during the migration. Instead, we only made changes to modules that did not work on the new architecture (mostly modules that dealt with UIManager). We used feature flags to fork the implementation, ensuring compatibility with both architectures. While TurboModules represent a step forward, they are not mandatory (yet), and with 40+ modules in the Shopify App, we decided to re-evaluate them after the migration. This allows us to determine which modules are still useful and how we can improve their APIs by leveraging the new capabilities of TurboModules.</li>
</ul>
<ul>
<li>
<strong>Dependency Management</strong>: We updated incompatible dependencies to dual-architecture versions. We also patched or removed unmaintained libraries. This provided an opportunity to reduce our dependency footprint.</li>
</ul>
<ul>
<li>
<strong>Upgrade to The Latest React Native Version: </strong>The new architecture is under intense development with continuous bug fixes and performance improvements. We prioritized upgrading to the latest React Native version available at the time, and ensuring it worked stable before starting app-specific optimizations. This approach ensured we benefited from upstream improvements rather than fixing issues that might already be resolved. <span><strong>The majority of bugs we encountered were fixed with version upgrades.</strong></span> Therefore we recommend updating to the latest possible version before starting the migration effort. </li>
</ul>
<ul>
<li>
<strong>App Code Changes:</strong> We made minimal changes to ensure feature code worked on both architectures. We also added deprecation warnings to temporary code paths for post-migration cleanup.</li>
</ul>
<h3><strong>Common Migration Issues</strong></h3>
<p>The migration required adapting to the new architecture&#39;s synchronous rendering model and updated native module interfaces, which impacted how our existing components and native integrations functioned.</p>
<p>Here are the most common issues we faced and their solutions:</p>
<p><strong>State Batching Exposing Component Issues</strong> </p>
<p><strong>Blank Screen of Doom</strong> </p>
<p><strong>Shadow Tree Manipulation Changes</strong> </p>
<p>In the case of Mobile Bridge, we used native modules to swap WebView components that were declared in React Native code on both iOS and Android. At best, this resulted in WebViews not loading, and at worst, in crashes. <span>We solved this problem by completely removing the WebView from React Native and managing its lifecycle entirely on the native side.</span> This was the simplest approach for our situation since we wanted to maintain compatibility with both architectures and reuse as much of our existing implementation as possible.</p>
<p><strong>View Flattening Side Effects</strong> </p>
<p><strong>Legacy Native Modules on the Main Thread</strong></p>
<p><strong><em>Solution:</em></strong> If you still have legacy native modules, make sure to set <code>requiresMainQueueSetup</code> to false unless strictly necessary. In most cases, it is not.</p>
<h3><strong>Animation Performance Concerns</strong></h3>
<p>The Shopify app uses <a href="https://docs.swmansion.com/react-native-reanimated/" rel="nofollow noopener noreferrer" target="_blank">Reanimated</a> extensively for navigation animations. We encountered severe frame rate drops on both platforms—issues unique to our scale and animation complexity.</p>
<p>These challenges highlighted the realities of early adoption on a large project. However, the response from both Software Mansion (Reanimated&#39;s maintainers) and Meta was exceptional. Both teams worked closely with us to identify and address performance issues that likely would have gone unnoticed in smaller or less complex applications.</p>
<p>Software Mansion provided early access to patches that addressed most of the performance issues. We&#39;re currently collaborating with both Meta and Software Mansion to integrate these fixes into Reanimated and React Native itself, ensuring the broader community benefits from the improvements discovered through our large-scale testing. The performance improvements and bug fixes resulting from this partnership will benefit all teams using Reanimated with the new architecture.</p>
<p><strong>Recommendation</strong>: For the majority of apps, we still recommend using Reanimated. These performance concerns appear to be noticeable primarily with complex animations at scale, and depending on where they&#39;re applied, may not significantly impact users.</p>
<h3><strong>Rollout Approach</strong></h3>
<p>Because this is not something we can ship behind a remote feature flag, we used a careful gradual rollout strategy to monitor stability and performance.</p>
<p>It was important to consider the differences in rollout control between the App Store and Play Store. </p>
<p>The Google Play Store offers fine-grained rollout control with the ability to set specific percentages and halt new installations at any time. The App Store, in contrast, uses a pre-determined gradual rollout schedule. When paused, users can <em>still</em> manually update to the new version. Additionally, the approval process for new submissions to the App Store can take up to 24 hours, making hotfixes slower and riskier.</p>
<p>For this reason, we prepared a schedule where we start with Android, gradually increasing the rollout. iOS started a day later, once we had more confidence on the stability of the release.</p>
<p><strong>Rollout Schedule:</strong></p>
<ul>
<li>
<strong>Day 1 - Android 8% and iOS 0%</strong>: the goal was to get early signals from Android since it can be fully stopped at any time.</li>
<li>
<strong>Day 2 - Android 30%, iOS 1%</strong>: substantial increase in Android rollout percentage, while keeping low adoption numbers on iOS to give us time to react.</li>
<li>
<strong>Day 3 - both platforms 100%: </strong>at this point we have high confidence no major issues are found. Since we can&#39;t increase iOS to a specific percentage, we elect to do a full rollout on both platforms so we have data at scale to work with. </li>
</ul>
<p><strong>Emergency Response Plan:</strong></p>
<p>Our stability target (crash free sessions) for the Shopify app is 99.95%. For this release, we established three response tiers based on stability thresholds:</p>
<ol>
<li>Stability above 99.80%: <strong>fix forward on next weekly release</strong>
</li>
<li>Stability between 99.00% and 99.80%, or broken critical flow with a known fix: <strong>pause rollout and hotfix</strong> </li>
<li>Stability below 99.00% or broken critical flow without a quick fix: <strong>rollback</strong>
</li>
</ol>
<p>Rollback was treated as a last resort because it had severe consequences for our migration timeline. We needed the data that only comes at scale when releasing the app to the public. Rolling back was not only operationally heavy, but it also would have set us back significantly in our migration progress. If we could pause the rollout early and address stability issues instead, we preferred that approach.</p>
<h3><strong>What Went Well</strong></h3>
<p>The migration was ultimately successful with minimal disruption to our development workflow. We maintained our weekly shipping cadence throughout the entire migration period, delivering new features to merchants without interruption. </p>
<p>While the focus was on making that transition, there were a few immediate wins from just migrating to Fabric:</p>
<ul>
<li>App launch times improved by about 10% on Android, and 3% on iOS.</li>
<li>We were able to simplify our screen rendering by leveraging measure before paint, which led to smoother and faster screen loads cases. You can read more about this on our <a href="https://shopify.engineering/flashlist-v2" rel="nofollow noopener noreferrer" target="_blank">FlashList v2 blog post</a>.</li>
<li>The new batched state reduced unnecessary re-renders, which made things like tab switching snappier.</li>
</ul>
<p>Overall, our team&#39;s expertise with the new architecture grew significantly during the process. What started as unfamiliarity became deep understanding, positioning us well for future React Native updates and optimizations.</p>
<p>The broader React Native ecosystem also benefited from our learnings. We rebuilt FlashList from scratch, providing practical code examples on how to optimize rendering performance on the New Architecture. We also worked closely with Meta and Software Mansion to uncover, <a href="https://github.com/facebook/react-native/pull/49849" rel="nofollow noopener noreferrer" target="_blank">fix bugs</a> and performance issues that are now being addressed upstream. </p>
<p>Hopefully this blog post can help other teams navigate similar challenges, creating lasting value beyond our own product.</p>
<h3><strong>What Did Not Go Well</strong></h3>
<p>While we measured performance extensively and made optimizations before rollout, we encountered some challenges that only became apparent at production scale. Despite our due diligence in internal testing, the real-world impact was more significant than anticipated.</p>
<p><strong>Performance Degradation</strong>: Some screens needed some performance tuning post release, since the changes to the rendering path broke some of the assumptions that were made when we created these components. We saw increases of up to 20% in load times on some complex components. These were not to blame on the New Architecture itself. It just revealed cracks in some component designs that were previously invisible.</p>
<p><strong>Stability Challenges</strong>: Session stability (crash-free sessions) dropped from our 99.95% target initially, recovering after a couple of weeks of bug fixing. We still see low occurrence crashes deep into RN or 3rd party library code, but nothing too impactful. We&#39;re working with Meta and library maintainers to find solutions.</p>
<p><strong>ANR Spikes</strong>: Application Not Responding crashes increased on both platforms, some from our custom Reanimated/React Native patches that fixed other performance issues. Some deadlocks were also introduced due to some native modules being initialized on the main thread. This didn&#39;t result in a problem on the old architecture, but in some rare cases it crashed the app on the new.</p>
<p>Given this was a fundamental change to our most important framework, it could have been much worse. We remain optimistic about React Native&#39;s future and believe the new architecture provides a better foundation for addressing these performance concerns.</p>
<h3><strong>Recommendations for Other Teams</strong></h3>
<p>The React Native new architecture migration is challenging but achievable with proper planning.</p>
<p>These recommendations are based on our experience migrating a large-scale production app serving millions of users. Depending on your project&#39;s size and complexity, you may need to adjust these approaches, but they provide a solid foundation for planning your migration.</p>
<ol>
<li>
<strong>Audit dependencies early</strong> - Identify compatibility issues before starting migration.</li>
<li>
<strong>Upgrade to the latest RN version before touching any code</strong> - Avoid wasting time on issues that were already fixed upstream. Release the upgrade before starting the migration to minimize the blast radius of changes.</li>
<li>
<strong>Get the ball rolling</strong> - Focus on enabling Fabric in development as soon as possible. That exposure will give your team valuable signals on what areas of your app need attention. Maintain compatibility with the old architecture.</li>
<li>
<strong>Leverage the community</strong> - Many issues you&#39;ll encounter have already been discussed in <a href="https://github.com/facebook/react-native/issues" rel="nofollow noopener noreferrer" target="_blank">GitHub issues on the React Native repository</a> or in other areas of the <a href="https://reactnative.dev/community/communities" rel="nofollow noopener noreferrer" target="_blank">community</a>. Search existing issues and discussions before trying to solve problems from scratch.</li>
<li>
<strong>Minimize changes initially</strong> - Prioritize bug fixes, and perform targeted optimizations before releasing.</li>
<li>
<strong>Strategic native modules</strong> - Only migrate modules with clear benefits to start.</li>
<li>
<strong>Plan for stability and performance degradation with phased rollouts</strong> - Accept temporary stability reduction and leverage app store gradual rollout features for risk mitigation.</li>
<li>
<strong>Fix forward when possible</strong> - Avoid rollbacks to maintain momentum.</li>
</ol>
<h2><strong>What&#39;s Next</strong></h2>
<p>With the new architecture foundation in place, our focus shifts from compatibility to optimization. We can now leverage capabilities that were impossible before, addressing our current performance challenges while building better user experiences.</p>
<p>Our next priorities include:</p>
<ul>
<li>
<strong>Strategic TurboModule migration</strong>: Convert high-frequency modules (user preferences, feature flags) and performance-critical paths to eliminate serialization costs</li>
<li>
<strong>Synchronous layout adoption</strong>: Build better components leveraging synchronous layout to eliminate visual jumps and improve performance on complex layouts</li>
<li>
<strong>Performance optimization</strong>: Use lazy TurboModule loading and optimized rendering to address our TTI and app launch time challenges</li>
</ul>
<p>Finally, we’d like to give special thanks to Meta and Software Mansion for being amazing partners, and helping us on every step of the way. We also want to thank the React Native community. This work wouldn&#39;t have been possible without the experiences shared on GitHub discussions, blog posts and open source projects.</p>
<p>The new architecture represents React Native&#39;s future. While migration requires significant effort, the long-term benefits make it worthwhile. We&#39;re excited about what comes next. Between synchronous layouts eliminating UI jank and TurboModules providing blazing-fast native interop, we can continue to craft the delightful and fluid experiences our merchants expect. The future of React Native looks brighter than ever, and Shopify is deeply invested in its continued success.</p>
<hr/>
<p><em>If you’re interested in joining us on our mission to make commerce better for everyone, check out our <a href="https://www.shopify.com/careers/disciplines/engineering-data">careers page</a>.</em></p>
<h2>About the Author</h2>
<p><a href="https://www.linkedin.com/in/thiagomagalhaesqc" target="_blank" rel="nofollow noopener noreferrer">Thiago Magalhaes</a> is a Staff Engineer at Shopify.</p>
<p>X: <a href="https://x.com/tmgsca33" target="_blank" rel="nofollow noopener noreferrer">@tmgsca33</a></p></div></div></div>
  </body>
</html>
