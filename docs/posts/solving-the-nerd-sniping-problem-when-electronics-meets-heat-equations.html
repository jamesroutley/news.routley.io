<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://praveshkoirala.com/2024/03/07/solving-the-nerd-sniping-problem-when-electronics-meets-heat/">Original</a>
    <h1>Solving the Nerd-Sniping Problem: When Electronics Meets Heat Equations</h1>
    
    <div id="readability-page-1" class="page"><article id="post-421">

	<!-- .entry-header -->

	<div>
		
<p>I recently stumbled upon this <a href="http://xkcd.com/356/" target="_blank" rel="noopener" title="">exciting problem</a> from XKCD, aptly named as the <em>Nerd-Sniping Problem:</em></p>



<figure><img fetchpriority="high" decoding="async" width="740" height="371" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image.png 740w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-300x150.png 300w" sizes="(max-width: 740px) 100vw, 740px"/></figure>



<p>True to its name, it successfully managed to derail me from whatever it was that I was doing. The problem itself is quite curious, we have to find resistance between two points in an infinite lattice of ideal 1-ohm resistors. </p>


<div>
<figure><img decoding="async" width="141" height="71" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-1.png" alt=""/></figure></div>


<p>Do not be fooled by the innocuous structure of the problem. It is, in fact, quite tricky, and true to its name, has the potential to <em>Nerd-Snipe</em> you. Being an empiricist through and through, I was curious if I could use some numerical methods to get a quick approximation for this particular problem. Something that immediately came to my mind was the Discrete Heat Equation in a 2D lattice and the structure of the problem seems similar enough to see if it applies here.</p>



<p>2D Heat Equation, as its name indicates, tells you how heat propagates in a 2D medium. Specifically, given that we know what’s the temperature in a conductor plate at some time <em>t=0</em> is (aka the initial condition) and the temperature along the boundary, or some other points, which never changes, we want to predict how Heat propagates through the conductor and what is the temperature distribution like at any given moment in the future. The Heat Equation involves solving partial differential equations and is a tricky mathematical exercise, which we won’t be repeating here. Worth knowing, however, is the 2D Discrete Heat Equation.</p>


<div>
<figure><img decoding="async" width="476" height="471" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-3.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image-3.png 476w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-3-300x297.png 300w" sizes="(max-width: 476px) 100vw, 476px"/><figcaption>Heat Equation tells you how heat propagates in your 2D plate.</figcaption></figure></div>


<p>In Discrete setting, we are typically given a lattice with some initial temperature conditions and are asked to derive how heat propagates at some discrete time-step in the future. For example, in the image below:</p>


<div>
<figure><img loading="lazy" decoding="async" width="416" height="398" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-4.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image-4.png 416w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-4-300x287.png 300w" sizes="(max-width: 416px) 100vw, 416px"/></figure></div>


<p>If we say that the temperature at the point <em>(k, l)</em> at timestep <em>t</em> is:</p>



<p>$$T_t(k,l)$$






</p>



<p>Then, the temperature at the same point at next timestep t+1, assuming \(\Delta x = \Delta y = 1\)  would simply be:</p>



<p>$$T_{t+1}(k,l) = \frac{T_t(k-1,l) + T_t(k+1, l) + T_t(k, l+1) + T_t(k, l-1)}{4}$$</p>







<p>In simple words, the temperature at the mid-point is the average of all surrounding temperatures i.e. left, right, top, and bottom. Simple enough, right? Let’s see if we can use this idea for our resistance problem.</p>



<p>First, we start by seeing that Heat propagation and electric current flow are quite similar in nature. Heat transfers from point of high temperature to point of low temperature, when in contact. Current flows, similarly, from point of higher potential to that of lower potential. There is thermal conductivity (or resistivity) which works very similar to what electrical conductivity or resistivity works like. So, we have a compelling case for using the 2D Heat Equation for Electric Current propagation. <em>Besides, if you consider Electric potential to be V(k,l) in a lattice, then you actually arrive at the same set of equations as above by using the KCL</em>:</p>



<p>We first start by defining our problem:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>N </span><span>=</span><span> </span><span>20</span><span>                                </span><span># Assume a N x N grid</span></span>
<span><span>Grid </span><span>=</span><span> [[</span><span>0</span><span>.] </span><span>*</span><span> N </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(N)]   </span><span># Initialize all potentials to 0</span></span>
<span></span>
<span><span>A </span><span>=</span><span> (N</span><span>//</span><span>2</span><span> </span><span>-</span><span> </span><span>1</span><span>, N</span><span>//</span><span>2</span><span>)                  </span><span># Point A</span></span>
<span><span>B </span><span>=</span><span> (N</span><span>//</span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>, N</span><span>//</span><span>2</span><span> </span><span>-</span><span> </span><span>1</span><span>)              </span><span># Point B</span></span>
<span></span>
<span><span>def</span><span> </span><span>set</span><span>(</span><span>G</span><span>, </span><span>xy</span><span>, </span><span>v</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  G[x][y] </span><span>=</span><span> v</span></span>
<span></span>
<span><span>def</span><span> </span><span>get</span><span>(</span><span>G</span><span>, </span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy                          </span><span># Boundary has 0 potential</span></span>
<span><span>  </span><span>if</span><span> x </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>or</span><span> x </span><span>&gt;</span><span> N</span><span>-</span><span>1</span><span> </span><span>or</span><span> y </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>or</span><span> y </span><span>&gt;</span><span> N</span><span>-</span><span>1</span><span>: </span><span>return</span><span> </span><span>0</span></span>
<span><span>  </span><span>return</span><span> G[x][y]</span></span>
<span></span>
<span><span>set</span><span>(Grid, A, </span><span>100</span><span>)                    </span><span># A has constant +100 V</span></span>
<span><span>set</span><span>(Grid, B, </span><span>-</span><span>100</span><span>)                   </span><span># B has constant -100 V</span></span></code></pre></div>



<p>We consider a N x N grid with electric potential at each node to be 0. We then apply the potentials +100 to point A and -100 to point B (doesn’t have to be these exact numbers). Then we define functions that let us access any neighbors of a point in the lattice:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>def</span><span> </span><span>left</span><span>(</span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  </span><span>return</span><span> x</span><span>-</span><span>1</span><span>, y</span></span>
<span></span>
<span><span>def</span><span> </span><span>right</span><span>(</span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  </span><span>return</span><span> x</span><span>+</span><span>1</span><span>, y</span></span>
<span></span>
<span><span>def</span><span> </span><span>top</span><span>(</span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  </span><span>return</span><span> x, y</span><span>-</span><span>1</span></span>
<span></span>
<span><span>def</span><span> </span><span>bottom</span><span>(</span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  </span><span>return</span><span> x, y</span><span>+</span><span>1</span></span></code></pre></div>



<p>Next comes the main loop. For a fixed number of iterations, for each lattice point, we update it to the average of its four immediate neighbors.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>def</span><span> </span><span>update</span><span>(</span><span>Grid</span><span>, </span><span>xy</span><span>):</span></span>
<span><span>  x, y </span><span>=</span><span> xy</span></span>
<span><span>  </span><span># Get all neighbors</span></span>
<span><span>  l </span><span>=</span><span> </span><span>left</span><span>(xy)</span></span>
<span><span>  r </span><span>=</span><span> </span><span>right</span><span>(xy)</span></span>
<span><span>  t </span><span>=</span><span> </span><span>top</span><span>(xy)</span></span>
<span><span>  b </span><span>=</span><span> </span><span>bottom</span><span>(xy)</span></span>
<span><span>  </span><span># Take average</span></span>
<span><span>  four_pt </span><span>=</span><span> </span><span>get</span><span>(Grid, l) </span><span>+</span><span> </span><span>get</span><span>(Grid, r) </span><span>+</span><span> </span><span>get</span><span>(Grid, t) </span><span>+</span><span> </span><span>get</span><span>(Grid, b)</span></span>
<span><span>  four_pt </span><span>/=</span><span> </span><span>4</span></span>
<span><span>  </span><span># Update</span></span>
<span><span>  </span><span>set</span><span>(Grid, xy, four_pt)</span></span>
<span><span>  </span><span>return</span></span>
<span></span>
<span><span>for</span><span> epoch </span><span>in</span><span> </span><span>range</span><span>(</span><span>500</span><span>):</span></span>
<span><span>  </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(N):</span></span>
<span><span>    </span><span>for</span><span> j </span><span>in</span><span> </span><span>range</span><span>(N):</span></span>
<span><span>      S </span><span>=</span><span> (i, j)</span></span>
<span><span>      </span><span>if</span><span> S </span><span>==</span><span> A </span><span>or</span><span> S </span><span>==</span><span> B: </span></span>
<span><span>        </span><span>continue</span><span> </span><span># we don&#39;t update these points, i.e. boundary cond.</span></span>
<span><span>      </span><span>update</span><span>(Grid, S)</span></span></code></pre></div>



<p>A difference between the traditional Heat Flow setting is that it assumes some initial condition i.e. <em>there is a certain temperature at certain place at the start.</em> And a distinct boundary condition, i.e. <em>the temperature at the boundary is always 0</em>. But our initial conditions are simultaneously our boundary conditions as well. Which is to say, we assume that we have some potential at point <em>A</em> and <em>B</em>. But we also go on to assume that these potentials never change. Accordingly, we exclude these points from ever being updated in our code.</p>



<p>Before running our code, our initial grid looks as follows:</p>


<div>
<figure><img loading="lazy" decoding="async" width="521" height="418" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-9.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image-9.png 521w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-9-300x241.png 300w" sizes="(max-width: 521px) 100vw, 521px"/></figure></div>


<p>We have +100V potential at point A (lower left) and -100V potential at point B. After running our code for specified epochs, our final grid looks like:</p>


<div>
<figure><img loading="lazy" decoding="async" width="521" height="418" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-10.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image-10.png 521w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-10-300x241.png 300w" sizes="(max-width: 521px) 100vw, 521px"/></figure></div>


<p>As you can see, the potential has been <em>diffused</em> because of current flow across different lattice points via the resistors. Once we have obtained the Electric potential across all points, obtaining the current flow at any lattice point is trivial. We just calculate all potential differences between the point and its neighbors and sum up the obtained currents. For the point B (the blue point with lower potential), we obtain total current flowing across it as:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>current </span><span>=</span><span> </span><span>get</span><span>(Grid, </span><span>left</span><span>(B)) </span><span>+</span><span> </span><span>get</span><span>(Grid, </span><span>right</span><span>(B) ) </span><span>+</span><span> </span><span>get</span><span>(Grid, </span><span>top</span><span>(B) ) </span><span>+</span><span> </span><span>get</span><span>(Grid, </span><span>bottom</span><span>(B) ) </span><span>-</span><span> </span><span>4</span><span> </span><span>*</span><span> </span><span>get</span><span>(Grid, B)</span></span>
<span><span># = 261.12551236325396</span></span></code></pre></div>



<p>And once we have the net current entering node B, by Ohm’s law, the resistance between point A and point B must follow the relation:</p>



<p>$$R_{AB} = \frac{V_A – V_B}{I} = \frac{200}{261.125} \approx 0.7659$$</p>



<p>In fact, we can repeat this calculation for multiple values of N and obtain the following chart:</p>


<div>
<figure><img loading="lazy" decoding="async" width="576" height="432" src="https://praveshkoirala.com/wp-content/uploads/2024/03/image-11.png" alt="" srcset="https://praveshkoirala.com/wp-content/uploads/2024/03/image-11.png 576w, https://praveshkoirala.com/wp-content/uploads/2024/03/image-11-300x225.png 300w" sizes="(max-width: 576px) 100vw, 576px"/></figure></div>


<p>The values are clearly converging towards 0.77 ohms. And sure enough, the analytical result obtained for this problem exactly equals:</p>



<p>$$\frac{4}{\pi} – \frac{1}{2} \approx 0.773 \Omega$$</p>



<p>I hope you enjoyed this writeup! Be careful from <em>Nerd-Sniping!!</em> And do spread awareness about it by sharing this post!</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
