<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tratt.net/laurie/blog/2023/displaying_my_washing_machines_remaining_time_with_curl_jq_pizauth.html">Original</a>
    <h1>Displaying my washing machine&#39;s remaining time with curl, jq, and pizauth</h1>
    
    <div id="readability-page-1" class="page"><p id="title">


<h3 id="article-date">
       April 11 2023
</h3>
</p><div id="article-body"><p>



A couple of months ago our washing machine produced a considerable quantity of
smoke when I opened its door, which I interpreted as a suggestion that
a replacement was needed. After rummaging around the internet for advice, a couple of days later a
new <a href="https://miele.com/">Miele</a> washing machine took its place in
our home.

</p><p>As well as boggling my mind at how much better the new machine was than the
cheap machine it replaced, I was pleased to discover that Miele make
available a <a href="https://www.miele.com/developer/swagger-ui/index.html">third party
API</a> which one can use to interact with the machine. Putting aside any
worries about connecting a high-speed rotating device to the internet, I
decided to have a poke around. Although the API is more limited in
practise than in theory – the API has support for setting values, but
those mostly aren&#39;t used – I eventually realised it can help
me solve one recurring problem.

</p><p>Like most washing machines, ours beeps to notify me that it&#39;s finished.
However, I can&#39;t always empty it straight away, the beep is obnoxious
and repetitive, and it ends up disturbing everyone in the house. I can
turn off the beep, but then I don&#39;t know when the machine has
finished. Miele&#39;s app can notify me, but it regularly
logs me out, and finding out the time remaining is a chore. What
I really wanted is a countdown of the remaining time and notification on my desktop computer.
Fortunately, I can do exactly what I want on
my desktop computer using basic Unix tools. Here&#39;s what a sped-up version
of the result looks like (the middle part is hugely sped up; the end part is
sped up slightly less so):

<video controls="">
<source src="/laurie/blog/extra/2023/washing_machine.mp4" type="video/mp4"/>
</video>

In this post I&#39;m going to explain how I got this working with the Unix shell,
<a href="https://curl.se/">curl</a>, <a href="https://stedolan.github.io/jq/">jq</a>,
and <a href="https://tratt.net/laurie/src/pizauth">pizauth</a>. Interested readers should not have much difficulty
adapting these techniques for other similar situations.


</p><h2>Registration and Authentication</h2>
<p>To get started, I first had to register my washing machine to my email address
with <a href="https://www.miele.co.uk/c/miele-app-3063.htm">Miele&#39;s app</a>.
It&#39;s not the smoothest experience: I had to give it a couple of tries before it
worked, but at least it&#39;s a one-off task.

</p><p>With my washing machine registered to my email address, I then needed to
set up OAuth2 so that I can use the API from my computer. First,
I needed an OAuth2 client ID and client secret . Miele allows anyone to generate
their own client ID and client secret by <a href="https://www.miele.com/f/com/en/register_api.aspx">registering ourselves
as a developer with Miele</a> which means giving them a random &#34;app name&#34; and
the same email address used to register the device in the app. I then had to
register that app as one I&#39;m allowing to use on my Miele account.

</p><p>I then needed an OAuth2 tool: I used pizauth because, well, I wrote it. My
<code>~/.config/pizauth.conf</code> file contains Miele&#39;s authorisation and
token URIs and the client ID and client secret  I got by registering myself with Miele:

</p><pre>account &#34;miele&#34; {
  auth_uri = &#34;https://api.mcs3.miele.com/thirdparty/login/&#34;;
  token_uri = &#34;https://api.mcs3.miele.com/thirdparty/token/&#34;;
  client_id = &#34;8nka83ka-38ak-38a9-38ah-ah38uaha82hi&#34;;
  client_secret = &#34;HOaniszumazr978toh789th789aAGa83&#34;;
}
</pre><p>

I then ran <code>pizauth server</code> which causes pizauth to listen for
requests for access tokens. The first time that pizauth is asked to display an access
token it will report an error which contains the URL needed to authenticate
yourself with Miele:

</p><pre>$ pizauth show miele
ERROR - Access token unavailable until authorised with URL https://api.mcs3.miele.com/thirdparty/login/?access_type=offline&amp;code_challenge=8akyhq28nahikgkanioqa8yHAatho2troanihtHIHI8&amp;code_challenge_method=S256&amp;client_id=8nka83ka-38ak-38a9-38ah-ah38uaha82hi&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8599%2F&amp;response_type=code&amp;state=auhykFAaaBB
</pre><p>

Plugging that URL into a web browser, using the same email address and password
as I used in Miele&#39;s App, and selecting a country (in my case &#34;Great Britain&#34;)
completes authentication, and pizauth now works as expected.


</p><h2>Getting the device ID</h2><p>

The Miele API is a RESTful API which we can query using curl,
though we have to send an OAuth2 access token each time we want it to do
something for us. Let&#39;s start by asking the API to list all the devices
I&#39;ve registered with Miele:

</p><pre>$ curl \
  --silent \
  --header &#34;Authorization: Bearer $(pizauth show miele)&#34; \
  https://api.mcs3.miele.com/v1/devices
</pre><p>

The only surprising part of this is the <code>--header</code> part:
<code>pizauth show miele</code> displays an access token on <code>stdout</code>
which is incorporated into the HTTP request. A couple of seconds later, curl
prints a vast wodge of JSON to stdout:

</p><pre>{&#34;000173036828&#34;:{&#34;ident&#34;:{&#34;type&#34;:{&#34;key_localized&#34;:&#34;Device type&#34;,&#34;value_raw&#34;:1,&#34;value_localized&#34;:&#34;Washing machine&#34;},&#34;deviceName&#34;:&#34;&#34;,&#34;protocolVersion&#34;:4,&#34;deviceIdentLabel&#34;:{&#34;fabNumber&#34;:&#34;000173036828&#34;,&#34;fabIndex&#34;:&#34;44&#34;,&#34;techType&#34;:&#34;WEG365&#34;,&#34;matNumber&#34;:&#34;11385920&#34;,&#34;swids&#34;:[&#34;3829&#34;,&#34;20384&#34;,&#34;28593&#34;,&#34;23848&#34;,&#34;29382&#34;,&#34;28390&#34;,&#34;23849&#34;,&#34;23820&#34;]},&#34;xkmIdentLabel&#34;:{&#34;techType&#34;:&#34;EK057&#34;,&#34;releaseVersion&#34;:&#34;08.20&#34;}},&#34;state&#34;:{&#34;ProgramID&#34;:{&#34;value_raw&#34;:1,&#34;value_localized&#34;:&#34;Cottons&#34;,&#34;key_localized&#34;:&#34;Program name&#34;},&#34;status&#34;:{&#34;value_raw&#34;:5,&#34;value_localized&#34;:&#34;In use&#34;,&#34;key_localized&#34;:&#34;status&#34;},&#34;programType&#34;:{&#34;value_raw&#34;:1,&#34;value_localized&#34;:&#34;Own programme&#34;,&#34;key_localized&#34;:&#34;Program type&#34;},&#34;programPhase&#34;:{&#34;value_raw&#34;:260,&#34;value_localized&#34;:&#34;Main wash&#34;,&#34;key_localized&#34;:&#34;Program phase&#34;},&#34;remainingTime&#34;:[1,25],&#34;startTime&#34;:[0,0],&#34;targetTemperature&#34;:[{&#34;value_raw&#34;:6000,&#34;value_localized&#34;:60.0,&#34;unit&#34;:&#34;Celsius&#34;},{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;},{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;}],&#34;coreTargetTemperature&#34;:[{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;}],&#34;temperature&#34;:[{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;},{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;},{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;}],&#34;coreTemperature&#34;:[{&#34;value_raw&#34;:-32768,&#34;value_localized&#34;:null,&#34;unit&#34;:&#34;Celsius&#34;}],&#34;signalInfo&#34;:false,&#34;signalFailure&#34;:false,&#34;signalDoor&#34;:false,&#34;remoteEnable&#34;:{&#34;fullRemoteControl&#34;:true,&#34;smartGrid&#34;:false,&#34;mobileStart&#34;:false},&#34;ambientLight&#34;:null,&#34;light&#34;:null,&#34;elapsedTime&#34;:[1,9],&#34;spinningSpeed&#34;:{&#34;unit&#34;:&#34;rpm&#34;,&#34;value_raw&#34;:1400,&#34;value_localized&#34;:&#34;1400&#34;,&#34;key_localized&#34;:&#34;Spin speed&#34;},&#34;dryingStep&#34;:{&#34;value_raw&#34;:null,&#34;value_localized&#34;:&#34;&#34;,&#34;key_localized&#34;:&#34;Drying level&#34;},&#34;ventilationStep&#34;:{&#34;value_raw&#34;:null,&#34;value_localized&#34;:&#34;&#34;,&#34;key_localized&#34;:&#34;Fan level&#34;},&#34;plateStep&#34;:[],&#34;ecoFeedback&#34;:{&#34;currentWaterConsumption&#34;:{&#34;unit&#34;:&#34;l&#34;,&#34;value&#34;:6.0},&#34;currentEnergyConsumption&#34;:{&#34;unit&#34;:&#34;kWh&#34;,&#34;value&#34;:0.7},&#34;waterForecast&#34;:0.5,&#34;energyForecast&#34;:0.5},&#34;batteryLevel&#34;:null}}}
</pre><p>

I don&#39;t know about you, but I find large wodges of JSON rather hard to
read, which is irritating because in amongst that JSON wodge is the
device ID of my washing machine. That ID is required to use later
parts of the API so I need to fish it out somehow. Fortunately, jq
allows us to easily extract the field in question:

</p><pre>$ curl \
  --silent \
  --header &#34;Authorization: Bearer $(pizauth show miele)&#34; \
  https://api.mcs3.miele.com/v1/devices \
  | jq -r &#39;.[] | .ident.deviceIdentLabel.fabNumber&#39;
000173036828
</pre><p>

That jq command actually prints out every device ID I&#39;ve registered with Miele.
Since I only have a single Miele device it&#39;s fairly obvious that the single ID
displayed is for my washing machine, but
if you have multiple IDs, how can you tell them apart? The curl command stays
the same as before, but now I use jq to fish out the model number and even
a human readable name:

</p><pre>$ curl ... \
  | jq -r \
    &#39;.[]
     | .ident
     | (.deviceIdentLabel
     | (.fabNumber + &#34;: &#34; + .techType))
       + &#34; &#34; + .type.value_localized&#39;
000173036828: WEG365 Washing machine
</pre><p>

It&#39;s now clear that &#34;000173036828&#34; is the device ID I want going forward.


</p><h2>Getting the remaining time</h2><p>

Now that I have its device ID, I can use a different part of the API
to see my washing machine&#39;s current state:

</p><pre>$ curl \
  --silent \
  --header &#34;Authorization: Bearer $(pizauth show miele)&#34; \
  https://api.mcs3.miele.com/v1/devices/000173036828/state
</pre><p>

This gives me another huge wodge of JSON of which only the
<code>remainingTime</code> field is interesting:

</p><pre>$ curl ... \
  | jq -r &#39;.remainingTime&#39;
[
  0,
  56
]
</pre><p>

That means I&#39;ve got 0 hours and 56 minutes left — but that formatting is rather
horrible. My first attempt might be:

</p><pre>$ curl ... \
  | jq -r &#39;.remainingTime[0] + .remainingTime[1]&#39;
54
</pre><p>

but that&#39;s added the two integers in the array together, so that&#39;s not what I
want. Instead, I want to convert each integer to a string and then concatenate
them:

</p><pre>$ curl ... \
  | jq -r \
    &#39;(.remainingTime[0] | tostring)
     + &#34;:&#34;
     + (.remainingTime[1] | tostring)&#39;
0:54
</pre><p>

What happens when the remaining time goes below 10?

</p><pre>$ curl ... \
  | jq -r
    &#39;(.remainingTime[0] | tostring)
     + &#34;:&#34;
     + (.remainingTime[1] | tostring)&#39;
0:9
</pre><p>

That&#39;s rather confusing! We need to make sure the minutes are always two digits.
There is no builtin way of padding numbers in jq, but we can multiply strings
by integers so with a bit of thought we can write:

</p><pre>$ curl ... \
  | jq -r \
    &#39;(.remainingTime[0] | tostring)
     + &#34;:&#34;
     + (.remainingTime[1] | tostring
        | (length | if . &gt;= 2 then &#34;&#34; else &#34;0&#34; * (2 - .) end))
     + (.remainingTime[1] | tostring)&#39;
0:09
</pre><p>

The API also tells us what phase the washing machine is currently in, which I
find interesting, so let&#39;s print that out:

</p><pre>$ curl ... \
  | jq -r &#39;.programPhase.value_localized&#39;
Rinsing
</pre>
<h2>A Countdown</h2><p>

At this point, I can print out the remaining time for the current load
once: what I really want to do is update this so that I have a meaningful
countdown. Before we try and go further, let&#39;s bundle what we&#39;ve got into a
simple script so that we don&#39;t have to continually enter commands into
a terminal:

</p><pre>#! /bin/sh

set -e

DEVICE_ID=000173036828

get() {
  curl \
    --silent \
    --header &#34;Authorization: Bearer $(pizauth show miele)&#34; \
    https://api.mcs3.miele.com/v1/devices/${DEVICE_ID}/state \
  | jq -r &#34;$1&#34;
}

case $1 in
  phase) get .programPhase.value_localized ;;
  remaining_time)
    get \
      &#39;(.remainingTime[0] | tostring)
       + &#34;:&#34;
       + (.remainingTime[1] | tostring
          | (length
	     | if . &gt;= 2 then &#34;&#34; else &#34;0&#34; * (2 - .) end))
       + (.remainingTime[1] | tostring)&#39;
    ;;
esac
</pre><p>

Let&#39;s call that script <code>washing_machine</code>:

</p><pre>$ washing_machine remaining_time
0:42
$ washing_machine phase
Rinsing
</pre><p>

What we now want to do is create a loop which prints out the remaining time. A
first cut, which updates the remaining time every 30 seconds is as follows:

</p><pre>while [ true ]; do
  printf &#34;\r%s (%s)&#34; \
    $(washing_machine remaining_time) \
    $(washing_machine phase)
  sleep 30
done
</pre><p>

That works surprisingly well, but has two flaws. First, when the load is finished,
the loop doesn&#39;t terminate. Second, <code>\r</code> is &#34;carriage return&#34; which
means that the countdown keeps displaying text on the same line. This works well
provided any new text is the same, or longer, length than what came before.
However, if the new text is shorter we end up with odd output such as:

</p><pre>0:32 (Rinsing)h)
</pre><p>

We can fix the first problem by noticing that the load is complete when
<code>remaining_time</code> returns &#34;0:00&#34;:

</p><pre>while [ true ]; do
  t=$(washing_machine remaining_time)
  if [[ $t == &#34;0:00&#34; ]]; then
    break
  fi
  printf &#34;\r%s (%s)&#34; \
    &#34;$t&#34; \
    &#34;$(washing_machine phase)&#34;
  sleep 30
done
</pre><p>

We can fix the second problem in various ways, but the most portable I know of
uses <code>tput el</code> after the carriage return. This causes all text between
the cursor (which <code>\r</code> has moved to the start of the line) and the end of the line
to be cleared:

</p><pre>while [ true ]; do
  t=$(washing_machine remaining_time)
  if [[ $t == &#34;0:00&#34; ]]; then
    break
  fi
  printf &#34;\r%s%s (%s)&#34; \
    $(tput el) \
    &#34;$t&#34; \
    &#34;$(washing_machine phase)&#34;
  sleep 30
done
</pre><p>

At this point, I&#39;m into nitpicking mode: it irritates me that my countdown has
a blinking cursor next to it. I can turn that off and on with <code>tput
civis</code> and <code>tput cnorm</code> respectively. However, I need to make
sure that if my program is terminated early (e.g. because I press Ctrl-C) that
cursor blinking is restored. Fortunately I can use the <code>trap</code>
command to restore blinking if this happens, so I can adjust my program
as follows:

</p><pre>tput civis
trap &#34;tput cnorm&#34; 1 2 3 13 15
while [ true ]; do
  ...
done
tput cnorm
</pre><p>

Last, but not least, when the load has finished I use <code>notify-send</code>
to pop a message up in my desktop telling me the load is complete:

</p><pre>notify-send -t 60000 &#34;Washing finished&#34;
</pre><p>

Now that I&#39;ve got that sorted out, I can put it into my script (keeping the
now-recursive calls as-is), which now looks as follows:

</p><pre>#! /bin/sh

set -e

DEVICE_ID=000173036828

get() {
  curl \
    --silent \
    --header &#34;Authorization: Bearer $(pizauth show miele)&#34; \
    https://api.mcs3.miele.com/v1/devices/${DEVICE_ID}/state \
  | jq -r &#34;$1&#34;
}

case $1 in
  countdown)
    tput civis
    trap &#34;tput cnorm&#34; 1 2 3 13 15
    while [ true ]; do
      t=$(washing_machine remaining_time)
      if [[ $t == &#34;0:00&#34; ]]; then
        break
      fi
      printf &#34;\r%s%s (%s)&#34; \
        $(tput el) \
        &#34;$t&#34; \
        &#34;$(washing_machine phase)&#34;
      sleep 30
    done
    tput cnorm
    echo
    notify-send -t 60000 &#34;Washing finished&#34;
    ;;
  phase) get .programPhase.value_localized ;;
  remaining_time)
    get \
      &#39;(.remainingTime[0] | tostring)
       + &#34;:&#34;
       + (.remainingTime[1] | tostring
          | (length
	     | if . &gt;= 2 then &#34;&#34; else &#34;0&#34; * (2 - .) end))
       + (.remainingTime[1] | tostring)&#39;
    ;;
esac
</pre><p>

And now each time I use my washing machine I need only execute the following
at the command line:

</p><pre>$ washing_machine countdown
</pre>
<h2>Summary</h2><p>

Open standards are great, especially when they can be used with simple tools.
Nearly everyone has curl installed on their machine already and most people can
easily install jq via their favourite package manager. At the time of writing,
I think OpenBSD is the only OS which makes pizauth easily installable, but perhaps
that will change as time goes on. Still, hopefully the underlying message of
this post is clear: we can often do a lot with simple tools!

</p>



<h3>Footnotes</h3>
<p><a name="70717824">[1] The latter doesn&#39;t make much sense in this context, and it&#39;s not required by
the OAuth2 standard, but Miele seem to require it.</a></p></div></div>
  </body>
</html>
