<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bobschrag/clolog">Original</a>
    <h1>Clolog</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Full-featured logic programming (AKA &#34;Prolog&#34;) embedded in/callable
from and supporting calls to Clojure.  In the spirit of LogLisp, Lisp
Machine Prolog, and Franz Inc.&#39;s Allegro Prolog, with some extra
goodies.  Emphasis on expressive power and execution transparency,
supporting rapid prototyping, proof-of-concept development, and
outer-loop reasoning (i.e., not real fast, so far).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Highlights, with examples</h2><a id="user-content-highlights-with-examples" aria-label="Permalink: Highlights, with examples" href="#highlights-with-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>
<p dir="auto"><strong>Clojure-based, Lispy (i.e., homoiconic) syntax, e.g., ...</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="(do 
    ;; Set up, clear knowledge base.
    (initialize-prolog)
    ;; Create unit assertion.    
    (&lt;- (has-subtype vertebrate mammal)) 
    ;; Execute query.
    (? ?x ; Answer template
       (has-subtype vertebrate ?x) ; Goal.
       )
    )
  [mammal] ; Answer(s) in vector (perhaps empty)."><pre>(<span>do</span> 
    <span><span>;</span>; Set up, clear knowledge base.</span>
    (<span>initialize-prolog</span>)
    <span><span>;</span>; Create unit assertion.    </span>
    (<span>&lt;-</span> (<span>has-subtype</span> vertebrate mammal)) 
    <span><span>;</span>; Execute query.</span>
    (<span>?</span> ?x <span><span>;</span> Answer template</span>
       (<span>has-subtype</span> vertebrate ?x) <span><span>;</span> Goal.</span>
       )
    )
  [mammal] <span><span>;</span> Answer(s) in vector (perhaps empty).</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Logical variable- (&#34;?var&#34;)-containing Clojure seqs (so, lists) and
vectors as &#34;complex&#34; terms---in assertion statements and answer templates</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? (?a ?b)
     (same [?a 2] [1 ?b]))
[(1 2)]"><pre>&gt; (<span>?</span> (<span>?a</span> ?b)
     (<span>same</span> [?a <span>2</span>] [<span>1</span> ?b]))
[(<span>1</span> <span>2</span>)]</pre></div>
</li>
<li>
<p dir="auto"><strong>Clojure calling predicates</strong></p>
<ul dir="auto">
<li>
<p dir="auto">Truthiness check: <code>truthy?</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? true (truthy? (+ 1 2)))
[true]"><pre>&gt; (<span>?</span> <span>true</span> (<span>truthy?</span> (<span>+</span> <span>1</span> <span>2</span>)))
[<span>true</span>]</pre></div>
</li>
<li>
<p dir="auto">?var-bearing term unification: <code>evals-from?</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? ?x (evals-from? ?x (+ 1 2)))
[3]"><pre>&gt; (<span>?</span> ?x (<span>evals-from?</span> ?x (<span>+</span> <span>1</span> <span>2</span>)))
[<span>3</span>]</pre></div>
</li>
<li>
<p dir="auto">Side effect: <code>do</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? nil (do (println &#34;Hello&#34;)))
Hello
[nil]"><pre>&gt; (<span>?</span> <span>nil</span> (<span>do</span> (<span>println</span> <span><span>&#34;</span>Hello<span>&#34;</span></span>)))
Hello
[<span>nil</span>]</pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Access to ?var bindings in Clojure calls---even within quoted
expressions</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (&lt;-- (male laban))
      (? ?y (male ?x) (evals-from? ?y (list &#39;?x))))
[(laban)]"><pre>&gt; (<span>do</span> (<span>&lt;--</span> (<span>male</span> laban))
      (<span>?</span> ?y (<span>male</span> ?x) (<span>evals-from?</span> ?y (<span>list</span> &#39;?x))))
[(<span>laban</span>)]</pre></div>
</li>
<li>
<p dir="auto"><strong>Negation as failure: <code>not</code></strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog) ; Clear knowledge base.
      (? :nothing (not (Huh?))))
[:nothing]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>) <span><span>;</span> Clear knowledge base.</span>
      (<span>?</span> <span>:nothing</span> (<span>not</span> (<span>Huh?</span>))))
[<span>:nothing</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>Facilitated access to Clojure values (<code>evals-from?</code> shorthand
<code>-&gt;?</code>) in goals with Clojure-calling predicates</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (binding [*leash* true]
    (? true (same (-&gt;? (+ 0 1)) 1)))
0. Processing query: ((same (-&gt;? (+ 0 1)) 1))
 Applied -&gt;? transform
 (evals-from?): Entering (evals-from? ??-0:0 (+ 0 1))
 (evals-from?): Succeeded (evals-from? 1 (+ 0 1))
 (same): Entering (same 1 1)
 (same): Succeeded (same 1 1)
Recorded answer: true
Answer limit reached. ; Because answer template `true` has no ?vars.
[true]"><pre>&gt; (<span>binding</span> [*leash* <span>true</span>]
    (<span>?</span> <span>true</span> (<span>same</span> (<span>-&gt;?</span> (<span>+</span> <span>0</span> <span>1</span>)) <span>1</span>)))
<span>0.</span> Processing query: ((<span>same</span> (<span>-&gt;?</span> (<span>+</span> <span>0</span> <span>1</span>)) <span>1</span>))
 Applied -&gt;? transform
 (<span>evals-from?</span>): Entering (<span>evals-from?</span> ??-0:0 (<span>+</span> <span>0</span> <span>1</span>))
 (<span>evals-from?</span>): Succeeded (<span>evals-from?</span> <span>1</span> (<span>+</span> <span>0</span> <span>1</span>))
 (<span>same</span>): Entering (<span>same</span> <span>1</span> <span>1</span>)
 (<span>same</span>): Succeeded (<span>same</span> <span>1</span> <span>1</span>)
Recorded answer: <span>true</span>
Answer limit reached. <span><span>;</span> Because answer template `true` has no ?vars.</span>
[<span>true</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>Built-in term [non-]matching predicates: <code>same</code>, <code>different</code></strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? (?a ?b)
     (same [?a 2] [1 ?b]))
[(1 2)]

&gt; (? (?a ?b)
     (different [?a 2] [1 ?b]))
[]"><pre>&gt; (<span>?</span> (<span>?a</span> ?b)
     (<span>same</span> [?a <span>2</span>] [<span>1</span> ?b]))
[(<span>1</span> <span>2</span>)]

&gt; (<span>?</span> (<span>?a</span> ?b)
     (<span>different</span> [?a <span>2</span>] [<span>1</span> ?b]))
[]</pre></div>
</li>
<li>
<p dir="auto"><strong>Built-in term inspection predicates: <code>var</code>, <code>ground</code></strong></p>

<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? ?x (same ?x 1) (ground ?x))
[1]"><pre>&gt; (<span>?</span> ?x (<span>same</span> ?x <span>1</span>) (<span>ground</span> ?x))
[<span>1</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>Built-in unconditional predicates: <code>true</code>, <code>false</code></strong></p>


</li>
<li>
<p dir="auto"><strong>Nestable built-in logical operators: <code>and</code>, <code>or</code>, <code>not</code>, <code>if</code></strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (? ?x (and (if (false)
               (same ?x :succeed)
               (same ?x :fail))
             (evals-from? ?x :fail)
         (or (true) (false))))
[:fail]"><pre>&gt; (<span>?</span> ?x (<span>and</span> (<span>if</span> (<span>false</span>)
               (<span>same</span> ?x <span>:succeed</span>)
               (<span>same</span> ?x <span>:fail</span>))
             (<span>evals-from?</span> ?x <span>:fail</span>)
         (<span>or</span> (<span>true</span>) (<span>false</span>))))
[<span>:fail</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>&#34;Cut&#34; operator: <code>first</code></strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (sister laban rebecca))
      (&lt;- (sister rachel leah))
      (? [?sibling ?sister]
         (first (sister ?sibling ?sister))))
 [[laban rebecca]]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>sister</span> laban rebecca))
      (<span>&lt;-</span> (<span>sister</span> rachel leah))
      (<span>?</span> [?sibling ?sister]
         (<span>first</span> (<span>sister</span> ?sibling ?sister))))
 [[laban rebecca]]</pre></div>
</li>
<li>
<p dir="auto"><strong>User-custom predicate transforms, supporting (e.g.)
varieties of <code>if</code>, <code>cond</code>, <code>optional</code></strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (create-predicate-transform &#39;((if% ?if ?then ?else)
                              (if (first ?if) ?then ?else)))"><pre>&gt; (<span>create-predicate-transform</span> &#39;((<span>if%</span> ?if ?then ?else)
                              (<span>if</span> (<span>first</span> ?if) ?then ?else)))</pre></div>
</li>
<li>
<p dir="auto"><strong>Full leashing of predicates, including operators</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (binding [*leash* true]
    (? [?sibling ?sister ?x] 
      (if% (sister ?sibling ?sister)
           (evals-from? ?x true)
           (evals-from? ?x false))))
0. Processing query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 (if%): Applying logic transform (if% ?if ?then ?else)
 (if): Entering (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking &#39;if&#39; condition (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if first): Entering first (first (sister ?sibling:0 ?sister:0))
   1. Entering &#34;sister/2&#34;: (sister ?sibling:0 ?sister:0)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded &#34;sister/2&#34;: (sister laban rebecca)
  (if first): Succeeded, cutting (first (sister laban rebecca))
 (if): Taking &#39;then&#39; branch of (if (first (sister laban rebecca)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (first (sister laban rebecca)) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  (if first): Failed (first (sister ?sibling:0 ?sister:0))
 (if): Failed (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true]]"><pre>&gt; (<span>binding</span> [*leash* <span>true</span>]
    (<span>?</span> [?sibling ?sister ?x] 
      (<span>if%</span> (<span>sister</span> ?sibling ?sister)
           (<span>evals-from?</span> ?x <span>true</span>)
           (<span>evals-from?</span> ?x <span>false</span>))))
<span>0.</span> Processing query: ((<span>if%</span> (<span>sister</span> ?sibling ?sister) (<span>evals-from?</span> ?x <span>true</span>) (<span>evals-from?</span> ?x <span>false</span>)))
 (<span>if%</span>): Applying logic transform (<span>if%</span> ?if ?then ?else)
 (<span>if</span>): Entering (<span>if</span> (<span>first</span> (<span>sister</span> ?sibling:0 ?sister:0)) (<span>evals-from?</span> ?x:0 <span>true</span>) (<span>evals-from?</span> ?x:0 <span>false</span>))
 (<span>if</span>): Checking &#39;if&#39; condition (<span>if</span> (<span>first</span> (<span>sister</span> ?sibling:0 ?sister:0)) (<span>evals-from?</span> ?x:0 <span>true</span>) (<span>evals-from?</span> ?x:0 <span>false</span>))
  (<span>if</span> first): Entering first (<span>first</span> (<span>sister</span> ?sibling:0 ?sister:0))
   <span>1.</span> Entering <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> ?sibling:0 ?sister:0)
   <span>1.</span> Matched head (<span>sister</span> laban rebecca): (<span>sister</span> laban rebecca)
   <span>1.</span> Succeeded <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> laban rebecca)
  (<span>if</span> first): Succeeded, cutting (<span>first</span> (<span>sister</span> laban rebecca))
 (<span>if</span>): Taking &#39;then&#39; branch of (<span>if</span> (<span>first</span> (<span>sister</span> laban rebecca)) (<span>evals-from?</span> ?x:0 <span>true</span>) (<span>evals-from?</span> ?x:0 <span>false</span>))
  (<span>if</span> evals-from?): Entering (<span>evals-from?</span> ?x:0 <span>true</span>)
  (<span>if</span> evals-from?): Succeeded (<span>evals-from?</span> <span>true</span> <span>true</span>)
 (<span>if</span>): Succeeded (<span>if</span> (<span>first</span> (<span>sister</span> laban rebecca)) (<span>evals-from?</span> <span>true</span> <span>true</span>) (<span>evals-from?</span> <span>true</span> <span>false</span>))
Recorded answer: [laban rebecca <span>true</span>]
  (<span>if</span> first): Failed (<span>first</span> (<span>sister</span> ?sibling:0 ?sister:0))
 (<span>if</span>): Failed (<span>if</span> (<span>first</span> (<span>sister</span> ?sibling:0 ?sister:0)) (<span>evals-from?</span> ?x:0 <span>true</span>) (<span>evals-from?</span> ?x:0 <span>false</span>))
<span>0.</span> Exhausted query: ((<span>if%</span> (<span>sister</span> ?sibling ?sister) (<span>evals-from?</span> ?x <span>true</span>) (<span>evals-from?</span> ?x <span>false</span>)))
[[laban rebecca <span>true</span>]]</pre></div>
</li>
<li>
<p dir="auto"><strong>Symbols interpreted as logic terms or predicates, regardless of their Clojure values</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (&lt;- (false true))
      (? ?x (false ?x)))
[true]

&gt; (do (&lt;- (neg? 3))
      (? true (neg? 3)))
[true]"><pre>&gt; (<span>do</span> (<span>&lt;-</span> (<span>false</span> <span>true</span>))
      (<span>?</span> ?x (<span>false</span> ?x)))
[<span>true</span>]

&gt; (<span>do</span> (<span>&lt;-</span> (<span>neg?</span> <span>3</span>))
      (<span>?</span> <span>true</span> (<span>neg?</span> <span>3</span>)))
[<span>true</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>Arbitrary Clojure things as terms or predicates, e.g., ...</strong></p>
<ul dir="auto">
<li>
<p dir="auto">Strings (supporting, e.g., RDF URIs)</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (&lt;- (&#34;false&#34; true))
      (? ?x (&#34;false&#34; ?x)))
[true]"><pre>&gt; (<span>do</span> (<span>&lt;-</span> (<span>&#34;false&#34;</span> <span>true</span>))
      (<span>?</span> ?x (<span>&#34;false&#34;</span> ?x)))
[<span>true</span>]</pre></div>
</li>
<li>
<p dir="auto">Numbers</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (&lt;- (3 neg?))
      (? ?x (3 ?x)))
[neg?]"><pre>&gt; (<span>do</span> (<span>&lt;-</span> (<span>3</span> neg?))
      (<span>?</span> ?x (<span>3</span> ?x)))
[neg?]</pre></div>
</li>
<li>
<p dir="auto">Complex terms</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- ([treasure] (buried ?x)))
  (? ?r ([treasure] ?r)))
[(buried ?unbound-0)]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> ([treasure] (<span>buried</span> ?x)))
  (<span>?</span> ?r ([treasure] ?r)))
[(<span>buried</span> ?unbound-0)]</pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Predicates that are ?var-bearing complex terms</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- ([treasure chest] (buried ?x)))
  (? [?r ?thing] ([treasure ?thing] ?r)))
[[(buried ?unbound-0) chest]]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> ([treasure chest] (<span>buried</span> ?x)))
  (<span>?</span> [?r ?thing] ([treasure ?thing] ?r)))
[[(<span>buried</span> ?unbound-0) chest]]</pre></div>
</li>
<li>
<p dir="auto"><strong>Predicates that are ?vars</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (male jacob))
  (? ?pred (?pred jacob)))
[male]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>male</span> jacob))
  (<span>?</span> ?pred (<span>?pred</span> jacob)))
[male]</pre></div>
</li>
<li>
<p dir="auto"><strong>Variadic (variable-tail/arity) predicates and complex terms</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (variadic))
      (&lt;- (variadic 1))
      (&lt;- (variadic 1 2))
      (? ?rest (variadic &amp; ?rest)))
[() (1) (1 2)]

&gt; (do (initialize-prolog)
      (&lt;- (variadic-term [1]))
      (&lt;- (variadic-term [1 2]))
  (? ?rest (variadic-term [1 &amp; ?rest])))
[[] [2]]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>variadic</span>))
      (<span>&lt;-</span> (<span>variadic</span> <span>1</span>))
      (<span>&lt;-</span> (<span>variadic</span> <span>1</span> <span>2</span>))
      (<span>?</span> ?rest (<span>variadic</span> &amp; ?rest)))
[() (<span>1</span>) (<span>1</span> <span>2</span>)]

&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>variadic-term</span> [<span>1</span>]))
      (<span>&lt;-</span> (<span>variadic-term</span> [<span>1</span> <span>2</span>]))
  (<span>?</span> ?rest (<span>variadic-term</span> [<span>1</span> &amp; ?rest])))
[[] [<span>2</span>]]</pre></div>
</li>
<li>
<p dir="auto"><strong>Goals that are ?vars</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (male jacob))
  (? ?goal ?goal)) ; Tell me everything you can prove.
[(male jacob)]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>male</span> jacob))
  (<span>?</span> ?goal ?goal)) <span><span>;</span> Tell me everything you can prove.</span>
[(<span>male</span> jacob)]</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (male jacob))
  (? ?goal (unasserted) ?goal)) ; ...with what you know so far.
[]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>male</span> jacob))
  (<span>?</span> ?goal (<span>unasserted</span>) ?goal)) <span><span>;</span> ...with what you know so far.</span>
[]</pre></div>
</li>
<li>
<p dir="auto"><strong>Anonymous ?vars</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (sister laban rebecca))
      (&lt;- (sister rachel leah))
      (? true (sister ?_person ?_person)))
[true]

&gt; (? true (sister ? ?))
[true]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>sister</span> laban rebecca))
      (<span>&lt;-</span> (<span>sister</span> rachel leah))
      (<span>?</span> <span>true</span> (<span>sister</span> ?_person ?_person)))
[<span>true</span>]

&gt; (<span>?</span> <span>true</span> (<span>sister</span> ? ?))
[<span>true</span>]</pre></div>
</li>
<li>
<p dir="auto"><strong>Suppression of answers that are (under ?var renaming) duplicates</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (male laban))
  (&lt;- (male jacob))
  (binding [*leash* true]
        (? ?x (or (male ?x) (male ?x)))))
0. Processing query: ((or (male ?x) (male ?x)))
 (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering &#34;male/1&#34;: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded &#34;male/1&#34;: (male laban)
Recorded answer: laban
  1. Backtracking into &#34;male/1&#34;: (male ?x:0)
  1. Succeeded &#34;male/1&#34;: (male jacob)
Recorded answer: jacob
  1. Backtracking into &#34;male/1&#34;: (male ?x:0)
  1. Failed &#34;male/1&#34;: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering &#34;male/1&#34;: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded &#34;male/1&#34;: (male laban)
Duplicate answer (not recorded): laban
  1. Backtracking into &#34;male/1&#34;: (male ?x:0)
  1. Succeeded &#34;male/1&#34;: (male jacob)
Duplicate answer (not recorded): jacob
  1. Backtracking into &#34;male/1&#34;: (male ?x:0)
  1. Failed &#34;male/1&#34;: (male ?x:0)
 (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[laban jacob]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>male</span> laban))
  (<span>&lt;-</span> (<span>male</span> jacob))
  (<span>binding</span> [*leash* <span>true</span>]
        (<span>?</span> ?x (<span>or</span> (<span>male</span> ?x) (<span>male</span> ?x)))))
<span>0.</span> Processing query: ((<span>or</span> (<span>male</span> ?x) (<span>male</span> ?x)))
 (<span>or</span>): Entering (<span>or</span> (<span>male</span> ?x:0) (<span>male</span> ?x:0))
  <span>1.</span> Entering <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> laban)
  <span>1.</span> Matched head (<span>male</span> laban): (<span>male</span> laban)
  <span>1.</span> Succeeded <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> laban)
Recorded answer: laban
  <span>1.</span> Backtracking into <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
  <span>1.</span> Succeeded <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> jacob)
Recorded answer: jacob
  <span>1.</span> Backtracking into <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
  <span>1.</span> Failed <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
 (<span>or</span>): Backtracking into (<span>or</span> (<span>male</span> ?x:0) (<span>male</span> ?x:0))
  <span>1.</span> Entering <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> laban)
  <span>1.</span> Matched head (<span>male</span> laban): (<span>male</span> laban)
  <span>1.</span> Succeeded <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> laban)
Duplicate answer (<span>not</span> recorded): laban
  <span>1.</span> Backtracking into <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
  <span>1.</span> Succeeded <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> jacob)
Duplicate answer (<span>not</span> recorded): jacob
  <span>1.</span> Backtracking into <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
  <span>1.</span> Failed <span><span>&#34;</span>male/1<span>&#34;</span></span>: (<span>male</span> ?x:0)
 (<span>or</span>): Failed (<span>or</span> (<span>male</span> ?x:0) (<span>male</span> ?x:0))
<span>0.</span> Exhausted query: ((<span>or</span> (<span>male</span> ?x) (<span>male</span> ?x)))
[laban jacob]</pre></div>
</li>
<li>
<p dir="auto"><strong>Optional suppression of answers subsumed by other answers</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
      (&lt;- (sister laban rebecca))
      (&lt;- (sister ?x ?y))
      (binding [*leash* true]
        (? [?x ?y] (sister ?x ?y))))
0. Processing query: ((sister ?x ?y))
 1. Entering &#34;sister/2&#34;: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded &#34;sister/2&#34;: (sister laban rebecca)
Recorded answer: [laban rebecca]
 1. Backtracking into &#34;sister/2&#34;: (sister ?x:0 ?y:0)
 1. Succeeded &#34;sister/2&#34;: (sister ?x:0 ?y:0)
Recorded subsuming answer (discarded 1 subsumed answer(s)):  [?x ?y]
 1. Backtracking into &#34;sister/2&#34;: (sister ?x:0 ?y:0)
 1. Failed &#34;sister/2&#34;: (sister ?x:0 ?y:0)
0. Exhausted query: ((sister ?x ?y))
[[?x ?y]]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
      (<span>&lt;-</span> (<span>sister</span> laban rebecca))
      (<span>&lt;-</span> (<span>sister</span> ?x ?y))
      (<span>binding</span> [*leash* <span>true</span>]
        (<span>?</span> [?x ?y] (<span>sister</span> ?x ?y))))
<span>0.</span> Processing query: ((<span>sister</span> ?x ?y))
 <span>1.</span> Entering <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> laban rebecca)
 <span>1.</span> Matched head (<span>sister</span> laban rebecca): (<span>sister</span> laban rebecca)
 <span>1.</span> Succeeded <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> laban rebecca)
Recorded answer: [laban rebecca]
 <span>1.</span> Backtracking into <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> ?x:0 ?y:0)
 <span>1.</span> Succeeded <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> ?x:0 ?y:0)
Recorded subsuming answer (<span>discarded</span> <span>1</span> subsumed answer(<span>s</span>)):  [?x ?y]
 <span>1.</span> Backtracking into <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> ?x:0 ?y:0)
 <span>1.</span> Failed <span><span>&#34;</span>sister/2<span>&#34;</span></span>: (<span>sister</span> ?x:0 ?y:0)
<span>0.</span> Exhausted query: ((<span>sister</span> ?x ?y))
[[?x ?y]]</pre></div>
</li>
<li>
<p dir="auto"><strong>Failure (i.e., not system error) when no assertions have been
defined for a called logic predicate and arity</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt; (do (initialize-prolog)
               (binding [*leash* true]
                 (? answer (undefined ?arity-1))))
0. Processing query: ((undefined ?arity-1))
 1. Entering &#34;undefined/1&#34;: (undefined ?arity-1:0)
 1. Failed &#34;undefined/1&#34;: (undefined ?arity-1:0)
0. Exhausted query: ((undefined ?arity-1))
[]"><pre>&gt; (<span>do</span> (<span>initialize-prolog</span>)
               (<span>binding</span> [*leash* <span>true</span>]
                 (<span>?</span> answer (<span>undefined</span> ?arity-1))))
<span>0.</span> Processing query: ((<span>undefined</span> ?arity-1))
 <span>1.</span> Entering <span><span>&#34;</span>undefined/1<span>&#34;</span></span>: (<span>undefined</span> ?arity-1:0)
 <span>1.</span> Failed <span><span>&#34;</span>undefined/1<span>&#34;</span></span>: (<span>undefined</span> ?arity-1:0)
<span>0.</span> Exhausted query: ((<span>undefined</span> ?arity-1))
[]</pre></div>
</li>
</ul>

<p dir="auto">In production rules below, ...</p>
<ul dir="auto">
<li>Angle brackets surround a grammar &lt;element&gt;.</li>
<li>&lt;element&gt;+ denotes one or more of &lt;element&gt;.</li>
<li>&lt;element&gt;* denotes zero or more of &lt;element&gt;.</li>
<li>&#34;:-&#34; separates rules&#39; left- and right-hand sides.</li>
<li>&#34;|&#34; separates right-hand sides&#39; alternatives.</li>
</ul>
<p dir="auto">&lt;assertion&gt;: <code>(</code>&lt;head-statement&gt;+ &lt;body-statement&gt;*<code>)</code></p>
<p dir="auto">&lt;head-statement&gt; :- &lt;statement&gt;</p>
<p dir="auto">&lt;body-statement&gt; :- &lt;statement&gt;</p>
<p dir="auto">&lt;statement&gt; :- &lt;fixed-arity-statement&gt; | &lt;variable-arity-statement&gt;</p>
<p dir="auto">&lt;fixed-arity-statement&gt; :- <code>(</code>&lt;predicate&gt;+ &lt;argument-term&gt;*<code>)</code></p>
<p dir="auto">&lt;argument-term&gt; :- &lt;term&gt;</p>
<p dir="auto">&lt;variable-arity-statement&gt; :- <code>(</code>&lt;predicate&gt;+ &lt;term&gt;* <code>&amp;</code> &lt;?var&gt;<code>)</code></p>
<p dir="auto">&lt;predicate&gt; :- &lt;special-predicate&gt; | &lt;assertion-predicate&gt;</p>
<p dir="auto">&lt;special-predicate&gt; :- &lt;built-in-predicate&gt; | &lt;transform-predicate&gt;</p>
<p dir="auto">&lt;built-in-predicate&gt; :- &lt;operator&gt; | &lt;Clojure-calling-predicate&gt; | <code>same</code> | <code>different</code> | <code>var</code> | <code>ground</code> | <code>true</code> | <code>false</code></p>
<p dir="auto">&lt;operator&gt; :- <code>and</code> | <code>or</code> | <code>if</code> | <code>not</code> | <code>first</code></p>
<p dir="auto">&lt;Clojure-calling-predicate&gt; :- <code>truthy?</code> | <code>evals-from?</code> | <code>do</code></p>
<p dir="auto">&lt;transform-predicate&gt;: A predicate constant registered using <code>create-predicate-transform</code></p>
<p dir="auto">&lt;assertion-predicate&gt;: A predicate all of whose assertions (if any) are from calls to one of the <code>&lt;-</code>... macros or <code>assert&lt;-</code>... functions</p>
<p dir="auto">&lt;term&gt; :- &lt;transparent-term&gt; | &lt;opaque-term&gt;</p>
<p dir="auto">&lt;transparent-term&gt; :- &lt;?var&gt; | &lt;complex-term&gt;</p>
<p dir="auto">&lt;complex-term&gt; :- &lt;fixed-artiy-complex-term&gt; | &lt;variable-arity-complex-term&gt;</p>
<p dir="auto">&lt;fixed-arity-complex-term&gt; :- <code>(</code>&lt;term&gt;*<code>)</code> | <code>[</code>&lt;term&gt;*<code>]</code></p>
<p dir="auto">&lt;variable-arity-complex-term&gt; :- <code>(</code>&lt;term&gt;* <code>&amp;</code> &lt;?var&gt;<code>)</code> | <code>[</code>&lt;term&gt;* <code>&amp;</code> &lt;?var&gt;<code>]</code></p>
<p dir="auto">&lt;opaque-term&gt; :- Any Clojure value supporting Clojure <code>=</code> (so, not a regex) that is not a transparent term</p>
<p dir="auto">&lt;?var&gt; :- &lt;binding-?var&gt; | &lt;anonymous-?var&gt;</p>
<p dir="auto">&lt;anonymous-?var&gt; :- <code>?</code> | &lt;<code>_</code>-anonymous-?var&gt;</p>
<p dir="auto">&lt;<code>_</code>-anonymous-?var&gt;: Symbol whose name begins with <code>&#34;?_&#34;</code></p>
<p dir="auto">&lt;constant&gt;: An opaque term or a ?var-free complex term</p>
<p dir="auto">&lt;answer-template&gt; :- &lt;term&gt;</p>
<p dir="auto">Note:</p>
<ul dir="auto">
<li>
<p dir="auto">All predicates are terms.</p>
</li>
<li>
<p dir="auto">All ?vars are symbols.</p>
</li>
<li>
<p dir="auto">Statements and assertions, being lists, are terms.</p>
</li>
<li>
<p dir="auto">The arguments of operators are statements.  See our Built-in predicates
section.</p>
</li>
<li>
<p dir="auto">Outside of Clojure-calling predicates&#39; Clojure form arguments:
Symbols appearing in statements are taken at face value, not evaluated.
A symbol used in Prolog otherwise has no relationship to its value
(or the lack thereof) in Clojure.</p>
</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Additional terminology and conventions</h2><a id="user-content-additional-terminology-and-conventions" aria-label="Permalink: Additional terminology and conventions" href="#additional-terminology-and-conventions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Considering for the moment only assertion (not special) predicates,
logic programming <strong>search</strong> processes (or <strong>calls</strong>), in turn from
left to right, each <strong>goal</strong> in an (implicitly) conjunctive <strong>query</strong>
by...</p>
<ul dir="auto">
<li>
<p dir="auto">Identifying assertions whose head statement matches the goal</p>
</li>
<li>
<p dir="auto">Prepending a matching assertion&#39;s body statements (AKA the assertion&#39;s
<strong>goals</strong>) to the query&#39;s remaining goals, after applying the
match&#39;s ?var bindings to each such goal</p>
</li>
<li>
<p dir="auto">Processing remaining goals, recursively, ...</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Backtracking</strong> to remaining matching assertions, when matching a
given assertion <strong>fails</strong></p>
</li>
<li>
<p dir="auto">When no goals remain, <strong>succeed</strong> by...</p>
<ul dir="auto">
<li>
<p dir="auto">Recording an <strong>answer</strong> that realizes the query&#39;s <strong>answer
template</strong> according to ?var matches made along the search path</p>
</li>
<li>
<p dir="auto">Backtracking to search for any additional answers.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p dir="auto">Search generally proceeds depth-first and from left to right.</p>
<p dir="auto">We <strong>match</strong> two statements or transparent terms by associating their
respective terms and ?vars, position by position, with consistent
matching for non-anonymous ?vars.  In matching (AKA &#34;unification&#34;),
...</p>
<ul dir="auto">
<li>
<p dir="auto">A ?var matches a ?var, a transparent term, or a constant.</p>
</li>
<li>
<p dir="auto">Constants match equal (Clojure <code>=</code>) constants.</p>
</li>
<li>
<p dir="auto">Complex terms match recursively.</p>
</li>
<li>
<p dir="auto">A <strong>tail ?var</strong> (last in a statement or complex term, and preceded by
<code>&amp;</code>) matches the (possibly empty) seq or vector of terms remaining in
the parallel traversal of its opposing complex term.</p>
</li>
</ul>
<p dir="auto">One term <strong>subsumes</strong> another if the two terms match and---considering
?var occurrences---the former is at least as general as the latter.</p>
<p dir="auto">A <strong>ground</strong> term has no ?vars (none outside of any opaque included
terms, where they are not treated as ?vars).</p>
<p dir="auto">Here---and in leash (execution tracing) reports---the notation
&lt;predicate&gt;/&lt;integer&gt; (e.g., <code>sibling/2</code>) refers to the
&lt;integer&gt; arity of &lt;predicate&gt;.</p>
<p dir="auto">By convention, we take the first argument of a 2-ary statement to be the
predicate&#39;s <strong>subject</strong>, the second to be its <strong>object</strong>.  Thus, in
<code>(brother Jane John)</code>, we take <code>Jane</code> to be the subject (or agent),
<code>John</code> to be the object (or patient).  (&#34;A brother of Jane is John.&#34;)</p>
<p dir="auto">A <strong>unit</strong> assertion has only a head statement, no body statements.</p>


<p dir="auto">Clear the knowledge base and any existing special predicate
transforms, then execute the transform definitions in function
<code>create-predicate-transforms</code>.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Knowledge base and predicate transform contexts</h3><a id="user-content-knowledge-base-and-predicate-transform-contexts" aria-label="Permalink: Knowledge base and predicate transform contexts" href="#knowledge-base-and-predicate-transform-contexts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Bind <code>*assertions*</code> and/or <code>*predicate-transforms*</code>, per their doc
strings, to set up contexts for different knowledge bases and/or
transform definitions.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Creating assertions---macros and functions</h3><a id="user-content-creating-assertions---macros-and-functions" aria-label="Permalink: Creating assertions---macros and functions" href="#creating-assertions---macros-and-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We provide four assertion creation functions and four corresponding
macros.  The macros, which don&#39;t require quoting arguments, so are
simpler to use at the REPL or from top level in a file, take their
statement arguments at top-level.  The functions take theirs in a list.</p>
<p dir="auto">An assertion&#39;s head statement...</p>
<ul dir="auto">
<li>
<p dir="auto">May not be a ?var.</p>
</li>
<li>
<p dir="auto">May be variadic, but must require arity &gt;= 1 (i.e., must not start
with <code>&amp;</code>).</p>
</li>
<li>
<p dir="auto">Must not have a built-in special predicate in its predicate
position.  We don&#39;t flag assertions to transform predicates;
however, once a predicate has been used on the left-hand side of a
transform&#39;s defining production rule, we refrain from exercising
same-predicate assertions.</p>
</li>
</ul>
<p dir="auto">See the functions&#39; doc strings for other fine points.</p>
<p dir="auto">The following forms have equivalent effect: Add the assertion with
head statement <code>(sibling ?x ?y)</code> and lone goal statement <code>(brother ?x ?y)</code>
to the knowledge base.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(&lt;- (sibling ?x ?y) (brother ?x ?y)) ; Macro.

(assert&lt;- &#39;((sibling ?x ?y) (brother ?x ?y))) ; Function."><pre>(<span>&lt;-</span> (<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y)) <span><span>;</span> Macro.</span>

(<span>assert&lt;-</span> &#39;((<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y))) <span><span>;</span> Function.</span></pre></div>
<p dir="auto">The following place their constant-predicate, fixed-arity assertion
first for consideration in search.  We provide no explicit control
over the order in which (less conventional) assertions with variadic,
variable, or non-ground complex head statement predicates are examined
during backtracking search.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(&lt;-0 (sibling ?x ?y) (brother ?x ?y)) ; Macro.

(assert&lt;-0 &#39;((sibling ?x ?y) (brother ?x ?y))) ; Function."><pre>(<span>&lt;-0</span> (<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y)) <span><span>;</span> Macro.</span>

(<span>assert&lt;-0</span> &#39;((<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y))) <span><span>;</span> Function.</span></pre></div>
<p dir="auto">The following clear <code>sibling/2</code> before making their assertion.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(&lt;-- (sibling ?x ?y) (brother ?x ?y)) ; Macro.

(assert&lt;-- &#39;((sibling ?x ?y) (brother ?x ?y))) ; Function."><pre>(<span>&lt;--</span> (<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y)) <span><span>;</span> Macro.</span>

(<span>assert&lt;--</span> &#39;((<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y))) <span><span>;</span> Function.</span></pre></div>
<p dir="auto">The following clear the entire knowledge base of all but special
transforms before making their assertion.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(&lt;--- (sibling ?x ?y) (brother ?x ?y)) ; Macro.

(assert&lt;--- &#39;((sibling ?x ?y) (brother ?x ?y))) ; Function."><pre>(<span>&lt;---</span> (<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y)) <span><span>;</span> Macro.</span>

(<span>assert&lt;---</span> &#39;((<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y))) <span><span>;</span> Function.</span></pre></div>
<p dir="auto">The following---when employed systematically---avoid
subsumed-subsuming assertion pairs in the knowledge base, by declining
to add would-be-subsumed assertions and by retracting subsumed
assertions.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(&lt;-_ (sibling ?x ?y) (brother ?x ?y)) ; Macro.

(assert&lt;-_ &#39;((sibling ?x ?y) (brother ?x ?y))) ; Function."><pre>(<span>&lt;-_</span> (<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y)) <span><span>;</span> Macro.</span>

(<span>assert&lt;-_</span> &#39;((<span>sibling</span> ?x ?y) (<span>brother</span> ?x ?y))) <span><span>;</span> Function.</span></pre></div>
<p dir="auto">We retrieve assertions once upon calling a predicate, and assertion or
retraction operations otherwise relevant to that predicate will be
reflected during the call.</p>

<p dir="auto">We provide three functions for retrieving assertions by matching their
heads against a statement pattern.  Each returns a vector containing the
knowledge base&#39;s assertions whose head statements exhibit the function&#39;s
required relationship to <code>statement-pattern</code>.</p>
<p dir="auto">Get assertions whose head matches <code>statement-pattern</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(get-matching-head-assertions statement-pattern)"><pre>(<span>get-matching-head-assertions</span> statement-pattern)</pre></div>
<p dir="auto">Get assertions whose head is subsumed by <code>statement-pattern</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(get-subsumed-head-assertions statement-pattern)"><pre>(<span>get-subsumed-head-assertions</span> statement-pattern)</pre></div>
<p dir="auto">Get assertions whose head subsumes <code>statement-pattern</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(get-subsuming-head-assertions statement-pattern)"><pre>(<span>get-subsuming-head-assertions</span> statement-pattern)</pre></div>
<p dir="auto">We provide two similar functions that match assertions against a
full assertion pattern.</p>
<p dir="auto">Get assertions entirely subsumed by <code>assertion-pattern</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(get-subsumed-assertions assertion-pattern)"><pre>(<span>get-subsumed-assertions</span> assertion-pattern)</pre></div>
<p dir="auto">Get assertions entirely subsuming <code>assertion-pattern</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(get-subsuming-assertions assertion-pattern)"><pre>(<span>get-subsuming-assertions</span> assertion-pattern)</pre></div>

<p dir="auto">We provide two functions, and two corresponding macros, for retracting
assertions by matching their head statements against a pattern and
one function to retract assertions entirely matching an assertion pattern.</p>
<p dir="auto">The following have equivalent effect.  As in the assertion retrieval
functions, <code>statement-pattern</code> refers to assertions&#39; head statements.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(retract-subsumed-head-assertions statement-pattern)

(--- statement-pattern)"><pre>(<span>retract-subsumed-head-assertions</span> statement-pattern)

(<span>---</span> statement-pattern)</pre></div>
<p dir="auto">The following have equivalent effect.  Here, <code>assertion</code> must be equal
(Clojure <code>=</code>, including equal ?var symbols) to an assertion in the
knowledge base, for the latter to be retracted.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(retract-specific-assertion assertion) ; Function.

(-- statement-pattern) ; Macro."><pre>(<span>retract-specific-assertion</span> assertion) <span><span>;</span> Function.</span>

(<span>--</span> statement-pattern) <span><span>;</span> Macro.</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="(retract-subsumed-assertions &#39;((?pred deceased-person)))"><pre>(<span>retract-subsumed-assertions</span> &#39;((<span>?pred</span> deceased-person)))</pre></div>

<p dir="auto">The following macro and function are equivalent---except that the
macro does not support keyword arguments (instead, bind the
default-value globals).  With a truthy limit, terminate search upon
having recorded so many answers.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(? answer-template &amp; goals) ; Macro.

(query answer-template goals ; Function.
       :limit *answer-count-limit*
       :discard-subsumed *discard-subsumed-answers*)"><pre>(<span>?</span> answer-template &amp; goals) <span><span>;</span> Macro.</span>

(<span>query</span> answer-template goals <span><span>;</span> Function.</span>
       <span>:limit</span> *answer-count-limit*
       <span>:discard-subsumed</span> *discard-subsumed-answers*)</pre></div>

<p dir="auto">For now, leashing is an all-or-nothing proposition.  Perform any query
with <code>*leash*</code> bound truthy, for goal-by-goal reports describing
execution.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(binding [*leash* true]
  ;; Query form(s) in here.
  )"><pre>(<span>binding</span> [*leash* <span>true</span>]
  <span><span>;</span>; Query form(s) in here.</span>
  )</pre></div>
<p dir="auto">As demonstrated in our Highlights section and in
<code>test/prolog/leash-tests.txt</code>, leashing reports...</p>
<ul dir="auto">
<li>Entry into and success or failure of goals</li>
<li>Backtracking into...
<ul dir="auto">
<li>Remaining matching assertions of goals with assertion predicates</li>
<li>Remaining disjuncts (remaining alternatives goals) of <code>or</code> goals</li>
</ul>
</li>
<li><code>first</code> operator-induced cuts</li>
<li>Application of predicate transforms</li>
<li>The discovery of answers and their disposition</li>
<li>Search termination upon reaching an answer count limit.</li>
</ul>
<p dir="auto">Leashing also...</p>
<ul dir="auto">
<li>Indexes reports per depth of assertion nesting</li>
<li>Indicates the nesting of built-in predicates for the current assertion</li>
<li>Left-pads reports per nesting of assertion and built-in predicate goals.</li>
</ul>
<p dir="auto">When <code>*pprint-leash-statements*</code> is truthy, ...<code>&#34;Entering&#34;</code>, ...</p>
<ul dir="auto">
<li><code>&#34;Matched head&#34;</code> leash reports are omitted.</li>
<li><code>&#34;Succeeded&#34;</code>, and <code>&#34;Failed&#34;</code> leash reports pprint (vs. print)
statement content, starting on a new line, with indentation, as in...</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="clolog.core&gt; (binding [*leash* true
                       *pprint-leash-statements* true]
               (query &#39;[?h ?w ?z] &#39;((zebra ?h ?w ?z)) :limit 1))
0. Processing query: ((zebra ?h ?w ?z))
 1. Entering `zebra`/3:
    (zebra ?h:0 ?w:0 ?z:0)

  1. (same): Entering...
             (same
              ?h:0
              ((house norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (house ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1))

  1. (same): Succeeded...
             (same
              ((house norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (house ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1)
              ((house norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (house ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1))

  2. Entering `member`/2:
     (member
      (house englishman ?anon-11:1 ?anon-12:1 ?anon-13:1 red)
      ((house norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
       ?anon-4:1
       (house ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
       ?anon-9:1
       ?anon-10:1))"><pre>clolog.core&gt; (<span>binding</span> [*leash* <span>true</span>
                       *pprint-leash-statements* <span>true</span>]
               (<span>query</span> &#39;[?h ?w ?z] &#39;((<span>zebra</span> ?h ?w ?z)) <span>:limit</span> <span>1</span>))
<span>0.</span> Processing query: ((<span>zebra</span> ?h ?w ?z))
 <span>1.</span> Entering `zebra`/<span>3</span>:
    (<span>zebra</span> ?h:0 ?w:0 ?z:0)

  <span>1.</span> (<span>same</span>): Entering...
             (<span>same</span>
              ?h:0
              ((<span>house</span> norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (<span>house</span> ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1))

  <span>1.</span> (<span>same</span>): Succeeded...
             (<span>same</span>
              ((<span>house</span> norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (<span>house</span> ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1)
              ((<span>house</span> norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
               ?anon-4:1
               (<span>house</span> ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
               ?anon-9:1
               ?anon-10:1))

  <span>2.</span> Entering `member`/<span>2</span>:
     (<span>member</span>
      (<span>house</span> englishman ?anon-11:1 ?anon-12:1 ?anon-13:1 red)
      ((<span>house</span> norwegian ?anon-0:1 ?anon-1:1 ?anon-2:1 ?anon-3:1)
       ?anon-4:1
       (<span>house</span> ?anon-5:1 ?anon-6:1 ?anon-7:1 milk ?anon-8:1)
       ?anon-9:1
       ?anon-10:1))</pre></div>

<p dir="auto">We support the following built-in predicates.  We borrow some notation
from our Grammar section and allow ourselves to introduce types via
obvious naming (e.g., a &lt;condition-statement&gt; is a
&lt;statement&gt;---distinguished merely by its role/argument position in the
built-in predicate <code>if</code>).  We invoke the exclued middle: If a goal
does not succeed, then it fails.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>(and</code> &lt;statement&gt;*<code>)</code> succeeds if, proceeding from left to right,
every conjunct statement succeeds.</p>
</li>
<li>
<p dir="auto"><code>(or</code> &lt;statement&gt;*<code>)</code> succeeds if, proceeding from left to
right, some disjunct statement succeeds (and remaining disjuncts are
ignored).  Backtracking will explore first alternative ways to
satisfy a failing statement, then subsequent statements.</p>
</li>
<li>
<p dir="auto"><code>(if</code> &lt;condition-statement&gt; &lt;then-statement&gt; &lt;else-statement&gt;<code>)</code>
succeeds if either:</p>
<ul dir="auto">
<li>
<p dir="auto">The condition statement succeeds and the then statement succeeds (in which
case we do not examine the else statement under the bindings for
the condition statement&#39;s ?vars)</p>
</li>
<li>
<p dir="auto">The condition statement fails and the else statement succeeds (in which
case we do not examine <code>then-statement</code>).</p>
</li>
</ul>
<p dir="auto">Backtracking will explore alternative ways to satisfy the argument
statements.</p>
</li>
<li>
<p dir="auto"><code>(not</code> &lt;statement&gt;<code>)</code> succeeds if the wrapped statement fails.</p>
</li>
<li>
<p dir="auto"><code>(first</code> &lt;statement&gt;<code>)</code> succeeds if the argument statement succeeds.  This
form (AKA Prolog &#34;cut&#34;) skips backtracking to explore other ways of
satisfying the statement, upon its first success.</p>
</li>
<li>
<p dir="auto"><code>(same</code> &lt;term&gt; &lt;term&gt;<code>)</code> succeeds if the two terms match.</p>
</li>
<li>
<p dir="auto"><code>(true)</code> succeeds unconditionally.</p>
</li>
<li>
<p dir="auto"><code>(false)</code> fails unconditionally.</p>
</li>
<li>
<p dir="auto"><code>(var</code> &lt;term&gt;<code>)</code> succeeds if the argument term is a ?var.</p>
</li>
<li>
<p dir="auto"><code>(ground \&lt;term\&gt;)</code> succeeds if the argument term is ground.</p>
</li>
<li>
<p dir="auto"><code>(truthy?</code> &lt;form&gt;<code>)</code> succeeds if the argument form is ground and
the result of its evaluation (in Clojure) is truthy.</p>
</li>
<li>
<p dir="auto"><code>(evals-from?</code> &lt;term&gt; &lt;form&gt;<code>)</code> succeeds if the argument form is
ground and the result of its evaluation (in Clojure) matches the
argument term (often a ?var).</p>
</li>
<li>
<p dir="auto"><code>(do</code> &lt;form&gt;*<code>)</code> succeeds if the whole <code>do</code> expression is ground,
evaluating it (in Clojure) for side effect, only.</p>
</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Creating special transforms</h2><a id="user-content-creating-special-transforms" aria-label="Permalink: Creating special transforms" href="#creating-special-transforms"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The function call below---performed by <code>initialize-prolog</code>---seeds
Clolog with some transforms for predicates we have found useful in
other Lisp-based Prologs.  As we intend this facility to support
customization, you may wish to copy our version of
<code>create-predicate-transforms</code> and edit it to your liking.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(create-predicate-transforms)"><pre>(<span>create-predicate-transforms</span>)</pre></div>
<p dir="auto"><code>create-predicate-transforms</code> includes calls to
<code>create-predicate-transform</code>.  Each call is a production rule.  During
search, a goal matching <code>source-statement</code> is transformed---via
de-referencing---into <code>target-statement</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(create-predicate-transform source-statement target-statement)"><pre>(<span>create-predicate-transform</span> source-statement target-statement)</pre></div>
<p dir="auto">The execution machinery for transform predicates applies the first
matching transform irrevocably, with no backtracking in case of
failure.  Compared to an assertion predicate defined using using one
assertion per transform and the same statements in each
transform-assertion pair, it is as if the transform predicate&#39;s goal
always were wrapped with <code>first</code>.  We consider predicate transforms to
be &#34;macros&#34; for Prolog, affording us cleaner leashing than would
similar assertion predicates.  Assertion predicatess more verbose
leashing may nonetheless be helpful in prototyping and debugging
prospective transforms.  It may help to call
<code>create-predicate-transforms</code> with optional argument <code>debugging?</code>
truthy---and either disregard any effects resulting from backtracking
into prospective transform predicates ultimately intended or (as in
<code>tests/clolog/core_tests.clj</code>) avoid backtracking by limiting the
count of answers found.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Potential future enhancements</h2><a id="user-content-potential-future-enhancements" aria-label="Permalink: Potential future enhancements" href="#potential-future-enhancements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We might pursue some of the following ideas towards increasing
expressivity/leashing, robustness/scale, and efficiency, given
motivating use cases.</p>
<ul dir="auto">
<li>
<p dir="auto">Potential enhancements to expressiveness and leashing:</p>
<ul dir="auto">
<li>
<p dir="auto">Accommodate non-ground Clojure expressions in Clojure-calling
forms---in case a called form would use these in crafting
subsequent goal (e.g.).</p>
</li>
<li>
<p dir="auto">Make the local/lexical environment accessible within called
Clojure forms.</p>
</li>
<li>
<p dir="auto">Support RDF, RDFS, selected aspects of OWL (e.g., inverses,
functional dependencies).</p>
</li>
<li>
<p dir="auto">Selective leashing, considering (e.g.) predicate, arity,
report type (e.g., answer disposition).</p>
</li>
<li>
<p dir="auto">Selective detail in leashing, e.g., re <code>if</code> subgoals</p>
</li>
<li>
<p dir="auto">Greater precision in leash report prefixes for n-ary operators
<code>and</code>, <code>or</code> (e.g., indexing potentially like-predicate conjuncts,
disjuncts).</p>
</li>
</ul>
</li>
<li>
<p dir="auto">Potential enhancements to robustness and scale</p>
<ul dir="auto">
<li>
<p dir="auto">Error-check user/application inputs more pervasively.</p>
</li>
<li>
<p dir="auto">Support Prolog stack limits, breakpoints, stepping/debugger
integration.</p>
</li>
<li>
<p dir="auto">Support database integration---access to unit ground assertions.</p>
</li>
</ul>
</li>
<li>
<p dir="auto">Potential efficiency enhancements</p>
<ul dir="auto">
<li>
<p dir="auto">Perform further indexing, including trie-based indexing.</p>
</li>
<li>
<p dir="auto">Qualify seq/vector matching with early check for compatible
lengths of candidate-matching seqs and vectors.</p>
</li>
<li>
<p dir="auto">Decline to explore alternative satisfactions of a ground goal.</p>
</li>
<li>
<p dir="auto">Skirt search branches that cannot instantiate an answer template
?var.</p>
</li>
<li>
<p dir="auto">Support parallelism and/or laziness.</p>
</li>
</ul>
</li>
</ul>

<p dir="auto">Copyright © 2023 Robert Carl Schrag</p>
<p dir="auto">This program and the accompanying materials are made available under
the terms of the Eclipse Public License 2.0 which is available at
<a href="http://www.eclipse.org/legal/epl-2.0" rel="nofollow">http://www.eclipse.org/legal/epl-2.0</a>.</p>
<p dir="auto">This Source Code may also be made available under the following
Secondary Licenses when the conditions for such availability set forth
in the Eclipse Public License, v. 2.0 are satisfied: GNU General
Public License as published by the Free Software Foundation, either
version 2 of the License, or (at your option) any later version, with
the GNU Classpath Exception which is available at
<a href="https://www.gnu.org/software/classpath/license.html" rel="nofollow">https://www.gnu.org/software/classpath/license.html</a>.</p>
</article></div></div>
  </body>
</html>
