<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogg.bekk.no/fixing-a-performance-problem-in-elm-using-html-lazy-c4298b72500d?gi=65357a7e63ad">Original</a>
    <h1>Fixing a performance problem in Elm using Html.Lazy</h1>
    
    <div id="readability-page-1" class="page"><div><div><section><div><div><div><div><div><div><p><a href="https://medium.com/@robinheggelundhansen?source=post_page-----c4298b72500d-----------------------------------" rel="noopener follow"><img alt="Robin Heggelund Hansen" src="https://miro.medium.com/fit/c/96/96/1*rxMRJovNH7y93KblWvAh-g.jpeg" width="48" height="48"/></a></p></div></div></div></div><p id="3e88">A few weeks ago, I got to sit down with a colleague of mine to fix a performance issue with one of our customer’s search page. The page looks something like this:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*Bg8SqiZO5GU49sXWch144A.png" width="700" height="645" role="presentation"/></p></div></figure><p id="9b75">This page is one Elm app. Its job is to present the user with a list of results that match a search the user has made, and let the user make a new search if they find no suitable result.</p><p id="f889">Before reading the next paragraph, keep in mind that the actual application is much more complex than the simple drawing I’ve just shown you. The illustration is only there to make it easier to understand the problem and the solution we arrived at.</p><p id="2b4d">The page worked as intended, but felt a bit slow. There were small, but noticeable, delays between characters when changing the content of the search field. When clicking a button you might notice a tiny delay before anything happened. The animation for clicking the search button, which due to a bug in <code>elm-animator</code> wasn&#39;t using css animations, was choppy.</p><p id="b31f">Now, the reason we were looking into this was because we, the developers, were unhappy about it. We hadn’t received any user feedback from our users that the page was slow. It wouldn’t even surprise me if most of our users didn’t notice any performance problem at all, much like many don’t notice the difference between a native- and an electron-app unless comparing them side-by-side. Well, the choppy animation was probably noticable, but that had only been in the app for a few days at this point.</p><p id="296b">In other words, the reason we were looking into this was because the performance didn’t meet our own high standards, not because it had become an actual problem… yet.</p><h2 id="dfc3">Finding the problem</h2><p id="7cdf">Whenever there is a performance problem, we need to find a reproducible way to measure it. Since we already had a choppy animation, we simply triggered the animation a couple of times while <a href="https://www.debugbear.com/blog/devtools-performance" rel="noopener ugc nofollow" target="_blank">running the browser’s builtin profiler</a>.</p><p id="e44b">Here are the results:</p><figure><p><img alt="" src="https://miro.medium.com/proxy/1*kmoDNrfg5ohbXzM0CXiRfA.png" role="presentation"/></p></figure><p id="30a3">The root of our performance problem stems from a function called <code>_Char_toCode</code>, which is being called by two <code>elm-css</code> functions: <code>VirtualDom.Styled.getClassname</code>and <code>Hash.fromString</code>.</p><p id="0f49">Since our animation isn&#39;t using css animations (again, due to a bug in <code>elm-animator</code>), every stage of the animation causes the view function of our Elm application to run. It seems that the most expensive part of our view function is when <code>elm-css</code>generates class names for the HTML elements.</p><p id="d32d">If the only problem we had was a choppy animation, we could re-implement it using css animations ourselves. However, since the app had a general feeling of sluggishness, that wouldn’t fix all our issues.</p><p id="764e">One could attempt to refactor the code to use less HTML elements, thereby giving <code>elm-css</code> less work to do. But when looking over the code, we didn&#39;t find any obvious way to do this. Even if we did manage to remove a bunch of HTML elements without changing the look of the page, we had no idea if it would be enough to fix our performance problems.</p><h2 id="a705">Enter Html.Lazy</h2><p id="28fa">Elm’s HTML package has a series of functions in a module called<code><a href="https://package.elm-lang.org/packages/elm/html/latest/Html-Lazy" rel="noopener ugc nofollow" target="_blank">Html.Lazy</a></code>, which lets you change a view function so that it is only called when its input arguments have changed. If the input arguments are the same as when the view was previously called, it will tell Elm&#39;s virtual dom implementation to make no changes to this particular part of the DOM <em>without</em> calling the actual view function.</p><p id="7748">As an example, if we have a view function call like:</p><pre><span id="2fdf">viewSearchResults currentDate results</span></pre><p id="e141">We can make it lazy by re-writing it to:</p><pre><span id="3f7d">Html.lazy2 viewSearchResults currentDate results</span></pre><p id="c39b">And then <code>viewSearchResults</code> will only be called if there is reason to believe that it could return something different, which potentially avoids all the computation that function has to make.</p><p id="9b57"><code>elm-css</code> has its own implementation of <code>Html.Lazy</code>, <code><a href="https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/Html-Styled-Lazy" rel="noopener ugc nofollow" target="_blank">Html.Styled.Lazy</a></code>, and so in theory we should be able to use this trick to give <code>elm-css</code> much less work to do, thereby increasing our performance.</p><p id="7526">It did turn out to be the case. Today, the search page runs much faster thanks to two lines of code that wrap our view functions using <code>Html.Styled.Lazy</code>. However, in order for those two lines to work we did have to do quite a bit of refactoring, in part because of how this optimization works.</p><h2 id="6f79">The problem with Html.Lazy</h2><p id="12e3">The first thing we had to fix was some bad design on our part.</p><p id="1e56">The search page is structured like two separate Elm views. The top part of the page, the search box, is one view while the results is another. It is natural then, that both of these top-level view functions become wrapped in <code>Html.Styled.Lazy</code> functions. This way, if you edit the text in the search box, the computation for rendering the search results can be skipped.</p><p id="5580">However, both view functions, as well as their sub-views, take in the entire model as an input argument. This doesn’t play too well with <code>Html.Lazy</code>, as the view will be triggered whenever the input changes, and since the input is the model itself, it will trigger every time one of its fields changes, even if that field isn’t being used in the particular view.</p><p id="ab4c">It’s also problematic from a code design perspective, as the views become very tightly coupled to the entire state of the application.</p><p id="7d1d">It took some time to refactor this so that both view functions had their own, entirely separate, piece of the model. Strangely enough, the application felt just as sluggish as before.</p><p id="61dc">In order to reduce the amount of refactoring, we had opted not to change the actual application model, as that would also require us to refactor the init and update functions. Instead, we divided the application model into separate pieces as part of the view function itself.</p><p id="cda7">So, where we previously had code like this:</p><pre><span id="5d9b">view : Model -&gt; Html msg</span></pre><p id="f2a5">We now had:</p><pre><span id="b3dd">view : Model -&gt; Html msg<!-- -->       <!-- --></span></pre><p id="32ef">But this didn’t work.</p><p id="0c4a">The reason is that functions in <code>Html.Styled.Lazy</code> have a different notion of equality than Elm itself. In general, two things are considered equal in Elm if they represent the same value. However, <code>Html.Styled.Lazy</code> functions only considers two things to be equal if they are the same <em>reference</em>.</p><p id="23b2">Since we were constructing a new <code>searchModel</code> and <code>resultsModel</code> object every time the view function was being called, they would <em>never</em> be considered equal to the previous input by <code>Html.Styled.Lazy</code>functions, even if comparing them with Elm&#39;s <code>==</code> would return true.</p><p id="9663">Realizing this, we went on and refactored the application model to have its own <code>search</code> and <code>results</code> sub-models. This also required big changes to our <code>init</code> and <code>update</code> functions.</p><p id="be61">After another hour or two we had a better structured application. Not only that, the animation was running silky-smooth and there were no noticable delays anywhere.</p><h2 id="6abd">In conclusion</h2><p id="467f"><code>Html.Lazy</code>, or <code>Html.Styled.Lazy</code>, can be a great way to improve the performance of your Elm applications. However, it&#39;s an optimization that is easy to get wrong.</p><p id="1f1e"><code>Html.Lazy</code> is the only construct in Elm that has the notion of reference equality. Because of that, it&#39;s an easy thing to forget when refactoring code, especially if you&#39;re not working on the same code base on a daily basis. You now need to be careful to retain reference equality in <code>update</code> and <code>view</code> functions around your code, something you normally don’t need to worry about.</p><p id="890d">If you don’t, nothing bad happens other than performance becoming worse, which you may or may not notice depending on your hardware, if you have Elm’s debugger running, or the code paths you’re triggering.</p><p id="c1da">So while <code>Html.Lazy</code> can be a great tool, I found myself wishing that <code>elm-css</code>was fast enough that we didn&#39;t have to use this optimization at all.</p><p id="f563">Tomorrow, I’ll take a deep dive into the inner workings of <code>elm-css</code> and explain how I found a way to nearly double the performance of the framework.</p></div></div></section></div></div></div>
  </body>
</html>
