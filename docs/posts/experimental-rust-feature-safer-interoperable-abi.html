<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rust-lang/rust/pull/105586">Original</a>
    <h1>Experimental Rust Feature: Safer Interoperable ABI</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">Hey there, I work on <a href="https://github.com/h33p/cglue">CGlue</a>, so I&#39;ve been trying to deal with this problem at a library level. Here are my 2 cents on some of the open questions</p>
<blockquote>

<div data-snippet-clipboard-copy-content="* Niches: should we support cases like `Option&lt;bool&gt;` without a separate
  discriminant, or should we (for simplicity) always pass a separate
  discriminant? Likely the latter. However, what about things like `Option&lt;&amp;T&gt;`
  and `Option&lt;NonZeroU32&gt;`, for which Rust guarantees the representation of
  `None`? Those work with the C ABI, and they have to work with the
  interoperable ABI, but can we make them work with the interoperable ABI
  _using the same encoding of `None`_?"><pre><code>* Niches: should we support cases like `Option&lt;bool&gt;` without a separate
  discriminant, or should we (for simplicity) always pass a separate
  discriminant? Likely the latter. However, what about things like `Option&lt;&amp;T&gt;`
  and `Option&lt;NonZeroU32&gt;`, for which Rust guarantees the representation of
  `None`? Those work with the C ABI, and they have to work with the
  interoperable ABI, but can we make them work with the interoperable ABI
  _using the same encoding of `None`_?
</code></pre></div>
</blockquote>
<p dir="auto"><code>Option&lt;&amp;T&gt;</code> I&#39;d say is already well defined to be represented as <code>*const T</code> and is as efficient as you can get, so I don&#39;t see the reason to change that. Things like <code>cbindgen</code> rely on the layout.</p>
<p dir="auto">Talking more about niches, and this is very very niche, successful Option and Result values can be returned using pointer to <code>MaybeUninit&lt;T&gt;</code> as function parameter,  and then returning an integer (0/1) to specify whether the option was successful or not. I think it may be worth to specify the general case for these ubiquitous types, but I wouldn&#39;t go as far as specifying <code>Option&lt;bool&gt;</code>, or we will end up with <a href="https://en.cppreference.com/w/cpp/container/vector_bool" rel="nofollow"><code>std::vector&lt;bool&gt;</code></a>, which as I understand correctly, C++ people almost universally hate.</p>
<blockquote>
<div data-snippet-clipboard-copy-content="* What subset of lifetimes can, and should, we support? We can&#39;t enforce them
  cross-language, but they may be useful as an advisory/documentation
  mechanism. Or we could leave them out entirely."><pre><code>* What subset of lifetimes can, and should, we support? We can&#39;t enforce them
  cross-language, but they may be useful as an advisory/documentation
  mechanism. Or we could leave them out entirely.
</code></pre></div>
</blockquote>
<p dir="auto">I personally don&#39;t see the reason why full set of lifetimes can&#39;t be supported on rust side. If I understand it correctly, lifetimes are something that sits on top of the type system. Foreign languages just need to uphold to the contract. In fact, this is the way it already is with <code>repr(C)</code>.</p>
<blockquote>
<div data-snippet-clipboard-copy-content="* To what extent should the interoperable ABI make _any_ attempt to specify
  things that can&#39;t be enforced, rather than ignoring semantics entirely and
  _only_ specifying how types get passed?"><pre><code>* To what extent should the interoperable ABI make _any_ attempt to specify
  things that can&#39;t be enforced, rather than ignoring semantics entirely and
  _only_ specifying how types get passed?
</code></pre></div>
</blockquote>
<p dir="auto">I think you can&#39;t enforce anything on the foreign side, but I&#39;m not good for this particular discussion.</p>
<blockquote>
<div data-snippet-clipboard-copy-content="* How can we make it easy to support data structures without having to do
  translation from `repr(Rust)` to `repr(interop)` and have parallel structures?
  Can we make that less painful to express, and ideally mostly free at runtime?"><pre><code>* How can we make it easy to support data structures without having to do
  translation from `repr(Rust)` to `repr(interop)` and have parallel structures?
  Can we make that less painful to express, and ideally mostly free at runtime?
</code></pre></div>
</blockquote>
<p dir="auto">Some things that <code>repr(Rust)</code> does could be specified, such as sorting fields by size. Some well defined rust structures could have <code>repr(interop)</code> attached, however, if I understand correctly, that would be a massive can of worms to open. So unless I&#39;m missing something, the best that can be done is ordering of fields so that in the end both <code>repr(Rust)</code> and <code>repr(interop)</code> types would end up having the same representation in majority of cases.</p>
<blockquote>
<div data-snippet-clipboard-copy-content="* Do we get any value out of supporting `()`, other than completeness? Passing
  `()` by value should just be ignored as if it weren&#39;t specified. Do we want
  people using pointers to `()`, and do those have any advantage over pointers
  to void?"><pre><code>* Do we get any value out of supporting `()`, other than completeness? Passing
  `()` by value should just be ignored as if it weren&#39;t specified. Do we want
  people using pointers to `()`, and do those have any advantage over pointers
  to void?
</code></pre></div>
</blockquote>
<p dir="auto">There is quite a lot of value in supporting <code>()</code>. For starters, miri complains if I pass <code>*const c_void</code> that points to a value of zero size, because <code>c_void</code> itself is not zero-sized. In addition, in generic contexts, it&#39;s useful to be able to completely eliminate a field. C ABI does not allow 2 fields to share a memory location.</p>
<p dir="auto">For some context, in CGlue I&#39;m generating an optional context structure for cases where a trait returns a reference to an object. What I do, is opaque wrap that reference and store it under that context structure, and then return a reference to the value within the context structure. More specifically, <a href="https://github.com/h33p/cglue/blob/main/cglue/src/trait_group.rs#L53">this field</a>. If a trait object does not return any references, context <code>C</code> type is zero sized and then through some bindgen/template magic I explicitly eliminate that field when generating C/C++ headers.</p>
<p dir="auto">Ability to represent zero-sized fields would be incredibly useful to avoid structure size bloat, or manual elimination.</p>
<blockquote>
<div data-snippet-clipboard-copy-content="* For generics, such as `Option&lt;u64&gt;` or `Result&lt;u32, ConcreteError&gt;` or
  `[u8; 16]`, does the rule &#34;all generic parameters must be bound to concrete
  types in the function signature&#34; suffice, or do we need a more complex rule
  than that?"><pre><code>* For generics, such as `Option&lt;u64&gt;` or `Result&lt;u32, ConcreteError&gt;` or
  `[u8; 16]`, does the rule &#34;all generic parameters must be bound to concrete
  types in the function signature&#34; suffice, or do we need a more complex rule
  than that?
</code></pre></div>
</blockquote>
<p dir="auto">There are 2 cases, function instantiation and function definition. To emit a symbol that is in the symbol table you need all generics to be bound, however, I don&#39;t see a reason why this couldn&#39;t work:</p>
<div dir="auto" data-snippet-clipboard-copy-content="extern &#34;interop&#34; fn nop&lt;T&gt;(val: T) -&gt; T {
    val
}"><pre><span>extern</span> <span>&#34;interop&#34;</span> <span>fn</span> <span>nop</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>val</span><span>:</span> <span>T</span><span>)</span> -&gt; <span>T</span> <span>{</span>
    val
<span>}</span></pre></div>
<p dir="auto">The following is already valid (and I rely on it in CGlue for generating vtables):</p>
<div dir="auto" data-snippet-clipboard-copy-content="extern &#34;C&#34; fn nop&lt;T&gt;(val: T) -&gt; T {
    val
}"><pre><span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>nop</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>val</span><span>:</span> <span>T</span><span>)</span> -&gt; <span>T</span> <span>{</span>
    val
<span>}</span></pre></div>
<p dir="auto">What you can&#39;t do is the following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#[no_mangle]
extern &#34;C&#34; fn nop&lt;T&gt;(val: T) -&gt; T {
    val
}"><pre><span>#<span>[</span>no_mangle<span>]</span></span>
<span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>nop</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>val</span><span>:</span> <span>T</span><span>)</span> -&gt; <span>T</span> <span>{</span>
    val
<span>}</span></pre></div>
<blockquote>
<div data-snippet-clipboard-copy-content="* Unwinding: The default interoperable-ABI should not support unwind, and most
  languages don&#39;t tend to have support for unwinding through C-ABI functions,
  but should we have a `interop-unwind` variant? Would doing so provide value?"><pre><code>* Unwinding: The default interoperable-ABI should not support unwind, and most
  languages don&#39;t tend to have support for unwinding through C-ABI functions,
  but should we have a `interop-unwind` variant? Would doing so provide value?
</code></pre></div>
</blockquote>
<p dir="auto">If unwinding is well defined, I&#39;d see great value in plugin systems to be able to panic. Otherwise, an efficient way to reach an abort in case of a panic without impacting performance would be beneficial. I am not so strong on the details here, but <code>catch_unwind</code> seems slow to me (but this is just me building on top of C++ try/catch experience).</p>
      </div>
</div></div>
  </body>
</html>
