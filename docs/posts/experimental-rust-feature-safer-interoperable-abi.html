<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rust-lang/rust/pull/105586">Original</a>
    <h1>Experimental Rust Feature: Safer Interoperable ABI</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <task-lists disabled="" sortable="">
    <div>
      
<p dir="auto">This experimental feature gate proposal proposes developing a new ABI, <code>extern &#34;interop&#34;</code>, and a new in-memory representation, <code>repr(interop)</code>, for</p>
<p dir="auto">This will use the feature gate <code>interoperable_abi</code>, which will be marked as</p>
<p dir="auto">The tag <code>interop</code> is a placeholder for the final name, and is likely to change</p>

<p dir="auto">Today, developers building projects incorporating multiple languages, or</p>
<p dir="auto">For popular pairs of languages, developers sometimes create higher-level</p>
<p dir="auto">Furthermore, higher-level data types such as <code>Option</code> and <code>Result</code> currently</p>
<p dir="auto">Finally, <em>system</em> libraries and other shared libraries typically use the C ABI</p>
<p dir="auto">The interoperable ABI will define a standard way to make calls across</p>
<p dir="auto">The interoperable ABI aims to be a reasonable default for compiled libraries in</p>

<p dir="auto">The interoperable ABI experiment will include a new ABI, <code>extern &#34;interop&#34;</code>,</p>
<p dir="auto">The interoperable ABI will be a strict superset of the C ABI. This ensures</p>
<p dir="auto">The interoperable ABI will be defined via &#34;lowering&#34; to the C ABI: the</p>
<p dir="auto">To the extent the interoperable ABI supports passing ownership (e.g. strings),</p>
<p dir="auto">The interoperable ABI may define a symbol naming scheme, to allow identifying</p>
<p dir="auto">The interoperable ABI should include a versioning scheme, to allow for future</p>
<p dir="auto">Rust will support defining functions using the interoperable ABI, and calling</p>
<p dir="auto">Rust should also support passing around function pointers to functions that use</p>
<h2 dir="auto">Non-requirements</h2>
<p dir="auto">The interoperable ABI does not aim to support the full richness of Rust&#39;s type</p>
<p dir="auto">In particular, while the interoperable ABI will over time support an increasing</p>
<p dir="auto">The interoperable ABI will not aim to support complex lifetime handling, or to</p>
<p dir="auto">The interoperable ABI (at least in the first version) will not provide an</p>
<p dir="auto">The interoperable ABI does not aim to provide &#34;translations&#34; between the</p>
<p dir="auto">The interoperable ABI cannot support arbitrary compile-time generic functions;</p>
<p dir="auto">The interoperable ABI cannot prevent callers from passing parameters that</p>
<p dir="auto">The initial version of the interoperable ABI will likely not attempt to</p>

<p dir="auto">This section includes some potential examples of types the interoperable ABI</p>
<ul dir="auto">
<li>Tuples, of arbitrary size.</li>
<li>The &#34;unit&#34; type <code>()</code>.</li>
<li>enums, including enum variants containing fields.
<ul dir="auto">
<li>More specifically, <code>Option</code> and <code>Result</code>.</li>
</ul>
</li>
<li>Counted UTF-8 strings, (with no guarantee of a NUL terminator).</li>
<li>A Unicode scalar value (Rust <code>char</code>).</li>
<li>Filesystem paths, or other operating-system strings.</li>
<li>Arrays, with a compile-time-known size.</li>
<li>Counted slices.</li>
<li>Ranges</li>
<li>Owned pointers to any supported type (e.g. <code>Box</code>), as well as owned pointers</li>
<li>References, with a limited degree of lifetime support.
<ul dir="auto">
<li><code>&amp;str</code></li>
</ul>
</li>
<li>Closures, with a limited degree of lifetime support.</li>
<li>Futures, with a limited degree of lifetime support. This would in particular</li>
<li>&#34;noreturn&#34; functions, as expressed in Rust via <code>-&gt; !</code>.</li>
<li>Opaque objects with interoperable-ABI methods, without exposing</li>
<li>Trait objects with interoperable-ABI methods. (This may use the same</li>
</ul>

<ul dir="auto">
<li>Niches: should we support cases like <code>Option&lt;bool&gt;</code> without a separate</li>
<li>What subset of lifetimes can, and should, we support? We can&#39;t enforce them</li>
<li>To what extent should the interoperable ABI make <em>any</em> attempt to specify</li>
<li>How can we make it easy to support data structures without having to do</li>
<li>Should we provide support for extensible enums, such that we don&#39;t assume the</li>
<li>For handling objects, could we avoid having to pass in-memory function</li>
<li>For ranges, should we provide a concrete range type or types, or should we</li>
<li>Do we get any value out of supporting <code>()</code>, other than completeness? Passing</li>
<li>Should we do anything special about <code>i128</code> and <code>u128</code>, or should we just push</li>
<li>For generics, such as <code>Option&lt;u64&gt;</code> or <code>Result&lt;u32, ConcreteError&gt;</code> or</li>
<li>Unwinding: The default interoperable-ABI should not support unwind, and most</li>
</ul>

<p dir="auto">Some potential sources of inspiration:</p>
<ul dir="auto">
<li>WebAssembly Interface Types</li>
<li>The <code>abi_stable</code> crate (which aims for Rust-to-Rust stability, not</li>
<li>Swift&#39;s stable ABI</li>
<li>C++&#39;s various ABIs (and the history of its ABI changes). The interoperable</li>
<li>Many, many interface description languages (IDLs).</li>
<li>The x86-64 psABI. While we&#39;re not specifying the lowering all the way to</li>
</ul>

<p dir="auto">Rather than being defined via lowering to the C ABI, the interoperable ABI could</p>
<p dir="auto">The interoperable ABI could exclude portions of the C ABI considered unsafe,</p>
<p dir="auto">The names <code>interop</code> and &#34;interoperable ABI&#34; are not particularly identifying,</p>
<p dir="auto">Given that the ABI does <em>not</em> exclude portions of the C ABI considered</p>

<ul dir="auto">
<li>Debug/trace tools, such as debugger support or <code>ltrace</code> support, to decode</li>
<li>Adding native support to various languages.</li>
<li>Shipping C header files defining structures for this ABI.</li>
</ul>
    </div>
  </task-lists>
  
</div>

      </div></div>
  </body>
</html>
