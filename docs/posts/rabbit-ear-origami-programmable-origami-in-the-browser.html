<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rabbitear.org/book/origami.html">Original</a>
    <h1>Rabbit Ear &#34;Origami&#34;: programmable origami in the browser</h1>
    
    <div id="readability-page-1" class="page">
  <nav>
    <div>
      <p><img alt="menu-dropdown" src="https://rabbitear.org/book/images/menu.svg"/>
      </p>
      
    </div>
  </nav>

<h3>
  Chapter IV.
</h3>



  

<p>
  Flat-foldable origami crease patterns are two-colorable.
</p>

<h2 id="graphs">
  Origami Objects
</h2>

<p>
  This class-style objects represent origami models. Underneath, each is a <a href="https://rabbitear.org/book/graph.html#fold-format">FOLD object</a>, bound with methods that do origami things. Each inherits from the &#34;parent&#34; class, <strong>graph</strong>.
</p>

  <pre><code><f>var</f> origami <key>=</key> ear.<f>graph</f>()</code></pre>

<p>
  This is the foundation for these objects, covered in detail in the <a href="https://rabbitear.org/book/graph.html">graph</a> chapter.
</p>

<h3>
  Origami
</h3>

<p>
  The <strong>origami</strong> object represents a foldable piece of paper. It will follow the same rules of folding that exist in our world.
</p>

  <pre><code><f>var</f> origami <key>=</key> ear.<f>origami</f>()</code></pre>

  

  <pre><code><f>var</f> origami <key>=</key> ear.<f>origami</f>()
origami.<f>flatFold</f>(<arg>line</arg>)</code></pre>

<p>
  All fold operations orient themselves using a similar rule:
</p>

<p>
  The fold direction is determined by the directionality of the line. For a flat-fold: &#34;fold all flaps to the counter-clockwise side from the line&#39;s vector.&#34; (this corresponds to the normal in the <a href="https://rabbitear.org/book/math.html#normal-parameterization">normal parameterization</a>)
</p>

  

  <pre><code>origami.<f>flatFold</f>(<arg>line</arg>)</code></pre>

<p>
  Currently, there is only one fold, the all-layers valley fold. In the future, more folds will be introduced here, like the reverse fold, squash, pedal.
</p>

<p>
  Be mindful of Y-axis direction for SVG renders. &#34;counter-clockwise&#34; is such in the mathematical, +Y upwards context. The sketch above has an upwards +Y.
</p>

<h3 id="crease-pattern">
  Crease Pattern
</h3>

  

<p>
  The <strong>crease pattern</strong> class foregoes imposing any rules of foldability and allows you to draw uninhibited on a flat canvas. It intends to be a replacement for commercial vector-based design software.
</p>

  <pre><code><f>var</f> origami <key>=</key> ear.<f>cp</f>()</code></pre>

<p>
  The graph maintains planarity, so a few things are taken care of for you:
</p>

<ul>
  <li>automatically split overlapping lines at any crossings (maintain a planar graph)</li>
  <li>convert curves into series of straight segments</li>
  <li>clip shapes within the bounds of the paper</li>
</ul>



  <pre><code><f>var</f> cp <key>=</key> ear.<f>cp</f>()</code></pre>

<p>
  The 3D visualization above is <a href="https://origamisimulator.org/">Origami Simulator</a>.
</p>

<p>
  Creasing is usually a two step process. Draw a shape, which returns a reference to a set of edges (if it was successful), then set the edges&#39; attributes, such as mountain/valley.
</p>

  <pre><code>cp.<f>segment</f>(<n>0</n>, <n>0</n>, <n>1</n>, <n>1</n>).<f>mountain</f>()</code></pre>

<p>
  These methods can also be chained.
</p>

<p>
  If you know all the points, you can draw a crease pattern with numbers.
</p>

  

<pre><code><f>var</f> cp <key>=</key> ear.<f>cp</f>()
<key>...</key>
cp.<f>segment</f>(<n>0.0</n>, <n>1.0</n>, <n>0.25</n>, <n>0.75</n>).<f>valley</f>();

<c>// center square</c>
cp.<f>rect</f>(<n>0.25</n>, <n>0.25</n>, <n>0.5</n>, <n>0.5</n>).<f>valley</f>();

<c>// edge diagonals</c>
cp.<f>segment</f>(<n>0.5</n>, <n>0.0</n>, <n>0.75</n>, <n>0.25</n>).<f>mountain</f>();
cp.<f>segment</f>(<n>1.0</n>, <n>0.5</n>, <n>0.75</n>, <n>0.75</n>).<f>mountain</f>();
<key>...</key></code></pre>

<p>
  Traditionally, a crease is not located using numbers, it&#39;s uncovered by folding, using the rules of origami.
</p>

<h2 id="axioms">
  Axioms
</h2>

  <pre><code>ear.<f>axiom</f>(<arg>number</arg>, <arg>params</arg>, <arg>boundary</arg>)</code></pre>

<p>
  <strong>boundary</strong> is an optional parameter
</p>

<p>
  The seven origami axioms are the different ways to make a crease <em>exactly</em> in place.
</p>

<p>
  The purpose of the <strong>axiom</strong> method is to get back a line (or 2 or 3). Once you get this line, it can then be used as the input for a fold operation.
</p>

<p id="axiom-math-description">
  fold two points together
</p>

  

<p><span>Axiom #</span>
  
  
  
  
  
  
  
</p>

  <pre><code>ear.<f>axiom</f>(<n id="axiom-math-number">2</n>, <span id="origami-axioms-params">params</span>)</code></pre>

<p>
  Each axiom takes a certain combination of <strong>points</strong> and <strong>lines</strong>; place them inside arrays, under their respective keys.
</p>

  <pre><code>ear.<f>axiom</f>(<n>2</n>, { <str>points</str>: [<key>...</key>], <str>lines</str>: [<key>...</key>] })</code></pre>

<div>
  <div>
    <p>Input</p>
    <ul>
      <li><strong>axiom 1</strong>: 2 points</li>
      <li><strong>axiom 2</strong>: 2 points</li>
      <li><strong>axiom 3</strong>: 2 lines</li>
      <li><strong>axiom 4</strong>: 1 point, 1 line</li>
      <li><strong>axiom 5</strong>: 2 points, 1 line</li>
      <li><strong>axiom 6</strong>: 2 points, 2 lines</li>
      <li><strong>axiom 7</strong>: 1 point, 2 lines</li>
    </ul>
  </div>
  <div>
    <p>Output, given correct inputs</p>
    <ul>
      <li><strong>axiom 1</strong>: 1 line</li>
      <li><strong>axiom 2</strong>: 1 line</li>
      <li><strong>axiom 3</strong>: 1 or 2 lines</li>
      <li><strong>axiom 4</strong>: 1 line</li>
      <li><strong>axiom 5</strong>: 1 or 2 lines</li>
      <li><strong>axiom 6</strong>: 1 or 2 or 3 lines</li>
      <li><strong>axiom 7</strong>: 1 line</li>
    </ul>
  </div>
</div>

<p>
  Points can be either arrays of numbers, or x,y objects. Lines are either parameterized with a <strong>vector</strong> and <strong>origin</strong>, or in <a href="https://rabbitear.org/book/math.html#u-d-parameterization"><strong>u-d form</strong></a>.
</p>

  <pre><code>{
  <str>points</str>: [
    [<n>0.8</n>, <n>0.75</n>],
    { x: <n>0.5</n>, y: <n>0.22</n> }
  ],
  <str>lines</str>: [
    { <str>vector</str>: [<n>0.75</n>, <n>0.25</n>], <str>origin</str>: [<n>0.5</n>, <n>0.5</n>] }
  ],
}</code></pre>

<p>
  Or use Rabbit Ear&#39;s <strong>vector</strong> and <strong>line</strong> types.
</p>

<p>
  Some axioms have multiple solutions; therefore, the return value for every axiom method is an <strong>array of lines</strong>.
</p>

<h3 id="axioms-boundary">
  Axioms within a boundary
</h3>

<p>
  In reality, an axiom is constructed on a sheet of paper, and should only be constructible if all necessary geometry lies on the paper.
</p>

  <pre><code>ear.<f>axiom</f>(<arg>number</arg>, <arg>params</arg>, <arg>boundary</arg>)</code></pre>

<p>
  <strong>boundary</strong> can be either a polygon or a FOLD graph.
</p>

<p>
  Provide a third argument for the boundary and non-constructible solutions will be filtered out.
</p>

<p id="axiom-fold-description">
  fold two points together
</p>

  

<p><span>Axiom #</span>
  
  
  
  
  
  
  
</p>

<p>
  Try moving the points and lines outside the boundary of the paper.
</p>

<p>
  Axioms can fail in two ways: they can fail due to input parameters being outside the boundary, or they can be non-constructible simply due to their input parameters. Not all can fail the latter, but Axiom 5 can be a good example of it.
</p>

  

<p>
  origami axiom 5
</p>

<h2 id="single-vertex">
  Single Vertex
</h2>

<p>
  A single-vertex refers to one vertex with its N-number of edges and faces around it. Complex problems on crease patterns can be tackled piecewise by focusing on single-vertices.
</p>

  <pre><code>ear.<f>vertex</f></code></pre>

  

  

  <pre><code>ear.vertex.<f>foldAngles4</f>(<arg>sectors</arg>, <arg>assignments</arg>)</code></pre>

<p>
  The continuous folding motion in 3D for a degree-four single vertex.
</p>

<h3 id="kawasaki">
  Kawasaki&#39;s Theorem
</h3>

  

  

  <pre><code>ear.vertex.<f>alternatingSum</f>(<arg>array</arg>)</code></pre>

<p>
  For a vertex to be flat-foldable, the sum of alternating sector angles must be 180Â°. This implies an <em>even number of creases</em>.
</p>

<p>
  Given an odd number of creases, we can ask the computer to find creases that can satisfy a solution.
</p>

<p>
  Only one result is required to be added to the set of input creases, and Kawasaki&#39;s theorem will be satisfied.
</p>

  

  

  

  

  <pre><code>ear.vertex.<f>kawasakiSolutions</f>(<arg>vectors</arg>)</code></pre>

<p>
  This set of results has a cool property: any number of them, whether it be one or many, can be added to the single vertex and the result will be valid according to Kawasaki&#39;s theorem.
</p>

  

<p>
  These methods require <a href="https://rabbitear.org/book/math.html#sorting">sorted</a> vectors/radians as an input. Use these methods below:
</p>

  <pre><code>ear.math.<f>counterClockwiseOrder2</f>(vectors)
  .map(<arg>i</arg> <f>=&gt;</f> vectors[i])</code></pre>

  <pre><code>ear.math.<f>counterClockwiseOrderRadians</f>(angles)
  .map(<arg>i</arg> <f>=&gt;</f> angles[i])</code></pre>

<p>
  Sort radially 2D vectors or vectors as radians.
</p>

<p>
  Given a crease pattern template like this origami twist, if we maintain the graph structure, we can use Kawasaki alone to create variation in form.
</p>

  

  <pre><code><f>var</f> valleys <key>=</key> ear.vertex.<f>kawasakiSolutions</f>(<arg>mountains</arg>)</code></pre>

<p>
  In the example above, Kawasaki&#39;s theorem is used to solve the angle of the valley fold (dashed) lines.
</p>

<h3 id="maekawa">
  Maekawa&#39;s theorem
</h3>

  

<p>
  For a vertex to be flat-foldable, the number of mountain and valley creases should differ by 2.
</p>

<p>
  This method will replace all unassigned creases &#34;U&#34; with mountain or valley, returning all permutations that satisfy Maekawa&#39;s Theorem.
</p>

  <pre><code>ear.vertex.<f>maekawaAssignments</f>([<str>&#34;M&#34;</str>, <str>&#34;U&#34;</str>, <str>&#34;U&#34;</str>, <str>&#34;U&#34;</str>])</code></pre>

  <pre><code>[
  [<str>&#34;M&#34;</str>, <str>&#34;V&#34;</str>, <str>&#34;V&#34;</str>, <str>&#34;V&#34;</str>],
  [<str>&#34;M&#34;</str>, <str>&#34;V&#34;</str>, <str>&#34;M&#34;</str>, <str>&#34;M&#34;</str>],
  [<str>&#34;M&#34;</str>, <str>&#34;M&#34;</str>, <str>&#34;V&#34;</str>, <str>&#34;M&#34;</str>],
  [<str>&#34;M&#34;</str>, <str>&#34;M&#34;</str>, <str>&#34;M&#34;</str>, <str>&#34;V&#34;</str>],
]</code></pre>

<p>
  This method is pretty simple on its own, but will become more powerful when paired with layer-order solvers.
</p>

<h3>
  Validators
</h3>

<p>
  Both Kawasaki and Maekawa can be quickly validated on all vertices of a crease pattern using these methods.
</p>

  <pre><code>ear.vertex.<f>validateKawasaki</f>(<arg>graph</arg>, <arg>epsilon</arg>)</code></pre>

  <pre><code>ear.vertex.<f>validateMaekawa</f>(<arg>graph</arg>)</code></pre>

<p>
  These methods return an array of invalid vertex indices.
</p>

<h2 id="folding-a-cp">
  Folding a Crease Pattern
</h2>

<p>
  By using a minimum spanning tree, an origami can be &#34;folded&#34; by reflecting each face across the adjacent edge along each path. Adjacent faces will naturally fall back into place next to their neighbors.
</p>

  

  <pre><code>origami.<f>folded</f>(<n>4</n>)</code></pre>

  <pre><code>origami.<f>flatFolded</f>(<n>4</n>)</code></pre>

<p>
  <strong>folded</strong> works in both 2D or 3D. <strong>flatFolded</strong> is for 2D origami only, and is slightly more precise.
</p>

<p>
  The result of these methods does not offer the renderer any direction about which face to draw first, resulting in the rendering on the right.
</p>

  

<p>
  Before solving the layer order
</p>

<p>
  A layer order provides the renderer with the correct z-ordering for the faces.
</p>

<h2>
  Layer Order
</h2>

  <pre><code>ear.<f>layer</f></code></pre>

<h3>
  Single Vertex Layer Order
</h3>

<p>
  If layer solvers are new to you, a gentle introduction might be a single-vertex.
</p>

<p>
  Imagine a side-view of a strip of paper containing 180-degree crease lines: <span>mountain</span>, <span>valley</span>, or flat.
</p>

  

  <pre><code><f>var</f> lengths <key>=</key> [<span id="span-layer-strip-solver-lengths"></span>]</code></pre>

<p>
  This visualization rounds the corners in a manner that can sometimes appear like a layer intersection. This is only a visualization error.
</p>

<p>
  The <strong>singleVertexSolver</strong> requires a list of scalars and a list of crease assignments. If multiple solutions exist it will find them all.
</p>

  

<p>
  The solver will reject any solutions which self-intersect.
</p>

<p>
  As far as the solver is concerned, a linear strip is the same thing as a single-vertex. The list of scalars is the <strong>sector angles</strong>.
</p>

  

<p>
  Toggle mountain and valley creases. Can you find other valid combinations?
</p>

<p>
  Of course, the main difference is that the strip loops back around. But all that this requires is the absence (or presence) of &#34;B&#34; boundary assignments.
</p>

  <pre><code>ear.layer.<f>singleVertexSolver</f>(<arg>sectors_angle</arg>, <arg>assignments</arg>)</code></pre>

<p>
  The result is an array of <strong>faces_layers</strong>.
</p>

<p>
  The following method will solve <em>both the layers and the assignments</em>, and return an array of all possible solutions.
</p>

  

<p>
  press to toggle through solutions
</p>

  <pre><code>ear.layer.<f>assignmentSolver</f>(<arg>sectors_angle</arg>)</code></pre>

<p>
  This method will work even if a partial set of assignments is known; simply mix &#34;U&#34; (unassigned) in the assignment array wherever necessary.
</p>

  <pre><code>ear.layer.<f>assignmentSolver</f>(<arg>sectors_angle</arg>, <arg>assignments</arg>)</code></pre>

<p>
  The assignment solver will only try to replace unassigned with valleys and mountains, not flats.
</p>

<p>
  Dynamically calculating Kawasaki&#39;s theorem, in action.
</p>

  

  <pre><code><f>var</f> bottom_left <key>=</key> ear.vertex.<f>kawasakiSolutions</f>(<arg>three_vectors</arg>)</code></pre>

  <pre><code><f>var</f> solution <key>=</key> ear.layer.<f>assignmentSolver</f>(<arg>sectors_angle</arg>)</code></pre>

<p>
  The above sketch demonstrates Kawasaki&#39;s theorem. The layer-order can be solved by calculating the sector angles and handing it off to the assignment solver which solves both layers and assignments. Or, we can instead use the much easier, and much more powerful global solver.
</p>

<h3>
  Global Layer Order
</h3>

  

<p>
  The traditional Kabuto Samurai Helmet and its 9 valid layer arrangements.
</p>

  <pre><code>ear.layer.<f>solver</f>(<arg>graph</arg>)</code></pre>

<p>
  This method takes a <a href="#folding-a-cp">folded origami</a>, not a crease pattern.
</p>

<p>
  Solving a crease pattern&#39;s global layer order is hard. There are many approaches. This library implements an algorithm designed by <a href="https://erikdemaine.org/theses/jku.pdf">Jason Ku</a> which works well for SVG renderings.
</p>

<p>
  The first step is, for every face, gather all other faces which overlap this face.
</p>

  

<p>
  Face-face overlap matrix
</p>

<p>
  Every overlapping pair of faces is a variable that needs to be solved. <em>Not all possible pairs of faces needs to be solved.</em>
</p>

<p>
  <strong>Yellow</strong> is an unsolved condition. The algorithm goes as such:
</p>

<ul>
  <li>(a): orders between neighboring faces is known from the edge assignment. populate these.</li>
  <li>(b): discover any implications from the current set, repeat as much as possible. an origami with only one solution will finish after this step.</li>
  <li>(c): recursively guess and check until all possible solutions are found. this will generate branches (multiple solutions).</li>
</ul>

<p>
  Faces <strong>above</strong> and <strong>below</strong> the selected face.
</p>

  

<p>
  (a) solved neighbor faces, (b) solved all non-toggleable flaps, (c) one of the nine solutions.
</p>

<p>
  Some crease patterns finish after (b). The Kabuto is an origami model with multiple layer flap arrangements, requiring recusively branching and guessing and checking (c).
</p>

<!-- <p class="explain">
  Steps (a) and (b) finish in milliseconds. Step (c) is variable, anytime between milliseconds and hours.
</p>

<p>
  Because of step (c) runtime we have another method: one that solves <strong>only one solution</strong> even if there are many.
</p> -->

  <!-- <div id="canvas-layer-kraft-bird-base"></div> -->

<!-- 
<p>
  If we know that a bilaterally-symmetrical origami's faces stay on their side, we can set a symmetry line that will not be crossed.
</p>

  <pre class="code"><code>ear.layer.<f>one_layer_conditions_with_axis</f>(<arg>folded</arg>, <arg>cp</arg>, <arg>line</arg>)<br>ear.layer.<f>all_layer_conditions_with_axis</f>(<arg>folded</arg>, <arg>cp</arg>, <arg>line</arg>)</code></pre>
 -->
<h3>
  Layer Solutions
</h3>

<p>
  The solution to a layer order contains both the certain relationships and all of its branches. To compile a solution you must choose one from each branch. To do this, you will need to know the number of branches, and how many options are available on each branch:
</p>

  <pre><code>ear.layer.<f>solver</f>(<arg>graph</arg>).<f>count</f>()</code></pre>

<p>
  This origami (Kabuto) has two branches, each with three options.
</p>

<p>
  Generally, the workflow might be (1) solve the layer order, (2) check the branch count, (3) choose branches.
</p>

  <pre><code><f>var</f> result <key>=</key> ear.layer.<f>solver</f>(<arg>graph</arg>) <c>// 1</c></code></pre>

<p>
  An empty parenthesis will simply choose the first from each branch.
</p>

  <pre><code>ear.layer.<f>solver</f>(<arg>graph</arg>).<f>facesOrder</f>(<n>0</n>, <n>0</n>)</code></pre>

<p>
  Empty parenthesis is, <strong>I don&#39;t care which result, just give me one.</strong>
</p>

<p>
  And finally, the solution can be compiled into one of a few forms, a <strong>faceOrders</strong>, a <strong>faces_layer</strong>, or either of these but with an array of all permutations of branch choices.
</p>

  <pre><code>ear.layer.<f>solver</f>(<arg>graph</arg>).<f>faceOrders</f>()</code></pre>

  

<h3>
  Cycles
</h3>

<p>
  The SVG renderer keeps faces intact and assigns one layer per face, making three or more cyclically-overlapping faces impossible to render; <em>unless,</em> the faces are divided with flat crease lines.
</p>

  

<p>
  This relies on a crease pattern already having this exact placement of these flat creases. An algorithm which takes care of this would be nice to develop.
</p>

<!-- 
<h3>
  faces_layer and layers_face
</h3>

<p>
  There are two ways of expressing a layer order, <strong>faces_layer</strong> and <strong>layers_face</strong>. They express the same concept, and look very similar.
</p>

  <pre class="code"><code>[<n>4</n>, <n>0</n>, <n>2</n>, <n>7</n>, <n>6</n>, <n>1</n>, <n>5</n>, <n>3</n>]</code></pre>

  <pre class="code"><code>[<n>1</n>, <n>5</n>, <n>2</n>, <n>7</n>, <n>0</n>, <n>6</n>, <n>4</n>, <n>3</n>]</code></pre>

<p class="quote">
  a faces_layer and a layers_face
</p>

<p>
  A <strong>faces_layer</strong> maps faces (indices) to a layer (value). The <strong>layers_face</strong> is the inverse, the indices are the layer and the values are the face indices.
</p>

  <pre class="code"><code><f>var</f> layers_face <key>=</key> ear.graph.<f>invert_map</f>(faces_layer)</code></pre>

<p>
  Use <a href="graph.html#invert">invert map</a> to convert back and forth between the two.
</p>
 -->

  

<!-- 
<h2>
  Diagramming
</h2>

<p>
  Origami diagrams date back to as early as the artform itself. Akira Yoshizawa and Samuel Randlett established a system of notation that is now standard, and available in this library.
</p>

<p>
  Without any information other than the fold line, a <strong>simple arrow</strong> at least indicates the direction of motion.
</p>

  <div id="canvas-diagram-simple-arrow"></div>

  <pre class="code"><code>ear.diagram.<f>simple_arrow</f>(<arg>graph</arg>, <arg>foldLine</arg>)</code></pre>

<p>
  A good arrow should not only indicate the direction of motion, but also describe to the folder which landmarks should be aligned.
</p>

<p>
  It's easy to code arrows for the seven origami axioms. If you can express your fold as one of the axioms you can get an arrow for free.
</p>

<p>
  Arrows are the heart of a diagram, and our arrow objects are customizable, though certainly not enough.
</p>

  <div id="canvas-diagram-arrow-style"></div>

<h2>
  To be continued
</h2>

<p>
  The library is in progress. Follow the <a href="https://github.com/robbykraft/Origami">Github</a> for the latest developments.
</p>
 -->



<!-- <script type="text/javascript" src="https://robbykraft.github.io/OrigamiSimulator/origami-simulator.min.js"></script> -->

<!-- <script type="text/javascript" src="https://threejs.org/build/three.js"></script> -->
<!-- <script type="text/javascript" src="./js/origami-sim/three.min.js"></script> -->




















<!-- START OF FOOTER -->
<!-- START OF FOOTER -->
<!-- START OF FOOTER -->





</div>
  </body>
</html>
