<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signal.org/docs/specifications/pqxdh/">Original</a>
    <h1>Signal: The Pqxdh Key Agreement Protocol</h1>
    
    <div id="readability-page-1" class="page"><div><div> <p><img src="https://signal.org/assets/body/spaceship-e722e5c700acd0e0ac8b003fb8269174a00e6190021f47ea233bb4713189818e.png"/></p><h3><p>Revision 1, 2023-05-24 [<a href="https://signal.org/docs/specifications/pqxdh/pqxdh.pdf">PDF</a>]</p><p>Ehren Kret, Rolfe Schmidt</p></h3></div></div><div><div><p>This document describes the “PQXDH” (or “Post-Quantum Extended Diffie-Hellman”) key agreement protocol. PQXDH establishes a shared secret key between two parties who mutually authenticate each other based on public keys. PQXDH provides post-quantum forward secrecy and a form of cryptographic deniability but still relies on the hardness of the discrete log problem for mutual authentication in this revision of the protocol.</p><p>PQXDH is designed for asynchronous settings where one user (“Bob”) is offline but has published some information to a server. Another user (“Alice”) wants to use that information to send encrypted data to Bob, and also establish a shared secret key for future communication.</p><h2 id="pqxdh-parameters">2.1. PQXDH parameters</h2><p>An application using PQXDH must decide on several parameters:</p><table><colgroup><col/><col/></colgroup><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td><em>curve</em></td><td>A Montgomery curve for which XEdDSA <span data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span> is specified, at present this is one of curve25519 or curve448</td></tr><tr><td><em>hash</em></td><td>A 256 or 512-bit hash function (e.g. SHA-256 or SHA-512)</td></tr><tr><td><em>info</em></td><td>An ASCII string identifying the application with a minimum length of 8 bytes</td></tr><tr><td><em>pqkem</em></td><td>A post-quantum key encapsulation mechanism (e.g. Crystals-Kyber-1024 <span data-cites="kyberfips203"><a href="#ref-kyberfips203" role="doc-biblioref">[2]</a></span>)</td></tr><tr><td><em>EncodeEC</em></td><td>A function that encodes a <em>curve</em> public key into a byte sequence</td></tr><tr><td><em>DecodeEC</em></td><td>A function that decodes a byte sequence into a <em>curve</em> public key and is the inverse of <em>EncodeEC</em></td></tr><tr><td><em>EncodeKEM</em></td><td>A function that encodes a <em>pqkem</em> public key into a byte sequence</td></tr><tr><td><em>DecodeKEM</em></td><td>A function that decodes a byte sequence into a <em>pqkem</em> public key and is the inverse of <em>EncodeKEM</em></td></tr></tbody></table><p>For example, an application could choose <em>curve</em> as curve25519, <em>hash</em> as SHA-512, <em>info</em> as “MyProtocol”, and <em>pqkem</em> as CRYSTALS-KYBER-1024.</p><p>The recommended implementation of <em>EncodeEC</em> consists of a single-byte constant representation of <em>curve</em> followed by little-endian encoding of the u-coordinate as specified in <span data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>. The single-byte representation of <em>curve</em> is defined by the implementer. Similarly the recommended implementation of <em>DecodeEC</em> reads the first byte to determine the parameter <em>curve</em>. If the first byte does not represent a recognized curve, the function fails. Otherwise it applies the little-endian decoding of the u-coordinate for <em>curve</em> as specified in <span data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>.</p><p>The recommended implementation of <em>EncodeKEM</em> consists of a single-byte constant representation of <em>pqkem</em> followed by the encoding of <strong><em>PQKPK</em></strong> specified by <em>pqkem</em>. The single-byte representation of <em>pqkem</em> is defined by the implementer. Similarly the recommended implementation of <em>DecodeKEM</em> reads the first byte to determine the parameter <em>pqkem</em>. If the first byte does not represent a recognized key encapsulation mechanism, the function fails. Otherwise it applies the decoding specified by the selected key encapsulation mechanism.</p><h2 id="cryptographic-notation">2.2. Cryptographic notation</h2><p>Throughout this document, all public keys have a corresponding private key, but to simplify descriptions we will identify key pairs by the public key and assume that the corresponding private key can be accessed by the key owner.</p><p>This document will use the following notation:</p><ul><li><p>The concatenation of byte sequences <strong><em>X</em></strong> and <strong><em>Y</em></strong> is <strong><em>X</em></strong> || <strong><em>Y</em></strong>.</p></li><li><p><strong><em>DH(PK1, PK2)</em></strong> represents a byte sequence which is the shared secret output from an Elliptic Curve Diffie-Hellman function involving the key pairs represented by public keys <em>PK1</em> and <em>PK2</em>. The Elliptic Curve Diffie-Hellman function will be either the X25519 or X448 function from <span data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>, depending on the <em>curve</em> parameter.</p></li><li><p><strong><em>Sig(PK, M, Z)</em></strong> represents the byte sequence that is a <em>curve</em> XEdDSA signature on the byte sequence <em>M</em> which was created by signing <em>M</em> with <em>PK</em>’s corresponding private key and using 64 bytes of randomness <em>Z</em>. This signature verifies with public key <em>PK</em>. The signing and verification functions for XEdDSA are specified in <span data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span>.</p></li><li><p><strong><em>KDF(KM)</em></strong> represents 32 bytes of output from the HKDF algorithm <span data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[4]</a></span> using <em>hash</em> with inputs:</p><ul><li><em>HKDF input key material</em> = <em>F</em> || <em>KM</em>, where <em>KM</em> is an input byte sequence containing secret key material, and <em>F</em> is a byte sequence containing 32 0xFF bytes if <em>curve</em> is curve25519, and 57 0xFF bytes if <em>curve</em> is curve448. As in in XEdDSA <span data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span>, <em>F</em> ensures that the first bits of the HKDF input key material are never a valid encoding of a scalar or elliptic curve point.</li><li><em>HKDF salt</em> = A zero-filled byte sequence with length equal to the <em>hash</em> output length, in bytes.</li><li><em>HKDF info</em> = The concatenation of string representations of the 4 PQXDH parameters <em>info</em>, <em>curve</em>, <em>hash</em>, and <em>pqkem</em> into a single string separated with ‘<code>_</code>’ such as “<code>MyProtocol_CURVE25519_SHA-512_CRYSTALS-KYBER-1024</code>”. The string representations of the PQXDH parameters are defined by the implementer.</li></ul></li><li><p><strong><em>(CT, SS) = PQKEM-ENC(PK)</em></strong> represents a tuple of the byte sequence that is the KEM ciphertext, <em>CT</em>, output by the algorithm <em>pqkem</em> together with the shared secret byte sequence <em>SS</em> encapsulated by the ciphertext using the public key <em>PK</em>.</p></li><li><p><strong><em>PQKEM-DEC(PK, CT)</em></strong> represents the shared secret byte sequence <em>SS</em> decapsulated from a <em>pqkem</em> ciphertext using the private key counterpart of the public key <em>PK</em> used to encapsulate the ciphertext CT.</p></li></ul><h2 id="roles">2.3. Roles</h2><p>The PQXDH protocol involves three parties: <strong>Alice</strong>, <strong>Bob</strong>, and a <strong>server</strong>.</p><ul><li><p><strong>Alice</strong> wants to send <strong>Bob</strong> some initial data using encryption, and also establish a shared secret key which may be used for bidirectional communication.</p></li><li><p><strong>Bob</strong> wants to allow parties like <strong>Alice</strong> to establish a shared key with him and send encrypted data. However, <strong>Bob</strong> might be offline when <strong>Alice</strong> attempts to do this. To enable this, <strong>Bob</strong> has a relationship with some <strong>server</strong>.</p></li><li><p>The <strong>server</strong> can store messages from <strong>Alice</strong> to <strong>Bob</strong> which <strong>Bob</strong> can later retrieve. The <strong>server</strong> also lets <strong>Bob</strong> publish some data which the server will provide to parties like <strong>Alice</strong>. The amount of trust placed in the server is discussed in <a href="#server-trust">Section 4.9</a>.</p></li></ul><p>In some systems the <strong>server</strong> role might be divided between multiple entities, but for simplicity we assume a single server that provides the above functions for <strong>Alice</strong> and <strong>Bob</strong>.</p><h2 id="elliptic-curve-keys">2.4. Elliptic Curve Keys</h2><p>PQXDH uses the following elliptic curve public keys:</p><table><colgroup><col/><col/></colgroup><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td><em>IK<sub>A</sub></em></td><td>Alice’s identity key</td></tr><tr><td><em>IK<sub>B</sub></em></td><td>Bob’s identity key</td></tr><tr><td><em>EK<sub>A</sub></em></td><td>Alice’s ephemeral key</td></tr><tr><td><em>SPK<sub>B</sub></em></td><td>Bob’s signed prekey</td></tr><tr><td>(<em>OPK<sub>B</sub><sup>1</sup></em>, <em>OPK<sub>B</sub><sup>2</sup></em>, …)</td><td>Bob’s set of one-time prekeys</td></tr></tbody></table><p>The elliptic curve public keys used within a PQXDH protocol run must either all be in curve25519 form, or they must all be in curve448 form, depending on the <em>curve</em> parameter <span data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>.</p><p>Each party has a long-term identity elliptic curve public key (<em>IK<sub>A</sub></em> for Alice, <em>IK<sub>B</sub></em> for Bob).</p><p>Bob also has a signed prekey <em>SPK<sub>B</sub></em>, which he changes periodically and signs each time with <em>IK<sub>B</sub></em>, and a set of one-time prekeys (<em>OPK<sub>B</sub><sup>1</sup></em>, <em>OPK<sub>B</sub><sup>2</sup></em>, …), which are each used in a single PQXDH protocol run. (“Prekeys” are so named because they are essentially protocol messages which Bob publishes to the server prior to Alice beginning the protocol run.) These keys will be uploaded to the <strong>server</strong> as described in <a href="#publishing-keys">Section 3.2</a>.</p><p>During each protocol run, Alice generates a new ephemeral key pair with public key <em>EK<sub>A</sub></em>.</p><h2 id="post-quantum-key-encapsulation-keys">2.5. Post-Quantum Key Encapsulation Keys</h2><p>PQXDH uses the following post-quantum key encapsulation public keys:</p><table><colgroup><col/><col/></colgroup><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td><em>PQSPK<sub>B</sub></em></td><td>Bob’s signed last-resort <em>pqkem</em> prekey</td></tr><tr><td>(<em>PQOPK<sub>B</sub><sup>1</sup></em>, <em>PQOPK<sub>B</sub><sup>2</sup></em>, …)</td><td>Bob’s set of signed one-time <em>pqkem</em> prekeys</td></tr></tbody></table><p>The <em>pqkem</em> public keys used within a PQXDH protocol run must all use the same <em>pqkem</em> parameter.</p><p>Bob has a signed last-resort post-quantum prekey <em>PQSPK<sub>B</sub></em>, which he changes periodically and signs each time with <em>IK<sub>B</sub></em>, and a set of signed one-time prekeys (<em>PQOPK<sub>B</sub><sup>1</sup></em>, <em>PQOPK<sub>B</sub><sup>2</sup></em>, …) which are also signed with <em>IK<sub>B</sub></em> and each used in a single PQXDH protocol run. These keys will be uploaded to the <strong>server</strong> as described in <a href="#publishing-keys">Section 3.2</a>. The name “last-resort” refers to the fact that the last-resort prekey is only used when one-time <em>pqkem</em> prekeys are not available. This can happen when the number of prekey bundles downloaded for Bob exceeds the number of one-time <em>pqkem</em> prekeys Bob has uploaded (see <a href="#the-pqxdh-protocol">Section 3</a> for details about the role of the server).</p><h2 id="overview">3.1. Overview</h2><p>PQXDH has three phases:</p><ol type="1"><li><p>Bob publishes his elliptic curve identity key, elliptic curve prekeys, and <em>pqkem</em> prekeys to a server.</p></li><li><p>Alice fetches a “prekey bundle” from the server, and uses it to send an initial message to Bob.</p></li><li><p>Bob receives and processes Alice’s initial message.</p></li></ol><p>The following sections explain these phases.</p><h2 id="publishing-keys">3.2. Publishing keys</h2><p>Bob generates a sequence of 64-byte random values <em>Z<sub>SPK</sub>, Z<sub>PQSPK</sub>, Z<sub>1</sub>, Z<sub>2</sub>, …</em> and publishes a set of keys to the server containing:</p><ul><li>Bob’s <em>curve</em> identity key <em>IK<sub>B</sub></em></li><li>Bob’s signed <em>curve</em> prekey <em>SPK<sub>B</sub></em></li><li>Bob’s signature on the <em>curve</em> prekey <em>Sig(IK<sub>B</sub>, EncodeEC(SPK<sub>B</sub>), Z<sub>SPK</sub>)</em></li><li>Bob’s signed last-resort <em>pqkem</em> prekey <em>PQSPK<sub>B</sub></em></li><li>Bob’s signature on the <em>pqkem</em> prekey <em>Sig(IK<sub>B</sub>, EncodeKEM(PQSPK<sub>B</sub>), Z<sub>PQSPK</sub>)</em></li><li>A set of Bob’s one-time <em>curve</em> prekeys <em>(OPK<sub>B</sub><sup>1</sup>, OPK<sub>B</sub><sup>2</sup>, OPK<sub>B</sub><sup>3</sup>, …)</em></li><li>A set of Bob’s signed one-time <em>pqkem</em> prekeys <em>(PQOPK<sub>B</sub><sup>1</sup>, PQOPK<sub>B</sub><sup>2</sup>, PQOPK<sub>B</sub><sup>3</sup>, …)</em></li><li>The set of Bob’s signatures on the signed one-time <em>pqkem</em> prekeys <em>(Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>1</sup>), Z<sub>1</sub>), Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>2</sup>), Z<sub>2</sub>), Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>3</sup>), Z<sub>3</sub>), …)</em></li></ul><p>Bob only needs to upload his identity key to the server once. However, Bob may upload new one-time prekeys at other times (e.g. when the server informs Bob that the server’s store of one-time prekeys is getting low).</p><p>For both the signed <em>curve</em> prekey and the signed last-resort <em>pqkem</em> prekey, Bob will upload a new prekey along with its signature using <em>IK<sub>B</sub></em> at some interval (e.g. once a week or once a month). The new signed prekey and its signatures will replace the previous values.</p><p>After uploading a new pair of signed <em>curve</em> and signed last-resort <em>pqkem</em> prekeys, Bob may keep the private key corresponding to the previous pair around for some period of time to handle messages using it that may have been delayed in transit. Eventually, Bob should delete this private key for forward secrecy (one-time prekey private keys will be deleted as Bob receives messages using them; see <a href="#receiving-the-initial-message">Section 3.4</a>).</p><h2 id="sending-the-initial-message">3.3. Sending the initial message</h2><p>To perform a PQXDH key agreement with Bob, Alice contacts the server and fetches a “prekey bundle” containing the following values:</p><ul><li>Bob’s <em>curve</em> identity key <em>IK<sub>B</sub></em></li><li>Bob’s signed <em>curve</em> prekey <em>SPK<sub>B</sub></em></li><li>Bob’s signature on the <em>curve</em> prekey <em>Sig(IK<sub>B</sub>, EncodeEC(SPK<sub>B</sub>), Z<sub>SPK</sub>)</em></li><li>One of either Bob’s signed one-time <em>pqkem</em> prekey <em>PQOPK<sub>B</sub><sup>n</sup></em> or Bob’s last-resort signed <em>pqkem</em> prekey <em>PQSPK<sub>B</sub></em> if no signed one-time <em>pqkem</em> prekey remains. Call this key <em>PQPK<sub>B</sub></em>.</li><li>Bob’s signature on the <em>pqkem</em> prekey <em>Sig(IK<sub>B</sub>, EncodeKEM(PQPK<sub>B</sub>), Z<sub>PQPK</sub>)</em></li><li>(Optionally) Bob’s one-time <em>curve</em> prekey <em>OPK<sub>B</sub><sup>n</sup></em></li></ul><p>The server should provide one of Bob’s <em>curve</em> one-time prekeys if one exists and then delete it. If all of Bob’s <em>curve</em> one-time prekeys on the server have been deleted, the bundle will not contain a one-time <em>curve</em> prekey element.</p><p>The server should prefer to provide one of Bob’s <em>pqkem</em> one-time signed prekeys <em>PQOPK<sub>B</sub><sup>n</sup></em> if one exists and then delete it. If all of Bob’s <em>pqkem</em> one-time signed prekeys on the server have been deleted, the bundle will instead contain Bob’s <em>pqkem</em> last-resort signed prekey <em>PQSPK<sub>B</sub></em>.</p><p>Alice verifies the signatures on the prekeys. If any signature check fails, Alice aborts the protocol. Otherwise, if all signature checks pass, Alice then generates an ephemeral <em>curve</em> key pair with public key EK<sub>A</sub>. Alice additionally generates a <em>pqkem</em> encapsulated shared secret:</p><div><p>    (CT, SS) = PQKEM-ENC(PQPK<sub>B</sub>)</p></div><p>If the bundle does not contain a <em>curve</em> one-time prekey, she calculates:</p><p>If the bundle does contain a <em>curve</em> one-time prekey, the calculation is modified to include an additional <em>DH</em>:</p><p>After calculating <em>SK</em>, Alice deletes her ephemeral private key, the <em>DH</em> outputs, the shared secret <em>SS</em>, and the ciphertext <em>CT</em>.</p><p>Alice then calculates an “associated data” byte sequence <em>AD</em> that contains identity information for both parties:</p><p>    AD = EncodeEC(IK<sub>A</sub>) || EncodeEC(IK<sub>B</sub>)</p><p>Alice may optionally append additional information to <em>AD</em>, such as Alice and Bob’s usernames, certificates, or other identifying information.</p><p>Alice then sends Bob an initial message containing:</p><ul><li>Alice’s identity key <em>IK<sub>A</sub></em></li><li>Alice’s ephemeral key <em>EK<sub>A</sub></em></li><li>The <em>pqkem</em> ciphertext <em>CT</em> encapsulating <em>SS</em> for <em>PQPK<sub>B</sub></em></li><li>Identifiers stating which of Bob’s prekeys Alice used</li><li>An initial ciphertext encrypted with some AEAD encryption scheme <span data-cites="aead"><a href="#ref-aead" role="doc-biblioref">[5]</a></span> using <em>AD</em> as associated data and using an encryption key which is either <em>SK</em> or the output from some cryptographic PRF keyed by <em>SK</em>.</li></ul><p>The initial ciphertext is typically the first message in some post-PQXDH communication protocol. In other words, this ciphertext typically has two roles, serving as the first message within some post-PQXDH protocol, and as part of Alice’s PQXDH initial message.</p><p>The initial message must be encoded in an unambiguous format to avoid confusion of the message items by the recipient.</p><p>After sending this, Alice may continue using <em>SK</em> or keys derived from <em>SK</em> within the post-PQXDH protocol for communication with Bob, subject to the security considerations discussed in <a href="#security-considerations">Section 4</a>.</p><h2 id="receiving-the-initial-message">3.4. Receiving the initial message</h2><p>Upon receiving Alice’s initial message, Bob retrieves Alice’s identity key and ephemeral key from the message. Bob also loads his identity private key and the private key(s) corresponding to the signed prekeys and one-time prekeys Alice used.</p><p>Using these keys, Bob calculates <em>PQKEM-DEC(PQPK<sub>B</sub>, CT)</em> as the shared secret <em>SS</em> and repeats the <em>DH</em> and <em>KDF</em> calculations from the previous section to derive <em>SK</em>, and then deletes the <em>DH</em> values and <em>SS</em> values.</p><p>Bob then constructs the <em>AD</em> byte sequence using <em>IK<sub>A</sub></em> and <em>IK<sub>B</sub></em> as described in the previous section. Finally, Bob attempts to decrypt the initial ciphertext using <em>SK</em> and <em>AD</em>. If the initial ciphertext fails to decrypt, then Bob aborts the protocol and deletes <em>SK</em>.</p><p>If the initial ciphertext decrypts successfully, the protocol is complete for Bob. For forward secrecy, Bob deletes the ciphertext and any one-time prekey private key that was used. Bob may then continue using <em>SK</em> or keys derived from <em>SK</em> within the post-PQXDH protocol for communication with Alice subject to the security considerations discussed in <a href="#security-considerations">Section 4</a>.</p><p>The security of the composition of X3DH <span data-cites="x3dh"><a href="#ref-x3dh" role="doc-biblioref">[6]</a></span> with the Double Ratchet <span data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span> was formally studied in <span data-cites="CCDGS20"><a href="#ref-CCDGS20" role="doc-biblioref">[8]</a></span> and proven secure under the Gap Diffie-Hellman assumption (GDH)<span data-cites="OP01"><a href="#ref-OP01" role="doc-biblioref">[9]</a></span>. PQXDH composed with the Double Ratchet retains this security against an adversary without access to a quantum computer, but strengthens the security of the initial handshake to require the solution of both GDH and Module-LWE <span data-cites="LS15"><a href="#ref-LS15" role="doc-biblioref">[10]</a></span>. The remainder of this section discusses an incomplete list of further security considerations.</p><h2 id="authentication">4.1. Authentication</h2><p>Before or after a PQXDH key agreement, the parties may compare their identity public keys <em>IK<sub>A</sub></em> and <em>IK<sub>B</sub></em> through some authenticated channel. For example, they may compare public key fingerprints manually, or by scanning a QR code. Methods for doing this are outside the scope of this document.</p><p>Authentication in PQXDH is not quantum-secure. In the presence of an active quantum adversary, the parties receive no cryptographic guarantees as to who they are communicating with. Post-quantum secure deniable mutual authentication is an open research problem which we hope to address with a future revision of this protocol.</p><p>If authentication is not performed, the parties receive no cryptographic guarantee as to who they are communicating with.</p><h2 id="protocol-replay">4.2. Protocol replay</h2><p>If Alice’s initial message doesn’t use a one-time prekey, it may be replayed to Bob and he will accept it. This could cause Bob to think Alice had sent him the same message (or messages) repeatedly.</p><p>To mitigate this, a post-PQXDH protocol may wish to quickly negotiate a new encryption key for Alice based on fresh random input from Bob. This is the typical behavior of Diffie-Hellman-based ratcheting protocols <span data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.</p><p>Bob could attempt other mitigations, such as maintaining a blacklist of observed messages, or replacing old signed prekeys more rapidly. Analyzing these mitigations is beyond the scope of this document.</p><h2 id="replay-and-key-reuse">4.3. Replay and key reuse</h2><p>Another consequence of the replays discussed in the previous section is that a successfully replayed initial message would cause Bob to derive the same <em>SK</em> in different protocol runs.</p><p>For this reason, any post-PQXDH protocol that uses <em>SK</em> to derive encryption keys MUST take measures to prevent catastrophic key reuse. For example, Bob could use a DH-based ratcheting protocol to combine <em>SK</em> with a freshly generated <em>DH</em> output to get a randomized encryption key <span data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.</p><h2 id="deniability">4.4. Deniability</h2><p>Informally, cryptographic deniability means that a protocol neither gives its participants a publishable cryptographic proof of the contents of their communication nor proof of the fact that they communicated. PQXDH, like X3DH, aims to provide both Alice and Bob deniablilty that they communicated with each other in a context where a “judge” who may have access to one or more party’s secret keys is presented with a transcript allegedly created by communication between Alice and Bob.</p><p>We focus on offline deniability because if either party is collaborating with a third party during protocol execution, they will be able to provide proof of their communication to such a third party. This limitation on “online” deniability appears to be intrinsic to the asynchronous setting <span data-cites="unger"><a href="#ref-unger" role="doc-biblioref">[11]</a></span>.</p><p>PQXDH has some forms of cryptographic deniability. Motivated by the goals of X3DH, Brendel et al. <span data-cites="bfgjs21"><a href="#ref-bfgjs21" role="doc-biblioref">[12]</a></span> introduce a notion of 1-out-of-2 deniability for semi-honest parties and a “big brother” judge with access to all parties’ secret keys. Since either Alice or Bob can create a fake transcript using only their own secret keys, PQXDH has this deniability property. Vatandas, et al. <span data-cites="vgik21"><a href="#ref-vgik21" role="doc-biblioref">[13]</a></span> prove that X3DH is deniable in a different sense subject to certain “Knowledge of Diffie-Hellman Assumptions”. PQXDH is deniable in this sense for Alice, subject to the same assumptions, and we conjecture that it is deniable for Bob subject to an additional Plaintext Awareness (PA) assumption for <em>pqkem</em>. We note that Kyber uses a variant of the Fujisaki-Okamoto transform with implicit rejection <span data-cites="hhk17"><a href="#ref-hhk17" role="doc-biblioref">[14]</a></span> and is therefore not PA as is. However, in PQXDH, an AEAD ciphertext encrypted with the session key is always sent along with the Kyber ciphertext. This should offer the same guarantees as PA. We encourage the community to investigate the precise deniability properties of PQXDH.</p><p>These assertions all pertain to deniability in the classical setting. As discussed in <span data-cites="hkkp21"><a href="#ref-hkkp21" role="doc-biblioref">[15]</a></span> we expect that for future revisions of this protocol (that provide post-quantum mutual authentication) assertions about deniability against semi-honest quantum advsersaries will hold. Deniability in the face of malicious quantum adversaries requires further research.</p><h2 id="signatures">4.5. Signatures</h2><p>It might be tempting to omit the prekey signature after observing that mutual authentication and forward secrecy are achieved by the <em>DH</em> calculations. However, this would allow a “weak forward secrecy” attack: A malicious server could provide Alice a prekey bundle with forged prekeys, and later compromise Bob’s <em>IK<sub>B</sub></em> to calculate <em>SK</em>.</p><p>Alternatively, it might be tempting to replace the DH-based mutual authentication (i.e. <em>DH<sub>1</sub></em> and <em>DH<sub>2</sub></em>) with signatures from the identity keys. However, this reduces deniability, increases the size of initial messages, and increases the damage done if ephemeral or prekey private keys are compromised, or if the signature scheme is broken.</p><h2 id="key-compromise">4.6. Key compromise</h2><p>Compromise of a party’s private keys has a disastrous effect on security, though the use of ephemeral keys and prekeys provides some mitigation.</p><p>Compromise of a party’s identity private key allows impersonation of that party to others. Compromise of a party’s prekey private keys may affect the security of older or newer <em>SK</em> values, depending on many considerations.</p><p>A full analysis of all possible compromise scenarios is outside the scope of this document, however a partial analysis of some plausible scenarios is below:</p><ul><li><p>If either an elliptic curve one-time prekey (<em>OPK<sub>B</sub></em>) or a post-quantum key encapsulation one-time prekey (<em>PQOPK<sub>B</sub></em>) are used for a protocol run and deleted as specified, then a compromise of Bob’s identity key and prekey private keys at some future time will not compromise the older <em>SK</em>.</p></li><li><p>If one-time prekeys were not used for a protocol run, then a compromise of the private keys for <em>IK<sub>B</sub></em>, <em>SPK<sub>B</sub></em>, and <em>PQSPK<sub>B</sub></em> from that protocol run would compromise the <em>SK</em> that was calculated earlier. Frequent replacement of signed prekeys mitigates this, as does using a post-PQXDH ratcheting protocol which rapidly replaces <em>SK</em> with new keys to provide fresh forward secrecy <span data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.</p></li><li><p>Compromise of prekey private keys may enable attacks that extend into the future, such as passive calculation of <em>SK</em> values, and impersonation of arbitrary other parties to the compromised party (“key-compromise impersonation”). These attacks are possible until the compromised party replaces his compromised prekeys on the server (in the case of passive attack); or deletes his compromised signed prekey’s private key (in the case of key-compromise impersonation).</p></li></ul><h2 id="passive-quantum-adversaries">4.7. Passive quantum adversaries</h2><p>PQXDH is designed to prevent “harvest now, decrypt later” attacks by adversaries with access to a quantum computer capable of computing discrete logarithms in <em>curve</em>.</p><ul><li><p>If an attacker has recorded the public information and the message from Alice to Bob, even access to a quantum computer will not compromise <em>SK</em>.</p></li><li><p>If a post-quantum key encapsulation one-time prekey (<em>PQOPK<sub>B</sub></em>) is used for a protocol run and deleted as specified then compromise after deletion and access to a quantum computer at some future time will not compromise the older <em>SK</em>.</p></li><li><p>If post-quantum one-time prekeys were not used for a protocol run, then access to a quantum computer and a compromise of the private key for <em>PQSPK<sub>B</sub></em> from that protocol run would compromise the <em>SK</em> that was calculated earlier. Frequent replacement of signed prekeys mitigates this, as does using a post-PQXDH ratcheting protocol which rapidly replaces <em>SK</em> with new keys to provide fresh forward secrecy <span data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.</p></li></ul><h2 id="active-quantum-adversaries">4.8. Active quantum adversaries</h2><p>PQXDH is not designed to provide protection against active quantum attackers. An active attacker with access to a quantum computer capable of computing discrete logarithms in <em>curve</em> can compute <em>DH(PK<sub>1</sub>, PK<sub>2</sub>)</em> and <em>Sig(PK, M, Z)</em> for all elliptic <em>curve</em> keys <em>PK<sub>1</sub></em>, <em>PK<sub>2</sub></em>, and <em>PK</em>. This allows an attacker to impersonate Alice by using the quantum computer to compute the secret key corresponding to <em>PK<sub>A</sub></em> then continuing with the protocol. A malicious server with access to such a quantum computer could impersonate Bob by generating new key pairs <em>PQSPK’<sub>B</sub></em> and <em>PQOPK’<sub>B</sub></em>, computing the secret key corresponding to <em>PK<sub>B</sub></em>, then using <em>PK<sub>B</sub></em> to sign the newly generated post-quantum KEM keys and delivering these attacker-generated keys in place of Bob’s post-quantum KEM key when Alice requests a prekey bundle.</p><p>It is tempting to consider adding a post-quantum identity key that Bob could use to sign the post-quantum prekeys. This would prevent the malicious server attack described above and provide Alice a cryptographic guarantee that she is communicating with Bob, but it does not provide mutual authentication. Bob does not have any cryptographic guarantee about who he is communicating with. The post-quantum KEM and signature schemes being standardized by NIST <span data-cites="nistpostquantum"><a href="#ref-nistpostquantum" role="doc-biblioref">[16]</a></span> do not provide a mechanism for post-quantum deniable mutual authentication, although this can be achieved through the use of a post-quantum ring signature or designated verifier signature <span data-cites="bfgjs21"><a href="#ref-bfgjs21" role="doc-biblioref">[12]</a></span>, <span data-cites="hkkp21"><a href="#ref-hkkp21" role="doc-biblioref">[15]</a></span>. We urge the community to work toward standardization of these or other mechanisms that will allow deniable mutual authentication.</p><h2 id="server-trust">4.9. Server trust</h2><p>A malicious server could cause communication between Alice and Bob to fail (e.g. by refusing to deliver messages).</p><p>If Alice and Bob authenticate each other as in <a href="#authentication">Section 4.1</a>, then the only additional attack available to the server is to refuse to hand out one-time prekeys, causing forward secrecy for <em>SK</em> to depend on the signed prekey’s lifetime (as analyzed in <a href="#key-compromise">Section 4.6</a>).</p><p>This reduction in initial forward secrecy could also happen if one party maliciously drains another party’s one-time prekeys, so the server should attempt to prevent this (e.g. with rate limits on fetching prekey bundles).</p><h2 id="identity-binding">4.10. Identity binding</h2><p>Authentication as in <a href="#authentication">Section 4.1</a> does not necessarily prevent an “identity misbinding” or “unknown key share” attack.</p><p>This results when an attacker (“Charlie”) falsely presents Bob’s identity key fingerprint to Alice as his (Charlie’s) own, and then either forwards Alice’s initial message to Bob, or falsely presents Bob’s contact information as his own. The effect of this is that Alice thinks she is sending an initial message to Charlie when she is actually sending it to Bob.</p><p>To make this more difficult the parties can include more identifying information into <em>AD</em>, or hash more identifying information into the fingerprint, such as usernames, phone numbers, real names, or other identifying information. Charlie would be forced to lie about these additional values, which might be difficult.</p><p>However, there is no way to reliably prevent Charlie from lying about additional values, and including more identity information into the protocol often brings trade-offs in terms of privacy, flexibility, and user interface. A detailed analysis of these trade-offs is beyond the scope of this document.</p><h2 id="risks-of-weak-randomness-sources">4.11. Risks of weak randomness sources</h2><p>In addition to concerns about the generation of the keys themselves, the security of the PQKEM shared secret relies on the random source available to Alice’s machine at the time of running the <strong><em>PQKEM-ENC</em></strong> operation. This leads to a situation similar to what we face with a Diffie-Hellman exchange. For both Diffie-Hellman and Kyber, if Alice has weak entropy then the resulting shared secret will have low entropy when conditioned on Bob’s public key. Thus both the classical and post-quantum security of <em>SK</em> depend on the strength of Alice’s random source.</p><p>Kyber hashes Bob’s public key with Alice’s random bits to generate the shared secret, making Bob’s key contributory, as it is with a Diffie-Hellman key exchange. This does not reduce the dependence on Alice’s entropy source, as described above, but it does limit Alice’s ability to control the post-quantum shared secret. Not all KEMs make Bob’s key contributory and this is a property to consider when selecting <em>pqkem</em>.</p><p>This document is hereby placed in the public domain.</p><p>The PQXDH protocol was developed by Ehren Kret and Rolfe Schmidt as an extension of the X3DH protocol <span data-cites="x3dh"><a href="#ref-x3dh" role="doc-biblioref">[6]</a></span> by Moxie Marlinspike and Trevor Perrin. Thanks to Trevor Perrin for discussions on the design of this protocol.</p><p>Thanks to Bas Westerbaan, Chris Peikert, Daniel Collins, Deirdre Connolly, John Schanck, Jon Millican, Jordan Rose, Karthik Bhargavan, Loïs Huguenin-Dumittan, Peter Schwabe, Rune Fiedler, Shuichi Katsumata, Sofía Celi, and Yo’av Rieck for helpful discussions and editorial feedback.</p><p>Thanks to the Kyber team <span data-cites="kyberweb"><a href="#ref-kyberweb" role="doc-biblioref">[17]</a></span> for their work on the Kyber key encapsulation mechanism.</p><div id="refs" role="list"><div id="ref-rfc7748" role="listitem"><p>[3]</p><p>A. Langley, M. Hamburg, and S. Turner, <span>“<span>Elliptic Curves for Security</span>.”</span> Internet Engineering Task Force; RFC 7748 (Informational); IETF, Jan-2016. <a href="http://www.ietf.org/rfc/rfc7748.txt">http://www.ietf.org/rfc/rfc7748.txt</a></p></div><div id="ref-rfc5869" role="listitem"><p>[4]</p><p>H. Krawczyk and P. Eronen, <span>“<span>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</span>.”</span> Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt">http://www.ietf.org/rfc/rfc5869.txt</a></p></div><div id="ref-aead" role="listitem"><p>[5]</p><p>P. Rogaway, <span>“<span>Authenticated-encryption with Associated-data</span>,”</span> in <span>Proceedings of the 9th <span>ACM</span> Conference on Computer and Communications Security</span>, 2002. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf">http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></p></div><div id="ref-CCDGS20" role="listitem"><p>[8]</p><p>K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, and D. Stebila, <span>“A formal security analysis of the signal messaging protocol,”</span> J. Cryptol., vol. 33, no. 4, 2020. <a href="https://doi.org/10.1007/s00145-020-09360-1">https://doi.org/10.1007/s00145-020-09360-1</a></p></div><div id="ref-OP01" role="listitem"><p>[9]</p><p>T. Okamoto and D. Pointcheval, <span>“The gap-problems: A new class of problems for the security of cryptographic schemes,”</span> in Proceedings of the 4th international workshop on practice and theory in public key cryptography: Public key cryptography, 2001.</p></div><div id="ref-LS15" role="listitem"><p>[10]</p><p>A. Langlois and D. Stehlé, <span>“Worst-case to average-case reductions for module lattices,”</span> Des. Codes Cryptography, vol. 75, no. 3, Jun. 2015. <a href="https://doi.org/10.1007/s10623-014-9938-4">https://doi.org/10.1007/s10623-014-9938-4</a></p></div><div id="ref-unger" role="listitem"><p>[11]</p><p>N. Unger and I. Goldberg, <span>“<span>Deniable Key Exchanges for Secure Messaging</span>,”</span> in <span>Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security</span>, 2015. <a href="https://cypherpunks.ca/~iang/pubs/dake-ccs15.pdf">https://cypherpunks.ca/~iang/pubs/dake-ccs15.pdf</a></p></div><div id="ref-bfgjs21" role="listitem"><p>[12]</p><p>J. Brendel, R. Fiedler, F. Günther, C. Janson, and D. Stebila, <span>“Post-quantum asynchronous deniable key exchange and the signal handshake,”</span> in Public-key cryptography - <span>PKC</span> 2022 - 25th <span>IACR</span> international conference on practice and theory of public-key cryptography, virtual event, march 8-11, 2022, proceedings, part <span>II</span>, 2022, vol. 13178. <a href="https://doi.org/10.1007/978-3-030-97131-1_1">https://doi.org/10.1007/978-3-030-97131-1_1</a></p></div><div id="ref-vgik21" role="listitem"><p>[13]</p><p>N. Vatandas, R. Gennaro, B. Ithurburn, and H. Krawczyk, <span>“On the cryptographic deniability of the signal protocol,”</span> in Applied cryptography and network security - 18th international conference, <span>ACNS</span> 2020, rome, italy, october 19-22, 2020, proceedings, part <span>II</span>, 2020, vol. 12147. <a href="https://doi.org/10.1007/978-3-030-57878-7_10">https://doi.org/10.1007/978-3-030-57878-7_10</a></p></div><div id="ref-hhk17" role="listitem"><p>[14]</p><p>D. Hofheinz, K. Hövelmanns, and E. Kiltz, <span>“A modular analysis of the fujisaki-okamoto transformation,”</span> in Theory of cryptography - 15th international conference, <span>TCC</span> 2017, baltimore, MD, USA, november 12-15, 2017, proceedings, part <span>I</span>, 2017, vol. 10677. <a href="https://doi.org/10.1007/978-3-319-70500-2_12">https://doi.org/10.1007/978-3-319-70500-2_12</a></p></div><div id="ref-hkkp21" role="listitem"><p>[15]</p><p>K. Hashimoto, S. Katsumata, K. Kwiatkowski, and T. Prest, <span>“An efficient and generic construction for signal’s handshake <span>(X3DH):</span> Post-quantum, state leakage secure, and deniable,”</span> J. Cryptol., vol. 35, no. 3, 2022. <a href="https://doi.org/10.1007/s00145-022-09427-1">https://doi.org/10.1007/s00145-022-09427-1</a></p></div></div></div></div></div>
  </body>
</html>
