<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://louisabraham.github.io/articles/probabilistic-tic-tac-toe">Original</a>
    <h1>Solving Probabilistic Tic-Tac-Toe</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <h3>11 Jun 2024</h3>
    
    <section id="main_content">
      <blockquote>
  <p>This morning, I came accross Cameron Sun’s <a href="https://www.csun.io/2024/06/08/probabilistic-tic-tac-toe.html">Probabilistic Tic-Tac-Toe</a> on <a href="https://news.ycombinator.com/item?id=40635397">HN</a>. However, the comments were disappointing, with people proposing probabilistic models, linear programming, minimax algorithms, and heuristic evaluations to develop AI approaches for the game, none of which quite correct. In this post, I’ll present an exact solution.</p>

  <p>An earlier version of this post included a mistake. Thanks to <a href="https://orlp.net/">Orson Peters</a> for <a href="https://news.ycombinator.com/item?id=40647831">pointing</a> it out and even sending me an email. Check out his <a href="https://orlp.net/blog/">blog</a>!</p>
</blockquote>



<p>You should definitely try <a href="https://www.csun.io/2024/06/08/probabilistic-tic-tac-toe.html">it</a> but as a reminder, probabilistic Tic-Tac-Toe is like tic-tac-toe but each cell is given a probability distribution. For example, if you play the center cell in the grid below, you have a 30% chance of marking it with your symbol, a 15% chance of not doing anything, and a 55% chance of marking it with the opponent’s symbol.</p>

<p><img src="https://louisabraham.github.io/static/probabilistic-tic-tac-toe.png" alt="Probabilistic Tic-Tac-Toe"/></p>



<p>If one ignores the probability of not marking a cell, the game is an obvious example of <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>. You have less than $3 ^ 9 = 19683$ states (the exact number is <a href="https://en.wikipedia.org/wiki/Game_complexity#Example:_tic-tac-toe_(noughts_and_crosses)">5478</a>) and one can compute the probability of the “cross” player winning in each state with the following pseudo-code:</p>

<div><div><pre><code>def value(state, turn):
    if state is a winning state for cross:
        return 1
    if state is a winning state for nought:
        return 0
    if turn == cross:
        return max(
            success(c) * value(apply(state, c, cross), nought)
            + failure(c) * value(apply(state, c, nought), nought)
            for c in available_cells(state)
        )
    else:
        return min(
            success(c) * value(apply(state, c, nought), cross)
            + failure(c) * value(apply(state, c, cross), cross)
            for c in available_cells(state)
        )
</code></pre></div></div>

<p>where <code>success(c)</code> and <code>failure(c)</code> are the probabilities of marking and not marking cell <code>c</code>.</p>



<p>The above pseudo-code is not enough to solve the game because of the possibility of doing nothing. If we were to simply add <code>neutral(c) * value(state, turn)</code> to the above pseudo-code, we would end up with an infinite loop.</p>

<p>However, let’s look at what the problem looks like for the cross player:</p>

<p>$V(s) = \max_c s_c \times V’(s + c) + f_c \times V’(s - c) + n_c \times V’(s)$</p>

<p>where $V(s)$ is the value of state $s$ for the cross player, $s_c$ is the probability of marking cell $c$ with a cross, $f_c$ is the probability of marking $c$ with a nought, $n_c$ is the probability of doing nothing, and $V’(s)$ is the value of state $s$ when it is the turn of the nought player. I also note that $s + c$ is the state $s$ where cell $c$ has been marked by the cross player and $s - c$ is the state $s$ where cell $c$ has been marked by the nought player.</p>

<p>But $s_c \times V’(s + c) + f_c \times V’(s - c)$ is something we can pre-compute without making loops since it depends on states with more marked cells. Let’s note that quantity $x_c$.</p>

<p>The problem now becomes $V(s) = \max_c x_c + n_c \times V’(s)$ where $n_c$ is less than 1.</p>

<p>Again, we can expand $V’(s)$ and get $V’(s) = \min_c s_c \times V(s - c) + f_c \times V(s + c) + n_c \times V(s) := \min_c x’_c + n_c \times V(s)$ where $x’_c$ is a quantity we can pre-compute and $n_c$ is less than 1.</p>

<p>The full equation becomes thus:</p>

\[\begin{align*}
V(s) &amp;= \max_c x_c + n_c \times V&#39;(s) \\
V&#39;(s) &amp;= \min_c x&#39;_c + n_c \times V(s)
\end{align*}\]

<p>We can rewrite the above equations as:</p>

\[\begin{align*}
y = \max_i f_i(x) = f(x) \\
x = \min_i g_i(y) = g(y)
\end{align*}\]

<p>where $f_i$ and $g_i$ are linear functions.</p>

<p><img src="https://louisabraham.github.io/static/plot-convex-tic-tac-toe.png" alt="Plot"/></p>

<p>Here, we are going to admit that there is a unique solution to the above equations. The curious reader can try to prove it.</p>

<p>There is an efficient way to solve this problem, that can generalize to any number of curves in $\mathcal{O}(N \log N)$ using some convex hull <a href="https://codeforces.com/blog/entry/63823">trick</a>. However we can solve the subproblem in an easy way by using binary search.</p>

<div><div><pre><code><span>def</span> <span>hull_intersection</span><span>(</span><span>f</span><span>,</span> <span>g</span><span>):</span>
    <span>&#34;&#34;&#34;
    f and g are two lists of tuples (a, b) representing linear functions
    solves
    y = max_i f_i(x)
    x = min_i g_i(y)
    &#34;&#34;&#34;</span>
    <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>0</span><span>,</span> <span>1</span>
    <span>while</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1e-9</span><span>:</span>
        <span>x</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>/</span> <span>2</span>
        <span>y</span> <span>=</span> <span>max</span><span>(</span><span>a</span> <span>*</span> <span>x</span> <span>+</span> <span>b</span> <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>f</span><span>)</span>
        <span>x1</span> <span>=</span> <span>min</span><span>(</span><span>a</span> <span>*</span> <span>y</span> <span>+</span> <span>b</span> <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>g</span><span>)</span>
        <span>if</span> <span>x1</span> <span>&lt;</span> <span>x</span><span>:</span>
            <span>b</span> <span>=</span> <span>x</span>
        <span>else</span><span>:</span>
            <span>a</span> <span>=</span> <span>x</span>
    <span>x</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>/</span> <span>2</span>
    <span>y</span> <span>=</span> <span>max</span><span>(</span><span>a</span> <span>*</span> <span>x</span> <span>+</span> <span>b</span> <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>f</span><span>)</span>
    <span>return</span> <span>y</span><span>,</span> <span>x</span>
</code></pre></div></div>



<p>We can now solve the problem. I invented a simple way to generate grids that seems to imitate the original game.</p>

<div><div><pre><code><span>import</span> <span>random</span>
<span>from</span> <span>functools</span> <span>import</span> <span>lru_cache</span>


<span>def</span> <span>hull_intersection</span><span>(</span><span>f</span><span>,</span> <span>g</span><span>):</span>
    <span>&#34;&#34;&#34;
    f and g are two lists of tuples (a, b) representing linear functions
    solves
    y = max_i f_i(x)
    x = min_i g_i(y)

    Also returns the indices of the optimal functions
    &#34;&#34;&#34;</span>
    <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>0</span><span>,</span> <span>1</span>
    <span>while</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1e-9</span><span>:</span>
        <span>x</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>/</span> <span>2</span>
        <span>y</span> <span>=</span> <span>max</span><span>(</span><span>a</span> <span>*</span> <span>x</span> <span>+</span> <span>b</span> <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>f</span><span>)</span>
        <span>x1</span> <span>=</span> <span>min</span><span>(</span><span>a</span> <span>*</span> <span>y</span> <span>+</span> <span>b</span> <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>g</span><span>)</span>
        <span>if</span> <span>x1</span> <span>&lt;</span> <span>x</span><span>:</span>
            <span>b</span> <span>=</span> <span>x</span>
        <span>else</span><span>:</span>
            <span>a</span> <span>=</span> <span>x</span>
    <span>x</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>/</span> <span>2</span>
    <span>y</span><span>,</span> <span>i</span> <span>=</span> <span>max</span><span>((</span><span>a</span> <span>*</span> <span>x</span> <span>+</span> <span>b</span><span>,</span> <span>i</span><span>)</span> <span>for</span> <span>i</span><span>,</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>f</span><span>))</span>
    <span>x</span><span>,</span> <span>j</span> <span>=</span> <span>min</span><span>((</span><span>a</span> <span>*</span> <span>y</span> <span>+</span> <span>b</span><span>,</span> <span>i</span><span>)</span> <span>for</span> <span>i</span><span>,</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>g</span><span>))</span>
    <span>return</span> <span>(</span><span>y</span><span>,</span> <span>i</span><span>),</span> <span>(</span><span>x</span><span>,</span> <span>j</span><span>)</span>


<span>def</span> <span>generate_cell</span><span>():</span>
    <span>neutral</span> <span>=</span> <span>random</span><span>.</span><span>choice</span><span>(</span><span>range</span><span>(</span><span>5</span><span>,</span> <span>35</span><span>,</span> <span>5</span><span>))</span>
    <span>success</span> <span>=</span> <span>random</span><span>.</span><span>choice</span><span>(</span><span>range</span><span>(</span><span>30</span><span>,</span> <span>100</span> <span>-</span> <span>neutral</span> <span>+</span> <span>5</span><span>,</span> <span>5</span><span>))</span>
    <span>failure</span> <span>=</span> <span>100</span> <span>-</span> <span>neutral</span> <span>-</span> <span>success</span>
    <span>return</span> <span>success</span> <span>/</span> <span>100</span><span>,</span> <span>neutral</span> <span>/</span> <span>100</span><span>,</span> <span>failure</span> <span>/</span> <span>100</span>


<span>def</span> <span>generate_grid</span><span>():</span>
    <span>return</span> <span>tuple</span><span>(</span><span>generate_cell</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>9</span><span>))</span>


<span>def</span> <span>apply</span><span>(</span><span>state</span><span>,</span> <span>cell</span><span>,</span> <span>player</span><span>):</span>
    <span>return</span> <span>tuple</span><span>(</span><span>player</span> <span>if</span> <span>i</span> <span>==</span> <span>cell</span> <span>else</span> <span>v</span> <span>for</span> <span>i</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>state</span><span>))</span>


<span>def</span> <span>winner</span><span>(</span><span>state</span><span>):</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>3</span><span>):</span>
        <span>if</span> <span>state</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>i</span> <span>+</span> <span>3</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>i</span> <span>+</span> <span>6</span><span>]</span> <span>and</span> <span>state</span><span>[</span><span>i</span><span>]</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>return</span> <span>state</span><span>[</span><span>i</span><span>]</span>
        <span>if</span> <span>(</span>
            <span>state</span><span>[</span><span>3</span> <span>*</span> <span>i</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>3</span> <span>*</span> <span>i</span> <span>+</span> <span>1</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>3</span> <span>*</span> <span>i</span> <span>+</span> <span>2</span><span>]</span>
            <span>and</span> <span>state</span><span>[</span><span>3</span> <span>*</span> <span>i</span><span>]</span> <span>is</span> <span>not</span> <span>None</span>
        <span>):</span>
            <span>return</span> <span>state</span><span>[</span><span>3</span> <span>*</span> <span>i</span><span>]</span>
    <span>if</span> <span>state</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>4</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>8</span><span>]</span> <span>and</span> <span>state</span><span>[</span><span>0</span><span>]</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>return</span> <span>state</span><span>[</span><span>0</span><span>]</span>
    <span>if</span> <span>state</span><span>[</span><span>2</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>4</span><span>]</span> <span>==</span> <span>state</span><span>[</span><span>6</span><span>]</span> <span>and</span> <span>state</span><span>[</span><span>2</span><span>]</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>return</span> <span>state</span><span>[</span><span>2</span><span>]</span>
    <span>return</span> <span>None</span>


<span>def</span> <span>available_cells</span><span>(</span><span>state</span><span>):</span>
    <span>return</span> <span>[</span><span>i</span> <span>for</span> <span>i</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>state</span><span>)</span> <span>if</span> <span>v</span> <span>is</span> <span>None</span><span>]</span>


<span>@</span><span>lru_cache</span><span>(</span><span>3</span><span>**</span><span>9</span><span>)</span>
<span>def</span> <span>value</span><span>(</span><span>grid</span><span>,</span> <span>state</span><span>=</span><span>(</span><span>None</span><span>,)</span> <span>*</span> <span>9</span><span>):</span>
    <span>&#34;&#34;&#34;
    Returns V(s) and V&#39;(s) along with the optimal actions
    &#34;&#34;&#34;</span>
    <span>w</span> <span>=</span> <span>winner</span><span>(</span><span>state</span><span>)</span>
    <span>if</span> <span>w</span> <span>==</span> <span>&#34;x&#34;</span><span>:</span>
        <span>return</span> <span>(</span><span>1</span><span>,</span> <span>None</span><span>),</span> <span>(</span><span>1</span><span>,</span> <span>None</span><span>)</span>
    <span>elif</span> <span>w</span> <span>==</span> <span>&#34;o&#34;</span><span>:</span>
        <span>return</span> <span>(</span><span>0</span><span>,</span> <span>None</span><span>),</span> <span>(</span><span>0</span><span>,</span> <span>None</span><span>)</span>

    <span>cells</span> <span>=</span> <span>available_cells</span><span>(</span><span>state</span><span>)</span>
    <span>if</span> <span>not</span> <span>cells</span><span>:</span>
        <span>return</span> <span>(</span><span>0.5</span><span>,</span> <span>None</span><span>),</span> <span>(</span><span>0.5</span><span>,</span> <span>None</span><span>)</span>

    <span>f</span> <span>=</span> <span>[]</span>
    <span>g</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>cell</span> <span>in</span> <span>cells</span><span>:</span>
        <span>success</span><span>,</span> <span>neutral</span><span>,</span> <span>failure</span> <span>=</span> <span>grid</span><span>[</span><span>cell</span><span>]</span>
        <span>s1</span> <span>=</span> <span>apply</span><span>(</span><span>state</span><span>,</span> <span>cell</span><span>,</span> <span>&#34;x&#34;</span><span>)</span>
        <span>(</span><span>v1</span><span>,</span> <span>_</span><span>),</span> <span>(</span><span>vp1</span><span>,</span> <span>_</span><span>)</span> <span>=</span> <span>value</span><span>(</span><span>grid</span><span>,</span> <span>s1</span><span>)</span>
        <span>s2</span> <span>=</span> <span>apply</span><span>(</span><span>state</span><span>,</span> <span>cell</span><span>,</span> <span>&#34;o&#34;</span><span>)</span>
        <span>(</span><span>v2</span><span>,</span> <span>_</span><span>),</span> <span>(</span><span>vp2</span><span>,</span> <span>_</span><span>)</span> <span>=</span> <span>value</span><span>(</span><span>grid</span><span>,</span> <span>s2</span><span>)</span>
        <span>x_c</span> <span>=</span> <span>success</span> <span>*</span> <span>vp1</span> <span>+</span> <span>failure</span> <span>*</span> <span>vp2</span>
        <span>xp_c</span> <span>=</span> <span>success</span> <span>*</span> <span>v2</span> <span>+</span> <span>failure</span> <span>*</span> <span>v1</span>
        <span>f</span><span>.</span><span>append</span><span>((</span><span>neutral</span><span>,</span> <span>x_c</span><span>))</span>
        <span>g</span><span>.</span><span>append</span><span>((</span><span>neutral</span><span>,</span> <span>xp_c</span><span>))</span>
    <span>(</span><span>v</span><span>,</span> <span>i</span><span>),</span> <span>(</span><span>vp</span><span>,</span> <span>ip</span><span>)</span> <span>=</span> <span>hull_intersection</span><span>(</span><span>f</span><span>,</span> <span>g</span><span>)</span>
    <span>return</span> <span>(</span><span>v</span><span>,</span> <span>cells</span><span>[</span><span>i</span><span>]),</span> <span>(</span><span>vp</span><span>,</span> <span>cells</span><span>[</span><span>ip</span><span>])</span>
</code></pre></div></div>

<p>With this code, we can solve the game for any grid. For example, the grid in the image above can be solved with the following code:</p>

<div><div><pre><code><span>grid</span> <span>=</span> <span>(</span>
    <span>(</span><span>0.65</span><span>,</span> <span>0.05</span><span>,</span> <span>0.3</span><span>),</span>
    <span>(</span><span>0.65</span><span>,</span> <span>0.2</span><span>,</span> <span>0.15</span><span>),</span>
    <span>(</span><span>0.55</span><span>,</span> <span>0.3</span><span>,</span> <span>0.15</span><span>),</span>
    <span>(</span><span>0.3</span><span>,</span> <span>0.2</span><span>,</span> <span>0.5</span><span>),</span>
    <span>(</span><span>0.3</span><span>,</span> <span>0.15</span><span>,</span> <span>0.55</span><span>),</span>
    <span>(</span><span>0.35</span><span>,</span> <span>0.05</span><span>,</span> <span>0.6</span><span>),</span>
    <span>(</span><span>0.3</span><span>,</span> <span>0.05</span><span>,</span> <span>0.65</span><span>),</span>
    <span>(</span><span>0.35</span><span>,</span> <span>0.2</span><span>,</span> <span>0.45</span><span>),</span>
    <span>(</span><span>0.45</span><span>,</span> <span>0.1</span><span>,</span> <span>0.45</span><span>),</span>
<span>)</span>

<span>print</span><span>(</span><span>value</span><span>(</span><span>grid</span><span>))</span>
<span># ((0.5385368180873334, 2), (0.46146318189602853, 2))
</span></code></pre></div></div>

<p>We can also compute the average score of the cross player on random grids:</p>

<div><div><pre><code><span>n</span> <span>=</span> <span>100</span>
<span>print</span><span>(</span><span>sum</span><span>(</span><span>value</span><span>(</span><span>generate_grid</span><span>())[</span><span>0</span><span>][</span><span>0</span><span>]</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>n</span><span>))</span> <span>/</span> <span>n</span><span>)</span>
<span># 0.5722708880508689
</span></code></pre></div></div>

<p>Finally, a little sanity check. If we decide who starts with a fair coin flip, then both players get the same value by symmetry. Since the total value of the game is $1$, the value of the game for both players is $\frac12$. Hence, the value of the cross player must be $\frac12$, aka $\frac{V(∅) + V’(∅)}{2} = \frac12$.</p>

<div><div><pre><code><span>(</span><span>v</span><span>,</span> <span>_</span><span>),</span> <span>(</span><span>vp</span><span>,</span> <span>_</span><span>)</span> <span>=</span> <span>value</span><span>(</span><span>generate_grid</span><span>())</span>
<span>print</span><span>((</span><span>v</span> <span>+</span> <span>vp</span><span>)</span> <span>/</span> <span>2</span><span>)</span>
<span># 0.49999999999061806
</span></code></pre></div></div>

    </section>
  </div></div>
  </body>
</html>
