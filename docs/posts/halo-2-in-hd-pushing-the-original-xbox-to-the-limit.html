<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://icode4.coffee/?p=738">Original</a>
    <h1>Halo 2 in HD: Pushing the Original Xbox to the Limit</h1>
    
    <div id="readability-page-1" class="page"><div>
									
									
<p>This blog post goes over all of the work I’ve done to add HD resolution support to the Original Xbox version of Halo 2. From patching the game to modifying the hardware of the Xbox console to writing custom tools for performance benchmarking, my goal with this project was to push the limits of both and see how far I could go. I’ve tried to keep this blog post as short as I could and only include the most technically interesting parts but even then it ended up quite long.</p>



<h2>Prelude</h2>



<p>A long time friend who goes by the handle “doom” has spent the past few years reverse engineering and researching the hardware and software on the original Xbox. His end goal was to learn more about PC hardware and see how far he could push the console. Some of his work includes swapping out the stock Pentium 3 CPU running at 733Mhz for a variant of the Pentium 3 CPU running at 1.4Ghz using a custom made CPU interposer board, and even being able to overclock it upwards of ~2Ghz. </p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/xbox_upgraded_cpu.png" target="_blank" rel="noopener"><img loading="lazy" width="960" height="720" src="https://icode4.coffee/wp-content/uploads/xbox_upgraded_cpu.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/xbox_upgraded_cpu.png 960w, https://icode4.coffee/wp-content/uploads/xbox_upgraded_cpu-300x225.png 300w, https://icode4.coffee/wp-content/uploads/xbox_upgraded_cpu-768x576.png 768w" sizes="(max-width: 960px) 100vw, 960px"/></a><figcaption>Pentium 3 Tualatin on Doom’s custom interposer</figcaption></figure></div>



<p>Doom also wrote custom patches for the Xbox kernel in order to on-the-fly patch timing calculations for games so they ran properly with the faster CPU. Combined with a few other hardware upgrades such as additional RAM and an SSD, doom started to refer to these as “god boxes”. These god boxes were also running a custom kernel (or BIOS image) that doom made to support all of the hardware modifications and push the hardware and software as far as they could go. One of his demos for his work was showing the opening sequence in Half-Life 2 which is notorious for abysmally slow loading times and poor performance on the Xbox, running at a solid 30 FPS and loading in a matter of seconds. But there were still additional benefits to be had. Doom wanted someone to create a proper HD resolution patch for a popular game and really utilize the hardware upgrades he performed. </p>



<p>One night while talking over Discord doom asked if I would be interested in developing an HD patch for Halo 2 and in exchange he would provide me with a god box to develop it on. Halo 2 has a max supported video resolution of 480p and patching in support for 720p (and possibly 1080i) would get a lot of attention to demonstrate the benefits of all this work. We both knew that many of the community “HD” or “720p” game patches were not actually functioning correctly and that patching in HD resolution support for a game was more work than just searching for 640/480 in a disassembler and changing the resolution. These patches require a deep understanding of 3D graphics, DirectX APIs, and a lot of specific knowledge about the game and Xbox console. Having spent years reverse engineering the Xbox and Halo 2’s game engine I had the perfect background to take on the task. As doom would put it “there’s nobody more qualified than you to do it for halo 2 so that’s why I asked”. While it piqued my interest (and I was pretty jealous of these god boxes and all the experience he’d gotten developing them), I made a request/requirement before I would even entertain the idea. </p>



<p>The upgraded CPU has more than double the processing power compared to the stock CPU, however, the GPU was going to take on most of the increased processing load once the video resolution was increased. After all, each additional pixel in the output image would result in more pixel shader calculations which meant more work the GPU would have to do. If he could manage to overclock the GPU I would do it, but at stock clock speeds it wasn’t worth the time it would take to develop this patch just to have it fall over on the GPU. He said he would look into it, and after a few weeks time he came back and said it was done. He managed to overclock the GPU by ~15%, and said he had the “GENESIS-3” console ready for me (a nickname for the 3rd iteration of the “god box” upgrades he’d been working on).</p>







<p>Having spent the past few years reverse engineering and re-implementing the Halo 2 rendering engine I already had a mental list of things I’d need to change to support higher video resolutions. The first thing that needed to be changed was the size of the D3D front and back buffers. The setup for the D3D device has 3 functions that need to be modified in order to use the proper resolution for the current video mode. The first is _rasterizer_detect_video_mode which checks the video mode and sets some global variables for widescreen and progressive video modes. Next is _rasterizer_init_screen_bounds which sets up the screen dimensions used for creating the D3D device, view frustum, and a number of other things. Lastly is rasterizer_device_initialize which is responsible for setting up the D3D device. Below is a shortened version of these 3 functions with the lines of interest highlighted. All of the code shown in this post has been reverse engineered from assembly back into C for ease of understanding.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a682183391043" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>_rasterizer_detect_video_mode</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>DWORD </span><span>videoStandard</span><span> </span><span>=</span><span> </span><span>XGetVideoStandard</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>DWORD </span><span>videoFlags</span><span> </span><span>=</span><span> </span><span>XGetVideoFlags</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>videoStandard</span><span> </span><span>==</span><span> </span><span>XC_VIDEO_STANDARD_PAL_I</span><span>)</span></p><p><span>		</span><span>g_refresh_rate_hz</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_PAL_60Hz</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>?</span><span> </span><span>60</span><span> </span><span>:</span><span> </span><span>50</span><span>;</span></p><p><span>	</span><span>g_letterbox_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_LETTERBOX</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>g_widescreen_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_WIDESCREEN</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>g_progressive_scan_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_HDTV_480p</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>_rasterizer_init_screen_bounds</span><span>(</span><span>int</span><span> </span><span>x_off</span><span>,</span><span> </span><span>int</span><span> </span><span>y_off</span><span>,</span><span> </span><span>float</span><span> </span><span>scale</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>float</span><span> </span><span>width</span><span> </span><span>=</span><span> </span><span>640.0f</span><span> </span><span>*</span><span> </span><span>scale</span><span>;</span></p><p><span>	</span><span>float</span><span> </span><span>height</span><span> </span><span>=</span><span> </span><span>480.0f</span><span> </span><span>*</span><span> </span><span>scale</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x0</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y0</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>width</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>height</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>x0</span><span> </span><span>=</span><span> </span><span>x_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>y0</span><span> </span><span>=</span><span> </span><span>y_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>x1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>width</span><span> </span><span>-</span><span> </span><span>x_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>y1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>height</span><span> </span><span>-</span><span> </span><span>y_off</span><span>;</span></p><p><span>}</span></p><p><span>bool</span><span> </span><span>rasterizer_device_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>D3DPRESENT_PARAMETERS </span><span>PresentParams</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>}</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferWidth</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x0</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferHeight</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_A8R8G8B8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>EnableAutoDepthStencil</span><span> </span><span>=</span><span> </span><span>TRUE</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>AutoDepthStencilFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_D24S8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>=</span><span> </span><span>D3DPRESENTFLAG_LOCKABLE_BACKBUFFER</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_RefreshRateInHz</span><span> </span><span>=</span><span> </span><span>g_refresh_rate_hz</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>=</span><span> </span><span>D3DPRESENT_INTERVAL_IMMEDIATE</span><span>;</span></p><p><span>	</span><span>switch</span><span> </span><span>(</span><span>g_presentation_interval</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>case</span><span> </span><span>0</span><span>:</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>SwapEffect</span><span> </span><span>=</span><span> </span><span>D3DSWAPEFFECT_FLIP</span><span>;</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>=</span><span> </span><span>D3DPRESENT_INTERVAL_IMMEDIATE</span><span>;</span></p><p><span>			</span><span>break</span><span>;</span></p><p><span>		</span><span>case</span><span> </span><span>1</span><span>:</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>SwapEffect</span><span> </span><span>=</span><span> </span><span>D3DSWAPEFFECT_DISCARD</span><span>;</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>|=</span><span> </span><span>g_present_immediately</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>?</span><span> </span><span>D3DPRESENT_INTERVAL_ONE</span><span> </span><span>:</span><span> </span><span>0</span><span>;</span></p><p><span>			</span><span>break</span><span>;</span></p><p><span>		</span><span>case</span><span> </span><span>2</span><span>:</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>SwapEffect</span><span> </span><span>=</span><span> </span><span>D3DSWAPEFFECT_DISCARD</span><span>;</span></p><p><span>			</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>|=</span><span> </span><span>g_present_immediately</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>?</span><span> </span><span>D3DPRESENT_INTERVAL_TWO</span><span> </span><span>:</span><span> </span><span>0</span><span>;</span></p><p><span>			</span><span>break</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>g_pDirect3D</span><span>-&gt;</span><span>CreateDevice</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DDEVTYPE_HAL</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>D3DCREATE_HARDWARE_VERTEXPROCESSING</span><span>,</span><span> </span><span>&amp;</span><span>PresentParams</span><span>,</span><span> </span><span>&amp;</span><span>g_pD3DDevice</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0017 seconds] -->
</div>



<h4>Halo 2 already supports 480p, or does it…</h4>



<p>If you’ve ever looked at the back of the game case for Halo 2 you might have seen it supports 480p. However, looking at line 42 above, the D3DPRESENTFLAG_PROGRESSIVE flag is not being set on the present parameters. And, if we look at the call site for the _rasterizer_init_screen_bounds function we see this:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/ida_init_screen_bounds.png" target="_blank" rel="noopener"><img loading="lazy" width="605" height="471" src="https://icode4.coffee/wp-content/uploads/ida_init_screen_bounds.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/ida_init_screen_bounds.png 605w, https://icode4.coffee/wp-content/uploads/ida_init_screen_bounds-300x234.png 300w" sizes="(max-width: 605px) 100vw, 605px"/></a><figcaption>Call site for _rasterizer_init_screen_bounds</figcaption></figure></div>



<p>The scale parameter is always set to 1.0f, which means the screen_bounds are always set to 640×480 regardless of what the video mode is set to on the console. On the Original Xbox 480p is considered to be 720×480, which means that <strong>Halo 2 does not render in 480p natively</strong> regardless of what the video settings are set to. If you enable 480p mode on the console you’ll get a 480p signal out but that’s because after the game is done drawing to the 640×480 back buffer it’ll get up-scaled to 720×480 by the GPU before being fed to the video encoder. I often get comments saying “that’s not not a 16:9 resolution” or “that’s not real 480p”, but “480p” <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/480p#Resolutions" target="_blank">encapsulates a range of resolutions and aspect ratios</a> and 720×480 is the resolution the Xbox considers to be 480p (so take it up with Microsoft, not me…).</p>



<p>If you’ve ever played Halo 2 in 480p mode with wide screen enabled you may have noticed that things look a little weird. That’s because when wide screen mode is enabled the game will use an anamorphic camera with an aspect ratio of 1.33:1. That means it renders 1.3x the width into the same 640×480 surface as it would when wide screen mode is disabled. Here is a comparison showing the effect anamorphic scaling has on the Zanzibar wheel:</p>







<p>I’m not entirely sure why it does this and my only guess is if you set your TV to stretch mode it would “cancel out” the horizontal “squish” introduced by the anamorphic scaling and look somewhat normal. However, I personally hate it and wanted the cleanest image I could get out of the console so I added an option to disable the anamorphic scaling entirely.</p>



<h4>Back to the back buffer…</h4>



<p>To create the D3D front/back buffers with the right dimensions we’ll need to change g_progressive_scan_enabled to be set when 720p is enabled, set the screen_bounds and frame_bounds variables based on the proper video resolution for the video mode set, and finally set some additional flags on the D3D present parameters depending on if the video mode is progressive or interlaced (1080i mode). The pseudo code for the modifications is shown below with the changed lines highlighted. I ignored the scale variable in _rasterizer_init_screen_bounds because it’s only ever set to 1.0 anyway.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a690718888287" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>_rasterizer_detect_video_mode</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>DWORD </span><span>videoStandard</span><span> </span><span>=</span><span> </span><span>XGetVideoStandard</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>DWORD </span><span>videoFlags</span><span> </span><span>=</span><span> </span><span>XGetVideoFlags</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>videoStandard</span><span> </span><span>==</span><span> </span><span>XC_VIDEO_STANDARD_PAL_I</span><span>)</span></p><p><span>		</span><span>g_refresh_rate_hz</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_PAL_60Hz</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>?</span><span> </span><span>60</span><span> </span><span>:</span><span> </span><span>50</span><span>;</span></p><p><span>	</span><span>g_letterbox_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_LETTERBOX</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>g_widescreen_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_WIDESCREEN</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>g_progressive_scan_enabled</span><span> </span><span>=</span><span> </span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>XC_VIDEO_FLAGS_HDTV_480p</span><span> </span><span>|</span><span> </span><span>XC_VIDEO_FLAGS_HDTV_720p</span><span>)</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>_rasterizer_init_screen_bounds</span><span>(</span><span>int</span><span> </span><span>x_off</span><span>,</span><span> </span><span>int</span><span> </span><span>y_off</span><span>,</span><span> </span><span>float</span><span> </span><span>scale</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Set default resolution to 640x480.</span></p><p><span>	</span><span>float</span><span> </span><span>width</span><span> </span><span>=</span><span> </span><span>640.0f</span><span>;</span></p><p><span>	</span><span>float</span><span> </span><span>height</span><span> </span><span>=</span><span> </span><span>480.0f</span><span>;</span></p><p><span>	</span><span>// Adjust resolution based on current video mode set.</span></p><p><span>	</span><span>DWORD </span><span>videoFlags</span><span> </span><span>=</span><span> </span><span>XGetVideoFlags</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_HDTV_1080i</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>width</span><span> </span><span>=</span><span> </span><span>1920</span><span>;</span></p><p><span>		</span><span>height</span><span> </span><span>=</span><span> </span><span>1080</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_HDTV_720p</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>width</span><span> </span><span>=</span><span> </span><span>1280</span><span>;</span></p><p><span>		</span><span>height</span><span> </span><span>=</span><span> </span><span>720</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>(</span><span>videoFlags</span><span> </span><span>&amp;</span><span> </span><span>XC_VIDEO_FLAGS_HDTV_480p</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>width</span><span> </span><span>=</span><span> </span><span>720</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x0</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y0</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>width</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>height</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>x0</span><span> </span><span>=</span><span> </span><span>x_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>y0</span><span> </span><span>=</span><span> </span><span>y_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>x1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>width</span><span> </span><span>-</span><span> </span><span>x_off</span><span>;</span></p><p><span>	</span><span>rasterizer_globals</span><span>.</span><span>frame_bounds</span><span>.</span><span>y1</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>height</span><span> </span><span>-</span><span> </span><span>y_off</span><span>;</span></p><p><span>}</span></p><p><span>bool</span><span> </span><span>rasterizer_device_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>D3DPRESENT_PARAMETERS </span><span>PresentParams</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>}</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferWidth</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x0</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferHeight</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_A8R8G8B8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>EnableAutoDepthStencil</span><span> </span><span>=</span><span> </span><span>TRUE</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>AutoDepthStencilFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_D24S8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>=</span><span> </span><span>D3DPRESENTFLAG_LOCKABLE_BACKBUFFER</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_RefreshRateInHz</span><span> </span><span>=</span><span> </span><span>g_refresh_rate_hz</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>=</span><span> </span><span>D3DPRESENT_INTERVAL_IMMEDIATE</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>// Check if wide screen mode is enabled.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>g_widescreen_enabled</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_WIDESCREEN</span><span>;</span></p><p><span>	</span><span>// Check if the video mode supports progressive scan.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>g_progressive_scan_enabled</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_PROGRESSIVE</span><span>;</span></p><p><span>	</span><span>// Check the resolution width to see if 1080i is enabled.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>==</span><span> </span><span>1920</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>&amp;=</span><span> </span><span>~</span><span>D3DPRESENTFLAG_PROGRESSIVE</span><span>;</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_INTERLACED</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>g_pDirect3D</span><span>-&gt;</span><span>CreateDevice</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DDEVTYPE_HAL</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>D3DCREATE_HARDWARE_VERTEXPROCESSING</span><span>,</span><span> </span><span>&amp;</span><span>PresentParams</span><span>,</span><span> </span><span>&amp;</span><span>g_pD3DDevice</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0020 seconds] -->
</div>



<p>Booting up the game with these changes gives some less than pleasing results. Looking at the main menu the first thing we can see is the blue filter is now gone, and there’s some repeating line pattern strewn across the screen. Looking a bit closer and we can see part of the water geometry is also cut off, suspiciously at where the old 640 width would be compared to the new width of 720.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/main_menu_issues.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/main_menu_issues.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/main_menu_issues.png 720w, https://icode4.coffee/wp-content/uploads/main_menu_issues-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Rendering issues in the main menu</figcaption></figure></div>



<h2>Making efficient use of D3D memory</h2>



<p>The Xbox uses a unified memory architecture meaning the CPU and GPU share the same RAM. Unlike a PC there’s no concept of creating a D3D allocation in VRAM and having the GPU manage it. On Xbox the CPU can create an allocation for textures, render targets, vertex buffers, etc, and pass the allocation address directly to the GPU. This gives developers the ability to allocate one buffer and have multiple resource “views” that utilize the memory. Consider the following code which shows how to create a render target letting D3D do all the work and how to create a render target by hand:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a697258596704" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>// How to create a render target with D3D:</span></p><p><span>IDirect3DSurface8</span><span>*</span><span> </span><span>pRenderTarget</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p><p><span>g_pD3DDevice</span><span>-&gt;</span><span>CreateRenderTarget</span><span>(</span><span>/* width */</span><span> </span><span>1024</span><span>,</span><span> </span><span>/* height */</span><span> </span><span>1024</span><span>,</span><span> </span><span>/* format */</span><span> </span><span>D3DFMT_A8R8G8B8</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>FALSE</span><span>,</span><span> </span><span>&amp;</span><span>pRenderTarget</span><span>)</span><span>;</span></p><p><span>// How to create a render target by hand:</span></p><p><span>// Allocate and initialize the texture header.</span></p><p><span>IDirect3DSurface8</span><span>*</span><span> </span><span>pRenderTarget</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DSurface8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DSurface8</span><span>)</span><span>)</span><span>;</span></p><p><span>DWORD </span><span>textureSize</span><span> </span><span>=</span><span> </span><span>XGSetTextureHeader</span><span>(</span><span>/* width */</span><span> </span><span>1024</span><span>,</span><span> </span><span>/* height */</span><span> </span><span>1024</span><span>,</span><span> </span><span>/* levels */</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>/* format */</span><span> </span><span>D3DFMT_A8R8G8B8</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>pRenderTarget</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>// Allocate memory for the pixel buffer.</span></p><p><span>void</span><span>*</span><span> </span><span>pSurfaceBuffer</span><span> </span><span>=</span><span> </span><span>D3D_AllocContiguousMemory</span><span>(</span><span>/* size */</span><span> </span><span>textureSize</span><span>,</span><span> </span><span>/* alignment */</span><span> </span><span>D3DSURFACE_ALIGNMENT</span><span>)</span><span>;</span></p><p><span>pRenderTarget</span><span>-&gt;</span><span>Register</span><span>(</span><span>pSurfaceBuffer</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>While the latter looks more messy it provides greater control to the developer and is something Halo 2 makes great use of to conserve memory for all the render targets it uses. In total Halo 2 has approximately 25 different render targets it uses but there’s only 4-5 unique buffers allocated for them which saves a lot of memory. So what does this have to do with the issues we saw in the main menu? Well if Halo 2 is creating render targets by hand it’ll need to encode the width and height of the surface into the header of the render target structure. If it’s hard coded to use 640×480 resolution it would cause issues that could result in cut off images or repeating line patterns as the pitch of the surface would not match the pitch of the back buffer. Essentially, there’s two different “views” for the same memory but the views see the memory as being of different widths which results in misplaced pixels when spanning each scan line. </p>



<p>Looking around the D3D/raster initialization code I found a function I called rasterizer_primary_targets_initialize that does exactly this. It takes the back, front, and depth buffers created by D3D and creates additional render targets and texture views from them, using hard coded dimensions of 640×480. Here is the C representation of the disassembly:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a69b298037725" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>rasterizer_primary_targets_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get the back buffer, front buffer, and depth buffer surfaces.</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>-</span><span>1</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetDepthStencilSurface</span><span>(</span><span>&amp;</span><span>global_d3d_surface_render_primary_z</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>// Setup texture views for back/front buffers.</span></p><p><span>	</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>2</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>XGSetTextureHeader</span><span>(</span><span>640</span><span>,</span><span> </span><span>480</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>D3DFMT_LIN_A8R8G8B8</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span></p><p><span>			</span><span>global_d3d_texture_render_primary</span><span>[</span><span>i</span><span>]</span><span>,</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>i</span><span>]</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Create a render target surface for the depth buffer that matches the size and format of the back buffer.</span></p><p><span>	</span><span>global_d3d_surface_z_as_target</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DSurface8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DSurface8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>memcpy</span><span>(</span><span>global_d3d_surface_z_as_target</span><span>,</span><span> </span><span>global_d3d_surface_render_primary</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>IDirect3DSurface8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_surface_z_as_target</span><span>-&gt;</span><span>Data</span><span> </span><span>=</span><span> </span><span>global_d3d_surface_render_primary_z</span><span>-&gt;</span><span>Data</span><span>;</span></p><p><span>	</span><span>// Create two textures for the depth buffer, one in ARGB format and one in ABGR format.</span></p><p><span>	</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>XGSetTextureHeader</span><span>(</span><span>640</span><span>,</span><span> </span><span>480</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>D3DFMT_LIN_A8R8G8B8</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span></p><p><span>		</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>0</span><span>]</span><span>,</span><span> </span><span>global_d3d_surface_render_primary_z</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>XGSetTextureHeader</span><span>(</span><span>640</span><span>,</span><span> </span><span>480</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>D3DFMT_LIN_A8B8G8R8</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span></p><p><span>		</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>1</span><span>]</span><span>,</span><span> </span><span>global_d3d_surface_render_primary_z</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
</div>



<p>This is relatively easy to fix, we simply need to hook this function, let it run normally, and then fix up the dimensions of the textures/surfaces afterwards. The pseudo code for this hook can be seen below:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a69f469048573" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>Hook_rasterizer_primary_targets_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Call the trampoline and let the real function complete.</span></p><p><span>	</span><span>bool</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>rasterizer_primary_targets_initialize_trampoline</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Update the dimensions of the surface/textures created to match the resolution of the back buffer.</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>return</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>D3DBaseTexture</span><span>*</span><span> </span><span>pResource</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Calculate the correct pitch for the texture with tiling enabled. This can be different than the normal pitch</span></p><p><span>	</span><span>// value and if set incorrectly will cause a &#34;striping&#34; effect on the back buffer.</span></p><p><span>	</span><span>DWORD </span><span>format</span><span> </span><span>=</span><span> </span><span>(</span><span>pResource</span><span>-&gt;</span><span>Format</span><span> </span><span>&gt;&gt;</span><span> </span><span>8</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>;</span></p><p><span>	</span><span>DWORD </span><span>pitch</span><span> </span><span>=</span><span> </span><span>D3D_CalcTilePitch</span><span>(</span><span>/* width */</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span>,</span><span> </span><span>/* texture format */</span><span> </span><span>format</span><span>)</span><span>;</span></p><p><span>	</span><span>// Set the new dimensions of the texture using the size of the back buffer.</span></p><p><span>	</span><span>XGSetTextureHeader</span><span>(</span><span>/* width */</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span>,</span><span> </span><span>/* height */</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span>,</span></p><p><span>		</span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>format</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>pResource</span><span>,</span><span> </span><span>pResource</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>pitch</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
</div>



<p>There’s one additional thing to note here and it’s that the memory used for the back, front, and depth buffers is a special type of memory known as “tiled” memory. Tiled memory stores the pixel data in a way that’s more efficient to read and write to based on the design of the actual RAM chip’s memory cells. Storing the pixel data in tiled memory decreases the overall bandwidth required when reading and writing these buffers. The gotcha here is that the pitch value for the surface/texture is not always the same as it would be for a texture in normal memory (width * bpp). This is why I call D3D_CalcTilePitch in the the Hack_UpdateD3dPixelContainerForScreenResolution helper function. It will calculate the correct pitch for tiled memory based on the width and bits per pixel for the texture format. If the pitch value is calculated incorrectly (ex: by doing width * bpp) you’ll end up getting a “striping” effect on the back buffer (which affects 1080i video resolutions specifically). If you’re curious what tiled memory looks like if you don’t “un-tile” it here you go:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/tiled_back_buffer.png" target="_blank" rel="noopener"><img loading="lazy" width="1095" height="616" src="https://icode4.coffee/wp-content/uploads/tiled_back_buffer.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/tiled_back_buffer.png 1095w, https://icode4.coffee/wp-content/uploads/tiled_back_buffer-300x169.png 300w, https://icode4.coffee/wp-content/uploads/tiled_back_buffer-768x432.png 768w" sizes="(max-width: 1095px) 100vw, 1095px"/></a><figcaption>D3D back buffer of the main menu in tiled form</figcaption></figure></div>



<p>This is the main menu image from earlier (only in 720p) dumped straight from the back buffer without un-tiling the data. If you squint hard enough you can almost make out the Halo 2 logo in the center. That aside it’s time to test the new patches and see if the modifications to the surface dimensions fixed our issues. Loading up the game with this new set of modifications gives us this:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/main_menu_issues2.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/main_menu_issues2.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/main_menu_issues2.png 720w, https://icode4.coffee/wp-content/uploads/main_menu_issues2-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Main menu with some issues fixed</figcaption></figure></div>



<p>Okay so the striping effect from using the incorrect pitch value in the back/front buffer surfaces is now fixed. However, the water geometry is still cutoff even after we changed the resolutions of all the render targets/textures, right? Well we only updated the <em>primary</em> render targets, we still need to update the intermediate render targets used by the game’s rasterizer, and this is where having game engine specific knowledge comes in handy.</p>



<h2>Resizing the rasterizer targets</h2>



<p>As I mentioned earlier there’s ~25 render targets Halo 2 uses for different passes in the render loop such as detail texture blending, water, reflections, fog, shadows, etc. The game’s rasterizer system allows for creating a render target with child render targets that utilize the same underlying memory. The 25 render targets the game creates are backed by only 4-5 unique memory allocations and uses this parent/child relationship to make efficient use of the memory. When one render target is no longer in use the others are free to use that memory. While most render targets are smaller than the back buffer (ranging from 512×512 all the way down to 64×64) there’s one in particular that needs to match the back buffer resolution which is the texture accumulator target, or taxaccum for short.</p>



<p>The DirectX implementation on Xbox only allows for sampling from 4 textures per pixel shader pass. If you want to render something that uses more than 4 input textures you’ll need to do it in two or more passes. This is what the texaccum layer is for. Objects in the game that use more than 4 textures will first render all the detail textures to the texaccum layer. When the texaccum pass is completed the taxaccum render target will be fed into the lightmap pass as an input and combined with any additional textures for the object along with the lightmap texture to get the final output.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass.png" target="_blank" rel="noopener"><img loading="lazy" width="1901" height="1080" src="https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-1901x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-1901x1080.png 1901w, https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-300x170.png 300w, https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-768x436.png 768w, https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-1536x873.png 1536w, https://icode4.coffee/wp-content/uploads/taxaccum_lightmap_pass-2048x1164.png 2048w" sizes="(max-width: 1901px) 100vw, 1901px"/></a><figcaption>Texaccum and lightmap shader passes</figcaption></figure></div>



<p>Here’s an example using the ground geometry in coagulation. In the texaccum pass the detail textures for the ground geometry are blended together into the texaccum render target. Then in the lightmap pass the texaccum render target is used as an input texture along with a bump map and lightmap texture to create the final image. The reason the water geometry in the main menu is cut off is because it’s being rendered to the texaccum render target which has a hard coded size of 640×480. Now that we’re rendering in larger video resolutions the dimensions of the texaccum target will need to be increased. Looking through the rasterizer initialization code we’ll find a function I called rasterizer_targets_initialize that allocates buffers for the various render targets and initializes them:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6a4508173705" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>rasterizer_targets_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Allocate and initialize the texaccum render target.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>!</span><span>_rasterizer_alloc_and_create_render_target</span><span>(</span><span>1</span><span>,</span><span> </span><span>640</span><span>,</span><span> </span><span>480</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>false</span><span>)</span><span>)</span></p><p><span>		</span><span>return</span><span> </span><span>false</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p><p><span>bool</span><span> </span><span>_rasterizer_alloc_and_create_render_target</span><span>(</span><span>int</span><span> </span><span>target_index</span><span>,</span><span> </span><span>int</span><span> </span><span>width</span><span>,</span><span> </span><span>int</span><span> </span><span>height</span><span>,</span><span> </span><span>int</span><span> </span><span>unk</span><span>,</span><span> </span><span>bool</span><span> </span><span>z_surface</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Calculate the allocation size rounded up to the nearest page size.</span></p><p><span>	</span><span>int</span><span> </span><span>allocationSize</span><span> </span><span>=</span><span> </span><span>(</span><span>(</span><span>(</span><span>(</span><span>width</span><span> </span><span>+</span><span> </span><span>63</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>64</span><span>)</span><span> </span><span>*</span><span> </span><span>height</span><span> </span><span>*</span><span> </span><span>4</span><span>)</span><span> </span><span>+</span><span> </span><span>4095</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>4096</span><span>;</span></p><p><span>	</span><span>// Allocate memory from the game&#39;s self-managed memory pool.</span></p><p><span>	</span><span>void</span><span>*</span><span> </span><span>pPhysicalAllocPtr</span><span> </span><span>=</span><span> </span><span>physical_memory_globals</span><span>.</span><span>hi_stage_address</span><span>[</span><span>physical_memory_globals</span><span>.</span><span>current_stage</span><span>]</span><span> </span><span>-</span><span> </span><span>allocationSize</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pPhysicalAllocPtr</span><span> </span><span>&gt;</span><span> </span><span>physical_memory_globals</span><span>.</span><span>low_stage_address</span><span>[</span><span>physical_memory_globals</span><span>.</span><span>current_stage</span><span>]</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>physical_memory_globals</span><span>.</span><span>hi_stage_address</span><span>[</span><span>physical_memory_globals</span><span>.</span><span>current_stage</span><span>]</span><span> </span><span>=</span><span> </span><span>pPhysicalAllocPtr</span><span>;</span></p><p><span>		</span><span>// Mark the allocated memory as RW write-combine memory.</span></p><p><span>		</span><span>pPhysicalAllocPtr</span><span> </span><span>|=</span><span> </span><span>PHYSICAL_MEM_ADDRESS_MASK</span><span>;</span></p><p><span>		</span><span>XPhysicalProtect</span><span>(</span><span>pPhysicalAllocPtr</span><span>,</span><span> </span><span>allocationSize</span><span>,</span><span> </span><span>PAGE_READWRITE</span><span> </span><span>|</span><span> </span><span>PAGE_WRITECOMBINE</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>return</span><span> </span><span>_rasterizer_create_render_target</span><span>(</span><span>target_index</span><span>,</span><span> </span><span>/* type */</span><span> </span><span>1</span><span>,</span><span> </span><span>width</span><span>,</span><span> </span><span>height</span><span>,</span><span> </span><span>z_surface</span><span>,</span><span> </span><span>/* linear */</span><span> </span><span>true</span><span>,</span><span> </span><span>true</span><span>,</span><span> </span><span>pPhysicalAllocPtr</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>To fix the hard coded dimensions I simply hook the _rasterizer_alloc_and_create_render_target function, check the target_index parameter for the texaccum index, and change the dimensions to match the back buffer size. The pseudo code for the hook looks like this:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6a9168916873" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>bool</span><span> </span><span>Hook__rasterizer_alloc_and_create_render_target</span><span>(</span><span>int</span><span> </span><span>target_index</span><span>,</span><span> </span><span>int</span><span> </span><span>width</span><span>,</span><span> </span><span>int</span><span> </span><span>height</span><span>,</span><span> </span><span>int</span><span> </span><span>unk</span><span>,</span><span> </span><span>bool</span><span> </span><span>z_surface</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Check the rasterizer target index and adjust the surface dimensions accordingly.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>target_index</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Texaccum rasterizer target:</span></p><p><span>		</span><span>width</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span>;</span></p><p><span>		</span><span>height</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Call the trampoline and create the render target.</span></p><p><span>	</span><span>return</span><span> </span><span>_rasterizer_alloc_and_create_render_target_trampoline</span><span>(</span><span>target_index</span><span>,</span><span> </span><span>width</span><span>,</span><span> </span><span>height</span><span>,</span><span> </span><span>unk</span><span>,</span><span> </span><span>z_surface</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Running the game with these modifications we can see the water geometry is no longer cutoff, and loading into a map doesn’t show any noticeable rendering issues:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/main_menu_texaccum_fixed.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/main_menu_texaccum_fixed.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/main_menu_texaccum_fixed.png 720w, https://icode4.coffee/wp-content/uploads/main_menu_texaccum_fixed-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Main menu with the texaccum layer fixed</figcaption></figure></div>



<p>The game looks okay in 480p but the real goal of this work is to get the game playing decently in 720p, and maybe booting in 1080p, even though it won’t play well at that resolution nor will the Xbox output a 1080p video signal (but I can still take some sweet screenshots!). We still need to fix the missing blue filter on the main menu but in the interest of keeping this post as short as possible I’m going to skip the blue filter fix as it’s not very interesting anyway (spoiler: it was just a simple size check that needed updating). Changing the video settings on my console to 720p and booting the game results in… well it results in the game crashing on startup. The reason? Due to the increased size of the front/back/depth buffers and rasterizer targets we’re out of memory, or at least, out of memory that the game is able to use.</p>







<p>The original Xbox had two different console types, the retail consoles that consumers would buy with 64MB of RAM, and a development console (or dev kit/debug console) that was used by game developers with 128MB of RAM. The extra RAM on the development console helped developers debug their games and run additional test code during the development process. The motherboard used by both console types is nearly identical with the main difference being the software they run and the additional RAM chips on the dev kit motherboards (they also have a slightly different south bridge for security purposes but that’s not really important here). However, retail motherboards still had the placements for the 4 additional RAM chips and over the years people found that they could solder in the missing RAM chips and run a modified Xbox kernel to give them access to the extra memory. Retail games won’t make any use of that extra memory, but homebrew applications like Xbox Media Center will use it for things like video decoding when watching movies or streaming media. </p>



<p>I’ve neglected to mention that up until this point the only way I was able to get the game to boot with the increased back buffer size is by running it on a console with 128MB of RAM and using an Xbox kernel with support for the additional 64MB of RAM. As-is the game will not utilize any of the additional memory, however, this kernel has additional logic to “force” certain types of memory allocations into the upper 64MB region to make space for allocations that must be in the lower 64MB region. Going into this project I already knew that the only way this game would boot in 720p would be with the RAM upgrade. In fact, the only way to get it to boot in proper 480p resolution without the RAM upgrade was to steal some memory back from the game’s in-memory texture cache which ends up causing additional texture pop-in. But all of this can be fixed by patching the game’s memory allocator to support the additional 64MB of RAM.</p>



<h2>Halo 2’s memory management</h2>



<p>It’s quite common for game developers to write their own memory management system, especially on older hardware where the built-in memory allocator may be slow or even buggy. Developers would use the built-in memory allocator to make a couple large allocations that they’d wrap in their own allocator to chunk it up and dish out as needed. At startup Halo 2 creates one large allocation that uses ~48.9MB of the available 64MB of RAM on the console, basically, every last page of memory they could possibly get once you account for the Xbox kernel and game executable. This region of memory is then chunked up for various subsystems in the game such as level metadata, texture, geometry, animation, and sound caches, rasterizer targets, network and simulation resources, etc. </p>



<p>In order to patch Halo 2’s memory allocator I was going to need a way to visualize memory usage so I could see where things are located and how much space is being used. I spent a few nights working on a tool (<a rel="noreferrer noopener" href="https://github.com/grimdoomer/XboxImageGrabber" data-type="URL" data-id="https://github.com/grimdoomer/XboxImageGrabber" target="_blank">GitHub: XboxImageGrabber</a>) that would walk the page table entries for all the RAM on the console and create a crude bitmap that color codes various chunks of data, allowing me to create a visualization of what memory looks like:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data.png" target="_blank" rel="noopener"><img loading="lazy" width="1697" height="1080" src="https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-1697x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-1697x1080.png 1697w, https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-300x191.png 300w, https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-768x489.png 768w, https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-1536x977.png 1536w, https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-2048x1303.png 2048w, https://icode4.coffee/wp-content/uploads/h2_retail_runtime_data-110x70.png 110w" sizes="(max-width: 1697px) 100vw, 1697px"/></a><figcaption>Memory profile of Halo 2</figcaption></figure></div>



<p>This might look like pixel barf and be hard to interpret but it was really only intended for my own use so I never bothered to make it pretty. The first column on the left shows the memory usage by the Xbox OS. At the very beginning is the Xbox kernel, down in the 0x83000000 region we have the Halo 2 executable and some virtual memory allocations, and at 0x84000000 is the end of the 64MB retail RAM region. This was taken on a console with 128MB of memory so everything after 0x84000000 is the “debug” memory region. The center column shows Halo 2’s memory usage for runtime data and d3d resources. This particular image doesn’t have color coding enabled so you can get an idea of how much memory the game reserves for this runtime data region. That blue blob? That’s the ~49MB allocation the game makes on startup. The column on the right shows combined memory usage, basically what has been allocated and what is free with no further classification for what the memory is used for. We can see that the stock version of the game uses almost every available page of memory it can get, sparing only a few as a safety net.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile.png" target="_blank" rel="noopener"><img loading="lazy" width="1697" height="1080" src="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1697x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1697x1080.png 1697w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-300x191.png 300w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-768x489.png 768w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1536x977.png 1536w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-2048x1303.png 2048w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-110x70.png 110w" sizes="(max-width: 1697px) 100vw, 1697px"/></a><figcaption>Halo 2 memory profile with data classification</figcaption></figure></div>



<p>Here’s the same memory profile image with the runtime data region color coded to show the various subsystem allocations. There’s actually a few more not pictured here but they aren’t too important. The ones we’re concerned with are going to be tag data, texture cache, geometry cache, and rasterizer buffer. The runtime data allocation appearing immediately after the Xbox kernel is not a coincidence, it’s purposefully allocated at a hard coded address of 0x80061000. The “tag data” region is actually all the metadata for every object in a map file in the form of C-structs that have been serialized using the predetermined base address of 0x80061000. The tag data system is designed to be as flexible and performant as possible, and, in my opinion the inner workings are really a feat of engineering. I could write an entire blog post about the inner workings of the tag data system and why I think it makes the Blam engine one of the most flexible engines ever made, but that isn’t relevant to this post. The key takeaway here is that this data needs to always be at the same address or else the game won’t work. But all of the other data in the runtime region can be moved around at will.</p>



<h4>Patching the memory allocator</h4>



<p>The regions we’ll want to move out of the runtime data buffer are the rasterizer targets (at least the ones we’ll be increasing in size), and the texture and geometry caches so we can increase their size to help reduce pop-in issues. We’ll also want to reduce the size of the runtime data buffer to account for the things we’re removing so we don’t waste any memory by not filling it. The patches for the memory allocator will consist of 3 main changes:</p>



<ol><li>Hooking certain allocation calls and moving them to the debug memory region. </li><li>When these allocations are “released” (ex: when loading a new level) we’ll need to call the appropriate free function.</li><li>Adjusting the size of the runtime data region to reclaim memory that’s no longer being used.</li></ol>



<p>I’ve called the memory allocation function we’ll need to hook physical_memory_malloc, and it’s unfortunately inlined by the compiler which means each “call site” for it will need a unique patch, and the same is true for when an allocation is free’d. The pseudo code for the memory allocator patches looks like this:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6ad123750316" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p></div>
				</td>
						<td><div><p><span>struct</span><span> </span><span>physical_memory_alloc_info</span></p><p><span>{</span></p><p><span>	</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>name</span><span>;</span><span>				</span><span>// Name for the allocation, ex: &#34;texture cache&#34;</span></p><p><span>	</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>override_size</span><span>;</span><span>		</span><span>// If non-zero use this size for the allocation</span></p><p><span>	</span><span>void</span><span>*</span><span> </span><span>address</span><span>;</span><span>					</span><span>// Allocation address</span></p><p><span>}</span><span>;</span></p><p><span>// Enum used to index into Hack_PhysicalMemoryRegionInfoTable</span></p><p><span>enum</span></p><p><span>{</span></p><p><span>	</span><span>PHYS_MEM_REGION_RASTERIZER_TEXACCUM_TARGET</span><span>,</span></p><p><span>	</span><span>PHYS_MEM_REGION_GEOMETRY_CACHE</span><span>,</span></p><p><span>	</span><span>PHYS_MEM_REGION_TEXTURE_CACHE</span><span>,</span></p><p><span>}</span><span>;</span></p><p><span>// Global array of tracked allocations:</span></p><p><span>physical_memory_alloc_info </span><span>Hack_PhysicalMemoryRegionInfoTable</span><span>[</span><span>]</span><span> </span><span>=</span></p><p><span>{</span></p><p><span>	</span><span>{</span><span> </span><span>&#34;rasterizer texaccum target&#34;</span><span>,</span><span> 	</span><span>0</span><span>,</span><span> </span><span>NULL</span><span> </span><span>}</span><span>,</span></p><p><span>	</span><span>{</span><span> </span><span>&#34;geometry cache&#34;</span><span>,</span><span> 				</span><span>0</span><span>,</span><span> </span><span>NULL</span><span> </span><span>}</span><span>,</span></p><p><span>	</span><span>{</span><span> </span><span>&#34;texture cache&#34;</span><span>,</span><span> 					</span><span>0</span><span>,</span><span> </span><span>NULL</span><span> </span><span>}</span><span>,</span></p><p><span>}</span><span>;</span></p><p><span>void</span><span>*</span><span> </span><span>Hack_PhysicalMemoryAlloc</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>regionIndex</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>size</span><span>,</span><span> </span><span>int</span><span> </span><span>protect</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get a pointer to the allocation info structure.</span></p><p><span>	</span><span>physical_memory_alloc_info</span><span>*</span><span> </span><span>pAllocInfo</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>Hack_PhysicalMemoryRegionInfoTable</span><span>[</span><span>regionIndex</span><span>]</span><span>;</span></p><p><span>	</span><span>// If the override size is specified use it for the allocation.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>override_size</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>size</span><span> </span><span>=</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>override_size</span><span>;</span></p><p><span>	</span><span>// Round the size up to the nearest page interval.</span></p><p><span>	</span><span>size</span><span> </span><span>=</span><span> </span><span>(</span><span>size</span><span> </span><span>+</span><span> </span><span>PAGE_SIZE</span><span>-</span><span>1</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>(</span><span>PAGE_SIZE</span><span>-</span><span>1</span><span>)</span><span>;</span></p><p><span>	</span><span>// TODO: Allocate memory from the debug region...</span></p><p><span>	</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span></p><p><span>		</span><span>DebugBreak</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Debug print the allocation info.</span></p><p><span>	</span><span>DbgPrint</span><span>(</span><span>&#34;physical_memory_malloc %s %ld at 0x%08x\n&#34;</span><span>,</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>name</span><span>,</span><span> </span><span>size</span><span>,</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span>)</span><span>;</span></p><p><span>	</span><span>return</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span>;</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>Hack_PhysicalMemoryFree</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>regionIndex</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get a pointer to the allocation info structure.</span></p><p><span>	</span><span>physical_memory_alloc_info</span><span>*</span><span> </span><span>pAllocInfo</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>Hack_PhysicalMemoryRegionInfoTable</span><span>[</span><span>regionIndex</span><span>]</span><span>;</span></p><p><span>	</span><span>// If the allocation is valid free it.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// TODO: Free the allocation...</span></p><p><span>		</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0010 seconds] -->
</div>



<p>This allows me to hook individual call sites where the physical_memory_malloc function is inlined using a patch like so:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6b2629728691" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>push</span><span>	</span><span>404h</span><span>								</span><span>; PAGE_WRITECOMBINE | PAGE_READWRITE</span></p><p><span>push</span><span>	</span><span>ecx</span><span>									</span><span>; size, calculated earlier in function</span></p><p><span>push</span><span>	</span><span>PHYS</span><span>_</span><span>MEM</span><span>_</span><span>REGION</span><span>_</span><span>GEOMETRY</span><span>_</span><span>CACHE</span><span>		</span><span>; regionIndex</span></p><p><span>mov</span><span>		</span><span>eax</span><span>,</span><span> </span><span>Hack</span><span>_</span><span>PhysicalMemoryAlloc</span></p><p><span>call</span><span>	</span><span>eax</span><span>									</span><span>; Call our helper function to perform the allocation</span></p><p><span>; Jump over code we no longer need to execute.</span></p><p><span>push</span><span>	</span><span>0012DA73h</span></p><p><span>ret</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now you’re probably wondering why the lines that perform the allocation and free calls in the pseudo code above are labeled as “TODO”, and that’s because allocating physical contiguous memory in the debug memory region is problematic… </p>



<h2>Xbox memory architecture</h2>



<p>Earlier I mentioned that the original Xbox uses a unified memory design allowing the CPU and GPU to share the same RAM. When the CPU provides a memory address to the GPU (ex: address of a texture or vertex buffer) it must use a physical memory address and the memory span must be contiguous (meaning the pages backing the allocation are all consecutive with no gaps). This is because the GPU doesn’t have any concept of page tables or virtual memory addresses so it’s unable to translate virtual addresses to perform memory accesses. It simply treats the memory address as an offset from the start of RAM and reads data as needed starting from this offset. There’s specific APIs for allocating “video” or “GPU” memory but these are all wrappers for allocating memory that is physical and contiguous.</p>



<p>The Xbox kernel provides various functions for allocating memory but there’s two main types of memory allocations that can be made. Physical memory which is also contiguous, and virtual memory which is not explicitly contiguous (it can end up being contiguous by chance but it’s virtual memory so it’s not required to be contiguous). On an unmodified retail Xbox console there’s only 64MB of RAM and the entire 64MB region can be used to make physical or virtual allocations. When using a console with 128MB of RAM and kernel with extra RAM support only the first 64MB of RAM can be used for physical allocations, but virtual allocations can be made anywhere in the 128MB region. If you try to make a physical allocation and there’s not enough free contiguous memory in the first 64MB of RAM, the kernel will attempt to relocate virtual allocations into the upper 64MB region to satisfy the allocation request.</p>



<p>This was done on purpose to provide a closer experience to the retail hardware for developers to work with. The additional 64MB of “debug” memory was to allow developers to run extra code and profiling tools that consumed memory without having to take away from the memory their game would normally have. There’s no benefit to allowing developers to allocate more “video” memory in the debug region as it doesn’t exist on retail hardware and can’t be used in a final version of the game. However, this limits me in terms of how much additional memory I can give Halo 2 for video allocations.</p>



<h2>Hot patching the Xbox kernel</h2>



<p>Looking at the memory profile image above we can see the “runtime data region” consumes most of the first 64MB of RAM. Not everything allocated in this region is required to be “video” memory (and thus needs to be in physical memory), so I could move as many things as possible out of that region and into the upper 64MB of RAM as a virtual allocation. But this gets quite messy to track down all of the allocations being made and patch each call site, and it won’t give us as much memory as we really need for additional performance tweaks later on. Rather than go for a sub-par solution I decided to take matters (or memory) into my own hands and try something crazy.</p>



<p>I ran some tests where I made a video memory allocation “by hand” and just stole some unused page table entries for the upper 64MB address space. Instead of asking the kernel to allocate the memory for me, I just “commandeered” the page tables and did it myself. Feeding this address to the GPU for rendering worked just fine which meant that the limitation of only being able to allocate “video” memory in the lower 64MB of RAM is not a hardware limitation it’s a software one. The only thing preventing me from making physical memory allocations in the upper 64MB of RAM is the kernel. After spending a few nights digging through the memory management functions in the Xbox kernel I found the blocker that was preventing me from making physical allocations passed the 64MB mark:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/max_pfn_check-1.png" target="_blank" rel="noopener"><img loading="lazy" width="879" height="516" src="https://icode4.coffee/wp-content/uploads/max_pfn_check-1.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/max_pfn_check-1.png 879w, https://icode4.coffee/wp-content/uploads/max_pfn_check-1-300x176.png 300w, https://icode4.coffee/wp-content/uploads/max_pfn_check-1-768x451.png 768w" sizes="(max-width: 879px) 100vw, 879px"/></a><figcaption>Max PFN check in MmAllocateContiguousMemoryEx</figcaption></figure></div>



<p>The MmAllocateContiguousMemoryEx function used to allocate contiguous physical memory takes in two parameters that let the caller specify the lowest and highest acceptable addresses for the memory allocation. This is how Halo 2 gets the runtime data region to always be at the address 0x80061000, by specifying the highest acceptable address as 0x61000 (the upper most bits are masked out). The kernel takes both of these parameters and converts them into page frame numbers (basically an index for the page of memory that corresponds to that address), and checks they’re less than or equal to this constant I called MAX_USABLE_PFN. The MAX_USABLE_PFN constant corresponds to the address 0x83FE0000, which is equal to 64MB – 128KB. What is the significance of this value? The top 128kb of RAM is always reserved with 64KB used as a “scratch” region for the GPU and the other 64KB used for the CPU page tables. I believe the GPU “scratch” region is used for storing data related to depth buffer compression tags and possibly processed vertex data that is still passing through the shader pipeline, but I’ve never actually confirmed this myself.</p>



<p>This check is our blocker for allocating physical memory in the upper 64MB of RAM. I changed this value at runtime after my test application loaded and confirmed I was able to allocate memory in the upper 64MB of RAM using MmAllocateContiguousMemoryEx, and the GPU was able to use that memory just fine. So now all I needed to do is write a function to hot patch the Xbox kernel when the game boots, no big deal right? For this patch I’ll first make sure the console has 128MB of RAM installed, then resolve the address of the MmAllocateContiguousMemoryEx function, search for the “mov edx, 0x3FDF” instruction, and patch it to use a new “MAX_USABLE_PFN” value suitable for 128MB RAM configuration. Here’s the pseudo code for the patch:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6b6405681268" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>PatchMaxPFN</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Search for the max PFN value.</span></p><p><span>	</span><span>BYTE</span><span>*</span><span> </span><span>pPtr</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>pMmAllocateContiguousMemoryEx</span><span>;</span></p><p><span>	</span><span>BYTE</span><span>*</span><span> </span><span>pEndPtr</span><span> </span><span>=</span><span> </span><span>(</span><span>BYTE</span><span>*</span><span>)</span><span>pMmAllocateContiguousMemoryEx</span><span> </span><span>+</span><span> </span><span>0x80</span><span>;</span></p><p><span>	</span><span>while</span><span> </span><span>(</span><span>pPtr</span><span> </span><span>&lt;</span><span> </span><span>pEndPtr</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Check for the max PFN value.</span></p><p><span>		</span><span>if</span><span> </span><span>(</span><span>*</span><span>(</span><span>DWORD</span><span>*</span><span>)</span><span>pPtr</span><span> </span><span>==</span><span> </span><span>0x00003FDF</span><span>)</span></p><p><span>		</span><span>{</span></p><p><span>			</span><span>_asm</span></p><p><span>			</span><span>{</span></p><p><span>				</span><span>// Disable write protect.</span></p><p><span>				</span><span>pushf</span></p><p><span>				</span><span>cli</span><span>							</span><span>// Disable interrupts</span></p><p><span>				</span><span>mov		</span><span>eax</span><span>,</span><span> </span><span>cr0</span><span>			</span><span>// Get the control register value</span></p><p><span>				</span><span>push	</span><span>eax</span><span>					</span><span>// Save it for later</span></p><p><span>				</span><span>and</span><span>		</span><span>eax</span><span>,</span><span> </span><span>0xFFFEFFFF</span><span>		</span><span>// Disable write-protect</span></p><p><span>				</span><span>mov		</span><span>cr0</span><span>,</span><span> </span><span>eax</span></p><p><span>				</span><span>// Update the max PFN to use the 128MB limit value.</span></p><p><span>				</span><span>mov		</span><span>eax</span><span>,</span><span> </span><span>pPtr</span></p><p><span>				</span><span>mov		</span><span>dword </span><span>ptr</span><span> </span><span>[</span><span>eax</span><span>]</span><span>,</span><span> </span><span>0x00007FCF</span></p><p><span>				</span><span>// Re-enable write-protect.</span></p><p><span>				</span><span>pop		</span><span>eax</span></p><p><span>				</span><span>mov		</span><span>cr0</span><span>,</span><span> </span><span>eax</span><span>			</span><span>// Re-enable write-protect</span></p><p><span>				</span><span>popf</span></p><p><span>			</span><span>}</span></p><p><span>			</span><span>return</span><span> </span><span>true</span><span>;</span></p><p><span>		</span><span>}</span></p><p><span>		</span><span>// Next round.</span></p><p><span>		</span><span>pPtr</span><span>++</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Failed to patch max PFN value.</span></p><p><span>	</span><span>return</span><span> </span><span>false</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Now that the memory allocation problems are solved we can fill in the two missing lines from the Hack_PhysicalMemoryAlloc/Hack_PhysicalMemoryFree functions above to use MmAllocateContiguousMemoryEx and MmFreeContiguousMemory. Once we hot patch the kernel we can call MmAllocateContiguousMemoryEx using a lowest acceptable address of 0 and highest acceptable address of 0xFFFFFFFF (which the function will override with our new MAX_USABLE_PFN value). The kernel will walk the page tables in reverse starting from the highest acceptable page number and search for a span of free pages large enough to satisfy the allocation request. This will guarantee the upper 64MB of RAM will take preference during allocation but allows using any available space in all 128MB of RAM to satisfy the request.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6ba931694689" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p></div>
				</td>
						<td><div><p><span>void</span><span>*</span><span> </span><span>Hack_PhysicalMemoryAlloc</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>regionIndex</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>int</span><span> </span><span>size</span><span>,</span><span> </span><span>int</span><span> </span><span>protect</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get a pointer to the allocation info structure.</span></p><p><span>	</span><span>physical_memory_alloc_info</span><span>*</span><span> </span><span>pAllocInfo</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>Hack_PhysicalMemoryRegionInfoTable</span><span>[</span><span>regionIndex</span><span>]</span><span>;</span></p><p><span>	</span><span>// If the override size is specified use it for the allocation.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>override_size</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>size</span><span> </span><span>=</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>override_size</span><span>;</span></p><p><span>	</span><span>// Round the size up to the nearest page interval.</span></p><p><span>	</span><span>size</span><span> </span><span>=</span><span> </span><span>(</span><span>size</span><span> </span><span>+</span><span> </span><span>PAGE_SIZE</span><span>-</span><span>1</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>(</span><span>PAGE_SIZE</span><span>-</span><span>1</span><span>)</span><span>;</span></p><p><span>	</span><span>// Allocate physical contiguous memory (using the entire 128MB address space).</span></p><p><span>	</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>=</span><span> </span><span>MmAllocateContiguousMemoryEx</span><span>(</span><span>size</span><span>,</span><span> </span><span>/* LowestAcceptableAddress */</span><span> </span><span>0</span><span>,</span><span> </span><span>/* HighestAcceptableAddress */</span><span> </span><span>0xFFFFFFFF</span><span>,</span><span> </span><span>/* Alignment */</span><span> </span><span>PAGE_SIZE</span><span>,</span><span> </span><span>/* PageAccess */</span><span> </span><span>protect</span><span>)</span><span>;</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span></p><p><span>		</span><span>DebugBreak</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Debug print the allocation info.</span></p><p><span>	</span><span>DbgPrint</span><span>(</span><span>&#34;physical_memory_malloc %s %ld at 0x%08x\n&#34;</span><span>,</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>name</span><span>,</span><span> </span><span>size</span><span>,</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span>)</span><span>;</span></p><p><span>	</span><span>return</span><span> </span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span>;</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>Hack_PhysicalMemoryFree</span><span>(</span><span>unsigned</span><span> </span><span>int</span><span> </span><span>regionIndex</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get a pointer to the allocation info structure.</span></p><p><span>	</span><span>physical_memory_alloc_info</span><span>*</span><span> </span><span>pAllocInfo</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>Hack_PhysicalMemoryRegionInfoTable</span><span>[</span><span>regionIndex</span><span>]</span><span>;</span></p><p><span>	</span><span>// If the allocation is valid free it.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Free the allocation.</span></p><p><span>		</span><span>MmFreeContiguousMemory</span><span>(</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span>)</span><span>;</span></p><p><span>		</span><span>pAllocInfo</span><span>-&gt;</span><span>address</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
</div>



<h4>Visualizing the results</h4>



<p>That was a lot of work but the results are well worth it. As I mentioned earlier the only way to get the game to run in 720p or higher is with a RAM upgrade. Even running the game in proper 480p on a console without the RAM upgrade requires stealing memory back from the game to offset the additional memory requirements, which exacerbates the texture pop-in issues that are prevalent even in the game’s unmodified form. I’ve rambled on about memory management enough, here’s what the game looks like in 720p:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/halo_2_720p.png" target="_blank" rel="noopener"><img loading="lazy" width="1280" height="720" src="https://icode4.coffee/wp-content/uploads/halo_2_720p.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/halo_2_720p.png 1280w, https://icode4.coffee/wp-content/uploads/halo_2_720p-300x169.png 300w, https://icode4.coffee/wp-content/uploads/halo_2_720p-768x432.png 768w" sizes="(max-width: 1280px) 100vw, 1280px"/></a><figcaption>Zanzibar beach in 720p</figcaption></figure></div>



<p>It looks great! But it doesn’t play great… The FPS is noticeably lower to the point where it’s dipping to 10 FPS or lower in heavy scenes. While I was expecting a performance hit I wasn’t expecting it to be this bad, but that’s okay because there’s things we can do to improve this quite a bit. Before that, lets give 1080p a try and see what it looks like. Remember that while the game is rendering natively in 1080p the Xbox console is only able to output a 1080i video signal. However, by dumping the D3D back buffer directly I’m able to get a proper 1080p screenshot before the GPU converts it into half frames for the video encoder to display on screen:</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/1080p_zanzibar.png" target="_blank" rel="noopener"><img loading="lazy" width="1920" height="1080" src="https://icode4.coffee/wp-content/uploads/1080p_zanzibar-1920x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/1080p_zanzibar.png 1920w, https://icode4.coffee/wp-content/uploads/1080p_zanzibar-300x169.png 300w, https://icode4.coffee/wp-content/uploads/1080p_zanzibar-768x432.png 768w, https://icode4.coffee/wp-content/uploads/1080p_zanzibar-1536x864.png 1536w" sizes="(max-width: 1920px) 100vw, 1920px"/></a><figcaption>Zanzibar beach in 1080p</figcaption></figure></div>



<h4>Unforeseen consequences</h4>



<p>Okay so this kernel hot patching does have some undesirable side effects which is understandable since I just changed a pretty crucial aspect of how memory management works mid-execution. Hot patching the kernel and letting Halo 2 run works fine until you exit the game without cold rebooting the console. If you do a warm reboot (returning to the dashboard, ejecting the dvd tray, etc) the console is basically “hosed” and the next application/game to run will have severe graphical artifacting, and the console will most likely crash shortly after. This is likely because there’s more changes required to expand the physical memory region outside of the single change I made. I have some theories as to what the remaining issues are but having spent a significant amount of time on memory management patches I decided to take the cop out solution here. To make this more “robust” I added additional patches that would cold reboot the console (which reloads the kernel) whenever you exit the game so all of the side effects of this hot patching are hidden from the end user. This would prove useful later on as there’s additional changes I make that really should be reset after exiting the game and cold rebooting the console solves all of this.</p>







<p>Now that the game is rendering in 720p and 1080p it’s time to address the performance issues and make it playable, at least in 720p. Adding 1080p support is really just a bonus to get nice screenshots and I have no expectations that the console will be able to run the game at that resolution and be “playable”, regardless of what performance improvements I can make. The first step was to get some baseline performance measurements on a stock Xbox console and the god box that doom sent me. The god box also had two different BIOS images, one that overclocked just the CPU, and one that overclocked both CPU and GPU. This would let me get three different measurements: one for stock hardware (no overclocking), one for CPU overclocking, and one for CPU + GPU overclocking. From these measurements I could determine where the performance bottlenecks were and start from there.</p>



<p>I found a particularly heavy area on Zanzibar that I’ll refer to as the “zanzibar benchmark scene”, which was a decent test case for performance benchmarks. While collecting the performance measurements I immediately realized that the FPS between all three setups was almost identical when under heavy load which was extremely suspicious. If overclocking the CPU and GPU show no improvement in performance then the bottleneck was certainly elsewhere. My first thought was I might be maxing the memory bandwidth now that the GPU has a lot more pixel calculations to do and thus a lot more memory to read and write. However, after spending a few nights running tests and bouncing ideas off doom I realized I’d overlooked something very obvious while staring at a performance graph.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2.png" target="_blank" rel="noopener"><img loading="lazy" width="1920" height="961" src="https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-1920x961.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-1920x961.png 1920w, https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-300x150.png 300w, https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-768x384.png 768w, https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-1536x769.png 1536w, https://icode4.coffee/wp-content/uploads/stock_perf_double_buffer-2-2048x1025.png 2048w" sizes="(max-width: 1920px) 100vw, 1920px"/></a><figcaption>Performance graph for stock console at 720p (double buffered)</figcaption></figure></div>



<p>This graph shows GPU use (yellow), CPU use (red), frames per second (blue), and swap stall rate (teal). Initially I didn’t know what “swap stall” was and I couldn’t find any documentation about it in the Xbox SDK docs. But after I realized the game was running with vsync on it made perfect sense, swap stall = swap chain stall, the GPU was stalling because the swap chain was full and vsync was on.</p>



<h4>VSync and swap chains</h4>



<p>Halo 2 runs with vsync on and uses double buffering so it only has 2 buffers in the swap chain (one front buffer and one back buffer). The back buffer is used by the GPU to render the current frame while the front buffer is the previous frame that was rendered and is now being displayed on screen. When the GPU finishes drawing the current frame it needs to swap the back and front buffers (or rotate the swap chain) so the newly completed frame can be drawn on screen and the old one can be used by the GPU for the next frame. But when vsync is on the GPU can only rotate the swap chain at the start of a vertical blanking (vblank) period (when the TV retraces to the top and starts drawing the image from the beginning). If you turn vsync off the GPU can rotate the swap chain at any time, but if the front buffer is only partially displayed on screen when you rotate the swap chain it’ll result in a “tearing” effect on screen (hence why you want vsync on as it prevents this).</p>



<p>The swap stall line in the graph above is the rate at which the GPU had to stall and wait for a vblank period in order to rotate the swap chain. Basically, the GPU isn’t able to render frames fast enough to keep up with the refresh rate of the screen and it ends up having to wait until the next screen refresh to rotate the swap chain. In hindsight this seems so obvious but at the time I was preoccupied with all the hardware modifications I completely forgot about vsync.</p>



<h2>From double to triple buffering</h2>



<p>This is relative easy to fix as we can just increase the number of buffers in the swap chain to 3 which allows us to queue a completed frame and immediately begin processing the next frame, even if the GPU needs to wait for the next vblank before rotating the swap chain. Here’s the updated pseudo code for the rasterizer_device_initialize hook:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6be040131461" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>rasterizer_device_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>D3DPRESENT_PARAMETERS </span><span>PresentParams</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>}</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferWidth</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x0</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferHeight</span><span> </span><span>=</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span> </span><span>-</span><span> </span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>y1</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_A8R8G8B8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>EnableAutoDepthStencil</span><span> </span><span>=</span><span> </span><span>TRUE</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>AutoDepthStencilFormat</span><span> </span><span>=</span><span> </span><span>D3DFMT_D24S8</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>=</span><span> </span><span>D3DPRESENTFLAG_LOCKABLE_BACKBUFFER</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_RefreshRateInHz</span><span> </span><span>=</span><span> </span><span>g_refresh_rate_hz</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>FullScreen_PresentationInterval</span><span> </span><span>=</span><span> </span><span>D3DPRESENT_INTERVAL_IMMEDIATE</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>// Setup back buffer count and swap effect for triple buffering.</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>BackBufferCount</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>SwapEffect</span><span> </span><span>=</span><span> </span><span>D3DSWAPEFFECT_DISCARD</span><span>;</span></p><p><span>	</span><span>PresentParams</span><span>.</span><span>PresentationInterval</span><span> </span><span>=</span><span> </span><span>D3DPRESENT_INTERVAL_ONE</span><span>;</span></p><p><span>	</span><span>// Check if wide screen mode is enabled.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>g_widescreen_enabled</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_WIDESCREEN</span><span>;</span></p><p><span>	</span><span>// Check if the video mode supports progressive scan.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>g_progressive_scan_enabled</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_PROGRESSIVE</span><span>;</span></p><p><span>	</span><span>// Check the resolution width to see if 1080i is enabled.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>rasterizer_globals</span><span>.</span><span>screen_bounds</span><span>.</span><span>x1</span><span> </span><span>==</span><span> </span><span>1920</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>&amp;=</span><span> </span><span>~</span><span>D3DPRESENTFLAG_PROGRESSIVE</span><span>;</span></p><p><span>		</span><span>PresentParams</span><span>.</span><span>Flags</span><span> </span><span>|=</span><span> </span><span>D3DPRESENTFLAG_INTERLACED</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>g_pDirect3D</span><span>-&gt;</span><span>CreateDevice</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DDEVTYPE_HAL</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>D3DCREATE_HARDWARE_VERTEXPROCESSING</span><span>,</span><span> </span><span>&amp;</span><span>PresentParams</span><span>,</span><span> </span><span>&amp;</span><span>g_pD3DDevice</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
</div>



<p>Here I’ve increased the back buffer count to 2 (default is 1), and set the swap effect such that the swap chain will be rotated on each present call. This will give us 3 buffers to work with (2 back and 1 front), but we’ll need to make another modification to the game’s rendering engine to account for this additional buffer. Earlier when I was going through the process of resizing the game’s render targets I showed some code for how the game sets up texture views for the back and front buffers for use in rendering passes:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6c2253055110" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></div>
				</td>
						<td><div><p><span>bool</span><span> </span><span>rasterizer_primary_targets_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Get the back buffer, front buffer, and depth buffer surfaces.</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>-</span><span>1</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetDepthStencilSurface</span><span>(</span><span>&amp;</span><span>global_d3d_surface_render_primary_z</span><span>)</span><span>;</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>IDirect3DTexture8</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>IDirect3DTexture8</span><span>)</span><span>)</span><span>;</span></p><p><span>	</span><span>// Setup texture views for back/front buffers.</span></p><p><span>	</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>2</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>XGSetTextureHeader</span><span>(</span><span>640</span><span>,</span><span> </span><span>480</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>D3DFMT_LIN_A8R8G8B8</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span></p><p><span>			</span><span>global_d3d_texture_render_primary</span><span>[</span><span>i</span><span>]</span><span>,</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>i</span><span>]</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
</div>



<p>Each frame after the game calls Present() it’ll swap the Data field in global_d3d_surface_render_primary[0]/[1] and global_d3d_texture_render_primary[0]/[1] so they point to the correct memory for the new back and front buffers. This works fine when the game is double buffered but now that we introduced a third buffer into the swap chain we’ll need to account for this after the game calls Present(). We’ll also need to update the rasterizer_primary_targets_initialize hook from earlier to initialize these buffers correctly before the first frame is drawn. Here is the pseudo code for these functions:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6c6914071783" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>Hook_IDirect3DDevice8_Swap</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Call the trampoline and let the real function run.</span></p><p><span>	</span><span>IDirect3DDevice8_Swap_trampoline</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Check if triple buffering is enable.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>Hack_TripleBufferingEnabled</span><span> </span><span>==</span><span> </span><span>false</span><span>)</span></p><p><span>		</span><span>return</span><span>;</span></p><p><span>	</span><span>// Release references to the old back buffer.</span></p><p><span>	</span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Release</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_surface_render_primary</span><span>[</span><span>1</span><span>]</span><span>-&gt;</span><span>Release</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Get the new back buffer and increment the reference count twice.</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>// Update the Data field for the back buffer textures.</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span> </span><span>=</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span>;</span></p><p><span>	</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span>-&gt;</span><span>Data</span><span> </span><span>=</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span>;</span></p><p><span>}</span></p><p><span>bool</span><span> </span><span>Hook_rasterizer_primary_targets_initialize</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>// Call the trampoline and let the real function complete.</span></p><p><span>	</span><span>bool</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>rasterizer_primary_targets_initialize_trampoline</span><span>(</span><span>)</span><span>;</span></p><p><span>	</span><span>// Check if triple buffering is enabled.</span></p><p><span>	</span><span>if</span><span> </span><span>(</span><span>Hack_TripleBufferingEnabled</span><span> </span><span>!=</span><span> </span><span>true</span><span>)</span></p><p><span>	</span><span>{</span></p><p><span>		</span><span>// Set both primary render surfaces to point to the active back buffer.</span></p><p><span>		</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>		</span><span>global_d3d_device</span><span>-&gt;</span><span>GetBackBuffer</span><span>(</span><span>0</span><span>,</span><span> </span><span>D3DBACKBUFFER_TYPE_MONO</span><span>,</span><span> </span><span>&amp;</span><span>global_d3d_surface_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>		</span><span>// Update the Data field for the back buffer textures.</span></p><p><span>		</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span> </span><span>=</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span>;</span></p><p><span>		</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span>-&gt;</span><span>Data</span><span> </span><span>=</span><span> </span><span>global_d3d_surface_render_primary</span><span>[</span><span>0</span><span>]</span><span>-&gt;</span><span>Data</span><span>;</span></p><p><span>	</span><span>}</span></p><p><span>	</span><span>// Update the dimensions of the surface/textures created to match the resolution of the back buffer.</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_render_primary</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_render_primary</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>Hack_UpdateD3dPixelContainerForScreenResolution</span><span>(</span><span>global_d3d_texture_z_as_target</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span></p><p><span>	</span><span>return</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
</div>



<p>With this change global_d3d_surface_render_primary[0]/[1] and global_d3d_texture_render_primary[0]/[1] will always reference the current back buffer. After the Swap hook returns the game will still swap global_d3d_surface_render_primary[0]/[1] and global_d3d_texture_render_primary[0]/[1] internally but this is basically a no-op since they point to the same underlying memory. Now, you might be thinking global_d3d_surface_render_primary[1] is supposed to point to the front buffer per the game’s original implementation, so what happens now that global_d3d_surface_render_primary[1] always points to the back buffer? And the answer, is nothing. The game never used the front buffer because it can’t do anything meaningful with it while it’s being drawn to screen. It only held the pointer so it could swap the surfaces every frame. With these changes in place I loaded up the Zanzibar benchmark scene and collected some new performance measurements:</p>



<figure><a href="https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1.png" target="_blank" rel="noopener"><img loading="lazy" width="1920" height="962" src="https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-1920x962.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-1920x962.png 1920w, https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-300x150.png 300w, https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-768x385.png 768w, https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-1536x769.png 1536w, https://icode4.coffee/wp-content/uploads/stock_perf_triple_buffer-1-2048x1026.png 2048w" sizes="(max-width: 1920px) 100vw, 1920px"/></a><figcaption>Performance graph for stock console at 720p (triple buffered)</figcaption></figure>



<p>As we can see the swap stall line is gone and the FPS is sitting at ~22 which is +~3 FPS higher than before. You might be thinking that a 3 FPS increase isn’t really much but when the game is capped at 30 FPS this is actually a 10% increase which is pretty nice. Also remember that the main goal here was to eliminate the swap stall which prevented the GPU from running as fast as it could. Looking at the graph some more we can see the GPU is now maxed! This might seem bad but we now know the GPU is the bottleneck. We’re still running on stock GPU clock speed and once we overclock the GPU the performance should increase quite a bit.</p>



<h2>Overclocking the GPU</h2>



<p>I spent a few nights digging through some PIX traces, running tests, and trying to find any other low hanging fruit for cheap performance gains. I was able to get another +1-2 FPS by tiling the texaccum render target but it seemed like that was all I was going to get for cheap gains. There’s one or two ideas I had that might get some performance increase but they required a decent amount of changes and I wasn’t sure if the end result would even get me a 1 FPS increase, so I decided to leave it alone and maybe loop back on it another day. With the changes to tile the texaccum render target the Zanzibar benchmark scene was sitting at 23-24 FPS which was a solid improvement over the original ~19 FPS. Now it was time to turn to overclocking, and running the Zanzibar benchmark scene on the god box with overclocked GPU gave a solid 27-28 FPS. Running around the map felt smooth and the FPS was typically holding at a steady 30 FPS, though there were still some areas (like the benchmark scene) where the FPS would drop. Overall I considered it to be highly playable and was relatively satisfied with the results. </p>



<p>The only problem is that the god box is running a one-off bespoke BIOS image that doom made for it. While the GPU overclocking settings could be patched into other community BIOS images it wouldn’t be great if the requirement to run this HD patch was “patch your BIOS image and reflash it to your console”. Luckily I wouldn’t have to resort to that because the GPU clock generator can be controlled entirely by memory mapped IO registers. Using these registers you can control the coefficients for the clock generator and change the clock speed on the fly. So for this next patch I’m going to have the game dynamically overclock the GPU on startup.</p>



<h4>Adjusting the clock speed</h4>



<p>The clock signal for the GPU is calculated as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6cb307391312" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>NVPLL_COEFF (32 bits):</p><p>	Bits 0-7: M</p><p>	Bits 8-15: N</p><p>	Bits 16-18: P</p><p>BASE_CLK = 16.6667 Mhz</p><p>nvclk = (N * BASE_CLK / (1 &lt;&lt; P) / M)</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>The M and P values are set to 1 by default, and BASE_CLK is always 16.6667 Mhz which is sourced from a crystal on the motherboard. So the formula can be shortened to: (N * 16.6667) / 2. We’ll be modifying the N component which is set to 28 by default for a GPU clock speed of 233.33 Mhz. This will let us step the clock speed in increments of ~8 Mhz which I made configurable via an ini file that the patch loads on startup. The pseudo code for overclocking the GPU looks like this:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a6d0055506951" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>Util_OverclockGPU</span><span>(</span><span>int</span><span> </span><span>step</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>/*</span></p><p><span>		NVPLL_COEFF (32 bits):</span></p><p><span>			Bits 0-7: M</span></p><p><span>			Bits 8-15: N</span></p><p><span>			Bits 16-18: P</span></p><p><span>		BASE_CLK = 16.6667 Mhz</span></p><p><span>		nvclk = (N * BASE_CLK / (1 &lt;&lt; P) / M)</span></p><p><span>	*/</span></p><p><span>	</span><span>// Read the current clock config from the NVPLL_COEFF register.</span></p><p><span>	</span><span>DWORD </span><span>clockConfig</span><span> </span><span>=</span><span> </span><span>*</span><span>(</span><span>DWORD</span><span>*</span><span>)</span><span>(</span><span>NV_GPU_BASE_ADDRESS</span><span> </span><span>+</span><span> </span><span>NVPLL_COEFF</span><span>)</span><span>;</span></p><p><span>	</span><span>// Mask out the old N value.</span></p><p><span>	</span><span>clockConfig</span><span> </span><span>&amp;=</span><span> </span><span>~</span><span>0xFF00</span><span>;</span></p><p><span>	</span><span>// Mask in the new N value.</span></p><p><span>	</span><span>clockConfig</span><span> </span><span>|=</span><span> </span><span>(</span><span>(</span><span>step</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>8</span><span>)</span><span>;</span></p><p><span>	</span><span>// Write the new NVPLL_COEFF value.</span></p><p><span>	</span><span>*</span><span>(</span><span>DWORD</span><span>*</span><span>)</span><span>(</span><span>NV_GPU_BASE_ADDRESS</span><span> </span><span>+</span><span> </span><span>NVPLL_COEFF</span><span>)</span><span> </span><span>=</span><span> </span><span>clockConfig</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>That’s it, the GPU is now overclocked. Kind of lack luster I know, but you’re probably wondering how far can we overclock the GPU? And what does the new performance graph look like?</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer.png" target="_blank" rel="noopener"><img loading="lazy" width="1920" height="961" src="https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-1920x961.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-1920x961.png 1920w, https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-300x150.png 300w, https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-768x384.png 768w, https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-1536x769.png 1536w, https://icode4.coffee/wp-content/uploads/oc_perf_triple_buffer-2048x1025.png 2048w" sizes="(max-width: 1920px) 100vw, 1920px"/></a><figcaption>Performance graph for 300Mhz GPU OC at 720p (triple buffered)</figcaption></figure></div>



<p>With the GPU overclocked to 300 Mhz (up from 233.33 Mhz stock) there’s a solid 3 FPS increase in performance in the Zanzibar benchmark scene compared to stock GPU clock speed. This doesn’t seem very impressive but remember this is the “benchmark” test, it was chosen because it puts a massive load on the GPU. Outside of this area there’s a noticeable increase in FPS and running around Zanzibar the game stays at 30 FPS most of the time, dipping slightly in a few heavy areas. So how far can we push the GPU? More speed better performance, right? </p>



<p>Semiconductor fabrication is not a perfect process and every chip has imperfections in it. While every GPU that made it into an Xbox console has minimum functional and quality requirements it had to meet, the maximum capabilities of each chip varies greatly. A lot of the GPUs in the 1.0-1.4 revision consoles are on the weaker end and seem to cap out in the low 300 Mhz range, while the GPUs in the 1.6 revision consoles have been able to go upwards of 400 Mhz stable. That’s almost a 100% increase in clock speed which is very impressive, but this won’t really improve the FPS much more (or so I think). There’s another bottleneck here, and one that can’t easily be worked around.</p>



<h4>Another chip, another clock…</h4>



<p>I spent a large amount of time throughout this project wondering if part of the bottleneck issue was memory bandwidth. There’s a number of articles in the Xbox SDK docs that go into great detail about the hardware in the console, the rendering pipeline, and all the gotchas you can hit that will hurt your game’s performance. There’s a number of times that memory bandwidth is mentioned and it seems the engineers believed you could max the memory bus bandwidth fairly easily. The bus has a theoretical maximum throughput of 6.4GB/s but only about 70% of that is usable in practice, for a practical max throughput of ~4.5GB/s. I captured a number of PIX traces on the game and the estimated memory usage for a single frame was never higher than low 40MBs. No matter how I ran the numbers I just could not see the memory bus bandwidth being maxed out. In my most generous calculation I estimated max throughput of 4GB/s / 30 FPS = ~135MB/frame. Even if we assume the CPU is consuming something like 50MBs that still gives ~80MBs for GPU data. Yeah 1280×720 is a lot of pixels but this would mean each frame is accessing more data than there is RAM on the console, and it was just hard to believe. However, I know very little in this area and it was very well possible that one of these numbers was off (perhaps PIX?). The engineers certainly believed it was possible so I was most likely missing or misunderstanding something.</p>



<p>Doom suggested I try increasing the RAM clock speed and see if FPS increases, which would indicate that memory is the likely bottleneck. The only problem is the RAM is already clocked at the practical maximum frequency of 200Mhz so you can only increase the speed by about ~10Mhz before it becomes unstable and the console crashes. After running some calculations I wrote the following snippet of code to change the memory clock speed:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.20 -->

		<div id="urvanov-syntax-highlighter-662299472a714862574321" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>OverclockRAM</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>	</span><span>DWORD </span><span>MPLLCoeff</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>	</span><span>// Read CR_CPU_MPLL_COEFF</span></p><p><span>	</span><span>HalReadWritePCISpace</span><span>(</span><span>0</span><span>,</span><span> </span><span>0x60</span><span>,</span><span> </span><span>0x6C</span><span>,</span><span> </span><span>&amp;</span><span>MPLLCoeff</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>MPLLCoeff</span><span>)</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>	</span><span>/*</span></p><p><span>		CR_CPU_MPLL_COEFF</span></p><p><span>			Bits 0-7: M</span></p><p><span>			Bits 8-15: N</span></p><p><span>			Bits 16-19: FSB_P</span></p><p><span>			Bits 20-23: MEM_P</span></p><p><span>		BASE_CLK = 16.6667 Mhz</span></p><p><span>		VCOFreq = (BASE_CLK / M) * FSB_P * 2 * N</span></p><p><span>		MEMCLK = VCOFreq / (2 * MEM_P)</span></p><p><span>	*/</span></p><p><span>	</span><span>// M/N values for 208 Mhz MEMCLK:</span></p><p><span>	</span><span>DWORD</span><span> </span><span>M</span><span> </span><span>=</span><span> </span><span>3</span><span>;</span></p><p><span>	</span><span>DWORD</span><span> </span><span>N</span><span> </span><span>=</span><span> </span><span>25</span><span>;</span></p><p><span>	</span><span>// Update PLL coefficients.</span></p><p><span>	</span><span>MPLLCoeff</span><span> </span><span>=</span><span> </span><span>(</span><span>MPLLCoeff</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>0xFF</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>M</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>;</span></p><p><span>	</span><span>MPLLCoeff</span><span> </span><span>=</span><span> </span><span>(</span><span>MPLLCoeff</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>0xFF00</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>(</span><span>N</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>8</span><span>)</span><span>;</span></p><p><span>	</span><span>// Update PPL value.</span></p><p><span>	</span><span>HalReadWritePCISpace</span><span>(</span><span>0</span><span>,</span><span> </span><span>0x60</span><span>,</span><span> </span><span>0x6C</span><span>,</span><span> </span><span>&amp;</span><span>MPLLCoeff</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>MPLLCoeff</span><span>)</span><span>,</span><span> </span><span>1</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>The M and N values above are chosen such that the resulting memory clock speed will be ~208 Mhz. I could adjust them some more and get closer to 210 Mhz but this was good enough to test. With these changes in place I booted up Halo 2, loaded up the Zanzibar benchmark scene and watched the perf monitor. I ran this test a number of times with and without the memory overclocking and the result was a solid 0.7 FPS increase when the memory overclocking was active. These test results aren’t conclusive but they’re definitely compelling. </p>



<p>There’s different RAM chips that work on the Xbox console and have a maximum clock speed of 250 Mhz. I searched around online and placed an order for some, but at the time of writing this I haven’t gotten to installing them or running any further tests. Doom has already tried using these memory chips and said he had trouble getting them above ~230 Mhz while the GPU was overclocked, and that there’s likely another piece to the puzzle to get them running any higher. I wanted to “push the console to the limits” with this patch but I was now 3 months into development of it and needed a break. Ultimately, even if I could get these other RAM chips running close to 250 Mhz I’d more or less be the only person able to utilize it as they’re hard to come by, quite costly, and require removing any existing RAM chips from the console motherboard before installing. With the chips on order I decided to save this experiment for future me and continue on with finishing the patch.</p>



<h2>Reducing pop-in</h2>



<p>Halo 2 had some notoriously bad pop-in issues with textures and geometry and this issue has only been exacerbated on consoles that are still running the original mechanical HDDs from the early 2000s. But now that we have all this extra RAM this should be easy to solve. Earlier I talked about the game making a single large memory allocation of ~48.9MB that I referred to as the “runtime data region”. This memory region is divided up into smaller sections for various subsystems in the game such as network resources, geometry cache, texture cache, sound cache, level data, etc. </p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile.png" target="_blank" rel="noopener"><img loading="lazy" width="1697" height="1080" src="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1697x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1697x1080.png 1697w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-300x191.png 300w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-768x489.png 768w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-1536x977.png 1536w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-2048x1303.png 2048w, https://icode4.coffee/wp-content/uploads/h2_retail_memory_profile-110x70.png 110w" sizes="(max-width: 1697px) 100vw, 1697px"/></a><figcaption>Halo 2 retail memory profile</figcaption></figure></div>



<p>The ones we’re interested in are the texture cache and geometry cache. The geometry cache is given 6.5MB of space for single player maps and 7MB for multiplayer maps. The texture cache size varies and is given all the remaining data after the “tag data” section and before the “low detail texture cache”. The larger the map the smaller the texture cache will be and the more pressure that’ll be put on it (especially for single player maps). These caches are “least recently used” data structures (or “lruv caches” as the game refers to them, not sure what the v is…), and work by evicting the least recently used data after a certain time period has elapsed. Every 30 frames (~1 second) the game will iterate through each cache and evict any data that hasn’t been used in the last 30 frames to free up space. If a request is made to load in data and there’s enough free space in the cache the data is loaded immediately (typically asynchronously, though it can block) and the request is satisfied once the read completes. If the cache is full there’s two code paths that can be taken:</p>



<ol><li>The caller can specify a parameter that indicates they want to force eviction on some other data. In this case the game will iterate through every entry in the cache and forcefully evict the least recently used items until there’s enough free space to satisfy the load request. If those items are currently being displayed on screen they’ll disappear in the next frame (and most likely submit new cache load requests). </li><li>The caller specifies they don’t want to force eviction and the load request fails. The object will not appear on screen this frame and the game will try to load it again next frame.</li></ol>



<p>Almost every call site for a load request falls down code path #2 with very few locations falling down code path #1. This is the first cause of pop-in, a request to load data is made and fails resulting in the object not being displayed on screen at the proper time. When the data is successfully loaded it will “pop” on screen and typically be far enough into the players field of view that they notice it. In the case of texture loads the map file can have up to 3 different texture buffers for low, medium, and high level of detail (LOD) versions of the same image. This is not to be confused with mip maps because each texture LOD will have its own set of mip maps. When a request is made to load in a texture the game will default to using the highest LOD possible, and if the load request fails it will try again using medium and low LOD buffers in hope that they require less memory and the load request may be possible to satisfy without waiting for memory to become available. If a load for a lower LOD version of the texture succeeds the game will attempt to load the highest LOD possible in the next few frames when more memory (hopefully) becomes available. When this happens the texture will be visible immediately at lower detail and then “pop” to higher detail when it becomes available. This is typically noticeable in cut-scenes which have the highest on-demand load requirements compared to normal game play.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/pop_in_fbf.png" target="_blank" rel="noopener"><img loading="lazy" width="1439" height="480" src="https://icode4.coffee/wp-content/uploads/pop_in_fbf.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/pop_in_fbf.png 1439w, https://icode4.coffee/wp-content/uploads/pop_in_fbf-300x100.png 300w, https://icode4.coffee/wp-content/uploads/pop_in_fbf-768x256.png 768w" sizes="(max-width: 1439px) 100vw, 1439px"/></a><figcaption>Master chief texture popping from low to high LOD</figcaption></figure></div>



<h4>Using cache eviction to find super bounces</h4>



<p>One additional note is that each map file also contains a “low detail texture cache” which contains an “emergency” version of almost every bitmap the map uses, in sizes from 2×2 pixels to at largest 8×8 pixels, which is always resident in memory while playing. This is used in cases where a model is present in memory but the load request for the texture(s) failed at all LODs. In this scenario there would normally be no textures to render the model with but the emergency low detail texture cache can be used temporarily to get the model on screen until the normal texture can be loaded into memory. Back in the Xbox Live days of Halo 2 there used to be a “glitch” where if you pulled up the Xbox Live friends menu and then closed it the level geometry would be rendered with extremely low detail textures. If you looked closely enough you could see “cracks” in the geometry (really, just where non-co-planar triangles were joined together) that you could try and use for super bounces. This technique was used to find suitable places for performing super bounces and I even remember finding a few myself using this method. It turns out this isn’t actually a “glitch” but the game using the emergency low detail texture cache because the normal textures for geometry were evicted and the geometry needs to be rendered this frame.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/low_detail_textures.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/low_detail_textures.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/low_detail_textures.png 720w, https://icode4.coffee/wp-content/uploads/low_detail_textures-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Foundation with low detail textures</figcaption></figure></div>



<h4>Visualizing cache usage</h4>



<p>When I first started adjusting the geometry and texture cache sizes I could definitely see pop-in was being reduced but I didn’t really have any good indication of when the caches were large enough and further tweaks were just redundant. After scraping through every Halo 2 build I had along with the Vista and MCC versions on PC, I was able to find enough info to recreate a debugging feature that Bungie had implemented in their debug builds of the game (this was such a pita). Using this graph visualization I could see exactly how much of the cache memory was being used at any given time which let me fine tune the sizes to what I felt was a pretty good result.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/texture_cache_stock_chief.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/texture_cache_stock_chief.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/texture_cache_stock_chief.png 720w, https://icode4.coffee/wp-content/uploads/texture_cache_stock_chief-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Halo 2 Outskirts stock texture cache</figcaption></figure></div>



<p>On the stock version of the game the campaign map Outskirts (old mombasa) has a texture cache size of ~19MB. I chose this map as my test map because the opening cinematic had pretty noticeable pop-in and with the original HDD in the console it could be comically bad at times. The image above shows the texture cache graph visualization. The graph is broken up into pairs of 2 lines. The first line indicates how the memory is being used: gray = free, red = in use high detail, purple = in use medium or lower detail (aka memory pressure), pink = stolen. The second line indicates when the memory was last used: green = in use this frame, blue = in use the last 30 frames. As a side note the game can steal memory from the texture cache for other purposes such as for rasterizer render targets that are only used in cinematic cutscenes, playing the intro/attraction/credits videos, etc. As we can see in the image above master chief is being rendered using the low detail texture cache because the normal texture cache is full and there’s no memory to satisfy the texture load request. Every single texture in the cache is either in use this frame or some time in the last 30 frames. So until enough textures age out and get evicted, master chief will be stuck in low detail.</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/texture_cache_stock_sniper.png" target="_blank" rel="noopener"><img loading="lazy" width="720" height="480" src="https://icode4.coffee/wp-content/uploads/texture_cache_stock_sniper.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/texture_cache_stock_sniper.png 720w, https://icode4.coffee/wp-content/uploads/texture_cache_stock_sniper-300x200.png 300w" sizes="(max-width: 720px) 100vw, 720px"/></a><figcaption>Halo 2 Outskirts stock texture cache</figcaption></figure></div>



<p>This scene with the sniper team is one of the heavier scenes in the opening cutscene and would often result in model and texture pop-in. We can see from the texture cache graph that almost all of the memory is in use and there’s quite a few textures that are being loaded at medium or lower detail (in purple) due to the memory pressure. I also implemented an almost identical graph view for the geometry cache and using both of these I began to fine tune the cache sizes until the pop-in issues were more or less gone. </p>



<h4>Increasing the cache sizes</h4>



<p>The final result is the geometry cache being increased from 6.5/7MB to 20MB, and the texture cache increased to a static size of 30MB, nearly doubling both caches in size from the stock version of the game. At these sizes I felt the caches had adequate space and texture and model pop-in was more or less resolved. </p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/texture_cache_upgrade.png" target="_blank" rel="noopener"><img loading="lazy" width="1439" height="480" src="https://icode4.coffee/wp-content/uploads/texture_cache_upgrade.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/texture_cache_upgrade.png 1439w, https://icode4.coffee/wp-content/uploads/texture_cache_upgrade-300x100.png 300w, https://icode4.coffee/wp-content/uploads/texture_cache_upgrade-768x256.png 768w" sizes="(max-width: 1439px) 100vw, 1439px"/></a><figcaption>Halo 2 Outskirts upgraded texture cache</figcaption></figure></div>



<p>As we can see the scene where master chief would appear with low detail textures now appears with high detail textures immediately (no more pop-in!) and there’s even plenty of free space in the texture cache. For the sniper scene we can see that in the previous frames all of the cache memory was being utilized, but not all at the same time as there’s plenty of chunks where the texture data has aged out of the cache. However, there were still a few cases where things would pop-in even though there was free space in the caches. To further fix this I ended up adding support to increase the HDD transfer speed from the stock UDMA 2 speed (~33.3MB/s) to UDMA 3 (~44.4MB/s) or UDMA 5 (~100MB/s) if your console had an 80 pin IDE cable. This provided a 10% increase in transfer speeds for consoles running the stock IDE cable and up to a 300% increase (theoretically, the actual transfer speeds depend greatly on the size of data being transferred) for consoles with an upgraded IDE cable. This not only helped with the remaining pop-in issues but greatly reduced loading times for the game as well. At this point I was pretty satisfied with the result.</p>



<h4>The final memory profile</h4>



<p>So after all these changes what does the final memory profile look like for Halo 2 in 720p on a console with 128MB of RAM?</p>



<div><figure><a href="https://icode4.coffee/wp-content/uploads/720p_memory_profile.png" target="_blank" rel="noopener"><img loading="lazy" width="1697" height="1080" src="https://icode4.coffee/wp-content/uploads/720p_memory_profile-1697x1080.png" alt="" srcset="https://icode4.coffee/wp-content/uploads/720p_memory_profile-1697x1080.png 1697w, https://icode4.coffee/wp-content/uploads/720p_memory_profile-300x191.png 300w, https://icode4.coffee/wp-content/uploads/720p_memory_profile-768x489.png 768w, https://icode4.coffee/wp-content/uploads/720p_memory_profile-1536x977.png 1536w, https://icode4.coffee/wp-content/uploads/720p_memory_profile-2048x1303.png 2048w, https://icode4.coffee/wp-content/uploads/720p_memory_profile-110x70.png 110w" sizes="(max-width: 1697px) 100vw, 1697px"/></a><figcaption>Halo 2 720p memory profile</figcaption></figure></div>



<p>The geometry and texture caches are now huge, and more than 75% of the available 128MB of RAM has been utilized. For 1080p mode I actually had to dial the geometry and texture cache sizes back a bit as the memory used by the swap chain and rasterizer targets was so large there wasn’t enough memory remaining for the increased caches, and more or less all 128MB of RAM was in use.</p>







<p>I wanna thank everyone that took the time to read all the way through this blog post. This is the longest post I’ve written to date and I tried to keep it as short as possible and even cut a bunch of smaller, less interesting things out. I also wanna give a huge thanks to Doom for encouraging me to do this work, providing hardware for testing, and insight into some deep technical areas. This project was a ton of fun to work on and I learned a lot throughout the process. I always wanted to work at Bungie on a game like Halo but never got the chance to do so, and working on this project in some ways felt like I actually got to work on the game. There’s still room for improvement with a lot of the performance and memory changes I made. But overall I feel this HD patch has pushed Halo 2 and the Xbox console to their limits and I’m satisfied with the results without trying to go any further.</p>



<p>You can find the download and source code for the Halo 2 HD patch here: <a rel="noreferrer noopener" href="https://github.com/grimdoomer/Halo-2-HD" data-type="URL" data-id="https://github.com/grimdoomer/Halo-2-HD" target="_blank">GitHub</a></p>



<p>I also made a video showing side-by-side comparisons of the stock game vs the HD patch, and performance metrics for each video resolution:</p>



<figure><p>
<iframe loading="lazy" title="Halo 2 in HD on the Original Xbox" width="470" height="264" src="https://www.youtube.com/embed/O_nk21389u8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p><figcaption>YouTube video showing a comparison between stock game and HD patch</figcaption></figure>
									
																		
								</div></div>
  </body>
</html>
