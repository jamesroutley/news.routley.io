<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://securelist.com/operation-triangulation-catching-wild-triangle/110916/">Original</a>
    <h1>How to catch a wild triangle</h1>
    
    <div id="readability-page-1" class="page"><div>
												<div>
													<p>In the beginning of 2023, thanks to our Kaspersky Unified Monitoring and Analysis Platform (KUMA) SIEM system, we noticed suspicious network activity that turned out to be an ongoing attack targeting the iPhones and iPads of our colleagues. The moment we understood that there was a clear pattern in the connections, and that the devices could have been infected, we initiated a standard digital forensics and incident response (DFIR) protocol for such cases – moving around the office, collecting the devices, and inspecting their contents. The ultimate goal was to locate and extract the malware, to find the point of entry (hopefully, a 0-day) and to develop a protocol for scanning the iDevices for active infection. That process turned into a months-long journey, and in this article we would like to summarize it.</p>
<h2 id="first-steps">First steps</h2>
<p>As we mentioned in <a href="https://securelist.com/operation-triangulation/109842/" target="_blank" rel="noopener">the very first article</a> on Operation Triangulation, the infected devices that we knew about initially, belonged to Kaspersky employees who worked in the HQ office in Moscow. All these devices were connected to the corporate Wi-Fi network, which allowed us to record and inspect the network traffic. After spending some time investigating with Wireshark, eventually we found the following:</p>
<ul>
<li>Right before exhibiting the suspicious behavior, the devices connected to the iMessage servers usually responsible for receiving messages and downloading attachments;</li>
<li>After downloading a few kilobytes of data that could have been an attachment, the devices established a connection to the server backuprabbit[.]com, exchanging data with it over a course of less than a minute;</li>
<li>Next, the devices connected to one of the following servers for a longer session:
<ul>
<li>cloudsponcer[.]com</li>
<li>snoweeanalytics[.]com</li>
<li>topographyupdates[.]com</li>
<li>unlimitedteacup[.]com</li>
<li>virtuallaughing[.]com</li>
</ul>
</li>
<li>Once the device rebooted, all the suspicious activity stopped.</li>
</ul>
<p>Unfortunately for us, all the communications with the servers in question happened over HTTPS, so we could not recover any additional details from the traffic.</p>
<h2 id="device-imaging">Device imaging</h2>
<p>Since all the devices were literally within hand’s reach, the obvious next step for us was to inspect their contents. Unfortunately, it was a dead end: available forensics acquisition software at the time of research was based on checkra1n and similar exploits that did not work for modern processors running iOS 15 and 16.</p>
<h2 id="examining-backups">Examining backups</h2>
<p>What we decided to do next was to use iTunes backups of the devices as a substitute for complete device images. This procedure had to be done with a fair amount of secrecy so as not to scare away the attackers. Since we did not know about the exact capabilities of the attackers, we assumed that they were listening to the microphones of the devices, and reading e-mail messages and messenger conversations. So, we had to arrange our meetings in person, putting the phones in airplane mode, and sometimes in Faraday bags. We used the excellent tooling from <a href="https://libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a> to acquire the backups, and inspected them by building a timeline of events with the <a href="https://docs.mvt.re/en/latest/" target="_blank" rel="noopener">Mobile Verification Toolkit</a>.</p>
<p>Such a timeline combines file system timestamps with data records extracted from various system databases. We focused on the iMessage directories, because we knew that in 2021 Citizen Lab researchers had found the infamous <a href="https://citizenlab.ca/2021/09/forcedentry-nso-group-imessage-zero-click-exploit-captured-in-the-wild/" target="_blank" rel="noopener">FORCEDENTRY</a> exploit by examining files in these directories. We wanted our analysis to be as fruitful – but the attackers behind Operation Triangulation turned out to be very stealthy, and we found no signs of exploits in the backup. We also searched it for malware executables, which we were also unable to find.</p>
<p>We had additional data points – the timestamps of suspicious network activity. So, we started to look for any repeating events in the timeline that happened around the same time. As a result, we found what looked like a new indicator: data usage records mentioning a system process named “BackupAgent” that should not have been executed at all – the binary was deprecated years before.</p>
		<div id="crayon-653a5fe1785a8645714312" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>2022</span>-<span>09</span>-<span>13</span><span> </span><span>10</span><span>:</span><span>04</span><span>:</span><span>11.890351Z</span><span> </span><span>Datausage </span></p><p><span>IMTransferAgent</span>/<span>com</span><span>.</span><span>apple</span><span>.</span><span>datausage</span><span>.</span><span>messages</span><span> </span><span>(</span><span>Bundle </span><span>ID</span><span>:</span><span> </span></p><p><span>com</span><span>.</span><span>apple</span><span>.</span><span>datausage</span><span>.</span><span>messages</span><span>,</span><span> </span><span>ID</span><span>:</span><span> </span><span>127</span><span>)</span><span> </span><span>WIFI </span><span>IN</span><span>:</span><span> </span><span>0.0</span><span>,</span><span> </span><span>WIFI </span><span>OUT</span><span>:</span><span> </span></p><p><span>0.0</span><span> </span>-<span> </span><span>WWAN </span><span>IN</span><span>:</span><span> </span><span>76281896.0</span><span>,</span><span> </span><span>WWAN </span><span>OUT</span><span>:</span><span> </span><span>100956502.0</span></p><p><span>2022</span>-<span>09</span>-<span>13</span><span> </span><span>10</span><span>:</span><span>04</span><span>:</span><span>54.000000Z</span><span> </span><span>Manifest </span></p><p><span>Library</span>/<span>SMS</span>/<span>Attachments</span>/<span>65</span>/<span>05</span><span> </span>-<span> </span><span>MediaDomain</span></p><p><span>2022</span>-<span>09</span>-<span>13</span><span> </span><span>10</span><span>:</span><span>05</span><span>:</span><span>14.744570Z</span><span> </span><span>Datausage </span><span>BackupAgent</span><span> </span><span>(</span><span>Bundle </span><span>ID</span><span>:</span><span> </span><span>,</span><span> </span></p><p><span>ID</span><span>:</span><span> </span><span>710</span><span>)</span><span> </span><span>WIFI </span><span>IN</span><span>:</span><span> </span><span>0.0</span><span>,</span><span> </span><span>WIFI </span><span>OUT</span><span>:</span><span> </span><span>0.0</span><span> </span>-<span> </span><span>WWAN </span><span>IN</span><span>:</span><span> </span><span>734459.0</span><span>,</span><span> </span><span>WWAN </span></p><p><span>OUT</span><span>:</span><span> </span><span>287912.0</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div><p><strong><em>Anomalous activity from the BackupAgent process observed in device logs – we shared this snippet in our first post on <a href="https://securelist.com/trng-2023/" target="_blank" rel="noopener">Operation Triangulation</a></em></strong></p>
<p>Based on the discovery of this anomaly, we wrote a first version of our <a href="https://securelist.com/find-the-triangulation-utility/109867/" target="_blank" rel="noopener">triangle_check</a> tool. It allowed us to quickly confirm if a device’s backup contained traces of potential compromise.</p>
<h2 id="trying-to-intercept-the-malicious-imessage">Trying to intercept the malicious iMessage</h2>
<p>Looking further into the event timelines, we discovered a second weak indicator: modification of an empty SMS attachment directory (one or several) prior to data usage by the BackupAgent process. Since the directory is modified but contains no files, that usually means with a high degree of confidence that the last operation was file deletion: there was an incoming attachment, it gets deleted, and seconds later a process named BackupAgent is running suspicious networking code.</p>
<p>Since the threat actor behind Operation Triangulation seemed to be smart enough to remove the malicious attachment from infected devices, we decided to try and capture the incoming message during the iMessage delivery process. While looking for a way to intercept iMessages, we found <a href="https://github.com/googleprojectzero/iOS-messaging-tools/blob/master/iMessage/dumpIncomingMessages.py" target="_blank" rel="noopener">this Frida script</a> coded by the Google Project Zero team. IIt is designed to run on a Mac, so we took a spare Mac mini and installed Frida on it. We then asked several of our targeted colleagues to log in to that Mac mini with their Apple IDs. By doing that, we were able to monitor and intercept iMessages that they received. All that we needed to do next was to wait until the attackers infected one of our colleagues’ devices once again.</p>
<p>At the same time, we were actively monitoring SIEM logs for the traces of suspicious activity. Soon enough, we detected familiar network connections that indicated a successful compromise of a phone with a “cloned” iMessage account. However, when we checked the iMessage interception logs on the Mac mini, we identified no traces of messages at the time of infection. Thus, our system was failing to capture the message that could have contained an exploit (we still don’t know why it didn’t work), so we started to seek other ways of capturing the malware.</p>
<h2 id="good-old-mitm">Good old MITM</h2>
<p>After the plan to intercept iMessages through a Mac device failed, we decided to try to decrypt HTTPS communications with the C2 servers previously identified from traffic analysis.</p>
<p>To do that, we:</p>
<ul>
<li>Set up a Linux server and installed <a href="https://mitmproxy.org/" target="_blank" rel="noopener">mitmproxy</a>, an HTTPS interception tool;</li>
<li>Installed a root SSL certificate (that we previously generated through mitmproxy) on several iOS devices that were known to be compromised before;</li>
<li>Installed a Wireguard VPN client on these devices and configured them to use our mitmproxy instance as a VPN server.</li>
</ul>
<p>We also developed a Telegram bot that would notify us whenever one of the monitored devices became infected:</p>
<p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02.jpg"><img decoding="async" loading="lazy" src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02.jpg" alt="" width="775" height="947" srcset="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02.jpg 775w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-246x300.jpg 246w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-768x938.jpg 768w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-143x175.jpg 143w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-370x452.jpg 370w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-229x280.jpg 229w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145702/How_to_catch_a_wild_triangle_02-737x900.jpg 737w" sizes="(max-width: 775px) 100vw, 775px"/></a></p>
<p>Unfortunately, this method did not allow us to intercept HTTPS traffic of Apple services (including iMessage), as iOS <a href="https://support.apple.com/en-us/HT210060" target="_blank" rel="noopener">implements SSL pinning</a> for this. Thus, we were not able to decrypt iMessage traffic that came through the VPN.</p>
<h2 id="catching-the-javascript-validator">Catching the JavaScript validator</h2>
<p>Once the attackers reinfected one of the targets, we looked in the mitmproxy logs, noticing that it managed to decrypt the C2 server traffic:</p>
<p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03.png"><img decoding="async" loading="lazy" src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-1024x171.png" alt="" width="1024" height="171" srcset="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-1024x171.png 1024w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-300x50.png 300w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-768x128.png 768w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-1030x172.png 1030w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-370x62.png 370w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03-800x134.png 800w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145745/How_to_catch_a_wild_triangle_03.png 1190w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></p>
<p>We expected the payload that we managed to obtain to be an exploit for iOS. However, it was the <a href="https://securelist.com/triangulation-validators-modules/110847/#javascript-validator" target="_blank" rel="noopener">JavaScript validator</a>, which simply collected information about the victim browser and sent it to the C2 server.</p>
<p>We observed the infected device receiving a payload in response to the validation information sent to the C2 server. However, while we were able to intercept HTTPS traffic, we could not decrypt it. That is because the JS validator implements its own layer of encryption for C2 communications, using the <a href="https://nacl.cr.yp.to/" target="_blank" rel="noopener">NaCl library</a>. The encryption algorithm used is based on public-key cryptography. Specifically, to communicate with the C2 server, the JS validator:</p>
<ul>
<li>Generates a random key pair (consisting of private and public key);</li>
<li>Derives a shared key from the generated private key and the C2 server’s public key;</li>
<li>Uses this shared key to encrypt messages sent to the C2 server and decrypt the ones received from it.</li>
</ul>

		<div id="crayon-653a5fe1785ae029105873" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p></div>
				</td>
						<td><div><p><span>var</span><span> </span><span>o</span><span> </span>=<span> </span><span>function</span><span> </span><span>(</span><span>t</span><span>)</span><span> </span><span>{</span></p><p><span>          </span><span>function</span><span> </span><span>u</span><span>(</span><span>t</span><span>)</span><span> </span><span>{</span></p><p><span>            </span><span>this</span><span>.</span><span>D</span><span> </span>=<span> </span><span>nacl</span><span>.</span><span>box</span><span>.</span><span>keyPair</span><span>(</span><span>)</span><span>;</span></p><p><span>            </span><span>this</span><span>.</span><span>L</span><span> </span>=<span> </span><span>nacl</span><span>.</span><span>box</span><span>.</span><span>before</span><span>(</span><span>t</span><span>,</span><span> </span><span>this</span><span>.</span><span>D</span><span>.</span><span>secretKey</span><span>)</span><span>;</span></p><p><span>          </span><span>}</span></p><p><span>          </span><span>u</span><span>.</span><span>prototype</span><span>.</span><span>encrypt</span><span> </span>=<span> </span><span>function</span><span> </span><span>(</span><span>t</span><span>,</span><span> </span><span>nonce</span><span>)</span><span> </span><span>{</span></p><p><span>            </span><span>return</span><span> </span><span>nacl</span><span>.</span><span>box</span><span>.</span><span>after</span><span>(</span><span>t</span><span>,</span><span> </span><span>nonce</span><span>,</span><span> </span><span>this</span><span>.</span><span>L</span><span>)</span><span>;</span></p><p><span>          </span><span>}</span><span>;</span></p><p><span>          </span><span>u</span><span>.</span><span>prototype</span><span>.</span><span>decrypt</span><span> </span>=<span> </span><span>function</span><span> </span><span>(</span><span>ciphertext</span><span>,</span><span> </span><span>nonce</span><span>)</span><span> </span><span>{</span></p><p><span>            </span><span>return</span><span> </span><span>nacl</span><span>.</span><span>box</span><span>.</span><span>open</span><span>.</span><span>after</span><span>(</span><span>ciphertext</span><span>,</span><span> </span><span>nonce</span><span>,</span><span> </span><span>this</span><span>.</span><span>L</span><span>)</span><span>;</span></p><p><span>          </span><span>}</span><span>;</span></p><p><span>          </span><span>u</span><span>.</span><span>prototype</span><span>.</span><span>N</span><span> </span>=<span> </span><span>function</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span></p><p><span>            </span><span>return</span><span> </span><span>nacl</span><span>.</span><span>randomBytes</span><span>(</span><span>nacl</span><span>.</span><span>box</span><span>.</span><span>nonceLength</span><span>)</span><span>;</span></p><p><span>          </span><span>}</span><span>;</span></p><p><span>          </span><span>u</span><span>.</span><span>prototype</span><span>.</span><span>k</span><span> </span>=<span> </span><span>function</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span></p><p><span>            </span><span>return</span><span> </span><span>this</span><span>.</span><span>D</span><span>.</span><span>publicKey</span><span>;</span></p><p><span>          </span><span>}</span><span>;</span></p><p><span>          </span><span>return</span><span> </span><span>new</span><span> </span><span>u</span><span>(</span><span>t</span><span>)</span><span>;</span></p><p><span>        </span><span>}</span><span>(</span><span>h</span><span>.</span><span>values</span><span>.</span><span>R</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div> 
<p><strong><em>Key generation</em></strong></p>
<p>In order to decrypt the C2 server communications, it is necessary to know the private key that was randomly generated by the JS validator. However, this key is kept in memory and is not sent to the C2 server. And so we had to do some additional work in order to decrypt the validator’s traffic.</p>
<p>As demonstrated by the screenshot above, the JS validator generates a random key pair by invoking the nacl.box.keyPair() method. To decrypt the traffic, we decided to compromise the process of generating this keypair. Specifically, we coded a tiny mitmproxy add-on that looked for invocations of the nacl.box.keyPair() method. It then replaced them with another method, nacl.box.keyPair.fromSecretKey(), that initializes a keypair from a provided private key.</p>
<p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145841/How_to_catch_a_wild_triangle_04.png"><img decoding="async" loading="lazy" src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145841/How_to_catch_a_wild_triangle_04.png" alt="" width="648" height="149" srcset="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145841/How_to_catch_a_wild_triangle_04.png 648w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145841/How_to_catch_a_wild_triangle_04-300x69.png 300w, https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2023/10/25145841/How_to_catch_a_wild_triangle_04-370x85.png 370w" sizes="(max-width: 648px) 100vw, 648px"/></a></p>
<p>As can be observed from the screenshot above, we hardcoded a private key into the arguments of this method, thus backdooring the validator’s encryption scheme. Once the backdoored validator was executed on the infected device, it became possible to decrypt all communications of the JS validator.</p>
<h2 id="the-binary-validator-and-the-hint-about-the-attachment">The binary validator and the hint about the attachment</h2>
<p>Once the attackers reinfected one of their targets, we were able to analyze the payload further executed by the validator. It turned out to contain two exploits: one for WebKit and the other for the iOS kernel. The ultimate goal of those two exploits is to launch the binary validator stage on the target device.</p>
<p>As we described in the article covering <a href="https://securelist.com/triangulation-validators-modules/110847/#binary-validator" target="_blank" rel="noopener">the stealth of Operation Triangulation</a>, the binary validator contains a function that cleans up traces of the malicious iMessage. Specifically, we found out that this function makes the following SQL request to the SMS.db database:</p>
		<div id="crayon-653a5fe1785b1077763065" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>SELECT </span><span>guid </span><span>FROM </span><span>attachment </span><span>WHERE </span><span>uti</span><span> </span>==<span> </span><span>&#34;com.apple.watchface&#34;</span><span> </span><span>AND</span><span> </span></p><p><span>LENGTH</span><span>(</span><span>transfer_name</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>32</span><span> </span><span>AND</span><span> </span><span>INSTR</span><span>(</span><span>transfer_name</span><span>,</span><span> </span><span>CHAR</span><span>(</span><span>0x2013</span><span>)</span><span>)</span><span> </span>==<span> </span><span>9</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div><p>
The condition ‘uti == “com.apple.watchface”‘ gave us another hint: now it became clear that the malicious attachment is a <a href="https://support.apple.com/guide/watch/faces-and-features-apde9218b440/watchos" target="_blank" rel="noopener">.watchface</a> file. And so, with a little bit more information about the attachment, we planned and executed the next attempt to obtain it.</p>
<h2 id="exploring-imessage">Exploring iMessage</h2>
<p>In order to devise another strategy for getting the attachment, we decided to study the process of sending iMessage attachments in greater detail. It turns out that this process <a href="https://support.apple.com/en-us/guide/security/sec70e68c949/web" target="_blank" rel="noopener">consists</a> of the following steps:</p>
<ol>
<li>The sender generates a random AES key and encrypts the attachment with it;</li>
<li>The encrypted attachment is uploaded to iCloud;</li>
<li>The iCloud link to the encrypted attachment is sent to the recipient along with the AES key, which is additionally encrypted using the device’s public RSA key.</li>
</ol>
<p>Thus, to obtain the malicious attachment file, we had to retrieve two components:</p>
<ul>
<li>The ciphertext of the attachment;</li>
<li>The AES key used to encrypt it.</li>
</ul>
<p>It is quite straightforward to obtain the attachment ciphertext, as it is possible to intercept traffic to the iCloud servers through mitmproxy. Previously, we wrote that iOS does not allow decryption of HTTPS traffic of Apple services. However, iCloud attachment links turned out to be an exception to that rule.</p>
<p>At the same time, the process of obtaining the AES key is quite difficult. It is sent over the iMessage protocol and so cannot be intercepted through mitmproxy. However, we discovered a way to recover the attachment and to extract this key using physical access to the target device. We prevented iMessage from successfully downloading the attachment using the iCloud link, so that the exploit would not activate and then delete the attachment, but the AES encryption key would be stored in the SMS.db database.</p>
<p>We decided to change a few bytes in the attachment ciphertext using our mitmproxy add-on. By doing that, we disrupted the process of downloading the attachment ciphertext, and the decryption key was kept in the SMS.db database. We then downloaded an iTunes backup of the infected device and extracted the key from the database inside this backup. As a result, we obtained the malicious .watchface attachment sent by the attackers – that was the beginning of the exploit chain used to compromise the devices.</p>
<h2 id="getting-the-implant">Getting the implant</h2>
<p>After we finished obtaining the exploits used by the attackers, all that remained was to get the <a href="https://securelist.com/triangledb-triangulation-implant/110050/" target="_blank" rel="noopener">implant</a> itself. The binary validator is the component responsible for downloading and activating the implant payload from the C2 server, and it uses a combination of RSA and AES for communications. Again, the use of RSA means that it is impossible to decrypt the implant payload by having only the ciphertext traffic.</p>
<p>To exchange data with the C2 server, the binary validator:</p>
<ul>
<li>Generates a random AES key;</li>
<li>Encrypts the generated AES key with the server’s RSA public key specified in the validator’s configuration;</li>
<li>Encrypts the message to be sent to the C2 server with the generated AES key;</li>
<li>Sends the encrypted message to the C2 server and receives a response from it;</li>
<li>Decrypts the response with the same AES key used for encrypting the sent message.</li>
</ul>
<p>The validator encrypts all the packets with the following ARM instructions:</p>
		<div id="crayon-653a5fe1785b2848220219" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>E0</span><span> </span><span>03</span><span> </span><span>18</span><span> </span><span>AA                           </span><span>MOV           </span><span>X0</span><span>,</span><span> </span><span>X24</span></p><p><span>2E</span><span> </span><span>1A</span><span> </span><span>00</span><span> </span><span>94</span><span>                           </span><span>BL            </span><span>serialize_plist</span></p><p><span>A0</span><span> </span><span>04</span><span> </span><span>00</span><span> </span><span>B4                           </span><span>CBZ           </span><span>X0</span><span>,</span><span> </span><span>loc_100006CD4</span></p><p><span>E1</span><span> </span><span>03</span><span> </span><span>17</span><span> </span><span>AA                           </span><span>MOV           </span><span>X1</span><span>,</span><span> </span><span>X23</span></p><p><span>39</span><span> </span><span>1A</span><span> </span><span>00</span><span> </span><span>94</span><span>                           </span><span>BL            </span><span>encryptData</span><span>       </span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div><p>
This code first executes the “serialized_plist” function, which prepares data for sending. After it is executed, the register X0 points to the data ready to be sent to the server.</p>
<p>The next function to be invoked is “encryptData”. It has two arguments: a pointer to the data being encrypted is passed to the X0 register, while the X1 register contains a plist with configuration data, including encryption parameters. After the execution of this function, the X0 register contains a pointer to the ciphertext.</p>
<p>Once again, we needed to compromise the encryption process to intercept the data from the infected device. We decided to replace the call to the “encryptData” function with a NOP instruction (1f 20 03 d5). This way, the value of the X0 register will not be overwritten with the pointer to the encrypted data, and the validator will send cleartext data to our VPN server.</p>
<p>Just as in the case with the JavaScript validator, we patched the code on the fly by extending our mitmproxy add-on:</p>
		<div id="crayon-653a5fe1785b4831611048" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>sig_pattern</span><span> </span>=<span> </span><span>re</span><span>.</span><span>compile</span><span>(</span><span>rb</span><span>&#34;...\xaa...\xf9...\x94...\xaa...\x94...\xb4...\xaa...\x94...\xb4...\xb4...\x71...\x54...\xaa...\x70...\xd5...\xaa...\x14&#34;</span><span>)</span></p><p><span>block_to_nop</span><span> </span>=<span> </span><span>sig_pattern</span><span>.</span><span>findall</span><span>(</span><span>ungzipped</span><span>)</span><span>[</span><span>0</span><span>]</span></p><p><span>new_block</span><span> </span>=<span> </span><span>block_to_nop</span><span>[</span><span>:</span><span>28</span><span>]</span><span> </span>+<span> </span><span>b</span><span>&#39;\x1f\x20\x03\xd5&#39;</span><span> </span>+<span> </span><span>block_to_nop</span><span>[</span><span>32</span><span>:</span><span>]</span></p><p><span>ungzipped</span><span> </span>=<span> </span><span>ungzipped</span><span>.</span><span>replace</span><span>(</span><span>block_to_nop</span><span>,</span><span> </span><span>new_block</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div><p><strong><em>Snippet of the mitmproxy add-on code that patches the call to the encryptData function with a NOP</em></strong></p>
<p>When the cleartext data reaches our VPN server, we (again, through the mitmproxy add-on) simulate a key exchange and data encryption and control the value of the encryption key. As a result, we successfully decrypted the data sent by the C2 server and extracted the body of the implant.</p>
<h2 id="obtaining-the-modules">Obtaining the modules</h2>
<p>After reverse engineering the TriangleDB implant, we found out that it is able to execute auxiliary modules, which made us want to obtain the module binaries. In our analysis of the implant, we wrote that module executables are passed to the implant through the CRXUpdateRecord and CRXUpdateRunRecord commands. Thus, in order to get these executables, it was necessary to be able to decrypt all the commands sent to the C2 server.</p>
<p>Again, the encryption algorithm was based on RSA, so our actions were similar to those we took to obtain the implant binaries.</p>
<p>This time, however, we decided to:</p>
<ul>
<li>Generate our own RSA public/private key pair;</li>
<li>Replace the RSA public key from the implant’s configuration with the previously generated one.</li>
</ul>
<p>We did that by adding the following code to the mitmproxy add-on:</p>

		<div id="crayon-653a5fe1785b5253323427" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>macho_second_index</span><span> </span>=<span> </span><span>find_nth</span><span>(</span><span>decompressed_implant</span><span>,</span><span> </span><span>b</span><span>&#34;\xcf\xfa\xed\xfe&#34;</span><span>,</span><span> </span><span>2</span><span>)</span></p><p><span>macho_second</span><span> </span>=<span> </span><span>decompressed_implant</span><span>[</span><span>macho_second_index</span><span>:</span><span>]</span></p><p><span>rsa_key</span><span>,</span><span> </span><span>xored_signature_offset</span><span>,</span><span> </span><span>xor_key</span><span> </span>=<span> </span><span>extract_rsa_key</span><span>(</span><span>macho_second</span><span>)</span></p><p><span>my_der_key</span><span> </span>=<span> </span><span>MY_CERT_DER</span></p><p><span>self</span><span>.</span><span>infections</span><span>[</span><span>flow</span><span>.</span><span>client_conn</span><span>.</span><span>peername</span><span>[</span><span>0</span><span>]</span><span>]</span><span>[</span><span>&#34;true_device_public_cert&#34;</span><span>]</span><span> </span>=<span> </span><span>rsa_key</span></p><p><span>my_der_key_xored</span><span> </span>=<span> </span><span>xor_one_byte_key</span><span>(</span><span>my_der_key</span><span>,</span><span> </span><span>xor_key</span><span>)</span></p><p><span>decompressed_implant</span><span>[</span><span>macho_second_index</span><span> </span>+<span> </span><span>xored_signature_offset</span><span>:</span><span>macho_second_index</span><span> </span>+<span> </span><span>xored_signature_offset</span>+<span>796</span><span>]</span><span> </span>=<span> </span><span>my_der_key_xored</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div> 
<p>When the implant traffic reached our VPN server, we:</p>
<ul>
<li>Decrypted it with the RSA private key that we generated;</li>
<li>Saved the decrypted traffic;</li>
<li>Re-encrypted the traffic with the public key used by the attackers.</li>
</ul>
<p>This way, we were able to eavesdrop on all communications performed by the implant, as well as obtain the module binaries.</p>


<h2 id="conclusion">Conclusion</h2>
<p>Our journey of investigating Operation Triangulation was quite lengthy; it took several months. Despite many ups and downs, we eventually managed to obtain all the stages used in this attack, including four zero-day exploits reported to Apple, two validators, an implant and its modules. </p>
<p>Along the way, we conducted a lot of research on iOS internals and came up with many interesting techniques, such as the one we used for extracting the iMessage attachment. </p>
<p>The main difficulty that we encountered during our research was to deal with the public-key cryptography that was used in just about every stage of the infection chain. To bypass the encryption, we had to develop a mitmproxy add-on that patched the malicious stages on the fly and compromised the original algorithms. Initially, we started with just 30 lines of code. When we finished extracting the modules, it had about 400 lines – and we definitely did not expect the add-on’s code to grow that much back at the start of our enduring adventure!</p>
												</div>
											</div></div>
  </body>
</html>
