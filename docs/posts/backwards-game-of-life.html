<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://pepijndevos.nl/2024/10/01/backwards-game-of-life.html">Original</a>
    <h1>Backwards Game of Life</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<article>
    
    <section>
    <p>I got a litlte bit nerd sniped by the following video and decided to implement game of life in clojure.core.logic, because any logic program can be evaluated forwards and backwards.</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/g8pjrVbdafY?si=AOnhIGwLQzy3MDaN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>Without further ado here is my implementation:</p>

<div><div><pre><code><span>(</span><span>ns</span><span> </span><span>pepijndevos.lifeclj</span><span>
  </span><span>(</span><span>:refer-clojure</span><span> </span><span>:exclude</span><span> </span><span>[</span><span>==</span><span>])</span><span>
  </span><span>(</span><span>:use</span><span> </span><span>clojure.core.logic</span><span>)</span><span>
  </span><span>(</span><span>:gen-class</span><span>))</span><span>

</span><span>;; A helper to get the neighbouring cells.</span><span>
</span><span>;; Clips to zero.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>get-neighbours</span><span> </span><span>[</span><span>rows</span><span> </span><span>x</span><span> </span><span>y</span><span>]</span><span>
  </span><span>(</span><span>for</span><span> </span><span>[</span><span>dx</span><span> </span><span>(</span><span>range</span><span> </span><span>-1</span><span> </span><span>2</span><span>)</span><span>
        </span><span>dy</span><span> </span><span>(</span><span>range</span><span> </span><span>-1</span><span> </span><span>2</span><span>)</span><span>
        </span><span>:when</span><span> </span><span>(</span><span>not</span><span> </span><span>(</span><span>=</span><span> </span><span>dx</span><span> </span><span>dy</span><span> </span><span>0</span><span>))]</span><span>
    </span><span>(</span><span>get-in</span><span> </span><span>rows</span><span> </span><span>[(</span><span>+</span><span> </span><span>x</span><span> </span><span>dx</span><span>)</span><span> </span><span>(</span><span>+</span><span> </span><span>y</span><span> </span><span>dy</span><span>)]</span><span> </span><span>0</span><span>)))</span><span>

</span><span>;; Produces binary vectors of a certain number of bits.</span><span>
</span><span>;; This is used to generate all neighbour combinations.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>bitrange</span><span> </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>sort-by</span><span> </span><span>#</span><span>(</span><span>apply</span><span> </span><span>+</span><span> </span><span>%</span><span>)</span><span>
           </span><span>(</span><span>for</span><span> </span><span>[</span><span>i</span><span> </span><span>(</span><span>range</span><span> </span><span>(</span><span>bit-shift-left</span><span> </span><span>1</span><span> </span><span>n</span><span>))]</span><span>
             </span><span>(</span><span>vec</span><span> </span><span>(</span><span>map</span><span> </span><span>#</span><span>(</span><span>bit-and</span><span> </span><span>1</span><span> </span><span>(</span><span>bit-shift-right</span><span> </span><span>i</span><span> </span><span>%</span><span>))</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>))))))</span><span>

</span><span>;; Encode the game of life rules as a 256 element conde.</span><span>
</span><span>;; Depending on the number of ones in a vector,</span><span>
</span><span>;; the corresponding rule is generated</span><span>
</span><span>;; that equates the pattern to the neigbours</span><span>
</span><span>;; and the appropriate next state.</span><span>
</span><span>;;</span><span>
</span><span>;; This can be asked simply what the next state is for</span><span>
</span><span>;; given neighbours and current state.</span><span>
</span><span>;; OR you could drive it backwards any way you like.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>lifegoals</span><span> </span><span>[</span><span>neigh</span><span> </span><span>self</span><span> </span><span>next</span><span>]</span><span>
  </span><span>(</span><span>or*</span><span>
   </span><span>(</span><span>for</span><span> </span><span>[</span><span>adj</span><span> </span><span>(</span><span>bitrange</span><span> </span><span>8</span><span>)</span><span>
         </span><span>:let</span><span> </span><span>[</span><span>n</span><span> </span><span>(</span><span>apply</span><span> </span><span>+</span><span> </span><span>adj</span><span>)]]</span><span>
     </span><span>(</span><span>cond</span><span>
       </span><span>(</span><span>or</span><span> </span><span>(</span><span>&lt;</span><span> </span><span>n</span><span> </span><span>2</span><span>)</span><span> </span><span>(</span><span>&gt;</span><span> </span><span>n</span><span> </span><span>3</span><span>))</span><span> </span><span>(</span><span>all</span><span> </span><span>(</span><span>==</span><span> </span><span>next</span><span> </span><span>0</span><span>)</span><span> </span><span>(</span><span>==</span><span> </span><span>neigh</span><span> </span><span>adj</span><span>))</span><span>
       </span><span>(</span><span>=</span><span> </span><span>n</span><span> </span><span>3</span><span>)</span><span>              </span><span>(</span><span>all</span><span> </span><span>(</span><span>==</span><span> </span><span>next</span><span> </span><span>1</span><span>)</span><span> </span><span>(</span><span>==</span><span> </span><span>neigh</span><span> </span><span>adj</span><span>))</span><span>
       </span><span>:else</span><span>             </span><span>(</span><span>all</span><span> </span><span>(</span><span>==</span><span> </span><span>next</span><span> </span><span>self</span><span>)</span><span> </span><span>(</span><span>==</span><span> </span><span>neigh</span><span> </span><span>adj</span><span>))))))</span><span>

</span><span>;; Relate two grids to each other according to the above rules.</span><span>
</span><span>;; Applies lifegoals to every cell and its neighbours.</span><span>
</span><span>;; in the forwards direction executes one life step,</span><span>
</span><span>;; in the backwards direction generates grids</span><span>
</span><span>;; that would produce the next step.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>stepo</span><span> </span><span>[</span><span>size</span><span> </span><span>vars</span><span> </span><span>next</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>rows</span><span> </span><span>(</span><span>-&gt;&gt;</span><span> </span><span>vars</span><span> </span><span>(</span><span>partition</span><span> </span><span>size</span><span>)</span><span> </span><span>(</span><span>map</span><span> </span><span>vec</span><span>)</span><span> </span><span>(</span><span>into</span><span> </span><span>[]))</span><span>
        </span><span>neig</span><span> </span><span>(</span><span>for</span><span> </span><span>[</span><span>x</span><span> </span><span>(</span><span>range</span><span> </span><span>size</span><span>)</span><span>
                   </span><span>y</span><span> </span><span>(</span><span>range</span><span> </span><span>size</span><span>)]</span><span>
               </span><span>(</span><span>get-neighbours</span><span> </span><span>rows</span><span> </span><span>x</span><span> </span><span>y</span><span>))]</span><span>
    </span><span>(</span><span>everyg</span><span> </span><span>#</span><span>(</span><span>apply</span><span> </span><span>lifegoals</span><span> </span><span>%</span><span>)</span><span> </span><span>(</span><span>map</span><span> </span><span>vector</span><span> </span><span>neig</span><span> </span><span>vars</span><span> </span><span>next</span><span>))))</span><span>

</span><span>;; Make a grid of unbound variables.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>grid</span><span> </span><span>[</span><span>size</span><span>]</span><span> </span><span>(</span><span>repeatedly</span><span> </span><span>(</span><span>*</span><span> </span><span>size</span><span> </span><span>size</span><span>)</span><span> </span><span>lvar</span><span>))</span><span>

</span><span>;; Simply execute a life step on the state.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>fwdlife</span><span> </span><span>[</span><span>size</span><span> </span><span>state</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>vars</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)</span><span>
        </span><span>next</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)]</span><span>
    </span><span>(</span><span>run</span><span> </span><span>1</span><span> </span><span>[</span><span>q</span><span>]</span><span>
         </span><span>(</span><span>==</span><span> </span><span>q</span><span> </span><span>next</span><span>)</span><span>
         </span><span>(</span><span>==</span><span> </span><span>vars</span><span> </span><span>state</span><span>)</span><span>
         </span><span>(</span><span>stepo</span><span> </span><span>size</span><span> </span><span>vars</span><span> </span><span>next</span><span>))))</span><span>

</span><span>;; Produce three backward steps on state.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>revlife</span><span> </span><span>[</span><span>size</span><span> </span><span>state</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>start</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)</span><span>
        </span><span>s1</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)</span><span>
        </span><span>s2</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)</span><span>
        </span><span>end</span><span> </span><span>(</span><span>grid</span><span> </span><span>size</span><span>)]</span><span>
    </span><span>(</span><span>run</span><span> </span><span>1</span><span> </span><span>[</span><span>q</span><span>]</span><span>
          </span><span>(</span><span>==</span><span> </span><span>q</span><span> </span><span>[</span><span>start</span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>end</span><span>])</span><span>
          </span><span>(</span><span>==</span><span> </span><span>end</span><span> </span><span>state</span><span>)</span><span>
          </span><span>(</span><span>stepo</span><span> </span><span>size</span><span> </span><span>s2</span><span> </span><span>end</span><span>)</span><span>
          </span><span>(</span><span>stepo</span><span> </span><span>size</span><span> </span><span>s1</span><span> </span><span>s2</span><span>)</span><span>
          </span><span>(</span><span>stepo</span><span> </span><span>size</span><span> </span><span>start</span><span> </span><span>s1</span><span>)</span><span>
         </span><span>)))</span><span>

</span><span>;; Nicely print the board.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>printlife</span><span> </span><span>[</span><span>size</span><span> </span><span>grids</span><span>]</span><span>
  </span><span>(</span><span>doseq</span><span> </span><span>[</span><span>g</span><span> </span><span>grids</span><span>]</span><span>
    </span><span>(</span><span>doseq</span><span> </span><span>[</span><span>row</span><span> </span><span>(</span><span>-&gt;&gt;</span><span> </span><span>g</span><span> </span><span>(</span><span>partition</span><span> </span><span>size</span><span>)</span><span> </span><span>(</span><span>map</span><span> </span><span>vec</span><span>)</span><span> </span><span>(</span><span>into</span><span> </span><span>[]))]</span><span>
      </span><span>(</span><span>doseq</span><span> </span><span>[</span><span>t</span><span> </span><span>row</span><span>]</span><span>
        </span><span>(</span><span>print</span><span> </span><span>t</span><span> </span><span>&#34;&#34;</span><span>))</span><span>
      </span><span>(</span><span>print</span><span> </span><span>&#34;\n&#34;</span><span>))</span><span>
    </span><span>(</span><span>print</span><span> </span><span>&#34;\n&#34;</span><span>)))</span><span>

</span><span>;; Test with a glider.</span><span>
</span><span>(</span><span>defn</span><span> </span><span>-main</span><span> </span><span>[</span><span>&amp;</span><span> </span><span>args</span><span>]</span><span>
  </span><span>(</span><span>-&gt;&gt;</span><span> </span><span>[</span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span>
        </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span>
        </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>1</span><span> </span><span>0</span><span>
        </span><span>0</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>1</span><span> </span><span>0</span><span> </span><span>0</span><span>
        </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>0</span><span>
        </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>0</span><span>]</span><span>
       </span><span>(</span><span>revlife</span><span> </span><span>6</span><span>)</span><span>
       </span><span>first</span><span>
       </span><span>(</span><span>printlife</span><span> </span><span>6</span><span>)))</span><span>
</span></code></pre></div></div>

<p>output:</p>

<div><div><pre><code>$ clj -Mrun
1 0 1 0 1 1 
1 0 0 0 0 1 
0 0 1 0 0 0 
0 0 0 0 0 1 
1 0 1 1 0 0 
1 0 1 1 1 1 

0 1 0 0 1 1 
0 0 0 1 1 1 
0 0 0 0 0 0 
0 1 1 1 0 0 
0 0 1 0 0 1 
0 0 1 0 1 0 

0 0 0 1 0 1 
0 0 0 1 0 1 
0 0 0 0 0 0 
0 1 1 1 0 0 
0 0 0 0 1 0 
0 0 0 1 0 0 

0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 1 1 0 
0 0 1 1 0 0 
0 0 0 0 1 0 
0 0 0 0 0 0
</code></pre></div></div>

<p>Sadly, this is nowhere near fast enough to solve the play button problem.</p>

    </section>
    
</article>




        </div></div>
  </body>
</html>
