<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://poniesandlight.co.uk/reflect/island_rendergraph_1/">Original</a>
    <h1>Rendergraphs and how to implement one</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  	<div><p>If the renderer can prove that some commands for the GPU have no effect on the final image, it will not send these commands to the GPU, and it won&#39;t even record these commands. Code that is not run is the best code, <span title=" - it has zero bugs, and runs faster than any actual code by a factor of ∞">after all</span><span> - it has zero bugs, and runs faster than any actual code by a factor of ∞</span>…</p>
<p>But how can a renderer achieve this?</p>
</div>
<div>
	
<p>By using a rendergraph. Organising potential GPU work in a rendergraph gives a renderer an amazing amount of information to do work with: In Island, <a href="https://github.com/tgfrerer/island">the renderer I&#39;ve been working on for a little while now</a>, a rendergraph is used to sort, optimize, synchronize, and queue up work for the GPU. It allows the renderer to reason which payloads to record and to execute, to infer extra synchronisation steps, and even to distribute work onto multiple GPU hardware queues, whenever possible.</p>
<p>I&#39;m going to spend a bit of time explaining how I implemented Island&#39;s rendergraph. It&#39;s an <em>immediate mode</em> rendergraph: every frame, it is rebuilt from scratch. A key design goal therefore was to make it lightweight, and predictable in terms of execution time. What I came up with is by far not the most elegant, or the most innovative use of a rendergraph, but it works <em>nicely</em>, and some architectural decisions turned out to pay off quite well, and I&#39;ll be trying to highlight these.</p>
<p>One such thing that I quite like is that, to show what&#39;s going on, and to help debugging visually, Island can automatically draw diagrams of the rendergraph for each frame.</p>
<p>Imagine a situation where we have a compute pass updating some vertices in a mesh, which is then drawn to screen. Here&#39;s how such a rendergraph might look like:</p>
<figure>
<img src="https://poniesandlight.co.uk/img/island_rendergraph/rendergraph_simple.png" alt="A simple Rendergraph" title="A simple Rendergraph"/>
<figcaption>
    <b>Fig. 1:</b> Rendergraph with two passes: ‘compute’, and ‘draw’. Root passes have their names underlined thickly, dependencies are shown with →arrows. △indicates read from a resource, ▼indicates write to a resource. Time progresses top-to-bottom
</figcaption>
</figure>
<p>The rendergraph is a directed, acyclical graph (DAG) with vertices made from renderpasses. The graph&#39;s edges are formed by read/write dependencies between resources inside these renderpasses. We can see this a bit better when we look at a diagram of a more complicated rendergraph:</p>
<figure>
<img src="https://poniesandlight.co.uk/img/island_rendergraph/rendergraph_aeon.png" alt="A more complex Rendergraph" title="A more complex Rendergraph"/>
<figcaption>
    <b>Fig. 2:</b></figcaption>
</figure>
<p>In Island, forming the vertices of the rendergraph, renderpasses are the smallest isolated unit of reasoning about GPU operations. <em>Everything</em> GPU- related must happen inside of a renderpass. And each renderpass must choose upfront which capability it requires from the GPU. Currently, it must choose one of: <code>GRAPHICS</code>, <code>COMPUTE</code> or <code>TRANSFER</code>. Additionally, every pass must upfront declare which resources it uses, and for each resource, whether it will access it <code>READ_ONLY</code>, <code>WRITE_ONLY</code>, or <code>READ_WRITE</code>. In code this could look a bit like this:</p>
<h2 id="rendergraph-declaration-in-code">Rendergraph Declaration in Code <a href="#rendergraph-declaration-in-code"></a></h2>
</div>
<div>
		
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span></code></pre></td>
<td>
<pre><code data-lang="c">app_update(){
<span>//...
</span><span></span>le<span>:</span><span>:</span>RenderGraph rendergraph{}; 

rendergraph
    .addRenderPass(
        le<span>:</span><span>:</span>RenderPass( <span></span><span>&#34;</span><span>compute_one</span><span>&#34;</span>, COMPUTE )
            .useBufferResource(  LE_BUF_RESOURCE(<span></span><span>&#34;</span><span>particle_buffer</span><span>&#34;</span>) , READ_ONLY)
            .setExecuteCallback( self, pass_comp_exec ) )
    .addRenderPass(
        le<span>:</span><span>:</span>RenderPass( <span></span><span>&#34;</span><span>draw_offscreen</span><span>&#34;</span>, GRAPHICS )
            .addColorAttachment(  LE_IMG_RESOURCE (<span></span><span>&#34;</span><span>two_output</span><span>&#34;</span>), CLEAR ) <span>// INFERRED WRITE_ONLY
</span><span></span>            .setExecuteCallback( self, pass_two_exec )
        )
    .addRenderPass(
        le<span>:</span><span>:</span>RenderPass( <span></span><span>&#34;</span><span>to_screen</span><span>&#34;</span>, GRAPHICS )
            .addColorAttachment( self<span>-</span><span>&gt;</span>renderer.getSwapchainResource(), LOAD) <span>// INFERRED READ_WRITE
</span><span></span>            .sampleTexture( TEX_TWO, LE_IMG_RESOURCE( <span></span><span>&#34;</span><span>two_output</span><span>&#34;</span> ), ... )  <span>// INFERRED READ-ONLY
</span><span></span>            .setExecuteCallback( self, pass_three_exec )
        )
    ;

<span>// update() will build the rendergraph, then call (filtered) render callbacks for this renderpass 
</span><span></span>self<span>-</span><span>&gt;</span>renderer.update( rendergraph ); 

<span>// ...
</span><span></span>}
</code></pre></td></tr></tbody></table>
</div>
</div><p>Note that each pass contains a callback method which contains commands that get recorded for the GPU. These commands are only allowed to touch GPU resources which were declared to its pass. If the pass contributes to the final frame, then the callback gets called by the renderer. If, however, the renderer can prove that a pass makes no contribution to the final frame, the pass is not executed, and its commands are not even recorded for the GPU. This can save a lot of CPU and GPU work.
</p><figure>
<img src="https://poniesandlight.co.uk/img/island_rendergraph/rendergraph_aeon_2.png" alt="Rendergraph 1" title="Rendergraph 1"/>
<figcaption>
    <b>Fig. 3:</b></figcaption>
</figure>
<p>When the renderer evaluates the renderpass, it only keeps passes which are linked to a pass that contributes to the final image on screen. How are these links formed? They are formed by the resources that are used inside each pass, and their usage – remember, for each pass we needed to declare which resources it reads, writes, and read/writes to. If a pass reads from a resource, the pass is automatically linked to the next earlier pass - in submission order - which writes to this resource.</p>
<p>Compared with <a href="https://themaister.net/blog/2017/08/15/render-graphs-and-vulkan-a-deep-dive/">other rendergraph implementations</a>, Island does not re-order passes. Once the list of renderpasses for the current frame is submitted to the renderer, graph assembly begins at the bottom of this list, and bubbles upwards searching for links. The renderer might ignore passes, or even generate independent sub-graphs, but it will keep pass execution order in submission order. I made this choice early on, because it looked less complex to implement and maintain, and easier to reason about - it also makes it a bit more predictable, and quicker, to build the rendergraph.</p>
<h3 id="building-the-rendergraph">Building the rendergraph <a href="#building-the-rendergraph"></a></h3>
<p>Before I go into a bit more detail about the individual steps for building the rendergraph, let&#39;s list them as a broad-stroke recipe:</p>
<ol>
<li>Filter passes by testing if they contribute to any root pass</li>
<li>Build independent sub-graphs beginning with each root pass</li>
<li>Test for sub-graph overlaps, and merge overlapping sub-graphs</li>
</ol>
<h3 id="1-filter-passes-by-testing-if-they-contribute-to-a-root-pass">1. Filter passes by testing if they contribute to a root pass <a href="#1-filter-passes-by-testing-if-they-contribute-to-a-root-pass"></a></h3>
<p>We begin our recipe by filtering for root pass contributions. What&#39;s a root pass? A root pass is a pass that we unconditionally want to keep. A classic root pass is any pass that writes to <span title=", which is the image that ends up displayed on screen">a swapchain image</span><span>, which is the image that ends up displayed on screen</span>. To never drop such passes, we automatically declare the last passes that write to any swapchain images as root passes. It&#39;s also possible to explicitly tag passes as root passes. This is useful, for example, when you want to spread work over multiple frames, where the results of a pass might only be used in the next frame.</p>
<p>Once we have our root passes, we know that we can get rid of any passes which are not linked to any of them. To perform this filter, we start at the bottom most root pass, from which we bubble up through our list of passes, all the while tagging any passes which have links to any root pass as contributing. Once we have reached the top of the list, any passes which have not been tagged as contributing can be discarded.</p>
<h3 id="2-build-independent-sub-graphs-beginning-with-each-root-pass">2. Build independent sub-graphs beginning with each root pass <a href="#2-build-independent-sub-graphs-beginning-with-each-root-pass"></a></h3>
<p>Then, we revisit our list of passes again, and now, we tag each pass with the root pass(es) that it contributes to, so that we can form independent sub-graphs, each with a root pass at its, well, root.</p>
<p>Again, we begin at the bottom-most root pass, and note all the resources that get read by this pass. Then we iterate upwards in our list of passes until we find a pass which writes to any of these read resources. If we find such a pass, it is tagged as contributing to that particular root pass.</p>
</div>
<div>
	
<p>We add the read resources of our contributing pass to our current set of monitored read resources and continue our iteration upwards, until we find the next pass which writes to any of these read resources. If we find such a pass, it too contributes to the current root pass and we add a matching tag to it.</p>
<p>We repeat this process until we have reached the top of our list of passes, at which point we return to the bottom to find the next root pass, from which we bubble up again, until we run out of root passes to process.</p>
<p>How is this implemented in detail? I&#39;m using bitsets to keep track of resource reads/and writes - it seems an effective way of testing many read- and write operations at once, as we can perform 32 comparisons or more with a single CPU instruction.</p>
</div>
<div>
	
<p>First, we map each resource to a unique bitset index. Then, for each pass we initialize two bitsets - one for writes and one for reads, and we switch on the bits representing writes and reads for the resources which are in use by this pass. Then, we execute the recipe from above.</p>
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td>
<td>
<pre><code data-lang="text">pass 0:
    READ : 0000011 // read from resource 0, and 1
    WRITE: 0000001 // write to resource 1

pass 1: 
    READ : 0000111 // read from resource 0, 1, and 2
    WRITE: 0100000 // write to resource 5

pass 2:
    READ : 0001001 // read from resource 0, and from resource 3
    WRITE: 0010000 // write to resource 4
</code></pre></td></tr></tbody></table>
</div>
</div><p>In the above example we can see that there is a dependency between <code>pass 2</code> and <code>pass 0</code>, because <code>pass 2</code> will read from <code>resource 0</code>, which is written to by <code>pass 0</code>.</p>
<p>There is, however, no dependency to <code>pass 1</code>, as <code>pass 1</code> does not write to any resources which are read in <code>pass 2</code>. We can therefore ignore <code>pass 1</code>.</p>
</div>
<div>
	<p>This method is of course far from perfect, as it&#39;s generally <em>pessimistic</em>: it assumes that <em>all</em> read resources conspire to modify <em>all</em> write resources in a pass - this might not always be the case. But this method seems to hit the right balance between complexity and usefulness for now. I might revisit this later if it needs further optimisation.</p>
<p>Tagging a passes’ contribution to a particular root pass works similarly: each pass stores a small bitset which is just large enough to have a single bit representing each distinct root pass. We tag a pass as contributing to a root pass by <span title=" (of the key bitfield inside the pass)">flipping the bit</span><span> (of the key bitfield inside the pass)</span> representing that root pass. This means that at the end of this process, we end up with a list of passes, where each pass has a key where at most a single bit is set, representing which root this pass contributes to.</p>
</div>
<div>
	
<p>With such a key, we can filter our initial list of passes for any passes which contribute to a root, giving us a subgraph of only the passes which contribute to this particular root pass.</p>
<p>Are we there yet? Not quite - we need one last step so that we can guarantee that subpasses are truly independent and could even run in parallel on different queues.</p>
<h3 id="3-test-for-sub-graph-overlaps-and-merge-overlapping-sub-graphs">3. Test for sub-graph overlaps, and merge overlapping sub-graphs <a href="#3-test-for-sub-graph-overlaps-and-merge-overlapping-sub-graphs"></a></h3>
<p>For passes to be absolutely free of resource contention, we must guarantee that there never is any resource which is read by one subgraph, and written by another subgraph. If all sub-graphs just <code>READ</code> a resource, that&#39;s fine.</p>
<p>What hazards do we need to look out for? Imagine that a downstream root pass writes to a resource, and an earlier pass reads from this same resource. After executing the algorithm above, we might still have two independent subgraphs:</p>
</div>
<div>
		
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code></pre></td>
<td>
<pre><code data-lang="text">pass 0:
    READ : 0000010 // read from resource 1
    WRITE: 0000001 // write  to resource 0

pass 1: 
    READ : 0000010 // read from resource 1
    WRITE: 1000010 // write  to resource 1, and 6
</code></pre></td></tr></tbody></table>
</div>
</div><p>To fix this, we need to test all subgraphs for whether their accumulated reads and accumulated writes overlap. If they do, that means that these two graphs are not independent, and that we must merge them. By merging subgraphs, we enforce that all their passes get executed in declaration order, and not, potentially, in parallel. This is important for when we want to spread workload over multiple parallel hardware queues.</p>
</div>
<div>
	
<p>So how do we merge two or more subgraphs? We can do this by simply combining (<code>OR</code>-ing) their keys.</p>
<h2 id="handing-it-over-to-the-backend">Handing it over to the backend <a href="#handing-it-over-to-the-backend"></a></h2>
<p>When the renderer hands over the rendergraph to the backend, it provides it with the original list of passes (minus non-contributing) where each pass has a key that shows the root pass that it contributes to. The backend also receives different set of keys, where each key can be used to filter for a distinct, independent subgraph.</p>
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span></code></pre></td>
<td>
<pre><code data-lang="text">passes list : 
{
    pass a - root key: 0001
    pass b - root key: 0010
    pass c - root key: 0100 
    pass d - root key: 0100 (root pass 2)
    pass e - root key: 0010 (root pass 1)
    pass f - root key: 0001 (root pass 0) 
}

subgraphs keys :
{
    key A - root key: 0001 (subgraph from root 0)
    key B - root key: 0110 (combined subgraph from root 1, and root 2)
}
</code></pre></td></tr></tbody></table>
</div>
</div><p>Now, if you filter passes using subgraph keys you will get:</p>
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td>
<td>
<pre><code data-lang="text">subgraph A ( key       0001 ){
    pass a - root key: 0001
    pass f - root key: 0001 (root pass 0) 
}

subgraph B (      key: 0110 ){
    pass b - root key: 0010
    pass c - root key: 0100 
    pass d - root key: 0100 (root pass 2)
    pass e - root key: 0010 (root pass 1)
}

</code></pre></td></tr></tbody></table>
</div>
</div><h2 id="closing-thoughts">Closing thoughts <a href="#closing-thoughts"></a></h2>
<p>I hope the above discussion gives an idea how the rendergraph is built in Island. There are many aspects to the rendergraph – how it is used to automate synchronisation, the subtleties of mapping a rendergraph onto the Vulkan API, how the rendergraph is used to automatically distribute work over multiple hardware queues – which might be worth talking about in more detail but will have to wait for a future post.</p>
<p>In Island, the rendergraph is assembled from scratch every frame, which is why I try to keep the workload for assembling the rendergraph fairly light. It could be nice to evaluate the rendergraph only on change - and while this might lead to less predictable frame times and more complexity, there could be quite some optimisation potential in it, especially for scenarios where the rendergraph itself does not change too much -or not at all- between frames.</p>
<figure>
<img src="https://poniesandlight.co.uk/img/island_preview.png" alt="Island preview image" title="Island preview image"/>
<figcaption>
    If you&#39;re interested in how I applied the method described in this post to the <a href="https://github.com/tgfrerer/island">Island</a> codebase, I recommend you take a look at the <a href="https://github.com/tgfrerer/island/blob/a843602cb9701cb7f0aab5da135808074e84f15b/modules/le_renderer/le_rendergraph.cpp#L831">relevant lines</a> in the source code inside Island&#39;s renderer module, <code>le_rendergraph.cpp</code>, on github.
</figcaption>
</figure>

<p>Shout-out to <a href="https://twitter.com/Themaister">Hans-Kristian Arntzen</a>, whose classic post <a href="https://themaister.net/blog/2017/08/15/render-graphs-and-vulkan-a-deep-dive/">Render Graphs and Vulkan - A Deep Dive</a> is indeed an in-depth discussion, and has been a great source for inspiration. His write-up also contains lots of ideas on synchronisation and how a rendergraph can help with that, something I ran out of space to touch upon in this post.</p>


	</div>
	
	
	
		<div>
			<h3>RSS:</h3>
			<p>Find out first about new posts by subscribing to the <a href="https://poniesandlight.co.uk/reflect/feed.xml">RSS Feed</a> <a href="https://poniesandlight.co.uk/reflect/feed.xml" type="application/rss+xml">R</a></p>
		</div>
	
		<p>
			<h3>Further Posts:</h3>
		</p>
		
        </div></div>
  </body>
</html>
