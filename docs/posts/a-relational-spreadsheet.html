<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevinlynagh.com/relational-spreadsheet/">Original</a>
    <h1>A Relational Spreadsheet</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://capnfabs.net/">← Back to Kevin&#39;s homepage</a><span>Published: 2023 February 26</span></p><p>I tried doing an INNER JOIN in Google Sheets and it was so awkward I was compelled to build my own lightweight relational spreadsheet / language / system.</p>


<div><pre><span></span>Timestamps:
 0:00 intro and motivation
 4:00 language semantics
 5:50 toy financial problem
12:00 symbolic variables
</pre></div>
<h2>Thanks</h2>

<p>I was inspired by:</p>

<ul>
<li>Daniel Jackson’s <a href="https://alloytools.org/">Alloy</a></li>
<li>RelationalAI’s <a href="https://docs.relational.ai/rel/primer/basic-syntax">Rel</a></li>
<li>Jamie Brandon’s <a href="https://www.scattered-thoughts.net/writing/imp-sets-and-funs/">Imp</a></li>
</ul>

<h2>The motivating example</h2>

<p>In trying to <a href="https://capnfabs.net/financial-plan/">tidy up my finances</a> I had to rebalance my portfolio, but even though I had all of my trades loaded into a spreadsheet, I found it difficult to aggregate them by ticker / account / category and calculate the actionable bit — the stocks and quantities I needed to buy/sell to meet a desired allocation.</p>

<p>This example shows the basic pieces I wanted to play with.</p>
<div><pre><span></span>def TradeWide (
  [ &#39;trade-0 2021-12-01 &#39;appl    2    ]
  [ &#39;trade-1 2022-02-01 &#39;appl    3    ]
  [ &#39;trade-2 2022-03-01 &#39;appl    5    ]
  [ &#39;trade-3 2022-06-01 &#39;msft    8    ]
  [ &#39;trade-4 2022-12-01 ?ticker  ?qty ]
)

def Trade      TradeWide[0]
def   date     TradeWide[0 1]
def   ticker   TradeWide[0 2]
def   qty      TradeWide[0 3]

def position sum [
  t: Trade
  t.ticker
  t.qty
]

def latest-px (
  [&#39;appl 2.00]
  [&#39;msft 3.00]
)

def position-value
  position * latest-px

def total-value
  sum position-value[-1]

def proportion
  position-value / total-value

proportion . &#39;appl = 0.5
</pre></div>
<p>The program is basically asking, “What trade should I make so that the mark-to-market value of my portfolio is 50% Apple?” (Answer: buy 2 appl.)</p>

<p>See the video demo above for more explanation.</p>

<h2>Language</h2>

<p>Everything acts on relations (sets of same-arity tuples).</p>

<p>Round parentheses union the contained relations and everything is first-order:</p>
<div><pre><span></span>  (1 2 3)
= (1 (2 3))
= ([1] [2] [3])
</pre></div>
<p>Square brackets cross (cartesian product) the contained relations:</p>
<div><pre><span></span>  [1 (2 3)]
= ([1 2] [1 3])
</pre></div>
<p>These can also include variable bindings and expressions:</p>
<div><pre><span></span>  [x: (1 2)
   x
   x * 2]

= ([1 2]
   [2 4])
</pre></div>
<p>The empty set is “false”, so predicates can be used within square brackets to filter:</p>
<div><pre><span></span>  [x: (1 2)
   y: (1 2)
   x + y = 3
   x
   y]

= ([1 2]
   [2 1])
</pre></div>
<p>The dot joins on the first column, consuming matches:</p>
<div><pre><span></span>  [1 2] . ([1 3] 
           [5 6])
= ([2 3])
</pre></div>
<p>Aggregation and binary operators match tuples based on their “key” (all columns but their last) and operate on the tuple “value” (the last column).</p>
<div><pre><span></span>sum ([1 2]
     [1 3]
     [2 0])

= ([1 5] 
   [2 0])
</pre></div>
<p>With binary operators, this feels a bit like array programming but with symbolic indexes rather than integer ones:</p>
<div><pre><span></span>([&#39;foo 2] 
 [&#39;bar 4]) * ([&#39;bar 4]
              [&#39;foo 1])

= ([&#39;bar 16] 
   [&#39;foo 2])
</pre></div>
<p>The “empty key” matches everything, which allows binary operators and 1-arity tuples to act sensibly:</p>
<div><pre><span></span>2 * ([&#39;foo 1]
     [&#39;bar 2])
= ([&#39;foo 2]
   [&#39;bar 4])
</pre></div>
<p>Symbolic varibles are prefixed with <code>?</code> and can be used anywhere.
They are first-order (scalar values like numbers, not relations) and can take on only a single value (even within square brackets).
Here the constraint on <code>?x</code> forces the value of <code>?s</code>:</p>
<div><pre><span></span>?x = ?s . sum ([&#39;foo 1]
               [&#39;bar 2]
               [?s   3])
?x = 5
// =&gt; {s &#34;bar&#34;, x 5}
</pre></div>
<p>Other examples:</p>
<div><pre><span></span>[?y ?x] in min ([1 2]
                [1 3] 
                [2 0])
?y != 1
// =&gt; {y 2, x 0}
</pre></div>

<div><pre><span></span>[?x ?y ?output] in [x: (1 2 3)
                    y: (3 4 5)
                    x 
                    y 
                    x * y]
maximize ?output
// =&gt; {x 3, y 5, output 15}
</pre></div>
<h2>Implementation</h2>

<p>This prototype is implemented in about 1000 lines of Clojure, leaning heavily on <a href="https://github.com/Engelberg/instaparse">Instaparse</a> and <a href="https://github.com/brandonbloom/backtick">backtick</a> to transform the formula syntax into forms suitable for Clojure’s <code>eval</code>.</p>

<p>I use Clojure’s binary operators, “lifting” them twice.
First to handle symbolic variables:</p>
<div><pre><span></span>(def s+ (lift-symbolic + &#39;+ 0))

(assert (= 0          (s+)))
(assert (= 1          (s+ 1)))
(assert (= 2          (s+ 1 1)))
(assert (= &#39;(+ 3 x)   (s+ 1 2 &#39;x)))
(assert (= &#39;y         (s+ &#39;y)))
(assert (= &#39;(+ x y)   (s+ &#39;x &#39;y)))
</pre></div>
<p>Then again to handle relations:</p>
<div><pre><span></span>(def r+    (lift-relational s+))
(assert (= (-&gt;rel [4])         (r+ (-&gt;rel [1])         (-&gt;rel [3]))))
(assert (= (-&gt;rel [&#39;(+ 1 x)])  (r+ (-&gt;rel [1])         (-&gt;rel [&#39;x]))))
(assert (= (-&gt;rel [1 4])       (r+ (-&gt;rel [1 1])       (-&gt;rel [3]))))
(assert (= (-&gt;rel [1 2] [2 4]) (r+ (-&gt;rel [1 1] [2 2]) (-&gt;rel [1 1] [2 2]))))
</pre></div>
<p>The relational aggregation and join operations track logical conditions on tuple-by-tuple basis.
For example, if <code>[1 2] . [?x 3]</code> join to create the tuple <code>[2 3]</code>, it must be the case that <code>?x = 1</code>.
So the <code>[2 3]</code> tuple better remember that for future operations.</p>

<p>Conceptually, aggregations are reductions yielding a set of “aggregate tuples” whose keys are distinct.
The reduction starts with an empty set and when adding each tuple there are two cases to consider:</p>

<ol>
<li>The tuple’s key doesn’t match anything, so the tuple is added to the aggregation set</li>
<li>The tuple’s key does match, so the tuple’s value is combined with the matching aggregate tuple’s value</li>
</ol>

<p>This is straightforward if everything is known.
However, things get complicated with symbolic variables since whether or not a tuple matches may depend on:</p>

<ol>
<li>Any symbolic variables in the tuple keys</li>
<li>Whether or not the tuple itself exists. I.e., even if all of a tuple’s values are ground (non-symbolic), the tuple itself may be the result of an operation that depends on symbolic variables</li>
</ol>

<p>This leads to a <em>lot</em> of logical conditions, since to prevent double-counting each aggregate tuple’s conditions must assert both that the matching tuples matched and that the non-matching tuples didn’t.</p>

<h2>Future work</h2>

<p>While logical conditions are ad-hoc simplified during some execution steps (e.g., any conjunction containing <code>false</code> is simplified to <code>false</code>), they tend to become enormous after only a few joins/aggregations containing symbolic variables.
I suspect performance could be greatly improved with an approach like <a href="https://egraphs-good.github.io/">equality saturation</a>.</p>

<p>Set semantics have footguns around aggregations as intermediate sets will discard duplicates.
For example, if <code>position-value</code> is <code>([&#39;msft $100] [&#39;appl $100] [&#39;tsmc $50])</code> then the total value calculation <code>sum position-value[-1]</code> will yield $150 rather than the correct $250.
Some systems have dedicated syntax to solve this (e.g., <a href="https://docs.datomic.com/on-prem/query/query.html#with">Datomic’s <em>with</em></a>), but why not just avoid the problem entirely by using bag (multiset) semantics?
(Of course, such a system would require dedicated syntax for deduplication.)</p>

<p>Rewrite in Rust, compile to WASM, and actually publish online so everyone can use it. =D</p>
</div></div>
  </body>
</html>
