<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.codeminer42.com/how-react-19-almost-made-the-internet-slower/">Original</a>
    <h1>React 19 almost made the internet slower</h1>
    
    <div id="readability-page-1" class="page"><div><p>It’s no news that React is still the <a href="https://gist.github.com/tkrotoff/b1caa4c3a185629299ec234d2314e190">most popular and most used</a> UI framework and powers some big names of the web like Netflix, Airbnb, Discord and of course, React’s birthplace, Meta (Facebook, Instagram and Whatsapp). Considering that React is used to create user interfaces that are used by billions of people, it’s reasonable to assume that a sizeable chunk of all of the internet’s traffic is &#34;handled&#34; by React.</p><p>Earlier this year, the much anticipated <a href="https://blog.codeminer42.com/whats-coming-next-in-react-19/">React 19 was announced</a>, but along with all the shiny new features and DX improvements, there was a little change that went unnoticed until <strong>last week</strong> that could potentially degrade in a significant manner the performance of many websites that rely on React.</p><p>It all started with this tweet:</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094424/tk-dodo-first-post.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/TkDodo/status/1800501040766144676">https://x.com/TkDodo/status/1800501040766144676</a></p><p>Which was then followed by quite some reaction:</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094427/adam-rackis-first-post-response.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/AdamRackis/status/1800588094560772224">https://x.com/AdamRackis/status/1800588094560772224</a></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094454/tanner-response.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/tannerlinsley/status/1800903098464096664">https://x.com/tannerlinsley/status/1800903098464096664</a></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094430/adam-rackis-vercel.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/AdamRackis/status/1800663066922963264">https://x.com/AdamRackis/status/1800663066922963264</a></p><p>Now, for those of you who don’t know Dominik, AKA <a href="https://x.com/TkDodo">TkDodo</a>, he’s one of the core maintainers of the widely used <a href="https://tanstack.com/query/latest">TanStack Query</a>, along with the legendary <a href="https://x.com/tannerlinsley">Tanner Linsley</a>.</p><p>But back to the main topic here, the change that’s being discussed is that React 19 <strong>disables parallel rendering of siblings within the same Suspense boundary</strong>, which essentially introduces data fetching waterfalls for data that is fetched inside these siblings.</p><p>Here’s an example of such a thing:</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094440/real-case-waterfall-1.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094445/real-case-waterfall-2.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://github.com/facebook/react/pull/26380#issuecomment-2166178673">https://github.com/facebook/react/pull/26380#issuecomment-2166178673</a></p><p>The worst part of all of this is that although this is a breaking change in terms of performance that’s going to affect a lot of people who rely on this pattern, there’s a <strong>single-line bullet point</strong> unceremoniously mentioning this change.</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094436/react-19-migration.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p>If you’re feeling lost with what I just said, you’re not the only one, I also felt this way the first time I stumbled upon these posts, so fear not as it all is going to make sense soon enough.</p><h2>Suspense Recap</h2><p>To understand what this is all about, we first need to do a quick recap on React’s Suspense.</p><p>Suspense is a React component that lets you display a fallback until its children have finished loading, either because these children components are being lazy loaded, or because they’re making use of a Suspense-enabled data fetching mechanism.</p><p>It is used like this:</p><pre><code>&lt;Suspense fallback={&lt;Loading /&gt;}&gt;
  &lt;ComponentThatFetchesDataOrIsLazyLoaded /&gt;
&lt;/Suspense&gt;</code></pre><p>Although Suspense has been a part of React’s API for quite some time now, for a long time, the only <em>officially approved</em> usage of it was to <strong>lazy load components with <code>React.lazy</code></strong>, which is extremely useful for code-splitting your app and then only loading the split parts when needed.</p><p>When used with <code>React.lazy</code>, when trying to render the lazy loaded component for the first time (that is, before lazy loading it), it would trigger the Suspense boundary (i.e. the <code>Suspense</code> wrapping the component) and render the fallback until fetching the component’s code was finished, and then it would render the component itself.</p><p>For a long time, we’ve been promised <em>official</em> data fetching support for Suspense <strong>on the client</strong> (it already works on the server when using RSCs), but we never really got it until now, and despite that, a lot of libraries (TanStack Query being one of those) have implemented it by investigating React’s internals. Because of that, there are plenty of applications in production that currently <strong>do</strong> use Suspense for data fetching on the client.</p><h2>Understanding the Change</h2><p>As of now (React 18.3.1), when either using suspense-enabled data fetching or lazy loading with <strong>multiple components</strong> within the <strong>same Suspense boundary</strong>, React will try to render <strong>all siblings before bailing out of the render, even if the very first sibling suspends</strong>.</p><p>In practice, this means that the data fetching or lazy loading that happens within these siblings will all initiate <strong>in parallel</strong>.</p><p>Here’s an example that showcases this idea:</p><pre><code>function App() {
  return (
    &lt;&gt;
      &lt;Suspense fallback={&#34;Loading...&#34;}&gt;
        &lt;ComponentThatFetchesData val={1} /&gt;
        &lt;ComponentThatFetchesData val={2} /&gt;
        &lt;ComponentThatFetchesData val={3} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}

const ComponentThatFetchesData = ({ val }) =&gt; {
  const result = fetchSomethingSuspense(val);

  return &lt;div&gt;{result}&lt;/div&gt;;
};</code></pre><p>Demo: <a href="https://stackblitz.com/edit/vitejs-vite-x3nv7r?file=src%2FApp.jsx">https://stackblitz.com/edit/vitejs-vite-x3nv7r?file=src%2FApp.jsx</a></p><p>In this example (in React 18), even though <code>fetchSomethingSuspense</code> causes the first <code>ComponentThatFetchesData</code> to suspend, React will still try to render its siblings, which is going to trigger the data fetching for each of them in parallel.</p><p>This can be seen by looking at the console where we’re logging when each data fetching was triggered:</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094450/stack-blitz-1.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p>All data fetching initiates at almost the exact same time.</p><p>Now let’s look at what happens when we run the <strong>exact same code</strong> in React 19 (canary):</p><p>Demo: <a href="https://stackblitz.com/edit/vitejs-vite-55rddj?file=src%2FApp.jsx">https://stackblitz.com/edit/vitejs-vite-55rddj?file=src%2FApp.jsx</a></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094453/stack-blitz-2.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p>When we look at the console again, we notice that now there’s a waterfall, as each data fetching only initiates <strong>after</strong> the previous one was completed.</p><p>This happens because of the following PR: <a href="https://github.com/facebook/react/pull/26380">https://github.com/facebook/react/pull/26380</a></p><p>After the changes introduced by this PR, instead of trying to render all of the siblings within the same Suspense boundary, React will <strong>bail out on the very first one that suspends</strong>, which in cases like this, makes it such that you first try rendering the first component, then it suspends, then only after its data fetching has finished and you can render it, is that you’ll hit the next sibling, which will suspend again and so on for each sibling.</p><p>Also, this new behavior will not only affect usages of Suspense for data fetching but also <strong>usages with <code>React.lazy</code></strong>, which <strong>were officially supported and are much more widespread as it’s an old pattern</strong>.</p><p><a href="https://x.com/bentonnnnnn/status/1800940807618171270">https://x.com/bentonnnnnn/status/1800940807618171270</a></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094434/lazy-loading.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><h2>Rationale and DX Implications</h2><p>The rationale behind this change, which is written out in the previously mentioned PR, is that <strong>trying to render all siblings before actually suspending is not free</strong>, and essentially delays displaying the fallback. Also, this change goes hand-in-hand with the &#34;render as you fetch&#34; approach that the React team has been pushing since the introduction of Suspense way back before React 18.</p><p>Ideally, instead of initiating the data fetching on the render of the same component that uses it, we should hoist it and start fetching data as early as possible.</p><p>Although this is undisputedly the best approach performance-wise, it does come with a significant DX drawback by making it unfeasible to collocate components and their data requirements.</p><p>I won’t go too deep into this topic because much has been said about it already and there’s even a <a href="https://relay.dev/">whole library</a> that was created specifically to address this very problem, but I’ll leave a few tweets that talk about this specific point:</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094418/teemu-taskula-1.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094421/teemu-taskula-2.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/teemu_taskula/status/1800770818097754509">https://x.com/teemu_taskula/status/1800770818097754509</a></p><p>The main takeaway here is that having both the best possible performance characteristics <strong>and</strong> collocation for components and their data requirements is not really possible without the usage of a <strong>compiler</strong>, which is exactly what Relay does.</p><h2>Aftermath</h2><p>Fortunately, this story has a happy ending. After a lot of public pushback, heated discussions, and probably a good deal of talking behind the scenes, the React team backed out and decided to hold off on this change for now.</p><p><img decoding="async" src="https://i0.wp.com/d604h6pkko9r0.cloudfront.net/wp-content/uploads/2024/06/17094448/sophie.png?w=1200&amp;ssl=1" alt="" data-recalc-dims="1"/></p><p><a href="https://x.com/sophiebits/status/1801663976973209620">https://x.com/sophiebits/status/1801663976973209620</a></p><p>This is not the first time there’s been pushback from the community towards changes that are introduced to React without much regard to how React is used outside Meta and Vercel. The push from React’s team and especially Vercel to make RSCs a fundamental part of building with React is one such case.</p><p>It’s clear that there’s a misalignment between what React’s maintainers think is best for the future of React and the community’s opinions on the subject. Whether these communication issues will deepen or not remains yet to be seen.</p><blockquote><p> We want to work with you. Check out our <a href="https://www.codeminer42.com?utm_source=blog&amp;utm_medium=post&amp;utm_campaign=what-we-do-cta#what-we-do" target="_blank" onclick="window.dataLayer.push({&#39;event&#39;: &#39;what_we_do_redirect&#39;});">&#34;What We Do&#34;</a> section!</p></blockquote></div></div>
  </body>
</html>
