<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/go-1-26/">Original</a>
    <h1>Go 1.26 Interactive Tour</h1>
    
    <div id="readability-page-1" class="page"><div><div><article data-namespace=""><div><div><header></header><p>Go 1.26 is coming out in February, so it&#39;s a good time to explore what&#39;s new. The official <a href="https://tip.golang.org/doc/go1.26">releaseÂ notes</a> are pretty dry, so I prepared an interactive version with lots of examples showing what has changed and what the new behavior is.</p><p>Read on and see!</p><p><a href="#new-expr">new(expr)</a>Â â€¢
<a href="#recursive-type-constraints">Recursive type constraints</a>Â â€¢
<a href="#errors-astype">Type-safe error checking</a>Â â€¢
<a href="#gc">Green Tea GC</a>Â â€¢
<a href="#cgo">Faster cgo and syscalls</a>Â â€¢
<a href="#malloc">Faster memory allocation</a>Â â€¢
<a href="#simd">Vectorized operations</a>Â â€¢
<a href="#runtime-secret">Secret mode</a>Â â€¢
<a href="#crypto-reader">Reader-less cryptography</a>Â â€¢
<a href="#crypto-hpke">Hybrid public key encryption</a>Â â€¢
<a href="#pprof-goroutineleak">Goroutine leak profile</a>Â â€¢
<a href="#runtime-goroutine-metrics">Goroutine metrics</a>Â â€¢
<a href="#reflect-iter">Reflective iterators</a>Â â€¢
<a href="#bytes-buffer-peek">Peek into a buffer</a>Â â€¢
<a href="#os-process-handle">Process handle</a>Â â€¢
<a href="#signal-cause">Signal as cause</a>Â â€¢
<a href="#netip-prefix-compare">Compare IP subnets</a>Â â€¢
<a href="#net-dialer-context">Context-aware dialing</a>Â â€¢
<a href="#httptest-example">Fake example.com</a>Â â€¢
<a href="#fmt-errorf">Optimized fmt.Errorf</a>Â â€¢
<a href="#io-readall">Optimized io.ReadAll</a>Â â€¢
<a href="#slog-multihandler">Multiple log handlers</a>Â â€¢
<a href="#testing-artifacts">Test artifacts</a>Â â€¢
<a href="#modernized-go-fix">Modernized go fix</a>Â â€¢
<a href="#final-thoughts">Final thoughts</a></p><blockquote><p>This article is based on the official release notes from The Go Authors and the Go source code, licensed under the BSD-3-Clause license. This is not an exhaustive list; see the official release notes for that.</p></blockquote><p>I provide links to the documentation (ğ——), proposals (ğ—£), commits (ğ—–ğ—Ÿ), and authors (ğ—”) for the features described. Check them out for motivation, usage, and implementation details. I also have dedicated guides (ğ—š) for some of the features.</p><p>Error handling is often skipped to keep things simple. Don&#39;t do this in production ãƒ„</p><h2 id="new-expr"><a href="#new-expr">#</a>
new(expr)</h2><p>Previously, you could only use the <code>new</code> built-in with types:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>p</span> <span>:=</span> <span>new</span><span>(</span><span>int</span><span>)</span>
</span></span><span><span><span>*</span><span>p</span> <span>=</span> <span>42</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>*</span><span>p</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="main.go" output=""></codapi-snippet><p>Now you can also use it with expressions:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Pointer to a int variable with the value 42.
</span></span></span><span><span><span></span><span>p</span> <span>:=</span> <span>new</span><span>(</span><span>42</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>*</span><span>p</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="main.go" output=""></codapi-snippet><p>If the argument <code>expr</code> is an expression of type T, then <code>new(expr)</code> allocates a variable of type T, initializes it to the value of <code>expr</code>, and returns its address, a value of type <code>*T</code>.</p><p>This feature is especially helpful if you use pointer fields in a struct to represent optional values that you marshal to JSON or Protobuf:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>Cat</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Name</span> <span>string</span> <span>`json:&#34;name&#34;`</span>
</span></span><span><span>    <span>Fed</span>  <span>*</span><span>bool</span>  <span>`json:&#34;is_fed&#34;`</span> <span>// you can never be sure
</span></span></span><span><span><span></span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>cat</span> <span>:=</span> <span>Cat</span><span>{</span><span>Name</span><span>:</span> <span>&#34;Mittens&#34;</span><span>,</span> <span>Fed</span><span>:</span> <span>new</span><span>(</span><span>true</span><span>)}</span>
</span></span><span><span><span>data</span><span>,</span> <span>_</span> <span>:=</span> <span>json</span><span>.</span><span>Marshal</span><span>(</span><span>cat</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>string</span><span>(</span><span>data</span><span>))</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="main.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>{&#34;name&#34;:&#34;Mittens&#34;,&#34;is_fed&#34;:true}
</span></span></code></pre></div><p>You can use <code>new</code> with composite values:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>s</span> <span>:=</span> <span>new</span><span>([]</span><span>int</span><span>{</span><span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>})</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>*</span><span>s</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Person</span> <span>struct</span><span>{</span> <span>name</span> <span>string</span> <span>}</span>
</span></span><span><span><span>p</span> <span>:=</span> <span>new</span><span>(</span><span>Person</span><span>{</span><span>name</span><span>:</span> <span>&#34;alice&#34;</span><span>})</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>*</span><span>p</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="main.go" output=""></codapi-snippet><p>And function calls:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>f</span> <span>:=</span> <span>func</span><span>()</span> <span>string</span> <span>{</span> <span>return</span> <span>&#34;go&#34;</span> <span>}</span>
</span></span><span><span><span>p</span> <span>:=</span> <span>new</span><span>(</span><span>f</span><span>())</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>*</span><span>p</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="main.go" output=""></codapi-snippet><p>Passing <code>nil</code> is still not allowed:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>p</span> <span>:=</span> <span>new</span><span>(</span><span>nil</span><span>)</span>
</span></span><span><span><span>// compilation error
</span></span></span></code></pre></div><p>ğ—— <a href="https://tip.golang.org/ref/spec#Allocation">spec</a> â€¢
ğ—£ <a href="https://go.dev/issue/45624">45624</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/704935">704935</a>, <a href="https://go.dev/cl/704737">704737</a>, <a href="https://go.dev/cl/704955">704955</a>, <a href="https://go.dev/cl/705157">705157</a> â€¢
ğ—” <a href="https://github.com/adonovan">Alan Donovan</a></p><h2 id="recursive-type-constraints"><a href="#recursive-type-constraints">#</a>
Recursive type constraints</h2><p>Generic functions and types take types as parameters:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// A list of values.
</span></span></span><span><span><span></span><span>type</span> <span>List</span><span>[</span><span>T</span> <span>any</span><span>]</span> <span>struct</span> <span>{}</span>
</span></span><span><span>
</span></span><span><span><span>// Reverses a slice in-place.
</span></span></span><span><span><span></span><span>func</span> <span>Reverse</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>s</span> <span>[]</span><span>T</span><span>)</span>
</span></span></code></pre></div><p>We can further restrict these type parameters by using type constraints:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// The map key must have a comparable type.
</span></span></span><span><span><span></span><span>type</span> <span>Map</span><span>[</span><span>K</span> <span>comparable</span><span>,</span> <span>V</span> <span>any</span><span>]</span> <span>struct</span> <span>{}</span>
</span></span><span><span>
</span></span><span><span><span>// S is a slice with values of a comparable type,
</span></span></span><span><span><span>// or a type derived from such a slice (e.g., type MySlice []int).
</span></span></span><span><span><span></span><span>func</span> <span>Compact</span><span>[</span><span>S</span> <span>~[]</span><span>E</span><span>,</span> <span>E</span> <span>comparable</span><span>](</span><span>s</span> <span>S</span><span>)</span> <span>S</span>
</span></span></code></pre></div><p>Previously, type constraints couldn&#39;t directly or indirectly refer back to the generic type:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>T</span><span>[</span><span>P</span> <span>T</span><span>[</span><span>P</span><span>]]</span> <span>struct</span><span>{}</span>
</span></span><span><span><span>// compile error:
</span></span></span><span><span><span>// invalid recursive type: T refers to itself
</span></span></span></code></pre></div><p>Now they can:</p><codapi-snippet sandbox="go:dev" editor="basic" template="type.go" output=""></codapi-snippet><p>A typical use case is a generic type that supports operations with arguments or results of the same type as itself:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// A value that can be compared to other values
</span></span></span><span><span><span>// of the same type using the less-than operation.
</span></span></span><span><span><span></span><span>type</span> <span>Ordered</span><span>[</span><span>T</span> <span>Ordered</span><span>[</span><span>T</span><span>]]</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>Less</span><span>(</span><span>T</span><span>)</span> <span>bool</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet id="s-type-ordered" editor="basic"></codapi-snippet><p>Now we can create a generic container with <code>Ordered</code> values and use it with any type that implements <code>Less</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// A tree stores comparable values.
</span></span></span><span><span><span></span><span>type</span> <span>Tree</span><span>[</span><span>T</span> <span>Ordered</span><span>[</span><span>T</span><span>]]</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>nodes</span> <span>[]</span><span>T</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// netip.Addr has a Less method with the right signature,
</span></span></span><span><span><span>// so it meets the requirements for Ordered[netip.Addr].
</span></span></span><span><span><span></span><span>t</span> <span>:=</span> <span>Tree</span><span>[</span><span>netip</span><span>.</span><span>Addr</span><span>]{}</span>
</span></span><span><span><span>_</span> <span>=</span> <span>t</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="type.go" depends-on="s-type-ordered" output=""></codapi-snippet><p>This makes Go&#39;s generics a bit more expressive.</p><p>ğ—£ <a href="https://go.dev/issue/68162">68162</a>, <a href="https://go.dev/issue/75883">75883</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/711420">711420</a>, <a href="https://go.dev/cl/711422">711422</a> â€¢
ğ—” <a href="https://github.com/griesemer">Robert Griesemer</a></p><h2 id="errors-astype"><a href="#errors-astype">#</a>
Type-safe error checking</h2><p>The new <code>errors.AsType</code> function is a generic version of <code>errors.As</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.13+
</span></span></span><span><span><span></span><span>func</span> <span>As</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>target</span> <span>any</span><span>)</span> <span>bool</span>
</span></span><span><span><span>// go 1.26+
</span></span></span><span><span><span></span><span>func</span> <span>AsType</span><span>[</span><span>E</span> <span>error</span><span>](</span><span>err</span> <span>error</span><span>)</span> <span>(</span><span>E</span><span>,</span> <span>bool</span><span>)</span>
</span></span></code></pre></div><p>It&#39;s type-safe and easier to use:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// using errors.As
</span></span></span><span><span><span></span><span>var</span> <span>target</span> <span>*</span><span>AppError</span>
</span></span><span><span><span>if</span> <span>errors</span><span>.</span><span>As</span><span>(</span><span>err</span><span>,</span> <span>&amp;</span><span>target</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;application error:&#34;</span><span>,</span> <span>target</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go" editor="basic" template="errors-1.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>application error: database is down
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="go"><span><span><span>// using errors.AsType
</span></span></span><span><span><span></span><span>if</span> <span>target</span><span>,</span> <span>ok</span> <span>:=</span> <span>errors</span><span>.</span><span>AsType</span><span>[</span><span>*</span><span>AppError</span><span>](</span><span>err</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;application error:&#34;</span><span>,</span> <span>target</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="errors-1.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>application error: database is down
</span></span></code></pre></div><p><code>AsType</code> is especially handy when checking for multiple types of errors. It makes the code shorter and keeps error variables scoped to their <code>if</code> blocks:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>connErr</span><span>,</span> <span>ok</span> <span>:=</span> <span>errors</span><span>.</span><span>AsType</span><span>[</span><span>*</span><span>net</span><span>.</span><span>OpError</span><span>](</span><span>err</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Network operation failed:&#34;</span><span>,</span> <span>connErr</span><span>.</span><span>Op</span><span>)</span>
</span></span><span><span><span>}</span> <span>else</span> <span>if</span> <span>dnsErr</span><span>,</span> <span>ok</span> <span>:=</span> <span>errors</span><span>.</span><span>AsType</span><span>[</span><span>*</span><span>net</span><span>.</span><span>DNSError</span><span>](</span><span>err</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;DNS resolution failed:&#34;</span><span>,</span> <span>dnsErr</span><span>.</span><span>Name</span><span>)</span>
</span></span><span><span><span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Unknown error&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="errors-2.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>DNS resolution failed: does.not.exist
</span></span></code></pre></div><p>Another issue with <code>As</code> is that it uses reflection and can cause runtime panics if used incorrectly (like if you pass a non-pointer or a type that doesn&#39;t implement <code>error</code>):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// using errors.As
</span></span></span><span><span><span></span><span>var</span> <span>target</span> <span>AppError</span>
</span></span><span><span><span>if</span> <span>errors</span><span>.</span><span>As</span><span>(</span><span>err</span><span>,</span> <span>&amp;</span><span>target</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;application error:&#34;</span><span>,</span> <span>target</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go" editor="basic" template="errors-1.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>panic: errors: *target must be interface or implement error
</span></span></code></pre></div><p><code>AsType</code> doesn&#39;t cause a runtime panic; it gives a clear compile-time error instead:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// using errors.AsType
</span></span></span><span><span><span></span><span>if</span> <span>target</span><span>,</span> <span>ok</span> <span>:=</span> <span>errors</span><span>.</span><span>AsType</span><span>[</span><span>AppError</span><span>](</span><span>err</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;application error:&#34;</span><span>,</span> <span>target</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="errors-1.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>./main.go:24:32: AppError does not satisfy error (method Error has pointer receiver)
</span></span></code></pre></div><p><code>AsType</code> doesn&#39;t use <code>reflect</code>, executes faster, and allocates less than <code>As</code>:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: darwin
</span></span><span><span>goarch: arm64
</span></span><span><span>cpu: Apple M1
</span></span><span><span>BenchmarkAs-8        12606744    95.62 ns/op    40 B/op    2 allocs/op
</span></span><span><span>BenchmarkAsType-8    37961869    30.26 ns/op    24 B/op    1 allocs/op
</span></span></code></pre></div><p><a href="https://github.com/golang/go/blob/release-branch.go1.26/src/errors/wrap_test.go">source</a></p><p>Since <code>AsType</code> can handle everything that <code>As</code> does, it&#39;s a recommended drop-in replacement for new code.</p><p>ğ—— <a href="https://pkg.go.dev/errors@go1.26rc1#AsType">errors.AsType</a> â€¢
ğ—£ <a href="https://go.dev/issue/51945">51945</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/707235">707235</a> â€¢
ğ—” <a href="https://github.com/jub0bs">Julien Cretel</a></p><h2 id="gc"><a href="#gc">#</a>
Green Tea garbage collector</h2><p>The new garbage collector (first introduced as experimental in 1.25) is designed to make memory management more efficient on modern computers with many CPU cores.</p><h3 id="motivation">Motivation</h3><p>Go&#39;s traditional garbage collector algorithm operates on graph, treating objects as nodes and pointers as edges, without considering their physical location in memory. The scanner jumps between distant memory locations, causing frequent cache misses.</p><p>As a result, the CPU spends too much time waiting for data to arrive from memory. More than 35% of the time spent scanning memory is wasted just stalling while waiting for memory accesses. As computers get more CPU cores, this problem gets even worse.</p><h3 id="implementation">Implementation</h3><p>Green Tea shifts the focus from being processor-centered to being memory-aware. Instead of scanning individual objects, it scans memory in contiguous 8 KiB blocks called <em>spans</em>. The algorithm focuses on small objects (up to 512 bytes) because they are the most common and hardest to scan efficiently.</p><p>Each span is divided into equal slots based on its assigned <em>size class</em>, and it only contains objects of that size class. For example, if a span is assigned to the 32-byte size class, the whole block is split into 32-byte slots, and objects are placed directly into these slots, each starting at the beginning of its slot. Because of this fixed layout, the garbage collector can easily find an object&#39;s metadata using simple address arithmetic, without checking the size of each object it finds.</p><p>When the algorithm finds an object that needs to be scanned, it marks the object&#39;s location in its span but doesn&#39;t scan it immediately. Instead, it waits until there are several objects in the same span that need scanning. Then, when the garbage collector processes that span, it scans multiple objects at once. This is much faster than going over the same area of memory multiple times.</p><p>To make better use of CPU cores, GC workers share the workload by stealing tasks from each other. Each worker has its own local queue of spans to scan, and if a worker is idle, it can grab tasks from the queues of other busy workers. This decentralized approach removes the need for a central global list, prevents delays, and reduces contention between CPU cores.</p><p>Green Tea uses vectorized CPU instructions (only on amd64 architectures) to process memory spans in bulk when there are enough objects.</p><h3 id="benchmarks">Benchmarks</h3><p>Benchmark results vary, but the Go team expects a 10â€“40% reduction in garbage collection overhead in real-world programs that rely heavily on the garbage collector. Plus, with vectorized implementation, an extra 10% reduction in GC overhead when running on CPUs like Intel Ice Lake or AMD Zen 4 and newer.</p><blockquote><p>Unfortunately, I couldn&#39;t find any public benchmark results from the Go team for the latest version of Green Tea, and I wasn&#39;t able to create a good synthetic benchmark myself. So, no details this time :(</p></blockquote><p>The new garbage collector is enabled by default. To use the old garbage collector, set <code>GOEXPERIMENT=nogreenteagc</code> at build time (this option is expected to be removed in Go 1.27).</p><p>ğ—£ <a href="https://go.dev/issue/73581">73581</a> â€¢
ğ—” <a href="https://github.com/mknyszek">Michael Knyszek</a></p><h2 id="cgo"><a href="#cgo">#</a>
Faster cgo and syscalls</h2><p>In the Go runtime, a <em>processor</em> (often referred to as a P) is a resource required to run the code. For a thread (a <em>machine</em> or M) to execute a goroutine (G), it must first acquire a processor.</p><p>Processors move through different states. They can be <code>_Prunning</code> (executing code), <code>_Pidle</code> (waiting for work), or <code>_Pgcstop</code> (paused because of the garbage collection).</p><p>Previously, processors had a state called <code>_Psyscall</code> used when a goroutine is making a system or cgo call. Now, this state has been removed. Instead of using a separate processor state, the system now checks the status of the goroutine assigned to the processor to see if it&#39;s involved in a system call.</p><p>This reduces internal runtime overhead and simplifies code paths for cgo and syscalls. The Go release notes say -30% in cgo runtime overhead, and the commit mentions an 18% sec/op improvement:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: linux
</span></span><span><span>goarch: amd64
</span></span><span><span>pkg: internal/runtime/cgobench
</span></span><span><span>cpu: AMD EPYC 7B13
</span></span><span><span>                   â”‚ before.out  â”‚             after.out              â”‚
</span></span><span><span>                   â”‚   sec/op    â”‚   sec/op     vs base               â”‚
</span></span><span><span>CgoCall-64           43.69n Â± 1%   35.83n Â± 1%  -17.99% (p=0.002 n=6)
</span></span><span><span>CgoCallParallel-64   5.306n Â± 1%   5.338n Â± 1%        ~ (p=0.132 n=6)
</span></span></code></pre></div><p>I decided to run the <a href="https://github.com/golang/go/blob/release-branch.go1.26/src/internal/runtime/cgobench/bench_test.go">CgoCall</a> benchmarks locally as well:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: darwin
</span></span><span><span>goarch: arm64
</span></span><span><span>cpu: Apple M1
</span></span><span><span>                      â”‚ go1_25.txt  â”‚             go1_26.txt              â”‚
</span></span><span><span>                      â”‚   sec/op    â”‚   sec/op     vs base                â”‚
</span></span><span><span>CgoCall-8               28.55n Â± 4%   19.02n Â± 2%  -33.40% (p=0.000 n=10)
</span></span><span><span>CgoCallWithCallback-8   72.76n Â± 5%   57.38n Â± 2%  -21.14% (p=0.000 n=10)
</span></span><span><span>geomean                 45.58n        33.03n       -27.53%
</span></span></code></pre></div><p>Either way, both a 20% and a 30% improvement are pretty impressive.</p><p>And here are the results from a local syscall benchmark:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: darwin
</span></span><span><span>goarch: arm64
</span></span><span><span>cpu: Apple M1
</span></span><span><span>          â”‚ go1_25.txt  â”‚             go1_26.txt             â”‚
</span></span><span><span>          â”‚   sec/op    â”‚   sec/op     vs base               â”‚
</span></span><span><span>Syscall-8   195.6n Â± 4%   178.1n Â± 1%  -8.95% (p=0.000 n=10)
</span></span></code></pre></div><details><summary>source</summary><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkSyscall</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>for</span> <span>b</span><span>.</span><span>Loop</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>_</span><span>,</span> <span>_</span><span>,</span> <span>_</span> <span>=</span> <span>syscall</span><span>.</span><span>Syscall</span><span>(</span><span>syscall</span><span>.</span><span>SYS_GETPID</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></details><p>That&#39;s pretty good too.</p><p>ğ—–ğ—Ÿ <a href="https://go.dev/cl/646198">646198</a> â€¢
ğ—” <a href="https://github.com/mknyszek">Michael Knyszek</a></p><h2 id="malloc"><a href="#malloc">#</a>
Faster memory allocation</h2><p>The Go runtime now has specialized versions of its memory allocation function for small objects (from 1 to 512 bytes). It uses jump tables to quickly choose the right function for each size, instead of relying on a single general-purpose implementation.</p><blockquote><p>The Go release notes say &#34;the compiler will now generate calls to size-specialized memory allocation routines&#34;. But based on the code, that&#39;s not completely accurate: the compiler still emits calls to the general-purpose <code>mallocgc</code> function. Then, at runtime, <code>mallocgc</code> dispatches those calls to the new specialized allocation functions.</p></blockquote><p>This change reduces the cost of small object memory allocations by up to 30%. The Go team expects the overall improvement to be ~1% in real allocation-heavy programs.</p><p>I couldn&#39;t find any existing benchmarks, so I came up with my own. And indeed, running it on Go 1.25 compared to 1.26 shows a significant improvement:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: darwin
</span></span><span><span>goarch: arm64
</span></span><span><span>cpu: Apple M1
</span></span><span><span>           â”‚  go1_25.txt   â”‚              go1_26.txt              â”‚
</span></span><span><span>           â”‚    sec/op     â”‚    sec/op     vs base                â”‚
</span></span><span><span>Alloc1-8      8.190n Â±  6%   6.594n Â± 28%  -19.48% (p=0.011 n=10)
</span></span><span><span>Alloc8-8      8.648n Â± 16%   7.522n Â±  4%  -13.02% (p=0.000 n=10)
</span></span><span><span>Alloc64-8     15.70n Â± 15%   12.57n Â±  4%  -19.88% (p=0.000 n=10)
</span></span><span><span>Alloc128-8    56.80n Â±  4%   17.56n Â±  4%  -69.08% (p=0.000 n=10)
</span></span><span><span>Alloc512-8    81.50n Â± 10%   55.24n Â±  5%  -32.23% (p=0.000 n=10)
</span></span><span><span>geomean       21.99n         14.33n        -34.83%
</span></span></code></pre></div><details><summary>source</summary><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>sink</span> <span>*</span><span>byte</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>benchmarkAlloc</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>,</span> <span>size</span> <span>int</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>b</span><span>.</span><span>ReportAllocs</span><span>()</span>
</span></span><span><span>    <span>for</span> <span>b</span><span>.</span><span>Loop</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>obj</span> <span>:=</span> <span>make</span><span>([]</span><span>byte</span><span>,</span> <span>size</span><span>)</span>
</span></span><span><span>        <span>sink</span> <span>=</span> <span>&amp;</span><span>obj</span><span>[</span><span>0</span><span>]</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>BenchmarkAlloc1</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span>   <span>{</span> <span>benchmarkAlloc</span><span>(</span><span>b</span><span>,</span> <span>1</span><span>)</span> <span>}</span>
</span></span><span><span><span>func</span> <span>BenchmarkAlloc8</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span>   <span>{</span> <span>benchmarkAlloc</span><span>(</span><span>b</span><span>,</span> <span>8</span><span>)</span> <span>}</span>
</span></span><span><span><span>func</span> <span>BenchmarkAlloc64</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span>  <span>{</span> <span>benchmarkAlloc</span><span>(</span><span>b</span><span>,</span> <span>64</span><span>)</span> <span>}</span>
</span></span><span><span><span>func</span> <span>BenchmarkAlloc128</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span> <span>benchmarkAlloc</span><span>(</span><span>b</span><span>,</span> <span>128</span><span>)</span> <span>}</span>
</span></span><span><span><span>func</span> <span>BenchmarkAlloc512</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span> <span>benchmarkAlloc</span><span>(</span><span>b</span><span>,</span> <span>512</span><span>)</span> <span>}</span>
</span></span></code></pre></div></details><p>The new implementation is enabled by default. You can disable it by setting <code>GOEXPERIMENT=nosizespecializedmalloc</code> at build time (this option is expected to be removed in Go 1.27).</p><p>ğ—–ğ—Ÿ <a href="https://go.dev/cl/665835">665835</a> â€¢
ğ—” <a href="https://github.com/matloob">Michael Matloob</a></p><h2 id="simd"><a href="#simd">#</a>
Vectorized operations (experimental)</h2><p>The new <code>simd/archsimd</code> package provides access to architecture-specific vectorized operations (SIMD â€” single instruction, multiple data). This is a low-level package that exposes hardware-specific functionality. It currently only supports amd64 platforms.</p><p>Because different CPU architectures have very different SIMD operations, it&#39;s hard to create a single portable API that works for all of them. So the Go team decided to start with a low-level, architecture-specific API first, giving &#34;power users&#34; immediate access to SIMD features on the most common server platform â€” amd64.</p><p>The package defines vector types as structs, like <code>Int8x16</code> (a 128-bit SIMD vector with sixteen 8-bit integers) and <code>Float64x8</code> (a 512-bit SIMD vector with eight 64-bit floats). These match the hardware&#39;s vector registers. The package supports vectors that are 128, 256, or 512 bits wide.</p><p>Most operations are defined as methods on vector types. They usually map directly to hardware instructions with zero overhead.</p><p>To give you a taste, here&#39;s a custom function that uses SIMD instructions to add 32-bit float vectors:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>Add</span><span>(</span><span>a</span><span>,</span> <span>b</span> <span>[]</span><span>float32</span><span>)</span> <span>[]</span><span>float32</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>len</span><span>(</span><span>a</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>b</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>&#34;slices of different length&#34;</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// If AVX-512 isn&#39;t supported, fall back to scalar addition,
</span></span></span><span><span><span></span>    <span>// since the Float32x16.Add method needs the AVX-512 instruction set.
</span></span></span><span><span><span></span>    <span>if</span> <span>!</span><span>archsimd</span><span>.</span><span>X86</span><span>.</span><span>AVX512</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>fallbackAdd</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>res</span> <span>:=</span> <span>make</span><span>([]</span><span>float32</span><span>,</span> <span>len</span><span>(</span><span>a</span><span>))</span>
</span></span><span><span>    <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>a</span><span>)</span>
</span></span><span><span>    <span>i</span> <span>:=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>// 1. SIMD loop: Process 16 elements at a time.
</span></span></span><span><span><span></span>    <span>for</span> <span>i</span> <span>&lt;=</span> <span>n</span><span>-</span><span>16</span> <span>{</span>
</span></span><span><span>        <span>// Load 16 elements from a and b vectors.
</span></span></span><span><span><span></span>        <span>va</span> <span>:=</span> <span>archsimd</span><span>.</span><span>LoadFloat32x16Slice</span><span>(</span><span>a</span><span>[</span><span>i</span> <span>:</span> <span>i</span><span>+</span><span>16</span><span>])</span>
</span></span><span><span>        <span>vb</span> <span>:=</span> <span>archsimd</span><span>.</span><span>LoadFloat32x16Slice</span><span>(</span><span>b</span><span>[</span><span>i</span> <span>:</span> <span>i</span><span>+</span><span>16</span><span>])</span>
</span></span><span><span>
</span></span><span><span>        <span>// Add all 16 elements in a single instruction
</span></span></span><span><span><span></span>        <span>// and store the results in the result vector.
</span></span></span><span><span><span></span>        <span>vSum</span> <span>:=</span> <span>va</span><span>.</span><span>Add</span><span>(</span><span>vb</span><span>)</span> <span>// translates to VADDPS asm instruction
</span></span></span><span><span><span></span>        <span>vSum</span><span>.</span><span>StoreSlice</span><span>(</span><span>res</span><span>[</span><span>i</span> <span>:</span> <span>i</span><span>+</span><span>16</span><span>])</span>
</span></span><span><span>
</span></span><span><span>        <span>i</span> <span>+=</span> <span>16</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// 2. Scalar tail: Process any remaining elements (0-15).
</span></span></span><span><span><span></span>    <span>for</span> <span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>        <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>b</span><span>[</span><span>i</span><span>]</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>res</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet id="s-simd-add" editor="basic"></codapi-snippet><p>Let&#39;s try it on two vectors:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>a</span> <span>:=</span> <span>[]</span><span>float32</span><span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>}</span>
</span></span><span><span>    <span>b</span> <span>:=</span> <span>[]</span><span>float32</span><span>{</span><span>17</span><span>,</span> <span>16</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>13</span><span>,</span> <span>12</span><span>,</span> <span>11</span><span>,</span> <span>10</span><span>,</span> <span>9</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>}</span>
</span></span><span><span>    <span>res</span> <span>:=</span> <span>Add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>res</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="simd.go" depends-on="s-simd-add" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>[18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18]
</span></span></code></pre></div><p>Common operations in the <code>archsimd</code> package include:</p><ul><li><code>Load</code> a vector from array/slice, or <code>Store</code> a vector to array/slice.</li><li>Arithmetic: <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>DotProduct</code>.</li><li>Bitwise: <code>And</code>, <code>Or</code>, <code>Not</code>, <code>Xor</code>, <code>Shift</code>.</li><li>Comparison: <code>Equal</code>, <code>Greater</code>, <code>Less</code>, <code>Min</code>, <code>Max</code>.</li><li>Conversion: <code>As</code>, <code>SaturateTo</code>, <code>TruncateTo</code>.</li><li>Masking: <code>Compress</code>, <code>Masked</code>, <code>Merge</code>.</li><li>Rearrangement: <code>Permute</code>.</li></ul><p>The package uses only AVX instructions, not SSE.</p><p>Here&#39;s a simple benchmark for adding two vectors (both the &#34;plain&#34; and SIMD versions use pre-allocated slices):</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: linux
</span></span><span><span>goarch: amd64
</span></span><span><span>cpu: AMD EPYC 9575F 64-Core Processor
</span></span><span><span>BenchmarkAddPlain/1k-2         	 1517698	       889.9 ns/op	13808.74 MB/s
</span></span><span><span>BenchmarkAddPlain/65k-2        	   23448	     52613 ns/op	14947.46 MB/s
</span></span><span><span>BenchmarkAddPlain/1m-2         	    2047	   1005628 ns/op	11932.84 MB/s
</span></span><span><span>BenchmarkAddSIMD/1k-2          	36594340	        33.58 ns/op	365949.74 MB/s
</span></span><span><span>BenchmarkAddSIMD/65k-2         	  410742	      3199 ns/op	245838.52 MB/s
</span></span><span><span>BenchmarkAddSIMD/1m-2          	   12955	     94228 ns/op	127351.33 MB/s
</span></span></code></pre></div><p><a href="https://go.dev/play/p/4_nCOcP3voQ?v=gotip">source</a></p><p>The package is experimental and can be enabled by setting <code>GOEXPERIMENT=simd</code> at build time.</p><p>ğ—— <a href="https://pkg.go.dev/simd/archsimd@go1.26rc1">simd/archsimd</a> â€¢
ğ—£ <a href="https://go.dev/issue/73787">73787</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/701915">701915</a>, <a href="https://go.dev/cl/712880">712880</a>, <a href="https://go.dev/cl/729900">729900</a>, <a href="https://go.dev/cl/732020">732020</a> â€¢
ğ—” <a href="https://github.com/JunyangShao">Junyang Shao</a>, <a href="https://github.com/seankhliao">Sean Liao</a>, <a href="https://github.com/tmthrgd">Tom Thorogood</a></p><h2 id="runtime-secret"><a href="#runtime-secret">#</a>
Secret mode (experimental)</h2><p>Cryptographic protocols like WireGuard or TLS have a property called &#34;forward secrecy&#34;. This means that even if an attacker gains access to long-term secrets (like a private key in TLS), they shouldn&#39;t be able to decrypt past communication sessions. To make this work, ephemeral keys (temporary keys used to negotiate the session) need to be erased from memory immediately after the handshake. If there&#39;s no reliable way to clear this memory, these keys could stay there indefinitely. An attacker who finds them later could re-derive the session key and decrypt past traffic, breaking forward secrecy.</p><p>In Go, the runtime manages memory, and it doesn&#39;t guarantee when or how memory is cleared. Sensitive data might remain in heap allocations or stack frames, potentially exposed in core dumps or through memory attacks. Developers often have to use unreliable &#34;hacks&#34; with reflection to try to zero out internal buffers in cryptographic libraries. Even so, some data might still stay in memory where the developer can&#39;t reach or control it.</p><p>The Go team&#39;s solution to this problem is the new <code>runtime/secret</code> package. It lets you run a function in <em>secret mode</em>. After the function finishes, it immediately erases (zeroes out) the registers and stack it used. Heap allocations made by the function are erased as soon as the garbage collector decides they are no longer reachable.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>secret</span><span>.</span><span>Do</span><span>(</span><span>func</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>// Generate an ephemeral key and
</span></span></span><span><span><span></span>    <span>// use it to negotiate the session.
</span></span></span><span><span><span></span><span>})</span>
</span></span></code></pre></div><p>This helps make sure sensitive information doesn&#39;t stay in memory longer than needed, lowering the risk of attackers getting to it.</p><p>Here&#39;s an example that shows how <code>secret.Do</code> might be used in a more or less realistic setting. Let&#39;s say you want to generate a session key while keeping the ephemeral private key and shared secret safe:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// DeriveSessionKey does an ephemeral key exchange to create a session key.
</span></span></span><span><span><span></span><span>func</span> <span>DeriveSessionKey</span><span>(</span><span>peerPublicKey</span> <span>*</span><span>ecdh</span><span>.</span><span>PublicKey</span><span>)</span> <span>(</span><span>*</span><span>ecdh</span><span>.</span><span>PublicKey</span><span>,</span> <span>[]</span><span>byte</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>var</span> <span>pubKey</span> <span>*</span><span>ecdh</span><span>.</span><span>PublicKey</span>
</span></span><span><span>    <span>var</span> <span>sessionKey</span> <span>[]</span><span>byte</span>
</span></span><span><span>    <span>var</span> <span>err</span> <span>error</span>
</span></span><span><span>
</span></span><span><span>    <span>// Use secret.Do to contain the sensitive data during the handshake.
</span></span></span><span><span><span></span>    <span>// The ephemeral private key and the raw shared secret will be
</span></span></span><span><span><span></span>    <span>// wiped out when this function finishes.
</span></span></span><span><span><span></span>    <span>secret</span><span>.</span><span>Do</span><span>(</span><span>func</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>// 1. Generate an ephemeral private key.
</span></span></span><span><span><span></span>        <span>// This is highly sensitive; if leaked later, forward secrecy is broken.
</span></span></span><span><span><span></span>        <span>privKey</span><span>,</span> <span>e</span> <span>:=</span> <span>ecdh</span><span>.</span><span>P256</span><span>().</span><span>GenerateKey</span><span>(</span><span>rand</span><span>.</span><span>Reader</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>e</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>err</span> <span>=</span> <span>e</span>
</span></span><span><span>            <span>return</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>// 2. Compute the shared secret (ECDH).
</span></span></span><span><span><span></span>        <span>// This raw secret is also highly sensitive.
</span></span></span><span><span><span></span>        <span>sharedSecret</span><span>,</span> <span>e</span> <span>:=</span> <span>privKey</span><span>.</span><span>ECDH</span><span>(</span><span>peerPublicKey</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>e</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>err</span> <span>=</span> <span>e</span>
</span></span><span><span>            <span>return</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>// 3. Derive the final session key (e.g., using HKDF).
</span></span></span><span><span><span></span>        <span>// We copy the result out; the inputs (privKey, sharedSecret)
</span></span></span><span><span><span></span>        <span>// will be destroyed by secret.Do when they become unreachable.
</span></span></span><span><span><span></span>        <span>sessionKey</span> <span>=</span> <span>performHKDF</span><span>(</span><span>sharedSecret</span><span>)</span>
</span></span><span><span>        <span>pubKey</span> <span>=</span> <span>privKey</span><span>.</span><span>PublicKey</span><span>()</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>
</span></span><span><span>    <span>// The session key is returned for use, but the &#34;recipe&#34; to recreate it
</span></span></span><span><span><span></span>    <span>// is destroyed. Additionally, because the session key was allocated
</span></span></span><span><span><span></span>    <span>// inside the secret block, the runtime will automatically zero it out
</span></span></span><span><span><span></span>    <span>// when the application is finished using it.
</span></span></span><span><span><span></span>    <span>return</span> <span>pubKey</span><span>,</span> <span>sessionKey</span><span>,</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet id="s-secret-derive" editor="basic"></codapi-snippet><p>Here, the ephemeral private key and the raw shared secret are effectively &#34;toxic waste&#34; â€” they are necessary to create the final session key, but dangerous to keep around.</p><p>If these values stay in the heap and an attacker later gets access to the application&#39;s memory (for example, via a core dump or a vulnerability like Heartbleed), they could use these intermediates to re-derive the session key and decrypt past conversations.</p><p>By wrapping the calculation in <code>secret.Do</code>, we make sure that as soon as the session key is created, the &#34;ingredients&#34; used to make it are permanently destroyed. This means that even if the server is compromised in the future, this specific past session can&#39;t be exposed, which ensures forward secrecy.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>// Generate a dummy peer public key.
</span></span></span><span><span><span></span>    <span>priv</span><span>,</span> <span>_</span> <span>:=</span> <span>ecdh</span><span>.</span><span>P256</span><span>().</span><span>GenerateKey</span><span>(</span><span>nil</span><span>)</span>
</span></span><span><span>    <span>peerPubKey</span> <span>:=</span> <span>priv</span><span>.</span><span>PublicKey</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>// Derive the session key.
</span></span></span><span><span><span></span>    <span>pubKey</span><span>,</span> <span>sessionKey</span><span>,</span> <span>err</span> <span>:=</span> <span>DeriveSessionKey</span><span>(</span><span>peerPubKey</span><span>)</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;public key = %x...\n&#34;</span><span>,</span> <span>pubKey</span><span>.</span><span>Bytes</span><span>()[:</span><span>16</span><span>])</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;error = %v\n&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>    <span>var</span> <span>_</span> <span>=</span> <span>sessionKey</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="secret.go" depends-on="s-secret-derive" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>public key = 04288d5ade66bab4320a86d80993f628...
</span></span><span><span>error = &lt;nil&gt;
</span></span></code></pre></div><p>The current <code>secret.Do</code> implementation only supports Linux (amd64 and arm64). On unsupported platforms, <code>Do</code> invokes the function directly. Also, trying to start a goroutine within the function causes a panic (this will be fixed in Go 1.27).</p><p>The <code>runtime/secret</code> package is mainly for developers who work on cryptographic libraries. Most apps should use higher-level libraries that use <code>secret.Do</code> behind the scenes.</p><p>The package is experimental and can be enabled by setting <code>GOEXPERIMENT=runtimesecret</code> at build time.</p><p>ğ—— <a href="https://pkg.go.dev/runtime/secret@go1.26rc1">runtime/secret</a> â€¢
ğ—£ <a href="https://go.dev/issue/21865">21865</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/704615">704615</a> â€¢
ğ—” <a href="https://github.com/DanielMorsing">Daniel Morsing</a></p><h2 id="crypto-reader"><a href="#crypto-reader">#</a>
Reader-less cryptography</h2><p>Current cryptographic APIs, like <code>ecdsa.GenerateKey</code> or <code>rand.Prime</code>, often accept an <code>io.Reader</code> as the source of random data:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Generate a new ECDSA private key for the specified curve.
</span></span></span><span><span><span></span><span>key</span><span>,</span> <span>_</span> <span>:=</span> <span>ecdsa</span><span>.</span><span>GenerateKey</span><span>(</span><span>elliptic</span><span>.</span><span>P256</span><span>(),</span> <span>rand</span><span>.</span><span>Reader</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>key</span><span>.</span><span>D</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Generate a 64-bit integer that is prime with high probability.
</span></span></span><span><span><span></span><span>prim</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Prime</span><span>(</span><span>rand</span><span>.</span><span>Reader</span><span>,</span> <span>64</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>prim</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go" editor="basic" template="crypto-main.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>31253152889057471714062019675387570049552680140182252615946165331094890182019
</span></span><span><span>17433987073571224703
</span></span></code></pre></div><p>These APIs don&#39;t commit to a specific way of using random bytes from the reader. Any change to underlying cryptographic algorithms can change the sequence or amount of bytes read. Because of this, if the application code (mistakenly) relies on a specific implementation in Go version X, it might fail or behave differently in version X+1.</p><p>The Go team chose a pretty bold solution to this problem. Now, most crypto APIs will just ignore the random <code>io.Reader</code> parameter and always use the system random source (<code>crypto/internal/sysrand.Read</code>).</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// The reader parameter is no longer used, so you can just pass nil.
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Generate a new ECDSA private key for the specified curve.
</span></span></span><span><span><span></span><span>key</span><span>,</span> <span>_</span> <span>:=</span> <span>ecdsa</span><span>.</span><span>GenerateKey</span><span>(</span><span>elliptic</span><span>.</span><span>P256</span><span>(),</span> <span>nil</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>key</span><span>.</span><span>D</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Generate a 64-bit integer that is prime with high probability.
</span></span></span><span><span><span></span><span>prim</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Prime</span><span>(</span><span>nil</span><span>,</span> <span>64</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>prim</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="crypto-main.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>16265662996876675161677719946085651215874831846675169870638460773593241527197
</span></span><span><span>14874320216361938581
</span></span></code></pre></div><p>The change applies to the following <code>crypto</code> subpackages:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// crypto/dsa
</span></span></span><span><span><span></span><span>func</span> <span>GenerateKey</span><span>(</span><span>priv</span> <span>*</span><span>PrivateKey</span><span>,</span> <span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>)</span> <span>error</span>
</span></span><span><span>
</span></span><span><span><span>// crypto/ecdh
</span></span></span><span><span><span></span><span>type</span> <span>Curve</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>GenerateKey</span><span>(</span><span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>)</span> <span>(</span><span>*</span><span>PrivateKey</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// crypto/ecdsa
</span></span></span><span><span><span></span><span>func</span> <span>GenerateKey</span><span>(</span><span>c</span> <span>elliptic</span><span>.</span><span>Curve</span><span>,</span> <span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>)</span> <span>(</span><span>*</span><span>PrivateKey</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span><span>func</span> <span>SignASN1</span><span>(</span><span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>priv</span> <span>*</span><span>PrivateKey</span><span>,</span> <span>hash</span> <span>[]</span><span>byte</span><span>)</span> <span>([]</span><span>byte</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span><span>func</span> <span>Sign</span><span>(</span><span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>priv</span> <span>*</span><span>PrivateKey</span><span>,</span> <span>hash</span> <span>[]</span><span>byte</span><span>)</span> <span>(</span><span>r</span><span>,</span> <span>s</span> <span>*</span><span>big</span><span>.</span><span>Int</span><span>,</span> <span>err</span> <span>error</span><span>)</span>
</span></span><span><span><span>func</span> <span>(</span><span>priv</span> <span>*</span><span>PrivateKey</span><span>)</span> <span>Sign</span><span>(</span><span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>digest</span> <span>[]</span><span>byte</span><span>,</span> <span>opts</span> <span>crypto</span><span>.</span><span>SignerOpts</span><span>)</span> <span>([]</span><span>byte</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// crypto/rand
</span></span></span><span><span><span></span><span>func</span> <span>Prime</span><span>(</span><span>rand</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>bits</span> <span>int</span><span>)</span> <span>(</span><span>*</span><span>big</span><span>.</span><span>Int</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// crypto/rsa
</span></span></span><span><span><span></span><span>func</span> <span>GenerateKey</span><span>(</span><span>random</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>bits</span> <span>int</span><span>)</span> <span>(</span><span>*</span><span>PrivateKey</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span><span>func</span> <span>GenerateMultiPrimeKey</span><span>(</span><span>random</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>nprimes</span> <span>int</span><span>,</span> <span>bits</span> <span>int</span><span>)</span> <span>(</span><span>*</span><span>PrivateKey</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span><span>func</span> <span>EncryptPKCS1v15</span><span>(</span><span>random</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>pub</span> <span>*</span><span>PublicKey</span><span>,</span> <span>msg</span> <span>[]</span><span>byte</span><span>)</span> <span>([]</span><span>byte</span><span>,</span> <span>error</span><span>)</span>
</span></span></code></pre></div><p><code>ed25519.GenerateKey(rand)</code> still uses the random reader if provided. But if <code>rand</code> is nil, it uses an internal secure source of random bytes instead of <code>crypto/rand.Reader</code> (which could be overridden).</p><p>To support deterministic testing, there&#39;s a new <code>testing/cryptotest</code> package with a single <code>SetGlobalRandom</code> function. It sets a global, deterministic cryptographic randomness source for the duration of the given test:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>Test</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>cryptotest</span><span>.</span><span>SetGlobalRandom</span><span>(</span><span>t</span><span>,</span> <span>42</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// All test runs will generate the same numbers.
</span></span></span><span><span><span></span>    <span>p1</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Prime</span><span>(</span><span>nil</span><span>,</span> <span>32</span><span>)</span>
</span></span><span><span>    <span>p2</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Prime</span><span>(</span><span>nil</span><span>,</span> <span>32</span><span>)</span>
</span></span><span><span>    <span>p3</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Prime</span><span>(</span><span>nil</span><span>,</span> <span>32</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>got</span> <span>:=</span> <span>[</span><span>3</span><span>]</span><span>int64</span><span>{</span><span>p1</span><span>.</span><span>Int64</span><span>(),</span> <span>p2</span><span>.</span><span>Int64</span><span>(),</span> <span>p3</span><span>.</span><span>Int64</span><span>()}</span>
</span></span><span><span>    <span>want</span> <span>:=</span> <span>[</span><span>3</span><span>]</span><span>int64</span><span>{</span><span>3713413729</span><span>,</span> <span>3540452603</span><span>,</span> <span>4293217813</span><span>}</span>
</span></span><span><span>    <span>if</span> <span>got</span> <span>!=</span> <span>want</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;got %v, want %v&#34;</span><span>,</span> <span>got</span><span>,</span> <span>want</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" command="test" editor="basic" template="crypto-header.go" output=""></codapi-snippet><p><code>SetGlobalRandom</code> affects <code>crypto/rand</code> and all implicit sources of cryptographic randomness in the <code>crypto/*</code> packages:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>Test</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>cryptotest</span><span>.</span><span>SetGlobalRandom</span><span>(</span><span>t</span><span>,</span> <span>42</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>t</span><span>.</span><span>Run</span><span>(</span><span>&#34;rand.Read&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>var</span> <span>got</span> <span>[</span><span>4</span><span>]</span><span>byte</span>
</span></span><span><span>        <span>rand</span><span>.</span><span>Read</span><span>(</span><span>got</span><span>[:])</span>
</span></span><span><span>        <span>want</span> <span>:=</span> <span>[</span><span>4</span><span>]</span><span>byte</span><span>{</span><span>34</span><span>,</span> <span>48</span><span>,</span> <span>31</span><span>,</span> <span>184</span><span>}</span>
</span></span><span><span>        <span>if</span> <span>got</span> <span>!=</span> <span>want</span> <span>{</span>
</span></span><span><span>            <span>t</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;got %v, want %v&#34;</span><span>,</span> <span>got</span><span>,</span> <span>want</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>
</span></span><span><span>    <span>t</span><span>.</span><span>Run</span><span>(</span><span>&#34;rand.Int&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>got</span><span>,</span> <span>_</span> <span>:=</span> <span>rand</span><span>.</span><span>Int</span><span>(</span><span>rand</span><span>.</span><span>Reader</span><span>,</span> <span>big</span><span>.</span><span>NewInt</span><span>(</span><span>10000</span><span>))</span>
</span></span><span><span>        <span>const</span> <span>want</span> <span>=</span> <span>6185</span>
</span></span><span><span>        <span>if</span> <span>got</span><span>.</span><span>Int64</span><span>()</span> <span>!=</span> <span>want</span> <span>{</span>
</span></span><span><span>            <span>t</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;got %v, want %v&#34;</span><span>,</span> <span>got</span><span>.</span><span>Int64</span><span>(),</span> <span>want</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" command="test" editor="basic" template="crypto-header.go" output=""></codapi-snippet><p>To temporarily restore the old reader-respecting behavior, set <code>GODEBUG=cryptocustomrand=1</code> (this option will be removed in a future release).</p><p>ğ—— <a href="https://pkg.go.dev/testing/cryptotest@go1.26rc1">testing/cryptotest</a> â€¢
ğ—£ <a href="https://go.dev/issue/70942">70942</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/724480">724480</a> â€¢
ğ—” <a href="https://github.com/FiloSottile">Filippo Valsorda</a>, <a href="https://github.com/qiulaidongfeng">qiulaidongfeng</a></p><h2 id="crypto-hpke"><a href="#crypto-hpke">#</a>
Hybrid public key encryption</h2><p>The new <code>crypto/hpke</code> package implements Hybrid Public Key Encryption (HPKE) as specified in <a href="https://www.rfc-editor.org/rfc/rfc9180.html">RFC 9180</a>.</p><p>HPKE is a relatively new IETF standard for hybrid encryption. Traditional public-key encryption methods, like RSA, are slow and can only handle small amounts of data. HPKE improves on this by combining two types of encryption: it uses asymmetric cryptography (public/private keys) to safely create a shared secret, then uses fast symmetric encryption to protect the actual data. This lets you securely and quickly encrypt large files or messages, while still using the security benefits of public-key systems.</p><p>The &#34;asymmetric&#34; part of HPKE (called Key Encapsulation Mechanism or KEM) can use both traditional algorithms, such as those using elliptic curves, and new post-quantum algorithms, like ML-KEM. ML-KEM is designed to remain secure even against future quantum computers that could break traditional cryptography.</p><p>I&#39;m not going to pretend I&#39;m an expert in cryptography, so here&#39;s an example I took straight from the Go standard library documentation. It uses ML-KEM-X25519 for asymmetric cryptography (traditional X25519 combined with ML-KEM), AES-256 for symmetric encryption, and SHA-256 as a key hash function:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Encrypt a single message from a sender to a recipient using the one-shot API.
</span></span></span><span><span><span></span><span>kem</span><span>,</span> <span>kdf</span><span>,</span> <span>aead</span> <span>:=</span> <span>hpke</span><span>.</span><span>MLKEM768X25519</span><span>(),</span> <span>hpke</span><span>.</span><span>HKDFSHA256</span><span>(),</span> <span>hpke</span><span>.</span><span>AES256GCM</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>// Recipient side
</span></span></span><span><span><span></span><span>var</span> <span>(</span>
</span></span><span><span>    <span>recipientPrivateKey</span> <span>hpke</span><span>.</span><span>PrivateKey</span>
</span></span><span><span>    <span>publicKeyBytes</span>      <span>[]</span><span>byte</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>k</span><span>,</span> <span>err</span> <span>:=</span> <span>kem</span><span>.</span><span>GenerateKey</span><span>()</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>recipientPrivateKey</span> <span>=</span> <span>k</span>
</span></span><span><span>    <span>publicKeyBytes</span> <span>=</span> <span>k</span><span>.</span><span>PublicKey</span><span>().</span><span>Bytes</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Sender side
</span></span></span><span><span><span></span><span>var</span> <span>ciphertext</span> <span>[]</span><span>byte</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>publicKey</span><span>,</span> <span>err</span> <span>:=</span> <span>kem</span><span>.</span><span>NewPublicKey</span><span>(</span><span>publicKeyBytes</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>message</span> <span>:=</span> <span>[]</span><span>byte</span><span>(</span><span>&#34;secret message&#34;</span><span>)</span>
</span></span><span><span>    <span>ct</span><span>,</span> <span>err</span> <span>:=</span> <span>hpke</span><span>.</span><span>Seal</span><span>(</span><span>publicKey</span><span>,</span> <span>kdf</span><span>,</span> <span>aead</span><span>,</span> <span>[]</span><span>byte</span><span>(</span><span>&#34;public&#34;</span><span>),</span> <span>message</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>ciphertext</span> <span>=</span> <span>ct</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Recipient side
</span></span></span><span><span><span></span><span>{</span>
</span></span><span><span>    <span>plaintext</span><span>,</span> <span>err</span> <span>:=</span> <span>hpke</span><span>.</span><span>Open</span><span>(</span><span>recipientPrivateKey</span><span>,</span> <span>kdf</span><span>,</span> <span>aead</span><span>,</span> <span>[]</span><span>byte</span><span>(</span><span>&#34;public&#34;</span><span>),</span> <span>ciphertext</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Decrypted: %s\n&#34;</span><span>,</span> <span>plaintext</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="crypto-hpke.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Decrypted: secret message
</span></span></code></pre></div><p>As Filippo Valsorda (the cryptography engineer who maintains Go&#39;s crypto packages) says, HPKE is now the right way to do public key encryption.</p><p>ğ—— <a href="https://pkg.go.dev/crypto/hpke@go1.26rc1">crypto/hpke</a> â€¢
ğ—£ <a href="https://go.dev/issue/75300">75300</a> â€¢
ğ—” <a href="https://github.com/FiloSottile">Filippo Valsorda</a></p><h2 id="pprof-goroutineleak"><a href="#pprof-goroutineleak">#</a>
Goroutine leak profile (experimental)</h2><p>A leak occurs when one or more goroutines are indefinitely blocked on synchronization primitives like channels, while other goroutines continue running and the program as a whole keeps functioning. Here&#39;s a simple example:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>leak</span><span>()</span> <span>&lt;-</span><span>chan</span> <span>int</span> <span>{</span>
</span></span><span><span>    <span>out</span> <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>int</span><span>)</span>
</span></span><span><span>    <span>go</span> <span>func</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>out</span> <span>&lt;-</span> <span>42</span> <span>// leaks if nobody reads from out
</span></span></span><span><span><span></span>    <span>}()</span>
</span></span><span><span>    <span>return</span> <span>out</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet id="s-leak" editor="basic"></codapi-snippet><p>If we call <code>leak</code> and don&#39;t read from the output channel, the inner <code>leak</code> goroutine will stay blocked trying to send to the channel for the rest of the program:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>leak</span><span>()</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="pprof.go" depends-on="s-leak" output=""></codapi-snippet><p>Unlike deadlocks, leaks do not cause panics, so they are much harder to spot. Also, unlike data races, Go&#39;s tooling did not address them for a long time.</p><p>Things started to change in Go 1.24 with the introduction of the <code>synctest</code> package. Not many people talk about it, but <code>synctest</code> is a great tool for catching leaks during testing.</p><p>Go 1.26 adds a new experimental <code>goroutineleak</code> profile designed to report leaked goroutines in production. Here&#39;s how we can use it in the example above:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>prof</span> <span>:=</span> <span>pprof</span><span>.</span><span>Lookup</span><span>(</span><span>&#34;goroutineleak&#34;</span><span>)</span>
</span></span><span><span>    <span>leak</span><span>()</span>
</span></span><span><span>    <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>50</span> <span>*</span> <span>time</span><span>.</span><span>Millisecond</span><span>)</span>
</span></span><span><span>    <span>prof</span><span>.</span><span>WriteTo</span><span>(</span><span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>2</span><span>)</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="pprof.go" depends-on="s-leak" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>goroutine 7 [chan send (leaked)]:
</span></span><span><span>main.leak.func1()
</span></span><span><span>    /tmp/sandbox/main.go:16 +0x1e
</span></span><span><span>created by main.leak in goroutine 1
</span></span><span><span>    /tmp/sandbox/main.go:15 +0x67
</span></span></code></pre></div><p>As you can see, we have a nice goroutine stack trace that shows exactly where the leak happens.</p><p>The <code>goroutineleak</code> profile finds leaks by using the garbage collector&#39;s marking phase to check which blocked goroutines are still connected to active code. It starts with runnable goroutines, marks all sync objects they can reach, and keeps adding any blocked goroutines waiting on those objects. When it can&#39;t add any more, any blocked goroutines left are waiting on resources that can&#39;t be reached â€” so they&#39;re considered leaked.</p><details><summary>Tell me more</summary><p>Here&#39;s the gist of it:</p><div><pre tabindex="0"><code data-lang="text"><span><span>   [ Start: GC mark phase ]
</span></span><span><span>             â”‚
</span></span><span><span>             â”‚ 1. Collect live goroutines
</span></span><span><span>             v
</span></span><span><span>   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span><span>   â”‚   Initial roots       â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span><span>   â”‚ (runnable goroutines) â”‚                  â”‚
</span></span><span><span>   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
</span></span><span><span>             â”‚                                â”‚
</span></span><span><span>             â”‚ 2. Mark reachable memory       â”‚
</span></span><span><span>             v                                â”‚
</span></span><span><span>   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
</span></span><span><span>   â”‚   Reachable objects   â”‚                  â”‚
</span></span><span><span>   â”‚  (channels, mutexes)  â”‚                  â”‚
</span></span><span><span>   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
</span></span><span><span>             â”‚                                â”‚
</span></span><span><span>             â”‚ 3a. Check blocked goroutines   â”‚
</span></span><span><span>             v                                â”‚
</span></span><span><span>   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          (Yes)   â”‚
</span></span><span><span>   â”‚ Is blocked G waiting  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span><span><span>   â”‚ on a reachable obj?   â”‚ 3b. Add G to roots
</span></span><span><span>   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span><span><span>             â”‚
</span></span><span><span>             â”‚ (No - repeat until no new Gs found)
</span></span><span><span>             v
</span></span><span><span>   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span><span>   â”‚   Remaining blocked   â”‚
</span></span><span><span>   â”‚      goroutines       â”‚
</span></span><span><span>   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span><span><span>             â”‚
</span></span><span><span>             â”‚ 5. Report the leaks
</span></span><span><span>             v
</span></span><span><span>      [   LEAKED!   ]
</span></span><span><span> (Blocked on unreachable
</span></span><span><span>  synchronization objects)
</span></span></code></pre></div><ol><li><em>Collect live goroutines</em>. Start with currently active (runnable or running) goroutines as roots. Ignore blocked goroutines for now.</li><li><em>Mark reachable memory</em>. Trace pointers from roots to find which synchronization objects (like channels or wait groups) are currently reachable by these roots.</li><li><em>Resurrect blocked goroutines</em>. Check all currently blocked goroutines. If a blocked goroutine is waiting for a synchronization resource that was just marked as reachable â€” add that goroutine to the roots.</li><li><em>Iterate</em>. Repeat steps 2 and 3 until there are no more new goroutines blocked on reachable objects.</li><li><em>Report the leaks</em>. Any goroutines left in the blocked state are waiting for resources that no active part of the program can access. They&#39;re considered leaked.</li></ol><p>For even more details, see the <a href="https://dl.acm.org/doi/pdf/10.1145/3676641.3715990">paper</a> by Saioc et al.</p></details><p>If you want to see how <code>goroutineleak</code> (and <code>synctest</code>) can catch typical leaks that often happen in production â€” check out my article on <a href="https://antonz.org/detecting-goroutine-leaks/">goroutine leaks</a>.</p><p>The <code>goroutineleak</code> profile is experimental and can be enabled by setting <code>GOEXPERIMENT=goroutineleakprofile</code> at build time. Enabling the experiment also makes the profile available as a <a href="https://pkg.go.dev/net/http/pprof@go1.26rc1">net/http/pprof</a> endpoint, <code>/debug/pprof/goroutineleak</code>.</p><p>According to the authors, the implementation is already production-ready. It&#39;s only marked as experimental so they can get feedback on the API, especially about making it a new profile.</p><p>ğ—— <a href="https://pkg.go.dev/runtime/pprof@go1.26rc1">runtime/pprof</a> â€¢
ğ—š <a href="https://antonz.org/detecting-goroutine-leaks/">Detecting leaks</a> â€¢
ğ—£ <a href="https://go.dev/issue/74609">74609</a>, <a href="https://go.dev/issue/75280">75280</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/688335">688335</a> â€¢
ğ—” <a href="https://github.com/VladSaioc">Vlad Saioc</a></p><h2 id="runtime-goroutine-metrics"><a href="#runtime-goroutine-metrics">#</a>
Goroutine metrics</h2><p>New metrics in the <code>runtime/metrics</code> package give better insight into goroutine scheduling:</p><ul><li>Total number of goroutines since the program started.</li><li>Number of goroutines in each state.</li><li>Number of active threads.</li></ul><p>Here&#39;s the full list:</p><div><pre tabindex="0"><code data-lang="text"><span><span>/sched/goroutines-created:goroutines
</span></span><span><span>    Count of goroutines created since program start.
</span></span><span><span>
</span></span><span><span>/sched/goroutines/not-in-go:goroutines
</span></span><span><span>    Approximate count of goroutines running
</span></span><span><span>    or blocked in a system call or cgo call.
</span></span><span><span>
</span></span><span><span>/sched/goroutines/runnable:goroutines
</span></span><span><span>    Approximate count of goroutines ready to execute,
</span></span><span><span>    but not executing.
</span></span><span><span>
</span></span><span><span>/sched/goroutines/running:goroutines
</span></span><span><span>    Approximate count of goroutines executing.
</span></span><span><span>    Always less than or equal to /sched/gomaxprocs:threads.
</span></span><span><span>
</span></span><span><span>/sched/goroutines/waiting:goroutines
</span></span><span><span>    Approximate count of goroutines waiting
</span></span><span><span>    on a resource (I/O or sync primitives).
</span></span><span><span>
</span></span><span><span>/sched/threads/total:threads
</span></span><span><span>    The current count of live threads
</span></span><span><span>    that are owned by the Go runtime.
</span></span></code></pre></div><p>Per-state goroutine metrics can be linked to common production issues. For example, an increasing <em>waiting</em> count can show a lock contention problem. A high <em>not-in-go</em> count means goroutines are stuck in syscalls or cgo. A growing <em>runnable</em> backlog suggests the CPUs can&#39;t keep up with demand.</p><p>You can read the new metric values using the regular <code>metrics.Read</code> function:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>go</span> <span>work</span><span>()</span> <span>// omitted for brevity
</span></span></span><span><span><span></span>    <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>100</span> <span>*</span> <span>time</span><span>.</span><span>Millisecond</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Goroutine metrics:&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines-created:goroutines&#34;</span><span>,</span> <span>&#34;Created&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines:goroutines&#34;</span><span>,</span> <span>&#34;Live&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines/not-in-go:goroutines&#34;</span><span>,</span> <span>&#34;Syscall/CGO&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines/runnable:goroutines&#34;</span><span>,</span> <span>&#34;Runnable&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines/running:goroutines&#34;</span><span>,</span> <span>&#34;Running&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/goroutines/waiting:goroutines&#34;</span><span>,</span> <span>&#34;Waiting&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Thread metrics:&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/gomaxprocs:threads&#34;</span><span>,</span> <span>&#34;Max&#34;</span><span>)</span>
</span></span><span><span>    <span>printMetric</span><span>(</span><span>&#34;/sched/threads/total:threads&#34;</span><span>,</span> <span>&#34;Live&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>printMetric</span><span>(</span><span>name</span> <span>string</span><span>,</span> <span>descr</span> <span>string</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>sample</span> <span>:=</span> <span>[]</span><span>metrics</span><span>.</span><span>Sample</span><span>{{</span><span>Name</span><span>:</span> <span>name</span><span>}}</span>
</span></span><span><span>    <span>metrics</span><span>.</span><span>Read</span><span>(</span><span>sample</span><span>)</span>
</span></span><span><span>    <span>// Assuming a uint64 value; don&#39;t do this in production.
</span></span></span><span><span><span></span>    <span>// Instead, check sample[0].Value.Kind and handle accordingly.
</span></span></span><span><span><span></span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;  %s: %v\n&#34;</span><span>,</span> <span>descr</span><span>,</span> <span>sample</span><span>[</span><span>0</span><span>].</span><span>Value</span><span>.</span><span>Uint64</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="metrics.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Goroutine metrics:
</span></span><span><span>  Created: 57
</span></span><span><span>  Live: 21
</span></span><span><span>  Syscall/CGO: 0
</span></span><span><span>  Runnable: 0
</span></span><span><span>  Running: 1
</span></span><span><span>  Waiting: 20
</span></span><span><span>Thread metrics:
</span></span><span><span>  Max: 2
</span></span><span><span>  Live: 4
</span></span></code></pre></div><p>The per-state numbers (not-in-go + runnable + running + waiting) are not guaranteed to add up to the live goroutine count (<code>/sched/goroutines:goroutines</code>, available since Go 1.16).</p><p>All new metrics use <code>uint64</code> counters.</p><p>ğ—— <a href="https://pkg.go.dev/runtime/metrics@go1.26rc1#hdr-Supported_metrics">runtime/metrics</a> â€¢
ğ—£ <a href="https://go.dev/issue/15490">15490</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/690397">690397</a>, <a href="https://go.dev/cl/690398">690398</a>, <a href="https://go.dev/cl/690399">690399</a> â€¢
ğ—” <a href="https://github.com/mknyszek">Michael Knyszek</a></p><h2 id="reflect-iter"><a href="#reflect-iter">#</a>
Reflective iterators</h2><p>The new <code>Type.Fields</code> and <code>Type.Methods</code> methods in the <code>reflect</code> package return iterators for a type&#39;s fields and methods:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// List the fields of a struct type.
</span></span></span><span><span><span></span><span>typ</span> <span>:=</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>http</span><span>.</span><span>Client</span><span>]()</span>
</span></span><span><span><span>for</span> <span>f</span> <span>:=</span> <span>range</span> <span>typ</span><span>.</span><span>Fields</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>f</span><span>.</span><span>Name</span><span>,</span> <span>f</span><span>.</span><span>Type</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="reflect.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Transport http.RoundTripper
</span></span><span><span>CheckRedirect func(*http.Request, []*http.Request) error
</span></span><span><span>Jar http.CookieJar
</span></span><span><span>Timeout time.Duration
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="go"><span><span><span>// List the methods of a struct type.
</span></span></span><span><span><span></span><span>typ</span> <span>:=</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>*</span><span>http</span><span>.</span><span>Client</span><span>]()</span>
</span></span><span><span><span>for</span> <span>m</span> <span>:=</span> <span>range</span> <span>typ</span><span>.</span><span>Methods</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>m</span><span>.</span><span>Name</span><span>,</span> <span>m</span><span>.</span><span>Type</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="reflect.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>CloseIdleConnections func(*http.Client)
</span></span><span><span>Do func(*http.Client, *http.Request) (*http.Response, error)
</span></span><span><span>Get func(*http.Client, string) (*http.Response, error)
</span></span><span><span>Head func(*http.Client, string) (*http.Response, error)
</span></span><span><span>Post func(*http.Client, string, string, io.Reader) (*http.Response, error)
</span></span><span><span>PostForm func(*http.Client, string, url.Values) (*http.Response, error)
</span></span></code></pre></div><p>The new methods <code>Type.Ins</code> and <code>Type.Outs</code> return iterators for the input and output parameters of a function type:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>typ</span> <span>:=</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>filepath</span><span>.</span><span>WalkFunc</span><span>]()</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Inputs:&#34;</span><span>)</span>
</span></span><span><span><span>for</span> <span>par</span> <span>:=</span> <span>range</span> <span>typ</span><span>.</span><span>Ins</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;-&#34;</span><span>,</span> <span>par</span><span>.</span><span>Name</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Outputs:&#34;</span><span>)</span>
</span></span><span><span><span>for</span> <span>par</span> <span>:=</span> <span>range</span> <span>typ</span><span>.</span><span>Outs</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;-&#34;</span><span>,</span> <span>par</span><span>.</span><span>Name</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="reflect.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Input params:
</span></span><span><span>- string
</span></span><span><span>- FileInfo
</span></span><span><span>- error
</span></span><span><span>Output params:
</span></span><span><span>- error
</span></span></code></pre></div><p>The new methods <code>Value.Fields</code> and <code>Value.Methods</code> return iterators for a value&#39;s fields and methods. Each iteration yields both the type information (<code>StructField</code> or <code>Method</code>) and the value:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>client</span> <span>:=</span> <span>&amp;</span><span>http</span><span>.</span><span>Client</span><span>{}</span>
</span></span><span><span><span>val</span> <span>:=</span> <span>reflect</span><span>.</span><span>ValueOf</span><span>(</span><span>client</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Fields:&#34;</span><span>)</span>
</span></span><span><span><span>for</span> <span>f</span><span>,</span> <span>v</span> <span>:=</span> <span>range</span> <span>val</span><span>.</span><span>Elem</span><span>().</span><span>Fields</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;- name=%s kind=%s\n&#34;</span><span>,</span> <span>f</span><span>.</span><span>Name</span><span>,</span> <span>v</span><span>.</span><span>Kind</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Methods:&#34;</span><span>)</span>
</span></span><span><span><span>for</span> <span>m</span><span>,</span> <span>v</span> <span>:=</span> <span>range</span> <span>val</span><span>.</span><span>Methods</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;- name=%s kind=%s\n&#34;</span><span>,</span> <span>m</span><span>.</span><span>Name</span><span>,</span> <span>v</span><span>.</span><span>Kind</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="reflect.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Fields:
</span></span><span><span>- name=Transport kind=interface
</span></span><span><span>- name=CheckRedirect kind=func
</span></span><span><span>- name=Jar kind=interface
</span></span><span><span>- name=Timeout kind=int64
</span></span><span><span>Methods:
</span></span><span><span>- name=CloseIdleConnections kind=func
</span></span><span><span>- name=Do kind=func
</span></span><span><span>- name=Get kind=func
</span></span><span><span>- name=Head kind=func
</span></span><span><span>- name=Post kind=func
</span></span><span><span>- name=PostForm kind=func
</span></span></code></pre></div><p>Previously, you could get all this information by using a for-range loop with <code>NumX</code> methods (which is what iterators do internally):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.25
</span></span></span><span><span><span></span><span>typ</span> <span>:=</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>http</span><span>.</span><span>Client</span><span>]()</span>
</span></span><span><span><span>for</span> <span>i</span> <span>:=</span> <span>range</span> <span>typ</span><span>.</span><span>NumField</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>field</span> <span>:=</span> <span>typ</span><span>.</span><span>Field</span><span>(</span><span>i</span><span>)</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>field</span><span>.</span><span>Name</span><span>,</span> <span>field</span><span>.</span><span>Type</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="reflect.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>Transport http.RoundTripper
</span></span><span><span>CheckRedirect func(*http.Request, []*http.Request) error
</span></span><span><span>Jar http.CookieJar
</span></span><span><span>Timeout time.Duration
</span></span></code></pre></div><p>Using an iterator is more concise. I hope it justifies the increased API surface.</p><p>ğ—— <a href="https://pkg.go.dev/reflect@go1.26rc1">reflect</a> â€¢
ğ—£ <a href="https://go.dev/issue/66631">66631</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/707356">707356</a> â€¢
ğ—” <a href="https://github.com/Splizard">Quentin Quaadgras</a></p><h2 id="bytes-buffer-peek"><a href="#bytes-buffer-peek">#</a>
Peek into a buffer</h2><p>The new <code>Buffer.Peek</code> method in the <code>bytes</code> package returns the next N bytes from the buffer without advancing it:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>buf</span> <span>:=</span> <span>bytes</span><span>.</span><span>NewBufferString</span><span>(</span><span>&#34;I love bytes&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>sample</span><span>,</span> <span>err</span> <span>:=</span> <span>buf</span><span>.</span><span>Peek</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;peek=%s err=%v\n&#34;</span><span>,</span> <span>sample</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>buf</span><span>.</span><span>Next</span><span>(</span><span>2</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>sample</span><span>,</span> <span>err</span> <span>=</span> <span>buf</span><span>.</span><span>Peek</span><span>(</span><span>4</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;peek=%s err=%v\n&#34;</span><span>,</span> <span>sample</span><span>,</span> <span>err</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="bytes.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>peek=I err=&lt;nil&gt;
</span></span><span><span>peek=love err=&lt;nil&gt;
</span></span></code></pre></div><p>If <code>Peek</code> returns fewer than N bytes, it also returns <code>io.EOF</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>buf</span> <span>:=</span> <span>bytes</span><span>.</span><span>NewBufferString</span><span>(</span><span>&#34;hello&#34;</span><span>)</span>
</span></span><span><span><span>sample</span><span>,</span> <span>err</span> <span>:=</span> <span>buf</span><span>.</span><span>Peek</span><span>(</span><span>10</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;peek=%s err=%v\n&#34;</span><span>,</span> <span>sample</span><span>,</span> <span>err</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="bytes.go" output=""></codapi-snippet><p>The slice returned by <code>Peek</code> points to the buffer&#39;s content and stays valid until the buffer is changed. So, if you change the slice right away, it will affect future reads:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>buf</span> <span>:=</span> <span>bytes</span><span>.</span><span>NewBufferString</span><span>(</span><span>&#34;car&#34;</span><span>)</span>
</span></span><span><span><span>sample</span><span>,</span> <span>err</span> <span>:=</span> <span>buf</span><span>.</span><span>Peek</span><span>(</span><span>3</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;peek=%s err=%v\n&#34;</span><span>,</span> <span>sample</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>sample</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>&#39;t&#39;</span> <span>// changes the underlying buffer
</span></span></span><span><span><span></span>
</span></span><span><span><span>data</span><span>,</span> <span>err</span> <span>:=</span> <span>buf</span><span>.</span><span>ReadBytes</span><span>(</span><span>0</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;data=%s err=%v\n&#34;</span><span>,</span> <span>data</span><span>,</span> <span>err</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="bytes.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>peek=car err=&lt;nil&gt;
</span></span><span><span>data=cat err=EOF
</span></span></code></pre></div><p>The slice returned by <code>Peek</code> is only valid until the next call to a read or write method.</p><p>ğ—— <a href="https://pkg.go.dev/bytes@go1.26rc1#Buffer.Peek">Buffer.Peek</a> â€¢
ğ—£ <a href="https://go.dev/issue/73794">73794</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/674415">674415</a> â€¢
ğ—” <a href="https://github.com/icholy">Ilia Choly</a></p><h2 id="os-process-handle"><a href="#os-process-handle">#</a>
Process handle</h2><p>After you start a process in Go, you can access its ID:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>attr</span> <span>:=</span> <span>&amp;</span><span>os</span><span>.</span><span>ProcAttr</span><span>{</span><span>Files</span><span>:</span> <span>[]</span><span>*</span><span>os</span><span>.</span><span>File</span><span>{</span><span>os</span><span>.</span><span>Stdin</span><span>,</span> <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>os</span><span>.</span><span>Stderr</span><span>}}</span>
</span></span><span><span><span>proc</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>StartProcess</span><span>(</span><span>&#34;/bin/echo&#34;</span><span>,</span> <span>[]</span><span>string</span><span>{</span><span>&#34;echo&#34;</span><span>,</span> <span>&#34;hello&#34;</span><span>},</span> <span>attr</span><span>)</span>
</span></span><span><span><span>defer</span> <span>proc</span><span>.</span><span>Wait</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;pid =&#34;</span><span>,</span> <span>proc</span><span>.</span><span>Pid</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go" editor="basic" template="os.go" output=""></codapi-snippet><p>Internally, the <code>os.Process</code> type uses a process <em>handle</em> instead of the PID (which is just an integer), if the operating system supports it. Specifically, in Linux it uses <em>pidfd</em>, which is a file descriptor that refers to a process. Using the handle instead of the PID makes sure that <code>Process</code> methods always work with the same OS process, and not a different process that just happens to have the same ID.</p><p>Previously, you couldn&#39;t access the process handle. Now you can, thanks to the new <code>Process.WithHandle</code> method:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>p</span> <span>*</span><span>Process</span><span>)</span> <span>WithHandle</span><span>(</span><span>f</span> <span>func</span><span>(</span><span>handle</span> <span>uintptr</span><span>))</span> <span>error</span>
</span></span></code></pre></div><p><code>WithHandle</code> calls a specified function and passes a process handle as an argument:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>attr</span> <span>:=</span> <span>&amp;</span><span>os</span><span>.</span><span>ProcAttr</span><span>{</span><span>Files</span><span>:</span> <span>[]</span><span>*</span><span>os</span><span>.</span><span>File</span><span>{</span><span>os</span><span>.</span><span>Stdin</span><span>,</span> <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>os</span><span>.</span><span>Stderr</span><span>}}</span>
</span></span><span><span><span>proc</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>StartProcess</span><span>(</span><span>&#34;/bin/echo&#34;</span><span>,</span> <span>[]</span><span>string</span><span>{</span><span>&#34;echo&#34;</span><span>,</span> <span>&#34;hello&#34;</span><span>},</span> <span>attr</span><span>)</span>
</span></span><span><span><span>defer</span> <span>proc</span><span>.</span><span>Wait</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;pid =&#34;</span><span>,</span> <span>proc</span><span>.</span><span>Pid</span><span>)</span>
</span></span><span><span><span>proc</span><span>.</span><span>WithHandle</span><span>(</span><span>func</span><span>(</span><span>handle</span> <span>uintptr</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;handle =&#34;</span><span>,</span> <span>handle</span><span>)</span>
</span></span><span><span><span>})</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="os.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>pid = 49
</span></span><span><span>handle = 6
</span></span><span><span>hello
</span></span></code></pre></div><p>The handle is guaranteed to refer to the process until the callback function returns, even if the process has already terminated. That&#39;s why it&#39;s implemented as a callback instead of a <code>Process.Handle</code> field or method.</p><p><code>WithHandle</code> is only supported on Linux 5.4+ and Windows. On other operating systems, it doesn&#39;t execute the callback and returns an <code>os.ErrNoHandle</code> error.</p><p>ğ—— <a href="https://pkg.go.dev/os@go1.26rc1#Process.WithHandle">Process.WithHandle</a> â€¢
ğ—£ <a href="https://go.dev/issue/70352">70352</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/699615">699615</a> â€¢
ğ—” <a href="https://github.com/kolyshkin">Kir Kolyshkin</a></p><h2 id="signal-cause"><a href="#signal-cause">#</a>
Signal as cause</h2><p><code>signal.NotifyContext</code> returns a context that gets canceled when any of the specified signals is received. Previously, the canceled context only showed the standard &#34;context canceled&#34; cause:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.25
</span></span></span><span><span><span></span>
</span></span><span><span><span>// The context will be canceled on SIGINT signal.
</span></span></span><span><span><span></span><span>ctx</span><span>,</span> <span>stop</span> <span>:=</span> <span>signal</span><span>.</span><span>NotifyContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>os</span><span>.</span><span>Interrupt</span><span>)</span>
</span></span><span><span><span>defer</span> <span>stop</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>// Send SIGINT to self.
</span></span></span><span><span><span></span><span>p</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>FindProcess</span><span>(</span><span>os</span><span>.</span><span>Getpid</span><span>())</span>
</span></span><span><span><span>_</span> <span>=</span> <span>p</span><span>.</span><span>Signal</span><span>(</span><span>syscall</span><span>.</span><span>SIGINT</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Wait for SIGINT.
</span></span></span><span><span><span></span><span>&lt;-</span><span>ctx</span><span>.</span><span>Done</span><span>()</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;err =&#34;</span><span>,</span> <span>ctx</span><span>.</span><span>Err</span><span>())</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;cause =&#34;</span><span>,</span> <span>context</span><span>.</span><span>Cause</span><span>(</span><span>ctx</span><span>))</span>
</span></span></code></pre></div><codapi-snippet sandbox="go" editor="basic" template="signal.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>err = context canceled
</span></span><span><span>cause = context canceled
</span></span></code></pre></div><p>Now the context&#39;s cause shows exactly which signal was received:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.26
</span></span></span><span><span><span></span>
</span></span><span><span><span>// The context will be canceled on SIGINT signal.
</span></span></span><span><span><span></span><span>ctx</span><span>,</span> <span>stop</span> <span>:=</span> <span>signal</span><span>.</span><span>NotifyContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>os</span><span>.</span><span>Interrupt</span><span>)</span>
</span></span><span><span><span>defer</span> <span>stop</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>// Send SIGINT to self.
</span></span></span><span><span><span></span><span>p</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>FindProcess</span><span>(</span><span>os</span><span>.</span><span>Getpid</span><span>())</span>
</span></span><span><span><span>_</span> <span>=</span> <span>p</span><span>.</span><span>Signal</span><span>(</span><span>syscall</span><span>.</span><span>SIGINT</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Wait for SIGINT.
</span></span></span><span><span><span></span><span>&lt;-</span><span>ctx</span><span>.</span><span>Done</span><span>()</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;err =&#34;</span><span>,</span> <span>ctx</span><span>.</span><span>Err</span><span>())</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;cause =&#34;</span><span>,</span> <span>context</span><span>.</span><span>Cause</span><span>(</span><span>ctx</span><span>))</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="signal.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>err = context canceled
</span></span><span><span>cause = interrupt signal received
</span></span></code></pre></div><p>The returned type, <code>signal.signalError</code>, is based on <code>string</code>, so it doesn&#39;t provide the actual <code>os.Signal</code> value â€” just its string representation.</p><p>ğ—— <a href="https://pkg.go.dev/os/signal@go1.26rc1#NotifyContext">signal.NotifyContext</a> â€¢
ğ—£ <a href="https://go.dev/issue/60756">60756</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/721700">721700</a> â€¢
ğ—” <a href="https://github.com/FiloSottile">Filippo Valsorda</a></p><h2 id="netip-prefix-compare"><a href="#netip-prefix-compare">#</a>
Compare IP subnets</h2><p>An IP address prefix represents an IP subnet. These prefixes are usually written in CIDR notation:</p><div><pre tabindex="0"><code data-lang="text"><span><span>10.0.0.0/16
</span></span><span><span>127.0.0.0/8
</span></span><span><span>169.254.0.0/16
</span></span><span><span>203.0.113.0/24
</span></span></code></pre></div><p>In Go, an IP prefix is represented by the <code>netip.Prefix</code> type.</p><p>The new <code>Prefix.Compare</code> method lets you compare two IP prefixes, making it easy to sort them without having to write your own comparison code:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>prefixes</span> <span>:=</span> <span>[]</span><span>netip</span><span>.</span><span>Prefix</span><span>{</span>
</span></span><span><span>    <span>netip</span><span>.</span><span>MustParsePrefix</span><span>(</span><span>&#34;10.1.0.0/16&#34;</span><span>),</span>
</span></span><span><span>    <span>netip</span><span>.</span><span>MustParsePrefix</span><span>(</span><span>&#34;203.0.113.0/24&#34;</span><span>),</span>
</span></span><span><span>    <span>netip</span><span>.</span><span>MustParsePrefix</span><span>(</span><span>&#34;10.0.0.0/16&#34;</span><span>),</span>
</span></span><span><span>    <span>netip</span><span>.</span><span>MustParsePrefix</span><span>(</span><span>&#34;169.254.0.0/16&#34;</span><span>),</span>
</span></span><span><span>    <span>netip</span><span>.</span><span>MustParsePrefix</span><span>(</span><span>&#34;203.0.113.0/8&#34;</span><span>),</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>slices</span><span>.</span><span>SortFunc</span><span>(</span><span>prefixes</span><span>,</span> <span>netip</span><span>.</span><span>Prefix</span><span>.</span><span>Compare</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>for</span> <span>_</span><span>,</span> <span>p</span> <span>:=</span> <span>range</span> <span>prefixes</span> <span>{</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>p</span><span>.</span><span>String</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="netip.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>10.0.0.0/16
</span></span><span><span>10.1.0.0/16
</span></span><span><span>169.254.0.0/16
</span></span><span><span>203.0.113.0/8
</span></span><span><span>203.0.113.0/24
</span></span></code></pre></div><p><code>Compare</code> orders two prefixes as follows:</p><ul><li>First by validity (invalid before valid).</li><li>Then by address family (IPv4 before IPv6).</li><li>Then by masked IP address (network IP).</li><li>Then by prefix length.</li><li>Then by unmasked address (original IP).</li></ul><p>This follows the same order as Python&#39;s <code>netaddr.IPNetwork</code> and the standard IANA (Internet Assigned Numbers Authority) convention.</p><p>ğ—— <a href="https://pkg.go.dev/net/netip@go1.26rc1#Prefix.Compare">Prefix.Compare</a> â€¢
ğ—£ <a href="https://go.dev/issue/61642">61642</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/700355">700355</a> â€¢
ğ—” <a href="https://github.com/database64128">database64128</a></p><h2 id="net-dialer-context"><a href="#net-dialer-context">#</a>
Context-aware dialing</h2><p>The <code>net</code> package has top-level functions for connecting to an address using different networks (protocols) â€” <code>DialTCP</code>, <code>DialUDP</code>, <code>DialIP</code>, and <code>DialUnix</code>. They were made before <code>context.Context</code> was introduced, so they don&#39;t support cancellation:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>raddr</span><span>,</span> <span>_</span> <span>:=</span> <span>net</span><span>.</span><span>ResolveTCPAddr</span><span>(</span><span>&#34;tcp&#34;</span><span>,</span> <span>&#34;127.0.0.1:12345&#34;</span><span>)</span>
</span></span><span><span><span>conn</span><span>,</span> <span>err</span> <span>:=</span> <span>net</span><span>.</span><span>DialTCP</span><span>(</span><span>&#34;tcp&#34;</span><span>,</span> <span>nil</span><span>,</span> <span>raddr</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;connected, err=%v\n&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span><span>defer</span> <span>conn</span><span>.</span><span>Close</span><span>()</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="net.go" output=""></codapi-snippet><p>There&#39;s also a <code>net.Dialer</code> type with a general-purpose <code>DialContext</code> method. It supports cancellation and can be used to connect to any of the known networks:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>d</span> <span>net</span><span>.</span><span>Dialer</span>
</span></span><span><span><span>ctx</span> <span>:=</span> <span>context</span><span>.</span><span>Background</span><span>()</span>
</span></span><span><span><span>conn</span><span>,</span> <span>err</span> <span>:=</span> <span>d</span><span>.</span><span>DialContext</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;tcp&#34;</span><span>,</span> <span>&#34;127.0.0.1:12345&#34;</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;connected, err=%v\n&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span><span>defer</span> <span>conn</span><span>.</span><span>Close</span><span>()</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="net.go" output=""></codapi-snippet><p>However, <code>DialContext</code> a bit less efficient than network-specific functions like <code>net.DialTCP</code> â€” because of the extra overhead from address resolution and network type dispatching.</p><p>So, network-specific functions in the <code>net</code> package are more efficient, but they don&#39;t support cancellation. The <code>Dialer</code> type supports cancellation, but it&#39;s less efficient. The Go team decided to resolve this contradiction.</p><p>The new context-aware <code>Dialer</code> methods (<code>DialTCP</code>, <code>DialUDP</code>, <code>DialIP</code>, and <code>DialUnix</code>) combine the efficiency of the existing network-specific <code>net</code> functions with the cancellation capabilities of <code>Dialer.DialContext</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>d</span> <span>net</span><span>.</span><span>Dialer</span>
</span></span><span><span><span>ctx</span> <span>:=</span> <span>context</span><span>.</span><span>Background</span><span>()</span>
</span></span><span><span><span>raddr</span> <span>:=</span> <span>netip</span><span>.</span><span>MustParseAddrPort</span><span>(</span><span>&#34;127.0.0.1:12345&#34;</span><span>)</span>
</span></span><span><span><span>conn</span><span>,</span> <span>err</span> <span>:=</span> <span>d</span><span>.</span><span>DialTCP</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;tcp&#34;</span><span>,</span> <span>netip</span><span>.</span><span>AddrPort</span><span>{},</span> <span>raddr</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;connected, err=%v\n&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span><span>defer</span> <span>conn</span><span>.</span><span>Close</span><span>()</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="net.go" output=""></codapi-snippet><p>I wouldn&#39;t say that having three different ways to dial is very convenient, but that&#39;s the price of backward compatibility.</p><p>ğ—— <a href="https://pkg.go.dev/net@go1.26rc1#Dialer.DialTCP">net.Dialer</a> â€¢
ğ—£ <a href="https://go.dev/issue/49097">49097</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/490975">490975</a> â€¢
ğ—” <a href="https://github.com/fraenkel">Michael Fraenkel</a></p><h2 id="httptest-example"><a href="#httptest-example">#</a>
Fake example.com</h2><p>The default <code>httptest.Server</code> certificate already lists <code>example.com</code> in its DNSNames (a list of hostnames or domain names that the certificate is authorized to secure). Because of this, <code>Server.Client</code> doesn&#39;t trust responses from the real <code>example.com</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.25
</span></span></span><span><span><span></span><span>func</span> <span>Test</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>handler</span> <span>:=</span> <span>http</span><span>.</span><span>HandlerFunc</span><span>(</span><span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;hello&#34;</span><span>))</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>    <span>srv</span> <span>:=</span> <span>httptest</span><span>.</span><span>NewTLSServer</span><span>(</span><span>handler</span><span>)</span>
</span></span><span><span>    <span>defer</span> <span>srv</span><span>.</span><span>Close</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>srv</span><span>.</span><span>Client</span><span>().</span><span>Get</span><span>(</span><span>&#34;https://example.com&#34;</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>Fatal</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="text"><span><span>--- FAIL: Test (0.29s)
</span></span><span><span>    main_test.go:19: Get &#34;https://example.com&#34;:
</span></span><span><span>    tls: failed to verify certificate:
</span></span><span><span>    x509: certificate signed by unknown authority
</span></span></code></pre></div><p>To fix this issue, the HTTP client returned by <code>httptest.Server.Client</code> now redirects requests for <code>example.com</code> and its subdomains to the test server:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// go 1.26
</span></span></span><span><span><span></span><span>func</span> <span>Test</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>handler</span> <span>:=</span> <span>http</span><span>.</span><span>HandlerFunc</span><span>(</span><span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;hello&#34;</span><span>))</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>    <span>srv</span> <span>:=</span> <span>httptest</span><span>.</span><span>NewTLSServer</span><span>(</span><span>handler</span><span>)</span>
</span></span><span><span>    <span>defer</span> <span>srv</span><span>.</span><span>Close</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>resp</span><span>,</span> <span>err</span> <span>:=</span> <span>srv</span><span>.</span><span>Client</span><span>().</span><span>Get</span><span>(</span><span>&#34;https://example.com&#34;</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>Fatal</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>body</span><span>,</span> <span>_</span> <span>:=</span> <span>io</span><span>.</span><span>ReadAll</span><span>(</span><span>resp</span><span>.</span><span>Body</span><span>)</span>
</span></span><span><span>    <span>resp</span><span>.</span><span>Body</span><span>.</span><span>Close</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>string</span><span>(</span><span>body</span><span>)</span> <span>!=</span> <span>&#34;hello&#34;</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;Unexpected response body: %s&#34;</span><span>,</span> <span>body</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" command="test" editor="basic" template="http.go" output=""></codapi-snippet><p>ğ—— <a href="https://pkg.go.dev/net/http/httptest@go1.26rc1#Server.Client">Server.Client</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/666855">666855</a> â€¢
ğ—” <a href="https://github.com/seankhliao">Sean Liao</a></p><h2 id="fmt-errorf"><a href="#fmt-errorf">#</a>
Optimized fmt.Errorf</h2><p>People often point out that using <code>fmt.Errorf(&#34;x&#34;)</code> for plain strings causes more memory allocations than <code>errors.New(&#34;x&#34;)</code>. Because of this, some suggest switching code from <code>fmt.Errorf</code> to <code>errors.New</code> when formatting isn&#39;t needed.</p><p>The Go team disagrees. Here&#39;s a quote from Russ Cox:</p><blockquote><p>Using <code>fmt.Errorf(&#34;foo&#34;)</code> is completely fine, especially in a program where all the errors are constructed with <code>fmt.Errorf</code>. Having to mentally switch between two functions based on the argument is unnecessary noise.</p></blockquote><p>With the new Go release, this debate should finally be settled. For unformatted strings, <code>fmt.Errorf</code> now allocates less and generally matches the allocations for <code>errors.New</code>.</p><p>Specifically, <code>fmt.Errorf</code> goes from 2 allocations to 0 allocations for a non-escaping error, and from 2 allocations to 1 allocation for an escaping error:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;foo&#34;</span><span>)</span>    <span>// non-escaping error
</span></span></span><span><span><span></span><span>sink</span> <span>=</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;foo&#34;</span><span>)</span> <span>// escaping error
</span></span></span></code></pre></div><p>This matches the allocations for <code>errors.New</code> in both cases.</p><p>The difference in CPU cost is also much smaller now. Previously, it was ~64ns vs. ~21ns for <code>fmt.Errorf</code> vs. <code>errors.New</code> for escaping errors, now it&#39;s ~25ns vs. ~21ns.</p><details><summary>Tell me more</summary><p>Here are the &#34;before and after&#34; benchmarks for the <code>fmt.Errorf</code> change. The non-escaping case is called <code>local</code>, and the escaping case is called <code>sink</code>. If there&#39;s just a plain error string, it&#39;s <code>no-args</code>. If the error includes formatting, it&#39;s <code>int-arg</code>.</p><p>Seconds per operation:</p><div><pre tabindex="0"><code data-lang="text"><span><span>goos: linux
</span></span><span><span>goarch: amd64
</span></span><span><span>pkg: fmt
</span></span><span><span>cpu: AMD EPYC 7B13
</span></span><span><span>                         â”‚    old.txt    â”‚        new.txt        â”‚
</span></span><span><span>                         â”‚      sec/op   â”‚   sec/op     vs base  â”‚
</span></span><span><span>Errorf/no-arsg/local-16     63.76n Â± 1%     4.874n Â± 0%  -92.36% (n=120)
</span></span><span><span>Errorf/no-args/sink-16      64.25n Â± 1%     25.81n Â± 0%  -59.83% (n=120)
</span></span><span><span>Errorf/int-arg/local-16     90.86n Â± 1%     90.97n Â± 1%        ~ (p=0.713 n=120)
</span></span><span><span>Errorf/int-arg/sink-16      91.81n Â± 1%     91.10n Â± 1%   -0.76% (p=0.036 n=120)
</span></span></code></pre></div><p>Bytes per operation:</p><div><pre tabindex="0"><code data-lang="text"><span><span>                         â”‚    old.txt    â”‚        new.txt       â”‚
</span></span><span><span>                         â”‚       B/op    â”‚    B/op     vs base  â”‚
</span></span><span><span>Errorf/no-args/local-16      19.00 Â± 0%      0.00 Â± 0%  -100.00% (n=120)
</span></span><span><span>Errorf/no-args/sink-16       19.00 Â± 0%     16.00 Â± 0%   -15.79% (n=120)
</span></span><span><span>Errorf/int-arg/local-16      24.00 Â± 0%     24.00 Â± 0%         ~ (p=1.000 n=120)
</span></span><span><span>Errorf/int-arg/sink-16       24.00 Â± 0%     24.00 Â± 0%         ~ (p=1.000 n=120)
</span></span></code></pre></div><p>Allocations per operation:</p><div><pre tabindex="0"><code data-lang="text"><span><span>                         â”‚    old.txt    â”‚        new.txt       â”‚
</span></span><span><span>                         â”‚    allocs/op  â”‚  allocs/op   vs base â”‚
</span></span><span><span>Errorf/no-args/local-16      2.000 Â± 0%     0.000 Â± 0%  -100.00% (n=120)
</span></span><span><span>Errorf/no-args/sink-16       2.000 Â± 0%     1.000 Â± 0%   -50.00% (n=120)
</span></span><span><span>Errorf/int-arg/local-16      2.000 Â± 0%     2.000 Â± 0%         ~ (p=1.000 n=120)
</span></span><span><span>Errorf/int-arg/sink-16       2.000 Â± 0%     2.000 Â± 0%         ~ (p=1.000 n=120)
</span></span></code></pre></div><p><a href="https://go.dev/play/p/rlRSO1ehx8O">source</a></p></details><p>If you&#39;re interested in the details, I highly recommend reading the CL â€” it&#39;s perfectly written.</p><p>ğ—— <a href="https://pkg.go.dev/fmt@go1.26rc1#Errorf">fmt.Errorf</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/708836">708836</a> â€¢
ğ—” <a href="https://github.com/thepudds">thepudds</a></p><h2 id="io-readall"><a href="#io-readall">#</a>
Optimized io.ReadAll</h2><p>Previously, <code>io.ReadAll</code> allocated a lot of intermediate memory as it grew its result slice to the size of the input data. Now, it uses intermediate slices of exponentially growing size, and then copies them into a final perfectly-sized slice at the end.</p><p>The new implementation is about twice as fast and uses roughly half the memory for a 65KiB input; it&#39;s even more efficient with larger inputs. Here are the geomean results comparing the old and new versions for different input sizes:</p><div><pre tabindex="0"><code data-lang="text"><span><span>                      â”‚     old     â”‚      new       vs base    â”‚
</span></span><span><span>          sec/op           132.2Âµ        66.32Âµ     -49.83%
</span></span><span><span>            B/op          645.4Ki       324.6Ki     -49.70%
</span></span><span><span>  final-capacity           178.3k        151.3k     -15.10%
</span></span><span><span>    excess-ratio            1.216         1.033     -15.10%
</span></span></code></pre></div><blockquote><p>See the full benchmark results in the commit. Unfortunately, the author didn&#39;t provide the benchmark source code.</p></blockquote><p>Ensuring the final slice is minimally sized is also quite helpful. The slice might persist for a long time, and the unused capacity in a backing array (as in the old version) would just waste memory.</p><p>As with the <code>fmt.Errorf</code> optimization, I recommend reading the CL â€” it&#39;s very good. Both changes come from <a href="https://github.com/thepudds">thepudds</a>, whose change descriptions are every reviewer&#39;s dream come true.</p><p>ğ—— <a href="https://pkg.go.dev/io@go1.26rc1#ReadAll">io.ReadAll</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/722500">722500</a> â€¢
ğ—” <a href="https://github.com/thepudds">thepudds</a></p><h2 id="slog-multihandler"><a href="#slog-multihandler">#</a>
Multiple log handlers</h2><p>The <code>log/slog</code> package, introduced in version 1.21, offers a reliable, production-ready logging solution. Since its release, many projects have switched from third-party logging packages to use it. However, it was missing one key feature: the ability to send log records to multiple handlers, such as stdout or a log file.</p><p>The new <code>MultiHandler</code> type solves this problem. It implements the standard <code>Handler</code> interface and calls all the handlers you set up.</p><p>For example, we can create a log handler that writes to stdout:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>stdoutHandler</span> <span>:=</span> <span>slog</span><span>.</span><span>NewTextHandler</span><span>(</span><span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>nil</span><span>)</span>
</span></span></code></pre></div><codapi-snippet id="s-slog-stdout" editor="basic"></codapi-snippet><p>And another handler that writes to a file:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>const</span> <span>flags</span> <span>=</span> <span>os</span><span>.</span><span>O_CREATE</span> <span>|</span> <span>os</span><span>.</span><span>O_WRONLY</span> <span>|</span> <span>os</span><span>.</span><span>O_APPEND</span>
</span></span><span><span><span>file</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>OpenFile</span><span>(</span><span>&#34;/tmp/app.log&#34;</span><span>,</span> <span>flags</span><span>,</span> <span>0644</span><span>)</span>
</span></span><span><span><span>defer</span> <span>file</span><span>.</span><span>Close</span><span>()</span>
</span></span><span><span><span>fileHandler</span> <span>:=</span> <span>slog</span><span>.</span><span>NewJSONHandler</span><span>(</span><span>file</span><span>,</span> <span>nil</span><span>)</span>
</span></span></code></pre></div><codapi-snippet id="s-slog-file" editor="basic"></codapi-snippet><p>Finally, combine them using a <code>MultiHandler</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// MultiHandler that writes to both stdout and app.log.
</span></span></span><span><span><span></span><span>multiHandler</span> <span>:=</span> <span>slog</span><span>.</span><span>NewMultiHandler</span><span>(</span><span>stdoutHandler</span><span>,</span> <span>fileHandler</span><span>)</span>
</span></span><span><span><span>logger</span> <span>:=</span> <span>slog</span><span>.</span><span>New</span><span>(</span><span>multiHandler</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Log a sample message.
</span></span></span><span><span><span></span><span>logger</span><span>.</span><span>Info</span><span>(</span><span>&#34;login&#34;</span><span>,</span>
</span></span><span><span>    <span>slog</span><span>.</span><span>String</span><span>(</span><span>&#34;name&#34;</span><span>,</span> <span>&#34;whoami&#34;</span><span>),</span>
</span></span><span><span>    <span>slog</span><span>.</span><span>Int</span><span>(</span><span>&#34;id&#34;</span><span>,</span> <span>42</span><span>),</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="slog.go" depends-on="s-slog-stdout s-slog-file" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>time=2025-12-31T11:46:14.521Z level=INFO msg=login name=whoami id=42
</span></span><span><span>{&#34;time&#34;:&#34;2025-12-31T11:46:14.521126342Z&#34;,&#34;level&#34;:&#34;INFO&#34;,&#34;msg&#34;:&#34;login&#34;,&#34;name&#34;:&#34;whoami&#34;,&#34;id&#34;:42}
</span></span></code></pre></div><blockquote><p>I&#39;m also printing the file contents here to show the results.</p></blockquote><p>When the <code>MultiHandler</code> receives a log record, it sends it to each enabled handler one by one. If any handler returns an error, <code>MultiHandler</code> doesn&#39;t stop; instead, it combines all the errors using <code>errors.Join</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>hInfo</span> <span>:=</span> <span>slog</span><span>.</span><span>NewTextHandler</span><span>(</span>
</span></span><span><span>    <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>&amp;</span><span>slog</span><span>.</span><span>HandlerOptions</span><span>{</span><span>Level</span><span>:</span> <span>slog</span><span>.</span><span>LevelInfo</span><span>},</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>hErrorsOnly</span> <span>:=</span> <span>slog</span><span>.</span><span>NewTextHandler</span><span>(</span>
</span></span><span><span>    <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>&amp;</span><span>slog</span><span>.</span><span>HandlerOptions</span><span>{</span><span>Level</span><span>:</span> <span>slog</span><span>.</span><span>LevelError</span><span>},</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>hBroken</span> <span>:=</span> <span>&amp;</span><span>BrokenHandler</span><span>{</span>
</span></span><span><span>    <span>Handler</span><span>:</span> <span>hInfo</span><span>,</span>
</span></span><span><span>    <span>err</span><span>:</span>     <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;broken handler&#34;</span><span>),</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>handler</span> <span>:=</span> <span>slog</span><span>.</span><span>NewMultiHandler</span><span>(</span><span>hBroken</span><span>,</span> <span>hInfo</span><span>,</span> <span>hErrorsOnly</span><span>)</span>
</span></span><span><span><span>rec</span> <span>:=</span> <span>slog</span><span>.</span><span>NewRecord</span><span>(</span><span>time</span><span>.</span><span>Now</span><span>(),</span> <span>slog</span><span>.</span><span>LevelInfo</span><span>,</span> <span>&#34;hello&#34;</span><span>,</span> <span>0</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Calls hInfo and hBroken, skips hErrorsOnly.
</span></span></span><span><span><span>// Returns an error from hBroken.
</span></span></span><span><span><span></span><span>err</span> <span>:=</span> <span>handler</span><span>.</span><span>Handle</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>rec</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>err</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="slog.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>time=2025-12-31T13:32:52.110Z level=INFO msg=hello
</span></span><span><span>broken handler
</span></span></code></pre></div><p>The <code>Enable</code> method reports whether any of the configured handlers is enabled:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>hInfo</span> <span>:=</span> <span>slog</span><span>.</span><span>NewTextHandler</span><span>(</span>
</span></span><span><span>    <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>&amp;</span><span>slog</span><span>.</span><span>HandlerOptions</span><span>{</span><span>Level</span><span>:</span> <span>slog</span><span>.</span><span>LevelInfo</span><span>},</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>hErrors</span> <span>:=</span> <span>slog</span><span>.</span><span>NewTextHandler</span><span>(</span>
</span></span><span><span>    <span>os</span><span>.</span><span>Stdout</span><span>,</span> <span>&amp;</span><span>slog</span><span>.</span><span>HandlerOptions</span><span>{</span><span>Level</span><span>:</span> <span>slog</span><span>.</span><span>LevelError</span><span>},</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>handler</span> <span>:=</span> <span>slog</span><span>.</span><span>NewMultiHandler</span><span>(</span><span>hInfo</span><span>,</span> <span>hErrors</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// hInfo is enabled.
</span></span></span><span><span><span></span><span>enabled</span> <span>:=</span> <span>handler</span><span>.</span><span>Enabled</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>slog</span><span>.</span><span>LevelInfo</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>enabled</span><span>)</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" editor="basic" template="slog.go" output=""></codapi-snippet><p>Other methods â€” <code>WithAttr</code> and <code>WithGroup</code> â€” call the corresponding methods on each of the enabled handlers.</p><p>ğ—— <a href="https://pkg.go.dev/log/slog@go1.26rc1#MultiHandler">slog.MultiHandler</a> â€¢
ğ—£ <a href="https://go.dev/issue/65954">65954</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/692237">692237</a> â€¢
ğ—” <a href="https://github.com/callthingsoff">Jes Cok</a></p><h2 id="testing-artifacts"><a href="#testing-artifacts">#</a>
Test artifacts</h2><p>Test <em>artifacts</em> are files created by tests or benchmarks, such as execution logs, memory dumps, or analysis reports. They are important for debugging failures in remote environments (like CI), where developers can&#39;t step through the code manually.</p><p>Previously, the Go test framework and tools didn&#39;t support test artifacts. Now they do.</p><p>The new methods <code>T.ArtifactDir</code>, <code>B.ArtifactDir</code>, and <code>F.ArtifactDir</code> return a directory where you can write test output files:</p><div id="s-test-artifacts-1"><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestFunc</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>dir</span> <span>:=</span> <span>t</span><span>.</span><span>ArtifactDir</span><span>()</span>
</span></span><span><span>    <span>logFile</span> <span>:=</span> <span>filepath</span><span>.</span><span>Join</span><span>(</span><span>dir</span><span>,</span> <span>&#34;app.log&#34;</span><span>)</span>
</span></span><span><span>    <span>content</span> <span>:=</span> <span>[]</span><span>byte</span><span>(</span><span>&#34;Loading user_id=123...\nERROR: Connection failed\n&#34;</span><span>)</span>
</span></span><span><span>    <span>os</span><span>.</span><span>WriteFile</span><span>(</span><span>logFile</span><span>,</span> <span>content</span><span>,</span> <span>0644</span><span>)</span>
</span></span><span><span>    <span>t</span><span>.</span><span>Log</span><span>(</span><span>&#34;Saved app.log&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet editor="basic"></codapi-snippet><p>If you use <code>go test</code> with <code>-artifacts</code>, this directory will be inside the output directory (specified by <code>-outputdir</code>, or the current directory by default):</p><div><pre tabindex="0"><code data-lang="text"><span><span>go1.26rc1 test -v -artifacts -outputdir=/tmp/output
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" command="test-artifacts" template="testing.go" selector="#s-test-artifacts-1 code" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>=== RUN   TestFunc
</span></span><span><span>=== ARTIFACTS TestFunc /tmp/output/_artifacts/2933211134
</span></span><span><span>    artifacts_test.go:14: Saved app.log
</span></span><span><span>--- PASS: TestFunc (0.00s)
</span></span></code></pre></div><p>As you can see, the first time <code>ArtifactDir</code> is called, it writes the directory location to the test log, which is quite handy.</p><p>If you don&#39;t use <code>-artifacts</code>, artifacts are stored in a temporary directory which is deleted after the test completes.</p><p>Each test or subtest within each package has its own unique artifact directory. Subtest outputs are not stored inside the parent test&#39;s output directory â€” all artifact directories for a given package are created at the same level:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestFunc</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>t</span><span>.</span><span>ArtifactDir</span><span>()</span>
</span></span><span><span>    <span>t</span><span>.</span><span>Run</span><span>(</span><span>&#34;subtest 1&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>ArtifactDir</span><span>()</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>    <span>t</span><span>.</span><span>Run</span><span>(</span><span>&#34;subtest 2&#34;</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>ArtifactDir</span><span>()</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><codapi-snippet sandbox="go:dev" command="test-artifacts" editor="basic" template="testing.go" output=""></codapi-snippet><div><pre tabindex="0"><code data-lang="text"><span><span>=== RUN   TestFunc
</span></span><span><span>=== ARTIFACTS TestFunc /tmp/output/_artifacts/2878232317
</span></span><span><span>=== RUN   TestFunc/subtest_1
</span></span><span><span>=== ARTIFACTS TestFunc/subtest_1 /tmp/output/_artifacts/1651881503
</span></span><span><span>=== RUN   TestFunc/subtest_2
</span></span><span><span>=== ARTIFACTS TestFunc/subtest_2 /tmp/output/_artifacts/3341607601
</span></span></code></pre></div><p>The artifact directory path normally looks like this:</p><div><pre tabindex="0"><code data-lang="text"><span><span>&lt;output dir&gt;/_artifacts/&lt;test package&gt;/&lt;test name&gt;/&lt;random&gt;
</span></span></code></pre></div><p>But if this path can&#39;t be safely converted into a local file path (which, for some reason, always happens on my machine), the path will simply be:</p><div><pre tabindex="0"><code data-lang="text"><span><span>&lt;output dir&gt;/_artifacts/&lt;random&gt;
</span></span></code></pre></div><p>(which is what happens in the examples above)</p><p>Repeated calls to <code>ArtifactDir</code> in the same test or subtest return the same directory.</p><p>ğ—— <a href="https://pkg.go.dev/testing@go1.26rc1#T.ArtifactDir">T.ArtifactDir</a> â€¢
ğ—£ <a href="https://go.dev/issue/71287">71287</a> â€¢
ğ—–ğ—Ÿ <a href="https://go.dev/cl/696399">696399</a> â€¢
ğ—” <a href="https://github.com/neild">Damien Neil</a></p><h2 id="modernized-go-fix"><a href="#modernized-go-fix">#</a>
Modernized go fix</h2><p>Over the years, the <code>go fix</code> command became a sad, neglected bag of rewrites for very ancient Go features. But now, it&#39;s making a comeback.</p><p>The new <code>go fix</code> is re-implemented using the Go <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis">analysis framework</a> â€” the same one <code>go vet</code> uses.</p><p>While <code>go fix</code> and <code>go vet</code> now use the same infrastructure, they have different purposes and use different sets of analyzers:</p><ul><li>Vet is for reporting problems. Its analyzers describe actual issues, but they don&#39;t always suggest fixes, and the fixes aren&#39;t always safe to apply.</li><li>Fix is (mostly) for modernizing the code to use newer language and library features. Its analyzers produce fixes are always safe to apply, but don&#39;t necessarily indicate problems with the code.</li></ul><div><pre tabindex="0"><code data-lang="text"><span><span>usage: go fix [build flags] [-fixtool prog] [fix flags] [packages]
</span></span><span><span>
</span></span><span><span>Fix runs the Go fix tool (cmd/fix) on the named packages
</span></span><span><span>and applies suggested fixes.
</span></span><span><span>
</span></span><span><span>It supports these flags:
</span></span><span><span>
</span></span><span><span>  -diff
</span></span><span><span>        instead of applying each fix, print the patch as a unified diff
</span></span><span><span>
</span></span><span><span>The -fixtool=prog flag selects a different analysis tool with
</span></span><span><span>alternative or additional fixers.
</span></span></code></pre></div><p>By default, <code>go fix</code> runs a full set of analyzers (currently, there are more than 20). To choose specific analyzers, use the <code>-NAME</code> flag for each one, or use <code>-NAME=false</code> to run all analyzers except the ones you turned off.</p><p>For example, here we only enable the <code>forvar</code> analyzer:</p><p>And here, we enable all analyzers except <code>omitzero</code>:</p><p>Currently, there&#39;s no way to suppress specific analyzers for certain files or sections of code.</p><p>To give you a taste of <code>go fix</code> analyzers, here&#39;s one of them in action. It replaces loops with <code>slices.Contains</code> or <code>slices.ContainsFunc</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// before go fix
</span></span></span><span><span><span></span><span>func</span> <span>find</span><span>(</span><span>s</span> <span>[]</span><span>int</span><span>,</span> <span>x</span> <span>int</span><span>)</span> <span>bool</span> <span>{</span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>v</span> <span>:=</span> <span>range</span> <span>s</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>x</span> <span>==</span> <span>v</span> <span>{</span>
</span></span><span><span>            <span>return</span> <span>true</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>false</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="go"><span><span><span>// after go fix
</span></span></span><span><span><span></span><span>func</span> <span>find</span><span>(</span><span>s</span> <span>[]</span><span>int</span><span>,</span> <span>x</span> <span>int</span><span>)</span> <span>bool</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>slices</span><span>.</span><span>Contains</span><span>(</span><span>s</span><span>,</span> <span>x</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>If you&#39;re interested, check out the dedicated blog post for the <a href="https://antonz.org/accepted/modernized-go-fix">full list of analyzers</a> with examples.</p><p>ğ—— <a href="https://pkg.go.dev/cmd/fix@go1.26rc1">cmd/fix</a> â€¢
ğ—š <a href="https://antonz.org/accepted/modernized-go-fix/">go fix</a> â€¢
ğ—£ <a href="https://go.dev/issue/71859">71859</a> â€¢
ğ—” <a href="https://github.com/adonovan">Alan Donovan</a></p><h2 id="final-thoughts"><a href="#final-thoughts">#</a>
Final thoughts</h2><p>Go 1.26 is incredibly big â€” it&#39;s the largest release I&#39;ve ever seen, and for good reason:</p><ul><li>It brings a lot of useful updates, like the improved <code>new</code> builtin, type-safe error checking, and goroutine leak detector.</li><li>There are also many performance upgrades, including the new garbage collector, faster cgo and memory allocation, and optimized <code>fmt.Errorf</code> and <code>io.ReadAll</code>.</li><li>On top of that, it adds quality-of-life features like multiple log handlers, test artifacts, and the updated <code>go fix</code> tool.</li><li>Finally, there are two specialized experimental packages: one with SIMD support and another with protected mode for forward secrecy.</li></ul><p>All in all, a great release!</p><p>You might be wondering about the <code>json/v2</code> package that was introduced as experimental in 1.25. It&#39;s still experimental and available with the <code>GOEXPERIMENT=jsonv2</code> flag.</p><p>P.S. To catch up on other Go releases, check out the <a href="https://antonz.org/which-go/">Go features by version</a> list or explore the interactive tours for Go <a href="https://antonz.org/go-1-25/">1.25</a> and <a href="https://antonz.org/go-1-24/">1.24</a>.</p><p>P.P.S. Want to learn more about Go? Check out my interactive book on <a href="https://antonz.org/go-concurrency/">concurrency</a></p><p><a href="https://antonz.org/subscribe/">â˜…Â Subscribe</a> to keep up with new posts.</p></div></div></article></div></div></div>
  </body>
</html>
