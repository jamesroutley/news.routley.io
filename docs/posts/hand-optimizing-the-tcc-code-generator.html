<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://briancallahan.net/blog/20220406.html">Original</a>
    <h1>Hand-optimizing the TCC code generator</h1>
    
    <div id="readability-page-1" class="page">
	<a name="top"></a>
	<div id="main">
	    
	    <p>academic, developer, with an eye towards a brighter techno-social life</p>
	    <hr/>
		
	    <hr/>
	</div>
<h5 id="prev"><a href="https://briancallahan.net/blog/20220402.html">[prev]</a></h5>
<h5 id="next">[next]</h5>
    <h2 id="title">2022-04-06</h2>
<p>I am on a number of different compiler mailing lists. One of those is the <a href="https://lists.nongnu.org/mailman/listinfo/tinycc-devel">mailing list</a> for the <a href="https://bellard.org/tcc/">Tiny C Compiler</a>. Imagine my surprise when a <a href="https://lists.nongnu.org/archive/html/tinycc-devel/2022-04/msg00002.html">recent email</a> mentioned our <a href="https://briancallahan.net/blog/20220330.html">latest</a> <a href="https://briancallahan.net/blog/20220402.html">series</a> and suggested trying a similar approach to improve the code generator in TCC. I was interested to see if there were any low-hanging fruit that could produce similar gains as <a href="https://github.com/ibara/O"><code>O</code></a> provides for <a href="https://c9x.me/compile/">QBE</a>.</p>
<h4>Differences between <code>tcc</code> and <code>cproc</code></h4>
<p>We should familiarize ourselves with how both <code>tcc</code> and <code>cproc</code> generate their output. For the purposes of simplifying things, we will presume that both compiler front-ends are perfectly equivalent. I know they&#39;re not, but our interest right now isn&#39;t in the front-end.</p>
<p>As we previously learned, <code>cproc</code> outputs QBE <a href="https://c9x.me/compile/doc/il.html">IL</a> that is further processed by QBE to produce assembly, which is then processed by the system <a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a> to produce object code and (eventually) linked with the system <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> to produce binaries and libraries. Because of this pipeline where each of the major steps is processed by a different standalone executable, we were able to write our own standalone executable, <code>O</code>, that we inserted into this compilation pipeline after QBE but before the system assembler. That allowed us to leverage knowledge about the format of QBE-generated assembly to search for deficiencies and write a simple pattern-matching program to output optimized versions of specific patterns. Our <code>O</code> program is a relatively straightforward <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole optimizer</a>.</p>
<p>In contrast, <code>tcc</code> combines the features of all the utilities needed to create a complete binary or library into a single executable. That means that <code>tcc</code> incorporates a <a href="https://en.wikipedia.org/wiki/C_preprocessor">C preprocessor</a>, C compiler, and linker all in one. There is also an integrated assembler in order to support <a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">inline assembly</a>. Unlike <code>cproc</code>, <code>tcc</code> does not output assembly—it directly outputs object files. That&#39;s great in terms of speed: saving an entire step compared to <code>cproc</code> (and <a href="https://gcc.gnu.org/">gcc</a>, for that matter) is bound to result in faster compiles, all else being equal.</p>
<p><span>However</span>, taking the single-binary approach combined with directly outputting object code means that we are not going to be able to take the <code>O</code> approach to optimization. There isn&#39;t a pipeline of standalone executables that we can insert a new utility into. And even if there were, while the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> format does divide code into sections that we could selectively interrogate and run a peephole optimizer over, it will be far more work than reading over assembly code, requiring at a minimum a manual so we could figure out what the binary decodes to. As x86 and x86_64 are <a href="https://yossarian.net/res/pub/mishegos-langsec-2021.pdf">notoriously difficult to decode correctly</a>, we would either have to spend countless sleepless nights pouring over Intel manuals (and still probably get it wrong sometimes) or trust someone else&#39;s decoder to get things right (and still probably get it wrong sometimes). Neither of these options are ideal, so we need to find another approach.</p>
<h4>Hand-optimizing the <code>tcc</code> code generator</h4>
<p>Because <code>tcc</code> directly outputs object code, we could take an approach where we read through the code generator spotting object code generation that is less than ideal and teach <code>tcc</code> about better code the generate instead. To start out, I am only going to worry about x86_64 code generation. There are code generators for x86, arm, aarch64, riscv64, and <a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320#C6000_series">TMS320C67x</a> as well. Each code generator is its own file and there is no intermediate code so there are no IL-based optimizations that would benefit all the code generators. Nevertheless, I suspect there is sufficient usage of the x86_64 code generator to make this a good starting point.</p>
<p>The x86_64 code generator can be found <a href="https://github.com/TinyCC/tinycc/blob/mob/x86_64-gen.c">here</a>. We are also going to use a very useful tool to decode the object code that <code>tcc</code> generates: <a href="https://en.wikipedia.org/wiki/Objdump"><code>objdump</code></a>. This utility is from the <a href="https://www.gnu.org/software/binutils/">GNU binutils</a> so chances are good you already have it installed on your system or can easily get it on your system. On my <a href="https://www.openbsd.org/">OpenBSD</a> system, I have a little script that every night grabs the latest git HEAD of binutils and builds and installs it, so on my machine I am using <code>GNU objdump (GNU Binutils) 2.38.50.20220406</code> but I am willing to bet that even old versions of <code>objdump</code> will work fine for today.</p>
<p>What we will do is build some simple sample programs with <code>tcc</code> and read the disassembled output from <code>objdump</code> in order to find opportunities to teach the code generator how to do things better.</p>
<p>Therefore, when we talk about optimizing the code generator for today, we&#39;re not talking about making the code generator smaller or faster necessarily. We&#39;re talking about making the code generator smarter. If we&#39;re lucky, even though we&#39;re likely to add some code to make the code generator smarter, since the improved code generator will be run on itself, perhaps the optimization improvements outweigh the additional code we will add.</p>
<p>With that said, there is an overarching concern that I want to care about: the overall goal of TCC is to be <span>fast</span>. It is about an order of magnitude faster than gcc. It turns out optimizations can be expensive to process and get right. I want to avoid making TCC take longer to compile code. Hopefully, our work today can make TCC both faster <span>and</span> produce better code. If not, we should at least not make TCC slower.</p>
<h4>Reading Hello World</h4>
<p>Let&#39;s start with the simplest C program. Even simpler than <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program#C">Hello World</a>. How about the <a href="https://man.openbsd.org/true.1">true</a> program? How about something even smaller:</p>
<pre>main(){}
</pre>
<p>That&#39;s it. That&#39;s the simplest complete C program I know how to write. Let&#39;s compile it with <code>tcc</code> and read the disassembly with <code>objdump</code>:</p>
<pre>/home/brian $ tcc -c true.c
/home/brian $ objdump -d true.o

true.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   48 81 ec 00 00 00 00    sub    $0x0,%rsp
   b:   b8 00 00 00 00          mov    $0x0,%eax
  10:   c9                      leave
  11:   c3                      ret
</pre>
<p>Our old friend <code>movl $0, %eax</code> is back. We know what to do with that, and now we can even see why it is we&#39;d want to make the replacement: <code>movl $0, %eax</code> is five bytes. For comparison, <code>xorl %eax, %eax</code> is only two bytes (<code>0x31 0xc0</code>), so we get a 60% reduction in code size for this optimization. It is also <a href="https://randomascii.wordpress.com/2012/12/29/the-surprising-subtleties-of-zeroing-a-register/">recommended by Intel</a> for zeroing a register.</p>
<p>As we learned when developing <code>O</code>, optimizing all instances of <code>mov $0</code> to <code>xor</code> consistently reduced binary sizes between 2% and 3%. Let&#39;s teach <code>tcc</code> how to make this improvement.</p>
<h4>Wading through the code generator</h4>
<p>The code generator (and most of TCC) is a bit opaque in its coding. Lots of one-letter and two-letter variables and function names. Fortunately for us, some comments make it abundantly clear where we should focus our attention: there&#39;s a comment that clearly says <code>/* mov $xx, r */</code> and that&#39;s the exact idiom we are looking for. We want to teach the code generator about a special case where if the immediate is zero, we can optimize this instruction to an <code>xor</code>. There&#39;s separate code for 32-bit and 64-bit cases. Let&#39;s start with the 32-bit case.</p>
<p>The 32-bit case code can be found <a href="https://github.com/TinyCC/tinycc/blob/e2e5377e7b68d57def00acda17ffcfca6dce8b84/x86_64-gen.c#L489">here</a>. Let&#39;s imagine that we don&#39;t know what the <code>orex()</code> function does. There is still some information we can glean in this block. The <a href="https://github.com/TinyCC/tinycc/blob/e2e5377e7b68d57def00acda17ffcfca6dce8b84/x86_64-gen.c#L490">next line</a> appears to emit a 32-bit immediate. It seems like the variable <code>fc</code> represents the 32-bit immediate. So that must be the value for us to check. If <code>fc</code> is zero, then we should apply the optimization. Even if we still don&#39;t know what the <code>orex()</code> function does, one of its arguments is <code>REG_VALUE(r)</code>, and its value is added to <code>0xb8</code> to form a <code>mov</code> opcode, so it appears to be a register modifier.</p>
<p>Let&#39;s see what <code>xorl %eax, %eax</code> encodes to. Yes, I know I already spoiled it earlier in this post, but let&#39;s confirm things. We can write a new assembly file named <code>xor.s</code> and inside put:</p>
<pre>	xorl %eax, %eax
</pre>
My version of the <a href="https://en.wikipedia.org/wiki/GNU_Assembler">GNU assembler</a> is <code>GNU assembler (GNU Binutils) 2.38.50.20220406</code>. I have seen examples where newer versions of GNU as select better encodings for certain instructions than older versions, but I don&#39;t think that will matter much today. When I run <code>as -o xor.o xor.s</code> and then run <code>objdump -d xor.o</code>, here is the output I see:
<pre>

xor.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   31 c0                   xor    %eax,%eax
</pre>
<p>Confirmed. We want to turn the binary pattern <code>b8 00 00 00 00</code> into <code>31 c0</code>. At least, that will turn <code>movl $0, %eax</code> into <code>xorl %eax, %eax</code>. It will be slightly different for the other registers. How different? Let&#39;s find out.</p>
<h4>Generalizing the pattern</h4>
<p>One of the things to notice is that TCC does not use all the available registers. Looking at the list, it seems like TCC avoids using registers that the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">System V AMD64 ABI</a> says are callee-saved registers because using callee-saved registers almost certainly complicates things. So we only have <code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, and <code>r11</code>. While <code>rsp</code> is in that enum, it is a callee-saved register; I&#39;m pretty sure it&#39;s only in this enum to deal with stack frame setup and teardown. Let&#39;s not worry about the <code>xmm</code> registers; those are for <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> instructions. The <code>st0</code> register is for the <a href="https://en.wikipedia.org/wiki/Intel_8087#Registers">floating-point unit</a>.</p>
<p>So let&#39;s follow the order in this enum and edit our <code>xor.s</code> test file to add additional <code>xor</code> lines for each of these registers we have available for us to use:</p>
<pre>	xorl %eax, %eax
	xorl %ecx, %ecx
	xorl %edx, %edx
	xorl %esp, %esp
	xorl %esi, %esi
	xorl %edi, %edi
	xorl %r8d, %r8d
	xorl %r9d, %r9d
	xorl %r10d, %r10d
	xorl %r11d, %r11d
</pre>
<p>That assembly produces this output:</p>
<pre>

xor.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   31 c0                   xor    %eax,%eax
   2:   31 c9                   xor    %ecx,%ecx
   4:   31 d2                   xor    %edx,%edx
   6:   31 e4                   xor    %esp,%esp
   8:   31 f6                   xor    %esi,%esi
   a:   31 ff                   xor    %edi,%edi
   c:   45 31 c0                xor    %r8d,%r8d
   f:   45 31 c9                xor    %r9d,%r9d
  12:   45 31 d2                xor    %r10d,%r10d
  15:   45 31 db                xor    %r11d,%r11d
</pre>
<p>Turns out that the <code>r8</code>-<code>r11</code> registers require an extra byte to encode. It&#39;s still smaller than a <code>mov</code> into those registers. However, I&#39;ve already done a good bit of testing and it turns out that it getting that far down the register list is so rare I&#39;ve never seen it happen. So we&#39;re just not going to bother with the three byte ones.</p>
<p>For the remaining six registers, the difference between each opcode is nine (c9-c0, d2-c9, ff-f6)—remember that we&#39;re missing <code>rbx</code> and <code>rbp</code> and those fill in the missing steps. The enum we previously saw does account for the missing registers. Let&#39;s put a pin in this for now.</p>
<h4>Adding our first optimization</h4>
<p>Armed with this new knowledge, let&#39;s improve the 32-bit case. We want to check to see if the <code>fc</code> variable is zero and if it is, and the register we are working with is one of the registers that encodes to a two byte <code>xor</code>, then we should output code to <code>xor</code> the register with itself. Otherwise, we should do what we&#39;ve been doing: <code>mov</code> the immediate into the register.</p>
<p>In code form, that would look like this:</p>
<pre>            if (fc == 0 &amp;&amp; r &lt; 8) {
                o(0x31); /* xor r, r */
                o(0xc0 + REG_VALUE(r) * 9);
            } else {
                orex(0,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */
                gen_le32(fc);
            }
</pre>
<p>That&#39;s it. That should improve the code generator for 32-bit <code>mov</code>. Note that we do <code>REG_VALUE(r) * 9</code> because we learned that each <code>xor</code> a register with itself is nine opcodes away from the next one. What&#39;s in between? If you want to <code>xor</code> a register with a different register.</p>
<h4>Improving 64-bit <code>mov</code></h4>
<p>We can follow the exact same pattern for 64-bit <code>mov</code> optimization. Note here that TCC is using <code>sv-&gt;c.i</code> to store the value of the immediate. Even though this is a 64-bit optimization, we are going to want to use the 32-bit <code>xor</code>. This is because <a href="http://x86asm.net/articles/x86-64-tour-of-intel-manuals/#General-purpose-Registers">32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose register</a>. Or, a bit more succinctly, 32-bit operations clear the upper half of the 64-bit destination register. It takes three bytes to encode a 64-bit <code>xor</code> but since the 32-bit <code>xor</code> will clear the upper half of the register anyway, we can save a byte and get the same result. Here&#39;s the code:</p>
<pre>            if (sv-&gt;c.i == 0 &amp;&amp; r &lt; 8) {
                o(0x31); /* xor r, r */
                o(0xc0 + REG_VALUE(r) * 9);
            } else {
                orex(1,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */
                gen_le64(sv-&gt;c.i);
            }
</pre>
<p>Was it really that easy? Yes, yes it was.</p>
<p>...almost</p>
<h4>An additional optimization location</h4>
<p>Further down the code generator, there is a <a href="https://github.com/TinyCC/tinycc/blob/e2e5377e7b68d57def00acda17ffcfca6dce8b84/x86_64-gen.c#L1425">location</a> where a hardcoded <code>mov</code> immediate into <code>%eax</code> is taking place. If that immediate is zero, then this is yet another location where we need to teach TCC about our <code>xor</code> optimization. It took me a while to notice it at first, and I only noticed it because subsequent runs of <code>objdump</code> told me I wasn&#39;t making all the optimizations I thought I should be.</p>
<p>Here is the improvement:</p>
<pre>    if (vtop-&gt;type.ref-&gt;f.func_type != FUNC_NEW) { /* implies FUNC_OLD or FUNC_ELLIPSIS */
        if (nb_sse_args == 0)
            o(0xc031); /* xor eax, eax */
        else
            oad(0xb8, nb_sse_args &lt; 8 ? nb_sse_args : 8); /* mov nb_sse_args, %eax */
    }
</pre>
<h4>Testing</h4>
<p>While we can congratulate ourselves on improving the code generator, we don&#39;t actually know we have made an improvement until we test things out. I want to test two different things: first, if we are producing smaller binaries; and second, if we are producing faster binaries. Again, I don&#39;t want to slow <code>tcc</code> down. I am quite confident we will produce smaller binaries. But if <code>tcc</code> takes longer to compile code, I&#39;m not sure it would be worth it.</p>
<p>First, I ran the TCC test suite to make sure I didn&#39;t break anything. Everything passed. So far, so good.</p>
<p>Next, I calculated the difference in the <code>.text</code> section of TCC binaries, libraries, and object files before and after applying this diff. Here are the numbers I saw:</p>
<table>
<tbody><tr><th>Binary</th>
<th>Old size</th>
<th>New size</th>
<th>Difference in bytes</th>
<th>Percent size reduction</th>
</tr><tr>
  <td><code>tcc</code></td>
  <td>328786</td>
  <td>321358</td>
  <td>7428</td>
  <td>2.26%</td>
</tr>
<tr>
  <td><code>libtcc.a</code></td>
  <td>307288</td>
  <td>300252</td>
  <td>7036</td>
  <td>2.29%</td>
</tr>
<tr>
  <td><code>bcheck.o</code></td>
  <td>23254</td>
  <td>22801</td>
  <td>453</td>
  <td>1.95%</td>
</tr>
<tr>
  <td><code>bt-exe.o</code></td>
  <td>4732</td>
  <td>4550</td>
  <td>182</td>
  <td>3.85%</td>
</tr>
<tr>
  <td><code>bt-log.o</code></td>
  <td>648</td>
  <td>639</td>
  <td>9</td>
  <td>1.39%</td>
</tr>
<tr>
  <td><code>libtcc1.a</code></td>
  <td>12678</td>
  <td>12119</td>
  <td>559</td>
  <td>4.41%</td>
</tr>
</tbody></table>
<p>That&#39;s pretty excellent. Even though we added code to the compiler, we still walked away with a pretty significant size reduction. That&#39;s a big win.</p>
<p>I also did a battery of build time tests and could find no statistically significant changes in compile time. In fact, the first time I ran the TCC test suite with the improved compiler, I was surprised to see that the times for that run were lower than they were with the old TCC. But it&#39;s not statistically significant as far as I can tell. This isn&#39;t all that unexpected as we really only added five truthiness checks, and those checks don&#39;t even run every time the code generator produces a new instruction.</p>
<p>Another TCC user <a href="https://lists.nongnu.org/archive/html/tinycc-devel/2022-04/msg00012.html">posted</a> some build times and <code>.text</code> sizes for <a href="https://sqlite.org/index.html">SQLite3</a>. A 2.60% reduction in binary size and no difference in build times (though there isn&#39;t quite enough data in the email to make a statement on significance of build times).</p>
<p>I&#39;m going to call this a win. Smaller binaries and no difference in compile times. This is an optimization worth sharing with the rest of the TCC community.</p>
<h4>Work continues...</h4>
<p>I <a href="https://lists.nongnu.org/archive/html/tinycc-devel/2022-04/msg00011.html">posted</a> the complete diff to the TCC mailing list. Other than a <a href="https://github.com/TinyCC/tinycc/commit/46bf3f940c24f277e6cacdbe468db6f781f80f48">drive-by commit</a> I made as part of my role as <a href="https://openports.se/lang/tcc">OpenBSD port maintainer of TCC</a> to support the riscv64 arch, I haven&#39;t personally made any other commits to TCC, though I did author the original diff to <a href="https://briancallahan.net/blog/20210214.html">finish TCC linker support on OpenBSD</a>. I&#39;m not exactly sure what the procedure is for committing something that is going to affect everyone to the <code>mob</code> branch. So I&#39;ll just wait until I get a go-ahead. Until then, you can grab the patch from the mailing list. I suspect I will commit it soon.</p>
<p>I hope you enjoyed coming on this journey with me to hand-optimize the TCC x86_64 code generator. There are certainly more such improvements in the x86_64 code generator and all the other code generators. Let&#39;s find those opportunities and teach them to TCC.</p>
<p><a href="#top"><img alt="Top" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAICAYAAADJEc7MAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wkWDyUKJxzXegAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAUklEQVQY02Ocd/j/fwY0kGjDwMhACPz//5/h////DPMO//8PYxODWXAZOP8Iw39k22F8uBg2G7Gx0cWYGMgEWJ2aaMPAiO5UDOcTGxjogUe2UwHwdJDZUucW5QAAAABJRU5ErkJggg=="/></a></p>
<a href="https://briancallahan.net/blog/feed.xml"><img alt="RSS" src="https://briancallahan.net/blog/media/pic_rss.gif"/></a>
	</div>
  </body>
</html>
