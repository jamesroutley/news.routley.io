<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://electricui.com/blog/latency-comparison">Original</a>
    <h1>Benchmarking latency across common wireless links for microcontrollers</h1>
    
    <div id="readability-page-1" class="page"><div><div><main><p>Scott</p><p>I was recently trying to quantify the tradeoffs in user-experience for a wireless product and successfully nerd-sniped myself into evaluating a super-set of wireless modules and protocols.</p>
<p>While standards groups, radio chipset vendors, and IOT system integrators happily talk about improvements to bandwidth, long-range capabilities, or how low their power consumption is, I&#39;ve really struggled to find substantive information about latency beyond hand-wavy marketing superlatives.</p>
<p>Calculating symbol rate and latency figures from radio first-principles is doable, but modern radio chipsets are also subject to protocol specific behaviours and increasingly complex software stacks. So let&#39;s experimentally compare them in &#39;typical&#39; implementations!</p>
<span><span>
      <a href="https://electricui.com/static/ca33933a8dc7d51605f394fb7aacba51/da6ee/module-assortment.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/ca33933a8dc7d51605f394fb7aacba51/7bb4c/module-assortment.avif 225w,
/static/ca33933a8dc7d51605f394fb7aacba51/212f8/module-assortment.avif 450w,
/static/ca33933a8dc7d51605f394fb7aacba51/4d7a3/module-assortment.avif 900w,
/static/ca33933a8dc7d51605f394fb7aacba51/6f77c/module-assortment.avif 1350w,
/static/ca33933a8dc7d51605f394fb7aacba51/cbb88/module-assortment.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/ca33933a8dc7d51605f394fb7aacba51/7d522/module-assortment.webp 225w,
/static/ca33933a8dc7d51605f394fb7aacba51/b5115/module-assortment.webp 450w,
/static/ca33933a8dc7d51605f394fb7aacba51/5722e/module-assortment.webp 900w,
/static/ca33933a8dc7d51605f394fb7aacba51/c5b95/module-assortment.webp 1350w,
/static/ca33933a8dc7d51605f394fb7aacba51/aa619/module-assortment.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/ca33933a8dc7d51605f394fb7aacba51/08b3c/module-assortment.jpg 225w,
/static/ca33933a8dc7d51605f394fb7aacba51/12ba2/module-assortment.jpg 450w,
/static/ca33933a8dc7d51605f394fb7aacba51/86440/module-assortment.jpg 900w,
/static/ca33933a8dc7d51605f394fb7aacba51/7e63a/module-assortment.jpg 1350w,
/static/ca33933a8dc7d51605f394fb7aacba51/da6ee/module-assortment.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/ca33933a8dc7d51605f394fb7aacba51/86440/module-assortment.jpg" alt="Collection of green, blue, white and black wireless boards without antennas on workbench" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<h2 id="microbenchmarking-embedded-hardware" is="h2">Microbenchmarking embedded hardware</h2>
<p>With any real-world project there are dozens of hardware and firmware design choices and optimisations that could meaningfully impact performance, and the matrix of potential tests becomes rather unapproachable if we also test across environments representative of real-world interference conditions.</p>
<p>While hardcore optimisation of each implementation isn&#39;t the primary focus here, I do want any comparisons to be fairly representative to the technologies and teams of engineers who&#39;ve built them.</p>
<p>So I need to simplify this first round of testing by:</p>
<ul>
<li>Picking a smaller set of popular hardware options and protocols,</li>
<li>Only performing &#39;bench tests&#39; in a semi-controlled environment,</li>
<li>Trying to answer one specific question: &#34;<em>How responsive can one-way wireless user interaction be?</em>&#34;</li>
</ul>
<p>Some of the most common examples of this behaviour also happen to be the most latency sensitive: toggling lightbulbs, real-time review of sensor streams, and wireless control of actuators or robots.</p>
<span>
      
    </span>
<p>Now that we know what we&#39;re testing for, let&#39;s work out how to measure the results.</p>
<h3 id="sizing-test-packets" is="h3">Sizing Test Packets</h3>
<p>Different use-cases may prioritise data rate or power consumption over responsiveness - a tank-level sensor has relaxed bandwidth and latency requirements, while a quadcopter control signal needs to be delivered with consistent latency and at a high rate.</p>
<p>Every communication link has a different set of design goals, but I want the tests to allow those design choices to be shown if possible. In my experiences with embedded systems, typical applications could describe their transfers with these common groups:</p>
<ul>
<li>Small packets with one or two small pieces of data, like a sensor reading or heart-beat value,</li>
<li>Longer structures of data, many sensor fields, a set of configuration values,</li>
<li>&#39;Big&#39; packets containing chunked historical data, audio or images, and user-facing file transfers</li>
</ul>
<p>So I&#39;ll test three different payload lengths: <code>12B</code>, <code>128B</code>, and <code>1024B</code>, which should help shape a reasonable picture of how these wireless links behave. Some of the protocols have a MTU (<strong>M</strong>aximum <strong>T</strong>ransmission <strong>U</strong>nit) which might not fit the larger packets, so where needed I&#39;ll break them into several packets.</p>
<h3 id="timing-capture" is="h3">Timing Capture</h3>
<p>To keep things manageable later on, I&#39;ll be triggering each implementation with the rising edge of a logic-level signal (with a high priority interrupt) to trigger a new packet to be sent.</p>
<p>The receiving end will indicate a valid packet has arrived by driving an IO pin high.</p>
<img src="https://electricui.com/a8a09d8f59875a4d86025bd4f14179ad/timing-capture-diagram.svg" alt="Waveform diagram with trigger and completion pulses on either side of a transmission block"/>
<p>There are a few reasons for this:</p>
<ul>
<li>Support for external trace probes, debug peripherals, and internal timekeeping quality varies between device,</li>
<li>External test equipment can measure timing information for all targets equally <em>in the lab</em>,</li>
<li>Testing latency and jitter over longer distances and in real-world crowded RF environments will be difficult using lab gear!<!-- -->
<ul>
<li>Externally synchronised trigger pulses offer some semblance of consistency (GPS PPS, <em>PTP?</em>)</li>
</ul>
</li>
</ul>
<p>I&#39;ll capture the timing information with a Saleae Logic analyser sampling at 100 Msamples/sec (10 ns), and then post-process exported edge timestamps with a simple R script.</p>
<h3 id="test-validation" is="h3">Test Validation</h3>
<p>I&#39;m fully aware of the complexities that come with remote communications in an embedded project, and that development time <em>is better spent</em> testing and optimising for power consumption or connection reliability. I expect the timing behaviour of most links&#39; physical layers and respective protocols to trivialise any test fixture overheads, but I still want to quantify and eliminate benchmark artifacts.</p>
<p>Skimming the surface of possible optimisations sees us consider compiler optimisation settings, microcontroller clock tree configuration, peripheral use and configuration, use of an RTOS, and the weight of different hardware abstraction layers such as ST&#39;s LL (<strong>L</strong>ow<strong>L</strong>ayer), STM32Cube&#39;s HAL or the Arduino framework.</p>
<p>Without blowing this into a full dissertation detailing each hardware target, I&#39;ll try to demonstrate the impact of some of these choices using one of my preferred microcontroller families.</p>
<span><span>
      <a href="https://electricui.com/static/ffa6fccb80c67be1ceae5cccc762b3aa/da6ee/test-hardware.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/ffa6fccb80c67be1ceae5cccc762b3aa/7bb4c/test-hardware.avif 225w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/212f8/test-hardware.avif 450w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/4d7a3/test-hardware.avif 900w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/6f77c/test-hardware.avif 1350w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/cbb88/test-hardware.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/ffa6fccb80c67be1ceae5cccc762b3aa/7d522/test-hardware.webp 225w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/b5115/test-hardware.webp 450w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/5722e/test-hardware.webp 900w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/c5b95/test-hardware.webp 1350w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/aa619/test-hardware.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/ffa6fccb80c67be1ceae5cccc762b3aa/08b3c/test-hardware.jpg 225w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/12ba2/test-hardware.jpg 450w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/86440/test-hardware.jpg 900w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/7e63a/test-hardware.jpg 1350w,
/static/ffa6fccb80c67be1ceae5cccc762b3aa/da6ee/test-hardware.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/ffa6fccb80c67be1ceae5cccc762b3aa/86440/test-hardware.jpg" alt="White STM32F4 microcontroller PCB next to red Saleae Logic analyser" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>First, let&#39;s see how severe the impact of <em>software choices</em> might be on the results. Hardware is kept consistent across these tests - a <code>STM32F429ZI</code> micro is clocked at <code>168 MHz</code> and running <a href="https://github.com/Scottapotamas/embedded-wireless-latency-eval/tree/main/firmware/gpio_tests" target="_blank" rel="noopener noreferrer">nearly identical code</a> that catches the trigger signal via interrupt and drives an IO pin high.</p>
<img src="https://electricui.com/c185c358f7c7b0cd7163155b3f213901/gpio-latency-tests.svg" alt="6 boxplots of ST LL results starting at 340ns, Arduino results around 1500ns"/>
<p>While we expect release builds to be faster than debug and a bare-metal LL project to exhibit less overhead than an Arduino sketch, this &#39;quick example&#39; still raises some interesting questions:</p>
<ul>
<li>Why does optimising for size (<code>-Os</code>) run faster than optimising for performance (<code>-O3</code>)?<!-- -->
<ul>
<li>Due to different handling of a boolean check! <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U8lJL6yAngGVG6AMKpaAVxYMQAJlIOAMngMmABy7gBGmMTeGqQADqgKhLYMzm4e3nEJSQIBQaEsEVFeMZaY1slCBEzEBKnunj6l5QKV1QS5IeGR0RZVNXXpjX3tgZ0F3cUAlBaorsTI7BwApF4AzIHIblgA1EurjgoE6GGoLgB0CHvYSxoAgje3AG4uTDb02ycu2wTEeMDAkWMsQcgWAu1WABFtlQxEo9gAhB4PQIEbYsJiBCCTJEAdkRd22AHcEHRMBAuNiCdtqUs8UiqdTGds8FQID8/gDiECQUZKbcmUzafj%2BQLRUwFCwICsvMEAPLKaXY1bw7YAelV2wA4soAJKy7Yk4CXBmixns/6A4EMfBGcFQmG0OHKh6m3Y4iEu02YR2YT2ioV%2B13bcWS6VyhVeLxKlXqrW6/W0VCEwOC92B2keu4ZjjTWicACsvE8HC0pFQnEc2wUs3mmF2ax4pAImhz0wA1iBVqszl3e33%2BwA2fScSRFltlzi8BQgGLNks50hwWBINAsWKksgUCCr9f0KLIYBcVY%2BLCPPALABqeEwhNlVs4jZotAIkWnEDC47CgWqAE8H7wv2YYgf1lMJtDKOdG1XNhBFlBhaD/edSCwMJXGARwxEdf9kMwdEjHEJD8GICC8EeTBpyQzBVDKVwX2wlFvXHWg8DCYhf2cLBx3ZFh/2mKgDGABQrxvO9GGw/hBBEMR2CkGRBEUFR1CQ3QuH0QwTDMfQWOnSBplQWIbAECiAFpZVWXhUDI4hfiwHSsQsb0SLsCAHAGTwuAADl8a0OnyQoJCHeJEkMlIXHqCQvKC7IGF8rooi4IcmhC1p%2BjC9JPIcqxkuGWLxnixLhjciLejaXL/IS6ZqzmBYJFzAsxyQ8sOG2VQPIHYyB0kbZgGQZBtiPM4vG2CBcEIEh61WCleDnLRJnbTtu37JbeyHPMOFHUhi1LJqpxnJsW2mJdEBQVA1w3chKB3DcUEPY8cLPS9r1ve9uF4J8X2IN8PyQwDf2w37gNA8DrGw6DGAIOCEPHFC0Iw2gsNenC8OAAjSyIkiyIo0sqJoujEYYtbS2Y1j2IwRZS243i%2BAEoSntE4tH1kKTxFkiT5CUNRx10HwDCMEBTGMcxibsvSDOSEzZQUCyrJs8j4Eqxzmk8FzrSK1T/FGPzulUqKQrVzJguSMrtcypyGBS2o0vc02lYt434pK1K0mtw5Ss1uLapmaqZLqjhC028cmpatqOq6nq%2BoGoaRvwIhiAmqb9vnObSA7Lse2Wpbh3WhrtsnCw9pm1ss68HOLLzwvk6sxI7EkIA%3D%3D%3D" target="_blank" rel="noopener noreferrer">Godbolt comparison here</a>.</li>
<li>For this contrived example, <code>-O1</code>, <code>-O2</code> and <code>-O3</code> release builds give identical performance.</li>
<li>Over the next few tests with higher complexity, <code>-Os</code> was consistently slower.</li>
</ul>
</li>
<li>Why do the Arduino results have such a wide variance?<!-- -->
<ul>
<li>Interestingly, the stm32duino project uses ST&#39;s LL internally, but deciphering where performance is lost needs its own discussion...</li>
<li>As a simple answer, EXTI redirection and heavier peripheral housekeeping.</li>
</ul>
</li>
</ul>
<p>This generally matched my expectations. While I&#39;ll only show data using the LL and built with <code>-O3</code> from here on, we should take a look at a more significant cause of test variations - <em>hardware configuration</em>.</p>
<p>Most modern micros support different strategies to manage performance critical peripherals: by polling registers, IRQ (<strong>I</strong>nterrupt <strong>R</strong>e<strong>q</strong>uest), or with DMA offload (<strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess). These configuration details are far more likely to impact latency, but it&#39;s important to point out that these choices are normally made to access specific features, reduce power consumption, or get out of the way of other application logic.</p>
<p>We need to communicate with some of our wireless modules using serial, so let&#39;s do a quick test of the UART peripheral using all three approaches and see why one of the best features of using DMA backed peripherals might not be so fantastic for these tests.</p>
<img src="https://electricui.com/b15b348f58b6a4119d36cb43a46eb9be/uart-115200baud-latency.svg" alt="Boxplots of similar polled and IRQ tests at 1050us, DMA at 1050 and 1140us"/>
<p>The majority of DMA tests have to wait for the UART peripheral to detect when the RX line is unused and generate an interrupt to wake the micro (usually one byte&#39;s worth of time, or ~87 µs). The small cluster of outliers nearly matching IRQ results is due to the DMA <em>half-complete</em> or <em>complete</em> interrupts firing when the final byte of the test sequence arrives.</p>
<p>This is normally less of a practical concern when handling other tasks or sending larger packets. The benefits for real projects are massively improved power consumption because the core can sleep for as long as possible without missing data, or other tasks can be executed with reduced overhead and context switches.</p>
<blockquote>
<p>While the polling test appears to perform as well as IRQ, the micro needs to spend <strong>all</strong> of its time sending and checking for data. In real-world applications, it will miss data without careful cooperative sharing of CPU time with application workloads.</p>
</blockquote>
<p>It&#39;s important to remember the context of these tests and the simple fact that implementation details are insignificant compared to increasing throughput - just waiting for 12 bytes at 115200 baud was responsible for 1041 µs of the 1050 µs, or <strong>~99%</strong>.</p>
<div><table><thead><tr><th>Baud</th><th>Bits/s</th><th>Bit duration</th><th>8N1 byte duration</th></tr></thead><tbody><tr><td>115200</td><td>115200 bits/s</td><td>8.681 µs</td><td>86.806 µs</td></tr><tr><td>230400</td><td>230400 bits/s</td><td>4.340 µs</td><td>43.403 µs</td></tr><tr><td>921600</td><td>921600 bits/s</td><td>1.085 µs</td><td>10.851 µs</td></tr></tbody></table></div>
<p>So we actually want to look at the <em>overhead</em>, ideally as we increase baudrate to reduce the total transfer duration. This plot shows a range of tests where I&#39;ve subtracted the theoretical duration for the 12 byte payload from the results.</p>
<img src="https://electricui.com/7c32d9685a7e7ad9683d12462df7580b/uart-handling-overhead.svg" alt="Boxplots comparing STM32 poll/IRQ/DMA for 5 baudrates, 115200 to 184320"/>
<p>When we ignore the DMA implementation&#39;s line-idle behaviour, the implementations have pretty similar overheads even as we increase the throughput by 16x. So it&#39;s probably reasonable to suggest that round-tripping (transmit and receive) data through my FIFO handling implementation results in an overhead under ~4.5 µs.</p>
<p>You didn&#39;t sign up for a lecture on embedded systems fundamentals, so I&#39;ll get into the actual tests now, but I don&#39;t want to contribute to the sea of subpar &#39;benchmark&#39; blog posts without pointing out the importance of double-checking underlying implementation details.</p>
<p>Firmware, logic traces, R scripts, and raw/processed logs are <a href="https://github.com/Scottapotamas/embedded-wireless-latency-eval" target="_blank" rel="noopener noreferrer">in the git repo</a>.</p>
<h2 id="radio-tests" is="h2">Radio Tests</h2>
<p>Integrating wireless communications into any embedded project is ultimately an exercise in balancing compromises. The radio is often the most power hungry hardware for battery powered devices, and integration complexity and ecosystem interoperability generally drive the cost.</p>
<p>For 90% of use cases we start by considering the most forcing requirements:</p>
<ul>
<li>
<p>Network topology</p>
<ul>
<li>
<p>Pair of radios in a point-to-point configuration.</p>
</li>
<li>
<p>Two or more radios in a star or mesh network.</p>
</li>
<li>
<p>Single radio with end-user hardware, i.e. WiFi infrastructure, phones, etc.</p>
</li>
</ul>
</li>
<li>
<p>Range (link budget) and throughput requirements</p>
<ul>
<li>&#39;Sub-gig&#39; bands such as 433/868/915 MHz provide longer range but lower throughput.</li>
<li>2.4 GHz is shorter range, with far higher throughput.</li>
<li>Differences in front-end filtering, transmit power, and receiver sensitivity.</li>
<li>RF modulation schemes offer improved interference rejection to improve effective range.</li>
</ul>
</li>
</ul>
<p>Selecting a small enough set of modules to cover all of these edges was hard. While I&#39;ve tried to use the <code>F429 Nucleo-144</code> with external radio modules, the most popular platforms for Bluetooth and WiFi are integrated microcontroller+radio parts. I&#39;ve used the <code>ESP32</code>, <code>ESP32-C6</code>, and <code>nRF52840</code> to help round out the test hardware.</p>
<h3 id="sik" is="h3">SiK</h3>
<p>Open-source modules based on the (now aging) <a href="https://www.silabs.com/documents/public/data-sheets/Si102x-3x.pdf" target="_blank" rel="noopener noreferrer">SiliconLabs <code>10x0-GM</code> RF+8051 micro</a> running <a href="https://github.com/ArduPilot/SiK" target="_blank" rel="noopener noreferrer">SiK firmware</a> have been commonly used for the last decade as telemetry radios for long range UAV telemetry. In normal configurations they operate as a transparent serial link, though many have <a href="https://mavlink.io/en/" target="_blank" rel="noopener noreferrer">MAVLink</a> aware firmware and support communications with multiple nodes.</p>
<span><span>
      <a href="https://electricui.com/static/f01cdc1dc51973119998c5d561e4df06/da6ee/sik.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/f01cdc1dc51973119998c5d561e4df06/7bb4c/sik.avif 225w,
/static/f01cdc1dc51973119998c5d561e4df06/212f8/sik.avif 450w,
/static/f01cdc1dc51973119998c5d561e4df06/4d7a3/sik.avif 900w,
/static/f01cdc1dc51973119998c5d561e4df06/6f77c/sik.avif 1350w,
/static/f01cdc1dc51973119998c5d561e4df06/cbb88/sik.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/f01cdc1dc51973119998c5d561e4df06/7d522/sik.webp 225w,
/static/f01cdc1dc51973119998c5d561e4df06/b5115/sik.webp 450w,
/static/f01cdc1dc51973119998c5d561e4df06/5722e/sik.webp 900w,
/static/f01cdc1dc51973119998c5d561e4df06/c5b95/sik.webp 1350w,
/static/f01cdc1dc51973119998c5d561e4df06/aa619/sik.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/f01cdc1dc51973119998c5d561e4df06/08b3c/sik.jpg 225w,
/static/f01cdc1dc51973119998c5d561e4df06/12ba2/sik.jpg 450w,
/static/f01cdc1dc51973119998c5d561e4df06/86440/sik.jpg 900w,
/static/f01cdc1dc51973119998c5d561e4df06/7e63a/sik.jpg 1350w,
/static/f01cdc1dc51973119998c5d561e4df06/da6ee/sik.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/f01cdc1dc51973119998c5d561e4df06/86440/sik.jpg" alt="Small green PCB radio with antenna, larger black RFD900 radio module with larger antennas" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>The smaller modules have been implemented and cloned dozens of times and use a minimal implementation normally rated for 100 mW output. The beefier <a href="https://rfdesign.com.au/products/rfd900-modem/" target="_blank" rel="noopener noreferrer">RFD900</a> modules offer diversity antenna switching, better filters, and extra amplification (TX up to 1W).</p>
<p>These modules are tested with their default configuration - wired serial at 57600 baud, air data-rate at 64 kbit/s, and output power of 20 dBm (100 mW).</p>
<img src="https://electricui.com/78d7986b88508692ccad1e2cbd2f4be9/sik-latency.svg" alt="SiK results, median 12B=64ms, 128B=105ms, 1kB=280ms"/>
<p>Hold on... on paper the process to send a 12 byte packet should <em>naively</em> take about 6 milliseconds (UART takes <code>12B at 57600 = 2 ms</code> per side, <code>12B at 64kbit/sec = ~1.5 ms</code> airtime) but we see a huge spread of latencies from a pretty reasonable 8 ms up to 130 ms.</p>
<p>Why isn&#39;t the magic transparent serial pipe just sending data when I do?</p>
<img src="https://electricui.com/f88ee6c02e807f258ea0ec72552dd904/sik-transmit-diagram.svg" alt="Waveform of ideal trigger, 12B uart transfer, RF magic, uart, completion pulse"/>
<p>With some adaptors to connect an antenna to the spectrum analyser, we can peek into the transmission behaviour of the radio link to work out what&#39;s happening.</p>
<p>SiK radios use FHSS (<strong>F</strong>requency <strong>H</strong>opping <strong>S</strong>pread <strong>S</strong>pectrum) which rapidly changes the channel in a pseudorandom sequence. This spreads the signal over a wider bandwidth to help reduce interference and meet regulatory requirements.</p>
<span>
      
    </span>
<p>By letting the analyser accumulate data for a little while, we can count out the 50 hopping channels across their configured 915-928 MHz frequency range. Nothing unexpected yet...</p>
<span><span>
      <a href="https://electricui.com/static/ec1494f60727623d1105a6d03f94d685/f1720/sik-hopping-accumulated.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/ec1494f60727623d1105a6d03f94d685/7bb4c/sik-hopping-accumulated.avif 225w,
/static/ec1494f60727623d1105a6d03f94d685/212f8/sik-hopping-accumulated.avif 450w,
/static/ec1494f60727623d1105a6d03f94d685/4d7a3/sik-hopping-accumulated.avif 900w,
/static/ec1494f60727623d1105a6d03f94d685/c509e/sik-hopping-accumulated.avif 1024w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/ec1494f60727623d1105a6d03f94d685/7d522/sik-hopping-accumulated.webp 225w,
/static/ec1494f60727623d1105a6d03f94d685/b5115/sik-hopping-accumulated.webp 450w,
/static/ec1494f60727623d1105a6d03f94d685/5722e/sik-hopping-accumulated.webp 900w,
/static/ec1494f60727623d1105a6d03f94d685/44907/sik-hopping-accumulated.webp 1024w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/ec1494f60727623d1105a6d03f94d685/1663a/sik-hopping-accumulated.png 225w,
/static/ec1494f60727623d1105a6d03f94d685/7f757/sik-hopping-accumulated.png 450w,
/static/ec1494f60727623d1105a6d03f94d685/7abe2/sik-hopping-accumulated.png 900w,
/static/ec1494f60727623d1105a6d03f94d685/f1720/sik-hopping-accumulated.png 1024w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/ec1494f60727623d1105a6d03f94d685/7abe2/sik-hopping-accumulated.png" alt="RF spectrum large raised area with many peaks looking like a comb" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>When looking at PvT (<strong>P</strong>ower <strong>v</strong>ersus <strong>T</strong>ime) plots, we can see distinct periodic transmit bursts from each of the radios with a lot of off-time. The &#39;receiving&#39; radio module is an additional meter away from the spectrum analyser and has a slightly weaker signal in these screenshots.</p>
<span>
      
    </span>
<p>By triggering on a power level threshold (shown as a blue horizontal line), we can get a more stable look at the radio while running the 12 byte test pattern.</p>
<span>
      
    </span>
<p>What we&#39;re seeing is <strong>T</strong>ime <strong>D</strong>omain <strong>M</strong>ultiplexing (TDM) <a href="https://github.com/ArduPilot/SiK/blob/master/Firmware/radio/tdm.c" target="_blank" rel="noopener noreferrer">behaviour interacting with transmit behaviour</a>, which can be grossly simplified into some simple steps:</p>
<ul>
<li>Synced modules <em>hop</em> to a new channel frequency at an agreed time,</li>
<li>Each module is allocated a transmit window long enough for 3 packets,<!-- -->
<ul>
<li>If nothing is in the buffer, send a zero length packet to yield to other radios (~2 ms).</li>
<li>Up to ~232 bytes of buffered data is packetised with a preamble and header (~133 µs/byte). The 12B test payload should use ~3.7 ms of air time.</li>
<li>If other radios aren&#39;t using their transmit time slots, continue sending packets if needed.</li>
</ul>
</li>
<li>When nothing else needs sending, listen in receive mode until the next hop!</li>
</ul>
<p>Running the spectrum analyser&#39;s trigger output through a frequency counter tells us the modems hop frequency every 120 ms.</p>
<p>So the underlying radio behaviour is actually pretty close to our theoretical transmit duration, but the test conditions don&#39;t take into account that pending data is buffered by the module until the start of the next channel hop, leading to the wide variation in latency results we saw earlier.</p>
<p>This is also why the results are so evenly distributed - we&#39;re actually measuring the time we spend waiting for the next transmit window, and as long as the UART transfer arrives before the next window we don&#39;t gain any immediate benefit from a higher UART baudrate.</p>
<p>For a quick bit of fun, I tried using the RF power level (yellow trace) as a trigger input to the signal generator to synchronise the test IO stimulus signal (blue trace) with a configurable offset. With a 113 ms delay applied at the sig-gen, the microcontroller can reliably send it&#39;s packet <em>just before</em> an upcoming transmission window.</p>
<span>
      
    </span>
<p>And we can now achieve a stable 9-15 ms latency result!</p>
<img src="https://electricui.com/b389a8432dcceedb8172e28db7eaf58d/sik-latency-rf-trigger-113ms.svg" alt="sik-latency-rf-trigger-113ms"/>
<p>But that&#39;s not how these modules are configured or intended to be used, and the lab gear needed to achieve this timing hack is out of reach for most!</p>
<p>While the low latency result isn&#39;t indicative of real-world performance for these radios, I do think the process of exploring <em>why</em> is instructive and an indicator of what&#39;s possible for &#39;simple&#39; point-to-point packet radios with a different design goal.</p>
<h3 id="lora" is="h3">LoRa</h3>
<p>In situations where periodic reporting of small messages from edge devices is needed, low power wide area networks (LPWAN) are an increasingly common choice for asset monitoring, smart power meters, and agri-sensing. The aim of these kinds of networks is to support large fleets of low-power nodes using one-hop star networks with an internet connected gateway.</p>
<p>LoRa (<strong>Lo</strong>ng <strong>Ra</strong>nge) is the brand name for the modulation scheme (physical layer), which uses CSS (<strong>C</strong>hirp <strong>S</strong>pread <strong>S</strong>pectrum) to achieve long distance communication with very low power consumption.</p>
<blockquote>
<p>It&#39;s worth pointing out that LoRa has rather low data rates compared to the other radios I&#39;m testing, maxing out at 37.5 kbps.</p>
</blockquote>
<p>In the spectrum analyser waterfall below we can see part of a typical LoRa transmission. By reading from the bottom of the trace upwards, we see 8 preamble sweeps, followed by 2 reverse-direction sync message sweeps, then payload chirps continuing past the top of the waterfall. We can see the start and stop frequencies change for payload chirps, which is how LoRa transmits symbols.</p>
<span><span>
      <a href="https://electricui.com/static/4d586e718d5c0fa9a7760946b5f982e6/b14b3/lora-chirp-sa2.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/4d586e718d5c0fa9a7760946b5f982e6/7bb4c/lora-chirp-sa2.avif 225w,
/static/4d586e718d5c0fa9a7760946b5f982e6/212f8/lora-chirp-sa2.avif 450w,
/static/4d586e718d5c0fa9a7760946b5f982e6/5deb7/lora-chirp-sa2.avif 848w" sizes="(max-width: 848px) 100vw, 848px" type="image/avif"/><source srcset="/static/4d586e718d5c0fa9a7760946b5f982e6/7d522/lora-chirp-sa2.webp 225w,
/static/4d586e718d5c0fa9a7760946b5f982e6/b5115/lora-chirp-sa2.webp 450w,
/static/4d586e718d5c0fa9a7760946b5f982e6/04056/lora-chirp-sa2.webp 848w" sizes="(max-width: 848px) 100vw, 848px" type="image/webp"/>
          <source srcset="/static/4d586e718d5c0fa9a7760946b5f982e6/1663a/lora-chirp-sa2.png 225w,
/static/4d586e718d5c0fa9a7760946b5f982e6/7f757/lora-chirp-sa2.png 450w,
/static/4d586e718d5c0fa9a7760946b5f982e6/b14b3/lora-chirp-sa2.png 848w" sizes="(max-width: 848px) 100vw, 848px" type="image/png"/>
          <img src="https://electricui.com/static/4d586e718d5c0fa9a7760946b5f982e6/b14b3/lora-chirp-sa2.png" alt="RF plot showing repeated zig-zag green lines on blue background" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>LoRaWAN is the most popular of the higher level protocols (MAC) built on LoRa and <a href="https://www.thethingsnetwork.org/docs/lorawan/classes/" target="_blank" rel="noopener noreferrer">has three classes</a> describing when nodes can transmit, receive, or sleep. It also handles authentication, encryption, and message forwarding to upstream network services.</p>
<blockquote>
<p>LoRaWAN uses a clever trick to improve capacity and reduce interference - by using different <a href="https://en.wikipedia.org/wiki/In-phase_and_quadrature_components" target="_blank" rel="noopener noreferrer">IQ (phase and quadrature)</a> configurations for TX and RX modes, nodes can only hear transmissions from gateway radios and not other node transmissions.</p>
</blockquote>
<p>The hardware under test is the Semtech SX1276 transceiver in the HopeRF RFM95W module (on an Adafruit Breakout board). The modules communicate with the STM32F429 using 10 MHz clocked SPI, and my LL based driver minimises timing overheads by using the transceiver&#39;s interrupt lines.</p>
<span><span>
      <a href="https://electricui.com/static/6569371ad432b25302aad273ad86cb33/da6ee/lora.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/6569371ad432b25302aad273ad86cb33/7bb4c/lora.avif 225w,
/static/6569371ad432b25302aad273ad86cb33/212f8/lora.avif 450w,
/static/6569371ad432b25302aad273ad86cb33/4d7a3/lora.avif 900w,
/static/6569371ad432b25302aad273ad86cb33/6f77c/lora.avif 1350w,
/static/6569371ad432b25302aad273ad86cb33/cbb88/lora.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/6569371ad432b25302aad273ad86cb33/7d522/lora.webp 225w,
/static/6569371ad432b25302aad273ad86cb33/b5115/lora.webp 450w,
/static/6569371ad432b25302aad273ad86cb33/5722e/lora.webp 900w,
/static/6569371ad432b25302aad273ad86cb33/c5b95/lora.webp 1350w,
/static/6569371ad432b25302aad273ad86cb33/aa619/lora.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/6569371ad432b25302aad273ad86cb33/08b3c/lora.jpg 225w,
/static/6569371ad432b25302aad273ad86cb33/12ba2/lora.jpg 450w,
/static/6569371ad432b25302aad273ad86cb33/86440/lora.jpg 900w,
/static/6569371ad432b25302aad273ad86cb33/7e63a/lora.jpg 1350w,
/static/6569371ad432b25302aad273ad86cb33/da6ee/lora.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/6569371ad432b25302aad273ad86cb33/86440/lora.jpg" alt="Hands holding blue PCB with metal shielding, antenna on short cable" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>I&#39;ll test a point-to-point LoRa link, as I don&#39;t have an existing network or gateway on hand. If these tests were being performed with a real-world LoRaWAN I&#39;d really be measuring any timing restrictions applied by the network - best practice is to normally sleep for minutes between packets to minimise air-time and power consumption.</p>
<p>I ran tests with two different chirp configurations representing sensible &#39;high speed&#39; and long range use-cases. LoRa&#39;s maximum payload is 255 bytes, so the 1 kiB payload is broken into 5 transmissions.</p>
<div><table><thead><tr><th></th><th>Bandwidth</th><th>Coding Rate</th><th>Spreading Factor</th><th>Data rate</th></tr></thead><tbody><tr><td>High Speed</td><td>250 kHz</td><td>4/5 (1.25x overhead)</td><td>7 = 128 chips/symbol</td><td>10.9 kbps</td></tr><tr><td>Long Range</td><td>64.5 kHz</td><td>4/6 (1.5x overhead)</td><td>11 = 2048 chips/symbol</td><td>224 bps</td></tr></tbody></table></div>
<p><a href="https://www.semtech.com/design-support/lora-calculator" target="_blank" rel="noopener noreferrer">Semtech&#39;s LoRa web calculator</a> provides air-time durations which we can compare our results against. For the high speed configuration we can expect a 128 byte transmission to take ~107 ms.</p>
<img src="https://electricui.com/f19ce0a2afe74f2d15c635879d947040/lora-results-hs.svg" alt="Lora high speed boxplots, 12B=22ms, 128B=109ms, 1kB=817ms"/>
<p>Experimental results line up with the theoretical air-time timing, and the whole system has less than 10 µs of jitter (ignoring a dozen 128B outliers arriving 250 ms late) which is surprisingly well controlled.</p>
<p>As someone who predominantly works with micro-controllers, I&#39;m most familiar thinking in milliseconds and microseconds, so seeing a calculated air-time of 5.4 <em>seconds</em> to transmit 128 bytes using the long range configuration hinted at a pretty scary 1 KiB transmit duration.</p>
<img src="https://electricui.com/3feedac939d9518eed7575bab9de8d81/lora-results-lr.svg" alt="Lora longrange boxplots, 12B=1180ms, 128B=5541, 1kb=40860"/>
<p>These are the longest transfer times of the hardware I tested, and I needed to increase the stimulus pulse interval up to 50 seconds for the 1 kiB tests - this meant I stopped capturing after ~100 samples (over an hour).</p>
<p>Benchmark results align with theoretical timings pretty well and are a good demonstration of the importance of minimising data transfer through careful payload design. These modules should better show their strengths in range and power measurement tests.</p>
<blockquote>
<p>I&#39;d love to know how many days deployed nodes have spent accumulating chunks of firmware updates...</p>
</blockquote>
<h3 id="nrf24" is="h3">nRF24</h3>
<p>Nordic&#39;s nRF24 family of 2.4GHz transciever modules has been a commonly chosen option for custom wireless links for more than 15 years (early datasheets appear ~2006).</p>
<p>Over the years Nordic have co-packaged the transceiver with microcontrollers and USB interface hardware for tighter integration, and while they&#39;re not recommended for new designs I still see these part numbers appearing in regularly in research papers and hobby projects. The most widely known commercial use was in older Logitech wireless receivers.</p>
<span><span>
      <a href="https://electricui.com/static/ad0eebd57e6d731c94948754ada96a7a/da6ee/nrf24.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/ad0eebd57e6d731c94948754ada96a7a/7bb4c/nrf24.avif 225w,
/static/ad0eebd57e6d731c94948754ada96a7a/212f8/nrf24.avif 450w,
/static/ad0eebd57e6d731c94948754ada96a7a/4d7a3/nrf24.avif 900w,
/static/ad0eebd57e6d731c94948754ada96a7a/6f77c/nrf24.avif 1350w,
/static/ad0eebd57e6d731c94948754ada96a7a/cbb88/nrf24.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/ad0eebd57e6d731c94948754ada96a7a/7d522/nrf24.webp 225w,
/static/ad0eebd57e6d731c94948754ada96a7a/b5115/nrf24.webp 450w,
/static/ad0eebd57e6d731c94948754ada96a7a/5722e/nrf24.webp 900w,
/static/ad0eebd57e6d731c94948754ada96a7a/c5b95/nrf24.webp 1350w,
/static/ad0eebd57e6d731c94948754ada96a7a/aa619/nrf24.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/ad0eebd57e6d731c94948754ada96a7a/08b3c/nrf24.jpg 225w,
/static/ad0eebd57e6d731c94948754ada96a7a/12ba2/nrf24.jpg 450w,
/static/ad0eebd57e6d731c94948754ada96a7a/86440/nrf24.jpg 900w,
/static/ad0eebd57e6d731c94948754ada96a7a/7e63a/nrf24.jpg 1350w,
/static/ad0eebd57e6d731c94948754ada96a7a/da6ee/nrf24.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/ad0eebd57e6d731c94948754ada96a7a/86440/nrf24.jpg" alt="Two black RF PCBs with antennas" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>While it&#39;s hard to check if my &#39;genuine&#39; modules are using cloned silicon or not, you can find barebones nRF24L01 modules using PCB antennas as cheap as $2 in single quantities on eBay (almost certainly clones) and fancier modules with low-noise amplifiers (LNA) and transmit amplifiers (PA) come with an external antenna for less than $10.</p>
<p>My interrupt driven implementation clocks the SPI link at 10 MHz (rated max) and configures the modules for maximum throughput with a 2 Mbps air rate. By enabling Nordic&#39;s <em>Enhanced Shockburst</em> the modules transparently handle automatic 16-bit checksums, acks, and re-transmit behaviour.</p>
<p>For the 128 and 1024 byte tests, the payload data is sent in chunks due to the nRF24&#39;s 32 byte payload limit. The next chunk is sent once the module&#39;s transmit success interrupt arrives. Enabling the dynamic payload length functionality impacted reliability, so any chunks requiring less than 32B are padded with <code>0x00</code> bytes (a 12B only packet test is shown below as <code>Raw 12B</code>).</p>
<img src="https://electricui.com/40430efb1c61f3031cd844b79e251fc5/nrf24-results-2mbps.svg" alt="NRF24 boxplot, 12B=0.3ms, 32B=0.4ms, 128B=1.9ms, 1kb=23ms"/>
<p>Achieving a lower-bound latency of 300 microseconds for a 12 byte transfer is a great result and the tight clustering shows highly consistent behaviour.</p>
<p>The nRF24&#39;s low jitter is easily visualised with some RF PvT traces (shown in yellow). We can see the module starts it&#39;s first RF burst about 100 µs after the test stimulus trigger (horizontally offset by -2 ms) and the complete the sequence of bursts within 5 ms. The slightly lower amplitude bursts are the RX module acknowledging the transmissions.</p>
<span>
      
    </span>
<p>By looking at the PvT behaviour with longer payload sizes, it seems like some of the variation is caused by occasional quiet periods between chunks. I haven&#39;t been able to work out why these happen.</p>
<p>I found it interesting that reducing the air-data rate to 256 kbps for &#39;long range&#39; performance didn&#39;t impact latency as much as we&#39;d expect from the ~8x reduction in rated throughput.</p>
<img src="https://electricui.com/985636a22bc219725209fa6fdd791af0/nrf24-results-256kbps.svg" alt="NRF24 boxplot, 32B=1.5ms, 128B=7ms, 1kB=68ms"/>
<p>Long-range mode maintains highly consistent results but incurs a slightly less than 4x increase in transfer duration, less than half of what we would have expected from the air-data rate reduction.</p>
<div><table><thead><tr><th></th><th>256 kbps</th><th>2 Mbps</th><th>Difference</th></tr></thead><tbody><tr><td>12B (padded)</td><td>1.5 ms</td><td>0.4 ms</td><td>3.75x</td></tr><tr><td>128B</td><td>7 ms</td><td>1.9 ms</td><td>3.6x</td></tr><tr><td>1024B</td><td>68 ms</td><td>23 ms</td><td>3x</td></tr></tbody></table></div>
<p>If I saturated the long-range link with more frequent test packets I suspect the difference would become more apparent.</p>
<h3 id="espnow" is="h3">ESPNOW</h3>
<p>The ESP32 and ESP8266 are probably the most popular hobby microcontrollers we&#39;ve seen over the past 5 years, mostly due to incredibly low cost, integrated WiFi/BT, and pretty good development tooling from release. While the community has quickly grown fond of them, they&#39;re also found in a lot of commercial IOT products.</p>
<span><span>
      <a href="https://electricui.com/static/e467b8bdad385d26e86233371d98e552/da6ee/esp32.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/e467b8bdad385d26e86233371d98e552/7bb4c/esp32.avif 225w,
/static/e467b8bdad385d26e86233371d98e552/212f8/esp32.avif 450w,
/static/e467b8bdad385d26e86233371d98e552/4d7a3/esp32.avif 900w,
/static/e467b8bdad385d26e86233371d98e552/6f77c/esp32.avif 1350w,
/static/e467b8bdad385d26e86233371d98e552/cbb88/esp32.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/e467b8bdad385d26e86233371d98e552/7d522/esp32.webp 225w,
/static/e467b8bdad385d26e86233371d98e552/b5115/esp32.webp 450w,
/static/e467b8bdad385d26e86233371d98e552/5722e/esp32.webp 900w,
/static/e467b8bdad385d26e86233371d98e552/c5b95/esp32.webp 1350w,
/static/e467b8bdad385d26e86233371d98e552/aa619/esp32.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/e467b8bdad385d26e86233371d98e552/08b3c/esp32.jpg 225w,
/static/e467b8bdad385d26e86233371d98e552/12ba2/esp32.jpg 450w,
/static/e467b8bdad385d26e86233371d98e552/86440/esp32.jpg 900w,
/static/e467b8bdad385d26e86233371d98e552/7e63a/esp32.jpg 1350w,
/static/e467b8bdad385d26e86233371d98e552/da6ee/esp32.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/e467b8bdad385d26e86233371d98e552/86440/esp32.jpg" alt="7 different black and red RF PCBs, some with RF metal shielding, on-board antenna" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p><a href="https://www.espressif.com/en/solutions/low-power-solutions/esp-now" target="_blank" rel="noopener noreferrer">ESPNow</a> is Espressif&#39;s proprietary point-to-point networking protocol running in the 2.4GHz band and is self-described as a low complexity option for smart lighting, sensors, and remote-control applications without a bridge or gateway. It uses a <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_now.html#frame-format" target="_blank" rel="noopener noreferrer">custom action-frame</a> in the 802.11 Wi-Fi standard for specific device functionality which provides 250 bytes of usable payload space and typically runs at 1 Mbps.</p>
<p>The website does have a latency claim that it &#34;<em>can achieve a millisecond-level delay</em>&#34; which we can attempt to replicate.</p>
<span><span>
      <a href="https://electricui.com/static/548a6afa266d1e1d1abf1e776971febc/bd009/esp32-website-latency.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/548a6afa266d1e1d1abf1e776971febc/7bb4c/esp32-website-latency.avif 225w,
/static/548a6afa266d1e1d1abf1e776971febc/212f8/esp32-website-latency.avif 450w,
/static/548a6afa266d1e1d1abf1e776971febc/4d7a3/esp32-website-latency.avif 900w,
/static/548a6afa266d1e1d1abf1e776971febc/6f77c/esp32-website-latency.avif 1350w,
/static/548a6afa266d1e1d1abf1e776971febc/a848b/esp32-website-latency.avif 1800w,
/static/548a6afa266d1e1d1abf1e776971febc/8379a/esp32-website-latency.avif 1860w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/548a6afa266d1e1d1abf1e776971febc/7d522/esp32-website-latency.webp 225w,
/static/548a6afa266d1e1d1abf1e776971febc/b5115/esp32-website-latency.webp 450w,
/static/548a6afa266d1e1d1abf1e776971febc/5722e/esp32-website-latency.webp 900w,
/static/548a6afa266d1e1d1abf1e776971febc/c5b95/esp32-website-latency.webp 1350w,
/static/548a6afa266d1e1d1abf1e776971febc/8fb31/esp32-website-latency.webp 1800w,
/static/548a6afa266d1e1d1abf1e776971febc/50416/esp32-website-latency.webp 1860w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/548a6afa266d1e1d1abf1e776971febc/1663a/esp32-website-latency.png 225w,
/static/548a6afa266d1e1d1abf1e776971febc/7f757/esp32-website-latency.png 450w,
/static/548a6afa266d1e1d1abf1e776971febc/7abe2/esp32-website-latency.png 900w,
/static/548a6afa266d1e1d1abf1e776971febc/5d6e7/esp32-website-latency.png 1350w,
/static/548a6afa266d1e1d1abf1e776971febc/7385a/esp32-website-latency.png 1800w,
/static/548a6afa266d1e1d1abf1e776971febc/bd009/esp32-website-latency.png 1860w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/548a6afa266d1e1d1abf1e776971febc/7abe2/esp32-website-latency.png" alt="Illustration of toy-car RC controller and marketing text" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>Using <a href="https://github.com/espressif/esp-idf/blob/master/examples/wifi/espnow/main/espnow_example_main.c" target="_blank" rel="noopener noreferrer">Espressif&#39;s IDF example</a> as reference, my stripped down implementation doesn&#39;t send complex structured payloads.</p>
<ul>
<li>At startup, the ESP32 boards find each other with some broadcast packets.<!-- -->
<ul>
<li>If the broadcast came from a MAC address that hasn&#39;t been seen yet, add it to the peer list.</li>
</ul>
</li>
<li>If a trigger pulse interrupt occurs, search the peer list for our destination MAC address.<!-- -->
<ul>
<li>Blindly send the test payload to that address as the only <em>user payload</em> information,</li>
<li>Because the 1024B test exceeds the 250 byte limit, 5 packets need to be sent. I wait for transmit completion callbacks to succeed before sending the next chunk.</li>
</ul>
</li>
<li>The espnow task callbacks provide inbound packets which are passed to the main task loop with a FreeRTOS queue,<!-- -->
<ul>
<li>Test packets are checked for valid length and checksum values using the same logic as earlier tests.</li>
</ul>
</li>
</ul>
<p>The results are pretty good - typical end-to-end latency for a single packet transfer is consistently ~5 ms. The 1 kiB payload shows good scaling behaviour as the 5 packet sequence takes ~24 ms to complete.</p>
<img src="https://electricui.com/6755ef06a0d5e40dbeae2221d1ff70e0/espnow-results.svg" alt="ESPNOW Boxplot, 12B=5.6ms, 128B=5.8ms, 1kB=24ms"/>
<p>Interestingly, enabling long-range mode (which limits the PHY to 512Kbps or 256Kbps) hurts the 5-packet sequence <em>slightly</em> more than I&#39;d expect.</p>
<h3 id="802154" is="h3">802.15.4</h3>
<p>IEEE 802.15.4 is a standardised physical and MAC layer protocol used most commonly for wireless home automation networks. Zigbee, Matter, and Thread are all high layer protocols built on IEEE 802.15.4.</p>
<p>Designed for embedded devices and low power consumption, it offers a reasonable range of data rates up to 250 kbit/second, three operating bands across 868/915/2450 MHz, and can operate point-to-point or with star network topologies.</p>
<p>I&#39;m using a pair of Espressif&#39;s official ESP32-C6-MINI devboards for this test, which are 2.4 GHz only.</p>
<p>I opted to use the ESP-IDF&#39;s low-level <a href="https://github.com/espressif/esp-idf/tree/master/examples/ieee802154" target="_blank" rel="noopener noreferrer"><code>ieee802154</code> library</a> directly because it&#39;s small and very easy to work with (though building 802.15.4 MAC frames manually is tedious). There are also Zigbee and OpenThread example projects for these chips.</p>
<p><a href="https://github.com/homewsn/whsniff" target="_blank" rel="noopener noreferrer"><code>whsniff</code> + Wireshark</a>  gives us a good view of the 9 chunks it takes to send a 1 KiB packet due to the 127B MTU.</p>
<span><span>
      <a href="https://electricui.com/static/4240535a1c2ee31d16b257ae2f49d265/a981d/802154-wireshark.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/4240535a1c2ee31d16b257ae2f49d265/7bb4c/802154-wireshark.avif 225w,
/static/4240535a1c2ee31d16b257ae2f49d265/212f8/802154-wireshark.avif 450w,
/static/4240535a1c2ee31d16b257ae2f49d265/4d7a3/802154-wireshark.avif 900w,
/static/4240535a1c2ee31d16b257ae2f49d265/6f77c/802154-wireshark.avif 1350w,
/static/4240535a1c2ee31d16b257ae2f49d265/a848b/802154-wireshark.avif 1800w,
/static/4240535a1c2ee31d16b257ae2f49d265/6a66b/802154-wireshark.avif 1929w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/4240535a1c2ee31d16b257ae2f49d265/7d522/802154-wireshark.webp 225w,
/static/4240535a1c2ee31d16b257ae2f49d265/b5115/802154-wireshark.webp 450w,
/static/4240535a1c2ee31d16b257ae2f49d265/5722e/802154-wireshark.webp 900w,
/static/4240535a1c2ee31d16b257ae2f49d265/c5b95/802154-wireshark.webp 1350w,
/static/4240535a1c2ee31d16b257ae2f49d265/8fb31/802154-wireshark.webp 1800w,
/static/4240535a1c2ee31d16b257ae2f49d265/e2d1e/802154-wireshark.webp 1929w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/4240535a1c2ee31d16b257ae2f49d265/1663a/802154-wireshark.png 225w,
/static/4240535a1c2ee31d16b257ae2f49d265/7f757/802154-wireshark.png 450w,
/static/4240535a1c2ee31d16b257ae2f49d265/7abe2/802154-wireshark.png 900w,
/static/4240535a1c2ee31d16b257ae2f49d265/5d6e7/802154-wireshark.png 1350w,
/static/4240535a1c2ee31d16b257ae2f49d265/7385a/802154-wireshark.png 1800w,
/static/4240535a1c2ee31d16b257ae2f49d265/a981d/802154-wireshark.png 1929w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/4240535a1c2ee31d16b257ae2f49d265/7abe2/802154-wireshark.png" alt="Wireshark GUI, columns of packet logs on top with lower payload detail section" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>I benchmarked both sending packets without acknowledgement aka &#34;Blind&#34;, and with the acknowledgement request bit enabled.</p>
<img src="https://electricui.com/66911e8916517f956ef6afca6bf66013/esp32c6-802154-results.svg" alt="ESP32C6 boxplot, 12B=2.5ms, 128B=8.7ms, 1kB=45ms"/>
<p>The tight clustering of results is great to see, and a ~2.5 ms lower bound for small packets is fairly impressive. Generally speaking these are similar results to the comparable nRF24&#39;s 256 Kbps configuration.</p>
<p>Despite trying for a little while, I wasn&#39;t able to work out <em>why</em> acknowledged 128B test outperformed blind transmission. The difference isn&#39;t too meaningful, but if anyone reading knows why I&#39;d love to hear from you.</p>
<p>Enabling the IDF Menuconfig&#39;s &#34;<em>Throughput Optimisation</em>&#34; setting didn&#39;t make any measurable impact for this test.</p>
<h3 id="bluetooth-spp" is="h3">Bluetooth SPP</h3>
<p>Often packaged alongside products as a &#39;wireless RS-232 dongle&#39; or &#39;Bluetooth serial adaptor&#39;, modules implementing Bluetooth SPP (<strong>S</strong>erial <strong>P</strong>ort <strong>P</strong>rofile) act as transparent serial bridges and are the starting point for the dive into Bluetooth based transports.</p>
<h4 id="hc-05" is="h4">HC-05</h4>
<p>The <code>HC-05</code>/<code>HC-06</code> modules are one model commonly found embedded in hobby electronics projects as a zero-effort way to send UART data to a phone, PC, or between microcontrollers. These use Bluetooth 2.0 + EDR (now called <em>Bluetooth Classic</em>) and can allegedly reach air-rates of 1 Mbps at close range.</p>
<span><span>
      <a href="https://electricui.com/static/e5d895cca42bb806e7bdc063833ced60/da6ee/hc-05.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/e5d895cca42bb806e7bdc063833ced60/7bb4c/hc-05.avif 225w,
/static/e5d895cca42bb806e7bdc063833ced60/212f8/hc-05.avif 450w,
/static/e5d895cca42bb806e7bdc063833ced60/4d7a3/hc-05.avif 900w,
/static/e5d895cca42bb806e7bdc063833ced60/6f77c/hc-05.avif 1350w,
/static/e5d895cca42bb806e7bdc063833ced60/cbb88/hc-05.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/e5d895cca42bb806e7bdc063833ced60/7d522/hc-05.webp 225w,
/static/e5d895cca42bb806e7bdc063833ced60/b5115/hc-05.webp 450w,
/static/e5d895cca42bb806e7bdc063833ced60/5722e/hc-05.webp 900w,
/static/e5d895cca42bb806e7bdc063833ced60/c5b95/hc-05.webp 1350w,
/static/e5d895cca42bb806e7bdc063833ced60/aa619/hc-05.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/e5d895cca42bb806e7bdc063833ced60/08b3c/hc-05.jpg 225w,
/static/e5d895cca42bb806e7bdc063833ced60/12ba2/hc-05.jpg 450w,
/static/e5d895cca42bb806e7bdc063833ced60/86440/hc-05.jpg 900w,
/static/e5d895cca42bb806e7bdc063833ced60/7e63a/hc-05.jpg 1350w,
/static/e5d895cca42bb806e7bdc063833ced60/da6ee/hc-05.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/e5d895cca42bb806e7bdc063833ced60/86440/hc-05.jpg" alt="Hand holding single small blue and green RF module" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>My modules arrived running <code>2.0-20100601</code> firmware and default to 9600 baud UART. I used AT commands to set one as &#39;master&#39; to auto-bind to the second module.</p>
<img src="https://electricui.com/c945835eb22b91f2fbe0843303b8e66b/hc05-results.svg" alt="HC05 Boxplot, 12B=33ms, 128B=166ms, 1kB=1140ms"/>
<p>The default configuration doesn&#39;t give great results, which is mostly caused by the low default UART speed.</p>
<p>At 9600 baud (8N1) it takes 1066 ms to transfer 1 kiB from the STM32 microcontroller to the HC-05 module. Increasing the baudrate immediately improves the situation.</p>
<img src="https://electricui.com/174c6c9f729bdd16eb709fe5b4ca758f/hc05-results-faster.svg" alt="HC05 faster baud boxplots, 57600b 1kB=206ms, 460800b 1kB=62ms"/>
<p>Looking at logic analyser traces (diagrams simplified for readability), we measure a 20 ±4 ms overhead duration between the UART transfers for the 12B test. This behaviour is consistent with any UART configuration.</p>
<img src="https://electricui.com/d5979741fc8cc278a4c7db36c15d5551/hc05-12b-diagram.svg" alt="Waveform showing 20ms delay between start of tx and rx UART output"/>
<p>For the larger 128 and 1024 byte payloads the modules behave consistently at 9600 and 57600 baud. The receiving side starts emitting the payload before the full payload has been written out but the output is still one consistent stream.</p>
<img src="https://electricui.com/d05c1b0702b240a15dfce8d3dbd64781/hc05-128b-diagram.svg" alt="Waveform showing longer transfers overlapping after 20ms start delay"/>
<p>460800 baud was the highest my modules would accept and still pass each of the payload tests. We still see the ~20 ms latency between sending the last byte and seeing it on the other side, but the stream now appears to arrive in variable length bursts. I&#39;ve seen these bursts range from a single byte to 254 bytes, on a ~5 ±2 ms slot interval.</p>
<img src="https://electricui.com/8360783527784ce4ca3474e36c9323f7/hc05-chunks-diagram.svg" alt="Waveform diagram showing variable rx output for long continuous tx"/>
<p>At these rates it&#39;s easy to overwhelm the modules by sending too much data - they handle this by dropping data randomly. This mostly justifies the slow default baudrate as it removes the need to consider rate limiting in userspace.</p>
<h4 id="esp32" is="h4">ESP32</h4>
<p>We can compare the HC-05 behaviour against a pair of ESP32 modules as the Bluedroid stack supports Classic BT. We should also be able to reduce latency a little bit because the ESP32 doesn&#39;t need to incur micro-to-radio transfer overheads!</p>
<p>Similar to the other ESP32 test firmwares, my implementation follows <a href="https://github.com/espressif/esp-idf/tree/master/examples/bluetooth/bluedroid/classic_bt/bt_spp_initiator" target="_blank" rel="noopener noreferrer">Espressif&#39;s example</a> but uses a FreeRTOS queue to pass write completion and inbound data events from SPP callbacks to a user task to handle the benchmark logic.</p>
<p>As the ESP32 in BT Classic mode has an MTU of 990 bytes, the 1 kiB payload requires splitting into two transfers.</p>
<img src="https://electricui.com/39e29db6bc7959202192943465c86335/esp32-spp-results.svg" alt="SPP boxplot, 12B=12.9ms, 128B=12.6, 1kB=18ms"/>
<p>ESP32 outperforms the HC-05 modules, achieving almost half the latency for smaller packets with the performance gap widening as payloads increase in size.</p>
<p>Espressif&#39;s docs reiterate some common sense - sending larger payloads less frequently is more efficient than high frequency smaller payloads. I experimented by forcing the 1 KiB payload into 32 and 64 byte chunks to compare against the 990 byte MTU result.</p>
<img src="https://electricui.com/91cc6e55d02e39913957b9207c5665a4/esp32-spp-chunks.svg" alt="Boxplot 1k chunked, 2=18ms, 16=64ms, 32=117ms"/>
<p>As expected, increased overheads mean smaller chunk sizes take longer, but we also see more variability in transfer timing.</p>
<p>Adding instrumentation and logging narrowed down the most likely cause as increased congestion events. Congestion flags bubble up from one of the lower levels of the Bluetooth stack (L2CAP) and signal that we shouldn&#39;t send more chunks until the flag is cleared.</p>
<h3 id="bluetooth-le" is="h3">Bluetooth LE</h3>
<p>Introduced alongside Bluetooth 4 in late 2009, BLE (<strong>B</strong>luetooth <strong>L</strong>ow <strong>E</strong>nergy) was designed ground-up for low power devices with the goal of improving compatibility with user devices like smartphones. Since then we&#39;ve seen an explosion in app-connected products across pretty much all consumer markets and even industrial hardware, with the majority of these devices using BLE.</p>
<p>BLE devices communicate using the GATT (<strong>G</strong>eneric <strong>ATT</strong>ribute Profile) server-client model: the server describes data (characteristics) and metadata (attributes), and client devices (a user&#39;s phone) read or write against these characteristics. You&#39;ll often see them called <em>Peripheral</em> and <em>Central</em> in Bluetooth documentation.</p>
<p>The BLE specification restricts the <em>minimum</em> connection interval to 7.5 ms, so I&#39;m expecting all of the implementations to achieve lower-bound results under 10 ms. The <a href="https://interrupt.memfault.com/blog/ble-throughput-primer" target="_blank" rel="noopener noreferrer">BLE Throughput Primer on Memfault&#39;s blog</a> covers many of the underlying behaviours being exercised in this section.</p>
<h4 id="esp32-bluedroid" is="h4">ESP32 Bluedroid</h4>
<p>The test firmware configures a pair of ESP32 boards using a typical approach for connecting a sensor node (peripheral/server) to an &#39;end user&#39; style device (central/client). GATT servers have the ability to &#39;push&#39; data to the client using either an <em>Indication</em> (requiring acknowledgement) or <em>Notification</em> (without acknowledgement).</p>
<p>I compared the latency of the server notification approach against the client&#39;s &#39;<em>Write Without Response</em>&#39; by supporting both directions of data transfer in the implementation and simply swapping the test setup to trigger the client board.</p>
<img src="https://electricui.com/6c9ede2d7eb9b09a7556022c1ca9bef5/esp32-ble-server-client-directionality.svg" alt="BLE 12B boxplot, notify=14.6ms, write=20ms"/>
<p>I hadn&#39;t properly tested this specific detail before and didn&#39;t expect to see much difference in latency, but we have a ~5ms difference with some outlier client writes extending past 40ms. I&#39;d be surprised if this detail would be a show-stopper for real-world projects though.</p>
<blockquote>
<p>The Notification test data show some distinct distribution bands of higher density.</p>
<p>These groups are roughly 7 ms apart, which has a strong correlation to the minimum 7.5 ms connection interval for BLE.</p>
</blockquote>
<p>Continuing with the different test payloads sent via Notification, both the 12B and 128B tests fit inside the ESP32&#39;s recommended 200 byte MTU, but the 1 kiB test needs 6 packets to send.</p>
<img src="https://electricui.com/c570d8a99c5fb89dc77db1d2313c8724/esp32-ble-results.svg" alt="BLE boxplot, 12B=14.6ms 128B=21ms, 1kB=31ms"/>
<p>These results are fairly good, but it&#39;s hard to see an improvement over the older Classic SPP results from the ESP32 without considering the differences in power consumption and vastly better end-user connection experience.</p>
<h4 id="esp32-nimble" is="h4">ESP32 NimBLE</h4>
<p>While the Bluedroid stack was used for the previous ESP32 BLE tests, the ESP-IDF also supports <a href="https://mynewt.apache.org/latest/network/" target="_blank" rel="noopener noreferrer">Apache&#39;s MyNewt NimBLE</a> stack which has been developed specifically for low-power and memory constrained hardware.</p>
<p>I couldn&#39;t find any information about any potential performance or latency benefits, so I re-implemented the BLE SPP firmware to see how NimBLE stacks up.</p>
<blockquote>
<p>It&#39;s worth pointing out that <a href="https://github.com/espressif/esp-idf/blob/master/examples/bluetooth/nimble/ble_spp/spp_client/README.md" target="_blank" rel="noopener noreferrer">Espressif&#39;s NimBLE examples</a> don&#39;t match their README. Also, be prepared to dig through scraps of MyNewt documentation to implement MTU exchange and subscriptions to achieve feature parity with the Bluedroid example.</p>
</blockquote>
<img src="https://electricui.com/78d9c49e76040244a53fd57175e38c92/esp32-nimble-server-client-directionality.svg" alt="BLE 12B boxplot, notify=45ms, write=28ms, outliers out to 150ms"/>
<p><em>Odd</em>, that&#39;s not what I expected at all. Before we jump to any conclusions, let&#39;s test the other payload sizes with the same setup as the previous SPP and GATT tests...</p>
<img src="https://electricui.com/a176e98d1a05063d534f67aba2ac7269/esp32-nimble-results.svg" alt="BLE boxplot 12B=45ms, 128B=32ms, 1kB=57ms wide range of outliers"/>
<p>There&#39;s clearly a few things wrong here, these NimBLE test results are meaningfully slower and far less consistent than the Bluedroid stack. I&#39;m also rather confused by the inversion in latency for client writes.</p>
<blockquote>
<p><a href="https://github.com/espressif/esp-idf/issues/12789" target="_blank" rel="noopener noreferrer">I asked Espressif</a> if everything was working properly, then went poking for a few days while waiting for a response.</p>
<p>At the time of publishing there&#39;s been no official response...</p>
</blockquote>
<p>Things improved somewhat with manually specifying faster <code>ble_gap_upd_params</code> for interval and connection timings (fixing the 40 ms gap spacings), but it wasn&#39;t until <a href="https://github.com/xyzzy42" target="_blank" rel="noopener noreferrer"><code>@xyzzy42</code></a> dropped a hint in the issue thread a few weeks later which led to some additional configuration.</p>
<p>Looking at some <a href="https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-Bluetooth-LE" target="_blank" rel="noopener noreferrer">sniffed BLE captures</a> in Wireshark we can see that our packets are being broken into six 26B fragments even though the peer confirmed our larger requested 200B MTU value during connection.</p>
<span><span>
      <a href="https://electricui.com/static/f4675a37e6fe2c665524d9ab4f210dcc/b7631/esp32-nimble-wireshark.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/f4675a37e6fe2c665524d9ab4f210dcc/7bb4c/esp32-nimble-wireshark.avif 225w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/212f8/esp32-nimble-wireshark.avif 450w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/4d7a3/esp32-nimble-wireshark.avif 900w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/6f77c/esp32-nimble-wireshark.avif 1350w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/81977/esp32-nimble-wireshark.avif 1480w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/f4675a37e6fe2c665524d9ab4f210dcc/7d522/esp32-nimble-wireshark.webp 225w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/b5115/esp32-nimble-wireshark.webp 450w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/5722e/esp32-nimble-wireshark.webp 900w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/c5b95/esp32-nimble-wireshark.webp 1350w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/fb172/esp32-nimble-wireshark.webp 1480w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/f4675a37e6fe2c665524d9ab4f210dcc/1663a/esp32-nimble-wireshark.png 225w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/7f757/esp32-nimble-wireshark.png 450w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/7abe2/esp32-nimble-wireshark.png 900w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/5d6e7/esp32-nimble-wireshark.png 1350w,
/static/f4675a37e6fe2c665524d9ab4f210dcc/b7631/esp32-nimble-wireshark.png 1480w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/f4675a37e6fe2c665524d9ab4f210dcc/7abe2/esp32-nimble-wireshark.png" alt="Wireshark GUI with rows of empty and 52byte L2CAP fragments, lower half highlights 6 fragment count" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>So the low-level controller&#39;s MTU doesn&#39;t seem to be affected and packets are being automatically fragmented and reassembled by L2CAP. Espressif uses an intermediate VHCI (<strong>H</strong>ost-<strong>C</strong>ontroller <strong>I</strong>nterface) layer between the NimBLE Host and the underlying Bluetooth controller, which is probably where this rough edge comes into play.</p>
<p>By calling the NimBLE&#39;s <code>ble_gap_set_data_len(handle, tx_octets, tx_time)</code>, we&#39;re making a (wrapped) call against the ESP32&#39;s Bluetooth HCI which does make the configuration change we wanted. We can sniff the connection and see it behaving correctly in Wireshark.</p>
<span><span>
      <a href="https://electricui.com/static/aef9329838cdf20331f8cf7b968113c8/cab22/esp32-nimble-wireshark-hci-fix.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/aef9329838cdf20331f8cf7b968113c8/7bb4c/esp32-nimble-wireshark-hci-fix.avif 225w,
/static/aef9329838cdf20331f8cf7b968113c8/212f8/esp32-nimble-wireshark-hci-fix.avif 450w,
/static/aef9329838cdf20331f8cf7b968113c8/4d7a3/esp32-nimble-wireshark-hci-fix.avif 900w,
/static/aef9329838cdf20331f8cf7b968113c8/6f77c/esp32-nimble-wireshark-hci-fix.avif 1350w,
/static/aef9329838cdf20331f8cf7b968113c8/2318d/esp32-nimble-wireshark-hci-fix.avif 1485w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/aef9329838cdf20331f8cf7b968113c8/7d522/esp32-nimble-wireshark-hci-fix.webp 225w,
/static/aef9329838cdf20331f8cf7b968113c8/b5115/esp32-nimble-wireshark-hci-fix.webp 450w,
/static/aef9329838cdf20331f8cf7b968113c8/5722e/esp32-nimble-wireshark-hci-fix.webp 900w,
/static/aef9329838cdf20331f8cf7b968113c8/c5b95/esp32-nimble-wireshark-hci-fix.webp 1350w,
/static/aef9329838cdf20331f8cf7b968113c8/4391b/esp32-nimble-wireshark-hci-fix.webp 1485w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/aef9329838cdf20331f8cf7b968113c8/1663a/esp32-nimble-wireshark-hci-fix.png 225w,
/static/aef9329838cdf20331f8cf7b968113c8/7f757/esp32-nimble-wireshark-hci-fix.png 450w,
/static/aef9329838cdf20331f8cf7b968113c8/7abe2/esp32-nimble-wireshark-hci-fix.png 900w,
/static/aef9329838cdf20331f8cf7b968113c8/5d6e7/esp32-nimble-wireshark-hci-fix.png 1350w,
/static/aef9329838cdf20331f8cf7b968113c8/cab22/esp32-nimble-wireshark-hci-fix.png 1485w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/aef9329838cdf20331f8cf7b968113c8/7abe2/esp32-nimble-wireshark-hci-fix.png" alt="Wireshark GUI with rows of empty and one 161B L2CAP packet" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>Running the benchmarks again, we see that these changes have contributed to a massive improvement to variance, and both the best and worst-case latency results are halved for the 1024B test.</p>
<img src="https://electricui.com/2fc96aef8be468e4af3e413eb0c5206c/esp32-nimble-fixes.svg" alt="BLE boxplots comparing previous poor results to fixed, 12B=22ms, 128B=24ms, 1kB=37ms"/>
<p>A generally better result and mostly matching Bluedroid&#39;s defaults. I haven&#39;t investigated power consumption or resource usage deeply (yet) but I&#39;d still want to pick Bluedroid with the ESP32 based purely on the quality of examples and documentation.</p>
<h4 id="nrf52" is="h4">nRF52</h4>
<p>Implementing the same BLE behaviour with a platform designed around Bluetooth is worthy of comparison. I bought a pair of Nordic&#39;s nRF52850-DK boards and implemented the benchmark tests using the &#34;Nordic UART Bridge Service (NUS)&#34; library which provides helper functions and vendor-standardisation for a GATT-based generic data transport.</p>
<span><span>
      <a href="https://electricui.com/static/0204374c06c1f7808ee24c19879f6da1/da6ee/nrf58240.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/0204374c06c1f7808ee24c19879f6da1/7bb4c/nrf58240.avif 225w,
/static/0204374c06c1f7808ee24c19879f6da1/212f8/nrf58240.avif 450w,
/static/0204374c06c1f7808ee24c19879f6da1/4d7a3/nrf58240.avif 900w,
/static/0204374c06c1f7808ee24c19879f6da1/6f77c/nrf58240.avif 1350w,
/static/0204374c06c1f7808ee24c19879f6da1/cbb88/nrf58240.avif 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/0204374c06c1f7808ee24c19879f6da1/7d522/nrf58240.webp 225w,
/static/0204374c06c1f7808ee24c19879f6da1/b5115/nrf58240.webp 450w,
/static/0204374c06c1f7808ee24c19879f6da1/5722e/nrf58240.webp 900w,
/static/0204374c06c1f7808ee24c19879f6da1/c5b95/nrf58240.webp 1350w,
/static/0204374c06c1f7808ee24c19879f6da1/aa619/nrf58240.webp 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/0204374c06c1f7808ee24c19879f6da1/08b3c/nrf58240.jpg 225w,
/static/0204374c06c1f7808ee24c19879f6da1/12ba2/nrf58240.jpg 450w,
/static/0204374c06c1f7808ee24c19879f6da1/86440/nrf58240.jpg 900w,
/static/0204374c06c1f7808ee24c19879f6da1/7e63a/nrf58240.jpg 1350w,
/static/0204374c06c1f7808ee24c19879f6da1/da6ee/nrf58240.jpg 1400w" sizes="(max-width: 900px) 100vw, 900px" type="image/jpeg"/>
          <img src="https://electricui.com/static/0204374c06c1f7808ee24c19879f6da1/86440/nrf58240.jpg" alt="Single blue large microcontroller development board" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>The implementation is similar to the handful of ESP32 projects tested earlier, but Zephyr RTOS has some slight differences in approach and runs on a higher tick rate than FreeRTOS. Just like most of the other tests, I needed to spend some time experimenting with BLE configuration to get fair results as the defaults were a bit relaxed.</p>
<p>One notable difference to the other BLE implementations was consistent performance regardless of the transfer direction between boards.</p>
<img src="https://electricui.com/ac005113db08570aa7b036812706c18d/nrf52-server-client-directionality.svg" alt="BLE Boxplots showing same distributions for notify and write, median 16.5ms"/>
<p>Something I found interesting during early tests was impressively tight clustering of results (within ±1 ms) for shorter benchmark sequences. Over longer spans of many minutes the distribution of results ranged more evenly.</p>
<p>This was a clear demonstration of accidental alignment and subtle drift between the stimulus signal and the boards waiting for the next BLE transmission slot. As a result, I&#39;m including a variation test run here to give a better impression of latency spread in less controlled environments:</p>
<ul>
<li>Normal periodic trigger pulse interval,</li>
<li>&#39;Randomised&#39; trigger intervals to mitigate synchronisation biases with the connection interval. The signal generator&#39;s sweep functionality slowly added +50 ms to the normal pulse interval.</li>
</ul>
<img src="https://electricui.com/b7407789d9b257e1bc757a60d06cfa07/nrf52-results.svg" alt="BLE boxplots 3x2, median 12B=13.4ms, 128B=13.8ms, 1kB=24.6ms"/>
<p>The tight clumps of results are aligned to multiples of the connection interval. We can also see the expected behaviour that larger packets increase the widths of the clusters. Outliers aren&#39;t anywhere to be seen, and the lower-bound latency for the 1 kiB packet is half of the ESP32&#39;s best BLE result.</p>
<p>Sniffing a 1 KiB test with Wireshark shows us the idealised 1 KiB transfer sequence in action, 6 packets immediately after each other taking ~6 ms combined. So we&#39;re still really limited by the connection interval!</p>
<span><span>
      <a href="https://electricui.com/static/92d23c414e41e62eee56f4fe0d51f15e/1f855/nrf52-1kb-chunks.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/92d23c414e41e62eee56f4fe0d51f15e/7bb4c/nrf52-1kb-chunks.avif 225w,
/static/92d23c414e41e62eee56f4fe0d51f15e/212f8/nrf52-1kb-chunks.avif 450w,
/static/92d23c414e41e62eee56f4fe0d51f15e/4d7a3/nrf52-1kb-chunks.avif 900w,
/static/92d23c414e41e62eee56f4fe0d51f15e/6f77c/nrf52-1kb-chunks.avif 1350w,
/static/92d23c414e41e62eee56f4fe0d51f15e/a848b/nrf52-1kb-chunks.avif 1800w,
/static/92d23c414e41e62eee56f4fe0d51f15e/b0cf9/nrf52-1kb-chunks.avif 1886w" sizes="(max-width: 900px) 100vw, 900px" type="image/avif"/><source srcset="/static/92d23c414e41e62eee56f4fe0d51f15e/7d522/nrf52-1kb-chunks.webp 225w,
/static/92d23c414e41e62eee56f4fe0d51f15e/b5115/nrf52-1kb-chunks.webp 450w,
/static/92d23c414e41e62eee56f4fe0d51f15e/5722e/nrf52-1kb-chunks.webp 900w,
/static/92d23c414e41e62eee56f4fe0d51f15e/c5b95/nrf52-1kb-chunks.webp 1350w,
/static/92d23c414e41e62eee56f4fe0d51f15e/8fb31/nrf52-1kb-chunks.webp 1800w,
/static/92d23c414e41e62eee56f4fe0d51f15e/e22d9/nrf52-1kb-chunks.webp 1886w" sizes="(max-width: 900px) 100vw, 900px" type="image/webp"/>
          <source srcset="/static/92d23c414e41e62eee56f4fe0d51f15e/1663a/nrf52-1kb-chunks.png 225w,
/static/92d23c414e41e62eee56f4fe0d51f15e/7f757/nrf52-1kb-chunks.png 450w,
/static/92d23c414e41e62eee56f4fe0d51f15e/7abe2/nrf52-1kb-chunks.png 900w,
/static/92d23c414e41e62eee56f4fe0d51f15e/5d6e7/nrf52-1kb-chunks.png 1350w,
/static/92d23c414e41e62eee56f4fe0d51f15e/7385a/nrf52-1kb-chunks.png 1800w,
/static/92d23c414e41e62eee56f4fe0d51f15e/1f855/nrf52-1kb-chunks.png 1886w" sizes="(max-width: 900px) 100vw, 900px" type="image/png"/>
          <img src="https://electricui.com/static/92d23c414e41e62eee56f4fe0d51f15e/7abe2/nrf52-1kb-chunks.png" alt="Wireshark GUI with rows of alternating empty and 230B ATT transfers, repeated 5x, 72B final" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></span>
<p>Nordic get brownie points for their documentation and examples working first try without modification, and the inclusion of <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/bluetooth_services/services/latency.html" target="_blank" rel="noopener noreferrer">GATT based Latency</a> and <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/bluetooth_services/services/throughput.html" target="_blank" rel="noopener noreferrer">Throughput APIs</a> shows us what the <em>bare minimum</em> should be for developers to reasonably reproduce and test their hardware.</p>
<h3 id="wifi" is="h3">WiFi</h3>
<p>Given the ESP32&#39;s core feature is its WiFi support, we really should see how it stacks up. Again, we&#39;re only looking at latency and ignoring the limited range and higher power consumption.</p>
<p>First up, non-blocking TCP and UDP socket implementations between the two boards using existing WiFi infrastructure (Unifi U6+ about 5 meters away, 8 other 2.4 GHz clients).</p>
<p>All of the test payloads can fit in a single packet and the boards are running at 72 Mbps PHY rate (HT20) which should trivialise test payload timings with sheer throughput.</p>
<img src="https://electricui.com/712da4fdab8f93bc3bd19ce7a7312cc1/esp32-sockets-defaults.svg" alt="TCP and UDP Boxplots 2x3, medians all between 74 and 84ms"/>
<p>Once again, we&#39;re seeing the ESP-IDF default configuration underperforming the expected latency results. For context, pinging either of the boards from my workstation gives ~7 ms results.</p>
<p>Going through the docs and forums shows us a few knobs we can turn - playing with the modem&#39;s power-saving modes, ensuring the WiFi <em>and</em> LwIP stacks are in IRAM, and disabling <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank" rel="noopener noreferrer">Nagle&#39;s Algorithm</a> for TCP.</p>
<img src="https://electricui.com/04bd12795d5c63e371bb9191efbcf17f/esp32-sockets-tweaked.svg" alt="TCP and UDP Boxplots 2x3, TCP medians ~6ms, UDP medians ~9ms, all with outliers to 25ms"/>
<p>Much better. Both TCP and UDP were able to achieve the <em>same</em> lower-bound latencies and similar worst-case outliers. UDP is shown with a ~2.5 ms higher median which I attributed to the more even distribution of results in the span, but I&#39;d consider it too-close to call for this micro-benchmark.</p>
<p>In real-world projects it&#39;s more common to see high-level protocols over raw sockets, especially given how often integrations need to support phones, web services, and 3rd party systems. WebSockets are a pretty popular choice and we&#39;d <em>expect</em> them to perform similarly on the ESP32 to our TCP results.</p>
<p>Espressif&#39;s example projects (<a href="https://github.com/espressif/esp-protocols/tree/master/components/esp_websocket_client" target="_blank" rel="noopener noreferrer"><code>esp_websockets_client</code></a> and <a href="https://github.com/espressif/esp-idf/tree/ece73357caa6c766770136b82639964870e340ba/examples/protocols/http_server/ws_echo_server" target="_blank" rel="noopener noreferrer"><code>ws_echo_server</code></a>) provided a better starting point for the benchmark implementation than the LwIP socket implementations.</p>
<p>At this point I shouldn&#39;t have been surprised, but I <em>really</em> struggled to achieve consistent run-to-run results across many testing and optimisation attempts.</p>
<img src="https://electricui.com/9af48f13f90c88458d46b9515af821d4/esp32-websocket-nagles.svg" alt="Boxplots x9, unique 10ms wide distributions scattered from 30ms to 245ms"/>
<p>While drafting a highly detailed GitHub issue I worked out that I was being thwarted by Nagle&#39;s Algorithm again, needing a slightly different approach to disable it when using the httpd server library.</p>
<div><div><pre><code><span><p><span>static</span><span> </span><span>esp_err_t</span><span> </span><span>ws_server_handler</span><span>(</span><span>httpd_req_t</span><span> </span><span>*</span><span>req</span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>req</span><span>-&gt;</span><span>method</span><span> </span><span>==</span><span> HTTP_GET</span><span>)</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>ESP_LOGI</span><span>(</span><span>TAG</span><span>,</span><span> </span><span>&#34;</span><span>WS Handshake Complete</span><span>&#34;</span><span>);</span><span>    </span></p><p><span>        </span><span>// Modify the underlying TCP socket. Surely there&#39;s a better way?</span></p><p><span>        </span><span>int</span><span> sock_id </span><span>=</span><span> </span><span>httpd_req_to_sockfd</span><span>(</span><span>req</span><span>);</span></p><p><span>        </span><span>int</span><span> no_delay </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span></p><p><span>        </span><span>setsockopt</span><span>(</span><span>sock_id</span><span>,</span><span> IPPROTO_TCP</span><span>,</span><span> TCP_NODELAY</span><span>,</span><span> </span><span>&amp;</span><span>no_delay</span><span>,</span><span> </span><span>sizeof(</span><span>int</span><span>));</span></p><p><span>        </span><span>return</span><span> ESP_OK</span><span>;</span></p><p><span>    </span><span>}</span></p><p><span>	</span><span>// Rest of websocket packet handling code</span></p></span></code></pre></div></div>
<img src="https://electricui.com/7f8ebce44db9a821d63dca1b65b460fb/esp32-websockets.svg" alt="ESP32 Websockets boxplot, 12B=14.4ms, 128B=13.6ms, 1kB=10ms"/>
<p>As expected, there&#39;s no meaningful impact of packet size due to the high link throughput, but we can see that Websockets have cost us around ~6 ms over the lower-level TCP socket implementation (this could be phrased as &#34;double the latency&#34; for clickbait?). Larger packets repeatedly tested faster than smaller transfers for some unknown reason.</p>
<p>So while WebSockets are a lot easier to work with, as implemented, they do have a latency cost on the ESP32.</p>
<p>For a quick comparison, a pair of Raspberry Pi&#39;s using onboard WiFi can achieve Websocket transfer results on-par with the ESP32&#39;s TCP results, with a <a href="https://github.com/Scottapotamas/embedded-wireless-latency-eval/tree/main/firmware/rpi-node/src" target="_blank" rel="noopener noreferrer">pretty minimal NodeJS implementation</a>.</p>
<img src="https://electricui.com/c7d283dc6d8a252a7cbe2ae54bb92761/pi4-node-ws-results.svg" alt="PI4 boxplots 2x3 for ethernet at 2.3ms, WiFi at 6.5ms, all have outliers past 50ms"/>
<p>The Pi&#39;s outliers are spread a little wider than I&#39;d expect (especially when on Ethernet) but digging into network and performance tuning of Linux and run-times like Node isn&#39;t something I&#39;ll be doing in this post!</p>
<h2 id="results" is="h2">Results</h2>
<p>We finally made it! It only took 10k lines of code, a new year, and running an overwhelming &gt;200 tests across the different targets...</p>
<p>To make comparisons easier, we&#39;re going to start with a barchart of the upper quartile latency figures as I think they&#39;re most statistically fair across the board.</p>
<img src="https://electricui.com/4556ae1dc53c0dbc9d071808ff7506ed/all-boxplot-uq.svg" alt="12 bar-chart ordered by 12B result: NRF24, 802154, ESPNOW, Pi4, TCP, SPP, WS, BLE, HC05, NRF52, SIK"/>
<p>When I started these micro-benchmarks I didn&#39;t expect the nRF24 module to perform so well - it recorded the lowest minimum, lower/upper quartile, and median for 12B and 128B payloads.</p>
<p>We can see an interesting trend with the top three results: despite strong performance for the small and medium payloads, their 1 KiB results are alongside the BLE implementations in the midfield. The common element between them is the small MTU which requires many chunk transfers.</p>
<p>Unfortunately, the NRF52 is placed second-to-last in this chart due to it&#39;s 75% latency result being <em>just slightly</em> higher than the HC05 and LoRA 12B results, even though it&#39;s median should place it alongside the ESP32 BLE (Bluedroid) implementation.</p>
<p>The 915 Mhz LoRa and SiK modules come in last place as expected - low-throughput links optimised for long range are going to struggle in a test that favours high throughput. I expect these modules will fare better when I look into range and congested RF environments in future tests!</p>
<blockquote>
<p>60fps is generally considered the lower-bound for playable game framerates, at just 16.6 ms per frame.</p>
<p>In general, most radios achieved <strong>average</strong> small-packet results lower than that!</p>
</blockquote>
<p>Because so many of these tests used an ESP32, we should have enough data to compare the different protocols and wireless stacks when using the same RF front-end. Most protocols had similar performance with 12B and 128B packets - they all have a MTU exceeding the 128B test and used (relatively) high throughput links.</p>
<p>I&#39;ve plotted the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" target="_blank" rel="noopener noreferrer">probability distribution</a> for each protocol against latency. This lets us make more intuitive comparisons between protocols than another set of box-plots. Picking a point on a line tells us what percentage of a test&#39;s results had finished prior to that duration.</p>
<img src="https://electricui.com/aab4fe54da2ac1bcdbdf6e0437df0fca/all-esp32-1024B-cdf.svg" alt="Coloured overlapping 1kB curves roughly ordered UDP, TCP, WS, SPP, ESPNow, Bluedroid, NimBLE"/>
<p>There are a few general findings that are fairly obvious:</p>
<ul>
<li>As packet size increases, WiFi&#39;s higher throughput beats everything.</li>
<li>When using WiFi with TCP/IP transfers, there are only small differences between TCP, UDP and Websockets performance <em>for these benchmark conditions</em>.</li>
<li>SPP leads over the BLE results, probably due to it&#39;s ~5x larger 990 byte MTU.</li>
<li>If using BLE on the ESP32, the Bluedroid stack is lower latency than NimBLE.</li>
</ul>
<h3 id="development-experience" is="h3">Development Experience</h3>
<p>The <strong>easiest implementation</strong> was the ESP32-C6 with IEEE 802.15.4, followed by the transparent UART bridges SiK and HC-05, and ESPNOW.</p>
<p>The <strong>most time consuming</strong> part was implementing and testing the RFM95 LoRA modules, as I burnt time trying a few different OSS libraries with design issues ranging from blocking sleeps, bugs, and polling the module&#39;s status IO instead of using interrupts.</p>
<p>However the <strong>most frustrating</strong> work was troubleshooting the NimBLE stack on the ESP32. The perfect storm of sub-par default performance, stale example projects, and needing to continually cross-reference between the Espressif and MyNewt documentation websites and source-code.</p>
<h3 id="what-wireless-module-is-best-for-my-project" is="h3">What wireless module is best for my project?</h3>
<p>I see this question all the time online, and it&#39;s hard to advocate for a specific radio module or protocol over another based on latency alone.</p>
<p>One of the takeaways of these tests should be how capable modern radios are and when they have ability to use multiple protocols (often at the same time), this becomes more of a <em>software</em> choice than hardware!</p>
<p>For microcontrollers with integrated radios:</p>
<ul>
<li>Newer Espressif parts like the ESP32-C6 are a compelling choice for their low cost, reasonable tooling, community support and capable hardware.<!-- -->
<ul>
<li>I&#39;ll definitely be building with the C6 and 802.15.4 in future projects...</li>
</ul>
</li>
<li>If you can tolerate a steeper learning curve and have climbed a DeviceTree before, then Nordic&#39;s nRF parts offer a more consistent developer experience and first-party examples.</li>
<li>ST&#39;s WB series is worth looking at, but have caused me a lot of pain previously.</li>
</ul>
<p>If you&#39;re adding an external radio to your microcontroller and don&#39;t need the best possible performance, any transparent UART bridge is a good low-effort choice.</p>
<p>The nRF24 performed well in these tests but is rather dated at this point. Probably still a reasonable choice for simple one-off projects, otherwise look at the <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/protocols/esb/index.html" target="_blank" rel="noopener noreferrer">nRF5&#39;s Shockburst support</a> for more recent options.</p>
<p>Still not sure? Look for modules that use SPI to maximise performance. A good starting point might be looking at the <a href="http://www.airspayce.com/mikem/arduino/RadioHead/" target="_blank" rel="noopener noreferrer">RadioHead</a> Arduino library which supports a wide range of modules.</p>
<h2 id="key-takeaways" is="h2">Key Takeaways</h2>
<p>The process of implementing and testing each of these modules reinforced a couple of valuable lessons:</p>
<ul>
<li>Fantastic low-latency communication links are more accessible than ever.</li>
<li>Unsurprisingly the balance between power consumption, throughput, and latency matters - and default settings are often on the conservative side.</li>
<li>If you <em>need</em> the lowest latency and tight control over your system&#39;s behaviour, you&#39;ll probably find the best results with a wireless stack that isn&#39;t trying to co-exist with other protocols or devices.</li>
<li>Even when you&#39;re doing everything properly, validate with scope traces and Wireshark captures.</li>
<li>Benchmarking things properly is <em>really</em> time consuming!</li>
</ul>
<p>I&#39;m thinking of doing a suite of real-world range tests against a sub-set of these devices, and would love feedback if you found this helpful or interesting (or have any corrections/suggestions).</p>
<h2 id="references--acknowledgements" is="h2">References &amp; Acknowledgements</h2>
<ul>
<li><a href="https://github.com/henriheimann/stm32-hal-rfm95" target="_blank" rel="noopener noreferrer">Henri Heimann&#39;s <code>stm32-hal-rfm95</code></a> and <a href="https://github.com/PeeWeeLabs/pwl_rfm9X" target="_blank" rel="noopener noreferrer">PeeWeeLabs&#39;s <code>pwl_rfm9X</code></a> as reference material.</li>
<li><a href="https://www.semtech.com/design-support/lora-calculator" target="_blank" rel="noopener noreferrer">Semtech&#39;s LoRa calculator</a>, and <a href="https://iftnt.github.io/lora-air-time/index.html" target="_blank" rel="noopener noreferrer">Yung-Hsiang Hu&#39;s <code>lora-air-time</code> calculator</a> as a sanity check.</li>
<li><a href="https://github.com/elmot/nrf24l01-lib" target="_blank" rel="noopener noreferrer">Ilia Motornyi&#39;s <code>nrf24l01-lib</code></a>.</li>
<li>Espressif&#39;s <a href="https://github.com/espressif/esp-idf/blob/master/examples" target="_blank" rel="noopener noreferrer"><code>ESP-IDF</code> example projects</a>.</li>
<li><a href="https://www.martyncurrey.com/arduino-with-hc-05-bluetooth-module-at-mode/" target="_blank" rel="noopener noreferrer">Martyn Currey&#39;s blog post</a> detailing HC-05 AT Commands.</li>
<li><a href="https://interrupt.memfault.com/blog/ble-throughput-primer" target="_blank" rel="noopener noreferrer">BLE Throughput Primer on Memfault&#39;s Interrupt blog.</a></li>
<li><a href="https://github.com/xyzzy42" target="_blank" rel="noopener noreferrer"><code>@xyzzy42</code></a> for NimBLE configuration suggestions.</li>
<li><a href="https://github.com/JamesBarwell/rpi-gpio.js" target="_blank" rel="noopener noreferrer">James Barwell&#39;s <code>rpi-gpio</code></a> NodeJS library.</li>
<li><a href="https://wavedrom.com/" target="_blank" rel="noopener noreferrer">WaveDrom</a> for <code>svg</code> timing diagrams.</li>
<li><a href="https://www.r-project.org/" target="_blank" rel="noopener noreferrer">R</a> and <a href="https://posit.co/products/open-source/rstudio/" target="_blank" rel="noopener noreferrer">RStudio</a>.</li>
<li><a href="https://www.cedricscherer.com/2021/06/06/visualizing-distributions-with-raincloud-plots-and-how-to-create-them-with-ggplot2" target="_blank" rel="noopener noreferrer">Cedric Scherer&#39;s blogpost on Raincloud plots.</a></li>
<li><a href="http://shiny.chemgrid.org/boxplotr/" target="_blank" rel="noopener noreferrer">BoxPlotR</a> (<a href="https://github.com/VizWizard/BoxPlotR.shiny" target="_blank" rel="noopener noreferrer">GitHub</a>) for <code>svg</code> boxplots (eventually replaced by my own script).</li>
<li><a href="https://personal.sron.nl/~pault/" target="_blank" rel="noopener noreferrer">Paul Tol&#39;s Introduction to Colour Schemes</a></li>
</ul></main></div></div></div>
  </body>
</html>
