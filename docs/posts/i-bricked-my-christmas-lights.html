<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.whizzy.org/2023-12-14-bricked-xmas/">Original</a>
    <h1>I bricked my Christmas lights</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    <div>

      

      

      <article role="main">
        

<p>If a device communicates via Bluetooth LE and has an app, it deserves to be integrated into my home automation system.</p>

<p>I’ve spent a significant amount of time reverse engineering various budget-friendly LED light strips to automate them. The process is generally repetitive, but I find it enjoyable. Recently, I successfully connected the cheapest lights I’ve ever come across — a £2.38 Bluetooth LE-controlled 5M non-addressable strip — to Home Assistant in just a few hours. You can buy some <a href="https://www.aliexpress.com/item/1005005485885067.html">here</a> and the code is <a href="https://github.com/8none1/bj_led">here</a>.</p>

<p>There is also the LEDnetWF controller I did the reverse engineering for <a href="https://github.com/raulgbcr/lednetwf_ble">here</a>.</p>

<p><img src="https://www.whizzy.org/wp-content/uploads/2023/12/ha.jpg" alt="AliExpress Lights"/></p>

<p>I also had another set of addressable lights on my desk. While decorating my office for Christmas, I decided to invest some time in connecting them to Home Assistant using the BJ_LED code as a template. It should have been straightforward, right? Well, yes, but also no.</p>

<p>These lights consist of a 10M long string of addressable LEDs controlled by the “iDeal LED” app. The app is feature-rich and works reasonably well. The LEDs are likely WS2812 or similar. I was quite pleased with these lights, which you can <a href="https://www.aliexpress.com/item/1005004829475855.html">find on AliExpress</a>.</p>

<p><img src="https://www.whizzy.org/wp-content/uploads/2023/12/aliex_lights.jpg" alt="AliExpress Lights"/></p>

<p>Now, let me share a cautionary tale. While I’m omitting some details for brevity, there are no secrets here, and additional instructions are readily available online. I understand this might feel a bit like <a href="https://knowyourmeme.com/memes/how-to-draw-an-owl">drawing the rest of the owl</a> but the provided links should serve as a starting point for anyone interested in reverse engineering their own LED lights.</p>

<h2 id="step-1-the-bytes-over-the-wire">Step 1. The bytes over the wire</h2>

<p>To control devices from your own software, the first step is to examine the bytes sent over Bluetooth to the device from the app. Typically, lights use a simple protocol with a header, command bytes (for actions like turning on/off, changing color), and a footer, which might be a checksum.</p>

<p>Android makes this process easy. Enable developer mode on your Android device, install the app for your lights, and enable <code>Bluetooth HCI snoop</code> in the developer settings. This logs Bluetooth bytes to a file readable by <a href="https://www.wireshark.org/">Wireshark</a>. Perform actions in the app, such as turning the lights on and off, and use <code>adb</code> to copy the logs to your computer.</p>

<p>For example:</p>

<pre><code>adb pull sdcard/btsnoop_hci.log .
</code></pre>

<p>Open the log in Wireshark to see the exact bytes sent to the device. Look for patterns in the values, and you’ll likely identify a series of bytes for each action, with one byte alternating between two values (e.g. <code>1</code> and <code>0</code> for <code>on</code> and <code>off</code>). Here’s a useful Wireshark filter:</p>

<pre><code>bluetooth.dst == ff:ff:ff:ff:ff:ff &amp;&amp; btatt.opcode.method==0x12
</code></pre>

<p>Change MAC address to be the MAC of your lights.  <code>btatt.opcode.method==0x12</code> is a write from the Android device to the lights.</p>

<p>Congratulations, you are now a reverse engineer!</p>

<p>Pro-tip:  You can speed things up a bit by using <a href="https://tshark.dev/">tshark</a> instead of Wireshark.  What you really care about is the values being written to the LED controller.  <code>tshark -r &lt;filename&gt; -T fields -e btatt.value</code> will dump the payload to the terminal for easy interrogation.</p>

<p>Sometimes your bytes will look like this:</p>

<pre><code>69 96 02 01 01
69 96 02 01 00
69 96 02 01 01
69 96 02 01 00
69 96 02 01 01
69 96 02 01 00
69 96 02 01 01
69 96 02 01 00
</code></pre>

<p>On, off, on, off, on, off, on, off.</p>

<p>Sometimes your bytes will look like this:</p>

<pre><code>84 dd 50 42 37 41 50 89 7a c8 2f 39 11 09 68 a8
79 d1 db a4 09 19 c2 46 a8 58 0a e7 d1 1b 78 84
84 dd 50 42 37 41 50 89 7a c8 2f 39 11 09 68 a8
79 d1 db a4 09 19 c2 46 a8 58 0a e7 d1 1b 78 84
84 dd 50 42 37 41 50 89 7a c8 2f 39 11 09 68 a8
79 d1 db a4 09 19 c2 46 a8 58 0a e7 d1 1b 78 84
84 dd 50 42 37 41 50 89 7a c8 2f 39 11 09 68 a8
</code></pre>

<p>There is still a repeating pattern here.  There are two distinct sets of bytes, one for on &amp; one for off, but… what?  Why is it so noisy?
Who designs their protocol like this?
The answer is: someone who is trying to hide something.</p>

<h2 id="step-2--replay-attacks">Step 2.  Replay attacks</h2>

<p>If your goal is simply turning the lights on and off, the repeating series of bytes you observed might be sufficient for power control. Test this with <code>gatttool</code>, which lets you connect to a BLE device and send bytes. You’ll need to know the handle to send bytes to, which you can find using Wireshark.</p>

<p><img src="https://www.whizzy.org/wp-content/uploads/2023/12/wireshark.jpg" alt=""/></p>

<p>For more control, understanding all those bytes is essential. Let’s go to the source…</p>

<h2 id="step-3-decompile-the-android-app">Step 3. Decompile the Android app</h2>

<p>Download the app’s APK and open it in <a href="https://github.com/skylot/jadx">jadx</a>. Witness the secrets within!</p>

<p>In my case, I noticed references to AES in the source, indicating a potentially encrypted protocol. If the data is encrypted, some assumptions can be made:</p>

<ul>
  <li>The encrypted data doesn’t change every time, suggesting a consistent key.</li>
  <li>The data needs quick decryption on a low-power MCU, favouring shorter keys.</li>
  <li>The key is likely not unique to each device, making a fixed key plausible.</li>
</ul>

<p>The source code contained a compiled AES library <code>libAES.so</code>, which <code>jadx</code> can’t help me with.</p>

<p><img src="https://www.whizzy.org/wp-content/uploads/2023/12/jadx.jpg" alt=""/>
<img src="https://www.whizzy.org/wp-content/uploads/2023/12/jadx2.jpg" alt=""/></p>

<p>This is where I got stuck.  For about 5 minutes.</p>

<p>I asked <a href="https://ubuntu.social/@popey">@popey</a> and <a href="https://mastodon.social/@sil">@sil</a> for some ideas.  @sil Googled some of the decompiled app code and found <a href="https://habr-com.translate.goog/ru/articles/722412/?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=en-US&amp;_x_tr_pto=wapp&amp;_x_tr_hist=true">this</a> page.  On closer examination the code looks identical.  This chap used <a href="https://hex-rays.com/ida-free/">ida free</a> to decompile the AES library and found the key embedded in it.  Let’s try that key.</p>

<pre><code>from Crypto.Cipher import AES

key = [
    0x34, 0x52, 0x2A, 0x5B, 0x7A, 0x6E, 0x49, 0x2C,
    0x08, 0x09, 0x0A, 0x9D, 0x8D, 0x2A, 0x23, 0xF8
]

def decrypt_aes_ecb(ciphertext, key):
    cipher = AES.new(key, AES.MODE_ECB)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext
</code></pre>

<p>When we try and decrypt the <code>on</code> and <code>off</code> packets we get:</p>

<pre><code>05 54 55 52 4E 01 00 00 00 00 00 00 00 00 00 00
05 54 55 52 4E 00 00 00 00 00 00 00 00 00 00 00
05 54 55 52 4E 01 00 00 00 00 00 00 00 00 00 00
05 54 55 52 4E 00 00 00 00 00 00 00 00 00 00 00
05 54 55 52 4E 01 00 00 00 00 00 00 00 00 00 00
05 54 55 52 4E 00 00 00 00 00 00 00 00 00 00 00
</code></pre>

<p>Success!  This is a lot more sensible.  A fixed header, byte 5 switching between a <code>1</code> and a <code>0</code> for on and off, and a bunch of zeros.</p>

<p>We can now decrypt all the packets being sent to the device and we can encrypt our own bytes so that we can duplicate the controls from the Android app in our own code.  It’s pretty much mission accomplished at this point.</p>

<h2 id="step-4-all-the-functions">Step 4. All the functions</h2>

<p>Now, work through each app function, recording the bytes sent. Write down each action, do it multiple times, and use separators like turning the lights on and off. This helps spot patterns and correlate notes with captured bytes.</p>

<p>For example, your process might be:</p>

<pre><code>turn off, turn on - [start of function]
set to red
set to green
set to blue
set to red
set to green
set to blue
set to red
set to green
set to blue
turn off, turn on - [end of colour changing]
set brightness to 100%
set brightness to 50%
set brightness to 10%
set brightness to 50%
set brightness to 100%
turn off, turn on - [end of brightness]
</code></pre>

<p>This will help you to spot patterns in the data and see which bytes change depending on what you are doing.</p>

<h2 id="step-5--automated-e-waste-generator">Step 5.  Automated e-waste generator</h2>

<p>While exploring color changes, I observed that the app never sent a value higher than 0x1F (5 bits) for red, green, or blue. Curious, I tried sending 8-bit values, and it worked remarkably well — brighter colors!</p>

<p>Great success!</p>

<p>Excited by my discovery I got to wondering what other secrets this light controller was hiding from me.  I wonder if there are any additional effects beyond the 10 that the app uses?
A good way to try this out would be a simple loop.</p>

<pre><code>    for n in range(20):
        print(f&#34;Setting effect {n}&#34;)
        set_effect(n)
        time.sleep(20)
</code></pre>

<p>I ran this and watched 1 to 10.  So far so good, then it ticked over to 11 and AH HA!  I have found a secret mode!
Then it ticked over to 12 and… darkness.</p>

<p>Oh well, I guess there are only 11 effects, that’s fine.  I’ll reboot it and finish off the rest of the code.</p>

<p>And that was then end of my fun.</p>

<p>The lights never came back.</p>

<p>They don’t advertise on Bluetooth any more and I can’t connect to them.  I’ve tried holding down the button when turning them on.  I’ve left them unplugged over night to see if that helps, but no.</p>

<p>They are dead.</p>

<p>I guess I overflowed some buffer and I’ve corrupted the firmware.</p>

<p>All is not lost however.  The LEDs themselves are standard addressable LEDs so I can at least hook the string up to a different microcontroller and use them.</p>

<h2 id="tell-me-how-i-can-break-my-own-lights">Tell me how I can break my own lights</h2>

<p>Despite the setback, I documented most of the protocol and created a Github project with a Home Assistant custom component. It works, but proceed at your own risk.</p>

<p><a href="https://github.com/8none1/idealLED">Github: 8none1/idealLED</a></p>

      </article>

      

      

      
        <!-- Check if any share-links are active -->








      

      
      
  
  
  

  


  

  



    </div>
  </div>
</div></div>
  </body>
</html>
