<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://crystal-lang.org/2021/12/29/crystal-i.html">Original</a>
    <h1>Crystal&#39;s Interpreter (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>The awaited Crystal interpreter has been <a href="https://github.com/crystal-lang/crystal/pull/11159">merged</a>. To use it, you need to compile Crystal with a special flag and, at the time of writing, the official releases (.deb, .rpm, docker images, etc.) are not being compiled with it.</p>

<p>This post doubles as a F.A.Q. for this special feature. Let’s start from the very beginning:</p>



<p>While many will find this obvious, it’s useful to point out two specific features that an interpreter might enable:</p>

<ol>
  <li>In principle an interpreter should start executing code faster, since the codegen phase is skipped (see below), allowing to quickly test the result of some code without needing to recompile. It should be noted that the interpreter is quick for short programs that need to run only once, but compiled mode provides much more performance and should be preferred for most production use cases. Also, while the behavior of interpreted and compiled programs might differ in some aspects (due to the system), we intend to keep the differences down to a minimum, and most programs should behave exactly the same in interpreted and compiled mode.</li>
  <li>An interpreter improves the experience of debugging, being an ad-hoc tool to the language (unlike the generic <code><span>lldb</span></code>).</li>
</ol>



<p>The interpreter is currently on an experimental phase, with lots of <a href="https://github.com/crystal-lang/crystal/issues/11555">missing bits</a>. The reason to merge it at this early stage is to enable a proper discussion of interpreter-related PRs and speed up its development a bit. For those willing to try it out, we welcome interpreter-related issues taking into consideration the already known issues aforelinked.</p>



<p>The <a href="https://github.com/crystal-lang/crystal/pull/11159">original PR</a> answers it:</p>

<blockquote>
  <p>When running in interpreted mode, semantic analysis is done as usual, but instead of then using LLVM to generate code, we compile code to bytecode (custom bytecode defined in this PR, totally unrelated to LLVM). Then there’s an interpreter that understands this bytecode.</p>
</blockquote>



<p>⚠️ This is not set in stone!</p>

<p>Assuming you’ve compiled Crystal passing the flag <code><span>interpreter</span><span>=</span><span>1</span></code> to <code><span>make</span></code>, you can invoke the interpreter using two modes right now:</p>

<ul>
  <li><code><span>crystal</span> <span>i</span> <span>file</span><span>.</span><span>cr</span></code></li>
</ul>

<p>This commands runs a file in interpreted mode, so if <code><span>write_hello</span><span>.</span><span>cr</span></code> contains the following:</p>

<div><div><pre><code><span>File</span><span>.</span><span>write</span><span>(</span><span>&#34;/tmp/hello&#34;</span><span>,</span> <span>&#34;Hello from the interpreter!&#34;</span><span>)</span>
<span>puts</span> <span>&#34;done&#34;</span>
</code></pre></div></div>

<p>Invoking <code><span>crystal</span> <span>i</span> <span>write_hello</span><span>.</span><span>cr</span></code> will produce the file <code><span>/tmp/</span><span>hello</span></code> and print <code><span>&#34;done&#34;</span></code> to the <code><span>stdout</span></code>.</p>

<ul>
  <li><code><span>crystal</span> <span>i</span></code></li>
</ul>

<p>This command opens an interactive crystal session (REPL) similar to <code><span>irb</span></code> from Ruby. In this session we can write a command and get its result:</p>

<div><div><pre><code><span>icr</span><span>:</span><span>1</span><span>:</span><span>0</span><span>&gt;</span> <span>File</span><span>.</span><span>read_lines</span><span>(</span><span>&#34;/tmp/hello&#34;</span><span>)</span>
<span>=&gt;</span> <span>[</span><span>&#34;Hello from the interpreter!&#34;</span><span>]</span>
</code></pre></div></div>

<p>(Note: the highlighting is not yet part of the interpreter.)</p>



<p>In any of these two modes, you can use <code><span>debugger</span></code> in your code to debug it at that point. This is similar to Ruby’s <code><span>pry</span></code>. There you can use these commands (similar to <code><span>pry</span></code> also):</p>

<ul>
  <li><code><span>step</span></code>: go to the next line/instruction, possibly going inside a method.</li>
  <li><code><span>next</span></code>: go to the next line/instruction, doesn’t enter into methods.</li>
  <li><code><span>finish</span></code>: exit the current method.</li>
  <li><code><span>continue</span></code>: resume execution.</li>
  <li><code><span>whereami</span></code>: show where the debugger is.</li>
</ul>

<p>For instance, if we add <code><span>debugger</span></code> between the <code><span>write</span></code> and the <code><span>puts</span></code> in <code><span>write_hello</span><span>.</span><span>cr</span></code>, we get the following after interpreting the file:</p>

<div><div><pre><code><span>From</span><span>:</span> <span>/tmp/</span><span>write_hello</span><span>.</span><span>cr</span><span>:</span><span>3</span><span>:</span><span>6</span> <span>&lt;</span><span>Program</span><span>&gt;</span><span>#/tmp/write_hello.cr:</span>

    <span>1</span><span>:</span> <span>File</span><span>.</span><span>write</span><span>(</span><span>&#34;/tmp/hello&#34;</span><span>,</span> <span>&#34;Hello from the interpreter!&#34;</span><span>)</span>
    <span>2</span><span>:</span> <span>debugger</span>
 <span>=&gt;</span> <span>3</span><span>:</span> <span>puts</span> <span>&#34;done&#34;</span>

<span>pry</span><span>&gt;</span>
</code></pre></div></div>

<p>And if we <code><span>step</span></code>, we can see the method form the standard library being called:</p>

<div><div><pre><code><span>pry</span><span>&gt;</span> <span>step</span>
<span>From</span><span>:</span> <span>/Users/</span><span>beta</span><span>/</span><span>projects</span><span>/</span><span>crystal</span><span>/</span><span>crystal</span><span>/</span><span>src</span><span>/</span><span>kernel</span><span>.</span><span>cr</span><span>:</span><span>385</span><span>:</span><span>1</span> <span>&lt;</span><span>Program</span><span>&gt;</span><span>#puts:</span>

    <span>380</span><span>:</span>
    <span>381</span><span>:</span> <span># Prints *objects* to `STDOUT`, each followed by a newline character unless</span>
    <span>382</span><span>:</span> <span># the object is a `String` and already ends with a newline.</span>
    <span>383</span><span>:</span> <span>#</span>
    <span>384</span><span>:</span> <span># See also: `IO#puts`.</span>
 <span>=&gt;</span> <span>385</span><span>:</span> <span>def</span> <span>puts</span><span>(</span><span>*</span><span>objects</span><span>)</span> <span>:</span> <span>Nil</span>
    <span>386</span><span>:</span>   <span>STDOUT</span><span>.</span><span>puts</span> <span>*</span><span>objects</span>
    <span>387</span><span>:</span> <span>end</span>
    <span>388</span><span>:</span>
    <span>389</span><span>:</span> <span># Inspects *object* to `STDOUT` followed</span>
    <span>390</span><span>:</span> <span># by a newline. Returns *object*.</span>

<span>pry</span><span>&gt;</span>
</code></pre></div></div>

<p>At this point, we might be curious: what are the <code><span>objects</span></code> that we passed to this method? We <code><span>step</span></code> once again to have the variable in scope, and we issue:</p>





<p>We’re definitely missing benchmarks, more so given that not many shards can be successfully interpreted. Testing on a few random files from the standard library and <a href="https://github.com/crystal-community/crystal-patterns">Crystal Patterns</a>, it loads them (and <em>executes</em> them, see below) between 50 and 75% faster than it takes when compiling them (comparing <code><span>time</span> <span>crystal</span> <span>&lt;</span><span>file</span><span>&gt;</span></code> vs. <code><span>time</span> <span>crystal</span> <span>i</span> <span>&lt;</span><span>file</span><span>&gt;</span></code>). This depends significantly on how much time Crystal takes on the common steps to the compiler and the interpreter, like parsing and semantic analysis.</p>



<p>As Ary, its creator, <a href="https://www.youtube.com/watch?v=een_W1YEICw">showed</a> in <a href="https://www.crystal-lang.org/conference/">Crystal Conf 1.0</a>, it runs sufficiently fast—for an interpreter that is. Of course, it’s not nearly as efficient as a mature interpreter implementation like Ruby’s, yet in our preliminary tests it runs fast enough for the expected use cases. For instance, it can handle millions of integer additions within the second. This said, using the interpreter for processing intensive tasks is definitively discouraged, as that’s the task for a compiled program.</p>

<hr/>
<p>To conclude, merging the PR is the first step to get a working interpreter in Crystal and, more importantly, it’s a testament of the will of the Crystal team to improve the developer experience.</p>

      </div></div>
  </body>
</html>
