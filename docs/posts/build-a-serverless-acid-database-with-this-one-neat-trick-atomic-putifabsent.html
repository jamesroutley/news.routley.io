<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.eatonphil.com/2024-09-29-build-a-serverless-acid-database-with-this-one-neat-trick.html">Original</a>
    <h1>Build a serverless ACID database with this one neat trick (atomic PutIfAbsent)</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>Delta Lake is an open protocol for serverless ACID databases. Due to
its simplicity, scalability, and the number of open-source
implementations, it&#39;s quickly becoming the DuckDB of serverless
transactional databases for analytics workloads. Iceberg is a
contender too, and is similar in many ways. But since Delta Lake is
simpler (simple != better) that&#39;s where we&#39;ll focus in this post.</p>
<p>Delta Lake has one of the most accessible database papers I&#39;ve read
(<a href="https://www.vldb.org/pvldb/vol13/p3411-armbrust.pdf">link</a>). It&#39;s
kind of like the
<a href="https://github.com/xoreaxeaxeax/movfuscator">movfuscator</a> of
databases.</p>
<p>Thanks to its simplicity, in this post we&#39;ll implement a Delta
Lake-inspired serverless ACID database in 500 lines of Go code with
zero dependencies. It will support creating tables, inserting rows
into a table, and scanning all rows in a table. All while allowing
concurrent readers and writers and achieving <a href="https://jepsen.io/consistency">snapshot
isolation</a>.</p>
<p>There are other critical parts of Delta Lake we&#39;ll ignore: updating
rows, deleting rows, checkpointing the transaction metadata log,
compaction, and probably much more I&#39;m not aware of. We must start
somewhere.</p>
<p>All code for this post is <a href="https://github.com/eatonphil/otf">available on GitHub</a>.</p>
<h3 id="delta-lake-basics">Delta Lake basics</h3><p>Delta Lake writes immutable data files to blob storage. It stores the
names of new data files for a transaction in a metadata file. It
handles concurrency (i.e. achieves snapshot isolation) with an atomic
PutIfAbsent operation on the metadata file for the transaction.</p>
<p>This method of concurrency control works because the metadata files
follow a naming scheme that includes the transaction id in the file
name. When a new transaction starts, it finds all existing metadata
files and picks its own transaction id by adding 1 to the largest
transaction id it sees.</p>
<p>When a transaction goes to commit, writing the metadata file will
fail if another transaction has already picked the same transaction
id.</p>
<p>If a transaction does no writes and creates no tables, the transaction
does not attempt to write any metadata file. Snapshot isolation!</p>
<p>Let&#39;s dig into the implementation.</p>
<h3 id="boilerplate">Boilerplate</h3><p>Let&#39;s give ourselves some nice assertion methods, a debug method, and
a uuid generator. In <code>main.go</code>:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span>

<span>import</span><span> </span><span>(</span>
<span>    </span><span>&#34;encoding/json&#34;</span>
<span>    </span><span>&#34;fmt&#34;</span>
<span>    </span><span>&#34;io&#34;</span>
<span>    </span><span>&#34;os&#34;</span>
<span>    </span><span>&#34;path&#34;</span>
<span>    </span><span>&#34;slices&#34;</span>
<span>    </span><span>&#34;strings&#34;</span>
<span>)</span>

<span>func</span><span> </span><span>assert</span><span>(</span><span>b</span><span> </span><span>bool</span><span>,</span><span> </span><span>msg</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>!</span><span>b</span><span> </span><span>{</span>
<span>        </span><span>panic</span><span>(</span><span>msg</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>

<span>func</span><span> </span><span>assertEq</span><span>[</span><span>C</span><span> </span><span>comparable</span><span>](</span><span>a</span><span> </span><span>C</span><span>,</span><span> </span><span>b</span><span> </span><span>C</span><span>,</span><span> </span><span>prefix</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>a</span><span> </span><span>!=</span><span> </span><span>b</span><span> </span><span>{</span>
<span>        </span><span>panic</span><span>(</span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%s &#39;%v&#39; != &#39;%v&#39;&#34;</span><span>,</span><span> </span><span>prefix</span><span>,</span><span> </span><span>a</span><span>,</span><span> </span><span>b</span><span>))</span>
<span>    </span><span>}</span>
<span>}</span>

<span>var</span><span> </span><span>DEBUG</span><span> </span><span>=</span><span> </span><span>slices</span><span>.</span><span>Contains</span><span>(</span><span>os</span><span>.</span><span>Args</span><span>,</span><span> </span><span>&#34;--debug&#34;</span><span>)</span>

<span>func</span><span> </span><span>debug</span><span>(</span><span>a</span><span> </span><span>...</span><span>any</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>!</span><span>DEBUG</span><span> </span><span>{</span>
<span>        </span><span>return</span>
<span>    </span><span>}</span>

<span>    </span><span>args</span><span> </span><span>:=</span><span> </span><span>append</span><span>([]</span><span>any</span><span>{</span><span>&#34;[DEBUG]&#34;</span><span>},</span><span> </span><span>a</span><span>...</span><span>)</span>
<span>    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>args</span><span>...</span><span>)</span>
<span>}</span>

<span>// https://datatracker.ietf.org/doc/html/rfc4122#section-4.4</span>
<span>func</span><span> </span><span>uuidv4</span><span>()</span><span> </span><span>string</span><span> </span><span>{</span>
<span>    </span><span>f</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Open</span><span>(</span><span>&#34;/dev/random&#34;</span><span>)</span>
<span>    </span><span>assert</span><span>(</span><span>err</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;could not open /dev/random: %s&#34;</span><span>,</span><span> </span><span>err</span><span>))</span>
<span>    </span><span>defer</span><span> </span><span>f</span><span>.</span><span>Close</span><span>()</span>

<span>    </span><span>buf</span><span> </span><span>:=</span><span> </span><span>make</span><span>([]</span><span>byte</span><span>,</span><span> </span><span>16</span><span>)</span>
<span>    </span><span>n</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>f</span><span>.</span><span>Read</span><span>(</span><span>buf</span><span>)</span>
<span>    </span><span>assert</span><span>(</span><span>err</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;could not read 16 bytes from /dev/random: %s&#34;</span><span>,</span><span> </span><span>err</span><span>))</span>
<span>    </span><span>assert</span><span>(</span><span>n</span><span> </span><span>==</span><span> </span><span>len</span><span>(</span><span>buf</span><span>),</span><span> </span><span>&#34;expected 16 bytes from /dev/random&#34;</span><span>)</span>

<span>    </span><span>// Set bit 6 to 0</span>
<span>    </span><span>buf</span><span>[</span><span>8</span><span>]</span><span> </span><span>&amp;=</span><span> </span><span>^(</span><span>byte</span><span>(</span><span>1</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>6</span><span>)</span>
<span>    </span><span>// Set bit 7 to 1</span>
<span>    </span><span>buf</span><span>[</span><span>8</span><span>]</span><span> </span><span>|=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>7</span>

<span>    </span><span>// Set version</span>
<span>    </span><span>buf</span><span>[</span><span>6</span><span>]</span><span> </span><span>&amp;=</span><span> </span><span>^(</span><span>byte</span><span>(</span><span>1</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>4</span><span>)</span>
<span>    </span><span>buf</span><span>[</span><span>6</span><span>]</span><span> </span><span>&amp;=</span><span> </span><span>^(</span><span>byte</span><span>(</span><span>1</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>5</span><span>)</span>
<span>    </span><span>buf</span><span>[</span><span>6</span><span>]</span><span> </span><span>|=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>6</span>
<span>    </span><span>buf</span><span>[</span><span>6</span><span>]</span><span> </span><span>&amp;=</span><span> </span><span>^(</span><span>byte</span><span>(</span><span>1</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>7</span><span>)</span>

<span>    </span><span>return</span><span> </span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%x-%x-%x-%x-%x&#34;</span><span>,</span>
<span>        </span><span>buf</span><span>[:</span><span>4</span><span>],</span>
<span>        </span><span>buf</span><span>[</span><span>4</span><span>:</span><span>6</span><span>],</span>
<span>        </span><span>buf</span><span>[</span><span>6</span><span>:</span><span>8</span><span>],</span>
<span>        </span><span>buf</span><span>[</span><span>8</span><span>:</span><span>10</span><span>],</span>
<span>        </span><span>buf</span><span>[</span><span>10</span><span>:</span><span>16</span><span>])</span>
<span>}</span>
</pre></div>
<p>Is that uuid method correct? Hopefully. Efficient? No. But it&#39;s
preferable to avoid dependencies in pedagogical projects.</p>
<p>Moving on.</p>
<h3 id="blob-storage-requirements">Blob storage requirements</h3><p>As mentioned above, the basic requirement is that we support
atomically writing some bytes to a location if the location doesn&#39;t
already exist.</p>
<p>On top of that we also need the ability to list locations by prefix,
and the ability to read the bytes at some location.</p>
<p>
  We&#39;ll diverge from Delta Lake in how we name files on disk. For one,
  we&#39;ll keep all files in the same directory with a fixed prefix for
  metadata and another table name prefix for each data file. This
  simplifies the implementation of <code>listPrefix</code> a bit.
</p><p>So let&#39;s set up an interface to describe these requirements:</p>
<div><pre><span></span><span>type</span><span> </span><span>objectStorage</span><span> </span><span>interface</span><span> </span><span>{</span>
<span>    </span><span>// Must be atomic.</span>
<span>    </span><span>putIfAbsent</span><span>(</span><span>name</span><span> </span><span>string</span><span>,</span><span> </span><span>bytes</span><span> </span><span>[]</span><span>byte</span><span>)</span><span> </span><span>error</span>
<span>    </span><span>listPrefix</span><span>(</span><span>prefix</span><span> </span><span>string</span><span>)</span><span> </span><span>([]</span><span>string</span><span>,</span><span> </span><span>error</span><span>)</span>
<span>    </span><span>read</span><span>(</span><span>name</span><span> </span><span>string</span><span>)</span><span> </span><span>([]</span><span>byte</span><span>,</span><span> </span><span>error</span><span>)</span>
<span>}</span>
</pre></div>
<p>And this is literally all we need to get ACID transactions. That&#39;s crazy!</p>
<h4 id="atomic-put-and-cloud-blob-storage">Atomic Put and cloud blob storage</h4><p>We could implement the atomic <code>putIfAbsent</code> part of this interface in
2024 using <a href="https://aws.amazon.com/about-aws/whats-new/2024/08/amazon-s3-conditional-writes/">conditional
writes</a>
on S3. Or we could implement this interface with the <code>If-None-Match</code>
<a href="https://learn.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations">header</a>
on Azure Cloud Storage. Or we could implement this interface with the
<code>x-goog-if-generation-match</code>
<a href="https://cloud.google.com/storage/docs/xml-api/put-object">header</a> on
Google Cloud Storage.</p>
<p>Indeed a good exercise for the reader would be to implement this
interface for other blob storage providers and see your serverless
cloud database in action!</p>
<p>But the simplest method of all is to implement it on the filesystem,
which is what we&#39;ll do next.</p>
<h3 id="a-filesystem-blob-store">A filesystem blob store</h3><p>If we had a server we could implement atomic <code>putIfAbsent</code> with a
mutex. But we&#39;re serverless baby. Thankfully, POSIX <a href="https://rcrowley.org/2010/01/06/things-unix-can-do-atomically.html">supports atomic
file
creation</a>
if you open the file with <code>O_CREAT | O_EXCL</code>.</p>
<p>So we&#39;ll just open the file and write out all the bytes. If there is
an error at any point, we must remove the file.</p>
<div><pre><span></span><span>type</span><span> </span><span>fileObjectStorage</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>basedir</span><span> </span><span>string</span>
<span>}</span>

<span>func</span><span> </span><span>newFileObjectStorage</span><span>(</span><span>basedir</span><span> </span><span>string</span><span>)</span><span> </span><span>*</span><span>fileObjectStorage</span><span> </span><span>{</span>
<span>    </span><span>return</span><span> </span><span>&amp;</span><span>fileObjectStorage</span><span>{</span><span>basedir</span><span>}</span>
<span>}</span>

<span>func</span><span> </span><span>(</span><span>fos</span><span> </span><span>*</span><span>fileObjectStorage</span><span>)</span><span> </span><span>putIfAbsent</span><span>(</span><span>name</span><span> </span><span>string</span><span>,</span><span> </span><span>bytes</span><span> </span><span>[]</span><span>byte</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>filename</span><span> </span><span>:=</span><span> </span><span>path</span><span>.</span><span>Join</span><span>(</span><span>fos</span><span>.</span><span>basedir</span><span>,</span><span> </span><span>name</span><span>)</span>
<span>    </span><span>f</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>OpenFile</span><span>(</span><span>filename</span><span>,</span><span> </span><span>os</span><span>.</span><span>O_WRONLY</span><span>|</span><span>os</span><span>.</span><span>O_EXCL</span><span>|</span><span>os</span><span>.</span><span>O_CREATE</span><span>,</span><span> </span><span>0644</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>written</span><span> </span><span>:=</span><span> </span><span>0</span>
<span>    </span><span>bufSize</span><span> </span><span>:=</span><span> </span><span>1024</span><span> </span><span>*</span><span> </span><span>16</span>
<span>    </span><span>for</span><span> </span><span>written</span><span> </span><span>&lt;</span><span> </span><span>len</span><span>(</span><span>bytes</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>toWrite</span><span> </span><span>:=</span><span> </span><span>min</span><span>(</span><span>written</span><span>+</span><span>bufSize</span><span>,</span><span> </span><span>len</span><span>(</span><span>bytes</span><span>))</span>
<span>        </span><span>n</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>f</span><span>.</span><span>Write</span><span>(</span><span>bytes</span><span>[</span><span>written</span><span>:</span><span>toWrite</span><span>])</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>removeErr</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Remove</span><span>(</span><span>filename</span><span>)</span>
<span>            </span><span>assert</span><span>(</span><span>removeErr</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not remove&#34;</span><span>)</span>
<span>            </span><span>return</span><span> </span><span>err</span>
<span>        </span><span>}</span>

<span>        </span><span>written</span><span> </span><span>+=</span><span> </span><span>n</span>
<span>    </span><span>}</span>

<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>f</span><span>.</span><span>Sync</span><span>()</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>removeErr</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Remove</span><span>(</span><span>filename</span><span>)</span>
<span>        </span><span>assert</span><span>(</span><span>removeErr</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not remove&#34;</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>f</span><span>.</span><span>Close</span><span>()</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>removeErr</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Remove</span><span>(</span><span>filename</span><span>)</span>
<span>        </span><span>assert</span><span>(</span><span>removeErr</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not remove&#34;</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>return</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p><code>listPrefix</code> and <code>read</code> are minimal wrappers around filesystem APIs:</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>fos</span><span> </span><span>*</span><span>fileObjectStorage</span><span>)</span><span> </span><span>listPrefix</span><span>(</span><span>prefix</span><span> </span><span>string</span><span>)</span><span> </span><span>([]</span><span>string</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>dir</span><span> </span><span>:=</span><span> </span><span>path</span><span>.</span><span>Join</span><span>(</span><span>fos</span><span>.</span><span>basedir</span><span>)</span>
<span>    </span><span>f</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Open</span><span>(</span><span>dir</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>var</span><span> </span><span>files</span><span> </span><span>[]</span><span>string</span>
<span>    </span><span>for</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>io</span><span>.</span><span>EOF</span><span> </span><span>{</span>
<span>        </span><span>var</span><span> </span><span>names</span><span> </span><span>[]</span><span>string</span>
<span>        </span><span>names</span><span>,</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>f</span><span>.</span><span>Readdirnames</span><span>(</span><span>100</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>&amp;&amp;</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>io</span><span>.</span><span>EOF</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span>
<span>        </span><span>}</span>

<span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>n</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>names</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>prefix</span><span> </span><span>==</span><span> </span><span>&#34;&#34;</span><span> </span><span>||</span><span> </span><span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>n</span><span>,</span><span> </span><span>prefix</span><span>)</span><span> </span><span>{</span>
<span>                </span><span>files</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>files</span><span>,</span><span> </span><span>n</span><span>)</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>f</span><span>.</span><span>Close</span><span>()</span>
<span>    </span><span>return</span><span> </span><span>files</span><span>,</span><span> </span><span>err</span>
<span>}</span>

<span>func</span><span> </span><span>(</span><span>fos</span><span> </span><span>*</span><span>fileObjectStorage</span><span>)</span><span> </span><span>read</span><span>(</span><span>name</span><span> </span><span>string</span><span>)</span><span> </span><span>([]</span><span>byte</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>filename</span><span> </span><span>:=</span><span> </span><span>path</span><span>.</span><span>Join</span><span>(</span><span>fos</span><span>.</span><span>basedir</span><span>,</span><span> </span><span>name</span><span>)</span>
<span>    </span><span>return</span><span> </span><span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>filename</span><span>)</span>
<span>}</span>
</pre></div>
<p>It is worth talking a bit about reading a directory though. Go doesn&#39;t
provide a nice iterator API for us and I didn&#39;t want to implement this
as callbacks with
<a href="https://pkg.go.dev/path/filepath#WalkDir"><code>path/filepath.WalkDir</code></a>.</p>
<p>We could use <a href="https://pkg.go.dev/os#File.ReadDir"><code>os.File.ReadDir</code></a>
but it allocates for all files in the directory. Sure, in a
pedagogical project we don&#39;t worry about millions of files. But the
<code>ReadDir</code> API, the error cases in particular, also isn&#39;t much simpler
than <a href="https://pkg.go.dev/os#File.Readdirnames"><code>Readdirnames</code></a>.</p>
<p>
  What&#39;s more, even though we iterated through batches of directory
  entries, and did prefix filtering before accumulating, we still could
  have considered returning an iterator here ourselves. It seems
  possible and likely that the number of data files grows quite large in
  a production system. But I was lazy.
</p><p>It would be nice if Go introduced an actual iterator API for
reading a directory. :)</p>
<h4 id="delta-lake-and-stale-reads">Delta Lake and stale reads</h4><p>In any case the ACID properties of Delta Lake (and Iceberg) don&#39;t
depend on being able to read up-to-date data.</p>
<p>This is because concurrent (or stale) transactions that <em>write</em> will
<em>fail on commit</em>. And also because all files written (even metadata
files) are immutable.</p>
<p>Since all data is immutable, we will always be able to read at least a
consistent snapshot of data. But we will never be able to get
SERIALIZABLE <strong>read-only</strong> transactions. This is just how Delta Lake
and Iceberg work. And it is a <a href="https://jepsen.io/consistency">similar</a>
or better consistency level to what any major SQL database <a href="https://github.com/ept/hermitage">gives you
by default</a>.</p>
<p>You&#39;ll see what I mean later on when we implement transaction commits.</p>
<h3 id="transaction-boilerplate">Transaction boilerplate</h3><p>Now that we&#39;ve got a blob storage abstraction and a filesystem
implementation of it, let&#39;s start sketching out what a client and what
a transaction looks like.</p>
<p>In Delta Lake, a transaction consists of a list of actions. An action
might be to define a table&#39;s schema, or to add a data file, or to
remove a data file, etc. In this post we&#39;ll only implement the first
two actions.</p>
<div><pre><span></span><span>type</span><span> </span><span>DataobjectAction</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>Name</span><span>  </span><span>string</span>
<span>    </span><span>Table</span><span> </span><span>string</span>
<span>}</span>

<span>type</span><span> </span><span>ChangeMetadataAction</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>Table</span><span>   </span><span>string</span>
<span>    </span><span>Columns</span><span> </span><span>[]</span><span>string</span>
<span>}</span>

<span>// an enum, only one field will be non-nil</span>
<span>type</span><span> </span><span>Action</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>AddDataobject</span><span>  </span><span>*</span><span>DataobjectAction</span>
<span>    </span><span>ChangeMetadata</span><span> </span><span>*</span><span>ChangeMetadataAction</span>
<span>    </span><span>// TODO: Support object removal.</span>
<span>    </span><span>// DeleteDataobject *DataobjectAction</span>
<span>}</span>
</pre></div>
<p>These fields are all exported (i.e. capitalized, if you&#39;re not
familiar with Go) because we will be writing them to disk when the
transaction commits as the transaction&#39;s metadata.</p>
<p>In fact <code>Action</code>s and the transaction&#39;s id will be the only parts of
the transaction we write to disk. Everything else will be in-memory
state.</p>
<p>For our convenience we will track in memory a history of all previous
actions, a mapping of table columns, and a mapping of unflushed data
by table.</p>
<div><pre><span></span><span>type</span><span> </span><span>transaction</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>Id</span><span> </span><span>int</span>

<span>    </span><span>// Both are mapping table name to a list of actions on the table.</span>
<span>    </span><span>previousActions</span><span> </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>Action</span>
<span>    </span><span>Actions</span><span>         </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>Action</span>

<span>    </span><span>// Mapping tables to column names.</span>
<span>    </span><span>tables</span><span> </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>string</span>

<span>    </span><span>// Mapping table name to unflushed/in-memory rows. When rows</span>
<span>    </span><span>// are flushed, the dataobject that contains them is added to</span>
<span>    </span><span>// `tx.actions` above and `tx.unflushedDataPointer[table]` is</span>
<span>    </span><span>// reset to `0`.</span>
<span>    </span><span>unflushedData</span><span>        </span><span>map</span><span>[</span><span>string</span><span>]</span><span>*</span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span>
<span>    </span><span>unflushedDataPointer</span><span> </span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span>
<span>}</span>
</pre></div>
<p>Only the current <code>transaction</code> will ever have
<code>transaction.previousActions</code> filled out. <code>transaction.tables</code> will be
populated when the transaction starts by reading through
<code>transaction.previousActions</code> for <code>ChangeMetadataAction</code>s, and we will
also add onto it when we create a table in the current transaction.</p>
<p>We will append to <code>transaction.Actions</code> every time we write a new data
file and every time we create a new table.</p>
<p>We will add rows to <code>transaction.unflushedData</code> for a table until
<code>transaction.unflushedDataPointer</code> for that table reaches
<code>DATAOBJECT_SIZE</code> upon which time we will write that data to disk and
add a <code>DataobjectAction</code> entry to <code>transaction.Actions</code>.</p>
<h3 id="client-boilerplate">Client boilerplate</h3><p>A <code>client</code> will consistent of an <code>objectStorage</code> implementation and a
possibly empty <code>*transaction</code>. Empty meaning there is no current
transaction.</p>
<div><pre><span></span><span>type</span><span> </span><span>client</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>os</span><span> </span><span>objectStorage</span>
<span>    </span><span>// Current transaction, if any. Only one transaction per</span>
<span>    </span><span>// client at a time. All reads and writes must be within a</span>
<span>    </span><span>// transaction.</span>
<span>    </span><span>tx</span><span> </span><span>*</span><span>transaction</span>
<span>}</span>

<span>func</span><span> </span><span>newClient</span><span>(</span><span>os</span><span> </span><span>objectStorage</span><span>)</span><span> </span><span>client</span><span> </span><span>{</span>
<span>    </span><span>return</span><span> </span><span>client</span><span>{</span><span>os</span><span>,</span><span> </span><span>nil</span><span>}</span>
<span>}</span>

<span>var</span><span> </span><span>(</span>
<span>    </span><span>errExistingTx</span><span>  </span><span>=</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;Existing Transaction&#34;</span><span>)</span>
<span>    </span><span>errNoTx</span><span>        </span><span>=</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;No Transaction&#34;</span><span>)</span>
<span>    </span><span>errTableExists</span><span> </span><span>=</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;Table Exists&#34;</span><span>)</span>
<span>    </span><span>errNoTable</span><span>     </span><span>=</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;No Such Table&#34;</span><span>)</span>
<span>)</span>
</pre></div>
<h4 id="client-or-database?">Client or database?</h4><p>In a previous version of my code I named this <code>client</code> struct
<code>database</code>. But that&#39;s misleading. There is no central database. There
is just the client and the blob storage.</p>
<p>Clients work with transactions directly and only when attempting to
commit does the blob storage abstraction let the client know if the
transaction succeeded or not.</p>
<h3 id="starting-a-transaction">Starting a transaction</h3><p>When we start a transaction, we will first read all existing
transactions from disk and accumulate the actions from each prior
transaction.</p>
<p>We will interpret <code>ChangeMetadataAction</code>s and materialize them into a
current view of all tables.</p>
<p>And we will assign a transaction ID to this transaction to be 1
greater than the largest existing transaction ID we see.</p>
<p>Again it doesn&#39;t matter if the <code>listPrefix</code> call we use returns an
up-to-date list. Notably on blob storage there are few guarantees
about LIST operations recency. The Delta Lake paper mentions this too.</p>
<p>Out-of-date transactions attempting to write will be caught when we go
to commit the transaction. Out-of-date transactions attempting only to
read will still read a consistent snapshot.</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>newTx</span><span>()</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errExistingTx</span>
<span>    </span><span>}</span>

<span>    </span><span>logPrefix</span><span> </span><span>:=</span><span> </span><span>&#34;_log_&#34;</span>
<span>    </span><span>txLogFilenames</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>os</span><span>.</span><span>listPrefix</span><span>(</span><span>logPrefix</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>tx</span><span> </span><span>:=</span><span> </span><span>&amp;</span><span>transaction</span><span>{}</span>
<span>    </span><span>tx</span><span>.</span><span>previousActions</span><span> </span><span>=</span><span> </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>Action</span><span>{}</span>
<span>    </span><span>tx</span><span>.</span><span>Actions</span><span> </span><span>=</span><span> </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>Action</span><span>{}</span>
<span>    </span><span>tx</span><span>.</span><span>tables</span><span> </span><span>=</span><span> </span><span>map</span><span>[</span><span>string</span><span>][]</span><span>string</span><span>{}</span>
<span>    </span><span>tx</span><span>.</span><span>unflushedData</span><span> </span><span>=</span><span> </span><span>map</span><span>[</span><span>string</span><span>]</span><span>*</span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span><span>{}</span>
<span>    </span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span> </span><span>=</span><span> </span><span>map</span><span>[</span><span>string</span><span>]</span><span>int</span><span>{}</span>

<span>    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>txLogFilename</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>txLogFilenames</span><span> </span><span>{</span>
<span>        </span><span>bytes</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>os</span><span>.</span><span>read</span><span>(</span><span>txLogFilename</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>err</span>
<span>        </span><span>}</span>

<span>        </span><span>var</span><span> </span><span>oldTx</span><span> </span><span>transaction</span>
<span>        </span><span>err</span><span> </span><span>=</span><span> </span><span>json</span><span>.</span><span>Unmarshal</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>&amp;</span><span>oldTx</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>err</span>
<span>        </span><span>}</span>
<span>        </span><span>// Transaction metadata files are sorted</span>
<span>        </span><span>// lexicographically so that the most recent</span>
<span>        </span><span>// transaction (i.e. the one with the largest</span>
<span>        </span><span>// transaction id) will be last and tx.Id will end up</span>
<span>        </span><span>// 1 greater than the most recent transaction ID we</span>
<span>        </span><span>// see on disk.</span>
<span>        </span><span>tx</span><span>.</span><span>Id</span><span> </span><span>=</span><span> </span><span>oldTx</span><span>.</span><span>Id</span><span> </span><span>+</span><span> </span><span>1</span>

<span>        </span><span>for</span><span> </span><span>table</span><span>,</span><span> </span><span>actions</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>oldTx</span><span>.</span><span>Actions</span><span> </span><span>{</span>
<span>            </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>action</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>actions</span><span> </span><span>{</span>
<span>                </span><span>if</span><span> </span><span>action</span><span>.</span><span>AddDataobject</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>                    </span><span>tx</span><span>.</span><span>previousActions</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>tx</span><span>.</span><span>previousActions</span><span>[</span><span>table</span><span>],</span><span> </span><span>action</span><span>)</span>
<span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>action</span><span>.</span><span>ChangeMetadata</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>                    </span><span>// Store the latest version of</span>
<span>                    </span><span>// each table in memory for</span>
<span>                    </span><span>// easy lookup.</span>
<span>                    </span><span>mtd</span><span> </span><span>:=</span><span> </span><span>action</span><span>.</span><span>ChangeMetadata</span>
<span>                    </span><span>tx</span><span>.</span><span>tables</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>mtd</span><span>.</span><span>Columns</span>
<span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>                    </span><span>panic</span><span>(</span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;unsupported action: %v&#34;</span><span>,</span><span> </span><span>action</span><span>))</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>d</span><span>.</span><span>tx</span><span> </span><span>=</span><span> </span><span>tx</span>
<span>    </span><span>return</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>And we&#39;re set.</p>
<h3 id="creating-a-table">Creating a table</h3><p>When we create a table, we need to add a <code>ChangeMetadataAction</code> to the
transactions <code>Actions</code>. And we also want to add the table info to the
in-memory <code>transaction.tables</code> field.</p>
<p>We don&#39;t do any of this durably. The change here will be written to
disk on commit (if the transaction succeeds).</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>createTable</span><span>(</span><span>table</span><span> </span><span>string</span><span>,</span><span> </span><span>columns</span><span> </span><span>[]</span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errNoTx</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>_</span><span>,</span><span> </span><span>exists</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>tables</span><span>[</span><span>table</span><span>];</span><span> </span><span>exists</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errTableExists</span>
<span>    </span><span>}</span>

<span>    </span><span>// Store it in the in-memory mapping.</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>tables</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>columns</span>

<span>    </span><span>// And also add it to the action history for future transactions.</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span>[</span><span>table</span><span>],</span><span> </span><span>Action</span><span>{</span>
<span>        </span><span>ChangeMetadata</span><span>:</span><span> </span><span>&amp;</span><span>ChangeMetadataAction</span><span>{</span>
<span>            </span><span>Table</span><span>:</span><span>   </span><span>table</span><span>,</span>
<span>            </span><span>Columns</span><span>:</span><span> </span><span>columns</span><span>,</span>
<span>        </span><span>},</span>
<span>    </span><span>})</span>

<span>    </span><span>return</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>Easy peasy. Now for the fun part, writing data!</p>
<h3 id="writing-a-row">Writing a row</h3><p>This is the next area where we&#39;ll diverge from Delta Lake. For the
sake of zero dependencies we are going to store data in-memory as an
array of array of <code>any</code>. And when we later write rows to disk we&#39;ll
write them as JSON. A real Delta Lake implementation would store data
in-memory in Apache Arrow format, and write to disk as Parquet.</p>
<p>In line with Delta Lake though we will buffer data in memory until we
get 64K rows. When we get 64K rows for a particular table we will
flush all those rows to disk. (When we go to commit a transaction we
will flush any outstanding rows.)</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>writeRow</span><span>(</span><span>table</span><span> </span><span>string</span><span>,</span><span> </span><span>row</span><span> </span><span>[]</span><span>any</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errNoTx</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>_</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>tables</span><span>[</span><span>table</span><span>];</span><span> </span><span>!</span><span>ok</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errNoTable</span>
<span>    </span><span>}</span>

<span>    </span><span>// Try to find an unflushed/in-memory dataobject for this table</span>
<span>    </span><span>pointer</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>]</span>
<span>    </span><span>if</span><span> </span><span>!</span><span>ok</span><span> </span><span>{</span>
<span>        </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span>
<span>        </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedData</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span><span>{}</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>pointer</span><span> </span><span>==</span><span> </span><span>DATAOBJECT_SIZE</span><span> </span><span>{</span>
<span>        </span><span>d</span><span>.</span><span>flushRows</span><span>(</span><span>table</span><span>)</span>
<span>        </span><span>pointer</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>}</span>

<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedData</span><span>[</span><span>table</span><span>][</span><span>pointer</span><span>]</span><span> </span><span>=</span><span> </span><span>row</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>]</span><span>++</span>
<span>    </span><span>return</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>Now let&#39;s implement flushing.</p>
<h3 id="flushing-a-data-object">Flushing a data object</h3><p>Recall that data objects in Delta Lake (and Iceberg) are
immutable. Once we&#39;ve got enough data to write a data object, we give
it a unique name, write it to disk, and add a <code>AddObjectAction</code> to the
transaction&#39;s list of <code>Actions</code>.</p>
<div><pre><span></span><span>type</span><span> </span><span>dataobject</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>Table</span><span> </span><span>string</span>
<span>    </span><span>Name</span><span>  </span><span>string</span>
<span>    </span><span>Data</span><span>  </span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span>
<span>    </span><span>Len</span><span>   </span><span>int</span>
<span>}</span>

<span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>flushRows</span><span>(</span><span>table</span><span> </span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errNoTx</span>
<span>    </span><span>}</span>

<span>    </span><span>// First write out dataobject if there is anything to write out.</span>
<span>    </span><span>pointer</span><span>,</span><span> </span><span>exists</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>]</span>
<span>    </span><span>if</span><span> </span><span>!</span><span>exists</span><span> </span><span>||</span><span> </span><span>pointer</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>nil</span>
<span>    </span><span>}</span>

<span>    </span><span>df</span><span> </span><span>:=</span><span> </span><span>dataobject</span><span>{</span>
<span>        </span><span>Table</span><span>:</span><span> </span><span>table</span><span>,</span>
<span>        </span><span>Name</span><span>:</span><span>  </span><span>uuidv4</span><span>(),</span>
<span>        </span><span>Data</span><span>:</span><span>  </span><span>*</span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedData</span><span>[</span><span>table</span><span>],</span>
<span>        </span><span>Len</span><span>:</span><span>   </span><span>pointer</span><span>,</span>
<span>    </span><span>}</span>
<span>    </span><span>bytes</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>json</span><span>.</span><span>Marshal</span><span>(</span><span>df</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>d</span><span>.</span><span>os</span><span>.</span><span>putIfAbsent</span><span>(</span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;_table_%s_%s&#34;</span><span>,</span><span> </span><span>table</span><span>,</span><span> </span><span>df</span><span>.</span><span>Name</span><span>),</span><span> </span><span>bytes</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>// Then record the newly written data file.</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span>[</span><span>table</span><span>],</span><span> </span><span>Action</span><span>{</span>
<span>        </span><span>AddDataobject</span><span>:</span><span> </span><span>&amp;</span><span>DataobjectAction</span><span>{</span>
<span>            </span><span>Table</span><span>:</span><span> </span><span>table</span><span>,</span>
<span>            </span><span>Name</span><span>:</span><span>  </span><span>df</span><span>.</span><span>Name</span><span>,</span>
<span>        </span><span>},</span>
<span>    </span><span>})</span>

<span>    </span><span>// Reset in-memory pointer.</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>return</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>That&#39;s it for writing data! Let&#39;s now look at reading data.</p>
<h3 id="scanning-a-table">Scanning a table</h3><p>We&#39;re going to make scanning mildly more complicated than it needed to
be in pedagogical code because we&#39;ll have <code>client.scan()</code> return an
iterator rather than an array with all rows.</p>
<p>The <code>scanIterator</code> will first read from in-memory (unflushed)
data. And then it will read through every data object for the table
that is still a part of this transaction. We will know which data
objects are still a part of this transaction by reading through all
<code>AddDataobject</code> actions. A future version of this project would also
eliminate data object files from the list by observing
<code>DeleteDataobject</code> actions. But we don&#39;t do that in this post.</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>scan</span><span>(</span><span>table</span><span> </span><span>string</span><span>)</span><span> </span><span>(</span><span>*</span><span>scanIterator</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>errNoTx</span>
<span>    </span><span>}</span>

<span>    </span><span>var</span><span> </span><span>dataobjects</span><span> </span><span>[]</span><span>string</span>
<span>    </span><span>allActions</span><span> </span><span>:=</span><span> </span><span>append</span><span>(</span><span>d</span><span>.</span><span>tx</span><span>.</span><span>previousActions</span><span>[</span><span>table</span><span>],</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span>[</span><span>table</span><span>]</span><span>...</span><span>)</span>
<span>    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>action</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>allActions</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>action</span><span>.</span><span>AddDataobject</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>dataobjects</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>dataobjects</span><span>,</span><span> </span><span>action</span><span>.</span><span>AddDataobject</span><span>.</span><span>Name</span><span>)</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>var</span><span> </span><span>unflushedRows</span><span> </span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span>
<span>    </span><span>if</span><span> </span><span>data</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedData</span><span>[</span><span>table</span><span>];</span><span> </span><span>ok</span><span> </span><span>{</span>
<span>        </span><span>unflushedRows</span><span> </span><span>=</span><span> </span><span>*</span><span>data</span>
<span>    </span><span>}</span>

<span>    </span><span>return</span><span> </span><span>&amp;</span><span>scanIterator</span><span>{</span>
<span>        </span><span>unflushedRows</span><span>:</span><span>    </span><span>unflushedRows</span><span>,</span>
<span>        </span><span>unflushedRowsLen</span><span>:</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>unflushedDataPointer</span><span>[</span><span>table</span><span>],</span>
<span>        </span><span>d</span><span>:</span><span>                </span><span>d</span><span>,</span>
<span>        </span><span>table</span><span>:</span><span>            </span><span>table</span><span>,</span>
<span>        </span><span>dataobjects</span><span>:</span><span>      </span><span>dataobjects</span><span>,</span>
<span>    </span><span>},</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>The <code>scanIterator</code> needs to track where we are in in-memory rows, in
data objects, and within a particular data object.</p>
<div><pre><span></span><span>type</span><span> </span><span>scanIterator</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>d</span><span>     </span><span>*</span><span>client</span>
<span>    </span><span>table</span><span> </span><span>string</span>

<span>    </span><span>// First we iterate through unflushed rows.</span>
<span>    </span><span>unflushedRows</span><span>       </span><span>[</span><span>DATAOBJECT_SIZE</span><span>][]</span><span>any</span>
<span>    </span><span>unflushedRowsLen</span><span>    </span><span>int</span>
<span>    </span><span>unflushedRowPointer</span><span> </span><span>int</span>

<span>    </span><span>// Then we move through each dataobject.</span>
<span>    </span><span>dataobjects</span><span>        </span><span>[]</span><span>string</span>
<span>    </span><span>dataobjectsPointer</span><span> </span><span>int</span>

<span>    </span><span>// And within each dataobject we iterate through rows.</span>
<span>    </span><span>dataobject</span><span>           </span><span>*</span><span>dataobject</span>
<span>    </span><span>dataobjectRowPointer</span><span> </span><span>int</span>
<span>}</span>
</pre></div>
<p>And the <code>scanIterator</code> will be driven by a <code>next()</code> method that goes
through in-memory data first and then through what&#39;s on disk.</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>readDataobject</span><span>(</span><span>table</span><span>,</span><span> </span><span>name</span><span> </span><span>string</span><span>)</span><span> </span><span>(</span><span>*</span><span>dataobject</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>bytes</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>os</span><span>.</span><span>read</span><span>(</span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;_table_%s_%s&#34;</span><span>,</span><span> </span><span>table</span><span>,</span><span> </span><span>name</span><span>))</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>var</span><span> </span><span>do</span><span> </span><span>dataobject</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>json</span><span>.</span><span>Unmarshal</span><span>(</span><span>bytes</span><span>,</span><span> </span><span>&amp;</span><span>do</span><span>)</span>
<span>    </span><span>return</span><span> </span><span>&amp;</span><span>do</span><span>,</span><span> </span><span>err</span>
<span>}</span>

<span>// returns (nil, nil) when done</span>
<span>func</span><span> </span><span>(</span><span>si</span><span> </span><span>*</span><span>scanIterator</span><span>)</span><span> </span><span>next</span><span>()</span><span> </span><span>([]</span><span>any</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>// Iterate through in-memory rows first.</span>
<span>    </span><span>if</span><span> </span><span>si</span><span>.</span><span>unflushedRowPointer</span><span> </span><span>&lt;</span><span> </span><span>si</span><span>.</span><span>unflushedRowsLen</span><span> </span><span>{</span>
<span>        </span><span>row</span><span> </span><span>:=</span><span> </span><span>si</span><span>.</span><span>unflushedRows</span><span>[</span><span>si</span><span>.</span><span>unflushedRowPointer</span><span>]</span>
<span>        </span><span>si</span><span>.</span><span>unflushedRowPointer</span><span>++</span>
<span>        </span><span>return</span><span> </span><span>row</span><span>,</span><span> </span><span>nil</span>
<span>    </span><span>}</span>

<span>    </span><span>// If we&#39;ve gotten through all dataobjects on disk we&#39;re done.</span>
<span>    </span><span>if</span><span> </span><span>si</span><span>.</span><span>dataobjectsPointer</span><span> </span><span>==</span><span> </span><span>len</span><span>(</span><span>si</span><span>.</span><span>dataobjects</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>nil</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>si</span><span>.</span><span>dataobject</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>name</span><span> </span><span>:=</span><span> </span><span>si</span><span>.</span><span>dataobjects</span><span>[</span><span>si</span><span>.</span><span>dataobjectsPointer</span><span>]</span>
<span>        </span><span>o</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>si</span><span>.</span><span>d</span><span>.</span><span>readDataobject</span><span>(</span><span>si</span><span>.</span><span>table</span><span>,</span><span> </span><span>name</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span>
<span>        </span><span>}</span>

<span>        </span><span>si</span><span>.</span><span>dataobject</span><span> </span><span>=</span><span> </span><span>o</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>si</span><span>.</span><span>dataobjectRowPointer</span><span> </span><span>&gt;</span><span> </span><span>si</span><span>.</span><span>dataobject</span><span>.</span><span>Len</span><span> </span><span>{</span>
<span>        </span><span>si</span><span>.</span><span>dataobjectsPointer</span><span>++</span>
<span>        </span><span>si</span><span>.</span><span>dataobject</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>        </span><span>si</span><span>.</span><span>dataobjectRowPointer</span><span> </span><span>=</span><span> </span><span>0</span>
<span>        </span><span>return</span><span> </span><span>si</span><span>.</span><span>next</span><span>()</span>
<span>    </span><span>}</span>

<span>    </span><span>row</span><span> </span><span>:=</span><span> </span><span>si</span><span>.</span><span>dataobject</span><span>.</span><span>Data</span><span>[</span><span>si</span><span>.</span><span>dataobjectRowPointer</span><span>]</span>
<span>    </span><span>si</span><span>.</span><span>dataobjectRowPointer</span><span>++</span>
<span>    </span><span>return</span><span> </span><span>row</span><span>,</span><span> </span><span>nil</span>
<span>}</span>
</pre></div>
<p>That&#39;s it for scanning a table! The final piece of the puzzle is
committing a transaction.</p>
<h3 id="committing-a-transaction">Committing a transaction</h3><p>When we commit a transaction we must flush any remaining data. A
read-only transaction (one which has no <code>Actions</code>) is immediately
done. There is no concurrency check.</p>
<p>Otherwise we will serialize transaction state and attempt to
atomically <code>putIfAbsent</code>.</p>
<p>The only way this will fail is if there is another concurrent writer.</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span>client</span><span>)</span><span> </span><span>commitTx</span><span>()</span><span> </span><span>error</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>d</span><span>.</span><span>tx</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>errNoTx</span>
<span>    </span><span>}</span>

<span>    </span><span>// Flush any outstanding data</span>
<span>    </span><span>for</span><span> </span><span>table</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>tables</span><span> </span><span>{</span>
<span>        </span><span>err</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>flushRows</span><span>(</span><span>table</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>d</span><span>.</span><span>tx</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>            </span><span>return</span><span> </span><span>err</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>wrote</span><span> </span><span>:=</span><span> </span><span>false</span>
<span>    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>actions</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Actions</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>len</span><span>(</span><span>actions</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span>
<span>            </span><span>wrote</span><span> </span><span>=</span><span> </span><span>true</span>
<span>            </span><span>break</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>// Read-only transaction, no need to do a concurrency check.</span>
<span>    </span><span>if</span><span> </span><span>!</span><span>wrote</span><span> </span><span>{</span>
<span>        </span><span>d</span><span>.</span><span>tx</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>        </span><span>return</span><span> </span><span>nil</span>
<span>    </span><span>}</span>

<span>    </span><span>filename</span><span> </span><span>:=</span><span> </span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;_log_%020d&#34;</span><span>,</span><span> </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>Id</span><span>)</span>
<span>    </span><span>// We won&#39;t store previous actions, they will be recovered on</span>
<span>    </span><span>// new transactions. So unset them. Honestly not totally</span>
<span>    </span><span>// clear why.</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span>.</span><span>previousActions</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>    </span><span>bytes</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>json</span><span>.</span><span>Marshal</span><span>(</span><span>d</span><span>.</span><span>tx</span><span>)</span>
<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>d</span><span>.</span><span>tx</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>        </span><span>return</span><span> </span><span>err</span>
<span>    </span><span>}</span>

<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>d</span><span>.</span><span>os</span><span>.</span><span>putIfAbsent</span><span>(</span><span>filename</span><span>,</span><span> </span><span>bytes</span><span>)</span>
<span>    </span><span>d</span><span>.</span><span>tx</span><span> </span><span>=</span><span> </span><span>nil</span>
<span>    </span><span>return</span><span> </span><span>err</span>
<span>}</span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>panic</span><span>(</span><span>&#34;unimplemented&#34;</span><span>)</span>
<span>}</span>
</pre></div>
<p>This is the crux of Delta Lake. It&#39;s simple. And honestly it&#39;s a bit
shocking. Real Delta Lake does support automatic retries in some
cases. But primarily you are limited to a single writer per table,
even if the writers are writing non-conflicting rows. Iceberg is
basically the same here, it&#39;s just how metadata is tracked that
differs.</p>
<p>The Delta Lake and Iceberg folks apparently wanted to avoid
FoundationDB (i.e. the Snowflake architecture, which is mentioned in
the Delta Lake paper) so much that they&#39;d give up row-level
concurrency to be mostly serverless.</p>
<p>Is it worth it? Dunno. Delta Lake and Iceberg are getting massive
adoption. Many very smart people have worked, and continue to work, on
both. Moreover it is apparently what the market wants. Every
database-like product is implementing, or is planning to implement,
Delta Lake or Iceberg.</p>
<h3 id="trying-it-out">Trying it out</h3><p>Let&#39;s add a test in <code>main_test.go</code> to see what happens with concurrent
writers. Follow the comments and debug logs for details:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span>

<span>import</span><span> </span><span>(</span>
<span>    </span><span>&#34;os&#34;</span>
<span>    </span><span>&#34;testing&#34;</span>
<span>)</span>

<span>func</span><span> </span><span>TestConcurrentTableWriters</span><span>(</span><span>t</span><span> </span><span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>dir</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>MkdirTemp</span><span>(</span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;test-database&#34;</span><span>)</span>

<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>panic</span><span>(</span><span>err</span><span>)</span>
<span>    </span><span>}</span>

<span>    </span><span>defer</span><span> </span><span>os</span><span>.</span><span>Remove</span><span>(</span><span>dir</span><span>)</span>

<span>    </span><span>fos</span><span> </span><span>:=</span><span> </span><span>newFileObjectStorage</span><span>(</span><span>dir</span><span>)</span>
<span>    </span><span>c1Writer</span><span> </span><span>:=</span><span> </span><span>newClient</span><span>(</span><span>fos</span><span>)</span>
<span>    </span><span>c2Writer</span><span> </span><span>:=</span><span> </span><span>newClient</span><span>(</span><span>fos</span><span>)</span>

<span>    </span><span>// Have c2Writer start up a transaction.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Writer</span><span>.</span><span>newTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not start first c2 tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2] new tx&#34;</span><span>)</span>

<span>    </span><span>// But then have c1Writer start a transaction and commit it first.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>newTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not start first c1 tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1] new tx&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>createTable</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>string</span><span>{</span><span>&#34;a&#34;</span><span>,</span><span> </span><span>&#34;b&#34;</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not create x&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1] Created table&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Joey&#34;</span><span>,</span><span> </span><span>1</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write first row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1] Wrote row&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Yue&#34;</span><span>,</span><span> </span><span>2</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write second row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1] Wrote row&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>commitTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not commit tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1] Committed tx&#34;</span><span>)</span>

<span>    </span><span>// Now go back to c2 and write data.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Writer</span><span>.</span><span>createTable</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>string</span><span>{</span><span>&#34;a&#34;</span><span>,</span><span> </span><span>&#34;b&#34;</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not create x&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2] Created table&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Holly&#34;</span><span>,</span><span> </span><span>1</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write first row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2] Wrote row&#34;</span><span>)</span>

<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Writer</span><span>.</span><span>commitTx</span><span>()</span>
<span>    </span><span>assert</span><span>(</span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;concurrent commit must fail&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2] tx not committed&#34;</span><span>)</span>
<span>}</span>
</pre></div>
<p>Try it out:</p>
<div><pre><span></span><span>$ </span>go<span> </span>mod<span> </span>init<span> </span>otf
<span>$ </span>go<span> </span>mod<span> </span>tidy
<span>$ </span>go<span> </span><span>test</span><span> </span>-run<span> </span>TestConcurrentTableWriters<span> </span>--<span> </span>--debug
<span>[DEBUG] [c2] new tx</span>
<span>[DEBUG] [c1] new tx</span>
<span>[DEBUG] [c1] Created table</span>
<span>[DEBUG] [c1] Wrote row</span>
<span>[DEBUG] [c1] Wrote row</span>
<span>[DEBUG] [c1] Committed tx</span>
<span>[DEBUG] [c2] Created table</span>
<span>[DEBUG] [c2] Wrote row</span>
<span>[DEBUG] [c2] tx not committed</span>
<span>PASS</span>
<span>ok      otf 0.311s</span>
</pre></div>
<p>That&#39;s pretty cool.</p>
<p>And what about a reader and concurrent writer? Observe that the reader
always reads a snapshot. Follow the comments again for detail:</p>
<div><pre><span></span><span>func</span><span> </span><span>TestConcurrentReaderWithWriterReadsSnapshot</span><span>(</span><span>t</span><span> </span><span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>dir</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>MkdirTemp</span><span>(</span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;test-database&#34;</span><span>)</span>

<span>    </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>        </span><span>panic</span><span>(</span><span>err</span><span>)</span>
<span>    </span><span>}</span>

<span>    </span><span>defer</span><span> </span><span>os</span><span>.</span><span>Remove</span><span>(</span><span>dir</span><span>)</span>

<span>    </span><span>fos</span><span> </span><span>:=</span><span> </span><span>newFileObjectStorage</span><span>(</span><span>dir</span><span>)</span>
<span>    </span><span>c1Writer</span><span> </span><span>:=</span><span> </span><span>newClient</span><span>(</span><span>fos</span><span>)</span>
<span>    </span><span>c2Reader</span><span> </span><span>:=</span><span> </span><span>newClient</span><span>(</span><span>fos</span><span>)</span>

<span>    </span><span>// First create some data and commit the transaction.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>newTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not start first c1 tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Started tx&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>createTable</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>string</span><span>{</span><span>&#34;a&#34;</span><span>,</span><span> </span><span>&#34;b&#34;</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not create x&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Created table&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Joey&#34;</span><span>,</span><span> </span><span>1</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write first row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Wrote row&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Yue&#34;</span><span>,</span><span> </span><span>2</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write second row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Wrote row&#34;</span><span>)</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>commitTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not commit tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Committed tx&#34;</span><span>)</span>

<span>    </span><span>// Now start a new transaction for more edits.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>newTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not start second c1 tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Starting new write tx&#34;</span><span>)</span>

<span>    </span><span>// Before we commit this second write-transaction, start a</span>
<span>    </span><span>// read transaction.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Reader</span><span>.</span><span>newTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not start c2 tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2Reader] Started tx&#34;</span><span>)</span>

<span>    </span><span>// Write and commit rows in c1.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>writeRow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span> </span><span>[]</span><span>any</span><span>{</span><span>&#34;Ada&#34;</span><span>,</span><span> </span><span>3</span><span>})</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not write third row&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Wrote third row&#34;</span><span>)</span>

<span>    </span><span>// Scan x in read-only transaction</span>
<span>    </span><span>it</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>c2Reader</span><span>.</span><span>scan</span><span>(</span><span>&#34;x&#34;</span><span>)</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not scan x&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2Reader] Started scanning&#34;</span><span>)</span>
<span>    </span><span>seen</span><span> </span><span>:=</span><span> </span><span>0</span>
<span>    </span><span>for</span><span> </span><span>{</span>
<span>        </span><span>row</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>it</span><span>.</span><span>next</span><span>()</span>
<span>        </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not iterate x scan&#34;</span><span>)</span>

<span>        </span><span>if</span><span> </span><span>row</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>debug</span><span>(</span><span>&#34;[c2Reader] Done scanning&#34;</span><span>)</span>
<span>            </span><span>break</span>
<span>        </span><span>}</span>

<span>        </span><span>debug</span><span>(</span><span>&#34;[c2Reader] Got row in reader tx&#34;</span><span>,</span><span> </span><span>row</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>seen</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>0</span><span>],</span><span> </span><span>&#34;Joey&#34;</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>1</span><span>],</span><span> </span><span>1.0</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>0</span><span>],</span><span> </span><span>&#34;Yue&#34;</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>1</span><span>],</span><span> </span><span>2.0</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>        </span><span>}</span>

<span>        </span><span>seen</span><span>++</span>
<span>    </span><span>}</span>
<span>    </span><span>assertEq</span><span>(</span><span>seen</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>&#34;expected two rows&#34;</span><span>)</span>

<span>    </span><span>// Scan x in c1 write transaction</span>
<span>    </span><span>it</span><span>,</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>scan</span><span>(</span><span>&#34;x&#34;</span><span>)</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not scan x in c1&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Started scanning&#34;</span><span>)</span>
<span>    </span><span>seen</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>for</span><span> </span><span>{</span>
<span>        </span><span>row</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>it</span><span>.</span><span>next</span><span>()</span>
<span>        </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not iterate x scan in c1&#34;</span><span>)</span>

<span>        </span><span>if</span><span> </span><span>row</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span>
<span>            </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Done scanning&#34;</span><span>)</span>
<span>            </span><span>break</span>
<span>        </span><span>}</span>

<span>        </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Got row in tx&#34;</span><span>,</span><span> </span><span>row</span><span>)</span>

<span>        </span><span>if</span><span> </span><span>seen</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>0</span><span>],</span><span> </span><span>&#34;Ada&#34;</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>            </span><span>// Since this hasn&#39;t been serialized to JSON, it&#39;s still an int not a float.</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>1</span><span>],</span><span> </span><span>3</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>seen</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>0</span><span>],</span><span> </span><span>&#34;Joey&#34;</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>1</span><span>],</span><span> </span><span>1.0</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>0</span><span>],</span><span> </span><span>&#34;Yue&#34;</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>            </span><span>assertEq</span><span>(</span><span>row</span><span>[</span><span>1</span><span>],</span><span> </span><span>2.0</span><span>,</span><span> </span><span>&#34;row mismatch in c1&#34;</span><span>)</span>
<span>        </span><span>}</span>

<span>        </span><span>seen</span><span>++</span>
<span>    </span><span>}</span>
<span>    </span><span>assertEq</span><span>(</span><span>seen</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>&#34;expected three rows&#34;</span><span>)</span>

<span>    </span><span>// Writer committing should succeed.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c1Writer</span><span>.</span><span>commitTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not commit second tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c1Writer] Committed tx&#34;</span><span>)</span>

<span>    </span><span>// Reader committing should succeed.</span>
<span>    </span><span>err</span><span> </span><span>=</span><span> </span><span>c2Reader</span><span>.</span><span>commitTx</span><span>()</span>
<span>    </span><span>assertEq</span><span>(</span><span>err</span><span>,</span><span> </span><span>nil</span><span>,</span><span> </span><span>&#34;could not commit read-only tx&#34;</span><span>)</span>
<span>    </span><span>debug</span><span>(</span><span>&#34;[c2Reader] Committed tx&#34;</span><span>)</span>
<span>}</span>
</pre></div>
<p>Run it:</p>
<div><pre><span></span><span>$ </span>go<span> </span><span>test</span><span> </span>-run<span> </span>TestConcurrentReaderWithWriterReadsSnapshot<span> </span>--<span> </span>--debug
<span>[DEBUG] [c1Writer] Started tx</span>
<span>[DEBUG] [c1Writer] Created table</span>
<span>[DEBUG] [c1Writer] Wrote row</span>
<span>[DEBUG] [c1Writer] Wrote row</span>
<span>[DEBUG] [c1Writer] Committed tx</span>
<span>[DEBUG] [c1Writer] Starting new write tx</span>
<span>[DEBUG] [c2Reader] Started tx</span>
<span>[DEBUG] [c1Writer] Wrote third row</span>
<span>[DEBUG] [c2Reader] Started scanning</span>
<span>[DEBUG] [c2Reader] Got row in reader tx [Joey 1]</span>
<span>[DEBUG] [c2Reader] Got row in reader tx [Yue 2]</span>
<span>[DEBUG] [c2Reader] Done scanning</span>
<span>[DEBUG] [c1Writer] Started scanning</span>
<span>[DEBUG] [c1Writer] Got row in tx [Ada 3]</span>
<span>[DEBUG] [c1Writer] Got row in tx [Joey 1]</span>
<span>[DEBUG] [c1Writer] Got row in tx [Yue 2]</span>
<span>[DEBUG] [c1Writer] Done scanning</span>
<span>[DEBUG] [c1Writer] Committed tx</span>
<span>[DEBUG] [c2Reader] Committed tx</span>
<span>PASS</span>
<span>ok      otf 0.252s</span>
</pre></div>
<p>Sweet.</p>
<h3 id="what&#39;s-next?">What&#39;s next?</h3><p>As mentioned, we didn&#39;t touch a lot of things. Handling updates and
deletes, transaction log checkpoints, data object compaction, etc.</p>
<p>Take a close look at the <a href="https://www.vldb.org/pvldb/vol13/p3411-armbrust.pdf">Delta Lake
paper</a> and the
<a href="https://github.com/delta-io/delta/blob/master/PROTOCOL.md">Delta Lake
Spec</a> and
see what you can do!</p>
<blockquote><p lang="en" dir="ltr">Build a serverless ACID database with this one neat trick.</p> Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1840474893491560777?ref_src=twsrc%5Etfw">September 29, 2024</a></blockquote> 

	</div></div>
  </body>
</html>
