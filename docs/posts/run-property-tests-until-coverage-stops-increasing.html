<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html">Original</a>
    <h1>Run property tests until coverage stops increasing</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
	    

	    <p>
    Posted on July 30, 2023
    
</p>

<p><img src="https://www.bitecode.dev/images/dreprun.png"/></p>

<p>I like <a href="https://en.wikipedia.org/wiki/Property_testing">property based testing</a>.</p>
<p>Your code generates a random input and then checks whether the property holds true for your code.</p>
<p>An example of a simple property is something like “the length of a list should be the same after sorting the list”.</p>

<p>How many random inputs do you feed to your property and call that enough?</p>
<p>I asked <a href="https://github.com/cdsmith/">a friend</a> this exact question and he said “turn on <a href="https://wiki.haskell.org/Haskell_program_coverage">Haskell program coverage</a> and see how much of your code was executed”.</p>
<p><img src="https://www.bitecode.dev/images/hpc.gif"/></p>
<p>That seemed really manual, I don’t want to be the human in the loop when the computer is doing useful things for me.</p>
<p>I decided to come up with a way to connect the code coverage tool to the property test runner.</p>

<p>The final idea was “keep running property tests until coverage stops increasing”.</p>
<p>The hpc tool creates a tree of regions for all the source in your program. When a region is executed, its execution count is increased by one.</p>
<p>I chose to map each of those regions to a boolean value describing how much of the program’s source has been executed.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>-- | How many regions were executed at least once for this module?</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>tixCount ::</span> <span>TixModule</span> <span>-&gt;</span> <span>Integer</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>tixCount (<span>TixModule</span> _ _ _ regions) <span>=</span> <span>sum</span> <span>$</span> <span>1</span> <span>&lt;$</span> <span>filter</span> (<span>&gt;</span> <span>0</span>) regions</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>-- | How many regions were executed at least once for all these modules?</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>tixModuleCount ::</span> <span>Tix</span> <span>-&gt;</span> <span>Integer</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>tixModuleCount (<span>Tix</span> ms) <span>=</span> <span>sum</span> <span>$</span> <span>map</span> tixCount ms</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span>-- | call out to the runtime system for region counts for all regions in all modules</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span>examineAndCount ::</span> ([<span>String</span>], <span>Bool</span>) <span>-&gt;</span> <span>IO</span> <span>Integer</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>examineAndCount v <span>=</span> unless (<span>snd</span> v) (<span>error</span> <span>&#34;your code is broken&#34;</span>) <span>&gt;&gt;</span> tixModuleCount <span>&lt;$&gt;</span> examineTix</span></code></pre></div>
<p>The <a href="https://github.com/shapr/kudzu/blob/main/src/Kudzu.hs">final code</a> is able to use QuickCheck, Hedgehog, and LeanCheck as the test runner.</p>
<p>I discovered that sometimes a few runs would go by without increased coverage, so the API includes “run this many tests without increased coverage”.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>testUntilSameLCMany ::</span> (<span>Traversable</span> t, <span>LC.Testable</span> a) <span>=&gt;</span> <span>Int</span> <span>-&gt;</span> t a <span>-&gt;</span> <span>IO</span> (t (<span>Int</span>, <span>Maybe</span> <span>Integer</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>testUntilSameLCMany howMany ts <span>=</span> <span>do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>mapM</span> (testUntilSameLC howMany) ts</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>-- | LeanCheck</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>testUntilSameLC ::</span> <span>LC.Testable</span> a <span>=&gt;</span> <span>Int</span> <span>-&gt;</span> a <span>-&gt;</span> <span>IO</span> (<span>Int</span>, <span>Maybe</span> <span>Integer</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>testUntilSameLC n testable <span>=</span> <span>do</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>let</span> rs <span>=</span> examineAndCount <span>&lt;$&gt;</span> LC.results testable</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  r1 <span>&lt;-</span> <span>head</span> rs</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  grabUntilNSame <span>0</span> n n (<span>tail</span> rs) r1</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span>grabUntilNSame ::</span> (<span>Monad</span> m, <span>Eq</span> a) <span>=&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> [m a] <span>-&gt;</span> a <span>-&gt;</span> m (<span>Int</span>, <span>Maybe</span> a)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>grabUntilNSame c _ <span>0</span> _ z <span>=</span> <span>pure</span> (c, <span>Just</span> z)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>grabUntilNSame c _ _ [] _ <span>=</span> <span>pure</span> (c, <span>Nothing</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>grabUntilNSame c orig n (a <span>:</span> as) z <span>=</span> <span>do</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  a&#39; <span>&lt;-</span> a</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span>if</span> a&#39; <span>==</span> z</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span>then</span> grabUntilNSame (c <span>+</span> <span>1</span>) orig (n <span>-</span> <span>1</span>) as z</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span>else</span> grabUntilNSame (c <span>+</span> <span>1</span>) orig orig as a&#39;</span></code></pre></div>
<p>One surprise is that <a href="https://github.com/rudymatela/leancheck/">LeanCheck</a>’s enumerative generator required the fewest steps to converge on maximum code coverage!
QuickCheck took the longest, and Hedgehog was somewhere between the two for number of tests required to consider “enough”.</p>

<p>Two weeks into this project I found Dan Luu’s <a href="https://danluu.com/testing/">blog post on testing</a>, there’s way more awesome info on that post.
If you enjoyed this post, go read that post next!</p>
<p>I did turn those ideas into another testing library that’s <a href="https://github.com/shapr/trynocular">larger and far reaching</a>, but that’s a different blog post.</p>

<p>At my previous job we used property based tests in our continuous integration pipeline, and some of my coworkers would get snippy when bugs were found that they had not added. They only wanted to know about “new” bugs, not “old” bugs.</p>
<p>We switched to using the same seed for the random number generator for every run, and their frustrations went away.</p>
<p>I wanted the best of both worlds, and after talking to a developer at hasura, he suggested that we save a “known good” seed, and whenever the tests failed on a new unknown seed, switch back to the known good seed so we could tell if this was a new or old bug.</p>
<p>Perhaps I’ll get around to adding explicit support for that to the Haskell property test frameworks someday? It’s a great solution!</p>

	</div></div>
  </body>
</html>
