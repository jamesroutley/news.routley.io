<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elvischidera.com/2022-04-29-philosphy-software-design/">Original</a>
    <h1>A Philosophy of Software Design – Book Summary and Notes</h1>
    
    <div id="readability-page-1" class="page"><div id="skip-nav"><p><time>29.04.2022</time> — <a href="http://harihareswara.net/tags/notes">notes</a>, <a href="http://harihareswara.net/tags/summary">summary</a> — <span>19<!-- --> min read</span></p><section><p>This is my summary and notes from <a href="https://amzn.to/382B0oX">A Philosophy of Software Design, 2nd Edition</a> by John Ousterhout. Please use the link if you decide to buy the book after reading this as it contains my affiliate code. Thanks.</p><blockquote><p>The most fundamental problem in computer science is problem decomposition: how to take a complex problem and divide it up into pieces that can be solved independently.</p></blockquote><h2>Chapter 1 — Introduction</h2><ol><li>Programmers aren’t bound by practical limitations such as laws of physics, they are bound by their limited ability to understand the systems they create.</li><li><a href="https://elvischidera.com/2022-01-02-summary-out-of-the-tar-pit/">Complexity hinders understanding</a> — which impedes development and leads to bugs.</li><li>Complexity begets complexity.</li><li>The larger the program and number of people working on it, the more difficult it is to manage complexity.</li><li>There is a limit to how much any tool can help to deal with complexity.</li><li>There are two general approaches to fighting complexity:<ul><li><strong>Complexity elimination</strong> — make code simpler and more obvious. E.g: eliminating special cases.</li><li><strong>Complexity encapsulation</strong> — into relatively independent modules (aka <code>modular design</code>), so that programmers can work on a system without being exposed to all of its complexity at once.</li></ul></li><li>Because software is so malleable, software design is a continuous process that spans the entire lifecycle of a software system.</li><li>It’s easier to see design problems in someone else’s code than your own.</li><li>Every rule has its exceptions, and every principle has its limits. If you take any design idea to its extreme, you will probably end up in a bad place.</li></ol><h3>Notes</h3><ol><li>The author talked about how agile practices can reduce complexity because engineers can continuously change a design as they understand the problem space better.</li><li>However, at the limit, incremental changes can lead to a bad design overall when engineers don’t take a holistic view of the system.</li></ol><h2>Chapter 2 — The Nature of Complexity</h2><h3>Complexity defined</h3><ol><li>Complexity is anything related to the structure of a software system that makes it hard to understand and thus modify the system.</li><li>The overall complexity of a system (<code>C</code>) is determined by the complexity of each part p (<code>cₚ</code>) weighted by the fraction of time developers spend working on that part (<code>tₚ</code>).</li></ol><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><msub><mi>c</mi><mi>p</mi></msub><msub><mi>t</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">C = \sum_{p = 0}^{n} c_{p} t_{p}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>C</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>p</span><span>=</span><span>0</span></span></span></span><span><span></span><span><span>∑</span></span></span><span><span></span><span><span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span>c</span><span><span><span><span><span><span></span><span><span><span>p</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>p</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span><ol><li>Based on the above formula, interfaces should be designed to make the common case as simple as possible:<blockquote><p>If the API for a <strong>commonly used feature</strong> forces users to learn about other features that are <strong>rarely used</strong>, this increases the cognitive load on users who don’t need the rarely used features.  </p></blockquote></li></ol><h3>Symptoms of complexity</h3><ol><li><strong>Change amplification</strong>: A seemingly simple change requires code modifications in many different places.</li><li><strong>Cognitive load</strong>: how much a developer needs to know in order to complete a task.<blockquote><p>Sometimes an approach that requires more lines of code is actually simpler, because it reduces cognitive load.  </p></blockquote></li><li><strong>Unknown unknowns</strong>: It’s not obvious which pieces of code must be modified or what information a developer must have to complete a task.</li></ol><h3>Causes of complexity</h3><ol><li><strong>Dependency</strong>:<ul><li>A dependency exists when a given piece of code cannot be understood and modified in isolation.</li><li>E.g: a dependency exists between a function and all its callers.</li><li>Dependencies lead to change amplification and a high cognitive load.</li><li>Because dependencies are a fundamental part of software that can’t be completely eliminated, the goal is to reduce them and make whatever remains simple and obvious.</li></ul></li><li><strong>Obscurity</strong>:<ul><li>Occurs when important information is not obvious.</li><li>Obscurity creates unknown unknowns and contributes to cognitive load.  </li></ul></li></ol><h3>Complexity is incremental</h3><ol><li>Death by a thousand cuts: Complexity isn’t caused by a single catastrophic error; it accumulates in lots of small chunks.</li></ol><h3>Notes</h3><ol><li>The definition of complexity here is subjective: a junior engineer might find a project hard to understand or the task at hand might be inherently complex.</li><li>The author doesn’t explicitly distinguish between essential and accidental complexity.</li><li>Modularity suggested in <a href="#chapter-1--introduction">chapter 1</a> can lead to obscurity.</li><li>The overall complexity should be viewed relative to an individual/team — a single engineer or team might work on a module more than any other engineers in the company combined.</li></ol><h2>Chapter 3 — Working Code Isn’t Enough</h2><h3>Tactical programming</h3><ol><li>Tactical programming focuses on finishing tasks (i.e: shipping working code) quickly. Any endeavor like refactoring that doesn’t pay dividends now is deprioritized.</li><li>It adds to complexity due to myopic design decisions that are usually subpar.</li></ol><h3>Strategic programming</h3><ol><li>Strategic programming requires an investment mindset to improve the design of the system even if it&#39;s not the fastest path to finish your current project.</li><li>Investment can be proactive (thinking ahead) or reactive (incorporating new knowledge into existing design).</li><li>In the short term, these investments slow development. In the long term, they make development faster.</li></ol><h3>How much to invest?</h3><ol><li>Our expertise of a problem domain improves as we work in it. Hence, huge upfront investment (like the waterfall model) don’t work because of the details that usually emerge only during actual implementation or usage.</li><li>The best approach is to make lots of small investments on a continual basis.</li><li>The author suggest spending about <code>10–20%</code> of total development time on investments. This amount is small enough that it won’t impact your schedules significantly, but large enough to produce significant benefits over time.   </li></ol><h3>Notes</h3><ol><li>In my experience, effective teams know when to switch between tactical &amp; strategic approaches.</li><li>The author discredits the tactical argument for startups. My counter argument is that I have see “well engineered” projects fail, a lot. In fact, a big trap I see great engineers fall for is to expend a significant amount of time on a product that hasn’t been validated — what’s the point?</li></ol><h2>Chapter 4 — Modules Should Be Deep</h2><h3>Modular design</h3><ol><li>Modules can take many forms, such as classes, subsystems, or services.</li><li>In order to manage dependencies, we think of each module in two parts:<ul><li>The <strong>interface</strong> consists of everything that a developer working in a different module must know in order to use the given module.</li><li>The <strong>implementation</strong> consists of the code that carries out the promises made by the interface.</li></ul></li><li>For the purposes of this book, a module is any unit of code that has an interface and an implementation.</li><li>The best modules are those whose interfaces are much simpler than their implementations. Such modules have two advantages:<ul><li>A simple interface minimizes the complexity that a module imposes on the rest of the system.</li><li>If a module is modified in a way that does not change its interface, then no other module will be affected by the modification.</li></ul></li></ol><h3>What’s in an interface?</h3><ol><li>If a developer needs to know a particular piece of information in order to use a module, then that information is part of the module’s interface.</li><li>An interface has two parts:<ul><li><strong>Formal parts</strong>: are specified explicitly in the code and can be enforced by a programming language. E.g: a method’s signature, a class public methods &amp; properties, etc.</li><li><strong>Informal parts</strong>: are specified in the documentation and can’t be enforced by a programming language. It includes its high level behavior like: what a function does when it&#39;s called.</li></ul></li></ol><h3>Abstractions</h3><ol><li>An abstraction is a simplified view of an entity, which omits unimportant details.</li><li>A module provides an abstraction in form of its interface: The interface presents a simplified view of the module’s functionality; the details of the implementation are unimportant from the standpoint of the module’s abstraction, so they are omitted from the interface.</li><li>Two pitfalls with abstractions:<ul><li><strong>Unimportant details inclusion</strong>: this increases cognitive load as the the abstraction is more complicated than necessary.</li><li><strong>Important details exclusion</strong>: This results in obscurity.</li></ul></li></ol><h3>Deep modules</h3><ol><li>The best modules are those that provide powerful functionality yet have simple interfaces.</li><li>Unix File I/O mechanism is a good example of deep modules.</li><li>Module depth is a way of thinking about cost versus benefit:<ul><li>The benefit provided by a module is its functionality.</li><li>The cost of a module (in terms of system complexity) is its interface.  </li></ul></li></ol><h3>Shallow modules</h3><ol><li>A shallow module is one whose interface is complicated relative to the functionality it provides.</li><li>Shallow modules don’t help much in the battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost of learning and using their interfaces.</li><li>Small modules tend to be shallow.  </li></ol><h3>Classitis</h3><ol><li>The conventional wisdom in programming is that classes should be small, not deep:<ul><li>Break up larger classes into smaller ones.</li><li>Any method longer than <code>N</code> lines should be divided into multiple methods</li></ul></li><li>The extreme of the “classes should be small” approach is a syndrome the author calls classitis:</li></ol><blockquote><p>Classitis may result in classes that are individually simple, but it increases the complexity of the overall system. Small classes don’t contribute much functionality, so there have to be a lot of them, each with its own interface. These interfaces accumulate to create tremendous complexity at the system level. Small classes also result in a verbose programming style, due to the boilerplate required for each class.  </p></blockquote><h3>Notes</h3><ol><li>Because all abstractions are leaky, in practice you will find that changes that don&#39;t change a module&#39;s interface might still require changes to consumers. See <a href="https://www.hyrumslaw.com/">Hyrum&#39;s law</a>.</li></ol><h2>Chapter 5 — Information Hiding (and Leakage)</h2><h3>Information hiding</h3><ol><li>Information hiding occurs when each module encapsulates a few pieces of knowledge, which represent design decisions. The knowledge is embedded in the module’s implementation but does not appear in its interface.</li><li>Information hiding also applies within a class:<ul><li>Design the private methods so that each method encapsulates some information or capability and hides it from the rest of the class.</li><li>Minimize the number of places where each instance variable is used. </li></ul></li></ol><h3>Information leakage</h3><ol><li>Information leakage occurs when a design decision is reflected in multiple modules.</li><li>Information leakage is the opposite of information hiding.</li><li>Leakage can occur directly via a module’s interface, or indirectly via implicit knowledge used in different modules (like the expected structure of a file).</li></ol><h3>Temporal decomposition</h3><ol><li>In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.</li><li>Information hiding can often be improved by making a class slightly larger. This enables us encapsulate specific knowledge in one place and raise the interface level (i.e: instead of exposing many intermediary low-level steps, expose a small number of high-level steps).</li></ol><h2>Chapter 6 — General-Purpose Modules are Deeper</h2><ol><li>General-purpose interfaces have many advantages over special-purpose ones:<ul><li>They tend to be simpler, with fewer methods that are deeper.</li><li>They also provide a cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes.</li></ul></li><li>Making your modules somewhat general-purpose is one of the best ways to reduce overall system complexity.  </li></ol><h3>Notes</h3><ol><li>This all ties down to layering (talked about in the next chapter): Make generic low-level modules, and specialized high-level modules.</li></ol><h2>Chapter 7 — Different Layer, Different Abstraction</h2><blockquote><p>Each piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element. In order for an element to provide a net gain against complexity, it must eliminate some complexity that would be present in the absence of the design element. Otherwise, you are better off implementing the system without that particular element. For example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.  </p><ol><li>Software systems are composed in layers, where higher layers use the facilities provided by lower layers and each layer has a different abstraction (level).</li></ol></blockquote><h3>Pass-Through Method</h3><ol><li>A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.</li><li>The interface to a piece of functionality should be in the same class that implements the functionality.</li><li>Ways to eliminate pass-through methods:<ul><li>Let callers invoke the method directly</li><li>Redistribute functionality to avoid calls between the two</li><li>Combining the classes</li></ul></li></ol><h3>When is interface duplication OK?</h3><ol><li>Having methods with the same signature is not always bad. The important thing is that each new method should contribute significant functionality. Pass-through methods are bad because they contribute no new functionality.  </li></ol><h3>Decorators</h3><ol><li>A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object. </li><li>The decorator design pattern (also known as a “wrapper”) encourages API duplication across layers.</li><li>Because decorators tend to be shallow, it’s worth considering alternative options:<ul><li>Could you add the new functionality directly to the underlying class, rather than creating a decorator class?</li><li>If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?</li><li>Could you merge the new functionality with an existing decorator, rather than creating a new decorator? </li><li>Ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class? </li></ul></li></ol><h3>Pass-through variables</h3><ol><li>Another form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods.</li><li>Ways to eliminate pass-through variables:<ul><li>Store the variable in a shared object</li><li>Use global variables</li><li>Use a context object that stores all system-wide information, such as a
timeout value and performance counters; a reference to the context is stored in all objects whose methods need access to it.</li></ul></li></ol><h3>Notes</h3><ol><li>Context object introduce obscurity like the author mentioned: why does a value exists &amp; where is it used. When is pass-through variables better than context objects?</li><li>Context objects could also exist at a more local scope.</li></ol><h2>Chapter 8 — Pull Complexity Downwards</h2><ol><li>It’s more important for a module to have a simple interface than a simple implementation — Most modules have more users than developers, so it is better for the developers to suffer than the users.</li><li>Pulling complexity down makes the most sense if:<ul><li>The complexity being pulled down is closely related to the class’s existing functionality</li><li>Pulling the complexity down will result in many simplifications elsewhere in the application</li><li>Pulling the complexity down simplifies the class’s interface.</li></ul></li></ol><h3>Notes</h3><ol><li>I disagree with the author on avoiding configuration parameters — Anyone who has built a niche complex system have run into a module that used values that are inadequate for the current situation.</li><li>Having settings or configuration parameters is not a design failure. Sensible defaults should be provided, but the user should be able to override them in most cases.</li></ol><h2>Chapter 9 — Better Together Or Better Apart?</h2><ol><li>One of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated?</li><li>While a large number of small modules lead to simpler individual modules, they usually increase the overall system complexity:<ul><li>Complexity from the number of modules — hard to keep track of all of them or find a desired module. Subdivision usually results in more interfaces, and every new interface adds complexity.</li><li>May require additional code to manage multiple modules.</li><li>Creates separation:<ul><li>For truly independent modules, separation is good — it allows the developer to focus on a single module at a time.</li><li>For dependent modules, separation is bad — Separation makes it harder for developers to see the modules at the same time, or even to be aware of their existence.</li></ul></li><li>May result in duplication.</li></ul></li><li>Related code should be brought together. Indications that code are related:<ul><li>They share specific knowledge: X &amp; Y have knowledge about Z</li><li>They are used together bidirectionally: X is used with Y and Y is used with X</li><li>They overlap conceptually: there is a simple higher-level category that includes both of the pieces of code.</li><li>It is hard to understand one of the pieces of code without looking at the other.</li></ul></li></ol><h3>Splitting and joining methods</h3><ol><li>Each method should do one thing and do it <strong>completely</strong>.</li><li>It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag.<blockquote><p>This is an instance of a general red flag: if two pieces of code are physically separated, but each can only be understood by looking at the other.</p></blockquote></li><li>Methods can be split if the original method:<ul><li>Can be split into independent general purpose subtasks</li><li>Has a complex interface and does too much, it can be split into multiple methods, so long as the callers don’t always have to use them all together in an exact order.</li></ul></li><li>There are situations where a system can be made simpler by joining methods together:<ul><li>Joining methods might replace two shallow methods with one deeper method</li><li>It might eliminate duplication of code</li><li>It might eliminate dependencies between the original methods, or intermediate data structures</li><li>It might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place</li><li>It might result in a simpler interface.  </li></ul></li></ol><h2>Chapter 10 — Define Errors Out Of Existence</h2><ol><li>The exceptions thrown by a class are part of its interface</li><li>Four techniques for reducing the number of exception handlers:<ul><li>Define errors out of existence by designing APIs that make an exception impossible/unnecessary.</li><li>Mask exceptions by detecting and handling them at a low-level.</li><li>Exception aggregation by handling many exceptions with a single piece of code (at a higher level).</li><li>Just crash when an exception is rare and difficult to deal with.</li></ul></li></ol><h3>Notes</h3><ol><li>Another technique is to have a clean and unclean part of the system. Parsing is done in the unclean part and exceptions are possible. The parsed objects are parsed to the clean part where exceptions are rare. See: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse don’t validate</a>.</li></ol><h2>Chapter 11 — Design it Twice</h2><ol><li>Designing software is hard, so it’s unlikely that your first thoughts about how to structure a module or system will produce the best design. You’ll end up with a much better result if you consider multiple options for each major design decision.  </li></ol><h3>Notes</h3><ol><li>My favorite part of the book. Reminds me of a paragraph in SICP:</li></ol><blockquote><p>“Every computer program is a model, hatched in the mind, of a real or mental process. These processes, arising from human experience and thought, are huge in number, intricate in detail, and at any time only partially understood. They are modeled to our permanent satisfaction rarely by our computer programs. Thus even though our programs are carefully handcrafted discrete collections of symbols, mosaics of interlocking functions, they continually evolve: we change them as our perception of the model deepens, enlarges, generalizes until the model ultimately attains a metastable place within still another model with which we struggle”</p></blockquote><h2>Chapter 12 — Why Write Comments? The Four Excuses</h2><ol><li>The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code. </li></ol><h3>i. Good code is self-documenting</h3><ol><li>Good code reduces the need and amount of comments, it doesn’t eliminate the need for comments.</li><li>There is a significant amount of design information that can’t be represented in code.</li><li>While code is the source of truth, it’s painful and time consuming to expect people to read the code to understand the interface.</li></ol><blockquote><p>Comments are fundamental to abstractions: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed.</p></blockquote><h3>ii. I don’t have time to write comments</h3><ol><li>Good comments make a huge difference in the maintainability of software, so the effort spent on them will pay for itself quickly.</li><li>This excuse sacrifices long term speed, for short term speed.</li></ol><h3>iii. Comments get out of date and become misleading</h3><ol><li>Updating the docs doesn’t take as much time as updating the code; disciplined teams should have docs sync as part of the development process.</li></ol><h3>iv. All the comments I have seen are worthless</h3><ol><li>This is solvable by learning how to write solid documentation.</li></ol><h3>Notes</h3><ol><li>Worthless comments can usually be attributed to <a href="https://en.wikipedia.org/wiki/Goodhart%27s_law">Goodhart&#39;s law</a>. People write comments because there is some incentive to write comments, but since they don’t deeply care about it, they only satisfy the minimum or easily measurable requirement: is a piece of code documented?</li></ol><h2>Chapter 13 — Comments Should Describe Things that Aren’t Obvious from the Code</h2><h3>Pick conventions</h3><ol><li>Conventions serve two purposes:<ul><li>They ensure consistency, which makes comments easier to read and understand.</li><li>They help to ensure that you actually write comments: constraints liberate, liberties constrain.</li></ul></li><li>Most comments fall into one of the following categories:<ul><li><strong>Interface</strong>: a comment block that immediately precedes and describes a module such as a class, data structure, or method.</li><li><strong>Data structure member</strong>: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.</li><li><strong>Implementation comment</strong>: a comment inside the code of a method, which describes how the code works internally.</li><li><strong>Cross-module comment</strong>: a comment describing dependencies that cross module boundaries.</li></ul></li></ol><h3>Don’t repeat the code</h3><ol><li>A comment isn’t helpful if the information in it is already obvious from the code next to it. One example of this is when the comment uses the same words that make up the name of the thing it is describing.</li></ol><h3>Lower-level comments add precision</h3><ol><li>Comments augment the code by providing information at a different level of detail.</li><li>Some comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code.</li><li>Other comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code.</li><li>Comments at the same level as the code are likely to repeat the code.  </li><li>When documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated.</li></ol><h3>Interface documentation</h3><ol><li>Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction.</li><li>Implementation comments describe how a class or method works internally in order to implement the abstraction.</li><li>If interface comments must also describe the implementation, then the class or method is shallow.</li><li>Implementation documentation contaminates the interface.</li></ol><h3>Implementation comments: what and why, not how</h3><ol><li>Most methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.</li><li>The main goal of implementation comments is to help readers understand what the code is doing (not how it does it).</li></ol><h3>Notes</h3><ol><li><p>Some of the things the author said should be in comments can instead be in code:</p><ul><li>A variable unit can be in its name.</li><li>Validation and information on method parameters can be in rich domain classes.</li><li>Variable names can be used for documentation — take the substring example, it can have <code>(startInclusive, endExclusive)</code> instead of <code>(start, end)</code> — the former doesn’t need extra documentation, the later does.</li></ul></li><li><blockquote><p>“If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader <strong>thinks it’s not obvious, then it’s not obvious</strong>”</p></blockquote><p>While this is usually true, it’s not always true. Also, “obvious” is subjective — you can make your code obvious for one person, and it becomes obscure to another.</p></li><li><p>Keep in mind people then to use unrelated words to describe a phenomenon. E.g: Conflating unfamiliarity with complexity.</p></li></ol><h2>Chapter 14 — Choosing Names</h2><ol><li>Good names are a form of documentation:<ul><li>They make code easier to understand.</li><li>They reduce the need for other documentation.</li><li>They make it easier to detect errors.</li></ul></li><li>Names are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity.</li><li>Names should be precise: If a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.</li><li>If it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.</li><li>Use names consistently: Consistent naming reduces cognitive load in much the same way as reusing a common class: once the reader has seen the name in one context, they can reuse their knowledge and instantly make assumptions when they see the name in a different context.</li></ol><blockquote><p>“The greater the distance between a name’s declaration and its uses, the longer the name should be.” — Andrew Gerrand  </p></blockquote><h2>Chapter 15 — Write The Comments First</h2><ol><li>Use comments as part of the design process.</li><li>Delayed comments are <!-- -->[usually]<!-- --> bad comments.</li></ol><h3>Notes</h3><ol><li>I’m a big fan of “documentation driven development”, so this chapter resonated with me.</li><li>On multiple occasions, I have simplified my designs or figured out better approaches by writing high-level documentation first.</li><li>However, the author seems to propose this like the TDD crowd proposes TDD. Sometimes clarity is obtained by first writing code. IMO, there is nothing wrong with “hacking code” locally — sometimes code is the best canvas.</li></ol><h2>Chapter 16 — Modifying Existing Code</h2><ol><li>Ideally, when you have finished with each change, the system will have the structure it would have had if you had designed it from the start with that change in mind.</li><li>If you’re not making the design better, you are probably making it worse.</li><li>The best way to ensure that comments get updated is to position them close to the code they describe.</li><li>The farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidated by code changes).</li><li>Comments belong in the code, not in the commit log.</li><li>Link to (external) resources, don’t duplicate them: It’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.</li></ol><h3>Notes</h3><ol><li>Sometimes copying external resources into the docs is useful: the information can be displayed in a consistent &amp; convenient fashion; and the copied information isn’t affected by dead links.</li></ol><h2>Chapter 17 — Consistency</h2><ol><li>Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach.  </li></ol><h2>Chapter 18 — Code Should be Obvious</h2><ol><li>Software should be designed for ease of reading, not ease of writing.</li><li>If code is nonobvious, that usually means there is important information about the code that the reader does not have.</li></ol><h3>Things that make code more obvious</h3><ol><li>Judicious use of white space.</li><li>Comments: Sometimes it isn’t possible to avoid code that is nonobvious. When this happens, it’s important to use comments to compensate by providing the missing information.</li></ol><h3>Things that make code less obvious</h3><ol><li>Event-driven programming: Event-driven programming makes it hard to follow the flow of control.</li><li>Generic containers (like Pair in Java): Generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning.</li><li>Different types for declaration and allocation.<div data-language="java"><pre data-linenumber="true"><code><p><span>1</span><span>private</span><span> </span><span>List</span><span>&lt;</span><span>Message</span><span>&gt;</span><span> incomingMessageList</span><span>;</span><span></span></p><p><span>2</span><span></span><span>.</span><span>.</span><span>.</span><span></span></p><p><span>3</span><span>incomingMessageList </span><span>=</span><span> </span><span>new</span><span> </span><span>ArrayList</span><span>&lt;</span><span>Message</span><span>&gt;</span><span>(</span><span>)</span><span>;</span></p></code></pre></div></li><li>Code that violates reader expectations.</li></ol><h3>Notes</h3><ol><li>Could the problem with event driven programming be solved with better tooling?</li><li>Obscurity might be eliminated if the objects in a generic container are rich domain objects.</li></ol><h2>Chapter 19 — Software Trends</h2><h3>Object-oriented programming and inheritance</h3><ol><li>Private methods and variables can be used to ensure information hiding.</li><li>The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures.</li><li>Interface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving one problem (such as how to use an I/O interface to read and write disk files) to be used to solve other problems (such as communicating over a network socket).</li><li>The second form of inheritance is implementation inheritance. In this form, a parent class defines not only signatures for one or more methods, but also default implementations. Subclasses can choose to inherit the parent’s implementation of a method or override it by defining a new method with the same signature.</li><li>Implementation inheritance can reduce the amount of code that needs to be modified as the system evolves (i.e: the change amplification problem).</li><li>Implementation inheritance creates dependencies between the parent class and each of its subclasses.</li><li>Favor composition over implementation inheritance.</li></ol><h3>Agile development</h3><ol><li>One of the most important elements of agile development is the notion that development should be incremental and iterative.</li><li>One of the risks of agile development is that it can lead to tactical programming.</li></ol><h3>Unit tests</h3><ol><li>Tests facilitate refactoring.</li></ol><h3>Test-driven development</h3><ol><li>The problems with test-driven development:<ul><li>It focuses attention on getting specific features working, rather than finding the best design — this is tactical programming.</li><li>It&#39;s too incremental — at any point in time, it’s tempting to just hack in the next feature to make the next test pass.</li></ul></li><li>Writing tests first makes the most sense when fixing bugs.</li></ol><h3>Design patterns</h3><ol><li>A design pattern is a commonly used approach for solving a particular kind of problem.</li><li>The greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don’t try to force a problem into a design pattern when a custom approach will be cleaner.</li><li>Using design patterns doesn’t automatically improve a software system; it only does so if the design patterns fit.</li><li>As with many ideas in software design, the notion that design patterns are good doesn’t necessarily mean that more design patterns are better.  </li></ol><h3>Getters and setters</h3><ol><li>The argument for getters and setters is that they allow additional functions to be performed while getting and setting.</li><li>Getters and setters are shallow methods (typically only a single line), so they add clutter to the class’s interface without providing much functionality.</li></ol><h3>Notes</h3><ol><li>Modern languages like Kotlin eliminated the need for traditional getters/setters.</li><li>Poorly written tests or bad test infrastructure can actually hinder refactoring.</li></ol><h2>Chapter 20 — Designing for Performance</h2><ol><li>Measure before modifying: allows you identify real performance issues and creates a baseline to compare your performance changes to.</li></ol></section></div></div>
  </body>
</html>
