<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2024/11/12/security/how-meta-built-large-scale-cryptographic-monitoring/">Original</a>
    <h1>Meta built large-scale cryptographic monitoring</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>Cryptographic monitoring at scale has been instrumental in helping our engineers understand how cryptography is used at Meta.</span></li>
<li aria-level="1"><span>Monitoring has given us a distinct advantage in our efforts to proactively detect and remove weak cryptographic algorithms and has assisted with our general change safety and reliability efforts.</span></li>
<li aria-level="1"><span>We’re sharing insights into our own cryptographic monitoring system, including challenges faced in its implementation, with the hope of assisting others in the industry aiming to deploy cryptographic monitoring at a similar scale.</span></li>
</ul>
<p><span>Meta’s managed cryptographic library, FBCrypto, plays an important role within Meta’s infrastructure and is used by the majority of our core infrastructure services. Given this, having a robust monitoring system in place for FBCrypto has been instrumental in ensuring its reliability as well as in helping our engineers understand how cryptography is used at Meta so they can make informed development decisions.</span></p>
<p><span>Monitoring the health of our library allows us to detect and revert bugs before they reach production services. The data from our monitoring service provides insight into the usage of FBCrypto, allowing us to make data-driven decisions when deciding what improvements to make to the library. For example, it helps us identify components that need more attention either because they are on a hot path or are less stable.</span></p>
<p><span>Understanding exactly how clients are using said library is a common pain point in managing any widely distributed library. But the improved understanding of FBCrypto provided by our monitoring helps us maintain a high bar for security posture. Since there is a limit to how much data a symmetric cryptographic key can protect, logging allows us to detect key overuse and rotate keys proactively. It also helps us build an inventory of cryptography usage, making it easy to identify the callsites of weakened algorithms that need to be migrated – a very important task because we need to proactively switch from weakened algorithms to newer, more robust ones as cryptography strength decays over time.</span></p>
<p><span>More generally, improved understanding helps us to make emergency algorithm migrations when a vulnerability of a primitive is discovered.</span></p>
<p><span>More recently, this is aiding our efforts to ensure</span> <a href="https://engineering.fb.com/2024/05/22/security/post-quantum-readiness-tls-pqr-meta/" target="_blank" rel="noopener"><span>post-quantum readiness</span></a><span> in our asymmetric use cases. The available data improves our decision-making process while prioritizing quantum-vulnerable use cases</span></p>
<h2><span>How cryptographic monitoring works at Meta</span></h2>
<p><span>Effective cryptographic monitoring requires storing persisted logs of cryptographic events, upon which diagnostic and analytic tools can be used to gather further insights. Supporting logging at the scale of FBCrypto requires an implementation with unique performance considerations in mind. Given that FBCrypto is used along many high-volume and critical code paths, a naive logging implementation could easily overwhelm a standard logging infrastructure or cause significant performance regressions. This is true for most widely distributed libraries and is especially true in the field of cryptography, where the sheer volume of usage can come as a complete surprise to those unfamiliar with the space. For example, we recently disclosed that roughly 0.05% of CPU cycles at Meta are spent on X25519 key exchange. </span></p>
<p><span>Most of Meta’s logs are constructed and written via</span> <a href="https://engineering.fb.com/2019/10/07/core-infra/scribe/" target="_blank" rel="noopener"><span>Scribe</span></a><span>, Meta’s standard logging framework. From there, data persists in</span> <a href="https://research.facebook.com/publications/scuba-diving-into-data-at-facebook/" target="_blank" rel="noopener"><span>Scuba</span></a><span> and</span> <a href="https://research.facebook.com/publications/hive-a-warehousing-solution-over-a-map-reduce-framework/" target="_blank" rel="noopener"><span>Hive</span></a><span>, Meta’s short-term and long term data stores, respectively.</span></p>
<p><span>Typically, the Scribe API is called directly to construct a log for every “event” that needs to be logged. For FBCrypto, this would mean constructing a log for nearly every cryptographic operation that our library is used for. Unfortunately, given the sheer frequency of such operations, a solution like this would consume an unreasonable amount of write throughput and storage capacity. A common solution to this problem would be to introduce sampling (i.e., only log 1/X cryptographic operations, and increase X until we no longer have capacity concerns). However, we felt strongly about not introducing any sampling since doing so would result in most logs being omitted, giving us a less clear picture of the library’s usage.</span></p>
<p><span>Instead, the logging uses a “buffering and flushing” strategy, in which cryptographic events are aggregated across time and flushed to a data store at a preconfigured interval.</span></p>
<p><span>During the aggregation, a “count” is maintained for every unique event. When it comes time to flush, this count is exported along with the log to convey how often that particular event took place. </span></p>
<p><span>Below is a rough illustration of what this looks like:</span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-1-e1731001505528.png?w=859" alt="" width="600" height="450"/></p>
<p><span>In the above example, the key named “myKeyName” is used to perform encryption using the AES-GCM-SIV encryption algorithm (in practice we log more fields than just key name, method, and algorithm). The operation happens five times and is assigned on a count of five. Since machines often compute millions of cryptographic operations per day, this strategy can lead to significant compute savings in production. </span></p>
<h3><span>A client-side view</span></h3>
<p><span>The aggregation and flushing is implemented within FBCrypto, so the logging and flushing code sits on the client hosts. When clients call a given cryptographic operation (e.g., “encrypt()”), the operation is performed and the log is added to our aggregated buffer. We refer to the object that holds the buffer as the “buffered logger.”</span></p>
<p><span>Note that the logging does not change the interface of FBCrypto, so all of this is transparent to the clients of the library. </span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?w=939" alt="" width="600" height="338" srcset="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png 939w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=580,326 580w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=916,516 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=768,433 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=96,54 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=192,108 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>In multithreaded environments all threads will log to the same buffer. For this to be performant, we need to choose the right underlying data structure (see the section below on </span><i><span>“Additional optimizations”</span></i><span> for more details).</span></p>
<p><span>While the aggregation works to reduce space and time overhead, the logs need to eventually be written to storage for further use. To do this, a background thread runs on the client host to periodically call the Scribe API to export the logs and flush the map’s contents. </span></p>
<p><span>Below is an overview of the overall flow: </span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?w=1024" alt="" width="600" height="520" srcset="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png 1478w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=916,793 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=768,665 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=1024,887 1024w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=96,83 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=192,166 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<h3><span>Additional optimizations</span></h3>
<p><span>We had to make some additional optimizations to support cryptographic monitoring on Meta’s major products (Facebook, Whatsapp, Instagram, etc.).</span></p>
<p><span>With careful design choices around the logging logic and data structures used, our cryptographic logging operates with </span><b>no sampling </b><span>and has had a negligible impact on compute performance across Meta’s fleet.</span></p>
<h4><span>Partially randomized flushing</span></h4>
<p><span>Due to the nature of our buffering and flushing strategy, certain clients who were running jobs that restarted large sets of machines at around the same time would have those machines’ logs get flushed at about the same time. This would result in “spiky” writes to the logging platform, followed by longer periods of underutilization between flushes. To normalize our write throughput, we distribute these spikes across time by applying a randomized delay on a per-host basis before logs are flushed for the first time. This leads to a more uniform flushing cadence, allowing for a more consistent load on Scribe. </span></p>
<p><span>The figure below demonstrates how this works:</span></p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?w=1024" alt="" width="1024" height="388" srcset="https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=916,347 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=768,291 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=1024,388 1024w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=1536,582 1536w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=96,36 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=192,73 192w" sizes="auto, (max-width: 992px) 100vw, 62vw"/></p>
<h4><span>Derived crypto</span></h4>
<p><span>FBCrypto supports a feature called derived crypto, which allows “child” keysets to be derived from “parent” keysets by applying a key derivation function (KDF) to all the keys in the keyset with some salt. This feature is used by a few large-scale use cases that need to generate millions of keys.</span></p>
<p><span>Our logging initially created a unique row in the buffered logger for every derived keyset, which used a lot of space and put increased load on backend data stores. To address this, we now aggregate the cryptographic operations of derived keys under the name of the parent key. This reduces our overall capacity needs without harming our ability to detect key overuse since, in the worst case, the aggregations would be a pessimistic counter for any given child key. </span></p>
<p><span>Thanks to this aggregation, we were able to cut down on the vast majority of our logging volume, compared to the space that would have been used with no aggregation. </span></p>
<h4><span>The Folly library </span></h4>
<p><span>Internally, our buffering makes use of the</span> <a href="https://github.com/facebook/folly/blob/main/folly/concurrency/ConcurrentHashMap.h" target="_blank" rel="noopener"><span>folly::ConcurrentHashMap</span></a><span>, which is built to be performant under heavy writes in multithreaded environments, while still guaranteeing atomic accesses.  </span></p>
<h3><span>Unified offerings</span></h3>
<p><span>Meta’s existing infrastructure and its emphasis on unified offerings are key to supporting this at scale (see the</span><a href="https://engineering.fb.com/2019/10/07/core-infra/scribe/"> <span>Scribe</span></a><span> logging framework and the FBCrypto library). These properties often mean that solutions only have to be implemented once in order for the entire company to benefit.</span></p>
<p><span>This is especially true here. Most machines in Meta’s fleet can log to Scribe, giving us easy log ingestion support. Furthermore, the wide adoption of FBCrypto gives us insights into cryptographic operations without needing clients to migrate to a new library/API. </span></p>
<p><span>From an engineering perspective, this helps us overcome many hurdles that others in the industry might face. For example, it helps us avoid fragmentation that might require multiple custom solutions to be implemented, which would increase our engineering workload.</span></p>
<h2><span>The impact of cryptographic monitoring</span></h2>
<p><span>The insights from our cryptographic monitoring efforts have served multiple use cases across our security and infrastructure reliability efforts.</span></p>
<h3><span>Preemptively mitigating security vulnerabilities</span></h3>
<p><span>Thanks to our long retention window, we can monitor trends over time and use them for more predictive modeling and analysis. We can present our findings to cryptography experts, who can do further analysis and predict whether vulnerabilities may emerge. This allows us to preemptively identify clients using cryptography in risky ways and work with them to mitigate these issues before they become real security vulnerabilities. </span></p>
<p><span>This is particularly beneficial in preparation for the world of</span><a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography"> <span>post-quantum cryptography</span></a><span> (PQC), which requires us to find clients using vulnerable algorithms and ensure they are migrated off in a timely fashion. </span></p>
<p><span>We have also found that being able to preemptively detect these vulnerabilities well in advance has led to stronger support during cross-team collaborations. Thanks to the ample notice, teams can seamlessly integrate any necessary migration efforts into their roadmap with minimal interruption to their ongoing projects.</span></p>
<h3><span>Promoting infrastructure reliability</span></h3>
<p><span>Our root dataset has also served as a useful proxy for client health. This is partially thanks to the lack of sampling, as we can see the exact number of calls taking place, along with their respective success rates. This has been particularly important during large-scale migrations, where anomalous drops in success rate, call volume, etc., may indicate a bug in a new code path. Indeed, numerous detectors and alarms have been built off our dataset to help us perform big migrations safely.</span></p>
<p><span>The dataset also contains library versioning information, so we can monitor what versions of our library are running across the fleet in real-time. This has been especially useful for rolling out new features, as we can see exactly which clients have picked up the latest changes. This allows us to move faster and more confidently, even when running large-scale migrations across the fleet. </span></p>
<h2><span>Challenges to cryptographic monitoring</span></h2>
<p><span>Supporting cryptographic logging at Meta’s scale has had its own unique set of challenges.</span></p>
<h3><span>Capacity constraints</span></h3>
<p><span>Despite our optimizations, we have occasionally found ourselves putting increased load on Scribe (see point above about underestimating cryptographic usage) and have worked with the Scribe team to manage the unexpected increase in write throughput. Doing so has been relatively easy for the company, considering the design optimizations mentioned above.</span></p>
<p><span>We also occasionally put an increased load on</span> <a href="https://research.facebook.com/publications/scuba-diving-into-data-at-facebook/" target="_blank" rel="noopener"><span>Scuba</span></a><span>, which is optimized to be performant for real-time data (i.e., warm storage) and can be inefficient if used for larger datasets. To minimize compute costs, we also rely on</span><a href="https://research.facebook.com/publications/hive-a-warehousing-solution-over-a-map-reduce-framework/"> <span>Hive</span></a><span> tables for longer-term storage (i.e., cold storage). </span></p>
<h3><span>Flushing on shutdown</span></h3>
<p><span>Besides flushing the logs in the shared singleton map at a preconfigured time interval, client machines will also do one final flush to log all remaining contents of their log buffer to Scribe when a job is being shut down. We have found that operating in a “shutdown environment” can lead to a number of interesting scenarios, particularly when attempting to access Scribe and its dependencies. Many of these scenarios boil down to the nuances of</span><a href="https://github.com/facebook/folly/blob/main/folly/Singleton.h"> <span>folly::Singleton</span></a><span>, which is Meta’s go-to library for managing singletons. Likewise, running something “on shutdown” in Java requires using only synchronous I/O code and operating quickly.</span></p>
<h2><span>Our next initiatives for cryptographic monitoring</span></h2>
<p><span>While our work thus far has been largely a success, there are many exciting avenues for improvements. For example, further optimizing Scribe throughput and Scuba storage utilization to make more efficient use of Meta’s infrastructure  </span></p>
<p><span>We will also continue to leverage the logging data to further develop monitoring and data analytics to promote security and reliability. On the security side, this means continuing to take an inventory of use cases that would be vulnerable in a PQC world and migrate them to more resilient algorithms/configurations. In terms of reliability, it means gaining a better understanding of the end-to-end latency for cryptography use cases.</span></p>
<p><span>Within all of this it’s also important that we continue driving the unification of cryptographic offerings and monitoring tooling. While FBCrypto provides a unified set of offerings, there are other cryptographic use cases across Meta that use a different set of tools for telemetry and data collection. More non-trivial work is needed to achieve full unification with all use cases.</span></p>
<h2><span>Acknowledgments</span></h2>
<p><i><span>This work could not have been accomplished without the critical efforts of numerous folks, particularly Grace Wu, Ilya Maykov, Isaac Elbaz, and the rest of the CryptoEng team at Meta.</span></i></p>

		
	</div></div>
  </body>
</html>
