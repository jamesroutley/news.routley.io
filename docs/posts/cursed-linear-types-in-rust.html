<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://geo-ant.github.io/blog/2024/rust-linear-types-use-once/">Original</a>
    <h1>Cursed Linear Types in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Inspired by Jack Wrenn’s post on <a href="https://jack.wrenn.fyi/blog/undroppable/">Undroppable Types</a>
in Rust, I set out to see if it’s possible to create types that must be used exactly
once. From my understanding, those things are called <em>linear types</em>, but
don’t quote me on that<sup id="fnref:title" role="doc-noteref"><a href="#fn:title" rel="footnote">1</a></sup>.</p>

<p>Let’s see if we can create a struct <code>UseOnce&lt;T&gt;</code> which enforces that an instance
is used (or <em>consumed</em>) exactly once. It should be impossible to consume it
more than once, and it should produce a compile error if it’s not consumed at all.
The first part is trivial with destructive move semantics, the second
part is where we <del>steal</del> adapt Jack’s original idea.</p>



<div><div><pre><code><span>use</span> <span>core</span><span>::</span><span>mem</span><span>::</span><span>ManuallyDrop</span><span>;</span>
<span>use</span> <span>core</span><span>::</span><span>mem</span><span>::</span><span>MaybeUninit</span><span>;</span>

<span>pub</span> <span>struct</span> <span>UseOnce</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>MaybeUninit</span><span>&lt;</span><span>T</span><span>&gt;</span><span>);</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>UseOnce</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span><span>val</span><span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span><span>(</span><span>MaybeUninit</span><span>::</span><span>new</span><span>(</span><span>val</span><span>))</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>consume</span><span>&lt;</span><span>F</span><span>,</span> <span>R</span><span>&gt;</span><span>(</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>F</span><span>)</span> <span>-&gt;</span> <span>R</span>
    <span>where</span>
        <span>F</span><span>:</span> <span>FnOnce</span><span>(</span><span>T</span><span>)</span> <span>-&gt;</span> <span>R</span><span>,</span>
    <span>{</span>
        <span>// (1)</span>
        <span>let</span> <span>mut</span> <span>this</span> <span>=</span> <span>ManuallyDrop</span><span>::</span><span>new</span><span>(</span><span>self</span><span>);</span>
        <span>// (2)</span>
        <span>let</span> <span>mut</span> <span>val</span> <span>=</span> <span>MaybeUninit</span><span>::</span><span>uninit</span><span>();</span>
        <span>std</span><span>::</span><span>mem</span><span>::</span><span>swap</span><span>(</span><span>&amp;</span><span>mut</span> <span>this</span><span>.0</span><span>,</span> <span>&amp;</span><span>mut</span> <span>val</span><span>);</span>
        <span>unsafe</span> <span>{</span>
            <span>let</span> <span>val</span> <span>=</span> <span>val</span><span>.assume_init</span><span>();</span>
            <span>f</span><span>(</span><span>val</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Drop</span> <span>for</span> <span>UseOnce</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>const</span> <span>{</span>
        <span>panic!</span><span>(</span><span>&#34;UseOnce instance must be consumed!&#34;</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>instance</span> <span>=</span> <span>UseOnce</span><span>::</span><span>new</span><span>(</span><span>41</span><span>);</span>
    <span>// (3)</span>
    <span>// comment out this line to get a compile error</span>
    <span>let</span> <span>_result</span> <span>=</span> <span>instance</span><span>.consume</span><span>(|</span><span>v</span><span>|</span> <span>v</span> <span>+</span> <span>1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8bb04cf8311fd98e0506a1b764b72d2b">Playground Link</a>.
Again, the clever part is Jack Wrenn’s original idea. I was also surprised this
works. To my understanding, it relies on the fact that the compiler can reason
that the drop implementation does not have to be generated when <code>consume</code> is 
called due to ①. There’s some additional unsafe trickery in ②,
which is not terribly important but it’s actually safe. It allows me to use
<code>MaybeUninit&lt;T&gt;</code> instead of <code>Option&lt;T&gt;</code> as the inner type so that there’s no
space penalty as there could be if I had used an <code>Option</code>.</p>

<p>As is, the code compiles just fine, but if we comment out the <code>consume</code> below
③, it will fail with a compile error like so:</p>

<div><div><pre><code>error[E0080]: evaluation of `&lt;UseOnce&lt;i32&gt; as std::ops::Drop&gt;::drop::{constant#0}` failed
  --&gt; src/main.rs:27:9
   |
27 |         panic!(&#34;UseOnce instance must be consumed!&#34;)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at &#39;UseOnce instance must be consumed!&#39;, src/main.rs:27:9
   |
   = note: this error originates in the macro `$crate::panic::panic_2021` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)

note: erroneous constant encountered
  --&gt; src/main.rs:26:9
   |
26 | /         const {
27 | |         panic!(&#34;UseOnce instance must be consumed!&#34;)
28 | |         }
   | |_________^

note: the above error was encountered while instantiating `fn &lt;UseOnce&lt;i32&gt; as std::ops::Drop&gt;::drop`
   --&gt; /playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:574:1
    |
574 | pub unsafe fn drop_in_place&lt;T: ?Sized&gt;(to_drop: *mut T) {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0080`.
</code></pre></div></div>

<p>Not exactly pretty but it does the trick. Note, that the compile error
is <a href="https://www.reddit.com/r/rust/comments/1h0zcku/comment/lzexqsz/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">not triggered</a>
by simply running <code>cargo check</code>, but we need to run <code>cargo build</code>.</p>



<p>Unfortunately, the <code>UseOnce&lt;T&gt;</code> is not as useful or powerful as it might seem
at first sight. Firstly, since the compiler error is enforced by the <code>Drop</code> implementation, we
can just <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>mem::forget</code></a> the instance
and not actually consume it. I don’t feel this is a giant problem because it’s
still very explicit and arguably counts as a sort of consumption. However,
there’s a <a href="https://www.reddit.com/r/rust/comments/1h0zcku/comment/lzaggnp/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">more fundamental problem</a>
with linear types in Rust as pointed out by <code>u/Shnatsel</code> in the reddit thread
for this post. Note also that I am using the term <em>linear types</em> somewhat loosely and incorrectly,
please see <a href="https://www.reddit.com/r/rust/comments/1h0zcku/comment/lz7xox5/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">this comment thread</a>.</p>

<p>Secondly, the presented API allows us to “exfiltrate” the inner value of the <code>UseOnce&lt;T&gt;</code> instance
by just calling <code>consume</code> with the identity function. To address this, we can
replace the implementation of <code>consume</code> by two functions like so:</p>

<div><div><pre><code><span>pub</span> <span>fn</span> <span>consume</span><span>&lt;</span><span>F</span><span>,</span> <span>R</span><span>&gt;</span><span>(</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>F</span><span>)</span> <span>-&gt;</span> <span>R</span>
<span>where</span>
    <span>F</span><span>:</span> <span>FnOnce</span><span>(</span><span>&amp;</span><span>T</span><span>)</span> <span>-&gt;</span> <span>R</span><span>,</span>
<span>{</span>
    <span>let</span> <span>mut</span> <span>this</span> <span>=</span> <span>ManuallyDrop</span><span>::</span><span>new</span><span>(</span><span>self</span><span>);</span>
    <span>let</span> <span>mut</span> <span>val</span> <span>=</span> <span>MaybeUninit</span><span>::</span><span>uninit</span><span>();</span>
    <span>std</span><span>::</span><span>mem</span><span>::</span><span>swap</span><span>(</span><span>&amp;</span><span>mut</span> <span>this</span><span>.0</span><span>,</span> <span>&amp;</span><span>mut</span> <span>val</span><span>);</span>
    <span>unsafe</span> <span>{</span>
        <span>let</span> <span>val</span> <span>=</span> <span>val</span><span>.assume_init</span><span>();</span>
        <span>f</span><span>(</span><span>&amp;</span><span>val</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>consume_mut</span><span>&lt;</span><span>F</span><span>,</span> <span>R</span><span>&gt;</span><span>(</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>F</span><span>)</span> <span>-&gt;</span> <span>R</span>
<span>where</span>
    <span>F</span><span>:</span> <span>FnOnce</span><span>(</span><span>Pin</span><span>&lt;&amp;</span><span>mut</span> <span>T</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>R</span><span>,</span>
<span>{</span>
    <span>let</span> <span>mut</span> <span>this</span> <span>=</span> <span>ManuallyDrop</span><span>::</span><span>new</span><span>(</span><span>self</span><span>);</span>
    <span>let</span> <span>mut</span> <span>val</span> <span>=</span> <span>MaybeUninit</span><span>::</span><span>uninit</span><span>();</span>
    <span>std</span><span>::</span><span>mem</span><span>::</span><span>swap</span><span>(</span><span>&amp;</span><span>mut</span> <span>this</span><span>.0</span><span>,</span> <span>&amp;</span><span>mut</span> <span>val</span><span>);</span>
    <span>unsafe</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>val</span> <span>=</span> <span>val</span><span>.assume_init</span><span>();</span>
        <span>let</span> <span>pinned</span> <span>=</span> <span>Pin</span><span>::</span><span>new_unchecked</span><span>(</span><span>&amp;</span><span>mut</span> <span>val</span><span>);</span>
        <span>f</span><span>(</span><span>pinned</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=18cab23d9f56c50bfbae024f863233a7">Playground Link</a>.
Calling any of these functions will still consume the instance of <code>UseOnce&lt;T&gt;</code>,
but the functions only expose access to the inner value by shared or mutable
reference, respectively. The borrow checker prohibits simply passing the reference
to the outside. Note, that we have used the infamous <code>Pin</code> in the <code>consume_mut</code>
function to express that the inner value must not be moved out of this reference<sup id="fnref:unsafe" role="doc-noteref"><a href="#fn:unsafe" rel="footnote">2</a></sup>.</p>

<p>Thirdly, as was <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=02cc5096672900f10fb190595c6361ff">pointed out</a>
by <code>u/SkiFire13</code> in the <a href="https://www.reddit.com/r/rust/comments/1gzmwcb/undroppable_types/">original reddit thread</a>,
this trick relies on the compiler’s ability to reason 
<em>without optimizations</em> that the type will not be dropped<sup id="fnref:unspecified" role="doc-noteref"><a href="#fn:unspecified" rel="footnote">3</a></sup>. Thus,
simply sticking a function call between the creation and consumption of the instance
will make this code fail<sup id="fnref:panic" role="doc-noteref"><a href="#fn:panic" rel="footnote">4</a></sup>:</p>

<div><div><pre><code><span>fn</span> <span>foo</span><span>()</span> <span>{}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>instance</span> <span>=</span> <span>UseOnce</span><span>::</span><span>new</span><span>(</span><span>41</span><span>);</span>
    <span>foo</span><span>();</span>
    <span>let</span> <span>_result</span> <span>=</span> <span>instance</span><span>.consume</span><span>(|</span><span>v</span><span>|</span> <span>v</span> <span>+</span> <span>1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This code does not compile despite the value being consumed. You can see how
this severely limits the applicability of <code>UseOnce</code>. There is an even more cursed
remedy for that, which is using the idea of the <a href="https://github.com/mickvangelderen/prevent_drop">prevent_drop</a>
crate. In that crate, a non-existing external function is linked in the <code>Drop</code>
implementation, which moves the error to link time. That will make it work for
this case but it also makes the error even uglier<sup id="fnref:linker" role="doc-noteref"><a href="#fn:linker" rel="footnote">5</a></sup>.</p>


<div role="doc-endnotes">
  <ol>
    <li id="fn:title" role="doc-endnote">
      <p>Unless you are quoting the title of this article which explicitly says linear types… I feel stupid now. <a href="#fnref:title" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:unsafe" role="doc-endnote">
      <p>It’s still possible to use unsafe code that violates the semantic restrictions of <code>Pin</code> to do that, though. <a href="#fnref:unsafe" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:unspecified" role="doc-endnote">
      <p>To add insult to injury, this implementation relies on <a href="https://www.reddit.com/r/rust/comments/1gzmwcb/comment/lyzj7yi/">unspecified behavior</a> of the compiler. This won’t cause runtime UB though, to my understanding. So the worst thing that can happen is that this neat trick stops compiling alltogether. Thanks to <code>u/dydhaw</code> for <a href="https://www.reddit.com/r/rust/comments/1h0zcku/comment/lz7xox5/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">mentioning this</a>. <a href="#fnref:unspecified" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:panic" role="doc-endnote">
      <p>If you want to find out why, it’s explained in the comment thread. <a href="#fnref:panic" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:linker" role="doc-endnote">
      <p>Plus it introduces the can of worms of how to know that a symbol name is never going to be actually linked. There are ways around that, but I don’t feel they’ll be pretty. <a href="#fnref:linker" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>


    <div>
      <p><a href="https://ko-fi.com/geoant" target="_blank" title="Buy me a coffee :)">
          <img src="https://raw.githubusercontent.com/geo-ant/user-content/refs/heads/main/ko-fi-support-blue.svg" alt="Banner Image"/>
      </a></p>
    
  <div>
    
    
      <p><a href="https://geo-ant.github.io/blog/tags/#generics">generics</a>
    
      <a href="https://geo-ant.github.io/blog/tags/#metaprogramming">metaprogramming</a>
    
      <a href="https://geo-ant.github.io/blog/tags/#rust">rust</a>
    
  </p></div>

  <div>
  
    



<div>
	
	<ul id="gh-comments-list"></ul>
	<p id="no-comments-found">You can comment on this post using your GitHub account.</p>
	<p id="leave-a-comment">Join the discussion for this article on <a href="https://github.com/geo-ant/blog/issues/74">this ticket</a>. Comments appear on this page instantly.</p>
</div>

  

  
  </div>

</div></div></div>
  </body>
</html>
