<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/919426/38b2b5aaacc9bba0/">Original</a>
    <h1>Formalizing Python F-Strings</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 1 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>

<p>
Python&#39;s formatted strings, or &#34;f-strings&#34;, came relatively late to the
language, but have become a popular feature.  F-strings allow a compact
representation for the common task of interpolating program data into
strings, often in order to output them in some fashion.  Some
restrictions were placed on f-strings to simplify the implementation of
them, but those restrictions are not really needed anymore and, in
fact, are complicating the CPython parser.  That has led to a Python
Enhancement Proposal (PEP) to formalize the syntax of f-strings for the
benefit of Python users while simplifying the maintenance of the
interpreter itself.
</p>

<h4>Some history</h4>

<p>
<a href="https://lwn.net/Articles/656898/">F-strings got their start</a> in 2015, when <a href="https://peps.python.org/pep-0498/">PEP 498</a> (&#34;Literal String
Interpolation&#34;) was accepted for Python 3.6.  The PEP added a new way
to specify strings that would have values interpolated into them:
</p><pre>    answer = 42
    reply = f&#39;Obviously, the answer is {answer}&#39;
    # reply is now &#34;Obviously, the answer is 42&#34;
</pre><p>
But f-strings are far more than just that, because any arbitrary Python
expression can be placed between the curly brackets; the expression will be
evaluated and its value interpolated into the string:
</p><pre>    reply = f&#39;More answers: { [ answer+i for i in range(5) ] }&#39;
    # &#34;More answers: [42, 43, 44, 45, 46]&#34;
</pre><p>
The expression can, of course, contain other strings, including f-strings,
but PEP 498 imposed a limitation due to the (then) existing
parser.  Whatever type of quote was used to start the f-string could not be
used inside the expression portions (i.e. the parts inside curly
brackets).  So, simply cutting and pasting code into an f-string may not
work:
</p><pre>    foo = a[&#39;x&#39;] + a[&#39;y&#39;]
    f&#39;{foo}&#39;     # works, of course
    f&#39;{a[&#39;x&#39;]}&#39;  # fails with SyntaxError
    f&#39;{a[&#34;x&#34;]}&#39;  # workaround
</pre>


<p>
The current implementation for f-strings simply used the existing machinery
for handling other kinds of specialized strings, such as <tt>r&#39;&#39;</tt> for raw
strings or <tt>b&#39;&#39;</tt> for byte strings. But f-strings are fundamentally
different from the others because of the arbitrary expressions that are
allowed.  The advent of a <a href="https://lwn.net/Articles/816922/">new CPython
parser</a> for Python 3.9 in 2020 opened up some other
possibilities for implementing f-strings.
</p>

<p>
In 2021, Pablo Galindo Salgado <a href="https://lwn.net/ml/python-dev/CAFjbc8G7q=0EH1oD8wm9Ee+V2gcbkDycocJ-JgRrQL7b+hg-Kg@mail.gmail.com/">posted
to the python-dev mailing list</a>
that he was working on moving the parsing of f-strings into the CPython
parser.  That would mean some of the restrictions could potentially be
removed and &#34;<q>we can drop a considerable amount of
hand-written code</q>&#34;.  He was asking for opinions about the idea and on
the various options for 
restrictions that could be lifted.  That resulted in a fairly brief
discussion (by 
Python standards at least) that was generally favorable toward the idea.
</p>

<p>
At the 2022 Python Language Summit in April, Galindo Salgado <a href="https://pyfound.blogspot.com/2022/05/the-2022-python-language-summit-f.html">gave
a presentation</a> on
the idea, which was greeted with enthusiasm from various core developers,
including Eric V. Smith who developed f-strings and authored PEP 498.
So Galindo Salgado teamed up with  Batuhan Taskaya and Lysandros Nikolaou
to create <a href="https://peps.python.org/pep-0701/">PEP 701</a>
(&#34;Syntactic formalization of f-strings&#34;), which was <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046">announced
on the Python discussion forum</a> in mid-December.
</p>

<h4>PEP 701</h4>

<p>
The new PEP sets out &#34;<q>to lift some of the restrictions originally formulated
in PEP 498 and to provide a formalized grammar for f-strings that can be
integrated into the parser directly</q>&#34;.  It notes that the restrictions
were set to be removed in <a href="https://peps.python.org/pep-0536/">PEP 536</a> (&#34;Final Grammar
for Literal String Interpolation&#34;) but that PEP, written in 2016, has
never been implemented and was <a href="https://lwn.net/ml/python-dev/CAP1%3D2W5ELaSEuTaAc1_j%2BNYAgocRwoeX%3DoE0LxNgDqSNDL%2Bb%2Bw%40mail.gmail.com/">deferred
in 2019</a>.  In addition to removing the restriction
on reusing the f-string quote delimiter within expressions, as mentioned above,
the new PEP would dispense with a few other restrictions: escape
sequences using backslashes would be permitted in the expressions as would
comments in 
multi-line f-strings.  The following examples would work as expected if
PEP 701 gets adopted:
</p><pre>    &gt;&gt;&gt; a = [ &#39;hello&#39;, &#39;world&#39; ]
    &gt;&gt;&gt; f&#39;{&#34;\n&#34;.join(a)}&#39;
      File &#34;&lt;stdin&gt;&#34;, line 1
	f&#39;{&#34;\n&#34;.join(a)}&#39;
			 ^
    SyntaxError: f-string expression part cannot include a backslash

    &gt;&gt;&gt; f&#39;&#39;&#39;foo {
    ... bar # a comment about bar
    ... }&#39;&#39;&#39;
      File &#34;&lt;stdin&gt;&#34;, line 3
	}&#39;&#39;&#39;
	    ^
    SyntaxError: f-string expression part cannot include &#39;#&#39;
</pre><p>
PEP 701 points out that other languages (such as Ruby, JavaScript, Swift,
and C#) that have string interpolation mechanisms allowing expressions also
allow arbitrary nesting of said expressions.  The current limitations are
more or less just annoyances, but they are unnecessary—removing them would also
 substantially simplify the code that parses f-strings.
</p>

<p>
The main objection to the PEP centers around the ability to reuse the
quotes within the expression, and the arbitrary nesting it allows, due to
the ability to abuse the feature in various ways.  Steven D&#39;Aprano <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/22">took
exception</a> to two of the examples given in the PEP:
</p><blockquote>
<pre>    f&#34;These are the things: {&#34;, &#34;.join(things)}&#34;

    f&#34;{source.removesuffix(&#34;.py&#34;)}.c: $(srcdir)/{source}&#34;

    [...]
</pre>
The first two might be perfectly understandable to the parser, but as a
human reader, they make it more complicated and error-prone to work out
which quotes delimit the f-string and which do not. 
<p>
[...] I consider the first two examples <i>terrible code which should be
discouraged</i> and the fact that your PEP allows it is a point against it, not
in favour. 
</p><p>
Especially since we can get the same effect by just changing one of the
pairs of quotes to &#39;. So in this regard, the PEP doesn&#39;t even add
functionality. It just encourages people to write code which is harder to
read and more error prone. 
</p></blockquote>


<p>
Galindo Salgado <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/23">acknowledged</a>
those concerns and <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/24">started
a poll</a> to try to gauge the sentiments of the participants in the
discussion.  Currently, the poll is around two-thirds in favor of allowing
quote reuse in the expressions.  Paul Moore <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/30">said</a>
that he had voted in favor because he had encountered the problem along the
way. &#34;<q>And 
I think consistency in allowing whatever can be in an expression is easier
to explain and understand.</q>&#34;   He did suggest that the PEP add a warning
about overusing the feature, however.
</p>

<p>
Barry Warsaw <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/34">agreed</a>
with D&#39;Aprano
that the &#34;<tt>join()</tt>&#34; example was &#34;<q>challenging for me to
parse</q>&#34;, but he can see the consistency argument as well. &#34;<q>But maybe
for consistency, the answer should be to let people write terrible,
unreadable code!</q>&#34;  Galindo Salgado <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/40">pointed
out</a> that there is a cost beyond inconsistency, though:
</p><blockquote>
[...] limiting quote reuse raises quite a lot the complexity. This is
because when parsing the expression part now the parser needs to be aware
that is parsing an expression inside an f-string with a given [quote], and
that becomes even more tricky when f-strings are nested with different
quotes. 
<p>
This doesn&#39;t mean that this invalidates the &#34;code smell&#34; argument by any
means: I just want to give some context on the maintenance point.
</p></blockquote>


<p>
Mark Shannon <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/67">thought</a>
that adding the quote-reuse restriction back in would be irritating:
</p><blockquote>
Personally, I found the prohibition on reusing the same quote mildly annoying.
<tt>f&#34;You have the following in your basket: {&#34;, &#34;.join(items)}.&#34;</tt> seems
perfectly fine to me. 
<p>
But I think I would find the restriction much more annoying if I knew that
it was unnecessary, and that extra work had been put in just to stop me. 
</p></blockquote>


<p>
There are some horrific f-string abuses that are already possible, as
Marc-André Lemburg <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/68">demonstrated</a>. &#34;<q>Should we
really head on in the same direction even more ?</q>&#34;  He supports the PEP
because it simplifies the implementation and &#34;<q>removes some annoying bits
(e.g. the backslash limitation)</q>&#34;, but keeping the current quote
restriction removes the possibility of arbitrary nesting of f-strings,
which is a good thing in his mind.
</p>

<p>
&#34;Shashwat&#34; <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/70">suggested</a>
that the possibility of misuse is not a good enough reason to disallow
quote reuse, thus nesting, in the parser; &#34;<q>such restrictions belong in
linters and code formatters rather than in the language grammar
itself</q>&#34;. Lemburg <a href="https://discuss.python.org/t/pep-701-syntactic-formalization-of-f-strings/22046/74">agreed</a>
with that point, but also thought the PEP should be changed to discourage
that usage. &#34;<q>At the moment, it reads in a way which promotes reusing the
same quotes inside f-string expressions as a feature.</q>&#34; 
</p>



<p>
There were also concerns expressed about difficulties in doing syntax
highlighting in editors and 
other tools, 
but the consensus seems to be that those tools can and will be taught to
handle the quote reuse.  In fact, any of those tools that
support multiple languages have 
probably already had to deal with this issue since its existence is fairly
widespread.  In light of the poll and the 
discussion, the PEP authors decided to keep the lifting of the quote-reuse
restriction, though a new, lengthy <a href="https://peps.python.org/pep-0701/#considerations-regarding-quote-reuse">&#34;Considerations
regarding quote reuse&#34; section</a> was <a href="https://github.com/python/peps/pull/2939">added to the PEP</a>. 
The thread also contained some detailed discussion of the guts of the
implementation for CPython and other Python dialects.  The results of that
have been incorporated as well.
</p>

<p>
Much of the argument around quote reuse seems to boil down to readability,
which is highly subjective.  But unreadable code can (and will) be written,
even if people differ in their view of which particular constructs fail
their criteria.  As we saw in the <a href="https://lwn.net/Articles/918058/">discussions about None-aware operators</a>,
readability is often simply in the eye of the beholder.
</p>

<p>
The discussion has pretty much wound down at this point, so it would not be a
surprise to see the PEP make its way to the steering council for
pronouncement before long, which means it could be coming in
Python 3.12 in October.  It seems a foregone conclusion that the idea of
formalizing f-strings and replacing the hand-written parser code will be
accepted; that will reduce the code maintenance and could lead to better error
messages for f-strings, like <a href="https://lwn.net/Articles/895587/">those that have
been added elsewhere for CPython</a>.   The council could perhaps require
that the quote constraint be retained, but that seems unlikely given the
general reception; discouraging abuses of the feature via the PEP and
various tools 
may well be enough.
</p></div></div>
  </body>
</html>
