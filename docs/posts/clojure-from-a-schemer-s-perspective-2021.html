<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.more-magic.net/posts/thoughts-on-clojure.html">Original</a>
    <h1>Clojure from a Schemer&#39;s perspective (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Recently I joined <a href="https://www.bevuta.com">bevuta IT</a>, where I am now working on a big project written in <a href="https://www.clojure.org/">Clojure</a>.  I&#39;m very fortunate to be working in a Lisp for my day job!</p>
<p>As I&#39;ve mostly worked with Scheme and have used other Lisps here and there, I would like to share my perspective on the language.</p><a href="#overall-design">
<h2 id="overall-design">Overall design</h2></a>
<p>From a first view, it is pretty clear that Clojure has been designed from scratch by (mostly) one person who is experienced with Lisps and as a language designer.  It is quite clean and has <a href="https://download.clojure.org/papers/clojure-hopl-iv-final.pdf">a clear vision</a>. Most of the standard library has a very consistent API.  It&#39;s also nice that it&#39;s a <a href="http://www.nhplace.com/kent/Papers/Technical-Issues.html">Lisp-1</a>, which obviously appeals to me as a Schemer.</p>
<p>My favourite aspect of the language is that everything is designed with a functional-first mindset.  This means I can program in the same functional style as I tend to do in Scheme.  Actually, it&#39;s even more functional, because for example its maps (what would be hash tables in Scheme) are much less clunky to deal with.  In Scheme, SRFI-69 hash tables are quite imperative, with <tt>hash-table-set!</tt> and <tt>hash-table-update!</tt> being the ways to insert new entries, which of course mutate the existing object.  Similarly, Clojure vectors can easily be extended (on either end!) functionally.</p>
<p>The underlying design of Clojure&#39;s data structures must be different. It needs to efficiently support functional updates; you don&#39;t want to fully copy a hash table or vector whenever you add a new entry. I am not sure how efficient everything is, because the system I&#39;m working on isn&#39;t in production yet.  A quick look <a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentArrayMap.java">at the code</a> implies that various data structures are used under the hood for what looks like one data structure in the language.  That&#39;s a lot of complexity!  I&#39;m not sure that&#39;s a tradeoff I&#39;d be happy to make.  It makes it harder to reason about performance.  You might just be using a completely different underlying data structure than expected, depending on which operations you&#39;ve performed.</p><a href="#non-lispiness">
<h2 id="non-lispiness">(non) Lispiness</h2></a>
<p>To a seasoned Lisp or Scheme programmer, Clojure can appear positively <i>bizarre</i>.  For example, while there is a <tt>cons</tt> function, there are no cons cells, and <tt>car</tt> and <tt>cdr</tt> don&#39;t exist.  Instead, it has <tt>first</tt> and <tt>rest</tt>, which are definitely saner names for a language designed from scratch.  It has &#34;persistent lists&#34;, which are immutable lists, but in most day to day programming you will not even be <b>using</b> lists, as weird as that sounds!</p><a href="#symbols-and-keywords">
<h3 id="symbols-and-keywords">Symbols and keywords</h3></a>
<p>One thing that really surprised me is that symbols are not interned. This means that two symbols which are constructed on the fly, or when read from the same REPL, are not identical (as in <tt>eq</tt> or <tt>eq?</tt>) to one another:</p>
<pre><tt>user&gt; <span>(<span>= &#39;foo &#39;foo</span>)</span>
true
user&gt; <span>(<span>identical? &#39;foo &#39;foo</span>)</span>
false</tt></pre>
<p>Keywords seem to fulfil most &#34;symbolic programming&#34; use cases.  For example, they&#39;re almost always used as &#34;keys&#34; in maps or when specifying options for functions.  Keywords <i>are</i> interned:</p>
<pre><tt>user&gt; <span>(<span>= <span>:foo</span> <span>:foo</span></span>)</span>
true
user&gt; <span>(<span>identical? <span>:foo</span> <span>:foo</span></span>)</span>
true</tt></pre>
<p>Code is still (mostly) expressed as lists of symbols, though.  When you&#39;re writing macros you&#39;ll deal with them a lot.  But in &#34;regular&#34; code you will deal more with keywords, maps and vectors than lists and symbols.</p><a href="#numeric-tower">
<h3 id="numeric-tower">Numeric tower</h3></a>
<p>A favorite gotcha of mine is that integers <a href="https://clojure.org/reference/data_structures#Numbers">are not automatically promoted to bignums</a> like in most Lisps that support bignums.  If you need bignums, you have to use special-purpose operators like <tt>+&#39;</tt> and <tt>-&#39;</tt>:</p>
<pre><tt>user&gt; <span>(<span>* <span>(<span>bit-shift-left 1 62</span>)</span> 2</span>)</span>
Execution error <span>(<span>ArithmeticException</span>)</span> at user/eval51159 <span>(<span>REPL:263</span>)</span>.
integer overflow
user&gt; <span>(<span>*&#39; <span>(<span>bit-shift-left 1 62</span>)</span> 2</span>)</span>
9223372036854775808N

user&gt; <span>(<span>* <span>(<span>bit-shift-left 1 62</span>)</span> 2N</span>)</span> 9223372036854775808N
user&gt; <span>(<span>* 1N 1</span>)</span> 1N</tt></pre>
<p>This could lead to better performance at the cost of more headaches when dealing with the accidental large numbers in code that was not prepared for them.</p>
<p>What about rationals, you ask?  Well, those are just treated as &#34;the unusual, slow case&#34;.  So even though they <i>do</i> normalize to regular integers when simplifying, operations on those always return BigInts:</p>
<pre><tt>user&gt; <span>(<span>+ 1/2 1/4</span>)</span>
3/4
user&gt; <span>(<span>+ 1/2 1/2</span>)</span>
1N
user&gt; <span>(<span>/ 1 2</span>)</span> 1/2
user&gt; <span>(<span>/ 4 2</span>)</span> 2</tt></pre>
<p>The sad part is, bitwise operators do not support bignums, <i>at all</i>:</p>
<pre><tt>user&gt; <span>(<span>bit-shift-right 9223372036854775808N 62</span>)</span>
Execution error <span>(<span>IllegalArgumentException</span>)</span> at user/eval51167 <span>(<span>REPL:273</span>)</span>.
bit operation not supported for: class clojure.lang.BigInt
user&gt; <span>(<span>bit-shift-right&#39; 9223372036854775808N 62</span>)</span> Syntax error compiling at <span>(<span>*cider-repl test:localhost:46543<span>(<span>clj</span>)</span>*:276:7</span>)</span>.
Unable to resolve symbol: bit-shift-right&#39; in this context</tt></pre>
<p>There&#39;s one benefit to all of this: if you know the types of something going into numeric operators, you will typically know the type that comes out, because there is no automatic coercion.  Like I mentioned, this may provide a performance benefit, but it also simplifies reasoning about types.  Unfortunately, this does not work as well as you would hope because division may change the type, depending on whether the result divides cleanly or not.</p><a href="#syntax">
<h3 id="syntax">Syntax</h3></a>
<p>For many Lispers, this is the elephant in the room.  Clojure certainly qualifies as a Lisp, but it is much heavier on syntax than most other Lisps.  Let&#39;s look at a small contrived example:</p>
<pre><tt><span>(<span><i><span>let</span></i> [foo-value <span>(<span>+ 1 2</span>)</span>
      bar-value <span>(<span>* 3 4</span>)</span>]
  {<span>:foo</span> foo-value
   <span>:bar</span> bar-value}</span>)</span></tt></pre>
<p>This is a <tt>let</tt> just like in Common Lisp or Scheme.  The bindings are put inside square brackets, which is literal syntax for <i>vectors</i>.  Inside this vector, key-value pairs are interleaved, like in a Common Lisp <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/26_glo_p.htm#property_list">property list</a>.</p>
<p>The lack of extra sets of &#34;grouping&#34; parentheses is a bit jarring at first, but you get used to it rather quickly.  I still mess up occasionally when I accidentally get an odd number of entries in a binding vector.  Now, the<tt> {:foo foo-value :bar bar-value} </tt>syntax is a <i>map</i>, which acts like a hash table (more on that below).</p>
<p>There doesn&#39;t seem to be a good rationale about why vectors are used instead of regular lists, though.  What I <i>do</i> really like is that all the binding forms (even function signatures!) support <a href="https://clojure.org/guides/destructuring">destructuring</a>.  The syntax for destructuring maps is a bit ugly, but having it available is super convenient.</p>
<p>What I regard as a design mistake is the fact that Clojure allows for optional commas in lists and function calls.  Commas are just whitespace to the reader.  For example:</p>
<pre><tt><span>(<span>= [1, 2, 3, 4] [1 2 3 4]</span>)</span> =&gt; true
<span>(<span>= &#39;<span>(<span>1, 2, 3, 4</span>)</span> &#39;<span>(<span>1 2 3 4</span>)</span></span>)</span> =&gt; true
<span>(<span>= {<span>:foo</span> 1, <span>:bar</span> 2, <span>:qux</span> 3} {<span>:foo</span> 1 <span>:bar</span> 2 <span>:qux</span> 3}</span>)</span> =&gt; true
<span>(<span>= <span>(<span>foo 1, 2, 3, 4</span>)</span> <span>(<span>foo 1 2 3 4</span>)</span></span>)</span> =&gt; true
<span>(<span>= [,,,,,,1,,,2,3,4,,,,,,] [1 2 3 4]</span>)</span> =&gt; true</tt></pre>
<p>Maybe this is to make up for removing the extra grouping parentheses in <tt>let</tt>, <tt>cond</tt> and map literal syntax?  With commas you can add back some clarity about which items belong together.  Rarely anybody uses commas in real code, though.  And since it&#39;s optional it doesn&#39;t make much sense.</p>
<p>This has an annoying ripple effect on quasiquotation.  Due to this decision, a different character has to be used for <tt>unquote</tt>, because the comma was already taken:</p>
<pre><tt>`<span>(<span>1 2 ~<span>(<span>+ 1 2</span>)</span></span>)</span> =&gt; <span>(<span>1 2 3</span>)</span>
`<span>(<span>1 2 ~@<span>(<span>list 3 4</span>)</span></span>)</span> =&gt; <span>(<span>1 2 3 4</span>)</span></tt></pre>
<p>This might seem like a small issue, but it is an unnecessary and stupid distraction.</p><a href="#minimalism">
<h2 id="minimalism">Minimalism</h2></a>
<p>One of the main reasons I enjoy Scheme so much is its goal of minimalism.  This is achieved through elegant building blocks.  This is embodied by the <a href="https://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-3.html#%_chap_Temp_3">Prime Clingerism</a>:</p>
<pre><tt>  Programming languages should be designed not by piling feature on
  top of feature, but by removing the weaknesses and restrictions
  that make additional features appear necessary.</tt></pre>
<p>Let&#39;s check the size of the <tt>clojure.core</tt> library.  It clocks in at 640 identifiers (v1.10.1), which is a lot more than R5RS Scheme&#39;s 218 identifiers.  It&#39;s not an entirely fair comparison as Scheme without SRFI-1 or SRFI-43 or an FFI has much less functionality as well. Therefore, I think Clojure&#39;s core library is fairly small but not exactly an exercise in minimalism.</p>
<p>Clojure reduces its API size considerably by having a &#34;<a href="https://clojure.org/reference/sequences">sequence</a> abstraction&#34;. This is similar to Common Lisp&#39;s sequences: you can call <tt>map</tt>, <tt>filter</tt> or <tt>length</tt> on any sequence-type object: lists, vectors, strings and even maps (which are treated as key/value pairs). However, it is less hacky than in Common Lisp because for example with <tt>map</tt> you don&#39;t need to specify which kind of sequence you want to get back.  I get the impression that in Common Lisp this abstraction is not very prominent or used often but in Clojure <i>everything</i> uses sequences.  What I also liked is that sequences can be <i>lazy</i>, which removes the need for special operators as well.</p>
<p>If you compare this to Scheme, you have special-purpose procedures for every concrete type: <tt>length</tt>, <tt>vector-length</tt>, <tt>string-length</tt> etc.  And there&#39;s no <tt>vector-map</tt> in the standard, so you need <a href="https://srfi.schemers.org/srfi-43/srfi-43.html#vector-map"><tt>vector-map</tt> from SRFI 43</a>.  Lazy lists are a <a href="https://srfi.schemers.org/srfi-41/srfi-41.html">separate type</a> with its own set of specialized operators.  And so on and so forth.  Using concrete types everywhere provides for less abstract and confusing code and the performance characteristics of an algorithm tend to be clearer, but it also leads to a massive growth in library size.</p>
<p>After a while I really started noticing mistakes that make additional features appear necessary: for example, there&#39;s a special macro called <tt>loop</tt> to make tail recursive calls.  This uses a keyword <tt>recur</tt> to call back into the loop.  In Scheme, you would do that with a named <tt>let</tt> where you can choose your own identifier to recur.  It&#39;s also not possible to nest such Clojure loops, because the identifier is hardcoded.  So, this called for adding <a href="https://archive.clojure.org/design-wiki/display/design/Named%2Bloops%2Bwith%2Brecur-to.html">another feature</a>, which is currently in proposal.  Speaking of <tt>recur</tt>, it is also used for tail recursive self-calls.  It relies on the programmer rather than the compiler to mark calls as tail recursive. I find this a bit of a cop-out, especially in a language that is so heavily functional.  Especially since this doesn&#39;t work for mutually tail-recursive functions.  The <a href="https://www.windley.com/archives/2008/11/tail_optimized_mutual_recursion_in_clojure.shtml">official way to do those</a> is even more of a crutch.</p>
<p>I find the special syntax for one-off lambdas <tt>#(foo %)</tt> just as misguided as <a href="https://srfi.schemers.org/srfi-26/srfi-26.html">SRFI 26</a> (<tt>cut</tt> and <tt>cute</tt>).  You often end up needing to tweak the code in such a way that you have to transform the lambda to a proper <tt>fn</tt>. And just like <tt>cut</tt>, it doesn&#39;t save that many characters anyway and makes the code less readable.</p>
<p>The <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E"><tt>-&gt;</tt></a> macro is a clever hack which allows you to &#34;thread&#34; values through expressions.  It implicitly adds the value as the first argument to the first forms, the result of that form as the first argument for the next, etc.  Because the core library is quite well-designed, this works 90% of the time.  Then the other 10% you need <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E%3E"><tt>-&gt;&gt;</tt></a> which does the same but adds the implicit argument at the <i>end</i> of the forms.  And that&#39;s not always enough either, so they decided to add a generic version called <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/as-%3E"><tt>as-&gt;</tt></a> which binds the value to a name so you can put it at any place in the forms.  These macros also don&#39;t compose well.  For example, sometimes you need a <tt>let</tt> in a <tt>-&gt;</tt> chain to have a temporary binding. That doesn&#39;t work because you can&#39;t randomly insert forms into <tt>let</tt>, so you have to split things up again.</p>
<p>And as I note below, the minimalism is kind of &#34;fake&#34; because some essentials simply aren&#39;t provided; you have to rely on Java for that.</p><a href="#java-integration">
<h2 id="java-integration">Java integration</h2></a>
<p>Clojure was originally designed as a &#34;hosted language&#34;, so it leverages the JVM.  It does this admirably well; Java classes can be <a href="http://clojure-doc.org/articles/language/interop.html">seamlessly invoked through Clojure</a>, without any ceremony:</p>
<pre><tt>user&gt; <span>(<span>java.util.UUID/randomUUID</span>)</span>
#uuid <span>&#34;bb788bae-5099-4a64-9c37-f6219d40a47f&#34;</span>

user&gt; <span>(<span>import &#39;java.util.UUID</span>)</span>
java.util.UUID
user&gt; <span>(<span>UUID/randomUUID</span>)</span>
#uuid <span>&#34;0bfd2092-14e1-4b88-a465-18698943ea4e&#34;</span></tt></pre>
<p>The downside is that the above is <i>the</i> way to generate a random UUID.  So even though uuids have literal syntax in Clojure (as <tt>#uuid &#34;...&#34;</tt>), there is no Lispy API for them in the Clojure standard library.  This can be pretty frustrating, especially in the beginning. There&#39;s no clear indication where to look; sometimes you&#39;ll be poring over Java language docs for random stuff you thought would have a Clojure interface (like, say, creating temporary files or dealing with byte arrays).  At those moments, you&#39;re basically programming Java with parentheses.</p>
<p>Having said that, there will often be community-provided nicer APIs for many of those things, but then you need to decide between adding an extra dependency just for a slightly nicer syntax.</p><a href="#development-style">
<h2 id="development-style">Development style</h2></a><a href="#repl-driven-development">
<h3 id="repl-driven-development">REPL-driven development</h3></a>
<p>Speaking of Java, one thing that constantly bothers me is the slow startup times of the REPL.  In my current project, it takes almost 30 seconds to boot up a development REPL.  Half a minute!</p>
<p>Luckily, there&#39;s great Slime-like Emacs integration with <a href="https://cider.mx/">CIDER</a>.  Basically, the only sane way to do iterative development is by connecting to a REPL first thing you do and then sending your code to it all the time.</p>
<p>Now, this may sound weird from a Scheme programmer, but I never fully bought into the REPL style of developing.  Sure, I experiment all the time in the REPL to try out a new API design or to quickly iterate on some function I&#39;m writing.  But my general development style tends more towards the &#34;save and then run the test suite from an xterm&#34;. Relying solely on the REPL just &#34;feels&#34; jarring to me.  I also constantly run into issues where re-evaluating a buffer doesn&#39;t get rid of global state that was built up on a previous run.  When this happens, I&#39;m testing an old version of some function without realising it.  Keeping track of the &#34;live&#34; state versus the textual code I&#39;m looking at is a total mind fuck for me.  I don&#39;t understand how others can do this.</p>
<p>Another thing I seem to constantly do is write some code, have the tests go all green, only to see the CI crash on some cyclic dependency in my namespaces.  The REPL does not always see those, because reloading a buffer with a namespace declaration works just fine when you loaded the imported namespaces before, even though they refer to the namespace being re-evaluated.</p>
<p>One thing I really find very nice when you&#39;re using CIDER is that everything (and I do mean <i>everything</i>) from Clojure is just a &#34;jump to source&#34; away.  Most of the builtin functions seems to be written in Clojure itself.  For example, if you want to know how <tt>map</tt> is implemented, you can just press <tt>M-.</tt> to see it.</p><a href="#maps-and-keywords-for-everything">
<h3 id="maps-and-keywords-for-everything">Maps and keywords for everything</h3></a>
<p>One thing you&#39;ll really notice is that in idiomatic Clojure code, maps are used for everything.  A map is a functionally updateable hash table.  It looks like this:</p>
<pre><tt>{<span>:key-1</span> <span>&#34;value 1&#34;</span>
 <span>:key-2</span> <span>&#34;value 2&#34;</span>}</tt></pre>
<p>This lends to a very dynamic style of programming, very much like you would in (dare I say it?) PHP.  A bit of a strange comparison, but PHP also makes dealing with arrays (which double as maps in a weird way) extremely ergonomic.  There, missing nested keys are automatically created on the fly and because of a strange quirk in its developmental history, arrays are the only objects which are passed by value.  This means you can program in a referentially transparent way, while still mutating them inside functions at will.  Not exactly the same mechanism, but the end effect on programming style feels very similar: you reach for them whenever you want to bunch some stuff together.  It is the go-to data structure when you need flexibility.</p>
<p>In other Lisps you&#39;d use alists (or plists, or SRFI-69 hash tables) for this, but they don&#39;t deal so well with nested maps and the library is not as convenient.  For example, you can easily select, drop and rename keys in a map:</p>
<pre><tt><span>(<span>-&gt; {<span>:key-1</span> <span>&#34;value 1&#34;</span> <span>:key-2</span> <span>&#34;value 2&#34;</span>}
    <span>(<span>set/rename-keys {<span>:key-1</span> <span>:key}</span></span>)</span>
    <span>(<span>dissoc <span>:key-2</span></span>)</span>
    <span>(<span>assoc <span>:foo</span> <span>&#34;bar&#34;</span></span>)</span></span>)</span> =&gt; {<span>:key</span> <span>&#34;value 1&#34;</span> <span>:foo</span> <span>&#34;bar&#34;</span>}</tt></pre>
<p>This <tt>-&gt;</tt> notation took me a while to get used to by the way, and I&#39;m still not entirely comfortable with it.  I explained how it works above.  It&#39;s a macro for &#34;threading&#34; expressions.  In Scheme, you&#39;d probably use a <tt>let*</tt> for this, or something.  In Clojure that would look like this:</p>
<pre><tt><span>(<span><i><span>let</span></i> [map {<span>:key-1</span> <span>&#34;value 1&#34;</span> <span>:key-2</span> <span>&#34;value 2&#34;</span>}
      map <span>(<span>set/rename-keys map {<span>:key-1</span> <span>:key}</span></span>)</span>
      map <span>(<span>dissoc map <span>:key-2</span></span>)</span>
      map <span>(<span>assoc map <span>:foo</span> <span>&#34;bar&#34;</span></span>)</span>]
  map</span>)</span> =&gt; {<span>:key</span> <span>&#34;value 1&#34;</span> <span>:foo</span> <span>&#34;bar&#34;</span>}</tt></pre>
<p>As you can see, the version with <tt>-&gt;</tt> is much more convenient and less repetitive.  Unfortunately, it doesn&#39;t compose that well (duh, it&#39;s a macro), but because of the way the standard library is designed it is more useful than it would seem at first glance.</p>
<p>Anyway, the way maps are typically used everywhere in a project means that there&#39;s a lot less &#34;structure&#34; to your data structures.  It is extremely convenient to use maps, even though there are also things like <a href="https://clojure.org/reference/datatypes">records</a> and <a href="https://clojure.org/reference/protocols">protocols</a>.  Because of their convenience, you&#39;ll end up using maps for everything.  As I&#39;ve noticed in my refactorings, when you change the structure of maps, a lot of code is going to break without a clear indication of where it went wrong.</p>
<p>This is made extra painful by &#34;nil punning&#34;.  For example, when you look up something in a map that doesn&#39;t exist, <tt>nil</tt> is returned. In Clojure, many operations (like <tt>first</tt> or <tt>rest</tt>) on <tt>nil</tt> just return <tt>nil</tt> instead of raising an error.  So, when you think you are looking up something in a map, but the &#34;map&#34; is actually <tt>nil</tt>, it will not give an error, but it will return <tt>nil</tt>.</p>
<p>Now like I said, <i>sometimes</i> you may get an error on <tt>nil</tt>.  It&#39;s a bit unclear which operations are nil-punning and which will give a proper error.  So when you finally get a <tt>nil</tt> error, you will have a hell of a time trying to trace back where this <tt>nil</tt> got generated, as that may have been several function calls ago.  This is an example where I really like the strictness of Scheme as compared to some other Lisps, as nil-punning is traditionally a dynamic Lisp thing; it&#39;s not unique to Clojure.</p><a href="#multimethods-with-keywords">
<h3 id="multimethods-with-keywords">Multimethods with keywords</h3></a>
<p>Initially, I was quite impressed by the way multimethods work; they&#39;re super simple and clean, yet powerful.  First, you declare the multimethod and a &#34;decision procedure&#34;, which returns a value that can be compared:</p>
<pre><tt><span>(<span><i><span>defmulti</span></i> say-hi <span>:kind</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> say-hi <span>:default</span> [animal]
  <span>(<span>println <span>(<span><span>:name</span> animal</span>)</span> <span>&#34;says hello&#34;</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> say-hi <span>:duck</span> [animal]
  <span>(<span>println <span>(<span><span>:name</span> animal</span>)</span> <span>&#34;says quack&#34;</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> say-hi <span>:dog</span> [animal]
  <span>(<span>println <span>(<span><span>:name</span> animal</span>)</span> <span>&#34;says woof&#34;</span></span>)</span></span>)</span>

<span>(<span>say-hi {<span>:name</span> <span>&#34;Daffy&#34;</span> <span>:kind</span> <span>:duck}</span></span>)</span>  =&gt; <span>&#34;Daffy says quack&#34;</span>
<span>(<span>say-hi {<span>:name</span> <span>&#34;Pluto&#34;</span> <span>:kind</span> <span>:dog}</span></span>)</span>   =&gt; <span>&#34;Pluto says woof&#34;</span>
<span>(<span>say-hi {<span>:name</span> <span>&#34;Peter&#34;</span> <span>:kind</span> <span>:human}</span></span>)</span> =&gt; <span>&#34;Peter says hello&#34;</span></tt></pre>
<p>Using multimethods takes some care and taste, because it splits up your logic.  So instead of having one place where you have decisions made with an <tt>if</tt> or <tt>cond</tt> tree, you have a function call and then depending on how the multimethod was defined, a different function will be called.  This is basically what makes C++ so difficult to deal with in large projects: when people use function overloading, it can get really messy.  You need to figure out which of the many things called &#34;say-hi&#34; is actually called in a situation, before you can dive into that implementation.</p>
<p>Compared to the insane amount of customizability that e.g. CLOS offers you, the design restraint shown in Clojure multimethods was nice to see, but then I realised this simplicity can be completely defeated by building <a href="https://clojure.org/reference/multimethods">hierarchies</a>. That is, Clojure allows you to define a hierarchy on <i>keywords</i>. This was a huge wtf for me, because to me, keywords are just static entities that are unrelated to eachother.</p>
<p>When you realise how Clojure keywords can be namespaced, it makes slightly more sense: this gives them some separation.</p>
<p>A keyword can appear in &#34;bare&#34; form like <tt>:foo</tt>.  This is a globally scoped keyword that belongs to no particular code.  It&#39;s definitely not smart to hang a hierarchy onto such a keyword, and you&#39;re also better off not adding any &#34;meta attributes&#34; to them.</p>
<p>The other form is <tt>::foo</tt>, which puts the keyword in the current namespace, which is shorthand for <tt>::more-magic.net/foo</tt> if you are in the <tt>more-magic.net</tt> namespace.</p><a href="#conclusion">
<h2 id="conclusion">Conclusion</h2></a>
<p>All in all, Clojure is a well-designed language with neat features and it&#39;s certainly a lot better than most other JVM languages.  There are things in it that I wish Scheme had, and it&#39;s certainly functional and modern.  As a general programming language, I just can&#39;t get over the JVM and all its Java trappings, which is just not my cup of tea.</p>
<p>Apart from the JVM, there are some gratuitous departures from traditional Lisps, especially the &#34;rich syntax&#34; and the extreme reliance and overloading of keywords and maps.</p>
<p>As always, such things are a matter of taste, so take my opinion with a large grain of salt.</p></div></div>
  </body>
</html>
