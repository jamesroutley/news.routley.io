<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jzhao.xyz/posts/bft-json-crdt/">Original</a>
    <h1>Building a BFT JSON CRDT</h1>
    
    <div id="readability-page-1" class="page"><article>
      
      <p>
        Last updated 
Nov 16, 2022

 
          
<a href="https://github.com/jackyzha0/quartz/tree/hugo/content/posts/bft-json-crdt.md" rel="noopener">Edit Source</a>


      </p>
      

      




      






  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  








  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  

  
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        
        
        
      
    
  











  
  


<p><img src="https://jzhao.xyz/thoughts/images/bft-crdt-cover.jpg" width="auto"/></p>
<p>CRDTs are a family of data structures that are designed to be replicated across multiple computers without needing to worry about conflicts when people write data to the same place. If you’ve ever had to deal with a nasty <code>git</code> merge conflict, you know how painful these can be to resolve.</p>
<p>CRDTs mathematically guarantee that an application can <em>safely</em> update their local state without needing to coordinate with all of its peers. By avoiding the extra coordination overhead, they have very good latency properties and work well in scenarios where real-time collaboration is needed (e.g. text editing, presence, chat, etc.).</p>
<p>Over the past few years, really cool open source CRDT libraries like 

<a href="https://github.com/automerge" rel="noopener">Automerge</a> and 

<a href="https://github.com/yjs/yjs" rel="noopener">Yjs</a> have emerged that enable developers to easily add these replicated data types to their own applications. Their support for JSON means that most web-applications can just plug-and-play, enabling collaborative experiences to be created easily.</p>
<p>What normally would have taken weeks or months of engineering to setup infrastructure for a collaborative web experience can be done in a day, bringing us one step closer to a future where the internet feels more default-multiplayer, cozy, and alive with life.</p>
<p>I learn best through building so I set out to write 

<a href="https://github.com/jackyzha0/bft-json-crdt" rel="noopener">my own CRDT library from scratch</a> to grok what was going on under the hood. When I was first learning about it, I spent a good few months scratching my head trying to read the papers. A lot of the literature took a long time for me to understand and required me to learn a non-trivial amount about <a href="https://jzhao.xyz/thoughts/Order-theory" rel="noopener" data-src="/thoughts/Order-theory">order theory</a> and <a href="https://jzhao.xyz/thoughts/distributed-systems" rel="noopener" data-src="/thoughts/distributed-systems">distributed systems</a>.</p>
<p>I write this blog post mostly as a note to my past self, distilling a lot of what I’ve learned since into a blog post I wish I had read before going in. I hope you find this useful too.</p>
<p>As a brief warning, the target audience of this blog post are people who have worked with a bit distributed systems in the past and is curious about the realm of CRDTs. I try my best to explain any relevant terminology when it comes up but familiarity with the topics helps a lot!</p>
<p><em>This blog post is really long so use the Table of Contents at the top to jump to whatever section interests you the most!</em></p>
<a href="#how-crdts-differ-from-traditional-databases"><h2 id="how-crdts-differ-from-traditional-databases"><span arialabel="Anchor"># </span>How CRDTs differ from traditional databases</h2></a>
<p>Before we really dive into CRDT internals, we first need to understand how they are different from databases. When I normally think of shared state, I think of databases. However, the guarantees that databases provide are <em>really</em> different than the ones CRDTs provide.</p>
<p>Traditional databases focus on a property called <a href="https://jzhao.xyz/thoughts/consistency" rel="noopener" data-src="/thoughts/consistency">linearizability</a>, which guarantees that all operations behave as if executed on a <em>single copy of the data</em>. We call this canonical view the <strong>primary site</strong>. Every read in a linearizable system, no matter what database node you read from, gives you an up to date value.</p>
<p><img src="https://jzhao.xyz/thoughts/images/linearizability.jpg" width="auto"/></p>
<p>This is great for allowing developers to reason about distributed applications more easily (you just treat your distributed database like a single database). There are no conflicts by definition because there is only one authoritative view on what the right state is.</p>
<p>However it isn’t without downsides either. Achieving this property adds a lot of overhead because both writes <em>and reads</em> need to coordinate (the dashed lines in the diagram above) across all database nodes to ensure consistency. This creates an availability problem: if you can’t reach a majority of your nodes, you can’t process any operations.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<p>CRDTs kind of throw all of that out the window and embrace the eventual nature of the real world. In an often cited essay titled <em><a href="https://jzhao.xyz/thoughts/A-Certain-Tendency-Of-The-Database-Community" rel="noopener" data-src="/thoughts/A-Certain-Tendency-Of-The-Database-Community">A Certain Tendency Of The Database Community</a></em>, the author argues that trying to provide “single system image” semantics (read: <a href="https://jzhao.xyz/thoughts/consistency" rel="noopener" data-src="/thoughts/consistency">linearizability</a>) is fundamentally flawed and at odds with how systems operate in the physical world.</p>
<p>In the real world, it takes time for us to learn about things that are happening around us and around the world. It takes time for our mail to send, calls to go through, and light to travel between servers across the world. We can take inspiration from the real world and embrace a design that considers every member in the system as the primary site for the data that it generates.</p>
<p>This means we allow peers to actually have different states as long as they <em>eventually</em> converge to a correct result. By relaxing the constraint on needing a globally consistent result, we remove the need to wait for all of our replicas to agree. In more formal distributed systems language, we trade linearizability for a property called <strong>strong eventual consistency</strong>:</p>
<ul>
<li>All updates will <em>eventually</em> reach every node</li>
<li>Every node that has received the same updates will have the same state</li>
</ul>
<a href="#when-should-we-use-strong-eventual-consistency-over-linearizability"><h3 id="when-should-we-use-strong-eventual-consistency-over-linearizability"><span arialabel="Anchor"># </span>When should we use strong eventual consistency over linearizability?</h3></a>
<p>It turns out that this is good enough most of the time. 

<a href="https://databeta.wordpress.com/2010/10/28/the-calm-conjecture-reasoning-about-consistency/" rel="noopener">Conventional wisdom</a> in the database world would agree that perfect data consistency is way too expensive in terms of both latency and bandwidth if changes happen frequently. Using eventually consistent approaches generally work better as temporary inconsistencies work out in most cases.</p>
<blockquote>
<p>Two users might simultaneously withdraw money from an account and end up with more money than the account ever held. Would a bank ever want this behavior? In practice, yes. An ATM’s ability to dispense money (availability) outweighs the cost of temporary inconsistency in the event that an ATM is partitioned from the master bank branch’s servers. In the event of overdrawing an account, banks have a well-defined system of external compensating actions: for example, overdraft fees charged to the user.</p>
<p>from <em>

<a href="https://queue.acm.org/detail.cfm?id=2462076" rel="noopener">Eventual Consistency Today: Limitations, Extensions, and Beyond</a></em></p>
</blockquote>
<a href="#what-actually-is-a-crdt"><h2 id="what-actually-is-a-crdt"><span arialabel="Anchor"># </span>What actually is a CRDT</h2></a>
<p>Ok so after about 1000 words, you’re probably asking “wtf is a CRDT??”. Maybe we should define that now.</p>
<p>CRDT stands for conflict-free/commutative/convergent replicated data type. Funnily enough, there is no strong consensus on what the C actually stands for<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. Regardless of the name, the tldr; is the same:</p>
<ul>
<li>You can write and read from your local copy of the data without needing to coordinate with other peers</li>
<li>Over time, all nodes converge to the same state by sending each other messages about operations they have performed on their local data
<ul>
<li>Because of the eventual nature of message delivery, there is no guarantee that the state across all the actors are consistent at any given moment</li>
<li><strong>If the CRDT is written properly, a view of a CRDT can only ever be out-of-date, but never incorrect</strong></li>
</ul>
</li>
<li>Each operation contains the necessary metadata to figure out a deterministic way to merge any operations that may happen concurrently
<ul>
<li>I’ll note here that the term ‘conflict-free’ is a little misleading. <strong>It’s not that conflict doesn’t ever occur, but rather that CRDTs are always able to determine how to resolve the conflict up front</strong> (without user intervention)</li>
</ul>
</li>
<li>CRDTs always try to preserve user intent and try not to lose data whenever possible
<ul>
<li>If two people insert a character into a string at the same spot, it will try to keep both edits</li>
<li>Note that these is inherently <em>different</em> from consensus methods. Collaboration involves keeping <em>all</em> edits and merging them. Consensus involves picking one of several proposed values and agreeing on it</li>
</ul>
</li>
</ul>
<p>Again, CRDTs are a <em>family</em> of data structures. There is no one single CRDT. You can make CRDTs that produce single values (registers), lists, maps, graphs, JSON, and many more I haven’t listed here. However, they can’t represent everything. A fundamental limitation here is that there are certain types of data structures (like sets) that <em>cannot</em> be made into CRDTs<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. We’ll talk more about these limitations later.</p>
<p>Now equipped with a 30,000ft overview of CRDTs, let’s dive into how they resolve conflicts.</p>
<a href="#ordering-messages"><h3 id="ordering-messages"><span arialabel="Anchor"># </span>Ordering Messages</h3></a>
<blockquote>
<p>A small note: this part will be pretty heavy on theory. If that’s not your cup of tea, you can just assume that there exists a way to order operations and skip to the section titled <em>Intuition behind CRDTs</em></p>
</blockquote>
<p><img src="https://jzhao.xyz/thoughts/images/message-ordering.jpg" width="auto"/></p>
<p>There is a whole branch of math focused on how to order things called <a href="https://jzhao.xyz/thoughts/Order-theory" rel="noopener" data-src="/thoughts/Order-theory">order theory</a>. In the case of message ordering, we want to define some way to compare messages such that no two messages are considered chronologically equal (in academic terms, we define a total ordering). If we can do so, we’ve mathematically avoided conflicts. So how do we do that?</p>
<p>Your first intuition may be to just use clocks. However, it would be naive to just randomly trust two different clocks from two different machines. Clocks can drift out of sync, leap seconds happen, and users can change their system time. Keeping time is famously hard.</p>
<p>If we can’t trust actual clocks, what can we do? Well, we can use Lamport timestamps. These track <em>logical time</em> rather than actual wall time, meaning we count number of events that have occurred rather than seconds elapsed.</p>
<p>This timestamp is just a simple counter. For the rest of the blog post, we refer to this counter as the sequence number <code>seq</code>.</p>
<ul>
<li>All nodes start their counter at 0</li>
<li>Everytime we perform an operation locally, we increment our counter by one</li>
<li>Everytime we broadcast a message to our peers, we attach this counter</li>
<li>Everytime we receive a message, we set our timer to <code>max(self.seq, incoming.seq) + 1</code></li>
</ul>
<p>If <code>a.seq &gt; b.seq</code> then event $a$ must have happened after event $b$. However, if <code>a.seq <mark> b.seq</mark></code>, we cannot be sure which event came first. This means that Lamport timestamps only give us a partial ordering, which means two identical sequence numbers might not correspond to the same unique event. For example, both nodes could emit an event with <code>seq = 1</code> even though they are different events.</p>
<p><img src="https://jzhao.xyz/thoughts/images/duplicate-seq.jpg" width="auto"/></p>
<p>Thankfully, we can actually create a total ordering of events in a distributed system by using some arbitrary (but deterministic) mechanism to break ties. For CRDTs, if we give each node a unique ID, we can actually tie-break on this ID to provide a deterministic way to order concurrent events.</p>
<p>In pseudocode, we can create a comparison operation that looks something like the following:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>// We assume this is unique for every node
</span></span></span><span><span><span></span><span>type</span> <span>AuthorID</span><span> </span><span>=</span><span> </span><span>u8</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// A lamport timestamp
</span></span></span><span><span><span></span><span>type</span> <span>SequenceNumber</span><span> </span><span>=</span><span> </span><span>u8</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// A CRDT Operation
</span></span></span><span><span><span></span><span>struct</span> <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>author</span>: <span>AuthorID</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>seq</span>: <span>SequenceNumber</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>content</span>: <span>Option</span><span>&lt;</span><span>T</span><span>&gt;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Compare based off of sequence number
</span></span></span><span><span><span>// If there&#39;s a tie, tie-break on unique author ID
</span></span></span><span><span><span></span><span>fn</span> <span>happens_before</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>op1</span>: <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span><span> </span><span>op2</span>: <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span>
</span></span></span><span><span><span>	</span><span>op1</span><span>.</span><span>seq</span><span> </span><span>&lt;</span><span> </span><span>op2</span><span>.</span><span>seq</span><span> </span><span>||</span><span>
</span></span></span><span><span><span>		</span><span>(</span><span>op1</span><span>.</span><span>seq</span><span> </span><span></span><span> </span><span>op2</span><span>.</span><span>seq</span><span> </span><span>&amp;&amp;</span><span> </span><span>op1</span><span>.</span><span>author</span><span> </span><span>&lt;</span><span> </span><span>op2</span><span>.</span><span>author</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Ordering solved!</p>
<a href="#causality"><h3 id="causality"><span arialabel="Anchor"># </span>Causality</h3></a>
<p>Or so we thought… Let’s think about when it is safe for us to apply an operation that we have received locally.</p>
<p><img src="https://jzhao.xyz/thoughts/images/safe-operation.jpg" width="auto"/></p>
<p>Say that the largest sequence number we know of is 3. We receive an operation with sequence number 5. We know that we are missing the operation with sequence number 4. Can we still deliver 5?</p>
<p>If 5 does not causally depend on 4, then we actually can still safely apply this operation.</p>
<p>But we can’t figure out this causality information from just sequence numbers alone. If an event A causes another event B to happen, then <code>a.seq &lt; b.seq</code>. However, we <strong>don’t know the converse</strong>. That is, if <code>a.seq &lt; b.seq</code>, we cannot say that A caused B to happen.</p>
<p>It turns out the fix for this is actually quite easy. As we have a unique way of identifying each operation, we can just send along a list of operations it causally depends on. That way, if we receive a message and we know we’ve received all of its causal dependencies, it should be safe to deliver.</p>
<p>If we receive a message where we <em>haven’t</em> received all of its causal dependencies, then we can add it to a queue so that when the message does get delivered, we can apply it afterwards. In the above example, if message 5 marked 4 as a causal dependency, it would wait until 4 was delivered before also applying 5.</p>
<p>This means that as long as we declare the right causal dependencies, we can make certain things that don’t seem commutative (like list operations) actually commute.</p>
<a href="#intuition-behind-crdts"><h3 id="intuition-behind-crdts"><span arialabel="Anchor"># </span>Intuition behind CRDTs</h3></a>
<p>Okay enough about theory, how do we actually go about making a CRDT?</p>
<p>Let’s survey what we have at our disposal so far (our assumptions):</p>
<ul>
<li>We can reliably send messages between peers</li>
<li>We have a total ordering on the messages so we don’t get any conflicts</li>
<li>We have some way of indicating causal dependencies</li>
</ul>
<p>This gives us an ever-growing pile of messages that are deemed ‘safe’ to apply. Here is probably a good time to make a distinction between the data in the CRDT itself and the view of that data.</p>
<ul>
<li>The data itself are the operations that are coming in</li>
<li>The view is the data structure we compute from it (and what applications end up seeing)</li>
</ul>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>CRDT</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>data</span>: <span>Vec</span><span>&lt;</span><span>Op</span><span>&lt;</span><span>T</span><span>&gt;&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>CRDT</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>// modify self.data to include op
</span></span></span><span><span><span></span><span>	</span><span>fn</span> <span>apply</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>op</span>: <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>	</span><span>// traverse self.data to produce the data structure
</span></span></span><span><span><span></span><span>	</span><span>// we&#39;re actually interested in (a list in this example)
</span></span></span><span><span><span></span><span>	</span><span>fn</span> <span>view</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>Vec</span><span>&lt;</span><span>T</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><img src="https://jzhao.xyz/thoughts/images/crdt-apply-view.jpg" width="auto"/></p>
<p>Specifically, we never<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> delete any operations from the internal data representation. The best we can do is mark them as deleted using a 

<a href="https://en.wikipedia.org/wiki/Tombstone_%28data_store%29" rel="noopener">tombstone</a>. Because a peer could technically reference any past operation as a causal dependency, we need to keep that metadata around.</p>
<p>Of course, we can’t go about willy-nilly trying to model every data structure this way. We can only have CRDTs of data structures which have invariants that <strong>do not depend on knowing the most up to date version of the data structure</strong>. From before, CRDTs are always guaranteed to have a correct state, but they may not have the most up-to-date value. This means that receiving any new operations should never break a CRDTs invariants.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<p>An example of something that CRDTs cannot model is an account balance that never decreases below zero. Say that you have $100 in an account. You spend 70 on your laptop and another 40 on your phone at the same time. Without waiting on the other transaction to arrive, there is no way for the CRDT to know whether these are valid! Even though both transactions are valid on their own, when done concurrently, they decrease the value to a negative value. Thus, CRDTs cannot model anything that requires maintaining <strong>global invariants</strong>.</p>
<a href="#list-crdts-rga-explained"><h3 id="list-crdts-rga-explained"><span arialabel="Anchor"># </span>List CRDTs (RGA Explained)</h3></a>
<p>This seems to lead us to the biggest problem in the room: list CRDTs.</p>
<p>When you think of the API for a list, most operations are normally done by indexing. But isn’t this a global invariant? Don’t we need to know what other operations have been done to the list to figure out what the index of each character is?</p>
<p>This is not an easy problem to solve. It may also be a reason as to why the vast majority of CRDT projects focus on lists or text editing (which is essentially a list of characters). Luckily for us, some smart people have figured it out for us so we can look to what they’ve done for inspiration.</p>
<p>The key insight here is that instead of using relative addressing (e.g. positional indexing), we can use absolute addressing (e.g. using IDs).</p>
<p>Every time we insert an element into the list, we need to know the ID of the character we are inserting after. Then, we just place it somewhere between that element and the element following it.</p>
<p>So instead of saying “insert ‘A’ after the character at position 4” we say “insert ‘A’, with ID <code>5</code>, and insert it after the character with ID <code>4</code>”. This matches our intuition for how text editing happens anyways. When we imagine inserting text, we are inserting it <em>after</em> something. It wouldn’t make sense to insert the character “a” of “cat” before we insert the character “c”.</p>
<p>We can imagine saying that “c” <em>caused</em> “a” which caused “t”. Conveniently, we can encode this causality by making the causal parent of each item the character it was inserted after. Remember causal dependencies? Yeah those.</p>
<p><img src="https://jzhao.xyz/thoughts/images/rga-explained.jpg" width="auto"/></p>
<p>This forms a sort of <em>causal tree</em> and this is effectively how RGA, a list CRDT, structures its data internally. Let’s modify our <code>Op</code> to match that:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>type</span> <span>OpID</span><span> </span><span>=</span><span> </span><span>(</span><span>AuthorID</span><span>,</span><span> </span><span>SequenceNumber</span><span>);</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>id</span>: <span>OpID</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>origin</span>: <span>OpID</span><span>,</span><span> </span><span>// causal dependency
</span></span></span><span><span><span></span><span>	</span><span>author</span>: <span>AuthorID</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>seq</span>: <span>SequenceNumber</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>content</span>: <span>Option</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>is_deleted</span>: <span>bool</span> <span>// tombstone as we can&#39;t actually remove items
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>When inserting a character we</p>
<ol>
<li>Find the origin (causal dependency). If it doesn’t exist, we queue it up for later.</li>
<li>Starting at this node, all of its siblings were inserted concurrently. We look through the list of siblings until we reach a node that we are greater determined by the happens-before comparison we defined<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>. Recall that we sort operations first by their sequence number then tie break by the author ID.</li>
</ol>
<p><img src="https://jzhao.xyz/thoughts/images/rga-insert.jpg" width="auto"/></p>
<p>In the example above, <code>&#39;s&#39;</code> has <code>&#39;a&#39;</code> as its causal origin. Thus, we look at where to insert it in the list of children of <code>&#39;a&#39;</code>. As <code>&#39;t&#39;</code> and <code>&#39;b&#39;</code> both have smaller sequence numbers, we skip past these. Both <code>&#39;s&#39;</code> and <code>&#39;p&#39;</code> have a sequence number of 5 so we tie-break on the <code>AuthorID</code>. As 1 &lt; 2, we insert <code>&#39;s&#39;</code> between <code>&#39;b&#39;</code> and <code>&#39;p&#39;</code>.</p>
<p>To get the actual list this CRDT represents, we perform an in-order traversal over the tree and only keep nodes that are not marked as deleted.</p>
<a href="#adding-byzantine-fault-tolerance-for-free-almost"><h2 id="adding-byzantine-fault-tolerance-for-free-almost"><span arialabel="Anchor"># </span>Adding Byzantine Fault Tolerance for free (almost)</h2></a>
<p>Up to this point, the CRDTs we’ve covered all work in trusted scenarios. These are scenarios in which you <em>know</em> all of the people participating and you trust them to not screw up the system for everyone else. For example, in a collaborative text document, you may limit collaborators to immediate colleagues who you trust to run the CRDT algorithm correctly and not attempt any funny business.</p>
<p>However, most of the interactions we have online are not in trusted scenarios. Luckily, we have servers to help mediate these interactions, dictate what is and what isn’t possible. Peer-to-peer systems, on the other hand, cannot rely on nodes always behaving the way the designers of the system intended. Here, we would like to be able to guarantee that the system continues functioning correctly even in the face of some nodes crashing, failing, and even acting maliciously.</p>
<p><img src="https://jzhao.xyz/thoughts/images/byzantine-node.jpg" width="auto"/></p>
<p>The CRDTs we have been exploring so far do not work in these untrusted scenarios. That is, any one node can do something bad and cause state to diverge permanently. Not good.</p>
<p>To be more concrete, here are some examples of what a malicious actor can do:</p>
<ul>
<li>Send malformed updates</li>
<li>Not forward information from honest nodes (an eclipse attack)</li>
<li>Send invalid updates
<ul>
<li>Messages that have duplicate IDs</li>
<li>Send incorrect sequence numbers (an equivocation attack)</li>
<li>Claim to be another user</li>
</ul>
</li>
</ul>
<p>Ideally, we want to adapt our existing CRDT algorithms to be resistant to these attacks while still allowing honest nodes to continue business as normal. This would allow us to use CRDTs in untrusted environments which opens up the door to lots of cool applications like games, social, and more.</p>
<p>To borrow a term from distributed systems, we want to make our CRDTs <a href="https://jzhao.xyz/thoughts/Byzantine-Faults" rel="noopener" data-src="/thoughts/Byzantine-Faults">Byzantine fault-tolerant</a>.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> The ‘Byzantine’ part of the name comes from the Byzantine Generals Problem, a situation where, in order to avoid catastrophic failure of the system, the system’s actors must agree on a concerted strategy, but some of these actors are unreliable and potentially malicious.</p>
<p>Notation wise, we denote the total number of nodes in the system $n$. We denote the number of faulty/Byzantine nodes $f$. Most consensus algorithms claim a tolerance of up to $f &lt; \frac n 3$, which means they can tolerate up to <a href="https://jzhao.xyz/thoughts/33-Impossibility-Result" rel="noopener" data-src="/thoughts/33-Impossibility-Result">33% Impossibility Result</a>. However, CRDTs require an even weaker bound. Remember that we are not trying to achieve consensus! All we really need to do is make sure that Byzantine actors can’t interrupt honest nodes from functioning properly.</p>
<p>In fact, we can reduce this to a problem called <a href="https://jzhao.xyz/thoughts/Byzantine-Broadcast" rel="noopener" data-src="/thoughts/Byzantine-Broadcast">Byzantine Broadcast</a>. Dolev-Strong, back in 1983, showed that it was possible to tolerate up to $f &lt; n$ faulty nodes! This means that, as long as there are honest nodes and they are connected to each other, they can still function properly.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p>
<p>Kleppmann detailed an approach in his paper <em>

<a href="https://martin.kleppmann.com/papers/bft-crdt-papoc22.pdf" rel="noopener">Making CRDTs Byzantine Fault Tolerant</a></em> that works without changing the internals of most CRDTs; it can be fully retrofit on top of it. We can create a ‘BFT adapter’ layer between the transport and application layer that is responsible for filtering out any Byzantine operations.</p>
<p><img src="https://jzhao.xyz/thoughts/images/bft-layer.jpg" width="auto"/></p>
<p>This approach has two major components we need to grasp:</p>
<ul>
<li>How we ensure Byzantine nodes don’t tamper with messages and pretend to be someone else (hashes + signed message digests)</li>
<li>How we ensure messages don’t get blocked from reaching honest nodes (eager reliable causal broadcast with retries)</li>
</ul>
<a href="#hashes-as-ids-and-signed-message-digests"><h3 id="hashes-as-ids-and-signed-message-digests"><span arialabel="Anchor"># </span>Hashes as IDs and Signed Message Digests</h3></a>
<p>So here’s a little trick we can do. Our only requirement for operation IDs is that they uniquely identify a node. We can generate this ID by SHA256 hashing parts of the operation:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>// Set the ID to the hash of its contents
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>set_id</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>self</span><span>.</span><span>id</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>hash_to_id</span><span>()</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// SHA256 computation over an operation
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>hash_to_id</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>OpID</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>let</span><span> </span><span>fmt_str</span><span> </span><span>=</span><span> </span><span>format!</span><span>(</span><span>
</span></span></span><span><span><span>		</span><span>&#34;{},{},{},{},{}&#34;</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>self</span><span>.</span><span>origin</span><span>,</span><span> </span><span>self</span><span>.</span><span>author</span><span>,</span><span> </span><span>self</span><span>.</span><span>seq</span><span>,</span><span> </span><span>self</span><span>.</span><span>is_deleted</span><span>,</span><span> </span><span>self</span><span>.</span><span>content</span><span>
</span></span></span><span><span><span>	</span><span>);</span><span>
</span></span></span><span><span><span>	</span><span>sha256</span><span>(</span><span>fmt_str</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Then, to check if an operation is valid, we can just hash the contents again and see if it matches the ID. If a Byzantine actor tries to change any of these properties while trying to pass it off as a different ID, there will be a hash mismatch.</p>
<p>However, how can we be sure that a Byzantine actor hasn’t just pretended to be someone else? After all, they could just create an operation, set the author field to someone else, then hash the content so that there is no mismatch between hash and ID.</p>
<p>Luckily, we can use <a href="https://jzhao.xyz/thoughts/Asymmetric-Key-Cryptography" rel="noopener" data-src="/thoughts/Asymmetric-Key-Cryptography">public key cryptography</a> to help us out here. Each node has a private key they keep to themselves. Earlier, we also mentioned that each node should have a unique identifier. We can actually use the public key of each node as its <code>AuthorID</code>.</p>
<p>Then, whenever we send a message to another peer, we hash <code>op.id</code> to create a digest, and then sign it with our private key. This way, we can verify that the person who signed the message is the actual author.</p>
<p><img src="https://jzhao.xyz/thoughts/images/op-hashing-process.jpg" width="auto"/></p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>// Create a digest to be signed
</span></span></span><span><span><span></span><span>fn</span> <span>digest</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>[</span><span>u8</span><span>;</span><span> </span><span>32</span><span>]</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>// note that self.dependencies here is *different* from self.origin
</span></span></span><span><span><span></span><span>	</span><span>// this will allow us to indicate causal dependencies *across* CRDTs
</span></span></span><span><span><span></span><span>	</span><span>// which we will cover in more detail later
</span></span></span><span><span><span></span><span>	</span><span>let</span><span> </span><span>fmt_str</span><span> </span><span>=</span><span> </span><span>format!</span><span>(</span><span>&#34;{},{},{}&#34;</span><span>,</span><span> </span><span>self</span><span>.</span><span>id</span><span>(),</span><span> </span><span>self</span><span>.</span><span>path</span><span>,</span><span> </span><span>self</span><span>.</span><span>dependencies</span><span>);</span><span>
</span></span></span><span><span><span>	</span><span>sha256</span><span>(</span><span>fmt_str</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Sign this digest with the given keypair
</span></span></span><span><span><span></span><span>fn</span> <span>sign_digest</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>keypair</span>: <span>&amp;</span><span>Ed25519KeyPair</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>self</span><span>.</span><span>signed_digest</span><span> </span><span>=</span><span> </span><span>sign</span><span>(</span><span>keypair</span><span>,</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>digest</span><span>()).</span><span>sig</span><span>.</span><span>to_bytes</span><span>()</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Ensure digest was actually signed by the author it claims to be signed by
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>is_valid_digest</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>op</span>: <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span>
</span></span></span><span><span><span>	</span><span>let</span><span> </span><span>digest</span><span> </span><span>=</span><span> </span><span>Ed25519Signature</span>::<span>from_bytes</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>signed_digest</span><span>);</span><span>
</span></span></span><span><span><span>	</span><span>let</span><span> </span><span>pubkey</span><span> </span><span>=</span><span> </span><span>Ed25519PublicKey</span>::<span>from_bytes</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>author</span><span>());</span><span>
</span></span></span><span><span><span>	</span><span>match</span><span> </span><span>(</span><span>digest</span><span>,</span><span> </span><span>pubkey</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>(</span><span>Ok</span><span>(</span><span>digest</span><span>),</span><span> </span><span>Ok</span><span>(</span><span>pubkey</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>pubkey</span><span>.</span><span>verify</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>digest</span><span>(),</span><span> </span><span>&amp;</span><span>digest</span><span>).</span><span>is_ok</span><span>(),</span><span>
</span></span></span><span><span><span>		</span><span>(</span><span>_</span><span>,</span><span> </span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>false</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Ok great! We now have a unique way to identify both peers and operations. But there is one more thing here that is a little pesky to deal with: mutability.</p>
<p>When we create references to operations in this internal representation (e.g. we need to declare a causal dependency), we expect that the <code>OpID</code> of an operation stays <em>static</em> throughout its lifetime. However, because we now set <code>OpID</code> to be the hash of the content, updating a node would change its <code>OpID</code> all the time!</p>
<p>Does this mean we have to give up hashing the message content for fault tolerance? Fortunately not! There is one tiny hack that allows us to still use this hashing approach.</p>
<p>Instead of making a copy of the original operation and just changing the content (which would cause the operation to be considered invalid by our hash check!), we can produce an <em>entirely new</em> operation that has the original ID as a causal dependency. These ‘modification’ operations don’t actually get included in the internal representation of the CRDT, rather they modify it directly.</p>
<p>We can look to our list CRDT for an example. This <code>delete</code> function produces an entirely valid operation. This also makes sense from a causality perspective, we need to have delivered the original before trying to delete it!</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>  </span><span>fn</span> <span>delete</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>id</span>: <span>OpID</span><span>,</span><span> </span><span>keypair</span>: <span>&amp;</span><span>Ed25519Keypair</span><span>)</span><span> </span>-&gt; <span>Op</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>let</span><span> </span><span>mut</span><span> </span><span>op</span><span> </span><span>=</span><span> </span><span>Op</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>id</span>: <span>PLACEHOLDER_ID</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>origin</span>: <span>id</span><span>,</span><span> </span><span>// the actual operation we are deleting
</span></span></span><span><span><span></span><span>		</span><span>author</span>: <span>self</span><span>.</span><span>our_id</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>seq</span>: <span>self</span><span>.</span><span>our_seq</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>is_deleted</span>: <span>true</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>content</span>: <span>None</span><span>,</span><span>
</span></span></span><span><span><span>		</span><span>signed_digest</span>: <span>PLACEHOLDER_DIGEST</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>};</span><span>
</span></span></span><span><span><span>	</span><span>op</span><span>.</span><span>id</span><span> </span><span>=</span><span> </span><span>op</span><span>.</span><span>hash_to_id</span><span>();</span><span>
</span></span></span><span><span><span>	</span><span>op</span><span>.</span><span>signed_digest</span><span> </span><span>=</span><span> </span><span>op</span><span>.</span><span>sign_digest</span><span>(</span><span>&amp;</span><span>keypair</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>self</span><span>.</span><span>apply</span><span>(</span><span>op</span><span>.</span><span>clone</span><span>);</span><span>
</span></span></span><span><span><span>	</span><span>op</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>When we apply it, we treat these modification events differently from insertion events. We look for the origin and just update its deleted field.</p>
<p>With that small problem solved, we know that our operations are now tamper resistant!</p>
<a href="#eager-reliable-causal-broadcast-and-retries"><h3 id="eager-reliable-causal-broadcast-and-retries"><span arialabel="Anchor"># </span>Eager Reliable Causal Broadcast and Retries</h3></a>
<p>Now, we just need to make sure that there is a way to get messages between honest nodes such that Byzantine faulty nodes can’t block it.</p>
<p>The easiest (and probably most naive) way to do this is through eager reliable broadcast:</p>
<ol>
<li>Each time a node receives a message with an <code>OpID</code> it has never seen before, it re-broadcasts that message to all its peers it is connected to</li>
<li>If we have been missing a causal dependency for a while, occasionally ask our peers if they have it</li>
</ol>
<p>This makes sure that as long there is a connected subgraph of honest nodes, they can all still communicate.</p>
<p><img src="https://jzhao.xyz/thoughts/images/connected-components.jpg" width="auto"/></p>
<p>However, there are a lot of potential optimizations to make here. It may be reliable but we broadcast $O(n^2)$ messages for each actual operation. This is really expensive and may flood the network!</p>
<p>Thankfully, we can take inspiration from <code>git</code> to figure out how to do this more efficiently. Kleppmann, again, mentions this approach in <em>Making CRDTs Byzantine Fault Tolerant</em>.</p>
<blockquote>
<p>Using cryptographic hashes of updates has several appealing properties. One is that if two nodes $p$ and $q$ exchange the hashes of their current heads, and find them to be identical, then they can be sure that the set of updates they have observed is also identical, because the hashes of the heads indirectly cover all updates. If the heads of $p$ and $q$ are mismatched, the nodes can run a graph traversal algorithm to determine which parts of the graph they have in common, and send each other those parts of the graph that the other node is lacking.</p>
</blockquote>
<p>This project does not include this more advanced hash graph reconciliation but it is a direction for future work.</p>
<a href="#a-json-crdt"><h2 id="a-json-crdt"><span arialabel="Anchor"># </span>A JSON CRDT</h2></a>
<p>Ok, we’ve seen now how we can create a Byzantine Fault Tolerant list CRDT. How can we make a JSON CRDT out of this?</p>
<p>Normally with JSON CRDTs, we just have a bunch of nested CRDTs.</p>
<ul>
<li>Values are LWW registers</li>
<li>Lists are RGA lists</li>
<li>Maps are lists of key-value pairs</li>
</ul>
<p>Each nested CRDT also keeps track of its path (e.g. <code>inventory[0].properties.damage</code>) so that when CRDTs produce an event, this information is also included. This ensures that peers know how to route a message to the right CRDT.</p>
<p>However, we have to be careful about how we store this path. We can’t naively just use the index into the list as we saw earlier how this is unstable. A small workaround here is having the <code>OpID</code> be the index.</p>
<p>Additionally, in addition to the <code>origin</code> field, we added a <code>dependencies</code> field. The distinction between the two is that the <code>origin</code> field is for same-CRDT causal dependencies whereas the <code>dependencies</code> field allows for cross-CRDT dependencies. This is important if we want, for example, an inventory update to be causally dependent on a LWW register CRDT update.</p>
<p>There is one last challenge to account for: JSON has no schema; data types can change! For example,</p>
<ul>
<li>A sets <code>&#34;a&#34;: [&#34;b&#34;]</code></li>
<li>B sets <code>&#34;a&#34;: {&#34;c&#34;: &#34;d&#34;}</code></li>
</ul>
<p>How do we resolve this? The way Automerge and Yjs resolve this is by essentially using a multi-value register: they keep both values and punts the responsibility to the application choose the right answer.</p>
<p>But wasn’t the whole point of CRDTs that there is no conflict? With most applications, allowing users to set arbitrary JSON is not actually desirable. We can somewhat mitigate these problems by allowing the application developers to define a fixed schema ahead of time and validating all operations through this.</p>
<a href="#putting-it-all-together-into-a-crate"><h3 id="putting-it-all-together-into-a-crate"><span arialabel="Anchor"># </span>Putting it all together into a crate</h3></a>
<p>What if we took advantage of the type-safety and metaprogramming abilities of a language like Rust to automatically derive these strict-schema BFT CRDTs from programmer-defined data structures?</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>#[add_crdt_fields]</span><span>
</span></span></span><span><span><span></span><span>#[derive(Clone, CRDTNode)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Player</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>inventory</span>: <span>ListCRDT</span><span>&lt;</span><span>Item</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>x</span>: <span>LWWRegisterCRDT</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>y</span>: <span>LWWRegisterCRDT</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[add_crdt_fields]</span><span>
</span></span></span><span><span><span></span><span>#[derive(Clone, CRDTNode)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Item</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>	</span><span>name</span>: <span>LWWRegisterCRDT</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>soulbound</span>: <span>LWWRegisterCRDT</span><span>&lt;</span><span>bool</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>After 5000 words of writing, I present to you the <code>bft-json-crdt</code> Rust crate. By using the provided CRDT types, programmers can instantly add CRDT functionality to their project.</p>
<p>There is a clear boundary between BFT and non-BFT operations as distinguished by data types to make sure that you don’t accidentally apply an operation to the wrong place.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="rust"><span><span><span>// initialize a new CRDT with a new keypair
</span></span></span><span><span><span></span><span>let</span><span> </span><span>keypair</span><span> </span><span>=</span><span> </span><span>make_keypair</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>BaseCRDT</span>::<span>&lt;</span><span>Player</span><span>&gt;</span>::<span>new</span><span>(</span><span>&amp;</span><span>keypair</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>_add_money</span><span> </span><span>=</span><span> </span><span>base</span><span>.</span><span>doc</span><span>.</span><span>balance</span><span>.</span><span>set</span><span>(</span><span>5000.0</span><span>).</span><span>sign</span><span>(</span><span>&amp;</span><span>keypair</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>_initial_balance</span><span> </span><span>=</span><span> </span><span>base</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>doc</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>balance</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>set</span><span>(</span><span>3000.0</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>sign</span><span>(</span><span>&amp;</span><span>keypair</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>sword</span>: <span>Value</span><span> </span><span>=</span><span> </span><span>json</span><span>!</span><span>({</span><span>
</span></span></span><span><span><span>	</span><span>&#34;name&#34;</span>: <span>&#34;Sword&#34;</span><span>,</span><span>
</span></span></span><span><span><span>	</span><span>&#34;soulbound&#34;</span>: <span>true</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}).</span><span>into</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>_new_inventory_item</span><span> </span><span>=</span><span> </span><span>base</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>doc</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>inventory</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>insert_idx</span><span>(</span><span>0</span><span>,</span><span> </span><span>sword</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>.</span><span>sign_with_dependencies</span><span>(</span><span>&amp;</span><span>kp1</span><span>,</span><span> </span><span>vec!</span><span>[</span><span>&amp;</span><span>_initial_balance</span><span>]);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// do something here to send _new_inventory_item to our peers
</span></span></span><span><span><span>// and on a remote peer...
</span></span></span><span><span><span></span><span>base</span><span>.</span><span>apply</span><span>(</span><span>_new_inventory_item</span><span>)</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Finally, I want to leave a word of warning. This is <strong>not a production ready library by any means</strong>. Although I do think this is a very solid proof of concept to demonstrate the potential of BFT CRDTs, it was still first and foremost for educational purposes.</p>
<p>I do not consider myself to be proficient at Rust so there might be lots of bad code smells/mistakes sprinkled throughout (please do 

<a href="https://github.com/jackyzha0/bft-json-crdt" rel="noopener">PR</a> if you have any fixes/suggestions)!</p>
<a href="#future-directions-for-crdts"><h2 id="future-directions-for-crdts"><span arialabel="Anchor"># </span>Future directions for CRDTs</h2></a>
<p>The field of CRDTs is still quite young. I really think there is a lot of promising work being done in exploring how CRDTs can be used to enable collaboration on the web.</p>
<p>James Addison has been working on creating a 

<a href="https://twitter.com/JungleSilicon/status/1592022670044205058" rel="noopener">real-time 3D engine using CRDTs</a>. Projects like 

<a href="http://bloom-lang.net/" rel="noopener">BLOOM</a> work on trying to figure out at compile time what parts of program state require coordination and what parts don’t.</p>
<p>I’d love to see more exploration of CRDTs applied to games and other real-time things. I think there’s a lot of really cool work to be done with interpolation <em>between</em> operations. Think 

<a href="https://www.ggpo.net/" rel="noopener">GGPO</a> or 

<a href="https://github.com/steveruizok/perfect-cursors/" rel="noopener">perfect-cursors</a> but for general CRDTs.</p>
<p>I hope that this blog post is a jumping point for new people interested in the space to really get their hands dirty and see what they can do with this technology. Again, checkout the codebase if you are interested in the internals and feel free to try to tackle anything under the ‘Further Work’ heading in the 

<a href="https://github.com/jackyzha0/bft-json-crdt/tree/main" rel="noopener">README</a>!</p>
<a href="#acknowledgements"><h2 id="acknowledgements"><span arialabel="Anchor"># </span>Acknowledgements</h2></a>
<p>If you are still reading by this point, I want to give you a huge thank you.</p>
<p>This was probably the most technically difficult project I’ve ever attempted, let alone finished. I felt like my conviction in my own abilities was tested multiple times and I can say I came out of the other side a better engineer. Thank you to the people who supported me as I struggled and stumbled around while trying to figure this project out.</p>
<p>There are a few people I’d like to thank individually. Thank you to 

<a href="https://www.ansonyu.me/" rel="noopener">Anson</a> for listening to my long and incoherent rambles and celebrating my small wins. Thank you to 

<a href="https://twitter.com/smsunarto" rel="noopener">Scott Sunarto</a> and 

<a href="https://twitter.com/JungleSilicon" rel="noopener">James Addison</a> for proofreading. Thank you to 

<a href="https://nibnalin.me/" rel="noopener">Nalin Bhardwaj</a> for helping me with my cryptography questions and 

<a href="https://martin.kleppmann.com/" rel="noopener">Martin Kleppmann</a> for his teaching materials and lectures which taught me a significant portion of what I’ve learned about distributed systems and CRDTs.</p>



    </article></div>
  </body>
</html>
