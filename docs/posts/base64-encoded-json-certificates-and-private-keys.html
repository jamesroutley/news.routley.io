<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ergaster.org/til/base64-encoded-json/">Original</a>
    <h1>Base64 encoded JSON, certificates, and private keys</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content" data-astro-cid-fur5yujb=""> <div data-astro-cid-37fxchfa=""><nav><ol></ol></nav><p>I was working on my homelab and examined a file that was supposed to contain encrypted content that I could safely commit on a Github repository. The file looked like this</p>
<div><figure><pre data-language="json"><code><div><p><span>{</span></p></div><div><p><span>  </span><span>&#34;serial&#34;</span><span>: </span><span>13</span><span>,</span></p></div><div><p><span>  </span><span>&#34;lineage&#34;</span><span>: </span><span>&#34;24d431ee-3da9-4407-b649-b0d2c0ca2d67&#34;</span><span>,</span></p></div><div><p><span>  </span><span>&#34;meta&#34;</span><span>: {</span></p></div><div><p><span>    </span><span>&#34;key_provider.pbkdf2.password_key&#34;</span><span>: </span><span>&#34;eyJzYWx0IjoianpHUlpMVkFOZUZKcEpSeGo4UlhnNDhGZk9vQisrR0YvSG9ubTZzSUY5WT0iLCJpdGVyYXRpb25zIjo2MDAwMDAsImhhc2hfZnVuY3Rpb24iOiJzaGE1MTIiLCJrZXlfbGVuZ3RoIjozMn0=&#34;</span></p></div><div><p><span><span>  </span></span><span>},</span></p></div><div><p><span>  </span><span>&#34;encrypted_data&#34;</span><span>: </span><span>&#34;ONXZsJhz37eJA[...]&#34;</span><span>,</span></p></div><div><p><span>  </span><span>&#34;encryption_version&#34;</span><span>: </span><span>&#34;v0&#34;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Hm, key provider? Password key? In an encrypted file? That doesn’t sound right. The problem is that this file is generated by taking a password, deriving a key from it, and encrypting the content with that key. I don’t know what the derived key could look like, but it could be that long indecipherable string.</p>
<p>I asked a colleague to have a look and he said “Oh that? It looks like a base64 encoded JSON. Give it a go to see what’s inside.”</p>
<p>I was incredulous but gave it a go, and it worked!!</p>
<div><figure><pre data-language="console"><code><div><p><span>$ echo </span><span>&#34;eyJzYW[...]&#34;</span><span> </span><span>|</span><span> </span><span>base64</span><span> </span><span>-d</span></p></div><div><p><span>{&#34;salt&#34;:&#34;jzGRZLVANeFJpJRxj8RXg48FfOoB++GF/Honm6sIF9Y=&#34;,&#34;iterations&#34;:600000,&#34;hash_function&#34;:&#34;sha512&#34;,&#34;key_length&#34;:32}</span></p></div></code></pre></figure></div>
<p>I couldn’t believe my colleague had decoded the base64 string on the fly, so I asked. “What gave it away? Was it the trailing equal signs at the end for padding? But how did you know it was base64 encoded <em>JSON</em> and not just a base64 string?”</p>
<p>He replied,</p>
<blockquote>
<p>Whenever you see <code>ey</code>, that’s <code>{&#34;</code> and then if it’s followed by a letter, you’ll get <code>J</code> followed by a letter.</p>
</blockquote>
<p>I did a few tests in my terminal, and he was right! You can spot base64 json with your naked eye, and you don’t need to decode it on the fly!</p>
<div><figure><pre data-language="console"><code><div><p><span>$ echo </span><span>&#34;{&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>ewo=</span></p></div><div><p><span>$ echo </span><span>&#34;{</span><span>\&#34;</span><span>&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>eyIK</span></p></div><div><p><span>$ echo </span><span>&#34;{</span><span>\&#34;</span><span>s&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>eyJzCg==</span></p></div><div><p><span>$ echo </span><span>&#34;{</span><span>\&#34;</span><span>a&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>eyJhCg==</span></p></div><div><p><span>$ echo </span><span>&#34;{</span><span>\&#34;</span><span>word</span><span>\&#34;</span><span>&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>eyJ3b3JkIgo=</span></p></div></code></pre></figure></div>
<p>But there’s even better! As <a href="https://toot.now/@tyzbit">tyzbit</a> reported on the fediverse, you can even spot base64 encoded certificates and private keys! They all start with <code>LS</code>, which reminds of the LS in “TLS certificate.”</p>
<div><figure><pre data-language="console"><code><div><p><span>$ echo -en </span><span>&#34;-----BEGIN CERTIFICATE-----&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t</span></p></div></code></pre></figure></div>
<blockquote><div><p>As pointed out by <a href="https://news.ycombinator.com/item?id=44803260">gnabgib</a> and <a href="https://news.ycombinator.com/item?id=44803259">athorax</a> on Hacker News, this actually detects the leading dashes of the PEM format, commonly used for certificates, and a YAML file that starts with <code>---</code> will yield the same result</p><div><figure><pre data-language="console"><code><div><p><span>$ echo </span><span>&#34;---\n&#34;</span><span> </span><span>|</span><span> </span><span>base64</span></p></div><div><p><span>LS0tXG4K</span></p></div></code></pre></figure></div><p>This is not a silver bullet!</p></div></blockquote>
<p><em>Thanks Davide and Denis for showing me this simple but pretty useful trick, and thanks tyzbit for completing it with certs and private keys!</em></p></div> </div></div>
  </body>
</html>
