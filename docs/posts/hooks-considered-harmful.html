<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://labs.factorialhr.com/posts/hooks-considered-harmful">Original</a>
    <h1>Hooks Considered Harmful</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p><span>Pau Ramon Revilla</span></p><p><span><img alt="" sizes="100vw" srcset="/_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=750&amp;q=75 750w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=828&amp;q=75 828w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=3840&amp;q=75 3840w" src="https://labs.factorialhr.com/_next/image?url=%2Fimages%2Fdownloaded%2Fauthor%2Fbef20d92-e8fb-4db1-ae8e-02100197c6eb.jpg&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill"/></span></p></div><p>Pau Ramon Revilla</p></div></div><p><time datetime="2022-03-21T00:00:00.000Z">Mon Mar 21 2022</time><span aria-hidden="true">¬∑</span><span>10<!-- --> minutes read</span></p></div><div><div><p><span>Oh, hooks!... I still remember seeing the presentation in 2018 when Sophie Alpert and Dan Abramov introduced them </span><span>at </span><a href="https://www.youtube.com/watch?v=V-QO-KO90iQ" title="React Conf">React Conf</a><span>. </span><span>I was blown away, well, everybody was.</span><span> It was such an innovative API that it took the frontend world by storm. Functional components with an easy way to separate stateful logic from rendering logic ü§Ø¬†. Did we achieve functional programming nirvana?</span></p><p><span>After several years of using them, I would love to share the dangers I encountered using hooks. I do not exaggerate when I claim that I find a dozen of hooks-related problems every single week while reviewing code. Most of those issues never manifest to the </span><span>end-u</span><span>ser, but incorrect code that is not a bug today will, eventually.</span></p><blockquote><span>A broken watch gives the time correctly twice a day ‚Äì Unknown</span></blockquote><h3><span>Closures</span></h3><p><span>A common misunderstanding is that the object-oriented paradigm is stateful, and the functional one is stateless. The argument usually follows that </span><code>state</code><span> is evil, hence object-orientation must be avoided. There is some truth in that, but like most truisms, nuanced.</span></p><p><span>What does </span><code>state</code><span> mean? In computers, it means something along the lines of ‚Äúkeeping things around while I compute other things‚Äù, mostly in memory. Every time you store something in a variable, you keep </span><code>state</code><span> around for a given lifetime. It is then safe to say that the only difference between programming paradigms is how long you keep stuff around and the space-time tradeoffs that these decisions entail.</span></p><p><span>Shown below are two pieces of code that are equivalent in functionality:</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code><code>class Hello {
  i = 0
  inc () { return this.i++ }
  toString () {return String(this.i) }
}
const h = new Hello()
console.log(h.inc()) // 1
console.log(h.inc()) // 2
console.log(h.toString()) // &#34;2&#34;</code></span></p></figure></div><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span></code><code>function Hello () {
  let i = 0
  return {
    inc: () =&gt; i++,
    toString: () =&gt; String(i)
  }
}
const h = Hello()
console.log(h.inc()) // 1
console.log(h.inc()) // 2
console.log(h.toString()) // &#34;2&#34;</code></span></p></figure></div><p><span>The mechanisms to retain memory have a lot in common. Classes use </span><code>this</code><span>, which refers to the object‚Äôs instance, while functions implement closures - the ability to remember all the variables within their scope.</span></p><p><span>Closures are significant since they allow functions to be stateful; you don‚Äôt need objects or classes for that to happen.</span></p><p><span>One important caveat of closures is that they can easily provoke memory leaks - a function can outlive its scope, thereby the garbage collector can‚Äôt collect the trash. In the example above, as long as we keep </span><code>inc</code><span> around, we won‚Äôt cleanup </span><code>i</code><span>.</span></p><p><span>The other important thing about closures is that they turn explicit dependencies into implicit ones. When you send arguments to a function, that dependency is explicit, however, there is no way for the program to know the dependencies in a closure. The corollary of this is that closures are not deterministic, ie. the values they keep in memory can change between calls, yielding different results.</span></p><h3><span>Closures - The undoing of hooks?</span></h3><p><span>How does all that closure mambo-jambo translate into React? Well, I‚Äôm pretty sure the React team looked into all the possible APIs and made the best decision available, but, basing hooks on closures has begotten remarkable consequences:</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code><code>function User ({ user }) {
  useEffect(() =&gt; {
    console.log(user.name)
  }, []) // exhaustive-deps eslint will bark

  return &lt;span&gt;{user.name}&lt;/span&gt;
}</code></span></p></figure></div><p><span>The idea behind hooks is that they produce side effects whenever their dependencies change; for example, </span><code>useEffect</code><span> should run only when the inputs required for the side-effect are different, like an excel sheet. The same applies to </span><code>useMemo</code><span> and </span><code>useCallback</code><span>.</span></p><p><span>Hooks benefit from closures because they can ‚Äúsee‚Äù and retain information from their scope, for instance, in the example above, </span><code>user</code><span>. However, with closure dependencies being implicit, it is impossible to know when to run the side-effect.</span></p><p><span>Closures are the reason why the hooks API needs an array of dependencies. This decision forces the programmer to be responsible for making explicit those implicit dependencies, thereby functioning as a ‚Äúhuman compiler‚Äù of some sort. Declaring dependencies is manual boilerplate work and error-prone, like C memory management.</span></p><p><span>If you‚Äôve ever done manual event subscription management, you would be familiar with the two main problems: over-subscription and under-subscription, ie. reacting too much and reacting too little. The former tends to result in performance problems and the latter into bugs.</span></p><p><span>React‚Äôs solution to this problem is a linter, but it becomes a moving target when React hooks are composed into custom ones. Not to mention the fact that the linter does not have enough information and will often lead to over-subscription, as we will see when talking about data structures.</span></p><p><span>There is an alternative API for hooks that avoids this problem altogether: moving hooks outside the component. This forces you to pass arguments, which can be reasonably used as dependencies:</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code><code>const createEffect = (fn) =&gt; (...args) =&gt; useEffect(() =&gt; fn(...args), args)
const useDebugUser = createEffect((user) =&gt; { console.log(user.name) })

function User ({ user }) {
  useDebugUser(user)

  return &lt;span&gt;{user.name}&lt;/span&gt;
}</code></span></p></figure></div><p><span>Moving the hook outside the closure will free you from manually tracking dependencies and running into under-subscription problems. But you will still be vulnerable to over-subscription related to how React ‚Äì and javascript ‚Äì interpret two dependencies as equal.</span></p><h3><span>Identity and memory</span></h3><p><span>Identity is a tricky concept. It looks easy because humans have an intuition about it; we recognize objects and people even when they change over time. Nevertheless, philosophically, identity is a complex topic. </span></p><blockquote><span>No man ever steps in the same river twice, for it‚Äôs not the same river, and he‚Äôs not the same man. ‚Äì Heraclitus, </span><span>organizer of the first Greek Clojure community back in 500BC</span></blockquote><p><span>Identity is easy for things that don‚Äôt change, eg. 3 will always be 3. We can confidently claim that </span><code>3 == 3</code><span>, but when things change, and we replace every plank out of the Theseus ship, what are we left with? Is it the same ship? Does </span><code>ship == replacePlanks(ship)</code><span>?</span></p><p><span>All programming languages find themselves at this philosophical crossroad. For example, some languages will ban mutation altogether, making the problem impossible. This means that attempting to renovate an ‚Äúimmutable‚Äù ship will always lead to creating a new one since you can‚Äôt replace the planks.</span></p><p><span>Immutability can have negative performance implications due to building things repeatedly, but the identity properties can offset the cost since deterministic functions are easier to cache.</span></p><p><span>Javascript and many other languages settle the debate by having different ways of asking for equality. For instance,  </span><code>==</code><span> , </span><code>===</code><span> and </span><code>Object.is</code><span> are completely different questions and will yield different answers. </span><code>Object.is</code><span> is the latest addition to the family and evaluates that the values are equal.</span></p><ul><li><span>both¬†</span><code>undefined</code></li><li><span>both¬†</span><code>null</code></li><li><span>both¬†</span><code>true</code><span>¬†or both¬†</span><code>false</code></li><li><span>both¬†</span><code>+0</code></li><li><span>both¬†</span><code>-0</code></li><li><span>both¬†</span><code>NaN</code></li><li><span>or both non-zero and both not¬†</span><code>NaN</code><span>¬†and both have the same value</span></li><li><span>For strings, it checks that the size is the same and the characters are in the same order.</span></li><li><span>The rest are non-primitives, and since those can mutate, we check that the memory reference is the same. This defies our intuition. </span><span>For instance, </span><code>Object.is([], [])</code><span> is </span><code>false</code><span>, because both objects have a different pointer in memory</span><span>, but </span><code>let a = b = []; Object.is(a, b)</code><span> is </span><code>true</code><span> because both variables point to the same.</span></li></ul><p><span>This last part is essential because it makes it impossible for the developer to predict if two objects are the same. Given two objects, one can‚Äôt tell whether </span><code>Object.is</code><span> is going to return </span><code>true</code><span> or </span><code>false</code><span> unless we understand how those objects reside in memory.</span></p><h3><span>Hooks and Identity</span></h3><p><span>Hooks use </span><code>Object.is</code><span> to check dependencies. Given two sets of dependencies, the hook will only run if those are not ‚Äúthe same.‚Äù In this case, ‚Äúsameness‚Äù is determined by the </span><code>Object.is</code><span> semantics described above. </span></p><p><span>Let‚Äôs try to see if you understand the challenge with the following snippet:</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code><code>const User({ user }) {
  useEffect(() =&gt; {
    console.log(`hello ${user.name}`)
  }, [user]) // eslint barked, so we added this dependency

  return &lt;span&gt;{user.name}&lt;/span&gt;
}</code></span></p></figure></div><p><span>Given what we know about this component, how many times will the </span><code>useEffect</code><span> run? We can‚Äôt say. It will run exactly once for each </span><span>different</span><span> </span><code>user</code><span> we receive. Remember what we said about identity? We can‚Äôt know about the identity of an object without knowing how memory was allocated. And the problem is that this memory allocation happens elsewhere, meaning that this code may work, but it‚Äôs incorrect, and a change in a parent component will completely break it.</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span></code><code>function App1 () {
  const user = { name: &#39;paco&#39; }

  return &lt;User user={user} /&gt;
}

const user = { name: &#39;paco&#39; }
function App2 () {
  return &lt;User user={user} /&gt;
}</code></span></p></figure></div><p><span>In the example above, we can see the subtleties of hooks.</span></p><p><span>In </span><code>App1</code><span> we allocate a new object every time. To a human, that object is always the same, but for </span><code>Object.is</code><span>, it‚Äôs not. This means that each time we render this component will run the side effect logging </span><code>‚Äúhello paco‚Äù</code><span>.</span></p><p><span>In </span><code>App2</code><span> though, we always refer to the same object pointer, which means that the side effect will correctly log only once, no matter how many times we render it.</span></p><p><span>This example does not resemble real-life code, but I wanted to show the problem with the simplest case. In reality, code is much more complex, and it‚Äôs hard for developers to understand when an object is being allocated and for how long. </span></p><p><span>Here is an example that is closer to production-like code:</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span></code><code>function App ({ options, teamId }) {
  const [user, setUser] = useState(null)
  const params = { ...options, teamId }

  useEffect(() =&gt; {
    fetch(`/teams/${params.teamId}/user`)
      .then(response =&gt; response.json)
      .then(user =&gt; { setUser(user) })
  }, [params])

  return &lt;User user={user} params={params} /&gt;
}</code></span></p></figure></div><p><span>This code will smash your server, making the same request repeatedly. Object restructuring allocates a new object for each render, making the </span><code>useEffect</code><span> dependencies useless. This is a clear case of over-subscription and a bug that your users may not suffer, but your server will.</span></p><h3><span>Conclusion</span></h3><p><span>Hooks, like every technology, have enjoyed the blessing of the new technology hype cycle. Many developers have ditched their state management solutions and embraced hooks for implementing stateful logic. Also, the API looks easy, but it‚Äôs deceptively complex underneath, increasing the risk of incorrectness. </span></p><p><span>We are at the point where people are starting to realize the rough edges of its API and the dangers it poses for large-scale applications.</span></p><p><span>Most bugs can be solved by moving hooks away from the components and using primitives as the only dependencies. If you use Typescript, you can always create your own hooks and type them strictly. This will help developers in your team greatly understand the limitations.</span></p><div><figure><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span></code><code>type Primitive = boolean | number | string | bigint | null | undefined
type Callback = (...args: Primitive[]) =&gt; void
type UnsafeCallback = (...args: any[]) =&gt; void

const createEffect = (fn: Callback): Callback =&gt; (...args) =&gt; {
  useEffect(() =&gt; fn(...args), args)
}

const createUnsafeEffect = (fn: UnsafeCallback): UnsafeCallback =&gt; (...args) =&gt; {
  useEffect(() =&gt; fn(...args), args)
}</code></span></p></figure></div><p><span>If you are not using Typescript, it may just be time to look for alternatives. </span><span>With the additions of libraries such as </span><a href="https://github.com/pmndrs/zustand" title="zustand">zustand</a><span>, </span><a href="https://jotai.org/" title="jotai">jotai</a><span>, and the old-timers redux and mobx</span><span>, there exist plenty of options to choose from. Those libraries will make your life easier, ensuring that code is not only working but correct.</span></p></div></div></div>
  </body>
</html>
