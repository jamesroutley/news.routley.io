<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/martinmimigames/little-file-explorer">Original</a>
    <h1>Little File Explorer – File Manager for Android 1.0 and above</h1>
    
    <div id="readability-page-1" class="page"><div><p>Little disclaimer: This article is about the <code>print!</code> macro in Rust.</p><p>This is my second attempt at learning Rust and I’m making a lot of progress so I figure it’s a good time to talk about my first ever “bug” in Rust.</p><p>In most languages, printing a string and accepting an input on the same line is quite straightforward. Take for example the Kotlin code below which prints out the text “Enter a number:” and waits to receive a number:</p><div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>fun</span> <span>main</span><span>()</span> <span>{</span> 
</span></span><span><span>	<span>print</span><span>(</span><span>&#34;Enter a number: &#34;</span><span>)</span>
</span></span><span><span>	<span>val</span> <span>number</span> <span>=</span> <span>readln</span><span>().</span><span>toIntOrNull</span><span>()</span>
</span></span><span><span>	<span>// do something with number
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>The direct Rust equivalent below though, does not have the same behavior:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span> 
</span></span></span><span><span><span>	</span><span>let</span><span> </span><span>mut</span><span> </span><span>number</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span> 
</span></span></span><span><span><span>	</span><span>print!</span><span>(</span><span>&#34;Enter a number: &#34;</span><span>);</span><span> 
</span></span></span><span><span><span>	</span><span>stdin</span><span>().</span><span>lock</span><span>().</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>number</span><span>).</span><span>unwrap</span><span>();</span><span> 
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>All you’ll see when you run the Rust code above is a blinking text cursor, not a text prompting you to enter a number. Strange. Thankfully I accidentally hit the return key after staring at this strange behavior for about 5 minutes before I got a clue as to what was going on. Pressing the return key caused the program to print the text and exit. Interesting.</p><p>I looked into why this was happening and found a link to <code>print!</code>’s <a href="https://doc.rust-lang.org/std/macro.print.html">documentation</a>. Turns out the earlier behavior is technically correct; the documentation has a very important note:</p><blockquote><p><code>stdout</code> is frequently line-buffered by default so it may be necessary to use <code>io::stdout().flush()</code> to ensure the output is emitted immediately.</p></blockquote><p>What does <code>stdout</code> being line-buffered even mean? In simpler terms, <code>stdout</code> will store all the text you write to it until it meets the newline (\n) character or you explicitly <strong>flush</strong> out its memory. So to get the behavior I wanted, I had to add <code>io::stdout().flush()</code> after the <code>print!</code> macro. Problem solved. Curiosity still not satisfied because why don’t languages like Kotlin require me to flush the output? The answer is simply because these other languages flush <code>stdout</code> under the hood.</p><p>Rust’s decision to not autoflush, though a little controversial as is shown in the comments under this <a href="https://github.com/rust-lang/rust/issues/23818">issue</a>, is true to Rust’s principle to refrain from implicitly doing stuff for you. David Tolnay’s <a href="https://github.com/rust-lang/rust/issues/23818#issuecomment-349394249">comment</a> highlights the Rust team’s stance on the issue.</p><p>In conclusion, don’t forget to flush — I know I won’t.</p></div></div>
  </body>
</html>
