<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://theleo.zone/posts/hashmap-in-c/">Original</a>
    <h1>a simple hash table in C</h1>
    
    <div id="readability-page-1" class="page"><div><p>I implemented a simple <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> in C when solving a problem in <a href="https://csprimer.com/courses/">CS Primer</a>. Solving it
helped me gain better intuition around hash functions, pointers, and memory segments like the stack and the heap.</p><h2 id="basics">Basics</h2><p>You have probably encountered a hash table in the wild, like
a <a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c"><code>dict</code> in Python</a>, <a href="https://github.com/golang/go/blob/master/src/runtime/map.go"><code>map</code> in Go</a>, or <a href="https://github.com/v8/v8/blob/main/src/objects/ordered-hash-table.cc"><code>Map</code> in JavaScript</a>. Hash tables
associate a key with a value. Setting, looking up, and deleting values is average O(1) time complexity – fast.</p><p>Under the hood of a hash table, there is an array of “buckets” or “slots”. I’ll use the term buckets going forward. The
buckets array holds the values stored in the hash table. When you associate a key with a value, the key’s hash is used
to obtain the index of its value in the buckets array. Since the index is quick and easy to derive from the key, setting
and looking up by key (usually) takes little work.</p><p>There are a number of design decisions when implementing a hash table:</p><ul><li>hash function selection</li><li>initial size of the buckets array</li><li>collision resolution (when many keys hash to the same index)</li><li>when to resize or compact the buckets array</li></ul><p>The C hash table implementation I walk through below starts with a buckets array of size 4, has no resizing or
compaction, accepts only strings as keys, and uses separate chaining (linked list) hash collision resolution.</p><h3 id="hash-functions">Hash functions</h3><p>A hash function takes an argument (in this case, a key) and deterministically returns a number. As a contrived example,
<code>my_hash_func(key=&#34;hello&#34;)</code> returns 123 for the lifetime of the program<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. A different key,
say <code>my_hash_func(key=&#34;world&#34;)</code> might return a different number, say 127. There are a number of desirable
characteristics for a good hash function<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><h3 id="the-buckets-array">The buckets array</h3><p>When setting a value, the hash table internally runs the key through its hash function, takes the output modulo the
length its buckets array, and puts the value at that index of the buckets array. For example, say “hello” hashed to 123
as above, and our buckets array is of length 4. <code>123 % 4</code> is 3. If I wanted to associate the key “hello” with the number
72 in my hash table, the buckets array would look like this in pseudo-code:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;</span> <span>h</span><span>[</span><span>&#34;hello&#34;</span><span>]</span> <span>=</span> <span>72</span>
</span></span><span><span><span>&gt;</span> <span>h</span><span>.</span><span>show_buckets</span><span>()</span> <span># &#34;hello&#34; hashes to 123, and 123 % 4 = 3</span>
</span></span><span><span><span>bucket</span> <span>0</span><span>:</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>1</span><span>:</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>2</span><span>:</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>3</span><span>:</span> <span>(</span><span>&#34;hello&#34;</span><span>,</span> <span>72</span><span>)</span> <span>-&gt;</span> <span>NULL</span>
</span></span></code></pre></div><p>Each bucket optionally contains the head of a linked list. Here, buckets 0 through 2 are empty and bucket 3 contains a
linked list with a single value (72) associated with the key “hello”.</p><p>When looking up the value of key “hello”, the hash map will once again infer that the key “hello” lives in bucket 3,
then traverse the linked list in bucket 3. Once it finds the matching key “hello” in the linked list, it returns the
associated value of 72. If no matching key is found in the linked list, the hash table may throw an error (e.g.
<code>KeyError</code> in Python) or return a null pointer like my implementation below.</p><p>You can imagine that if a lot of keys hash-and-mod to bucket 3, the linked list there will be very long, and
setting/getting values from the hash table will no longer be performant. This is why most implementations resize the
number of buckets when the buckets array gets too full<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p><h3 id="the-heap">The heap</h3><p>I’ll be mentioning the heap frequently. You can think of the stack and heap as different memory spaces (or segments, à
la <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segfault</a>) in RAM during program runtime. Variables on the stack are scoped to a function – they are all
deallocated and are no longer referencable when the function returns. The heap is used to store variables that need to
be referenced outside the scope of the function that defines them. A common way variables are stored on the heap is with
the function <code>malloc</code>. They are then referencable until the program calls the function <code>free</code> on them. Failure to <code>free</code>
unused variables on the heap as the program continues to run is what is referred to as a memory leak, as the heap memory
may repeatedly fill up, causing the process to request more heap memory.</p><h2 id="hash-table-c-implementation">Hash table C implementation</h2><p>In C, a <code>struct</code> is a collection of named and typed fields. I define two <code>struct</code>s. One is called <code>Entry</code> and represents
an item in the hash table.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>Entry</span> <span>{</span>
</span></span><span><span>    <span>char</span> <span>*</span><span>key</span><span>;</span>
</span></span><span><span>    <span>void</span> <span>*</span><span>val</span><span>;</span>
</span></span><span><span>    <span>struct</span> <span>Entry</span> <span>*</span><span>next</span><span>;</span>
</span></span><span><span><span>}</span> <span>Entry</span><span>;</span>
</span></span></code></pre></div><p><code>Entry</code> contains three fields:</p><ul><li><code>key</code>, the key associated with the value</li><li><code>val</code>, a void (“any type”) pointer to the value itself</li><li><code>next</code>, a pointer to the next <code>Entry</code> for collision resolution</li></ul><p>All fields are pointers in order to ensure each <code>Entry</code> is a static size in memory – the output of the <code>sizeof</code>
function for each field is fixed, therefore the output of <code>sizeof(Entry)</code> is constant.</p><p>The other <code>struct</code> represents the hash table itself:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>HashTable</span> <span>{</span>
</span></span><span><span>    <span>Entry</span> <span>**</span><span>buckets</span><span>;</span>
</span></span><span><span>    <span>int</span> <span>nBuckets</span><span>;</span>
</span></span><span><span><span>}</span> <span>HashTable</span><span>;</span>
</span></span></code></pre></div><p><code>HashTable</code> contains 2 fields:</p><ul><li><code>buckets</code>, a pointer to an array of pointers to <code>Entry</code>s (the memory tables below may help if this is initially
confusing)</li><li><code>nBuckets</code>, the number of buckets in the Hashmap</li></ul><p>Similar to <code>Entry</code>, since both fields are a static size, a <code>HashTable</code> instance is also a static size.</p><h3 id="the-djb2-hash-function">The djb2 hash function</h3><p>The hash function used operates only on strings, and is called <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a> written by <a href="https://en.wikipedia.org/wiki/Daniel_J._Bernstein">Daniel Bernstein</a><sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>uint32_t</span> <span>hash</span><span>(</span><span>char</span> <span>*</span><span>s</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>uint32_t</span> <span>h</span> <span>=</span> <span>5381</span><span>;</span>
</span></span><span><span>    <span>char</span> <span>c</span><span>;</span>
</span></span><span><span>    <span>while</span> <span>((</span><span>c</span> <span>=</span> <span>*</span><span>s</span><span>++</span><span>))</span> <span>{</span>
</span></span><span><span>        <span>h</span> <span>=</span> <span>33</span> <span>*</span> <span>h</span> <span>+</span> <span>c</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>h</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The <code>get_bucket</code> function returns the bucket index for a given key:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>uint32_t</span> <span>get_bucket</span><span>(</span><span>HashTable</span> <span>*</span><span>h</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>hash</span><span>(</span><span>key</span><span>)</span> <span>%</span> <span>h</span><span>-&gt;</span><span>nBuckets</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h3 id="creating-an-empty-hash-table">Creating an empty hash table</h3><p>When creating a new <code>HashTable</code>, memory is allocated on the heap for the <code>HashTable</code> and its buckets array. Each entry
in the buckets array, i.e. each bucket, is a pointer to an <code>Entry</code>. A pointer to the <code>HashTable</code> is returned.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>HashTable</span> <span>*</span><span>HashTable_new</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>int</span> <span>nBuckets</span> <span>=</span> <span>4</span><span>;</span>
</span></span><span><span>    <span>HashTable</span> <span>*</span><span>h</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>HashTable</span><span>));</span>
</span></span><span><span>    <span>h</span><span>-&gt;</span><span>nBuckets</span> <span>=</span> <span>nBuckets</span><span>;</span>
</span></span><span><span>    <span>h</span><span>-&gt;</span><span>buckets</span> <span>=</span> <span>malloc</span><span>(</span><span>nBuckets</span> <span>*</span> <span>sizeof</span><span>(</span><span>Entry</span> <span>*</span><span>));</span>
</span></span><span><span>    <span>return</span> <span>h</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>After calling <code>HashTable_new</code>, <code>malloc</code> has been called twice, so the heap looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span>0xFF40</span></td><td><code>[NULL, NULL, NULL, NULL]</code></td><td>Initial buckets</td></tr></tbody></table><h3 id="associating-a-key-and-value">Associating a key and value</h3><p>Let’s define a <code>HashTable_set</code> function to associate keys and values:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>void</span> <span>HashTable_set</span><span>(</span><span>HashTable</span> <span>*</span><span>h</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>,</span> <span>void</span> <span>*</span><span>val</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>uint32_t</span> <span>bucket</span> <span>=</span> <span>get_bucket</span><span>(</span><span>h</span><span>,</span> <span>key</span><span>);</span>
</span></span><span><span>    <span>Entry</span> <span>*</span><span>v</span> <span>=</span> <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>];</span>
</span></span><span><span>    
</span></span><span><span>    <span>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span><span><span></span>    <span>while</span> <span>(</span><span>v</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>v</span><span>-&gt;</span><span>key</span><span>,</span> <span>key</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>// if Entry is found, overwrite its value
</span></span></span><span><span><span></span>            <span>v</span><span>-&gt;</span><span>val</span> <span>=</span> <span>val</span><span>;</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>v</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// found no existing entry - create one
</span></span></span><span><span><span></span>    <span>// and make it the head of the linked list
</span></span></span><span><span><span></span>    <span>Entry</span> <span>*</span><span>newVal</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Entry</span><span>));</span>
</span></span><span><span>    <span>newVal</span><span>-&gt;</span><span>key</span> <span>=</span> <span>strdup</span><span>(</span><span>key</span><span>);</span>
</span></span><span><span>    <span>newVal</span><span>-&gt;</span><span>val</span> <span>=</span> <span>val</span><span>;</span>
</span></span><span><span>    <span>newVal</span><span>-&gt;</span><span>next</span> <span>=</span> <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>];</span>
</span></span><span><span>    <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>]</span> <span>=</span> <span>newVal</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We get the key’s bucket index from its hash, then traverse the optional linked list of <code>Entry</code>s at that index in the
buckets array. If we find an existing key, we overwrite its value with the new value and return. If no existing <code>Entry</code>
for the key is found, allocate memory for a new <code>Entry</code>, create and store a copy of the key using <a href="https://man7.org/linux/man-pages/man3/strdup.3.html">strdup</a> (which uses
<code>malloc</code> under the hood), set its value, and insert it as the head<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> of the linked list at the appropriate bucket
index.</p><p>Now we can run the following code:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>HashTable</span> <span>*</span><span>h</span> <span>=</span> <span>HashTable_new</span><span>();</span>
</span></span><span><span><span>int</span> <span>a</span> <span>=</span> <span>5</span><span>;</span>
</span></span><span><span><span>// hash(&#34;item a&#34;) % 4 = 1 for this example
</span></span></span><span><span><span></span><span>HashTable_set</span><span>(</span><span>h</span><span>,</span> <span>&#34;item a&#34;</span><span>,</span> <span>&amp;</span><span>a</span><span>);</span>
</span></span><span><span><span>// &gt;breakpoint&lt;
</span></span></span></code></pre></div><p>At the breakpoint, the stack looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td><span>0x0000</span></td><td><code>5</code></td><td>Integer a</td></tr></tbody></table><p>The heap looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span>0xFF40</span></td><td><code>[NULL, <span>0xFF80</span>, NULL, NULL]</code></td><td>Buckets array</td></tr><tr><td><span>0xFF80</span></td><td><code>Entry(<span>0xFFB0</span>, <span>0x0000</span>, NULL)</code></td><td>Inserted entry</td></tr><tr><td><span>0xFFB0</span></td><td><code>&#34;item a&#34;</code></td><td>Key for entry</td></tr></tbody></table><p>And the buckets of <code>h</code> looks like this:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>bucket</span> <span>0</span><span>:</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>1</span><span>:</span> <span>(</span><span>&#34;item a&#34;</span><span>,</span> <span>5</span><span>)</span> <span>-&gt;</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>2</span><span>:</span> <span>NULL</span>
</span></span><span><span><span>bucket</span> <span>3</span><span>:</span> <span>NULL</span>
</span></span></code></pre></div><h3 id="looking-up-values-by-key">Looking up values by key</h3><p>For looking up values by key, <code>HashTable_get</code> is similar but simpler than <code>HashTable_set</code>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>void</span> <span>*</span><span>HashTable_get</span><span>(</span><span>HashTable</span> <span>*</span><span>h</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>uint32_t</span> <span>bucket</span> <span>=</span> <span>get_bucket</span><span>(</span><span>h</span><span>,</span> <span>key</span><span>);</span>
</span></span><span><span>    <span>Entry</span> <span>*</span><span>v</span> <span>=</span> <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>];</span>
</span></span><span><span>    
</span></span><span><span>    <span>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span><span><span></span>    <span>while</span> <span>(</span><span>v</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>// if Entry is found, return the value
</span></span></span><span><span><span></span>        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>v</span><span>-&gt;</span><span>key</span><span>,</span> <span>key</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>v</span><span>-&gt;</span><span>val</span><span>;</span>
</span></span><span><span>        <span>v</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    
</span></span><span><span>    <span>// no key found, return NULL
</span></span></span><span><span><span></span>    <span>return</span> <span>NULL</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>A void pointer to the value rather than the value itself is returned.</p><h3 id="deleting-entries">Deleting entries</h3><p>Hash tables often also include functionality to delete an entry, like Python’s <a href="https://docs.python.org/3/reference/simple_stmts.html#the-del-statement"><code>del</code> keyword</a>. The
<code>HashTable_delete</code> function allows the user or program to mark entries as removed:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>void</span> <span>HashTable_delete</span><span>(</span><span>HashTable</span> <span>*</span><span>h</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>uint32_t</span> <span>bucket</span> <span>=</span> <span>get_bucket</span><span>(</span><span>h</span><span>,</span> <span>key</span><span>);</span>
</span></span><span><span>    <span>Entry</span> <span>*</span><span>prev</span> <span>=</span> <span>NULL</span><span>;</span>
</span></span><span><span>    <span>Entry</span> <span>*</span><span>v</span> <span>=</span> <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>];</span>
</span></span><span><span>    
</span></span><span><span>    <span>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span><span><span></span>    <span>while</span> <span>(</span><span>v</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>v</span><span>-&gt;</span><span>key</span><span>,</span> <span>key</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>// found Entry to delete
</span></span></span><span><span><span></span>            <span>if</span> <span>(</span><span>prev</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>// if head of linked list,
</span></span></span><span><span><span></span>                <span>// set head to next value
</span></span></span><span><span><span></span>                <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>bucket</span><span>]</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>            <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>                <span>// if middle or end of linked list,
</span></span></span><span><span><span></span>                <span>// remove without disrupting pointers
</span></span></span><span><span><span></span>                <span>prev</span><span>-&gt;</span><span>next</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>            <span>// free allocated heap memory for the Entry&#39;s
</span></span></span><span><span><span></span>            <span>// key and the Entry itself
</span></span></span><span><span><span></span>            <span>free</span><span>(</span><span>v</span><span>-&gt;</span><span>key</span><span>);</span>
</span></span><span><span>            <span>free</span><span>(</span><span>v</span><span>);</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>prev</span> <span>=</span> <span>v</span><span>;</span>
</span></span><span><span>        <span>v</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>// if no Entry found, do nothing
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>So after running the following:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>HashTable</span> <span>*</span><span>h</span> <span>=</span> <span>HashTable_new</span><span>();</span>
</span></span><span><span><span>int</span> <span>a</span> <span>=</span> <span>5</span><span>;</span>
</span></span><span><span><span>HashTable_set</span><span>(</span><span>h</span><span>,</span> <span>&#34;item a&#34;</span><span>,</span> <span>&amp;</span><span>a</span><span>);</span>
</span></span><span><span><span>HashTable_delete</span><span>(</span><span>h</span><span>,</span> <span>&#34;item a&#34;</span><span>)</span>
</span></span><span><span><span>// &gt;breakpoint&lt;
</span></span></span></code></pre></div><p>At the breakpoint, the stack looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0x0000</td><td><code>5</code></td><td>Integer a</td></tr></tbody></table><p>And the heap looks the same as when the hash table was originally initialized:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span>0xFF40</span></td><td><code>[NULL, NULL, NULL, NULL]</code></td><td>Buckets array</td></tr></tbody></table><h3 id="discarding-the-hash-table">Discarding the hash table</h3><p>Finally, the user may want to free the entire hash table, so let’s provide them with a <code>HashTable_free</code> function:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>void</span> <span>HashTable_free</span><span>(</span><span>HashTable</span> <span>*</span><span>h</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// traverse every linked list and free
</span></span></span><span><span><span></span>    <span>// each Entry and its key
</span></span></span><span><span><span></span>    <span>for</span> <span>(</span><span>int</span> <span>b</span> <span>=</span> <span>0</span><span>;</span> <span>b</span> <span>&lt;</span> <span>h</span><span>-&gt;</span><span>nBuckets</span><span>;</span> <span>b</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>Entry</span> <span>*</span><span>v</span> <span>=</span> <span>h</span><span>-&gt;</span><span>buckets</span><span>[</span><span>b</span><span>];</span>
</span></span><span><span>        <span>while</span> <span>(</span><span>v</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>Entry</span> <span>*</span><span>next</span> <span>=</span> <span>v</span><span>-&gt;</span><span>next</span><span>;</span>
</span></span><span><span>            <span>free</span><span>(</span><span>v</span><span>-&gt;</span><span>key</span><span>);</span>
</span></span><span><span>            <span>free</span><span>(</span><span>v</span><span>);</span>
</span></span><span><span>            <span>v</span> <span>=</span> <span>next</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    
</span></span><span><span>    <span>// free the buckets array and the HashTable itself
</span></span></span><span><span><span></span>    <span>free</span><span>(</span><span>h</span><span>-&gt;</span><span>buckets</span><span>);</span>
</span></span><span><span>    <span>free</span><span>(</span><span>h</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>This completes the implementation of a simple hash table in C.</p><h2 id="alternatives-and-discussion">Alternatives and discussion</h2><p>There are a couple things I know I’m doing imperfectly above, and probably more that I don’t know about:</p><ul><li><a href="https://man7.org/linux/man-pages/man3/calloc.3p.html"><code>calloc</code></a> should be used instead of <code>malloc</code> in initialization to ensure allocated memory is zeroed</li><li><a href="https://linux.die.net/man/3/strncmp"><code>strncmp</code></a> should be used instead of <code>strcmp</code> in order to avoid unexpected behavior if non-null-terminated strings
are passed to it</li></ul><p>Some easy optimizations:</p><ul><li>use <code>(h &lt;&lt; 5) + h</code> instead of <code>33 * h</code> in <code>djb2</code> as they are equivalent, but bit shifting &amp; addition may produce
faster machine code than multiplication depending on the compiler</li><li>store the hash of the key in each <code>Entry</code> and only compare the keys if the hash values match</li></ul><p>More involved improvements:</p><ul><li>support non-string keys</li><li>use a balanced binary tree at each bucket rather than a linked list</li><li>resize the buckets array once it gets too full</li><li>switch from chained resolution with linked lists to a different technique like open addressing<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></li><li>maintain insertion order</li><li>add a random seed to each process that uses the hash table in order to prevent <a href="https://berthub.eu/articles/posts/dutch-intel-law-about-intel/dos_via_algo_complexity_attack.pdf">DoS attacks</a></li></ul><p>Thanks to Oz and <a href="https://csprimer.com/courses/">CS Primer</a> for this problem. I found it a great exercise to learn more about hash tables and
the design decisions behind them, hash functions, the C programming language, and memory management.</p></div></div>
  </body>
</html>
