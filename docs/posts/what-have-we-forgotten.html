<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://mikhailian.mova.org/node/291">Original</a>
    <h1>What Have We Forgotten?</h1>
    
    <div id="readability-page-1" class="page"><div class="page" id="page">
          
      <section id="section-content">
  <div id="zone-content-wrapper">  
  <div id="zone-content">    
        
        <div id="region-content">
  <div>
    
                        <div id="block-system-main">
  <div>
                
    <div>
      <article about="/node/291" typeof="sioc:Item foaf:Document" id="node-story-291">
        <span property="dc:title" content="What have we forgotten"></span>    
  
  <div>
    <div><div><div property="content:encoded"><p>This is the story of an organization that seems to have forgotten basic software engineering concepts. This organization does exists and has these exact problems, but it is also a generic story about similar organizations that abandon engineering excellence for their own peril.</p>

<h2>We have forgotten how to run distributed applications</h2>

<p>Long ago, the organization ran mostly on Weblogic. As a rule, there were always two Weblogic servers that hosted any given application. What we have forgotten is that the Weblogic servers were configured to enable distributed transactions, so even when two instances of the same application accessed the same data, there was a high degree of assurance that there will be no data corruption nor race conditions.</p>

<p>Fast forward to now, the organization migrated to Kubernetes, kept the old rule of having two instances of every application, but forgot why it was possible previously.</p>

<p>The organization being highly compartmentalized, developers did their their own migration from EJB to Spring  and then Spring Boot  where the likes of JPA and ehcache created lots of state within the application instances... which, given the absence of an application server that synchronized state among instances, resulted in spurious race conditions that are often resolved via manual reboots because... we have forgotten how to make distributed apps.</p>

<h2>We have forgotten session cookies</h2>

<p>I do not know what was the reason to get rid of session cookies. Maybe the fear of GDPR violations or because the organization invested in an API Gateway designed around JWT tokens.</p>

<p>Still, the organization forgot about session cookies and bet on an application design where</p>

<ol>
<li>frontend applications in Angular are publicly accessible on their own domains, like gui.serviceprovider.com.</li>
<li>Java backend is accessed via the API Gateway on separate domains like backend.serviceprovider.com that are protected by the <code>Authorization:</code>  header that should contain a signed JWT.</li>
</ol>

<p>This immediately created subtle CORS problems that were dealt with valiantly but successfully.  They still make life harder in edge cases, e.g. when interfacing with mobile apps. Less obvious problems appeared later. For instance, many applications exposed files via the backend.</p>

<p>Now, these files could not be downloaded via the browser, by lack of session cookies. The JavaScript frontend had to authenticate via OAuth 2.0, obtain a properly signed JWT token, download a file, then forward it to the user. Or worse, when the file had to be displayed inline, the frontend JavaScript code created a Blob object, then asked the browser to render it.</p>

<p>Downloading a file from the backend  became a challenge in its own right. The API Gateway imposed JSON APIs for all calls, so what could be a simple GET request to an <code>octet/stream</code> became a  <code>multipart/form-data</code> response, with the binary accompanied by a JSON that contained the file name and the file description, because... we forgot about <code>Content-Disposition</code> headers either.</p>

<p>Users are now required to authenticate every time they switch from one single-page application to another, because JWT tokens live only in the context of the JavaScript execution, thus rendering the use of Single Sign-On OAuth 2.0 workflow totally moot.</p>

<p>Screen readers and many kinds of web accessibility are barely useable, all that... because we have forgotten about session cookies.</p>

<h2>How to unforget?</h2>

<p>There is clearly a failure of engineering leadership. I am still puzzled why. Because of lack of competition? Complacency with non-technical leadership? Lack of integrity and deontological code of conduct enforced by a professional organization of software engineers?</p>

<h2>Follow-up</h2>

<p>I am gathering <a rel="nofollow" href="https://news.ycombinator.com/item?id=42862288">ideas from the HN crowd</a> in real time, and it seems that at least for the cookies problem, the way out should be to pass JWT in session cookies instead of <code>Authorization:</code> header. This will solve all problems with binary downloads and reauthentication across single-page apps, especially if the JWT would authorize many roles for the user simultaneously.</p>
</div></div></div>  </div>
  
  
</article>    </div>
  </div>
</div>      </div>
</div>  </div>
</div></section>    
  
  </div></div>
  </body>
</html>
