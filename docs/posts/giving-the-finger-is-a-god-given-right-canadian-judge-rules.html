<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://citoyens.soquij.qc.ca/php/decision.php?ID=B40649560046AC98B6BC3AA9D9C409F7">Original</a>
    <h1>Giving the finger is a ‚ÄòGod-given right‚Äô, Canadian judge rules</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>While working on my <a target="_blank" rel="noopener" href="https://github.com/scriptnull/waymond">recent Go project</a>, I had a use-case where I wanted to pass a struct between two Go packages and I used <code>context.WithValue</code> to do it.</p>
<p>In retrospect while reading the Go docs for it, I believe I have gone against every possible rule for using it üòÖ Sometimes you will have to try things out practically to get a lasting lesson.</p>
<p>This is such a case and I am going to share the lessons that I learned here.</p>
<p>All these lessons come from <a target="_blank" rel="noopener" href="https://github.com/scriptnull/waymond/commit/f429fe9d0d6d1d7b1b6cdfe819a3f8c3eb7e9503">this single commit</a> - feel free to take a look at it if you are interested.</p>
<h2 id="my-use-case"><a href="#my-use-case" title="my use-case"></a>my use-case</h2><p>I have three kinds of packages.</p>
<ul>
<li><code>main</code> package - starting point of my app</li>
<li><code>trigger</code>, <code>connector</code>, <code>scaler</code> packages - these are called from <code>main</code> and accept a context.</li>
<li><code>event</code> package which is initialized in <code>main</code> and is supposed to be used in the above packages</li>
</ul>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> main</span></pre></td></tr></tbody></table></figure>
<p>Inside the scaler, I would do something like this.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>func</span> <span>(s *Scaler)</span> <span>Register</span><span>(ctx context.Context)</span> <span>error</span></span> {</span></pre></td></tr></tbody></table></figure>
<h2 id="what‚Äôs-wrong-here"><a href="#what‚Äôs-wrong-here" title="what‚Äôs wrong here?"></a>what‚Äôs wrong here?</h2><p>This line <code>ctx = context.WithValue(ctx, &#34;eventBus&#34;, eventBus)</code> in <code>main.go</code> is what is wrong.</p>
<p>While trying to refactor, I accidentally removed that line from <code>main.go</code> and ran <code>go build</code>. Guess what? The build succeeded without any problem üò±</p>
<p>This is scary because the <code>eventBus</code> is at the core of my project. All the packages emit and subscribe to events via it. I would maybe expect a compiler error if something as obvious as not passing it to these packages was happening.</p>
<p>If we try to run the passing build, it would result in a runtime panic whenever we hit the code path where it was used. Because we are getting the <code>eventBus := ctx.Value(&#34;eventBus&#34;).(event.Bus)</code> at runtime and we missed setting that value via <code>context.WithValue</code>, we will get back a nil reference. Since that value is being used just after that <code>eventBus.Subscribe()</code>, it will lead to a runtime panic.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>panic: interface conversion: interface {} is nil, not event.Bus</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="Let-us-visit-the-docs"><a href="#Let-us-visit-the-docs" title="Let us visit the docs"></a>Let us visit the docs</h2><p>It is time to visit <a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithValue">the Go docs for context.WithValue</a></p>
<blockquote>
<p>WithValue returns a copy of parent in which the value associated with key is val.</p>
</blockquote>
<p>Yep, I did want value associated with my key.</p>
<blockquote>
<p>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</p>
</blockquote>
<p>LOL, I was not even trying to pass an optional parameter, but a mandatory parameter.</p>
<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context.</p>
</blockquote>
<p>LOL, I was using string type.</p>
<blockquote>
<p>Users of WithValue should define their own types for keys.</p>
</blockquote>
<p>I did have this idea in mind and wanted to do it as a refactor.</p>
<blockquote>
<p>To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables‚Äô static type should be a pointer or interface.</p>
</blockquote>
<p>Okay, I still don‚Äôt fully understand this part because the example in the Go Doc seems to use the type of <code>string</code></p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>type</span> favContextKey <span>string</span></span></pre></td></tr></tbody></table></figure>
<p>I would have expected it to be something like this based on that last line from the docs</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>type</span> favContextKey <span>struct</span>{}</span></pre></td></tr></tbody></table></figure>
<p>I am guessing <code>k1</code> and <code>k2</code> will result in memory allocation whereas <code>s1</code> and <code>s2</code> won‚Äôt. Could somebody confirm it for me?</p>
<h2 id="Then-how-to-use-context-WithValue"><a href="#Then-how-to-use-context-WithValue" title="Then how to use context.WithValue"></a>Then how to use context.WithValue</h2><p>As the docs suggest, it is should be strictly used for carrying request-scoped data that ideally live only during the lifetime of a request.</p>
<p>Example: let us consider an http handler which gets called every time we make an http request to a client.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {</span></pre></td></tr></tbody></table></figure>
<p>So, here the context is very specific to the handler and lives only throughout the lifetime of the handler. It is used to store a piece of information very specific to the request (i.e. the request-id of the request) and pass it to the downstream API requests which could make use of it.</p>
<h2 id="References"><a href="#References" title="References"></a>References</h2><p>Two URLs on the internet helped me in my learning here:</p>
<ul>
<li>Go docs: <a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithValue">https://pkg.go.dev/context#WithValue</a></li>
<li>This blog post from Dave Cheney: <a target="_blank" rel="noopener" href="https://dave.cheney.net/2017/01/26/context-is-for-cancelation">https://dave.cheney.net/2017/01/26/context-is-for-cancelation</a> </li>
</ul>
<p>~ ~ ~ ~</p>
<p>I dedicate this to all people who are faced with the question of ‚Äúshould I pass down my logger in my go context?‚Äù in their busy lives. The answer is simple. Don‚Äôt do it.</p>

  </div></div>
  </body>
</html>
