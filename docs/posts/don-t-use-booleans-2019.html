<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.luu.io/posts/dont-use-booleans">Original</a>
    <h1>Don&#39;t use booleans (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Use enums instead.</p>
<p><em>With any blanket statements like this, there are always exceptions.
Though in general, I believe the use of enums is often a better choice compared to boolean, unless you really need to squeeze your data into one single physical bit.</em></p>
<h3>Readability</h3>
<p>Recently, I came across a function call in our code-base where I challenged my team to name the arguments for some cash, and sadly, I kept my money. It looked something similar to this:</p>
<pre><code>fetch(accountId, false, true, true);
</code></pre>
<p>Obviously, the readability could improve quite a bit by having inline annotation:</p>
<pre><code>fetch(
  accountId,
  true, // include disabled,
  true, // fetch history, 
  true, // fetch details
);
</code></pre>
<p>Though, as we see here, you either need a rigorous code review process or linter, or just rely on developers doing due diligence. Something like this would be much more readable:</p>
<pre><code>fetch(
  accountId,
  {ItemStatus::Active, ItemStatus::Disabled},
  FetchOptions::History | FetchOptions::Details,
);
</code></pre>
<p>Notice the difference between the <code>ItemStatus</code> and <code>FetchOptions</code> enums. One is an exlusive enum (i.e. each item can only have one of the boolean values) and one is a bit-mask flags.</p>
<h3>Explicit typing</h3>
<p>Why would you want explicit typing? Imaging staying up late fixing a bug and calling this <code>fetch</code> function. If you’re like me, there’s a high probability that you’ll cross your eyes and pass true/false in the wrong places, calling <code>fetch(false, true, false)</code> instead of <code>fetch(true, false, false)</code>. Your tests would have needed to have all the permutations of the booleans to catch that issue. And good luck spotting the issue even if your tests failed.</p>
<p>With the enum version of the API, you can’t accidentally call <code>fetch(FetchOptions::History, {ItemStatus::Active})</code>. The compiler or interpreter should bark pretty loudly in this case.</p>
<p>If your programming language allows, use explicit bit-mask types instead of <code>int</code>. This will make sure that the call site cannot accidentally pass in the wrong flags.</p>
<h3>Behavior Driven &amp; Extendability</h3>
<p>Whenever I was about to use booleans and stepped back to consider using enums as an alternative, I often found myself going over the actual use-cases, or the behaviors and states of the application. It’s easy to just slap on another boolean at that point in time without considering the actual use-case or the behavior of the API. Let’s look at our <code>fetch</code> API again; boolean signature is:</p>
<pre><code>fetch(
  int accountId,
  bool includeDisabled,
  bool includeHistory,
  bool includeDetails,
);
</code></pre>
<p>Suppose we have a new piece of data called <code>flags</code>, and we want to return those <code>flags</code>. However, we need to be backward compatible to the existing callers, and only return the flags if they explicitly indicate so. So let’s update our API signature:</p>
<pre><code>fetch(
  int accountId,
  bool includeDisabled,
  bool includeHistory,
  bool includeDetails,
  bool includeFlags, // &lt;----- This is our shiny new boolean
);
</code></pre>
<p>One issue though: the flags actually come from the details. In other words, we need to validate that if <code>includeFlags</code> is <code>true</code>, the caller must also set <code>includeDetails</code> to true, and need to document it somewhere (assuming your callers read documentation):</p>
<pre><code>if (includeFlags) {
  assert includeHistory;
}
</code></pre>
<p>Imagine having three or more enums that are coindependent, we’ll suddenly need a big compatibility matrix. Let’s see how we can extend the enum version of this API:</p>
<pre><code>enum FetchOptions {
  None = 0,
  History = 1,
  Details = 2,
}
</code></pre>
<pre><code>fetch(int accountId, set&lt;ItemStatus&gt; statuses, FetchOptions options);
</code></pre>
<p>The only thing that we need to do is to add a new option in our <code>FetchOptions</code> enum:</p>
<pre><code>enum FetchOptions {
  None = 0,
  History = 1,
  Details = 2,
  DetailsWithFlags = 4, // &lt;----- This is our new fetch option
}
</code></pre>
<p>The caller just <strong>can’t</strong> pass in the wrong thing!</p>
<h2>Summary</h2>
<p>With every codebase, there is always a fine balance with how much one should “over engineer”. Though, I feel that the overhead for using enums of booleans are quite low, and the benefits enums provide are worth the effort.</p>

</div></div>
  </body>
</html>
