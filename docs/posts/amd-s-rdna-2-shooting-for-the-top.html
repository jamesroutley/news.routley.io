<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/">Original</a>
    <h1>AMD’s RDNA 2: Shooting for the Top</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In 2019, AMD moved off their long-serving GCN architecture in favor of RDNA. We’ll cover the first generation of RDNA some other time. RDNA 2 takes that foundation and scales it up while adding raytracing support and a few other enhancements. We already covered compute aspects of the RDNA 2 architecture in a couple of other articles, in order to make comparisons with other architectures. So, I figured we could do something fun and look at some games from RDNA 2’s perspective.</p>
<h2>Architecture</h2>
<p>As its name implies, RDNA 2 builds on top of the RDNA 1 architecture. AMD made a number of changes to improve efficiency and keep hardware capabilities up to date, but the basic WGP architecture remains in place. Each WGP, or workgroup processor, features four SIMDs. Each SIMD has a 32-wide execution unit for the most common operations. RDNA 2 gets a few extra instructions for dot product operations to help accelerate machine learning. For example, V_DOT2_F32_F16 multiplies pairs of FP16 values, adds them, and adds a FP32 accumulator. It doesn’t go as far as tensor cores on Nvidia, where instructions like HMMA directly deal with 8×8 matrices. But those instructions let RDNA 2 do matrix multiplication with fewer instructions than if it had to use plain fused multiply-add instructions.</p>
<p> Each SIMD has 32-wide execution units for the most common operations, a 128 KB vector register file, and can track up to 16 wavefronts. AMD therefore reduced the number of wavefronts RDNA 2 could track, from 20 in RDNA 1. GPUs don’t do out of order execution the way high performance CPUs do. Instead, they keep a lot of threads in flight, and switch between threads to keep the execution units occupied to hide latency. On RDNA 2, a SIMD basically has 16-way SMT, versus 20-way on RDNA 1.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=15448"><img data-attachment-id="15448" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2-drawio-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?fit=2012%2C844&amp;ssl=1" data-orig-size="2012,844" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2.drawio-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?fit=2012%2C844&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?fit=688%2C289&amp;ssl=1" decoding="async" width="688" height="289" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=688%2C289&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?w=2012&amp;ssl=1 2012w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=768%2C322&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=1536%2C644&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=1200%2C503&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=1600%2C671&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=1320%2C554&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2.drawio-1.png?resize=688%2C289&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Basic sketch of the RDNA 2 architecture’s WGP, and Nvidia Ampere’s SM</figcaption></figure></div>
<p>That might sound like a regression, but tracking more wavefronts (analogous to CPU threads) is probably expensive. Thread or wavefront selection logic has to solve a very similar problem to CPU schedulers. Every cycle, every entry must be checked to see if it’s ready for execution. AMD probably wanted to reduce the number of checks per cycle from 20 to 16, in order to hit higher clock speeds at lower power. RDNA 2 clocks much higher than its predecessor on the same process node, so AMD did a good job there.</p>
<p>RDNA 2 also compares well to Ampere. Even though both architectures use basic building blocks (SMs or WGPs) that can do 128 FP32 operations per cycle, a RDNA 2 WGP can keep 64 wavefronts in flight. An Ampere SM can only keep 48 warps in flight. RDNA 2 also has more vector register file capacity, meaning the compiler can keep more data in registers without reducing occupancy.</p>
<figure><table><tbody><tr><td>Architecture</td><td>Waves Per SIMD/SMSP</td><td>Vector Registers Per SIMD/SMSP</td><td>Registers Available for Max Occupancy</td></tr><tr><td>RDNA 2</td><td>16 (wave32)</td><td>128 KB</td><td>64</td></tr><tr><td>RDNA 1</td><td>20 (wave32)</td><td>128 KB</td><td>51</td></tr><tr><td>GCN</td><td>10 (wave64)</td><td>64 KB</td><td>25</td></tr><tr><td>Ampere</td><td>12 (32-wide warp)</td><td>64 KB</td><td>42</td></tr></tbody></table></figure>
<p>That gives a RDNA 2 WGP a better chance of being able to hide latency, by keeping more work in flight. Combine that with better caching, and each RDNA 2 WGP should be able to punch harder than an Ampere SM.</p>
<p>A WGP’s four SIMDs are organized into groups of two, which AMD calls compute units (CUs). A CU has its own memory pipeline and 16 KB L0 vector cache. At the CU level, AMD augmented the memory pipeline to add hardware raytracing acceleration. Specifically, the texture unit can now perform ray intersection tests, at a rate of four box tests per cycle or one triangle test per cycle. Box tests take place at upper levels of the BVH, while triangle tests happen at the last level. A BVH, or bounded vertex hierarchy, speeds up raytracing with a divide-and-conquer methodology. Because checking every triangle in a scene would be extremely expensive, box tests narrow down what area a ray goes through, and ideally the GPU only checks a narrow set of triangles in the end.</p>
<div>
<figure><img data-attachment-id="15225" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_rt_instructions/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_rt_instructions.png?fit=641%2C542&amp;ssl=1" data-orig-size="641,542" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_rt_instructions" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_rt_instructions.png?fit=641%2C542&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_rt_instructions.png?fit=641%2C542&amp;ssl=1" decoding="async" width="641" height="542" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_rt_instructions.png?resize=641%2C542&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_rt_instructions.png?resize=641%2C542&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Raytracing acceleration instructions introduced in RDNA 2</figcaption></figure></div>
<p>Raytracing acceleration is accessed via a couple of new texture instructions. Obviously these instructions don’t actually do traditional texture work, but the texture unit is a convenient place to tack on this extra functionality. The new instructions themselves don’t do anything beyond an intersection test. Regular compute shader code deals with traversing the BVH. It also has to calculate the inverse ray direction and provide that to the texture unit, even though the texture unit has enough info to calculate that by itself. AMD probably wanted to minimize the hardware cost of supporting raytracing, and figured they had enough regular shader power to get by with such a solution.</p>
<h2>Caching</h2>
<p>Beyond going for feature parity with Nvidia, RDNA 2 scales up to reach performance parity. The highest end RDNA 1 GPU, the RX 5700 XT, only has 20 WGPs. It’s also built on a small 251 mm<sup>2</sup> die, and competes with Nvidia’s midrange cards rather than challenging their highest end ones. RDNA 2’s RX 6900 XT doubles WGP count and increases clock speed, showing AMD’s ambition to take a shot at Nvidia’s best. But just like increasing core counts on a CPU, scaling up a GPU creates higher bandwidth demands. Nvidia opted for a power hungry 384-bit GDDR6X setup to feed Ampere. AMD however chose to stick with a 256-bit GDDR6 configuration. To avoid memory bandwidth bottlenecks, RDNA 2 gets an extra level of cache. AMD dubs this “Infinity Cache”, and internally refers to it as MALL (memory attached last level).</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?ssl=1"><img data-attachment-id="15232" data-permalink="https://chipsandcheese.com/rdna2_caches/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?fit=1484%2C455&amp;ssl=1" data-orig-size="1484,455" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_caches" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?fit=1484%2C455&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?fit=688%2C211&amp;ssl=1" decoding="async" width="688" height="211" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?resize=688%2C211&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?w=1484&amp;ssl=1 1484w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?resize=768%2C235&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?resize=1200%2C368&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?resize=1320%2C405&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_caches.png?resize=688%2C211&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Simplified sketch of RDNA 2 and Nvidia Ampere’s cache hierarchies</figcaption></figure></div>

<p>The MALL designation makes sense because <a href="https://llvm.org/docs/AMDGPUUsage.html">all VRAM accesses </a>go through it. RDNA 2’s L2 is also a single cache shared by the entire GPU, but can be bypassed if virtual memory pages are set to uncached. Synchronization barriers can also flush L2 to ensure coherency. Those accesses could be caught by the Infinity Cache on RDNA 2, while previous AMD GPUs would service them from VRAM.</p>
<p>Because the L2 should be large enough to catch the bulk of memory accesses, Infinity Cache performance isn’t as important and AMD runs the Infinity Cache on a separate clock domain. That means it can be clocked lower to save power. </p>
<h3>Latency</h3>
<p>Using a latency test, we can see AMD’s complex four-level cache system in action. We can also see Nvidia’s simpler two-level cache hierarchy. Ampere’s SMs have more L1 caching capacity, letting a SM service requests from its first level cache when RDNA WGPs would have to do so from the slower per-SA L1. At larger test sizes, RDNA 2 has a clear latency advantage especially when test sizes spill out of Nvidia’s L2.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?ssl=1"><img data-attachment-id="15242" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_scalar_latency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?fit=1060%2C475&amp;ssl=1" data-orig-size="1060,475" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_scalar_latency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?fit=1060%2C475&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?fit=688%2C308&amp;ssl=1" decoding="async" width="688" height="308" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?resize=688%2C308&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?w=1060&amp;ssl=1 1060w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?resize=768%2C344&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_scalar_latency.png?resize=688%2C308&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Compared to RDNA 1, the first three cache levels see minor performance gains, mostly from increased clock speeds. Then Infinity Cache makes a huge impact at larger test sizes. Latency is impressively low for such a large cache. For comparison, the RTX 3090’s L2 has 140 ns of latency, but only 6 MB of capacity. </p>
<p>Infinity cache latency also deserves a closer look. AMD’s Adrenaline Edition software is quite advanced and lets users set almost arbitrary maximum clock speeds. We can use that to see how the cache behaves as GPU core clocks vary.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?ssl=1"><img data-attachment-id="15337" data-permalink="https://chipsandcheese.com/rdna2_if_clocking/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?fit=1073%2C460&amp;ssl=1" data-orig-size="1073,460" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_if_clocking" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?fit=1073%2C460&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?fit=688%2C295&amp;ssl=1" decoding="async" width="688" height="295" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?resize=688%2C295&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?w=1073&amp;ssl=1 1073w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?resize=768%2C329&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_if_clocking.jpg?resize=688%2C295&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>At lower clocks, RDNA 2’s WGPs take fewer cycles to get data from Infinity Cache. That could mean improved shader utilization at lower clocks.</p>
<p>From the vector side, we see the same story. RDNA 2 is a lot like a faster RDNA 1, with an extra gigantic cache bolted on. Vector accesses are higher latency than scalar ones. Nvidia doesn’t have a separate scalar memory hierarchy. Their architectures do have constant caches, but those are read only and serve a more limited purpose than AMD’s scalar datapath.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?ssl=1"><img data-attachment-id="15241" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_vector_latency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?fit=1060%2C475&amp;ssl=1" data-orig-size="1060,475" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_vector_latency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?fit=1060%2C475&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?fit=688%2C308&amp;ssl=1" decoding="async" width="688" height="308" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?resize=688%2C308&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?w=1060&amp;ssl=1 1060w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?resize=768%2C344&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vector_latency.png?resize=688%2C308&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Nvidia benefits from lower latency for small test sizes, while RDNA 2 maintains an advantage at larger test sizes. AMD’s L2 and Infinity Cache latency look very good, considering RDNA 2 has to check more cache levels than Nvidia. The situation flips back around once we get to VRAM.</p>
<h3>Bandwidth</h3>
<p>Bandwidth is important too, because GPUs are designed to process lots of operations in parallel. Let’s start by looking at bandwidth from a single workgroup. Running a single workgroup limits us to a single WGP on AMD, or a SM on Nvidia architectures. That’s the closest we can get to single core bandwidth on a CPU. Like single core bandwidth on a CPU, such a test isn’t particularly representative of any real world workload. But it does give us a look into the memory hierarchy from a single compute unit’s perspective.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?ssl=1"><img data-attachment-id="15149" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_wgp/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?fit=1393%2C574&amp;ssl=1" data-orig-size="1393,574" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_wgp" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?fit=1393%2C574&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?fit=688%2C283&amp;ssl=1" decoding="async" width="688" height="283" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?resize=688%2C283&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?w=1393&amp;ssl=1 1393w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?resize=768%2C316&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?resize=1200%2C494&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?resize=1320%2C544&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_wgp.png?resize=688%2C283&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Not commenting on first level cache bandwidth because that’s hard to test, due to address generation and bounds checking overhead</figcaption></figure></div>
<p>From a single WGP, RDNA 2 achieves very high cache bandwidth thanks to high clocks. This advantage is especially prominent at large test sizes, where the 128 MB Infinity Cache comes into play. AMD’s cache architecture is a lot better than Nvidia’s here. At low occupancy, even Infinity Cache can provide more bandwidth than Ampere’s L2.</p>
<p>As we use more workgroups and load more WGPs or SMs, bandwidth demands obviously go up. That puts heavier demands on shared caches. AMD does a very good job here. L2 bandwidth starts excellent and scales very well as we load up more WGPs. We have to load up a lot more SMs on Nvidia’s RTX 3090 before we start getting good bandwidth. </p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?ssl=1"><img data-attachment-id="15152" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_bw_scaling/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?fit=1403%2C578&amp;ssl=1" data-orig-size="1403,578" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_bw_scaling" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?fit=1403%2C578&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?fit=688%2C283&amp;ssl=1" decoding="async" width="688" height="283" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?resize=688%2C283&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?w=1403&amp;ssl=1 1403w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?resize=768%2C316&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?resize=1200%2C494&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?resize=1320%2C544&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_bw_scaling.png?resize=688%2C283&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Infinity Cache bandwidth scales very well too, and actually closely matches RDNA 1’s L2 bandwidth. It can’t match L2 bandwidth on Nvidia’s 3090, but it doesn’t need to because the 4 MB L2 in front of it should catch a lot of accesses. So far, AMD looks pretty good in terms of cache bandwidth. VRAM however, is another story. </p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?ssl=1"><img data-attachment-id="15181" data-permalink="https://chipsandcheese.com/rdna2_vram_scaling/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?fit=1403%2C577&amp;ssl=1" data-orig-size="1403,577" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_vram_scaling" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?fit=1403%2C577&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?fit=688%2C283&amp;ssl=1" decoding="async" width="688" height="283" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?resize=688%2C283&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?w=1403&amp;ssl=1 1403w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?resize=768%2C316&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?resize=1200%2C494&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?resize=1320%2C543&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_vram_scaling.png?resize=688%2C283&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Nvidia has a massive VRAM bandwidth advantage. With large workloads that don’t fit in cache, Ampere is far less likely to run out of VRAM bandwidth. However, both RDNA generations are better at making use of the VRAM bandwidth they do have. They don’t need as much work in flight to make good use of their available bandwidth.</p>
<h3>CU and WGP Mode</h3>
<p>The WGPs in AMD’s RDNA architecture can operate in both WGP mode, and CU mode. In WGP mode, the 128 KB LDS works as a single unified block of memory. All four SIMDs within the WGP can access the entire 128 KB. In CU mode, the LDS is split into two 64 KB halves, each associated with a pair of SIMDs. </p>
<p>LDS latency stays the same in both modes at around 19.5 ns, even though CU mode should simplify request routing from the LDS. The same applies to RDNA 1, which has about 26.6 ns of LDS latency. </p>
<p>The LDS organization difference lets us hit a single CU (half of a WGP) by testing with a single workgroup. Because each CU has its own memory pipeline and L0 cache, we see a drop in L0 bandwidth when we’re only using one CU in the WGP. There’s no drop in bandwidth once we get to L2 on beyond. </p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?ssl=1"><img data-attachment-id="15366" data-permalink="https://chipsandcheese.com/rdna2_cu_vs_wgp_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?fit=1402%2C574&amp;ssl=1" data-orig-size="1402,574" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_cu_vs_wgp_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?fit=1402%2C574&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?fit=688%2C282&amp;ssl=1" decoding="async" width="688" height="282" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?resize=688%2C282&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?w=1402&amp;ssl=1 1402w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?resize=768%2C314&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?resize=1200%2C491&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?resize=1320%2C540&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cu_vs_wgp_bw.png?resize=688%2C282&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>That’s a large improvement over RDNA 1, which sees a significant drop in bandwidth further down the cache hierarchy. Bandwidth is often a function of how well queues can hide latency, so perhaps RDNA 2 is more flexible in how it can allocate queue entries. Maybe some queues between L1 and L2 were allocated per-CU in RDNA 1, but are allocated per-WGP in RDNA 2. To GPU workloads, that means RDNA 2 performs better if waves running in one half of a WGP finish early. </p>
<h2>From the Gaming Perspective</h2>
<p>RDNA 2 is a gaming first architecture, so let’s look at what the RX 6900 XT has to deal with in those workloads. Looking at gaming will also help us understand what gaming workloads look like.</p>
<h3>Cyberpunk 2077, RT On</h3>
<p>CD Projekt Red’s Cyberpunk 2077 is a showcase of modern GPU technology. It uses DirectX 12 with plenty of raytracing to provide a wealth of graphical effects. Unfortunately, these effects can be very heavy. Raytracing takes an especially large toll on performance. Keep in mind numbers for this game were obtained with the GPU’s maximum clock set to 1800 MHz for consistency. The 3950X had boost disabled. So, numbers here shouldn’t be taken as stock performance figures, and shouldn’t be compared with other systems. We’re only looking at what kind of work the card is doing. In this game, we’ll be looking down Jig Jig street.</p>
<div>
<figure><img data-attachment-id="15158" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/jigjig/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?fit=1920%2C1085&amp;ssl=1" data-orig-size="1920,1085" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="jigjig" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?fit=1920%2C1085&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?fit=688%2C389&amp;ssl=1" decoding="async" width="688" height="389" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=688%2C389&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=768%2C434&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=1536%2C868&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=1200%2C678&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=1600%2C904&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=1320%2C746&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/jigjig.jpg?resize=688%2C389&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Looking down Jig-Jig street in Cyberpunk 2077</figcaption></figure></div>
<p>RT-related work takes up around 21 ms of frame time. Over 9 ms of that is spent building the BVH, so optimizing BVH build time is almost as important as optimizing BVH traversal. To render raytraced effects, the 6900 XT had to do 580 million box intersection tests, and 109.5 million triangle intersection tests. At the achieved 25.9 FPS, that’s 15 billion box tests and 2.8 billion triangle tests per second.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?ssl=1"><img data-attachment-id="15160" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_jigjig_rt_on/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?fit=1920%2C1040&amp;ssl=1" data-orig-size="1920,1040" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_jigjig_rt_on" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?fit=1920%2C1040&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?fit=688%2C373&amp;ssl=1" decoding="async" width="688" height="373" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=688%2C373&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=768%2C416&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=1536%2C832&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=1200%2C650&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=1600%2C867&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=1320%2C715&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_on.png?resize=688%2C373&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Checking out the frame with Radeon GPU Profiler. The top view shows occupancy as the frame is rendered</figcaption></figure></div>
<p>Besides raytracing, Cyberpunk makes heavy use of compute. Traditional rasterization takes a back seat, perhaps showing a trend with cutting edge games. Because most of the time is spent doing raytracing, let’s take a closer look at that starting with the longest running DispatchRays call. Specifically, let’s check out the one that takes 7.2 ms, all by itself:</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?ssl=1"><img data-attachment-id="15164" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/image-68/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?fit=1920%2C1040&amp;ssl=1" data-orig-size="1920,1040" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?fit=1920%2C1040&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?fit=688%2C373&amp;ssl=1" decoding="async" width="688" height="373" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=688%2C373&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=768%2C416&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=1536%2C832&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=1200%2C650&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=1600%2C867&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=1320%2C715&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/image.png?resize=688%2C373&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Putting a box around the call we’re looking at</figcaption></figure></div>
<p>Internally, RDNA 2 treats raytracing kernels as compute shaders. This particular call launched 32,400 compute wavefronts. The 6900 XT’s 40 WGPs can keep a total of 2560 wavefronts in flight, so this is more than enough work to fill the entire GPU. However, RDNA 2 can’t keep 2560 of this kernel’s wavefronts in flight, because it doesn’t have enough vector register file capacity. Unlike CPUs, GPUs flexibly allocate vector register file capacity. Giving each thread (wavefront) more registers can help prevent register spilling, but also reduces the number of threads it can keep in flight. </p>
<p>For this kernel, the compiler chose to use 96 vector registers, meaning RDNA 2 only has enough vector register file capacity to track 10 wavefronts per SIMD, or 1600 across the entire GPU. On one hand, that means each SIMD has less capability to keep execution units busy by switching between wavefronts when one stalls. On the other, using more registers could let the compiler expose more instruction level parallelism. From the profile, RDNA 2 spends a lot of time with occupancy limited by vector register capacity, so reducing maximum occupancy from RDNA 1 looks justified.</p>
<div>
<figure><img data-attachment-id="15171" data-permalink="https://chipsandcheese.com/2023/02/19/amds-rdna-2-shooting-for-the-top/rdna2_jigjig_longest_rt_call_stats/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_longest_rt_call_stats.png?fit=583%2C688&amp;ssl=1" data-orig-size="583,688" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_jigjig_longest_rt_call_stats" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_longest_rt_call_stats.png?fit=583%2C688&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_longest_rt_call_stats.png?fit=583%2C688&amp;ssl=1" decoding="async" width="583" height="688" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_longest_rt_call_stats.png?resize=583%2C688&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_longest_rt_call_stats.png?resize=583%2C688&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>More details on that call</figcaption></figure></div>
<p>In this case, the driver probably made the right tradeoff, or at least didn’t make a bad one. 51% vector ALU usage is in a good place to be. The shaders are not under-utilized. At the same time, utilization doesn’t push over 70-80%, which would suggest a compute bound scenario. We also see light LDS usage. AMD uses the LDS to store the BVH traversal stack, keeping writes and latency-sensitive reads off the less optimized global memory path. Other raytracing calls show similar hardware utilization patterns.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?ssl=1"><img data-attachment-id="15262" data-permalink="https://chipsandcheese.com/rdna2_intersect_instruction_usage/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?fit=871%2C440&amp;ssl=1" data-orig-size="871,440" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_intersect_instruction_usage" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?fit=871%2C440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?fit=688%2C348&amp;ssl=1" decoding="async" width="688" height="348" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?resize=688%2C348&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?w=871&amp;ssl=1 871w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?resize=768%2C388&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_intersect_instruction_usage.png?resize=688%2C348&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Here’s a basic block from the shader that hits the RT units. The shader has to use three extra instructions to calculate the inverse of the ray direction, and provide that alongside the ray direction. Three extra instructions isn’t much, but these reciprocal instructions are rather expensive and only execute at quarter rate compared to simpler FP32 operations. On top of that, the compiler has to use three extra registers to hold the inverse ray direction. I’m not sure how much of an impact this makes, but there’s room for improvement.</p>
<p>Unfortunately AMD does not expose Infinity Cache counters through their profiling tools. However, we can still look at how the first three cache levels do. To start, L0 cache hitrate is poor at just under 55%. CPUs usually see well over 80% first-level cache hitrate even in sub-par implementations like Bulldozer. The 128 KB mid-level cache helps catch some of those misses, bringing cumulative L0+L1 hitrate to just under 73%. My impression here is that the L0 and L1 caches are too small. The 4 MB L2 is a hero here, bringing cumulative hitrate to 95.4% before going out to the higher latency Infinity Cache. </p>
<p>RDNA 2’s 16 KB scalar cache achieves relatively good hitrate at just over 90%, and more importantly offloads some requests from the vector path. From the instruction side, the L1i gets over 99% hitrate. GPU programs seem to have smaller instruction footprints than CPU ones, and the 32 KB L1i appears adequate.</p>
<h4>BVH Building</h4>
<p>RGP annotates several sections as calls to BuildRaytracingAccelerationStructure, which builds the BVH. As noted before, these sections consume a significant portion of raytracing time, so let’s look at one of those too. The longest one is call number 4838, which strangely is a DispatchRays call and shows intersection test activity. I’m not sure what that means, so I’ll move on to the second longest one.</p>
<p>Call 4221 corresponds to CmdDispatchBuildBVH, and ran in the compute queue. It exhibits very poor occupancy because only 160 wavefronts were launched. That’s nowhere near enough work to fill the GPU, so this section is likely latency bound. A synchronization barrier prevents the GPU from using async work to keep the execution units busy. Fortunately, this section only lasts for 1.7 ms.</p>
<div>
<figure><img data-attachment-id="15211" data-permalink="https://chipsandcheese.com/rdna2_build_bvh/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_build_bvh.png?fit=445%2C817&amp;ssl=1" data-orig-size="445,817" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_build_bvh" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_build_bvh.png?fit=445%2C817&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_build_bvh.png?fit=445%2C817&amp;ssl=1" decoding="async" width="445" height="817" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_build_bvh.png?resize=445%2C817&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_build_bvh.png?resize=445%2C817&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Unlike the ray traversal section covered above, AMD’s driver opted to use wave64 mode for this BVH building section. I doubt this is the best choice. wave32 mode should be preferable at low occupancy, because it’ll allow more thread level parallelism. But AMD probably had a good reason to use wave64, so I’ll stop being an armchair quarterback and move on to caching.</p>
<p>As before, instruction cache hitrates are very high. There’s not enough scalar memory accesses for the scalar cache to matter. On the vector side, the 16 KB L0 performs very poorly with less than 25% hitrate, and the 128 KB L1 may as well be absent. RDNA’s L2 ends up servicing most of the memory traffic, and in a more extreme way than with the ray traversal part. Because occupancy is so low, and L0/L1 cache hitrates are so poor, L2 latency is likely to be a limiting factor when building the BVH.</p>
<h4>Compute</h4>
<p>Besides raytracing, which is technically treated as a form of compute on RDNA, Cyberpunk 2077 makes heavy use of compute shaders. Non-raytracing compute in this game tends to consist of a lot of short duration calls, rather than a few very heavy ones. The longest duration compute call (number 4473) was compiled for wave32 mode, and runs for just under 0.7 of a millisecond. RDNA 2 eats this one for lunch. The shader doesn’t use a lot of vector registers or LDS space, and launches 130,560 wavefronts. As a result, occupancy is excellent.</p>
<div>
<figure><img data-attachment-id="15269" data-permalink="https://chipsandcheese.com/rdna2_compute_4473/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4473.png?fit=555%2C764&amp;ssl=1" data-orig-size="555,764" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_compute_4473" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4473.png?fit=555%2C764&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4473.png?fit=555%2C764&amp;ssl=1" decoding="async" width="555" height="764" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4473.png?resize=555%2C764&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4473.png?resize=555%2C764&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Vector ALU utilization is very good as well. In fact, it’s almost too good. Any higher, and we would be calling this section compute limited. RDNA 2’s scalar datapath plays a critical role here in offloading calculations that apply across the wavefront. Cache hitrates contribute to good compute utilization too. About 94% of vector accesses were serviced by the L0 and L1 caches, with the bulk of those coming from L0. The L2 brings cumulative hitrate to over 98%. L1 instruction cache and scalar cache hitrates are so high that misses are basically noise. For this shader, good cache hitrates and high occupancy combine to let RDNA 2 shine.</p>
<p>The second longest compute shader (number 4884) ran for just under half a millisecond, and exhibits different characteristics. It uses wave64, and occupancy is limited by vector register file capacity to just four waves per SIMD. Despite that, RGP still reports very good VALU utilization. That’s likely because this kernel overwhelmingly consists of vector ALU instructions. There aren’t a lot of memory accesses, and a good chunk of the memory accesses that do happen go to the scalar path. </p>
<div>
<figure><img data-attachment-id="15274" data-permalink="https://chipsandcheese.com/rdna2_compute_4884/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4884.png?fit=548%2C770&amp;ssl=1" data-orig-size="548,770" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_compute_4884" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4884.png?fit=548%2C770&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4884.png?fit=548%2C770&amp;ssl=1" decoding="async" width="548" height="770" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4884.png?resize=548%2C770&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_compute_4884.png?resize=548%2C770&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Moreover, this compute shader has very few branches, and RGP did not pick up any taken branches. Branches are quite expensive on GPUs, which don’t have branch prediction and must stall a thread until the branch condition is resolved. The lack of taken branches also implies divergence is not a big issue. Overall, this shader largely consists of straight-line FP32 spam. GPUs love that stuff. RDNA 2 is no exception, and achieves very good hardware utilization despite low occupancy.</p>
<div>
<figure><img data-attachment-id="15276" data-permalink="https://chipsandcheese.com/rdna2_fp32_spam/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?fit=1171%2C899&amp;ssl=1" data-orig-size="1171,899" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_fp32_spam" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?fit=1171%2C899&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?fit=688%2C528&amp;ssl=1" decoding="async" width="688" height="528" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?resize=688%2C528&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?w=1171&amp;ssl=1 1171w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?resize=768%2C590&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_fp32_spam.png?resize=688%2C528&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Here, enjoy a screen full of nonstop FP32 spam. RDNA 2 liked it, so I’m sure you’ll like it too</figcaption></figure></div>
<h3>Cyberpunk 2077, RT Off</h3>
<p>Raytracing effects are cool, but Cyberpunk 2077 still looks really good with RT off. Traditional rasterization can still render impressive scenes if artists and developers are good at their job, and the people who worked on CP2077 definitely seem up to the task. </p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?ssl=1"><img data-attachment-id="15280" data-permalink="https://chipsandcheese.com/rdna2_jigjig_rt_off/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?fit=1920%2C1040&amp;ssl=1" data-orig-size="1920,1040" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_jigjig_rt_off" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?fit=1920%2C1040&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?fit=688%2C373&amp;ssl=1" decoding="async" width="688" height="373" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=688%2C373&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?w=1920&amp;ssl=1 1920w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=768%2C416&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=1536%2C832&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=1200%2C650&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=1600%2C867&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=1320%2C715&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_jigjig_rt_off.png?resize=688%2C373&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Massive blank areas near the start with no GPU activity indicate we’re CPU bound</figcaption></figure></div>
<p>Without raytracing, traditional vertex and pixel shaders step in and play a much bigger role. However, the game still heavily uses compute shaders, and async compute shows up too. The three longest duration calls are all compute, summarized below:</p>
<figure><table><tbody><tr><td>Call</td><td>Wave Mode</td><td>Wavefronts (Threads)</td><td>Theoretical Occupancy Per SIMD</td><td>VALU Utilization</td><td>Cache Hitrates</td><td>Comments</td></tr><tr><td>5092 – ExecuteIndirect, 0.664 ms</td><td>wave64</td><td>30,224</td><td>9/16, vector register limited</td><td>35.6%</td><td>53.65% L0</td><td>Too many accesses are served from slower L2, and occupancy is not high enough to hide latency, leading to mediocre shader utilization</td></tr><tr><td>4951 – Dispatch, 0.643 ms</td><td>wave32</td><td>130,560</td><td>16/16, scheduler capacity limited</td><td>71.3%</td><td>85.4% L0 27.19% L1 68.51% L2</td><td>High occupancy and decent cache hitrates lead to good vector ALU utilization</td></tr><tr><td>3442 – Dispatch, 0.459 ms</td><td>wave64</td><td>8,160</td><td>4/16, vector register limited</td><td>78.5%</td><td>97.4% L0</td><td>Low occupancy mitigated by high L0 hitrate.</td></tr></tbody></table><figcaption>Comparing the three longest duration GPU calls. All three are compute shaders</figcaption></figure>
<p>RDNA 2 puts in a very good showing in these compute kernels, even if utilization is on the low side for the longest running kernel. Vector register file capacity continues to limit how much parallelism the architecture can take advantage of, but this problem isn’t unique to AMD. On the caching front, the 128 KB L1 often does badly. We saw that a 256 KB mid-level cache is <a href="https://chipsandcheese.com/2021/02/22/analyzing-zen-2s-cinebench-r15-lead/">already pretty mediocre for CPUs</a>. GPU caching is even harder. Time and time again, RDNA 2’s L1 sees more misses than hits. I’m glad AMD chose to double L1 cache capacity in RDNA 3. On the bright side, scalar and instruction cache hitrates continue to be good.</p>
<h4>Rasterization</h4>
<p>Unlike raytracing, the traditional rasterization pipeline is very efficient. Instead of sending off rays everywhere and seeing what they hit, rasterization can use simple calculations to map 3D points into 2D screen space. Then, the GPU uses fixed function hardware to distribute work to pixel shaders, which determine what color those pixels should be. Like before, let’s look at a couple of the longest rasterization calls in CP2077.</p>
<figure><table><tbody><tr><td>Kernel</td><td>Wave Mode</td><td>Wavefronts (Threads)</td><td>Theoretical Occupancy per SIMD</td><td>VALU Utilization</td><td>Cache Hitrates</td></tr><tr><td>5112 – DrawInstanced</td><td>Vertex: wave32</td><td>Vertex: 1</td><td>Vertex: 16/16</td><td>68.1%</td><td>80.85% L0</td></tr><tr><td>5102 – DrawInstanced</td><td>Vertex: wave32</td><td>Vertex: 1</td><td>Vertex: 16/16</td><td>N/A, didn’t run for long enough for RGP to provide an estimate</td><td>91.5% L0</td></tr></tbody></table></figure>
<p>With rasterization work, the L1 cache puts in a more credible showing. Hitrates still aren’t great, but in some cases it’s catching enough L0 misses to ensure that the vast majority of requests don’t have to be satisfied from L2 or beyond. That can be a big advantage, because L1 latency and bandwidth characteristics are much better than the L2’s.</p>
<p>There’s also a cluster of vertex shader work close to the start of the frame. It’s hard to analyze because there are a ton of tiny calls, but peeking at a few shows that they often launch fewer than 100 wavefronts each. From our latency and bandwidth scaling tests, RDNA 2 is a very strong performer at low occupancy, and likely copes with those calls better than Nvidia’s Ampere would.</p>
<h3>Titanic Honor and Glory, Megademo 401 (Rasterization, 4K)</h3>
<p>Large studios with multi-million dollar budgets can produce complex games with many deep storylines and impressive visuals. But they don’t have a monopoly on fun, and independent creators on smaller budgets can create immersive and visually stunning stuff too. One such example is the work-in-progress Titanic Honor and Glory project, which focuses on recreating the Titanic in 3D. It uses Unreal Engine, and runs using DirectX 12.</p>
<p>Like many independent games, the developers have less time and resources to spend on optimization. But perhaps because it hasn’t been optimized, the demo has a stunning level of detail and is very heavy even on modern GPUs.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?ssl=1"><img data-attachment-id="15328" data-permalink="https://chipsandcheese.com/thg_screenshot/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?fit=3839%2C2159&amp;ssl=1" data-orig-size="3839,2159" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="thg_screenshot" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?fit=2560%2C1440&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?fit=688%2C387&amp;ssl=1" decoding="async" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=688%2C387&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?w=3839&amp;ssl=1 3839w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=1280%2C720&amp;ssl=1 1280w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=768%2C432&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=1536%2C864&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=2048%2C1152&amp;ssl=1 2048w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=1200%2C675&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=1600%2C900&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=1320%2C742&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/thg_screenshot.jpg?resize=688%2C387&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>The first class lounge scene getting profiled. Detail here is incredible</figcaption></figure></div>
<p>Here, we’re looking down the first class lounge with the game running at 4K, and GPU/CPU clocks set as before. Pixel shaders dominate this workload, but compute shaders do play a role too. Async compute usage is minimal, with almost all calls happening on the graphics queue.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?ssl=1"><img data-attachment-id="15312" data-permalink="https://chipsandcheese.com/rdna2_thg_occupancy/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?fit=1726%2C994&amp;ssl=1" data-orig-size="1726,994" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_thg_occupancy" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?fit=1726%2C994&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?fit=688%2C396&amp;ssl=1" decoding="async" width="688" height="396" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=688%2C396&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?w=1726&amp;ssl=1 1726w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=768%2C442&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=1536%2C885&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=1200%2C691&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=1600%2C921&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=1320%2C760&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_occupancy.png?resize=688%2C396&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>The longest call is event 1325, a pixel shader running in wave64 mode. It launched 129,652 wavefronts, or enough waves to cover every pixel at 4K. Occupancy is low due to vector register file limitations. Vector ALU utilization is also poor, likely due to the combination of poor occupancy and mediocre cache hitrates.</p>
<div>
<figure><img data-attachment-id="15319" data-permalink="https://chipsandcheese.com/rdna2_thg_ps/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_ps.png?fit=562%2C808&amp;ssl=1" data-orig-size="562,808" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_thg_ps" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_ps.png?fit=562%2C808&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_ps.png?fit=562%2C808&amp;ssl=1" decoding="async" width="562" height="808" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_ps.png?resize=562%2C808&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_ps.png?resize=562%2C808&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Profiler stats for the long running pixel shader</figcaption></figure></div>
<p>Event 1330 is the second longest call, and is a compute shader that launches 16,320 wave32 wavefronts. Occupancy is again limited by the vector register file, but this time it’s better at 12 waves per SIMD. The shader achieves 27.7% vector ALU utilization, which is more acceptable but still on the low side. L0 hitrate is alright at 59.69%, while L1 hitrate is an embarrassingly low 13.11%. Fortunately, the L2 cache saves the day with 99.82% hitrate. Compute utilization should really be better because 12 waves per SIMD isn’t terrible occupancy. But a closer look reveals another problem. Work isn’t evenly distributed between threads, and some finish before others.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?ssl=1"><img data-attachment-id="15333" data-permalink="https://chipsandcheese.com/rdna2_thg_cs/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?fit=1875%2C636&amp;ssl=1" data-orig-size="1875,636" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_thg_cs" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?fit=1875%2C636&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?fit=688%2C233&amp;ssl=1" decoding="async" width="688" height="233" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=688%2C233&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?w=1875&amp;ssl=1 1875w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=768%2C261&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=1536%2C521&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=1200%2C407&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=1600%2C543&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=1320%2C448&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_thg_cs.png?resize=688%2C233&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Zooming in on that compute shader, with annotations added and coloring set to shader engine</figcaption></figure></div>
<p>Apparently the next call needs data written by the compute shader, so a synchronization barrier prevents it from executing until all the threads in the compute shader have finished executing. Toward the end, that means many of the 6900 XT’s WGPs are idle or don’t have enough thread level parallelism left to effectively hide latency. That’s not great for any GPU, but RDNA 2’s high clock speeds and better handling at low occupancy should let it cope better than say, Nvidia’s Ampere.</p>
<p>With THG, we can see DirectX12 in action with rasterization. It doesn’t do raytracing like Cyberpunk 2077, but cache behavior is surprisingly similar across both workloads.</p>
<h3>Gunner, HEAT, PC</h3>
<p>Gunner, HEAT, PC (GHPC) is tank simulation indie game. It aims to accurately depict fire control systems and sensors on late Cold War tanks, while being more accessible than something like DCS. Unlike the THG demo, GHPC uses the Unity engine and runs off DirectX 11. AMD’s profiler unfortunately does not support DirectX 11. I used PIX to profile the game. But that has been quite annoying because PIX has a nasty habit of crashing both itself and the game it’s trying to profile.</p>
<p>GHPC overwhelmingly uses traditional pixel and vertex shaders. I’m running the game at 4K, so unsurprisingly there’s a lot of pixel shader work. Compute shaders are used. But unlike the DirectX 12 workloads above, they play a very minor role.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?ssl=1"><img data-attachment-id="15374" data-permalink="https://chipsandcheese.com/rdna2_claustrophobia/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?fit=1684%2C840&amp;ssl=1" data-orig-size="1684,840" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_claustrophobia" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?fit=1684%2C840&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?fit=688%2C343&amp;ssl=1" decoding="async" width="688" height="343" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=688%2C343&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?w=1684&amp;ssl=1 1684w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=768%2C383&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=1536%2C766&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=1200%2C599&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=1600%2C798&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=1320%2C658&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia.jpg?resize=688%2C343&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>GHPC’s longest running pixels shaders are far more cache friendly than THG’s. We see over 90% L0 hitrate. L1 hitrate is finally excellent at 70-80%, and L2 hitrate oscillates between over 90% and around 60%. Scalar and instruction cache hitrates are basically 100%. Unfortunately PIX doesn’t show metrics on execution unit utilization, but I expect it to be quite good. That’s because game tends to make the card generate a lot of heat, even when running below stock clock speeds. Fortunately, PIX does expose far more counters than RGP does, so we can look into other aspects of the rasterization pipeline. </p>
<p>The long running pixel shader is compute bound, and seems to deal with drawing smoke effects. Calls early in the frame mainly deal with drawing objects, like houses and roads. Because those calls are short, and often overlap with each other, we see some rasterization bottlenecks show up. “PAStalledOnRasterizer” means that the primitive assembler is generating primitives faster than the rasterizer handle them. That could indicate a bottleneck at the rasterizer or anywhere after.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?ssl=1"><img data-attachment-id="15378" data-permalink="https://chipsandcheese.com/rdna2_claustrophobia_rasterization/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?fit=1681%2C341&amp;ssl=1" data-orig-size="1681,341" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_claustrophobia_rasterization" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?fit=1681%2C341&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?fit=688%2C140&amp;ssl=1" decoding="async" width="688" height="140" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=688%2C140&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?w=1681&amp;ssl=1 1681w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=768%2C156&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=1536%2C312&amp;ssl=1 1536w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=1200%2C243&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=1600%2C325&amp;ssl=1 1600w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=1320%2C268&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_claustrophobia_rasterization.png?resize=688%2C140&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>PAStalledOnRasterizer is gray, PSExportStalls are red</figcaption></figure></div>
<p>Another metric is “PSExportStalls”, which indicates when pixel shader programs have calculated color information, but the final stages in the rasterization pipeline aren’t ready to accept the data. One culprit is the Z unit, which does depth tests to make sure only non-occluded pixels are displayed. For example, if half of a tank is sitting behind a house, the Z-unit part would make sure the house’s pixels are displayed in the final frame. If a lot of pixels from many different objects have to go through this depth testing, perhaps it’s hard for the Z unit to keep up.</p>
<p>But zooming back out, the biggest performance culprits are definitely smoke and haze effects. Drawing those effects take up the most GPU time, and are very heavy on pixel shader operations. The texture units are active pretty much the entire time during those shaders, so there could be a texturing bottleneck too.</p>
<h2>Caching Comments</h2>
<p>For a long time, GPU caching trailed behind CPU caching. In the early 2000s, GPUs didn’t have a general purpose cache hierarchy. They did have specialized buffers, but for the most part they relied on explicit parallelism and high bandwidth memory setups. Toward the late 2000s, memory bandwidth constraints drove GPUs to adopt caches. These tended to be much smaller than CPU caches, and two-level cache setups were the norm. CPUs moved to triple level setups around that time in order to keep performance up with high core counts and large shared caches.</p>
<div>
<figure><img data-attachment-id="15386" data-permalink="https://chipsandcheese.com/hc14_geforce4_caching/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?fit=1049%2C807&amp;ssl=1" data-orig-size="1049,807" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hc14_geforce4_caching" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?fit=1049%2C807&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?fit=688%2C529&amp;ssl=1" decoding="async" width="688" height="529" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?resize=688%2C529&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?w=1049&amp;ssl=1 1049w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?resize=768%2C591&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/hc14_geforce4_caching.png?resize=688%2C529&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Once upon a time in the Geforce 4 era, GPU caching was impractical. Oh how times have changed…</figcaption></figure></div>
<p>RDNA 2 turns everything around by adopting a cache hierarchy that’s both more sophisticated and higher capacity than what we see on most CPUs. It uses an incredible four levels of cache, and the last cache level has a sweet 128 MB of capacity. For comparison, even AMD’s VCache CPUs only have 96 MB of last level cache, and use a triple level cache setup. </p>
<p>Just like with CPUs, DRAM technology was struggling to keep up with increases in GPU performance. But unlike CPUs, GPUs are less sensitive to latency, making such a cache setup practical (latency appears to be a large part of why L4 caches aren’t popular with CPUs). It’s exciting to see GPUs come full circle and use caching even more heavily than CPUs do.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?ssl=1"><img data-attachment-id="15363" data-permalink="https://chipsandcheese.com/rdna2_cache_hitrates/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?fit=792%2C508&amp;ssl=1" data-orig-size="792,508" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_cache_hitrates" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?fit=792%2C508&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?fit=688%2C441&amp;ssl=1" decoding="async" width="688" height="441" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?resize=688%2C441&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?w=792&amp;ssl=1 792w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?resize=768%2C493&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_cache_hitrates.png?resize=688%2C441&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Overall hitrate, for all accesses across the frame</figcaption></figure></div>
<p>But a more sophisticated cache setup is not necessarily good. More levels of cache mean you’re potentially checking more tags for hits. If a level of cache doesn’t catch a lot of memory accesses, it could end up delaying accesses to wherever the data ultimately ends up coming from. RDNA 2’s L1 cache therefore feels disappointing, with low hitrates compared to the other cache levels. It either needs to get bigger, or should go away in favor of larger L0 caches.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?ssl=1"><img data-attachment-id="15364" data-permalink="https://chipsandcheese.com/rdna2_mem_hitcount/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?fit=855%2C568&amp;ssl=1" data-orig-size="855,568" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_mem_hitcount" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?fit=855%2C568&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?fit=688%2C457&amp;ssl=1" decoding="async" width="688" height="457" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?resize=688%2C457&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?w=855&amp;ssl=1 855w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?resize=768%2C510&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_mem_hitcount.png?resize=688%2C457&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Assuming each scalar cache access gets a 64-bit value. Let’s pause for a moment to admire the incredible amount of data that GPU caches have to deal with.</figcaption></figure></div>
<p>Caches also help for bandwidth, which is more important for GPUs. The L1 cache does reduce traffic going to L2, but I doubt the L2 needs that help. AMD’s RX 6900 XT already has a serious amount of L2 bandwidth, even compared to Nvidia’s larger RTX 3090. The L1 therefore ends up serving just to consolidate requests from multiple WGPs, which simplifies L2 routing.</p>
<p>Zooming back out, we can look at request counts, multiply by request size, and then multiply by achieved framerate to get an estimate of how much data the GPU is pulling from its caches. The L0 caches serve terabytes of data per second, and that figure would be even higher if I ran my 6900 XT at stock clocks instead of capping it to 1800 MHz. Even at L2, we’re seeing over 1.5 TB/s of bandwidth demand. A modern GPU without multi-megabyte caches would be quite bandwidth starved, even if we gave it a six-stack HBM2E setup like the one on Nvidia’s A100. </p>
<h2>Game Trends</h2>
<p>From the small selection of games I looked at, compute seems to be gaining a larger role. Compute shaders are especially prominent in Cyberpunk 2077, a modern AAA game developed on a large budget. I count raytracing as a form of compute. RDNA 2 treats raytracing like compute. I’m not sure what Nvidia does, but Pascal handles raytracing with compute shaders. Even without raytracing, Cyberpunk uses a lot of compute alongside traditional rasterization.</p>
<p>Independent games on smaller budgets tend to emphasize the rasterization pipeline more, but still leverage compute. How much they do so probably depends a lot on the game engine, since independent developers typically don’t have time to create their own game engines from scratch. Unreal Engine, used by Titanic Honor and Glory, has a good chunk of compute. GHPC uses the Unity engine, and has very little compute. While the traditional rasterization pipeline remains extremely important, we’re probably going to see that increasingly supplemented by compute in new titles.</p>
<div>
<figure><a href="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?ssl=1"><img data-attachment-id="15426" data-permalink="https://chipsandcheese.com/rdna2_citysample/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?fit=1516%2C660&amp;ssl=1" data-orig-size="1516,660" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rdna2_citysample" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?fit=1516%2C660&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?fit=688%2C300&amp;ssl=1" decoding="async" width="688" height="300" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?resize=688%2C300&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?w=1516&amp;ssl=1 1516w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?resize=768%2C334&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?resize=1200%2C522&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?resize=1320%2C575&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2023/02/rdna2_citysample.png?resize=688%2C300&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Profiling a frame from Unreal Engine’s City Demo, showing very heavy use of compute and raytracing</figcaption></figure></div>
<p>Modern video cards therefore need to have good compute capabilities, and RDNA 2 does not disappoint. It might not have massive FP32 throughput of Nvidia’s Ampere architecture, but it’s in a good position to better make use of the execution units it does have.</p>
<h2>Conclusion</h2>
<p>RDNA 2 was a big moment for AMD. For the past decade or so, Nvidia generally dominated the high performance GPU market. AMD (and ATI) occasionally produces a card that can go head to head with Nvidia’s best, but that never seems to last for long. The RDNA 2 based RX 6900 XT is one of those examples, and is significant in the same way the Terascale 2 based HD 5800 was. Terascale 2 provided most of the performance of Nvidia’s Fermi cards, but at much lower power consumption. Similarly, RDNA 2 provides most of Ampere’s performance but with better power efficiency. At least part of that is down to RDNA 2’s use of cache, rather than a large GDDR6X setup. RDNA 2 thus represents a turning point in GPU cache strategy. </p>
<p>That cache setup makes RDNA 2 significant in another way. It represents a turning point in GPU cache strategy towards prioritizing general compute performance. The days of spamming more shaders, and then building a massive VRAM subsystem to feed it seem to be gone. The same applies to tile based rendering, which tries to optimize cache footprint by optimizing rasterization ordering. With compute gaining more prominence, rasterization-based tricks start having less of an impact. Like with CPUs, the answer seems to be more cache. AMD’s next generation GPU architecture, RDNA 3 uses a similar four level cache subsystem. Nvidia is similarly moving away from reliance on giant VRAM configurations. <a href="https://chipsandcheese.com/2022/11/02/microbenchmarking-nvidias-rtx-4090/">Ada Lovelace</a> massively increases L2 caching capacity, with the RTX 4090 getting 72 MB of L2. Even if a bigger GDDR6X setup or HBM could provide enough bandwidth to get by with just 4 MB or 6 MB of cache, such a solution would be too power hungry or expensive.</p>
<p>RDNA 2 also brings hardware raytracing acceleration into AMD’s GPU lineup. In contrast to Nvidia’s all-out approach, AMD’s probably trying to get acceptable performance with minimal hardware cost. I think that’s a smart move, because regular compute and rasterization still dominate a lot of workloads, and raytracing is definitely not required to produce good visuals. Also, future raytracing workloads are unlikely to be within reach with today’s technology, even with GPU power and die area maxed out. That’s because we’re nowhere near using pure raytracing render AAA titles, and even limited raytracing effects come with such a performance hit that Nvidia and AMD resort to using upscaling technologies.</p>
<p>But the important thing is, RDNA 2’s raytracing implementation gives AMD something to build off. So does the caching setup. RDNA 2 is almost like RDNA 1 in terms of building up a foundation for future success.</p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<div>

<ul>
<li>
<p><img alt="clamchowder" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" decoding="async" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
 </p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
