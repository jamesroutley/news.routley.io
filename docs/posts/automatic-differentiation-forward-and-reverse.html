<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jingnanshi.com/blog/autodiff.html">Original</a>
    <h1>Automatic Differentiation: Forward and Reverse</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
Deriving derivatives is not fun.
In this post, I will deep dive into the methods for automatic differentiation (abbreviated as AD by many).
After reading this post, you should feel confident with using the various AD techniques,
and hopefully never manually calculate derivatives again.
Note that this post is not a comparison between AD libraries. For that, a good starting point is <a href="http://www.stochasticlifestyle.com/engineering-trade-offs-in-automatic-differentiation-from-tensorflow-and-pytorch-to-jax-and-julia/">here</a>.
</p>

<div id="outline-container-orgcd8c8d6">
<h2 id="orgcd8c8d6">Why Automatic Differentiation?</h2>
<div id="text-orgcd8c8d6">
<p>
Automatic differentiation (AD) is a natural continuation of scientists and engineers’ pursuit for mechanizing computation.
After all, we learn how to take derivatives by memorizing a set of rules.
Why can’t computers do the same thing?
</p>


<div id="org6ba0fbe">
<p><img src="https://jingnanshi.com/img/articles/5_autodiff/leibniz_machine.jpg" alt="leibniz_machine.jpg"/>
</p>
<p><span>Figure 1: </span>Leibniz’s drawing of his calculating machine, appeared in <i>Miscellanea Berolensia ad incrementum scientiarum (1710)</i> (<a href="http://www.sophiararebooks.com/pages/books/3941/gottfried-wilhelm-leibniz/brevis-descriptio-machinae-arithmeticae-cum-figura">source</a>). This machine was supposed to be able to conduct addition, subtraction, multiplication and division. Unfortunately the prototype never worked properly.</p>
</div>

<p>
Nevertheless, if you just simply follow the rules and symbolically solve for derivatives,
the results you get will be deep in the expression hell.
Consider the <i>product rule</i> we are all familiar with:
</p><p>
\begin{align}
\frac{d}{d x}(f(x) g(x)) = \left(\frac{d}{d x} f(x)\right) g(x)+f(x)\left(\frac{d}{d x} g(x)\right)
\end{align}
</p><p>
Assume that we are not conducting any simplification along the way.
By simply following the product rule, we are multiplying the number of common terms in both \(f(x)\) and \(\frac{d}{dx}f(x)\), and \(g(x)\) and \(\frac{d}{dx}g(x)\) by two.
Essentially, this well result in a tree-like structure where the number of terms increase exponentially.
Table <a href="#org81b03f7">1</a> shows the results of applying symbolic differentiation using MATLAB’s <code>diff(f,x)</code> function without simplification.
Notice how the number of terms drastically increase, and how there are a repetition of the same terms in the derivatives’ expressions (which will come in handy when we discuss the algorithms for AD).
</p>

<table id="org81b03f7">
<caption><span>Table 1:</span> Derivatives From Symbolic Differentiation</caption>

<colgroup>
<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">\(f(x)\)</th>
<th scope="col">\(\frac{d}{dx} f(x)\) from MATLAB R2021a’s <code>diff(f, x)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>4(x-1)(x-2)</td>
<td>8x-12</td>
</tr>

<tr>
<td>4(x-1)(x-2)(x-3)</td>
<td>4(x - 2)(x - 3) + (4x - 4)(x - 2) + (4x - 4)(x - 3)</td>
</tr>

<tr>
<td>4(x-1)(x-2)(x-3)(x-4)</td>
<td>(4x - 4)(x - 2)(x - 3) + (4x - 4)(x - 2)(x - 4) + (4x - 4)(x - 3)(x - 4) + 4(x - 2)(x - 3)(x - 4)</td>
</tr>
</tbody>
</table>

<p>
So what if we find derivatives numerically?
After all, in most applications we don’t care about the forms of the derivatives, only the final values.
Perhaps we can try the finite difference method.
It is essentially the numerical approximation to the definition of gradients.
Given a scalar multivariate function \(f: \mathbb{R}^{n} \rightarrow \mathbb{R}\), we can approximate the gradients as
</p><p>
\begin{align}
\frac{\partial f(\mathbf{x})}{\partial x_{i}} \approx \frac{f\left(\mathbf{x}+h \mathbf{e}_{i}\right)-f(\mathbf{x})}{h}
\end{align}
</p><p>
where \(\mathbf{e}_{i}\) are the i-th unit vector and \(h\) is a small number.
This is the so-called forward difference method.
</p>




<div id="org749cb69">
<p><img src="https://jingnanshi.com/img/articles/5_autodiff/1x1.png" margin-top="5px"/>
</p>
<p><span>Figure 2: </span>Errors of forward difference method at different \(h\). At small \(h\), round off errors dominate, and at large \(h\), truncation errors dominate.</p>
</div>

<p>
There are a few issues with this method.
First, it requires \(O(n)\) work for n-dimensional gradients, which is prohibitive for neural networks with millions of learnable parameters.
It is also plagued by numerical errors.
Specifically, round-off errors (errors caused by using finite-bit floating point representations)
and truncation errors (the difference between the analytical gradients and the numerical gradients).
At small \(h\), round-off errors dominate. At large \(h\), truncation errors dominate (see Fig. <a href="#org749cb69">2</a>).
Such errors might be significant in ill-conditioned problems, causing numerical instabilities.
</p>

<p>
Automatic differentiation, on the other hand, is a solution to the problem of calculating derivatives without the downfalls of symbolic differentiation and finite differences.
The key idea behind AD is to decompose calculations into elementary steps that form an <b>evaluation trace</b>,
and combine each step’s derivative together through the chain rule.
Because of the use of evaluation traces, AD can differentiate through not only closed-form calculations,
but also control flow statements used in programs.
Regardless of the actual path taken,
at the end numerical computations will form an evaluation trace which can be used for AD.
</p>

<p>
In the rest of this post, I introduce the definition of evaluation traces, and the two modes of AD: forward and reverse.
I accompany the discussion with a implementation written in Rust.
</p>
</div>
</div>

<div id="outline-container-orgbc05961">
<h2 id="orgbc05961">Evaluation Traces</h2>
<div id="text-orgbc05961">
<p>
To decompose the functions into elementary steps,
we need to construct their <b>evaluation traces</b>.
You can view these traces as a recording of the steps you take to reach the final results.
Let’s take a look at an example function \(f: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}\) where \(n=2\) and \(m=1\) taken from Griewank and Walther <sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>:
</p><p>
\begin{align}
y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right]
\end{align}
</p><p>
Define the following variables:
</p>
<ul>
<li>\(v_{i-n} = x_{i}\), \(i=1, \ldots, n\) are the input variables,</li>
<li>\(v_{i}\), \(i=1,\ldots,l\) are the intermediate variables,</li>
<li>\(y_{m-i} = v_{l-i}\), \(i=m-1, \ldots, 0\) are the output variables.</li>
</ul>
<p>
Note that the numbering system used is arbitrary, as long as it is consistent.
</p>

<p>
Let’s now evaluate the function when \(x_{1} = 1.5\) and \(x_{2} = 2.0\), and record all the intermediate values.
</p>
<table id="orgf51a4a2">
<caption><span>Table 2:</span> Evaluation Trace of \(y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right]\)</caption>

<colgroup>
<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Intermediate Vars.</th>
<th scope="col">Expressions</th>
<th scope="col">Values</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(v_{-1}\)</td>
<td>\(x_1\)</td>
<td>\(1.5\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{0}\)</td>
<td>\(x_2\)</td>
<td>\(2.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{1}\)</td>
<td>\(v_{-1} / v_{0}\)</td>
<td>\(3.0000\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{2}\)</td>
<td>\(\sin{(v_{1})}\)</td>
<td>\(0.1411\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{3}\)</td>
<td>\(\exp(v_{0})\)</td>
<td>\(1.6487\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{4}\)</td>
<td>\(v1 - v3\)</td>
<td>\(1.3513\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{5}\)</td>
<td>\(v2+v4\)</td>
<td>\(1.4924\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{6}\)</td>
<td>\(v5 \cdot v4\)</td>
<td>\(2.0167\)</td>
</tr>
</tbody>
</table>
<p>
\(v_{6}\) is the final output variable \(y\), which equals to \(2.0167\).
Some also call this evaluation trace the Wengert list,
which is named after the author of the 1964 paper <i>A Simple Automatic Derivative Evaluation Program</i>.
Note that there is nothing special about this list.
In fact, you can probably represent it as a list in Python if you want.
</p>

<p>
Graphically, we can also represent it as a directed acyclic graph, where the variables are the nodes of the graph,
and edges represent the algebraic relationships.
</p>


<div id="orgc408073">
<p><img src="https://jingnanshi.com/img/articles/5_autodiff/simple_trace.png" alt="simple_trace.png"/>
</p>
<p><span>Figure 3: </span>Computation Graph of Table <a href="#orgf51a4a2">2</a>, for \(y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right]\)</p>
</div>

<p>
Comparing to the table format,
this graph shows the logical dependencies of each of the intermediate variables on the evaluation trace better.
For example, if we want to compute \(v_{5}\), we have to have computed \(v_{4}\) and \(v_{2}\).
</p>

<p>
A logical next step for finding the defivatives of \(y\)
with respect to \(x_{1}\) and \(x_{2}\) is to follow the evaluation trace, and simple calculate the derivatives one intermediate variable at a time.
This leads us to the forward mode automatic differentiation algorithm.
</p>
</div>
</div>

<div id="outline-container-org842c2cd">
<h2 id="org842c2cd">Forward Mode</h2>

<div id="outline-container-org52fdd34">
<h3 id="org52fdd34">Accumulating the Tangent Trace</h3>
<div id="text-org52fdd34">
<p>
Let’s say we want to calculate the partial derivative of \(y\) with respect to \(x_{1}\), with \(x_{1} = 1.5\) and \(x_{2} = 0.5\).
As we mentioned above, we can try do it one intermediate variable at a time.
Note that we are only calculating the numerical value of the derivative.
For each \(v_{i}\), we calculate \(\dot{v}_{i} = \frac{\partial v_{i}}{\partial x_{1}}\).
Let’s try a few variables to see how it goes:
</p><p>
\begin{align}
\dot{v}_{-1} &amp;= \frac{\partial x_{1}}{\partial x_{1}} = 1.0 \\
\dot{v}_{0} &amp;= \frac{\partial x_{2}}{\partial x_{1}} = 0 \\
\dot{v}_{1} &amp;= \frac{\partial (v_{-1} / v_{0}) }{\partial x_{1}} = \dot{v}_{-1} (v_{0}^{-1}) + \dot{v}_{0} (-v_{-1} v_{0}^{-2})  = 1.00 / 0.50 = 2.00 \\
\dot{v}_{2} &amp;= \frac{\partial (\sin{(v_{1})}) }{\partial x_{1}} = \cos(v_{1}) \dot{v_{1}} = -0.99 \times 2.00 = -1.98
\end{align}
</p><p>
For these calculations, we are simply applying chain rules with basic derivatives.
Note that how \(\dot{v}_{i}\) only depends on the derivatives and values of the earlier variables.
We can now augment Table <a href="#orgf51a4a2">2</a>
to include the derivatives.
</p>
<table id="org8e965d4">
<caption><span>Table 3:</span> Evaluation Trace of \(y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right]\) with derivatives with respect to \(x_{1}\)</caption>

<colgroup>
<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Intermediate Vars.</th>
<th scope="col">Values</th>
<th scope="col">Derivatives</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(v_{-1}\)</td>
<td>\(1.5\)</td>
<td>\(1.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{0}\)</td>
<td>\(2.0\)</td>
<td>\(0.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{1}\)</td>
<td>\(3.0000\)</td>
<td>\(2.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{2}\)</td>
<td>\(0.1411\)</td>
<td>\(-1.98\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{3}\)</td>
<td>\(1.6487\)</td>
<td>\(0.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{4}\)</td>
<td>\(1.3513\)</td>
<td>\(2.0\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{5}\)</td>
<td>\(1.4924\)</td>
<td>\(0.02\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{6}\)</td>
<td>\(2.0167\)</td>
<td>\(3.0118\)</td>
</tr>
</tbody>
</table>
<p>
The values of the intermediate variables are sometimes called the <b><b>primal trace</b></b>,
and the derivative values the <b><b>tangent trace</b></b>.
</p>

<p>
This generalizes nicely to a generic vector-valued function \(f: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}\).
Assume we are trying to evaluate the function at \(\mathbf{x} = \mathbf{a}, \mathbf{a} \in \mathbb{R}^{n}\).
In that case, the Jacobian matrix is in the form of
</p><p>
\begin{align}
\mathbf{J}_{f}=\left.\left[\begin{array}{ccc}
\frac{\partial y_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial x_{n}} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_{m}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}
\end{array}\right]\right|_{\mathbf{x}=\mathbf{a}}
\end{align}
</p><p>
and each column consists of
</p><p>
\begin{align}
\dot{y}_{j}=\left.\frac{\partial y_{j}}{\partial x_{i}}\right|_{\mathbf{x}=\mathbf{a}}, j=1, \ldots, m
\end{align}
</p><p>
which are the partial derivatives of \(y_{j}\) with respect to each \(x_{i}\).
So we can obtain the columns one by one by setting the corresponding \(\dot{x}_{i} = 1\) and setting the other entries zero.
This opens some interesting techniques.
For example, if we want to compute the Jacobian-vector product with \(\mathbf{r}\), we can simply set \(\dot{\mathbf{x}}=\mathbf{r}\) instead of a unit vector:
</p><p>
\begin{align}
\mathbf{J}_{f} \mathbf{r}=\left[\begin{array}{ccc}
\frac{\partial y_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial x_{n}} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_{m}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}
\end{array}\right]\left[\begin{array}{c}
r_{1} \\
\vdots \\
r_{n}
\end{array}\right].
\end{align}

</p><p>
In terms of complexity, forward mode is on the order of \(O(n)\), where \(n\) is the dimension of the input vector.
Hence, it will be a great choice for \(f: \mathbb{R} \rightarrow \mathbb{R}^{m}\), while performing poorly for \(f: \mathbb{R}^{n} \rightarrow \mathbb{R}\).
</p>
</div>
</div>

<div id="outline-container-org0affa75">
<h3 id="org0affa75">Using Dual Numbers</h3>
<div id="text-org0affa75">
<p>
One popular way to implement forward mode AD is to use <b><b>dual numbers</b></b>.
Dual numbers were introduced by William Clifford in 1873 through his paper <i>Preliminary Sketch of Biquaternions</i>.
Clifford was studying how to extend Hamilton’s vectors to consider rotations around not only the origin,
but any arbitrary lines in the 3-dimensional space.
He called his extension on vectors rotors, and the sum of such rotors motors.
He then introduces a symbol \(\omega\) to convert motors into vectors, and that \(\omega^{2} = 0\).
His reasoning was purely geometric:
</p>
<blockquote>
<p>
The symbol \(\omega\), applied to any motor, changes it into a vector parallel to its axis and proportional    to the rotor part of it. … and if made to operate directly on a vector, reduces it to zero.
</p>
</blockquote>
<p>
However, it turns out that dual numbers can be conveniently to represent differentiation.
</p>

<p>
Formally, we represent dual numbers as \(a + b\epsilon\).
They follow the usual component-wise addition rule:
</p><p>
\begin{align}
(a + b \epsilon) + (c + d \epsilon) = (a + c) + (b + d) \epsilon.
\end{align}
</p><p>
And their multiplications work like this (similar to complex numbers):
</p><p>
\begin{align}
(a+b \epsilon)(c+d \epsilon)=a c+(a d+b c) \epsilon + db \epsilon^{2} = a c + (a d+b c) \epsilon,
\end{align}
</p><p>
with the rule that \(\epsilon^{2} = 0\).
</p>

<p>
The connection between dual numbers and differentiation becomes clear once we look at the Taylor series expansion.
Given an arbitrary real function \(f : \mathbb{R} \rightarrow \mathbb{R}\), we can express its Taylor series expansion at \(x_{0}\) as
</p><p>
\begin{align}
f(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+\mathcal{O}\left(\left(x-x_{0}\right)^{n+1}\right)
\end{align}
</p><p>
as long as the function is \(n+1\) times differentiable and has bounded \(n+1\) derivative.
If we instead extend them to using dual numbers as inputs, it follows that
</p><p>
\begin{align}
f(a + b \epsilon) =\sum_{n=0}^{\infty} \frac{f^{(n)}(a) b^{n} \epsilon^{n}}{n !}=f(a)+b f^{\prime}(a) \epsilon.
\end{align}
</p><p>
So if we set \(b=1\), we can get the derivative at \(x=a\) by taking the coefficient of \(\epsilon\) after evaluation:
</p><p>
\begin{align} \label{eq:dual-single-v} \tag{1}
f(a + \epsilon) = f(a) + f^{\prime}(a) \epsilon
\end{align}
</p><p>
where we expanded the Taylor series at \(a\), and since \(\epsilon^{2} = 0\), all terms involving \(\epsilon^{2}\) and higher vanish.
Under this formulation, addition works:
</p><p>
\begin{align}
f(a + \epsilon) + g(a + \epsilon) &amp;= f(a) + g(a) + (f^{\prime}(a) + g^{\prime}(a) ) \epsilon.
\end{align}
</p><p>
Multiplication works:
</p><p>
\begin{align}
f(a + \epsilon)  g(a + \epsilon) &amp;= f(a) g(a) + (f^{\prime}(a) g(a)  + f(a) g^{\prime}(a) ) \epsilon.
\end{align}
</p><p>
And chain rule works as expected:
</p><p>
\begin{align}
f(g(a + \epsilon)) &amp;=f(g(a) + g^{\prime}(a) \epsilon) \\
                     &amp;=f(g(a)) + f^{\prime}(g(a)) g^{\prime}(a) \epsilon.
\end{align}
</p><p>
This essentially gives us the way to conduct forward mode AD: by using dual numbers, we can get the primal and tangent trace simultaneously.
</p>

<p>
So, how do we take this to higher dimensions?
We simply add an \(\epsilon\) for each component.
Assume a function \(f: \mathbb{R}^{n} \rightarrow \mathbb{R}\).
We define a vector \(\boldsymbol{\epsilon} \in \mathbb{R}^{n}\) where \(\boldsymbol{\epsilon}_{i}^{2} =  \boldsymbol{\epsilon}_{i} \boldsymbol{\epsilon}_{j} = 0\).
If you write out the component-wise computation following Eq. \ref{eq:dual-single-v},
it follows that
</p><p>
\begin{align} \label{eq:dual-multi-v} \tag{2}
f(\boldsymbol{a} + \boldsymbol{\epsilon}) = f(\boldsymbol{a}) + \nabla f(\boldsymbol{a}) \cdot \boldsymbol{\epsilon}
\end{align}
</p><p>
\(\nabla f(\boldsymbol{a}) \cdot \boldsymbol{\epsilon}\) can be interpreted as the directional derivative of \(f\) in the direction of \(\boldsymbol{\epsilon}\).
Addition, multiplication and chain rule work as expected:
</p><p>
\begin{align}
f(\boldsymbol{a} + \boldsymbol{\epsilon}) + g(\boldsymbol{a} + \boldsymbol{\epsilon}) &amp;= f(\boldsymbol{a}) + g(\boldsymbol{a}) + (\nabla f(\boldsymbol{a}) + \nabla g(\boldsymbol{a}) ) \boldsymbol{\epsilon} \\
f(\boldsymbol{a} + \boldsymbol{\epsilon})   g(\boldsymbol{a} + \boldsymbol{\epsilon}) &amp;= f(\boldsymbol{a}) g(\boldsymbol{a}) + (\nabla f(\boldsymbol{a}) g(\boldsymbol{a})  + f(\boldsymbol{a}) \nabla g(\boldsymbol{a}) ) \boldsymbol{\epsilon} \\
f(g(\boldsymbol{a} + \boldsymbol{\epsilon})) &amp;=f(g(\boldsymbol{a})) + \nabla f(g(\boldsymbol{a})) \nabla g(\boldsymbol{a}) \boldsymbol{\epsilon}
\end{align}

</p><p>
For \(f : \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}\), instead of using a vector of \(\epsilon\), we can use a matrix of \(\epsilon\).
And for each row of that matrix, we follow the exact same rule as Eq. \ref{eq:dual-multi-v}.
</p>
</div>
</div>
</div>

<div id="outline-container-orgee3426d">
<h2 id="orgee3426d">Reverse Mode</h2>

<div id="outline-container-orgcf2f0d4">
<h3 id="orgcf2f0d4">Propagate From the End</h3>
<div id="text-orgcf2f0d4">
<p>
Reverse mode automatic differentiation, also known as adjoint mode, calculates the derivative by going from the end of the evaluation trace to the beginning.
The intuition comes from the chain rule.
Consider a function \(y = f(x(t))\). From the chain rule, it follows that
</p><p>
\begin{align}
\frac{\partial y}{\partial t} = \frac{\partial y}{\partial x} \cdot \frac{\partial x}{\partial t}
\end{align}
</p><p>
The two terms on the right-hand side can be seen as going backwards: \(\frac{\partial y}{\partial x}\)
can be determined once we calculate \(y\) from \(x\),
and \(\frac{\partial x}{\partial t}\) can be calculated once we calculate \(x\) from \(t\).
Extending this to multivariate functions, we have the multivariate chain rule:
</p>
<p>
Theorem <a href="#orgd604df9">1</a>: Suppose \(g: \mathbf{R}^{n} \rightarrow \mathbf{R}^{m}\) is differentiable at \(a \in \mathbf{R}^{n}\) and \(f: \mathbf{R}^{m} \rightarrow \mathbf{R}^{p}\) is differentiable at \(g(a) \in \mathbf{R}^{m}\). Then \(f \circ g: \mathbf{R}^{n} \rightarrow \mathbf{R}^{p}\) is differentiable at \(a\), and its derivative at this point is given by
\[
D_{a}(f \circ g)=D_{g(a)}(f) D_{a}(g).
\]
</p>
<p>
The proof of it can be found in Appendix A4 of <i>Vector Calculus, Linear Algebra, and Differential Forms: a Unified Approach</i> by John H. Hubbard and Barbara Burke Hubbard.
For example, for a function \(F(t) = f(g(t)) = f(x(t), y(t))\) where \(f : \mathbf{R}^{2} \rightarrow \mathbf{R}\) and \(g : \mathbf{R} \rightarrow \mathbf{R}^{2}\), we have
</p><p>
\begin{align}
D_{a}(f \circ g)=D_{a}(F)=\frac{d F}{d t} \\
D_{g(a)}(f)=\left[\begin{array}{ll}
\frac{\partial f}{\partial x} &amp; \frac{\partial f}{\partial y}
\end{array}\right] \\
D_{a}(g)=\left[\begin{array}{l}
\partial x / \partial t \\
\partial y / \partial t
\end{array}\right]
\end{align}
</p><p>
So it follows
</p><p>
\begin{align}
\frac{d F}{d t} = \left[\begin{array}{ll}
\frac{\partial f}{\partial x} &amp; \frac{\partial f}{\partial y}
\end{array}\right]
\left[\begin{array}{l}
\partial x / \partial t \\
\partial y / \partial t
\end{array}\right] = \frac{\partial f}{\partial x} \frac{\partial x}{\partial t} + \frac{\partial f}{\partial y} \frac{\partial y}{\partial t}
\end{align}

</p><p>
Applying this idea to automatic differentiation, we have the reverse mode.
To calculate derivatives in this mode, we need to conduct two passes.
First, we need to do a forward pass, where we obtain the primal trace (Table <a href="#orgf51a4a2">2</a>).
We then propagate the partials backward to obtain the desired derivatives (following the chain rule).
Let’s go back to our example before to see reverse mode in action.
Consider again the function
</p><p>
\begin{align}
y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right].
\end{align}
</p><p>
Following the same way of assigning intermediate variables as in Table <a href="#orgf51a4a2">2</a> and in Fig. <a href="#orgc408073">3</a>, we can assemble an adjoint trace.
An adjoint \(\bar{v}_{i}\) is defined as
</p><p>
\begin{align}
\bar{v}_{i} = \frac{\partial y_{j}}{\partial v_{i}},
\end{align}
</p><p>
which is equivalent to the product of all the partials from \(y_{j}\) up until \(v_{i}\).
We start from the last variable \(v_{6} = y\):
</p><p>
\begin{align}
\bar{v}_{6} &amp;= \frac{\partial y}{\partial v_{6}} = 1 \\
\bar{v}_{5} &amp;= \frac{\partial y}{\partial v_{5}} = \bar{v}_{6} \frac{\partial v_{6}}{\partial v_{5}} = 1 \times v_{4} = 1.3513 \\
\bar{v}_{4} &amp;= \frac{\partial y}{\partial v_{4}} = \frac{\partial y}{\partial v_{5}} \frac{\partial v_{5}}{\partial v_{4}} + \frac{\partial y}{\partial v_{6}} \frac{\partial v_{6}}{\partial v_{4}} = \bar{v}_{5} \frac{\partial v_{5}}{\partial v_{4}} + \bar{v}_{6} \frac{\partial v_{6}}{\partial v_{4}} = 1.3513 + 1.4914 = 2.8437
\end{align}
</p><p>
And repeat the same process for all the intermediate variables, we have Table <a href="#org8fc0b48">4</a> below.
</p>
<table id="org8fc0b48">
<caption><span>Table 4:</span> Evaluation Trace of \(y=\left[\sin \left(x_{1} / x_{2}\right)+x_{1} / x_{2}-\exp \left(x_{2}\right)\right] \left[x_{1} / x_{2}-\exp \left(x_{2}\right)\right]\) with adjoints. To read this table, start from the bottom row up.</caption>

<colgroup>
<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Intermediate Vars.</th>
<th scope="col">Values</th>
<th scope="col">Adjoints</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(v_{-1}\)</td>
<td>\(1.5\)</td>
<td>\(3.0118\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{0}\)</td>
<td>\(2.0\)</td>
<td>\(-13.7239\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{1}\)</td>
<td>\(3.0000\)</td>
<td>\(1.5059\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{2}\)</td>
<td>\(0.1411\)</td>
<td>\(1.3513\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{3}\)</td>
<td>\(1.6487\)</td>
<td>\(-2.8437\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{4}\)</td>
<td>\(1.3513\)</td>
<td>\(2.8437\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{5}\)</td>
<td>\(1.4924\)</td>
<td>\(1.3513\)</td>
</tr>
</tbody>
<tbody>
<tr>
<td>\(v_{6}\)</td>
<td>\(2.0167\)</td>
<td>\(1\)</td>
</tr>
</tbody>
</table>
<p>
Note how we are able to obtain the adjoints of the input variables \(x\) and \(y\) (which are equivalent to the partial derivatives of \(f\) with respect to \(x\) and \(y\)) at the same time.
For a function \(f : \mathbf{R}^{n} \rightarrow \mathbf{R}\), it takes only one application of reverse mode to compute the entire gradient.
In general, if the dimension of the outputs is significantly smaller than that of inputs, reverse mode is a better choice.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc961e92">
<h2 id="orgc961e92"><code>diffomatic</code>: My Implementation in Rust</h2>
<p>
It’s always fun to implement theories in actual code. In this section, I describe <code>diffomatic</code>, my attempt at implementing both forward and reverse mode automatic differentiation.
Note that in the current implementation, I only support first-order differentiation.
In addition, I have not spent any time optimizing the code. You can access the repo <a href="https://github.com/jingnanshi/diffomatic">here</a>.
During writing the code, I have referenced <a href="https://github.com/elrnv/autodiff/blob/master/src/forward_autodiff.rs">this</a> repo and <a href="https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation">this</a> blog post.
</p>
<div id="outline-container-orgb0ccf85">
<h3 id="orgb0ccf85">Forward Mode</h3>
<div id="text-orgb0ccf85">
<p>
To implement forward mode in Rust,
I opt to create a structure to represent dual numbers:
</p>
<div>
<pre><span>pub</span> <span>struct</span> <span>DualScalar</span> {
    <span>pub</span> <span>v</span>: <span>f64</span>,
    <span>pub</span> <span>dv</span>: <span>f64</span>,
}
</pre>
</div>
<p>
The operations are then implemented on <code>DualScalar</code>,
following standard traits such as <code>std::ops::{Add, Div, Mul, Neg, Sub}</code>. For example,
</p>
<div>
<pre><span>impl</span> <span>Add</span> <span>for</span> <span>DualScalar</span> {
    <span>type</span> <span>Output</span> = <span>Self</span>;

    <span>fn</span> <span>add</span>(<span>self</span>, <span>rhs</span>: <span>Self</span>) -&gt; <span>Self</span>::<span>Output</span> {
        <span>DualScalar</span> {
            <span>v</span>: <span>self</span>.v + rhs.v,
            <span>dv</span>: <span>self</span>.dv + rhs.dv,
        }
    }
}
</pre>
</div>
<div>
<pre><span>pub</span> <span>fn</span> <span>deriv</span>(<span>&amp;</span><span>self</span>) -&gt; <span>f64</span> {
    <span>self</span>.dv.clone()
}
</pre>
</div>
<p>
where the addition rule is implemented for the <code>add(self, rhs: Self)</code> function.
To access the derivative value, we have
And evaluating a function to get the derivative is done through the <code>derivative&lt;F&gt;(func: F, x0: f64 )</code> function:
</p>
<div>
<pre><span>pub</span> <span>fn</span> <span>derivative</span>&lt;<span>F</span>&gt;(<span>func</span>: <span>F</span>, <span>x0</span>: <span>f64</span> ) -&gt; <span>f64</span>
    <span>where</span> <span>F</span> : <span>Fn</span>(<span>DualScalar</span>) -&gt; <span>DualScalar</span>,
{
    func(<span>DualScalar</span>{ <span>v</span>: x0, <span>dv</span>: <span>1.0</span>}).deriv()
}
</pre>
</div>
<p>
For multivariate functions, I simply represent the inputs as a <code>Vec</code> holding <code>DualScalar</code>.
</p>
<div>
<pre><span>pub</span> <span>fn</span> <span>gradient</span>&lt;<span>F</span>&gt;(<span>func</span>: <span>F</span>, <span>x0</span>: <span>&amp;</span>[<span>f64</span>]) -&gt; <span>Vec</span>&lt;<span>f64</span>&gt;
    <span>where</span> <span>F</span>: <span>Fn</span>(<span>&amp;</span>[<span>DualScalar</span>]) -&gt; <span>DualScalar</span>,
{
    
    
    <span>let</span> <span>mut</span> <span>inputs</span>: <span>Vec</span>&lt;<span>DualScalar</span>&gt; = x0.iter().map(|<span>&amp;</span>v| <span>DualScalar</span> { <span>v</span>: v, <span>dv</span>: <span>0</span>. }).collect();
    (<span>0</span>..x0.len()).map(
        |i| {
            inputs[i].dv = <span>1</span>.;
            <span>let</span> <span>partial</span> = func(<span>&amp;</span>inputs).deriv();
            inputs[i].dv = <span>0</span>.;
            partial
        }
    ).collect()
}
</pre>
</div>
<p>
Note that we have to iterate through all the inputs by setting <code>dv</code> to be 1, then collect the partials.
For Jacobians, we obtain the columns one by one:
</p>
<div>
<pre><span>pub</span> <span>fn</span> <span>jacobian</span>&lt;<span>F</span>, <span>const</span> <span>N</span>: <span>usize</span>, <span>const</span> <span>M</span>: <span>usize</span>&gt;(<span>func</span>: <span>F</span>, <span>x0</span>: <span>&amp;</span>[<span>f64</span>]) -&gt; <span>SMatrix</span>&lt;<span>f64</span>, <span>M</span>, <span>N</span>&gt;
    <span>where</span> <span>F</span>: <span>Fn</span>(<span>&amp;</span>[<span>DualScalar</span>]) -&gt; <span>Vec</span>&lt;<span>DualScalar</span>&gt;,
{
    
    
    <span>let</span> <span>mut</span> <span>jacobian</span>: <span>SMatrix</span>&lt;<span>f64</span>, <span>M</span>, <span>N</span>&gt; = <span>SMatrix</span>::zeros();
    <span>let</span> <span>mut</span> <span>inputs</span>: <span>Vec</span>&lt;<span>DualScalar</span>&gt; = x0.iter().map(|<span>&amp;</span>v| <span>DualScalar</span> { <span>v</span>: v, <span>dv</span>: <span>0</span>. }).collect();

    
    <span>for</span> (i, <span>mut</span> col) <span>in</span> jacobian.column_iter_mut().enumerate() {
        inputs[i].dv = <span>1</span>.;
        <span>let</span> <span>col_result</span> = func(<span>&amp;</span>inputs);
        <span>for</span> <span>j</span> <span>in</span> <span>0</span>..<span>M</span> {
            col[j] = col_result[j].dv;
        }
        inputs[i].dv = <span>0</span>.;
    }

    <span>return</span> jacobian;
}
</pre>
</div>
<p>
The API of these functions are pretty straightforward:
</p>
<div>
<pre>



<span>let</span> <span>f1_test</span> = |<span>x</span>: <span>fdiff</span>::<span>DualScalar</span>| x * x;
<span>let</span> <span>f1_result</span>: <span>f64</span> = <span>fdiff</span>::derivative(f1_test, <span>2.0</span>);
<span>println!</span>(<span>&#34;Derivative of f(x) = x^2 at </span><span>{}</span><span> is </span><span>{}</span><span>&#34;</span>, <span>2.0</span>, f1_result);


<span>let</span> <span>f2_test</span> = |<span>x</span>: <span>&amp;</span>[<span>fdiff</span>::<span>DualScalar</span>]| x[<span>0</span>] + x[<span>1</span>];
<span>let</span> <span>f2_result</span>: <span>Vec</span>&lt;<span>f64</span>&gt; = <span>fdiff</span>::gradient(f2_test, <span>vec!</span>[<span>1</span>., <span>2</span>.].as_slice());
<span>println!</span>(<span>&#34;Gradient of f(x,y) = x + y at (</span><span>{}</span><span>, </span><span>{}</span><span>) is </span><span>{:?}</span><span>&#34;</span>, <span>1.0</span>, <span>2.0</span>, f2_result);




<span>let</span> <span>f3_test</span> = |<span>x</span>: <span>&amp;</span>[<span>fdiff</span>::<span>DualScalar</span>]| {
    <span>vec!</span>[x[<span>0</span>] * x[<span>0</span>] * x[<span>1</span>], x[<span>0</span>] + x[<span>1</span>]]
};
<span>let</span> <span>f3_result</span>: <span>SMatrix</span>&lt;<span>f64</span>, <span>2</span>, <span>2</span>&gt; = <span>fdiff</span>::jacobian(f3_test, <span>vec!</span>[<span>1</span>., <span>2</span>.].as_slice());
<span>println!</span>(<span>&#34;Jacobian of f(x,y) = [x^2 * y , x + y] at (</span><span>{}</span><span>, </span><span>{}</span><span>) is </span><span>{:?}</span><span>&#34;</span>, <span>1.0</span>, <span>2.0</span>, f3_result);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaf46974">
<h3 id="orgaf46974">Reverse Mode</h3>
<div id="text-orgaf46974">
<p>
Reverse mode turns out to be a bit harder in Rust. Initially, I struggled with the ownership model as I wanted to dynamically represent the computation graph as linked nodes.
Then I stumbled across <a href="https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation">this</a> excellent post by Rufflewind, which goes through a tape-based implementation.
Essentially, we need to separate the computation graph with the expression, so that users can treat variables as float-like, because we are simply storing indices to the locations on an array.
</p>

<p>
We first define a <code>Tape</code> and <code>Node</code>:
</p>
<div>
<pre><span>pub</span> <span>struct</span> <span>Tape</span> {
    <span>pub</span> <span>nodes</span>: <span>RefCell</span>&lt;<span>Vec</span>&lt;<span>Node</span>&gt;&gt;,
}

<span>#[derive(Clone, Copy)]</span>
<span>pub</span> <span>struct</span> <span>Node</span> {
    <span>pub</span> <span>partials</span>: [<span>f64</span>; <span>2</span>],
    <span>pub</span> <span>parents</span>: [<span>usize</span>; <span>2</span>],
}
</pre>
</div>
<p>
The <code>parents</code> hold the node’s dependencies in the computation graph, and <code>partials</code> are the respective partials to the parents.
We then define a few operations on the <code>Tape</code>:
</p>
<div>
<pre><span>impl</span> <span>Tape</span> {
    <span>pub</span> <span>fn</span> <span>var</span>(<span>&amp;</span><span>self</span>, <span>value</span>: <span>f64</span>) -&gt; <span>Var</span> {
        <span>let</span> <span>len</span> = <span>self</span>.nodes.borrow().len();
        <span>self</span>.nodes.borrow_mut().push(
            <span>Node</span> {
                <span>partials</span>: [<span>0.0</span>, <span>0.0</span>],
                
                <span>parents</span>: [len, len],
            }
        );
        <span>Var</span> {
            <span>tape</span>: <span>self</span>,
            <span>index</span>: len,
            <span>v</span>: value,
        }
    }

    <span>pub</span> <span>fn</span> <span>binary_op</span>(<span>&amp;</span><span>self</span>, <span>lhs_partial</span>: <span>f64</span>, <span>rhs_partial</span>: <span>f64</span>,
                     <span>lhs_index</span>: <span>usize</span>, <span>rhs_index</span>: <span>usize</span>, <span>new_value</span>: <span>f64</span>) -&gt; <span>Var</span> {
        <span>let</span> <span>len</span> = <span>self</span>.nodes.borrow().len();
        <span>self</span>.nodes.borrow_mut().push(
            <span>Node</span> {
                <span>partials</span>: [lhs_partial, rhs_partial],
                
                <span>parents</span>: [lhs_index, rhs_index],
            }
        );
        <span>Var</span> {
            <span>tape</span>: <span>self</span>,
            <span>index</span>: len,
            <span>v</span>: new_value,
        }
    }
}
</pre>
</div>
<p>
The <code>var</code> function is called when we create a new variable on the tape, and <code>binary_op</code> is a helper function for creating intermediate variables as results of mathematical operations (such as <code>+</code>).
As for the users, we implement a <code>Var</code> struct (which has a one-to-one correspondence to a <code>Node</code> on the tape)
</p>
<div>
<pre><span>#[derive(Clone, Copy)]</span>
<span>pub</span> <span>struct</span> <span>Var</span>&lt;&#39;<span>t</span>&gt; {
    <span>pub</span> <span>tape</span>: <span>&amp;</span>&#39;<span>t</span> <span>Tape</span>,
    <span>pub</span> <span>index</span>: <span>usize</span>,
    <span>pub</span> <span>v</span>: <span>f64</span>,
}
</pre>
</div>
<p>
where <code>tape</code> points to the tape we currently have, <code>index</code> is the location of the corresponding <code>Node</code> on the tape, and <code>v</code> is the actual value.
The reason why we need a separate <code>Var</code> struct is that users don’t need to deal with the ownership of the <code>Node</code> by the tape, and that <code>Var</code> can be copied just like a float.
The actual reverse pass (back-propagation) is easy:
</p>
<div>
<pre><span>impl</span> <span>Var</span>&lt;&#39;<span>_</span>&gt; {
    <span>/// Perform back propagation</span>
    <span>pub</span> <span>fn</span> <span>backprop</span>(<span>&amp;</span><span>self</span>) -&gt; <span>Grad</span> {
        
        <span>let</span> <span>tape_len</span> = <span>self</span>.tape.nodes.borrow().len();
        <span>let</span> <span>mut</span> <span>grad</span> = <span>vec!</span>[<span>0.0</span>; tape_len];
        grad[<span>self</span>.index] = <span>1.0</span>;

        <span>for</span> <span>i</span> <span>in</span> (<span>0</span>..tape_len).rev() {
            <span>let</span> <span>node</span> = <span>self</span>.tape.nodes.borrow()[i];
            
            <span>let</span> <span>lhs_dep</span> = node.parents[<span>0</span>];
            <span>let</span> <span>lhs_partial</span> = node.partials[<span>0</span>];
            grad[lhs_dep] += lhs_partial * grad[i];

            
            
            
            <span>let</span> <span>rhs_dep</span> = node.parents[<span>1</span>];
            <span>let</span> <span>rhs_partial</span> = node.partials[<span>1</span>];
            grad[rhs_dep] += rhs_partial * grad[i];
        }

        <span>Grad</span> { grad }
    }
}
</pre>
</div>
<p>
where <code>Grad</code> is simply a struct holding the gradients, with a <code>wrt()</code> function that gets the specific partial derivatives for a specific <code>Var</code>.
To implement specific differentiation rules, we implement the corresponding traits on <code>Var</code>:
</p>
<div>
<pre><span>impl</span>&lt;&#39;<span>t</span>&gt; <span>Add</span> <span>for</span> <span>Var</span>&lt;&#39;<span>t</span>&gt; {
    <span>type</span> <span>Output</span> = <span>Self</span>;

    <span>fn</span> <span>add</span>(<span>self</span>, <span>rhs</span>: <span>Self</span>) -&gt; <span>Self</span>::<span>Output</span> {
        <span>self</span>.tape.binary_op(<span>1.0</span>, <span>1.0</span>,
                            <span>self</span>.index, rhs.index, <span>self</span>.v + rhs.v)
    }
}
</pre>
</div>
<p>
For the users, they can obtain partial derivatives easily:
</p>
<div>
<pre><span>let</span> <span>tape</span> = <span>rdiff</span>::<span>Tape</span>::new();
<span>let</span> <span>x</span> = tape.var(<span>1.0</span>);
<span>let</span> <span>y</span> = tape.var(<span>1.0</span>);
<span>let</span> <span>z</span> = -<span>2.0</span> * x + x * x * x * y + <span>2.0</span> * y;
<span>let</span> <span>grad</span> = z.backprop();
<span>println!</span>(<span>&#34;dz/dx of z = -2x + x^3 * y + 2y at x=1.0, y=1.0 is </span><span>{}</span><span>&#34;</span>, grad.wrt(x));
<span>println!</span>(<span>&#34;dz/dy of z = -2x + x^3 * y + 2y at x=1.0, y=1.0 is </span><span>{}</span><span>&#34;</span>, grad.wrt(y));
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1fc341e">
<h2 id="org1fc341e">Conclusion</h2>
<p>
This post covers basic automatic differentiation techniques for forward and reverse mode.
I learned a lot by actually implementing the techniques, instead of just going over the mathematics.
For future posts, I might try cover the topics of differentiable programming and optimization for robotics.
</p>
</div>

<div id="outline-container-orga8cdcc2">
<h2 id="orga8cdcc2">References</h2>
<div id="text-orga8cdcc2">
<p>
Here are some resources I’ve used in writing this post:
</p>
<ul>
<li>Textbook:
<ul>
<li>Griewank, Andreas, and Andrea Walther. Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation. 2nd ed. Philadelphia, PA: Society for Industrial and Applied Mathematics, 2008.</li>
</ul></li>
<li>Papers:
<ul>
<li>Revels, Jarrett, Miles Lubin, and Theodore Papamarkou. “Forward-mode automatic differentiation in Julia.” arXiv preprint arXiv:1607.07892 (2016). (<a href="https://arxiv.org/pdf/1607.07892.pdf">link</a>)</li>
<li>Baydin, Atilim Gunes, et al. “Automatic differentiation in machine learning: a survey.” Journal of Marchine Learning Research 18 (2018): 1-43. (<a href="https://www.jmlr.org/papers/volume18/17-468/17-468.pdf">link</a>)</li>
</ul></li>
<li>Repos:
<ul>
<li><a href="https://github.com/elrnv/autodiff/blob/master/src/forward_autodiff.rs"><code>autodiff</code></a>: A Rust library implementing forward mode AD.</li>
<li><a href="https://github.com/rasmusbergpalm/nanograd/blob/main/nanograd.py"><code>nanograd</code></a>: A minimal implementation of reverse mode AD in Python.</li>
<li><a href="https://github.com/breandan/picograd"><code>picograd</code></a>: Another minimal implementation of reverse mode AD in Python.</li>
</ul></li>
<li>Blog posts:
<ul>
<li><a href="https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation">Reverse-mode automatic differentiation: a tutorial</a>: This excellent post by Rufflewind has helped me a lot when implementing reverse mode in Rust.</li>
<li><a href="http://www.stochasticlifestyle.com/engineering-trade-offs-in-automatic-differentiation-from-tensorflow-and-pytorch-to-jax-and-julia/">Engineering Trade-Offs in Automatic Differentiation: from TensorFlow and PyTorch to Jax and Julia</a>: This great post covers the differences between some popular AD libraries.</li>
</ul></li>
</ul>
</div>
</div>
</div></div>
  </body>
</html>
