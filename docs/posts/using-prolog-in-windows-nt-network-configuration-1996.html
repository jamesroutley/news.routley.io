<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://web.archive.org/web/20030218034509/http://www.research.microsoft.com/research/dtg/davidhov/pap.htm">Original</a>
    <h1>Using Prolog in Windows NT Network Configuration (1996)</h1>
    
    <div id="readability-page-1" class="page">
<p><strong><b>David Hovel</b></strong>
</p><p>Microsoft Research</p><p><b>Abstract</b>
<em>
</em></p><p><em>Microsoft&#39;s Windows NT operating system uses an embedded Prolog 
interpreter to configure its local and wide-area network systems. 
 Interdependent software and hardware components are abstracted into 
a simplified object-oriented framework using declarative information 
provided by each component&#39;s installation script.   This information, 
along with the Prolog algorithm, is consulted into the embedded interpreter, 
which is then queried to construct the most usable configuration. 
 The algorithm which solves the plumbing problem is described, including 
its positive and negative constraints, Prolog database and efficiency 
considerations.  The results of the query, stored into NT&#39;s configuration 
database,  inform each component of its load order and binding targets. 
 A description of the<b>C++</b> wrapper class is given and portation 
considerations are discussed.  The <b>Small Prolog </b>interpreter 
is briefly described.<b>
</b></em><b>
</b></p>

<h2>1.1 Windows NT</h2>
Microsoft Windows NT is a completely new software architecture which 
corrects many of the limitations of past operating systems.  It is 
a fully 32-bit virtual memory operating system which supports multiprogramming 
and symmetric multiprocessing.  It has a built-in graphical subsystem 
which is compatible with Windows 3.1.
<p>Windows NT was built from the start as a highly extensible platform 
for both client and server networking.   Fully two years before its 
initial release, developers at Microsoft were developing NT on NT 
systems which supported multiple network cards and protocol stacks.
</p><h2>1.2 Problems in Network Configuration</h2>
Although many systems support networking, there is no standard approach 
or tool set.  Network configuration information on most systems is 
stored in a set text files with different syntaxes and relationships. 
  Many systems still require relinking or regeneration of operating 
system binaries in order to change the network software ensemble.
<p>Historically, networking systems have commonly suffered from three 
wide-spread problems.  First,  there was no system-pervasive configuration 
managementsoftware which could be used as a foundation.  In MS-DOS, 
for example, every installer was required to have its own parsers 
for CONFIG.SYS and AUTOEXEC.BAT.  This often meant that trivial formatting 
changes or unusual data could cause product installations to fail 
in catastrophic ways.  Even simple changes in the order of component 
installation could result in situations which the vendors software 
was not designed to handle.
</p><p>Second, there was no standard repository for network configuration 
information.  Even experienced systems administrators were often 
uncertain as to which text files were required by the network and 
which components utilized them.
</p><p>Third, the network components themselves were interconnected through 
proprietary software interfaces.   Hence, components built by separate 
vendors could not generally be connected or bound even if their roles 
in the network software ensemble were inherently compatible.
</p><h2>1.3 Configuring Networks on Windows NT</h2>

<h3>1.3.1 Network Enhancements in Windows NT</h3>
Many of the main stumbling blocks to intelligent network configuration 
systems in the past are absent in Windows NT, at least in principle:
<ul>
<li>NT mandates use of the Network Driver Interface Specification 
(NDIS), and the Transport Driver Interface (TDI) which together provide 
standardized network component behavior.
</li><li>Most drivers are reentrant.
</li><li>All configuration information is stored in a common configuration 
database with data types.
</li><li>All drivers are dynamically demand-loaded.
</li><li>All driver interconnections and configuration parameters 
are based upon explicit textual information in the configuration 
database.
</li><li>Driver load ordering and grouping is governed by explicit 
information in the configuration database.
</li><li>The NT operating system in its entirety is functioning 
during installation, configuration and networking initiation, as 
opposed to a reduced boot-time load system of limited capability.
</li></ul>
<p>By comparison with other networking platforms, NT presents a highly 
normalized and well-behaved interface centered around its configuration 
database called the Registry.  Given a correct Registry, the system 
runs correctly.
</p><h3>1.3.2 The Centralized Approach</h3>
In Windows NT, we decided that there could only be one central algorithm 
for network configuration.  This led to the formulation of a declarative 
approach, in which vendors had a rich set of declarative information 
which could be added to the configuration database by their products. 
 However, the final configuration was always generated and stored 
by the NT network configuration software.  
<p>In this architecture, the user would have the opportunity to rescind 
decisions made by the network configuration software, <b><i>but neither 
the user nor vendor software could coerce the system into invalid 
configurations</i></b>.
</p><h3>1.3.3 The Goals of Network Configuration</h3>
The overall goals of network configuration were:
<ul>
<li>Support a diverse and rapidly evolving ensemble of software 
and hardware components.
</li><li>Strive for a no-questions-asked network installation process.
</li><li>Offload configuration intelligence from individual components 
to the generalized configuration software.
</li></ul>
<p>To achieve a high degree of user acceptance, the planned implementation 
approach was all-encompassing.  In one pass, the network configuration 
software would be required to:
</p><ul>
<li>Detect a network card.
</li><li>Install all the necessary software components.
</li><li>Allow the user to install additional hardware and software 
components.
</li><li>Create all the network configuration information.
</li><li>Load and start the network.
</li><li>Use the new systems network capabilities to allow the 
user to join an NT security domain.
</li></ul>
<p>Equally importantly, the system was supposed to do as little interaction 
with the user as possible.  To the best of my knowledge, no previous 
networking system has ever been installed in this fashion before.
</p>
<h2>2.1 The Network Lattice</h2>
An ensemble of active networking software components in a computer 
is best understood as a lattice.  The vertices or nodes of the lattice 
are the components themselves; the edges or arcs are dataflow paths 
between the components.  The arcs are considered to be directed from 
the service requester to the service provider.  In a well-behaved 
system, there are no dataflow cycles, and all communications between 
two components is considered to travel along the same edge or arc. 
 Similarly, if component <b><i>A</i></b> is connected to <b><i>B 
</i></b>and <b><i>B </i></b>is connected to <b><i>C</i></b>, any 
communications between <b><i>A </i></b>and <b><i>C </i></b>is considered 
to flow through <b><i>B</i></b>.
<p><img src="https://web.archive.org/web/20030218034509im_/http://www.research.microsoft.com/research/dtg/davidhov/figure1.gif"/>
</p><p><b>Figure 1: An Example Network Lattice</b>
</p><p>The lattice is considered to be oriented from the user downwards; 
the uppermost nodes are the originators of network traffic and the 
lowest nodes are those connecting directly to the hardware.
</p><h2>2.2 Plumbing and the NT Namespace</h2>
Setting up this lattice is often referred to as <i>plumbing</i>. 
 The basic result of a plumbing algorithm is a set of ordered pairs 
of component tokens; each such pair indicates the existence of an 
arc from the first component to the second.  Data flow along this 
arc is considered to be bi-directional.
<p>In <b>Windows NT</b>, as in the members of the <b>Unixi  </b>family, 
the concept of a <b><i>file </i></b>has been extended to include 
any data source or sink.  As in <b>Unix</b>, NT maintains names for 
all such files in a global namespace organized as a tree, and they 
are accessed using the system openfunction in the same manner as 
disk files.
</p><p>Therefore, each ordered pair previously mentioned is really a 
triple: the final element is the name of the file or port to be created 
and opened.  This triple constitutes an instruction to the higher 
component to open a connection to the lower component using the given 
name, as well as an instruction to the lower component to provide 
an access port of the name required.
</p><h2>2.3 Load Ordering and Grouping</h2>
The NT Registry also contains information about load ordering and 
grouping of components; this allows diverse and unrelated elements 
of the system to initiate and stabilize their operations in the correct 
sequence.
<p>The solution to the plumbing problem is used to determine the 
loading sequence of the network modules.  If component <b><i>A</i></b> 
must open a file or port created by component <b><i>B</i></b>, then 
<b><i>B </i></b>must complete its loading and initialization operations 
before <b><i>A </i></b>is loaded.
</p><h2>2.4 Decorating the Paths Through the Lattice</h2>
From the point of view of a system component, the results of a lattice 
construction algorithm is a set of device names and relationships 
for each component.   The constructed lattice can be viewed as having 
been labeled or <b><i>decorated</i></b> with generated names which 
enable the necessary dataflow paths.  
<p>In this context, a <b><i>path </i></b>is defined as a complete 
routing from an initiating component downward through the lattice 
to a network adapter card or other end-point.  Product loading requirements 
and ordering are determined by the topological relationships inherent 
in the complete set of all constructed paths.
</p><h2>2.5 Object-Oriented Configuration Design</h2>
NT was intended from the outset to be a scaleable architecture.  
Older PC-based networking systems were predicated on simplistic assumptions 
about the number of network cards or protocol stacks which any one 
machine might employ.  Such restrictions were not viable for NT.
<p>In systems employing several protocol stacks, network cards and 
serial ports, components of a similar type are treated virtually 
identically.  While the exact details of their addressing might vary, 
their participation in the network lattice is determined solely by 
the component type.
</p><p>Elements of object-oriented design were adopted to exploit this 
type-versus-instance analogy.   In this scheme, there is a global 
space of named <b><i>interface classes</i></b>.  A <b><i>class </i></b>may 
be <b><i>basic</i></b>(that is, have no parent class), or it 
may inherit from one or more parent classes.    A component <b><i>type 
</i></b>is defined by the class names describing its upper and lower 
boundaries.  In addition, a class may be marked as a <b><i>logical 
end-point</i></b>, which means it acts as a terminal point for interconnections 
in the lattice.  A network adapter card is always considered a logical 
end-point.
</p><p>Instances of classes can be <b><i>bound</i></b> to one another 
in the sense that an interconnection can legitimately be made between 
them.  There is a close analogy between this approach and class compatibility 
in common object-oriented programming languages.  For example, if 
two classes <b><i>aClass</i></b> and <b><i>bClass</i></b> are declared 
in Prolog as <b><i>bindable(aClass,bClass)</i></b>, then instances 
of <b><i>aClass</i></b> can be bound to instances of <b><i>bClass, 
</i></b>but not the reverse.  In addition, instances of their subclasses 
can also be bound together, but not instances of their superclasses. 
 In the case of multiple inheritance, instances of such classes inherit 
the bindablity of every superclass.
</p><h2>2.6 Object Model</h2>
At a deeper level, the object-oriented class descriptions do not 
describe networking components themselves; instead, they describe 
the interfaces they offer to other components.
<p>In the configuration model, each network component is abstracted 
as a black box with an upper and a lower boundary or interface.  
Most types of objects have the same class interface at both boundaries. 
 However, there are occasions on which it is necessary to consider 
the upper and lower layers of an object as having distinct properties.
</p><p><img src="https://web.archive.org/web/20030218034509im_/http://www.research.microsoft.com/research/dtg/davidhov/figure2.gif"/>
</p><p><b>Figure 2: Basic Component Object Model</b>
</p><p>The definition of a network component <b><i>type</i></b>, then, 
requires the declaration of the interface classes to which its upper 
and lower layers belong.  It is important to remember that these 
semantic or behavioral interface classes are defined on top of the 
NDIS and TDI syntactic or general interface standards.
</p><h2>2.7 Overview of the Algorithm</h2>
The lattice plumbing algorithm must first determine all possible 
hierarchical relationships between pairs of components.  Then it 
has to eliminate those pairs which do not eventually connect to a 
network adapter card or other end-point.  To accomplish this, the 
algorithm has to be given the following information.
<ul>
<li>The set of all interface class declarations.
</li><li>The set of all component type declarations.
</li><li>The set of all components which are actively present.
</li><li>Rules governing interface binding.
</li><li>Rules governing symbolic device name construction.
</li></ul>
<p>Given these rules, all dataflow paths can be determined, and the 
lattice can be constructed and decorated.
</p>
To solve the lattice construction problem, I decided to use a public 
domain Prolog interpreter called <b>Small Prolog</b> <b>(SProlog)</b>. 
 This section attempts to recapitulate my decision-making process.
<h2>3.1 Viewing the Problem as Declarative</h2>
Under the assumption that there needed to be a central lattice generation 
algorithm, the problem could be viewed as declarative.  In such an 
approach, each individual component is responsible for declaring 
the classes, types and products it adds to the ensemble.  During 
network configuration, the Prolog interpreter is given these declarations 
in the form of base clauses.  Base clauses are clauses with no unbound 
variables or functors; clauses of this kind are referred to as <i>facts</i>i
n this document.  The interpreter is then asked to produce a correctly 
plumbed or connected lattice.
<h2>3.2 Experience with Small Prolog</h2>
Before joining Microsoft I was involved in a project to build intelligent 
applications for the legal profession.  The primary prototype for 
this project was developed in the <b>Think C</b> object-oriented 
graphical applications framework on the <b>Macintosh</b>; at its 
core was a ported version of <b>SProlog.  </b>Running <b>SProlog 
</b>in such an environment gave clear experiential evidence of its 
stability and behavior.
<p>Another issue clearly in its favor is that the interpreteruses 
a simplified syntax similar to that of <b>LISP</b>; this format made 
<b>SProlog</b> clauses very easy to generate and process using recursive 
descent.
</p><h2>3.3 Prototyping</h2>
A primary advantage to using Prolog was that a console or character-mode 
version of the interpreter could immediately be used to experiment 
with lattice generation algorithms.  Tests could start using simple, 
hand-written clauses and work outward, validating concepts and justifying 
assumptions.
<p>During the course of the project there were several occasions 
when the Prolog algorithm had to be enhanced.  On each of these occasions, 
changes were developed and tested in console mode; when completed, 
the network configuration dynamic-link library was simply relinked 
with an updated Prolog text program.  This ability to perform continual 
prototyping within a stable application was greatly beneficial.
</p><h2>3.4 Search Space Management</h2>
The design for solving the bindings problem was strongly influenced 
by previous experience with Prolog.  It seemed to decompose readily 
into a series of backtrack operations across a bounded search space. 
 Solving such a problem in a procedural language like <b>C++ </b>seemed 
unnatural, since it would require numerous new classes and functions 
for database management, backtracking and unification.
<h2>3.5 Introduction to SProlog</h2>

<h3>3.5.1 Origin</h3>
The Small Prolog interpreter was written by Henri de Feraudy and 
placed into the public domain.  It is written in standard (K&amp;R) 
<b>C </b>and was ported to several platforms by M. de Feraudy during 
development.
<h3>3.5.2 Syntax</h3>
<b>SProlog </b>uses a simplified LISP-like syntax for efficiency 
reasons.  For example, here is the standard <b><i>member/2 </i></b>predicate:
<blockquote><b>/* membership in a list */</b></blockquote>
<h3>3.5.3 Advantages</h3>

<h4>3.5.3.1 Size and Portability</h4>
<b>SProlog </b>is very small and quite portable. Virtually all machine-specific 
coding was isolated to a single source module, and makefilesfor several 
compilers and platforms were included with the source.  
<p>Since M. de Feraudy had already considered some of the issues 
involved in embedding the interpreter, the outer query loop was structured 
so that it could be readily replaced.
</p><h4>3.5.3.2 Memory Usage  </h4>
In <b>SProlog, </b>all memory allocation is performed in one module. 
 The various different dynamic areas (heap, stack, trail, etc.) are 
given <b><i>zones </i></b>in which to grow; the size, behavior and 
placement of these zones are controlled through a single, platform-specific 
source module. Memory within each zone has to be contiguous.  This 
simplistic approach prevents backtracking from entailing extensive 
run-time heap manipulation.
<h4>3.5.3.3 List and String Handling</h4>
The lattice generation algorithm was necessarily going to require 
the maintenance of many lists and would perform extensive string 
manipulation to generate the final Registry results.  The flexibility 
of Prologs built-in list handling simplified lattice path management. 
  <b>SProlog </b>also has a useful set of string manipulation primitives, 
to which were added several built-in predicates to facilitate case 
shifting and string parsing.
<h3>3.5.4 Limitations</h3>
The version of <b>SProlog</b> which was used does not support tail 
recursion elimination or garbage collection.
<p>The absence of garbage collection was not a primary concern since 
the lattice generation algorithm ran only once during network reconfiguration. 
 Being a virtual memory operating system, NT had no problems supporting 
the full contingent of memory required for the worst-case scenarios. 
 Similarly, the absence of tail recursion elimination, while a minor 
performance consideration, did not affect run-time memory use or 
performance significantly.
</p>
<h2>4.1 Background</h2>
<h3>4.1.1 The Configuration Registry</h3>
The NT Configuration Registry is a hierarchical database similar 
to a directory tree.  In the Registry, each <b><i>key</i></b> or 
named location can contain <b><i>values</i></b> or deeper <b><i>keys</i></b>. 
  Each <b><i>value </i></b>entry has a name, a data type and a data 
block.  Most Registry information is either character strings or 
integers.  All persistent configuration information is recorded in 
the Configuration Registry.
<h3>4.1.2 Network Configuration Information</h3>
Information related to the network configuration is stored entirely 
in the configuration Registry.  This information can be divided into 
two broad categories:
<ul>
<li>device-specific information; that is, information which 
is particular to the driver or software component in question;
</li><li>declarative information used to support network lattice 
construction.
</li></ul>
<p>The latter type of information governs the behavior of the lattice 
construction algorithm.  As will be explained later, much of it is 
converted to <b>SProlog </b>declarative <i>facts</i> or base clauses.
</p><h3>4.1.3 Steps in the Installation Process</h3>
The large-scale operations performed by the network installation 
software are:
<ol>
<li>Detect or choose a network card and run its installation script.
</li><li>Run the installation scripts for the default software components
</li><li>Allow the user to pick additional products to install (scripts to run)
</li><li>Gather the network-related Registry information
and convert it to SProlog format.
</li><li>Run the binding algorithm to generate a correct lattice.
</li><li>Convert the query results to Registry format.
</li><li>Update the Registry to reflect the new lattice.
</li><li>Allow the user to rescind any bindings which are inappropriate or unnecessary.
</li><li>Perform a topological sort based upon the revised (active) lattice
and update the Registry with the load order information.
</li><li>Start the network by loading the network redirector.
</li></ol>
<p>The steps 4, 5 and 6 above are those which involve the embedded 
Prolog engine and its interfaces.  Given a correct lattice and software 
loading order, the last step suffices to cause the entire network 
ensemble to be loaded and initiated correctly.
</p><h2>4.2 Basic Algorithm</h2>
The fundamental Prolog algorithm is straightforward.  First, the 
lattice construction program is consulted.   Then the Registrys network 
configuration information is converted into a textual block of Prolog 
facts and consulted.
<p>The algorithm then backtracks across every possible pair of device 
interfaces and determines if they are bindable.  Those which succeed 
are asserted as facts into the interpreters database.   The discovered 
set of possible bindings is then examined, and any bindings which 
violate constraints are retracted.   (See the appendix <i><em>Basic 
Binding Backtrack Algorithm</em></i>for more information.)
</p><p>Finally, the set is converted into usable binding information; 
that is, the actual device names to be used in the NT namespace are 
constructed and topological information about the exact path through 
the network lattice is generated.<i>
</i></p><p><i>(Note: The full details of the generation of binding names is 
beyond the scope of this document.)</i>
</p><h2>4.3 Constraints</h2>
There are several ways in which the construction of the lattice can 
be constrained.
<ul>
<li>Any potential path in the lattice which does not reach 
a network adapter card or a logical end-point is discarded as moot.
</li><li>Bindings can be declared as <b><i>exclusive, </i></b>or 
restricted to a single instance.  This can be applied to either the 
source or sink end of a binding or both.
</li><li>If multiple conflicting binding rules apply, a simple 
priority scheme is used to resolve contention.
</li><li>Another more general negative binding constraint can be 
specified that prevents any two device classes from appearing anywhere 
along a binding path in the lattice, regardless of the degree of 
separation.
</li></ul>
<p>Binding information which is found to violate a constraint or 
which loses a contention resolution arbitration is retracted.
</p><h2>4.4 Binding Names and Paths</h2>
Once a correct lattice is generated, a corresponding set of device 
or file names is generated.  These names are based upon strings declared 
in the component configuration information.
<p>Along with these names, the exact path of each binding down through 
the network lattice is preserved in a list of component tokens stored 
with each individual binding fact.  This information is used by the 
calling program to perform a topological sort as part of the process 
of generating the correct network component loading sequence.
</p><h2>4.5 Converted Fact Predicates</h2>
This section documents the Prolog predicates into which the information 
in the Configuration Registry is converted.   All of these predicates 
are base clauses, since no uninstantiated variables are allowed into 
or generated by the Registry conversion process.
<h3>4.5.1 devClass/3</h3>
<strong>devClass(className,parentClassName,logicalEndPoint).</strong>
<p>This fact declares that a class exists, and declares its parent 
class or uses the token <b><i>basic </i></b>to indicate that it has 
no parent.  A final token of <b><i>yes </i></b>or <b><i>no </i></b>indicates 
whether the class is a logical end-point or terminus for the binding 
search.  Multiple <b><i>devClass </i></b>facts are used to indicate 
multiple inheritance..
</p><h3>4.5.2 devType/4</h3>
<strong>devType(productName,productGenericType,upperClass,lowerClass).</strong>
<p>This fact declares that a product type exists, but may not necessarily 
be present or active.  Each boundary (upper and lower) of the product 
can be declared to be of a different class.  The Registry fact conversion 
software defaults both boundaries to be the same if only one is specified.
</p><h3>4.5.3 present/4</h3>
<strong>present(productId,productName,&#34;objectName&#34;,&#34;Registry Key Name&#34;).</strong>
<p>This fact declares that an instance of a product type exists and 
tells where it is located in the Registry.
</p><h3>4.5.4 bindable/5</h3>
<strong>bindable(fromClass,toClass,exclusive,exclusive,bindValue).</strong>
<p>This fact declares that instances of <b><i>fromClass</i></b> can 
bind to instances of <b><i>toClass</i></b>.  The Boolean <b><i>exclusive</i></b> 
tokens are used to indicate whether the upper or lower layer can 
only be bound multiply or only once.
</p><p>The <b><i>bindValue</i></b> token is a number from 0 to 100.  
Multiple applicable binding rules are resolved as follows.  The rule 
with the highest binding value is used in preference to all others. 
 Then, the rule closest to the binder&#39;s true class is used in preference 
to rules based on parent classes.  Finally, multiple specific rules 
are order-dependent; the first found is the one used.
</p><h3>4.5.5 devBind/5</h3>
<strong>devBind(productName,objectName,getsBindings,appearsInBindings, namingMethod).</strong>
<p>This fact is used to control the generation of names in the NT 
namespace.  The arguments indicate the following:<b>
</b></p><p><b>objectName: </b>This is a string value used as the basis for names 
generated for this product (contrasted to the tokenized name used 
inside the interpreter).<b>
</b></p><p><b>getsBindings: </b>This Boolean value determines whether or not 
a product&#39;s Registry area is actually updated with binding information.<b>
</b></p><p><b>appearsInBindings</b>: This Boolean value determines whether or 
not a product&#39;s name is inserted into the generated name.  Some layers 
of a protocol ensemble can be &#34;invisible&#34;.<b>
</b></p><p><b>namingMethod</b>:  The NT driver architecture allows drivers to 
create containers (or directories) in the NT name space; if a driver 
supports this, backslashes are used to separate product level names; 
otherwise, they are simply concatenated using underscores to create 
unique names.
</p><h3>4.5.6 block/2</h3>
<strong>block(fromClass,toClass).</strong>
<p>This fact indicates a constraint which prevents any path from 
being created which connects, however distantly, an instance of <b><i>fromClass 
</i></b>to an instance of <b><i>toClass</i></b>.  Normal rules of 
inheritance apply.  Note that this is an ordered pair and therefore 
would not in and of itself prevent a binding in the opposite direction.
</p><h2>4.6 Using the Facts: A Simple Binding Example</h2>
The following figure represents two components, one called  <b><i>redir</i></b> 
and the other called <b><i>proto1</i></b>.  They are defined by their 
<b><i>devType </i></b>facts (shown) and their <b><i>present </i></b>facts 
(not shown).
<p><img src="https://web.archive.org/web/20030218034509im_/http://www.research.microsoft.com/research/dtg/davidhov/figure3.gif"/>
</p><p><b>Figure 3: Binding Two Components</b>
</p><p>The arc connecting <b><i>redir </i></b>to <b><i>proto1 </i></b>would 
be instantiated by the binding algorithm because backtracking across 
all possible component pairs would present the list <b>[redir proto1]</b>, 
and backtracking across all <b><i>bindable</i></b> facts would yield 
the rule which directly permitted binding between the lower interface 
of <b><i>redir </i></b>and the upper interface of <b><i>proto1</i></b>.
</p><p>The search for applicable <b><i>bindable </i></b>facts also entails 
searching the set of classes since interface classes inherit bindability 
from their parents.
<pl></pl></p><h2>4.7 Gathering and Converting the Facts</h2>
The configuration information for each networking product is stored 
under two distinct keys in the Registry.
<ul>
<li>A software or hardware product registration key containing
 permanent configuration information, and
</li><li>A service registration key containing 
generated configuration information used during system boot.
</li></ul>
<p>The conversion software enumerates the software and hardware products 
stored under the product registration keys.   Components which are 
part of the network ensemble are identified by a subkey named <b><i>NetRules</i></b><b>.
  </b>A typical set of entries under a <b><i>NetRules </i></b>key 
is:
</p><pre><blockquote>type = srv lmNetService lanmanServer
class = &#34;lanmanServer lmNetService&#34;
use = service yes yes
bindform = &#34;LanmanServer&#34; yes yes container
</blockquote></pre>
<p>The generated <b>SProlog </b>facts from these values are:
</p><pre><blockquote>(devType srv service lmNetService lanmanServer)
(devBind srv &#34;LanmanServer&#34; yes yes container)
(devClass lanmanServer lmNetService no)
(present srv srv &#34;LanmanServer&#34;
      &#34;Machine\SOFTWARE\Microsoft\LanmanServer&#34;)
</blockquote></pre>
<p>The <b><i>NetRules </i></b>values are thus converted into <b>SProlog 
</b>facts.  This conversion is performed in <b>C++</b>, and the tokens 
are coerced into valid Prolog tokens.  The declarations are then 
reorganized for the convenience of the Prolog algorithm.  (A complete 
listing of the facts for a standard machine is given in the appendix 
<i><em>Sample Fact Set</em></i>.)
</p><p>It is important to note that the space of declarative facts is 
global.  It is the responsibility of each vendor to guarantee the 
uniqueness of tokens used in the facts.  In addition, each component 
can, if desired, add any number of uninspected Prolog predicates 
to extend the fact set.
</p><h2>4.8 Consultation and Querying</h2>
After the Registry information is converted to <b>SProlog</b> form, 
the memory areas for the interpreter are allocated and it is initialized. 
 The textual Prolog algorithm is extracted from the executable file 
and consulted.  Finally, the block of strings of converted Registry 
facts is consulted.
<p>When <b>SProlog</b> has all the necessary clauses in its database, 
a single predicate <b><i>makebindstrings/1</i></b> is queried. This 
predicate uses failure-driven loops to backtrack across every ordered 
pair of installed components to find all possible component bindings.
</p><p>As each pair is retrieved, the classes to which the lower layer 
of the first object and the upper layer of the second belong are 
backtracked over in an attempt to discover a direct or inherited 
<b><i>bindable</i></b> rule.
</p><p>After that, the query <b><i>bindstring/6</i></b> is issued by 
the calling program once for each product in the ensemble of network 
components.  This predicate is defined as:
</p><pre>    bindstring(Owner,Interface,ObjectName,AtomList,
                    BindString,ExportString).</pre>
<p>This query may result in zero or more replies, all of which are 
stored into the output query result string.  The <b><i>Owner </i></b>variable 
is the token name of the device instance.   The <b><i>AtomList </i></b>variable 
is bound to a list of tokens representing the complete path of the 
binding down to the hardware adapter or logical end-point. This information 
is used by the outer-level <b>C++</b> code to perform a topological 
sort to derive the loading sequence.  The other arguments are bound 
to strings which are used to update the Registry.
</p><h2>4.9 Handling Identical Instances</h2>
There are many configurations where several devices are present with 
exactly the same declaration, differing only in the specific instance 
name.  The most obvious case of this in Windows NT is the<b><i>Remote 
Access Services</i></b>, which can support hundreds of serial interface 
connections. Since the lattice generation algorithm will always generate 
the same results for these identical instances, backtracking is used 
to create sets of such indistinguishable objects.  When found, the 
actual instances are hidden (by retraction and storage into ancillary 
clauses) and replaced by one pseudo-instance for each set.
<p>When the binding discovery and constraint satisfaction phases 
are complete, the results involving the pseudo-instances are used 
as templates to generate the actual results for all the identical 
instances.  All information pertaining to the pseudo-instances is 
then discarded.
</p><p>In spite of the additional complexity, this approach yields a 
significant performance improvement for the overall algorithm.  Instead 
of being <b><i>O(n**2)</i></b> in the <i>number</i> of 
components, the algorithm becomes <b><i>O(n**2)</i></b> 
in the number of distinct <i>types</i> of components.   The final 
additional phase of generating information from the templates is 
linear in the number of actual instances.
</p><h2>4.10 Constraints</h2>
After all the potentially allowable bindings are discovered, the 
constraints must be considered. The first of these is the <b><i>exclusivity 
</i></b>constraint.  This is a point-to-point constraint which disallows 
more than one binding between certain interfaces.  Although there 
is a simple contention resolution scheme (a number from 0 to 100), 
it is rarely used since it does not allow the user to override it.
<p>The other significant constraint is represented by the <b><i>block 
</i></b>clause, which disallows instances of two classes or their 
subclasses from occurring anywhere along a binding path, regardless 
of separation.  This is quite a flexible and powerful rule, but causes 
a significant efficiency problem, since each element in a dataflow 
path must be checked against every other subsequent element in the 
path.
</p><h2>4.11 Generating the Results</h2>
After all the constrained bindings are retracted, the information 
is prepared for use by the calling  program.  This involves two basic 
steps.
<ul>
<li>Creation of valid NT namespace names for binding control.
</li><li>Construction of lists of tokens representing the path each binding will
 follow to its logical end-point or adapter card.
</li></ul>
The namespace names are used by the calling program to update 
the Registry.  Here is an example which uses the Microsoft NETBEUI 
protocol component <b><i>Nbf</i></b> and the file server component 
<b><i>LanmanServer</i></b> in an ensemble with three network cards, 
two Etherlink IIs and an IBM Token Ring card.
<pre>KEY = Services\LanmanServer\Linkage
    Bind   = &#34;\Device\Nbf_ElnkII1&#34;
             &#34;\Device\Nbf_ElnkII2&#34;
             &#34;\Device\Nbf_IbmTok1&#34;
    Export = &#34;\Device\LanmanServer\Nbf_ElnkII1&#34;
             &#34;\Device\LanmanServer\Nbf_ElnkII2&#34;
             &#34;\Device\LanmanServer\Nbf_IbmTok1&#34;
    Route  = &#34;Nbf ElnkIISys ElnkII1&#34;
             &#34;Nbf ElnkIISys ElnkII2&#34;
             &#34;Nbf IbmtokSys IbmTok1&#34;
KEY = Services\Nbf\Linkage
    Bind   = &#34;\Device\ElnkII1&#34;
             &#34;\Device\ElnkII2&#34;
             &#34;\Device\IbmTok1&#34;
    Export = &#34;\Device\Nbf_ElnkII1&#34;
             &#34;\Device\Nbf_ElnkII2&#34;
             &#34;\Device\Nbf_IbmTok1&#34;
    Route  = &#34;ElnkIISys ElnkII1&#34;
             &#34;ElnkIISys ElnkII2&#34;
             &#34;IbmtokSys IbmTok1&#34;
</pre>
<p>The <b><i>Bind </i></b>subkey contains an array of names to which 
the network component services are to connect;  the <b><i>Export 
</i></b>subkey contains names which the services are to create as 
access points for higher level software. 
</p><p>The <b><i>Route</i></b> information enumerates the component tokens 
which constitute the exact path through the network lattice.  These 
lists are used by the calling program to topologically sort the network 
objects to determine correct load ordering.
</p><h2>4.12 User Review</h2>
Once the lattice generation algorithm has been run, the Registry 
is updated accordingly.  At this point, the user has the option of 
calling up a dialog and reviewing all the generated binding information. 
 The Registry is updated again afterwards if the user has rescinded 
or reordered any bindings.  The load order is also checked again, 
since the user may have rescinded all the bindings to a particular 
component and hence rendered it unnecessary.
<pl><h2>4.13 Additional Issues</h2>

<h3>4.13.1 Non-Determinism</h3>
Although the fundamental algorithm was non-deterministic in the Prolog 
sense, care had to be taken that subordinate backtracking clauses 
did not unexpectedly yield multiple solutions.  This issue demanded 
a testing discipline in which all new clauses were unit-tested for 
proper behavior using full-blown configuration scenarios.
<h3>4.13.2 Backtrack Ordering</h3>
When the sub-clauses in a clause must backtrack across several different 
segments of the database, ordering them properly can result in significant 
overall performance improvement.  The operations should typically 
be ordered according to likelihood or frequency of success, from 
least to most.


<h2>5.1 The Network Configuration Executable</h2>
The actual network configuration program is a Win32 dynamic-link 
library called <b>NCPA.CPL</b>. The extension <b><i>CPL </i></b>indicates 
that it is a Windows NT Control Panel extension (or <b><i>applet</i></b>). 
 It is represented in the Control Panels main window by an icon representing 
a netcard cable.
<p>The source code for the <b>NCPA</b> is written in <b>C++</b>. 
 The <b>SProlog</b> interpreter is written in standard <b>C</b> and 
is encapsulated in a <b>C++</b> class called <b>SPROLOG</b>.
</p><p>This executable file controls the invocation of the Windows NT 
SETUP utility, which interprets and executes installation and configuration 
scripts provided by Microsoft and other vendors.
</p><p><img src="https://web.archive.org/web/20030218034509im_/http://www.research.microsoft.com/research/dtg/davidhov/figure4.gif"/>
</p><p><b>Figure 4: Components of Network Configuration</b>
</p><p>In the preceding figure, the block labeled <b>SPROLOG</b> represents 
the Small Prolog interpreter residing within its C++ class 
(described later). 
</p><h2>5.2 Portation</h2>
<h3>5.2.1 Memory Allocation </h3>
Due to the support for virtual memory in the Win32 API, the simplistic 
approach taken toward memory allocation in <b>SProlog</b> actually 
suited the Windows NT environment well.  In the NT version of the 
memory allocation module, the initialization routine creates a temporary 
virtual 16MB region.  This region is then divided into smaller 2MB 
<b><i>zones</i></b> to support SPrologs heap, trail, stack and so 
on.  However, no actual memory is allocated or committed into the 
region.   Instead, each new memory allocation request probes the 
desired zone to see if memory is available at the next logical location. 
 This probe operation consists of attempting to store a word, and 
it is enclosed in a Win32 exception handling block.  If memory is 
not present at the probed location, an access violation exception 
occurs.  The handler for this exception then attempts to commit memory 
into the zone, and the probe is reattempted.  This method dedicates 
a very small amount of memory to the interpreter, and the use of 
exception handling requires very little checking during allocation. 

<h3>5.2.2 STDIO and Friends</h3>
Since normal Windows DLLs have no standard I/O streams (e.g., <b><i>stdout</i></b>,
 <b><i>stdin</i></b>), it was necessary to segregate all use of the 
C run-time librarys <b><i>stdio</i></b> functions into a single module. 
 Different versions of this <b><i>stdio </i></b>aliasing module were 
written for different environments.
<h3>5.2.3 Query and Consulting</h3>
Both consulting and querying were extended to operate within string 
buffers instead of using standard file handles.  The DLL-based version 
of the <b><i>stdio</i></b> aliasing module stores query results into 
a buffer donated to the interpreter by the calling program.  If this 
string is exhausted by the query, an error is returned.  The complete 
results of non-deterministic queries are concatenated into this buffer.
<h2>5.3 Tools and Techniques</h2>

<h3>5.3.1 The Console Application</h3>
The <b>SProlog</b> source code is also compiled into a standard TTY-style 
console application.  This is the main environment for testing changes 
to the lattice generation algorithm.
<h3>5.3.2 The Windows Test Application</h3>
Using a separate <i>makefile</i>, the entire <b>C++</b> code ensemble 
can be linked into a simple Windows application.  The menu bar of 
this test application presents an interface to the large-scale actions 
of the code base, such as converting the network-related Registry 
entries to <b>SProlog</b> format.  This environment is used for unit-testing 
the macroscopic functions of the code set.
<h3>5.3.3 Use of Resource Fork</h3>
Since the lattice generation algorithm is contained in a standard 
text file, releasing it in this form would have rendered it susceptible 
to accidental modification, deletion or path location problems.  
Since it should ideally be bound directly into the DLL, the Windows 
NT SDK Resource Compiler was used to add the Prolog text file as 
a UNICODE text resource.  At run-time, the <b>C++ </b>code loads 
this resource, converts it from the UNICODE character set back to 
ANSI and passes it to interpreter.
<h2>5.4 The C++ WrapperClass</h2>
All run-time interface to the SProlog interpreter is through an encapsulating 
<b>C++ </b>class called <b>SPROLOG</b>.  The constructor of this 
class initializes interpreter memory regions and prepares for file 
handling.   The destructor releases all memory and file resources 
back to the system.
<p><img src="https://web.archive.org/web/20030218034509im_/http://www.research.microsoft.com/research/dtg/davidhov/figure5.gif"/>
</p><p><b>Figure 5: Small Prolog C++ Wrapper Class</b>
</p><p>In addition to member functions for querying or consulting text 
files, the <b>SPROLOG</b> class provides similar functions for accessing 
string buffers.
</p><p>All queries are nested within an exception handler which catches 
such errors as
</p><ul>
<li>memory access violations
</li><li>attempts to write to standard streams
</li><li>memory allocation failure
</li><li>internal errors in interpreter processing.
</li></ul>
<p>With the exception handler, the <b>SPROLOG</b> class is able to 
intercept any form of aberrant behavior on the part of the interpreter 
except serious corruption of the machine stack.
</p><h2>5.5 New Built-In Predicates</h2>

<h3>5.5.1 Debugging Predicates</h3>
A set of debugging predicates were created to match the standard 
Prolog <b><i>write</i></b> predicates; their output is directed 
to the Windows API <b><i>OutputDebugString()</i></b>.  This provided 
the ability to monitor the behavior of the lattice generation algorithm 
at any level of detail desired while preserving the results on disk 
via the system debugger.
<h3>5.5.2 Registry Querying</h3>
A complete set of predicates was added to query the NT Configuration 
Registry.
<h3>5.5.3 The fault/0 Predicate</h3>
To test the robustness of exception handling, a predicate called 
<b><i>fault/</i></b><b>0 </b>was written which generated a protection 
violation by dereferencing the address 0xFFFFFFFF.

<h2>6.1 User and Press Evaluation</h2>
The overall results of using a Prolog interpreter to solve the network 
configuration problem have been very positive.  Of the network server 
platforms available on the market, the Windows NT Advanced Server 
is consistently judged to be the simplest and most reliable to install 
and re-configure.
<h2>6.2 Software Development Considerations</h2>
The configuration system has shown itself to be very extensible, 
and the primary Prolog algorithm has needed no almost no changes 
in the past year.   Much of this stability is due to the ease with 
which new changes can be tested using the console version of the 
interpreter.
<p>The centralized configuration approach has resulted in very short 
lead-times for the development of new component installers.  The 
installation script for a new network product can typically be written 
in a matter of minutes, and many scripts are minor variations on 
existing scripts of similar component classes.
</p><h2>6.3 Future Considerations</h2>
Using the proper tool is important in any development effort, and 
Prolog is clearly a superior tool for rule-based construction algorithms. 
 Several Prolog vendors have recently begun to take seriously the 
issue of truly embeddable Prolog engines.  Space does not permit 
a full exposition of the issues involved, but experience has shown 
the viability of encapsulating a Prolog interpreter into a Windows 
dynamic-link library.&gt;
<h2>Bibliography</h2>
<p>de Feraudy, Henri.  <i>Small Prolog, C User&#39;s Group diskette 
# 297</i>.  The C Users&#39; Group, P.O. Box 97, McPherson, KS  67460. 
  This is the public domain version of the Small Prolog interpreter, 
including complete source, documentation and examples.
</p><p>Microsoft Corporation.  <i>Windows NT Resource Guide, Volume 1</i>. 
Redmond, Washington: Microsoft Press, 1993.   This volume of the 
three volume set describes the Windows NT network architecture, documents 
all Configuration Registry entries and describes the functions of 
the SETUP program in detail.
</p><p>Microsoft Corporation.  <i>Win32 Programmer&#39;s Reference, Volume 
2</i>. Redmond, Washington: Microsoft Press, 1993.  This volume describes 
Win32 structured exception handling.  Other volumes in the series 
describe the architecture of Win32 Dynamic Link Libraries and all 
other areas of the Win32 programming standard.
</p><p>Clocksin, W.F. and Mellish, C.S. <i>Programming in Prolog.</i> 
New York: Springer-Verlag, 1981.  This is the standard reference 
for the Prolog programming language.
</p><p>Stroustrop, B. <i>The C++ Programming Language</i> 2nd ed. New 
York: Addison-Wesley, 1994.  This is the standard reference for the 
C++ programming language.
</p><h2>Appendix A. Basic Binding Backtrack Algorithm</h2>
<pre><blockquote>/*  Return a list of ordered pairs of bindable components  */
( (getbindings List)
  (findall L (bindpair X Y L) List))
/*  Succeed once for each bindable pair: lower -&gt; upper  */
( (bindpair Dev1 Dev2 (Dev1 Dev2 Excl1 Excl2 Value))
  (ifpresent lower Dev1 Type1 _ _)
  (ifpresent upper Dev2 Type2 _ _)
  (not (eq Dev1 Dev2))
  (canbind Type1 Type2 Excl1 Excl2 Value))
<p>
/*  Succeed if a common &#34;bindable&#34; rule is inherited by the
	lower layer of X and the upper layer of Y.  */
( (canbind X Y Xexcl Yexcl Value)
  (iflower X Lower)
  (ifupper Y Upper)
  (bindable Blower Bupper Xexcl Yexcl Value)
  (devDerived Lower Blower)
  (devDerived Upper Bupper))
</p><p>
// Determine if a device class is a sub-class of another 
//  (devDerived SubClass BaseClass)
( (devDerived X basic)
  (cut))
( (devDerived X X)
  (cut))
( (devDerived X Y)
  (devClass X Y _)
  (cut))
( (devDerived X Y)
  (devClass X Z _)
  (devDerived Z Y))

//  ifupper/2: return the class of a device&#39;s upper interface
//  (ifupper Devname Classname)
( (ifupper Ifname Ifclass)
  (devType Ifname _ Ifclass _))

//  iflower/2: return the class of a device&#39;s lower interface
//  (iflower Devname Classname)
( (iflower Ifname Ifclass)
  (devType Ifname Usage _ Ifclass) 
// Adapters cannot connect to anything
(not (eq Usage adapter)))

//  ifpresent/5: validate the presence of an interface.
//  devTypes have upper and lower interface; devIfs only
//  have an upper interface.
//  (ifpresent Layer Device Type Owner Objectname)
( (ifpresent _ Dev Type Type Objname)
  (present Dev Type Objname _))
( (ifpresent upper Dev Dev Owner Objname)
  (devIf Owner Dev _ Objname _)
  (present Owner _ _ _))
</p></blockquote></pre>
<h2>Appendix B. Sample Fact Set</h2>
<p>The <b>SProlog</b> clauses in this section were extracted from 
a standard PC development machine at Microsoft.
</p><pre><blockquote>(devClass ndisDriver basic no)
(devClass ndisTransport basic no)
(devClass netBiosTransport ndisTransport no)
(devClass lmNetService basic no)
(bindable ndisTransport ndisDriver non non 100)
(bindable lmNetService netBiosTransport non non 100)
(devType decetherworksturbo adapter decetherworksturboAdapter
    decetherworksturboAdapter)
(devBind decetherworksturbo &#34;Lance1&#34; yes yes container)
(devClass decetherworksturboAdapter basic no)
(present decetherworksturbo decetherworksturbo &#34;Lance1&#34;
    &#34;Machine\SOFTWARE\Microsoft\Windows NT\NetworkCards\1&#34;)
(devType lanceSys driver ndisDriver lanceDriver)
(devBind lanceSys &#34;LanceSys&#34; yes no container)
(devClass lanceDriver basic no)
(bindable lanceDriver dec100Adapter non exclusive 100)
(bindable lanceDriver dec101Adapter non exclusive 100)
(bindable lanceDriver decetherworksturboAdapter non exclusive 100)
(bindable lanceDriver dec422Adapter non exclusive 100)
(bindable lanceDriver decpcAdapter non exclusive 100)
(bindable lanceDriver decstatAdapter non exclusive 100)
(present lanceSys lanceSys &#34;LanceSys&#34; &#34;Machine\SOFTWARE\Microsoft\Lance&#34;)
(devType ubnb transport ubnbNbTransport streamsStack)
(devBind ubnb &#34;Ubnb&#34; yes yes container)
(devClass ubnbNbTransport netBiosTransport yes)
(present ubnb ubnb &#34;Ubnb&#34; &#34;Machine\SOFTWARE\Microsoft\Ubnb&#34;)
(devType mcsxns transport mcsxnsTransport streamsStack)
(devBind mcsxns &#34;McsXns&#34; yes yes container)
(devClass mcsxnsTransport basic yes)
(present mcsxns mcsxns &#34;McsXns&#34; &#34;Machine\SOFTWARE\Microsoft\McsXns&#34;)
(devType nbf transport netBiosTransport rasCapableTransport)
(devBind nbf &#34;Nbf&#34; yes yes simple)
(devClass rasCapableTransport netBiosTransport no)
(present nbf nbf &#34;Nbf&#34; &#34;Machine\SOFTWARE\Microsoft\Nbf&#34;)
(devType netbios service lmNetService lmNetService)
(devBind netbios &#34;Netbios&#34; yes yes container)
(present netbios netbios &#34;Netbios&#34; &#34;Machine\SOFTWARE\Microsoft\NetBIOS&#34;)
(devType srv service lmNetService lanmanServer)
(devBind srv &#34;LanmanServer&#34; yes yes container)
(devClass lanmanServer lmNetService no)
(present srv srv &#34;LanmanServer&#34; &#34;Machine\SOFTWARE\Microsoft\LanmanServer&#34;)
(devType streams transport streamsEnvironment streamsEnvironment)
(devBind streams &#34;Streams&#34; yes yes streams)
(devClass streamsEnvironment basic no)
(devClass streamsStack basic no)
(bindable streamsEnvironment ndisDriver non non 100)
(bindable streamsStack streamsEnvironment exclusive non 100)
(present streams streams &#34;Streams&#34; &#34;Machine\SOFTWARE\Microsoft\Streams&#34;)
(devType wksta service lmNetService lanmanWorkstation)
(devBind wksta &#34;LanmanWorkstation&#34; yes yes container)
(devClass lanmanWorkstation lmNetService no)
(present wksta wksta &#34;LanmanWorkstation&#34;
    &#34;Machine\SOFTWARE\Microsoft\LanmanWorkstation&#34;)
</blockquote></pre>



</pl></div>
  </body>
</html>
