<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.facebook.com/blog/post/2021/12/09/drgn-how-linux-kernel-team-meta-debugs-kernel-scale/">Original</a>
    <h1>Drgn: How the Linux kernel team at Facebook debugs the kernel at scale</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn&amp;h=AT2GnrIp126kAWg77wTdB1BU4yTYanZM6lvZc2Y3pwkOd30yC1QMuyv7vssqWOu-MHgB_jAAvojrTlrCW8XqoZlv4VhZtpqr9gPG-7YGvV-ZeOYQSZ2YcBY7U9qk3kFn27JZwezyr761tchw" rel="nofollow" target="_blank" data-lynx-mode="hover">drgn</a> (pronounced “dragon”) is a debugger that exposes the types and variables in a program for easy, expressive scripting in Python. The Linux kernel team at Meta originally built drgn to make it easier to investigate the kinds of difficult Linux kernel bugs that the team encounters at Meta. The team has since added further use cases for it, like monitoring and userspace memory profiling. This blog discusses why we built drgn, how drgn works, how to use it, and what the team would like to do with drgn next. The drgn project is open source and available in the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn&amp;h=AT1rDrbW0n7SLssQWs17kxUe7d6zwS5UAmdzN84siN2PdG0yWMYsuZI2mnwmFsS2C0LWB2LUKS3Kp7WlzvSOClnt35l554Vc2oZwL_urzWOd668H2r19ZO6Z9jFO-23pw6yBZck2V3EUB2hp" rel="nofollow" target="_blank" data-lynx-mode="hover">drgn</a> GitHub repo for you to try. </p><h3 id="u_0_2t_Y+">Why drgn?</h3><p> Meta uses Linux for most of its infrastructure. The Linux kernel team at Meta has a comprehensive validation and phased rollout procedure to help catch bugs before they are in production. Of course, some rare bugs aren’t caught until the kernel is deployed at a huge scale. Debugging issues like this often required traversing and sifting through lots of interconnected data structures, which was difficult or tedious with existing tools. </p><p> The Kernel team built drgn to have a tool with: </p><ul><li>Better scripting support than the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fcrash-utility.github.io%2F&amp;h=AT3BBGtUWnrdskGmj-wbh24fPAXB6Ik4vk0Zst9LY7wS7EOqHSSqKiRyM1DGAX3a6vScKxMD23xbp_Eml1btgNCqiE1uM_D5dX8-EGdu01O12gkVShdJfkMOH2eKxcSECBM364BZgIf9LFgG" rel="nofollow" target="_blank" data-lynx-mode="hover">crash utility</a></li><li>More natural scripting than <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.gnu.org%2Fsoftware%2Fgdb%2F&amp;h=AT2FAzSH9-JlV4sZA_IY8hfrODGAqvh2dQAfVeEJlUvQz5QOo5cnmD9PI5a-hU_Qd5pHAWnuqZk7P3H401YfcRCz2_LfTntSA3MDQGM9EFh7RXjvkQJSy2LUFwrv3U3pZit5MjoZhNxWUDRw" rel="nofollow" target="_blank" data-lynx-mode="hover">GDB</a></li><li>Better Linux kernel support than GDB</li></ul><h3 id="u_0_2w_2f">How to Use drgn</h3><p> To use drgn for debugging purposes, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%23installation&amp;h=AT20ShJMyBYqpBVHIVYs0qKRwJOaBufDDTZd_QHF295H9avPJ_0d3rAAnnhJBBnZ_lRzIv0CBFfbKAb70UeSAHISHsp3z7E0TNOw21RCLGivaBJekLmqHABrgaIo2njfh8_Vb-vJPVd6HBz5" rel="nofollow" target="_blank" data-lynx-mode="hover">install drgn</a> and get <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdrgn.readthedocs.io%2Fen%2Flatest%2Fgetting_debugging_symbols.html&amp;h=AT1122VmadirB4pOVAOYn_hivGWo_UkEJd4gp0AQASPeR2oBWbC3vwykcBO7mxCucJoOwaMtoyaeNrZ_gLgi4W6Bx9V1UGVoFfUMlS73c9_NEPXaNuUMlFJFii10BnK62dh7fYgYmlrX1O0B" rel="nofollow" target="_blank" data-lynx-mode="hover">debugging symbols</a> for your running kernel. drgn can debug a kernel core dump or the running kernel. To debug the running kernel, simply run <i>sudo drgn</i>. This starts a Python interpreter that is preloaded with the drgn environment. Namely, it provides the <i>prog</i> variable, which is drgn’s representation of the program that can be used to access variables, types, and more: </p><pre>$ sudo drgn
&gt;&gt;&gt; prog.type(&#34;struct list_head&#34;)
struct list_head {
	struct list_head *next;
	struct list_head *prev;
}
&gt;&gt;&gt; prog.variable(&#34;jiffies_64&#34;)
(u64)4295733889
# Shorthand:
&gt;&gt;&gt; prog[&#34;jiffies_64&#34;]
(u64)4295735240
        </pre><p> The drgn interpreter pretty-prints variables by default, but the <i>prog.variable()</i> method and <i>prog[]</i> syntax return one of the core building blocks of drgn: <i>drgn.Object</i>. A drgn object represents a variable, constant, function, or computed value. It has several fields and methods that can be used to get information about the variable: </p><pre>&gt;&gt;&gt; hex(prog[&#34;jiffies_64&#34;].address_)
&#39;0xffffffff8fa07980&#39;
&gt;&gt;&gt; prog[&#34;jiffies_64&#34;].type_
typedef __u64 u64   
        </pre><p> More importantly, a drgn object can be used in expressions just like in the actual program, like doing arithmetic or accessing structure members or array elements: </p><pre>&gt;&gt;&gt; prog[&#34;jiffies_64&#34;] + 1
(u64)4295933335
&gt;&gt;&gt; prog[&#34;init_task&#34;].comm
(char [16])&#34;swapper/0&#34;
&gt;&gt;&gt; prog[&#34;init_task&#34;].comm[0]
(char)115          
        </pre><p> drgn also provides <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdrgn.readthedocs.io%2Fen%2Flatest%2Fhelpers.html&amp;h=AT04FKAsUT1ZGzn9tt0qYyunz-PVUioESpIGBZ1eT9Y5Gn_v1aQ4ZUaulXb0W2Fky73DLoW7KXHAIqMg9_Q8cRlRrrfq_LsnXG7qAzkvejsQXqvfUEg0fZAdNNqJ0ypf6ftuSxSztJq1bsCq" rel="nofollow" target="_blank" data-lynx-mode="hover">helpers</a>, which are predefined functions for working with common data structures and subsystems: </p><pre>&gt;&gt;&gt; for task in for_each_task(prog):
...     if task_state_to_char(task) == &#34;R&#34;:
...             print(task.comm)
...
(char [16])&#34;drgn&#34;
&gt;&gt;&gt; path_lookup(prog, &#34;/etc/hosts&#34;)
(struct path){
       .mnt = (struct vfsmount *)0xffff9806008557e0,
       .dentry = (struct dentry *)0xffff980601678900,
}   
        </pre><p> Helpers aren’t magic; they are just Python functions that use drgn objects and some knowledge of the Linux kernel.</p><pre>&gt;&gt;&gt; trace = prog.stack_trace(508)
&gt;&gt;&gt; trace
#0  context_switch (kernel/sched/core.c:4940:2)
#1  __schedule (kernel/sched/core.c:6287:8)
#2  schedule (kernel/sched/core.c:6366:3)
#3  io_schedule (kernel/sched/core.c:8389:2)
#4  wait_on_page_bit_common (mm/filemap.c:1356:4)
#5  __lock_page (mm/filemap.c:1648:2)
#6  lock_page (./include/linux/pagemap.h:625:3)
#7  pagecache_get_page (mm/filemap.c:1910:4)
#8  find_or_create_page (./include/linux/pagemap.h:420:9)
#9  cluster_pages_for_defrag (fs/btrfs/ioctl.c:1249:10)
#10 btrfs_defrag_file (fs/btrfs/ioctl.c:1549:10)
#11 btrfs_ioctl_defrag (fs/btrfs/ioctl.c:3179:9)
#12 btrfs_ioctl (fs/btrfs/ioctl.c:4935:10)
#13 vfs_ioctl (fs/ioctl.c:51:10)
#14 __do_sys_ioctl (fs/ioctl.c:874:11)
#15 __se_sys_ioctl (fs/ioctl.c:860:1)
#16 __x64_sys_ioctl (fs/ioctl.c:860:1)
#17 do_syscall_x64 (arch/x86/entry/common.c:50:14)
#18 do_syscall_64 (arch/x86/entry/common.c:80:7)
#19 entry_SYSCALL_64+0x7c/0x15b (arch/x86/entry/entry_64.S:113)
#20 0x7f843e30d59b
&gt;&gt;&gt; trace[6]
#6 at 0xffffffff8e62e573 (pagecache_get_page+0x433/0x4df) in lock_page at ./include/linux/pagemap.h:625:3 (inlined)
&gt;&gt;&gt; inode_path(trace[6][&#34;page&#34;].mapping.host)
b&#39;usr/bin/myservice&#39;          
        </pre><p> The <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdrgn.readthedocs.io%2Fen%2Flatest%2Fuser_guide.html&amp;h=AT1zjRETqvPH0pP_WydlfFZVF_CmAMixFnCfQ7zgvSsQoD39c7dYcy5mPgynZLaMoc0XF6HvYY5C4XMmEC5_4lOOfkO2ly6hohGiENPkdlb2Q1zu7_5gxQ50QrB-yuDzurt01XtuJMPHMGN8" rel="nofollow" target="_blank" data-lynx-mode="hover">drgn user guide</a> goes into more details about these concepts. </p><h3 id="u_0_2y_MY">How Meta Uses drgn</h3><p> Meta has used drgn to investigate many Linux kernel bugs. To name a few: </p><ul><li>A complex interaction between <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fbtrfs.wiki.kernel.org%2Findex.php%2FMain_Page&amp;h=AT0NMjecEUPuN7ax2SEvJLXyLQ03PowUSbFjB-EkIzE5rrv51vEv4NpAq1esONzHETn51WfW4XGbY2AkW7729P7nQSIH4v2VDNe5T09CQcUJyP3qMLi6lHQZaZtJ7nW_M5uSKK2qU_OgxgjQ" rel="nofollow" target="_blank" data-lynx-mode="hover">Btrfs</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLoop_device&amp;h=AT2f4cKXsBEw4DrAwI7ZyNzCeByJVJ2d3IeyXtLTaJAum_4gyBGMG5nVCVPdMZkxNqDmI5p-AOmaKJqzL9hMqAVFdLpGatoRWSKO6JQ63fEcLLaKuh6wM128BPT-Y4PaerdjvbyDz9GgHvUv" rel="nofollow" target="_blank" data-lynx-mode="hover">loop devices</a>, and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Ftree%2Finclude%2Flinux%2Fworkqueue.h&amp;h=AT3r9VW1LjQLoax9iml908sYkMpSS1CJpQWvQUcQIEugYyCtFF-S3cQvZoBda-SywB-0F9SZlRhoYh_4_liBI5vmQgqc8OsKINqkNsXoHuI6nns97cwgCM1avl6fSV872fXbjn3elTxq7KJ_" rel="nofollow" target="_blank" data-lynx-mode="hover">workqueues</a> created a rare deadlock. This investigation involved looking at various servers that had hit the deadlock looking for patterns and hints. This culminated in a <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Dc495dcd6fbe1dce51811a76bb85b4675f6494938&amp;h=AT28d1kxq1aMJVZJqLHLVHmTparHJP7cyZc924UuwWxEHOE4fVPjaZaFRG6sdujjlNjrik0ipvrqQ38C_vu87hv2Aowr1TjkC-dZTjq_aUwUp_3JxhMQD83RuoPeIkRFe851XwjiUzWHQ_Mn" rel="nofollow" target="_blank" data-lynx-mode="hover">fix to the kernel</a>.</li><li>A <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Db910eaaaa4b89976ef02e5d6448f3f73dc671d91&amp;h=AT1bs_m1bsEZRqxjI_HC3kB4ZuJTbhnG6A_EV0kwh1ghmVWC_WgMo4388PnpNRotMb4TE8MtiLnICotapf1um0eNKjQ7Gr9GFy2V70Df4jziwmd2nExiSDfYriVz5fI8MXchW_Rkm_Bx6eZM" rel="nofollow" target="_blank" data-lynx-mode="hover">change</a> to <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Flatest%2Fbpf%2Fmap_cgroup_storage.html&amp;h=AT20hyS4EeEFjYlPSEZ1MINAkP26vAQDye-hDq--BkJTK_hTBGzsA1SZX6CdKUg1FgMJtotSbZM5I8zgKvxwWK_LbK6Hk0w3rQdN19PtZV39_aQanLlUKSh8OlkOYYiF-429PFk-WAWvKN_1" rel="nofollow" target="_blank" data-lynx-mode="hover">BPF cgroup local storage</a> introduced a logic error. This was diagnosed using drgn. Again, this resulted in a <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Da2baf4e8bb0f306fbed7b5e6197c02896a638ab5&amp;h=AT25UwWFyJRc8rSGn1Y6R09hkbeJHoBpdcTIp5S2_bc_scTMa72VpbsRD3Ge8TsiypMdUH2adaxyOpT8D042nN9Ms8X2mqbBUaY3H0Wxk3lYeFRrtTpC37A-ENO6HC6mvKuiB4oZGdGSZ9Eq" rel="nofollow" target="_blank" data-lynx-mode="hover">fix</a>. </li><li>Btrfs defragmentation deadlocked when defragmenting a file with <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Flore.kernel.org%2Flkml%2F20190801184244.3169074-1-songliubraving%40fb.com%2F&amp;h=AT2OFFQv18Bm3M99t6_rh67QNA8EeOHVE6NOPQJIxPd_CUg5M7TwlYO0-wKgtNfDkKjHqB36tEuMSZfHnrvqwggNSu97r_8R5P0hPXpVWP9zz9TGwVHBxEx_Soi_RUKBrfEmBO9_XI1lqPg1" rel="nofollow" target="_blank" data-lynx-mode="hover">transparent huge pages</a>. This was also <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3D24bcb45429d924711576856b26c99ad3375b1e12&amp;h=AT1Y2oF51SpkqsPvJoQNM6xzwkxo_JBNhJUZaTY03KRC7hPd2a3zqqTRntF04cruuh-jq-Xltwz2afIdYurBwgC81Cb8173LswuMXr6_aLrUgNj4RZner7xie9xOBPG6m5InJM36Z-lbreFI" rel="nofollow" target="_blank" data-lynx-mode="hover">fixed</a>. </li><li>A preemption bug in the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Ftree%2Fblock%2Fkyber-iosched.c&amp;h=AT0pHDu2bpKddlOlwwNQiwOGNDemC0K7e_EdhQnw-CUU-lak2zsUbQfTe8k976C4p1mkLostIdFBhpkHTC3S64Q58H99vtwdkR8lUjtoaqSHfouZV9F-dd0rivB38GR-728lEjk9rt7pU_YTdVYAB73Jrcqllw" rel="nofollow" target="_blank" data-lynx-mode="hover">Kyber I/O scheduler</a> was easy to <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdrgn.readthedocs.io%2Fen%2Flatest%2Fcase_studies%2Fkyber_stack_trace.html&amp;h=AT1bqk-8zrsMbuCQ9yaguFtpIFxhxxu1hhTOCu8ZtVSbs_PMm_I4JQPi3GJe2k_88NXtQznGisuiMyoYl188q7THRaHME9CK4yJNpO9Gg72P73TDcZfyJTPt4fTvqEI0sQh_M9t0cuTnkyJ-" rel="nofollow" target="_blank" data-lynx-mode="hover">find</a> and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Defed9a3337e341bd0989161b97453b52567bc59d&amp;h=AT0PPWDR_s0x9H5JlnZrpLCM8ySiQrgtYf-xR_f_IK0BMcRhfYKr9M0wV9bGBsOaiS6atmKPpFiXfmt6cAZsq0Zg1Apw2Z46o2oV4yoQAo9n3D6jxBAjUx1sJc3qQuHc8coGnw5vgzR56Did" rel="nofollow" target="_blank" data-lynx-mode="hover">fix</a> with drgn.</li></ul><p> In addition to ad hoc debugging sessions, we have also integrated drgn into our automatic kernel core dump collection system. Whenever we have a kernel crash, we use <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FKdump_%28Linux%29&amp;h=AT1YLzN1Ea4qGQGMQmnaeX58pCetiYFpqhyWFLUE_81ACjgXeX2tGg6Sw7OpAZmJPXaNzNSYEeH2dE4IF1C7E-CjhqBK--qLS0SAOa7ffwdpdZQaimWN2Nw2lu5Qk0lDCEqIvjSo7Tzb7LUm" rel="nofollow" target="_blank" data-lynx-mode="hover">kdump</a> to capture a core dump. When the machine reboots, we use drgn to automatically collect stack traces and information about what processes were running at the time of the crash, what BPF programs were loaded, etc. That information is sent to Meta’s monitoring systems, including <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fresearch.fb.com%2Fpublications%2Fscuba-diving-into-data-at-facebook%2F&amp;h=AT2VYWhQpXkHclEK0kSZC5WMvXCZOsp8woE3RJW71FteeJajFPRGZsN1YVRvsgdCJEHwgGQ1qHmuvZF-29n52kbuuh8kqKGWeg0khdE5npaOsvpGLwS-KBc9z0bLlLmBfCu5e2UxsSpRK-qd" rel="nofollow" target="_blank" data-lynx-mode="hover">Scuba</a>. This is used both for automatic alerts of frequent crashes and for manual investigations. </p><p> drgn is not limited to debugging. We have also used drgn to collect statistics and monitor kernel internals that are not otherwise exposed. For example, we have published scripts to <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3De5bd61e82b7a60c92bc09a618a0d8a612689037b&amp;h=AT2mSAIZ6qvlBajkJHUsQ5r5V3TqmWgI54D4RW4YyCaZQpjboXnuwmGsd8zMIjff5-ZSCJQMtlnmDyLOSnbiItTulyxx1ukjHH_hfAdsTQqsz1nXORJIcBQojn5E6DW8nrqiFdgLmSHMzA3Z" rel="nofollow" target="_blank" data-lynx-mode="hover">count RCU callbacks</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Dfbc1ac9d09d70859eee24131d667e01e3986e368&amp;h=AT1KkybCrXTG88Ng5jsCcJJy6Sb9gIlCdY8bkZb71BuzT-e6Yy8EkwCGDm3i_1A7IlHZaYjsYNNac9z_quFe-OGc4Ug2NfxlDt5FHPJ6po2DHsOWTp5SORsXw86DpNEzMl-qYwuW3LJOoKzg" rel="nofollow" target="_blank" data-lynx-mode="hover">inspect cgroup slab allocator usage</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%2Fblob%2Fmain%2Ftools%2Fbpf_inspect.py&amp;h=AT2NEhgA-Lspy1l5ZXAcg7Y0imWvVfYaZQhicA-dTP0j9FcbHTPpobmHsc31SefuRMcVjl2_Wtmz4ZliyVKAsixwpZ7rdc9zB7XA7GRTus5Itmoe1rvg7-vhxv1ctbTrOX0IbWvPNDWSBZCv" rel="nofollow" target="_blank" data-lynx-mode="hover">list BPF programs and maps</a>, and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3D6954ff185ee0811cdd2e0f388ff4dd7df17f11af&amp;h=AT3E6HY7UaDjph_Ws4YG09t1A3a2Jiq3zh3jcFW6rg5STlAUNJ8AmHM9RqfezF2An-JdmDMgi5iejeRZEsIJvPcDoT4D2UzDzfe1EvctYXIaybrQYZAIDHwSvShFX6FRhzHTSzdFDCt0w2Ek" rel="nofollow" target="_blank" data-lynx-mode="hover">monitor the iocost cgroup I/O controller</a>. </p><p> Finally, although drgn was initially developed for the Linux kernel, it is designed as a generic library for introspecting program types and state. As such, the Capacity Engineering and Analysis team at Meta uses drgn as the backend for getting type information for their Object Introspection memory profiler. This profiler was used to implement some multi-gigabyte memory savings in a critical Meta service. </p><h3 id="u_0_31_M+">How drgn Works</h3><p> The internals of drgn are not drastically different from other debuggers, although it has some important optimizations that make it more pleasant to use. drgn consumes two main inputs: the memory of the program and the debugging symbols for the program. The source of the memory depends on what is being debugged: </p><ul><li>For a crashed program, drgn uses a core dump (which on Linux is an <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FExecutable_and_Linkable_Format&amp;h=AT0wZtZFFeA2e0TmqybTilAkGqV3jPfQpYo1hkJnboTI1BAOhB9cDALgXD2dUxMTPaVLpAFD2m1OWsIs9JTjg9xz8bGf1MPf6OcbnjudLd69FlyqWBECoOnEKbIZjw_7Qkd-qJ-98CVzWDgf" rel="nofollow" target="_blank" data-lynx-mode="hover">ELF</a> file).</li><li>For a running program, drgn uses the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman5%2Fproc.5.html&amp;h=AT1fSKtAffJFxVBuD6HAG-ADWFJxa66tNraEQ1dWXIOOJ1ho9kBC87yRZk8OSrTR5Gc4rJiM-QOAUjmF7IoxhDk6Iuk3i2CRYsPMfV9EiyXi7J_ri3393g92vHJNZajDGI177jO3CLyVbQ_U" rel="nofollow" target="_blank" data-lynx-mode="hover">/proc/[pid]/mem</a> pseudo-file.</li><li>For a kernel crash, drgn can use an ELF core dump (e.g., /proc/vmcore) or a compressed dump generated by <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Flinux.die.net%2Fman%2F8%2Fmakedumpfile&amp;h=AT3JMPsRE4CftT0p_mrV3HPx7Cb2ABWqimzG2ARJgYlHgLRCu11Fjeeu7M-NmSNRk-PFv8_qykDiNQVWaiJgeMrS8vVE1x7kVrKBS-M93g5ZtnS-aUzqpK3e_7Y4blVZLLD8udQmQqUoup4z" rel="nofollow" target="_blank" data-lynx-mode="hover">makedumpfile</a>.</li><li>For the running kernel, drgn uses the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman5%2Fproc.5.html&amp;h=AT02xrAPHxKk5gHt-QT8SYr9GnwdnztQHxaJKeWYoNE12z3z5PzcS_ZuhdDUJwnuiGIUTK1tYwiVBpDOCXgPn7dJJuGwlmSqHiLQGe497QQVOREjtK9Tg3Q3mqWugMzOWVhdaQPIocG1SATH" rel="nofollow" target="_blank" data-lynx-mode="hover">/proc/kcore pseudo-file</a>, which is also formatted like an ELF file.</li></ul><p> On Linux, the standard debugging information format is <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDWARF&amp;h=AT20QRSugl9pLUyMy_My2XwsJ5YUpWDb7oXCQcT_KlrwKR1vz8m3Ke4EHqastVcxcyFUP5lKeRaasEYq4ERmeikjMLNRehueFWg5l8AtxhrxFfMRuyTIPVjPr4Qjuy-eKiJ4ex_JyKL3c4am" rel="nofollow" target="_blank" data-lynx-mode="hover">DWARF</a>. DWARF provides information about the locations of variables, layouts of types, how to unwind the stack at a given instruction pointer address, and more. drgn mostly uses libdw from <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fsourceware.org%2Felfutils%2F&amp;h=AT3KfZeC00_c_fqiFCx2YL8_AFlPISP2sGjaiLJvvDZBj5grKVtilZRjLgGZz4KZVmYD-y6GPWQYEeMjKY1KuOOGDf_pEHgrgP3w0YUs66H7OmZW8oHSzh2wN_FmxI8IOG0UDnj0zKZS2oHQ" rel="nofollow" target="_blank" data-lynx-mode="hover">elfutils</a> to process ELF and DWARF data. However, when starting up, drgn uses a custom-built, parallelized DWARF parser to quickly build a cache of DWARF information indexed by the names of types, variables, etc. drgn starts up 5 times as fast as GDB, which provides a better user experience. drgn also has programming language-specific logic for emulating types and operators (currently mainly C, with C++ in progress) and instruction set architecture-specific logic for accessing CPU registers, page tables, and more (currently mainly x86_64). </p><p> The core drgn functionality is implemented in a native library, libdrgn. <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdocs.python.org%2F3%2Fextending%2Fextending.html&amp;h=AT1jkBvD_degZNKclvlFnZTQTK_7G3LTm1V9n57MOXeOaIT4z0B_S9M17OcP92QWJVd6LoDylBzYyLonYQqeMw6ZVqhYUan70nYSUE6x3qvNiaQZY6rDogq_TQlcihKZ51_hlt08EUVE6yUM" rel="nofollow" target="_blank" data-lynx-mode="hover"> Python bindings</a> are built on top of libdrgn, and the command-line interface and helpers are built on top of those bindings. </p><h3 id="u_0_34_3s">Next Steps</h3><p> The long-term vision for drgn is to provide programmatic access to anything and everything about a program’s internals, enabling a wide variety of debugging and monitoring tasks. However, since we originally developed it with a focus on debugging the Linux kernel, there are several incomplete or missing features: </p><ul><li>C++ <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253AC%252B%252B%2B&amp;h=AT3bj_UxlYgPkjmyqklbZIV_VT6Qwp05dxHwUelqjwU9HDwHhYPBNZNPcxdsTUk01HYkyFZW_obXJKBmpq19JJr4L6cRHUtSscakmoL0C0zyuCumSWpyZPUJYWhoVED4fi3yqFV0BCOrNPBK" rel="nofollow" target="_blank" data-lynx-mode="hover">support</a> is in progress as part of the aforementioned Object Introspection project. Rust support could also be added in the future.</li><li>Userspace debugging is missing <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%2Fissues%2F92&amp;h=AT27Qoye3OixoDCca0HSJZy2evaE83IMCflY4czulWON0YoA62CWeE2mUWeOCGi1JhK6t7RY-KZS3i3rQosPm5pn5b-LJ6pYqiX0q-NIyhdjIsrShzRBISw8Fw1U98_Be_zyPDmoDAsqTgWo" rel="nofollow" target="_blank" data-lynx-mode="hover">support</a> for listing threads and attaching to threads to pause and resume them.</li><li>drgn is currently read-only. It cannot set breakpoints, modify memory, or call functions in the program (yet).</li><li>drgn could always use more helper functions for areas that are not already covered.</li></ul><h3 id="u_0_37_A2">Conclusion</h3><p> drgn is a powerful tool that makes debugging complex programs much easier. It is being actively developed to add more complete support for C++ and userspace applications as well as to continue improving its support for the Linux kernel. See the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdrgn.readthedocs.io%2F&amp;h=AT1DdPhtCSyWqhel6ZOVffpB_UIy7U7xJnev-k8Gi4MCkcdKw-2YdSNl2KBpWvXEwJEVf5eg-fH8IzBLjPge7pGEfQcMars3zC5tTOva6sXvzym1qjLbtkY41yCREtzdqPUoS5tnaK-jdpsF" rel="nofollow" target="_blank" data-lynx-mode="hover">documentation</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%23installation&amp;h=AT0dccLl7Rz6QyaGYEKGJdt7-osYCU4cjYsoM4WK53G6iqB90isJ-eMF7CquSSlkoOybV2t5DLlnwuD4sJ6pcExCXncZ-x7I0sVMGBxE5Pi346nK3Kldnwwr9DZrDpNSZfZX5N4Xb92c39Hx" rel="nofollow" target="_blank" data-lynx-mode="hover">try it out</a>, and share feedback, feature requests, or bugs to the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fosandov%2Fdrgn%2Fissues&amp;h=AT1nNe4XPPPBKFiK9VAVFrRxYjQpckTYmOq5CCJZgwxeIaOwiJZhnNgHUKhiFhTz4fNboYl2fMnImnzOasjaiU3g_mIZCVsbhDPJNZ4XZbFKw8Bg1oHRIJp0BnbhWZ32LkEMKrtM_ilQ2Jcv" rel="nofollow" target="_blank" data-lynx-mode="hover">issue tracker</a>. </p><p> To learn more about Meta Open Source, visit our <a href="https://opensource.facebook.com/" target="_blank">open source site</a>, subscribe to our <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCCQY962PmHabTjaHv2wJzfQ&amp;h=AT3p2LMrvr8gxkQBjoqxo2akLWQNezAyD6nLhNEE7hbVlZy7h2897krwwjtXaln_HOjg5b8825mtfj4XpuGlsKuDvqoWT0QiwUWvHRvrO9vDYrbnRjKeYIHh2Ly-7_6blxaReRXH9spDuazs" rel="nofollow" target="_blank" data-lynx-mode="hover">YouTube channel</a>, or follow us on <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Ftwitter.com%2FMetaOpenSource&amp;h=AT0ly1phly14Bp8Uq_8oWJSBuQnTgjS-IFViPQjchpy3699F6EBOtbGQLTZGNglgHcp5nOE79T7bHpSvloTwmrPnyzLDfQ_w2IUt6TEhuwPlTY4dtpKSJijqAHp3lCgSfeOwP5IXf5hJ8NoR" rel="nofollow" target="_blank" data-lynx-mode="hover">Twitter</a> and <a href="https://www.facebook.com/MetaOpenSource" target="_blank">Facebook</a>. </p></div></div></div></div></div>
  </body>
</html>
