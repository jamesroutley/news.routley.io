<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmer.io/posts/announcing-winterjs-service-workers">Original</a>
    <h1>WinterJS</h1>
    
    <div id="readability-page-1" class="page"><div><p>Today we are incredibly excited to announce <a href="https://github.com/wasmerio/winterjs">WinterJS</a> (<a href="https://wasmer.io/wasmer/winterjs"><code>wasmer/winterjs</code> package</a>).</p>
<p>WinterJS is a JavaScript Service Workers server written in Rust, that uses the SpiderMonkey runtime to execute JavaScript (the same runtime that Firefox uses). We chose to follow the <a href="https://wintercg.org/">WinterCG</a> specification to aim for maximum compatibility with other services such as Cloudflare Workers, Deno Deploy and Vercel (hence the name <em>WinterJS</em>).</p>
<p>WinterJS is not only <em>blazing fast™️</em> but can also be compiled to WebAssembly <a href="https://wasix.org/">thanks to WASIX</a> and thus also run fully with Wasmer.</p>
<p>Let&#39;s see how it works. We&#39;ll start by creating a simple <code>serviceworker.js</code> file that just returns a simple &#34;hello world&#34;;</p>
<pre tabindex="0"><code><span><span>addEventListener</span><span>(</span><span>&#39;fetch&#39;</span><span>, (</span><span>req</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  req.</span><span>respondWith</span><span>(</span><span>`hello world from ${</span><span>req</span><span>.</span><span>request</span><span>.</span><span>url</span><span>.</span><span>href</span><span>}`</span><span>);</span></span>
<span><span>});</span></span></code></pre>
<p>Running it with WinterJS is as simple as this:</p>
<pre tabindex="0"><code><span><span>$</span><span> wasmer run wasmer</span><span>/</span><span>winterjs </span><span>--</span><span>net </span><span>--</span><span>mapdir </span><span>/</span><span>app</span><span>:.</span><span> </span><span>/</span><span>app</span><span>/</span><span>serviceworker</span><span>.</span><span>js</span></span></code></pre>
<blockquote>
<p>WinterJS can also be run natively with Rust (<code>cargo install --git https://github.com/wasmerio/winterjs &amp;&amp; winterjs serviceworker.js</code>).
You can find the source code of WinterJS in the GitHub repo: <a href="https://github.com/wasmerio/winterjs">https://github.com/wasmerio/winterjs</a></p>
</blockquote>
<p>Thanks to the WASIX capabilities of WinterJS, the JavaScript service worker can also be deployed to <a href="https://wasmer.io/products/edge">Wasmer Edge</a>.
Check the working demo here: <a href="https://js-service-worker-demo.wasmer.app/">https://js-service-worker-demo.wasmer.app/</a></p>
<hr/>
<p>And now that you have seen a sneak peak on how to use WinterJS, lets do a deep dive on our journey building it.</p>
<h2>Choosing the JS engine</h2>
<p>Before starting on the quest of creating a JavaScript Service Workers server, we analyzed the Javacript runtimes that we could use.</p>
<p>Here are the main requirements we have for such JavaScript runtime:</p>
<ul>
<li><strong>Speed</strong>: It should be fast to run</li>
<li><strong>Wasm-compatible</strong>: It should be able to run without restrictions in a Wasm environment (such as Wasmer)</li>
<li><strong>Development time</strong>: We should be able to iterate fast on it</li>
</ul>
<p>And here are the JS runtimes that we analyzed:</p>
<ul>
<li><strong>QuickJS.</strong> Challenges:
<ul>
<li>We will need to implement all the JS apis diff (<code>peformance.now()</code>, <code>addEventListener</code>, …)</li>
<li>We need to implement the serviceWorker API entirely in C</li>
</ul>
</li>
<li><strong>Static Hermes.</strong> Challenges:
<ul>
<li>Node.js polyfills not available in static mode</li>
<li>Not a lot of functions (such as http calls) are available in the polyfill</li>
<li>Had to make it compile to Wasm with WASIX</li>
</ul>
</li>
<li><strong>Bun</strong> (JavascriptCore). Challenges:
<ul>
<li>Zig not fully supporting WASIX</li>
<li>Compiling JavascriptCore to WASIX is possible (was done before), but not trivial</li>
</ul>
</li>
<li><strong>MozJS</strong> (SpiderMonkey). Challenges:
<ul>
<li>We will need to implement all the JS apis diff (<code>peformance.now()</code>, <code>addEventListener</code>, …)</li>
<li>We need to implement the serviceWorker API (in Rust)</li>
<li>We will need to plug the service worker with a WASIX http server</li>
</ul>
</li>
<li><strong>Node.js</strong> (v8). Challenges:
<ul>
<li>Compile v8 in jitless mode to Wasm is an unknown-unknown</li>
</ul>
</li>
</ul>
<h2>Using SpiderMonkey with mozjs</h2>
<p>After a few runtime trials we set on SpiderMonkey as the most reasonable approach that fitted our tight timeline.</p>
<p>So we begin porting. We started with a fork of mozjs that supported a <strong><a href="https://cfallin.org/blog/2023/10/11/spidermonkey-pbl/">new compilation tier called PBI</a></strong> (Portable Baseline Interpreter).</p>
<p>After some work on the mozjs build system to target WASIX, we were able to bypass most of the issues, except one: the bindings generation.</p>
<p>The bindings that allow using the SpiderMonkey C++ API from Rust were automatically generated using c-bindgen. Plugging those bindings onto WASIX was a challenge so we simply decided to target a 32 bit system and modify them by hand (a 32,000 file!) to target <a href="https://wasix.org">WASIX</a>.</p>
<p>And voilá… everything worked!</p>
<p>However, after adding a few missing resources to JS, we realized that perhaps mozjs didn’t have the easiest API to use:</p>
<pre tabindex="0"><code><span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span><span> </span><span>base64_encode</span><span>(cx</span><span>:</span><span> </span><span>*mut</span><span> </span><span>JSContext</span><span>, argc</span><span>:</span><span> </span><span>u32</span><span>, vp</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Value</span><span>) </span><span>-&gt;</span><span> </span><span>bool</span><span> {</span></span>
<span><span>    </span><span>let</span><span> args </span><span>=</span><span> </span><span>CallArgs</span><span>::</span><span>from_vp</span><span>(vp, argc);</span></span>
<span></span>
<span><span>    </span><span>if</span><span> args</span><span>.</span><span>argc_ </span><span>&lt;</span><span> </span><span>1</span><span> {</span></span>
<span><span>        </span><span>return</span><span> </span><span>false</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>let</span><span> source </span><span>=</span><span> </span><span>js_try!</span><span>(cx, </span><span>raw_handle_to_string</span><span>(cx, args</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)));</span></span>
<span><span>    </span><span>let</span><span> result </span><span>=</span><span> </span><span>::</span><span>base64</span><span>::</span><span>engine</span><span>::</span><span>general_purpose</span><span>::</span><span>STANDARD</span><span>.</span><span>encode</span><span>(bytes);</span></span>
<span></span>
<span><span>    </span><span>rooted!</span><span>(</span><span>in</span><span>(cx) </span><span>let</span><span> </span><span>mut</span><span> rval </span><span>=</span><span> </span><span>UndefinedValue</span><span>());</span></span>
<span><span>    result</span><span>.</span><span>to_jsval</span><span>(cx, rval</span><span>.</span><span>handle_mut</span><span>());</span></span>
<span></span>
<span><span>    args</span><span>.</span><span>rval</span><span>()</span><span>.</span><span>set</span><span>(rval</span><span>.</span><span>get</span><span>());</span></span>
<span></span>
<span><span>    </span><span>true</span></span>
<span><span>}</span></span></code></pre>
<h2>Using SpiderMokey with spiderfire</h2>
<p>Thankfully, the <a href="https://github.com/Redfire75369/spiderfire/">spiderfire</a> project had been working on improving the API surface for using SpiderMonkey from Rust.</p>
<p>So the example laid out before now looks way simpler and easier to read/maintain:</p>
<pre tabindex="0"><code><span><span>#[js_fn]</span></span>
<span><span>fn</span><span> </span><span>btoa</span><span>&lt;&#39;</span><span>cx</span><span>&gt;(val</span><span>:</span><span> </span><span>String</span><span>) </span><span>-&gt;</span><span> </span><span>String</span><span> {</span></span>
<span><span>    </span><span>let</span><span> bytes </span><span>=</span><span> val</span><span>.</span><span>as_bytes</span><span>();</span></span>
<span><span>    </span><span>::</span><span>base64</span><span>::</span><span>engine</span><span>::</span><span>general_purpose</span><span>::</span><span>STANDARD</span><span>.</span><span>encode</span><span>(bytes)</span></span>
<span><span>}</span></span></code></pre>
<h2>Deploying to Wasmer Edge</h2>
<p>Compiling WinterJS to WASIX was challenging, but completely worth it. Thanks to its WASIX capabilities we can now run any Javascript Service Workers workloads in <a href="https://wasmer.io/products/edge">Wasmer Edge</a>.</p>
<p>We have put together an <strong>in depth tutorial on how to use Javascript Service Workers in Wasmer Edge</strong>... please check it out!</p>
<p><a href="https://docs.wasmer.io/edge/quickstart/js-wintercg">https://docs.wasmer.io/edge/quickstart/js-wintercg</a></p>
<hr/>
<p>We believe WinterJS will enable many new use cases. For example, running Service Workers natively in your IoT device (where Node is too heavy to run), or even in your browser.</p>
<p>At Wasmer we are incredibly excited to see how you will use WinterJS.</p>
<p>WinterJS on GitHub: <a href="https://github.com/wasmerio/winterjs">https://github.com/wasmerio/winterjs</a></p></div></div>
  </body>
</html>
