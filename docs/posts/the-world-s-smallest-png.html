<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://evanhahn.com/worlds-smallest-png/">Original</a>
    <h1>The world&#39;s smallest PNG</h1>
    
    <div id="readability-page-1" class="page"><div><div><address>by <a rel="author" href="https://evanhahn.com/">Evan Hahn</a></address><p>,
updated
<time datetime="2024-01-21">Jan 21, 2024</time>
(originally posted
<time datetime="2024-01-04">Jan 4, 2024</time>)</p></div><p>The smallest PNG file is 67 bytes. It’s a single black pixel. Here’s what it looks like, zoomed in 200×:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQAAAAA3bvkkAAAACklEQVR4AWNgAAAAAgABc3UBGAAAAABJRU5ErkJggg==" width="200" height="200" alt="A single black pixel."/></p><p>Wow, what a beauty.</p><p>This file has four sections:</p><ol><li>The PNG signature, the same for every PNG: 8 bytes</li><li>The image’s metadata, which includes its dimensions: 25 bytes</li><li>The image’s pixel data: 22 bytes</li><li>An “end of image” marker: 12 bytes</li></ol><p>The rest of this post describes this file in more detail and tries to explain how PNGs work along the way.</p><p>There’s a big twist at the end, if that excites you. But I hope you’re just excited to learn about PNGs.</p><h2 id="part-1-the-png-signature">Part 1: the PNG signature</h2><p>Every single PNG, including this one, starts with the same 8 bytes. Encoded in hex, those bytes are:</p><pre><code>89 50 4E 47 0D 0A 1A 0A
</code></pre><p>This is called the <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#5PNG-file-signature"><strong>PNG signature</strong></a>. Try doing a hex dump on any PNG and you’ll see that it starts with these bytes.</p><p>PNG decoders use the signature to ensure that they’re reading a PNG image. Typically, they reject the file if it doesn’t start with the signature. Data can get corrupted in various ways (ever had a file with the wrong extension?) and this helps address that.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p><p>Fun fact: if you decode these bytes as ASCII, you’ll see the letters “PNG” in there:</p><pre><code>.PNG....
</code></pre><p>So that’s the first 8 bytes. One part done! Here’s our “checklist”:</p><ol><li><del>PNG signature</del></li><li>Image metadata chunk</li><li>Pixel data chunk</li><li>“End of image” chunk</li></ol><p>What about the rest?</p><p>The next part of the PNG is the image metadata, which is one of several <strong>chunks</strong>. What’s a chunk?</p><h3 id="quick-intro-to-chunks">Quick intro to chunks</h3><p>Other than the PNG signature at the start, PNGs are made up of chunks.</p><p>Chunks have two logical pieces: a <strong>type</strong> and some <strong>data bytes</strong>. Types are things like “image header” or “text metadata”. The data depends on the type—the text metadata chunk is encoded differently from the image header chunk.</p><p>These logical pieces are encoded with <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-layout">four fields</a>. These fields are always in the same order for every chunk. They are:</p><ol><li><strong>Length</strong>: the number of bytes in the chunk’s data field (field #3 below). Encoded as a 4-byte integer.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></li><li><strong>Chunk type</strong>: the type of chunk this is. There are lots of different chunk types. Encoded as a 4-byte ASCII string, such as “IHDR” for “image header” or “tEXt” for “text metadata”.</li><li><strong>Data</strong>: the data for the chunk. See the “length” field for how many bytes there will be. Varies based on the chunk type. For example, the IHDR chunk encodes the image’s dimensions. May be empty, but usually isn’t.</li><li><strong>Checksum</strong>: a checksum for the rest of the chunk, to make sure no data was corrupted. 4 bytes.</li></ol><p>As you can see, each chunk is a minimum of 12 bytes long (4 for the length, 4 for the type, and 4 for the checksum).</p><p>Note that the “length” field is the size of the “data” field, <em>not</em> the entire chunk. If you want to know the whole size of the chunk, just add 12—4 bytes for the length, 4 bytes for the type, and 4 bytes for the checksum.</p><p>You have some wiggle room but chunks have a specific order. For example, the image metadata chunk has to appear before the pixel data chunk. Once you reach the “image is done” chunk, the PNG is done.</p><p>Our tiny PNG will have just three of these chunks.</p><p>The first chunk of every PNG, including ours, is of type <strong>IHDR</strong>, short for <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#11IHDR">“image header”</a>.</p><p>Each chunk starts with the <strong>length</strong> of the data in that chunk.</p><p>The IHDR chunk always has 13 bytes of associated data, as we’ll see in a moment. 13 is <code>0D</code> in hex, which gets encoded like this:</p><pre><code>00 00 00 0D
</code></pre><p>The <strong>chunk type</strong> is next. This is another four bytes. “IHDR” is encoded as:</p><pre><code>49 48 44 52
</code></pre><p>This is just ASCII encoding. Chunk types are made up of ASCII letters. <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-naming-conventions">The capitalization of each letter is significant.</a> For example, the first letter is capitalized which means it’s a required chunk.</p><p>Next, the chunk’s <strong>data</strong>. IHDR’s data happens to be 13 total bytes, arranged as follows:</p><ul><li><p>The first eight bytes encode the image’s width and height. Because this is a 1×1 image, that’s encoded as <code>00 00 00 01 00 00 00 01</code>.</p></li><li><p>The next two bytes are the <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#3bitDepth">bit depth</a> and <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#6Colour-values">color type</a>.</p><p>These values are probably the most confusing part of this PNG.</p><p>There are five possible color types. Our image is black-and-white so we use the “greyscale” color type (encoded as <code>00</code>). If our image had color, we might use the “truecolor” type (encoded with <code>02</code>). There are three other color types which we don’t need today, but you can <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#4Concepts.PNGImage">read more about them in the PNG specification</a>.</p><p>Once you’ve picked a color type, you need to pick a bit depth. The bit depth depends on the color type, but usually means the number of bits per color channel in an image. For example, hex colors like <code>#FE9802</code> have a bit depth of eight—eight bits for red, eight bits for green, and eight bits for blue. Our all-black image doesn’t need all that…we only need <em>one</em> bit! The pixel is either completely black (<code>0</code>) or completely white (<code>1</code>)—in our case, it’s completely black.</p><p>If we picked a more “expressive” color type and bit depth, we could make the same 1×1 image visually, but the file could be bigger because there could be more bits per pixel that we don’t actually need. For example, if we used the “truecolor” type and 16 bits per channel, each pixel would require 48 bits instead of just one—not necessary to encode “completely black”.</p><p>With bit depth of 1 and a color type of 0, we encode these two values with <code>00 01</code>.</p></li><li><p>The next byte is the <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#10CompressionCM0">compression method</a>. All PNGs set this to <code>00</code> for now. This is here just in case they want to add another compression method later. As far as I know, nobody has.</p></li><li><p>Same story for the <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#3filter">filter method</a>. It’s always <code>00</code>.</p></li><li><p>The last part of the chunk’s data is the <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#8InterlaceMethods">interlace method</a>. PNGs support progressive decoding which allows images to be partly rendered as they download. We aren’t going to use that feature so we set this to <code>00</code>.</p></li></ul><p>Finally, every chunk ends with a four-byte <strong>checksum</strong>. It uses <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#5CRC-algorithm">a common checksum function</a> called CRC32, and uses the rest of the chunk as an input. Computing that checksum gives us the following bytes:</p><pre><code>37 6E F9 24
</code></pre><p>All together, here’s the whole IHDR chunk:</p><table><thead><tr><th>Bytes</th><th>What?</th></tr></thead><tbody><tr><td><code>00 00 00 0D</code></td><td>data length of 13 bytes</td></tr><tr><td><code>49 48 44 52</code></td><td>“IHDR” as ASCII</td></tr><tr><td><code>00 00 00 01</code></td><td>width</td></tr><tr><td><code>00 00 00 01</code></td><td>height</td></tr><tr><td><code>01</code></td><td>bit depth</td></tr><tr><td><code>00</code></td><td>color type</td></tr><tr><td><code>00</code></td><td>compression method</td></tr><tr><td><code>00</code></td><td>filter method</td></tr><tr><td><code>00</code></td><td>interlace method</td></tr><tr><td><code>37 6E F9 24</code></td><td>checksum</td></tr></tbody></table><p>So that’s our first chunk! Let’s take another look at our checklist:</p><ol><li><del>PNG signature</del></li><li><del>Image metadata chunk</del></li><li>Pixel data chunk</li><li>“End of image” chunk</li></ol><p>Two more chunks to go—pixel data is next.</p><h2 id="part-3-pixel-data-chunk">Part 3: pixel data chunk</h2><p>Our next chunk is <strong>IDAT</strong>, short for <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#11IDAT">“image data”</a>. This is where the actual pixels are encoded…or just one pixel, in our case.</p><p>Remember that each chunk has four parts: the data’s <em>length</em>, the <em>chunk type</em>, the <em>data</em>, and a <em>checksum</em>.</p><p>This chunk will have 10 bytes of data. We’ll talk about <em>what</em> that data is shortly, but I promise it’s 10 bytes. Let’s encode that length:</p><pre><code>00 00 00 0A
</code></pre><p>Next, let’s encode “IDAT” for the chunk type:</p><pre><code>49 44 41 54
</code></pre><p>Again, this is just ASCII, and I’m showing the hex-encoded values.</p><p>Now for the interesting part: the image data.</p><h3 id="first-step-uncompressed-pixels">First step: uncompressed pixels</h3><p>Image data is encoded in a series of <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#3scanline">“scanlines”</a>, and then compressed.</p><p>A scanline represents a horizontal line of pixels. For example, a 123×456 image has 456 scanlines. In our case, we have just one scanline, because our image is just one pixel tall.</p><p>Scanlines start with something called a <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#9Filter-types">filter type</a> which can improve compression, depending on your image. Our image is so small that this is irrelevant, so we use filter type 0, or “None”.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p><p>After the filter type, each pixel is encoded with one or more bits, depending on the bit depth. In our case, we just need one bit per pixel—recall that we have a bit depth of 1; all black or all white.</p><p>If your pixel data doesn’t line up with a byte boundary—in other words, if it’s not a multiple of 8 bits—you pad the end of your scanline with zeroes. That’s true in our case, so we add seven padding bits to fill out a byte.</p><p>Putting that together (a zero byte to start the scanline, the single zero bit, and seven zero padding bits), our single scanline is:</p><pre><code>00 00
</code></pre><p>Now it’s time to “compress” the data.</p><h3 id="second-step-compression">Second step: “compression”</h3><p>Next, we compress the scanline data…well, not quite.</p><p>More accurately, we run it through a compression algorithm. Most of the time, compression algorithms produce smaller outputs—that’s the whole point! But sometimes, “compressing” tiny inputs actually produces <em>bigger</em> outputs because of some small overhead. Unfortunately for us, that’s what happens here. But the PNG file format makes us do it.</p><p>PNG image data is encoded in <a href="https://www.rfc-editor.org/rfc/rfc1950">the zlib format</a> using the <a href="https://zlib.net/feldspar.html">DEFLATE compression algorithm</a>. DEFLATE is also used with <a href="https://en.wikipedia.org/wiki/Gzip">gzip</a> and <a href="https://en.wikipedia.org/wiki/ZIP_(file_format)">ZIP</a>, two very popular compression formats.</p><p>I won’t go in depth on DEFLATE here (in part because I am not an expert<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>), but here’s what our chunk’s data contains:</p><ol><li>The zlib header: 2 bytes</li><li>One compressed DEFLATE block that encodes two literal zeroes<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>: 4 bytes</li><li>The zlib checksum (this is separate from the PNG chunk checksum!): 4 bytes</li></ol><p>For more on how DEFLATE works, check out <a href="https://zlib.net/feldspar.html">“An Explanation of the DEFLATE Algorithm”</a>. I also recommend <a href="https://github.com/madler/infgen/">infgen</a>, a useful tool for inspecting DEFLATE streams.</p><p>All together, here are the ten data bytes:</p><pre><code>78 01 63 60 00 00 00 02 00 01
</code></pre><p>Again, unfortunate that we had to run our two-byte scanline through an algorithm that made it <em>five times bigger</em>, but PNG makes us do it!</p><p>With that, we can compute the PNG’s checksum field and finish off the chunk.</p><table><thead><tr><th>Bytes</th><th>What?</th></tr></thead><tbody><tr><td><code>00 00 00 0A</code></td><td>data length of 10 bytes</td></tr><tr><td><code>49 44 41 54</code></td><td>“IDAT” as ASCII</td></tr><tr><td><code>78 01</code></td><td>zlib header</td></tr><tr><td><code>63 60 00 00</code></td><td>“compressed” DEFLATE block</td></tr><tr><td><code>00 02 00 01</code></td><td>zlib checksum</td></tr><tr><td><code>73 75 01 18</code></td><td>chunk checksum</td></tr></tbody></table><p>Just one more chunk to go! Taking a final look at our checklist before everything is crossed off:</p><ol><li><del>PNG signature</del></li><li><del>Image metadata chunk</del></li><li><del>Pixel data chunk</del></li><li>“End of image” chunk</li></ol><p>Let’s finish this up.</p><h2 id="part-4-the-end">Part 4: the end</h2><p>Poetically, PNGs end like they begin: with a small number of constant bytes.</p><p><strong>IEND</strong> is the final chunk, short for <a href="https://www.w3.org/TR/2022/WD-png-3-20221025/#11IEND">“image trailer”</a>.</p><p>The zero length is encoded with 4 zeroes:</p><pre><code>00 00 00 00
</code></pre><p>“IEND” is then encoded:</p><pre><code>49 45 4E 44
</code></pre><p>There’s no data in IEND chunks, so we just move onto the checksum. Because everything else in the chunk is constant, this checksum is always the same:</p><pre><code>AE 42 60 82
</code></pre><p>Here’s the whole trailer chunk:</p><table><thead><tr><th>Bytes</th><th>What?</th></tr></thead><tbody><tr><td><code>00 00 00 00</code></td><td>data length of 0</td></tr><tr><td><code>49 45 4E 44</code></td><td>“IEND” as ASCII</td></tr><tr><td><code>AE 42 60 82</code></td><td>checksum</td></tr></tbody></table><p>And our PNG is done!</p><h2 id="admiring-our-work">Admiring our work</h2><p>Here it is one more time, scaled up 200×:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQAAAAA3bvkkAAAACklEQVR4AWNgAAAAAgABc3UBGAAAAABJRU5ErkJggg==" width="200" height="200" alt="A single black pixel."/></p><p>Beautiful. It starts with the classic PNG signature, follows up with a bit of metadata, “compresses” the pixel data, and signs off with an empty chunk.</p><p>And that’s the world’s smallest PNG!</p><p>…or is it?</p><h2 id="the-twist-there-are-lots-of-champions">The twist: there are lots of champions</h2><p>Throughout this post, I’ve said that this is the world’s smallest PNG. But that’s not quite true: it’s <em>tied</em> for first. There are several “world’s smallest PNGs”!</p><p><em>As long as we encode all pixel data in a single byte, we can tie for the world’s smallest PNG.</em></p><p>For example, you could encode this 8×1 black image, which is also 67 bytes:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABAQAAAADLe9LuAAAACklEQVR4AWNgAAAAAgABc3UBGAAAAABJRU5ErkJggg==" width="400" height="50" alt="A black rectangle, 8 pixels wide and 1 pixel tall."/></p><p>This works because we use all eight bits are used to encode pixel data.</p><p>With our 1×1 image, recall that seven bits were effectively “wasted” on padding. Here’s basically what happened:</p><table><thead><tr><th>Bits</th><th>What?</th></tr></thead><tbody><tr><td><code>0</code></td><td>a black pixel</td></tr><tr><td><code>0000000</code></td><td>padding</td></tr></tbody></table><p>An 8×1 image can encode eight black pixels like so:</p><table><thead><tr><th>Bits</th><th>What?</th></tr></thead><tbody><tr><td><code>00000000</code></td><td>eight black pixels</td></tr></tbody></table><p>Instead of adding more pixels, you could also add more color resolution. Many grey colors can be encoded in a single byte, letting us tie for first. For example, this 1×1 grey pixel is also 67 bytes:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAAAAAA6fptVAAAACklEQVR4AWOwBQAAPwA+Eq7IEAAAAABJRU5ErkJggg==" width="100" height="100" alt="A single grey pixel."/></p><p>Again, this “uses up” the whole byte we have available, unlike our 1×1 image.</p><p>For more on this, my former coworker Jordan Rose published <a href="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/">“The Biggest Smallest PNG”</a> in response to this post. It shows the biggest 67-byte PNG: a 1×2064 black line.</p><h2 id="summary">Summary</h2><p>PNGs start with a “signature”. The rest of the file is made up of chunks. Each chunk has a length, type, data, and checksum. Some chunks are always required, like the image header (IHDR) chunk.</p><p>The smallest PNGs use the minimum number of chunks and the smallest possible data.</p><p>Our PNGs are made up of four parts:</p><ol><li>The constant PNG signature (8 bytes)</li><li>The IHDR chunk, containing metadata (25 bytes)</li><li>The IDAT chunk, image pixel data (22 bytes)</li><li>The IEND chunk, an image trailer (12 bytes)</li></ol><p>If you’re interested in learning more about PNGs interactively, I built <a href="https://evanhahn.gitlab.io/png-explorer/">PNG Chunk Explorer</a>, which lets you analyze PNGs. Try uploading your own images to see what they’re made of! (It doesn’t work well on mobile, apologies.)</p><p>I also built <a href="https://singlecolorimage.com/">Single Color Image</a>, which generates monochromatic PNGs of arbitrary sizes. For example, you could generate a 12×34 purple rectangle. The images should be small but I haven’t yet implemented the most sophisticated compression, so you might need to run its results through a PNG compressor to achieve the smallest sizes.</p><p>Finally, I also wrote about the <a href="https://evanhahn.com/largest-possible-png/"><em>largest</em> possible PNG</a>. There’s no theoretical file size limit, but there is a maximum number of pixels, and many decoders impose various limits.</p><p>I hope this long post has given you a good understanding of the PNG file format. If you read this far and have anything to say, <a href="https://evanhahn.com/contact/">let me know</a>!</p></div></div>
  </body>
</html>
