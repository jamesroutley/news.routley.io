<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/">Original</a>
    <h1>We used C&#43;&#43;20 to eliminate a class of runtime bugs</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                
         <div><div><div><p><img alt="" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2020/09/Cameron-DaCamara-150x150.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFElEQVQ4jWNgGAWjYBSMglFATwAABXgAAfmlXscAAAAASUVORK5CYII=" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2020/09/Cameron-DaCamara-150x150.png 2x" height="58" width="58"/></p><p>Cameron</p></div></div></div>     
        <p>
            January 13th, 2022            </p><!-- .entry-meta -->

        
<p>C++20 is here and has been supported in MSVC since <a href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">16.11</a>, but today’s post is not about how you can use it, but rather how <em>we</em> used it to effectively eliminate an entire class of runtime bugs by hoisting a check into compile-time. Let’s get right into it!</p>
<h4><span id="humble-beginnings">Humble beginnings</span></h4>
<p>In compiler design one of the very first things you need is a way to convey to the programmer that their source code has an error or warn them if their code might not behave as expected. In MSVC our error infrastructure looks something like this:</p>
<pre>enum ErrorNumber {
    C2000,
    C2001,
    C2002,
    ...
};
void error(ErrorNumber, ...);</pre>
<p>The way <code>error</code> works is that each <code>ErrorNumber</code> has a corresponding string entry which represents the text we want to display to the user. These text strings can be anything from: <code>C2056 -&gt; &#34;illegal expression&#34;</code> to: <code>C7627 -&gt; &#34;&#39;%1$T&#39;: is not a valid template argument for &#39;%2$S&#39;&#34;</code>, but what are these <code>%1$T</code> and <code>%2$S</code> things? These are some of the compiler’s format-specifiers to display certain types of structures in the compiler to the user in a readable way.</p>
<h4><span id="double-edged-sword">The double-edged sword of format-specifiers</span></h4>
<p>Format-specifiers provide a lot of flexibility and power to us as compiler developers. Format-specifiers can more clearly illustrate why a diagnostic was issued and provide the user with more context into the problem. The problem with format-specifiers is that they are not type checked in the call to <code>error</code>, so if we happen to get an argument type wrong or did not pass an argument at all it will almost certainly end up in a runtime error later for the user. Other problems arise when you want to refactor a diagnostic message into something clearer, but to do that you need to query every caller of that diagnostic message and ensure that the refactor agrees with the arguments being passed to <code>error</code>.</p>
<p>We have three high-level goals when designing a system that can check our format-specifiers:</p>
<ol>
<li>Validate that argument types passed into our diagnostic APIs at compile-time so authoring a mistake is caught as early as possible.</li>
<li>Minimize changes made to callers of diagnostic APIs. This is to ensure well-formed calls retain their original structure (no disruption to future calls as well).</li>
<li>Minimize changes made to implementation details of the callee. We should not change the behavior of the diagnostic routines at runtime.</li>
</ol>
<p>There are, of course, some solutions introduced with later C++ standards which could aid in trying to remedy this problem. For one, once variadic templates were introduced into the language we could have tried some template metaprogramming to try and type check the calls to <code>error</code>, but that would require a separate lookup table since constexpr and templates were limited in what they could do. C++14/17 both introduced a lot of improvements to constexpr and non-type template arguments. Something like this would work great:</p>
<pre>constexpr ErrorToMessage error_to_message[] = {
    { C2000, fetch_message(C2000) },
    { C2001, fetch_message(C2001) },
    ...
};

template &lt;typename... Ts&gt;
constexpr bool are_arguments_valid(ErrorNumber n) {
    /* 1. fetch message
       2. parse specifiers
       3. check each specifier against the parameter pack Ts... */
    return result;
}</pre>
<p>So we finally had the tools to try and check the format-specifiers at compile-time. But there was still a problem: we still did not have a way to silently check all the existing calls to <code>error</code> meaning that we would have to add an extra layer of indirection between the call sites of <code>error</code> to ensure that the <code>ErrorNumber</code> could fetch the string at compile-time and check the argument types against it. In C++17 this will not work:</p>
<pre>template &lt;typename... Ts&gt;
void error(ErrorNumber n, Ts&amp;&amp;... ts) {
    assert(are_arguments_valid&lt;Ts...&gt;(n));
    /* do error stuff */
}</pre>
<p>And we cannot make <code>error</code> itself constexpr because it does a lot of constexpr-unfriendly things. Additionally, adjusting all the call sites to something like: <code>error&lt;C2000&gt;(a, b, c)</code> so that we can check the error number as a compile-time expression is unsavory and would cause a lot of unnecessary churn in the compiler.</p>
<h4><span id="cpp20">C++20 to the rescue!</span></h4>
<p>C++20 introduced an important tool for us to enable compile-time checking, <code>consteval</code>. <code>consteval</code> is in the family of constexpr but the language guarantees that a function adorned with <code>consteval</code> will be evaluated at compile-time. A well-known library by the name of <a href="https://github.com/fmtlib/fmt">fmtlib</a> introduced compile-time checking as part of the <a href="https://fmt.dev/latest/api.html#core-api">core API</a> and it did so without changing any call sites, assuming the call site was well-formed according to the library. Imagine a simplified version of <code>fmt</code>:</p>
<pre>template &lt;typename T&gt;
void fmt(const char* format, T);

int main() {
    fmt(&#34;valid&#34;, 10);    // compiles
    fmt(&#34;oops&#34;, 10);     // compiles?
    fmt(&#34;valid&#34;, &#34;foo&#34;); // compiles?
}</pre>
<p>Where the intent is that <code>format</code> should always be equal to <code>&#34;valid&#34;</code> and <code>T</code> should always be an <code>int</code>. The code in <code>main</code> is ill-formed according to the library in this case, but nothing validates that at compile-time. fmtlib accomplished compile-time checking using a little trick with user-defined types:</p>
<pre>#include &lt;string_view&gt;
#include &lt;type_traits&gt;

// Exposition only
#define FAIL_CONSTEVAL throw

template &lt;typename T&gt;
struct Checker {
    consteval Checker(const char* fmt) {
        if (fmt != std::string_view{ &#34;valid&#34; }) // #1
            FAIL_CONSTEVAL;
        // T must be an int
        if (!std::is_same_v&lt;T, int&gt;)            // #2
            FAIL_CONSTEVAL;
    }
};

template &lt;typename T&gt;
void fmt(std::type_identity_t&lt;Checker&lt;T&gt;&gt; checked, T);

int main() {
    fmt(&#34;valid&#34;, 10);    // compiles
    fmt(&#34;oops&#34;, 10);     // fails at #1
    fmt(&#34;valid&#34;, &#34;foo&#34;); // fails at #2
}</pre>
<p>Note: you need to use the <code>std::type_identity_t</code> trick to keep <code>checked</code> from participating in type deduction. We only want it to deduce the rest of the arguments and use their deduced types as template arguments to <code>Checker</code>.</p>
<p>You can fiddle with the example for yourself using <a href="https://godbolt.org/z/baPvojah1">Compiler Explorer</a>.</p>
<h4><span id="tying-it-together">Tying it all together</span></h4>
<p>The code above is powerful in that it gives us a tool which can perform additional safety checking without changing any caller which is well-formed. Using the technique above we applied compile-time checking to all our <code>error</code>, <code>warning</code>, and <code>note</code> message routines. The code used in the compiler is nearly identical to the <code>fmt</code> above except that the argument to <code>Checker</code> is an <code>ErrorNumber</code>.</p>
<p>In total we identified <b>~120</b> instances where we were either passing the incorrect number of arguments to a diagnostic API or where we passed the wrong type for a particular format-specifier. Over the years we have received bugs regarding strange compiler behavior when emitting a diagnostic or a straight-up ICE (Internal Compiler Error) because the format-specifiers were looking for arguments which were incorrect or did not exist. Using C++20 we have largely eliminated possibility of such bugs happening in the future and while offering the ability for us to safely refactor diagnostic messages, made possible by one little keyword: <code>consteval</code>.</p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
        
        

		        
        
        <div>

        <p><img alt="" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2020/09/Cameron-DaCamara-150x150.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFElEQVQ4jWNgGAWjYBSMglFATwAABXgAAfmlXscAAAAASUVORK5CYII=" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2020/09/Cameron-DaCamara-300x300.png 2x" height="96" width="96"/></p>
            
        
       </div>
        
	</div><!-- .entry-content -->
    
    </div></div>
  </body>
</html>
