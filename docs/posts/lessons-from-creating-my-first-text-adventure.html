<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/lessons-from-creating-first-text-adventure">Original</a>
    <h1>Lessons from creating my first text adventure</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
When I write about <a href="https://entropicthoughts.com/the-greatness-of-text-adventures.html">the greatness of text adventures</a>, I pretend they are easy to
make. They are, compared to many other types of games, but it’s still a bit of a
lie. They’re hard to make.
</p>

<p>
I made one and submitted it to ParserComp 2025, and here’s what I learned.
</p>
<section id="outline-container-my-first-text-adventure--lockout">

<div id="text-orge845687">

<p><img src="https://xkqr.org/if/lockout/lockout.jpg" alt="lockout.jpg"/>
</p>

<p>
Since ParserComp voting has opened, the game is now public, and <a href="https://iplayif.com/?story=https%3A%2F%2Fxkqr.org%2Fif%2Flockout%2Flockout.zblorb">you can play it
in your browser</a>. The game itself reveals what it is about as you progress, so I
won’t write too much about it here. You should be able to finish it in 30–60
minutes. Don’t feel bad about needing hints, especially if you’re new to text
adventures.
</p>

<p>
<i>Lockout</i> is my third attempt at making a text adventure. The first two failed
because of ambition.
</p>
</div>
</section>
<section id="outline-container-scope-and-richness-of-world-modeling">

<div id="text-org3bf04ac">
<p>
It’s very easy to accidentally try to create too large a text adventure. My
first attempt was way too ambitious, and would have taken months to finish. I
still love the idea for that, but it had to go. I picked another idea that was
much smaller in scope, but it, too, grew too ambitious. I restarted one more
time, from an idea that was even more pared down, and I was actually able to
finish that game. With the minimalistic scope it took maybe fifteen hours of
active work to create most of the game, and then almost as much time again to
fix the 57 problems I received feedback on from beta testers.<span><sup>1</sup> This is a
large time investment for me, which makes it unlikely I’ll create another one
any time soon, even if I’d really like to.</span>
</p>

<p>
Scope in text adventures is complicated, because there are two dimensions along
which scope can vary: breadth and detail.
</p>

<ul>
<li>A broad game might have many locations, items, and events, but each is
relatively sparsely implemented. Actions get generic responses, and items are
mainly generic scenery without interesting interactions. This is the style of
some of the earliest text adventures; they had to do it that way due to
technical limitations of the time.</li>

<li>A detailed game might have few locations, items, and events, but those that do
exist are modeled in high detail and interact realistically with each other.
Modern development tools afford insane levels of detail, and it’s up to the
author to set a reasonable limit to the detail included.</li>
</ul>

<p>
<i>Lockout</i> is in the narrow-but-detailed category. Making a broad <i>and</i>
detailed game takes a huge effort, so for the hobbyist it boils down to finding
the right tradeoff between breadth and detail.
</p>

<p>
For better or worse, the community encourages detailed games, and among modern
games, a text adventure that is broad and not detailed stands out as lacking in
implementation. A useful comparison to study this difference is <a href="https://scottandrew.com/blog/2025/06/you-can-now-play-plot-of-the-phantom-the-text-adventure-game/"><i>The Plot of the
Phantom</i></a>: a newly released game which was designed in the 1980’s, but
implemented using modern tools. It contrasts with <i>Lockout</i> in that it is mainly
in the broad-and-sparse camp, as the following interactions illustrate.
</p>

<blockquote>
<p>
CAVE ENTRANCE
</p>

<p>
You stand at the base of a sandstone cliff, at the mouth of a large cave. Behind
you to the south, a misty Appalachian forest stretches in all directions. A
weathered sign made of pressure-treated lumber and painted in the style of
National Park signage stands to the right of the cave entrance.
</p>

<p>
The cave entrance is to the north.
</p>
</blockquote>

<p>
Oh, wow, what sort of cave is this? <b>&gt; look at cave</b>
</p>

<blockquote>
<p>
You can’t see any such thing.
</p>
</blockquote>

<p>
Huh. Well, what can I find in the direction I came from? <b>&gt; go south</b>
</p>

<blockquote>
<p>
You can’t go that way.
</p>
</blockquote>

<p>
Why not? I suppose what remains is to enter the cave. <b>&gt; enter cave</b>
</p>

<blockquote>
<p>
You can’t see any such thing.
</p>
</blockquote>

<p>
Oh right, the cave doesn’t exist in the world, only in the description. Maybe I
have to go inside. <b>&gt; go in</b>
</p>

<blockquote>
<p>
You can’t go that way.
</p>
</blockquote>

<p>
I could have sworn … I guess I’ll go north to enter. <b>&gt; go north</b>
</p>

<blockquote>
<p>
LARGE CAVERN
</p>

<p>
You step into a large open space, a cavern created by seeping
groundwater dissolving the sandstone over many decades. The sandy floor is
strewn with rocks and the damp ceiling hangs low, just a foot or two above your
head.
</p>

<p>
You’re not the first to find this place. Crumpled beer cans and cigarette butts
are everywhere, and the cold, blackend remains of a firepit sit in the cavern
center, and the eastern wall is blanketed with a remarkable amount of
multicolored graffiti.
</p>

<p>
To the north, a passage disapppears into the rock, while to the west you can see
a hole just barely wide enough to crawl through.
</p>
</blockquote>

<p>
I’m worried about the safety of the ceiling. Can I get more information? <b>&gt; look
at ceiling</b>
</p>

<blockquote>
<p>
You can’t see any such thing.
</p>
</blockquote>

<p>
That’s odd. Let’s take some stuff we found here before we move on. <b>&gt; get beer cans and cigarettes</b>
</p>

<blockquote>
<p>
That’s hardly portable.
</p>
</blockquote>

<p>
This goes on for the rest of <i>The Plot of the Phantom</i>. There are a lot of things that appear to
exist, but when the player tries to examine them, they aren’t really there, or
they behave in unexpected ways.
</p>

<p>
Don’t get me wrong! I finished <i>The Plot of the Phantom</i> and I had a lot of fun
with it. You can make sparse games fun. However, this sort of sparsity does tend
to annoy modern players. One of the reasons is that when there are four hundred
objects mentioned in the game, but only forty of them actually exist in the game
world, the player can easily miss vital clues because they stop examining
things, having grown tired of the stock “You can’t see any such thing”
response.<span><sup>2</sup> Another common example of beta testing criticism is when the
player is given e.g. a matchbox and is somehow able to stuff something like a
keyboard inside it. The matchbox is technically a container and can contain
things, but a detailed world model will prevent the player from inserting large
things into small things. A sparse world model will not care.</span>
</p>

<p>
Detailed world models are more fun for the player, but harder for the developer.
The complexity of the implementation scales multiplicatively thanks to
interactions. When we add another item, we have to account for how it interacts
with everything else already in the game. When we add another action the player
can perform, we now have to contend with the fact that the player might perform
that action on every single object we already have in the game.<span><sup>3</sup> My first
attempt at making a text adventure included the ability of levitation! It’s a
great mechanic that can be used creatively, but it can also be exploited to skip
a lot of puzzles and enter restricted areas unless the rest of the game is very
carefully designed around it.</span>
</p>
</div>
<div id="outline-container-scope-can-be-measured-in-locations">
<h2 id="scope-can-be-measured-in-locations">Scope can be measured in locations</h2>
<div id="text-org229d1f8">
<p>
Text adventure complexity used to be measured in number of objects, going back
to the time when primary memory was the main limiting factor in how complex text
adventures could become. The most popular text adventure system of the 1980’s
were limited to 256 objects, where locations also count as objects, as well as
some things like directions. In practice, these games typically had
</p>

<ul>
<li>80-ish locations,</li>
<li>40-ish significant objects, and</li>
<li>100-ish scenery objects.</li>
</ul>

<p>
The rest of the object budget was used for housekeeping, directions, etc.
</p>

<p>
Infocom, a highly influential developer of text adventures, released 34 games
over their most active decade. These games had a total of about 2800 locations.
I don’t have exact employment numbers, but let’s say they had 70–100
implementer-years over that decade. This works out to maybe 2300–4000
implementer-weeks, accounting for various inefficiencies and lossages along the
way. In the end, that gets us an estimation of effort at 30–60 implementer-hours
per location, which – satisfyingly – matches my experience with the
single-location <i>Lockout</i>.<span><sup>4</sup> Although it should be said that I have the
benefit of modern tooling, so they certainly had to accomplish more with their
time.</span>
</p>

<p>
On the one hand, the 1980’s density of two interactable objects per location is
a little low for a modern game, but on the other hand we have modern tooling, so
maybe the two cancel out: we can build more detailed games at less effort,
giving us similar development times for similar location counts. This means we
can pick how many hours we’re willing to spend on making a text adventure, and
count backwards to how many locations we’ll be able to make in that time. That’s
useful for scoping a design.<span><sup>5</sup> It also reveals how expensive creating text
adventures can be: If we, as hobbyists, can spend a couple of hours three days a
week on it, a relatively small ten-location game will take as long as a human
pregnancy! That said, someone who is more experienced is probably going to be
able to go much faster with modern tooling. I have heard some people are able to
make text adventures as fast as one hour per location, although I suspect these are
for speed competitions and will take a few more hours per location to flesh out.</span>
</p>

<p>
Selecting a small enough scope and managing to design a fun game around it is
probably one of the most difficult aspects of text adventure design, with the
caveat that I’m not the right person to talk to about design, since I’m a
terrible game designer, and I’ve only just dipped my toes into the world of
making text adventures anyway.
</p>

<p>
I think one of my key realisations making text adventures is that they are a
form of simulated world, in which the player is relatively free to act according
to their will – and often the solution to puzzles comes out of this freedom, so
players expect the world to react faithfully to their freedom. But
<i>simultaneously</i> with the above, the simulated world does not exist: all the
developer has to do is to present to the player words that make the player
willing to imagine that the world exists.
</p>
</div>
</div>
</section>
<section id="outline-container-technical-challenges">

<div id="text-org5d7f3e2">
<p>
Beyond the issue of good game design, there are technical challenges related to
presenting words such that the player is willing to imagine. I can think of
three:
</p>

<ol>
<li>Making a conventional parser, i.e. the bit of the game that reads the
player’s commands and turns them into in-game actions;</li>

<li>Generating text that is grammatically sensible when different objects are
spliced into templates; and</li>

<li>Creating a consistent world model that governs interactions between items and
actors.</li>
</ol>

<p>
We briefly touched world modelling already, and much of it is about good game
design more generally. I’m the wrong person to talk about that. Let’s just say
that the world model does not have to be realistic, but it has to be consistent.
If one part of the game requires the player to <code>LICK STAMP</code> then the player
should also get a reasonable response when they try to <code>LICK APPLE</code>. A standard
“that is not something you can do” response shatters immersion. If there’s a hat
and a coat rack, should the player be able to hang the hat on the coat rack,
even if that does not fill any function in the game? In a detailed world model,
sure.
</p>

<p>
Let’s speak more about the parser and text generation.
</p>
</div>
<div id="outline-container-a-conventional-parser">
<h2 id="a-conventional-parser">A conventional parser</h2>
<div id="text-orgd0cff98">
<p>
Someone who has not played text adventures before are likely to struggle at the
prompt. It might play out like
</p>

<p>
<b>&gt; I’d like to try knocking again</b>
</p>

<blockquote>
<p>
That’s not a verb I recognise.
</p>
</blockquote>

<p>
<b>&gt; Look around.</b>
</p>

<blockquote>
<p>
You can’t see any such thing.
</p>
</blockquote>

<p>
<b>&gt; How do I get out?</b>
</p>

<blockquote>
<p>
That’s not a verb I recognise.
</p>
</blockquote>

<p>
The openness of the prompt breeds confusion and frustration. It tricks beginners
into thinking the game speaks English, but of course, the game does not speak
English. The game speaks a specific conventional language that looks like
English when squinting. These are all commands that could work:
</p>

<pre id="org208f9a2">SMELL
EXAMINE DOOR
TAKE SCREWDRIVER
HIT COMPUTER WITH KEYBOARD
SWING ON ROPE
DROP ALL TOOLS BUT HAMMER
</pre>

<p>
Parsers typically ignore articles, so there’s no difference between <code>TAKE
SCREWDRIVER</code> and <code>TAKE THE SCREWDRIVER</code>. The pattern behind the commands above
are that they consist of an action (a verb phrase, like <code>SMELL</code> or <code>SWING ON</code>),
optionally followed by a subject (like <code>COMPUTER</code> or <code>DOOR</code>). Sometimes they
take an additional object after a <code>WITH</code> modifier (like <code>WITH KEYBOARD</code>).
</p>

<p>
Modern parsers understand that <code>ALL TOOLS BUT HAMMER</code> is a meaningful
description of a set of objects. They will look in your inventory, find all the
things that are tools, and then remove the hammer from that set before dropping
them.
</p>

<p>
A player may also expect to be able to chain commands together, and refer to
items in earlier commands, such as typing
</p>

<pre id="org2a9b586">EXAMINE SCREWDRIVER. TAKE IT.
</pre>

<p>
and having both actions play out. Writing this kind of parser is non-trivial, to
say the least.
</p>
</div>
</div>
<div id="outline-container-text-generation">
<h2 id="text-generation">Text generation</h2>
<div id="text-orgfe496da">
<p>
English is full of weird rules. The parser can get away with ignoring them by
not really speaking English, but the text presented to the user does not have
the same luxury. If we have a template string that indicates someone stands
quiet when spoken to, we need it to generate the article in “The guard stands
quiet”, but it must not also generate “The Monica stands quiet”.
</p>

<p>
A text generation system, then, must know some basics about how to form
grammatically valid English sentences. It needs to know about plurals, proper
names, articles, pronouns, etc. Writing that kind of system is perhaps easier
than a parser, but still not a walk in the park.
</p>
</div>
</div>
<div id="outline-container-text-adventure-making-environments">
<h2 id="text-adventure-making-environments">Text adventure-making environments</h2>
<div id="text-orga9f740a">
<p>
Text adventures are superficially simple. Anyone with some rudimentary Python
knowledge could make one! But the above technical challenges make this less than
desirable. It’s as they say: if you want to make a game engine, feel free to.
But if you want to make a game, use someone else’s engine.
</p>

<p>
There are three popular, mature programming environments for making text
adventures: <i>Inform 6</i>, <i>Inform 7</i>, and <i><abbr>tads</abbr> 3</i>. These come with a
conventional parser, powerful text generation tools, and they have a primitive
but consistent world model built in by default: out of the box, they understand
actors can move around and perform actions, objects stay where they are dropped,
some objects are fixed in place, containers can have objects inside them, etc.
</p>

<p>
Both Inform 6 and <abbr>tads</abbr> 3 are more traditional object-oriented languages. I
have played with Inform 7, because I was intrigued by its model of computation.
</p>
</div>
</div>
</section>
<section id="outline-container-inform-7">

<div id="text-org810b796">
<p>
The fundamental units of Inform 7 code are
</p>

<ul>
<li>Rules, which are lists of instructions that should be executed in response to
events. Rules can prevent further rules from running.</li>
<li>Actions, which are attempts by actors to manipulate the world, leading to
sequences of events being fired off.</li>
<li>Filters (I don’t know their real name) which determine when rules apply.</li>
<li>Properties, which characterise objects and serve as the state of the game
world.</li>
<li>Relationships, which characterise how objects relate to each other. These form
a sort of graph for which there are manipulation utilities in the standard
libraries, e.g. pathfinding.</li>
</ul>

<p>
I’m not very good at Inform 7 yet, but I have a vague sense that this paradigm
is actually really powerful and could be used to good effect for other types of
software too, but I’m early in my explorations of it. One of the co-inventors of
Inform 7 has described <a href="http://brasslantern.org/writers/iftheory/i7observations.html">her early experience with the paradigm</a>.
</p>

<p>
Inform 7 is a little hard to learn, because nobody sits down and explains its
model of computation, nor the syntax. People are assumed to learn by
copy-pasting and tweaking examples, and I’m not that sort of person anymore. I
want to try to understand first and do later.
</p>

<p>
The syntax of Inform 7 is often the thing people react to first. Here’s an
excerpt from a popular Inform 7 library which handles keys and doors a little
more intelligently than the default.
</p>

<p><label>In[1]:</label></p><div>
<pre>A keychain is a kind of supporter that is portable.

Instead of putting something which is not a passkey on a keychain
(this is the limiting keychains rule):
    say &#34;[The noun] [are] not a key.&#34; (A).

The keychain-aware carrying requirements rule is listed instead
    of the carrying requirements rule
      in the action-processing rules.

This is the keychain-aware carrying requirements rule:
    if locking or unlocking something with something
      which is on a keychain which is carried by the actor:
        continue the action;
    abide by the carrying requirements rule.
</pre>
</div>

<p>
Yes, that looks like English. No, it is not English. For some people, this
syntax is a big deal, either because they find it easy to read, or difficult to
write, or both. I’m not one to care much about syntax, but I will say this style
of syntax does make it a little more difficult to learn the language.<span><sup>6</sup> There
are these subtle variations on phrasing that sometimes matter a lot and
sometimes don’t matter at all, which make the first few days of learning really
frustrating. For example <code>now the chest is not open</code> is a valid statement, as is
<code>now chest is closed</code>, but not <code>the chest is now closed</code>. To update a property
of an object, we must use specifically the syntax <code>now &lt;object&gt; is &lt;property&gt;</code>,
where the article “the” is optional, and “closed” is an automatically-derived
synonym for “not open”. Things you just have to know.</span>
</p>

<p>
The rules, properties, and relationships systems of Inform 7 are very powerful.
When used properly, these give us the ability to construct complex systems out
of simple pieces, with the programming environment itself filling in many of the
blanks. On the other hand, it is also easy to misuse Inform 7, and focus on the
concrete rather than the specific. I wish I could give good examples here, but
I’m just not skilled enough with Inform 7 to do that. I just know that in the
process of making <i>Lockout</i>, I ended up duplicating a lot of code that could
have been handled more generally, with fewer bugs to boot.
</p>
</div>
<div id="outline-container-learning-the-language-and-troubleshooting">
<h2 id="learning-the-language-and-troubleshooting">Learning the language and troubleshooting</h2>
<div id="text-org19b290f">
<p>
The documentation for Inform 7 is not great. It’s effectively a long cookbook
with small examples for specific mechanics. The examples are good, but it’s hard
to find what one is looking for. Jim Aikin’s <a href="https://www.musicwords.net/if/I7_Handbook_3.pdf">Inform 7 Handbook (<abbr>pdf</abbr>)</a> does a
slightly better job of introducing the language<span><sup>7</sup> Note that this is version 3
– when you search the web for it you run a large risk of getting version 2.</span>,
but I’m still missing an “Inform 7 the Hard Way” guide that starts from the core
fundamentals.<span><sup>8</sup> But why don’t you write it, kqr? Because I’m not yet good
enough at the language to. Maybe if I stick with this for another year I can do
that.</span> There is also <a href="https://zedlopez.github.io/i7doc/i7prog/index.html">Inform 7 For Programmers</a> by Ron Newcomb but it seems a
little confusingly structured for me too – it starts talking about computation
(functions and variables) which are not the most important parts of Inform 7
code. At least not as far as I’ve been able to tell. More recently, I’ve also
come across <a href="https://catn.decontextualize.com/inform7/">Inform 7 Concepts and Strategies</a> which is in the direction I want,
but too short and shallow, and lacking in examples showcasing the variety of
functionality possible with the fundamentals.
</p>

<p>
Another key source of language knowledge comes from the built-in debugging
commands. <code>SHOME APPLE</code> prints details of an object. <code>SHOWVERB KICK</code> helps
figure out what is triggered by a particular command. <code>ACTIONS</code> turns on
explicit printing of implicit action conversions, such as when e.g. <code>LOOK UNDER</code>
triggers a <code>SEARCH</code> action. For maximum verbosity, the <code>RULES</code> debug command
turns on explicit printing of every rule that gets evaluated in response to an
event. This can help pinpoint why things are printed the way they are.
</p>

<p>
Once we have found something interesting using the above debug commands, we
might want to find out how that thing was created. We can get at this through
the index in the <abbr>ide</abbr> somehow, but easier is searching <a href="https://zedlopez.github.io/standard_rules/">the <abbr>html</abbr> dump of the
<i>Standard Rules</i></a> provided by Zed Lopez. These are the full standard libraries
that run by default in all Inform 7 projects, unless they are explicitly
disabled.
</p>

<p>
There are extensions to Inform 7. If the standard rules are like the standard
library, then extensions are like third-party libraries; these add generic
functionality and simulation we might want in our games. The most popular ones
are available at the <a href="https://i7.github.io/extensions/">Friends of I7 Extensions listing</a>.
</p>

<p>
With some luck, our syntax questions might be answered by <a href="http://www.ifarchive.org/if-archive/infocom/compilers/inform7/manuals/Inform7_CheatSheet.pdf">the Inform 7
cheatsheet</a> made by Mark-Oliver Reiser.
</p>
</div>
</div>
</section>
<section id="outline-container-publishing-a-text-adventure">

<div id="text-org967ca5d">
<ul>
<li>testing builds</li>
<li>publishing to comps</li>
<li>ifdb</li>
</ul>
</div>
</section>

            </div></div>
  </body>
</html>
