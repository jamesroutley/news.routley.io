<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://peter.horne-khan.com/relaxed-radix-balanced-trees/">Original</a>
    <h1>Relaxed Radix Balanced Trees (2024)</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-tnnyocjb="">    <p>I’m adding immutable vectors to my language, Ivan, and needed to pick a suitable data structure to implement them. Clojure uses Persistent Vectors (PVs) which support lookups, updates, and appends all in ‘effectively’ constant time. However, it doesn’t have efficient insert or merge operations. Relaxed Radix Balanced (RRB) Trees, introduced by Bagwell and Rompf in 2011, address this shortcoming.</p>
<p>I had to read a few different papers to properly understand how they worked so I thought I’d write an introduction in the hope of making it a tad easier for others. I’ll try to convey how they work and some intuition for why, while leaving the deeper mathematical treatment to the academic papers.</p>
<p>I will assume you’re already familiar with <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">how Persistent Vectors work</a>.</p>
<h2 id="merging-persistent-vectors">Merging Persistent Vectors</h2>
<p>Let’s suppose we merge two Persistent Vectors, giving us the following result:</p>
<img src="https://peter.horne-khan.com/_astro/figure-1.C0izVYEa_Z6UaAU.svg" alt="Merging 2 Persistent Vectors" width="751" height="91" loading="lazy" decoding="async"/>
<p>Since we rely on a fixed node size (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span>) for radix search to work, we must ensure that every node (except the right edge) has <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> children. A tree with this property is said to be <em>leftwise dense</em>. In this example, since the last child of the left vector only has 2 elements we must move 2 elements over from the right vector. Doing so imbalances the first child node of the right vector, so we must repeat the process with its subsequent children until all nodes are balanced. This process involves creating many new replacement nodes (shown in orange). The work that needs to be done is proportional to the size of the right vector.</p>
<h2 id="relax">Relax</h2>
<p>We need to relax the leftwise dense constraint, but doing so will introduce two problems:</p>
<ol>
<li>Radix search relies on each node having the same fixed branching factor.</li>
<li>The height of the tree, which is what lets us claim ‘effectively’ constant operations, is bounded by the fixed branching factor.</li>
</ol>
<p>The first problem can be overcome by recording the actual size of nodes somewhere. We’ll add a <em>size table</em> to each branch – an array with a length equal to the number of children contained in that node. Each entry in the size table records the <em>cumulative</em> number of elements contained in the corresponding child node, which we’ll refer to as a <em>slot</em>.</p>
<img src="https://peter.horne-khan.com/_astro/figure-2.UQI5iB4R_16LP2R.svg" alt="RRB Tree with size tables" width="591" height="151" loading="lazy" decoding="async"/>
<p>In this example, the root node has two children and we can see from the associated size table that the first child contains 14 elements, while the second contains 8 (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>22</mn><mo>−</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">22 - 14</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>22</span><span></span><span>−</span><span></span></span><span><span></span><span>14</span></span></span></span>). Since we can now derive the range of elements contained within each slot, finding an element is fairly straightforward. Suppose we wanted to retrieve the element at index position <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>16</span></span></span></span>:</p>
<ol>
<li>Starting at the root, the element we are searching for will be contained within the first slot that has a corresponding entry in the size table greater than the index we are looking up. In this case, we skip the first slot (since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>&gt;</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">16 &gt; 14</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>16</span><span></span><span>&gt;</span><span></span></span><span><span></span><span>14</span></span></span></span>) and find our element will be in the second slot (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>&lt;</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">16 &lt; 22</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>16</span><span></span><span>&lt;</span><span></span></span><span><span></span><span>22</span></span></span></span>).</li>
<li>Before we repeat the process and search for the element within that slot, we need to adjust our index to account for all the elements in preceding nodes that we are now disregarding. We do that by simply subtracting the previous entry in the size table (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>14</span></span></span></span>) from our index (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>16</span></span></span></span>) which gives us a new index of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span>.</li>
<li>We step through the slots to find our element and this time it’s contained within the first slot (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>&lt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2 &lt; 3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span>&lt;</span><span></span></span><span><span></span><span>3</span></span></span></span>). Once again, we adjust our index before recursing – this time subtracting nothing because there is no previous entry in the size table.</li>
<li>We’ve now reached a leaf node which doesn’t have a size table since we can rely on normal array indexing instead. Our index is currently <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span> and we can see the 3<sup>rd</sup> item is the expected value of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>16</span></span></span></span>.</li>
</ol>
<p>Doing a linear scan through the size table at each level of the tree is a lot more work than the handful of bit operations performed when radix indexing. However, we can combine the two approaches. Consider that if we’re allowing nodes to contain <em>fewer</em> than <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> slots then any elements that no longer fit in the current node will have to be placed in subsequent slots. Therefore we can use radix indexing on the size table to skip any slots that are guaranteed not to contain our element and then, if necessary, step forward until we find the right slot. We’ll soon introduce invariants that limit the number of additional slots we have to step to, on average, only 2 or 3.</p>
<p>Here’s how we might implement relaxed radix search in TypeScript:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> M</span><span> =</span><span> 32</span><span> // power of 2</span></span>
<span><span>const</span><span> BIT_WIDTH</span><span> =</span><span> Math.</span><span>log2</span><span>(</span><span>M</span><span>) </span><span>// 5</span></span>
<span></span>
<span><span>/**</span></span>
<span><span> * Find the element at position `idx`, or null if the index is out of bounds.</span></span>
<span><span> */</span></span>
<span><span>export</span><span> const</span><span> get</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>rrb</span><span>:</span><span> Rrb</span><span>&lt;</span><span>T</span><span>&gt;, </span><span>idx</span><span>:</span><span> number</span><span>)</span><span>:</span><span> T</span><span> |</span><span> null</span><span> =&gt;</span><span> {</span></span>
<span><span>  if</span><span> (idx </span><span>&gt;=</span><span> rrb.count) </span><span>return</span><span> null</span></span>
<span><span>  return</span><span> findElement</span><span>(rrb.root, idx)</span></span>
<span><span>}</span></span>
<span></span>
<span><span>const</span><span> findElement</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>node</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;, </span><span>idx</span><span>:</span><span> number</span><span>)</span><span>:</span><span> T</span><span> =&gt;</span><span> {</span></span>
<span><span>  if</span><span> (</span><span>isBranch</span><span>(node)) {</span></span>
<span><span>    // find the slot containing our element</span></span>
<span><span>    const</span><span> slot</span><span> =</span><span> findSlot</span><span>(idx, node.height, node.sizes)</span></span>
<span><span>    // find the number of elements in the preceding slots</span></span>
<span><span>    const</span><span> prevSize</span><span> =</span><span> slot </span><span>===</span><span> 0</span><span> ?</span><span> 0</span><span> :</span><span> node.sizes[slot </span><span>-</span><span> 1</span><span>]</span></span>
<span><span>    // calculate the index within our slot</span></span>
<span><span>    const</span><span> nextIdx</span><span> =</span><span> idx </span><span>-</span><span> prevSize</span></span>
<span><span>    // recurse</span></span>
<span><span>    return</span><span> findElement</span><span>(node.items[slot], nextIdx)</span></span>
<span><span>  } </span><span>else</span><span> {</span></span>
<span><span>    // fallback to array indexing for leaf nodes</span></span>
<span><span>    return</span><span> node.items[idx]</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>const</span><span> findSlot</span><span> =</span><span> (</span><span>idx</span><span>:</span><span> number</span><span>, </span><span>height</span><span>:</span><span> number</span><span>, </span><span>sizes</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> =&gt;</span><span> {</span></span>
<span><span>  // find starting slot by radix indexing</span></span>
<span><span>  let</span><span> slot </span><span>=</span><span> idx </span><span>&gt;&gt;</span><span> (</span><span>BIT_WIDTH</span><span> *</span><span> height)</span></span>
<span><span>  // skip slots until we reach the first with a cumulative size greater than</span></span>
<span><span>  // our index - this is where our element will be</span></span>
<span><span>  while</span><span> (sizes[slot] </span><span>&lt;=</span><span> idx) slot</span><span>++</span></span>
<span><span>  return</span><span> slot</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Another simple optimisation that we could do is to omit the size table on nodes that are leftwise dense. In other words, we start with Persistent Vectors and only add size tables, incurring their costs, to the subset of nodes that are affected when merging.</p>
<h2 id="mm-1-invariant">M..M-1 Invariant</h2>
<p>To address the second problem, that the tree height is no longer bounded, we’ll reintroduce an invariant similar to the original Persistent Vector requirement that all nodes, except the rightmost edge, must contain <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> slots. To permit a variable slot size, we’ll require nodes to have between <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M -1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> slots. With our example branching factor of 4, nodes may now have 3 or 4 slots. In our implementation where we use a branching factor of 32, nodes may have 31 or 32 slots.</p>
<p>Exactly how this impacts the height of the tree wasn’t immediately obvious to me, so let’s break it down. With a branching factor of 32 the maximum addressable space is 4,294,967,295. In the best case, every node has 32 children, so the height is given by <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>32</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>294</mn><mo separator="true">,</mo><mn>967</mn><mo separator="true">,</mo><mn>295</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_{32}(4,294,967,295)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>l</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>32</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>4</span><span>,</span><span></span><span>294</span><span>,</span><span></span><span>967</span><span>,</span><span></span><span>295</span><span>)</span></span></span></span> which is 6.39 so we’ll have 7 levels. In the worst case, we have <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>31</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>294</mn><mo separator="true">,</mo><mn>967</mn><mo separator="true">,</mo><mn>295</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_{31}(4,294,967,295)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>l</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>31</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>4</span><span>,</span><span></span><span>294</span><span>,</span><span></span><span>967</span><span>,</span><span></span><span>295</span><span>)</span></span></span></span> which is 6.45… also only 7 levels!</p>
<p>Not only does this constrain the height of the tree but it also constrains the number of possible extra search steps we have to perform during lookup. Higher levels of the tree may require more steps than lower levels since the offsetting compounds. We can calculate the total possible extra steps at the top of a tree of height <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>h</span></span></span></span> by taking the difference between the maximum possible number of leaf elements, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">M^h</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>M</span><span><span><span><span><span><span></span><span><span>h</span></span></span></span></span></span></span></span></span></span></span>, and the minimum possible number of leaf elements, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">(M-1)^h</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span><span>)</span><span><span><span><span><span><span></span><span><span>h</span></span></span></span></span></span></span></span></span></span></span>, and dividing it by the number of slots under that level, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">M^{h-1}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>M</span><span><span><span><span><span><span></span><span><span><span>h</span><span>−</span><span>1</span></span></span></span></span></span></span></span></span></span></span></span>:</p>
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><msup><mi>M</mi><mi>h</mi></msup><mo>−</mo><mo stretchy="false">(</mo><mi>M</mi><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>h</mi></msup></mrow><msup><mi>M</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{M^h - (M-1)^h}{M^{h-1}}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>M</span><span><span><span><span><span><span></span><span><span><span>h</span><span>−</span><span>1</span></span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>M</span><span><span><span><span><span><span></span><span><span>h</span></span></span></span></span></span></span></span><span></span><span>−</span><span></span><span>(</span><span>M</span><span></span><span>−</span><span></span><span>1</span><span><span>)</span><span><span><span><span><span><span></span><span><span>h</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span>
<p>To make that concrete, the worst case for a tree with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span> levels and a branching factor of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>32</span></span></span></span> is an additional <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4.69</mn></mrow><annotation encoding="application/x-tex">4.69</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>4.69</span></span></span></span> steps. However, assuming a random distribution of node sizes between <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M-1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span>, then on average we only have to perform <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.49</mn></mrow><annotation encoding="application/x-tex">2.49</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2.49</span></span></span></span> additional steps which adds very little overhead. Especially since the relevant entries in the size table are small enough to fit in the CPU cache.</p>
<p>With the introduction of size tables and the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M..M-1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span>..</span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> invariant we now have a data structure permitting some flexibility in the number of slots at each node while maintaining efficient lookup. Let’s revisit our earlier example of merging two vectors to see how many replacement nodes we now need to create to ensure a balanced tree.</p>
<img src="https://peter.horne-khan.com/_astro/figure-3.Dvv6G6cr_Z2qdjVz.svg" alt="Merging RRB under M..M-1 invariant" width="771" height="191" loading="lazy" decoding="async"/>
<p>The second leaf node has only 2 slots yet we must ensure each node has at least 3. The most efficient way to redistribute the slots is either to move the last slot of the first node, or the first slot of the third node, into the second node. In both cases we create 2 new replacement nodes rather than the 3 necessitated when using Persistent Vectors. This may not seem like much, since the trees in this example are shallow and we’re using a branching factor of 4 but we no longer need to shuffle <em>every</em> element in the right vector to the left which means we will be able to leave entire subtrees untouched when merging.</p>
<h2 id="search-step-invariant">Search Step Invariant</h2>
<p>However, we can do even better. You may have noticed that we merged 4 slots across 2 nodes into a single node with a total of… 4 slots. Had we simply merged both trees without rebalancing we would still have the same number of additional search steps for each index (at most 1). Could we use a different invariant that permits us to do that? What if rather than a lower bound on the branching factor we instead placed an invariant on the number of additional search steps permitted?</p>
<p>We know that the optimal number of slots to contain <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span> nodes is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>P</mi><mi mathvariant="normal">/</mi><mi>M</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil P / M \rceil</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>⌈</span><span>P</span><span>/</span><span>M</span><span>⌉</span></span></span></span> because we can fully fill up the first <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">P/M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span><span>/</span><span>M</span></span></span></span> slots and then use one additional slot to put the remainder in. Let’s say that we allow some constant, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span></span></span></span>, of additional extra search steps then the total number of slots <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span></span></span></span> we may use to contain <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span> nodes is given by the inequality <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>≤</mo><mo stretchy="false">⌈</mo><mi>P</mi><mi mathvariant="normal">/</mi><mi>M</mi><mo stretchy="false">⌉</mo><mo>+</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">S \le \lceil P / M \rceil + E</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span></span><span>≤</span><span></span></span><span><span></span><span>⌈</span><span>P</span><span>/</span><span>M</span><span>⌉</span><span></span><span>+</span><span></span></span><span><span></span><span>E</span></span></span></span>. We’ll call this the <em>Search Step Invariant</em>. Bagwell &amp; Rompf claim that with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">M = 32</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>=</span><span></span></span><span><span></span><span>32</span></span></span></span>, using <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">E = 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> provides a good balance between a small impact on the indexing time and a low concatenation cost. Although we’re only using <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">M = 4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>=</span><span></span></span><span><span></span><span>4</span></span></span></span> in these examples we’ll use <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">E = 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> too.</p>
<p>Applying this new invariant to our example, we see that no rebalancing is necessary since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>≤</mo><mo stretchy="false">⌈</mo><mn>14</mn><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">⌉</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">4 \le \lceil 14 / 4 \rceil + 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>4</span><span></span><span>≤</span><span></span></span><span><span></span><span>⌈</span><span>14/4</span><span>⌉</span><span></span><span>+</span><span></span></span><span><span></span><span>2</span></span></span></span>, or  <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>≤</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4 \le 6</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>4</span><span></span><span>≤</span><span></span></span><span><span></span><span>6</span></span></span></span>. In this simple example, merging is very efficient since we only need to recreate the parent node to contain the slots from both input trees. No children nodes need replacing since no rebalancing is required. We also know that lookup is efficient since there are, at most, only <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">E =2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> additional search steps required at this level.</p>
<img src="https://peter.horne-khan.com/_astro/figure-4.CAI8tCQf_ZhyRbi.svg" alt="Merging RRB under search step invariant with no rebalancing" width="791" height="91" loading="lazy" decoding="async"/>
<p>Now lets look at another example so we can see how the rebalancing algorithm works in detail. Then we’ll finally cover how to merge RRB trees.</p>
<img src="https://peter.horne-khan.com/_astro/figure-5.CBARG3PW_eHNOQ.svg" alt="Merging RRB under search step invariant with no rebalancing" width="972" height="92" loading="lazy" decoding="async"/>
<p>When rebalancing, we consider all <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span></span></span></span> slots together. Since each of the 2 nodes we are merging have at most <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> slots, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>≤</mo><mn>2</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">S \le 2M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span></span><span>≤</span><span></span></span><span><span></span><span>2</span><span>M</span></span></span></span>. To make things easier and reduce the amount of copying done, we first calculate a plan of how many items each slot should contain in the following way:</p>
<ol>
<li>Check if our invariant, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>≤</mo><mo stretchy="false">⌈</mo><mi>P</mi><mi mathvariant="normal">/</mi><mi>M</mi><mo stretchy="false">⌉</mo><mo>+</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">S \le \lceil P / M \rceil + E</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span></span><span>≤</span><span></span></span><span><span></span><span>⌈</span><span>P</span><span>/</span><span>M</span><span>⌉</span><span></span><span>+</span><span></span></span><span><span></span><span>E</span></span></span></span>, is met. If not, proceed.</li>
<li>Skip any slots with at least <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mrow><annotation encoding="application/x-tex">M-{E/2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span><span>E</span><span>/2</span></span></span></span></span> items as these don’t need redistributing. Once we reach the first slot with fewer than <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mrow><annotation encoding="application/x-tex">M-{E/2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span><span>E</span><span>/2</span></span></span></span></span> items, there will always be enough space in the subsequent slots for us to distribute the items over. (I don’t have a good explanation for <em>why</em> this is the case. The papers include a simple proof if you’re curious.)</li>
<li>Remove the slot that needs redistributing and add as many of its items as possible to the next slot, then as many of the remainder to the next one, and so on.</li>
<li>Repeat.</li>
</ol>
<p>Lets apply that to the example step by step:</p>
<ol>
<li>First, we check the invariant <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>≤</mo><mo stretchy="false">⌈</mo><mn>16</mn><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">⌉</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">7 \le \lceil 16 / 4 \rceil + 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>7</span><span></span><span>≤</span><span></span></span><span><span></span><span>⌈</span><span>16/4</span><span>⌉</span><span></span><span>+</span><span></span></span><span><span></span><span>2</span></span></span></span>, or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>≤</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">7 \le 6</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>7</span><span></span><span>≤</span><span></span></span><span><span></span><span>6</span></span></span></span>, which does not hold - so we need to redistribute some items to reduce the slot count.</li>
<li>We skip slots with 3 items or more (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mrow><annotation encoding="application/x-tex">M - {E/2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span><span>E</span><span>/2</span></span></span></span></span>), which means we skip the first slot (contains 3) but need to distribute the second slot (contains 2).</li>
<li>Slots can contain at most <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> items so we add one item to the third slot and carry the remaining item over to the fourth slot.</li>
<li>This has reduced our total slot count by 1 so we check the invariant to see if we need to continue. If we do, we find the next slot with fewer than <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mi>E</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">M-E/2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>E</span><span>/2</span></span></span></span> items and redistribute it; however, since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>≤</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">6 \le 6</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>6</span><span></span><span>≤</span><span></span></span><span><span></span><span>6</span></span></span></span> we are done.</li>
</ol>
<p>We apply our plan to the original set of nodes, producing a new set conforming to our invariant. Nodes that already contain the desired number of items can be reused so we only need to copy items when creating slots that have been redistributed over. Bagwell &amp; Rompf claim this new invariant reduces the concatenation cost by a factor of 3.</p>
<p>Despite the somewhat lengthy explanation, the implementation is fairly simple:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>/**</span></span>
<span><span> * Generate a plan of how the items in `node` should be</span></span>
<span><span> * distributed that conforms to the search step invariant.</span></span>
<span><span> */</span></span>
<span><span>const</span><span> createConcatPlan</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>node</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt;)</span><span>:</span><span> number</span><span>[] </span><span>=&gt;</span><span> {</span></span>
<span><span>  // our initial plan is the current distribution of items</span></span>
<span><span>  const</span><span> plan</span><span> =</span><span> node.items.</span><span>map</span><span>(</span><span>item</span><span> =&gt;</span><span> item.items.</span><span>length</span><span>)</span></span>
<span><span>  // count the total number of items</span></span>
<span><span>  const</span><span> s</span><span> =</span><span> plan.</span><span>reduce</span><span>((</span><span>a</span><span>, </span><span>b</span><span>) </span><span>=&gt;</span><span> a </span><span>+</span><span> b, </span><span>0</span><span>)</span></span>
<span><span>  // calculate the optimal number of slots necessary</span></span>
<span><span>  const</span><span> opt</span><span> =</span><span> Math.</span><span>ceil</span><span>(s </span><span>/</span><span> M</span><span>)</span></span>
<span></span>
<span><span>  let</span><span> i </span><span>=</span><span> 0</span></span>
<span><span>  let</span><span> n </span><span>=</span><span> plan.</span><span>length</span></span>
<span><span>  // check if our invariant is met</span></span>
<span><span>  while</span><span> (n </span><span>&gt;</span><span> opt </span><span>+</span><span> E_MAX</span><span>) {</span></span>
<span><span>    // skip slots that don&#39;t need redistributing</span></span>
<span><span>    while</span><span> (plan[i] </span><span>&gt;=</span><span> M</span><span> -</span><span> E_MAX</span><span> /</span><span> 2</span><span>) i</span><span>++</span></span>
<span></span>
<span><span>    // current slot needs distributing over its subsequent siblings</span></span>
<span></span>
<span><span>    // track remaining items to distribute, which starts as all</span></span>
<span><span>    // the items from the current slot we&#39;re going to distribute</span></span>
<span><span>    let</span><span> r </span><span>=</span><span> plan[i]</span></span>
<span><span>    while</span><span> (r </span><span>&gt;</span><span> 0</span><span>) {</span></span>
<span><span>      // replace the items in the current slot with all the items from the next</span></span>
<span><span>      // slot, plus as many remaining items we have to distribute as possible</span></span>
<span><span>      plan[i] </span><span>=</span><span> Math.</span><span>min</span><span>(r </span><span>+</span><span> plan[i </span><span>+</span><span> 1</span><span>], </span><span>M</span><span>)</span></span>
<span><span>      // calculate the items remaining</span></span>
<span><span>      r </span><span>=</span><span> r </span><span>+</span><span> plan[i </span><span>+</span><span> 1</span><span>] </span><span>-</span><span> plan[i]</span></span>
<span><span>      i </span><span>+=</span><span> 1</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // slots that were distributed over were shuffled one slot to the left so</span></span>
<span><span>    // we need to do the same for any remaining slots</span></span>
<span><span>    for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> i; j </span><span>&lt;</span><span> n </span><span>-</span><span> 1</span><span>; j</span><span>++</span><span>) {</span></span>
<span><span>      plan[j] </span><span>=</span><span> plan[j </span><span>+</span><span> 1</span><span>]</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // account for shuffling slots to the left</span></span>
<span><span>    i</span><span>--</span></span>
<span><span>    n</span><span>--</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  return</span><span> plan.</span><span>slice</span><span>(</span><span>0</span><span>, n)</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h2 id="merging">Merging</h2>
<p>Finally, let’s merge some trees!</p>
<img src="https://peter.horne-khan.com/_astro/figure-6.D-xXlWtY_Vbb2.svg" alt="Merging 2 RRB Trees - Part #1" width="1141" height="152" loading="lazy" decoding="async"/>
<p>To reduce clutter, I won’t include the size tables in the subsequent diagrams but in the example implementation we create them as necessary when new nodes are created.</p>
<p>We start by walking down the left tree until we reach the slot pointing to the rightmost leaf node, and the right tree until we reach the slot pointing to the leftmost leaf node. We take these two slots and create a new node from them, thus leaving us with 3 nodes: the original left node minus its last slot, the newly created ‘middle’ node, and the original right node minus its first slot.</p>
<img src="https://peter.horne-khan.com/_astro/figure-7.eEursljJ_1SrHNv.svg" alt="Merging 2 RRB Trees - Part #2" width="1091" height="161" loading="lazy" decoding="async"/>
<p>We consider the slots of all 3 nodes together and rebalance as necessary, placing the result in a new parent node that will be carried up to the next level and merged in a recursive fashion. Presently, the search step invariant is not met so we redistribute the second slot (which is the first with fewer than <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mi>E</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">M - E/2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span><span></span><span>−</span><span></span></span><span><span></span><span>E</span><span>/2</span></span></span></span> items) over its subsequent siblings, which is sufficient to rebalance the slots. We then create a parent node along with sufficient children to optimally contain the rebalanced slots. All newly created nodes are indicated in orange so you can see that the merging process is able to reuse a lot of the existing nodes, reducing the amount of work that needs to be done.</p>
<img src="https://peter.horne-khan.com/_astro/figure-8.CX0-kYdd_Z2bn0Ay.svg" alt="Merging 2 RRB Trees - Part #3" width="1091" height="161" loading="lazy" decoding="async"/>
<p>Since the parent node we created is 1 level higher than the nodes we merged, we move up a level an merge it with the other nodes at that level. Much like before, we drop the rightmost slot from the left node, and the rightmost slot from the left node, since those subtrees are already contained in our ‘middle’ node and then consider the slots of all 3 nodes together for rebalancing. This time we have 12 items distributed over 4 slots so the invariant is already met and all we need to do is create a new node to hold them.</p>
<img src="https://peter.horne-khan.com/_astro/figure-9.cmBocD6d_XkTJG.svg" alt="Merging 2 RRB Trees - Part #4" width="1091" height="211" loading="lazy" decoding="async"/>
<p>This time the new parent node has no siblings to merge with since we’ve reached the top of the tree. As the parent node only contains a single slot the rebalancing process has introduced a redundant level which we simply chop off.</p>
<p>And that’s it! We’ve successfully merged both trees together, ensuring the search step invariant is maintained, while reusing most of the existing nodes.</p>
<p>The implementation is fairly lengthy but there’s nothing especially complex going on:</p>
<pre tabindex="0" data-language="typescript"><code><span><span>/**</span></span>
<span><span> * Concatenate two RRB trees into a single balanced RRB tree.</span></span>
<span><span> */</span></span>
<span><span>export</span><span> const</span><span> concat</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>left</span><span>:</span><span> Rrb</span><span>&lt;</span><span>T</span><span>&gt;, </span><span>right</span><span>:</span><span> Rrb</span><span>&lt;</span><span>T</span><span>&gt;)</span><span>:</span><span> Rrb</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> {</span></span>
<span><span>  // create a single, balanced node containing all items from left and right</span></span>
<span><span>  const</span><span> merged</span><span> =</span><span> concatNodes</span><span>(left.root, right.root)</span></span>
<span><span>  return</span><span> {</span></span>
<span><span>    count: left.count </span><span>+</span><span> right.count,</span></span>
<span><span>    root:</span></span>
<span><span>      // there may be a redundant extra level so we chop it off if necessary</span></span>
<span><span>      merged.items.</span><span>length</span><span> ===</span><span> 1</span><span> ?</span><span> merged.items[</span><span>0</span><span>] </span><span>:</span><span> merged,</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/**</span></span>
<span><span> * Concatenate two nodes into a single balanced branch.</span></span>
<span><span> *</span></span>
<span><span> * Since we always return a branch, but there may be M or fewer items, the</span></span>
<span><span> * branch may be redundant and can be unwrapped by the caller.</span></span>
<span><span> */</span></span>
<span><span>const</span><span> concatNodes</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span></span>
<span><span>  left</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;,</span></span>
<span><span>  right</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;,</span></span>
<span><span>  top</span><span>:</span><span> boolean</span><span> =</span><span> true</span></span>
<span><span>)</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> {</span></span>
<span><span>  // first, we handle trees of different heights</span></span>
<span></span>
<span><span>  if</span><span> (left.height </span><span>&gt;</span><span> right.height) {</span></span>
<span><span>    assert</span><span>(</span><span>isBranch</span><span>(left))</span></span>
<span><span>    const</span><span> middle</span><span> =</span><span> concatNodes</span><span>(array.</span><span>last</span><span>(left.items), right, </span><span>false</span><span>)</span></span>
<span><span>    return</span><span> rebalance</span><span>(left, middle, </span><span>null</span><span>, top)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  if</span><span> (left.height </span><span>&lt;</span><span> right.height) {</span></span>
<span><span>    assert</span><span>(</span><span>isBranch</span><span>(right))</span></span>
<span><span>    const</span><span> middle</span><span> =</span><span> concatNodes</span><span>(left, array.</span><span>first</span><span>(right.items), </span><span>false</span><span>)</span></span>
<span><span>    return</span><span> rebalance</span><span>(</span><span>null</span><span>, middle, right, top)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // then, we handle leaf nodes</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>isLeaf</span><span>(left) </span><span>&amp;&amp;</span><span> isLeaf</span><span>(right)) {</span></span>
<span><span>    const</span><span> total</span><span> =</span><span> left.items.</span><span>length</span><span> +</span><span> right.items.</span><span>length</span></span>
<span><span>    if</span><span> (top </span><span>&amp;&amp;</span><span> total </span><span>&lt;=</span><span> M</span><span>) {</span></span>
<span><span>      return</span><span> Branch</span><span>(</span><span>1</span><span>, [</span><span>Leaf</span><span>([</span><span>...</span><span>left.items, </span><span>...</span><span>right.items])])</span></span>
<span><span>    } </span><span>else</span><span> {</span></span>
<span><span>      // this may not be balanced but the outer</span></span>
<span><span>      // recursive step will rebalance it later</span></span>
<span><span>      return</span><span> Branch</span><span>(</span><span>1</span><span>, [left, right])</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // finally, we handle branches of equal height</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>isBranch</span><span>(left) </span><span>&amp;&amp;</span><span> isBranch</span><span>(right)) {</span></span>
<span><span>    const</span><span> middle</span><span> =</span><span> concatNodes</span><span>(</span></span>
<span><span>      array.</span><span>last</span><span>(left.items),</span></span>
<span><span>      array.</span><span>first</span><span>(right.items),</span></span>
<span><span>      false</span></span>
<span><span>    )</span></span>
<span><span>    return</span><span> rebalance</span><span>(left, middle, right, top)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  throw</span><span> Error</span><span>(</span><span>&#34;unreachable&#34;</span><span>)</span></span>
<span><span>}</span></span>
<span></span>
<span><span>const</span><span> calcSizes</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>items</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;[])</span><span>:</span><span> number</span><span>[] </span><span>=&gt;</span><span> {</span></span>
<span><span>  let</span><span> prev </span><span>=</span><span> 0</span></span>
<span><span>  return</span><span> items.</span><span>map</span><span>(</span><span>item</span><span> =&gt;</span><span> (prev </span><span>+=</span><span> sizeOf</span><span>(item)))</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/**</span></span>
<span><span> * Create a single, balanced branch containing</span></span>
<span><span> * all items from the input branches.</span></span>
<span><span> */</span></span>
<span><span>const</span><span> rebalance</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span></span>
<span><span>  left</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt; </span><span>|</span><span> null</span><span>,</span></span>
<span><span>  middle</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt;,</span></span>
<span><span>  right</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt; </span><span>|</span><span> null</span><span>,</span></span>
<span><span>  top</span><span>:</span><span> boolean</span></span>
<span><span>)</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> {</span></span>
<span><span>  // merge into a single, unbalanced node that may contain up to 2M items</span></span>
<span><span>  const</span><span> merged</span><span> =</span><span> Branch</span><span>(middle.height, [</span></span>
<span><span>    ...</span><span>(left </span><span>?</span><span> array.</span><span>init</span><span>(left.items) </span><span>:</span><span> []),</span></span>
<span><span>    ...</span><span>middle.items,</span></span>
<span><span>    ...</span><span>(right </span><span>?</span><span> array.</span><span>tail</span><span>(right.items) </span><span>:</span><span> []),</span></span>
<span><span>  ])</span></span>
<span><span>  // create a plan of how the items should be balanced</span></span>
<span><span>  const</span><span> plan</span><span> =</span><span> createConcatPlan</span><span>(merged)</span></span>
<span><span>  // create a single, balanced node that may contain up to 2M items</span></span>
<span><span>  const</span><span> balanced</span><span> =</span><span> executeConcatPlan</span><span>(merged, plan)</span></span>
<span></span>
<span><span>  if</span><span> (plan.</span><span>length</span><span> &lt;=</span><span> M</span><span>) {</span></span>
<span><span>    return</span><span> top </span><span>?</span><span> balanced </span><span>:</span><span> Branch</span><span>(balanced.height </span><span>+</span><span> 1</span><span>, [balanced])</span></span>
<span><span>  } </span><span>else</span><span> {</span></span>
<span><span>    // distribute the (up to 2M) items across 2 nodes in a new branch</span></span>
<span><span>    const</span><span> left</span><span> =</span><span> Branch</span><span>(balanced.height, balanced.items.</span><span>slice</span><span>(</span><span>0</span><span>, </span><span>M</span><span>))</span></span>
<span><span>    const</span><span> right</span><span> =</span><span> Branch</span><span>(balanced.height, balanced.items.</span><span>slice</span><span>(</span><span>M</span><span>))</span></span>
<span><span>    return</span><span> Branch</span><span>(balanced.height </span><span>+</span><span> 1</span><span>, [left, right])</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/*</span></span>
<span><span> * Distribute the items in `node` according to `plan`. Both the input and</span></span>
<span><span> * output may have more than M items which will be handled in `rebalance`.</span></span>
<span><span> */</span></span>
<span><span>const</span><span> executeConcatPlan</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>node</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt;, </span><span>plan</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> Branch</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> items</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;[] </span><span>=</span><span> []</span></span>
<span></span>
<span><span>  let</span><span> i </span><span>=</span><span> 0</span></span>
<span><span>  let</span><span> offset </span><span>=</span><span> 0</span></span>
<span><span>  plan.</span><span>forEach</span><span>(</span><span>target</span><span> =&gt;</span><span> {</span></span>
<span><span>    if</span><span> (offset </span><span>===</span><span> 0</span><span> &amp;&amp;</span><span> node.items[i].items.</span><span>length</span><span> ===</span><span> target) {</span></span>
<span><span>      items.</span><span>push</span><span>(node.items[i])</span></span>
<span><span>      i </span><span>+=</span><span> 1</span></span>
<span><span>    } </span><span>else</span><span> {</span></span>
<span><span>      const</span><span> current</span><span>:</span><span> Node</span><span>&lt;</span><span>T</span><span>&gt;[] </span><span>|</span><span> T</span><span>[] </span><span>=</span><span> []</span></span>
<span><span>      while</span><span> (current.</span><span>length</span><span> &lt;</span><span> target) {</span></span>
<span><span>        const</span><span> required</span><span> =</span><span> target </span><span>-</span><span> current.</span><span>length</span></span>
<span><span>        const</span><span> size</span><span> =</span><span> node.items[i].items.</span><span>length</span></span>
<span><span>        const</span><span> available</span><span> =</span><span> size </span><span>-</span><span> offset</span></span>
<span><span>        const</span><span> min</span><span> =</span><span> Math.</span><span>min</span><span>(required, available)</span></span>
<span><span>        current.</span><span>push</span><span>(</span></span>
<span><span>          ...</span><span>(node.items[i].items.</span><span>slice</span><span>(offset, min </span><span>+</span><span> offset) </span><span>as</span><span> any</span><span>)</span></span>
<span><span>        )</span></span>
<span><span>        if</span><span> (min </span><span>===</span><span> available) {</span></span>
<span><span>          offset </span><span>=</span><span> 0</span></span>
<span><span>          i </span><span>+=</span><span> 1</span></span>
<span><span>        } </span><span>else</span><span> {</span></span>
<span><span>          offset </span><span>+=</span><span> min</span></span>
<span><span>        }</span></span>
<span><span>      }</span></span>
<span><span>      items.</span><span>push</span><span>(</span><span>Node</span><span>(node.height </span><span>-</span><span> 1</span><span>, current))</span></span>
<span><span>    }</span></span>
<span><span>  })</span></span>
<span></span>
<span><span>  return</span><span> Branch</span><span>(node.height, items)</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>The example implementation can be found in full at <a href="https://github.com/peterhorne/rrb-tree">https://github.com/peterhorne/rrb-tree</a>.</p>  </div></div>
  </body>
</html>
