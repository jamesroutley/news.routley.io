<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://walletwallet.alen.ro/">Original</a>
    <h1>Show HN: WalletWallet â€“ create Apple passes from anything</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>In terms of new TypeScript features, 2025 was a very quiet year. But it&#39;s been a big year for TypeScript and typed JavaScript in general, and the ecosystem has a new direction that sets the stage for big fireworks in 2026.</p>
<p>The two big announcements in 2025 were:</p>
<ol>
<li>Microsoft is rewriting the TypeScript compiler and language service in Go.</li>
<li>Node.js began supporting TypeScript natively.</li>
</ol>
<h2 id="TypeScript-rewrite-in-Go"><a href="#TypeScript-rewrite-in-Go" title="TypeScript rewrite in Go"></a>TypeScript rewrite in Go</h2><p>I&#39;ve followed the TypeScript <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://devblogs.microsoft.com/typescript/&#39;, event);">release notes</a> for years. Recent releases have had relatively few big new language features, and many of these have been contributed by external developers. This March, <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/typescript-native-port/" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://devblogs.microsoft.com/typescript/typescript-native-port/&#39;, event);">we found out why</a>: The TypeScript team at Microsoft has been working on a massive project to port <code>tsc</code> and <code>tsserver</code> from TypeScript to Go.</p>
<p>My first reaction was: &#34;is it April 1st already?&#34; My next reaction was a whole lot of mixed feelings.</p>
<p>It&#39;s generally considered a good practice for compilers to be <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://en.wikipedia.org/wiki/Bootstrapping_(compilers)&#39;, event);">bootstrapped</a>, i.e. written in their own language. While this sounds strange at first, it&#39;s quite common and has several positive consequences:</p>
<ol>
<li>It&#39;s a demonstration that you can build a large, substantial program in the language.</li>
<li>It makes the development team aware of issues in the language, since they work in it day-to-day.</li>
<li>It makes the development team acutely sensitive to compiler and language service performance.</li>
</ol>
<p>No one doubts that you can build large programs in TypeScript, but the &#34;dogfooding&#34; aspect of self-hosting has been good for the TypeScript ecosystem. Every TypeScript release comes with performance improvements, and one reason for this is that the TS team appreciates fast builds and responsive editors, too.</p>
<p>So bootstrapping is, in principle, good. That being said, a 10x speedup should make you question your principles.</p>
<p>When I was developing my <a href="https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/">inferred type predicates feature</a>, I was struck that the TypeScript in <code>tsc</code> is written in a distinctive, low-level style. It often looks more like C than JavaScript. I started to think about how you could turn that into a faster <code>tsc</code>. A direct port to C wouldn&#39;t work since JavaScript has garbage collection and <code>tsc</code> relies on that. I wrote in a notebook: &#34;what&#39;s the lowest-level language with garbage collection?&#34; I figured it might be Java and left things there.</p>
<p>It seems the TS team, in particular <a target="_blank" rel="noopener" href="https://jakebailey.dev/" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://jakebailey.dev/&#39;, event);">Jake Bailey</a>, went through the same thought process and came to a different conclusion: <a target="_blank" rel="noopener" href="https://go.dev/" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://go.dev/&#39;, event);">Go</a>!</p>
<p>The new TypeScript is a line-by-line port of the existing one. There&#39;s a notorious 50,000+ line <code>checker.ts</code> file today, and in the future there will be a 50,000+ line <code>checker.go</code>. TypeScript 6.0 will be <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/#typescript-6.0-is-the-last-javascript-based-release" onclick="return trackOutboundLink(&#39;typescript rewrite in go&#39;, &#39;https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/#typescript-6.0-is-the-last-javascript-based-release&#39;, event);">the last TypeScript-based version of TypeScript</a>, and then future versions will be written in Go.</p>
<p>The upshot is that, sometime next year, you&#39;ll update your packages and everything will get 10x faster. Slow compiler and language service performance has always been one of the biggest complaints about TypeScript. I&#39;ve experienced this myself on large projects and I&#39;m looking forward to the speed boost.</p>
<p>My other hope is that, once the dust settles, we&#39;ll see a renewed focus on new language features.</p>
<h2 id="Node-js-Runs-TypeScript-Natively"><a href="#Node-js-Runs-TypeScript-Natively" title="Node.js Runs TypeScript Natively"></a>Node.js Runs TypeScript Natively</h2><p>This one flew under the radar for me when it happened earlier this year, and perhaps it&#39;s news to you, too: Node.js now natively supports TypeScript!</p>
<figure><div><pre><code><span>// test.ts</span></code></pre></div></figure>

<figure><div><pre><code><span>&gt;</span><span> node test.ts</span></code></pre></div></figure>

<p>Impressive stuff! This should work with any version of Node.js after 22.18.0, which was <a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/release/v22.18.0" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://nodejs.org/en/blog/release/v22.18.0&#39;, event);">released</a> on July 31st, 2025. (This behavior has been available since <a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/release/v22.6.0" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://nodejs.org/en/blog/release/v22.6.0&#39;, event);">Node 22.6.0</a> last year via <code>--experimental-strip-types</code>.)</p>
<p>This is a big deal. Ever since Node came out in 2009, people have been running preprocessors in front of it to improve JavaScript in various ways. <a target="_blank" rel="noopener" href="https://coffeescript.org/" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://coffeescript.org/&#39;, event);">CoffeeScript</a> was one of the first, then we started using &#34;transpilers&#34; like <a target="_blank" rel="noopener" href="https://babeljs.io/" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://babeljs.io/&#39;, event);">Babel</a> to get early access to ES2015 features, and now we use TypeScript to get types. In all these cases, we&#39;re adding a tool to the stack. It has to be configured, you have to know it exists, and something might go wrong with it. In short, it adds friction.</p>
<p>Node.js has supported ES2015 features for years now, so there&#39;s no need for a transpiler to use arrow functions, <code>async</code>, <code>Map</code>, etc. Now you don&#39;t need <code>tsc</code> to use TypeScript with node. It just works out of the box.</p>
<p>A few things to note here:</p>
<ol>
<li>This is only about <em>running</em> your code. Node doesn&#39;t do type checking. It simply strips off the types. If you want type checking (and you do!) then you&#39;ll still need to run <code>tsc</code> separately.</li>
<li>Since this works by stripping types, you can&#39;t use TypeScript&#39;s niche runtime features: enums, parameter properties, triple-slash imports, experimental decorators, and member visibility modifiers (<code>private</code>). I&#39;ve long advised against doing this (See <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);">Effective TypeScript</a> <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-write-run/avoid-non-ecma.md" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-write-run/avoid-non-ecma.md&#39;, event);">Item 72: Prefer ECMAScript Features to TypeScript Features</a>) and, as of TypeScript 5.8, there&#39;s an <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/#the---erasablesyntaxonly-option" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/#the---erasablesyntaxonly-option&#39;, event);"><code>--erasableSyntaxOnly</code> flag</a> to keep you away from these.</li>
<li>Stripping types doesn&#39;t change line numbers, so you don&#39;t need source maps to debug.</li>
<li>While TypeScript supports any TC39 proposal at stage 3 or later, Node.js only supports features once they&#39;ve landed in the spec. So for the few features in between those states, you&#39;ll need to hold off until they&#39;re official.</li>
</ol>
<p>I want to reiterate that this doesn&#39;t do any type checking! Node will happily run programs with clear type errors:</p>
<figure><div><pre><code><span>// test-bad.ts</span></code></pre></div></figure>

<figure><div><pre><code><span>&gt;</span><span> node test-bad.ts</span></code></pre></div></figure>

<p><code>tsc</code> can strip type annotations, of course, but there are several other tools that do the same thing, like Bloomberg&#39;s aptly-named <a target="_blank" rel="noopener" href="https://github.com/bloomberg/ts-blank-space" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://github.com/bloomberg/ts-blank-space&#39;, event);">ts-blank-space</a>. Node uses <a target="_blank" rel="noopener" href="https://swc.rs/docs/references/wasm-typescript" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://swc.rs/docs/references/wasm-typescript&#39;, event);"><code>@swc/wasm-typescript</code></a>, which uses WASM for speed.</p>
<p>So does this mean that TypeScript has won? On some level, yes. It&#39;s so widely adopted now that Node.js felt the need to add built-in support. But this change also opens the door to more competition in the typed JavaScript landscape. It was designed with TypeScript in mind, but it doesn&#39;t have to be <code>tsc</code> checking your code. It could be some other type checker instead.</p>
<p>This puts JavaScript in a situation akin to Python. Python has a <a target="_blank" rel="noopener" href="https://peps.python.org/pep-0484/" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://peps.python.org/pep-0484/&#39;, event);">standardized syntax</a> for type annotations but, for the most part, they have no effect on the runtime behavior of your program. There&#39;s a healthy ecosystem of type checkers for Python that all use the same syntax for type hints, but have different philosophies and provide different sorts of checking. Examples of Python type checkers include <a target="_blank" rel="noopener" href="https://mypy-lang.org/" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://mypy-lang.org/&#39;, event);">mypy</a>, <a target="_blank" rel="noopener" href="https://github.com/microsoft/pyright" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://github.com/microsoft/pyright&#39;, event);">pyright</a> (Microsoft), <a target="_blank" rel="noopener" href="https://pyrefly.org/" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://pyrefly.org/&#39;, event);">pyrefly</a> (Facebook) and <a target="_blank" rel="noopener" href="https://github.com/astral-sh/ty" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://github.com/astral-sh/ty&#39;, event);">ty</a> (Astral).</p>
<p>By standardizing a syntax for type annotations, Node is making it easier for new entrants to bring their own take on type checking to JavaScript. Competition is a good thing, and I hope this brings some of it to the typed JavaScript ecosystem.</p>
<p>What about browsers? There&#39;s a Microsoft-backed <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-type-annotations" onclick="return trackOutboundLink(&#39;nodejs runs typescript natively&#39;, &#39;https://github.com/tc39/proposal-type-annotations&#39;, event);">TC39 proposal</a> to add type annotations to the language itself, but it&#39;s only at stage 1. I assume it would need to advance significantly before there&#39;s browser adoption. I hope Node&#39;s move gives this proposal some momentum. As it says, the motivation is to &#34;unfork JavaScript,&#34; which would be good for everyone.</p>
<p>So long 2025! Here&#39;s hoping that 2026 brings faster build times, more responsive editors, exciting new language features, and a simpler JavaScript ecosystem.</p>

          </div></div>
  </body>
</html>
