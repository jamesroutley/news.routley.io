<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeberg.org/gsou/LCL">Original</a>
    <h1>An implementation of Common Lisp targeting Lua</h1>
    
    <div id="readability-page-1" class="page"><div id="user-content-outline-text-headline-5">
<p>
After loading <code>lcl.lua</code>, the Lua VM is ready to run Common Lisp code. To do that, the lisp functions can be directly called by Lua or by the host application by following the <a href="https://riskmusings.substack.com/gsou/LCL/src/branch/main/%2ALCL%20Calling%20Convention" title="calling convention" rel="nofollow">calling convention</a>.</p>
<p>
Note that the symbol metatable provides a <code>__call</code> metamethod so symbols can be called directly.</p>
<p>
For instance, to read a form from a string, the lisp function <code>read-from-string</code> is used. It is located in the <code>COMMON-LISP</code> package. It can be accessed by: <code>LCL[&#39;COMMON-LISP&#39;][&#39;READ-FROM-STRING&#39;]</code>, or with the shortcut <code>CL[&#39;READ-FROM-STRING&#39;]</code>. This function takes the string to read, two optional arguments and key arguments. If we want to omit any optional or key arguments, the function is called as follows:</p>
<div>
<pre><code><span>read_from_string</span> <span>=</span> <span>CL</span><span>[</span><span>&#39;READ-FROM-STRING&#39;</span><span>](</span><span>&#34;read-from-string&#34;</span><span>,</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>{})</span></code></pre>
</div>
<p>
<code>read-from-string</code> returns a symbol. It is assigned to the Lua global <code>read_from_string</code> in the snippet above. Since symbols are callable, we could do:</p>
<div>
<pre><code><span>CL.PRINT</span><span>(</span><span>read_from_string</span><span>(</span><span>&#34;#C(0 1)&#34;</span><span>,</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>{}))</span>
<span>-- Prints: #C(0 1)</span></code></pre>
</div>
<p>
Or we could just use <code>cl:funcall</code> if we don&#39;t wan&#39;t to care about the <a href="https://riskmusings.substack.com/gsou/LCL/src/branch/main/%2ALCL%20Calling%20Convention" title="calling convention" rel="nofollow">calling convention</a>.</p>
<div>
<pre><code><span>CL.PRINT</span><span>(</span> <span>CL.FUNCALL</span><span>(</span> <span>read_from_string</span><span>,</span> <span>l</span><span>(</span> <span>&#34;#C(0 1)&#34;</span> <span>)</span> <span>)</span> <span>)</span>
<span>-- Prints: #C(0 1)</span></code></pre>
</div>
<p>
The <code>read-from-string</code> function returns a Lisp list. The <code>eval</code> function evaluates a Lisp list. They can be used in the same way from Lua:</p>
<div>
<pre><code><span>CL.PRINT</span><span>(</span><span>CL.EVAL</span><span>(</span><span>CL.FUNCALL</span><span>(</span> <span>CL</span><span>[</span><span>&#39;READ-FROM-STRING&#39;</span><span>],</span> <span>l</span><span>(</span><span>&#34;(reduce #&#39;cons &#39;(1 2 3 4) :from-end t)&#34;</span><span>))))</span>
<span>-- Prints: (1 2 3 . 4)</span></code></pre>
</div>
<p>
The Lisp list could also be generated from Lua:</p>
<div>
<pre><code><span>CL.PRINT</span><span>(</span><span>CL.EVAL</span><span>(</span>
           <span>l</span><span>(</span><span>CL.REDUCE</span><span>,</span> <span>l</span><span>(</span><span>CL.FUNCTION</span><span>,</span> <span>CL.CONS</span><span>),</span> <span>l</span><span>(</span><span>CL.QUOTE</span><span>,</span> <span>l</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>)),</span> <span>KEYWORD</span><span>[</span><span>&#39;FROM-END&#39;</span><span>],</span> <span>CL.T</span><span>)))</span>
<span>-- Prints: (1 2 3 . 4)</span>

<span>-- Or even</span>
<span>CL.PRINT</span><span>(</span><span>CL.EVAL</span><span>(</span>
           <span>{</span><span>CL.REDUCE</span><span>,</span> <span>{{</span><span>CL.FUNCTION</span><span>,</span> <span>{</span><span>CL.CONS</span><span>,</span> <span>CL.NIL</span><span>}},</span> <span>{</span> <span>{</span><span>CL.QUOTE</span><span>,</span> <span>{{</span><span>1</span><span>,{</span><span>2</span><span>,{</span><span>3</span><span>,{</span><span>4</span><span>,</span> <span>CL.NIL</span><span>}}}},</span> <span>CL.NIL</span><span>}},</span> <span>{</span><span>KEYWORD</span><span>[</span><span>&#39;FROM-END&#39;</span><span>],</span> <span>{</span><span>CL.T</span><span>,</span> <span>CL.NIL</span><span>}}}}}))</span>
<span>-- Prints: (1 2 3 . 4)</span></code></pre>
</div>
<p>
The <code>load</code> and <code>compile-file</code> are ways to load Lisp code from files as in other Common Lisp implementations.</p>
<div>
<pre><code><span>CL.EVAL</span><span>(</span><span>CL</span><span>[</span><span>&#39;READ-FROM-STRING&#39;</span><span>](</span><span>&#39;(compile-file #P&#34;lispcode.lisp&#34;)&#39;</span><span>,</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>{}))</span>
<span>CL.EVAL</span><span>(</span><span>CL</span><span>[</span><span>&#39;READ-FROM-STRING&#39;</span><span>](</span><span>&#39;(load #P&#34;lispcode.lisp&#34;)&#39;</span><span>,</span> <span>nil</span><span>,</span> <span>nil</span><span>,</span> <span>{}))</span></code></pre>
</div>
<p>
Additionally, some Lua functions are included to easily call Common Lisp.</p>
<div>
<pre><code><span>function</span> <span>eval</span><span>(</span><span>str</span><span>)</span> <span>...</span> <span>end</span>
<span>function</span> <span>lclc</span><span>(</span><span>str</span><span>)</span> <span>...</span> <span>end</span>
<span>function</span> <span>read</span><span>(</span><span>str</span><span>)</span> <span>...</span> <span>end</span></code></pre>
</div>
<p>
These functions all take a string containing a Lisp form. If the argument is ommited, <code>cl:read</code> is called and a form is read from <code>stdin</code>.</p>
<p>
The function <code>read</code> reads the form and prints it.</p>
<p>
The function <code>lclc</code> reads the form, compile it to Lua and return a string containing the resulting Lua code.</p>
<p>
The function <code>eval</code> reads the form, evaluates it, and prints it. The result of the evaluation is returned.</p>
<div>
<pre><code><span>eval</span><span>()</span>
<span>-- From stdin: (reduce #&#39;cons &#39;(1 2 3 4) :from-end t)</span>
<span>-- Prints: (1 2 3 . 4)</span>
<span>-- Return a table containing the above list</span>

<span>-- Equivalent, without reading from stdin:</span>
<span>eval</span><span>(</span><span>&#34;(reduce #&#39;cons &#39;(1 2 3 4) :from-end t)&#34;</span><span>)</span>

<span>lclc</span><span>(</span><span>&#34;(reduce #&#39;cons &#39;(1 2 3 4) :from-end t)&#34;</span><span>)</span>
<span>-- Returns:  return CL[&#34;REDUCE&#34;](CL[&#34;CONS&#34;].fbound, {1,{2,{3,{4,CL[&#34;NIL&#34;]}}}},</span>
<span>--                               k(CL_LIB[&#34;FROM-END&#34;], CL[&#34;T&#34;].bound))</span>

<span>read</span><span>(</span><span>&#34;(reduce #&#39;cons &#39;(1 2 3 4) :from-end t)&#34;</span><span>)</span>
<span>-- Prints: (REDUCE (FUNCTION CONS) (QUOTE (1 2 3 4)) :FROM-END T)</span>

<span>read</span><span>(</span><span>&#34;#.(reduce #&#39;cons &#39;(1 2 3 4) :from-end t)&#34;</span><span>)</span>
<span>-- Prints: (1 2 3 . 4)</span></code></pre>
</div>
</div></div>
  </body>
</html>
