<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/minborg/articles/tree/jep442/2023/March/22-jep442-FFM-Third-Preview">Original</a>
    <h1>JEP 442: Foreign Function and Memory API (Third Preview)</h1>
    
    <div id="readability-page-1" class="page"><div dir="auto">
<p dir="auto">In this chapter, we will explore some of the basic features of the FFM API. The examples below will run <strong>only when <a href="https://github.com/openjdk/jdk/pull/13079" data-hovercard-type="pull_request" data-hovercard-url="/openjdk/jdk/pull/13079/hovercard">this PR</a> is merged</strong> into the Java mainline repo and only in JDK 21.</p>
<div dir="auto">
<h3 id="user-content-allocate-native-memory" tabindex="-1" dir="auto"><a id="user-content-allocate-native-memory" aria-hidden="true" href="#allocate-native-memory"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocate Native Memory</h3>
<p dir="auto">Here is an example of how to allocate 16 bytes of native memory that is automatically managed by the garbage collector (GC).</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="{
    // ...
    MemorySegment segment = Arena.ofAuto().allocate(16);
    // ...
} // Segment eligible for collection by the GC here.
  // Actual time of collection is unspecified."><pre>{
    <span>// ...</span>
    <span>MemorySegment</span> <span>segment</span> = <span>Arena</span>.<span>ofAuto</span>().<span>allocate</span>(<span>16</span>);
    <span>// ...</span>
} <span>// Segment eligible for collection by the GC here.</span>
  <span>// Actual time of collection is unspecified.</span></pre></div>
</div>
</div>
</div>
<div dir="auto">
<h3 id="user-content-allocate-native-memory-deterministically" tabindex="-1" dir="auto"><a id="user-content-allocate-native-memory-deterministically" aria-hidden="true" href="#allocate-native-memory-deterministically"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocate Native Memory Deterministically</h3>
<p dir="auto">Here is another example where memory is implicitly and deterministically
released:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="try (var arena = Arena.ofConfined()) {
    var segment = arena.allocate(16);
} // Segment is deterministically freed here"><pre><span>try</span> (<span>var</span> <span>arena</span> = <span>Arena</span>.<span>ofConfined</span>()) {
    <span>var</span> <span>segment</span> = <span>arena</span>.<span>allocate</span>(<span>16</span>);
} <span>// Segment is deterministically freed here</span></pre></div>
</div>
</div>
</div>
<div dir="auto">
<h3 id="user-content-work-with-memory-layouts" tabindex="-1" dir="auto"><a id="user-content-work-with-memory-layouts" aria-hidden="true" href="#work-with-memory-layouts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Work with Memory Layouts</h3>
<p dir="auto">Memory layouts can be used to describe the layout of a <code>MemorySegment</code>. Here is how a Point with <code>int</code> coordinates can be defined:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.MemoryLayout.*;
import static java.lang.foreign.ValueLayout.*;

private static final MemoryLayout POINT = structLayout(
        JAVA_INT.withName(&#34;x&#34;),
        JAVA_INT.withName(&#34;y&#34;)
).withName(&#34;point&#34;);

// Accessor for x
private static final VarHandle X = POINT.varHandle(groupElement(&#34;x&#34;));
// Accessor for y
private static final VarHandle Y = POINT.varHandle(groupElement(&#34;y&#34;));"><pre><span>import</span> <span>static</span> <span>java</span>.<span>lang</span>.<span>foreign</span>.<span>MemoryLayout</span>.<span>PathElement</span>.*;
<span>import</span> <span>static</span> <span>java</span>.<span>lang</span>.<span>foreign</span>.<span>MemoryLayout</span>.*;
<span>import</span> <span>static</span> <span>java</span>.<span>lang</span>.<span>foreign</span>.<span>ValueLayout</span>.*;

<span>private</span> <span>static</span> <span>final</span> <span>MemoryLayout</span> <span>POINT</span> = <span>structLayout</span>(
        <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;x&#34;</span>),
        <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;y&#34;</span>)
).<span>withName</span>(<span>&#34;point&#34;</span>);

<span>// Accessor for x</span>
<span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>X</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;x&#34;</span>));
<span>// Accessor for y</span>
<span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>Y</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;y&#34;</span>));</pre></div>
</div>
</div>
<p dir="auto">Armed with these static variables, we can (somewhat manually) roll a memory-segment-backed point:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="try (var arena = Arena.ofConfined()) {
    MemorySegment point = arena.allocate(POINT);
    X.set(point, 3);
    Y.set(point, 4);
    System.out.println(
            Arrays.toString(point.toArray(JAVA_INT))
    );
} // Point is deterministically freed here"><pre><span>try</span> (<span>var</span> <span>arena</span> = <span>Arena</span>.<span>ofConfined</span>()) {
    <span>MemorySegment</span> <span>point</span> = <span>arena</span>.<span>allocate</span>(<span>POINT</span>);
    <span>X</span>.<span>set</span>(<span>point</span>, <span>3</span>);
    <span>Y</span>.<span>set</span>(<span>point</span>, <span>4</span>);
    <span>System</span>.<span>out</span>.<span>println</span>(
            <span>Arrays</span>.<span>toString</span>(<span>point</span>.<span>toArray</span>(<span>JAVA_INT</span>))
    );
} <span>// Point is deterministically freed here</span></pre></div>
</div>
</div>
<p dir="auto">When run, this program will produce the following output:</p>

</div>
<div dir="auto">
<h3 id="user-content-encapsulating-memory-layouts" tabindex="-1" dir="auto"><a id="user-content-encapsulating-memory-layouts" aria-hidden="true" href="#encapsulating-memory-layouts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Encapsulating Memory Layouts</h3>
<p dir="auto">It is often better to encapsulate the inner workings of constructs that are using memory layouts. Here is how a custom <code>Point</code> class can be written using a backing native <code>MemorySegment</code>:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="static final class Point {

    private static final MemoryLayout POINT = structLayout(
            JAVA_INT.withName(&#34;x&#34;),
            JAVA_INT.withName(&#34;y&#34;)
    ).withName(&#34;point&#34;);

    private static final VarHandle X = POINT.varHandle(groupElement(&#34;x&#34;));
    private static final VarHandle Y = POINT.varHandle(groupElement(&#34;y&#34;));

    private final MemorySegment segment;

    public Point(Arena arena) {
        this.segment = arena.allocate(POINT);
    }

    int x() {
        return (int) X.get(segment);
    }

    int y() {
       return (int) Y.get(segment);
    }

    void x(int x) {
       X.set(segment, x);
    }

    void y(int y) {
        Y.set(segment, y);
    }

    @Override
    public String toString() {
        return &#34;(&#34; + x() + &#34;, &#34; + y() + &#34;)&#34;;
    }

    @Override
    public boolean equals(Object o) {
        return o instanceof Point that &amp;&amp;
                this.x() == that.x() &amp;&amp;
                this.x() == that.y();
    }

    @Override
    public int hashCode() {
        return Objects.hash(x(), y());
    }
}"><pre><span>static</span> <span>final</span> <span>class</span> <span>Point</span> {

    <span>private</span> <span>static</span> <span>final</span> <span>MemoryLayout</span> <span>POINT</span> = <span>structLayout</span>(
            <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;x&#34;</span>),
            <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;y&#34;</span>)
    ).<span>withName</span>(<span>&#34;point&#34;</span>);

    <span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>X</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;x&#34;</span>));
    <span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>Y</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;y&#34;</span>));

    <span>private</span> <span>final</span> <span>MemorySegment</span> <span>segment</span>;

    <span>public</span> <span>Point</span>(<span>Arena</span> <span>arena</span>) {
        <span>this</span>.<span>segment</span> = <span>arena</span>.<span>allocate</span>(<span>POINT</span>);
    }

    <span>int</span> <span>x</span>() {
        <span>return</span> (<span>int</span>) <span>X</span>.<span>get</span>(<span>segment</span>);
    }

    <span>int</span> <span>y</span>() {
       <span>return</span> (<span>int</span>) <span>Y</span>.<span>get</span>(<span>segment</span>);
    }

    <span>void</span> <span>x</span>(<span>int</span> <span>x</span>) {
       <span>X</span>.<span>set</span>(<span>segment</span>, <span>x</span>);
    }

    <span>void</span> <span>y</span>(<span>int</span> <span>y</span>) {
        <span>Y</span>.<span>set</span>(<span>segment</span>, <span>y</span>);
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>String</span> <span>toString</span>() {
        <span>return</span> <span>&#34;(&#34;</span> + <span>x</span>() + <span>&#34;, &#34;</span> + <span>y</span>() + <span>&#34;)&#34;</span>;
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span>(<span>Object</span> <span>o</span>) {
        <span>return</span> <span>o</span> <span>instanceof</span> <span>Point</span> <span>that</span> &amp;&amp;
                <span>this</span>.<span>x</span>() == <span>that</span>.<span>x</span>() &amp;&amp;
                <span>this</span>.<span>x</span>() == <span>that</span>.<span>y</span>();
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>int</span> <span>hashCode</span>() {
        <span>return</span> <span>Objects</span>.<span>hash</span>(<span>x</span>(), <span>y</span>());
    }
}</pre></div>
</div>
</div>
<p dir="auto">Note that the <code>VarHandle</code> objects are declared <code>static final</code> and that there are explicit <code>(int)</code> casts for the getters <code>x()</code> and <code>y()</code>. Failure to observe these coding conventions will reduce performance substantially.</p>
<p dir="auto">Also note that we are passing an <code>Arena</code> to the constructor so that we can control the lifecycle of the <code>MemorySegment</code> used. Here is how the <code>Point</code> class can be used:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="try (var arena = Arena.ofConfined()) {
    var point = new Point(arena);
    point.x(3);
    point.y(4);
    System.out.println(point);
} // Point is deterministically freed here"><pre><span>try</span> (<span>var</span> <span>arena</span> = <span>Arena</span>.<span>ofConfined</span>()) {
    <span>var</span> <span>point</span> = <span>new</span> <span>Point</span>(<span>arena</span>);
    <span>point</span>.<span>x</span>(<span>3</span>);
    <span>point</span>.<span>y</span>(<span>4</span>);
    <span>System</span>.<span>out</span>.<span>println</span>(<span>point</span>);
} <span>// Point is deterministically freed here</span></pre></div>
</div>
</div>
<p dir="auto">When run, this program will produce the following output:</p>

</div>
<div dir="auto">
<h3 id="user-content-writing-an-abstract-segment-wrapper" tabindex="-1" dir="auto"><a id="user-content-writing-an-abstract-segment-wrapper" aria-hidden="true" href="#writing-an-abstract-segment-wrapper"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing an Abstract Segment Wrapper</h3>
<p dir="auto">We could easily create a generic <code>MemorySegment</code> wrapper that relieve us from the burden of writing a segment declaration, custom constructors, <code>toString()</code>, <code>hashCode()</code> and, <code>equals()</code> methods in inheriting classes:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="public abstract class AbstractSegmentWrapper {

    private final MemorySegment segment;

    protected AbstractSegmentWrapper(Arena arena) {
        this.segment = arena.allocate(layout());
    }

    abstract protected StructLayout layout();

    abstract protected List&lt;VarHandle&gt; varHandles();

    protected MemorySegment segment() {
        return segment;
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + layout().memberLayouts()
                .stream()
                .map(l -&gt; l.name().orElse(l.toString()) + &#34;=&#34; + l.varHandle().get(segment))
                .collect(Collectors.joining(&#34;, &#34;, &#34;{&#34;, &#34;}&#34;));
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || !getClass().equals(o.getClass())) {
            return false;
        }
        AbstractSegmentWrapper that = (AbstractSegmentWrapper) o;
        return varHandles().stream()
                .allMatch(vh -&gt; Objects.equals(vh.get(this.segment), vh.get(that.segment)));
    }

    @Override
    public int hashCode() {
        return varHandles().stream()
                .map(vh -&gt; vh.get(segment))
                .mapToInt(v -&gt; v == null ? 0 : v.hashCode())
                .reduce(1, (a, b) -&gt; a * 31 + b);
    }

}"><pre><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractSegmentWrapper</span> {

    <span>private</span> <span>final</span> <span>MemorySegment</span> <span>segment</span>;

    <span>protected</span> <span>AbstractSegmentWrapper</span>(<span>Arena</span> <span>arena</span>) {
        <span>this</span>.<span>segment</span> = <span>arena</span>.<span>allocate</span>(<span>layout</span>());
    }

    <span>abstract</span> <span>protected</span> <span>StructLayout</span> <span>layout</span>();

    <span>abstract</span> <span>protected</span> <span>List</span>&lt;<span>VarHandle</span>&gt; <span>varHandles</span>();

    <span>protected</span> <span>MemorySegment</span> <span>segment</span>() {
        <span>return</span> <span>segment</span>;
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>String</span> <span>toString</span>() {
        <span>return</span> <span>getClass</span>().<span>getSimpleName</span>() + <span>layout</span>().<span>memberLayouts</span>()
                .<span>stream</span>()
                .<span>map</span>(<span>l</span> -&gt; <span>l</span>.<span>name</span>().<span>orElse</span>(<span>l</span>.<span>toString</span>()) + <span>&#34;=&#34;</span> + <span>l</span>.<span>varHandle</span>().<span>get</span>(<span>segment</span>))
                .<span>collect</span>(<span>Collectors</span>.<span>joining</span>(<span>&#34;, &#34;</span>, <span>&#34;{&#34;</span>, <span>&#34;}&#34;</span>));
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span>(<span>Object</span> <span>o</span>) {
        <span>if</span> (<span>o</span> == <span>null</span> || !<span>getClass</span>().<span>equals</span>(<span>o</span>.<span>getClass</span>())) {
            <span>return</span> <span>false</span>;
        }
        <span>AbstractSegmentWrapper</span> <span>that</span> = (<span>AbstractSegmentWrapper</span>) <span>o</span>;
        <span>return</span> <span>varHandles</span>().<span>stream</span>()
                .<span>allMatch</span>(<span>vh</span> -&gt; <span>Objects</span>.<span>equals</span>(<span>vh</span>.<span>get</span>(<span>this</span>.<span>segment</span>), <span>vh</span>.<span>get</span>(<span>that</span>.<span>segment</span>)));
    }

    <span>@</span><span>Override</span>
    <span>public</span> <span>int</span> <span>hashCode</span>() {
        <span>return</span> <span>varHandles</span>().<span>stream</span>()
                .<span>map</span>(<span>vh</span> -&gt; <span>vh</span>.<span>get</span>(<span>segment</span>))
                .<span>mapToInt</span>(<span>v</span> -&gt; <span>v</span> == <span>null</span> ? <span>0</span> : <span>v</span>.<span>hashCode</span>())
                .<span>reduce</span>(<span>1</span>, (<span>a</span>, <span>b</span>) -&gt; <span>a</span> * <span>31</span> + <span>b</span>);
    }

}</pre></div>
</div>
</div>
<p dir="auto">Using the abstract class above, we could more easily create wrapper classes like <code>Point</code> here:</p>
<div dir="auto">
<div dir="auto">
<div dir="auto" data-snippet-clipboard-copy-content="public final class Point extends AbstractSegmentWrapper {

    private static final StructLayout POINT = structLayout(
            JAVA_INT.withName(&#34;x&#34;),
            JAVA_INT.withName(&#34;y&#34;)
    ).withName(&#34;point&#34;);

    private static final VarHandle X = POINT.varHandle(groupElement(&#34;x&#34;));
    private static final VarHandle Y = POINT.varHandle(groupElement(&#34;y&#34;));

    private static final List&lt;VarHandle&gt; VAR_HANDLES = List.of(X, Y);

    public Point(Arena arena) {
        super(arena);
    }

    @Override
    protected StructLayout layout() {
        return POINT;
    }

    @Override
    protected List&lt;VarHandle&gt; varHandles() {
        return VAR_HANDLES;
    }

    int x() {
        return (int) X.get(segment());
    }

    int y() {
        return (int) Y.get(segment());
    }

    void x(int x) {
        X.set(segment(), x);
    }

    void y(int y) {
        Y.set(segment(), y);
    }

}"><pre><span>public</span> <span>final</span> <span>class</span> <span>Point</span> <span>extends</span> <span>AbstractSegmentWrapper</span> {

    <span>private</span> <span>static</span> <span>final</span> <span>StructLayout</span> <span>POINT</span> = <span>structLayout</span>(
            <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;x&#34;</span>),
            <span>JAVA_INT</span>.<span>withName</span>(<span>&#34;y&#34;</span>)
    ).<span>withName</span>(<span>&#34;point&#34;</span>);

    <span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>X</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;x&#34;</span>));
    <span>private</span> <span>static</span> <span>final</span> <span>VarHandle</span> <span>Y</span> = <span>POINT</span>.<span>varHandle</span>(<span>groupElement</span>(<span>&#34;y&#34;</span>));

    <span>private</span> <span>static</span> <span>final</span> <span>List</span>&lt;<span>VarHandle</span>&gt; <span>VAR_HANDLES</span> = <span>List</span>.<span>of</span>(<span>X</span>, <span>Y</span>);

    <span>public</span> <span>Point</span>(<span>Arena</span> <span>arena</span>) {
        <span>super</span>(<span>arena</span>);
    }

    <span>@</span><span>Override</span>
    <span>protected</span> <span>StructLayout</span> <span>layout</span>() {
        <span>return</span> <span>POINT</span>;
    }

    <span>@</span><span>Override</span>
    <span>protected</span> <span>List</span>&lt;<span>VarHandle</span>&gt; <span>varHandles</span>() {
        <span>return</span> <span>VAR_HANDLES</span>;
    }

    <span>int</span> <span>x</span>() {
        <span>return</span> (<span>int</span>) <span>X</span>.<span>get</span>(<span>segment</span>());
    }

    <span>int</span> <span>y</span>() {
        <span>return</span> (<span>int</span>) <span>Y</span>.<span>get</span>(<span>segment</span>());
    }

    <span>void</span> <span>x</span>(<span>int</span> <span>x</span>) {
        <span>X</span>.<span>set</span>(<span>segment</span>(), <span>x</span>);
    }

    <span>void</span> <span>y</span>(<span>int</span> <span>y</span>) {
        <span>Y</span>.<span>set</span>(<span>segment</span>(), <span>y</span>);
    }

}</pre></div>
</div>
</div>
<p dir="auto">As always, it is important to declare the <code>MethodHandle</code> instances <code>final</code>.</p>
</div>
<div dir="auto">
<h3 id="user-content-call-a-native-method" tabindex="-1" dir="auto"><a id="user-content-call-a-native-method" aria-hidden="true" href="#call-a-native-method"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Call a Native Method</h3>
<p dir="auto">With FFM, it is possible to call many native functions directly. Below is an example where we invoke the system library call  <a href="https://man7.org/linux/man-pages/man3/strlen.3.html" rel="nofollow">&#39;strlen&#39;</a> directly from Java. This is made in two steps where, in step one, we obtain a <code>MethodHandle</code> for the native method:</p>
<div dir="auto">
<div dir="auto">
<div data-snippet-clipboard-copy-content="Linker linker = Linker.nativeLinker();
MethodHandle strlen = linker.downcallHandle(
        linker.defaultLookup().find(&#34;strlen&#34;).get(),
        FunctionDescriptor.of(JAVA_LONG, ADDRESS)
);"><pre lang="text"><code>Linker linker = Linker.nativeLinker();
MethodHandle strlen = linker.downcallHandle(
        linker.defaultLookup().find(&#34;strlen&#34;).get(),
        FunctionDescriptor.of(JAVA_LONG, ADDRESS)
);</code></pre></div>
</div>
</div>
<p dir="auto">With the <code>MethodHandle</code> <code>strlen</code>, we can, in a second step, easily invoke the method directly from Java:</p>
<div dir="auto">
<div dir="auto">
<div data-snippet-clipboard-copy-content="try (Arena arena = Arena.ofConfined()) {
    MemorySegment str = arena.allocateUtf8String(&#34;Hello&#34;);
    long len = (long) strlen.invoke(str);
    System.out.println(&#34;The length is &#34; + len);
}"><pre lang="text"><code>try (Arena arena = Arena.ofConfined()) {
    MemorySegment str = arena.allocateUtf8String(&#34;Hello&#34;);
    long len = (long) strlen.invoke(str);
    System.out.println(&#34;The length is &#34; + len);
}</code></pre></div>
</div>
</div>
<p dir="auto">When run, this program will produce the following output:</p>

<p dir="auto">This is correct as &#34;Hello&#34; consists of five ASCII characters (not including the terminating &#39;/0&#39; character used by C/C++).</p>
</div>
</div></div>
  </body>
</html>
