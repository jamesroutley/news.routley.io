<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/installing-npm-packages-very-quickly">Original</a>
    <h1>Installing NPM Packages Very Quickly</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Some package managers are faster than others. The early JavaScript package managers, <a href="https://docs.npmjs.com/cli/v11">npm</a> and <a href="https://yarnpkg.com/">yarn</a>, are commonly replaced by faster alternatives like <a href="https://bun.sh/">bun</a> and <a href="https://pnpm.io/">pnpm</a>. I&#39;ve also seen benchmarks between package managers where the performance gap is rather large – but I&#39;m not sure why one package manager would ever be significantly faster than another.</p><p>To understand more about package manager performance, I traced some call paths through bun&#39;s <a href="https://github.com/oven-sh/bun">Zig codebase</a> and pnpm&#39;s <a href="https://github.com/pnpm/pnpm">TypeScript codebase</a> but I was still missing some details about the performance challenges these projects were taking on.</p><p>So I built my own toy package manager called <a href="https://github.com/healeycodes/caladan">caladan</a>. For now, it just does two things: install npm packages from a valid <code>package-lock.json</code> file and run <a href="https://docs.npmjs.com/cli/v11/configuring-npm/package-json#bin">bin scripts</a>.</p><p>I wanted to get close to the cold install performance of <code>bun</code> and I&#39;m pretty happy with the results. Benchmarks are usually incorrect so there&#39;s a good chance I&#39;m being unfair to <code>bun</code> here. Here are the results nonetheless:</p><pre><div><div><p><span># ran on m1 mac w/ 600mbps network, bun v1.2.5</span><span></span></p><p><span></span><span># both have an equivalent lockfile with 16 packages (311mb on disk)</span><span></span></p><p><span></span><span># cache is cleared before each run with `bun pm cache rm &amp;&amp; rm -rf node_modules`</span><span></span></p><p><span>./benchmark.sh</span></p><p><span>Benchmark </span><span>1</span><span>: ./caladan install-lockfile fixtures/1</span></p><p><span>  Time </span><span>(</span><span>mean ± σ</span><span>)</span><span>:      </span><span>1.767</span><span> s ±  </span><span>0.052</span><span> s    </span><span>[</span><span>User: </span><span>2.168</span><span> s, System: </span><span>2.236</span><span> s</span><span>]</span><span></span></p><p><span>  Range </span><span>(</span><span>min … max</span><span>)</span><span>:    </span><span>1.729</span><span> s …  </span><span>1.857</span><span> s    </span><span>5</span><span> runs</span></p><p><span>Benchmark </span><span>2</span><span>: bun </span><span>install</span><span> --force --ignore-scripts --no-cache --network-concurrency </span><span>64</span><span></span></p><p><span>  Time </span><span>(</span><span>mean ± σ</span><span>)</span><span>:      </span><span>1.587</span><span> s ±  </span><span>0.097</span><span> s    </span><span>[</span><span>User: </span><span>0.496</span><span> s, System: </span><span>1.293</span><span> s</span><span>]</span><span></span></p><p><span>  Range </span><span>(</span><span>min … max</span><span>)</span><span>:    </span><span>1.486</span><span> s …  </span><span>1.693</span><span> s    </span><span>5</span><span> runs</span></p><p><span>Summary</span></p><p><span>  bun </span><span>install</span><span> --force --ignore-scripts --no-cache --network-concurrency </span><span>64</span><span> ran</span></p><p><span>    </span><span>1.11</span><span> ± </span><span>0.08</span><span> </span><span>times</span><span> faster than ./caladan install-lockfile fixtures/1</span></p></div></div></pre><p>The much lower <a href="https://en.wikipedia.org/wiki/CPU_time#User_and_System_time">user time</a> of <code>bun</code> points to its efficient Zig codebase. Seeing similar-ish system times and overall wall clock times suggests that both tools have the same fundamental limits (whether network, disk I/O, or system call overhead). On a faster and more capable machine, <code>bun</code> would be able to make better use of the available resources.</p><p>To verify that my package manager is doing the same work, I checked that the sizes of the directories inside <code>node_modules</code> were comparable, and I checked that the bin scripts ran without any errors (e.g. <code>nanoid</code>, <code>next</code>, and <code>image-size</code>).</p><pre><div><div><p><span>./caladan run fixtures/1 nanoid     </span></p><p><span>Running nanoid with args: </span><span>[</span><span>]</span><span></span></p><p><span>Working directory: fixtures/1</span></p><p><span>guxvWmbNcvIuAowqzrnEu</span></p></div></div></pre><p>The benchmark script is <a href="https://github.com/healeycodes/caladan">open source</a> and hopefully you&#39;ll correct me if I&#39;ve set it up unfairly.</p><p>I&#39;ll outline my efforts to get close to <code>bun</code>&#39;s cold install performance in the following sections.</p><h2 id="installing-a-package">Installing a Package</h2><p><code>package-lock.json</code> is automatically generated by the <em>previous install</em> to lock the exact versions of all dependencies (and their dependencies) in a Node.js project. It ensures consistent installations across different environments by recording the precise dependency tree at the previous install.</p><p>It&#39;s mostly made up of dependency entries like this:</p><pre><div><div><p><span>  </span><span>&#34;dependencies&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span>    </span><span>&#34;date-fns&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>&#34;2.29.3&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;resolved&#34;</span><span>:</span><span> </span><span>&#34;&lt;https://registry.npmjs.org/date-fns/-/date-fns-2.29.3.tgz&gt;&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;integrity&#34;</span><span>:</span><span> </span><span>&#34;sha512-dDCnyH2WnnKusqvZZ6+jA1O51Ibt8ZMRNkDZdyAyK4YfbDwa/cEmuztzG5pk6hqlp9aSBPYcjOlktquahGwGeA==&#34;</span><span></span></p><p><span>  </span><span>}</span><span>,</span></p></div></div></pre><p>Our job, as a minimal package manager, is to install all of these dependencies.</p><ol start="1"><li>Parse <code>package-lock.json</code></li><li>Download the compressed files from <code>resolved</code></li><li>Verify their <code>integrity</code> by calculating the hash of these files</li><li>Extract them to <code>node_modules</code></li><li>Parse <code>node_modules/$package/package.json</code> and check for a <code>bin</code> property</li><li>(If so, create a symlink inside <code>node_modules/.bin/$package</code>)</li></ol><p><em>Not listed here are other features like pre- and post-install scripts that I haven&#39;t implemented. I think I&#39;m also missing some validation steps (e.g. checking if <code>package.json</code> differs from the lockfile).</em></p><p>To get everything working, I started by implementing these steps to run sequentially. It was very slow and took, like, ~30sec to install all the packages for my small project.</p><p>I got a 2x improvement by skipping installing extra packages when I didn&#39;t need them (i.e. by filtering by OS). On my MacBook, I don&#39;t need to install <code>node_modules/@next/swc-darwin-x64</code> but I <em>do</em> need to install <code>node_modules/@next/swc-darwin-arm64</code>.</p><p>The next big improvement was to run things in parallel. I put each package&#39;s download-and-extract step in its own goroutine and stuck them in an <a href="https://pkg.go.dev/golang.org/x/sync/errgroup">errgroup</a>.</p><pre><div><div><p><span>g </span><span>:=</span><span> errgroup</span><span>.</span><span>Group</span><span>{</span><span>}</span><span></span></p><p><span></span><span>// Process each package in parallel</span><span></span></p><p><span></span><span>for</span><span> pkgName</span><span>,</span><span> pkgInfo </span><span>:=</span><span> </span><span>range</span><span> packages </span><span>{</span><span></span></p><p><span>    g</span><span>.</span><span>Go</span><span>(</span><span>func</span><span>(</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Skip OS-specific packages that don&#39;t match current OS</span><span></span></p><p><span>        </span><span>// ..</span><span></span></p><p><span>        </span><span>// Create package directory</span><span></span></p><p><span>        </span><span>// ..</span><span></span></p><p><span>        </span><span>// Normalize package path</span><span></span></p><p><span>        </span><span>// ..</span><span></span></p><p><span>        </span><span>// Download the package tarball</span><span></span></p><p><span>        </span><span>DownloadAndExtractPackage</span><span>(</span><span></span></p><p><span>          ctx</span><span>,</span><span></span></p><p><span>          httpSemaphore</span><span>,</span><span></span></p><p><span>          tarSemaphore</span><span>,</span><span></span></p><p><span>          client</span><span>,</span><span></span></p><p><span>          pkgInfo</span><span>.</span><span>Resolved</span><span>,</span><span></span></p><p><span>          pkgInfo</span><span>.</span><span>Integrity</span><span>,</span><span></span></p><p><span>          pkgPath</span></p><p><span>        </span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>nil</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Wait for all packages to complete</span><span></span></p><p><span>err </span><span>:=</span><span> g</span><span>.</span><span>Wait</span><span>(</span><span>)</span><span></span></p><p><span></span><span>// ..</span></p></div></div></pre><p>This was much faster than doing everything sequentially. However, without limits on parallelism, there was resource contention in two areas: HTTP requests, and unzipping files.</p><h2 id="comparing-cpu-profiles">Comparing CPU Profiles</h2><p>From reading their codebases, I knew that bun and pnpm used different levels of concurrency for HTTP requests and unzipping files.</p><p>When I added separate semaphores around these steps, the performance of my install step improved by ~20% for the small project I&#39;ve been testing. I knew intuitively that these semaphores helped with resource contention but I thought it would be interesting to prove this using profiling tools.</p><p>I&#39;ve chosen to highlight the effect of adding the semaphore for unzipping files as the performance improvement is more significant there.</p><p>In my program, I have an env var that allows me to output CPU profiles:</p><pre><div><div><p><span>if</span><span> cpuProfilePath </span><span>:=</span><span> os</span><span>.</span><span>Getenv</span><span>(</span><span>&#34;CPU_PROFILE&#34;</span><span>)</span><span>;</span><span> cpuProfilePath </span><span>!=</span><span> </span><span>&#34;&#34;</span><span> </span><span>{</span><span></span></p><p><span>    f</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Create</span><span>(</span><span>cpuProfilePath</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Error creating CPU profile file: %v\n&#34;</span><span>,</span><span> err</span><span>)</span><span></span></p><p><span>        os</span><span>.</span><span>Exit</span><span>(</span><span>1</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    pprof</span><span>.</span><span>StartCPUProfile</span><span>(</span><span>f</span><span>)</span><span></span></p><p><span>    </span><span>defer</span><span> pprof</span><span>.</span><span>StopCPUProfile</span><span>(</span><span>)</span><span></span></p><p><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;CPU profiling enabled, writing to: %s\n&#34;</span><span>,</span><span> cpuProfilePath</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>I used pprof&#39;s <code>-text</code> output to compare two different profiles (with unzip sema and without it) side-by-side in my code editor:</p><pre><div><div><p><span>go</span><span> tool pprof </span><span>-</span><span>text cpu_without_sema</span><span>.</span><span>prof </span><span>&gt;</span><span> cpu_without_sema</span><span>.</span><span>txt</span></p><p><span></span><span>go</span><span> tool pprof </span><span>-</span><span>text cpu_with_sema</span><span>.</span><span>prof </span><span>&gt;</span><span> cpu_with_sema</span><span>.</span><span>txt</span></p></div></div></pre><h3 id="decompression-performance-improvement"><strong>Decompression Performance Improvement</strong></h3><p>With the semaphore, the core decompression functions represented less of the overall percentage of program time, and were also quicker to run. Below is the profile data for <code>huffmanBlock</code> (decoding a single Huffman block), and <code>huffSym</code> (reading the next Huffman-encoded symbol).</p><pre><div><div><p><span># with semaphore</span></p><p><span> flat  flat%   sum%        cum   cum%</span></p><p><span>0.11s  1.94% 89.22%      0.42s  7.42%  compress/flate.(*decompressor).huffmanBlock</span></p><p><span>0.11s  1.94% 87.28%      0.19s  3.36%  compress/flate.(*decompressor).huffSym</span></p><p><span># without semaphore</span></p><p><span> flat  flat%   sum%        cum   cum%</span></p><p><span>0.11s  1.88% 88.57%      0.51s  8.70%  compress/flate.(*decompressor).huffmanBlock</span></p><p><span>0.19s  3.24% 82.08%      0.29s  4.95%  compress/flate.(*decompressor).huffSym</span></p></div></div></pre><p>There was also a ~5% decrease in the time spent waiting on system calls (<code>syscall.syscall</code>) and I/O (<code>os.(*File).Write</code> and <code>os.(*File).ReadFrom</code>).</p><h3 id="more-detail-on-why">More Detail on Why</h3><p>The semaphore limits the number of concurrent extraction operations, preventing CPU, memory, and I/O contention. By matching the extraction concurrency to available CPU resources (using 1.5x cores), the system avoids thrashing and context switching.</p><p>Notably, there was an increase in &#34;scheduling time&#34; which may seem counterintuitive but here it&#39;s desirable as it means synchronization is more orderly and predictable and there&#39;s less chaotic contention for system resources:</p><pre><div><div><p><span>runtime.schedule       +2.70%</span></p><p><span>runtime.park_m         +1.23%</span></p><p><span>runtime.gopreempt_m    +0.42%</span></p><p><span>runtime.goschedImpl    +0.42%</span></p><p><span>runtime.notewakeup     +0.21%</span></p><p><span>runtime.lock           +1.31%</span></p><p><span>runtime.lockWithRank   +1.31%</span></p><p><span>runtime.lock2          +1.31%</span></p></div></div></pre><p>We traded a small amount of scheduling time for faster I/O and faster decompression (CPU).</p><h2 id="keeping-things-in-memory">Keeping Things in Memory</h2><p>One of the ways you can be fast is to avoid disk operations altogether. This was the final optimization I added. Initially, I downloaded each package to a temporary file and then extracted it into <code>node_modules</code>.</p><p>I realized I could do everything at the same time using the HTTP response stream:</p><ul><li>Download the bytes of the archive</li><li>Extract directly to the final location</li><li>Calculate the hash as we go so we can verify each package&#39;s <a href="https://docs.npmjs.com/cli/v9/configuring-npm/package-lock-json#dependencies">integrity</a></li></ul><pre><div><div><p><span>// DownloadAndExtractPackage downloads a package tarball and extracts it</span><span></span></p><p><span></span><span>func</span><span> </span><span>DownloadAndExtractPackage</span><span>(</span><span>ctx context</span><span>.</span><span>Context</span><span>,</span><span> httpSemaphore</span><span>,</span><span> tarSemaphore </span><span>*</span><span>semaphore</span><span>.</span><span>Weighted</span><span>,</span><span> client </span><span>*</span><span>http</span><span>.</span><span>Client</span><span>,</span><span> url</span><span>,</span><span> integrity</span><span>,</span><span> destPath </span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>    httpSemaphore</span><span>.</span><span>Acquire</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>1</span><span>)</span><span></span></p><p><span>    </span><span>defer</span><span> httpSemaphore</span><span>.</span><span>Release</span><span>(</span><span>1</span><span>)</span><span></span></p><p><span>    </span><span>// Request the tarball</span><span></span></p><p><span>    resp</span><span>,</span><span> err </span><span>:=</span><span> client</span><span>.</span><span>Get</span><span>(</span><span>url</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>return</span><span> fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;error downloading package: %v&#34;</span><span>,</span><span> err</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>defer</span><span> resp</span><span>.</span><span>Body</span><span>.</span><span>Close</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// Setup hash verification</span><span></span></p><p><span>    </span><span>var</span><span> hash </span><span>interface</span><span> </span><span>{</span><span></span></p><p><span>        io</span><span>.</span><span>Writer</span></p><p><span>        </span><span>Sum</span><span>(</span><span>)</span><span> </span><span>[</span><span>]</span><span>byte</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span>    </span><span>// Use a TeeReader to compute hash while reading</span><span></span></p><p><span>    teeReader </span><span>:=</span><span> io</span><span>.</span><span>TeeReader</span><span>(</span><span>resp</span><span>.</span><span>Body</span><span>,</span><span> hash</span><span>)</span><span></span></p><p><span>    reader </span><span>:=</span><span> teeReader</span></p><p><span>    tarSemaphore</span><span>.</span><span>Acquire</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>1</span><span>)</span><span></span></p><p><span>    </span><span>defer</span><span> tarSemaphore</span><span>.</span><span>Release</span><span>(</span><span>1</span><span>)</span><span></span></p><p><span>    </span><span>// Extract directly from the download stream</span><span></span></p><p><span>    err </span><span>:=</span><span> </span><span>extractTarGz</span><span>(</span><span>reader</span><span>,</span><span> destPath</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>return</span><span> fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;error extracting package: %v&#34;</span><span>,</span><span> err</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Compare hashes</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>nil</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>In a way, everything gets blocked on the semaphore that wraps the extracting step. But seeing as it&#39;s an order of magnitude faster than downloading bytes over the network, it feels like a good design.</p><h2 id="running-scripts">Running Scripts</h2><p>The final part of my package manager program configures the symlinks for any <a href="https://docs.npmjs.com/cli/v11/configuring-npm/package-json#bin">bin scripts</a> that the packages might have. It also runs them when invoked with <code>caladan run &lt;directory&gt; &lt;script&gt; &lt;args&gt;</code>.</p><p>After a package is downloaded to <code>node_modules/$package/</code> it has a <code>package.json</code> file which may have a <code>bin</code> property.</p><p>For example, <code>nanoid</code> has:</p><pre><div><div><p><span>&#34;bin&#34;</span><span>:</span><span> </span><span>&#34;./bin/nanoid.cjs&#34;</span><span>,</span></p></div></div></pre><p>Which means there&#39;s a file at <code>node_modules/nanoid/bin/nanoid.cjs</code> that we need to create an executable symlink for at <code>node_modules/.bin/nanoid</code>.</p><p>The hardest part is getting the relative file paths correct and ensuring that args are passed correctly. Running the script isn&#39;t too hard. It&#39;s effectively just <code>exec.Command</code>.</p><pre><div><div><p><span>func</span><span> </span><span>Run</span><span>(</span><span>directory </span><span>string</span><span>,</span><span> args </span><span>[</span><span>]</span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// Set up command to run script using project-relative path</span><span></span></p><p><span>    binScriptName </span><span>:=</span><span> filepath</span><span>.</span><span>Join</span><span>(</span><span>&#34;./node_modules/.bin&#34;</span><span>,</span><span> scriptName</span><span>)</span><span></span></p><p><span>    cmd </span><span>:=</span><span> exec</span><span>.</span><span>Command</span><span>(</span><span>&#34;sh&#34;</span><span>,</span><span> </span><span>&#34;-c&#34;</span><span>,</span><span> binScriptName</span><span>+</span><span>&#34; &#34;</span><span>+</span><span>strings</span><span>.</span><span>Join</span><span>(</span><span>scriptArgs</span><span>,</span><span> </span><span>&#34; &#34;</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>// Set working directory to the specified directory (project root)</span><span></span></p><p><span>    cmd</span><span>.</span><span>Dir </span><span>=</span><span> directory</span></p><p><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Working directory: %s\n&#34;</span><span>,</span><span> directory</span><span>)</span><span></span></p><p><span>    </span><span>// Connect standard IO</span><span></span></p><p><span>    cmd</span><span>.</span><span>Stdout </span><span>=</span><span> os</span><span>.</span><span>Stdout</span></p><p><span>    cmd</span><span>.</span><span>Stderr </span><span>=</span><span> os</span><span>.</span><span>Stderr</span></p><p><span>    cmd</span><span>.</span><span>Stdin </span><span>=</span><span> os</span><span>.</span><span>Stdin</span></p><p><span>    </span><span>// Run the command and wait for it to finish</span><span></span></p><p><span>    err </span><span>:=</span><span> cmd</span><span>.</span><span>Run</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// ..</span></p></div></div></pre><h2 id="to-conclude">To Conclude</h2><p>All this to have a package manager that implements 2% of the spec that users expect, hah.</p><p>It&#39;s ~700 lines of Go (<a href="https://github.com/healeycodes/caladan">open source</a>) and it was fun to write. I have more of an understanding about the upper-end of performance that&#39;s possible when it comes to installing packages.</p><p>I&#39;d like to be able to handle a cold install of a <code>package.json</code> (creating and updating the lockfile) at similar speeds. I hope to put a follow-up post together when I&#39;m able to get my dependency resolution and hoisting to match how <code>npm</code> does it.</p><p>I&#39;d also like to look into the cache optimizations that <code>bun</code> does for repeat package installs which, in some cases, takes tens of milliseconds.</p><p>After getting up close to the basics of package manager-ing over the past week, I feel like JavaScript doesn&#39;t cut it as far as the required performance is concerned. I used to think that package managers were network-bound but now I&#39;ve changed my mind.</p><p>The raw performance (and concurrency primitives) of a systems-y language like Go give you so much more power.</p><p>To end on a <a href="https://x.com/jarredsumner/status/1868090574378840523">Jarred Sumner post</a>:</p><blockquote><p>A lot of performance optimizations come from looking closely at things people assume is &#34;just the network&#34; or &#34;just I/O bound&#34;</p></blockquote></div></div></div>
  </body>
</html>
