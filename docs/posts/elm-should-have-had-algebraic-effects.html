<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/elm-should-have-had-algebraic-effects/">Original</a>
    <h1>Elm should have had Algebraic Effects</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>While the world has moved on from Elm, I still think about its simplicity a lot and how that was achieved, and what gaps there were in its design. The gaping weakness I&#39;ll talk about today was also the result of its strength. </p><p>Elm apps have a single unidirectional flow that stemmed from a core design foundation of &#34;<strong>the view is a pure function of application state</strong>&#34;, succinctly written as <em>f(state, msg) = view</em>. This is a great fit if a single user action results in a single message that makes a small state change.</p><p>But if a single user action results in multiple messages, or the single message requires multiple side-effects, then the simplicity becomes a hindrance–the developer must now trace multiple cycles through the architecture. It&#39;s no longer simple to trace through what the system does in response to a single user action.</p><p>If Elm had Algebraic Effects, it would have made it more adaptable to these multi-message processing. In fact, Algebraic Effects as a control flow mechanism, would simplify many other types of more complicated workarounds we see today in other systems.</p><h2 id="elms-outsized-contribution">Elm&#39;s Outsized Contribution</h2><p>Even if Elm isn&#39;t very popular language and frontend framework today, it&#39;s had a drastic and important influence on web frontend architecture with <em>The Elm Architecture</em> (TEA). After shedding its signals from its Functional Reactive Programming roots, <a href="https://lambdadays.org/lambdadays2025/evan-czaplicki?ref=interjectedfuture.com" rel="noreferrer">Evan Czapliki</a> (creator of Elm) said this <a href="https://www.youtube.com/watch?v=oYk8CKH7OhE&amp;t=2160s&amp;ref=interjectedfuture.com" rel="noreferrer">architecture sort of fell into place</a>.</p><figure><img src="https://interjectedfuture.com/content/images/2025/09/image.png" alt="" loading="lazy" width="500" height="383"/><figcaption><span>The Elm Architecture</span></figcaption></figure><p>TEA is conceptually simple. Model the view as a pure function of application state. Views can generate messages in response to user actions, like clicks. And based on any messages that come in from the outside, we immutably modify the state. Any state change is reflected by the pure function that transforms state into a view. The state change function is a giant switch statement that routes messages to the appropriate part of the code that makes a small state change. </p><p>The entire thing is a unidirectional dataflow. No rat&#39;s nest of dependency graphs. No race conditions. It’s easy to keep in your head what&#39;s going on at any moment in the lifecycle in response to user input. And The big switch statement to route messages means that you only need to trace a single branch of the pure function to understand what it’s doing.</p><p>Compared to the object-orientated <a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC?ref=interjectedfuture.com" rel="noreferrer">Model-View-Controller</a>, the <a href="https://www.geeksforgeeks.org/system-design/observer-pattern-set-1-introduction/?ref=interjectedfuture.com" rel="noreferrer">Observer pattern</a>, <a href="https://v17.angular.io/guide/two-way-binding?ref=interjectedfuture.com" rel="noreferrer">bidirectional binding in Angular</a>/<a href="https://backbonejs.org/?ref=interjectedfuture.com#Model-View-separation" rel="noreferrer">Backbone</a>/etc, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events?ref=interjectedfuture.com" rel="noreferrer">a pile of event handlers for event callbacks</a> in <a href="https://jquery.com/?ref=interjectedfuture.com" rel="noreferrer">jQuery</a>, <em>The Elm Architecture</em> was devastatingly simple. In fact, the original <a href="https://www.youtube.com/watch?v=i__969noyAM&amp;ref=interjectedfuture.com" rel="noreferrer">React Flex architecture</a>, the subsequent <a href="https://react-redux.js.org/introduction/why-use-react-redux?ref=interjectedfuture.com" rel="noreferrer">Redux library</a>, and the now standard <a href="https://react.dev/reference/react/useReducer?ref=interjectedfuture.com" rel="noreferrer">React useReduce</a> are of the same lineage. They are all unidirectional flows from application state to the view, and they cycle back to state changes in response to user generated events by interacting with the view.</p><h2 id="performing-side-effects">Performing Side Effects</h2><p>What if you want to perform side effects in your Elm-based web application? Elm is a pure functional language, and in program where the view is a pure function of the application state, how do you fetch from the network or generate random numbers?</p><figure><img src="https://interjectedfuture.com/content/images/2025/09/image-1.png" alt="" loading="lazy" width="772" height="352" srcset="https://interjectedfuture.com/content/images/size/w600/2025/09/image-1.png 600w, https://interjectedfuture.com/content/images/2025/09/image-1.png 772w" sizes="(min-width: 720px) 720px"/><figcaption><span>You can still be pure if you let the runtime handle the dirty work for you.</span></figcaption></figure><p>The short answer is, you don&#39;t–at least not directly. Instead, you unwind the callstack of your pure function generating the view from application state and return a command (or subscription) back to the runtime (Cmd/Sub in the figure above). The runtime then takes that command and executes it for you, and returns the result back to you as yet another message. You can then handle that message like you would any other in the giant switch statement in your <em>f(state, msg)</em>.</p><p>The great part of this design is that it keeps the same architecture and model, and repurposes it for running side effects. The bad part of this design is that you need to trace through multiple Cmd/Msg cycles in order to figure out what the program is doing in response to a single user action. That increase in cognitive load can boil over beyond the advantages of TEA in the first place.</p><p>How would that happen? It happens when a single user action generates a message that requires multiple side effects to complete. The most familiar way this happens is if there&#39;s a button that shows the user a list of blog posts and the number of tweets for that post. In order to do that the application must query the database for blog posts and fetch from a 3rd party API for number of retweets. This is what would happen:</p><figure><img src="https://interjectedfuture.com/content/images/2025/09/Screenshot-2025-09-02-at-9.51.05-AM.png" alt="" loading="lazy" width="2000" height="1408" srcset="https://interjectedfuture.com/content/images/size/w600/2025/09/Screenshot-2025-09-02-at-9.51.05-AM.png 600w, https://interjectedfuture.com/content/images/size/w1000/2025/09/Screenshot-2025-09-02-at-9.51.05-AM.png 1000w, https://interjectedfuture.com/content/images/size/w1600/2025/09/Screenshot-2025-09-02-at-9.51.05-AM.png 1600w, https://interjectedfuture.com/content/images/2025/09/Screenshot-2025-09-02-at-9.51.05-AM.png 2296w" sizes="(min-width: 1200px) 1200px"/></figure><ul><li>User clicks the button that generates a <em>button_click</em> message.</li><li><em>button_click</em> message gets routed by the TEA switch statement to the <em>button_click_handler</em></li><li>The <em>button_click_handler</em> returns <em>fetch_posts</em> command back to the runtime.</li><li>The runtime fetches posts from the database and sends a <em>result_posts</em> message.</li><li><em>result_posts</em> message gets routed by the TEA switch statement to the <em>blog_posts_handler branch</em>.</li><li>The <em>blog_post_handler branch</em> returns the <em>get_retweets</em> command back to the runtime.</li><li>The runtime fetches retweet counts from the network API and sends a <em>num_retweets</em> message.</li><li><em>get_retweets</em> message gets routed by the TEA switch statement to the <em>retweets_handler branch</em>.</li><li>The change in application state then changes the view.</li></ul><p>If you skipped all that, that&#39;s the point. It was as tedious for me to write it as it would have been for you to read it. But the gist is this:</p><p><strong>The logical, linear progression of a computation to handle a single user action is now broken up across multiple branches in a switch statement.</strong> Every time you have to cross the boundary to match messages in order to trace program execution, it&#39;s overhead in your cognitive load.</p><p>What if instead you could fetch posts and retweets and just resume a pure function call where you left off with the results of the side effect. Notice the lines with <code>perform</code> in this listing. That&#39;s where the effects are being called. We don&#39;t have to break this up into separate branches of the switch statement every time we need to perform a side effect.</p><figure><pre><code>-- effect signatures
effect FetchPosts : () -&gt; List { id : String, title : String, body : String }
effect GetRetweetsBulk : List String -&gt; List ( String, Int ) -- (postId, count)

update : Msg -&gt; Model -&gt; Model
update msg model =
    case msg of
        ClickRefresh -&gt;
            handleEffects model &lt;| \resume -&gt;
                let
                    posts = perform (FetchPosts ())
                    ids   = List.map .id posts
                    pairs = perform (GetRetweetsBulk ids)
                    dict  = Dict.fromList pairs

                    merged =
                        List.map
                            (\p -&gt;
                                { id = p.id
                                , title = p.title
                                , body = p.body
                                , retweets = Dict.get p.id dict |&gt; Maybe.withDefault 0
                                }
                            )
                            posts
                in
                resume { model | posts = merged, loading = False, error = Nothing }

        _ -&gt;
            model</code></pre><figcaption><p><span>You could run the fetching of posts and retweets in parallel, but I kept it sequential to illustrate the resumption of side effect results.</span></p></figcaption></figure><p>So instead of multiple messages to handle this sequence of computations, we raise effects every time we need the result of a side effect, and resume the computation after we got the side effect result.</p><p>This is what Algebraic Effects do.</p><h2 id="a-short-description-of-algebraic-effects">A short description of Algebraic Effects</h2><p>Algebraic effects is not too hard to write your head around if you understand a few basic concepts. They&#39;re basically a new kind of control flow that can be easily described mechanically to newcomers as <strong>resumable exceptions</strong>. However, unlike exceptions, they&#39;re meant for everyday control flow.</p><p>Most developers now are familiar with exceptions. We wrap computation in try/catch block, where the catch block is the exception handlers, in case those handlers need to be invoked by thrown exceptions. Structurally, algebraic effects are no different. We wrap computation in a block with an effect handler that will execute should the computation raise effects.</p>
<!--kg-card-begin: html-->

<!--kg-card-end: html-->
<p>But exceptions and algebraic effects are different in that we&#39;re taught that we shouldn&#39;t use exceptions as regular control flow, because they&#39;re <em>for exceptional cases</em>. And once an exception is throw, the stack is unwound, and we can never go back to where the exception was raised.</p><p>Algebraic effects are different. When an effect is performed (or raised), like exceptions, we start searching up the callstack for a suitable handler for this effect. Once we find the first suitable handler, we can execute that handler to do some side effect. With the side effect result in hand, the handler can decide to do a couple of things:</p><ul><li>Resume the computation with the result one or more times.</li><li>Abort the computation</li><li>Delegate to another handler higher up the call stack.</li></ul><p>If the handler resumes the computation, the control flow jumps back to <em>the point of execution right after that effect was raised</em>. To the application developer, performing an effect seems like a simple function call: you raise the effect, you can a value back. However, the differences are:</p><ul><li>The function that raised the effect remains pure. Hence easier to test and easier to reason about.</li><li>A handler can choose to resume multiple times, and computation will resume right after the raised effect with the same call stack every time.</li></ul><p>Why would you want to resume a handler multiple times? Maybe the side effect you want is a websocket and you want it to stream results to your program as it gets the data. So the handler would just resume your program at the same spot every time it gets a new piece of data.</p><p>If the handler aborts the computation, the control flow <em>throws away all the work it did since it entered the handler</em>. It&#39;s as if we never went that way and did any of the work. We resume execution after the handler as if we never executed our computation at all!</p><p>There&#39;s more to Algebraic Effects, such as how they work under the hood, what they&#39;re commonly used for, and their current downsides (it can be slow to look up handlers, but that can be mitigated). Also, what&#39;s algebraic about Algebraic Effects? I won&#39;t get into any of that for now, but just to say that it would have been a good solution to this problem in Elm.</p><h2 id="designing-systems">Designing systems</h2><p>This kind of control flow is very powerful. Control flow that&#39;s typically hard-coded inside language features can now be written with Algebraic Effects, such as:</p><ul><li>Exceptions</li><li>Async/await concurrency</li><li>Generators and Coroutines</li><li>Break/continue in loops</li><li>Returns in nested scopes</li><li>State threading in state monads in pure functional languages</li><li>search and backtracking in logical languages like Prolog</li><li>Transactions, rollbacks, and undos in databases</li><li>I/O and external interactions in pure functional languages</li></ul><p>They also replace a lot of the use cases for monads. </p><p>So given the option for simplicity of a mental model for a narrow band of use-cases, I can understand why Evan Czapliki wouldn&#39;t have implemented it. That said, the simplicity of the mental model didn&#39;t end up being a good fit for the situation I often found myself in while building web apps, which was the single-message/multiple-side-effects pattern I outlined above.</p><p>Would I have gone ahead and attempted the implementation? </p><p>Implementing algebraic effects also would have been hard in the Javascript engine. You can implement single resumption algebraic effects with javascript generators, but not the full-blown multiple resumption algebraic effects. To do so requires delimited continuations to be available by the javascript runtime. Your only other alternative is to recreate the callstack in userland and implement delimited continuations in the Elm runtime on top of the javascript runtime.</p><p>Given that Elm is a compiled language, recreating the callstack wouldn&#39;t have too too far off the beaten path, everyone else higher in the stack. I do know there are attempts to put <a href="https://www.youtube.com/watch?v=DRFsodbxHQo&amp;ref=interjectedfuture.com" rel="noreferrer">delimited continuations</a> in Haskell, and Elm is developed in Haskell–maybe there&#39;s a viable path there.</p><p>The thing to carefully consider is the downside of algebraic effects. I haven&#39;t used them enough to know all the catches, but it does seem to me it can be really easy to write spaghetti code with algebraic effects, where the control flow jumps around. I think it should probably remain a super power for library writers to do what they need to, but then everyday application writers probably should use it judiciously in simple ways.</p><hr/><p>There&#39;s up and coming languages that have algebraic effects if you want to use them in experimental languages, check out <a href="https://koka-lang.github.io/koka/doc/index.html?ref=interjectedfuture.com" rel="noreferrer">Koka</a> and <a href="https://www.eff-lang.org/learn/?ref=interjectedfuture.com" rel="noreferrer">Eff</a>. In more production languages, they&#39;re available in <a href="https://www.unison-lang.org/docs/language-reference/ability-patterns/?ref=interjectedfuture.com" rel="noreferrer">Unison</a> and <a href="https://github.com/ocaml-multicore/ocaml-multicore?ref=interjectedfuture.com" rel="noreferrer">Multicore Ocaml</a>. You can check out more in my previous post.</p><figure><a href="https://interjectedfuture.com/algebraic-handler-lookup-in-koka-eff-ocaml-and-unison/"><div><p>Algebraic Handler Lookup in Koka, Eff, OCaml, and Unison</p><p>What are the different ways to do handler look up in programming languages that support algebraic effects?</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-3.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/algebraic_langs.jpeg" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>Let me know if you have other questions.</p>
        </section></div>
  </body>
</html>
