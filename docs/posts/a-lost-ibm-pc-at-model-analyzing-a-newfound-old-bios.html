<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://int10h.org/blog/2025/11/lost-ibm-at-model-bios-analysis/">Original</a>
    <h1>A Lost IBM PC/at Model? Analyzing a Newfound Old Bios</h1>
    
    <div id="readability-page-1" class="page"><article>
		
		<div>
			
			

<p>For the disassembled code and the ROM images discussed here, see <strong><a href="https://github.com/viler-int10h/IBM-AT_03-08-1985_disassembly">this repository</a></strong></p>

<p>Something intriguing turned up recently over at the Vintage Computer Federation Forums.  Member <strong>GearTechWolf</strong> occasio­nally rescues and dumps random ROM chips that show up on eBay, and makes the contents available so they aren&#39;t lost to the ages.  One of his hauls turned up two pairs of EPROMs labeled &#34;IBM&#34; in plain dot-<wbr/>matrix: one showing part numbers (and &#34;© IBM CORP 1981,1985&#34;), the other tagged with a specific date (&#34;25/05/90&#34;).</p>

<figure>
    <a href="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/IBM_6448246_6448238_08-Mar-85.jpg" target="_blank"><img src="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/IBM_6448246_6448238_08-Mar-85.jpg" alt="Enigmatic IBM EPROMs"/></a>
    <figcaption>Enigmatic IBM EPROMs</figcaption>
</figure>

<p>They came with no further identi­fication, and no hints about their origins, or what machines they may have come from.  And just to establish that proper setting of suspense and mystery, neither pair could be content-<wbr/>matched against any known IBM firmware.</p>

<p>Much poking and prying commenced.  I didn&#39;t delve very deeply into the &#39;25/05/90&#39; odd/<wbr/>even pair, but it seemed to be some sort of PS/2 BIOS: it proved to contain those tell­tale extra VGA fonts (on which <a href="https://int10h.org/blog/2022/06/ibm-ps2-30-286-hidden-vga-fonts/" target="_blank">past</a> <a href="https://int10h.org/blog/2025/07/secret-fonts-isa16-ps2-again/" target="_blank">verbiage</a> abounds), and to share some other bits and pieces with known Model 35 SX/40 SX ROMs. Seeing that, I prodded the <a href="https://www.ardent-tool.com" target="_blank">Ardent Tool</a> crew, and Major Tom identi­fied it as rev. 2 of the 35-/40-SX firmware - earlier than other known variants.  It&#39;s now up for download on the <a href="https://www.ardent-tool.com/firmware/system.html#:~:text=Model%2035%20SX%20and%2040%20SX" target="_blank">System ROMs</a> page.</p>

<p>The more intriguing one for me was the &#39;<strong><em>1981, 1985</em></strong>&#39; duo (yellow labels in the photo).  A cursory look in a hex viewer revealed the following:</p>

<ul>
    <li>EPROM 6448246 has the even addresses, 6448238 the odd addresses.</li>
    <li>The <em>internal</em> part numbers are 6480442 and 6480441, respectively.</li>
    <li>The BIOS date stamp in the standard location (F000:FFF5) is <strong>03/08/85</strong>.</li>
    <li>At F000:330A, there&#39;s yet another date stamp - <strong>02/14/85</strong>.</li>
    <li>The model byte (in the second-to-last position) is <strong>FCh</strong>.</li>
</ul>

<p>In 1985, the <code>FCh</code> model byte could only mean the 5170 (PC/<wbr/>AT), and the even/<wbr/>odd byte inter­leaving does point at a 16-bit bus.  But there are three known versions of the PC/<wbr/>AT BIOS released during the 5170 family&#39;s lifetime, corres­ponding to the three AT mother­board types.  This one here is clearly not one of them: its date stamps and part numbers don&#39;t match, and the actual contents are substan­tially different besides.</p>

<p>My first thought was that this may have come from one of those more shadowy members of the 5170 family: perhaps the AT/370, the 3270 AT/G(X), or the rack-mounted 7532 Industrial AT.  But known examples of those carry the same firmware sets as the plain old 5170, so their BIOS extensions (if any) came in the shape of extra adapter ROMs.  Whatever <em>this</em> thing was - some other 5170-type machine, a prototype, or even just a custom patch - it seemed I&#39;d have to inquire within for any further clues.</p>

<h3 id="the-pc-at-bios-known-versions">The PC/AT BIOS: Known Versions</h3>

<p>This was a good time to brush up on the three official revi­sions of the AT BIOS: how to tell them apart, and how they corres­pond to hardware options.  The following table was compiled mostly from the pages at <strong>Minus Zero Degrees</strong> (<a href="https://minuszerodegrees.net/5170/bios/5170_bios_revisions.htm" target="_blank">IBM 5170 BIOS Revisions</a>) and <strong>PC DOS Retro</strong> (<a href="https://pcdosretro.gitlab.io/IBMBIOS.txt" target="_blank">IBM PC BIOS version history</a>), and from the info in <a href="http://www.delorie.com/djgpp/doc/rbinter/" target="_blank">Ralf Brown&#39;s Inter­rupt List</a>.  Where the sources weren&#39;t in total agree­ment, I went with what seemed to conform with IBM&#39;s pub­lished source code listings.</p>

<table><thead>
    <tr>
        <th>PC/AT BIOS revision</th>
        <th>Rev. 1</th>
        <th>Rev. 2</th>
        <th>Rev. 3</th>
    </tr>
</thead><tbody>
    <tr>
        <th scope="row">Date (US format)</th>
        <td>01/10/84</td>
        <td>06/10/85</td>
        <td>11/15/85</td>
    </tr>
    <tr>
        <th scope="row">P/N (internal/<wbr/>mask ROM)</th>
        <td>U27, even: 6181028</td>
        <td>U27, even: 6480090</td>
        <td>U27, even: 62X0820</td>
    </tr>
    <tr>
        <th scope="row">P/N (EPROM label)</th>
        <td>U17/U27, even: 6181024/5</td>
        <td>U27, even: 6448896</td>
        <td>U27, even: 61X9266</td>
    </tr>
    <tr>
        <th scope="row">ID bytes: Model, Submodel, Revision level</th>
        <td>FCh, N/A, N/A <sup>a</sup></td>
        <td>FCh, 00h, 01h</td>
        <td>FCh, 01h, 00h</td>
    </tr>
    <tr>
        <th scope="row"><a href="https://bitsavers.trailing-edge.com/pdf/ibm/pc/at/">Technical Reference</a> (with source code listing)</th>
        <td>March 1984</td>
        <td>September 1985</td>
        <td>March 1986</td>
    </tr>
    <tr>
        <th scope="row">PC/AT model and main­board type</th>
        <td>068, 099 (Type 1)</td>
        <td>239 (Type 2)</td>
        <td>319, 339 (Type 3)</td>
    </tr>
    <tr>
        <th scope="row">CPU clock supported</th>
        <td>6 MHz (<strong>not</strong> tested in POST)</td>
        <td>6 MHz (tested in POST)</td>
        <td>8 MHz (tested in POST)</td>
    </tr>
    <tr>
        <th scope="row">Keyboards supported</th>
        <td>84-key AT</td>
        <td>84-key AT <sup>b</sup></td>
        <td>84-key AT</td>
    </tr>
    <tr>
        <th scope="row">Floppy drive types supported</th>
        <td>360 KB</td>
        <td>360 KB</td>
        <td>360 KB</td>
    </tr>
    <tr>
        <th scope="row">Hard drive types supported</th>
        <td>14 (types 01-14)</td>
        <td>22 (types 01-14, 16-23)</td>
        <td>22 (types 01-14, 16-23)</td>
    </tr>
    <tr>
        <th scope="row">Checks for &#34;multiple data rate&#34; drive controller? <sup>c</sup></th>
        <td>No</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
</tbody></table>

<div>
    <div>
        <p><sup>a</sup></p>
        <p>Rev. 1 has a model ID byte, but the function to return submodel and revision (INT 15h/<wbr/>AH=C0h) did not exist yet.</p>
    </div>
    <div>
        <p><sup>b</sup></p>
        <p>Rev. 2 appears to have partial/unfinished support for the Enhanced Keyboard: INT 09h performs the necessary decoding (or some of it), but none of the enhanced INT 16h functions are implemented.</p>
    </div>
    <div>
        <p><sup>c</sup></p>
        <p>Rev. 2 and 3 show a &#34;601 Diskette Error&#34; if not found (see the above -0° page for more info).</p>
    </div>
</div>

<p>That&#39;s the low-down on what we have to compare against.  In this yet-unknown revision, both of the date stamps within the BIOS image (<strong>03/08/85</strong> and <strong>02/14/85</strong>) place it in-<wbr/>between revisions 1 and 2.  So for the sake of conve­nience (read: laziness), I&#39;ll be stun­ningly original and refer to it below as <strong><em>&#34;rev. 1.5&#34;</em></strong>.</p>

<h6 id="are-you-at-enough">Are You AT Enough?</h6>

<p>Before I embarked on some actual reverse-<wbr/>enginee­ring, I thought I&#39;d try a little experiment first: how would 86box&#39;s IBM AT emulation fare with this firmware?  Easy enough to find out; just substitute these two ROM images for the expected even/<wbr/>odd pair (86box uses the rev. 3 BIOS by default) and see what happens.</p>

<p>Since I don&#39;t have an actual IBM 5170, that&#39;s as close to an &#34;AT compatibility test&#34; as I could get, but this firmware appeared to pass muster:</p>



<p>Our &#39;rev. 1.5&#39; BIOS makes it through POST with no issues.  The IBM AT Advanced Diagnostics v2.07 disk loads up, and dutifully reports the firmware&#39;s P/N and date string; System Checkout (which lists the installed hardware) and the SETUP procedure (which is where you configure it) both run as expected.</p>

<p>Evidently this is some manner of PC/AT BIOS, or close enough to make Diagnostics happy.  Poking at it under an emulator isn&#39;t going to tell us a whole lot more than this, however: we don&#39;t know <em>exactly</em> what this revision assumes about the hardware, so we can&#39;t expect to tell compati­bility issues from configuration errors, or just sketchy emulation.  At this juncture (if you&#39;ll excuse the imagery) we might as well roll up our sleeves and start rummaging through the entrails.</p>

<h3 id="findings">Findings</h3>

<p>For more detailed notes about the disassembly itself, have a look at the <a href="https://github.com/viler-int10h/IBM-AT_03-08-1985_disassembly" target="_blank">repository</a>.  I&#39;ll just mention that the goal was to figure out just where and how this &#39;rev. 1.5&#39; BIOS differs from the others, and this would have been much more difficult if it wasn&#39;t for two things:</p>

<ul>
<li>The published source listings for all official AT BIOS versions, from the respective editions of the PC/AT Technical Reference - available on <a href="https://bitsavers.trailing-edge.com/pdf/ibm/pc/at/" target="_blank">Bitsavers</a> (and on the Internet Archive: <a href="https://archive.org/details/bitsavers_ibmpcat150ferenceMar84_26847525" target="_blank">#1</a>, <a href="https://archive.org/details/bitsavers_ibmpcat613ferenceSep85_23137392" target="_blank">#2</a>, <a href="https://archive.org/details/bitsavers_ibmpcat618ferenceMar86_25829277" target="_blank">#3</a>).</li>
<li>The excellent reconstructions of the source code by Vernon Brooks over at <a href="https://pcdosretro.gitlab.io/IBMPCBIOS.htm" target="_blank">PC DOS Retro</a>, which have the listings in plain text (and they can be success­fully reassem­bled, too).</li>
</ul>



<p>I didn&#39;t go quite as far as trying to recon­struct a version that actually builds, but thanks to the above I believe I have things mostly figured out, so here&#39;s my analysis.</p>

<h6 id="the-code-base">The Code Base</h6>

<p>Just to get this out of the way, this is very clearly <strong><em>not</em></strong> a custom patch, or a little localized modifi­cation.  Most obviously, all offsets/<wbr/>addresses differ from the other versions, and not just by a simple, easily-explained shift. The exceptions are certain entry points and tables (mostly in the top 4 KB) delibe­rately forced to fixed addresses, something that&#39;s been done in every PC-family BIOS.</p>

<p>In fact, with some (important) diffe­rences which will be detailed below, overall the code base appears to be something you&#39;d expect if you were looking at a snapshot of some interim state between rev. 1 and 2.  Some sections are closer to their rev. 1 counter­parts, others to rev. 2; many contain elements of both, or follow the general logic of one version while still showing certain practices more common in the other.</p>

<p>For instance, a routine may perform essentially the same thing it did in rev. 1, but include certain optimi­zations which are mostly found only in rev. 2, such as imme­diate multi-<wbr/>bit shifts (you might see <code>SHL BL, 2</code> in place of two <code>SHL BL, 1</code> instruc­tions), or updating segment registers with <code>PUSH</code>/<wbr/><code>POP</code> (instead of <code>MOV</code>ing the value through a go-<wbr/>between).</p>

<p>Other routines appear more or less in the same form they have in rev. 2, while signs of the rev. 1 coding style still persist.  For example, all the I/O required to access CMOS memory is done inline, as opposed to rev. 2 which calls two new routines for this purpose (<code>CMOS_READ</code> and <code>CMOS_WRITE</code>).  Or the encoding of jumps: two-byte (short) jumps are often found padded with a <code>NOP</code> instru­ction, like in rev. 1, something that no longer happens in the later itera­tions.</p>

<p>The more interesting parts, of course, are the sections which are unique to &#39;rev. 1.5&#39; and don&#39;t have direct counter­parts elsewhere, but I&#39;ll be getting to them in a bit.  Those aside, the whole thing does look like an authentic version of the BIOS code, caught in some interme­diate state of develop­ment between revisions 1 and 2 - including some (but not all) of the changes that later made it to the second revision, as well as a few modifi­cations that didn&#39;t.</p>

<h6 id="top-level-organization-and-build-environment">Top-Level Organization (and Build Environment)</h6>

<p>The other editions of the AT BIOS were all generated from multiple source files.  Here we only have the final image, but by comparing the overall structure against the other versions, we can deduce the break­down into separate source modules.  The arrange­ment of the code and data here is the same as in rev. 1, which suggests that &#39;rev. 1.5&#39; was built before the restruc­turing that can be seen in the second revision.</p>

<p>Rev. 1 was appa­rently assem­bled with MASM v1.0, but rev. 2 switched to v2.0, as we&#39;re told by the page titles in IBM&#39;s source listing.  If the struc­tural overhaul was down to that change, then &#39;1.5&#39; was likely still built with MASM v1.0... a form of cruel and unusual punish­ment if there ever was one, but perhaps they had some inside scoops from Microsoft on how to deal with all the errata in that famously bug-<wbr/>infested mess of an assem­bler.</p>

<h3 id="functionality-and-hardware-support-comparison">Functionality (and Hardware Support) Comparison</h3>

<p>Now for some of the actual simila­rities and diffe­rences between &#39;rev 1.5&#39; and its older/<wbr/>younger siblings.  The code may be closer to the first revision in its general <em>structure</em>, but if we take the date stamps at face value, it post­dates rev. 1 by more than a year - while the next revision was only three or four months away.</p>

<p>So it wasn&#39;t a complete surprise to find quite a few similarities with rev. 2. For instance,</p>

<ul>
<li>It supports 720K (3.5&#34; DSDD) floppy disks, offi­cially intro­duced only in rev. 2.</li>
<li>21 different hard drive types are avai­lable: 01-14 and 16-22, just one short of rev. 2 (and 3), which add drive type 23.  Only types 01-14 were recog­nized in rev. 1 (15 is always reserved).</li>
<li>It implements INT 15h function C0h (&#34;<a href="http://www.delorie.com/djgpp/doc/rbinter/id/02/16.html" target="_blank">Get System Configuration</a>&#34;), which didn&#39;t exist in rev. 1, but was present in rev. 2 (and in all later PC compa­tible BIOSes).</li>
<li>Keyboard support is more or less the same as in rev. 2: only the 84-key AT keyboard is (fully) supported, but <em>some</em> code for the 101/102-key Enhanced Keyboard is already present. The hardware IRQ handler (INT 09h) attempts to detect it, and uses its expanded scan code tables, but the enhanced INT 16h services are not available.</li>
</ul>



<p>In certain other respects, however, there&#39;s more in common with the first revision:</p>

<ul>
<li>It doesn&#39;t attempt to verify the 286&#39;s clock speed, a test that was added to POST in revisions 2 and 3 (at checkpoint 11h).</li>
<li>When testing the floppy/<wbr/>hard drive controller (&#34;combo card&#34; in IBM-<wbr/>speak), it won&#39;t throw up a &#34;601 diskette error&#34; if it cannot find the &#34;multiple data rate capa­bility&#34; indi­cation bit. What this means in practice is that more third-­party cont­rollers should be supported.</li>
<li>POST checkpoint codes 02 and 03 mean the same things as in rev. 1 (respectively, these tests verify the CMOS Shutdown Byte and the BIOS ROM checksum).  The later revisions swap these two tests around.</li>
</ul>



<p>Then you&#39;ve got those peculiar sections where &#39;rev. 1.5&#39; does its own thing entirely.  The most signifi­cant ones handle <strong>RAM testing and parity errors</strong>: this also provides our biggest clue about just what sort of AT this firmware came from, so I&#39;ll expand on this down below.</p>

<p>For now, just a few notes about some of the above:</p>

<h6 id="the-system-configuration-table">The System Configuration Table</h6>

<p>This is where we find the machine ID bytes: model, sub-<wbr/>model, and revision level.  A pointer to this table is returned by the (new) BIOS function <strong>INT 15h/<wbr/>AH=C0h</strong>.  Per <a href="http://www.delorie.com/djgpp/doc/rbinter/id/02/16.html" target="_blank">RBIL</a>, this was avai­lable in the PC XT since the 1986/01/10 BIOS, in the PC/AT since 1985/06/10 (second revision), and in all subsequent PC and PS/2 machines; but evidently &#39;rev. 1.5&#39; had it first.</p>

<p>The odd part is that it returns sub-<wbr/>model <span>01</span> and revision level <span>00</span>, which is the same as the <strong><em>third</em></strong> revision BIOS - the second revision has sub-model 00, revision level 01.  Perhaps the meaning (or the order) of these bytes was still not quite final at this point.  On the other hand, the fourth (&#39;feature&#39;) byte is 70h, like in rev. 2 and 3.</p>

<pre><span>F000:E6F5</span> <span>08 00      </span> <span>CONF_TBL</span> <span>dw</span> <span>8</span>                            <span>; LENGTH OF FOLLOWING TABLE</span>
<span>F000:E6F7</span> <span>FC         </span>          <span>db</span> <span>MODEL_BYTE</span>                   <span>; SYSTEM MODEL BYTE</span>
<span>F000:E6F8</span> <span>01         </span>          <span>db</span> <span>SUB_MODEL_BYTE</span>               <span>; SYSTEM SUB MODEL TYPE BYTE</span>
<span>F000:E6F8</span>                                                      <span>; [* 1, like rev. 3 (0 in rev. 2) *]</span>
<span>F000:E6F9</span> <span>00         </span>          <span>db</span> <span>BIOS_LEVEL</span>                   <span>; BIOS REVISION LEVEL</span>
<span>F000:E6F9</span>                                                      <span>; [* 0, like rev. 3 (1 in rev. 2) *]</span>
<span>F000:E6FA</span> <span>70         </span>          <span>db</span> <span>1110000b</span>                     <span>; 10000000 = DMA CHANNEL 3 USE BY BIOS</span>
<span>F000:E6FA</span>                                                      <span>; 01000000 = CASCADED INTERRUPT LEVEL 2</span>
<span>F000:E6FA</span>                                                      <span>; 00100000 = REAL TIME CLOCK AVAILABLE</span>
<span>F000:E6FA</span>                                                      <span>; 00010000 = KEYBOARD SCAN CODE HOOK 1AH</span>
</pre>

<h6 id="floppy-drive-support">Floppy Drive Support</h6>

<p>This is one area where the &#39;rev 1.5&#39; code base diverges from all other revisions, but the actual functio­nality doesn&#39;t seem to be too diffe­rent from rev. 2.  It looks more as if 3.5&#34; 720 KB media support was shoe­horned into the rev. 1 code (which only handled 1.2 MB and 360 KB disks and drives).  This somewhat over-<wbr/>compli­cated the logic of many routines, especially those dealing with state/<wbr/>format bits and varia­bles in the BIOS Data Area whose formats couldn&#39;t be changed, for the sake of compati­bility.</p>

<p>Rev. 2 refactored and simpli­fied the floppy code, in part by imple­menting what the comments call a &#34;new archi­tecture&#34;, along with two routines (<code>XLAT_NEW</code> and <code>XLAT_OLD</code>) which convert such data fields to a new internal format when entering a BIOS function, then back to the old format on exit.  The floppy code in &#39;rev 1.5&#39; is there­fore noti­ceably messy compared to the other revisions, and in places it seems to use certain &#34;reserved&#34; state bits for tempo­rary purposes which I haven&#39;t fully grokked yet (see <code>set_dskstate_*</code> in the disas­sembly).</p>

<p>Still, the <em>inter­face</em> already has the familiar form it would retain later. For instance, INT 13h function 17h (<a href="http://www.delorie.com/djgpp/doc/rbinter/id/47/6.html" target="_blank">Set Disk Type for Format</a>), named <code>FORMAT_SET</code> in the code (address F000:<wbr/>28D3), allows you to set the new 720 KB type by speci­fying <strong>AL=4</strong>, like rev. 2 and all subseq­uent PC firmware.</p>

<p>Function 08h (<a href="http://www.delorie.com/djgpp/doc/rbinter/id/27/6.html" target="_blank">Get Drive Parameters</a>), which in rev. 1 was only avai­lable for hard drives, works for floppies here.  It returns the same data in the same regi­sters as rev. 2 and onward, although it&#39;s executed diffe­rently.  The data is popu­lated from a table at F000:<wbr/>EF5A, which includes the parame­ters for 720 KB:</p>

<pre><span>F000:EF62</span> <span>00 F0       </span><span>d720_seg</span> <span>dw</span> <span>0F000h</span>
<span>F000:EF64</span> <span>C7 EF       </span><span>d720_off</span> <span>dw</span> <span>offset</span> <span>DISK_BASE</span>             <span>; [* 720k: ptr to DISK_BASE *]</span>
<span>F000:EF66</span> <span>09          </span><span>d720_spt</span> <span>db</span> <span>9</span>                            <span>; [* 720K: sectors/track *]</span>
<span>F000:EF67</span> <span>4F 00       </span><span>d720_mxt</span> <span>dw</span> <span>79</span>                           <span>; [* 720K: max tracks *]</span>
<span>F000:EF69</span> <span>01          </span><span>d720_mxh</span> <span>db</span> <span>1</span>                            <span>; [* 720K: max heads *]</span>
</pre>

<p>720 KB floppy support might just be another inno­vation of this firmware.  The first PC-<wbr/>family machine with 3.5&#34; drives was the IBM JX (late 1984), but those were 360 KB only, up until 1986. The next one was the Convertible, with a BIOS dated September 1985; the XT didn&#39;t get a 720K-<wbr/>capable BIOS until 1986, either.  As the para­meter table tells us, this March &#39;85 AT firmware knows about the full 80-track format, so this was likely the first occurence of actual 720K media support in the PC family.</p>

<h3 id="it-s-all-about-that-base-ram">It&#39;s All About that Base RAM</h3>

<p>At last, the interesting part: what this BIOS does about memory - and how this appears to hint at a machine that isn&#39;t quite your garden-<wbr/>variety AT.  Inciden­tally, the whole thing could also explain a curious little riddle in IBM&#39;s source code for the <em>later</em> revisions of the AT BIOS.</p>

<h6 id="system-board-ram-and-the-keyboard-controller">System Board RAM (and the Keyboard Controller)</h6>

<p>A bit of background to keep in mind here: through the AT&#39;s lifetime, IBM never saw fit to release a model with room for more than 512K of RAM on the system board, unlike the XT (and the XT Model 286).  A <a href="https://minuszerodegrees.net/5170/cards/5170_cards.htm#128_meo" target="_blank">128K expansion board</a> can be used to bring a 512K system up to the 640K &#34;base RAM&#34; (AKA conven­tional RAM) limit.</p>

<p>Now, <em>most</em> of the AT&#39;s config­uration options are kept in CMOS memory, but a couple of things still have to be set the old way - as with the PC and XT, via mother­board switches and jumpers. These settings can be read from the 8042 keyboard control­ler&#39;s input port (by sending C0h to port 64h, then reading port 60h).</p>

<figure>
<p>┌───────┬───────────────────────────────────────────────┐
│ Bit 7 │ Keyboard inhibit switch                       │
│       │  0 = Keyboard inhibited                       │
│       │  1 = Keyboard not inhibited                   │
│ Bit 6 │ Display switch - Primary display attached to: │
│       │  0 = Color/Graphics adapter                   │
│       │  1 = Monochrome adapter                       │
│ Bit 5 │ Manufacturing Jumper                          │
│       │  0 = Manufacturing jumper installed           │
│       │  1 = Jumper not installed                     │
│ Bit 4 │ RAM on the system board                       │
│       │  0 = Enable 512K of system board RAM          │
│       │  1 = Enable 256K of system board RAM          │
│ <span>Bit 3 │ Reserved                                     </span> │
│ Bit 2 │ Reserved                                      │
│ Bit 1 │ Reserved                                      │
│ Bit 0 │ Reserved                                      │
└───────┴───────────────────────────────────────────────┘
</p>
<figcaption>PC/AT: 8042 controller input port bit definitions</figcaption>
</figure>

<p>During the POST procedure, the 5170 BIOS reads these switch settings and stores them in the BIOS Data Area at address <strong>0040:0012</strong> - a byte that was previ­ously unused, except on the PCjr.  The AT BIOS listings label this byte <code>MFG_TST</code>, although the manufac­turing test jumper status is just one of the bits used.</p>

<p>One of these settings (deter­mined by jumper J18) speci­fies the amount of RAM on the system board.  Type 2 and type 3 AT mother­boards come with the full comple­ment of 512 KB; on a Type 1 board, either 256 or 512 KB may be populated, so on these early 5170s this setting can take either value.</p>

<p>In the data byte obtained from the 8042 input port, that&#39;s what <strong>bit 4</strong> indi­cates.  Seems simple enough: as far as the offi­cial documen­tation is con­cerned, this is the only jumper or switch setting that has anything to do with the amount of on-<wbr/>board memory.</p>

<p>But hold on: in the defini­tion table, you will also notice a <span>bit 3</span>. In <strong>all three versions</strong> of the <em>PC/AT Tech­nical Refe­rence</em>, bit 3 is marked &#34;unde­fined&#34; or &#34;reserved&#34;.<wbr/>  Nothing very special about that in itself, because the same goes for bits 0--2... but that&#39;s where that anomaly in IBM&#39;s source code comes in.</p>

<h6 id="the-base-planar-memory-extension">The &#34;Base Planar Memory Extension&#34;</h6>

<p>The BIOS code listings include IBM&#39;s comments for all symbolic cons­tants, most of them at the very start (<code>POSTEQU.INC</code> in the recons­tructed source files). There, the sources for revisions 2 and 3 (but <strong><em>not</em></strong> for rev. 1!) sneak one more entry into the list of bits in the keyboard cont­roller&#39;s input port: </p>

<pre><span>        <span>       C</span>  <span>;--------- 8042 INPUT PORT BIT DEFINITION SAVED IN @MFG_TST --------------------</span>
<span> = 0008 <span>       C</span> <span> <span>BASE_MEM8</span>       <span>EQU</span>     <span>00001000B</span>       <span>; BASE PLANAR R/W MEMORY EXTENSION 640/X</span> </span>
<span> = 0010 <span>       C</span>  <span>BASE_MEM</span>        <span>EQU</span>     <span>00010000B</span>       <span>; BASE PLANAR R/W MEMORY SIZE 256/512</span>
<span> = 0020 <span>       C</span>  <span>MFG_LOOP</span>        <span>EQU</span>     <span>00100000B</span>       <span>; LOOP POST JUMPER BIT FOP MANUFACTURING</span>
<span> = 0040 <span>       C</span>  <span>DSP_JMP</span>         <span>EQU</span>     <span>01000000B</span>       <span>; DISPLAY TYPE SWITCH JUMPER BIT</span>
<span> = 0080 <span>       C</span>  <span>KEY_BD_INHIB</span>    <span>EQU</span>     <span>10000000B</span>       <span>; KEYBOARD INHIBIT SWITCH BIT</span>
</span></span></span></span></span></span></pre>

<p>This <code>BASE_MEM8</code> would be our &#34;reserved&#34; bit 3.  Note how it&#39;s desc­ribed: &#34;base <strong>planar</strong> R/W memory extension 640<wbr/>/X&#34; - &#39;planar&#39; is IBMese for the mother­board.  You could perhaps inter­pret this as a poorly-<wbr/>worded refe­rence to the 128 KB Memory Expan­sion Option mentio­ned above, but that&#39;s not it.  The presence of this external card is signified by a CMOS register (33h, bit 7), not by a system board switch, and rev. 1 <em>does</em> support it perfectly well.<wbr/></p>

<p>Anyway, the POST process does just what that block comment says on the tin: around checkpoint 11, it reads the switch settings, which were tempo­rarily stored in the <code>DMA_PAGE+1</code> register a bit earlier.  Then it strips off the unneeded bits, and saves the result to the <code>@MFG_TST</code> byte in the BIOS Data Area.</p>

<p>BIOS revisions 2 and 3, which know about bit 3 (as <code>BASE_MEM8</code>), take care to preserve it - again, unlike rev. 1:</p>

<pre>                  <span>;-----  GET THE INPUT BUFFER (SWITCH SETTINGS)</span>

<span>05CB  </span><span>E4 82       </span>        <span>IN</span>      <span>AL</span><span>,</span><span>DMA_PAGE</span><span>+</span><span>1</span>           <span>; GET THE SWITCH SETTINGS</span>
<span>05CD  </span><span>24 F8       </span>        <span>AND</span>     <span>AL</span><span>,</span><span>KEY_BD_INHIB</span><span>+</span><span>DSP_JMP</span><span>+</span><span>MFG_LOOP</span><span>+</span><span>BASE_MEM</span><span><span>+</span><span>BASE_MEM8</span></span> <span>; STRIP BITS</span>
<span>05CF  </span><span>A2 12 00    </span>        <span>MOV</span>     <span>@MFG_TST</span><span>,</span><span>AL</span>             <span>; SAVE SETTINGS</span>
</pre>

<p>&#34;But what do they actually <em>do</em> with this bit once they&#39;ve read it?&#34;, you ask.  To channel Trade Master Greenish, &#34;that&#39;s a good question, with a very inte­resting answer&#34;: they do pre­cisely <em>nothing whatso­ever</em> with it at any point.  Whether in the POST process or elsewhere, this piece of infor­mation is consulted a grand total of zero times.</p>

<p>I should mention that I couldn&#39;t find any <em>un­official</em> explanation of this bit, either. None of the usual refe­rences and books have anything better to say about it than &#34;reserved&#34; or &#34;unde­fined&#34;, and that includes such <em>ne plus ultra</em> sources as Ralf Brown, or <a href="https://archive.org/details/TheUndocumentedPC" target="_blank"><em>The Undocu­mented PC</em></a> by Frank van Gilluwe.  A most curious state of affairs.</p>

<p>So what could <em>&#34;base planar memory extension 640<wbr/>/X&#34;</em> stand for, and how did revisions 2 and 3 of the AT firmware end up acknow­ledging its exis­tence - only to comp­letely ignore it?</p>

<h3 id="the-640-x-factor">The 640/X Factor</h3>

<p>At this point you can likely guess where this is going: the &#39;rev 1.5&#39; AT BIOS <em>does</em> pay atten­tion to this undocu­mented &#39;640/X&#39; bit.  It&#39;s checked in a couple of places, but always in the same context, and it&#39;s a rather enligh­tening one: RAM parity checking.</p>

<h6 id="a-perfunctory-parity-primer">A Perfunctory Parity Primer</h6>

<p>For every byte of memory in the IBM PC-<wbr/>family archi­tecture, there&#39;s one bit of <em>parity</em>, as a basic means of detecting RAM corrup­tion.  A parity mismatch will initiate a <em>Non-<wbr/>Maskable Inter­rupt (NMI)</em>; this is trig­gered by setting off one of two signals - depen­ding on the general direc­tion that the error came from.  In the AT, it works like this:</p>

<ul>
<li><strong>RAM on the system board</strong> triggers <b>&#34;Parity Check&#34;</b>, which sets <b>bit 7</b> of port 61h (if enabled by setting <b>bit 2</b>).</li>
<li><strong>RAM expansion cards</strong> trigger <b>&#34;I/O Channel Check&#34;</b>, which sets <b>bit 6</b> of port 61h (if enabled by setting <b>bit 3</b>).</li>
</ul>



<p>These commonly-<wbr/>seen signal names may be somewhat confu­sing, but for our purposes it&#39;s enough to remem­ber that they <em>both</em> indicate parity errors, and both are concerned with RAM; &#34;I/O channel&#34; simply means the expan­sion bus. The BIOS&#39;s NMI handler has the addi­tional job of telling you more pre­cisely just <em>where</em> things went lopsided, and in this &#39;rev. 1.5&#39; BIOS, that&#39;s where our mystery bit 3 crops up.</p>

<h6 id="many-nmis-bring-much-honor">Many NMIs Bring Much Honor</h6>

<p>When the NMI service routine is invoked, it tries to deter­mine what has roused it from its slumber.  If the cause was a parity error, it will display the message &#34;<strong>PARITY CHECK 1</strong>&#34; (if the source was on-<wbr/>board RAM) or &#34;<strong>2</strong>&#34; (a RAM expan­sion card), and then promptly halt the system - not a bad idea if your RAM chips are out of whack.  But first, it&#39;ll try to <em>repro­duce</em> the error in the first 640K; so if that&#39;s where the problem lies, you could find out which chip is acting up.</p>

<p>Interes­tingly, this test <em>doesn&#39;t</em> try to match the specific type of parity error that raised the NMI: for each 64K region, it decides which of the two parity check signals it&#39;s going to look for.  Those switch settings in <code>MFG_TST</code> play into this choice, so we can get some insight by looking at the logic. In all versions of the AT BIOS, the relevant code is in <code>NMI_INT_1</code>.</p>

<p>For compa­rison, the <strong>Rev. 1</strong> BIOS does it as follows.  The diagram is somewhat simpli­fied, but this is the general logic:</p>

<p><svg style="max-width: 100%; height: auto; border:2px solid var(--c-border); padding: 0 3%; background: black" version="1.1" viewBox="0 0 860 360" xmlns="http://www.w3.org/2000/svg">
    <rect width="100%" height="100%" style="fill:#000"></rect>
    <g transform="translate(16,11)" stroke-miterlimit="10" style="stroke:#aaa;fill:#aaa">
        <path d="m190 50.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m360 50.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m422 139-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m535 50.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m520 260-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m412 289-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m596 139-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m772 139-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m483 180 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m710 180-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m673 260 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m483 310 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m313 180 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m252 71.6 4.5 9-4.5-2.25-4.5 2.25z"></path>
        <path d="m95 70.6 4.5 9-4.5-2.25-4.5 2.25z"></path>
        <path d="m252 289-4.5-9 4.5 2.25 4.5-2.25z"></path>
    </g>
    <g transform="translate(16,11)" style="stroke:#aaa;fill:none" stroke-miterlimit="10">
        <path d="m322 50.5h32.1"></path>
        <path d="m114 50.5h69.9"></path>
        <path d="m422 90.5v42.1"></path>
        <path d="m482 50.5h47.1"></path>
        <path d="m432 214v36.7q0 10 10 10h72.1"></path>
        <path d="m412 214v16.7q0 10 0 20v32.1"></path>
        <path d="m596 90.5v42.1"></path>
        <path d="m656 50.5h105q10 0 10 10v72.1"></path>
        <path d="m536 180h-47.1"></path>
        <path d="m656 180h47.1"></path>
        <path d="m760 211h1q1 0 1 10v29.9q0 10-10 10h-72.1"></path>
        <path d="m785 212-1.72.03q-1.72.02-1.72 10v78.7q0 10-10 10h-282"></path>
        <path d="m382 310h-25q-10 0-10-10v-110q0-10-10-10h-17.1"></path>
        <path d="m252 156v-56q0-10 0-16.1v-6.06"></path>
        <path d="m95 111v-33.8"></path>
        <path d="m252 204v56q0 10 0 16.1v6.06"></path>
    </g>
    <g transform="translate(16,11)" style="fill:#4e3028;stroke:#97625f" stroke-width="2">
        <rect x="521" y="240" width="150" height="40" rx="19.2" ry="19.2"></rect>
        <rect x="181" y="290" width="140" height="40" rx="19.2" ry="19.2"></rect>
        <g stroke-miterlimit="10" style="fill:#732b26;stroke:#c87137">
            <path d="m421 10 60 40-60 40-60-40z"></path>
            <path d="m596 10 60 40-60 40-60-40z"></path>
            <path d="m596 140 60 40-60 40-60-40z"></path>
            <path d="m251 140 60 40-60 40-60-40z"></path>
        </g>
    </g>
    <g transform="translate(16,11)" stroke-miterlimit="10" stroke-width="2" style="fill:#675000;stroke:#d4aa00">
        <path d="m421 140 60 40-60 40-60-40z"></path>
        <path d="m771 140 60 40-60 40-60-40z"></path>
    </g>
    <rect x="18" y="118" width="160" height="136" rx="12.8" ry="12.8" stroke-dasharray="2, 2" stroke-width="2" style="fill:#49401f;stroke:#d4aa00"></rect>
    <rect x="207" y="41" width="130" height="40" stroke-width="2" style="fill:#453426;stroke:#ac7d56"></rect>
    <g style="fill:#2b2b2b;stroke:#d4aa00">
        <rect x="73" y="41" width="76" height="40"></rect><rect x="398" y="302" width="100" height="40"></rect>
    </g>
    <g style="fill:#000">
        <rect x="254" y="113" width="26.7" height="17.6"></rect>
        <rect x="422" y="113" width="26.7" height="17.6"></rect>
        <rect x="598" y="113" width="26.7" height="17.6"></rect>
        <rect x="784" y="252" width="26.7" height="17.6"></rect>
        <rect x="412" y="252" width="26.7" height="17.6"></rect>
        <rect x="255" y="253" width="26.7" height="17.6"></rect>
        <rect x="508" y="52.7" width="26.7" height="17.6"></rect>
        <rect x="702" y="52.7" width="26.7" height="17.6"></rect>
        <rect x="724" y="262" width="26.7" height="17.6"></rect>
        <rect x="474" y="262" width="26.7" height="17.6"></rect>
        <rect x="683" y="180" width="26.6" height="23.4"></rect>
        <rect x="516" y="180" width="26.6" height="23.4"></rect>
    </g>
    <g transform="translate(16,11)" font-family="Arial, Helvetica" style="fill:#fff;font-size:13px">
        <text x="2.7" y="11" style="font-size:14px;font-weight:bold">AT BIOS Rev. 1 NMI Handler</text>
        <text><tspan x="11.5" y="124.4">Read port 61h to</tspan><tspan x="11.5" y="138.7">determine source.</tspan><tspan x="11.5" y="161.3">If <tspan style="font-weight:bold">on-board RAM</tspan>, <tspan dy="-5" style="fill:#ff6600;font-size:85%">a</tspan></tspan><tspan x="11.5" y="175.6">print &#34;<tspan style="font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">PARITY CHECK 1</tspan>&#34;</tspan><tspan x="11.5" y="198.2">If <tspan style="font-weight:bold">I/O channel RAM</tspan>, <tspan dy="-5" style="fill:#ff6600;font-size:85%">b</tspan></tspan><tspan x="11.5" y="212.5">print &#34;<tspan style="font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">PARITY CHECK 2</tspan>&#34;</tspan><tspan x="11.5" y="235.1">If neither, exit handler</tspan></text>
        <text style="font-size:11px;fill:#f60"><tspan x="3.2" y="280.6">a</tspan><tspan x="3.2" y="294.9">b</tspan><tspan x="3.2" y="309.2">c</tspan></text>
        <text><tspan x="15.4" y="284.4">Port 61h bit 7 is set</tspan><tspan x="15.4" y="298.7">Port 61h bit 6 is set</tspan><tspan x="15.4" y="313"><tspan style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">BASE_RAM</tspan> (<tspan style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">MFG_TST</tspan></tspan><tspan x="15.4" y="327.7">bit 4)</tspan></text>
        <text text-anchor="middle"><tspan x="255.6" y="48" style="fill:#d4aa00">(NMI_LOOP)</tspan><tspan x="255.6" y="62.3" style="fill:#d4aa00">Read 64K segment</tspan></text>
        <g text-anchor="middle">
            <text x="421" y="115">No</text>
            <text x="505.2" y="55.1">Yes</text>
            <text><tspan x="421.2" y="40.3">Above</tspan><tspan x="421.2" y="54.6">256K</tspan><tspan x="421.2" y="68.9">mark?</tspan></text>
            <text x="471" y="264">Yes</text>
            <text x="411" y="254">No</text>
        </g>
        <text x="421.2" y="170.3" text-anchor="middle"><tspan x="421.2" y="170.3">New</tspan><tspan x="421.2" y="184.6">on-board RAM</tspan><tspan x="421.2" y="198.9">error? <tspan dy="-5" style="fill:#ff6600;font-size:85%">a</tspan></tspan></text>
        <g text-anchor="middle">
            <text x="596" y="115">No</text>
            <text x="699" y="54">Yes</text>
            <text><tspan x="596.2" y="40.3">Above</tspan><tspan x="596.2" y="54.6">512K</tspan><tspan x="596.2" y="68.9">mark?</tspan></text>
            <text><tspan x="513" y="177.9">512</tspan><tspan x="513" y="192.2">KB</tspan></text>
            <text><tspan x="680.1" y="177.9">256</tspan><tspan x="680.1" y="192.2">KB</tspan></text>
            <text><tspan x="596.1" y="170.4">Size of</tspan><tspan x="596.1" y="184.7" style="text-decoration:underline">on-board</tspan><tspan x="596.1" y="199">RAM? <tspan dy="-5" style="fill:#ff6600;font-size:85%">c</tspan></tspan></text>
            <text x="721" y="264">Yes</text>
            <text x="781" y="254">No</text>
            <text><tspan x="770.8" y="170.3">New</tspan><tspan x="770.8" y="184.6">I/O Channel</tspan><tspan x="770.8" y="198.9">error? <tspan dy="-5" style="fill:#ff6600;font-size:85%">b</tspan></tspan></text>
            <g style="fill:#d4aa00">
                <text><tspan x="431.4" y="307.6">Point to next</tspan><tspan x="431.4" y="321.9">64K segment</tspan></text>
                <text><tspan x="95" y="46">Point to</tspan><tspan x="95" y="61">segment 0</tspan></text>
            </g>
            <g style="fill:#e27366">
                <text><tspan x="250.6" y="307.4">Not reproduced: print</tspan><tspan x="250.6" y="321.7">&#34;?????&#34; and halt</tspan></text>
                <text><tspan x="595.6" y="257.1">Error reproduced: print</tspan><tspan x="595.6" y="271.4">segment no. and halt</tspan></text>
            </g>
            <text x="251" y="115">No</text>
            <text x="251" y="255">Yes</text>
            <text><tspan x="251" y="170.4">Top</tspan><tspan x="251" y="184.7">of base</tspan><tspan x="251" y="199">RAM?</tspan></text>
        </g>
        <text x="3" y="96" style="fill:#aaaaaa">Start:</text>
    </g>
</svg></p>

<p>That is, below 256K it always watches for on-<wbr/>board RAM parity checks; between 256K and 512K, the RAM is either on-<wbr/>board (in a 512K system) or on an expan­sion card (in a 256K system), so it selects the signal to watch for based on the size of on-<wbr/>board RAM. Above 512K, it has to be expan­sion RAM, so it always goes with the &#34;I/O channel&#34; error.</p>

<p>In <strong>revisions 2 and 3</strong>, the NMI handler&#39;s memory test is less revealing: no matter the RAM address, it always watches for <em>both</em> types of parity error, and treats either one as a good enough repro­duction. Likely, the desi­gners decided that being picky about it wasn&#39;t worth the extra code, since the test already disre­gards the type of error which caused the NMI to fire in the first place.</p>

<p>&#39;<strong>Rev. 1.5</strong>&#39;, however, still insists on being pedantic. Which is fortu­nate for us, because the change in logic from rev. 1 is very instruc­tive:</p>

<p><svg style="max-width: 100%; height: auto; border:2px solid var(--c-border); padding: 0 3%; background: black" version="1.1" viewBox="0 0 860 386" xmlns="http://www.w3.org/2000/svg">
    <rect width="100%" height="100%" style="fill:#000"></rect>
    <g stroke-miterlimit="10" style="stroke:#aaa;fill:#aaa">
        <path d="m194 80.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m378 80.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m439 169-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m553 80.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m538 300-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m429 329-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m614 169-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m728 80.5-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m500 210 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m728 210-9 4.5 2.25-4.5-2.25-4.5z"></path>
        <path d="m690 300 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m506 350 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m330 242 9-4.5-2.25 4.5 2.25 4.5z"></path>
        <path d="m269 329-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m268 102 4.6 8.95-4.52-2.2-4.48 2.3z"></path>
        <path d="m97 102 4.6 8.95-4.52-2.2-4.48 2.3z"></path>
        <path d="m789 169-4.5-9 4.5 2.25 4.5-2.25z"></path>
        <path d="m376 210-9 4.5 2.25-4.5-2.25-4.5z"></path>
    </g>
    <g style="stroke:#aaa;fill:none" stroke-miterlimit="10">
        <path d="m299 80.5h72.1"></path>
        <path d="m115 80.5h72.1"></path>
        <path d="m439 120v42.1"></path>
        <path d="m499 80.5h47.1"></path>
        <path d="m449 244v46.7q0 10 10 10h72.1"></path>
        <path d="m429 244v26.7q0 10 0 20v32.1"></path>
        <path d="m614 120v42.1"></path>
        <path d="m97 100v42.1"></path>
        <path d="m674 80.5h47.1"></path>
        <path d="m554 210h-47.1"></path>
        <path d="m674 210h47.1"></path>
        <path d="m779 243-.03 47.7q-.01 10-10 10h-72.1"></path>
        <path d="m798 244 .01 8.2q.01 8.2.07 18.2l.38 70q.06 10-9.94 10h-282"></path>
        <path d="m405 350h-25c-6.67 0-10-3.33-10-10v-89c0-6.67-3.33-10-10-10h-23.1"></path>
        <path d="m269 244v56q0 10 0 16.1v6.06"></path>
        <path d="m269 202v-40.5q0-10-.11-20l-.35-31.6"></path>
        <path d="m789 120v42.1"></path>
        <path d="m789 40.5v-10q0-10-10-10H355q-9.7 0-10 10v45c6 0 6 10 0 10v0 115q0 10 10 10h29"></path>
    </g>
    <g stroke-miterlimit="10" stroke-width="2" style="fill:#732b26;stroke:#c87137">
        <path d="m438 40 60 40-60 40-60-40z"></path>
        <path d="m614 40 60 40-60 40-60-40z"></path>
        <path d="m614 170 60 40-60 40-60-40z"></path>
        <path d="m268 201 60 40-60 40-60-40z"></path>
        <path d="m788 40 60 40-60 40-60-40z"></path>
    </g>
    <g fill="#fff" stroke-width="2" style="fill:#4e3028;stroke:#97625f">
        <rect x="538" y="280" width="150" height="40" rx="19.2" ry="19.2"></rect>
        <rect x="206" y="330" width="136" height="40" rx="19.2" ry="19.2"></rect>
    </g>
    <g fill="#e3c800" stroke-miterlimit="10" stroke-width="2" style="fill:#675000;stroke:#d4aa00">
        <path d="m438 170 60 40-60 40-60-40z"></path>
        <path d="m788 170 60 40-60 40-60-40z"></path>
    </g>
    <rect x="18.5" y="134" width="160" height="136" rx="12.8" ry="12.8" stroke-dasharray="2, 2" stroke-width="2" style="fill:#49401f;stroke:#d4aa00"></rect>
    <rect x="196" y="60" width="123" height="40" stroke-width="2" style="fill:#453426;stroke:#ac7d56"></rect>
    <g style="fill:#2b2b2b;stroke:#d4aa00">
        <rect x="405" y="330" width="100" height="40"></rect><rect x="59" y="60.5" width="75.7" height="40"></rect>
    </g>
    <g style="fill:#000">
        <rect x="256" y="142" width="26.7" height="17.6"></rect>
        <rect x="426" y="133" width="26.7" height="17.6"></rect>
        <rect x="601" y="133" width="26.7" height="17.6"></rect>
        <rect x="786" y="277" width="26.7" height="17.6"></rect>
        <rect x="416" y="277" width="26.7" height="17.6"></rect>
        <rect x="255" y="293" width="26.7" height="17.6"></rect>
        <rect x="509" y="71.7" width="26.7" height="17.6"></rect>
        <rect x="684" y="71.7" width="26.7" height="17.6"></rect>
        <rect x="728" y="292" width="26.7" height="17.6"></rect>
        <rect x="478" y="292" width="26.7" height="17.6"></rect>
        <rect x="729" y="11.2" width="26.7" height="17.6"></rect>
        <rect x="776" y="133" width="26.7" height="17.6"></rect>
        <rect x="684" y="202" width="26.7" height="17.6"></rect>
        <rect x="519" y="202" width="21.2" height="17.6"></rect>
    </g>
    <g transform="translate(16,11)" font-family="Arial, Helvetica" style="fill:#fff;font-size:13px">
        <text x="2.7" y="15.5" style="font-size:14px;font-weight:bold">AT BIOS &#34;Rev. 1.5&#34; NMI Handler</text>
        <text><tspan x="13.3" y="140.4">Read port 61h to</tspan><tspan x="13.3" y="154.7">determine source.</tspan><tspan x="13.3" y="177.3">If <tspan style="font-weight:bold">on-board RAM</tspan>, <tspan dy="-5" style="fill:#ff6600;font-size:85%">a</tspan></tspan><tspan x="13.3" y="191.6">print &#34;<tspan style="font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">PARITY CHECK 1</tspan>&#34;</tspan><tspan x="13.3" y="214.2">If <tspan style="font-weight:bold">I/O channel RAM</tspan>, <tspan dy="-5" style="fill:#ff6600;font-size:85%">b</tspan></tspan><tspan x="13.3" y="228.5">print &#34;<tspan style="font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">PARITY CHECK 2</tspan>&#34;</tspan><tspan x="13.3" y="251.1">If neither, exit handler</tspan></text>
        <text style="font-size:11px;fill:#f60"><tspan x="-0.3" y="282.9">a</tspan><tspan x="-0.3" y="297.2">b</tspan><tspan x="-0.3" y="311.5">c</tspan><tspan x="-0.3" y="340.1">d</tspan></text>
        <text><tspan x="11.9" y="286.8">Port 61h bit 7 is set</tspan><tspan x="11.9" y="301.1">Port 61h bit 6 is set</tspan><tspan x="11.9" y="315.4"><tspan style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">BASE_MEM8 &amp; !BASE_MEM</tspan></tspan><tspan x="11.9" y="330">(<tspan style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">MFG_TST</tspan> bit 3 &amp; !bit 4)</tspan><tspan x="11.9" y="344.6" style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">BASE_MEM+BASE_MEM8</tspan><tspan x="11.9" y="359.3">(<tspan style="fill:#d4aa00;font-family:&#39;Iosevka Fixed SS05&#39;;font-size:12px">MFG_TST</tspan> bit 3 | bit 4)</tspan></text>
        <text text-anchor="middle"><tspan x="240.6" y="66.3" style="fill:#d4aa00">(NMI_LOOP)</tspan><tspan x="240.6" y="80.6" style="fill:#d4aa00">Read 64K segment</tspan></text>
        <g text-anchor="middle">
            <text x="597.7" y="135.1">No</text>
            <text x="506.7" y="74.1">Yes</text>
            <text><tspan x="422.7" y="59.3">Above</tspan><tspan x="422.7" y="73.6">256K</tspan><tspan x="422.7" y="87.9">mark?</tspan></text>
            <text x="475.7" y="294.6">Yes</text>
            <text x="413" y="279.5">No</text>
        </g>
        <text text-anchor="middle"><tspan x="422.7" y="189.3">New</tspan><tspan x="422.7" y="203.6">on-board RAM</tspan><tspan x="422.7" y="217.9">error? <tspan dy="-5" style="fill:#ff6600;font-size:85%">a</tspan></tspan></text>
        <g text-anchor="middle">
            <text x="772.7" y="135.1">No</text>
            <text x="681.7" y="74.1">Yes</text>
            <text><tspan x="597.7" y="59.3">Above</tspan><tspan x="597.7" y="73.6">512K</tspan><tspan x="597.7" y="87.9">mark?</tspan></text>
            <text><tspan x="597.6" y="189.5">256K on</tspan><tspan x="597.6" y="203.8">board + &#39;640/X&#39;</tspan><tspan x="597.6" y="218.1">flag? </tspan><tspan dy="-5" style="fill:#ff6600;font-size:85%">c</tspan></text>
            <text x="725.7" y="294.6">Yes</text>
            <text x="783.2" y="279.5">No</text>
        </g>
        <g text-anchor="middle">
            <g style="fill:#d4aa00">
                <text><tspan x="438.9" y="335.6">Point to next</tspan><tspan x="438.9" y="349.9">64K segment</tspan></text>
                <text><tspan x="80.9" y="66.2">Point to</tspan><tspan x="80.9" y="80.5">segment 0</tspan></text>
            </g>
            <text><tspan x="773.3" y="190.3">New</tspan><tspan x="773.3" y="204.6">I/O Channel</tspan><tspan x="773.3" y="218.9">error? <tspan dy="-5" style="fill:#ff6600;font-size:85%">b</tspan></tspan></text>
            <text x="422.7" y="135.1">No</text>
            <text x="252.5" y="295.4">Yes</text>
            <text><tspan x="252.5" y="220.4">Top</tspan><tspan x="252.5" y="234.7">of base</tspan><tspan x="252.5" y="249.0">RAM?</tspan></text>
            <g style="fill:#e27366">
                <text text-anchor="middle"><tspan x="258.1" y="336.4">Not reproduced: print</tspan><tspan x="258.1" y="350.7">&#34;?????&#34; and halt</tspan></text>
                <text><tspan x="597.1" y="285.7">Error reproduced: print</tspan><tspan x="597.1" y="300.0">segment no. and halt</tspan></text>
            </g>
            <text x="252.8" y="144.4">No</text>
            <text x="726.1" y="13.6">Yes</text>
            <text x="514.2" y="204.1">No</text>
            <text x="681.7" y="204.1">Yes</text>
            <text><tspan x="772.8" y="59.8">512K on</tspan><tspan x="772.8" y="74.1">board + &#39;640/X&#39;</tspan><tspan x="772.8" y="88.4">flag? </tspan><tspan dy="-5" style="fill:#ff6600;font-size:85%">d</tspan></text>
        </g>
        <text x="3" y="112.5" style="fill:#aaaaaa">Start:</text>
    </g>
</svg></p>

<p>The crucial diffe­rence is in the region above 512K, where the &#39;640/X&#39; flag (AKA <code>BASE_MEM8</code>) comes in. When the machine has 512K on the system board <em>and</em> the &#39;640/X&#39; bit is set, the test in revision &#34;1.5&#34; will expect <em>on-board</em> parity errors in this block of RAM.</p>

<p>If follo­wing a bunch of arrows around isn&#39;t your idea of a good time, this format may be easier on the eyes:</p>

<table><thead>
    <tr>
        <th>Region</th>
        <th><strong>Rev. 1</strong> checks for</th>
        <th><strong>Rev. &#39;1.5&#39;</strong> checks for</th>
        <th><strong>Rev. 2, 3</strong> check for</th>
    </tr>
</thead><tbody>
    <tr>
        <th scope="row">0K<wbr/>--<wbr/>256K</th>
        <td>On-board RAM error</td>
        <td>On-board RAM error</td>
        <td>(Any parity error)</td>
    </tr>
    <tr>
        <th scope="row">256K<wbr/>--<wbr/>512K</th>
        <td>[256K system]: I/O channel error</td>
        <td>[256K+&#39;640/X&#39;]: I/O channel error</td>
        <td>(Any parity error)</td>
    </tr>
    <tr>
        <th scope="row">512K<wbr/>--<wbr/>640K</th>
        <td>I/O channel error</td>
        <td><span>[512K+&#39;640/X&#39;]: On-board RAM error</span></td>
        <td>(Any parity error)</td>
    </tr>
</tbody></table>

<p><em>&#34;Yeah, yeah, get to the point&#34;:</em> what does this <em>mean</em>, then?</p>

<p>Well, let&#39;s imagine that the matching mother­board had some­thing like an extra 128K bank of RAM, plus a switch or a jumper to indicate that it was popu­lated. If the &#39;640/X&#39; bit ref­lected the state of that switch, this would all make sense - and so would the &#34;<em>base planar</em>&#34; termi­nology from IBM&#39;s later listings.</p>

<p>What <em>doesn&#39;t</em> make quite as much sense is the behavior of the &#34;256K on board&#34; setting: whether it&#39;s used in tandem with the &#39;640/<wbr/>X&#39; flag or without it, there&#39;s <em>some</em> region of memory where the error-<wbr/>catching logic seems to be all wrong.  But it&#39;s entirely possible (even likely, as we&#39;ll see in a bit) that these mother­boards simply never had less than 512K, like the Type 2 and Type 3 AT boards.  That would make the &#34;256K&#34; setting rather pointless, so the code paths involved might have been neglected or disregarded.  Unless this jumper setting was repurposed to mean something else, although if it was, the code doesn&#39;t make it immediately clear.</p>

<h6 id="the-post-memory-test-loop-and-the-1mb-oddity">The POST Memory Test Loop... and the &gt;1MB Oddity</h6>

<p>There&#39;s another place where the &#39;rev. 1.5&#39; BIOS refers to the status of the &#39;640/X&#39; flag: the cold-<wbr/>boot RAM checkup.  This one performs a full read/<wbr/>write test, but it also watches out for parity errors, as in the NMI handler.  However, the latter only bothers with conven­tional (&#39;base&#39;) memory; for the boot-<wbr/>up test, the POST has to enter protected mode and go through <em>all</em> RAM in the system, inclu­ding extended memory above 1 MB (if any).</p>

<p>For conven­tional memory, when deter­mining the type of parity check to expect for each range of addres­ses, the cold-<wbr/>boot RAM test broadly follows the same logic we&#39;ve seen in the NMI handler.  For each of the 3 official BIOS versions, the res­pective assump­tions from the NMI routine are repeated here, and that&#39;s still true for this revision. But past the 1 MB mark, it goes and does its own thing again.</p>

<p>In <strong>rev. 1</strong>, all non-<wbr/>conven­tional memory is reaso­nably assumed to reside on some sort of expan­sion board, so when testing the &gt;1 MB region it looks for <em>I/O Channel</em> parity errors.  Revisions <strong>2</strong> and <strong>3</strong> always check for both types of errors, regard­less of the address, and they&#39;re as non-<wbr/>specific about extended memory as they were about the first 640K.</p>

<p>But for some reason, &#39;rev. 1.5&#39; here appears to reserve special treat<wbr/>ment for the address range between 1 and <strong>1.5 MB</strong>:</p>

<pre><span>F000:0FFC</span>                 <span>E21_C1M:</span>                                        <span>; [* 1MB boundary *]</span>
<span>F000:0FFC</span><span> C6 06 64 00 10</span>      <span>mov</span>   <span>byte</span> <span>ptr</span> <span>ds</span><span>:</span><span>DS_TEMP</span><span>+</span><span>BASE_HI_BYTE</span><span>,</span> <span>16</span>
<span>F000:1001</span><span> C6 06 4C 00 10</span>      <span>mov</span>   <span>byte</span> <span>ptr</span> <span>ds</span><span>:</span><span>ES_TEMP</span><span>+</span><span>BASE_HI_BYTE</span><span>,</span> <span>16</span>
<span>F000:1006</span><span> B0 40         </span>      <span>mov</span>   <span>al</span><span>,</span> <span>IO_CHECK</span>                          <span>; [* I/O Check mask (&gt;1M on exp. card) *]</span>
<span>F000:1008</span><span> E6 87         </span>      <span>out</span>   <span>DMA_PAGE</span><span>+</span><span>6</span><span>,</span> <span>al</span>                        <span>; [* temporary storage *]</span>
<span>F000:100A</span><span> 1E            </span>      <span>push</span>  <span>ds</span>
<span>F000:100B</span>
<span>F000:100B</span>                 <span>; [* this rev. only: get hardware configuration again *]</span>
<span>F000:100B</span>
<span>F000:100B</span><span> B8 18 00      </span>      <span>mov</span>   <span>ax</span><span>,</span> <span>RSDA_PTR</span>                          <span>; [* system data area for POST *]</span>
<span>F000:100E</span><span> 8E D8         </span>      <span>mov</span>   <span>ds</span><span>,</span> <span>ax</span>
<span>F000:1010</span><span> A0 12 00      </span>      <span>mov</span>   <span>al</span><span>,</span> <span>ds</span><span>:</span><span>@MFG_TST</span>                       <span>; [* get mfg test config *]</span>
<span>F000:1013</span><span> 1F            </span>      <span>pop</span>   <span>ds</span>
<span>F000:1014</span><span> 24 18         </span>      <span>and</span>   <span>al</span><span>,</span> <span>BASE_MEM</span><span>+</span><span>BASE_MEM8</span>                <span>; [* Planar RAM configuration bits:    *]</span>
<span>F000:1016</span><span> 3C 10         </span>      <span>cmp</span>   <span>al</span><span>,</span> <span>BASE_MEM</span>                          <span>; [* bit 4 (512k planar) ONLY?         *]</span>
<span>F000:1018</span><span> 75 04         </span>      <span>jnz</span>   <span>short</span> <span>E21_C1M5</span>                        <span>; [* no: keep I/O Check mask *]</span>
<span>F000:101A</span><span> B0 80         </span>      <span>mov</span>   <span>al</span><span>,</span> <span>PARITY_CHECK</span>                      <span>; [* yes: use Parity check mask (planar) *]</span>
<span>F000:101C</span><span> E6 87         </span>      <span>out</span>   <span>DMA_PAGE</span><span>+</span><span>6</span><span>,</span> <span>al</span>                        <span>; [* and save to temporary storage *]</span>
<span>F000:101E</span>
<span>F000:101E</span>                 <span>; [* this rev. only: check for 1.5MB boundary (24*64K)? *]</span>
<span>F000:101E</span>
<span>F000:101E</span>                 <span>E21_C1M5:</span>
<span>F000:101E</span><span> 80 3E 64 00 18</span>      <span>cmp</span>   <span>byte</span> <span>ptr</span> <span>ds</span><span>:</span><span>DS_TEMP</span><span>+</span><span>BASE_HI_BYTE</span><span>,</span> <span>24</span>
<span>F000:1023</span><span> 72 04         </span>      <span>jb</span>    <span>short</span> <span>NEXT1</span>                           <span>; [* continue if below 1.5MB *]</span>
<span>F000:1025</span><span> B0 40         </span>      <span>mov</span>   <span>al</span><span>,</span> <span>IO_CHECK</span>                          <span>; [* reset to I/O Check mask above 1.5MB *]</span>
<span>F000:1027</span><span> E6 87         </span>      <span>out</span>   <span>DMA_PAGE</span><span>+</span><span>6</span><span>,</span> <span>al</span>                        <span>; [* temporary storage *]</span>
</pre>

<p>The logic here seems to be this: if the 1--<wbr/>1.5 MB region contains any RAM at all, the code checks whether the &#34;512K on board&#34; bit is set, and the &#39;640/X&#39; bit is <em>clear</em>.  If (and only if) this is the case, it watches for <em>on-<wbr/>board RAM</em> parity errors when testing these first 512K of extended memory.  Other­wise, it goes with the I/O Channel (expan­sion RAM) check, which is what you&#39;d expect on a standard 5170.</p>

<p>What that could mean is anybody&#39;s guess.  But if we take this at face value, then our theo­retical mother­board may have had two selec­table configu­rations:</p>

<ul>
<li><strong>640K</strong> on board (the usual 512K plus 128K extra), which would then fill up conven­tional memory to the limit; <em>OR</em>,</li>
<li><strong>1024K</strong> on board, set up as 512K base plus 512K extended, with the latter mapped between 1 and 1.5 MB.</li>
</ul>



<p>In the first case, you&#39;d set the hypothe­tical switch or jumper one way, causing the &#39;640/X&#39; bit (AKA <code>BASE_MEM8</code>) to be set.  In the second case, the switch goes the other way, which would clear it.  With a full meg on board, the logic implies that the 128K expansion board can still be used, bringing your base RAM up to 640K.</p>

<h6 id="the-pcb-real-estate-question">The PCB Real-Estate Question</h6>

<figure><a href="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/AT_512k.jpg"><img src="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/AT_512k_tn.jpg" alt="512K RAM bank from a Type 3 IBM AT board"/></a>
<figcaption>512K RAM bank from a Type 3 IBM AT board: that&#39;s an awful lot of space there, isn&#39;t it? <i>[image courtesy of Rodney/<a href="https://www.knaapic.nl/wordpress/recreation-of-the-historic-ibm-pc-at-model-5170" target="blank">knaapic.nl</a>]</i></figcaption></figure>
    

<p>One may wonder where a megabyte of RAM might go on the 5170 main­board (or on some plau­sible variant of it).  But that&#39;s not too far fetched if we assume 256 kbit DRAM chips, like the Type 2 and 3 AT boards.</p>

<p>In fact, looking at those later main­boards, the layout around that single 512K RAM bank seems rather cozy and spacious, which sort of stands out next to the cramped organi­zation of the rest of the board.  Those two rows of chips are flanked on both sides by curiously empty space - coinci­dentally, it looks like there&#39;s just enough room there to double the chip count with a minimal change in design.</p>

<p>If we roll with this obser­vation, we can just about arrive at a scenario where the <em>first</em> redesign of the 5170 mainboard - cor­res­pon­ding to our &#39;rev. 1.5&#39; AT BIOS on the timeline - could have ac­com­mo­da­ted as much as 1024K of memory.  For reasons of their own, the powers that be at IBM decided not to pursue this as a finished product, and the next AT models to hit the market (with the Type 2 main­board, and the rev. 2 BIOS) were stripped down to one bank of 512K, leaving all that board real-<wbr/>estate unused.</p>

<p>Since the &#39;rev. 1.5&#39; BIOS code seems to imply a selec­table co­fi­gu­ra­tion of either 1 MB or 640 KB, could such a RAM sub­system support either setup at the flip of a switch?  Supposing one 16-<wbr/>bit bank of 512K (using 256 kbit DRAM chips), that second 16-bit bank would then have to accept either all-<wbr/>256 kbit or all-<wbr/>64 kbit DRAM, without mixing and matching capa­cities.  Not exactly a common design on PC mother­boards, but entirely feasible, and some memory add-<wbr/>on cards with flexible capa­cities did do things that way.</p>

<h3 id="skyrocket-the-real-deal">Skyrocket: The Real Deal?</h3>

<p>Conjec­tures are fun and all, but can this hypothe­tical PC/AT variant be identi­fied with anything like an actual real-<wbr/>world machine?  Nothing&#39;s for sure, but there may be a rather fat clue lurking in an old Usenet post from ex-IBM employee Tony Ingenoso (thanks to David of <a href="http://ibmmuseum.com/" target="_blank">IBM Museum</a> for remin­ding me of this one).</p>

<p>The thread in question is &#39;<a href="https://groups.google.com/g/comp.sys.ibm.ps2.hardware/c/9libo3DblGQ/m/N-Cis5lVdwYJ" target="_blank">OT: &#34;Sky­rocket&#34; the AT that never was</a>&#39;, posted to comp.<wbr/>sys.<wbr/>ibm.<wbr/>ps2.<wbr/>hardware back in 2001. Tony shares the follo­wing:</p>

<blockquote>
<p>Sorting through the piles a bit I&#39;ve (re)­dis­covered a bit of ancient AT
history -- the machine that had the internal code­name &#34;Sky­rocket&#34;. Looks
just like a normal AT with the primary diffe­rence being there is 640K on the
planar rather than 512K as shipped in all the retail models.</p>

<p>How did I happen across this rather unique piece of history? Well, I was in
the right place at the right time when the Boca Raton site was being
shutdown and thrown to the wind. IBM was fire­saleing off all sorts of gear
to the employees and I&#39;d bought a stack of AT&#39;s for $10/<wbr/>each. On closer
exa­mi­na­tion, one of the stack turned out to be the rare Skyrocket...</p>
</blockquote>

<p>Further along the thread, we get more details:</p>

<blockquote>
<p>Sky­rocket&#39;s planar is tra­di­tional &#34;big&#34; AT style (not the shortie 339 or
XT-286 style), but uses normal DIP&#39;s not the old Mostek/<wbr/>TI DIL&#39;s (posi­tioned
on the usual place the double deckers would be on the planar though). It&#39;s
got a two rows of 41256 and two of 4164 type DIP.</p>

<p>I believe Sky­rocket probably predates XT-286, and may have been con­cur­rent
with 339 at some point. When the project was shelved, some number of
advanced proto­type had been produced and were dis­tri­bu­ted about the site on
an IUO basis - I had one on my desk in 86&#39; during OS/2 1.0 deve­lop­ment (real
339&#39;s were rare and all being shipped out to custo­mers<wbr/><g>). Where the &#34;AT&#34;
badge would be is a metalic emblem shooting star logo, which leads me to
believe it was fairly well along when it was shot down...</g></p>
</blockquote>



<blockquote>
<p>My sense is that the Skyrocket machine was tanked because the 339 planar was
ready, cost less to manufacture, and with PS/2 ready to be unveiled, it just
wasn&#39;t worth the bother to get the extra 128K onto the planar for a machine
that would have a distinctly limited lifespan.</p>
</blockquote>

<p>That DRAM layout is just as predicted above for the 640 KB option: one Type 2/­3-<wbr/>style bank of 256 kbit DIPs (512 KB), plus one bank of 64 kbit DIPs (for the extra 128 KB).  In a <a href="https://groups.google.com/g/comp.sys.ibm.ps2.hardware/c/Eu4vGX-0f3M/m/A-ZoyzrXqdUJ" target="_blank">diffe­rent thread</a>, Tony also mentions that &#34;Sky­rocket&#34; had an <strong>8 MHz</strong> system board.</p>

<h6 id="or-is-it">...Or is it?</h6>

<p>Now, I&#39;m not comple­tely con­vinced beyond a shadow of a doubt that this is what we have here.  Given what I can make of this BIOS, the parti­culars of this cancelled AT proto­type do fit... but not <em>exactly</em> like a glove.</p>

<ul>
<li><p>The most obvious smoking gun is of course the 640K system board, but there&#39;s also that alter­native 1 MB option implied by the cold-<wbr/>boot RAM test loop, which Tony doesn&#39;t mention.</p></li>

<li><p>He makes it sound like &#34;Sky­rocket&#34; came along fairly late in the 5170&#39;s lifespan, pos­sibly con­cur­rent with the Model 339/<wbr/>Type 3 AT, and not all that long before the launch of the PS/2.  But the date stamps in this &#39;rev. 1.5&#39; BIOS (as well as the code!) date it to before the Type 2 boards.</p></li>

<li><p>A <em>&#34;tradi­tional big AT style&#34;</em> planar (which I take to mean a &#39;Type 1&#39; form factor) <em>does</em> fit the time frame; but an 8 MHz CPU clock wouldn&#39;t be my first guess with that sort of thing, since even the Type 2 still limped along at 6 MHz.</p></li>
</ul>

<p>But on the other hand:</p>

<ul>
<li><p>The option to switch between 640 KB and 1 MB confi­gura­tions may be techni­cally supported in the &#39;rev. 1.5&#39; BIOS, but perhaps the mecha­nism to do this (along with the extra address decoding logic) was simply never imple­mented in the proto­type system board... or maybe there just weren&#39;t enough 256 kbit DRAM parts to go around, and all the &#34;Sky­rocket&#34; ATs ended up with a fixed 640 KB on board.</p></li>

<li><p>ROM date stamps never corre­late very well with actual availa­bility anyway, and we have to keep in mind that the 5170 had less than 3 years of official lifetime as a product. Within that period, I could easily imagine various projects going on si­mul­ta­neous­ly, with all sorts of fun bureau­cratic delays to ensure maximum con­fusion.</p></li>

<li><p>I don&#39;t see anything in the &#39;rev. 1.5&#39; BIOS code to suggest that it <em>can&#39;t</em> be an 8 MHz system. In fact nothing seems to indicate <em>any</em> parti­cular clock rate, because it&#39;s missing the CPU speed test which was added in rev. 2.  There are a few ins­tances of speed-<wbr/>depen­dent &#34;busy wait&#34; loops scat­tered through­out the code, but the counter values used for those weren&#39;t even consis­tent between the two 6 MHz BIOS editions, so they tell us very little.</p></li>
</ul>

<p>Since there&#39;s nothing to abso­lutely <em>preclude</em> this BIOS from being the &#34;Sky­rocket&#34; firmware, and the &#39;640/X&#39; business with RAM capacity sure seems to be a good match, I&#39;ll invoke Occam&#39;s trusty razor and say it&#39;s <em>probably</em> &#34;Sky­rocket&#34;... or at least something very closely related to it.</p>

<figure><a href="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/badge-mockup.jpg"><img src="https://int10h.org/blog/img/lost-ibm-at-model-bios-analysis/badge-mockup.jpg" alt="NOT an actual &#39;Skyrocket&#39; 5170 case badge"/></a>
<figcaption><b>NOT</b> an actual &#34;Skyrocket&#34; 5170 case badge</figcaption></figure>

<p>With that talk about <em>&#34;a metallic emblem shooting star logo&#34;</em> in place of the &#34;AT&#34; one, I couldn&#39;t resist making this little mock-<wbr/>up of what the Sky­rocket&#39;s case badge might have looked like.  Of course, that&#39;s probably not even close.  But this being the internet, where any form of creative license is certain to be mis­repre­sented as gospel truth sooner or later, I&#39;ll just repeat again (very slowly) that this is not the real thing.</p>

<p>Whichever 5170 variant this BIOS came from, it wasn&#39;t a released product, but it makes sense for a proto­type that made it as far as &#34;internal use&#34; at IBM: the EPROMs have part numbers (on printed labels and in the data), which seems to hint that this project got to a respec­table stage in the deve­lop­ment cycle before they canned it.</p>

<p>I&#39;m given to under­stand that Tony Ingenoso is regret­tably no longer with us, so we won&#39;t be able to verify whether the BIOS ROMs in his &#34;Sky­rocket&#34; are the same as this &#39;rev. 1.5&#39;. But maybe someone else out there will be able to shed some more light here.</p>

<p>Amusingly, it&#39;s a lucky thing that this firmware still retains rev. 1&#39;s pickiness about specific parity error types - it could have been less fussy about it (like the later revi­sions), and our only clue that there was anything funny about the RAM setup would have gone down the chute.  But it didn&#39;t, and now we can also explain that little riddle from the rev. 2 and 3 BIOS listings, where they mention the undo­cu­men­ted &#34;640/X&#34; bit: evidently someone done goofed, and simply forgot to clean up the source files.</p>

<p>&#34;Skyrocket&#34; or not, this was a diverting little game of connect-<wbr/>the-<wbr/>dots. Huge thanks go to <strong>GearTechWolf</strong> for rescuing and dumping these ROMs! <span></span></p>


		</div>
		

	</article></div>
  </body>
</html>
