<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://myme.no/posts/2023-01-22-git-commands-you-do-not-need.html">Original</a>
    <h1>Git commands you probably do not need</h1>
    
    <div id="readability-page-1" class="page"><section>
    
<p>Ah, <a href="https://git-scm.com/">git</a>! Love it, hate it. Few things are as central to the modern software
development workflow as source-control management (SCM) tools. Although there
have been and still are plenty of alternatives to <code>git</code> in the world of SCMs,
none other seem quite as prevalent both in open-source and the enterprise.</p>
<p>Regardless of how central <code>git</code> has grown to be for many (most?) software
developers, I frequently get the impression that people have a tendency to shy
away from anything beyond the relatively basic functionality it provides.</p>
<p>Since its very inception <code>git</code> has been notorious for its often unfriendly,
inconsistent and occasionally hostile command line interface:</p>
<p><img src="https://myme.no/images/git-abuse-tracked-repo.png" alt="Git man page generator" title="Git man page generator"/></p>

<p>In this post I‚Äôll present a few <code>git</code> commands and operations I run or have run
on occasion, in no particular order, that the majority of <code>git</code> users out there
might not ever need.</p>
<h2 id="the-empty-commit">The empty commit ‚àÖ</h2>
<p><code>git</code> is designed to track content and changes to that content over time, so
creating <em>empty</em> commits doesn‚Äôt sound like a very productive or sensible thing
to do. Not <em>adding</em> any content might seem like a waste.</p>
<p>Yet, I know off the top of my mind at least two occasions where creating an
empty commit can make quite a bit of sense:</p>
<ol type="1">
<li>Initializing new repositories.</li>
<li>Triggering continuous deployment pipelines.</li>
</ol>
<h3 id="initializing-a-new-repository">1. Initializing a new repository</h3>
<p>My main reason for using the <code>--allow-empty</code> flag to <code>git</code> is to create an
initial commit in a repository <em>before</em> I have any content for it.</p>
<p>Why?</p>
<p>Primary reason for me is that <code>git rebase</code> is somewhat troublesome when wanting
to rewrite the first commit of a repository. The <code>rebase</code> command centers around
working against an <code>&lt;upstream&gt;</code> commit<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>, and by definition the first commit
of a branch has no upstream. In later versions of <code>git</code> the <code>--root</code> option has
been added to remedy this, but I still like to use the opportunity to start any
new line of history with an empty commit:</p>
<pre><code>‚ùØ git commit --allow-empty -m &#34;Initial commit&#34;
‚ùØ git show --stat 592f9dd06d1013e4b5300311e6c1b7033c17ab9b
commit 592f9dd06d1013e4b5300311e6c1b7033c17ab9b
Author: Martin √òin√¶s Myrseth &lt;myrseth@gmail.com&gt;
Date:   Thu Dec 21 21:25:24 2017 +0100

    Initial commit
</code></pre>
<p>Observe that the typical <em>diff</em> of the <code>git show</code> command is missing. There was
no content in this commit.</p>
<h3 id="trigger-a-build">2. Trigger a build</h3>
<p>Depending on your continuous integration/deployment setup chances are that
automated work is scheduled based on updates to some <code>git</code> repository. Alas,
flaky network and computation resources, tests and dependency management often
come in the way of a flawless pipeline execution.</p>
<p>Creating empty <code>git</code> commits and pushing them to a PR might be all you need to
scratch that ‚Äúlet‚Äôs just try it once more, without <em>changing</em> anything‚Äù itch.</p>
<h2 id="pushing-locally">Pushing locally üí®</h2>
<p>It‚Äôs hard to use <code>git</code> for long without encountering <code>git push</code>, the <code>git</code>
sub-command for transferring (copying) stuff from your local repository to some
<em>other</em>, remote <code>git</code> repository. The format of the command I‚Äôm sure most people
are familiar with is:</p>
<pre><code>git push &lt;remote&gt;
</code></pre>
<p>Or for the more adventurous:</p>
<pre><code>git push &lt;remote&gt; &lt;refspec&gt;
</code></pre>
<p>Now what if I told you it‚Äôs possible to push a <em>remote</em> reference to your
<em>local</em> repository, effectively reversing the direction of the push operation?</p>
<pre><code>git push . origin/main:main
</code></pre>
<p>The dot (<code>.</code>) in the command above is what tells <code>git</code> that the destination
repository is the current directory. It‚Äôs equivalent to <code>./</code> or the absolute
path of the repository (i.e. <code>$(pwd)</code>).</p>
<blockquote>
<p>Why on earth would you ever want to do this? Haven‚Äôt you heard of git pull?</p>
</blockquote>
<p>Well, first off <code>git pull</code> is a combination of <em>two</em> <code>git</code> operations: <code>git
fetch</code> followed by either a <code>git merge</code> or a <code>git rebase</code> depending on user
configuration.</p>
<p>Truthfully, a <code>git fetch</code> does the opposite of a typical <code>git push</code>, which is to
update the remote-tracking branches locally, including retrieving all objects
required to complete the history of the newfound remote commits. Then ‚Äì in the
<code>git pull</code> case ‚Äì <code>git merge</code> or <code>git rebase</code> are invoked to update the
currently checked out <code>ref</code> to whichever commit is pointed to by the
remote-tracking branch defined as the ‚Äúupstream‚Äù of the current local branch
(<em>pheeew</em>).</p>
<p>The main issue with <code>git pull</code> in this scenario is the second step, as both <code>git
merge</code> and <code>git rebase</code> require the <code>ref</code> about to be updated to also be checked
out. This is because any potential conflicts must be resolved ‚Äúon the branch‚Äù.</p>
<p>In fact, in order to properly ‚Äúpush to the local repository‚Äù it‚Äôs <em>necessary</em> to
invoke a <code>git fetch</code> first to ensure that the remote tracking branches are
updated.</p>
<p>Remote-tracking branches are <code>git</code> references (<code>refs</code>) typically stored in
<code>.git/refs/remotes/&lt;remote-name&gt;/&lt;branch-name&gt;</code> which keep track of the branch
state of a remote repository. For the most part the <code>remote-name</code> and <code>branch</code>
combinations are unambiguous allowing references to remote-tracking branches to
be abbreviated like <code>origin/main</code>. These references are managed by the <code>git
fetch</code> command primarily. It‚Äôs important to be aware that <code>git</code> does <em>not</em> hit
the network to check for updates when simply referring to <code>refs</code> like
<code>origin/main</code>.</p>
<p>Let‚Äôs say that you have been working for a long-ish period of time on a feature
branch, leaving your local copy of the project‚Äôs <code>main</code> branch significantly out
of date. For whatever reason (diffing, cherry-picking, etc) you want to update
<code>main</code> with the latest upstream changes, but you don‚Äôt want to navigate <em>off</em>
your feature branch<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. One reason might be to avoid invalidating much of a
slow-running incremental build.</p>
<p>Instead of using e.g. the <code>worktree</code> functionality to create and checkout a
whole new working tree, we can use the ‚Äúpush to local‚Äù to update whichever
<em>passive</em><a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> <code>head</code> that we wish.</p>
<p><code>git</code> provides the same branch protection rules as when pushing to remote
repositories. Which is to say that it denies non-fast-forward pushes by default,
but allows overrides through <code>+&lt;commit&gt;:&lt;ref&gt;</code> refspecs, or the <code>--force</code> and
<code>--force-with-lease</code> command line options.</p>
<p>Keep in mind that using these overrides are destructive and may lead to
dataloss. Always create a backup branch with something like <code>git branch
&lt;some-temp-name&gt; &lt;branch-to-update&gt;</code> if you‚Äôre not 100% certain you‚Äôre in
control of what‚Äôs going to get pushed.</p>
<h2 id="commit-ranking">Commit ranking ü•á</h2>
<p>Perhaps in need for something to serve as the year-end bonus rounds tie-breaker?
What better way to settle the implicit battle between your peers of ‚Äúwho‚Äôs
providing most value‚Äù than by having a ‚Äúgit commit count‚Äù showdown?</p>
<blockquote>
<p>No, that‚Äôs a horrible idea ‚Ä¶</p>
</blockquote>
<p>Yes, yes it is. Any sensible developer knows that nothing good ever comes out of
placing merit in lines of code changed or number of commits committed.</p>
<p>But <em>should you</em>, God forbid, ever be in need to know (for the sake of
curiosity) who‚Äôs been committing the most to a repository, here‚Äôs <code>git rank</code>:</p>
<pre><code>git shortlog -s -n --no-merges
</code></pre>
<p>Configure it as an alias in <code>~/.config/git/config</code> with:</p>
<pre><code>[alias]
  rank = &#34;shortlog -s -n --no-merges&#34;
</code></pre>
<p>and simply run:</p>
<pre><code>git rank
</code></pre>
<p>As a quick example, behold, here‚Äôs the horrendous output from my own <code>dotfiles</code>
repository, where I‚Äôve been able to make commits under different names and
identities:</p>
<pre><code>‚ùØ git shortlog -nse
   567  Martin √òin√¶s Myrseth &lt;myrseth@gmail.com&gt;
   322  Martin √òin√¶s Myrseth &lt;mmyrseth@cisco.com&gt;
   142  Martin Myrseth &lt;mm@myme.no&gt;
    14  Martin Myrseth &lt;myrseth@gmail.com&gt;
     4  Martin √òin√¶s Myrseth &lt;mm@myme.no&gt;
     3  Martin Myrseth &lt;myme@map&gt;
     2  Martin √òin√¶s Myrseth &lt;myme@Tuple.localdomain&gt;
     2  Martin √òin√¶s Myrseth &lt;myme@map.localdomain&gt;
</code></pre>
<p>It‚Äôs painful to read, I know. Try to imagine the pain and embarrassment it is
for me to share it. And have you been unfortunate or careless enough to get
yourself into a similar situation, please read on. I‚Äôll revisit this problem in
the <a href="#filter-branch">filter branch</a> section below.</p>
<h2 id="cat-file">Cat file üêà</h2>
<p>This is more of a <code>git</code> party trick than anything to actually make much use of.
But I should say I have made use of <code>git cat-file -p</code> on a couple of occasions
to help people <em>visualize</em> and actually grok <code>git</code>‚Äôs data model.</p>
<p>As the name hints at, the <code>cat-file</code> command outputs information about <code>git</code>
objects. I‚Äôve personally only used <code>cat-file</code> with the <code>-p</code> (pretty-print) flag,
which first determines the type of the object before printing it out. Let‚Äôs
start off with inspecting the <code>HEAD</code> commit:</p>
<pre><code>$ git cat-file -p HEAD
tree 9491ada70010d722646b674d2e2a26521628df94
parent 9d7e5a6490c9f560f54fee9e1af5d72429bb26c7
author Martin Myrseth &lt;mm@myme.no&gt; 1665439490 +0200
committer Martin Myrseth &lt;mm@myme.no&gt; 1665439490 +0200

Delete Docker deploy action
</code></pre>
<p>We see the main metadata that git associates with a commit: the repository file
structure (<code>tree</code>), a parent commit <code>SHA1</code> reference, author information and
finally the commit message after a blank line. Let‚Äôs dig further by passing the
<code>SHA1</code> (<code>9491ad..94</code>) of the <code>tree</code> associated with the <code>HEAD</code> commit:</p>
<pre><code>$ git cat-file -p 9491ada70010d722646b674d2e2a26521628df94
040000 tree 6d71faa5d70085c5d07228d8fa522fb712253b6d    .github
100644 blob e09fe0dc282fdcaff06bcc6a9bbf57cbfc845eb4    .gitignore
100644 blob da7e7945524871726071f919690c9c9f6c1e173d    README.md
100644 blob e6be557357c3fe2e3cce6f1b7b9b3c9c55981a16    default.nix
040000 tree 4f69a79c432cde80b4a1c486974b03cab84b45b9    docker
100644 blob 2f8aacd9efa3cfdf9e5f2860fa7226b510ed83bc    feed-cors.conf
100644 blob 14b9e2dd0a41aa932c1f4bb5938519547f37f82c    flake.lock
100644 blob eeae336837db94ca62255a7e5fa7f32ae3363716    flake.nix
100644 blob f1f8ef836b3b9b9ea011a43972a28ffaa713c868    image.nix
040000 tree 5cad033d973f19ece938c33c3bb912eb63dc3305    site
040000 tree 49dc35d8e519f02f6f1a647f437226af198d225a    ssg
100644 blob 60dede4bba8cd9479b0bec49048da1397e14f352    todo.org
</code></pre>
<p>The result of printing a <code>tree</code> is what looks like a directory listing of the
contents of that ‚Äútree‚Äù directory. Each directory entry is represented as some
mode bits, an object type, the <code>SHA1</code> of the object and the name of the entry.
Trees may contain other <code>tree</code> objects to create a directory structure, or
<code>blob</code> objects which contain file contents.</p>
<p>Finally, let‚Äôs inspect one of the <code>blob</code> in the output, like <code>.gitignore</code>
(<code>e09fe0..b4</code>):</p>
<pre><code>$ git cat-file -p e09fe0dc282fdcaff06bcc6a9bbf57cbfc845eb4
.stack-work
_cache
public
dist-newstyle
.ghc.environment.*

# nix-build
result
</code></pre>
<p>Which prints out the actual content of <code>.gitignore</code> the way it was committed
into the current <code>HEAD</code> commit.</p>
<blockquote>
<p>Wait? What? So everything is just <em>text</em> files?</p>
</blockquote>
<p>Conceptually, yes. However, modern <code>git</code> does a lot more to optimize storage
(re)usage and whatnot to ensure that a repository stays as small as possible.
There are other, scarier objects lurking under <code>.git/objects</code> in a <code>git</code>
repository.</p>
<h3 id="the-git-parable">The git parable</h3>
<p>As I said in the beginning of this section, I‚Äôve used <code>cat-file</code> to help myself
and others understand the <code>git</code> object model. Learning all the details of that
model isn‚Äôt the purpose of this section (or post) though. However, if reading
this ignited some form of curiosity on your part I would gladly recommend the
talk ‚ÄúThe Git Parable‚Äù which dives deeper into the <code>git</code> object model, as
presented by my good friend <a href="https://herland.net/">Johan Herland</a>:</p>
<p>
  <iframe width="1279" height="721" src="https://www.youtube.com/embed/ANNboouhNHE" title="The Git Parable: a different approach to understanding Git" frameborder="3" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="">
  </iframe>
</p>

<h3 id="use-case">Use case</h3>
<p>Now, why would you want to use <code>cat-file</code>? (Except you wouldn‚Äôt, but let‚Äôs just
play along here)</p>
<p>I was deep into some refactoring and clean-up of a set of template files used
for various messages sent out from a system. Each template directory would
contain a set of files for each message template. I‚Äôve been working with the
files for a while when a feeling grew on me that several of these templates
seemed to be fairly similar, identical in fact.</p>
<p>At this point I had already been making some work-in-progress commits, which
would definitely get in the way for any attempt at checking if there were
identical template directories in my working copy. I wanted to compare the
contents of the template directories at the point <em>before</em> I started making my
changes.</p>
<p>The primary tool for checking differences to files in <code>git</code> is obviously the
<code>git diff</code> command. It can easily check the differences between files stored in
the <code>git</code> history. Typical usage of <code>diff</code> is to compare a <em>single</em> path across
various versions. However, looking closer at it‚Äôs synopsis we can see that there
are a couple of call signatures that might do somewhat what we need:</p>
<pre><code>NAME
       git-diff - Show changes between commits, commit and working tree, etc

SYNOPSIS
       git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;...]
       git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;...]
       git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [&lt;commit&gt;...] &lt;commit&gt; [--] [&lt;path&gt;...]
       git diff [&lt;options&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;path&gt;...]
       git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;
       git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;
</code></pre>
<p>Primarily <code>git diff &lt;blob&gt; &lt;blob&gt;</code> which would let us compare any two <code>git</code> blob
objects. There‚Äôs also a note under ‚ÄúDESCRIPTION‚Äù which states:</p>
<blockquote>
<p>Just in case you are doing something exotic, it should be noted that all of the
<code>&lt;commit&gt;</code> in the above description, except in the <code>--merge-base</code> case and in
the last two forms that use <code>..</code> notations, can be any <code>&lt;tree&gt;</code>.</p>
</blockquote>
<p>Which means that also <code>git diff &lt;blob&gt; &lt;blob&gt;</code> should do something along the
lines that we want. And surely, doing something similar to the following yielded
an empty diff (where <code>HEAD~3</code> is the commit I based my work on):</p>
<pre><code>‚ùØ git diff HEAD~3:some/templates/path/ HEAD~3:some/templates/other-path/
</code></pre>
<p>The manual page for <code>git-diff</code> states that it takes two <em>blobs</em>, but it‚Äôs just
as valid with any tree-like object, often called <code>tree-ish</code> in the <code>git</code>
documentation.</p>
<p>So I had found one pair of templates that were identical, and which could be
coalesced into one. But what if there were more? Using <code>git diff</code> alone I would
have had to compare all permutations of template directories to see if the
results were empty.</p>
<p>No time for that‚Ä¶</p>
<p>Instead we can use <code>cat-file</code> to simply dump all the hashes of every sub
<code>&lt;tree&gt;</code>. Then we can use a familiar shell pipeline to group the hashes and
count them:</p>
<pre><code>‚ùØ git cat-file -p HEAD~3:some/templates/ \
  | awk &#39;{ print $3; }&#39; \
  | sort \
  | uniq -c \
  | sort -rn
      2 af83bb357f2b8dc42f6c9f07620140590dc7fd44
      2 228182da5a0ffcf4c0d263bfa54852176f0250d2
      1 ef1a471185c2092e6708349fa710702dd416f892
      1 e453cb9d3dddbdd46a65c811068352ac40941fcd
      1 e3df1181dae478172a7ae6bbc1618a3af2151db4
      1 de0f6cd53ea97cb100a74c812f75c0d4844c0efa
      1 d7f239da6283c927dad650599d49639ddc761465
      1 d7d8f5aa3571ea2392028e353ad958d778d2bee0
      1 cc03005d684b5735da337a6e5ca9765751943d7d
      ... # A bunch more
</code></pre>
<p>Et voil√†! We clearly see that there are not just one pair of duplicate
templates, but two!</p>
<p>I should note that this approach is brittle in the sense that should there be
<em>any</em> difference to the blobs <em>at all</em> this method falls apart. In my case it
worked perfectly, but your mileage might vary. In my experience there are often
several ways to do the ‚Äúsame thing‚Äù using <code>git</code>, so it would be nice to hear of
other approaches.</p>
<h2 id="orphan-commits">Orphan commits ü§∑</h2>
<p>Every commit in a <code>git</code> repository has a reference to its parent, which is the
commit that chronologically came immediately <em>before</em> the commit. For merge
commits the number of parents are greater than one.</p>
<p>Well, that‚Äôs not 100% accurate. As discussed in <a href="#the-empty-commit">the empty commit</a> the initial
commit of a branch is somewhat special: it has no parents. Commits without any
reference to a parent is called an ‚Äúorphan‚Äù commit. In most repos there would
only be one such commit, the initial commit.</p>
<p>However, <code>git</code> is by no means limited to a single orphan commit. The default
behavior when creating a new branch is that the new branch is based on some
<code>start-point</code>. Using <code>git checkout --orphan</code> (or the <em>currently</em> unstable <code>git
switch --orphan</code>) it‚Äôs possible to start off a completely new and independent
line of history totally disconnected from the rest of the repository.</p>
<p>The main use-case I‚Äôve had for <code>git</code>‚Äôs support of this functionality is not to
start ‚Äúorphaned‚Äù histories, but rather <em>absorb</em> the history of a branch from
another, unrelated repository. It‚Äôs very useful when coalescing many smaller
repositories into a monorepo or when vendorizing some library.</p>
<h3 id="merging-histories">Merging histories</h3>
<p>As a synthetic case-study let‚Äôs import the <code>doomemacs</code> history into my
<code>dotfiles</code> repo!</p>
<p>First let‚Äôs create a new <code>worktree</code> so that we don‚Äôt mess up my <em>actual</em> files:</p>
<pre><code>‚ùØ git worktree add ~/code/doomfiles doomfiles
Preparing worktree (checking out &#39;doomfiles&#39;)
HEAD is now at a0b32f8 machine: deque: Setup nginx with rtcp.myme.no
‚ùØ cd ~/code/doomfiles
</code></pre>
<p>Doing a <code>git log</code> of the most recent commits we can see that they‚Äôre all mine:</p>
<pre><code>‚ùØ git log --oneline --graph -5
* 0f1f6cd machine: map: Enable podman
* 46099b9 emacs: Add React fn-component snippet
* 2e75458 ssh: Update hosts
* 445ade4 machine: deque: Set SSH port
* bf0a552 flake: Add utils as &#34;apps&#34;
</code></pre>
<p>Another ‚Äúlittle known‚Äù feature of <code>git</code> is that it‚Äôs trivial to fetch ‚Äúa random‚Äù
upstream repository without adding an explicit <code>git remote</code>. This can be quite
useful when e.g. checking out some incoming one-off contribution. Just pass the
remote url to <code>fetch</code> directly:</p>
<pre><code>‚ùØ git fetch git@github.com:doomemacs/doomemacs
remote: Enumerating objects: 118606, done.
remote: Counting objects: 100% (20/20), done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 118606 (delta 4), reused 15 (delta 3), pack-reused 118586
Receiving objects: 100% (118606/118606), 26.98 MiB | 6.80 MiB/s, done.
Resolving deltas: 100% (82950/82950), done.
From github.com:doomemacs/doomemacs
 * branch                HEAD       -&gt; FETCH_HEAD
</code></pre>
<p>As the output states, the result of the fetch is placed in the special <code>git</code> ref
<code>FETCH_HEAD</code>. We can use this ref to refer to the <code>doomemacs</code> commit that was
fetched when we wish to merge the histories.</p>
<p>Now, <code>git</code> won‚Äôt let us merge without warning us first:</p>
<pre><code>‚ùØ git merge FETCH_HEAD
fatal: refusing to merge unrelated histories
</code></pre>
<p>Easily enough we can add the <code>--allow-unrelated-histories</code> telling <code>git</code> we‚Äôre
being quite serious right here:</p>
<pre><code>‚ùØ git merge --allow-unrelated-histories FETCH_HEAD
Auto-merging .gitignore
CONFLICT (add/add): Merge conflict in .gitignore
Auto-merging README.md
CONFLICT (add/add): Merge conflict in README.md
Recorded preimage for &#39;.gitignore&#39;
Recorded preimage for &#39;README.md&#39;
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p><em>Pfffft</em>, conflicts ‚Ä¶ Let‚Äôs get on with our lives by simply resetting the conflicting files to the imported versions <code>#yolo</code>.</p>
<pre><code>‚ùØ git checkout --theirs -- .gitignore README.md
‚ùØ git add .gitignore README.md
‚ùØ git commit -m &#39;Pulling in Doom Emacs!&#39;
Recorded resolution for &#39;.gitignore&#39;.
Recorded resolution for &#39;README.md&#39;.
[doomfiles 11826ae12] Pulling in Doom Emacs!
</code></pre>
<p>And that‚Äôs about it! Let‚Äôs inspect the result:</p>
<pre><code>‚ùØ git show
commit 11826ae125834cc4e2263172275d8c51bca11d63 (HEAD -&gt; doomfiles)
Merge: a0b32f85f e96624926
Author: Martin Myrseth &lt;mm@myme.no&gt;
Date:   Thu Jan 19 01:13:17 2023 +0100

    Pulling in Doom Emacs!
</code></pre>
<p>We can see that the commit is a merge commit, where one parent is <a href="https://github.com/myme/dotfiles/commit/a0b32f85fd07eaa09fcb2bc06b695b7a067a43aa">a0b32f85f</a> from
my <code>dotfiles</code> while the other parent <a href="https://github.com/doomemacs/doomemacs/commit/e96624926d724aff98e862221422cd7124a99c19">e96624926</a> is the current<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> <code>HEAD</code> from the
<code>doomemacs</code> repo.</p>
<p>We have successfully merged the histories of my <code>dotfiles</code> repository with Doom
Emacs!</p>
<p>As stated previously, this can be quite useful when pulling in e.g. an
experimental repository, vendorizing some dependency or similarly constructing a
monorepo from separate smaller repositories.</p>
<p>The next section is about one (of several) times I‚Äôve found this useful myself.</p>
<h3 id="dotfiles-bankruptcy">Dotfiles bankruptcy</h3>
<p>I agree that the previous example of absorbing <code>Doom Emacs</code> into my <code>dotfiles</code> is kind of silly, but it illustrates <em>possibilities</em>.</p>
<p>Stepping away from synthetic examples I also would like to show one of a few
occasions where I‚Äôve made use of it to solve a real-world use-case.</p>
<p>Let‚Äôs step back into my <code>dotfiles</code>.</p>
<p>With our new knowledge about orphan commits we may wonder if there is a way to easily query for them in a <code>git</code> repository. And there sure is:</p>
<pre><code>‚ùØ git log --all --max-parents=0
commit 6fa853118711f557a911b98f00d5c4a2eb3ded71
Author: Martin Myrseth &lt;mm@myme.no&gt;
Date:   Mon Jan 17 21:44:43 2022 +0000

    nixos: Initial commit

commit 61a3f80babec8c1339391462590dafe7ff30fe7f
Author: Martin Myrseth &lt;mm@myme.no&gt;
Date:   Wed Feb 10 11:59:23 2016 +0100

    Inital import of tuple
</code></pre>
<p>There is not one, but <em>two</em> commits in the <code>dotfiles</code> repository which doesn‚Äôt
have any parents.</p>
<ol type="1">
<li>The <em>real</em> ‚Äú<a href="https://github.com/myme/dotfiles/commit/61a3f80babec8c1339391462590dafe7ff30fe7f">Initial import</a>‚Äù created at the beginning of time<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</li>
<li>The much more recent ‚Äú<a href="https://github.com/myme/dotfiles/commit/6fa853118711f557a911b98f00d5c4a2eb3ded71">nixos: Initial commit</a>‚Äù.</li>
</ol>
<p>The second commit was the beginning of my attempt to move my machine
configurations towards a fully <code>NixOS</code> managed declarative setup built on top of
<code>flakes</code>. I‚Äôve already covered this journey in <a href="https://myme.no/posts/2022-06-14-nixos-confederation.html">another post</a> which also links to
the state of my configuration management <em>before</em> that migration.</p>
<p>In any case, when starting my configuration rewrite I wasn‚Äôt yet sure if I would
want a clean slate or eventually port it into my <code>dotfiles</code>. In the end I
figured I could have both, by simply pulling in the experiment into my already
existing history.</p>
<p>Eventually my experiment had matured to the point where I was convinced I had
what I wanted. It was time to import it into the <code>dotfiles</code> repository.
Following pretty much the same steps as in the previous section I ended up with
the following <a href="https://github.com/myme/dotfiles/commit/79977b007099390a53e11f540e178f6285137206">merge commit</a>:</p>
<pre><code>‚ùØ git show 79977b007099390a53e11f540e178f6285137206
commit 79977b007099390a53e11f540e178f6285137206
Merge: ad28da4 841eec3
Author: Martin Myrseth &lt;mm@myme.no&gt;
Date:   Wed Feb 2 00:19:24 2022 +0100

    nixos: Declare dotfile bankruptcy
</code></pre>
<div>
<p>I remember reading an email thread on the <code>git</code> mailing list in the early days
of <code>git</code> where Linus Torvalds boasted performing this ‚Äúabsorption‚Äù operation in
order to pull in some unrelated history.</p>
<p>And equally interesting I remember reading an analysis which touched on how many
orphan commits there are in the <code>Linux</code> main tree. I remember there being four,
one in particular seemed like a ‚Äúcareless‚Äù unintentional mistake.</p>
<p>Edit 2023-01-23:</p>
<p>Initially I didn‚Äôt spend enough effort trying to find these two sources, but
both through help from readers and some more search-fu vigilance I was able to
find what I was referring to:</p>
<ol type="1">
<li><p>From <a href="https://lore.kernel.org/">lore.kernel.org</a>: Behold, <a href="https://lore.kernel.org/all/Pine.LNX.4.58.0506221433540.2353@ppc970.osdl.org/T/">The coolest merge EVER!</a></p></li>
<li><p>Thanks to a reader I was directed towards exactly the post I was after that
researched ‚Äúweird‚Äù <code>Linux</code> commits (from <a href="https://www.destroyallsoftware.com/">Destroy All Software)</a>:</p>
<p><a href="https://www.destroyallsoftware.com/blog/2017/the-biggest-and-weirdest-commits-in-linux-kernel-git-history">‚ÄúThe Biggest and Weirdest Commits in Linux Kernel Git History‚Äù</a> goes through
both octopus merges and orphaned commits in the history <code>Linux</code>.</p></li>
</ol>
</div>
<h2 id="filter-branch">Filter branch üåø</h2>
<p>The <code>git filter-branch</code> command has got WARNING written all over it. Please
proceed with caution. This section illuminates usage of <code>filter-branch</code> to fix a
particular problem. As the section goes on to explain, there are better, less
destructive ways to resolve these problems.</p>
<p>I tend to work in a number of <code>git</code> repositories across various machines. I also
split work between my personal projects and anything related to <code>$DAYJOB</code>. I do
not want to taint the <code>git</code> history in work repositories with <em>personal</em> email
addresses and other ‚Äúunprofessionalism‚Äù.</p>
<p>Turns out I <em>do</em> though. Remember the painful output from <a href="#commit-ranking">commit ranking</a>?</p>
<p><img src="https://myme.no/images/git-email-messup.png" alt="A shameful git log view with localdomain author email addresses" title="A shameful git log view with localdomain author email addresses"/></p>
<p>Oh, the embarrassment! It‚Äôs unbearable!</p>
<p>This example <del>is</del> was from <a href="https://github.com/myme/dotfiles">my dotfiles</a> history before I cleaned it up. I
occasionally setup new machines, and my <code>dotfiles</code> repo is the first thing I
pull in after the machine boots. Every host typically needs some form of
tweaking, and not realizing I haven‚Äôt setup my <code>git</code> configurations correctly, I
start patching and committing configurations for the new host.</p>
<p>Next thing I know I‚Äôve completely missed the fact that I‚Äôve been committing with
all kinds of ad-hoc <code>user</code> settings inferred from <code>git</code> without letting me know.</p>
<p>I‚Äôve been aware of this potential issue for a long time, and have proactively
tried to mitigate it using various strategies on several occasions in the past.
Sometimes bad commits manage to slip through though. With a stricter focus on a
holistic <code>nix flakes</code> host setup, I hope I‚Äôm rid this issue of partial
(mis)configuration once and for all.</p>
<h3 id="the-filter-branch-cleanup">The filter-branch cleanup</h3>
<p>Most people familiar with rewriting <code>git</code> history know about <code>git rebase</code> and
<code>git rebase --interactive</code>, which allow operations like ‚Äúmoving‚Äù (or replaying)
commits onto new parents, rewriting commit messages, re-assigning author
information, as well as making changes to the source tree.</p>
<p>Perhaps less familiar to people is the <code>git filter-branch</code> command, which is
sort of the <em>hydrogen bomb</em> of history rewriting. I urge you to heed the glaring warning
that meets you in <code>man git-filter-branch(1)</code> and perhaps consider alternative
solutions like <a href="https://github.com/newren/git-filter-repo/">git-filter-repo</a>:</p>
<pre><code>WARNING
       git filter-branch has a plethora of pitfalls that can produce non-obvious
       manglings of the intended history rewrite (and can leave you with little
       time to investigate such problems since it has such abysmal performance).
       These safety and performance issues cannot be backward compatibly fixed
       and as such, its use is not recommended. Please use an alternative
       history filtering tool such as git filter-repo. If you still need to use
       git filter-branch, please carefully read the section called ‚ÄúSAFETY‚Äù (and
       the section called ‚ÄúPERFORMANCE‚Äù) to learn about the land mines of
       filter-branch, and then vigilantly avoid as many of the hazards listed
       there as reasonably possible.
</code></pre>
<p>Warning aside, a few factors lead me to believe this was what I wanted in this particular scenario:</p>
<ol type="1">
<li>All the faulty commits were fairly recent, I wouldn‚Äôt touch very old history.</li>
<li>I‚Äôve had experience running <code>filter-branch</code> from way back and felt confident
choosing it again.</li>
<li>The manpage has the exact use-case exemplified.</li>
</ol>
<p>With a few modifications from <a href="https://stackoverflow.com/a/750182">this Stack Overflow answer</a>:</p>
<pre><code>‚ùØ git filter-branch --env-filter &#39;
WRONG_EMAIL=&#34;martin@machine.localdomain&#34;
NEW_NAME=&#34;Martin Myrseth&#34;
NEW_EMAIL=&#34;martin@example.com&#34;

if [ &#34;$GIT_COMMITTER_EMAIL&#34; = &#34;$WRONG_EMAIL&#34; ]
then
    export GIT_COMMITTER_NAME=&#34;$NEW_NAME&#34;
    export GIT_COMMITTER_EMAIL=&#34;$NEW_EMAIL&#34;
fi
if [ &#34;$GIT_AUTHOR_EMAIL&#34; = &#34;$WRONG_EMAIL&#34; ]
then
    export GIT_AUTHOR_NAME=&#34;$NEW_NAME&#34;
    export GIT_AUTHOR_EMAIL=&#34;$NEW_EMAIL&#34;
fi
&#39; --tag-name-filter cat -- --branches --tags
</code></pre>
<p>I do not have the output of this command ready at hand. It‚Äôs a while since I ran
it, and I do not intending to do it again any time soon. All I can say is it
worked out nicely for me.</p>
<p>I don‚Äôt think there‚Äôs much reason to invest a whole lot of effort into
understanding all the ins and outs of <code>filter-branch</code>. There are most likely
always better options to solve the problems it too can solve, so try your best
to avoid it.</p>
<p>Following are some other workarounds to avoid committing with a broken <code>user</code>
configuration or ensuring that faults are at least concealed in command outputs.</p>
<h3 id="git-templates-and-pre-commit-hooks">Git templates and pre-commit hooks</h3>
<p>Before all of the other mitigations outlined in the sections below I used to
have a <code>.gittemplates</code> folder containing a few <code>git hooks</code> that would be added
to every newly created repository. One of these hooks was the <a href="https://github.com/myme/dotfiles/blob/cee48efdbfc34f2cf156234501e88337583b852c/git/.gittemplate/hooks/pre-commit">pre-commit hook</a>
which checked that I had a properly configured <code>user.name</code> and <code>user.email</code>.</p>
<div id="cb26" data-org-language="sh"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>#!/usr/bin/env bash</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>!</span><span>(</span><span>git</span> config user.name <span>&amp;&gt;</span> /dev/null <span>&amp;&amp;</span> <span>git</span> config user.email <span>&amp;&gt;</span> /dev/null<span>);</span> <span>then</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span>echo</span> <span>&#34;Please setup your repository with a user.name and user.email&#34;</span> <span>&gt;&amp;</span><span>2</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span>exit</span> 1</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span>fi</span></span></code></pre></div>
<p>If I ever forgot to properly setup particularly the <code>user.email</code> for a specific
repository then <code>git</code> wouldn‚Äôt let me commit without annoying me with a warning.
Since I rarely change my name (I haven‚Äôt yet), I would hardcode <code>user.name</code> into
my user-global git configuration.</p>
<p>Due to the chicken-and-egg problem, these hooks weren‚Äôt created for my
<code>dotfiles</code> repo on new hosts because they‚Äôre <em>in</em> the <code>dotfiles</code> repo. It‚Äôs a
while since I abandoned this approach alltogether as it‚Äôs obsoleted by the
solution of the next section.</p>
<p>Keep in mind this was added a while ago, and before I‚Äôd learned about the
superior means of working around this problem which I‚Äôll get to below. This
solution is most likely not what you want.</p>
<h3 id="no-second-guessing-please">No second guessing please!</h3>
<p>One of the <code>git</code> defaults I‚Äôm not very fond of is the <code>user.useConfigOnly</code>
configuration which is <code>false</code> by default. Here‚Äôs its excerpt from <code>man
git-config(1)</code>:</p>
<pre><code>user.useConfigOnly
    Instruct Git to avoid trying to guess defaults for user.email and user.name,
    and instead retrieve the values only from the configuration. For example, if
    you have multiple email addresses and would like to use a different one for
    each repository, then with this configuration option set to true in the
    global config along with a name, Git will prompt you to set up an email
    before making new commits in a newly cloned repository. Defaults to false.
</code></pre>
<p>I guess the documentation outlines my ‚Äúdefault‚Äù use-case, which is to use
different email addresses for the repository I work in. With the following
configuration <code>git</code> will refuse to commit when <code>user</code> configuration is missing,
thus obsoleting my <code>pre-commit</code> hook:</p>
<pre><code>[user]
  name = &#34;Martin Myrseth&#34;
  useConfigOnly = true
</code></pre>
<h3 id="git-conditional-configuration">Git conditional configuration</h3>
<p>It‚Äôs hard to argue against the fact that the <em>best</em> way to solve <em>any</em> problem,
is to not have the problem in the first place. Using some ‚Äúclever‚Äù conditional
configuration sections it‚Äôs possible to include additional configurations for
e.g. repositories within specific sub-directories on the filesystem, ensuring
that there never <em>is</em> a partial <code>user</code> configuration.</p>
<p>Once I became aware of this configuration trick I took more care as to where I
placed repositories on disk. Making sure to have separate directories for
personal and work related repos. With this repository directory layout, it‚Äôs
possible to have a conditional section in <code>gitconfig</code> which applies additional
configurations to any repository matching the predicate (i.e. placement on
disk):</p>
<pre><code>[includeIf &#34;gitdir:~/code/work/&#34;]
    path = &#34;./work_config&#34;
</code></pre>
<p>Any repository under <code>~/code/work</code> will include the configuration from
<code>./work_config</code>, which may contain something like the following:</p>
<pre><code>[commit]
    gpgSign = true
[tag]
    forceAnnotated = true
    gpgSign = true
[user]
    email = &#34;martin@day.job&#34;
    signingKey = &#34;martin@day.job&#34;
</code></pre>
<h3 id="mailmap">.mailmap</h3>
<p>Although the <code>filter-branch</code> command allows a full cleanup of the history of a
<code>git</code> repository, it shouldn‚Äôt be understated the potential damage and
<em>inconvenience</em> such an operation has on the repository integrity. Rewriting
history has the viral effect of changing <code>SHA1</code> sums of all subsequent commits,
leading to parallel histories (old vs. new). This is most likely not what you
want for public histories.</p>
<p>On the other end of the spectrum <code>git</code> provides a rather convenient and
non-destructive feature to solve this particular issue through its <code>mailmap</code>
support. Quoting the <code>man gitmailmap</code>:</p>
<blockquote>
<p>If the file <code>.mailmap</code> exists at the toplevel of the repository ‚Ä¶ it is used
to map author and committer names and email addresses to canonical real names
and email addresses.</p>
</blockquote>
<p>The man page of <code>gitmailmap</code> contains syntactical examples of mailmap entries.
To correct a simple incorrect email one can add an entry on the format:</p>
<pre><code>&lt;proper@email.xx&gt; &lt;commit@email.xx&gt;
</code></pre>
<p>The <code>.mailmap</code> can also correct <code>user.name</code> issues as well as correct <em>specific</em>
commits and so on. Here‚Äôs the <a href="https://github.com/myme/dotfiles/blob/0736ab8da3312418750961c9eaa75d34da7bbada/.mailmap">.mailmap</a> file from my <code>dotfiles</code> which fixes up a
few of my past mistakes:</p>
<pre><code>Martin Myrseth &lt;mm@myme.no&gt; &lt;mm@myme.no&gt;
Martin Myrseth &lt;mm@myme.no&gt; &lt;myrseth@gmail.com&gt;
Martin Myrseth &lt;mm@myme.no&gt; &lt;mmyrseth@cisco.com&gt;
Martin Myrseth &lt;mm@myme.no&gt; &lt;myme@Tuple.localdomain&gt;
Martin Myrseth &lt;mm@myme.no&gt; &lt;myme@map.localdomain&gt;
</code></pre>
<h2 id="octopus-merge">Octopus merge üêô</h2>
<p>I must admit, I never use this, but I remember being amazed the first time I learned about the many-parent merge ability of <code>git</code> long ago.</p>
<p>I would assume most people live their life thinking a merge commit is just the
combined result of <em>two</em> somewhat related histories. Ideally two histories that
forked off one another in (hopefully) the not too distant past.</p>
<p>Yet, we‚Äôve already seen and debunked the fact that histories have to be
‚Äúsomewhat related‚Äù in order to be merged. That‚Äôs what the ‚Äúabsorb some other
repository‚Äù functionality covered in the <a href="#orphan-commits">orphan commits</a> section was all about.</p>
<p>I guess then it comes as no surprise that the assumption of merges only ever
having just two parents is <em>also</em> not a hard limitation.</p>
<h3 id="tentacles">Tentacles</h3>
<p>Let‚Äôs see how we can create a many-parent merge commit, called an ‚Äúoctopus
merge‚Äù, by starting off a new repository and adding a bunch of branches to it:</p>
<pre><code>‚ùØ mkdir octopus
‚ùØ cd octopus/
‚ùØ git init
Initialized empty Git repository in /home/myme/tmp/octopus/.git/

‚ùØ git commit --allow-empty -m &#39;Initial commit&#39;
Author identity unknown

*** Please tell me who you are.

Run

  git config --global user.email &#34;you@example.com&#34;
  ...
</code></pre>
<p>Ah ‚Ä¶ right. Forgot about that ü§¶</p>
<pre><code>‚ùØ git config user.email &#39;dave@tentacle.org&#39;
‚ùØ git commit --allow-empty -m &#39;Initial commit&#39;
[main (root-commit) 9ff0a71] Initial commit
</code></pre>
<p>At this point we have a new <code>git</code> repository with a single <code>main</code> branch containing a single <em>empty</em> commit:</p>
<pre><code>‚ùØ git log --all --oneline --graph
* 9ff0a71 (HEAD -&gt; main) Initial commit
</code></pre>
<p>Let‚Äôs create some branches with content:</p>
<pre><code>‚ùØ git checkout -b tentacle
Switched to a new branch &#39;tentacle&#39;
‚ùØ date &gt; tentacle.txt
‚ùØ git add tentacle.txt
‚ùØ git commit -m &#39;Add day of tentacle.txt&#39;
[tentacle 4dadc16] Add day of tentacle.txt
 1 file changed, 1 insertion(+)
 create mode 100644 tentacle.txt

</code></pre>
<p>Yay, one limb (aka branch) in place!</p>
<pre><code>‚ùØ git log --all --oneline --graph
* 4dadc16 (HEAD -&gt; tentacle) Add day of tentacle.txt
* 9ff0a71 (main) Initial commit
</code></pre>
<p>But creating limbs is tedious. Let‚Äôs push the fast-forward button:</p>
<div id="cb38"><pre><code><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span>for</span> count <span>in</span> nine eight seven six five four three two one<span>;</span> <span>do</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span>limb</span><span>=</span><span>&#34;</span><span>${count}</span><span>tacle&#34;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span>git</span> checkout <span>-b</span> <span>&#34;</span><span>$limb</span><span>&#34;</span> main</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span>date</span> <span>&gt;</span> <span>&#34;</span><span>${limb}</span><span>.txt&#34;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span>git</span> add <span>&#34;</span><span>${limb}</span><span>.txt&#34;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span>git</span> commit <span>-m</span> <span>&#34;Add </span><span>${limb}</span><span>&#34;</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span>done</span></span></code></pre></div>
<pre><code>Switched to a new branch &#39;ninetacle&#39;
[ninetacle 3f7a95e] Add ninetacle
 1 file changed, 1 insertion(+)
 create mode 100644 ninetacle.txt
Switched to a new branch &#39;eighttacle&#39;
[eighttacle e9cd39a] Add eighttacle
 1 file changed, 1 insertion(+)
 create mode 100644 eighttacle.txt
Switched to a new branch &#39;seventacle&#39;
...
Switched to a new branch &#39;sixtacle&#39;
...
Switched to a new branch &#39;fivetacle&#39;
...
Switched to a new branch &#39;fourtacle&#39;
...
Switched to a new branch &#39;threetacle&#39;
...
Switched to a new branch &#39;twotacle&#39;
...
Switched to a new branch &#39;onetacle&#39;
[onetacle c78c58a] Add onetacle
 1 file changed, 1 insertion(+)
 create mode 100644 onetacle.txt
</code></pre>
<p>And we got ourselves a bunch of limbs!</p>
<pre><code>‚ùØ git log --all --oneline --graph
* e9cd39a (eighttacle) Add eighttacle
| * e310cbc (fivetacle) Add fivetacle
|/
| * 44ad755 (fourtacle) Add fourtacle
|/
| * 3f7a95e (ninetacle) Add ninetacle
|/
| * c78c58a (HEAD -&gt; onetacle) Add onetacle
|/
| * 6be7cf4 (seventacle) Add seventacle
|/
| * a54e5c1 (sixtacle) Add sixtacle
|/
| * 3b1a5da (threetacle) Add threetacle
|/
| * bb79112 (twotacle) Add twotacle
|/
| * 4dadc16 (tentacle) Add day of tentacle.txt
|/
* 9ff0a71 (main) Initial commit
</code></pre>
<p>Time to assemble our squid:</p>
<pre><code>‚ùØ git merge tentacle ninetacle eighttacle seventacle sixtacle fivetacle fourtacle threetacle twotacle onetacle -m &#39;Assemble squid&#39;
Fast-forwarding to: tentacle
Trying simple merge with ninetacle
Trying simple merge with eighttacle
Trying simple merge with seventacle
Trying simple merge with sixtacle
Trying simple merge with fivetacle
Trying simple merge with fourtacle
Trying simple merge with threetacle
Trying simple merge with twotacle
Trying simple merge with onetacle
Merge made by the &#39;octopus&#39; strategy.
 eighttacle.txt | 1 +
 fivetacle.txt  | 1 +
 fourtacle.txt  | 1 +
 ninetacle.txt  | 1 +
 onetacle.txt   | 1 +
 seventacle.txt | 1 +
 sixtacle.txt   | 1 +
 tentacle.txt   | 1 +
 threetacle.txt | 1 +
 twotacle.txt   | 1 +
 10 files changed, 10 insertions(+)
 create mode 100644 eighttacle.txt
 create mode 100644 fivetacle.txt
 create mode 100644 fourtacle.txt
 create mode 100644 ninetacle.txt
 create mode 100644 onetacle.txt
 create mode 100644 seventacle.txt
 create mode 100644 sixtacle.txt
 create mode 100644 tentacle.txt
 create mode 100644 threetacle.txt
 create mode 100644 twotacle.txt
</code></pre>
<p>The end result is the most wonderful <code>git</code> graph ever!</p>
<p><img src="https://myme.no/images/git-octopus-merge.png"/></p>
<p>We‚Äôve managed to create a new commit in our repository with no less than <em>ten</em>
parents. We can also confirm this using <code>git show</code>:</p>
<pre><code>‚ùØ git show
commit 442b9a2852fc2707517690f1a994c1c5a38ac20b (HEAD -&gt; main)
Merge: 4dadc16 3f7a95e e9cd39a 6be7cf4 a54e5c1 e310cbc 44ad755 3b1a5da bb79112 c78c58a
Author: Martin Myrseth &lt;dave@tentacle.org&gt;
Date:   Fri Jan 20 01:09:57 2023 +0100

    Assemble squid
</code></pre>
<p>Note the <code>Merge:</code> line with all the parent <code>SHA1</code> sums. Also notice how <code>git
show</code> deviates from the more ‚Äúvanilla‚Äù <code>cat-file -p</code> output by renaming each of the
metadata labels.</p>
<h3 id="use-cases">Use-cases</h3>
<p>Honestly, in practice I haven‚Äôt found a single valid use-case for octopus merges
which aren‚Äôt already covered by sequencing a series of merges, one after the
other. Perhaps there are some integration use-cases out there which really let‚Äôs
the octopus merge strategy shine. Let me know!</p>
<p>I should also note that the octopus merge strategy is quite conservative and
bluntly refuses to merge anything which doesn‚Äôt trivially apply without
conflicts. I imaging trying to juggle changes and their origins during a merge
resolution to be quite the mess.</p>
<p>One thing I like though about the octopus merge is that it quite visually shows
how simple the <code>git</code> graph model really is. It has helped me build intuition
about what goes on during a merge operation in <code>git</code>.</p>
<h3 id="the-dishonest-merge">The dishonest merge ü§û</h3>
<p>While on the topic of merges, I‚Äôd like to quickly break down some of the
misconception(?) that merge commits are something special in <code>git</code>.</p>
<p>It might be true that there‚Äôs some special sauce involving <code>merge-bases</code> and
heuristics in order to determine the merge <em>result</em> of joining multiple
histories. But once a commit with multiple parents have been made there‚Äôs no
requirement that whichever <code>tree</code> is associated with a merge commit to make any
kind of sense with regards to the merge operation its parent relationship
reflects.</p>
<p>Let‚Äôs continue from where the octopus merge left off and see that we‚Äôve got all
ten *tacles in place:</p>
<pre><code>‚ùØ ls -la
total 52
drwxr-xr-x 3 myme users 4096 Jan 20 01:09 .
drwxr-xr-x 7 myme users 4096 Jan 20 00:42 ..
-rw-r--r-- 1 myme users   32 Jan 20 01:09 eighttacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 fivetacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 fourtacle.txt
drwxr-xr-x 9 myme users 4096 Jan 20 01:09 .git
-rw-r--r-- 1 myme users   32 Jan 20 01:09 ninetacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 onetacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 seventacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 sixtacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 tentacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 threetacle.txt
-rw-r--r-- 1 myme users   32 Jan 20 01:09 twotacle.txt
</code></pre>
<p>There‚Äôs nothing stopping us at this point to <em>delete</em> everything introduced by
merging all the tentacles and amending the <code>HEAD</code> commit:</p>
<pre><code>‚ùØ git rm *.txt
rm &#39;eighttacle.txt&#39;
rm &#39;fivetacle.txt&#39;
rm &#39;fourtacle.txt&#39;
rm &#39;ninetacle.txt&#39;
rm &#39;onetacle.txt&#39;
rm &#39;seventacle.txt&#39;
rm &#39;sixtacle.txt&#39;
rm &#39;tentacle.txt&#39;
rm &#39;threetacle.txt&#39;
rm &#39;twotacle.txt&#39;

‚ùØ git commit --amend -C HEAD
[main 8494ef5] Assemble squid
 Date: Fri Jan 20 01:09:57 2023 +0100
</code></pre>
<p>All files are gone:</p>
<pre><code>‚ùØ ls -l
total 0
</code></pre>
<p>Yet the default view of <code>git show</code> of the merge doesn‚Äôt hint at anything suspicious:</p>
<pre><code>commit de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (HEAD -&gt; main)
Merge: 4dadc16 3f7a95e e9cd39a 6be7cf4 a54e5c1 e310cbc 44ad755 3b1a5da bb79112 c78c58a
Author: Martin Myrseth &lt;dave@tentacle.org&gt;
Date:   Fri Jan 20 01:09:57 2023 +0100

    Assemble squid

</code></pre>
<p>While asking it to also include the <em>merge</em> commits it‚Äôs fairly obvious that
somebody have been messing around with the merge resolution:</p>
<pre><code>‚ùØ git show --pretty=oneline -m --stat
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from 4dadc16d89758ed1625223286e1218b63c988313) (HEAD -&gt; main) Assemble squid
 tentacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from 3f7a95ecac18a92451f7e205c8ea0bb2366c2e97) (HEAD -&gt; main) Assemble squid
 ninetacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from e9cd39ad4664b04f29263250396ec1b270e4eeb8) (HEAD -&gt; main) Assemble squid
 eighttacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from 6be7cf4b00f640a32d61a9e205e0b4a1e18b3bb8) (HEAD -&gt; main) Assemble squid
 seventacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from a54e5c16f807a3f9aad8dd0c5187abcc9e6b6c7d) (HEAD -&gt; main) Assemble squid
 sixtacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from e310cbcfecaa3cb6f08084a64c18318f7552a8a7) (HEAD -&gt; main) Assemble squid
 fivetacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from 44ad755cc07047ee3dd25c5170aa9d4dde60475c) (HEAD -&gt; main) Assemble squid
 fourtacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from 3b1a5da6c6e5b2d0b93517dda20c3295ed893374) (HEAD -&gt; main) Assemble squid
 threetacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from bb791123be4bd03a0c6427d1990cd57898dd9793) (HEAD -&gt; main) Assemble squid
 twotacle.txt | 1 -
 1 file changed, 1 deletion(-)
de3e016de71484e62e6ac7e6dda08fe7f9d85af4 (from c78c58a2debbab2d88ed0e747a54f4d750f8378f) (HEAD -&gt; main) Assemble squid
 onetacle.txt | 1 -
 1 file changed, 1 deletion(-)
</code></pre>
<p>In the end, a merge commit in <code>git</code> tracks a <code>tree</code><a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a> ‚Äì like any other commit ‚Äì
and it only <em>extends</em> on the parent commit metadata by including one <code>parent</code>
field for all commits that serves as inputs to the merge operation. Furthermore,
it places no constraints onto the changes <em>made</em> to the <code>tree</code> associated with
that commit. Which basically gives a committer full ‚Äúartistic freedom‚Äù as to
what should be the result of a merge, ranging from the trivial ‚Äúsum of all
differences‚Äù or minor conflict resolutions to absolutely wild rewrites that had
absolutely nothing to do with the differences that went into a merge to begin with.</p>
<h2 id="rounding-off">Rounding off</h2>
<p>I‚Äôm sure that many of these features of <code>git</code> are by no means news to the
readers of this post, and I‚Äôm not exactly sure what pushed me towards writing it
in the first place. If anything, it‚Äôs a recollection of (silly) things I‚Äôve done
in the past. Hopefully it could also inspire people to go learn tools that serve
as their daily drivers beyond just the basic or core functionality.</p>
<p>I‚Äôm a believer that not everything we learn or do has to necessarily have some
obvious usefulness in and of itself. Often when learning tools, techniques,
programming languages, and everything else in the field of software, I find that
going off on tangents can help build intuition about core concepts, ultimately
leading to a deeper understanding. Of course, the few times this peripheral
knowledge is of <em>actual</em> use in real-life situations it‚Äôs even better.</p>
<p>I <em>do</em> place great value in utility, but I also like to remind people to have
fun, experiment, and to build simply for the sake of building. Which, while
typing out this summary, reminded me of this recent post ‚Äì <a href="https://twitchard.github.io/posts/2023-01-18-unicycles.html">‚ÄúTake your pragmatism for a unicycle ride‚Äù</a> ‚Äì which appeared on <a href="https://lobste.rs/s/wdeoob/take_your_pragmatism_for_unicycle_ride">my favorite tech aggregator site</a> the other day. A post which also touched on the importance of
<em>developer energy</em>. That‚Äôs something I consider very central to my own
motivation and mental well-being. If there‚Äôs fun to be had in learning ‚Äì or
building ‚Äì we‚Äôre much less likely to burn out from it.</p>


  </section></div>
  </body>
</html>
