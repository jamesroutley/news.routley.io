<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/topics/developers-practitioners/find-anything-blazingly-fast-googles-vector-search-technology">Original</a>
    <h1>Find anything fast with Google&#39;s vector search technology</h1>
    
    <div id="readability-page-1" class="page"><article><article-header-block><section><div><div><!----><p>Developers &amp; Practitioners</p></div></div></section></article-header-block><!----><!----><div><div><div><!----><div><article-author-block><div><!----><div><p> Tomoyuki Chikanaga </p><p> Chief Architect, Groovenauts </p></div><p><span> December 13, 2021 </span></p></div></article-author-block></div></div></div><article-cta _nghost-c14=""><!----><div _ngcontent-c14=""><div _ngcontent-c14=""><h4 _ngcontent-c14=""><!----><!----><span _ngcontent-c14="">Try Google Cloud</span><!----><!----><!----><!----><!----></h4><p _ngcontent-c14=""><!----><!----><span _ngcontent-c14="">Start building on Google Cloud with $300 in free credits and 20+ always free products.</span><!----><!----><!----><!----><!----></p><a _ngcontent-c14="" clicktracker="" rel="external" track-metadata-module="article cta" track-type="button" track-name="free trial" track-metadata-eventdetail="https://cloud.google.com/free/" href="https://cloud.google.com/free/"><!----><!----><span _ngcontent-c14="">Free Trial</span><!----><!----><!----><!----><!----></a></div></div></article-cta></div><article-share-block></article-share-block><article-sticky-share-block></article-sticky-share-block><section><div><div><!----><article-content-stream-block><!----><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><p>Recently, Google Cloud partner <a href="https://www.groovenauts.jp/en/" target="_blank" track-type="inline link" track-name="1" track-metadata-eventdetail="https://www.groovenauts.jp" track-metadata-module="post">Groovenauts, Inc.</a> published a live demo of <a href="https://matchit.magellanic-clouds.com/" target="_blank" track-type="inline link" track-name="2" track-metadata-eventdetail="https://matchit.magellanic-clouds.com" track-metadata-module="post">MatchIt Fast</a>. As the demo shows, you can find images and text similar to a selected sample from a collection of millions in a matter of milliseconds:</p></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;Give it a try &amp;#8212; and either select a preset image or upload one of your own. Once you make your choice, you will get the top 25 similar images from two million images on &lt;a href=&#34;https://commons.wikimedia.org/wiki/Category:Images&#34; target=&#34;_blank&#34;&gt;Wikimedia images&lt;/a&gt; in an instant, as you can see in the video above. No caching involved.&lt;/p&gt;&lt;p&gt;The demo also lets you perform the similarity search with news articles. Just copy and paste some paragraphs from any news article, and get similar articles from 2.7 million articles on &lt;a href=&#34;https://www.gdeltproject.org/&#34; target=&#34;_blank&#34;&gt;the GDELT project&lt;/a&gt; within a second.&lt;/p&gt;"><p>Give it a try — and either select a preset image or upload one of your own. Once you make your choice, you will get the top 25 similar images from two million images on <a href="https://commons.wikimedia.org/wiki/Category:Images" target="_blank" track-type="inline link" track-name="3" track-metadata-eventdetail="https://commons.wikimedia.org" track-metadata-module="post">Wikimedia images</a> in an instant, as you can see in the video above. No caching involved.</p><p>The demo also lets you perform the similarity search with news articles. Just copy and paste some paragraphs from any news article, and get similar articles from 2.7 million articles on <a href="https://www.gdeltproject.org/" target="_blank" track-type="inline link" track-name="4" track-metadata-eventdetail="https://www.gdeltproject.org" track-metadata-module="post">the GDELT project</a> within a second.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;h3&gt;Vector Search: the technology behind Google Search, YouTube, Play, and more&lt;/h3&gt;&lt;p&gt;How can it find matches that fast? The trick is that the MatchIt Fast demo uses the vector similarity search (or &lt;a href=&#34;https://en.wikipedia.org/wiki/Nearest_neighbor_search&#34; target=&#34;_blank&#34;&gt;nearest neighbor search&lt;/a&gt; or simply vector search) capabilities of the &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/matching-engine/overview&#34;&gt;Vertex AI Matching Engine&lt;/a&gt;, which shares the same backend as Google Image Search, YouTube, Google Play, and more, for billions of recommendations and information retrievals for Google users worldwide. The technology is one of the most important components of Google&#39;s core services, and not just for Google: it is becoming a vital component of many popular web services that rely on content search and information retrieval accelerated by the power of deep neural networks.&lt;/p&gt;&lt;p&gt;So what&#39;s the difference between traditional keyword-based search and vector similarity search? For many years, relational databases and full-text search engines have been the foundation of information retrieval in modern IT systems. For example, you would add tags or category keywords such as &amp;#34;movie&amp;#34;, &amp;#34;music&amp;#34;, or &amp;#34;actor&amp;#34; to each piece of content (image or text) or each entity (a product, user, IoT device, or anything really). You&amp;#8217;d then add those records to a database, so you could perform searches with those tags or keywords.&lt;/p&gt;"><h3>Vector Search: the technology behind Google Search, YouTube, Play, and more</h3><p>How can it find matches that fast? The trick is that the MatchIt Fast demo uses the vector similarity search (or <a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search" target="_blank" track-type="inline link" track-name="5" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">nearest neighbor search</a> or simply vector search) capabilities of the <a href="https://cloud.google.com/vertex-ai/docs/matching-engine/overview" track-type="inline link" track-name="6" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/matching-engine/overview" track-metadata-module="post">Vertex AI Matching Engine</a>, which shares the same backend as Google Image Search, YouTube, Google Play, and more, for billions of recommendations and information retrievals for Google users worldwide. The technology is one of the most important components of Google&#39;s core services, and not just for Google: it is becoming a vital component of many popular web services that rely on content search and information retrieval accelerated by the power of deep neural networks.</p><p>So what&#39;s the difference between traditional keyword-based search and vector similarity search? For many years, relational databases and full-text search engines have been the foundation of information retrieval in modern IT systems. For example, you would add tags or category keywords such as &#34;movie&#34;, &#34;music&#34;, or &#34;actor&#34; to each piece of content (image or text) or each entity (a product, user, IoT device, or anything really). You’d then add those records to a database, so you could perform searches with those tags or keywords.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><p>In contrast, vector search uses vectors (where each vector is a list of numbers) for representing and searching content. The combination of the numbers defines similarity to specific topics. For example, if an image (or any content) includes 10% of “movie”, 2% of “music”, and 30% of “actor”-related content, then you could define a vector [0.1, 0.02, 0.3] to represent it. (Note: this is an overly simplified explanation of the concept; the actual vectors have much more complex vector spaces). You can find similar content by comparing the distances and similarities between vectors. This is how Google services find valuable content for a wide variety of users worldwide in milliseconds. </p></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;With keyword search, you can only specify a binary choice as an attribute of each piece of content; it&#39;s either about a movie or not, either music or not, and so on. Also, you cannot express the actual &amp;#34;meaning&amp;#34; of the content to search. If you specify a keyword &amp;#34;films&amp;#34;, for example, you would not see any content related to &amp;#34;movies&amp;#34; unless there was a synonyms dictionary that explicitly linked these two terms in the database or search engine.&amp;#160;&lt;/p&gt;&lt;p&gt;Vector search provides a much more refined way to find content, with subtle nuances and meanings. Vectors can represent a subset of content that contains &amp;#34;much about actors, some about movies, and a little about music&amp;#34;. Vectors can represent the meaning of content where &amp;#8220;films&amp;#8221;, &amp;#8220;movies&amp;#8221;, and &amp;#8220;cinema&amp;#8221; are all collected together. Also, vectors have the flexibility to represent categories&amp;#160; previously unknown to or undefined by service providers. For example, emerging categories of content primarily attractive to kids, such as &lt;a href=&#34;https://www.youtube.com/results?search_query=asmr&#34; target=&#34;_blank&#34;&gt;ASMR&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/results?search_query=slime&#34; target=&#34;_blank&#34;&gt;slime&lt;/a&gt;, are really hard for adults or marketing professionals to predict beforehand, and going back through vast databases to manually update content with these new labels would be all but impossible to do quickly. But vectors can capture and represent never-before-seen categories instantly.&lt;/p&gt;"><p>With keyword search, you can only specify a binary choice as an attribute of each piece of content; it&#39;s either about a movie or not, either music or not, and so on. Also, you cannot express the actual &#34;meaning&#34; of the content to search. If you specify a keyword &#34;films&#34;, for example, you would not see any content related to &#34;movies&#34; unless there was a synonyms dictionary that explicitly linked these two terms in the database or search engine. </p><p>Vector search provides a much more refined way to find content, with subtle nuances and meanings. Vectors can represent a subset of content that contains &#34;much about actors, some about movies, and a little about music&#34;. Vectors can represent the meaning of content where “films”, “movies”, and “cinema” are all collected together. Also, vectors have the flexibility to represent categories  previously unknown to or undefined by service providers. For example, emerging categories of content primarily attractive to kids, such as <a href="https://www.youtube.com/results?search_query=asmr" target="_blank" track-type="inline link" track-name="7" track-metadata-eventdetail="https://www.youtube.com" track-metadata-module="post">ASMR</a> or <a href="https://www.youtube.com/results?search_query=slime" target="_blank" track-type="inline link" track-name="8" track-metadata-eventdetail="https://www.youtube.com" track-metadata-module="post">slime</a>, are really hard for adults or marketing professionals to predict beforehand, and going back through vast databases to manually update content with these new labels would be all but impossible to do quickly. But vectors can capture and represent never-before-seen categories instantly.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;h3&gt;Vector search changes business&lt;/h3&gt;&lt;p&gt;Vector search is not only applicable to image and text content. It can also be used for information retrieval for anything you have in your business when you can define a vector to represent each thing. Here are a few examples:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Finding similar users: If you define a vector to represent each user in your business by combining the user&amp;#8217;s activities, past purchase history, and other user attributes, then you can find all users similar to a specified user.&amp;#160; You can then see, for example, users who are purchasing similar products, users that are likely bots, or users who are potential premium customers and who should be targeted with digital marketing.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finding similar products or items: With a vector generated from product features such as description, price, sales location, and so on, you can find similar products to answer any number of questions; for example, &amp;#34;What other products do we have that are similar to this one and may work for the same use case?&amp;#34; or &amp;#34;What products sold in the last 24 hours in this area?&amp;#8221; (based on time and proximity)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finding defective IoT devices: With a vector that captures the features of defective devices from their signals, vector search enables you to instantly find potentially defective devices for proactive maintenance.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finding ads: Well-defined vectors let you find the most relevant or appropriate ads for viewers in milliseconds at high throughput.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finding security threats: You can identify security threats by vectorizing the signatures of computer virus binaries or malicious attack behaviors against web services or network equipment.&amp;#160;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;...and many more: Thousands of different applications of vector search in all industries will likely emerge in the next few years, making the technology as important as relational databases.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;OK, vector search sounds cool. But what are the major challenges to applying the technology to real business use cases? Actually there are two:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Creating vectors that are meaningful for business use cases&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Building a fast and scalable vector search service&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Embeddings: meaningful vectors for business use cases&lt;/h3&gt;&lt;p&gt;The first challenge is creating vectors for representing various entities that are meaningful and useful for business use cases. This is where deep learning technology can really shine. In the case of the MatchIt Fast demo, the application simply uses a pre-trained &lt;a href=&#34;https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/feature_vector/5&#34; target=&#34;_blank&#34;&gt;MobileNet v2 model&lt;/a&gt; for extracting vectors from images, and the &lt;a href=&#34;https://tfhub.dev/google/collections/universal-sentence-encoder&#34; target=&#34;_blank&#34;&gt;Universal Sentence Encoder&lt;/a&gt; (USE) for text. By applying such models to raw data, you can extract &amp;#34;&lt;a href=&#34;https://developers.google.com/machine-learning/crash-course/embeddings/video-lecture&#34; target=&#34;_blank&#34;&gt;embeddings&lt;/a&gt;&amp;#34; - vectors that map each row of data in a space of their &amp;#34;meanings&amp;#34;. MobileNet puts images that have similar patterns and textures closer to one another in the embedding space, and USE puts texts that have similar topics closer.&lt;/p&gt;&lt;p&gt;For example, a carefully designed and trained machine learning model could map movies into an embedding space like the following:&lt;/p&gt;"><h3>Vector search changes business</h3><p>Vector search is not only applicable to image and text content. It can also be used for information retrieval for anything you have in your business when you can define a vector to represent each thing. Here are a few examples:</p><ul><li><p>Finding similar users: If you define a vector to represent each user in your business by combining the user’s activities, past purchase history, and other user attributes, then you can find all users similar to a specified user.  You can then see, for example, users who are purchasing similar products, users that are likely bots, or users who are potential premium customers and who should be targeted with digital marketing.</p></li><li><p>Finding similar products or items: With a vector generated from product features such as description, price, sales location, and so on, you can find similar products to answer any number of questions; for example, &#34;What other products do we have that are similar to this one and may work for the same use case?&#34; or &#34;What products sold in the last 24 hours in this area?” (based on time and proximity)</p></li><li><p>Finding defective IoT devices: With a vector that captures the features of defective devices from their signals, vector search enables you to instantly find potentially defective devices for proactive maintenance.</p></li><li><p>Finding ads: Well-defined vectors let you find the most relevant or appropriate ads for viewers in milliseconds at high throughput.</p></li><li><p>Finding security threats: You can identify security threats by vectorizing the signatures of computer virus binaries or malicious attack behaviors against web services or network equipment. </p></li><li><p>...and many more: Thousands of different applications of vector search in all industries will likely emerge in the next few years, making the technology as important as relational databases.</p></li></ul><p>OK, vector search sounds cool. But what are the major challenges to applying the technology to real business use cases? Actually there are two:</p><ul><li><p>Creating vectors that are meaningful for business use cases</p></li><li><p>Building a fast and scalable vector search service</p></li></ul><h3>Embeddings: meaningful vectors for business use cases</h3><p>The first challenge is creating vectors for representing various entities that are meaningful and useful for business use cases. This is where deep learning technology can really shine. In the case of the MatchIt Fast demo, the application simply uses a pre-trained <a href="https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/feature_vector/5" target="_blank" track-type="inline link" track-name="9" track-metadata-eventdetail="https://tfhub.dev" track-metadata-module="post">MobileNet v2 model</a> for extracting vectors from images, and the <a href="https://tfhub.dev/google/collections/universal-sentence-encoder" target="_blank" track-type="inline link" track-name="10" track-metadata-eventdetail="https://tfhub.dev" track-metadata-module="post">Universal Sentence Encoder</a> (USE) for text. By applying such models to raw data, you can extract &#34;<a href="https://developers.google.com/machine-learning/crash-course/embeddings/video-lecture" target="_blank" track-type="inline link" track-name="11" track-metadata-eventdetail="https://developers.google.com" track-metadata-module="post">embeddings</a>&#34; - vectors that map each row of data in a space of their &#34;meanings&#34;. MobileNet puts images that have similar patterns and textures closer to one another in the embedding space, and USE puts texts that have similar topics closer.</p><p>For example, a carefully designed and trained machine learning model could map movies into an embedding space like the following:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;With the embedding space shown here, users could find recommended movies based on the two dimensions: is the movie for children or adults, and is it a blockbuster or arthouse movie? This is a very simple example, of course, but with an embedding space like this that fits your business requirements, you can deliver a better user experience on recommendation and information retrieval services with insights extracted from the model.&amp;#160;&lt;/p&gt;&lt;p&gt;For more about creating embeddings, the &lt;a href=&#34;https://developers.google.com/machine-learning/recommendation&#34; target=&#34;_blank&#34;&gt;Machine Learning Crash Course on Recommendation Systems&lt;/a&gt; is a great way to get started. We will also discuss how to extract better embeddings from business data later in this post.&lt;/p&gt;&lt;h3&gt;Building a fast and scalable vector search service&lt;/h3&gt;&lt;p&gt;Suppose that you have successfully extracted useful vectors (embeddings) from your business data. Now the only thing you have to do is search for similar vectors. That sounds simple, but in practice it is not. Let&#39;s see how the vector search works when you implement it with BigQuery in a naive way:&lt;/p&gt;"><p>With the embedding space shown here, users could find recommended movies based on the two dimensions: is the movie for children or adults, and is it a blockbuster or arthouse movie? This is a very simple example, of course, but with an embedding space like this that fits your business requirements, you can deliver a better user experience on recommendation and information retrieval services with insights extracted from the model. </p><p>For more about creating embeddings, the <a href="https://developers.google.com/machine-learning/recommendation" target="_blank" track-type="inline link" track-name="12" track-metadata-eventdetail="https://developers.google.com" track-metadata-module="post">Machine Learning Crash Course on Recommendation Systems</a> is a great way to get started. We will also discuss how to extract better embeddings from business data later in this post.</p><h3>Building a fast and scalable vector search service</h3><p>Suppose that you have successfully extracted useful vectors (embeddings) from your business data. Now the only thing you have to do is search for similar vectors. That sounds simple, but in practice it is not. Let&#39;s see how the vector search works when you implement it with BigQuery in a naive way:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><!----><!----><!----><div><div><div><article-video-block _nghost-c13=""><p _ngcontent-c13=""><iframe _ngcontent-c13="" allow="encrypted-media" allowfullscreen="" frameborder="0" height="100%" position="absolute" width="100%" src="https://www.youtube.com/embed/wHNJspvxj2w?enablejsapi=1&amp;"></iframe></p></article-video-block></div></div></div><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;It takes about 20 seconds to find similar items (fish images in this case) from a pool of one million items. That level of performance is not so impressive, especially when compared to the MatchIt Fast demo. BigQuery is one of the fastest data warehouse services in the industry, so why does the vector search take so long?&lt;/p&gt;&lt;p&gt;This illustrates the second challenge: building a fast and scalable vector search engine isn&#39;t an easy task. The most widely used metrics for calculating the similarity between vectors are L2 distance (Euclidean distance), cosine similarity, and inner product (dot product).&lt;/p&gt;"><p>It takes about 20 seconds to find similar items (fish images in this case) from a pool of one million items. That level of performance is not so impressive, especially when compared to the MatchIt Fast demo. BigQuery is one of the fastest data warehouse services in the industry, so why does the vector search take so long?</p><p>This illustrates the second challenge: building a fast and scalable vector search engine isn&#39;t an easy task. The most widely used metrics for calculating the similarity between vectors are L2 distance (Euclidean distance), cosine similarity, and inner product (dot product).</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;But all require calculations proportional to the number of vectors multiplied by the number of dimensions if you implement them in a naive way. For example, if you compare a vector with 1024 elements to 1M vectors, the number of calculations will be proportional to 1024 x 1M = 1.02B. This is the computation required to look through all the entities for a single search, and the reason why the BigQuery demo above takes so long.&lt;/p&gt;&lt;p&gt;Instead of comparing vectors one by one, you could use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor&#34; target=&#34;_blank&#34;&gt;approximate nearest neighbor&lt;/a&gt; (ANN) approach to improve search times. Many ANN algorithms use &lt;a href=&#34;https://en.wikipedia.org/wiki/Vector_quantization&#34; target=&#34;_blank&#34;&gt;vector quantization&lt;/a&gt; (VQ), in which you split the vector space into multiple groups, define &amp;#34;codewords&amp;#34; to represent each group, and search only for those codewords. This VQ technique dramatically enhances query speeds and is the essential part of many ANN algorithms, just like indexing is the essential part of relational databases and full-text search engines.&lt;/p&gt;"><p>But all require calculations proportional to the number of vectors multiplied by the number of dimensions if you implement them in a naive way. For example, if you compare a vector with 1024 elements to 1M vectors, the number of calculations will be proportional to 1024 x 1M = 1.02B. This is the computation required to look through all the entities for a single search, and the reason why the BigQuery demo above takes so long.</p><p>Instead of comparing vectors one by one, you could use the <a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor" target="_blank" track-type="inline link" track-name="13" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">approximate nearest neighbor</a> (ANN) approach to improve search times. Many ANN algorithms use <a href="https://en.wikipedia.org/wiki/Vector_quantization" target="_blank" track-type="inline link" track-name="14" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">vector quantization</a> (VQ), in which you split the vector space into multiple groups, define &#34;codewords&#34; to represent each group, and search only for those codewords. This VQ technique dramatically enhances query speeds and is the essential part of many ANN algorithms, just like indexing is the essential part of relational databases and full-text search engines.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;As you may be able to conclude from the diagram above, as the number of groups in the space increases the speed of the search decreases and the accuracy increases.&amp;#160; Managing this trade-off &amp;#8212; getting higher accuracy at shorter latency &amp;#8212; has been a key challenge with ANN algorithms.&amp;#160;&lt;/p&gt;&lt;p&gt;Last year, Google Research announced &lt;a href=&#34;https://ai.googleblog.com/2020/07/announcing-scann-efficient-vector.html&#34; target=&#34;_blank&#34;&gt;ScaNN&lt;/a&gt;, a new solution that provides state-of-the-art results for this challenge. With ScaNN, they introduced a new VQ algorithm called anisotropic vector quantization:&lt;/p&gt;"><p>As you may be able to conclude from the diagram above, as the number of groups in the space increases the speed of the search decreases and the accuracy increases.  Managing this trade-off — getting higher accuracy at shorter latency — has been a key challenge with ANN algorithms. </p><p>Last year, Google Research announced <a href="https://ai.googleblog.com/2020/07/announcing-scann-efficient-vector.html" target="_blank" track-type="inline link" track-name="15" track-metadata-eventdetail="https://ai.googleblog.com" track-metadata-module="post">ScaNN</a>, a new solution that provides state-of-the-art results for this challenge. With ScaNN, they introduced a new VQ algorithm called anisotropic vector quantization:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><p>Anisotropic vector quantization uses a new loss function to train a model for VQ for an optimal grouping to capture farther data points (i.e. higher inner product) in a single group. With this idea, the new algorithm gives you higher accuracy at lower latency, as you can see in the benchmark result below (the violet line): </p></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;This is the magic ingredient in the user experience you feel when you are using Google Image Search, YouTube, Google Play, and many other services that rely on recommendations and search. In short, Google&#39;s ANN technology enables users to find valuable information in milliseconds, in the vast sea of web content.&lt;/p&gt;&lt;h3&gt;How to use Vertex AI Matching Engine&lt;/h3&gt;&lt;p&gt;Now you can use the same search technology that powers Google services with your own business data. &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/matching-engine&#34;&gt;Vertex AI Matching Engine&lt;/a&gt; is the product that shares the same ScaNN based backend with Google services for fast and scalable vector search, and recently it became GA and ready for production use. In addition to ScaNN, Matching Engine gives you additional features as a commercial product, including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Scalability and availability: The &lt;a href=&#34;https://github.com/google-research/google-research/tree/master/scann&#34; target=&#34;_blank&#34;&gt;open source version of ScaNN&lt;/a&gt; is a good choice for evaluation purposes, but as with most new and advanced technologies, you can expect challenges when putting it into production on your own. For example, how do you operate it on multiple nodes with high scalability, availability, and maintainability? Matching Engine uses Google&#39;s production backend for ScaNN, which provides auto-scaling and auto-failover with a large worker pool. It is capable of handling tens of thousands of requests per second, and returns search results in less than 10 ms for the 90th percentile with a recall rate of 95 - 98%.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Fully managed: You don&#39;t have to worry about building and maintaining the search service. Just create or update an index with your vectors, and you will have a production-ready ANN service deployed. No need to think about rebuilding and optimizing indexes, or other maintenance tasks.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Filtering: Matching Engine provides filtering functionality that enables you to filter search results based on tags you specify on each vector. For example, you can assign &amp;#34;country&amp;#34; and &amp;#34;stocked&amp;#34; tags to each fashion item vector, and specify filters like &amp;#34;(US OR Canada) AND stocked&amp;#34;&amp;#160; or &amp;#34;not Japan AND stocked&amp;#34; on your searches.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let&#39;s see how to use Matching Engine with code examples from the MatchIt Fast demo.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Generating embeddings&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Before starting the search, you need to generate embeddings for each item like this one:&lt;/p&gt;"><p>This is the magic ingredient in the user experience you feel when you are using Google Image Search, YouTube, Google Play, and many other services that rely on recommendations and search. In short, Google&#39;s ANN technology enables users to find valuable information in milliseconds, in the vast sea of web content.</p><h3>How to use Vertex AI Matching Engine</h3><p>Now you can use the same search technology that powers Google services with your own business data. <a href="https://cloud.google.com/vertex-ai/docs/matching-engine" track-type="inline link" track-name="16" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/matching-engine" track-metadata-module="post">Vertex AI Matching Engine</a> is the product that shares the same ScaNN based backend with Google services for fast and scalable vector search, and recently it became GA and ready for production use. In addition to ScaNN, Matching Engine gives you additional features as a commercial product, including:</p><ul><li><p>Scalability and availability: The <a href="https://github.com/google-research/google-research/tree/master/scann" target="_blank" track-type="inline link" track-name="17" track-metadata-eventdetail="https://github.com" track-metadata-module="post">open source version of ScaNN</a> is a good choice for evaluation purposes, but as with most new and advanced technologies, you can expect challenges when putting it into production on your own. For example, how do you operate it on multiple nodes with high scalability, availability, and maintainability? Matching Engine uses Google&#39;s production backend for ScaNN, which provides auto-scaling and auto-failover with a large worker pool. It is capable of handling tens of thousands of requests per second, and returns search results in less than 10 ms for the 90th percentile with a recall rate of 95 - 98%.</p></li><li><p>Fully managed: You don&#39;t have to worry about building and maintaining the search service. Just create or update an index with your vectors, and you will have a production-ready ANN service deployed. No need to think about rebuilding and optimizing indexes, or other maintenance tasks.</p></li><li><p>Filtering: Matching Engine provides filtering functionality that enables you to filter search results based on tags you specify on each vector. For example, you can assign &#34;country&#34; and &#34;stocked&#34; tags to each fashion item vector, and specify filters like &#34;(US OR Canada) AND stocked&#34;  or &#34;not Japan AND stocked&#34; on your searches.</p></li></ul><p>Let&#39;s see how to use Matching Engine with code examples from the MatchIt Fast demo.</p><p><b>Generating embeddings</b></p><p>Before starting the search, you need to generate embeddings for each item like this one:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><!----><article-code-block _nghost-c17=""><!----><pre _ngcontent-c17="">  <!----><code _ngcontent-c17="">{
</code><code _ngcontent-c17="">  &#34;Id&#34;:&#34;b5c65fea9b0b8a57bfa574ea&#34;,
</code><code _ngcontent-c17="">  &#34;Embedding&#34;: [
</code><code _ngcontent-c17="">    0.16329009830951691,
</code><code _ngcontent-c17="">    0.92436742782592773,
</code><code _ngcontent-c17="">    0.00095699273515492678,
</code><code _ngcontent-c17="">    0.011479727923870087,
</code><code _ngcontent-c17="">    0.0089491046965122223,
</code><code _ngcontent-c17="">    0.019959751516580582,
</code><code _ngcontent-c17="">    0.031516745686531067,
</code><code _ngcontent-c17="">    0.0066015380434691906,
</code><code _ngcontent-c17="">    0.46404418349266052,
</code><code _ngcontent-c17="">    ...</code>
</pre></article-code-block></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><p>This is an embedding with 1280 dimensions for a single image, generated with a MobileNet v2 model. The MatchIt Fast demo generates embeddings for two million images with <a href="https://github.com/groovenauts/MatchItFast/blob/master/image_vectorize/vectorizer.py" target="_blank" track-type="inline link" track-name="18" track-metadata-eventdetail="https://github.com" track-metadata-module="post">the following code</a>:</p></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><!----><article-code-block _nghost-c17=""><!----><pre _ngcontent-c17="">  <!----><code _ngcontent-c17="">class Vectorizer:
</code><code _ngcontent-c17="">    def __init__(self):
</code><code _ngcontent-c17="">        self._model = tf.keras.Sequential([hub.KerasLayer(&#34;https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/feature_vector/5&#34;, trainable=False)])
</code><code _ngcontent-c17="">        self._model.build([None, 224, 224, 3])  # Batch input shape.
</code><code _ngcontent-c17="">
</code><code _ngcontent-c17="">    def vectorize(self, jpeg_file):
</code><code _ngcontent-c17="">        ...snip...
</code><code _ngcontent-c17="">        embedding = self._model.predict({&#34;inputs&#34;: input_tensor})[0].tolist()
</code><code _ngcontent-c17="">        return embedding</code>
</pre></article-code-block></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;After you generate the embeddings, you store them in a Google Cloud Storage bucket.&amp;#160;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Configuring an index&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Then, define a&lt;a href=&#34;https://github.com/groovenauts/MatchItFast/blob/master/metadata/wikimedia_images_index_metadata.json&#34; target=&#34;_blank&#34;&gt; JSON file&lt;/a&gt; for the index configuration:&lt;/p&gt;"><p>After you generate the embeddings, you store them in a Google Cloud Storage bucket. </p><p><b>Configuring an index</b></p><p>Then, define a<a href="https://github.com/groovenauts/MatchItFast/blob/master/metadata/wikimedia_images_index_metadata.json" target="_blank" track-type="inline link" track-name="19" track-metadata-eventdetail="https://github.com" track-metadata-module="post"> JSON file</a> for the index configuration:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><!----><article-code-block _nghost-c17=""><!----><pre _ngcontent-c17="">  <!----><code _ngcontent-c17="">{
</code><code _ngcontent-c17="">  &#34;contentsDeltaUri&#34;: &#34;gs://match-it-fast-us-central1/wikimedia_images/index-1&#34;,
</code><code _ngcontent-c17="">  &#34;config&#34;: {
</code><code _ngcontent-c17="">    &#34;dimensions&#34;: 1280,
</code><code _ngcontent-c17="">    &#34;approximateNeighborsCount&#34;: 150,
</code><code _ngcontent-c17="">    &#34;distanceMeasureType&#34;: &#34;SQUARED_L2_DISTANCE&#34;,
</code><code _ngcontent-c17="">    &#34;algorithm_config&#34;: {
</code><code _ngcontent-c17="">      &#34;treeAhConfig&#34;: {
</code><code _ngcontent-c17="">        &#34;leafNodeEmbeddingCount&#34;: 1000,
</code><code _ngcontent-c17="">        &#34;leafNodesToSearchPercent&#34;: 5
</code><code _ngcontent-c17="">      }
</code><code _ngcontent-c17="">    }
</code><code _ngcontent-c17="">  }
</code><code _ngcontent-c17="">}</code>
</pre></article-code-block></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;You can find a detailed description for each field in &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes&#34;&gt;the documentation&lt;/a&gt;, but here are some important fields:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;contentsDeltaUri&lt;/code&gt;: the place where you have stored the embeddings&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dimensions&lt;/code&gt;: how many dimensions in the embeddings&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;approximateNeighborsCount&lt;/code&gt;: the default number of neighbors to find via approximate search&amp;#160;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;distanceMeasureType&lt;/code&gt;: how the similarity between embeddings should be measured, either L1, L2, cosine or dot product (&lt;a href=&#34;https://developers.google.com/machine-learning/recommendation/overview/candidate-generation#which-similarity-measure-to-choose&#34; target=&#34;_blank&#34;&gt;this page&lt;/a&gt; explains which one to choose for different embeddings)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To create an index on the Matching Engine, run &lt;a href=&#34;https://github.com/groovenauts/MatchItFast/#configure-matching-engine&#34; target=&#34;_blank&#34;&gt;the following gcloud command&lt;/a&gt; where the &lt;code&gt;metadata-file&lt;/code&gt; option takes the JSON file name defined above.&lt;/p&gt;"><p>You can find a detailed description for each field in <a href="https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes" track-type="inline link" track-name="20" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes" track-metadata-module="post">the documentation</a>, but here are some important fields:</p><ul><li><p><code>contentsDeltaUri</code>: the place where you have stored the embeddings</p></li><li><p><code>dimensions</code>: how many dimensions in the embeddings</p></li><li><p><code>approximateNeighborsCount</code>: the default number of neighbors to find via approximate search </p></li><li><p><code>distanceMeasureType</code>: how the similarity between embeddings should be measured, either L1, L2, cosine or dot product (<a href="https://developers.google.com/machine-learning/recommendation/overview/candidate-generation#which-similarity-measure-to-choose" target="_blank" track-type="inline link" track-name="21" track-metadata-eventdetail="https://developers.google.com" track-metadata-module="post">this page</a> explains which one to choose for different embeddings)</p></li></ul><p>To create an index on the Matching Engine, run <a href="https://github.com/groovenauts/MatchItFast/#configure-matching-engine" target="_blank" track-type="inline link" track-name="22" track-metadata-eventdetail="https://github.com" track-metadata-module="post">the following gcloud command</a> where the <code>metadata-file</code> option takes the JSON file name defined above.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><!----><article-code-block _nghost-c17=""><!----><pre _ngcontent-c17="">  <!----><code _ngcontent-c17="">gcloud --project=gn-match-it-fast beta ai indexes create \
</code><code _ngcontent-c17="">       --display-name=wikimedia-images \
</code><code _ngcontent-c17="">       --description=&#34;Wikimedia Image Demo&#34; \
</code><code _ngcontent-c17="">       --metadata-file=metadata/wikimedia_images_index_metadata.json \
</code><code _ngcontent-c17="">       --region=us-central1</code>
</pre></article-code-block></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;&lt;b&gt;Run the search&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Now the Matching Engine is ready to run. The demo processes each search request in the following order:&lt;/p&gt;"><p><b>Run the search</b></p><p>Now the Matching Engine is ready to run. The demo processes each search request in the following order:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;ol&gt;&lt;li&gt;&lt;p&gt;First, the web UI takes an image (the one chosen or uploaded by the user) and encodes it into an embedding using the TensorFlow.js MobileNet v2 model running inside the browser. Note: this &amp;#34;client-side encoding&amp;#34; is an interesting option for reducing network traffic when you can run the encoding at the client. In many other cases, you would encode contents to embeddings with a server-side prediction service such as &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/predictions/getting-predictions&#34;&gt;Vertex AI Prediction&lt;/a&gt;, or just retrieve pre-generated embeddings from a repository like &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/featurestore&#34;&gt;Vertex AI Feature Store&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;https://cloud.google.com/appengine/&#34;&gt;App Engine&lt;/a&gt; frontend receives the embedding and submits a query to the Matching Engine. Note that you can also use any other compute services in Google Cloud for submitting queries to Matching Engine, such as &lt;a href=&#34;https://cloud.google.com/run&#34;&gt;Cloud Run&lt;/a&gt;, &lt;a href=&#34;https://cloud.google.com/compute&#34;&gt;Compute Engine&lt;/a&gt;, or &lt;a href=&#34;https://cloud.google.com/kubernetes-engine&#34;&gt;Kubernetes Engine&lt;/a&gt;, or whatever is most suitable for your applications.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Matching Engine executes its search. The connection between App Engine and Matching Engine is provided via a VPC private network for optimal latency.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Matching Engine returns the IDs of similar vectors in its index.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Step 3 is implemented with the following &lt;a href=&#34;https://github.com/groovenauts/MatchItFast/blob/172772589e72d348f5241e9468fd2c5997aa51c3/matching/query.py#L6&#34; target=&#34;_blank&#34;&gt;code&lt;/a&gt;:&lt;/p&gt;"><ol><li><p>First, the web UI takes an image (the one chosen or uploaded by the user) and encodes it into an embedding using the TensorFlow.js MobileNet v2 model running inside the browser. Note: this &#34;client-side encoding&#34; is an interesting option for reducing network traffic when you can run the encoding at the client. In many other cases, you would encode contents to embeddings with a server-side prediction service such as <a href="https://cloud.google.com/vertex-ai/docs/predictions/getting-predictions" track-type="inline link" track-name="23" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/predictions/getting-predictions" track-metadata-module="post">Vertex AI Prediction</a>, or just retrieve pre-generated embeddings from a repository like <a href="https://cloud.google.com/vertex-ai/docs/featurestore" track-type="inline link" track-name="24" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/featurestore" track-metadata-module="post">Vertex AI Feature Store</a>.</p></li><li><p>The <a href="https://cloud.google.com/appengine/" track-type="inline link" track-name="25" track-metadata-eventdetail="https://cloud.google.com/appengine/" track-metadata-module="post">App Engine</a> frontend receives the embedding and submits a query to the Matching Engine. Note that you can also use any other compute services in Google Cloud for submitting queries to Matching Engine, such as <a href="https://cloud.google.com/run" track-type="inline link" track-name="26" track-metadata-eventdetail="https://cloud.google.com/run" track-metadata-module="post">Cloud Run</a>, <a href="https://cloud.google.com/compute" track-type="inline link" track-name="27" track-metadata-eventdetail="https://cloud.google.com/compute" track-metadata-module="post">Compute Engine</a>, or <a href="https://cloud.google.com/kubernetes-engine" track-type="inline link" track-name="28" track-metadata-eventdetail="https://cloud.google.com/kubernetes-engine" track-metadata-module="post">Kubernetes Engine</a>, or whatever is most suitable for your applications.</p></li><li><p>Matching Engine executes its search. The connection between App Engine and Matching Engine is provided via a VPC private network for optimal latency.</p></li><li><p>Matching Engine returns the IDs of similar vectors in its index.</p></li></ol><p>Step 3 is implemented with the following <a href="https://github.com/groovenauts/MatchItFast/blob/172772589e72d348f5241e9468fd2c5997aa51c3/matching/query.py#L6" target="_blank" track-type="inline link" track-name="29" track-metadata-eventdetail="https://github.com" track-metadata-module="post">code</a>:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><!----><article-code-block _nghost-c17=""><!----><pre _ngcontent-c17="">  <!----><code _ngcontent-c17="">class MatchingQueryClient:
</code><code _ngcontent-c17="">    ...snip...
</code><code _ngcontent-c17="">
</code><code _ngcontent-c17="">    def query_embedding(self, embedding, num_neighbors=30):
</code><code _ngcontent-c17="">        request = match_service_pb2.MatchRequest()
</code><code _ngcontent-c17="">        request.deployed_index_id = self._deployed_index_id
</code><code _ngcontent-c17="">        for v in embedding:
</code><code _ngcontent-c17="">            request.float_val.append(v)
</code><code _ngcontent-c17="">        request.num_neighbors = num_neighbors
</code><code _ngcontent-c17="">        response = self._stub.Match(request)
</code><code _ngcontent-c17="">        return response</code>
</pre></article-code-block></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;The request to the Matching Engine is sent via gRPC as you can see in the code above. After it gets the request object, it specifies the index id, appends elements of the embedding, specifies the number of neighbors (similar embeddings) to retrieve, and calls the Match function to send the request. The response is received within milliseconds.&lt;/p&gt;&lt;h3&gt;Next steps: Making changes for various use cases and better search quality&lt;/h3&gt;&lt;p&gt;As we noted earlier, the major challenges in applying vector search on production use cases are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Creating vectors that are meaningful for business use cases&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Building a fast and scalable vector search service&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;From the example above, you can see that Vertex AI Matching Engine solves the second challenge. What about the first one? Matching Engine is a vector search service; it doesn&#39;t include the creating vectors part.&lt;/p&gt;&lt;p&gt;The MatchIt Fast demo uses a simple way of extracting embeddings from images and contents; specifically it uses an existing pre-trained model (either MobileNet v2 or Universal Sentence Encoder). While those are easy to get started with, you may want to explore other options to generate embeddings for other use cases and better search quality, based on your business and user experience requirements.&lt;/p&gt;&lt;p&gt;For example, how do you generate embeddings for product recommendations?&amp;#160; The &lt;a href=&#34;https://developers.google.com/machine-learning/recommendation/collaborative/basics&#34; target=&#34;_blank&#34;&gt;Recommendation Systems section of the Machine Learning Crash Course&lt;/a&gt; is a great resource for learning how to use collaborative filtering and DNN models (the two-tower model) to generate embeddings for recommendation. Also, &lt;a href=&#34;https://www.tensorflow.org/recommenders&#34; target=&#34;_blank&#34;&gt;TensorFlow Recommenders&lt;/a&gt; provides useful guides and tutorials for the topic, especially on the two-tower model and advanced topics. For integration with Matching Engine, you may also want to check out the &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/matching-engine/train-embeddings-two-tower&#34;&gt;Train embeddings by using the two-tower built-in algorithm&lt;/a&gt; page.&lt;/p&gt;&lt;p&gt;Another interesting solution is &lt;a href=&#34;https://arxiv.org/abs/1602.02215&#34; target=&#34;_blank&#34;&gt;the Swivel model&lt;/a&gt;. Swivel is a method for generating item embeddings from an item co-occurrence matrix. For structured data, such as purchase orders, the co-occurrence matrix of items can be computed by counting the number of purchase orders that contain both product A and product B, for all products you want to generate embeddings for. To learn more, take a look at &lt;a href=&#34;https://cloud.google.com/vertex-ai/docs/matching-engine/create-embedding-swivel-pipeline&#34;&gt;this tutorial&lt;/a&gt; on how to use the model with Matching Engine.&lt;/p&gt;&lt;p&gt;If you are looking for more ways to achieve better search quality, consider &lt;a href=&#34;https://en.wikipedia.org/wiki/Similarity_learning#Metric_learning&#34; target=&#34;_blank&#34;&gt;metric learning&lt;/a&gt;, which enables you to train a model for discrimination between entities in the embedding space, not only classification:&lt;/p&gt;"><p>The request to the Matching Engine is sent via gRPC as you can see in the code above. After it gets the request object, it specifies the index id, appends elements of the embedding, specifies the number of neighbors (similar embeddings) to retrieve, and calls the Match function to send the request. The response is received within milliseconds.</p><h3>Next steps: Making changes for various use cases and better search quality</h3><p>As we noted earlier, the major challenges in applying vector search on production use cases are:</p><ul><li><p>Creating vectors that are meaningful for business use cases</p></li><li><p>Building a fast and scalable vector search service</p></li></ul><p>From the example above, you can see that Vertex AI Matching Engine solves the second challenge. What about the first one? Matching Engine is a vector search service; it doesn&#39;t include the creating vectors part.</p><p>The MatchIt Fast demo uses a simple way of extracting embeddings from images and contents; specifically it uses an existing pre-trained model (either MobileNet v2 or Universal Sentence Encoder). While those are easy to get started with, you may want to explore other options to generate embeddings for other use cases and better search quality, based on your business and user experience requirements.</p><p>For example, how do you generate embeddings for product recommendations?  The <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics" target="_blank" track-type="inline link" track-name="30" track-metadata-eventdetail="https://developers.google.com" track-metadata-module="post">Recommendation Systems section of the Machine Learning Crash Course</a> is a great resource for learning how to use collaborative filtering and DNN models (the two-tower model) to generate embeddings for recommendation. Also, <a href="https://www.tensorflow.org/recommenders" target="_blank" track-type="inline link" track-name="31" track-metadata-eventdetail="https://www.tensorflow.org" track-metadata-module="post">TensorFlow Recommenders</a> provides useful guides and tutorials for the topic, especially on the two-tower model and advanced topics. For integration with Matching Engine, you may also want to check out the <a href="https://cloud.google.com/vertex-ai/docs/matching-engine/train-embeddings-two-tower" track-type="inline link" track-name="32" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/matching-engine/train-embeddings-two-tower" track-metadata-module="post">Train embeddings by using the two-tower built-in algorithm</a> page.</p><p>Another interesting solution is <a href="https://arxiv.org/abs/1602.02215" target="_blank" track-type="inline link" track-name="33" track-metadata-eventdetail="https://arxiv.org" track-metadata-module="post">the Swivel model</a>. Swivel is a method for generating item embeddings from an item co-occurrence matrix. For structured data, such as purchase orders, the co-occurrence matrix of items can be computed by counting the number of purchase orders that contain both product A and product B, for all products you want to generate embeddings for. To learn more, take a look at <a href="https://cloud.google.com/vertex-ai/docs/matching-engine/create-embedding-swivel-pipeline" track-type="inline link" track-name="34" track-metadata-eventdetail="https://cloud.google.com/vertex-ai/docs/matching-engine/create-embedding-swivel-pipeline" track-metadata-module="post">this tutorial</a> on how to use the model with Matching Engine.</p><p>If you are looking for more ways to achieve better search quality, consider <a href="https://en.wikipedia.org/wiki/Similarity_learning#Metric_learning" target="_blank" track-type="inline link" track-name="35" track-metadata-eventdetail="https://en.wikipedia.org" track-metadata-module="post">metric learning</a>, which enables you to train a model for discrimination between entities in the embedding space, not only classification:</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><p>Popular pre-trained models such as the MobileNet v2 can classify each object in an image, but they are not explicitly trained to discriminate the objects from each other with a defined distance metric. With metric learning, you can expect better search quality by designing the embedding space optimized for various business use cases. <a href="https://blog.tensorflow.org/2021/09/introducing-tensorflow-similarity.html" target="_blank" track-type="inline link" track-name="36" track-metadata-eventdetail="https://blog.tensorflow.org" track-metadata-module="post">TensorFlow Similarity</a> could be an option for integrating metric learning with Matching Engine.</p></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div><div><!----><!----><div><div><div><!----><!----><paragraph-block _nghost-c16=""><div _ngcontent-c16="" innerhtml="&lt;p&gt;Interested? Today, we&amp;#8217;re just beginning the migration from traditional search technology to new vector search. Over the next 5 to 10 years, many more best practices and tools will be developed in the industry and community. These tools and best practices will help answer many questions, like... How do you design your own embedding space for a specific business use case? How do you measure search quality? How do you debug and troubleshoot the vector search? How do you build a hybrid setup with existing search engines for meeting sophisticated requirements? There are many new challenges and opportunities ahead for introducing the technology to production. Now&amp;#8217;s the time to get started delivering better user experiences and seizing new business opportunities with Matching Engine powered by vector search.&lt;/p&gt;&lt;h3&gt;Acknowledgements&lt;/h3&gt;&lt;p&gt;We would like to thank Anand Iyer, Phillip Sun, and Jeremy Wortz for their invaluable feedback to this post.&lt;/p&gt;"><p>Interested? Today, we’re just beginning the migration from traditional search technology to new vector search. Over the next 5 to 10 years, many more best practices and tools will be developed in the industry and community. These tools and best practices will help answer many questions, like... How do you design your own embedding space for a specific business use case? How do you measure search quality? How do you debug and troubleshoot the vector search? How do you build a hybrid setup with existing search engines for meeting sophisticated requirements? There are many new challenges and opportunities ahead for introducing the technology to production. Now’s the time to get started delivering better user experiences and seizing new business opportunities with Matching Engine powered by vector search.</p><h3>Acknowledgements</h3><p>We would like to thank Anand Iyer, Phillip Sun, and Jeremy Wortz for their invaluable feedback to this post.</p></div></paragraph-block><!----><!----><!----></div></div></div><!----><!----><!----><!----><!----><!----><!----></div></article-content-stream-block><!----><article-tag-list-block><!----></article-tag-list-block></div><section><article-up-1to3-block _nghost-c15=""><!----></article-up-1to3-block></section></div></section></article></div>
  </body>
</html>
