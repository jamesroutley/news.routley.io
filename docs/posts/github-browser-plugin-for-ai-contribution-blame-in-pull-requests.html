<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.rbby.dev/posts/github-ai-contribution-blame-for-pull-requests/">Original</a>
    <h1>GitHub Browser Plugin for AI Contribution Blame in Pull Requests</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><h2 id="quickstart-tldr">Quickstart, TL;DR</h2><p><img src="https://blog.rbby.dev/github-ai-contribution-blame-for-pull-requests/roboctocat.webp" alt="refined-github-with-ai-pr" title="robotic octocat" width="200"/></p><ul><li> Learn about and add <a href="https://github.com/git-ai-project/git-ai">git-ai</a> to your tooling, (git cli and editor extensions)</li><li> Build, install and authenticate <a href="https://github.com/rbbydotdev/refined-github-with-ai-pr">refined-github-ai-pr</a></li><li> Push and pull request some Ai generated code via git to Github</li><li> Navigate to your PR in Github <code>https://github.com/&lt;owner&gt;/&lt;repo&gt;/pull/&lt;PR ID&gt;/changes</code></li><li> Bask in the glory of ai annotations (scroll to the end â†“ for example screenshots)</li></ul><div><div><p>Join my email list for updates</p></div></div><h2 id="identifying-ai-contributions">Identifying AI Contributions</h2><h3 id="the-rise-of-lowfriction-ai-contributions">The Rise of Lowâ€‘Friction AI Contributions</h3><p>With the proliferation of effortless codeâ€‘generating tools like Claude Code, Codex, and Cursor, slopâ€‘slung contributions are being doled out as outright spam in hopes of getting a name tacked onto popular openâ€‘source projects. Most are wellâ€‘intentioned â€” itâ€™s just that this workflow is entirely new, and the tools and norms havenâ€™t been established yet. Some openâ€‘source projects have publicly banned them (see: <a href="https://ziglang.org/code-of-conduct/">zig</a>, <a href="https://github.com/tldraw/tldraw/issues/7695">tldr</a>, <a href="https://github.com/ghostty-org/ghostty/blob/main/CONTRIBUTING.md#ai-usage">ghostty</a>), going so far as to vet contributors into a select trusted group.</p><h3 id="when-aigenerated-code-can-be-appropriate">When AIâ€‘Generated Code Can Be Appropriate</h3><p>Oftentimes, depending on the preference of the team and project, less consequential and isolated code could warrant a 100% AI contribution. Nonâ€‘userâ€‘facing tooling, a private beta feature, or a proofâ€‘ofâ€‘concept immediately come to mind. The ability to retroactively see which parts of the codebase were AI contributions, especially in these use cases, could be very valuable. What was tabbed in by Cursor at 3am six months ago could be a part of todayâ€™s refactor.</p><h3 id="percentages-policies-and-maintainer-trust">Percentages, Policies, and Maintainer Trust</h3><p>Projects like Zig may <em>never</em> allow ai contributions, and I am not here to argue that they should change this stance. But in other cases, where the reaction is a heavyâ€‘handed outright refusal, maintainers and developers could have a change of heart if they could codify an allowable percentage done by AI in each pull request. Even without a hardâ€‘andâ€‘fast rule, a percentage could serve as a sort of gut check â€” an overall score as part of a bigger picture of quality in a PR.</p><h2 id="enter-the-git-ai-project">Enter the Git-Ai Project</h2><p><a href="https://github.com/git-ai-project/git-ai"><img src="https://github.com/acunniffe/git-ai/raw/main/assets/docs/supported-agents.png" alt="git ai open graph image" width="300" title="git ai"/></a></p><h3 id="what-gitai-does">What Gitâ€‘AI Does</h3><p>The git-ai project allows you to <em>automatically</em> track agentic ai code contributions across your team and codebase, zeroing in line-by-line, preserving code-generating prompts, all while working within common git workflows. Git-ai works by extending and enhancing your current tooling without slowdown (thanks to Rust) while â€˜staying out of the wayâ€™ - so you can work as if itâ€™s not even there.</p><h3 id="what-data-gitai-captures">What Data Gitâ€‘AI Captures</h3><p>git-ai stores things like per-line ai contributions, the model and prompt given for the code generated.</p><p>git-ai works by storing this ai contribution data in git notes. Git notes are simply blobs attached to commit refs. Itâ€™s eloquent in that the meta data <em>stays with the commit</em>, git-ai also contains additional instrumentation to â€œsurvive a <code>merge --squash</code>, <code>rebase</code>, <code>reset</code>, <code>cherry-pick</code> etc.â€</p><h3 id="project-goals-from-the-readme">Project Goals (From the README)</h3><p><strong>From the <a href="https://github.com/git-ai-project/git-ai/edit/main/README.md">README.md</a>:</strong></p><blockquote><h3 id="goals-of-git-ai-project">Goals of <code>git-ai</code> project</h3><p>ğŸ¤– <strong>Track AI code in a Multi-Agent</strong> world. Because developers get to choose their tools, engineering teams need a <strong>vendor agnostic</strong> way to track AI impact in their repos.</p><p>ğŸ¯ <strong>Accurate attribution</strong> from Laptop â†’ Pull Request â†’ Merged. Claude Code, Cursor and Copilot cannot track code after generationâ€”Git AI follows it through the entire workflow.</p><p>ğŸ”„ <strong>Support real-world git workflows</strong> by making sure AI-Authorship annotations survive a <code>merge --squash</code>, <code>rebase</code>, <code>reset</code>, <code>cherry-pick</code> etc.</p><p>ğŸ”— <strong>Maintain link between prompts and code</strong> - there is valuable context and requirements in team promptsâ€”preserve them alongside code.</p><p>ğŸš€ <strong>Git-native + Fast</strong> - <code>git-ai</code> is built on git plumbing commands. Negligible impact even in large repos (&lt;100ms). Tested in <a href="https://github.com/chromium/chromium">Chromium</a>.</p></blockquote><p><strong>NOTE</strong>: I have no affiliation with git-ai, but happily applaud their efforts, go check emâ€™ out! <a href="https://github.com/git-ai-project/git-ai">github.com/git-ai-project/git-ai</a></p><h2 id="github-pr-interface-support">Github PR interface Support</h2><h3 id="why-focus-on-pull-requests">Why Focus on Pull Requests</h3><p>To experimentally work towards a developer friendly solution, I wanted to try dropping this tooling into a common point of convergence within collaborative version control workflows; <em>Github Pull Requests</em></p><h3 id="existing-gitai-integrations-with-vscode">Existing Gitâ€‘AI Integrations with VSCode</h3><p>git-ai comes with many integrations, and even has an <a href="https://github.com/git-ai-project/git-ai/blob/main/specs/git_ai_standard_v3.0.0.md">RFC v3.0</a>, so other tooling providers may implement it themselves. <strong>The VSCode integration</strong> works very well. AI contributed code is given a gutter highlight, and upon line selectshows the model responsible for said ai generated code, long-hovering provides even more context.</p><figure><img src="https://blog.rbby.dev/github-ai-contribution-blame-for-pull-requests/git-ai-vscode-scrn.webp" alt="git ai vscode" title="git ai vscode" width="800"/><figcaption>AI-contributed code highlighted in VSCode using the git-ai extension.</figcaption></figure><h3 id="extending-the-github-pr-experience">Extending the GitHub PR Experience</h3><p>To recreate this editor/code-view highlighting, as well as provide human-vs-ai percentage metering in the Github PR experience, I forked an existing github extended plugin <a href="https://github.com/refined-github/refined-github">github-refined</a> into <a href="https://github.com/rbbydotdev/refined-github-with-ai-pr">refined-github-ai-pr</a> This plugin has all the features of the prior, even allowing you to toggle this ai contribution blaming feature on and off in the options (<em>Be sure to check out the screenshots below</em>)</p><figure><img src="https://blog.rbby.dev/github-ai-contribution-blame-for-pull-requests/light-scrn.webp" alt="light mode screenshot" title="light mode screenshot" width="800"/><figcaption>GitHub PR with AI contribution annotations in light mode.</figcaption></figure><figure><img src="https://blog.rbby.dev/github-ai-contribution-blame-for-pull-requests/dark-scrn.webp" alt="dark mode screenshot" title="dark mode screenshot" width="800"/><figcaption>GitHub PR with AI contribution annotations in dark mode.</figcaption></figure><h3 id="more-on-git-ai-tooling">More on Git-Ai Toolingâ€¦</h3><p>Although there is currently no official support from git-ai (as of Jan 2026) for extending the Github PR interface with Git-ai annotations. There is an <a href="https://github.com/git-ai-project/git-ai?tab=readme-ov-file#installing-the-stats-bot-early-access">early access feature: <strong>Stat Bot</strong></a> - to â€œAggregate git-ai data at the PR, developer, repository and organization levelsâ€ It may be worth it for you to check out and could serve as an excellent way to support the creators of git-ai</p><h3 id="caveats">Caveats</h3><p>One <strong>Major Caveat</strong> with <code>refined-github-with-ai-pr</code>, is that it relies on augmenting Githubâ€™s HTML via classes, which could very well change without notice, breaking this plugin.</p><p>This plugin serves as a beta and prototype, to fuel the conversation of what working with these new tools might look like; <em>and I encourage community members to join the conversation.</em> Maybe github will work towards adding this themselves in the future. Please comment on this post in hackernews or open an issue for <a href="https://github.com/rbbydotdev/refined-github-with-ai-pr/issues">refined-github-ai-pr</a> Iâ€™d love to hear what youâ€™re thinking!</p></div></article></div></div>
  </body>
</html>
