<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xorvoid.com/forsp.html">Original</a>
    <h1>Forsp: A Forth&#43;Lisp Hybrid Lambda Calculus Language</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

<p>Recently I&#39;ve discovered a very interesting language / realization of the Lambda Calculus.
I was unable to find any other language like it, which I find quite surprising. In hindsight, the language
seems obvious and natural. And the language keeps surprising me. I say &#34;discovered&#34; in the same sense that
Paul Graham says that McCarthy &#34;discovered Lisp&#34; <a href="https://xorvoid.com/jmc.pdf">(link)</a>.</p>
<p>It&#39;s a hybrid language combining Forth and Lisp, so naturally it&#39;s called Forsp (<a href="https://github.com/xorvoid/forsp/tree/main">code</a>)!</p>
<p>Forsp has:</p>
<ul>
<li>An S-Expression syntax like Lisp</li>
<li>Function abstraction like Lisp</li>
<li>Function application like Forth</li>
<li>An environment structure like Lisp</li>
<li>Lexically-scoped closures like Lisp (Scheme)</li>
<li>Cons-cells / lists / atoms like Lisp</li>
<li>A value/operand stack like Forth</li>
<li>An ability to express the Lambda Calculus</li>
<li>A Call-By-Push-Value evaluation order</li>
<li>Only 3 syntax special forms: &#39; ^ $</li>
<li>Only 1 eval-time special form: quote</li>
<li>Only 10 primitive functions need to self-implement</li>
<li>Ability to self-implement in very little code</li>
</ul>
<p>It&#39;s evaluator is very simple. I suspect simpler than a McCarthy Lisp <em>eval()</em> function, but I haven&#39;t
defined a &#34;simplicity function&#34;, so you can be the judge.</p>
<p>In contrast to Lisp, <em>apply()</em> is trivial in Forsp, and instead we have a core function called <em>compute()</em></p>
<h2>Computation</h2>
<p>Computation processes a list of <em>instructions</em> that work like a Forth.</p>
<h3>Application</h3>
<p>An example:</p>
<pre><code>  foo bar
</code></pre>
<p>Semantically, this means:</p>
<ol>
<li>call <code>foo</code></li>
<li>call <code>bar</code></li>
</ol>
<p>Functions manipulate an operand/value stack implicitly like Forth. Therefore, operationally they take no formal
arguments and return no values. However, semantically, they can be viewed as pure functions with <code>stack -&gt; stack</code>
signatures: take the stack as an argument and return a new stack.</p>
<h3>Special Forms</h3>
<p>There are 3 syntactic special forms, but only 1 is special at evaluation-time.</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Parsed as</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;foo</code></td>
<td><code>quote foo</code></td>
<td>The quoted literal (foo) is retained as-is and pushed to the stack</td>
</tr>
<tr>
<td><code>$foo</code></td>
<td><code>quote foo pop</code></td>
<td>A value will be popped from the stack and bound to &#34;foo&#34; in the environment</td>
</tr>
<tr>
<td><code>^foo</code></td>
<td><code>quote foo push</code></td>
<td>The name &#34;foo&#34; will be resolved in current environment and pushed to the stack</td>
</tr>
</tbody>
</table>
<p>As you can see, <code>&#34;quote&#34;</code> is the only form that requires special handling by the evaluator. Both <code>&#34;pop&#34;</code> and <code>&#34;push&#34;</code>
can be implemented as ordinary built-ins.</p>
<p>The syntax forms are not strictly required, but they make coding much more manageable.</p>
<h3>Thunking and Forcing</h3>
<pre><code>()
</code></pre>
<p>In Forsp, parenthesis grouping is used as a thunking operator.</p>
<p>As an example:</p>
<pre><code>(foo bar)
</code></pre>
<p>is the thunked-computation of:</p>
<pre><code>foo bar
</code></pre>
<p>A thunk is pushed to the stack like any other value. Thunks can be forced by using the <code>force</code> term (see [1]).
The <code>force</code> term pops a value from the stack and forces the computation.
This means that:</p>
<pre><code>(foo bar) force
</code></pre>
<p>is the same computation as:</p>
<pre><code>foo bar
</code></pre>
<p>Similarly:</p>
<pre><code>^a force
</code></pre>
<p>is the same computation as just</p>
<pre><code>a
</code></pre>
<p>Furthermore, thunks are closures. They bind the current environment on creation.</p>
<p>This means that in the following:</p>
<pre><code>(fn) &#39;a $fn force
</code></pre>
<p>We (1) thunk a computation involving <code>fn</code>, (2) rebind <code>fn</code> to <code>a</code>, (3) force the thunk.</p>
<p>The computation will use the original <code>fn</code> rather than the re-bound <code>fn</code></p>
<h3>What else?</h3>
<p>That&#39;s all. Seems too simple?</p>
<p>We&#39;ll it&#39;s shockingly expressive. Let&#39;s demonstrate!</p>
<h2>Lambda Calculus</h2>
<p>Forsp can express the lambda calculus via very simple re-write/re-ordering rules.</p>
<h3>Abstraction</h3>
<p>In Lambda Calculus, an abstraction is written as:</p>
<pre><code>λx.M
</code></pre>
<p>where <code>x</code> is a variable bound on application and <code>M</code> is some body, possibly using <code>x</code></p>
<p>In Forsp, we can express this as:</p>
<pre><code>($x M)
</code></pre>
<h3>Application</h3>
<p>In Lambda Calculus, an application is written as:</p>
<pre><code>MN
</code></pre>
<p>where <code>M</code> and <code>N</code> are two different terms and we&#39;re applying <code>M</code> to <code>N</code></p>
<p>In Forsp, this is similar but transposed:</p>
<pre><code>^N M
</code></pre>
<p>Notice also that we use <code>^N</code> because we don&#39;t wish to apply <code>N</code> at this moment</p>
<p>Let&#39;s translate some more complicated lambda terms:</p>
<pre><code>TRUE  := λx.λy.x
FALSE := λx.λy.y
IF    := λp.λt.λf.(p t f)
IF TRUE 1 2
</code></pre>
<p>In Forsp (direct translation):</p>
<pre><code>(
  ($x $y ^x) $true
  ($x $y ^y) $false
  ($p $x $y ^y ^x p) $if
  2 1 ^true if
)
</code></pre>
<p>After execution, <code>1</code> will be the only value left on the stack.</p>
<p>You can check by inserting the following after the <code>if</code>:</p>
<pre><code>stack print
</code></pre>
<p>This is a very handy debugging code sequence.</p>
<h3>Binding Names</h3>
<p>Notice that the pattern:</p>
<pre><code>(stuff here) $name
... SNIP ...
</code></pre>
<p>is used to bind names to function closures. The thunk is pushed after the
closure is bound and then the <code>$name</code> operation pops it back off the stack and binds
the name so we can use it.</p>
<p>This name-bind sequence is equivalent to the following lambda-calculus form:</p>
<pre><code>(λname.(
  ... SNIP ...
))
λ.(stuff here)
</code></pre>
<p>which could be written more directly/verbosely in Forsp as:</p>
<pre><code>(
  (stuff here)
  ($name
    ... SNIP ...
  ) force
)
</code></pre>
<h2>Call-By-Push-Value (CBPV)</h2>
<p>Most languages based on Lambda Calculus have to contend with a choice between Normal Order Evaluation (Call-By-Value,CBV) or Applicative-Order (Call-By-Name,CBN).
Eager languages (most of them) are CPV and Lazy languages (notably Haskell) are CBN.
But Forsp is neither, it is Call-By-Push-Value (CBPV).</p>
<p>CBPV treats lambda variable binding as being &#34;popped&#34; and application arguments as being &#34;pushed&#34;. Further, there is
a concept of &#34;thunking&#34; and &#34;forcing&#34;. This should sound familiar, Forsp is inspired by Paul Levy&#39;s <a href="https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf">CBPV work</a>.</p>
<p>In fact, while reading about CBPV, I couldn&#39;t help but think &#34;That&#39;s Just Forth!&#34;, and thus Forsp was born.</p>
<p>The very interesting upshot of this is that Forsp can have the determinism/eagerness nature of a CBV language when
desired, but also the deferred/lazy nature of a CBN language when useful.</p>
<p>Here&#39;s an example of this, defining a block-structured <code>if</code>:</p>
<pre><code>(
  ; NOTE: &#34;cswap&#34; is a &#34;conditional swap&#34; primitive.
  ;       It consumes a &#34;cond&#34; argument and if it&#39;s equal to the atom &#34;t&#34;, then it performs a swap
  ;       on the top two elements of the stack

  ; Explanation:
  ;   (1) conditionally swap the true and false blocks, (2) drop the unused one, (3) force the remaining one

  (cswap $_ force) $if

  (&#39;false print)
  (&#39;true print)
  &#39;t if
)
</code></pre>
<p>This code only prints &#34;true&#34;, which shows that the false case never executed.</p>
<p>But, this is just a simple case, the full power is much more.</p>
<h2>Recursion</h2>
<p>In lambda calculus, achieving recursive functions can be cumbersome since lambda-abstractions
don&#39;t have a way to refer to themselves. In Lisp, this leads to solutions like &#34;LABEL&#34;. Usually, an
implementation includes some special-form to help with it.</p>
<p>Forsp has no such special-form. It solves the issue the same way the Lambda Calculus does: a fixpoint combinator, the Y Combinator.</p>
<p>In Lambda Calculus:</p>
<pre><code>Y := λf.(λx.f(x x))(λx.f(x x))
Yg = g(Yg) = g(g(Yg)) = g(g(g(Yg))) = ...
</code></pre>
<p>In CPV languages, the Y-Combinator leads to infinite recursion and cannot be used.</p>
<p>But, Forsp is CBPV, so it actually can:</p>
<pre><code>;; Y-Combinator
(
  ($f
    ($x (^x x) f)
    ($x (^x x) f)
    force
  ) $Y
)
</code></pre>
<p>We can use it to define a classic recursive factorial as:</p>
<pre><code>(
 ; ... SNIP ... Assuming &#34;Y&#34; and &#34;if&#34; are defined previously

 ($g (^g Y)) $rec  ; syntax sugar for applying the Y-Combinator

 ($self $n
    (^n 1 - self ^n *) 1 0 ^n eq if
 ) rec $factorial

  5 factorial print
)
</code></pre>
<p>Which will print <code>&#34;120&#34;</code> as desired. Notice that we defined a little <code>&#34;rec&#34;</code> helper function. This makes
the syntax similar to the ML <code>&#34;let rec&#34;</code> syntax.</p>
<h2>Stack Languages are Confusing</h2>
<p>So you say &#34;stack languages are confusing and backwards&#34;? Well we can fix that too.
Take our &#34;if&#34; construct.</p>
<p>Currently we write:</p>
<pre><code>(
  ^false_block
  ^true_block
  ^condition
  if
)
</code></pre>
<p>Instead we&#39;d prefer something like:</p>
<pre><code>(
  ^if (condition computation)
    ^true_block
    ^false_block
  endif
)
</code></pre>
<p>Let&#39;s do it!</p>
<pre><code>(
  (force cswap $_ force)       $if
  ($f $t $c $fn ^f ^t ^c fn)   $endif

  ^if (0 1 eq)
    (&#39;true print)
    (&#39;false print)
  endif
)
</code></pre>
<p>Much better.</p>
<p>With this, we can write a nicer &#34;factorial&#34;:</p>
<pre><code>(
 ; ... SNIP ... Assuming previously defined functions

 ($self $n
    ^if (^n 0 eq) 1
      (^n 1 - self ^n *)
    endif
 ) rec $factorial

  5 factorial print
)
</code></pre>
<h2>Syntax Parsing</h2>
<p>Syntax is S-Expressions, but like Lisp there is a tiny modification for special-forms.
In Lisp, &#34;&#39;something&#34; is converted to &#34;(quote something)&#34; by the parser. In Forsp, we
convert somewhat similarly:</p>
<pre><code>&#39;something =&gt; quote something
^something =&gt; quote something push
$something =&gt; quote something pop
</code></pre>
<p>Similar to Lisp, the Forsp parser also skips line-comments that start with &#34;;&#34;</p>
<h2>Implementation</h2>
<p>The implementation is simple and ~600 lines of clean C code. It&#39;s effectively a Lisp interpreter
implementation with different semantics. That is to say, Forsp has atoms, interning, cons cells,
environment, read, print, eval, etc.</p>
<p>The core &#34;eval/compute&#34; routines are given below to demonstrate their stunning simplicity:</p>
<pre><code>void eval(obj_t *expr, obj_t **env);

void compute(obj_t *comp, obj_t *env)
{
  while (comp != state-&gt;nil) {
    // unpack
    obj_t *cmd  = car(comp);
    comp = cdr(comp);

    if (cmd == state-&gt;atom_quote) {
      if (comp == state-&gt;nil) FAIL(&#34;Expected data following a quote form&#34;);
      push(car(comp));
      comp = cdr(comp);
      continue;
    }

    // atoms and (...) get ordinary eval
    eval(cmd, &amp;env);
  }
}

void eval(obj_t *expr, obj_t **env)
{
  if (IS_ATOM(expr)) {
    obj_t *val = env_find(*env, expr);
    if (IS_CLOS(val)) { // closure
      return compute(val-&gt;clos.body, val-&gt;clos.env);
    } else if (IS_PRIM(val)) { // primitive
      return val-&gt;prim.func(env);
    } else {
      return push(val);
    }
  } else if (IS_NIL(expr) || IS_PAIR(expr)) {
    return push(make_clos(expr, *env));
  } else {
    return push(expr);
  }
}
</code></pre>
<p>There are 10 core primitives (needed to self-implement):</p>
<pre><code>/* Core primitives */
void prim_push(obj_t **env) { push(env_find(*env, pop())); }
void prim_pop(obj_t **env)  { obj_t *k, *v; k = pop(); v = pop(); *env = env_define(*env, k, v); }
void prim_eq(obj_t **_)     { push(obj_equal(pop(), pop()) ? state-&gt;atom_true : state-&gt;nil); }
void prim_cons(obj_t **_)   { obj_t *a, *b; a = pop(); b = pop(); push(make_pair(a, b)); }
void prim_car(obj_t **_)    { push(car(pop())); }
void prim_cdr(obj_t **_)    { push(cdr(pop())); }
void prim_cswap(obj_t **_)  { if (pop() == state-&gt;atom_true) { obj_t *a, *b; a = pop(); b = pop(); push(a); push(b); } }
void prim_tag(obj_t **_)    { push(make_num(pop()-&gt;tag)); }
void prim_read(obj_t **_)   { push(read()); }
void prim_print(obj_t **_)  { print(pop()); }
</code></pre>
<p>Some extra &#34;non-essential&#34; primitives are also included:</p>
<pre><code>void prim_stack(obj_t **_) { push(state-&gt;stack); }
void prim_env(obj_t **env) { push(*env); }
void prim_sub(obj_t **_)   { obj_t *a, *b; b = pop(); a = pop(); push(make_num(obj_i64(a) - obj_i64(b))); }
void prim_mul(obj_t **_)   { obj_t *a, *b; b = pop(); a = pop(); push(make_num(obj_i64(a) * obj_i64(b))); }
void prim_nand(obj_t **_)  { obj_t *a, *b; b = pop(); a = pop(); push(make_num(~(obj_i64(a) &amp; obj_i64(b)))); }
void prim_lsh(obj_t **_)   { obj_t *a, *b; b = pop(); a = pop(); push(make_num(obj_i64(a) &lt;&lt; obj_i64(b))); }
void prim_rsh(obj_t **_)   { obj_t *a, *b; b = pop(); a = pop(); push(make_num(obj_i64(a) &gt;&gt; obj_i64(b))); }
</code></pre>
<p>And, as any good Forth has low-level functions, so does Forsp (if desired):</p>
<pre><code>#if USE_LOWLEVEL
/* Low-level primitives */
void prim_ptr_state(obj_t **_)    { push(make_num((int64_t)state)); }
void prim_ptr_read(obj_t **_)     { push(make_num(*(int64_t*)obj_i64(pop()))); }
void prim_ptr_write(obj_t **_)    { obj_t *a, *b; b = pop(); a = pop(); *(int64_t*)obj_i64(a) = obj_i64(b); }
void prim_ptr_to_obj(obj_t **_)   { push((obj_t*)obj_i64(pop())); }
void prim_ptr_from_obj(obj_t **_) { push(make_num((int64_t)pop())); }
#endif
</code></pre>
<p>There&#39;s really not much else besides standard Lisp implementation details.</p>
<p>The full source is <a href="https://github.com/xorvoid/forsp/blob/0c2a5c3eb5029b262b2696f89cc5f5bd9a8910e3/forsp.c">here</a></p>
<h2>Self-Evaluator</h2>
<p>Naturally, A Lisp needs to be able to implement itself elegantly.</p>
<p>Forsp succeeds here too. The core &#34;eval/compute&#34; routines are given below (in just 18 non-comment lines!):</p>
<pre><code>  ; compute [$comp $stack $env -&gt; $stack]
  ($compute $eval
    ^if (dup is-nil) (rot $_ $_) ( ; false case: return $stack
      stack-pop
      ^if (dup &#39;quote eq)
        ($_ stack-pop rot swap stack-push swap ^eval compute)
        (swap $comp eval ^comp ^eval compute) endif
    ) endif
  ) rec $compute

  ; eval: [$expr $stack $env -&gt; $stack $env]
  ($eval
    ^if (dup is-atom) (
      over2 swap env-find dup $callable
      ^if (dup is-closure) (swap $stack cdr unpack-closure ^stack swap ^eval compute)
      (^if (dup is-clos)   (force)
                           (stack-push)  endif) endif)
    (^if (dup is-list)
      (over2 swap make-closure stack-push)
      (stack-push) endif) endif
  ) rec $eval
</code></pre>
<p>The full implementation with all utility functions, type-checking, recursion, environment, stack operations,
closure operations, compute/eval, and primitives is under 80 lines of Forsp code!</p>
<p>It can be found <a href="https://github.com/xorvoid/forsp/blob/0c2a5c3eb5029b262b2696f89cc5f5bd9a8910e3/examples/forsp.fp">here</a></p>
<h2>Unexpected Discoveries</h2>
<p>I stumbled across Forsp while thinking about CBPV and minimalist bootstrapping languages (unrelated project). It kind of
just appeared and then has continued to surprise me. In many ways it feels more fundamental than Lisp or Forth. It
appears to be both simpler than Lisp and more powerful than Forth.</p>
<p>A fascinating thing about Forsp is that is seems to naturally express multiple computation fundamentals. For starters, a
stack is a <em>very</em> natural computational structure. For example: a Turing Machine can be viewed as two-stacks and a
process moving values between them. Between the value stack and cons&#39;ing lists, it often feels like exactly this.
On the other side, it expresses lambda calculus quite comfortably, and the variable binding syntax is
naturally similar to A-Normal Form.</p>
<p>It&#39;s also curious that Forsp programs can be viewed as either as one big long list of instructions (much like a Turing Machine)
or as a realization of Lambda Calculau.</p>
<p>The addition of variables to a Forth style language is very helpful. Rather than dealing with a complicated stack
dance, you can just do <code>($x do a bunch of things ^x USE)</code>. This pattern has occurred enough that I&#39;ve started calling it
<code>&#34;value lifting&#34;</code>.</p>
<p>Because of the stack+variable combination, Forsp code can express the same code in multiple ways:</p>
<p>Variable-binding / sequenced / imperative:</p>
<pre><code>($a $b $c
   ^c ^b * $result
   ^a ^result + $result
   ^result
) $multiply_add
</code></pre>
<p>Functional / Point-free / Pipelined / Data-flow</p>
<pre><code>(* +) $multiply_add
</code></pre>
<p>Even though this example makes the later look more elegant, both forms are quite useful. Often the later
form is hard to achieve so elegantly in practice.</p>
<p>Other discoveries that surprised me:</p>
<ul>
<li>Being able to actually use the Y-combinator for recursion</li>
<li>That &#34;force&#34; didn&#39;t have to be a primitive</li>
<li>Core stack manipulation operations can be written in Forsp (not generally doable in Forth)</li>
<li>Currying and partial evaluation work nicely</li>
<li>Originally $ and ^ were also special eval forms, but they didn&#39;t need to be</li>
<li>The stack is just an ordinary cons list (used implicitly just like the environment)</li>
<li>CBPV is actually pretty useful</li>
</ul>
<p>I suspect there are more discoveries. Let me know if you find some.</p>
<h2>Conclusion</h2>
<p>There&#39;s so much more I could say, but this seems like a good time to wrap up.</p>
<p>If you&#39;re interested in learning more, the repository is <a href="https://github.com/xorvoid/forsp/tree/main">here</a>.</p>
<p>There are many good examples to explore <a href="https://github.com/xorvoid/forsp/tree/main/examples">here</a>.</p>
<p>And, if you enjoyed this, you can:</p>
<ul>
<li><a href="https://xorvoid.com/index.html">Read Other Articles</a></li>
<li><a href="https://xorvoid.com/rss.xml">Follow My RSS Feed</a></li>
<li><a href="https://www.buymeacoffee.com/xorvoid">Buy Me a Coffee</a></li>
</ul>
<h3>Footnotes</h3>
<p>[1] <code>&#34;force&#34;</code> is not a primitive. But, it can be easily defined as:</p>
<pre><code>($x x) $force
</code></pre>
  </div></div>
  </body>
</html>
