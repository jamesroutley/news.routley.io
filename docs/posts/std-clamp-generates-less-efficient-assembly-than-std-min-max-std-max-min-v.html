<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://1f6042.blogspot.com/2024/01/stdclamp-still-generates-less-efficient.html">Original</a>
    <h1>Std: Clamp generates less efficient assembly than std:min(max,std:max(min,v))</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-2600092658134636588" itemprop="description articleBody">
<p>I originally wrote this blog post in 2019 (or maybe 2018 - my timestamps say that it was written before 1 May 2019). Recently I decided to revisit my old blog and found that <code>std::clamp</code> still generates less efficient assembly than <code>std::min(max, std::max(min, v))</code> even on the latest versions of GCC (13.2) and Clang (17.0.1).</p>
<p>Here’s my old blog post:</p>
<p>Contents:</p>
<ul>
<li><a href="#ternary">Ternary</a></li>
<li><a href="#using-intermediate-values">Using intermediate values</a></li>
<li><a href="#using-stdmin-and-stdmax">using std::min and std::max</a></li>
<li><a href="#using-stdclamp">Using std::clamp</a></li>
</ul>
<p>Let’s say you want to clamp a value v between 2 values, min and max. If v is greater than max, return max. If v is smaller than min, return min. Otherwise return v.</p>

<p>Implementing it directly as per the description:</p>
<pre><code><span>double</span> <span>clamp</span><span>(</span><span>double</span> v<span>,</span> <span>double</span> min<span>,</span> <span>double</span> max<span>)</span><span>{</span>
    <span>return</span> v <span>&lt;</span> min<span>?</span> min <span>:</span> v <span>&gt;</span> max<span>?</span> max <span>:</span> v<span>;</span>
<span>}</span>
</code></pre>
<p>gcc 8.2:</p>
<pre><code>clamp(double, double, double):
        comisd  xmm1, xmm0
        ja      .L2
        minsd   xmm2, xmm0
        movapd  xmm1, xmm2
.L2:
        movapd  xmm0, xmm1
        ret
</code></pre>
<p>One branch instruction.</p>
<p>clang 7.0:</p>
<pre><code>clamp(double, double, double):                            # @clamp(double, double, double)
        minsd   xmm2, xmm0
        cmpltsd xmm0, xmm1
        movapd  xmm3, xmm0
        andnpd  xmm3, xmm2
        andpd   xmm0, xmm1
        orpd    xmm0, xmm3
        ret
</code></pre>
<p>Branchless.</p>

<p>From this stackoverflow answer: <a href="https://stackoverflow.com/questions/427477/fastest-way-to-clamp-a-real-fixed-floating-point-value">https://stackoverflow.com/questions/427477/fastest-way-to-clamp-a-real-fixed-floating-point-value</a></p>
<pre><code><span>double</span> <span>clamp</span><span>(</span><span>double</span> v<span>,</span> <span>double</span> min<span>,</span> <span>double</span> max<span>)</span><span>{</span>
    <span>double</span> out <span>=</span> v <span>&gt;</span> max <span>?</span> max <span>:</span> v<span>;</span>
    <span>return</span> out <span>&lt;</span> min <span>?</span> min <span>:</span> out<span>;</span>
<span>}</span>
</code></pre>
<p>gcc 8.2:</p>
<pre><code>clamp(double, double, double):
        minsd   xmm2, xmm0
        maxsd   xmm1, xmm2
        movapd  xmm0, xmm1
        ret
</code></pre>
<p>clang 7.0:</p>
<pre><code>clamp(double, double, double):                            # @clamp(double, double, double)
        minsd   xmm2, xmm0
        maxsd   xmm1, xmm2
        movapd  xmm0, xmm1
        ret
</code></pre>
<p>Identical output. Much better than before. Can we do better?</p>

<p>This is the idiomatic way to do clamp in C++ (and most other languages):</p>
<pre><code><span>#<span>include</span> <span>&lt;algorithm&gt;</span></span>
<span>double</span> <span>clamp</span><span>(</span><span>double</span> v<span>,</span> <span>double</span> min<span>,</span> <span>double</span> max<span>)</span><span>{</span>
    <span>return</span> std<span>::</span><span>min</span><span>(</span>max<span>,</span> std<span>::</span><span>max</span><span>(</span>min<span>,</span> v<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>gcc 8.2:</p>
<pre><code>clamp(double, double, double):
        maxsd   xmm0, xmm1
        minsd   xmm0, xmm2
        ret
</code></pre>
<p>clang 7.0:</p>
<pre><code>clamp(double, double, double):                            # @clamp(double, double, double)
        maxsd   xmm0, xmm1
        minsd   xmm0, xmm2
        ret
</code></pre>
<p>Also seems to generate the best code.</p>

<pre><code><span>#<span>include</span> <span>&lt;algorithm&gt;</span></span>
<span>double</span> <span>clamp</span><span>(</span><span>double</span> v<span>,</span> <span>double</span> min<span>,</span> <span>double</span> max<span>)</span><span>{</span>
    <span>return</span> std<span>::</span><span>clamp</span><span>(</span>v<span>,</span> min<span>,</span> max<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>gcc 8.2:</p>
<pre><code>clamp(double, double, double):
        comisd  xmm1, xmm0
        ja      .L2
        minsd   xmm2, xmm0
        movapd  xmm1, xmm2
.L2:
        movapd  xmm0, xmm1
        ret
</code></pre>
<p>clang 7.0:</p>
<pre><code>clamp(double, double, double):                            # @clamp(double, double, double)
        minsd   xmm2, xmm0
        cmpltsd xmm0, xmm1
        movapd  xmm3, xmm0
        andnpd  xmm3, xmm2
        andpd   xmm0, xmm1
        orpd    xmm0, xmm3
        ret
</code></pre>
<p>Not very efficient.</p>
<p>EDIT: It’s been almost 5 years since I originally wrote this article, so I decided to try again using the latest versions of GCC and Clang:</p>
<p>gcc 13.2:</p>
<pre><code>clamp(double, double, double):
        maxsd   xmm1, xmm0
        minsd   xmm2, xmm1
        movapd  xmm0, xmm2
        ret
</code></pre>
<p>clang 17.0.1:</p>
<pre><code>clamp(double, double, double):                            # @clamp(double, double, double)
        maxsd   xmm1, xmm0
        minsd   xmm2, xmm1
        movapd  xmm0, xmm2
        ret
</code></pre>
<p>Still not the most efficient - it uses one more instruction than the <code>std::min(max, std::max(min, v))</code> implementation.</p>
<p>But how does the fastest implementation work you ask? Going through the code line by line:</p>
<pre><code>clamp(double, double, double):
        maxsd   xmm0, xmm1
        minsd   xmm0, xmm2
        ret
</code></pre>
<p>The <code>maxsd xmm0, xmm1</code> puts the max value of xmm0 and xmm1 into xmm0.</p>
<p>The <code>minsd xmm0, xmm2</code> puts the min value of xmm0 and xmm2 into xmm0.</p>
<p>Thus, after the first line, xmm0 contains the max of the lower bound and the value.</p>
<p>And after the second line, xmm0 contains the min of the upper bound and the previous result.</p>
<p>But let’s step through with gdb to confirm.</p>
<p>Source code:</p>
<pre><code><span>#<span>include</span> <span>&lt;algorithm&gt;</span></span>
<span>double</span> <span>__attribute__</span> <span>(</span><span>(</span>noinline<span>)</span><span>)</span> <span>clamp</span><span>(</span><span>double</span> v<span>,</span> <span>double</span> min<span>,</span> <span>double</span> max<span>)</span><span>{</span>
    <span>return</span> std<span>::</span><span>min</span><span>(</span>max<span>,</span> std<span>::</span><span>max</span><span>(</span>min<span>,</span> v<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>volatile</span> <span>double</span> x<span>,</span> min<span>,</span> max<span>;</span>
    x <span>=</span> <span>1653</span><span>;</span>
    min <span>=</span> <span>1776</span><span>;</span>
    max <span>=</span> <span>1729</span><span>;</span>
    <span>return</span> <span>clamp</span><span>(</span>x<span>,</span> min<span>,</span> max<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>gdb logs:</p>
<p>Before running maxsd:</p>
<pre><code>│  &gt; 0x555555555180 &lt;_Z5clampddd&gt;                    maxsd  %xmm1,%xmm0                                                                                       │
│    0x555555555184 &lt;_Z5clampddd+4&gt;                  minsd  %xmm2,%xmm0                                                                                       │
│    0x555555555188 &lt;_Z5clampddd+8&gt;                  ret                                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7dca7 In: clamp                                                                                              L254  PC: 0x555555555180
xmm0           {v8_bfloat16 = {0x0, 0x0, 0xd400, 0x4099, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0xd400, 0x4099, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x4099
d400, 0x0, 0x0}, v2_double = {0x4099d40000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xd4, 0x99, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int1
6 = {0x0, 0x0, 0xd400, 0x4099, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x4099d400, 0x0, 0x0}, v2_int64 = {0x4099d40000000000, 0x0}, uint128 = 0x4099d40000000000}

xmm1           {v8_bfloat16 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b
c000, 0x0, 0x0}, v2_double = {0x409bc00000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int1
6 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409bc000, 0x0, 0x0}, v2_int64 = {0x409bc00000000000, 0x0}, uint128 = 0x409bc00000000000}

xmm2           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}
</code></pre>
<p>After running maxsd but before running minsd:</p>
<pre><code>│    0x555555555180 &lt;_Z5clampddd&gt;                    maxsd  %xmm1,%xmm0                                                                                       │
│  &gt; 0x555555555184 &lt;_Z5clampddd+4&gt;                  minsd  %xmm2,%xmm0                                                                                       │
│    0x555555555188 &lt;_Z5clampddd+8&gt;                  ret                                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7dca7 In: clamp                                                                                              L4    PC: 0x555555555184
xmm0           {v8_bfloat16 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b
c000, 0x0, 0x0}, v2_double = {0x409bc00000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int1
6 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409bc000, 0x0, 0x0}, v2_int64 = {0x409bc00000000000, 0x0}, uint128 = 0x409bc00000000000}

xmm1           {v8_bfloat16 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b
c000, 0x0, 0x0}, v2_double = {0x409bc00000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int1
6 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409bc000, 0x0, 0x0}, v2_int64 = {0x409bc00000000000, 0x0}, uint128 = 0x409bc00000000000}

xmm2           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}
</code></pre>
<p>After running minsd:</p>
<pre><code>│    0x555555555180 &lt;_Z5clampddd&gt;                    maxsd  %xmm1,%xmm0                                                                                       │
│    0x555555555184 &lt;_Z5clampddd+4&gt;                  minsd  %xmm2,%xmm0                                                                                       │
│B+&gt; 0x555555555188 &lt;_Z5clampddd+8&gt;                  ret                                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7dca7 In: clamp                                                                                              L5    PC: 0x555555555188
xmm0           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}

xmm1           {v8_bfloat16 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b
c000, 0x0, 0x0}, v2_double = {0x409bc00000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int1
6 = {0x0, 0x0, 0xc000, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409bc000, 0x0, 0x0}, v2_int64 = {0x409bc00000000000, 0x0}, uint128 = 0x409bc00000000000}

xmm2           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}
</code></pre>
<p>And how does the value from xmm0 get placed into eax? The answer is the cvttsd2si instruction:</p>
<pre><code>│    0x555555555080 &lt;main()+64&gt;      call   0x555555555180 &lt;_Z5clampddd&gt;                                                                                      │
│    0x555555555085 &lt;main()+69&gt;      add    $0x20,%rsp                                                                                                        │
│  &gt; 0x555555555089 &lt;main()+73&gt;      cvttsd2si %xmm0,%eax                                                                                                     │
│    0x55555555508d &lt;main()+77&gt;      ret                                                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7dca7 In: main                                                                                               L12   PC: 0x555555555089
(gdb) i r eax xmm0
eax            0x55555040          1431654464
xmm0           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}



│    0x555555555080 &lt;main()+64&gt;      call   0x555555555180 &lt;_Z5clampddd&gt;                                                                                      │
│    0x555555555085 &lt;main()+69&gt;      add    $0x20,%rsp                                                                                                        │
│    0x555555555089 &lt;main()+73&gt;      cvttsd2si %xmm0,%eax                                                                                                     │
│  &gt; 0x55555555508d &lt;main()+77&gt;      ret                                                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7dca7 In: main                                                                                               L13   PC: 0x55555555508d
(gdb) i r eax xmm0
eax            0x6c1               1729
xmm0           {v8_bfloat16 = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v8_half = {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_float = {0x0, 0x409b04
00, 0x0, 0x0}, v2_double = {0x409b040000000000, 0x0}, v16_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x9b, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 =
 {0x0, 0x0, 0x400, 0x409b, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x409b0400, 0x0, 0x0}, v2_int64 = {0x409b040000000000, 0x0}, uint128 = 0x409b040000000000}
</code></pre>
<p>Pretty cool.</p>
<p>Anyway, I found it surprising that <code>std::clamp</code> still generates less efficient assembly than <code>std::min(max, std::max(min, v))</code> even on the latest versions of GCC (13.2) and Clang (17.0.1).</p>


</div></div>
  </body>
</html>
