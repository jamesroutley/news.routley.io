<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://snufk.in/blog/silly-compression.html">Original</a>
    <h1>Silly Image Compression Idea</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>An idea that I had a few days ago on twitter:</p>
<blockquote darkmode="" data-title="snufkin on Twitter" data-author="" cite="https://twitter.com/sn_fk_n/status/1510562695808000001">
  image compression algorithm that resizes to the smallest size an AI can still classify the image correctly
  
</blockquote>

<p>So I made a quick demo in python.</p>
<h2>Technical Stuff</h2>
<p>I started by implementing a quick class that defines an &#39;evaluator&#39;, or
something that classifies an image. Essentially just a wrapper around a
pre-trained model from <code>torchvision</code>.</p>
<div><pre><span></span><code><span>import</span> <span>torchvision.models</span> <span>as</span> <span>models</span>
<span>from</span> <span>torchvision</span> <span>import</span> <span>datasets</span><span>,</span> <span>transforms</span> <span>as</span> <span>T</span>


<span>class</span> <span>Evaluator</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>net</span> <span>=</span> <span>models</span><span>.</span><span>resnet152</span><span>(</span><span>pretrained</span><span>=</span><span>True</span><span>)</span>

        <span># transforms from torchvision docs</span>
        <span>self</span><span>.</span><span>transform</span> <span>=</span> <span>T</span><span>.</span><span>Compose</span><span>(</span>
            <span>[</span>
                <span>T</span><span>.</span><span>Resize</span><span>(</span><span>256</span><span>),</span>
                <span>T</span><span>.</span><span>CenterCrop</span><span>(</span><span>224</span><span>),</span>
                <span>T</span><span>.</span><span>ToTensor</span><span>(),</span>
                <span>T</span><span>.</span><span>Normalize</span><span>(</span><span>mean</span><span>=</span><span>[</span><span>0.485</span><span>,</span> <span>0.456</span><span>,</span> <span>0.406</span><span>],</span> <span>std</span><span>=</span><span>[</span><span>0.229</span><span>,</span> <span>0.224</span><span>,</span> <span>0.225</span><span>]),</span>
            <span>]</span>
        <span>)</span>

        <span># set model to eval</span>
        <span>self</span><span>.</span><span>net</span><span>.</span><span>eval</span><span>()</span>

    <span>def</span> <span>__call__</span><span>(</span><span>self</span><span>,</span> <span>image</span><span>):</span>
        <span>&#34;&#34;&#34;</span>
<span>        Returns predicted class for image</span>
<span>        &#34;&#34;&#34;</span>
        <span>transformed_image</span> <span>=</span> <span>self</span><span>.</span><span>transform</span><span>(</span><span>image</span><span>)</span><span>.</span><span>unsqueeze</span><span>(</span><span>0</span><span>)</span>
        <span>output</span> <span>=</span> <span>self</span><span>.</span><span>net</span><span>(</span><span>transformed_image</span><span>)</span>
        <span>_</span><span>,</span> <span>predicted</span> <span>=</span> <span>output</span><span>.</span><span>max</span><span>(</span><span>1</span><span>)</span>

        <span>return</span> <span>predicted</span>
</code></pre></div>

<p>This is fairly simple, load a pre-trained model (Resnet152, here for no
particular reason.) the transforms from the documentation and set the mode to
eval, since we aren&#39;t training. Then a quick method that applies those
transforms and takes the predicted class as the max.</p>
<p>This maybe isn&#39;t the smartest way to approach the predicted class as we will see
later, but this isn&#39;t a serious problem! It&#39;ll do for now.</p>
<p>The other component is the &#39;compressor&#39;. Used here extremely loosely (is
resizing &#39;compression&#39;, in some respects maybe), this implements an iterative
method that simply runs an iterative &#39;compression&#39; method and checks if the
evaluator&#39;s prediction has changed.</p>
<div><pre><span></span><code><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span><span>,</span> <span>abstractmethod</span>

<span>class</span> <span>Compressor</span><span>(</span><span>ABC</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>evaluator</span><span>):</span>
        <span>self</span><span>.</span><span>evaluator</span> <span>=</span> <span>evaluator</span>

    <span>@abstractmethod</span>
    <span>def</span> <span>iteration</span><span>(</span><span>self</span><span>,</span> <span>image</span><span>):</span>
        <span>pass</span>

    <span>def</span> <span>__call__</span><span>(</span><span>self</span><span>,</span> <span>image</span><span>):</span>
        <span>initial_prediction</span> <span>=</span> <span>self</span><span>.</span><span>evaluator</span><span>(</span><span>image</span><span>)</span>

        <span>iteration</span> <span>=</span> <span>previous_iteration</span> <span>=</span> <span>image</span>
        <span>iter_prediction</span> <span>=</span> <span>initial_prediction</span>

        <span>while</span> <span>iter_prediction</span> <span>==</span> <span>initial_prediction</span><span>:</span>
            <span>previous_iteration</span> <span>=</span> <span>iteration</span>
            <span>iteration</span> <span>=</span> <span>self</span><span>.</span><span>iteration</span><span>(</span><span>previous_iteration</span><span>)</span>
            <span>iter_prediction</span> <span>=</span> <span>self</span><span>.</span><span>evaluator</span><span>(</span><span>iteration</span><span>)</span>

        <span>return</span> <span>previous_iteration</span>
</code></pre></div>

<p>Using compressor as an abstract class means it&#39;s easy to implement just the
iteration.</p>
<div><pre><span></span><code><span>from</span> <span>PIL</span> <span>import</span> <span>Image</span>
<span>from</span> <span>random</span> <span>import</span> <span>randint</span>
<span>from</span> <span>io</span> <span>import</span> <span>BytesIO</span>
<span>from</span> <span>compressor</span> <span>import</span> <span>Compressor</span>

<span>class</span> <span>ResizeCompressor</span><span>(</span><span>Compressor</span><span>):</span>
    <span>def</span> <span>iteration</span><span>(</span><span>self</span><span>,</span> <span>image</span><span>):</span>
        <span>&#34;&#34;&#34;</span>
<span>        Returns a resized image that is (at most)</span>
<span>        10 pixels smaller in both directions</span>
<span>        &#34;&#34;&#34;</span>
        <span>current_size</span> <span>=</span> <span>image</span><span>.</span><span>size</span>
        <span>new_size</span> <span>=</span> <span>(</span><span>current_size</span><span>[</span><span>0</span><span>]</span> <span>-</span> <span>10</span><span>,</span> <span>current_size</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>10</span><span>)</span>
        <span># thumbnail preserves aspect ratio</span>
        <span>image</span><span>.</span><span>thumbnail</span><span>(</span><span>new_size</span><span>)</span>
        <span>return</span> <span>image</span>


<span>class</span> <span>JPEGCompressor</span><span>(</span><span>Compressor</span><span>):</span>
    <span>def</span> <span>iteration</span><span>(</span><span>self</span><span>,</span> <span>image</span><span>):</span>
        <span>buffer</span> <span>=</span> <span>BytesIO</span><span>()</span>
        <span>image</span><span>.</span><span>save</span><span>(</span><span>buffer</span><span>,</span> <span>&#34;JPEG&#34;</span><span>,</span> <span>quality</span><span>=</span><span>randint</span><span>(</span><span>0</span><span>,</span> <span>100</span><span>))</span>
        <span>compressed</span> <span>=</span> <span>Image</span><span>.</span><span>open</span><span>(</span><span>buffer</span><span>)</span>
        <span>return</span> <span>compressed</span>
</code></pre></div>

<p>In the first case, are we really &#39;compressing&#39;? Well we are &#39;encoding
information using fewer bits that the original&#39;, and it certainly is lossy.</p>
<p><img alt="resize example" src="https://snufk.in/blog/images/resize.jpg"/></p>
<p>I have also implemented a jpg compressor which maybe is more like what
compression actually is. This saves the image with a random quality level, which
whilst stochastic, does eventually accumulate the classic overly jpegged look.
This means that the final image may look different but does produce cool
effects.</p>
<p><img alt="jpeg example" src="https://snufk.in/blog/images/jpeg.jpg"/></p>
<h2>Philosophical Questions</h2>
<p>This opens a question around compression in general. Whilst formats like JPEG
are designed around human perception. What would image compression look like if
designed around other <em>things</em> perceptions? </p>
<p>In a world where data is processed by things that aren&#39;t human, why should we
settle for human-friendly representations of these data? In the same way that
JSON and XML might not be the greatest way to move data between services when
there&#39;s no requirement for human intervention (why use text-based formats when a
binary format might make more sense?). Why do we compress images for humans?</p>
<p>Surely there are other formats that similarly get the <strong>semantics</strong> of an image
(or other piece of media as it may be) across without being necessarily
human-friendly.</p>
<h2>Conclusion</h2>
<p>Whilst this scheme for &#39;compression&#39; is obviously silly, and definitely more
artistic than practical, we might consider it as maybe a decent tool for
thinking about other ways that we might want to encode semantic information?</p>
<p>In the future, changes could be made to consider the hierarchy of the classes,
or operate on thresholds of the changing outputs of the neural network.
Currently it changes only when the max class changes which leads to termination
where it changes label to something with a very similar semantic meaning (e.g.
&#39;Tiger Cat&#39; to &#39;Egyptian Cat&#39;). </p>
  </div></div>
  </body>
</html>
