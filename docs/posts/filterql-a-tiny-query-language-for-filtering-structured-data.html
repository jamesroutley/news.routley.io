<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/adamhl8/filterql">Original</a>
    <h1>Show HN: FilterQL â€“ A tiny query language for filtering structured data</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">

<p dir="auto">A tiny query language for filtering structured data ðŸš€</p>

<p dir="auto"><a href="https://git.io/typing-svg" rel="nofollow"><img src="https://camo.githubusercontent.com/3614ff21806137811605cb3a8b8d56d63f14ea4f0ce7d023033eb61d632ffd53/68747470733a2f2f726561646d652d747970696e672d7376672e64656d6f6c61622e636f6d3f666f6e743d4a6574427261696e732b4d6f6e6f2673697a653d3136266475726174696f6e3d333030302670617573653d37353030267643656e7465723d747275652677696474683d363930266865696768743d3235266c696e65733d2867656e72652b2533442533442b416374696f6e2b2537432537432b67656e72652b2533442533442b436f6d656479292b2532362532362b726174696e672b2533452533442b382e352b2537432b534f52542b726174696e672b64657363" alt="Typing SVG" data-canonical-src="https://readme-typing-svg.demolab.com?font=JetBrains+Mono&amp;size=16&amp;duration=3000&amp;pause=7500&amp;vCenter=true&amp;width=690&amp;height=25&amp;lines=(genre+%3D%3D+Action+%7C%7C+genre+%3D%3D+Comedy)+%26%26+rating+%3E%3D+8.5+%7C+SORT+rating+desc"/></a></p>
<hr/>
<p dir="auto">There are two main parts of this repository: the TypeScript library and the <a href="#language-specification">FilterQL language specification</a>. Implementations in other languages are more than welcome!</p>

<ul dir="auto">
<li><a href="#typescript-library">TypeScript Library</a>
<ul dir="auto">
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#a-more-realistic-example">A more realistic example</a></li>
<li><a href="#queries">Queries</a></li>
<li><a href="#operations">Operations</a></li>
<li><a href="#filterql-class"><code>FilterQL</code> Class</a></li>
<li><a href="#api-reference">API Reference</a></li>
</ul>
</li>
<li><a href="#language-specification">Language Specification</a>
<ul dir="auto">
<li><a href="#grammar">Grammar</a></li>
<li><a href="#comparison-operators-1">Comparison Operators</a></li>
<li><a href="#logical-operators-1">Logical Operators</a></li>
<li><a href="#match-all-1">Match-All</a></li>
<li><a href="#operations-1">Operations</a></li>
<li><a href="#syntax-rules">Syntax Rules</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>



<div dir="auto" data-snippet-clipboard-copy-content="bun add filterql
# or: npm install filterql"><pre>bun add filterql
<span><span>#</span> or: npm install filterql</span></pre></div>

<p dir="auto">Define a schema for your data and create a FilterQL instance:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { FilterQL } from &#34;filterql&#34;

// The schema determines what fields are allowed in the query
const schema = {
  title: { type: &#34;string&#34;, alias: &#34;t&#34; },
  year: { type: &#34;number&#34;, alias: &#34;y&#34; },
  monitored: { type: &#34;boolean&#34;, alias: &#34;m&#34; },
  rating: { type: &#34;number&#34; },
  genre: { type: &#34;string&#34; },
}

const filterql = new FilterQL({ schema })

const movies = [
  { title: &#34;The Matrix&#34;, year: 1999, monitored: true, rating: 8.7, genre: &#34;Action&#34; },
  { title: &#34;Inception&#34;, year: 2010, monitored: true, rating: 8.8, genre: &#34;Thriller&#34; },
  { title: &#34;The Dark Knight&#34;, year: 2008, monitored: false, rating: 9.0, genre: &#34;Action&#34; },
]

// Filter movies by genre
const actionMovies = filterql.filter(movies, &#34;genre == Action&#34;)

// Field aliases and multiple comparisons
const recentGoodMovies = filterql.filter(movies, &#34;y &gt;= 2008 &amp;&amp; rating &gt;= 8.5&#34;)

// Sort the filtered data by using the built-in SORT operation
const recentGoodMovies = filterql.filter(movies, &#34;year &gt;= 2008 | SORT rating desc&#34;)

// Filter using boolean shorthand
const monitoredMovies = filterql.filter(movies, &#34;monitored&#34;)"><pre><span>import</span> <span>{</span> <span>FilterQL</span> <span>}</span> <span>from</span> <span>&#34;filterql&#34;</span>

<span>// The schema determines what fields are allowed in the query</span>
<span>const</span> <span>schema</span> <span>=</span> <span>{</span>
  <span>title</span>: <span>{</span> <span>type</span>: <span>&#34;string&#34;</span><span>,</span> <span>alias</span>: <span>&#34;t&#34;</span> <span>}</span><span>,</span>
  <span>year</span>: <span>{</span> <span>type</span>: <span>&#34;number&#34;</span><span>,</span> <span>alias</span>: <span>&#34;y&#34;</span> <span>}</span><span>,</span>
  <span>monitored</span>: <span>{</span> <span>type</span>: <span>&#34;boolean&#34;</span><span>,</span> <span>alias</span>: <span>&#34;m&#34;</span> <span>}</span><span>,</span>
  <span>rating</span>: <span>{</span> <span>type</span>: <span>&#34;number&#34;</span> <span>}</span><span>,</span>
  <span>genre</span>: <span>{</span> <span>type</span>: <span>&#34;string&#34;</span> <span>}</span><span>,</span>
<span>}</span>

<span>const</span> <span>filterql</span> <span>=</span> <span>new</span> <span>FilterQL</span><span>(</span><span>{</span> schema <span>}</span><span>)</span>

<span>const</span> <span>movies</span> <span>=</span> <span>[</span>
  <span>{</span> <span>title</span>: <span>&#34;The Matrix&#34;</span><span>,</span> <span>year</span>: <span>1999</span><span>,</span> <span>monitored</span>: <span>true</span><span>,</span> <span>rating</span>: <span>8.7</span><span>,</span> <span>genre</span>: <span>&#34;Action&#34;</span> <span>}</span><span>,</span>
  <span>{</span> <span>title</span>: <span>&#34;Inception&#34;</span><span>,</span> <span>year</span>: <span>2010</span><span>,</span> <span>monitored</span>: <span>true</span><span>,</span> <span>rating</span>: <span>8.8</span><span>,</span> <span>genre</span>: <span>&#34;Thriller&#34;</span> <span>}</span><span>,</span>
  <span>{</span> <span>title</span>: <span>&#34;The Dark Knight&#34;</span><span>,</span> <span>year</span>: <span>2008</span><span>,</span> <span>monitored</span>: <span>false</span><span>,</span> <span>rating</span>: <span>9.0</span><span>,</span> <span>genre</span>: <span>&#34;Action&#34;</span> <span>}</span><span>,</span>
<span>]</span>

<span>// Filter movies by genre</span>
<span>const</span> <span>actionMovies</span> <span>=</span> <span>filterql</span><span>.</span><span>filter</span><span>(</span><span>movies</span><span>,</span> <span>&#34;genre == Action&#34;</span><span>)</span>

<span>// Field aliases and multiple comparisons</span>
<span>const</span> <span>recentGoodMovies</span> <span>=</span> <span>filterql</span><span>.</span><span>filter</span><span>(</span><span>movies</span><span>,</span> <span>&#34;y &gt;= 2008 &amp;&amp; rating &gt;= 8.5&#34;</span><span>)</span>

<span>// Sort the filtered data by using the built-in SORT operation</span>
<span>const</span> <span>recentGoodMovies</span> <span>=</span> <span>filterql</span><span>.</span><span>filter</span><span>(</span><span>movies</span><span>,</span> <span>&#34;year &gt;= 2008 | SORT rating desc&#34;</span><span>)</span>

<span>// Filter using boolean shorthand</span>
<span>const</span> <span>monitoredMovies</span> <span>=</span> <span>filterql</span><span>.</span><span>filter</span><span>(</span><span>movies</span><span>,</span> <span>&#34;monitored&#34;</span><span>)</span></pre></div>

<p dir="auto">Let&#39;s say you&#39;re building a CLI tool that fetches some data to be filtered by a query the user provides:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { FilterQL } from &#34;filterql&#34;

// data is an array of objects
const data = await (await fetch(&#34;https://api.example.com/movies&#34;)).json()

const query = process.argv[2] // first argument

const schema = {
  title: { type: &#34;string&#34;, alias: &#34;t&#34; },
  year: { type: &#34;number&#34;, alias: &#34;y&#34; },
  monitored: { type: &#34;boolean&#34;, alias: &#34;m&#34; },
  rating: { type: &#34;number&#34; },
  genre: { type: &#34;string&#34; },
}

const filterql = new FilterQL({ schema })
const filteredMovies = filterql.filter(data, query)

console.log(filteredMovies)"><pre><span>import</span> <span>{</span> <span>FilterQL</span> <span>}</span> <span>from</span> <span>&#34;filterql&#34;</span>

<span>// data is an array of objects</span>
<span>const</span> <span>data</span> <span>=</span> <span>await</span> <span>(</span><span>await</span> <span>fetch</span><span>(</span><span>&#34;https://api.example.com/movies&#34;</span><span>)</span><span>)</span><span>.</span><span>json</span><span>(</span><span>)</span>

<span>const</span> <span>query</span> <span>=</span> <span>process</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span> <span>// first argument</span>

<span>const</span> <span>schema</span> <span>=</span> <span>{</span>
  <span>title</span>: <span>{</span> <span>type</span>: <span>&#34;string&#34;</span><span>,</span> <span>alias</span>: <span>&#34;t&#34;</span> <span>}</span><span>,</span>
  <span>year</span>: <span>{</span> <span>type</span>: <span>&#34;number&#34;</span><span>,</span> <span>alias</span>: <span>&#34;y&#34;</span> <span>}</span><span>,</span>
  <span>monitored</span>: <span>{</span> <span>type</span>: <span>&#34;boolean&#34;</span><span>,</span> <span>alias</span>: <span>&#34;m&#34;</span> <span>}</span><span>,</span>
  <span>rating</span>: <span>{</span> <span>type</span>: <span>&#34;number&#34;</span> <span>}</span><span>,</span>
  <span>genre</span>: <span>{</span> <span>type</span>: <span>&#34;string&#34;</span> <span>}</span><span>,</span>
<span>}</span>

<span>const</span> <span>filterql</span> <span>=</span> <span>new</span> <span>FilterQL</span><span>(</span><span>{</span> schema <span>}</span><span>)</span>
<span>const</span> <span>filteredMovies</span> <span>=</span> <span>filterql</span><span>.</span><span>filter</span><span>(</span><span>data</span><span>,</span> <span>query</span><span>)</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>filteredMovies</span><span>)</span></pre></div>
<p dir="auto">And then the user might use your CLI tool like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="movie-cli &#39;(genre == Action || genre == Comedy) &amp;&amp; year &gt;= 2000 &amp;&amp; rating &gt;= 8.5&#39;"><pre>movie-cli <span><span>&#39;</span>(genre == Action || genre == Comedy) &amp;&amp; year &gt;= 2000 &amp;&amp; rating &gt;= 8.5<span>&#39;</span></span></pre></div>

<p dir="auto">The most basic query is a single comparison: <code>&lt;field&gt; &lt;comparison operator&gt; &lt;value&gt;</code></p>

<p dir="auto">You can also use the alias for a field:</p>

<p dir="auto">Combine multiple comparisons using logical operators for more complex queries:</p>
<div data-snippet-clipboard-copy-content="title == Interstellar &amp;&amp; year == 2014"><pre><code>title == Interstellar &amp;&amp; year == 2014
</code></pre></div>

<p dir="auto">The following logical operators can be used in queries:</p>
<ul dir="auto">
<li><code>()</code> (parentheses for grouping)</li>
<li><code>!</code> (not)</li>
<li><code>&amp;&amp;</code> (and)</li>
<li><code>||</code> (or)</li>
</ul>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">Note that these operators are listed in order of precedence. This is important because many queries will likely require parentheses to do what you want.</p>
</div>
<p dir="auto">For example:</p>
<p dir="auto"><code>genre == Action || genre == Thriller &amp;&amp; rating &gt;= 8.5</code> means &#34;genre must be Action or, genre must be Thriller and rating must be at least 8.5.&#34; This probably isn&#39;t what you want.</p>
<p dir="auto"><code>(genre == Action || genre == Thriller) &amp;&amp; rating &gt;= 8.5</code> means &#34;genre must be Action or Thriller, and rating must be at least 8.5.&#34;</p>

<p dir="auto">The following comparison operators can be used in comparisons:</p>
<ul dir="auto">
<li><code>==</code> (equals)</li>
<li><code>!=</code> (not equals)</li>
<li><code>*=</code> (contains)</li>
<li><code>^=</code> (starts with)</li>
<li><code>$=</code> (ends with)</li>
<li><code>~=</code> (matches regex)</li>
<li><code>&gt;=</code> (greater than or equal)</li>
<li><code>&lt;=</code> (less than or equal)</li>
</ul>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">Comparisons are case-sensitive. To make them case-insensitive, prefix the comparison operator with <code>i</code>.</p>
</div>


<p dir="auto">For boolean fields, you can use the field name without any comparison to check for <code>true</code>:</p>
<p dir="auto"><code>downloaded</code> is equivalent to <code>downloaded == true</code></p>
<p dir="auto"><code>!downloaded</code> is equivalent to <code>!(downloaded == true)</code></p>

<p dir="auto">If your comparison value has spaces, you must enclose it in double quotes:</p>
<div data-snippet-clipboard-copy-content="title == &#34;The Dark Knight&#34;"><pre><code>title == &#34;The Dark Knight&#34;
</code></pre></div>
<p dir="auto">Inside a quoted value, double quotes must be escaped:</p>
<div data-snippet-clipboard-copy-content="title == &#34;A title with \&#34;quotes\&#34;&#34;"><pre><code>title == &#34;A title with \&#34;quotes\&#34;&#34;
</code></pre></div>
<p dir="auto">Values ending with <code>)</code> <em>as part of the value</em> (not a closing parenthesis) must be quoted:</p>
<div data-snippet-clipboard-copy-content="title == &#34;(a title surrounded by parentheses)&#34;"><pre><code>title == &#34;(a title surrounded by parentheses)&#34;
</code></pre></div>

<p dir="auto">Sometimes the data you&#39;re filtering might have empty values (<code>&#34;&#34;</code>, <code>undefined</code>, <code>null</code>). You can filter for empty values by comparing to an empty string:</p>
<p dir="auto">Get all entries that <em>don&#39;t</em> have a rating:</p>

<p dir="auto">Get all entries that have a rating:</p>


<p dir="auto">If you want to get <em>all</em> of the entries, use <code>*</code> (the data is not filtered):</p>

<p dir="auto">This is mainly useful when you don&#39;t want to filter the data but want to apply operations to it.</p>


<p dir="auto">After filtering, you can apply operations to transform the data: <code>&lt;filter&gt; | &lt;operation&gt; [arg]...</code></p>
<div data-snippet-clipboard-copy-content="year &gt;= 2000 | SORT rating desc | LIMIT 10"><pre><code>year &gt;= 2000 | SORT rating desc | LIMIT 10
</code></pre></div>
<ul dir="auto">
<li>Operations are applied in the order they are specified.</li>
<li>The same operation can be applied multiple times.</li>
</ul>

<p dir="auto">There are currently two built-in operations:</p>
<ul dir="auto">
<li><code>SORT</code>: Sorts the data by the specified field.
<ul dir="auto">
<li><code>SORT &lt;field&gt; [direction]</code></li>
<li><code>direction</code> can be <code>asc</code> or <code>desc</code> (default: <code>asc</code>).</li>
</ul>
</li>
<li><code>LIMIT</code>: Limits the number of entries returned.
<ul dir="auto">
<li><code>LIMIT &lt;number&gt;</code></li>
</ul>
</li>
</ul>
<p dir="auto">If you have any suggestions for other operations, please let me know by opening an issue!</p>



<p dir="auto">The schema given to the <code>FilterQL</code> constructor determines what fields are allowed in queries.</p>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">FilterQL does not care about extra properties/keys in the <em>data</em>.</p>
<p dir="auto">In other words, a schema&#39;s keys can be a subset of the data&#39;s keys.</p>
</div>
<p dir="auto">Each field has a <code>type</code> and an (optional) <code>alias</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const schema = {
  title: { type: &#34;string&#34;, alias: &#34;t&#34; },
  year: { type: &#34;number&#34;, alias: &#34;y&#34; },
  monitored: { type: &#34;boolean&#34; },
}

const filterql = new FilterQL({ schema })"><pre><span>const</span> <span>schema</span> <span>=</span> <span>{</span>
  <span>title</span>: <span>{</span> <span>type</span>: <span>&#34;string&#34;</span><span>,</span> <span>alias</span>: <span>&#34;t&#34;</span> <span>}</span><span>,</span>
  <span>year</span>: <span>{</span> <span>type</span>: <span>&#34;number&#34;</span><span>,</span> <span>alias</span>: <span>&#34;y&#34;</span> <span>}</span><span>,</span>
  <span>monitored</span>: <span>{</span> <span>type</span>: <span>&#34;boolean&#34;</span> <span>}</span><span>,</span>
<span>}</span>

<span>const</span> <span>filterql</span> <span>=</span> <span>new</span> <span>FilterQL</span><span>(</span><span>{</span> schema <span>}</span><span>)</span></pre></div>
<p dir="auto">Field types determine validation behavior:</p>
<ul dir="auto">
<li><code>string</code>: The value must be coercible to a string (this is always the case)</li>
<li><code>number</code>: The value must be coercible to a number</li>
<li><code>boolean</code>: The value must be <code>true</code> or <code>false</code></li>
</ul>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">When a comparison value can&#39;t be coerced to the field&#39;s type, an error is thrown. For example, a query like <code>year = foo</code> will cause an error to be thrown.</p>
</div>

<div dir="auto" data-snippet-clipboard-copy-content="const filterql = new FilterQL({
  schema,
  options: {
    allowUnknownFields: false,
  },
})"><pre><span>const</span> <span>filterql</span> <span>=</span> <span>new</span> <span>FilterQL</span><span>(</span><span>{</span>
  schema<span>,</span>
  <span>options</span>: <span>{</span>
    <span>allowUnknownFields</span>: <span>false</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span></pre></div>
<p dir="auto">The <code>FilterQL</code> constructor accepts an optional <code>options</code> object with the following properties:</p>
<p dir="auto"><code>allowUnknownFields</code> (default: <code>false</code>): By default, an error is thrown if a query contains a field that&#39;s not in the schema. If <code>true</code>, unknown fields are allowed.</p>
<ul dir="auto">
<li>This could be useful in situations where the schema can&#39;t be determined ahead of time. i.e. the keys of the data are unknown or may change.</li>
</ul>


<p dir="auto">Let&#39;s say you want to create a custom operation called <code>ROUND</code> that takes a field name as the first argument and rounds the number value of that field.</p>
<p dir="auto">A query might look something like <code>year &gt;= 2000 | SORT rating desc | ROUND rating</code>.</p>
<p dir="auto">You can define custom operations by providing a <code>customOperations</code> object to the <code>FilterQL</code> constructor.</p>
<ul dir="auto">
<li>The keys are the names of the custom operations and <strong>must</strong> be all uppercase.</li>
<li>The values are functions that return the transformed data.</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="import type { OperationMap } from &#34;filterql&#34;

const customOperations: OperationMap = {
  ROUND: (data, args, { resolveField }) =&gt; {
    const field = resolveField(args[0]) // the first argument might be the alias of the field
    if (!field) throw new Error(`Unknown field &#39;${args[0]}&#39; for operation &#39;ROUND&#39;`)
    return data.map((item) =&gt; Math.round(item[field]))
  },
}

const filterql = new FilterQL({ schema: mySchema, customOperations })"><pre><span>import</span> <span>type</span> <span>{</span> <span>OperationMap</span> <span>}</span> <span>from</span> <span>&#34;filterql&#34;</span>

<span>const</span> <span>customOperations</span>: <span>OperationMap</span> <span>=</span> <span>{</span>
  <span>ROUND</span>: <span>(</span><span>data</span><span>,</span> <span>args</span><span>,</span> <span>{</span> resolveField <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>field</span> <span>=</span> <span>resolveField</span><span>(</span><span>args</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>// the first argument might be the alias of the field</span>
    <span>if</span> <span>(</span><span>!</span><span>field</span><span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>`Unknown field &#39;<span><span>${</span><span>args</span><span>[</span><span>0</span><span>]</span><span>}</span></span>&#39; for operation &#39;ROUND&#39;`</span><span>)</span>
    <span>return</span> <span>data</span><span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=&gt;</span> <span>Math</span><span>.</span><span>round</span><span>(</span><span>item</span><span>[</span><span>field</span><span>]</span><span>)</span><span>)</span>
  <span>}</span><span>,</span>
<span>}</span>

<span>const</span> <span>filterql</span> <span>=</span> <span>new</span> <span>FilterQL</span><span>(</span><span>{</span> <span>schema</span>: <span>mySchema</span><span>,</span> customOperations <span>}</span><span>)</span></pre></div>
<p dir="auto">Three arguments are provided to a given operation function:</p>
<ul dir="auto">
<li><code>data</code>: The data after its been filtered (and transformed by any previous operations).</li>
<li><code>args</code>: A string array containing any arguments passed to the operation.</li>
<li><code>operationHelpers</code>: An object containing the FilterQL instance <code>schema</code>, <code>options</code>, and a <code>resolveField</code> function.
<ul dir="auto">
<li>The <code>resolveField</code> function takes a string and returns the full field name if it exists in the schema. Use it to support field aliases in operations. e.g. <code>&#34;t&#34; -&gt; &#34;title&#34;</code> or <code>&#34;title&#34; -&gt; &#34;title&#34;</code> (full field name resolves to itself).</li>
</ul>
</li>
</ul>
<p dir="auto">Built-in operations can be overridden by providing a custom operation with the same name:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const customOperations: OperationMap = {
  SORT: (data, args, { resolveField }) =&gt; {
    // your custom SORT implementation
  },
}"><pre><span>const</span> <span>customOperations</span>: <span>OperationMap</span> <span>=</span> <span>{</span>
  <span>SORT</span>: <span>(</span><span>data</span><span>,</span> <span>args</span><span>,</span> <span>{</span> resolveField <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// your custom SORT implementation</span>
  <span>}</span><span>,</span>
<span>}</span></pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="class FilterQL {
  constructor({
    schema: Schema,
    options?: FilterQLOptions,
    customOperations?: OperationMap
  })
  filter&lt;T extends Record&lt;string | number | symbol, unknown&gt;&gt;(data: T[], query: string): T[]
}"><pre><span>class</span> <span>FilterQL</span> <span>{</span>
  <span>constructor</span><span>(</span><span>{</span>
    <span>schema</span>: <span>Schema</span><span>,</span>
    <span>options</span>?: <span>FilterQLOptions</span><span>,</span>
    <span>customOperations</span>?: <span>OperationMap</span>
  <span>}</span><span></span><span>)</span>
  <span>filter</span><span>&lt;</span><span>T</span> <span>extends</span> <span>Record</span><span>&lt;</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>symbol</span><span>,</span> <span>unknown</span><span>&gt;</span><span>&gt;</span><span>(</span><span>data</span>: <span>T</span><span>[</span><span>]</span><span>,</span> <span>query</span>: <span>string</span><span>)</span>: <span>T</span><span>[</span><span>]</span>
<span>}</span></pre></div>


<p dir="auto">FilterQL follows this grammar:</p>
<div data-snippet-clipboard-copy-content="query := filter ( &#34;|&#34; operation )*
filter := expr
operation := operation_name arg*
expr := and_expr ( &#34;||&#34; and_expr )*
and_expr := term ( &#34;&amp;&amp;&#34; term )*
term := &#34;!&#34; term | &#34;(&#34; expr &#34;)&#34; | comparison
comparison := field operator value | field | &#34;*&#34;"><pre><code>query := filter ( &#34;|&#34; operation )*
filter := expr
operation := operation_name arg*
expr := and_expr ( &#34;||&#34; and_expr )*
and_expr := term ( &#34;&amp;&amp;&#34; term )*
term := &#34;!&#34; term | &#34;(&#34; expr &#34;)&#34; | comparison
comparison := field operator value | field | &#34;*&#34;
</code></pre></div>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equals</td>
<td><code>title == Interstellar</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equals</td>
<td><code>title != &#34;The Matrix&#34;</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>Contains</td>
<td><code>title *= &#34;Matrix&#34;</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>Starts with</td>
<td><code>title ^= The</code></td>
</tr>
<tr>
<td><code>$=</code></td>
<td>Ends with</td>
<td><code>title $= Knight</code></td>
</tr>
<tr>
<td><code>~=</code></td>
<td>Regular expression</td>
<td><code>title ~= &#34;.*Matrix.*&#34;</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
<td><code>year &gt;= 2000</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
<td><code>rating &lt;= 8.0</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Any comparison operator can be prefixed with <code>i</code> (used to make a comparison case-insensitive):</p>


<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
<th>Precedence (in order from highest to lowest)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>()</code></td>
<td>Parentheses (grouping)</td>
<td><code>(year &gt;= 2000 &amp;&amp; year &lt;= 2010)</code></td>
<td>Highest precedence</td>
</tr>
<tr>
<td><code>!</code></td>
<td>NOT</td>
<td><code>!title *= Matrix</code></td>
<td>Right associative</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>AND</td>
<td><code>monitored &amp;&amp; year &gt;= 2000</code></td>
<td>Left associative</td>
</tr>
<tr>
<td><code>||</code></td>
<td>OR</td>
<td><code>genre == Action || genre == Drama</code></td>
<td>Left associative</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">The <code>*</code> character can be used in place of a comparison. When evaluated, it <em>always</em> matches.</p>
<p dir="auto"><code>* | SORT year</code>: Matches all entries and then sorts by <code>year</code>.</p>
<p dir="auto"><code>title == Matrix || * | SORT year</code>: This is effectively the same as the above query because the <code>|| *</code> matches all entries.</p>

<p dir="auto">Operations can be chained after the filter expression using the pipe operator (<code>|</code>). Each operation consists of an uppercase operation name followed by zero or more arguments:</p>
<div data-snippet-clipboard-copy-content="title == &#34;Matrix&#34; | SORT year
rating &gt;= 8.5 | SORT rating desc | LIMIT 10"><pre><code>title == &#34;Matrix&#34; | SORT year
rating &gt;= 8.5 | SORT rating desc | LIMIT 10
</code></pre></div>

<ul dir="auto">
<li>Tokens/words in queries are terminated by whitespace (<code> </code>, <code>\t</code>, <code>\n</code>, <code>\r</code>)
<ul dir="auto">
<li>e.g. a query like <code>title==Matrix</code> would be tokenized as <em>one</em> token with a value of <code>&#34;title==Matrix&#34;</code></li>
</ul>
</li>
<li>Queries are terminated by end of input</li>
<li>Fields can be used without a comparison operator: <code>monitored</code> is equivalent to <code>monitored == true</code></li>
<li>Fields and values can have operators &#34;attached&#34; to them that are automatically split off during tokenization:
<ul dir="auto">
<li>Fields can have one or more leading operators (<code>!</code>, <code>(</code>) and trailing operators (<code>)</code>) attached. e.g. <code>!(monitored)</code> becomes tokens: <code>[&#34;!&#34;, &#34;(&#34;, &#34;monitored&#34;, &#34;)&#34;]</code></li>
<li>Values can have one or more trailing operators (<code>)</code>) attached. e.g. <code>(title == Matrix)</code> becomes tokens: <code>[&#34;(&#34;, &#34;title&#34;, &#34;==&#34;, &#34;Matrix&#34;, &#34;)&#34;]</code>
<ul dir="auto">
<li>As a consequence, values ending with <code>)</code> <em>as part of the value</em> must be quoted: <code>field == &#34;(value)&#34;</code></li>
</ul>
</li>
<li>This allows for natural syntax like <code>!(field == value)</code> without requiring spaces around operators</li>
</ul>
</li>
<li>Values are either <strong>unquoted</strong> or <strong>quoted</strong>
<ul dir="auto">
<li>Values requiring whitespace must be enclosed in double quotes: <code>&#34;The Matrix&#34;</code></li>
<li>Double quotes (<code>&#34;</code>) are the only valid quotes</li>
<li>Double quotes inside quoted values are escaped with a backslash (<code>\&#34;</code>): <code>&#34;a value with \&#34;quotes\&#34;&#34;</code>
<ul dir="auto">
<li>This is the only supported escape sequence</li>
</ul>
</li>
<li>Empty quoted values are valid: <code>&#34;&#34;</code></li>
</ul>
</li>
<li>Values are <em>always</em> preceded by a comparison operator, which is how they can be differentiated from fields</li>
<li>Operation names must be all uppercase</li>
</ul>

<p dir="auto">This repository serves as a reference implementation for the language. See the source code for implementation details.</p>
</article></div></div>
  </body>
</html>
