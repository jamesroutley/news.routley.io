<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/02/05/stamp/">Original</a>
    <h1>Stamping production binaries with build info</h1>
    
    
<p>
As my assortment of dumb little home-grown utility programs grew over 
the years, I found myself needing to know when a given binary was built.  
Sometimes things exist outside the realm of a packaging system, and so 
the binary itself needs to convey that metadata from build time.
</p>
<p>
I&#39;ve seen some places solve for this by having giant placeholder strings 
baked into their binaries that they then reach in and &#34;stamp&#34; later, 
turning the &#34;XXXXXXXX&#34; or whatever into &#34;Built by foo@foo.blah.evilcorp 
on ...&#34;.  While that approach mostly worked, it was too spooky for me 
and I decided to stay away from it.
</p>
<p>
My system is something that uses a little nuance of C++ that I&#39;ve
<a href="https://rachelbythebay.com/w/2011/12/03/spooky/">mentioned</a>
a
<a href="https://rachelbythebay.com/w/2023/01/20/mainless/">couple</a>
of times already.  It&#39;s not the cleanest thing and it does involve a bit 
of groaning, but it works.  In case anyone else wants to try it in their 
projects, here&#39;s how I set it up.
</p>
<p>
First, I have this buildinfo/base.h, and in it, I define a struct called 
Details, and it has all of the fields I care about - times, hostnames, 
usernames, commit hashes, that kind of thing.  
</p>
<p>
There&#39;s also this:
</p>
<pre class="terminal">extern std::optional&lt;Details&gt; details_;
</pre>
<p>
Yes, that is globally visible, but it&#39;s inside a namespace so the crap 
factor is reduced somewhat.  It&#39;s a necessary evil.
</p>
<p>
I also have a buildinfo/base.cc and it actually creates that variable:
</p>
<pre class="terminal">std::optional&lt;Details&gt; details_;
</pre>
<p>
There&#39;s also a GetBuildDetails function which will return the value of 
details_ if one exists, or a suitable error if not.
</p>
<p>
Now, you might be saying &#34;it&#39;ll never have a value, so it&#39;ll always be 
an error&#34;, and you&#39;re mostly right.  Just from what I&#39;ve described so 
far, that in fact is the case.  buildinfo/base.{cc,h} rolls up into 
buildinfo/base.o, and that gets linked into my programs during a normal 
development type build.  If one of those programs calls the 
GetBuildDetails() function, then yes, they get the &#34;sorry, nobody home&#34; 
error response.
</p>
<p>
But, I have a way to <em>inject</em> the build info when I do a &#34;production&#34; 
build.  This kind of build has slightly different config settings in my 
build system, and one of them tells it to &#34;stamp&#34; the binary.
</p>
<p>
The way this works is where the evil starts slipping in.  On stamped 
builds, my build system writes out a file called buildinfo/overlay.cc.  
This file #includes &#34;buildinfo/base.h&#34; to pick up the definition of 
Details and the &#39;extern&#39; for details_ itself.  Then it rattles off a 
bunch of variables and their values (build time, build host, build 
user, ...) then it defines a class called Overlay.
</p>
<p>
Overlay&#39;s constructor has one job: it reaches into details_ and 
populates a bunch of fields with the values from those earlier 
variables.
</p>
<p>
Then the thing that actually makes it run shows up, and here&#39;s the 
&#34;spooky action at a distance&#34;:
</p>
<pre class="terminal">static Overlay overlay;
</pre>
<p>
Just by having that line in the file, it will cause the program to 
create an instance of that class shortly before it reaches main() as 
long as it&#39;s linked into the final binary.  When that constructor runs, 
it will populate details_, and then any code run from the rest of the 
program will see the build info.
</p>
<p>
This is convoluted, so I&#39;ll restate it here for clarity: it&#39;s the 
difference between linking &#34;a.o&#34;, &#34;b.o&#34; and &#34;c.o&#34; into &#34;prog&#34;, or &#34;a.o&#34;, 
&#34;b.o&#34;, &#34;c.o&#34; *and* &#34;overlay.o&#34; into &#34;prog&#34;.  If you don&#39;t link in that 
extra object, the sneaky stuff never happens, and it stays unpopulated.
Using a std::optional wrapper saves us from the jankiness of using a 
bare pointer... or worse.
</p>
<p>
There are some bonuses from using the intermediate variables instead of 
just having a bunch of .field = &#34;val&#34; type things in the part where 
details_ gets initialized.  For one, if those variables are not set to 
static, then they&#39;ll be visible to things like debuggers and certain 
other tools.  Then you can do something like this:
</p>
<pre class="terminal">$ gdb lavalamp_server -q
Reading symbols from lavalamp_server...
(gdb) print buildinfo::kBuildTime
$1 = 1707186971
(gdb) 
</pre>
<p>
That&#39;s pretty neat, right?  Analysis of a binary at rest?  You can even 
do this without going through a debugger if you really want to.
</p>
<p>
Finally, how does the build tool handle this?  It&#39;s a bit more of the
special-case stuff for something that isn&#39;t just an ordinary build.  If 
&#34;stamping&#34; of binaries has been requested for the active build type, 
then it generates a fresh overlay.cc and compiles it to overlay.o.
</p>
<p>
Then, in the link stage, if it&#39;s in &#34;stamp mode&#34;, it inserts that object 
file as just another dependency of the build target as if it had been 
discovered by way of a &#39;#include &#34;some_dir/some_lib.h&#34;&#39; or whatever.  
This adds it to the list of objects passed to the linker, and a fresh 
binary pops out a few moments later.
</p>
<p>
I&#39;m a fan of this technique since it only really adds two places in the 
build system where things go off and act a little strangely: the init 
sequence of the build tool when it&#39;s first built, and the link sequence 
of the target(s) to make sure it gets &#34;injected&#34;.
</p>
<p>
For anyone who&#39;s worrying about &#34;repeatable builds&#34; or somesuch, I will 
point out that nothing&#39;s stopping you from having yet another build type 
which is otherwise as described above but which puts known placeholder 
data into the details_ variable.  In that world, you should be able to 
go through the entire process and still get the same output, even on a 
different date, on a different box, and as another username.
</p>
<p>
I no longer wonder about which version of a binary is in &#34;prod&#34;.
</p>

  </body>
</html>
