<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/">Original</a>
    <h1>Re-implementing an old DOS game in C&#43;&#43; 17</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>Back in 2016, I started a side project to reverse engineer the game <a href="https://en.wikipedia.org/wiki/Duke_Nukem_II" target="_blank" rel="noopener">Duke Nukem II</a> and build an open source reimplementation of its engine from scratch ‚Äì called Rigel Engine (<a href="https://github.com/lethal-guitar/RigelEngine" target="_blank" rel="noopener">Check it out on GitHub</a>). Now, more than 2 1/2 years later, my version is complete enough to allow playing the entire shareware episode of the original game, offering a practically identical experience to running the original. Here‚Äôs a video showing off the first level:</p>
<p><span><iframe width="1100" height="619" src="https://www.youtube.com/embed/Z3gCS5LvC2s?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span></p>
<p>So what can it do? Rigel Engine works as a drop-in replacement for the original DOS binary (<code>NUKEM2.EXE</code>). You can place it into the game directory and it will read all the data from there, or you can specify the path to the game data as a command-line argument. It builds and runs on Windows, Mac OS X, and Linux. Based on <a href="https://www.libsdl.org/" target="_blank" rel="noopener">SDL</a> and OpenGL 3/OpenGL ES 2, written in C++ 17.</p>
<p>It implements the game logic for all the enemies and game mechanics found in the Shareware episode, plus most of the menu system. Saved games and high scores from the original game can also be imported.</p>
<p>On top of that, it already offers some enhancements compared to running the original game:</p>

<ul>
<li>No emulator or vintage hardware required, no need to tweak settings</li>
<li>No loading screens ‚Äì hit enter in the ‚Äúnew game‚Äù menu and you‚Äôre immediately in the action</li>
<li>Multiple sound effects can play at the same time, which is not possible in the original</li>
<li>No limitations on the number of simultaneous particle effects, explosions etc. going on</li>
<li>Per-user save files and high score lists</li>
<li>Much more responsive menus</li>
</ul>
<p>Now, I don‚Äôt consider Rigel Engine fully ‚Äúdone‚Äù yet. But this is a nice milestone for sure, and a good opportunity to write about the project again (find some older posts <a href="https://lethalguitar.wordpress.com/2017/04/02/introducing-the-rigel-engine-dev-blog/" target="_blank" rel="noopener">here</a> and <a href="https://lethalguitar.wordpress.com/2017/10/20/state-of-the-project-pt-1/" target="_blank" rel="noopener">here</a>). Let‚Äôs start by taking stock of what‚Äôs in the code right now, and how I got there.</p>
<h2><b>How much code is it?</b></h2>
<p>At the time of this writing, RigelEngine consists of 270 source files containing over 25k lines of code (without comments/blank lines). Of those, 10 files and 2.5k lines are unit tests. A breakdown including blank lines and comments can be found <a href="https://gist.github.com/lethal-guitar/6cc2421fe05aff85be49e228d5b20258" target="_blank" rel="noopener">here</a>.</p>
<p>What‚Äôs in all that code? There‚Äôs a bit of general infrastructure and utilities, we have fundamentals like rendering, and a lot of smaller pieces of logic here and there. On top of that, some of the bigger chunks are:</p>
<ul>
<li>parsers/loaders for 14 different file formats used by the original game ‚Äì 2k LOC</li>
<li>behavior/game logic for 24 enemies/hostile objects ‚Äì 3.8k LOC</li>
<li>game logic for 14 interactive elements and game mechanics ‚Äì 2k LOC</li>
<li>the player control logic ‚Äì 1.2k LOC</li>
<li>154 configuration entries (how much health does this enemy have, how much points does this collectable give etc.) ‚Äì 1k LOC</li>
<li>31 destruction effect specifications (effects triggered when an enemy or other destructible object is destroyed) ‚Äì 254 LOC</li>
<li>the camera control code ‚Äì 159 LOC</li>
<li>interpreter for the game‚Äôs menu/cut scene description language ‚Äì 643 LOC</li>
<li>HUD and other UI code 818 LOC</li>
<li>5 non-menu screens/modes, e.g. the intro movie, bonus screen etc. ‚Äì 789 LOC</li>
</ul>
<p>Of course, all of this code had to be written, which brings us to the next part.</p>
<h2><b>How much work was it?</b></h2>
<p>Although it‚Äôs been 2 and a half years since I started the project, I didn‚Äôt always work on it during this time. There were a couple of months where I didn‚Äôt spend any time on the project, and others where I only put a few hours into it. Then, there have also been times where I worked quite extensively on Rigel Engine. Looking at the commit chart from Github gives us a rough idea of how my efforts were distributed in time:</p>
<p><img data-attachment-id="918" data-permalink="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/gh-screen/" data-orig-file="https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png" data-orig-size="905,287" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="GH-Screen" data-image-description="" data-image-caption="" data-medium-file="https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=300" data-large-file="https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=905" src="https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=1100" alt="GH-Screen" srcset="https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png 905w, https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=150 150w, https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=300 300w, https://lethalguitar.files.wordpress.com/2019/05/gh-screen.png?w=768 768w" sizes="(max-width: 905px) 100vw, 905px"/></p>
<p>What we see in that chart are 1081 commits to the master branch. Before creating the repository though, I was working in a private one which features another 247 commits, thus giving us 1328 commits in total. In addition to that, there were various prototype branches I used to explore and experiment, but never merged, and I sometimes squashed larger commit histories down to a more condensed form before merging.</p>
<p>Now, writing code was only one part of the project ‚Äì reverse-engineering being the other major one. I‚Äôve spent quite a few hours looking at the original executable‚Äôs disassembly in <a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml" target="_blank" rel="noopener">Ida Pro</a> (the free version), taking notes, writing down pseudocode, and planning out how to implement things in my version. I also did a lot of testing with the original game, running it in <a href="https://www.dosbox.com/" target="_blank" rel="noopener">DOSBox</a> and on original hardware (various 386 and 486 machines which I got from eBay). I built test levels for focused observation of specific enemies and game mechanics, recorded video captures of these using DOSBox, and stepped through the recordings frame by frame to verify my findings from reading assembly code. Once I had implemented an enemy or game mechanic, I would also typically record footage from my version, and compare it to the original frame by frame to verify the accuracy of my implementation.</p>
<p>A few pictures from some of my notes (click to enlarge):</p>
<figure data-shortcode="caption" id="attachment_media-67" aria-describedby="caption-attachment-media-67"><a href="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg" target="_blank" rel="noopener"><img data-attachment-id="920" data-permalink="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/img_20190504_144556/" data-orig-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg" data-orig-size="5952,3348" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.8&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;ZTE A2017G&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1556981156&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4.216&#34;,&#34;iso&#34;:&#34;163&#34;,&#34;shutter_speed&#34;:&#34;0.0083333333333333&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="IMG_20190504_144556" data-image-description="" data-image-caption="" data-medium-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=300" data-large-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=1024" src="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=1100" alt="IMG_20190504_144556.jpg" srcset="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=1100 1100w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=2200 2200w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=150 150w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=300 300w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=768 768w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144556.jpg?w=1024 1024w" sizes="(max-width: 1100px) 100vw, 1100px"/></a><figcaption id="caption-attachment-media-67">Reverse-engineering the camera control code. The large rectangle represents the screen. The dotted lines indicate zones in which the player can move without the camera following. If you‚Äôre curious, <a href="https://github.com/lethal-guitar/RigelEngine/blob/67f1ff7faecb565a93b72d1f803c4424c9428e63/src/game_logic/camera.cpp#L157" target="_blank" rel="noopener">the actual camera control code can be found here</a>.</figcaption></figure>
<figure data-shortcode="caption" id="attachment_media-68" aria-describedby="caption-attachment-media-68"><a href="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144655.jpg" target="_blank" rel="noopener"><img loading="lazy" data-attachment-id="921" data-permalink="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/img_20190504_144655/" data-orig-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144655.jpg" data-orig-size="5952,3344" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.8&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;ZTE A2017G&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1556981215&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4.216&#34;,&#34;iso&#34;:&#34;188&#34;,&#34;shutter_speed&#34;:&#34;0.0083333333333333&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="IMG_20190504_144655" data-image-description="" data-image-caption="" data-medium-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144655.jpg?w=300" data-large-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144655.jpg?w=1024" src="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144655.jpg?w=6696" alt="IMG_20190504_144655.jpg" width="3348" height="5952"/></a><figcaption id="caption-attachment-media-68">General notes to help with understanding assembly code. Left side is the original game‚Äôs update order on a high level. Right side is notes about a bit-field representing some game object state.</figcaption></figure>
<figure data-shortcode="caption" id="attachment_media-69" aria-describedby="caption-attachment-media-69"><a href="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg" target="_blank" rel="noopener"><img data-attachment-id="922" data-permalink="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/img_20190504_144622/" data-orig-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg" data-orig-size="3348,5952" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.8&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;ZTE A2017G&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1556981182&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4.216&#34;,&#34;iso&#34;:&#34;183&#34;,&#34;shutter_speed&#34;:&#34;0.0083333333333333&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="IMG_20190504_144622" data-image-description="" data-image-caption="" data-medium-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=169" data-large-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=576" src="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=1100" alt="IMG_20190504_144622.jpg" srcset="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=1100 1100w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=2200 2200w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=84 84w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=169 169w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=768 768w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144622.jpg?w=576 576w" sizes="(max-width: 1100px) 100vw, 1100px"/></a><figcaption id="caption-attachment-media-69">Transcription of assembly into pseudo code. I usually did this in a fairly mechanical way, transcribing assembly without thinking too much about what the code is doing, and then using the pseudo code version to get an understanding of the underlying logic. Based on that, I‚Äôd then derive my implementation. <a href="https://github.com/lethal-guitar/RigelEngine/blob/67f1ff7faecb565a93b72d1f803c4424c9428e63/src/game_logic/ai/boss_episode_1.cpp#L79" target="_blank" rel="noopener">See the final code here</a>.</figcaption></figure>

<figure data-shortcode="caption" id="attachment_media-70" aria-describedby="caption-attachment-media-70"><a href="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg" target="_blank" rel="noopener"><img data-attachment-id="923" data-permalink="https://lethalguitar.wordpress.com/2019/05/28/re-implementing-an-old-dos-game-in-c-17/img_20190504_144602/" data-orig-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg" data-orig-size="3348,5952" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.8&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;ZTE A2017G&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1556981162&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4.216&#34;,&#34;iso&#34;:&#34;106&#34;,&#34;shutter_speed&#34;:&#34;0.016666666666667&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="IMG_20190504_144602" data-image-description="" data-image-caption="" data-medium-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=169" data-large-file="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=576" src="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=1100" alt="IMG_20190504_144602.jpg" srcset="https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=1100 1100w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=2200 2200w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=84 84w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=169 169w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=768 768w, https://lethalguitar.files.wordpress.com/2019/05/img_20190504_144602.jpg?w=576 576w" sizes="(max-width: 1100px) 100vw, 1100px"/></a><figcaption id="caption-attachment-media-70">Pseudo-code for the cleaned up version of an enemy‚Äôs logic. The captions represent states in the state machine, the code below indicates what should happen in the respective states. This was derived from the raw pseudo-code resulting from transcribing assembly. You can find the final code <a href="https://github.com/lethal-guitar/RigelEngine/blob/67f1ff7faecb565a93b72d1f803c4424c9428e63/src/game_logic/ai/watch_bot.cpp#L284" target="_blank" rel="noopener">here</a>.</figcaption></figure>
<p>Ultimately, doing this was quite a lot of fun, and I learned a lot: About reverse engineering, 16-bit x86 assembly, low-level VGA programming, the strict limitations PC game developers in the early 90s had to face, but also a lot of insights into how the original game works and how quirky and odd some of it was implemented ‚Äì that‚Äôs actually worth a series of dedicated blog posts at some point.</p>
<h2><b>What‚Äôs next?</b></h2>
<p>Besides adding the last missing features and finishing support for the registered version, I have quite a few ideas for enhancing and improving Rigel Engine, not to mention a whole lot of cleanups and refactoring that could be done ‚Äì as usual, the best way to architect a piece of software becomes most evident once you‚Äôre done writing said piece of software üôÇ</p>
<p>In terms of future enhancements, here are some of the things I‚Äôve thought about doing:</p>
<ul>
<li>Smooth motion with interpolation. The game only updates its logic roughly 15 times a second, and in the original version, that‚Äôs also the frame rate for rendering. Rigel Engine, on the other hand, can easily run at 60 FPS or higher. At the moment, these additional frames don‚Äôt really offer any benefits, but I can imagine using them for in-between frames to make for smoother scrolling and object motion. The game logic would still run at its original speed, but objects would move smoothly instead of ‚Äújumping‚Äù by 8-pixel increments as they do now. I‚Äôve prototyped this in the past and it looks great, but needs a bit more work.</li>
<li>Gamepad support. The original game features joystick support, and DosBox can emulate this for a modern game pad, but it can be a bit cumbersome to set up, requiring configuration tweaks and calibration in game. Not to mention that not all controller buttons are supported, and menus often still require using the keyboard. So I believe that native controller support would make for a much better experience.</li>
<li>Enhanced audio. At the moment, sound effects always have the same volume. Objects that produce sound, e.g. force fields, will abruptly become audible once they appear on screen, and vanish just as abruptly. I was wondering how it would sound if these effects would weaken with distance instead. So you would faintly hear the force field even when it‚Äôs not on screen, and it would get louder as you get closer.</li>
<li>Zoomed out view/showing more of the level at once. The game wasn‚Äôt made for this, so it might hurt the experience somewhat as you‚Äôd start to see enemies being inactive while off screen etc. But I‚Äôm still interested to see how it would look and feel. Not being able to see enough of the surroundings is a common complaint about the game, after all. Having an option to disable the HUD or replace it with a more minimal one making use of transparency could also be interesting.</li>
<li>Replacing graphics with higher-resolution versions. This is a common feature in many source ports/recreations of games, and would be nice to see here as well. It‚Äôs already possible to override Sprite graphics with custom images, but they can‚Äôt be higher resolution at the moment, since everything is rendered to a small internal buffer and then upscaled. This first needs to change so that up-scaling happens per object.</li>
</ul>
<p>I don‚Äôt really have a set roadmap for the future, so I might do any of these things whenever I feel like it. Before all that though, the next step is integrating Dear ImGui in order to then build an options menu ‚Äì which is still a missing feature in the game in general, but also necessary so that it‚Äôs possible to enable and disable the enhancements listed above. Finally, of course, <a href="https://github.com/lethal-guitar/RigelEngine/issues" target="_blank" rel="noopener">contributions on GitHub</a> are always welcome!</p>
			
			
				</div></div>
  </body>
</html>
