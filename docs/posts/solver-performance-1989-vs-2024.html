<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.solvermax.com/blog/solver-performance-1989-vs-2024">Original</a>
    <h1>Solver Performance: 1989 vs. 2024</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>5 January 2024</p>
<p><img title="Blue steps" src="https://www.solvermax.com/images/blog/crossword/blue-steps.png" alt="Blue steps" width="300" height="180"/></p>
<p>In our <a title="Optimal but not practical - Virtual machine" href="https://www.solvermax.com/blog/optimal-but-not-practical-virtual-machine">previous article</a>, we solved a mixed integer linear program (MILP) model with more than 8 million binary variables. Not long ago, a model of that size would have been unsolvable. Yet, once we had a computer with sufficient memory, the model was solved to optimality by an open source solver in 3 hours.</p>
<p>Of course, not all large models are solvable â€“ even some small models are unsolvable, or at least hard to solve. Nonetheless, modern solvers, in association with modern computers, enable us to solve models that not-so-long-ago were beyond our capabilities.</p>
<p>In our next article, we&#39;ll look to compile crosswords using a MILP model. We&#39;re not the first to consider using a MILP model to compile crosswords. An article published in 1989 reported attempts to compile small crosswords using MILP models. The article&#39;s conclusion was very pessimistic, noting that:</p>
<blockquote><p>...the prospects of using integer programming for any type of puzzle of realistic size and with a substantial lexicon remain bleak.</p><span>Wilson, 1989, <a title="Crossword compilation using integer programming" href="https://academic.oup.com/comjnl/article-pdf/32/3/273/947308/320273.pdf">Crossword compilation using integer programming</a></span></blockquote>
<p>The problems Wilson encountered were insufficient computer memory and the time needed to solve a very small crossword grid, even though he was using a then state-of-the-art million dollar superminicomputer.</p>
<p>But a lot has changed in the 35 years since 1989. Computer hardware is many times faster, and memory capacity has increased enormously. In addition, optimization solver software has improved by orders of magnitude. Models that were difficult to solve in 1989 are now trivial. Solutions that were impossible to find in 1989 may now be within reach.</p>
<p>In this article, we estimate the magnitude of speed improvement for optimization solvers and computer hardware in the 35 years from 1989 to 2024. The results may be surprising.</p>
<h2>1989: Crossword compilation using integer programming</h2>
<figure>
<figcaption>Figure 1. 4x4 grid in Wilson&#39;s paper</figcaption>
<img title="4x4 grid" src="https://www.solvermax.com/images/blog/crossword/4x4.png" alt="4x4 grid" width="300" height="226"/>
</figure>
<p>As a motivating example, we consider an early attempt to compile crosswords using a mixed integer linear program (MILP). The paper <a title="Crossword compilation using integer programming" href="https://academic.oup.com/comjnl/article-pdf/32/3/273/947308/320273.pdf">Crossword compilation using integer programming</a>, was published in 1989 by J. M. Wilson. That article proposes two MILP model formulations for compiling crosswords:</p>
<figure>
<figcaption>Figure 2. Prime 750 superminicomputer</figcaption>
<img title="Prime 750 superminicomputer" src="https://www.solvermax.com/images/blog/crossword/prime750.jpg" alt="Prime 750 superminicomputer" width="468" height="400"/>

</figure>
<ul>
<li>Model 1, whole words. Model 1 attempts to fit whole words into a 4x4 fully interlocking puzzle (i.e. no black cells), as shown in Figure 1. With a lexicon of 100 4-letter words, the problem size was 800 variables and 524 constraints. A solution for this 4x4 <a title="double word square" href="https://en.wikipedia.org/wiki/Word_square#Double_word_squares">double word square</a> puzzle was found in 1,800 seconds.</li>
<li>Model 2, individual letters. Model 2 attempts to place individual letters into a grid. It is more memory-efficient than Model 1, but it failed to find any solutions within 3,000 seconds, even for very small grids. In any case, Model 2 has a loose formulation that can create &#34;words&#34; that are not in the lexicon, so a solution (if found) may not be valid.</li>
</ul>
<p>From Wilson&#39;s experience, we observe that:</p>
<ul>
<li>A key modelling issue was memory usage, especially as the lexicon size increases. The models used a lexicon of 100 words, which is very limiting given that there are several thousand 4-letter English words.</li>
<li>Solutions were difficult to find, even for very small grids.</li>
<li>A model with 800 variables and 524 constraints is now considered to be small. In 1989 it was a large model.</li>
<li>Dense American-style puzzles (like Figure 1) are much harder to solve than sparser British-style crossword puzzles. This is likely because a dense grid has more word intersections. We&#39;ll explore this issue further in our next article.</li>
<li>The modelling was performed on a <a title="Prime 750 superminicomputer" href="https://en.wikipedia.org/wiki/Prime_Computer">Prime 750 superminicomputer</a>, an example of which is shown in Figure 2. The Prime 750 superminicomputer had up to 8 MB of RAM and it ran at 1 million instructions per second (MIPS). The Prime 750 was a state-of-the-art computer at the time. Depending on configuration, a <a title="THE EXECUTIVE COMPUTER; A Chip With Supercomputer Power" href="https://www.nytimes.com/1989/03/05/business/the-executive-computer-a-chip-with-supercomputer-power.html">system cost several hundred thousand US dollars</a> in the mid to late 1980s. That equates to about US\$1,000,000 today, <a title="U.S. Inflation Calculator" href="https://www.usinflationcalculator.com/">adjusted for inflation</a>.</li>
</ul>
<p>Wilson&#39;s paper refers to <a title="Crossword compilation with Horn clauses" href="https://academic.oup.com/comjnl/article/30/2/183/404335">another paper</a> that uses a lexicon of 1,000 4-letter words to compile crosswords using first-order predicate logic in the Prolog programming language, noting that, &#34;This size of lexicon would present an almost impossible task for an integer programming model.&#34;</p>
<p>Overall, Wilson was pessimistic about using integer programming for compiling crosswords, considering it to be impractical, concluding that &#34;the prospects of using integer programming for any type of puzzle of realistic size and with a substantial lexicon remain bleak&#34;.</p>
<p>So, integer programming was not a viable method for compiling crossword puzzles in 1989. But a lot has changed since then.</p>
<h2>Computers and solvers have improved enormously</h2>
<p>Wilson&#39;s paper was published in 1989. As we write this article in early 2024, that&#39;s 35 years ago. Since 1989, computers have become much faster, and they have a lot more memory. In addition, linear programming solvers have improved in both speed and sophistication.</p>
<p>In the following sections we attempt to estimate the magnitude of improvement in the 35 years since 1989.</p>
<h2>Computer improvements</h2>
<h3>Computer speed improvement: 1989-2024</h3>
<p>Computer processing speed has increased enormously over time. According to the <a title="50 years of microprocessor trend data" href="https://github.com/karlrupp/microprocessor-trend-data">50 years of microprocessor trend</a> data shown in Figure 3, single-thread Computer Processing Unit (CPU) performance (using the <a title="SpecINT benchmark" href="https://en.wikipedia.org/wiki/SPECint">SpecINT benchmark</a>) improved from an average score of 67 in 1988-1989 to 105,300 in 2021. That equates to a factor of 1,572 times faster.</p>
<p>From 2021 to 2023, <a title="CPU single thread benchmark scores" href="https://www.cpubenchmark.net/singleThread.html">CPU single thread benchmark scores</a> improved by a further 10%, for a total factor from 1989 to 2023 of 1,729 times faster.</p>
<figure>
<figcaption>Figure 3. 50 years of microprocessor trend data</figcaption>
<img title="50 years of microprocessor trend data" src="https://www.solvermax.com/images/blog/crossword/cpu.png" alt="50 years of microprocessor trend data" width="769" height="446"/>
</figure>
<p>Until 2004, almost all CPUs had a single processing core. Since then, the number of logical CPU cores (i.e., physical cores and/or parallel threads within a physical core) has been increasing. A typical desktop computer now has at least several cores, with many having one or two dozen cores. Some CPUs have hundreds of cores. Graphics card GPUs typically have thousands of cores, though that is a different story.</p>
<p>Many solvers can use multiple CPU cores, to a greater or lesser extent. For example:</p>
<ul>
<li><a title="Gurobi" href="https://www.gurobi.com/documentation/current/refman/threads.html">Gurobi</a> and <a title="CPLEX" href="https://www.ibm.com/docs/en/icos/22.1.1?topic=parameters-parallel-mode-switch">CPLEX</a> use multiple cores, by default, when solving models.</li>
<li>The <a title="Octeract" href="https://octeract.gg/octeract-engine/">Octeract solver engine</a> relies on parallel processing for its high performance in solving non-linear models.</li>
<li>The open-source <a title="HiGHS" href="https://ergo-code.github.io/HiGHS/dev/parallel/#Future-plans">HiGHS</a> solver has &#34;limited opportunities for exploiting parallel computing&#34;, though greater use of multiple CPU cores is planned soon.</li>
</ul>
<p>However, the speed improvement for multiple cores compared with a single core, according to <a title="Amdahl&#39;s law" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl&#39;s law</a>, is generally much less than a linear multiple of the number of cores.</p>
<p>For this analysis, we make the sweeping assumption that using multiple CPUs somewhat more than doubles the performance of a single CPU. That is, we estimate that total computer processing speed increased by a factor of about 4,000 times (= 2.3 x 1,729) from 1989 to 2024.</p>
<h3>Computers have a lot more memory</h3>
<p>The Prime 750 superminicomputer used by Wilson could have up to 8 MB of RAM (though some installations had only 2 or 4 MB of RAM). A modern desktop PC may have 8 GB of RAM â€“ i.e., 1,024 times as much memory.</p>
<p>Though 8 GB of RAM is quite small for a computer in 2024. For example, the virtual machine we used in <a title="Optimal but not practical - Virtual machine" href="https://www.solvermax.com/blog/optimal-but-not-practical-virtual-machine">our previous article</a> has 128 GB of RAM â€“ that&#39;s 16,384 times the maximum memory available in a million dollar computer in 1989.</p>
<p>Computer memory in 2024 is also many times faster than it was in 1989. We assume that the memory speed does not materially change our estimate of CPU speed increase.</p>
<h3>Computer costs has plummeted</h3>
<p>In this analysis, we&#39;re comparing a 1989 superminicomputer with a 2024 desktop PC â€“ because those are the machines that would typically be used for optimization modelling in their respective eras. But this is not an entirely fair comparison, as the superminicomputer cost a million dollars (in today&#39;s money), while a high specification desktop computer now costs only a few thousand dollars â€“ a reduction of more than 99%. If we maintained cost parity, then the performance of a 2024 computer would be even greater.</p>
<h3>Summary of computer hardware improvements</h3>
<p>Compared with 35 years ago, computers are thousands of times faster, with thousands of times more memory, and their cost has fallen by more than 99%.</p>
<h2>Solver improvements</h2>
<h3>Our estimate is based on aggregating separate estimates for periods of time</h3>
<p>The best estimate we can find of how much optimization solvers have improved is published by Gurobi. We start with an analysis by Gurobi estimating the <a title="Computation progress in linear and mixed integer programming" href="https://www.yumpu.com/en/document/read/54431495/computational-progress-in-linear-and-mixed-integer-programming">computation progress in linear and mixed integer programming</a> from 1991 to 2008. We then look at an updated analysis to 2020, which we extend to 2023.</p>
<h3>CPLEX performance improvement: 1991 to 2008</h3>
<figure>
<figcaption>Figure 4. CPLEX speed improvement for MILP from 1991 to 2008</figcaption>
<img title="CPLEX speed improvement" src="https://www.solvermax.com/images/blog/crossword/cplex-speedup.png" alt="CPLEX speed improvement" width="664" height="359"/>
</figure>
<p>Figure 4 shows Gurobi&#39;s assessment of speed improvement for the CPLEX solver when solving MILP models, for each major software version (bars) and cumulative (line), from 1991 to 2008.</p>
<p>The total cumulative speed improvement is a factor of almost 30,000 times faster (note the log scale for the right-hand axis).</p>
<p>Over those 17 years, this equates to about 1.8 times faster per annum, on average. Though improvements don&#39;t occur at a steady rate, with especially large improvements occurring in CPLEX versions 2.1-3.0 (inclusion of the dual simplex method) and in CPLEX versions 6.0-6.5 (many improvements gleaned from &#34;mining&#34; the academic literature).</p>
<p>Importantly, this estimate is just the improvement in solver software performance, not allowing for the speed increase of computer hardware over the same period.</p>
<p>Note that we ignore any improvement in solver performance from 1989 to 1991, as we don&#39;t have that information. But if the same rate of improvement (1.8 times per annum) had occurred in those 3 years, then we would have another factor of almost 6 times faster.</p>
<h3>Gurobi performance improvement: 2009 to 2023</h3>
<p>Dr. Bixby, one of the founders of Gurobi, presented an <a title="Optimization: Past, Present, Future with Dr. Robert Bixby" href="https://www.youtube.com/watch?v=_R8-nt5NyiE">updated analysis</a> of solver performance improvement in 2021, as shown in Figure 5.</p>
<figure>
<figcaption>Figure 5. Gurobi speed improvement for MILP from 2009 to 2020</figcaption>
<img title="Gurobi speed improvement" src="https://www.solvermax.com/images/blog/crossword/bixby-2021.png" alt="Gurobi speed improvement" width="639" height="348"/>
</figure>
<p>The figure states a cumulative improvement factor of 3,730,625 times, from CPLEX 1.2 to Gurobi 9.1 (released in 2020). Given the CPLEX improvement factor of 29,530 above, this implies an additional improvement for Gurobi of 126 times for the period 2009 to 2020.</p>
<p>Subsequent versions of Gurobi claim performance improvements for MILP models of:</p>
<ul>
<li><a title="Version 9.1 to 9.5" href="https://www.gurobi.com/wp-content/uploads/9.5-launch-Presentation.pdf">Version 9.1 to 9.5 (2021)</a>: 15%</li>
<li><a title="Version 9.5 to 10.0" href="https://www.gurobi.com/whats-new-gurobi-10-0/">Version 9.5 to 10.0 (2022)</a>: 13%</li>
<li><a title="Version 10.0 to 11.0" href="https://www.gurobi.com/whats-new-gurobi-11-0/">Version 10.0 to 11.0 (2023)</a>: 8.6%</li>
</ul>
<p>Combining these changes, we estimate that from 2009 to 2023 the Gurobi solver&#39;s speed improved by a factor of about 178 times.</p>
<p>A factor of 178 over 14 years equates to an average rate of about 1.45 times per annum. This is lower than the 1.8 times annual average rate from 1991 to 2009, but it is still impressive nonetheless.</p>
<h3>Solver performance improvement: 1989 to 2024</h3>
<p>Overall, by combining each of the solver-related steps above, we can estimate the cumulative improvement in solver performance over the last 35 years.</p>
<p>The result is that MILP solver performance improved by a factor of 5 million times (in round numbers) from 1989 to 2024. This is conservative estimate, as we exclude any improvement that may have occurred from 1989 to 1991, and from 2023 to 2024.</p>
<p>This improvement, assuming the same computer hardware, is equivalent to a model that takes 60 seconds to solve in 2023 taking 10 years to solve if started in 1989. That is, if it was possible to solve at all in 1989.</p>
<p>Note that our solver performance increase estimate is based on the commercial solvers CPLEX and Gurobi. An open-source solver, like HiGHS, is generally not as fast as CPLEX or Gurobi â€“ perhaps by an order of magnitude, more-or-less, depending on the model. Though that hardly seems significant, given the magnitude of speed improvements over the past three+ decades.</p>
<h2>Solver + computer performance improvement: 1989 to 2024</h2>
<figure>
<figcaption>20 billion times faster</figcaption>
<p>Solving MILP models is about 20 billion times faster than it was 35 years ago.</p>
</figure>
<h3>Combined result</h3>
<p>Combining the computer hardware speed increase of 4,000 times with the solver software performance improvement of 5 million times, the total improvement from 1989 to 2024 is a factor of 20 billion times faster!</p>
<p>At that rate, a model that takes 60 seconds to solve in 2023 would have taken 38,000 years to solve if started in 1989.</p>
<h3>A grain of salt</h3>
<p>Of course, we shouldn&#39;t take these estimates too literally.</p>
<p>Firstly, there&#39;s substantial room for variation in our estimates. Some numbers are uncertain, while others are simply guesses. Also, aggregating the various factors in a multiplicative manner may not be entirely valid.</p>
<p>Secondly, there are many elements that contribute to how fast, or even whether, a MILP model can be solved, in addition to computer and solver raw speed. Other elements include memory size, programming language features, the fit between solver methodology and a model&#39;s specific characteristics, and changes in solver features.</p>
<p>Nonetheless, the magnitude of speed increases we&#39;ve described in this article surely help in solving larger, more difficult MILP models. A lot.</p>
<h2>Conclusion</h2>
<p>In this article, we estimate the speed improvement in computer hardware and optimization solver software since 1989. This assessment is motivated by an academic paper by Wilson, published 35 years ago, describing an attempt to compile crossword puzzles using mixed integer linear programming (MILP). That attempt was largely unsuccessful, as the task was beyond the capability of MILP solvers at that time.</p>
<p>But both computers and MILP solvers have advanced enormously since 1989 â€“ by a combined factor of around 20 billion time faster! That improvement should be enough to offset at least some of Wilson&#39;s pessimism about being able to compile crossword puzzles using MILP models. Likewise for many other optimization models.</p>
<p>In the next article, we attempt to formulate and solve a MILP to compile crossword puzzles. This is still a difficult problem, though given the improvement in computer and solver speed, there is some basis for optimism that the task is now possible.</p>
<p>If you would like help with your own models, then please <a href="https://www.solvermax.com/contact">contact us</a>.</p>
<h2>References</h2>
<p>The main references used in this article are listed below. Other information is linked within the article.</p>
<p>Gurobi Optimization, 2015. <a title="Computational progress in linear and mixed integer programming" href="https://www.yumpu.com/en/document/read/54431495/computational-progress-in-linear-and-mixed-integer-programming">Computational progress in linear and mixed integer programming</a>, accessed 13 December 2023.</p>
<p>Passmark Software, 2023. <a title="Single thread CPU performance" href="https://www.cpubenchmark.net/singleThread.html">Single thread CPU performance</a>, accessed 13 December 2023.</p>
<p>Rupp, K., 2023. <a title="Microprocessor trend data" href="https://github.com/karlrupp/microprocessor-trend-data">Microprocessor trend data</a>, accessed 13 December 2023.</p>
<p>Wilson, J.M., 1989. <a title="Crossword compilation using integer programming" href="https://academic.oup.com/comjnl/article-pdf/32/3/273/947308/320273.pdf">Crossword compilation using integer programming</a>, The Computer Journal, Volume 32, Number 3, Pages 273â€“275.</p>
</div></div>
  </body>
</html>
