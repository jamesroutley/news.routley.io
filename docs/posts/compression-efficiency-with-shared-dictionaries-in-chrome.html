<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/blog/shared-dictionary-compression">Original</a>
    <h1>Compression efficiency with shared dictionaries in Chrome</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    




<div translate="no">
  
    
    
      <div>
        
          <p><img alt="Jeremy Wagner" src="https://web.dev/images/authors/jlwagner.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
</div>



<p>Data compression is a time-tested performance optimization technique that reduces the size of eligible page resources. For some time, it was common practice to primarily use gzip on web servers to compress common text-based page resources such as HTML, CSS, and JavaScript files, and send them to the client where they could be decompressed. The result is faster load times for resources without affecting the intended behavior of a page.</p>

<p>Though gzip is highly effective in its own right, further improvements in compression on the web have been realized in recent years. In 2016, the Brotli algorithm shipped in Chrome, delivering overall better compression ratios for eligible resources. By the end of 2017, all modern browsers supported Brotli, and server support for it started to become more widespread. More recently, Chrome <a href="https://chromestatus.com/feature/6186023867908096">has shipped ZStandard compression</a>.</p>

<p>The work doesn&#39;t stop there though! The Chrome team has been working on making shared dictionaries usable on the web, which are now available in an origin trial for both <a href="https://hazure.neocities.org/origintrials#/view_trial/2583940286203822081">Brotli and ZStandard</a>. Shared dictionaries can supplement Brotli and ZStandard compression to deliver substantially higher compression ratios for websites that frequently ship updated code, and can—in some cases—deliver <strong>90% or better compression ratios</strong>. This post goes into more detail on how shared dictionaries work, and how you can register for the origin trials to use them for Brotli and ZStandard on your website.</p>



<p>Compression is a process of finding redundant sequences in an input and using that information to create a much smaller output, which can be reversed later on. Compression works well on the web because it substantially reduces resource load times. Both Brotli and ZStandard can further increase their effectiveness by using a <em>compression dictionary</em>, which is a collection of additional patterns that these algorithms can use during compression. In fact, Brotli&#39;s high efficiency is achieved to some degree by using an internal dictionary.</p>

<p>However, <em>custom</em> user-curated dictionaries can be used with Brotli and ZStandard that contain patterns specific to particular resources. In practice, a custom dictionary is an external file that can be applied to any input. Dictionaries can be highly specific to an application&#39;s production code, or really any content at all. How applicable a given dictionary is to its input can have a big impact on overall compression efficiency. Dictionaries that are highly similar to the contents of an input will yield outputs with higher compression ratios than dictionaries with generic or dissimilar contents.</p>

<p>Here&#39;s an example of how effective a custom compression dictionary can be: say your website uses the Angular framework, and the current version you&#39;re using is version 1.7.9. This version of the Angular framework is about 172 KiB uncompressed. When compressed with Brotli&#39;s default settings, its size becomes about 53 KiB. This yields nearly a 70% compression ratio. However, say you decide to upgrade to Angular 1.8.3 later on. Given that this version of Angular is roughly the same size as version 1.7.9, you can expect pretty much the same compression ratio as the previous version.</p>

<p>This is where a custom dictionary can come in handy by using a process known as <em>delta compression</em> , which is when a dictionary of a previous version of a resource can be used to compress a later version. Using the previous example, if you compressed version 1.8.3 of Angular using version 1.7.9 as a dictionary, the output would be just over 4 KiB. This represents a compression ratio of <strong>nearly 98%</strong>. Clearly, compression dictionaries can have a big impact on loading performance, and their effectiveness has already <a href="https://github.com/WICG/compression-dictionary-transport/blob/main/examples.md#static-resource-flow-results">been realized in real-world applications</a>!</p>

<p>However, there&#39;s a challenge in making this flow work on the web. The catch is that, if you use a dictionary to compress a resource, you need that same dictionary in order to <em>decompress</em> it. This flow has been attempted on the web before—namely <a href="https://en.wikipedia.org/wiki/SDCH">SDCH</a>—but was challenging to implement safely. This latest proposal for shared dictionary compression <a href="https://github.com/WICG/compression-dictionary-transport?tab=readme-ov-file#this-time-will-be-different">addresses those concerns</a> while providing a substantial benefit for both static and dynamic resources.</p>



<p>All browsers advertise the compression algorithms they support through the <a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Encoding"><code translate="no" dir="ltr">Accept-Encoding</code> request header</a>. The content of the header is a comma-separated list of supported encodings:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">Accept-Encoding: gzip, br, zstd
</code></pre>
<p>This particular <code translate="no" dir="ltr">Accept-Encoding</code> header states that the browser requesting the resource supports the gzip, Brotli, and ZStandard compression algorithms. A web server responding to the request can then decide which algorithm to use when responding to the request.</p>

<p>When shared dictionary support is enabled and a relevant dictionary is available for a resource, additional tokens are added to the <code translate="no" dir="ltr">Accept-Encoding</code> header. These tokens are <code translate="no" dir="ltr">br-d</code> for Brotli and <code translate="no" dir="ltr">zstd-d</code> for Zstandard. Chrome will also include the hash of an available dictionary, which is covered next.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">Accept-Encoding: gzip, br, zstd, br-d, zstd-d
Available-Dictionary: :pZGm1Av0IEBKARczz7exkNYsZb8LzaMrV7J32a2fFG4=:
</code></pre>
<p>If a web server is configured to recognize this token, and it recognizes the dictionary, it can respond to that request with a resource that was compressed using the dictionary for the applicable encoding. How this is achieved in practice depends on whether the request is for a static or dynamic resource.</p>



<p>A static page resource is one that always produces the same response for a requested URL. Common examples of compressible static page resources are JavaScript and CSS files. These resources are typically versioned for caching purposes in some way—sometimes with a hash of the file&#39;s contents in the filename (for example <code translate="no" dir="ltr">styles.abcd1234.css</code>), or some other method of fingerprinting the resource. These resource types are a great candidate for the delta compression that shared dictionaries provide, as static resources are often cached for long periods of time and tend to be updated with some frequency.</p>

<p>A dictionary can be specified for a static resource by setting the <code translate="no" dir="ltr">Use-As-Dictionary</code> response header for it. The header takes one of a few key/value pairs, but the only required one is <code translate="no" dir="ltr">match</code>, which accepts <a href="https://urlpattern.spec.whatwg.org/"><code translate="no" dir="ltr">URLPattern</code> syntax</a> specifying the resource path where the dictionary should be used:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">Use-As-Dictionary: match=&#34;/dist/styles.*.css&#34;
</code></pre>


<p>Think of the <code translate="no" dir="ltr">Use-As-Dictionary</code> header as a mechanism that applies to future versions of a resource that match the pattern specified within it. So, say your website ships all of its styles in a single CSS file. For simplicity&#39;s sake, say the first version of that resource is located at <code translate="no" dir="ltr">/dist/styles.v1.css</code>, and is sent with a <code translate="no" dir="ltr">Use-As-Dictionary</code> response header containing a <code translate="no" dir="ltr">match</code> value of <code translate="no" dir="ltr">/dist/styles.*.css</code>.</p>

<p>After some time passes, you update your website&#39;s CSS and ship a new version of it located at <code translate="no" dir="ltr">/dist/styles.v2.css</code>. Because the <code translate="no" dir="ltr">match</code> value used in the <code translate="no" dir="ltr">Use-As-Dictionary</code> response header from the previous version applies to this request, the browser will send a <code translate="no" dir="ltr">Available-Dictionary</code> header containing a hash of the dictionary encoded as a <a href="https://www.rfc-editor.org/rfc/rfc8941.html#name-byte-sequences">structured field byte sequence</a>:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">Accept-Encoding: gzip, br, zstd, br-d, zstd-d
Available-Dictionary: :pZGm1Av0IEBKARczz7exkNYsZb8LzaMrV7J32a2fFG4=:
</code></pre>


<p>At this point, it&#39;s up to the server to configure compression on its end to ensure the matching dictionary is used. The resource compressed with that dictionary will then be sent, and the available dictionary in the user&#39;s browser cache will be used to decompress it.</p>

<p>If you ship new code often for your website, delta compression can go a long way. However, the process is flexible. If the browser doesn&#39;t determine that a dictionary is available in the user&#39;s browser cache, it will <em>not</em> specify the additional <code translate="no" dir="ltr">br-d</code> or <code translate="no" dir="ltr">zstd-d</code> tokens in the <code translate="no" dir="ltr">Accept-Encoding</code> header. In that case, the standard compression flow applies.</p>





<p>Dynamic resources can also benefit from shared dictionary compression. Dynamic resources are those that change based on a context—such a news website where the main page is updated frequently as news breaks, for example. HTML documents are often dynamic resources. In such cases, the dictionary can contain most of the site&#39;s common HTML structure and template code leading to compressed pages where only the unique parts of each page are sent.</p>

<p>Due to the nature of dynamically-generated resources, a dictionary must be loaded on the client for later use. Loading a dictionary ahead of time means that applying shared dictionary compression to dynamic resources is speculative. The hope in such cases is that your website receives enough traffic that the dictionary cost can be amortized over a large number of navigations. Should you decide to try it, the first step is to specify the dictionary&#39;s location by way of a <code translate="no" dir="ltr">&lt;link&gt;</code> element in your page HTML:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">&lt;link rel=&#34;dictionary&#34; href=&#34;/dictionary.dat&#34;&gt;
</code></pre>
<p>When Chrome encounters this <code translate="no" dir="ltr">&lt;link&gt;</code> element, it <em>may</em> fetch the dictionary once the page is idle, and at low priority in an effort to avoid bandwidth contention. The response for the dictionary itself must specify a <code translate="no" dir="ltr">Use-As-Dictionary</code> header and specify which dynamic resource path it applies to:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">Use-As-Dictionary: match=&#34;/product/*&#34;
</code></pre>
<p>From here, the flow is largely the same as for static resources. The browser will see that the dictionary itself applies to matching resources, and the browser will attach an <code translate="no" dir="ltr">Available-Dictionary</code> header to the request with a hash of the dictionary&#39;s contents, again, similar to the static resources flow explained earlier.</p>



<h2 id="compress_static_resources_at_build_time" data-text="Compress static resources at build time" tabindex="-1">Compress static resources at build time</h2>

<p>If you&#39;re familiar with bundlers, you might be familiar with various plugins for them that can compress resources at build time, and subsequently serve those compressed resources. For example, <a href="https://bash-prompt.net/guides/apache-brotli-static/">Apache lets you use directives to serve those precompressed resources</a> at the time of the request. </p>

<p>Most Node.js-based bundlers that support compression use Node&#39;s built-in Zlib library. Zlib offers support for Brotli and bundlers that use it typically offer an interface to pass options directly into Zlib, which <a href="https://nodejs.org/api/zlib.html#class-options">supports dictionary-aided compression</a>. Here are a few bundlers that support using dictionaries:</p>

<ul>
<li>webpack&#39;s <code translate="no" dir="ltr">CompressionWebpackPlugin</code>, <a href="https://webpack.js.org/plugins/compression-webpack-plugin/#compressionoptions">through its <code translate="no" dir="ltr">compressionOptions</code> interface</a>.</li>
<li><a href="https://www.npmjs.com/package/rollup-plugin-brotli#configuration"><code translate="no" dir="ltr">rollup-plugin-brotli</code> offers an <code translate="no" dir="ltr">options</code> configuration</a> that passes straight through to Zlib in Node.js, where dictionaries can be specified.</li>
<li>The <a href="https://github.com/LinbuduLab/esbuild-plugins/tree/main/packages/esbuild-plugin-compress"><code translate="no" dir="ltr">esbuild-plugin-compress</code> third-party plugin</a> for esbuild also offers access to the Zlib options in Node.js.</li>
</ul>



<p>Note that available dictionaries for any given version of a resource may use one of any previous versions of a resource. This means that you will need to analyze user traffic and plan accordingly. Aim for a balance and generate resources that benefit the maximum number of returning users as best as you can. CDN providers are currently experimenting with shared dictionary compression. No implementations are yet available for public use, but we expect that to change!</p>

<h2 id="try_it_out" data-text="Try it out!" tabindex="-1">Try it out!</h2>

<p>Integrating shared dictionary compression with the browser&#39;s existing compression capabilities has the potential to substantially improve loading performance for websites that frequently ship updated production code and receive significant traffic from returning visitors. If you&#39;re interested in giving shared dictionary compression a shot, you have two options:</p>

<ol>
<li>If you&#39;re just looking to tinker with shared dictionary compression on your own to get a feel for how it works, you can enable the <strong>Compression dictionary transport</strong> experimental feature on the <code translate="no" dir="ltr">chrome://flags</code> page.</li>
<li>If you&#39;re interested in trying this out on your production website and see how shared dictionary compression could benefit real users, <a href="https://hazure.neocities.org/origintrials#/view_trial/2583940286203822081">register for the origin trial</a> to get a token, and read up on <a href="https://hazure.neocities.org/docs/web-platform/origin-trials">how origin trials work</a>.</li>
</ol>

<h2 id="conclusion" data-text="Conclusion" tabindex="-1">Conclusion</h2>

<p>We&#39;re quite excited about this major advancement in compression technology on the web, and how much faster it could make existing applications that people use every day. We encourage you to try it out, and most importantly, <a href="https://github.com/WICG/compression-dictionary-transport/issues">we want to hear your thoughts</a> if you do! If you find a bug, <a href="https://issues.chromium.org/issues">file it at crbug.com</a>. For additional resources and tools, check out <a href="https://use-as-dictionary.com/">use-as-dictionary.com</a>. Finally, if you&#39;re interested in a deeper dive into how it all works, <a href="https://github.com/WICG/compression-dictionary-transport/blob/main/README.md">the explainer</a> is a good next step!</p>

  

  
</div></div>
  </body>
</html>
