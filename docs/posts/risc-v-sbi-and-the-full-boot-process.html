<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/risc-v-sbi-and-full-boot-process/">Original</a>
    <h1>RISC-V SBI and the full boot process</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p>In the last article, we covered <a href="https://writing.natwelch.com/posts/bare-metal-programming-risc-v">bare metal programming on RISC-V</a>. Please familiarize yourself with that material before proceeding with the rest of this article, as this article is a direct continuation of the aforementioned one.</p>
<p>This time we are talking about RISC-V <strong>SBI (Supervisor Binary Interface)</strong>, with <strong>OpenSBI</strong> as the example. We’ll look at how SBI can assist us with implementing operating system kernel primitives and we’ll end the article with a practical example using <code>riscv64 virt</code> machine.</p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li>
<p><a href="#risc-v-and-bios">RISC-V and “BIOS”</a></p>
<ul>
<li><a href="#machine-modes">Machine modes</a></li>
<li><a href="#sbi">SBI</a></li>
<li><a href="#fancy-abstractions">Fancy abstractions</a></li>
<li><a href="#binary-interface">Binary interface</a></li>
</ul>
</li>
<li>
<p><a href="#practical-example-with-opensbi">Practical example with OpenSBI</a></p>
</li>
<li>
<p><a href="#booting-the-os-kernel-after-sbi-and-calling-into-opensbi">Booting the OS kernel after SBI and calling into OpenSBI</a></p>
<ul>
<li>
<p><a href="#what-really-happens-in-the-zsbl">What really happens in the ZSBL?</a></p>
</li>
<li>
<p><a href="#3-flavors-of-opensbi">3 flavors of OpenSBI</a></p>
<ul>
<li><a href="#fw_payload"><code>FW_PAYLOAD</code></a></li>
<li><a href="#fw_jump"><code>FW_JUMP</code></a></li>
<li><a href="#fw_dynamic"><code>FW_DYNAMIC</code></a></li>
<li><a href="#exploring-the-fw_dynamic_info-struct">Exploring the <code>fw_dynamic_info</code> struct</a></li>
<li><a href="#building-an-infinite-loop-fake-kernel">Building an “infinite-loop fake kernel”</a></li>
<li><a href="#intentionally-skipped-details">Intentionally skipped details</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#hello-world-fake-kernel">Hello world fake kernel</a></p>
</li>
<li>
<p><a href="#conclusion">Conclusion</a></p>
</li>
<li>
<p><a href="#code-pointers">Code pointers</a></p>
</li>
</ul>
</details>
<h2 id="risc-v-and-bios">RISC-V and “BIOS”</h2>
<p>In the article mentioned above, we talked extensively about the very first stages of the RISC-V bootup process. We mentioned that first the ZSBL (Zero Stage Bootloader) runs, initializes a few registers and jumps directly to some address hardcoded by ZSBL. In the case of QEMU’s <code>riscv64 virt</code>, the hardcoded address is <code>0x80000000</code>. This is where the first user-provided code runs, and if left to default, QEMU will load <code>OpenSBI</code> there.</p>
<h3 id="machine-modes">Machine modes</h3>
<p>So far we have avoided talking about different machine modes, and now is the perfect time to introduce them. The concept with machines modes is that not every piece of software should be able to access just about any memory address on the machine, or even execute just about any instructions available with the CPU. Traditionally, in a textbook example, the two main divisions are made here:</p>
<ol>
<li>Privileged mode</li>
<li>Unprivileged mode</li>
</ol>
<p>The <em>privileged mode</em> is where the machine starts at the boot time. Any instruction is permitted and no address access is considered an access violation. Once the operating system takes over the control of the system and starts launching the user code (aka userspace code), the modes start switching. When the user code is running on the CPU core, it is running within the <em>unprivileged mode</em> where not everything is accessible. Going back to the kernel mode means switching back to the privilged mode.</p>
<p>This is a very textbook and simplistic view at the permissions of operations and the question arises: why only 2 modes?</p>
<p>In systems, more than 2 modes typically exist, forming a <a href="https://en.wikipedia.org/wiki/Protection_ring">protection ring</a> with multiple access modes. RISC-V specification does not necessarily prescribe exactly which modes must be implemented for a core, except the <strong>M (Machine)</strong> mode. This is the most privileged mode.</p>
<p>Typically, the processors with M mode only are simple embedded systems, moving over more secure systems (M and S modes), all the way to full systems that can run Unix-like operating systems (M, S and U modes).</p>
<h3 id="sbi">SBI</h3>
<p>The <a href="https://github.com/riscv-non-isa/riscv-sbi-doc">official docs</a> provide a formal definition, and I will try to water it down here with the goals of making it more intuitive.</p>
<p>RISC-V’s SBI spec defines the layer of software that sits at the bottom of the RISC-V software stack. This is very similar to BIOS, which is traditionally the first bit of software that runs on a machine. You might have seen some of the guides for developing a simple kernel from scratch, and they typically involve something similar to what we did in the <a href="https://writing.natwelch.com/posts/bare-metal-programming-risc-v">initial guide</a> for bare metal programming on RISC-V, with a small twist — they are very often actually depending on the pre-existing software to do some I/O. The similarity to our previous guide is that they also carefully align the first instructions to the correct address to ensure that the processor’s execution flow goes as intended and the simple kernel takes over at the right time, however, what I have typically observed in those short guides is that the goal is typically to print something like ‘Hello world’ to <strong>the VGA screen</strong>. This last bit sounds like a fairly complex operation, and it really is.</p>
<p>How is printing to the VGA then done easily then? The answer is that BIOS is here to assist with the most basic I/O operations such as printing some characters to the screen, hence its name — <strong>B</strong>asic <strong>I</strong>nput <strong>O</strong>utput <strong>S</strong>ystem! Please pay attention to the opening section of the bare metal programming guide: we were achieving interaction with the user <em>without</em> depending on <em>any</em> existing software on the machine (well, almost true, we still went through the Zero Stage Bootloader, but we didn’t depend on any outcome from it, nor we really had any control over it; it’s simply hardcoded into the system). If we were to print something on the VGA screen, instead of sending characters out through UART, we would have to do a lot more than send an ASCII code to a single address. VGA involves setting up the display device into the right mode, by sending multiple values over, setting up different parameters, etc. It’s a fairly ellaborate operation.</p>
<p>So how does BIOS traditionally help with tasks like these? The main concept is that whatever operating system ends up installed on the machine, it would anyway need some basic functionality, such as printing some information to the VGA screen. Thus, the machine can have these standard operations simply baked into it and ready to consume by whatever operating system ends up on the machine. Conceptually, we can think of these procedures as an everyday library we write our applications against.</p>
<p>Additionally, if an operating system is written against such a “library”, it automatically becomes more portable. The “library” should have all the low level details, such as “outputting to UART means writing to <code>0x10000000</code>” (as is the case with QEMU’s <code>riscv64 virt</code> VM), vs. “outputting to UART means writing to <code>0x12345678</code>”, and the operating system simply needs to invoke “outputting to UART” procedure, while this “library” will know exactly how to interact with the hardware.</p>
<h3 id="fancy-abstractions">Fancy abstractions</h3>
<p>This is all just a lot of talk for a very simple concept we have been using in programming since day 1: we apply <strong>layers of abstractions</strong> in our coding. Think of something like a Python function that does something like “sending a local file to an email address”. From a high level perspective, we simply call a function <code>send_file_to_email(file, email)</code> and the underlying library opens up the network connection and starts pumping the bytes. This could be just another Python library. At some point, that will likely move down the software stack, and the Python library will depend on the Python runtime written in something like C to make a system call to the operating system (for example, to perform a core operation such as opening a network socket). The operating system has a network driver somewhere deep down, which knows to which address in the address space does it need to send the individual bytes in order to send the bytes over the wire to the network and so on. The main concept here is that we have an established way of hiding the complexity of operations by delegating them to the lower layers of the software stack. We built the larger system not from the atomic parts, but out of “molecules”.</p>
<p>If we’re delegating the complexity to the underlying library, it probably just means a function call. However, once it’s time to delegate the complexity to the operating system and lower, this happens through a <strong>binary interface</strong>.</p>
<h3 id="binary-interface">Binary interface</h3>
<p>Since basically forever, the <code>x86</code> has been the dominant architecture for the computers we use, be it desktops or laptops. Things have been changing a lot lately, and other architectures are entering the picture, but let’s focus on just <code>x86</code>. What then, makes an application built for Linux incompatible with the application for Windows? If it’s written for <code>x86</code>, and both Linux and Windows run on <code>x86</code>, what could possibly be the differentiator here? The CPU instructions are not different from one platform and the other, so what could it be? The answer is the <strong>interface between the application and the operating system</strong>. This particular link between the user software and the operating system is called the <strong>application binary interface (ABI)</strong>. ABI is just a definition that says how the services from the operating system are invoked from the user application.</p>
<p>Therefore, when we say something like “this software is written for platform X”, it’s not enough to just say that X is <code>x86</code> or <code>RISC-V</code>, we must say <code>x86/Linux</code> or <code>x86/Windows</code> or <code>RISC-V Linux</code> etc. The platform definition may be even more complex than that if things like dynamic linking are involved, but let us not go there for now.</p>
<p>Let’s take a quick example at a program written in assembly for <code>x86/Linux</code> that just prints a ‘Hello’ string to the standard output.</p>
<pre is:raw="" tabindex="0"><code><span><span>.global _start</span></span>
<span></span>
<span><span>.</span><span>section .text</span></span>
<span></span>
<span><span>_start:</span><span> </span><span>mov</span><span> </span><span>$4</span><span>, %</span><span>eax</span><span> </span><span>; 4 is the code for the &#39;write&#39; system call</span></span>
<span><span>        </span><span>mov</span><span> </span><span>$1</span><span>, %</span><span>ebx</span><span> </span><span>; We are writing to file 1, i.e. the &#39;standard output&#39;</span></span>
<span><span>        </span><span>mov</span><span> </span><span>$message</span><span>, %</span><span>ecx</span><span> </span><span>; The data we want to print is at the address defined by the symbol message</span></span>
<span><span>        </span><span>mov</span><span> </span><span>$5</span><span>, %</span><span>edx</span><span> </span><span>; The length of the data we want to print is 5</span></span>
<span><span>        </span><span>int</span><span> </span><span>$0x80</span><span> </span><span>; Invoke the system call, i.e. ask kernel to print the data to the standard output</span></span>
<span></span>
<span><span>        </span><span>mov</span><span> </span><span>$1</span><span>, %</span><span>eax</span><span> </span><span>; 1 is the code for the &#39;exit&#39; system call</span></span>
<span><span>        </span><span>mov</span><span> </span><span>$0</span><span>, %</span><span>ebx</span><span> </span><span>; 0 is the process return code</span></span>
<span><span>        </span><span>int</span><span> </span><span>$0x80</span><span>  </span><span>; Invoke the system call, i.e. ask the the kernel to close this process</span></span>
<span></span>
<span><span>.</span><span>section .data</span></span>
<span><span>message:</span><span> .ascii &#34;Hello&#34;</span></span></code></pre>
<p>Assemble this program with:</p>
<pre is:raw="" tabindex="0"><code><span><span>as -o syscall.o syscall.s</span></span></code></pre>
<p>Link it with:</p>
<pre is:raw="" tabindex="0"><code><span><span>ld -o syscall syscall.o</span></span></code></pre>
<p>Run with:</p>
<pre is:raw="" tabindex="0"><code><span><span>./syscall</span></span></code></pre>
<p>You should see the output “Hello”. If you’re on Bash and you also want to double check the process return code, simply run:</p>
<pre is:raw="" tabindex="0"><code><span><span>echo $?</span></span></code></pre>
<p>And you should see <code>0</code>.</p>
<p><em>Tip: If you want to try out this example from above, but you do not have access to an x86/Linux machine, you can do this through a JavaScript VM that emulates an x86 system in-browser <a href="https://bellard.org/jslinux/">here</a>; that’s a really cool website!</em></p>
<p>And there we have it: a program which prints a message to the standard output when run on an <code>x86</code> machine with a Linux kernel. C standard library <strong>was not used</strong>. The final <code>ELF</code> binary should run on Linux with no dependencies other than it is run on the correct platform.</p>
<p>Now back to the question, what makes this binary incompatible with Windows (potentially)? <strong>Another operating system encodes the system calls differently (e.g. writing isn’t code 4, but code 123, or the parameters are passed through different CPU registers).</strong> And now you have a good idea of how to directly interface with the kernel, without the assistance of the standard library (although you probably almost never want to do it). This means you have uncovered the layer at which software does things like opening files, allocates memory, sends signals, etc. The C standard library can be thought of as a wrapper which hides this complexity of invoking software interrupts through the <code>int</code> instruction to communicate with the kernel, and instead makes it look like a normal call to a C function, and then under the hood, this is what it is. To be fair, the library does a lot more than that, but for the purposes of this article, it can be thought of simply as a wrapper.</p>
<p>And now in the RISC-V world, we have the same thing: the user application interfaces with the kernel through software interrupt CPU instructions, and passing the parameters through the CPU registers. And the kernel basically does <strong>the same thing</strong> with the SBI in order to invoke its services! It’s just that this final layer of logic invocation is called the <strong>SBI</strong>, not the <strong>ABI</strong>. A way to think about it is that it is not the <strong>application</strong> that works in the lower layer, but rather the <strong>supervisor</strong> of the applications. The difference, however, is in the name only, and the concept remains absolutely the same.</p>
<h2 id="practical-example-with-opensbi">Practical example with OpenSBI</h2>
<p>At this point we have established that SBI, much like ABI, is just a way of invoking a functionality in the lower layers of the software stack. Furthermore, we also established the SBI sits at the bottom of the software stack on a RISC-V machine, and runs in the most privileged M mode. Let’s add some more details to this picture.</p>
<p>It should also make sense at this point why the QEMU developers chose the <code>-bios</code> flag in order to accept the SBI software image (because the functionality is basically the same as BIOS). As a reminder, the <code>-bios</code> flag should point to an <code>ELF</code> file that will lay out the SBI software out in memory starting from address <code>0x80000000</code>.</p>
<p>Let’s start the QEMU’s VM with just OpenSBI loaded, and see what happens. We shouldn’t really have to pass anything to QEMU since it defaults to loading OpenSBI at <code>0x80000000</code>.</p>
<pre is:raw="" tabindex="0"><code><span><span>qemu-system-riscv64 -machine virt</span></span></code></pre>
<p>This is the output (on the serial port, not VGA):</p>
<pre is:raw="" tabindex="0"><code><span><span>OpenSBI v0.8</span></span>
<span><span>   ____                    _____ ____ _____</span></span>
<span><span>  / __ \                  / ____|  _ \_   _|</span></span>
<span><span> | |  | |_ __   ___ _ __ | (___ | |_) || |</span></span>
<span><span> | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |</span></span>
<span><span> | |__| | |_) |  __/ | | |____) | |_) || |_</span></span>
<span><span>  \____/| .__/ \___|_| |_|_____/|____/_____|</span></span>
<span><span>        | |</span></span>
<span><span>        |_|</span></span>
<span><span></span></span>
<span><span>Platform Name       : riscv-virtio,qemu</span></span>
<span><span>Platform Features   : timer,mfdeleg</span></span>
<span><span>Platform HART Count : 1</span></span>
<span><span>Boot HART ID        : 0</span></span>
<span><span>Boot HART ISA       : rv64imafdcsu</span></span>
<span><span>BOOT HART Features  : pmp,scounteren,mcounteren,time</span></span>
<span><span>BOOT HART PMP Count : 16</span></span>
<span><span>Firmware Base       : 0x80000000</span></span>
<span><span>Firmware Size       : 96 KB</span></span>
<span><span>Runtime SBI Version : 0.2</span></span>
<span><span></span></span>
<span><span>MIDELEG : 0x0000000000000222</span></span>
<span><span>MEDELEG : 0x000000000000b109</span></span>
<span><span>PMP0    : 0x0000000080000000-0x000000008001ffff (A)</span></span>
<span><span>PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)</span></span></code></pre>
<p>The machine keeps spinning in place, presumably because it is set up to do so by default since there is no other piece of software passed to QEMU to take over the control after OpenSBI. At this point, things look good, it seems like OpenSBI has been set up properly (and its output confirms that it sits right at <code>0x80000000</code>).</p>
<p>How do we keep going up the software stack, how do we add a new layer? The new layer could be something like an operating system kernel, so similarly to how we have previously built an <code>ELF</code> file containing instructions to be placed at <code>0x80000000</code>, we will build another <code>ELF</code> file for QEMU to load into its memory, but this time the instructions will come to another address, since the portion starting at <code>0x80000000</code> has already been taken over by OpenSBI.</p>
<p>Which address should we load our fake “kernel” at, then?</p>
<h2 id="booting-the-os-kernel-after-sbi-and-calling-into-opensbi">Booting the OS kernel after SBI and calling into OpenSBI</h2>
<p>When we loaded the BIOS/SBI/whatever you want to call it, the address was basically burnt into the machine’s logic. The first few instructions were Zero Stage Bootloader (ZSBL) and the final instruction from there was jumping to the hardcoded address <code>0x80000000</code>. As we previously mentioned, this is an immutable fact of the platform we’re working with, it’s just simply what it does. However, that’s all it really hardcodes at this point: it just hardcodes that you will have to start from <code>0x80000000</code>, and now we have OpenSBI placed there, so where does OpenSBI take us next?</p>
<p>Now enters the importance of the <strong>ZSBL</strong> again and now it really matters how it initializes those registers before performing that hardcoded jump to <code>0x80000000</code>. What ZSBL really does is two things:</p>
<ol>
<li>Ensures that the software running <strong>after</strong> OpenSBI’s initialization can run, and this is basically the OS kernel bootloader, or it could be the kernel itself directly (which is what you typically see in QEMU guides where you launch Linux, bootloader is skipped and the memory is immediately loaded with the kernel).</li>
<li>Jumps to the OpenSBI.</li>
</ol>
<p>We have covered the second point in great detail so far, so let’s now dig deeper into how does it accomplish point #1.</p>
<h3 id="what-really-happens-in-the-zsbl">What really happens in the ZSBL?</h3>
<p>We have mentioned before that ZSBL execution starts at the address <code>0x1000</code>. Let’s trace the execution through QEMU and see what’s going on. To do that, we’ll add 2 flags to the QEMU CLI command: <code>-s</code> and <code>-S</code>. These flags ensure that QEMU exposes a <code>gdb</code> debug port, and additionally, the VM pauses immediately upon creation, waiting for us to drive it manually (which we will do through <code>gdb</code>).</p>
<p>Let’s begin this reverse engineering process. We’re starting QEMU as so:</p>
<pre is:raw="" tabindex="0"><code><span><span>qemu-system-riscv64 -machine virt -s -S</span></span></code></pre>
<p>In another terminal, we connect to the <code>gdb</code> server nested in QEMU, so we can drive the VM forward. I am doing this on an <code>x86</code> machine, so I will use <code>gdb-multiarch</code> so I can do a cross-platform debug for <code>riscv</code>. So in this new terminal, I just run:</p>
<pre is:raw="" tabindex="0"><code><span><span>gdb-multiarch</span></span></code></pre>
<p>I want to set up a few things before I connect into the VM to drive it forward:</p>
<pre is:raw="" tabindex="0"><code><span><span>set architecture riscv:rv64</span></span></code></pre>
<p>It should be obvious what the line above does. Next, I want to get the actual running instruction printed to my terminal each time I move one instruction:</p>
<pre is:raw="" tabindex="0"><code><span><span>set disassemble-next-line on</span></span></code></pre>
<p>It’s time to connect to the QEMU <code>gdb</code> server (port <code>1234</code> is I believe hardcoded by QEMU, though it <em>may</em> be configurable by the <code>-s</code> flag somehow; I never tried it and I don’t think you’ll need to change this behavior)</p>
<pre is:raw="" tabindex="0"><code><span><span>target remote :1234</span></span></code></pre>
<p>And right there, <code>gdb</code> is waiting for us at <code>0x1000</code>, exactly where the very first instruction after power on happens. We will use <code>si</code> a few times to step through instructions one by one, until we get to the jump to SBI at <code>0x80000000</code>.</p>
<pre is:raw="" tabindex="0"><code><span><span>(gdb) target remote:1234</span></span>
<span><span>Remote debugging using :1234</span></span>
<span><span>warning: No executable has been specified and target does not support</span></span>
<span><span>determining executable automatically.  Try using the &#34;file&#34; command.</span></span>
<span><span>0x0000000000001000 in ?? ()</span></span>
<span><span>=&gt; 0x0000000000001000:	97 02 00 00	auipc	t0,0x0</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x0000000000001004 in ?? ()</span></span>
<span><span>=&gt; 0x0000000000001004:	13 86 82 02	addi	a2,t0,40</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x0000000000001008 in ?? ()</span></span>
<span><span>=&gt; 0x0000000000001008:	73 25 40 f1	csrr	a0,mhartid</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x000000000000100c in ?? ()</span></span>
<span><span>=&gt; 0x000000000000100c:	83 b5 02 02	ld	a1,32(t0)</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x0000000000001010 in ?? ()</span></span>
<span><span>=&gt; 0x0000000000001010:	83 b2 82 01	ld	t0,24(t0)</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x0000000000001014 in ?? ()</span></span>
<span><span>=&gt; 0x0000000000001014:	67 80 02 00	jr	t0</span></span>
<span><span>(gdb) si</span></span>
<span><span>0x0000000080000000 in ?? ()</span></span>
<span><span>=&gt; 0x0000000080000000:	33 04 05 00	add	s0,a0,zero</span></span></code></pre>
<p>There were only 6 instructions in ZSBL before handing the control over to the OpenSBI, including the jump itself. However, what are these few instructions that happened, what is their significance?</p>
<p>It turns out that all this is part of the SBI specification too, it’s a part of the boot sequence. However, with OpenSBI, there are 3 different flavors of this dance, and let’s look at those flavors first before getting into a lot of details on what happens after the ZSBL.</p>
<h3 id="3-flavors-of-opensbi">3 flavors of OpenSBI</h3>
<p>You can build OpenSBI in 3 different ways:</p>
<ol>
<li><code>FW_PAYLOAD</code> (<a href="https://github.com/riscv-software-src/opensbi/blob/master/docs/firmware/fw_payload.md">official docs</a>)</li>
<li><code>FW_JUMP</code> (<a href="https://github.com/riscv-software-src/opensbi/blob/master/docs/firmware/fw_jump.md">official docs</a>)</li>
<li><code>FW_DYNAMIC</code> (<a href="https://github.com/riscv-software-src/opensbi/blob/master/docs/firmware/fw_dynamic.md">official docs</a>)</li>
</ol>
<h4 id="fw_payload"><code>FW_PAYLOAD</code></h4>
<p>This one is probably the easiest to understand conceptually. When building this flavor of OpenSBI, you will literally point the <code>make</code> tool to your kernel/“whatever you want to run after OpenSBI” image and you will get a single binary payload that you can directly load wherever you first CPU instructions start from (in QEMU’s VM case, <code>0x80000000</code>). As I understand, it is possible to tweak the exact location of your software in relation to the OpenSBI blob in the memory, but for simplicity, the mental model we can apply here is that OpenSBI and your software blob are spliced together into a single blob and once the OpenSBI initialization finishes, the very next instruction is your software (you basically slide right into your software after OpenSBI).</p>
<p>The way to achieve this is:</p>
<ol>
<li>Make sure <code>FW_PAYLOAD=y</code> is set in the <code>make</code> process, this will ensure a file called <code>fw_payload</code> is generated.</li>
<li>Point <code>FW_PAYLOAD_PATH</code> in your <code>make</code> process to the software you want to run after OpenSBI.</li>
</ol>
<p>Per the docs linked aboved, if you skip the second flag, a very simple piece of software will be spliced with OpenSBI: a blank infinite loop. That explains why when we just launched QEMU with no flags, basically with OpenSBI only, the machine kept spinning in place — OpenSBI was likely built this way (since you can’t just keep executing random contents of the memory) and it was just busy waiting in place.</p>
<p>The upside of this approach is that now you have a single, spliced, monolithic software image to load into your machine. You don’t have to deal with multiple floating pieces, just one monolith. If your build process for the software is straightforward, you may even end up with a really easy way to manage all the software on the target machine, while getting all the upside of having OpenSBI do some work for you.</p>
<p>The downside is that you are now responsible for building everything together, including OpenSBI. What’s worse, if the machine already had OpenSBI, let’s imagine, burnt into some ROM, it already has OpenSBI to boot up, having it twice on a machine likely won’t cut it.</p>
<h4 id="fw_jump"><code>FW_JUMP</code></h4>
<p>This one is fairly simple too: you basically hardcode the address of your software that comes after OpenSBI. Similarly to above, 2 steps are needed.</p>
<ol>
<li>Make sure <code>FW_JUMP=y</code> is set in the <code>make</code> process, this will ensure a file called <code>fw_jump</code> is generated.</li>
<li>Set <code>FW_JUMP_ADDR</code> in the <code>make</code> process to the address where OpenSBI should jump once its done.</li>
</ol>
<p>This is quite similar to what we had in the previous scenario, only the jump address is hardcoded. It seems like in this case you are still necessarily responsible for building the OpenSBI image, but it’s easy to rebuild it and point to different addresses for different machines (let’s say different machines with varying memory layouts).</p>
<h4 id="fw_dynamic"><code>FW_DYNAMIC</code></h4>
<p>This one is the most generalized flavor and that’s why we leave it for last. This is where the importance of the register set up in ZSLB shines.</p>
<p>In this flavor, the boot stage that happens before OpenSBI is in charge of passing a few pointers to OpenSBI. In this case, we’re of course talking about the ZSBL. If we play close attention, we see that it touches the register <code>a2</code>.</p>
<p>At this point, I would like to encourage the reader to also read the section on ZSBL from <a href="https://embeddedinn.xyz/articles/tutorial/RISCV-Uncovering-the-Mysteries-of-Linux-Boot-on-RISC-V-QEMU-Machines/#the-zero-stage-bootloader-zsbl">this article</a>. The whole article is great, I just initially found it a little tough to go through, so consider this article a warmup for understanding that article, it’s really worth going through.</p>
<p>Anyway, keeping this article watered down still — what is the significance of setting up the register <code>a2</code> in ZSBL? <strong>It points to a struct <code>struct fw_dynamic_info</code></strong> which gives the dynamic OpenSBI flavor a way to continue going through the boot process! In fact, one of the piece of data in this struct is the address of the next piece of software running after OpenSBI! A good question to ask is: on a real machine, who populates this struct? Based on what we’ll see below, it’s obvious that QEMU hardcodes this content into the memory, and that logic is not part a of the ZSBL, but I can definitely imagine a device where ZSBL actually populates this struct and passes it on to OpenSBI.</p>
<p>Slide 17 of <a href="https://riscv.org/wp-content/uploads/2019/06/13.30-RISCV_OpenSBI_Deep_Dive_v5.pdf">this presentation</a> by an engineer from Western Digital (presumably a core contributor to OpenSBI) outlines the contents of this <code>struct</code>:</p>
<ol>
<li>Magic number</li>
<li>Version</li>
<li>Next address</li>
<li>Next mode</li>
<li>Options</li>
</ol>
<p>All of these are unsigned longs (I guess that means 64 bit, 8 bytes?).</p>
<h4 id="exploring-the-fw_dynamic_info-struct">Exploring the <code>fw_dynamic_info</code> struct</h4>
<p>At this point, let’s take a quick detour to make sure we’re on the same page. Let’s quickly make sure we’re all looking at the same version of the OpenSBI because different systems have different version of QEMU which may come with a different version of OpenSBI. Building OpenSBI from source is really straightforward, so let’s quickly do it. First, we need to clone the Git repo (time of writing of this article is 10th Sept 2023; if you want to achieve full reproducibility, build at a commit at this date):</p>
<pre is:raw="" tabindex="0"><code><span><span>git clone https://github.com/riscv-software-src/opensbi.git</span></span>
<span><span>cd opensbi</span></span>
<span><span>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- PLATFORM=generic</span></span></code></pre>
<p>The build should be fairly fast and lightweight. The output file we’re interested in is <code>build/platform/generic/firmware/fw_dynamic.bin</code>. We’ll pass this through the <code>-bios</code> flag to QEMU. Starting QEMU with (from the <code>opensbi</code> folder we just cloned with Git):</p>
<pre is:raw="" tabindex="0"><code><span><span>qemu-system-riscv64 -machine virt -s -S -bios build/platform/generic/firmware/fw_dynamic.bin</span></span></code></pre>
<p>After a few <code>si</code>s in <code>gdb</code>, we get back to where we were before. Let’s poke QEMU’s memory to see what’s going on there at the end of ZSBL. At the last instruction of ZSBL, we look at the register dump (we use <code>i r</code> for this).</p>
<pre is:raw="" tabindex="0"><code><span><span>=&gt; 0x0000000080000000:	33 04 05 00	add	s0,a0,zero</span></span>
<span><span>(gdb) i r</span></span>
<span><span>ra             0x0	0x0</span></span>
<span><span>sp             0x0	0x0</span></span>
<span><span>gp             0x0	0x0</span></span>
<span><span>tp             0x0	0x0</span></span>
<span><span>t0             0x80000000	2147483648</span></span>
<span><span>t1             0x0	0</span></span>
<span><span>t2             0x0	0</span></span>
<span><span>fp             0x0	0x0</span></span>
<span><span>s1             0x0	0</span></span>
<span><span>a0             0x0	0</span></span>
<span><span>a1             0x87e00000	2279604224</span></span>
<span><span>a2             0x1028	4136</span></span>
<span><span>a3             0x0	0</span></span>
<span><span>a4             0x0	0</span></span>
<span><span>a5             0x0	0</span></span>
<span><span>a6             0x0	0</span></span>
<span><span>a7             0x0	0</span></span>
<span><span>s2             0x0	0</span></span>
<span><span>s3             0x0	0</span></span>
<span><span>s4             0x0	0</span></span>
<span><span>s5             0x0	0</span></span>
<span><span>s6             0x0	0</span></span>
<span><span>s7             0x0	0</span></span>
<span><span>s8             0x0	0</span></span>
<span><span>s9             0x0	0</span></span>
<span><span>s10            0x0	0</span></span>
<span><span>s11            0x0	0</span></span>
<span><span>t3             0x0	0</span></span>
<span><span>t4             0x0	0</span></span>
<span><span>t5             0x0	0</span></span>
<span><span>t6             0x0	0</span></span>
<span><span>pc             0x80000000	0x80000000</span></span></code></pre>
<p><code>a2</code> is therefore pointing to <code>0x1028</code>. As we said, let’s poke that memory with <code>gdb</code>. We’ll ask it to read 10 successive 8-byte values starting from <code>0x1028</code>, and display them in hex format.</p>
<pre is:raw="" tabindex="0"><code><span><span>(gdb) x/10xg 0x1028</span></span></code></pre>
<p>The <code>g</code> flag prints out the memory contents in 8-byte (giant) chunks.</p>
<pre is:raw="" tabindex="0"><code><span><span>(gdb) x/10xg 0x1028</span></span>
<span><span>0x1028:	0x000000004942534f	0x0000000000000002</span></span>
<span><span>0x1038:	0x0000000000000000	0x0000000000000001</span></span>
<span><span>0x1048:	0x0000000000000000	0x0000000000000000</span></span>
<span><span>0x1058:	0x0000000000000000	0x0000000000000000</span></span>
<span><span>0x1068:	0x0000000000000000	0x0000000000000000</span></span></code></pre>
<p>This roughly seems to match <a href="https://embeddedinn.xyz/articles/tutorial/RISCV-Uncovering-the-Mysteries-of-Linux-Boot-on-RISC-V-QEMU-Machines/#the-zero-stage-bootloader-zsbl">Vysakh’s article</a>. We definitely see the magic described in that article, followed by the <code>0x02</code> info version. Next should be the address for the next jump, but there are all zeroes… This is strange, but let’s keep looking. Next value is <code>0x01</code> which again, according to the article, should correspond to the next mode of execution which is <code>S</code>. This is correct, we’re going from <code>M</code> mode running SBI to the <code>S</code> mode running the OS kernel bootloader, or the kernel itself, whatever we want. Why is the address of the next jump all zeroes though? At this point, I’ll just let QEMU run without interference from <code>gdb</code>. I run the following in <code>gdb</code>:</p>
<pre is:raw="" tabindex="0"><code><span><span>continue</span></span></code></pre>
<p>Everything is sort of hanging, but I got a newer OpenSBI output on UART since I am now running a newer version of OpenSBI:</p>
<pre is:raw="" tabindex="0"><code><span><span>OpenSBI v1.3-54-g901d3d7</span></span>
<span><span>   ____                    _____ ____ _____</span></span>
<span><span>  / __ \                  / ____|  _ \_   _|</span></span>
<span><span> | |  | |_ __   ___ _ __ | (___ | |_) || |</span></span>
<span><span> | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |</span></span>
<span><span> | |__| | |_) |  __/ | | |____) | |_) || |_</span></span>
<span><span>  \____/| .__/ \___|_| |_|_____/|____/_____|</span></span>
<span><span>        | |</span></span>
<span><span>        |_|</span></span>
<span><span></span></span>
<span><span>Platform Name             : riscv-virtio,qemu</span></span>
<span><span>Platform Features         : medeleg</span></span>
<span><span>Platform HART Count       : 1</span></span>
<span><span>Platform IPI Device       : aclint-mswi</span></span>
<span><span>Platform Timer Device     : aclint-mtimer @ 10000000Hz</span></span>
<span><span>Platform Console Device   : uart8250</span></span>
<span><span>Platform HSM Device       : ---</span></span>
<span><span>Platform PMU Device       : ---</span></span>
<span><span>Platform Reboot Device    : syscon-reboot</span></span>
<span><span>Platform Shutdown Device  : syscon-poweroff</span></span>
<span><span>Platform Suspend Device   : ---</span></span>
<span><span>Platform CPPC Device      : ---</span></span>
<span><span>Firmware Base             : 0x80000000</span></span>
<span><span>Firmware Size             : 322 KB</span></span>
<span><span>Firmware RW Offset        : 0x40000</span></span>
<span><span>Firmware RW Size          : 66 KB</span></span>
<span><span>Firmware Heap Offset      : 0x48000</span></span>
<span><span>Firmware Heap Size        : 34 KB (total), 2 KB (reserved), 9 KB (used), 22 KB (free)</span></span>
<span><span>Firmware Scratch Size     : 4096 B (total), 768 B (used), 3328 B (free)</span></span>
<span><span>Runtime SBI Version       : 1.0</span></span>
<span><span></span></span>
<span><span>Domain0 Name              : root</span></span>
<span><span>Domain0 Boot HART         : 0</span></span>
<span><span>Domain0 HARTs             : 0*</span></span>
<span><span>Domain0 Region00          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()</span></span>
<span><span>Domain0 Region01          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()</span></span>
<span><span>Domain0 Region02          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()</span></span>
<span><span>Domain0 Region03          : 0x0000000000000000-0xffffffffffffffff M: () S/U: (R,W,X)</span></span>
<span><span>Domain0 Next Address      : 0x0000000000000000</span></span>
<span><span>Domain0 Next Arg1         : 0x0000000087e00000</span></span>
<span><span>Domain0 Next Mode         : S-mode</span></span>
<span><span>Domain0 SysReset          : yes</span></span>
<span><span>Domain0 SysSuspend        : yes</span></span>
<span><span></span></span>
<span><span>Boot HART ID              : 0</span></span>
<span><span>Boot HART Domain          : root</span></span>
<span><span>Boot HART Priv Version    : v1.10</span></span>
<span><span>Boot HART Base ISA        : rv64imafdc</span></span>
<span><span>Boot HART ISA Extensions  : zicntr</span></span>
<span><span>Boot HART PMP Count       : 16</span></span>
<span><span>Boot HART PMP Granularity : 4</span></span>
<span><span>Boot HART PMP Address Bits: 54</span></span>
<span><span>Boot HART MHPM Info       : 0 (0x00000000)</span></span>
<span><span>Boot HART MIDELEG         : 0x0000000000000222</span></span>
<span><span>Boot HART MEDELEG         : 0x000000000000b109</span></span></code></pre>
<p>This matches what we saw above, the next address is all zeroes… This is strange, there’s no way that could be true. I now ran QEMU without the initial pause, just letting it run and connecting with <code>gdb</code> asynchronously. I’ll spare you the details, but inspecting the registers on that “live run” definitely showed to me that nothing is executing in the <code>0x0000000000000000</code> area. The CPU seems to be spinning around some other address.</p>
<p>This likely has something to do with the fact that I actually didn’t pass any software to QEMU to load other than OpenSBI, so that’s probably what’s throwing it off. QEMU likely populated the struct in memory with all zeroes, and OpenSBI identifies it as an illegal edge case, so it just keeps spinning in OpenSBI forever — this is my educated guess.</p>
<p>How do we pass some software to run other than OpenSBI? <strong>The same way we passed OpenSBI, just a diferent flag name!</strong> This time, we’re using the <code>-kernel</code> QEMU flag. And how are we going to build this software? The same way we built the “fake BIOS” in our previous article, we’ll just map it to a different memory location. Let’s give it a shot at <code>0x80200000</code>.</p>
<h4 id="building-an-infinite-loop-fake-kernel">Building an “infinite-loop fake kernel”</h4>
<p>Our OS kernel will just spin in place. It will be a single jump instruction at <code>0x80200000</code> that just stays there infinitely. Here’s the assembly source code:</p>
<pre is:raw="" tabindex="0"><code><span><span>	.global _start</span></span>
<span><span>	.</span><span>section .text</span><span>.kernel</span></span>
<span></span>
<span><span>_start:</span><span>	j _start</span></span></code></pre>
<p>The linker script is the following:</p>
<pre is:raw="" tabindex="0"><code><span><span>MEMORY {</span></span>
<span><span>  kernel_space (rwx) : ORIGIN = 0x80200000, LENGTH = 128</span></span>
<span><span>}</span></span>
<span><span></span></span>
<span><span>SECTIONS {</span></span>
<span><span>  .text : {</span></span>
<span><span>    infinite_loop.o(.text.kernel)</span></span>
<span><span>  } &gt; kernel_space</span></span>
<span><span>}</span></span></code></pre>
<p><em>For details on how to use these files to build an <code>ELF</code> image that can be loaded into QEMU, please see the original bare metal programming article.</em></p>
<p>Once we build it, we end up with the <code>infinte_loop</code> <code>ELF</code> file that can serve as our fake kernel. We now run QEMU</p>
<pre is:raw="" tabindex="0"><code><span><span>qemu-system-riscv64 -machine virt -s -S -bios build/platform/generic/firmware/fw_dynamic.bin -kernel ~/work/github_demo/risc-v-bare-metal-fake-kernel/infinite_loop</span></span></code></pre>
<p>Again, I connect <code>gdb</code> and <code>si</code> my way to the end of ZSBL. Now when I read the infamous struct at <code>0x1028</code>, things look a lot better, which confirms the theory that QEMU was populating that struct weirdly.</p>
<pre is:raw="" tabindex="0"><code><span><span>=&gt; 0x0000000080000000:	33 04 05 00	add	s0,a0,zero</span></span>
<span><span>(gdb) x/10xg 0x1028</span></span>
<span><span>0x1028:	0x000000004942534f	0x0000000000000002</span></span>
<span><span>0x1038:	0x0000000080200000	0x0000000000000001</span></span>
<span><span>0x1048:	0x0000000000000000	0x0000000000000000</span></span>
<span><span>0x1058:	0x0000000000000000	0x0000000000000000</span></span>
<span><span>0x1068:	0x0000000000000000	0x0000000000000000</span></span></code></pre>
<p>We now see that the new address is populated in this struct, as is expected. This is also reflected in the OpenSBI output on UART. Let’s continue to our fake kernel with <code>gdb</code> and see if everything is OK there.</p>
<pre is:raw="" tabindex="0"><code><span><span>(gdb) break *0x080200000</span></span>
<span><span>Breakpoint 1 at 0x80200000</span></span>
<span><span>(gdb) continue</span></span>
<span><span>Continuing.</span></span>
<span><span></span></span>
<span><span>Breakpoint 1, 0x0000000080200000 in ?? ()</span></span>
<span><span>=&gt; 0x0000000080200000:	6f 00 00 00	j	0x80200000</span></span></code></pre>
<p>Everything looks good here. Let’s recap:</p>
<ol>
<li>ZSBL is the first thing that runs after the power-on. It initializes a few registers. The key register is <code>a2</code>, which points to a <code>fw_dynamic_info</code> struct containing the crucial info for the <code>FW_DYNAMIC</code> flavor of OpenSBI to operate. In QEMU case, this struct is somehow populated during the power-on, magically by the virutalization engine, but in reality, this is <strong>likely</strong> the job of the ZSBL. Either way, OpenSBI now knows what to do after it’s done.</li>
<li>OpenSBI provides an interrupt-based interface for the software up on the stack (presumably OS kernel bootloader and kernel itself) to invoke it. This interface is called SBI and it’s conceptually the same as ABI for the application software on top of an operating system.</li>
<li>We pass the kernel image to QEMU as yet another ELF which just populated another section of the memory. QEMU populates the struct in such way that OpenSBI can pass the control to there, and before it switches there, it enters the <code>S</code> mode of execution.</li>
</ol>
<h4 id="intentionally-skipped-details">Intentionally skipped details</h4>
<p>ZSBL also touched the <code>a0</code> and <code>a1</code> registers.</p>
<p><code>a0</code> has something to do with RISC-V <code>hart</code>s, but let’s not get into those details, they are not relevant for the rest of this article. Besides, this particular step in the boot process doesn’t seem to be particularly relevant, per <a href="https://github.com/riscv-software-src/opensbi/issues/170#issuecomment-642679348">comments from Github</a>.</p>
<p><code>a1</code> is an interesting pointer because it points to the <strong>device tree</strong> data structure in memory. For the rest of this article, this data structure is not relevant, so we can disregard this piece of information. However, the device tree is really useful for real kernels like Linux. Linux is able to scan the device tree from memory and understand the structure of the machine it’s running on, rather than having to run a lot of <code>if/else</code> branches in its programming for every hardware combination. <a href="https://en.wikipedia.org/wiki/Devicetree#Linux">The Wikipedia article</a> should give a decent idea of how this is used in Linux. As mentioned, however, we won’t be concerned with the details of device tree in the rest of this article.</p>
<h2 id="hello-world-fake-kernel">Hello world fake kernel</h2>
<p>Now we have all the knowledge we need to code a fake OS kernel that just prints “Hello world” to the UART device. The functionality is not at all different from the bare metal program we looked at in the previous guide, but the way we’ll get there is significantly different. We’ll be using an SBI call to print to UART, instead of directly interacting with the UART device (we’re using a more privileged lower layer of software to do this work for us). This could have serious consequences, even on a trivial example such as a “hello world” one: <strong>we delegate the responsibility of interacting with the UART hardware to the SBI layer, thus achieving portability across different machines that conform to this SBI interface</strong>.</p>
<p>How do we call into RISC-V SBI layer? Conceptually, it’s exactly the same as invoking a print to standard output in x86 Linux — we’ll populate some registers and invoke a software interrupt/trap to pass the control down the software stack to OpenSBI. OpenSBI offers a lot of services in the SBI layer, and many of them can be extremely useful for developing a portable operating system kernel, such as interaction with the timers (relevant for time slicing and enabling multiple threads to share the same CPU core). For the full list of functionality exposed through the SBI layer, please take a look <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.adoc">here</a>.</p>
<p>In this guide, we’ll be focusing on the <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/src/ext-debug-console.adoc">debug console</a> functionality, i.e. we’ll be writing out to UART through SBI. Let’s code!</p>
<p>First, we need to know how do we encode the functionality we want OpenSBI to execute through registers. This is well documented <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/src/binary-encoding.adoc">here</a>. tl;dr is that SBI functionality is grouped into “extensions”. Register <code>a7</code> contains the extension ID (EID), while <code>a6</code> encodes the individual function ID (FID) within that extension. The parameters are then passed through <code>a0</code>, <code>a1</code>, <code>a2</code>, …</p>
<p>For printing to the console, the EID we are looking for is <code>0x4442434E</code> (a rather interesting value) and the FID is simply <code>0x00</code>.</p>
<p>This time, instead of printing one by one character as we did in the initial bare metal programming guide, we’ll invoke the printing as a single operation. After all, we should be benefiting from the high level functionality that the SBI layer offers. Therefore, our binary should store the output string somewhere in the memory, and ideally we want to do something like invoking the SBI to print from that address. We’ll do just that:</p>
<pre is:raw="" tabindex="0"><code><span><span>        .global _start</span></span>
<span><span>        .</span><span>section .text</span><span>.kernel</span></span>
<span></span>
<span><span>_start:</span><span> li a7, </span><span>0x4442434E</span></span>
<span><span>        li a6, </span><span>0x00</span></span>
<span><span>1</span><span>:      auipc a3, %pcrel_hi(debug_string)</span></span>
<span><span>        addi a3, a3, %pcrel_lo(</span><span>1b</span><span>)</span></span>
<span><span>        li a4, </span><span>0x00000000FFFFFFFF</span></span>
<span><span>        li a5, </span><span>0xFFFFFFFF00000000</span></span>
<span><span>        li a0, </span><span>12</span></span>
<span><span>        </span><span>and</span><span> a1, a3, a4</span></span>
<span><span>        </span><span>and</span><span> a2, a3, a5</span></span>
<span><span>        ecall</span></span>
<span></span>
<span><span>        li a7, </span><span>0x01</span></span>
<span><span>        mv a6, a0</span></span>
<span><span>        ecall</span></span>
<span></span>
<span><span>loop</span><span>:   j </span><span>loop</span></span>
<span></span>
<span><span>        .</span><span>section .rodata</span></span>
<span><span>debug_string:</span></span>
<span><span>        .string &#34;Hello world\n&#34;</span></span></code></pre>
<p>A couple of things to note here:</p>
<ol>
<li>We use PC-relative addressing here for the output string. As a reminder, the kernel is stored at an address represented by a very large unsigned integer. This value is too high to be encoded within any RISC-V 32-bit instruction word. That’s not a problem, we simply use a short sequence of <code>AUIPC</code> and <code>ADDI</code> instructions to get there (check out <a href="https://michaeljclark.github.io/asm.html">this article</a> for more information on this). If you do not understand what this point is all about, please make sure to revise different memory addressing modes and the differences between them: this is crucial for any sort of bare metal programming.</li>
<li>There is some bit-masking happening as well for registers <code>a1</code> and <code>a2</code>. SBI for some reason asks for the pointer to the string to be printed to be broken down into two 32-bit pieces.</li>
</ol>
<p>So our SBI call is defined by several registers:</p>
<ol>
<li><code>a7</code> identifies the SBI extension</li>
<li><code>a6</code> identifies the function within the extension (in this case, debug console extension)</li>
<li><code>a0</code> contains the length of the string that needs to go to the debug console output</li>
<li><code>a1</code> and <code>a2</code>, when joined together, contain the 64-bit pointer to the address of the stirng that needs to be printed</li>
</ol>
<p>The SBI call is now invoked through an <code>ecall</code> instruction, which activates a CPU trap. At this point, OpenSBI takes over and writes to UART, in exactly the same way as we did in the initial bare metal programming guide. If you are wondering how a simple <code>ecall</code> invocation takes us to OpenSBI, that is because OpenSBI set up the trap handling mechanism in such way that when our kernel gets into a trap, the program counter will jump into the OpenSBI software section. The details of this are way outside the scope of this article, but we may cover this in some other article.</p>
<p>For now, just check out the QEMU serial port and confirm that “Hello world” is printed properly:</p>
<pre is:raw="" tabindex="0"><code><span><span>qemu-system-riscv64 -machine virt -s -S -bios build/platform/generic/firmware/fw_dynamic.bin -kernel ~/work/github_demo/risc-v-bare-metal-fake-kernel/hello_world_kernel</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>OpenSBI v1.3-54-g901d3d7</span></span>
<span><span>   ____                    _____ ____ _____</span></span>
<span><span>  / __ \                  / ____|  _ \_   _|</span></span>
<span><span> | |  | |_ __   ___ _ __ | (___ | |_) || |</span></span>
<span><span> | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |</span></span>
<span><span> | |__| | |_) |  __/ | | |____) | |_) || |_</span></span>
<span><span>  \____/| .__/ \___|_| |_|_____/|____/_____|</span></span>
<span><span>        | |</span></span>
<span><span>        |_|</span></span>
<span><span></span></span>
<span><span>Platform Name             : riscv-virtio,qemu</span></span>
<span><span>Platform Features         : medeleg</span></span>
<span><span>Platform HART Count       : 1</span></span>
<span><span>Platform IPI Device       : aclint-mswi</span></span>
<span><span>Platform Timer Device     : aclint-mtimer @ 10000000Hz</span></span>
<span><span>Platform Console Device   : uart8250</span></span>
<span><span>Platform HSM Device       : ---</span></span>
<span><span>Platform PMU Device       : ---</span></span>
<span><span>Platform Reboot Device    : syscon-reboot</span></span>
<span><span>Platform Shutdown Device  : syscon-poweroff</span></span>
<span><span>Platform Suspend Device   : ---</span></span>
<span><span>Platform CPPC Device      : ---</span></span>
<span><span>Firmware Base             : 0x80000000</span></span>
<span><span>Firmware Size             : 322 KB</span></span>
<span><span>Firmware RW Offset        : 0x40000</span></span>
<span><span>Firmware RW Size          : 66 KB</span></span>
<span><span>Firmware Heap Offset      : 0x48000</span></span>
<span><span>Firmware Heap Size        : 34 KB (total), 2 KB (reserved), 9 KB (used), 22 KB (free)</span></span>
<span><span>Firmware Scratch Size     : 4096 B (total), 768 B (used), 3328 B (free)</span></span>
<span><span>Runtime SBI Version       : 1.0</span></span>
<span><span></span></span>
<span><span>Domain0 Name              : root</span></span>
<span><span>Domain0 Boot HART         : 0</span></span>
<span><span>Domain0 HARTs             : 0*</span></span>
<span><span>Domain0 Region00          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()</span></span>
<span><span>Domain0 Region01          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()</span></span>
<span><span>Domain0 Region02          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()</span></span>
<span><span>Domain0 Region03          : 0x0000000000000000-0xffffffffffffffff M: () S/U: (R,W,X)</span></span>
<span><span>Domain0 Next Address      : 0x0000000080200000</span></span>
<span><span>Domain0 Next Arg1         : 0x0000000087e00000</span></span>
<span><span>Domain0 Next Mode         : S-mode</span></span>
<span><span>Domain0 SysReset          : yes</span></span>
<span><span>Domain0 SysSuspend        : yes</span></span>
<span><span></span></span>
<span><span>Boot HART ID              : 0</span></span>
<span><span>Boot HART Domain          : root</span></span>
<span><span>Boot HART Priv Version    : v1.10</span></span>
<span><span>Boot HART Base ISA        : rv64imafdc</span></span>
<span><span>Boot HART ISA Extensions  : zicntr</span></span>
<span><span>Boot HART PMP Count       : 16</span></span>
<span><span>Boot HART PMP Granularity : 4</span></span>
<span><span>Boot HART PMP Address Bits: 54</span></span>
<span><span>Boot HART MHPM Info       : 0 (0x00000000)</span></span>
<span><span>Boot HART MIDELEG         : 0x0000000000000222</span></span>
<span><span>Boot HART MEDELEG         : 0x000000000000b109</span></span>
<span><span>Hello world</span></span></code></pre>
<p>As an exercise, I suggest probing the <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/src/ext-base.adoc">base extension (<code>0x10</code>)</a> with <code>gdb</code> to investigate what the QEMU machine + OpenSBI you build are capable of offering.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We ended up with an entirely portable fake kernel that prints “Hello world” to UART! This may seem like nothing special, but the concept here is very powerful. Without rebuilding, you can drop the same kernel image on a different RISC-V 64-bit machine with OpenSBI that supports the debug console extension.</p>
<p>In fact, I played a little trick here. :) One of the main reasons I suggested building OpenSBI from source is that some QEMU versions provided by the Linux distro package managers do not support the debug console extension (they’re simply old). This was the case with my default OpenSBI which came with Debian’s version of QEMU.</p>
<p>Finally, I would like to remind the reader that we have extensively focused on the QEMU <code>virt</code> machine with a RISC-V core and all the fine details of this article are related to it. That said, my hope is that the reader has learned enough about the boot sequence concepts and bare metal programming that adapting this knowledge to a particular real-world scenario becomes easy.</p>
<p>In the next posts, we’ll talk about taking this further and booting up a full blown Linux kernel. We’ll expand that step by step until we reach a Linux deployment that can handle I/O with keyboard, mouse, screen and Ethernet network.</p>
<p>I hope you enjoyed this lengthy writeup!</p>
<h2 id="code-pointers">Code pointers</h2>
<p>If you prefer not to copy/paste, the code is available on <a href="https://github.com/popovicu/risc-v-bare-metal-fake-kernel">this GitHub repo</a>.</p>
    </article></div>
  </body>
</html>
