<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kstefanj.github.io/2021/11/24/gc-progress-8-17.html">Original</a>
    
    <div id="readability-page-1" class="page"><div>
    <p>JDK 17 has been out for a few months and it’s not just packed with new language features. The <strong>performance boost</strong> compared to older JDK versions is also really <strong>significant</strong>. It becomes especially clear when compared to the previous LTS releases, JDK 8 and JDK 11. Much of the improved performance comes from <strong>new features and optimizations</strong> in the <a href="https://docs.oracle.com/en/java/javase/17/vm/java-virtual-machine-technology-overview.html">JVM</a> and in this post the focus will be on the <strong>improvements done in the area of garbage collection</strong>.</p>

<p>I recently gave a talk focusing on new features in <strong><a href="https://inside.java/2021/10/11/p99-g1-to-infinity-and-beyond/">G1 since JDK 8</a></strong> and this post will expand this to also cover the progress made in <strong>Parallel GC</strong> and <strong>ZGC</strong>. We also have a fourth supported collector, <strong>Serial GC</strong>, but it is not included in this comparison. Serial is a stable collector that has low overhead, but the benchmark used below requires a high performing GC to work well.</p>

<h2 id="serving-different-use-cases">Serving different use cases</h2>

<p>Deciding which garbage collector to use is not always obvious. It’s important to understand that to make the correct choice you first need to figure out what your <strong>main goals</strong> are. Often goals are to optimize for throughput, latency and/or footprint. The optimal solution would of course be to optimize for all of the above and get the best possible performance in every situation. The collectors strive to be as optimal as possible from every aspect, but they are designed to make <strong>different tradeoffs</strong> to support <strong>different use-cases</strong>.</p>

<p>A quick summary of what we mean by improving in the different areas:</p>
<ul>
  <li><strong>Throughput</strong> – lower the GC’s impact on the total number of transactions that can be completed in a set amount of time</li>
  <li><strong>Latency</strong> – lower the GC’s impact on any single transaction</li>
  <li><strong>Footprint</strong> – lower the additional resources used by the GC</li>
</ul>

<p>Doing different tradeoffs doesn’t mean that the collectors can’t be improved from every aspect. When improving the collectors, one big part is to make sure that the tradeoffs are done as <strong>efficiently</strong> as possible. Another good approach to improve across the board is to <strong>re-evaluate old design decisions</strong> and come up with better solutions.</p>

<h2 id="the-progress-since-jdk-8">The progress since JDK 8</h2>

<p>Looking at the progress made since JDK 8 we see that all collectors have <strong>improved</strong> in more or less <strong>every aspect</strong>. To better show the progress the comparisons below are using normalized scores <strong>comparing the collectors individually</strong>, instead of looking at raw scores. 
I’ve been using <a href="https://www.spec.org/jbb2015/">SPECjbb® 2015</a><sup id="fnref:spec" role="doc-noteref"><a href="#fn:spec" rel="footnote">1</a></sup> with a 16 GB heap to compare the collectors. This is a well-known and stable benchmark that doesn’t only focus on GC performance, so the results will also show <strong>progress for the whole Java platform</strong>. The benchmark has a few different modes and it produces both a throughput metric and a latency metric. The latency metric is measuring throughput under response time constraints.</p>

<p>For pause time comparisons I’ve run the benchmark with a fixed load for an hour. This way all collectors are stressed at the same level regardless of their end score.</p>

<p>One last note before looking at the score charts. ZGC was introduced in JDK 11 (<a href="https://openjdk.java.net/jeps/377">production ready since JDK 15</a>) so we only have two data points for ZGC compared to three for G1 and Parallel.</p>

<h2 id="throughput">Throughput</h2>
<p><img src="https://kstefanj.github.io/assets/posts/gc-8-17/throughput.png" alt="Throughput"/></p>

<p>Looking at the throughput metric we see that all collectors have <strong>improved significantly</strong> compared to older releases. ZGC is the one making the biggest improvement in this area. G1 and Parallel still have better raw throughput in this setup but scaling up the heap, ZGC closes this gap.</p>

<p>When it comes to this metric, we should also keep in mind that we are not only measuring GC performance. Other parts of the Java platform, for example the JIT compiler, also contribute to these improvements.</p>

<h2 id="latency">Latency</h2>
<p><img src="https://kstefanj.github.io/assets/posts/gc-8-17/latency.png" alt="Latency"/></p>

<p>From a latency perspective the results have improved even more. Here we can see all the benefits of the work put into making <strong>GC pauses shorter</strong>. When it comes to this metric a lot of the improvements can really be contributed to what has been improved in the GCs.</p>

<p>G1 shows the best progress when considering this metric. ZGC has also improved a lot from a latency perspective. The most impressive part is not seen in this chart because the benchmark is measuring application latencies. ZGC does such a good job keeping the pauses short that we start to see other things affecting the latency score. If we instead look at how the <strong>pause times have improved</strong>, we can see that there has been some <strong>extraordinary work going on in ZGC</strong>.</p>

<p><img src="https://kstefanj.github.io/assets/posts/gc-8-17/p99-pause.png" alt="P99-pause"/></p>

<p>Here we look at raw numbers (because normalized pause-times are a bit strange) and as we can see ZGC in JDK 17 is way below its goal of <strong>sub-millisecond pause times</strong>. G1, with its goal of keeping a <strong>balance between latency and throughput</strong>, keeps well below its default pause time target of 200 ms. This chart also includes an extra bar to quickly show how the different collectors handle scalability. ZGC is designed to have pause times that do not scale with the heap size, and we clearly see that this is the case when the heap is enlarged to 128 GB. G1 handles the larger heap better than Parallel from a pause time perspective because it has the logic to keep the pause time target.</p>


<p><img src="https://kstefanj.github.io/assets/posts/gc-8-17/footprint.png" alt="Footprint"/></p>

<p>This chart compares the <strong>peak native memory overhead</strong> of the three different collectors. Since both Parallel and ZGC have been pretty stable from this perspective, it makes more sense to look at raw numbers here as well. We can see that <strong>G1 has really improved</strong> in this area and the main reason for this is all features and enhancements to make <strong>remembered set management more efficient</strong>.</p>

<p>Even if the other collectors have not decreased their overhead, we should still remember that they have improved in the other areas without having to use additional memory.</p>

<h2 id="time-to-upgrade">Time to upgrade</h2>

<p>The <strong>overall performance in JDK 17</strong> compared to older versions is <strong>significantly better</strong> regardless of which collector you use. If you are still on JDK 8 and plan to upgrade, it might be a good time to <strong>re-evaluate which GC to use</strong>. In JDK 8 <strong>Parallel was the default</strong>, but this was <strong>changed to G1 in JDK 9</strong>. Since then G1 has improved at a higher rate than Parallel, but there are still use-cases where Parallel is the best choice. With the introduction of ZGC (production ready since JDK 15) there is also a third high performing alternative to put into the equation.</p>

<h2 id="more-details">More details</h2>
<p>If you want more details around what’s been done to achieve those great results, I recommend reading <a href="https://malloc.se/">Per Liden’s blog</a> focusing on ZGC and <a href="https://tschatzl.github.io/">Thomas Schatzl’s blog</a> focusing on G1 (and a bit on Parallel).</p>

<p>For general news and insights from the Java team at Oracle make sure to check out <a href="https://inside.java/">inside.java</a>.</p>

<hr/>



  </div></div>
  </body>
</html>
