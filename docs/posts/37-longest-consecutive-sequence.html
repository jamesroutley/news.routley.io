<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/37%29-Longest-Consecutive-Sequence">Original</a>
    <h1>37) Longest Consecutive Sequence</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>Okay so this was the approach I went with off the bat:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> getLastFromMap</span><span>(</span><span>map</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt;)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>  const</span><span> arr</span><span> =</span><span> Array.</span><span>from</span><span>(map);</span></span>
<span data-line=""><span>  return</span><span> arr.</span><span>length</span><span> &gt;</span><span> 0</span><span> ?</span><span> arr[arr.</span><span>length</span><span> -</span><span> 1</span><span>][</span><span>1</span><span>] </span><span>:</span><span> 0</span><span>;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> longestConsecutive</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    // A map that stores a key that is the next element in any given sequence, </span></span>
<span data-line=""><span>    // and when you find that element, it deletes that entry</span></span>
<span data-line=""><span>    // and it adds an entry for the next element</span></span>
<span data-line=""><span>    // But it increments the value every time</span></span>
<span data-line=""><span>    // But this sounds more like a stack maybe</span></span>
<span data-line=""><span>    // oh but I mean, maps are in order so</span></span>
<span data-line=""><span>    // that should be fine</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> cMap</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> nums.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        let</span><span> num </span><span>=</span><span> nums[i];</span></span>
<span data-line=""><span>        if</span><span> (cMap.</span><span>has</span><span>(num)){</span></span>
<span data-line=""><span>            const</span><span> finds</span><span> =</span><span> cMap.</span><span>get</span><span>(num)</span></span>
<span data-line=""><span>            cMap.</span><span>delete</span><span>(num)</span></span>
<span data-line=""><span>            cMap.</span><span>set</span><span>(num</span><span>+</span><span>1</span><span>, finds</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            cMap.</span><span>set</span><span>(num</span><span>+</span><span>1</span><span>, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> getLastFromMap</span><span>(cMap)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>But pretty quickly after writing it down realized that this only works in <em>one direction</em> of finding the next number in a sequence(and I’m not saying it quite does that yet). Whereas I need an algo that can keep track of numbers before and after. I mean it’s really just a case of encoding the human behavior of what we do when we are trying to construct a straight out of a group of cards in poker.</p>
<p>Here is a Claude generated result:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestConsecutive</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (nums.</span><span>length</span><span> ===</span><span> 0</span><span>) </span><span>return</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> numSet</span><span> =</span><span> new</span><span> Set</span><span>(nums)</span></span>
<span data-line=""><span>    let</span><span> maxLength </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>const</span><span> num</span><span> of</span><span> nums){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>numSet.</span><span>has</span><span>(num</span><span>-</span><span>1</span><span>)){</span></span>
<span data-line=""><span>            let</span><span> currentNum </span><span>=</span><span> num</span></span>
<span data-line=""><span>            let</span><span> currentLength </span><span>=</span><span> 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>            while</span><span> (numSet.</span><span>has</span><span>(currentNum</span><span>+</span><span>1</span><span>)){</span></span>
<span data-line=""><span>                currentNum</span><span>++</span></span>
<span data-line=""><span>                currentLength</span><span>++</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""><span>            maxLength </span><span>=</span><span> Math.</span><span>max</span><span>(currentLength, maxLength)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> maxLength</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>What it does that’s really smart is it just checks to see if any consecutive numbers exists <em>behind</em> the current number, and if yes, then we simply don’t check that number.</p>
<p>This prevents us from needing to do a two-way check, would requires us to do tree-like movement.</p>
<p>I do think it would be kind of cool to concatenate the lengths of sequences we find that end up matching up. But also more complicated.</p></article><hr/></div></div></div>
  </body>
</html>
