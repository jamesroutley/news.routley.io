<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt-rickard.com/the-programmable-web/">Original</a>
    <h1>I Miss the Programmable Web (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><p>In some ways, we&#39;ve taken a few steps back from a programmable web—two things I miss: bookmarklets and user scripts. Imagine having a bookmarked shortcut to do complex things like taking screenshots or saving a PDF. Or running scripts to automatically change the styling of websites, removing annoying sections (not just ads!). All of this <em>used to be </em>possible.</p><p>Brendan Eich, the author of JavaScript, thought that we&#39;d use JavaScript bookmarklets to run arbitrary scripts against the DOM:</p><blockquote>They were a deliberate feature in this sense: I invented the <code>javascript:</code> URL along with JavaScript in 1995, and intended that <code>javascript:</code> URLs could be used as any other kind of URL, including being bookmark-able. In particular, I made it possible to generate a new document by loading, e.g. <code>javascript:&#39;hello, world&#39;</code>, but also (key for bookmarklets) to run arbitrary script against the DOM of the current document, e.g. <code>javascript:alert(document.links[0].href)</code>. The difference is that the latter kind of URL uses an expression that evaluates to the undefined type in JS. I added the void operator to JS before Netscape 2 shipped to make it easy to discard any non-undefined value in a <code>javascript:</code> URL. — Brendan Eich, email to Simon Willison</blockquote><p>User scripts took this even further – <a href="https://en.wikipedia.org/wiki/Greasemonkey">Greasemonkey</a> (and its successor <a href="https://en.wikipedia.org/wiki/Tampermonkey">Tampermonkey</a>) – hosted a repository of scripts you could install and run on specific websites. These scripts added functionality to websites before companies could (or would) implement them – e.g., usability features for common sites like YouTube (add a download link), a queue for Netflix shows, or direct image links for Google Image Search. </p><p>Security policies have essentially killed the user script and bookmarklet ecosystem. Most of the scripts you can find on the remaining sites like <a href="https://greasyfork.org/en/scripts?sort=total_installs">Greasy Fork</a> only provide minor improvements. The most-used scripts – like ad-blocking or annotating have become their own standalone browser extensions (e.g., AdBlock and Evernote/Notion Web Clipper).</p><p>The security benefit to consumers of blocking user scripts is probably a net positive for the average internet user. But why can&#39;t we have both? Surely we can find a way. Maybe running something like the QuickJS sandbox inside WebAssembly can provide a more secure way to access selective parts of the DOM. </p></div></div>
  </body>
</html>
