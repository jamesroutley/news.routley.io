<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.app.build/blog/six-principles-production-ai-agents">Original</a>
    <h1>Principles for production AI agents</h1>
    
    <div id="readability-page-1" class="page"><div><div><section><div><article><div><div><p>Every now and then, people ask me:</p><p>“<em>I am new to agentic development, I’m building something, but I feel like I&#39;m missing some tribal knowledge. Help me catch up!</em>”.</p><p>I’m tempted to suggest some serious stuff like multiweek courses (e.g. by <a href="https://huggingface.co/learn/agents-course/en/unit0/introduction">HuggingFace</a> or <a href="https://rdi.berkeley.edu/llm-agents/f24">Berkeley</a>), but not everyone is interested in that level of diving. </p><p>So I decided to gather six simple empirical learnings that helped me a lot during <a href="http://app.build">app.build</a> development. This post is somewhat inspired by <a href="https://www.app.build/blog/design-decisions">Design Decisions Behind app.build</a>, but is generalized and aimed to be a quick guideline for newcomers in agentic engineering.</p><p>I’ve been skeptical about prompt engineering for a long time, it seemed more like shaman rituals rather than anything close to engineering. All those approaches “<em>I will tip you $100</em>” or “<em>My grandmother is dying and needs this</em>” or “<em>Be 100% accurate or else</em>” could be useful as local fluctuation leveraging local model inefficiency, but never worked in the longer run.</p><p>I changed my mind regarding prompt / context engineering when I realized a simple thing: modern LLMs just need direct detailed context, no tricks, but clarity and lack of contradictions. That’s it, no manipulation needed. Models are good at instruction following, and the problem is often just the ambiguous nature of the instructions.</p><p>All LLM providers have educational resources on best practices on how to prompt their models (e.g., <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview">one by Anthropic</a> and <a href="https://ai.google.dev/gemini-api/docs/prompting-strategies">one by Google</a>). Just follow them and ensure your instructions are direct and detailed, no smart-pants tricks required. For example, here is a <a href="https://github.com/appdotbuild/claude_astgrep/blob/main/.claude/commands/ast_grep.md">system prompt </a>we use to make Claude generate rules for <a href="http://ast-grep/ast-grep:%20%E2%9A%A1A%20CLI%20tool%20for%20code%20structural%20search,%20lint%20and%20rewriting.%20Written%20in%20Rust">ast-grep</a> - nothing tricky, just details on how to use the tool that the agent barely knows.</p><p>One trick we like is to bootstrap the initial system prompt with the draft created by Deep Research-like variants of LLM. It typically needs human improvements, but is a solid baseline.</p><p>Keeping a shared part of the context is beneficial for the <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching">prompt caching</a> mechanisms. Technically, one can cache user messages too, but structuring context so that the system part is large and static and user one is small and dynamic works great.</p><p>Alright, a solid system prompt is here. But there is a reason why &#34;context engineering&#34; has been the latest trend over &#34;prompt engineering&#34;.</p><p>Context management is a subject for a trade-off. Without proper context, models tend to hallucinate, get off track or just refuse to provide an answer with a too large context. They’re subject to attention attrition (where models struggle to focus on relevant parts of very long contexts, leading to degraded performance on key details buried in the middle), higher costs and latency.</p><p>A principle we found useful is to provide the bare minimum of knowledge in the first place, and the option to fetch more context if needed via tools. For example, in our case it may mean listing all the project files in the prompt and providing a tool to read the files that are relevant for the requested change; although if we’re certain some file content is crucial, we can include its content in the context in advance.</p><p>Logs and other artifacts from the feedback loop can bloat the context pretty quickly. Simple <a href="https://github.com/appdotbuild/agent/blob/2a09b4e0c4ba1d7ddba04832514352f424852a04/agent/core/actors.py#L241">context compaction</a> tools applied automatically can help a lot. Encapsulation was a hype word for object-oriented programming, but for context management it is even more important: separate the concerns, and provide every bit of your agentic solution only the context it absolutely needs.</p><figure><p><img alt="" loading="lazy" width="704" height="752" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F485788bd46375c109848ca476111ff90a83b1f7d-1226x1308.png%3Frect%3D1%2C0%2C1225%2C1308%26w%3D1408%26h%3D1504%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=750&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r 1x, /_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F485788bd46375c109848ca476111ff90a83b1f7d-1226x1308.png%3Frect%3D1%2C0%2C1225%2C1308%26w%3D1408%26h%3D1504%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=1920&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r 2x" src="https://www.app.build/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F485788bd46375c109848ca476111ff90a83b1f7d-1226x1308.png%3Frect%3D1%2C0%2C1225%2C1308%26w%3D1408%26h%3D1504%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=1920&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r"/></p></figure><p>The core feature of an AI agent is <a href="https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview">tool calling</a>, the combination of an LLM + exposed tools + basic control flow operators makes an agent.</p><p>Designing a toolset for the agent is somewhat similar to designing an API… but actually more complex. Human API users are more capable of reading between the lines, can navigate complex docs and find workarounds. Tools created for agents are usually more limited (having too many of them is a way to pollute the context), should have direct straightforward interfaces and overall bring order to the stochastic LLM world. When building for a human user, it may be fine to design one main road and some tricks for corner cases; LLMs are very likely to misuse your loopholes, and that’s why you don’t want to have any loopholes.</p><p>Good tools typically operate on a similar level of granularity, and have a limited number of strictly typed parameters. They are focused and well-tested, like an API you’re ready to provide to a smart but distractible junior developer. Idempotency is highly recommended to avoid state management issues. Most software engineering agents have under 10 multifunctional tools (such as read_file, write_file, edit_file, execute…) with 1-3 parameters each (<a href="https://github.com/appdotbuild/agent/blob/2a09b4e0c4ba1d7ddba04832514352f424852a04/agent/core/actors.py#L157">appbuild example</a>, <a href="https://github.com/opencode-ai/opencode/blob/f0571f5f5adef12eba9ddf6d07223a043d63dca8/README.md?plain=1#L400">opencode example</a>), and attaching additional tools based on context <a href="https://github.com/appdotbuild/agent/blob/2a09b4e0c4ba1d7ddba04832514352f424852a04/agent/nicegui_agent/actors.py#L176">may be suitable too</a>.</p><p>In some cases, designing an agent to write some DSL (domain-specific language) code with actions rather than calling tools one by one is a great idea. This approach was widely <a href="https://huggingface.co/blog/smolagents">popularized by smolagents</a>; however, it needs a properly designed set of functions to be exposed for the agent execution. Despite the top level structure change, the main idea remains valid: simple, sufficient but non-ambiguous and non-redundant tools are crucial for the agent performance.</p><p>Good agentic solutions combine the advantages of LLMs and traditional software. One crucial way of this combination is designing a two-phase algorithm similar to the <a href="https://en.wikipedia.org/wiki/Actor-critic_algorithm">actor-critic approach</a>: where an actor decides on actions and a critic evaluates them.</p><p>We find it useful to allow LLM Actors to be creative, and Critics to be strict. In our app generation world, it means Actors create new files or edit them, and Critics ensure this code matches our expectations. The expectations are based on handcrafted criteria: we want the code to be compilable, pass tests, type checks, linters and other validators. The Critic’s work is mostly determined, but not 100% — e.g., we can generate tests with an LLM independently and run the test suite later.</p><p>When building agents for any vertical, it is crucial to include domain-specific validation. This requires defining and checking domain invariants that must hold regardless of the agent&#39;s specific approach — a concept ML engineers refer to as including an &#34;<a href="https://en.wikipedia.org/wiki/Inductive_bias">inductive bias</a>&#34;.</p><p>Software engineering is an industry most affected by AI agents for precisely this reason. The feedback loop is incredibly effective: it is easy to filter out bad results using very straightforward validators such as compilers, linters, and tests. This affects performance on two levels: foundational models are trained on such verifiable rewards at scale, and later product engineers can leverage these learned properties.</p><p>This same thinking applies to other domains. As an example, if a travel-oriented agent suggests a multi-leg flight, the first thing is to verify those connections exist. Likewise, if a bookkeeping agent’s result does not satisfy double-entry principles, it is a bad result and it should not be accepted.</p><p>Feedback loops are tightly coupled with the concept of “guardrails” available in many frameworks. Agents are moderately good at recovering. Sometimes, a bad result is worth trying to fix (sending a next message to the LLM reflecting “hey, your previous solution is not acceptable because of X”), other times a chain of bad fixes is not fixable anymore - just discard and try again. </p><p>Agentic system should be ready for both hard and soft failures with different recovery strategies, and those recovery strategies together with the guardrails are the essence of a feedback loop. You can think of it in a manner similar to the <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Monte-Carlo tree search</a> concept: some branches are promising and should be developed further, some are dead-end and should be cut away.</p><p>Once you have a basic agent and a feedback loop attached, you can iterate and improve. Error analysis has always been a cornerstone in AI/ML engineering, and AI agents are not any different. </p><p>One approach to error analysis is to review common failures, but agents are so productive! It is often easy to spawn dozens of agents, keep them running on different tasks, generate tons of logs (hope your feedback loop has some observability feature built in, right?). No matter how productive you are, it is very likely that agents’ log stream won’t be readable.</p><p>That is why a simple meta-agentic loop is very powerful:</p><ol><li>Make a baseline</li><li>Get some trajectories / logs</li><li>Analyze them with a LLM (kudos to Gemini’s 1M context)</li><li>Improve the baseline based on the received insights.</li></ol><p>Very often this will reveal blind spots in the context management or tools provided.</p><figure><p><img alt="" loading="lazy" width="704" height="391" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F4f9291a28cae740b6e223a9f0f85d1f994760069-1736x962.png%3Frect%3D2%2C0%2C1732%2C962%26w%3D1408%26h%3D782%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=750&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r 1x, /_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F4f9291a28cae740b6e223a9f0f85d1f994760069-1736x962.png%3Frect%3D2%2C0%2C1732%2C962%26w%3D1408%26h%3D782%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=1920&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r 2x" src="https://www.app.build/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F7ty6nxwv%2Fproduction%2F4f9291a28cae740b6e223a9f0f85d1f994760069-1736x962.png%3Frect%3D2%2C0%2C1732%2C962%26w%3D1408%26h%3D782%26q%3D95%26fit%3Dcrop%26auto%3Dformat&amp;w=1920&amp;q=100&amp;dpl=dpl_KJKRnhBBdEnsLse2JeWAdyeGmJ4r"/></p></figure><p>LLMs are powerful these days, and that is why people are getting frustrated fairly quickly when agents do really stupid things, or completely ignore the instructions. The reality is that instruction-tuned models are also very prone to reward hacking, meaning they’re doing whatever possible to satisfy the goal as it is interpreted. This is, however, not necessarily the goal the original system designer had in mind.</p><p>The insight is: an irritating issue can be caused not by the LLM flaws, but a system error such as the lack of the tool to handle required to solve the problem or ambiguous paragraph in the system prompt. </p><p>Recently, I was cursing loudly: why on Earth does the agent not use the integration provided to get the data and use the simulated random data instead despite my explicit request not to do it? I read the logs and realized I am the silly one here - I didn’t provide the agent with proper API keys, so it tried to fetch the data, failed multiple times in a row in the same way and went for a workaround instead. That was not the only accident: for example, we also observed similar behavior with agents trying to write a file while missing file system access.</p><p>Building effective AI agents isn&#39;t about finding a silver bullet of a great prompt or an advanced framework — it is system design and proper software engineering. Focus on clear instructions, lean context management, robust tool interfaces, and automated validation loops. When your agent frustrates you, debug the system first: missing tools, unclear prompts, or insufficient context are usually the culprits, not model limitations.</p><p>Most importantly, treat error analysis as a first-class citizen in your development process. Let LLMs help you understand where your agents fail, then systematically address those failure modes. The goal isn&#39;t perfect agents — it&#39;s reliable, recoverable ones that fail gracefully and can be improved iteratively. <br/></p></div></div></article></div></section></div></div></div>
  </body>
</html>
