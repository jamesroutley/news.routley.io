<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/safe-and-efficient-c-interoperability-via-non-escapable-types-and-lifetimes/75426">Original</a>
    <h1>Safe and efficient C&#43;&#43; interoperability via non-escapable types and lifetimes</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
              
<p>Safely interacting with unsafe code is challenging. The C++ interoperability layer has limited safeguards in place to mitigate some sources of unsafety including hiding some APIs (like methods returning iterators) and exposing them with an “Unsafe” suffix. Unfortunately, these are based on simple syntactic heuristics that are incomplete (like identifying methods that return pointer like objects) and therefore do not provide sufficient safety guarantees and do not provide a way to safely access those APIs.</p>
<pre data-code-wrap="Swift"><code>let vec = getVecOfInt();
let begin = vec.__beginUnsafe(); // Last use of vec, it might be freed.
let val = begin.pointee; // Potential use after free.
</code></pre>
<p>Building on the ongoing work to express lifetimes in Swift, we propose using annotations to express lifetime information for C++ APIs. Then, the compiler can know that <code>begin</code> depends on <code>vec</code> and it should not be cleaned up before <code>begin</code> ‘s last use.</p>
<p>Moreover, the interoperability layer introduces defensive copies to extend the lifetime of collections while they are being iterated on. This has a performance cost and can result in a less ergonomic experience interacting with C++ code.</p>
<pre data-code-wrap="Swift"><code>var v = getVectorOfString()
for e in v { // Creating a deep copy of the vector.
...
}
</code></pre>
<p>With sufficient annotations on the C++ side we can safely remove the defensive copy when iterating on a C++ container.</p>

<p><a href="https://github.com/swiftlang/swift-evolution/pull/2304" rel="noopener nofollow ugc">Non-escapable types</a> provide the ability to create types whose instances cannot escape out of the context in which they were created with no runtime overhead. We want to introduce C++ annotations to let users import types as not escapable. For example, view types in C++ like iterators are good candidates to be imported as non-escapable types. Templates pose a challenge as <code>std::vector&lt;int&gt;</code> is safe to escape from a function while <code>std::vector&lt;std::span&lt;int&gt;&gt;</code> might not be. We plan to introduce C++ annotations to help express conditional escapability similar to conditional conformances in Swift: <code>extension Container: Escapable where T: Escapable { }</code> .</p>
<p>We plan to import a targeted set of types such as C++ iterators as not escapable. By default, most types would still be imported to Swift as escapable for backward compatibility and ergonomic reasons. Once Swift has better support for non-escapable types (like the new container protocols), we will reconsider changing the defaults for a subset of types under a new interop version.</p>

<p>Clang supports the <code>[[clang::lifetimebound]]</code> attribute to annotate lifetime dependencies between a return value and some input arguments. This annotation does not support all the scenarios that Swift <a href="https://github.com/swiftlang/swift-evolution/pull/2305" rel="noopener nofollow ugc">lifetime dependencies</a> can express. However, Clang already has some diagnostics to find some lifetime related errors in annotated code. The Clang community is <a href="https://discourse.llvm.org/t/lifetime-analysis-improvements-in-clang/81374" rel="noopener nofollow ugc">actively improving </a>these diagnostics and <a href="https://discourse.llvm.org/t/rfc-introduce-clang-lifetime-capture-by-x/81371" rel="noopener nofollow ugc">proposed extensions </a>to these annotations. We propose importing lifetimebound annotations as Swift dependencies. Users annotating their C++ code can benefit from additional checking in both Swift and C++.</p>
<pre data-code-wrap="cpp"><code>SpanOfInts MyContainer::getBuffer() [[clang::lifetimebound]];
// Is imported as:
</code></pre>
<pre data-code-wrap="Swift"><code>@lifetime(self)
func getBuffer() -&gt; SpanOfInts
</code></pre>
<p>We plan to recognize certain idioms in the importer and import reference returning methods like <code>operator*</code> , <code>operator[]</code> as projections with the correct lifetime dependecies. As a result, users would no longer get an implicit copy of the object behind the reference when calling these methods. We expect this to improve the performance and resolve some current problems when objects are sliced unintentionally.</p>
<p>Moreover, we plan to add or infer <code>lifetimebound</code> annotations for the C++ Standard Library so commonly used methods like <code>vector::front</code> work as expected out of the box.</p>
<p>In the future, we plan to add new annotations on the C++ side that closely match the semantics of how lifetime dependencies are specified on the Swift side.</p>

<p>Swift has an optional strict memory safety mode that provides more guarantees than the existing Safe-by-Default model. We plan supporting this effort by importing some user specified types without escapability annotations as <code>@unsafe</code> . This makes sure that only audited and annotated APIs can be called from strict memory safe Swift. This is a good fit for safety critical code but comes at the cost of bigger annotation burden. For more details see the post “<a href="https://forums.swift.org/t/prospective-vision-optional-strict-memory-safety-for-swift/75090">Optional Strict Memory Safety for Swift</a>”.</p>

<p>We plan to introduce heuristics in the future that will help reduce the annotation burden. The goal is to find a good balance between usability and safety. The inference will make a set of assumptions like the C++ code is not casting constness away and the lifetime dependencies of the outputs of a function call can only depend on on its inputs.</p>

<p>Here is a rough roadmap (subject to change) for implementing the features laid out in this proposal. We also link to PRs where they are available.</p>
<ul>
<li><a href="https://github.com/swiftlang/swift/pull/76209" rel="noopener nofollow ugc">Add</a> <code>Escapable</code> and <code>~Escapable</code> annotations to C++.</li>
<li><a href="https://github.com/swiftlang/swift/pull/76311" rel="noopener nofollow ugc">Import</a> <code>[[clang::lifetimebound]]</code> annotations as Swift lifetime dependencies</li>
<li><a href="https://github.com/swiftlang/swift/pull/76429" rel="noopener nofollow ugc">Introduce</a> a safe mode for interoperability</li>
<li>Add or infer lifetimebound annotations to the STL</li>
<li>Add a way to express objects without lifetime dependencies (e.g., API returning a <code>string_view</code> to a literal).</li>
<li>Introduce a way to distinguish between scoped and inherited lifetime dependency (<code>vector::operator[]</code> vs <code>span::operator[]</code>).</li>
<li>Import reference returning <code>operator[]</code> and <code>operator*</code> using projections</li>
<li>Make iterator types non-escapable</li>
</ul>
<p>We also plan to work on the following features later:</p>
<ul>
<li>More complex lifetime annotations</li>
<li>Conditional escapability annotations</li>
<li>Inference of escapability for certain types</li>
<li>Inference of lifetime annotations for certain APIs</li>
<li>Better support for output arguments</li>
</ul>
<p>Let us know what you think.</p>
            </div></div>
  </body>
</html>
