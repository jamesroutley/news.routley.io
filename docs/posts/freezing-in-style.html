<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.broulik.de/2023/11/freezing-in-style/">Original</a>
    <h1>Freezing in style</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1456">
	
	<!-- .entry-header -->

	<div>
		
<p>One of the the less apparent omissions in Plasma’s Wayland session compared to X was the lack of a prompt for terminating an unresponsive app. Of course, you should never see one because any decent app will just crash and quit rather than get stuck. Nevertheless, over the course of three evenings I spent way too much time making the “KWin Killer Helper” work on Wayland and while at it revamped its user interface entirely.</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752.png"><img fetchpriority="high" decoding="async" width="1024" height="596" src="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752-1024x596.png" alt="KWrite text editor window, desaturated, reading “Untitled – KWrite (Not Responding)” with a popup ontop of it reading “Untitled of KWrite is not responding. Do you want to terminate this application? Terminating this application will close all of its windows. Any unsaved data will be lost” with actions “Terminate KWrite” and “Wait Longer” (highlighted)." srcset="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752-1024x596.png 1024w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752-300x175.png 300w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752-768x447.png 768w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_210752.png 1252w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Isn’t it pretty? Of course this is staged using <em>SIGSTOP</em> – KWrite is awesome and never freezes like this!</figcaption></figure>



<p>It’s always fun to add your copyright from 2023 to a file with “© 2003” at the top. Times were surely different back then and what was considered good user interface design, too. The prompt for terminating an app is actually a separate executable since under X KWin isn’t really designed to open windows by itself and even under Wayland it’s tough. The helper might also use <em>KAuth</em> to end a privileged process. Being an external application, however, poses some challenges under Wayland because unlike X, it actually has some notion of security, and thus no random client can just mess with another one.</p>



<p>In order for the helper to attach itself to the frozen application window, it needs to use the <em><a href="https://wayland.app/protocols/xdg-foreign-unstable-v2" data-type="link" data-id="https://wayland.app/protocols/xdg-foreign-unstable-v2" target="_blank" rel="noreferrer noopener">XDG Foreign</a></em> protocol. It’s designed for this particular use case of parenting oneself to a window in another process and used by for example the <a href="https://github.com/flatpak/xdg-desktop-portal" data-type="link" data-id="https://github.com/flatpak/xdg-desktop-portal">XDG Desktop Portal</a> where a file dialog should appear as if it were coming from the application that requested it. The way it works is relatively simple: A client can ask the compositor to “export” a surface and receives a unique token for it. This token can then be passed to another application by any means (DBus, environment variable, doesn’t matter) which uses it to “import” that surface (to put it simply) and parent a window to it. But it’s a one-way street – you cannot pull a surface <em>from</em> another client, it has to send it <em>to</em> you.</p>



<p>KWin of course supports this protocol but its internals weren’t designed for it to launch an application by itself and export a surface to it, it would only export surfaces on behalf of an actual Wayland client. It took me like three different attempts to find a good solution everyone was happy about: just create an “exported surface” base class that is referenced internally and create a subclass including the Wayland resources when actually needed. I’m still having a bit of a hard time wrapping my head around the memory ownership model employed by Qt Wayland Scanner. It’s a build tool which takes a Wayland XML Protocol description and generates C++ classes out of it for use in your Qt application.</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231123_124252.png"><img decoding="async" width="1010" height="702" src="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231123_124252.png" alt="KWrite text editor window, desaturated, reading “Untitled – KWrite (Not Responding)” with a popup ontop of it reading “Application kwrite is not responding. You tried to close window Untitled from application KWrite (PID 1464283) but the application is not responding. Do you want to terminate this application? Warning: Terminating the application will close all of its child windows. Any unsaved data will be lost” with actions “Terminate Application kwrite” and “Wait Longer” (highlighted)." srcset="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231123_124252.png 1010w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231123_124252-300x209.png 300w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231123_124252-768x534.png 768w" sizes="(max-width: 1010px) 100vw, 1010px"/></a><figcaption>The original prompt, just running under Wayland. Quite a mouthful, isn’t it?</figcaption></figure>



<p>Next, I introduced a <em>KillPrompt</em> class that managed the life cycle of the process so its logic could easily be shared between X11 and Wayland windows. Originally, the <em>X11Window</em> class even used lowlevel <em>::kill(0)</em> calls scattered throughout it to check whether the helper was still alive. Not something you would do today thanks to <em>QProcess</em>. The helper takes a bunch of command-line arguments, such as the window title, application name, process ID, etc. Instead of sending an X Window ID I used the UUID of the aforementioned exported surface and instead of using the “Window Class” I used the more contemporary “desktop file name” (application ID) – that’s also why the original version above reads “org.kde.kwrite” instead of just “kwrite”.</p>



<p>Additionally, instead of setting the “X User Time” for soothing KWin’s focus stealing prevention I generated an activation token to enable the dialog to properly focus itself. That’s using <a href="https://wayland.app/protocols/xdg-activation-v1" target="_blank" rel="noreferrer noopener"><em>XDG Activation</em></a>, a Wayland protocol for passing focus between programs, for instance clicking a link in a chat app should bring the browser to the front. The same principle applies: you ask the compositor for a token and then pass it to another application. However, the compositor may invalidate that token if you’re typing elsewhere in the meantime or the window wasn’t actually active at the time it requested the token and so on.</p>



<p>KWin also has a <em>killPingTimeout</em> option (despite what some people say about KDE software being jammed with settings, this one isn’t in a spin box in System Settings) which defaults to 5 seconds. When clicking the close button, at half that time the window gets de-saturated as “not responding” and once the full timeout has passed the prompt asks whether to terminate the application. Now you might be asking yourself: Wait a minute, I have seen my windows getting all washed out even without trying to close them?!</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_222031.png"><img decoding="async" width="728" height="548" src="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_222031.png" alt="Same dialog, this time asking to terminate a browser window" srcset="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_222031.png 728w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_222031-300x226.png 300w" sizes="(max-width: 728px) 100vw, 728px"/></a><figcaption>I will never figure out the word wrapping logic for message boxes. Again, staged using <em>SIGSTOP</em>.</figcaption></figure>



<p>I congratulate you on using Wayland then! On X we only ping a window when asking it to close because we cannot really be certain that it will respond to our ping or even implement the interfaces that we need for that. On Wayland however, your typical floating desktop application will implement the <a href="https://wayland.app/protocols/xdg-shell" data-type="link" data-id="https://wayland.app/protocols/xdg-shell" target="_blank" rel="noreferrer noopener"><em>XDG Shell</em> protocol</a> which handles things such as the window title, title bar buttons, and popup menus, and specifies a “ping” operation. In addition to pinging a window when closing it, KWin can also safely ping it whenever it gets focus, and thus realize sooner that it has become frozen.</p>



<p>Coming back to the timeout, I found that it was actually hard-coded to 1 second in the Wayland case. Sometimes even my IDE loading a large project or the email client handling lots of incoming messages was enough to cause a brief flash of white. How hard can it be to pass an <em>int</em> around? Well, KWin’s Wayland interfaces are to be kept separate from its main application logic (most importantly to ease unit testing but also historically from trying to make them available to others as a KDE Framework) so I couldn’t just access KWin’s <em>options</em> dict from there and read the setting out of it. Instead, I had to inject the value from the outside and refactor KWin’s startup a bit so that the XDG Shell integration is only initialized once the options have actually been read.</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_192839.png"><img loading="lazy" decoding="async" width="814" height="457" src="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_192839.png" alt="Dialog asking to permanently delete a QML file, instead of the regular warning icon there is a QML file icon (green sheet of paper) with an orange exclamation mark in the corner." srcset="https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_192839.png 814w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_192839-300x168.png 300w, https://blog.broulik.de/wp-content/uploads/2023/11/Screenshot_20231124_192839-768x431.png 768w" sizes="(max-width: 814px) 100vw, 814px"/></a><figcaption><em>Concept: </em>Should we use this icon with a badge design in more places?</figcaption></figure>



<p>Ultimately, I figured, if I’m working on this piece of code anyway, I might as well overhaul its design which hasn’t changed much in two decades. You might recall I <a href="https://blog.broulik.de/2021/06/blast-from-the-past-icon-dialog/" data-type="post" data-id="1016">like doing that sort of thing</a>. First of all, I used the desktop file name to look up the actual application name. Next, I significantly reduced the amount of text – by the time you finished reading the original dialog, the app might already be responding again ;) Technical information like the process ID and host name (in case of remote X applications) was then tucked away in the expandable “Details” section. I also tried hard to remove the redundant application name from the displayed title but some apps use an <em>ndash</em>, some an <em>mdash</em>, some just a regular hyphen, and some even put it <em>before</em> the window title.</p>



<p>I furthermore felt the need to more prominently correlate the dialog to the application that is about to be terminated and used its icon instead of the generic orange exclamation mark. The overlay you can see in the screenshots was achieved using <em>KIconUtils</em> in our <a href="https://api.kde.org/frameworks/kguiaddons/html/index.html" data-type="link" data-id="https://api.kde.org/frameworks/kguiaddons/html/index.html" target="_blank" rel="noreferrer noopener">KGuiAddons framework</a> which – instead of drawing a pixmap once – creates a “live” <em>QIconEngine</em> that can re-render when the window gets moved between screens of different DPI. Saved me quite some <em>QPainter</em> headaches right there! Finally, the helper received a proper <em>.desktop</em> file which is needed to give it an appropriate window icon. It also let me suppress the bouncing cursor it would otherwise get by setting <em>StartupFeedback</em> to <em>false</em>. Originally, I wanted to restore the “bomb” icon it used to have but given the circumstances I opted for that sad face we also use in <em>DrKonqi</em> when an application crashes.</p>



<p>Next time you’re wondering why it took so long to implement that tiny feature X and Y, think of me and all the plumbing that had to be done for a <em>stupid freaking message box</em> that you should never even see in the first place and the love and attention to detail that me and my fellow KDE developers put in our software. A good way to show your love for KDE is to donate to our <a href="https://kde.org/fundraisers/plasma6member/" data-type="link" data-id="https://kde.org/fundraisers/plasma6member/" target="_blank" rel="noreferrer noopener">Plasma 6 fundraiser</a>! ♥</p>



<p><em>Discuss this post on <a href="https://discuss.kde.org/t/freezing-in-style/7655" data-type="link" data-id="https://discuss.kde.org/t/freezing-in-style/7655" target="_blank" rel="noreferrer noopener">KDE Discuss</a>.</em></p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
