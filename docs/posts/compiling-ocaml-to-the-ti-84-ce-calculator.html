<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://farlow.dev/2025/05/17/ocaml-on-calculator">Original</a>
    <h1>Compiling OCaml to the TI-84 CE Calculator</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>In this post, I‚Äôll explain how I compiled an OCaml program to run on a TI-84+ CE calculator. üê™</p>

<p><img src="https://farlow.dev/assets/2025-05-17-ocaml-on-calculator/cube.gif" alt="A 3D cube rotating on a TI-84+ CE calculator"/>
</p>

<h2 id="background">Background</h2>

<p><a href="https://ocaml.org/">OCaml</a> is a somewhat niche functional language that I‚Äôve
enjoyed learning over the last couple of years. I‚Äôve also been a calculator
enthusiast since high school, working on projects like
<a href="https://github.com/nathanfarlow/PineappleCAS">PineappleCAS</a>. At the time, the
calculator toolchain only supported C and (e)z80 assembly. Now, talented folks
have set up a <a href="https://github.com/CE-Programming/toolchain">toolchain</a> that
leverages LLVM so you can program in C, C++, Rust, Zig, and others. OCaml is
notably missing from this list. Let‚Äôs fix that!</p>

<h2 id="compiling-ocaml">Compiling OCaml</h2>

<p>There are <a href="https://ocaml.org/manual/native.html">native OCaml compilers</a> for
x86, ARM, and PowerPC. There is also a bytecode compiler, though it‚Äôs largely
undocumented (see
<a href="https://github.com/ocaml/ocaml/blob/trunk/runtime/interp.c">interp.c</a>). All of
these backends need a runtime that includes a garbage collector and native
functions to do useful things like print to stdout and read files.
Unfortunately, these artifacts tend to be large due to the OCaml compiler‚Äôs lack
of dead code elimination.</p>

<p>I really like the idea of compiling an entire OCaml program into a single highly
portable ANSI C file that we could compile with the calculator toolchain (or any
C toolchain!).</p>

<p>This idea isn‚Äôt new: <a href="https://github.com/bvaugon/ocamlcc">ocamlcc</a> compiles
OCaml bytecode to C. <a href="https://github.com/stevenvar/OMicroB">OMicroB</a> compiles
OCaml to small devices by optimizing the OCaml bytecode and using a lightweight
virtual machine.</p>

<p>For my approach, I wanted something that is:</p>

<ol>
  <li>Highly portable</li>
  <li>Interacts well with the OCaml build system</li>
  <li>Small ‚Äì The generated code and runtime should fit in the 256k RAM on the TI-84+ CE</li>
</ol>

<p><em>Note that ‚Äúefficient‚Äù and ‚Äúpractical‚Äù are missing from this list :)</em></p>

<p>Enter <a href="https://ocsigen.org/js_of_ocaml/">Js_of_ocaml</a>. Js_of_ocaml powers nearly
all of the OCaml website frontends that are written in OCaml. (Yes, that‚Äôs a
real thing!). First, the OCaml is compiled to bytecode, then Js_of_ocaml
optimizes that bytecode and lifts that bytecode into javascript.</p>

<p>The high level idea is as follows: we‚Äôll write a new backend for Js_of_ocaml to
emit C instead of javascript. Then we‚Äôll just need to add a couple native
functions and a garbage collector. The great thing about this approach is that
Js_of_ocaml is well maintained, so we can expect it to keep up with OCaml as the
language and bytecode changes. Js_of_ocaml also has a strong dead code
elimination pass, and it is first-class supported by dune, OCaml‚Äôs build system.</p>

<h2 id="new-c-backend">New C Backend</h2>

<p>Because most javascript constructs map trivially to C, we can mostly just use
the real Js_of_ocaml backend as a reference and hack out <a href="https://github.com/nathanfarlow/c-of-ocaml/blob/main/compiler/compile.ml">our C
backend</a>.
We can take some shortcuts, like using <code>goto</code> statements instead of
reimplementing complex logic to map things into <code>if</code>/<code>else</code> blocks. The only
catch is that we have to write a garbage collector.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>In order to write a garbage collector, we need to know which objects are alive
at the time of garbage collection. The native compilers can do this by scanning
the stack and CPU registers for pointers to OCaml heap objects. We can‚Äôt do this
because we want our C file to be as portable as possible. Instead, we‚Äôll replace
all local variables with explicit reads and writes into a global stack. That
way, we can scan the global stack to find all of our live objects when it comes
time to GC. Here‚Äôs a conceptual example of what I mean:</p>

<div><div><pre><code><span>value</span> <span>global_stack</span><span>[</span><span>1024</span><span>];</span>
<span>value</span> <span>*</span><span>bp</span> <span>=</span> <span>global_stack</span><span>;</span>
<span>value</span> <span>*</span><span>sp</span> <span>=</span> <span>global_stack</span><span>;</span>

<span>void</span> <span>transmogrify</span><span>(</span><span>value</span> <span>string</span><span>)</span> <span>{</span>
  <span>bp</span> <span>=</span> <span>sp</span><span>;</span>
  <span>sp</span> <span>+=</span> <span>2</span><span>;</span> <span>// Allocate space for 2 local variables</span>

  <span>bp</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>caml_copy_string</span><span>(</span><span>string</span><span>);</span>
  <span>bp</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>caml_reverse_string</span><span>(</span><span>string</span><span>);</span>

  <span>// Do something with these local vars</span>

  <span>sp</span> <span>=</span> <span>bp</span><span>;</span> <span>// Deallocate the two local variables</span>
<span>}</span>

<span>void</span> <span>gc</span><span>()</span> <span>{</span>
  <span>// Scan through global_stack from 0 up to sp</span>
  <span>// and mark those values as &#34;alive&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>We‚Äôll consider garbage collecting any time we want to allocate a new OCaml
object. We‚Äôll garbage collect if either:</p>

<ol>
  <li>The allocation would put us over the max memory limit</li>
  <li>The allocation would put us over 2x the memory that we were at after the last
collection</li>
</ol>

<p>When we garbage collect, we‚Äôll do a simple mark and sweep. First, we‚Äôll scan the
global stack. When we encounter an OCaml pointer, we‚Äôll follow that pointer and
every pointer that object has recursively, marking them all as alive. When we‚Äôre
done, we‚Äôll free every other object that wasn‚Äôt marked.</p>

<h2 id="runtime">Runtime</h2>

<p>In order for the OCaml code to do useful things, we can use the <code>extern</code> keyword
in OCaml to call any C functions that we write. We can then write the C
functions to support a minimal <a href="https://github.com/nathanfarlow/c-of-ocaml/tree/main/runtime/stdlib">standard
library</a>
and a small <a href="https://github.com/nathanfarlow/c-of-ocaml/tree/main/calc/ti84ce">TI-84+ CE
library</a> that
can do things like drawing to the screen.</p>

<h2 id="build-system">Build system</h2>

<p>Because Js_of_ocaml is first-class supported in OCaml‚Äôs build system, so also is
our C_of_ocaml. We can ergonomically write a <a href="https://github.com/nathanfarlow/c-of-ocaml/tree/main/calc/cube">spinning cube OCaml
program</a> for the
calculator with LSP support and <code>dune build</code> commands working out of the box.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Feel free to check out the generated C code for a simple OCaml fibonacci program
<a href="https://github.com/nathanfarlow/c-of-ocaml/blob/main/assets/example_generated.c">here</a>.
You can compile it with gcc! The first half of the C file is the runtime, and
the second half is the generated code.</p>

<p>Many OCaml features (floats, exceptions, etc) aren‚Äôt supported. In fact, the
spinny cube demo uses fixed point numbers (with 24 bit registers!). Maybe in the
future I‚Äôll try to use this project with
<a href="https://farlow.dev/2025/05/02/wee">wee</a> to get OCaml running ~anywhere.
I hope you found the post interesting! Thanks for reading. All the source code
can be found <a href="https://github.com/nathanfarlow/c-of-ocaml">here</a>.</p>

  </div>

  
</article>

      </div>
    </div></div>
  </body>
</html>
