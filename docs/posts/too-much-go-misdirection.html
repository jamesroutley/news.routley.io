<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/too-much-go-misdirection">Original</a>
    <h1>Too Much Go Misdirection</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Poking through layers of indirection in <b>go</b> trying to recover some efficiency.</p><p>Many functions in <b>go</b> take an <code>io.Reader</code> interface as input. This is a sensible default, allowing for streaming of data, instead of loading the entirety into memory. In some cases, though, we need the bytes. Which we may already have, in which case it would be great to simply use those bytes. Alas, this can be quite difficult.</p><h3 id="context">context</h3><p>I’m decoding some images. I’m using <i>libavif</i> and <i>libheif</i> via C bindings. For reasons primarily motivated by simplicity, I’m using the simple memory interfaces for these libraries, which makes it much easier to get the data from go into C. The streaming interface is much more work, and anyway the libraries would then just buffer the data internally, making another copy. Not every decoder fully works in a streaming fashion.</p><p>So the primary do the work function takes a <code>[]byte</code> and passes it to C, and there’s a wrapper that does things the go way with an <code>io.Reader</code>, which does a full read into a temporary buffer before sending it along. Now, as it happens, my application also uses <code>[]byte</code> internally because that’s what I’m getting out of <i>libsqlite3</i> (because again, the streaming interface is much trickier to wire up) and also because that’s what you get when doing RPC with <i>encoding/gob</i>. I think this is not an unusual scenario.</p><h3 id="bytes">bytes</h3><p>What I would like is for my image decoding function to notice that the <code>io.Reader</code> it has been given is in fact a <code>bytes.Reader</code> so we can skip the copy. Anyone who’s spent any time looking around in the go standard library has noticed that similar shortcuts are commonplace. Interfaces are type checked against specific implementations, and then optimized code paths are taken. Well, we can do the check, but it doesn’t immediately help, because <code>bytes.Reader</code> doesn’t expose its internal byte slice.</p><p>But it’s in there somewhere and I will not be denied.</p><pre><code>    <span>if</span> br<span>,</span> ok <span>:=</span> r<span>.</span><span>(</span><span>*</span>bytes<span>.</span>Reader<span>)</span>; ok <span>{</span>
        data <span>=</span> <span>*</span><span>(</span><span>*</span>[]<span>byte</span><span>)</span><span>(</span>unsafe<span>.</span>Pointer<span>(</span>br<span>)</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>var</span> buf bytes<span>.</span>Buffer
        io<span>.</span>Copy<span>(</span>&amp;buf<span>,</span> r<span>)</span>
        data <span>=</span> buf<span>.</span>Bytes<span>(</span><span>)</span>
    <span>}</span></code></pre><p>This seems to work in simple tests, but not when using the <code>image.Decode</code> function. A copy is still made. What’s wrong?</p><pre><code><span>func</span> Decode<span>(</span>r io<span>.</span>Reader<span>)</span> <span>(</span>Image<span>,</span> <span>string</span><span>,</span> error<span>)</span> <span>{</span>
    rr <span>:=</span> asReader<span>(</span>r<span>)</span>
<span>}</span>
<span>func</span> asReader<span>(</span>r io<span>.</span>Reader<span>)</span> reader <span>{</span>
    <span>if</span> rr<span>,</span> ok <span>:=</span> r<span>.</span><span>(</span>reader<span>)</span>; ok <span>{</span>
        <span>return</span> rr
    <span>}</span>
    <span>return</span> bufio<span>.</span>NewReader<span>(</span>r<span>)</span>
<span>}</span>
<span>type</span> reader <span>interface</span> <span>{</span>
    io<span>.</span>Reader
    Peek<span>(</span><span>int</span><span>)</span> <span>(</span>[]<span>byte</span><span>,</span> error<span>)</span>
<span>}</span></code></pre><p>Turns out the go image library does its own type inspection, looking for a <code>Peek</code> function, and if it’s not found, wraps the reader in a <code>bufio.Reader</code> instead. So the <code>bytes.Reader</code> never makes it into our function as is.</p><p>Now, why doesn’t <code>bytes.Reader</code> implement <code>Peek</code>? It’s just a byte slice, it’s definitely possible to peek ahead without altering stream state. But it was overlooked, and instead this workaround is applied.</p><p>Just knowing that we have a <code>bufio.Reader</code> isn’t sufficient, because, again, it doesn’t expose the underlying reader to us. It’s fine, okay, whatever. I am a master of unception.</p><pre><code><span>type</span> bufioReader <span>struct</span> <span>{</span>
    buf []<span>byte</span>
    rd  io<span>.</span>Reader
<span>}</span>
    <span>if</span> br<span>,</span> ok <span>:=</span> r<span>.</span><span>(</span><span>*</span>bufio<span>.</span>Reader<span>)</span>; ok <span>{</span>
        insides <span>:=</span> <span>(</span><span>*</span>bufioReader<span>)</span><span>(</span>unsafe<span>.</span>Pointer<span>(</span>br<span>)</span><span>)</span>
        r <span>=</span> insides<span>.</span>rd
    <span>}</span></code></pre><p>The new procedure is to look for a <code>bufio.Reader</code> and if so, unpack the inner reader. And then, as before, if it’s a <code>bytes.Reader</code>, we extract the bytes. The zero copy dream is alive.</p><h3 id="trees">trees</h3><p>The <code>bufio.Reader</code> should <i>probably</i> expose the underling reader.</p><p>The <code>bytes.Reader</code> should really implement <code>Peek</code>. I’m pretty sure the reason it doesn’t is because this is the only way of creating read only views of slices. And a naughty user could peek at the bytes and then modify them. Sigh. People hate const poisoning, but I hate this more.</p><p><code>bytes.Buffer</code> provides a <code>Bytes</code> function, but still not <code>Peek</code>, so even if you know that’s required or useful, it’s not a simple swap.</p><h3 id="forest">forest</h3><p>I’ve said this before, but the way <b>go</b> does structural typing, and the way the standard library uses it, creates these shadow APIs where blessed types work better than others. It’s almost never documented what the secret requirements are. But can you blame me for wanting to join the party?</p><p>I think two interpretations are possible. Casting was added to the language, and it’s used throughout the standard library, thus proving the feature is useful. Or pessimistically, every cast is a design oversight. The approach (in general, not my specific wizardry) only scales to the extent people stick with the standard types. It’s obviously not going to be feasible to specialize on third party types.
</p></div><div><p>
Posted 19 May 2025 14:45 by tedu Updated: 19 May 2025 14:45 
</p></div></div>
  </body>
</html>
