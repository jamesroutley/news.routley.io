<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dylibso.com/blog/why-extism/">Original</a>
    <h1>Extism makes WebAssembly easy</h1>
    
    <div id="readability-page-1" class="page"><div>
          
<p>A staggering number of languages and platforms support WebAssembly (Wasm). Runtimes are available in every major browser, via the most popular edge and serverless providers, across a dizzying number of IoT devices, and on globe-spanning blockchain compute platforms. When you compile your program to Wasm, you can run it nearly anywhere. But that power isn’t exactly easy to harness today.</p>
<p>While programmers are accustomed to modeling their work in terms of their business logic – classes like <code>User</code>, <code>Item</code>, or <code>Cart</code> – Wasm works in terms of numbers and linear memory, making it difficult to communicate with guest Wasm programs about even basic types, like strings<sup><a href="#user-content-fn-component-model" id="user-content-fnref-component-model" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. And while Wasm is broadly supported, it’s not natively available for every language platform, and specifications are adopted by language compilers and runtimes at different rates. This makes it difficult to compile to Wasm and run it “out of the box”.</p>
<p>This is where <a href="https://extism.org/">Extism</a> comes in. Extism streamlines the developer experience across languages and platforms for everyone – whether you’re compiling to Wasm or embedding Wasm programs. And you can use it today.</p>
<h2 id="how-does-extism-help">How does Extism help?</h2>
<p>So how does Extism help make WebAssembly easier to use? With two assertions:</p>
<ol>
<li>It should be a no-brainer to host WebAssembly guest programs from applications written in your language of choice.</li>
<li>It should be dead simple to communicate between WebAssembly and the host program.</li>
</ol>
<p>Extism makes it easy to use Wasm in your application by providing <a href="https://extism.org/docs/category/integrate-into-your-codebase">host SDKs</a> in an ever growing list of languages. We use runtimes native to the host language – like Golang’s <a href="https://wazero.io/docs/">Wazero</a> or JS’s web platform – where available. Where that’s not available, we distribute <code>libextism</code> shared objects, and allow for easy installation with the <a href="https://extism.org/docs/install/">Extism CLI</a>. <code>libextism</code> wraps <a href="https://wasmtime.dev/">Wasmtime</a>, an industrial-grade Wasm runtime. With this approach, Extism brings the ability to host Wasm programs to environments that may be years away from being able to do so natively.</p>
<p>Making it dead simple to communicate with Wasm is less straightforward. It involves abstracting away the hard parts of Wasm by providing constructs to enable HTTP requests, error handling, memory management, and the ability to pass types that are more complex than numbers between the host and the WebAssembly. A lot of great work is being done in the Wasm community to define specifications like <a href="https://wasi.dev/">WASI</a> and the <a href="https://github.com/WebAssembly/component-model">Component Model</a> that make Wasm development easier. We at Dylibso are participating in these efforts and working to make sure Extism supports the Component Model as it develops. Extism already has support for WASI (preview 1) and will continue to seamlessly integrate new standards and bring them to as many languages as possible as they solidify.</p>
<p>To better illustrate the hard parts of using Wasm, let’s create a function that takes a string as input, modifies it, and returns a new string, then compile that to Wasm and run it. Seems simple enough, right? Maybe get a glass of water just in case.</p>

<p>When using Wasm, it is often helpful to bear in mind the guest/host relationship. The Wasm binary being executed is the “guest”, and the “host” is the program that executes that binary.</p>
<p>Let’s start by writing a <strong>guest</strong> program that defines a function called <code>say_hello</code> which accepts a string as input and returns a string as output. At least, that’s how we’d like to think about the guest program. In actuality, since this code is being compiled to Wasm, our function can only accept and return numeric types, so we have to pass our input string and recieve our output string another way. In this case, we’ll store the input and output strings in linear memory and pass their size and addresses (pointers) between the host and guest through the guest’s exported <code>say_hello</code> function<sup><a href="#user-content-fn-radu" id="user-content-fnref-radu" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>.</p>
<p>Ok, we’ve got a plan, let’s give it a go (in Rust)!</p>
<pre>  <code><span><span>// src/lib.rs:</span></span>
<span></span>
<span><span>use</span><span> </span><span>std</span><span>::</span><span>mem;</span></span>
<span><span>use</span><span> </span><span>std</span><span>::</span><span>ptr;</span></span>
<span><span>use</span><span> </span><span>std</span><span>::</span><span>slice;</span></span>
<span></span>
<span><span>#[no_mangle]</span></span>
<span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span><span> </span><span>say_hello</span><span>(mem_addr</span><span>:</span><span> </span><span>*const</span><span> </span><span>u8</span><span>, len</span><span>:</span><span> </span><span>usize</span><span>, ret_len_addr</span><span>:</span><span> </span><span>*mut</span><span> </span><span>u32</span><span>) </span><span>-&gt;</span><span> </span><span>i32</span><span> {</span></span>
<span><span>    // read input string</span></span>
<span><span>    </span><span>let</span><span> data</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt; </span><span>=</span><span> </span><span>unsafe</span><span> { </span><span>slice</span><span>::</span><span>from_raw_parts</span><span>(mem_addr, len)</span><span>.</span><span>to_vec</span><span>() };</span></span>
<span></span>
<span><span>    // create output string</span></span>
<span><span>    </span><span>let</span><span> greeting </span><span>=</span><span> </span><span>format!</span><span>(</span></span>
<span><span>        </span><span>&#34;Hello there, {}.  That was a lot of memory management to pass a string!&#34;</span><span>,</span></span>
<span><span>        </span><span>String</span><span>::</span><span>from_utf8_lossy</span><span>(</span><span>&amp;</span><span>data)</span></span>
<span><span>    );</span></span>
<span></span>
<span><span>    // determine the length of the output string and set that value in the address of ret_len_addr</span></span>
<span><span>    </span><span>unsafe</span><span> {</span></span>
<span><span>        </span><span>ptr</span><span>::</span><span>write</span><span>(ret_len_addr, greeting</span><span>.</span><span>len</span><span>() </span><span>as</span><span> </span><span>u32</span><span>);</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    greeting</span><span>.</span><span>as_ptr</span><span>() </span><span>as</span><span> </span><span>i32</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[no_mangle]</span></span>
<span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span><span> </span><span>alloc</span><span>() </span><span>-&gt;</span><span> </span><span>*const</span><span> </span><span>u8</span><span> {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> buf </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>1024</span><span>);</span></span>
<span><span>    </span><span>let</span><span> ptr </span><span>=</span><span> buf</span><span>.</span><span>as_mut_ptr</span><span>();</span></span>
<span></span>
<span><span>    // tell Rust not to clean this up</span></span>
<span><span>    </span><span>mem</span><span>::</span><span>forget</span><span>(buf);</span></span>
<span></span>
<span><span>    ptr</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[no_mangle]</span></span>
<span><span>pub</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span><span> </span><span>dealloc</span><span>(ptr</span><span>:</span><span> </span><span>&amp;mut</span><span> </span><span>u8</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> _ </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>from_raw_parts</span><span>(ptr, </span><span>0</span><span>, </span><span>1024</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code>
</pre>
<p>We start off by including the <code>std::slice</code>, <code>std::mem</code> and <code>std::ptr</code> modules from the Rust Standard Library. These modules allow us to perform operations on raw pointers. The <code>#[no_mangle]</code> attribute instructs the compiler to preserve the function name as authored during compilation.  This is necessary so that the runtime knows how to reference the function when it is being executed by a host. On the following line, <code>pub extern &#34;C&#34; fn say_hello</code> indicates that the <code>say_hello</code> function is intended to be called by some external code across an <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>. In many cases, this is used to compile your code into a <code>.dylib</code> or <code>.so</code> to be linked into some other program. However, because we are compiling to Wasm, we are indicating to the compiler that the function is to be exported from our Wasm module so that a host (or some other module) may call it.</p>
<p>Now we’ve got to come up with some numeric parameters that will allow us to express a string. We’ll use Wasm’s linear memory in combination with function arguments and returns to facilitate passing complex data into and out of the <code>say_hello</code> function. Before we start passing pointers around, let’s have a quick sidebar about memory management.</p>
<p>In order to use Wasm’s linear memory in a somewhat responsible manner, we need to be careful about how we allocate and deallocate memory. This is where the <code>alloc</code> and <code>dealloc</code> functions we defined as guest exports come into play. These functions serve as a naive implementation of a memory allocator that can only allocate and deallocate 1024 bytes at a time. This allows the host and guest to allocate linear memory without corrupting one another, however this naive approach is bound to lead to an excess of memory allocation. Spoiler alert: Extism takes additional care into ensuring efficient memory allocation and abstracts this away for the developer. Ok let’s get back to breaking down the <code>say_hello</code> function.</p>
<p>The first parameter, <code>mem_addr: *const u8</code>, represents a raw pointer to the location in linear memory where the host placed the input string. The next parameter, <code>len: usize</code> represents the length of the input string in bytes.</p>
<p>This is enough for us to go and retrieve our input string, so let’s zoom in on that before we describe how we return a string - I haven’t forgotten about the third parameter!</p>
<pre>  <code><span></span>
<span><span>// ...</span></span>
<span><span>let</span><span> data</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt; </span><span>=</span><span> </span><span>unsafe</span><span> { </span><span>slice</span><span>::</span><span>from_raw_parts</span><span>(mem_addr, len)</span><span>.</span><span>to_vec</span><span>() };</span></span>
<span><span>let</span><span> greeting </span><span>=</span><span> </span><span>format!</span><span>(</span></span>
<span><span>    </span><span>&#34;Hello there, {}.&#34;</span><span>,</span></span>
<span><span>    </span><span>String</span><span>::</span><span>from_utf8_lossy</span><span>(</span><span>&amp;</span><span>data)</span></span>
<span><span>);</span></span>
<span><span>// ...</span></span></code>
</pre>
<p>First we use <code>slice::from_raw_parts</code> to initialize a <code>Vec&lt;u8&gt;</code> from the location and length in memory that the host passed in. This is an unsafe operation in Rust because we are dealing with raw pointers, so the compiler cannot guarantee the memory is allocated with what we expect it to be (or even at all!). This is ok though since we have full control over linear memory as authors of both the guest and the host. On the following line, we decode our <code>Vec&lt;u8&gt;</code> from raw bytes to a UTF-8 string, and save that to a new variable called <code>greeting</code>. Our guest code has now created a new String called <code>greeting</code> which simply appends the string we got from our input to some hard-coded string. Let’s look at how we return this string to the host. This is where that third parameter to <code>say_hello</code> comes into play:</p>
<pre>  <code><span></span>
<span><span>// set the address pointed to by `ret_len_addr` to the length of the new string</span></span>
<span><span>unsafe</span><span> {</span></span>
<span><span>    </span><span>ptr</span><span>::</span><span>write</span><span>(ret_len_addr, greeting</span><span>.</span><span>len</span><span>() </span><span>as</span><span> </span><span>u32</span><span>);</span></span>
<span><span>};</span></span>
<span></span>
<span><span>greeting</span><span>.</span><span>as_ptr</span><span>() </span><span>as</span><span> </span><span>i32</span></span></code>
</pre>
<p>In order for the host to receive the output string, it needs to know the location and size of the string that the guest created. We again need to perform an unsafe operation by writing a <code>u32</code> integer (which holds the length of the new string, <code>greeting</code>) into the memory address passed to us by the host as a function parameter (<code>ret_len_addr</code>). With the length of the output string written to a place in linear memory that the host knows about, we can return a pointer to the output string’s memory address, and now the host has all it needs (the memory address and length) to find and decode the return string. You can compile this code to WebAssembly by running: <code>cargo build --target=wasm32-unknown-unknown</code> (the source code for this example is also available <a href="https://github.com/extism/why-extism-blog/tree/main/no-extism-guest">here</a>).</p>
<p>Before we get into how to do this in Extism, let’s take a quick look at the host code just to show you how to run the guest WebAssembly module we created above. I left comments in-line rather than going through it in depth.</p>
<pre>  <code><span><span>// /src/main.rs</span></span>
<span></span>
<span><span>// we&#39;re using Wasmtime as our WebAssembly runtime, but there are a number of runtimes available</span></span>
<span><span>use</span><span> </span><span>wasmtime</span><span>::*</span><span>;</span></span>
<span></span>
<span><span>fn</span><span> </span><span>main</span><span>() </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(), </span><span>Box</span><span>&lt;</span><span>dyn</span><span> std</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>&gt;&gt; {</span></span>
<span><span>    // checkout the wasmtime crate docs to learn more about embedding wasmtime into your rust applications - https://docs.wasmtime.dev/examples-rust-embed.html</span></span>
<span><span>    </span><span>let</span><span> engine </span><span>=</span><span> </span><span>Engine</span><span>::</span><span>default</span><span>();</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> store </span><span>=</span><span> </span><span>Store</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>engine, ());</span></span>
<span><span>    </span><span>let</span><span> module </span><span>=</span><span> </span><span>Module</span><span>::</span><span>new</span><span>(</span></span>
<span><span>        </span><span>&amp;</span><span>engine,</span></span>
<span><span>        // the location of the Wasm binary we compiled from our guest code</span></span>
<span><span>        </span><span>include_bytes!</span><span>(</span></span>
<span><span>            </span><span>&#34;../../no-extism-guest/target/wasm32-unknown-unknown/debug/no_extism_guest.wasm&#34;</span></span>
<span><span>        ),</span></span>
<span><span>    )</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> instance </span><span>=</span><span> </span><span>Instance</span><span>::</span><span>new</span><span>(</span><span>&amp;mut</span><span> store, </span><span>&amp;</span><span>module, </span><span>&amp;</span><span>[])</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> say_hello </span><span>=</span><span> instance</span><span>.</span><span>get_typed_func</span><span>::</span><span>&lt;(</span><span>i32</span><span>, </span><span>i32</span><span>, </span><span>i32</span><span>), </span><span>i32</span><span>&gt;(</span><span>&amp;mut</span><span> store, </span><span>&#34;say_hello&#34;</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> alloc </span><span>=</span><span> instance</span><span>.</span><span>get_typed_func</span><span>::</span><span>&lt;(), </span><span>i32</span><span>&gt;(</span><span>&amp;mut</span><span> store, </span><span>&#34;alloc&#34;</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> dealloc </span><span>=</span><span> instance</span><span>.</span><span>get_typed_func</span><span>::</span><span>&lt;</span><span>i32</span><span>, ()&gt;(</span><span>&amp;mut</span><span> store, </span><span>&#34;dealloc&#34;</span><span>)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // get an instance of linear memory</span></span>
<span><span>    </span><span>let</span><span> memory </span><span>=</span><span> instance</span></span>
<span><span>        </span><span>.</span><span>get_memory</span><span>(</span><span>&amp;mut</span><span> store, </span><span>&#34;memory&#34;</span><span>)</span></span>
<span><span>        </span><span>.</span><span>ok_or</span><span>(</span><span>anyhow</span><span>::</span><span>format_err!</span><span>(</span><span>&#34;failed to find `memory` export&#34;</span><span>))</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // allocate memory to hold the input string and the output string return length</span></span>
<span><span>    </span><span>let</span><span> input_addr </span><span>=</span><span> alloc</span><span>.</span><span>call</span><span>(</span><span>&amp;mut</span><span> store, ())</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> output_len_addr </span><span>=</span><span> alloc</span><span>.</span><span>call</span><span>(</span><span>&amp;mut</span><span> store, ())</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // define the input string and write the string as binary to the memory we allocated for the input string</span></span>
<span><span>    </span><span>let</span><span> input_string </span><span>=</span><span> </span><span>b&#34;non-extism host!&#34;</span><span>;</span></span>
<span><span>    memory</span><span>.</span><span>write</span><span>(</span><span>&amp;mut</span><span> store, input_addr </span><span>as</span><span> </span><span>usize</span><span>, input_string)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // invoke the `say_hello` function and save the memory address to where the output will be saved</span></span>
<span><span>    </span><span>let</span><span> output_addr </span><span>=</span><span> say_hello</span><span>.</span><span>call</span><span>(</span></span>
<span><span>        </span><span>&amp;mut</span><span> store,</span></span>
<span><span>        (</span></span>
<span><span>            input_addr,</span><span>                // input memory address</span></span>
<span><span>            input_string</span><span>.</span><span>len</span><span>() </span><span>as</span><span> </span><span>i32</span><span>,</span><span> // input length</span></span>
<span><span>            output_len_addr </span><span>as</span><span> </span><span>i32</span><span>,</span><span>    // output length memory address</span></span>
<span><span>        ),</span></span>
<span><span>    )</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // we are storing the length of the output string as an unsigned 32 bit integer in linear memory, so let&#39;s</span></span>
<span><span>    // allocate 4 bytes, read the data from linear memory, and store it in the len_buffer</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> len_buffer </span><span>=</span><span> [</span><span>0</span><span>u8</span><span>; </span><span>4</span><span>];</span></span>
<span><span>    memory</span><span>.</span><span>read</span><span>(</span><span>&amp;</span><span>store, output_len_addr </span><span>as</span><span> </span><span>usize</span><span>, </span><span>&amp;mut</span><span> len_buffer)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // convert the bytes into an i32 (WebAssembly is always little endian)</span></span>
<span><span>    </span><span>let</span><span> len </span><span>=</span><span> </span><span>i32</span><span>::</span><span>from_le_bytes</span><span>(len_buffer);</span></span>
<span></span>
<span><span>    // let&#39;s now create a new Vec&lt;u8&gt; to store the bytes of the output string and fit it to size</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> v </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>::</span><span>new</span><span>();</span></span>
<span><span>    v</span><span>.</span><span>resize</span><span>(len </span><span>as</span><span> </span><span>usize</span><span>, </span><span>0</span><span>);</span></span>
<span></span>
<span><span>    // read the memory address returned to us by the `say_hello` function, which points to the location</span></span>
<span><span>    // in linear memory where our WebAssembly module stored the output string</span></span>
<span><span>    memory</span><span>.</span><span>read</span><span>(</span><span>&amp;</span><span>store, output_addr</span><span>.</span><span>try_into</span><span>()</span><span>.</span><span>unwrap</span><span>(), </span><span>&amp;mut</span><span> v)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // decode the byte vector into a UTF8 string and print to the console!</span></span>
<span><span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>, </span><span>String</span><span>::</span><span>from_utf8_lossy</span><span>(</span><span>&amp;</span><span>v));</span></span>
<span></span>
<span><span>    // deallocate all of the memory that we allocated</span></span>
<span><span>    // this is technically unnecessary because the program is about to end, but that may not always be the case</span></span>
<span><span>    dealloc</span><span>.</span><span>call</span><span>(</span><span>&amp;mut</span><span> store, input_addr)</span><span>?</span><span>;</span></span>
<span><span>    dealloc</span><span>.</span><span>call</span><span>(</span><span>&amp;mut</span><span> store, output_len_addr)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    </span><span>Ok</span><span>(())</span></span>
<span><span>}</span></span>
<span></span></code>
</pre>
<p>We did it! We passed a string into a Wasm function and got a string back in return! After a well deserved pat on the back, let’s now take a look at how to do this with Extism.</p>

<p>Luckily, there’s a lot less to go through with Extism. Here is the equivalent code:</p>
<pre>  <code><span><span>// /src/lib.rs</span></span>
<span></span>
<span><span>use</span><span> </span><span>extism_pdk</span><span>::*</span><span>;</span></span>
<span></span>
<span><span>#[plugin_fn]</span></span>
<span><span>pub</span><span> </span><span>fn</span><span> </span><span>say_hello</span><span>(input</span><span>:</span><span> </span><span>String</span><span>) </span><span>-&gt;</span><span> </span><span>FnResult</span><span>&lt;</span><span>String</span><span>&gt; {</span></span>
<span><span>    </span><span>let</span><span> greeting </span><span>=</span><span> </span><span>format!</span><span>(</span><span>&#34;Hello, {}&#34;</span><span>, input);</span></span>
<span><span>    </span><span>Ok</span><span>(greeting)</span></span>
<span><span>}</span></span></code>
</pre>
<p>and the host code:</p>
<pre>  <code><span><span>// /src/main.rs</span></span>
<span></span>
<span><span>fn</span><span> </span><span>main</span><span>() </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(), </span><span>Box</span><span>&lt;</span><span>dyn</span><span> std</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>&gt;&gt; {</span></span>
<span><span>    </span><span>let</span><span> ctx </span><span>=</span><span> </span><span>extism</span><span>::</span><span>Context</span><span>::</span><span>new</span><span>();</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> plugin </span><span>=</span><span> </span><span>extism</span><span>::</span><span>Plugin</span><span>::</span><span>new</span><span>(</span></span>
<span><span>        </span><span>&amp;</span><span>ctx,</span></span>
<span><span>        </span><span>include_bytes!</span><span>(</span><span>&#34;../../yes-extism/target/wasm32-unknown-unknown/debug/yes_extism.wasm&#34;</span><span>),</span></span>
<span><span>        [],</span></span>
<span><span>        </span><span>false</span><span>,</span></span>
<span><span>    )</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> data </span><span>=</span><span> plugin</span><span>.</span><span>call</span><span>(</span><span>&#34;say_hello&#34;</span><span>, </span><span>&#34;extism host!&#34;</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>, </span><span>String</span><span>::</span><span>from_utf8_lossy</span><span>(data));</span></span>
<span><span>    </span><span>Ok</span><span>(())</span></span>
<span><span>}</span></span></code>
</pre>
<p>As tempting as it is to drop the mic, let’s be civil and talk a bit about what Extism is doing.</p>
<p>One of the things you may have already noticed is that you no longer need to manage Wasm memory directly in either the guest or the host. Extism abstracts away the “hard part” of managing your own memory by providing constructs for clean and efficient memory management that you can rely on throughout the runtime of your program. Oh, and Extism doesn’t only work with strings, you can use JSON, Protobuf, raw binary.. whatever!</p>
<p>The Extism <a href="https://extism.org/docs/category/write-a-plug-in">Plugin Development Kit (“PDK”)</a> provides constructs for dealing with input, output, errors, and memory (as seen in this small program), but it also provides mechanisms for http, configuration, plugin scoped variables… the list will continue to grow with the needs of the community. As for the host code, let’s take another look and talk about some of the key benefits we get from using Extism:</p>
<pre>  <code><span><span>// /src/main.rs</span></span>
<span></span>
<span><span>fn</span><span> </span><span>main</span><span>() </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(), </span><span>Box</span><span>&lt;</span><span>dyn</span><span> std</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>&gt;&gt; {</span></span>
<span><span>    </span><span>let</span><span> ctx </span><span>=</span><span> </span><span>extism</span><span>::</span><span>Context</span><span>::</span><span>new</span><span>();</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> plugin </span><span>=</span><span> </span><span>extism</span><span>::</span><span>Plugin</span><span>::</span><span>new</span><span>(</span></span>
<span><span>        </span><span>&amp;</span><span>ctx,</span></span>
<span><span>        </span><span>include_bytes!</span><span>(</span><span>&#34;../../yes-extism/target/wasm32-unknown-unknown/debug/yes_extism.wasm&#34;</span><span>),</span></span>
<span><span>        [],</span></span>
<span><span>        </span><span>false</span><span>,</span></span>
<span><span>    )</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> data </span><span>=</span><span> plugin</span><span>.</span><span>call</span><span>(</span><span>&#34;say_hello&#34;</span><span>, </span><span>&#34;extism host!&#34;</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>, </span><span>String</span><span>::</span><span>from_utf8_lossy</span><span>(data));</span></span>
<span><span>    </span><span>Ok</span><span>(())</span></span>
<span><span>}</span></span></code>
</pre>
<p>Not only is this code easier to reason about, but we preserved the flexibility we need while abstracting away the initialization of the Wasm runtime. As a result, we could swap it out for a runtime that aligns more with the specific needs of your program with minimal changes. Extism accounts for the nuances of Wasm runtimes and compilers to achieve a smooth and interoperable developer experience <a href="https://extism.org/docs/category/integrate-into-your-codebase">across a growing list of languages and platforms</a>.</p>

<p>As the primary maintainers of Extism, we keep a close eye on <a href="https://webassembly.github.io/spec/core/">the core WebAssembly specification</a> and related specifications like <a href="https://wasi.dev/">WASI</a> and the <a href="https://github.com/WebAssembly/component-model">Component Model</a>. We track Wasm feature adoption in runtimes throughout the ecosystem to make sure that Extism developers have access to the latest capabilities Wasm has to offer. Our goal with Extism is to make it painless to unlock all of Wasm’s capability, even as those capabilities grow.</p>
<p>We’ve had a blast bringing the speed, security, portability and composability of Wasm to developers in so many languages and <em>this is just the beginning</em>! Extism is already used in production by many projects and, later this year, we’ll release <strong>Extism 1.0</strong>. Extism 1.0 comes with a promise that our tooling and libraries are officially stable. Beyond 1.0, we are excited to continue to advance Extism in alignment with the core WebAssembly specification and community, and will continue to ensure a smooth and consistent developer experience for those who are producing or executing WebAssembly.</p>

<p>Have a question about anything in this article, Extism, or WebAssembly in general? Head on over to our <a href="https://extism.org/discord">friendly discord</a> and drop us a note!</p>

<p>A big thanks to my colleagues <a href="http://www.neversaw.us/">Chris Dickinson</a> and <a href="https://bhelx.simst.im/">Ben Eckel</a> for their sage guidance in writing this article!</p>

        </div></div>
  </body>
</html>
