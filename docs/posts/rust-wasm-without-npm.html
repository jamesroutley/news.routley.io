<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lionturkey.github.io/posts/rustwasm/rustwasm.html">Original</a>
    <h1>Rust/Wasm without npm</h1>
    
    <div id="readability-page-1" class="page"><article>
                    
                    <p>A couple weeks ago, I saw Rachel&#39;s Rust generative <a href="https://r4chel.github.io/art/">art app</a> and since then, I&#39;ve been gunning to make a Rust web app of my own. Like most Rust documentation, the go-to Game of Life <a href="https://rustwasm.github.io/docs/book/introduction.html">web app tutorial</a> is informative and easy to follow. However, it assumes use of <a href="https://www.npmjs.com/">npm</a> and a Javascript bundler whereas I prefer avoiding extra stuff. If for whatever reason that resonates with someone, maybe this post will be helpful.</p>
                    <p>If not, skip to the bottom to see the thing!</p>
                    <h2 id="some-notes">Some notes</h2>
                    <p>The point of all this is to write performant stuff in Rust, compile it into webassembly (Wasm) using <a href="https://rustwasm.github.io/wasm-pack/installer/"><code>wasm-pack</code></a>, and have regular Javascript call on the Wasm to do heavy lifting. In order to expose Rust/Wasm functions so that they can be called from Javascript, we use the Rust crate <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> and annotate any Rust function we wish to export with <code>#[wasm-bindgen]</code>.</p>
                    <p>Rather than following the tutorial&#39;s bloated Hello World, I recommend the <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/hello-world.html">equivalent page</a> from the <code>wasm-bindgen</code> documentation, which also provides information on how to do without npm and Webpack. Otherwise, the Game of Life tutorial is excellent. To compile to Wasm for immediate use, use the command <code>wasm-pack build --target web</code>.</p>
                    <p>In addition to the resulting <code>.wasm</code> binary, <code>wasm-pack</code> will generate Javascript boilerplate, Typescript declaration files, and a <code>package.json</code> in a folder called <code>pkg</code>. From what I can tell, most of this is for npm to build a package from. Without npm, it turned out the <code>.wasm</code> binary and the <code>.js</code> boilerplate was all I needed.</p>
                    <pre><code>pkg
├── package<span>.json</span>
├── wasm_game_of_life_bg<span>.wasm</span>
├── wasm_game_of_life_bg<span>.wasm</span><span>.d</span><span>.ts</span>
├── wasm_game_of_life<span>.d</span><span>.ts</span>
└── wasm_game_of_life.js</code></pre>
                    <h2 id="adjustments">Adjustments</h2>
                    <p>Without npm, a few things change from the tutorial:</p>
                    <h4 id="javascript-imports-must-specify-the-js-file-and-include-the-provided-default-init-function">Javascript imports must specify the <code>.js</code> file and include the provided default <code>init</code> function</h4>
                    <p>For instance,</p>
                    <pre><code>import init, { Universe, Cell } from &#39;./pkg/wasm_game_of_life.js&#39;;</code></pre>
                    <p>rather than</p>
                    <pre><code>import { Universe, Cell } from &#34;wasm-game-of-life&#34;;</code></pre>
                    <h4 id="the-wasm-binary-must-be-loaded-in-with-the-init-function-before-it-is-used">The <code>.wasm</code> binary must be loaded in with the <code>init()</code> function before it is used</h4>
                    <p>For example, if we exported a <code>wordle</code> function from Rust, we might write the following Javascript to use it:</p>
                    <pre><code><span>import</span> init, {wordle} <span>from</span> <span>&#39;./pkg/wasm_wordle.js&#39;</span>
                    
<span>async</span> <span><span>function</span> <span>run</span>(<span></span>) </span>{
        <span>await</span> init();
        wordle();
}

run();</code></pre>
                    <p>In case you&#39;re like me and don&#39;t know much Javascript and/or are very rusty, <code>await</code> can only be used in an <code>async</code> function and will halt the function until the statement finishes (more correctly: until a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> is settled, but this isn&#39;t super helpful for me to think about yet). In this case, that means <code>wordle()</code> will not be called until <code>init()</code> finishes loading in the Wasm that <code>wordle()</code> needs to run.</p>
                    <h4 id="in-order-to-access-memory-used-by-wasm-without-npm-we-need-to-save-the-output-of-the-init-function">In order to access memory used by Wasm without npm, we need to save the output of the <code>init()</code> function</h4>
                    <p>So instead of:</p>
                    <pre><code>import { memory } from <span>&#34;wasm-wordle/wasm_wordle_bg&#34;</span>
                    
...<span>blah </span><span>blah...
</span>const wordleData = new Uint8Array(memory.<span>buffer, </span>dataPtr, dataLength)</code></pre>
                    <p>something like:</p>
                    <pre><code><span>import</span> init, {wordle} <span>from</span> <span>&#39;./pkg/wasm_wordle.js&#39;</span>
                    
<span>async</span> <span><span>function</span> <span>run</span>(<span></span>) </span>{
    <span>let</span> wasm = <span>await</span> init();

    ...blah blah...
    const wordleData = <span>new</span> <span>Uint8Array</span>(wasm.memory.buffer, dataPtr, dataLength);
}

run();</code></pre>
                    <h2 id="results">Results</h2>
                    <p>In the end, you&#39;ve got a Wasm binary and a Javascript module to load it into whatever HTML document you&#39;ve got. Like this one! I&#39;m pretty excited to try this again with my own projects. I have some ideas involving audio processing and grammar parsing that might appreciate the speed boost of Rust and Wasm.</p>
                    <p>Anyhoo, below is the thing. I&#39;ll figure out how to CSS style it better later.</p>
                    
                </article></div>
  </body>
</html>
