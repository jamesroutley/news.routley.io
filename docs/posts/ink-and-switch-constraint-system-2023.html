<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.inkandswitch.com/ink/notes/phase-2-constraint-system/">Original</a>
    <h1>Ink and Switch Constraint System (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
<dl>
<p><dt>title</dt><dd>Constraint System</dd></p>
<p><dt>dated</dt><dd>Fall 2023</dd></p>
</dl>
<p>At the beginning of <a href="https://www.inkandswitch.com/ink/notes/phase-2-snapshot/">phase 2</a>, we weren’t sure what to do about constraints. Based on past exploration, constraints seemed to hold a lot of promise but were notoriously unreliable. A good constraint system could unify and power a number of key aspects of the dynamic medium we seek. It would allow for mechanical constructions, like a rope and pulley, that feel physically correct. It would allow for a computational model that bridged between algebraic formulae and tangible objects, like an architectural drawing that changed in response to edits in a parameter table. It’d allow for true bidirectional computation, instead of the limited / biased computation we had in Crosscut.</p>
<p>But constraint systems are hard to implement. They tend to suffer from the following issues:</p>
<ul>
<li>“Floaty-ness”, where manipulating one parameter causes other parameters to drift in ways that feel unnatural or unrealistic.</li>
<li>“Blow-ups”, where manipulating part of the system causes other parts of the system to collapse inward or explode out to infinity (divergence toward or away from zero, rather than convergence on a reasonable value).</li>
<li>Poor performance, either due to slow convergence or to excess recalculation when constraints are added or removed.</li>
</ul>
<p>Early in this phase Alex was optimistic that with a bit of effort these issues could be overcome. After a few weeks he was able to show very promising results. This early success built on his earlier work on <a href="">propagation of knowns</a> to reduce the number of variables whose values had to be determined by the solver. Then, by leveraging equality constraints (and more generally, any linear relationship between variables — <code>y=mx+b</code> where <code>m</code> is not zero) he further reduced the number of dimensions that the solver had to worry about.</p>
<p>As an example, consider an angle constraint that “exports” two variables: one whose value is the angle in degrees, and another whose value is in radians. While either or both of those variables may be referenced by other constraints or scrubbed by the user, they collapse to a single variable as far as the solver is concerned — after all, once you know the value of one of them, you can compute the value of the other.</p>
<p>This technique is not just an optimization that enables the solver to converge to a solution more quickly; it often enables the solver to find a solution where it wouldn’t have been able to otherwise. It also improves the feel of our prototype by eliminating the “floaty-ness” that results from duplicated state. More importantly, this technique also enabled us to avoid blow-ups when duplicated or “uneven” constraints are added to a model.</p>
<p>To illustrate this point, suppose the user has added an angle constraint between points <code>A</code> and <code>B</code>, which introduced a variable <code>θ<sub>AB</sub></code>. Now consider what happens when the user adds another angle constraint that involves the same points, but this time in the opposite direction. This is a situation that could lead to an unstable construction. Our new constraint system detects this, and instead of adding the second angle constraint, it introduces the variable <code>θ<sub>BA</sub></code> and a linear relationship  <code>θ<sub>BA</sub> = θ<sub>AB</sub> + π</code>. So nothing changes for the solver: there is still only one variable (<code>θ<sub>AB</sub></code>) to solve for, and only one constraint to satisfy. But to the user, it looks like there are two separate angle constraints. They can further constrain <code>θ<sub>BA</sub></code>, or later remove the second angle constraint if they wish. (We are happy to report that all of the <a href="">unstable constructions we documented in phase 1</a><!--https://www.notion.so/inkandswitch/78346b6ab0a34f1cad0ed990bbfcf5d4--> are perfectly stable in our new constraint system.)</p>
<p>Another useful technique we developed for the constraint system is what we call “clustering”, i.e., the partitioning of the constraints and the variables on which they operate into <em>clusters</em> that can be solved independently. (As Avi pointed out, this is analogous to the notion of <a href="https://box2d.org/posts/2023/10/simulation-islands/">simulation islands</a> in some physics engines.) By breaking up the solver’s workload into clusters, we reduced the number of dimensions it has to worry about, which has led to significant improvements in convergence. Clustering also opens up the possibility for us to parallelize the solver — this is something we can explore when we start to build larger projects/models that require better performance.</p>
<p>While these analyses and techniques are an important part of our constraint system, they are not tied to a particular choice of solver. This gives us the freedom to plug in better options as they become available. In addition to Alex’s relaxation-based solver, we tried several gradient descent-based solvers, which resulted in better convergence. The first was the uncmin from <a href="https://github.com/sloisel/numeric">numericjs</a>. Later, we found a version of uncmin that was modified by Guillermo Webster for his <a href="https://github.com/bijection/g9">g9</a> project, which gave us even better results. We hope to eventually try Avi Bryant’s new solver which uses auto-diff (instead of numerical differentiation) and WebAssembly for added performance and stability.</p>
<p>Further gains were made by reframing the way values were represented in the system. For example, instead of representing positional relationships as occurring in cartesian space (with x/y coordinates), relationships were expressed in polar space (with angle/distance coordinates).</p>

  </div></div>
  </body>
</html>
