<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.agwa.name/blog/post/sqlite_durability">Original</a>
    <h1>SQLite&#39;s Durability Settings Are a Mess</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>
One of the most important properties of a database is durability.  Durability means that after a transaction commits, you
can be confident that, absent catastrophic hardware failure, the changes made by the commit won&#39;t be lost.  This should
remain true even if the operating system crashes or the system loses power soon after the commit.  On Linux, and most other Unix operating systems, durability is ensured by calling the <a href="https://man7.org/linux/man-pages/man2/fsync.2.html" rel="external">fsync</a> system call at the right time.
</p>

<p>
Durability comes at a performance cost, and sometimes applications don&#39;t need durability.  Some applications can tolerate
losing the last several seconds of commits in the event of a power failure, as long as the database doesn&#39;t end up
corrupted.  Thus, databases typically provide knobs to configure if and when they call fsync.  This is fine, but it&#39;s essential
that the database clearly documents what its default durability properties are, and what each configuration setting guarantees.
</p>

<p>
Unfortunately, SQLite&#39;s documentation about its durability properties is far from clear.  I cannot tell whether SQLite is durable
by default, and if not, what are the minimal settings you need to use to ensure durability.
</p>

<p>The two relevant configuration
options are <a href="https://sqlite.org/pragma.html#pragma_journal_mode" rel="external"><code>journal_mode</code></a> and <a href="https://sqlite.org/pragma.html#pragma_synchronous" rel="external"><code>synchronous</code></a>.  <code>journal_mode</code> has several possible values, but most people use either DELETE or WAL.  <code>synchronous</code> has four possible values: EXTRA, FULL, NORMAL, and OFF.
</p>

<p>
This is how I interpret SQLite&#39;s documentation after a careful reading:
</p>

<ul><li><p>The default value of <code>journal_mode</code> is DELETE:</p><blockquote>The DELETE journaling mode is the normal behavior (<a href="https://sqlite.org/pragma.html#pragma_journal_mode" rel="external">source</a>; <a href="https://web.archive.org/web/20250826165231/https://www.sqlite.org/pragma.html#pragma_journal_mode" rel="external">archived</a>)</blockquote></li><li><p>The default value of <code>synchronous</code> is FULL:</p><blockquote>If not overridden at compile-time, the default setting is 2 (FULL) (<a href="https://sqlite.org/compile.html#default_synchronous" rel="external">source</a>; <a href="https://web.archive.org/web/20250826070702/https://sqlite.org/compile.html#default_synchronous" rel="external">archived</a>)</blockquote></li><li><p>The default value of <code>synchronous</code> is FULL even in WAL mode:</p><blockquote>If not overridden at compile-time, this value is the same as SQLITE_DEFAULT_SYNCHRONOUS. (<a href="https://sqlite.org/compile.html#default_wal_synchronous" rel="external">source</a>; <a href="https://web.archive.org/web/20250826070702/https://sqlite.org/compile.html#default_wal_synchronous" rel="external">archived</a>)</blockquote></li><li><p>When <code>journal_mode</code> is DELETE, you need to set <code>synchronous</code> to EXTRA to get durability:</p><blockquote>EXTRA synchronous is like FULL with the addition that the directory containing a rollback journal is synced after that journal is unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability if the commit is followed closely by a power loss. (<a href="https://sqlite.org/pragma.html#pragma_synchronous" rel="external">source</a>; <a href="https://web.archive.org/web/20250826165231/https://www.sqlite.org/pragma.html#pragma_synchronous" rel="external">archived</a>)</blockquote>
<p>
Edited to add: I confirmed this to be true through testing - see <a href="https://news.ycombinator.com/item?id=45069533" rel="external">my Hacker News comment</a> for the methodology.
</p>
</li><li><p>When <code>journal_mode</code> is WAL, FULL is sufficient for durability:</p><blockquote>With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction helps ensure that transactions are durable across a power loss (<a href="https://sqlite.org/pragma.html#pragma_synchronous" rel="external">source</a>; <a href="https://web.archive.org/web/20250826165231/https://www.sqlite.org/pragma.html#pragma_synchronous" rel="external">archived</a>)</blockquote><p>Note that this is not mentioned under the definition of FULL, but rather further down in the documentation for <code>synchronous</code>.</p></li></ul>

<p>
Based on the above, I conclude that:
</p>

<ul><li><p>By default, SQLite is <strong>not</strong> durable, because the default value of <code>journal_mode</code> is DELETE, and the default value of <code>synchronous</code> is FULL, which doesn&#39;t provide durability in DELETE mode.</p></li><li><p>If you change <code>journal_mode</code> to WAL, then SQLite <strong>is</strong> durable, because <code>synchronous=FULL</code> provides durability in WAL mode.</p></li></ul>



<p>
However, a recent <a href="https://news.ycombinator.com/item?id=45014296" rel="external">Hacker News comment</a> by a user who credibly claims to be Richard Hipp, the creator of SQLite, says:
</p>

<ul><li><p>&#34;In its default configuration, SQLite is durable.&#34;</p></li><li><p>&#34;If you switch to WAL mode, the default behavior is that transactions ... are not necessarily durable across OS crashes or power failures&#34;</p></li></ul>

<p>
That&#39;s literally the opposite of what the documentation seems to say!
</p>

<p>
A Hacker News commenter who agrees with my reading of the documentation <a href="https://news.ycombinator.com/item?id=45015366" rel="external">asked Hipp</a> how his comment is consistent with the documentation, but received no reply.
</p>

<p>
Hipp also says that WAL mode used to be durable by default, but it was changed after people complained about poor performance.
This surprised me, since I had the impression that SQLite cared deeply about backwards compatibility, and weakening the
default durability setting is a nasty breaking change for any application which needs durability.
</p>

<p>
There are a couple other pitfalls around SQLite durability that you should be aware of, though I don&#39;t necessarily
blame the SQLite project for these:
</p>

<ul><li><p>Libraries that wrap SQLite can override the default value of <code>synchronous</code>.  For example, the most popular Go driver for SQLite <a href="https://github.com/mattn/go-sqlite3/blob/8bf7a8a844faf952aa0245b4c0ad0a47e84f4efd/sqlite3.go#L1318-L1320" rel="external">sets it to NORMAL</a> when in WAL mode, which does not provide durability.</p></li><li><p>On macOS, <a href="https://lactoseintolerant.dev/fsync-may-not-be-enough-to-guarantee-data-durability-on-mac-os/" rel="external">fsync is nerfed</a> to make macOS appear faster.  If you want a real fsync, you have to make a different, macOS-specific system call.  SQLite can do this, but it&#39;s <a href="https://sqlite.org/pragma.html#pragma_fullfsync" rel="external">off by default</a>.</p></li></ul>

<p>
My takeaway is that if you need durability, you&#39;d better set the <code>synchronous</code> option explicitly because who knows what the default is, or what it will be in the future.  With WAL mode, FULL seems to suffice.  As for DELETE mode, who knows if FULL is enough, so you&#39;d better go with EXTRA to be safe. And if your application might be used on macOS, enable <code>fullfsync</code>.
</p>

<p>
The SQLite project ought to clarify their documentation.  Since the meaning of <code>synchronous</code> depends on the value of <code>journal_mode</code>, I think it would be quite helpful to document the values of <code>synchronous</code> separately for each possible <code>journal_mode</code>, rather than mixing it all together.  A table with <code>synchronous</code> values on one axis and <code>journal_mode</code> on the other which tells you if the combination provides durability would do wonders.
</p>

<p>
By the way, there are definitely many applications for which losing a few seconds of data in exchange for better performance is a great tradeoff, which is why SQLite and macOS have made the choices they have made.  But programmers need to know what guarantees their tools provide, which is why unclear documentation and breaking previously-held assumptions is not cool.
</p>

</div></div>
  </body>
</html>
