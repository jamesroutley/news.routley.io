<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/i-won-free-load-testing">Original</a>
    <h1>I won free load testing</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>Long story short: a couple of my articles got <em>really</em> popular on a bunch of
sites, and someone, somewhere, went &#34;well, let&#39;s see how much traffic that
smart-ass can handle&#34;, and suddenly I was on the receiving end of a couple DDoS
attacks.</p>
<p>It really doesn&#39;t matter what the articles were about — the attack is <em>certainly
not representative</em> of how folks on either side of any number of debates
generally behave.</p>
<p>My assumption is that it&#39;s a small group (maybe a Discord?) with a botnet, who
wanted to have fun.</p>
<p>And, friends: fun was had.</p>
<h2>The main attack</h2>
<p>My main site (&#34;the blog&#34;) received about 34M requests over 72h - in three
spikes. It&#39;s behind Cloudflare at the time of this writing, so, here&#39;s a pretty
graph (the granularity / bucket size is 1 hour):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-analytics.05c3d2f3f55b777d.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-analytics.8fa0aedc10c5c1b8.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-analytics.5d992e3a2131d66b.jpg" title="8 million requests spike the morning of saturday the 30th, and an 11 million requests spike in the evening." alt="8 million requests spike the morning of saturday the 30th, and an 11 million requests spike in the evening."/>
            </picture>
            
<p>To give you an idea of scale, the article that &#34;blew up&#34; on multiple news
aggregators only got around 130K hits. This is what organic traffic looks like
(with a long tail and everything):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-organic.39c432ecc4abd259.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-organic.61fbfa208c2d29df.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-organic.c69a023851809d25.jpg" title="a 9 thousand requests spike on the afternoon of friday the 29th, that slowly withers down to 500 requests over the next two days" alt="a 9 thousand requests spike on the afternoon of friday the 29th, that slowly withers down to 500 requests over the next two days"/>
            </picture>
            
<p>In some ways, that attack was unsophisticated: it hit a single route, <code>/</code> (the
front page), and two thirds of the requests used a single user agent:</p>
<div><pre data-lang="">Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36
</pre></div>
<p>Which is just the user-agent of Chrome&#39;s current version on Linux 64-bit. The
traffic doesn&#39;t look like something like headless Chrome was used, (otherwise
there&#39;d be a lot more requests for assets like fonts, stylesheets, images etc.),
but it could&#39;ve been.</p>
<p>On the other hand, the attack was pretty well distributed:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-countries.5fa81c7152cf19c2.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-countries.c123eb50d5ce4a18.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-countries.87fd6d1e2bf73230.jpg" title="4 million requests from China, 3.5 million from India, 3 million from Brazil, 2M from the US, then Indonesia, the Philippines, Tor, Hong Kong, the UK, Thailand, everything else is under 800K requests" alt="4 million requests from China, 3.5 million from India, 3 million from Brazil, 2M from the US, then Indonesia, the Philippines, Tor, Hong Kong, the UK, Thailand, everything else is under 800K requests"/>
            </picture>
            
<p>Here are the top 15 <a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)">AS</a> the traffic came from:</p>
<ul>
<li>AS4134: <a href="http://www.chinatelecom-h.com/en/global/home.php">China Telecom</a> (China, backbone)</li>
<li>AS61317: <a href="https://www.heficed.com/">Heficed</a> (cloud provider)</li>
<li>AS398465: <a href="https://rackdog.com/">Rackdog</a> (cloud provider)</li>
<li>AS18209: <a href="https://www.actcorp.in/">Actcorp</a> (India, telecom)</li>
<li>AS14061: <a href="https://www.digitalocean.com/">DigitalOcean</a> (cloud provider)</li>
<li>AS17639: <a href="https://www.convergeict.com/">Converge ICT</a> (Philippines, telecom)</li>
<li>AS9829: <a href="https://bsnl.co.in/">Bharat Sanchar Nigam Limited</a> (India, backbone)</li>
<li>AS7713: <a href="https://telkom.co.id/sites">Telkom Indonesia</a> (Indonesia, telecom)</li>
<li>AS208294: <a href="https://www.cia-triad.com/">CIA Triad LLC</a>
<ul>
<li>IP prefix is in the US</li>
<li>Phone number has Australian prefix (+61)?</li>
<li>Associated with <a href="https://en.wikipedia.org/wiki/Torservers.net">Zwiebelfreunde</a> who provide Tor exit nodes</li>
</ul>
</li>
<li>AS8452: <a href="https://afrinic.net/">TE-AS</a> (Egypt, telecom)</li>
<li>AS205100: <a href="https://f3netze.de/">F3 Netze</a>, (Germany, associated with <a href="https://wiki.freifunk-franken.de/w/Hauptseite">Freifunk Franken</a>)</li>
<li>AS9299: <a href="https://main.pldt.com/">PLDT</a> (Philippines, telecom)</li>
<li>AS36947: <a href="https://www.algerietelecom.dz/fr/">Algérie Telecom</a> (Algeria, telecom)</li>
<li>AS141995: <a href="https://contabo.com/de/">Contabo Asia</a> (Singapore ops of a German cloud provider)</li>
<li>AS27699: <a href="https://www.telefonica.com/es/">Telefonica</a> (Brazil, telecom)</li>
</ul>
<p>So, you know. The flip side of compute and bandwidth becoming a very affordable
commodity worldwide is that... it&#39;s also affordable for bad actors.</p>
<p>Also, I&#39;m sure  Heficed, Rackdog, DigitalOcean and Contabo all say in their
Terms of Service &#34;don&#39;t use us to DDoS someone else&#34;, but it appears you can
definitely do it for a few hours without them noticing (whether it was through
compromised instances or not).</p>
<h2>The secondary attack</h2>
<p>The other target was my recently-launched video platform, which is a separate
service, and runs on <a href="https://fly.io/">fly.io</a>.</p>
<p>Here&#39;s that attack as seen from fly.io metrics (that I see as a user):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/fly-metrics.bff3180ad55f609b.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/fly-metrics.d55c272ba118259b.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/fly-metrics.c53a70ccf10726cb.jpg" title="a data transfer graph, showing a peak at 3.1GB/s" alt="a data transfer graph, showing a peak at 3.1GB/s"/>
            </picture>
            
<p>Here is the same attack as seen from <a href="https://www.honeycomb.io/">Honeycomb</a>,
where data is self-reported (from multiple instances of my app) and sampled (not
all traces are sent to Honeycomb):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-heatmap.d7e07be351029019.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-heatmap.1a1c9ca5fa9bae56.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-heatmap.69d416427f29c2c6.jpg" title="a honeycomb heatmap, showing request duration shooting up to 11 minutes!" alt="a honeycomb heatmap, showing request duration shooting up to 11 minutes!"/>
            </picture>
            
<p>Why yes, I do see something that stands out.</p>
<p>Let&#39;s use <a href="https://docs.honeycomb.io/working-with-your-data/bubbleup/">BubbleUp</a>
on that whole area there:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/circus-url.c268cc1a77e9cc5c.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/circus-url.15022b4a3a6d5831.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/circus-url.a80d07ba94831438.jpg" title="the honeycomb bubbleup feature, showing that 100% of requests in my selection are for the same path, for the I&#39;m in ur address space video, a file named av1_2160p.mp4" alt="the honeycomb bubbleup feature, showing that 100% of requests in my selection are for the same path, for the I&#39;m in ur address space video, a file named av1_2160p.mp4"/>
            </picture>
            
<p>Single biggest asset (4K@60 video asset for a 50 minute video), makes sense.</p>
<p>They even left me a note! How thoughtful.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/circus-useragent.ea41359ffcff4442.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/circus-useragent.985480b977652538.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/circus-useragent.b2a31d88fe4cb84a.jpg" title="" alt=""/>
            </picture>
            
<p>(That&#39;s a reference to one of the articles that got popular this week.)</p>
<p>I don&#39;t track which ranges were requested, but they did do some range requests,
and some full requests. Not sure if that was random or just two individuals
going at it:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/circus-status-code.7939c4417c0f6b01.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/circus-status-code.33bd5a5beb0450ef.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/circus-status-code.6ee15ef1ee705648.jpg" title="" alt=""/>
            </picture>
            
<p>That attack was a lot less distributed: it came from a bunch of
<a href="https://www.vultr.com/">Vultr</a> IPs, and it stopped after banning the whole AS
(just for my app).</p>
<h2>How effective were the attacks?</h2>
<p>To evaluate whether or not the attacks were successful, we need to discuss why
people on the internet perform them.</p>
<p>Arguably, the only reason is &#34;for the lulz&#34; (for laughs), but the lulz has
multiple tiers: the primary goal is to &#34;deny service&#34; - to overload the
server(s) so that some content is not accessible anymore.</p>
<p>Then there&#39;s secondary goals: because providers typically bill for bandwidth, if
it costs the target some money, that&#39;s even more fun. And if said providers
decide that actually, they <em>don&#39;t</em> want a customer who&#39;s getting targeted like
that, and boot them off their platform, then that&#39;s maximum fun.</p>
<p>And then of course there&#39;s the power trip, the idea that you have control over
someone else, the ability to &#34;punish&#34; them for something they did. Just like
any other form of harassment really.</p>
<p>So, were those goals met? </p>
<p>The primary goal definitely was: the site was inaccessible for a few hours over
the course of Saturday, April 30th. As far as HTTP status codes go, I&#39;m counting:</p>
<ul>
<li>11M &#34;499 Client Closed Request&#34;</li>
<li>6.5M &#34;503 Service Unavailable&#34;</li>
<li>6M &#34;403 Forbidden&#34;</li>
<li>4M &#34;200 OK&#34;</li>
<li>3M &#34;524 Origin Timeout&#34;</li>
<li>2M &#34;522 Origin Connection time-out&#34;</li>
<li>1.5M &#34;429 Too Many Requests&#34;</li>
<li>500K &#34;520 Origin Error&#34;</li>
<li>100K &#34;521 Origin Down&#34;</li>
</ul>
<p>A few people reached out to let me know about it, bummed they couldn&#39;t read the
article for the time being. But I mean, as long as <a href="https://archive.org/">The Internet
Archive</a> is up, is anything <em>really</em> down? News aggregator
users reflexively save articles that become somewhat popular, expecting them to
go down, or in case they need receipts.</p>
<p>As for the secondary objectives: none of them were met.</p>
<p>It didn&#39;t cost me a single dollar:</p>
<ul>
<li><a href="https://www.hetzner.com/">Hetzner</a> doesn&#39;t bill for bandwidth, it&#39;s a fixed monthly price kind of deal</li>
<li><a href="https://www.cloudflare.com/">Cloudflare</a> eats bigger attacks for breakfast, and they don&#39;t charge for it either.</li>
</ul>
<p>As for <a href="https://fly.io/">fly.io</a>, well, I work there, so, they pay <em>me</em>.</p>
<p>It didn&#39;t get me in trouble either. On the contrary, every time something like
that happens, I make new friends and hear back from old friends.</p>
<p>And honestly? Everyone brought popcorn and took notes. An attack like that is
both entertaining and informative. It kinda gave me a kick in the butt to
address some issues with my website. And it gave everyone ideas on how to better
protect against this kind of thing.</p>
<p>Just like this article right here is good intel for anyone who <em>is</em> looking to
DDoS me. But for me, sharing that info is part of the fun, and I don&#39;t really
believe you can really achieve resiliency through obscurity.</p>
<h2>Why the attack worked</h2>
<p>A service &#34;going down&#34; can mean many things: being temporarily suspended by a
cloud provider is one failure mode, for example. Having resource utilization
increase so much that a machine is constantly swapping and everything is 1000x
slower is another.</p>
<p>Here, there was a single point of failure: my origin, a single
<a href="https://www.hetzner.com/">Hetzner</a> dedicated server, running (some guessed it)
some Rust code.</p>
<p>It&#39;s not exactly a secret: I outlined <a href="https://www.evalapply.org/articles/a-new-website-for-2020">how my website is
built</a> back in 2020, and although I&#39;ve made
multiple <a href="https://www.evalapply.org/series/dont-shell-out">incremental improvements</a> since, it still
works essentially the same way.</p>
<p>Before I wrote my own server, I was using static site generators (nanoc, Hugo,
etc.), and deploying the result directly to an S3 bucket, configured for static
site serving, behind Cloudflare. That was an easy, reliable setup.</p>
<p>My site wouldn&#39;t have gone down if I was still using that setup. However, I
would also be looking at a rather large AWS bill right about now. (And I&#39;d
rather talk to AWS friends about anything other than billing).</p>
<div>

<div>
<p>Wait, a large AWS bill?</p>
<p>I thought you just said it was behind Cloudflare?</p>
</div>
</div>
<p>I know, I was surprised too. I&#39;m <em>fairly sure</em> it wasn&#39;t always that way, but if
you consult the Cloudflare docs, it <a href="https://developers.cloudflare.com/cache/about/default-cache-behavior/#default-cached-file-extensions">clearly says</a>:</p>
<blockquote>
<p>Cloudflare only caches based on file extension and not by MIME type. <strong>The
Cloudflare CDN does not cache HTML by default.</strong> Additionally, Cloudflare caches a
website’s robots.txt.</p>
</blockquote>
<p>And then, further down:</p>
<blockquote>
<p>To cache additional content, see <a href="https://developers.cloudflare.com/cache/how-to/create-page-rules/">Page
Rules</a> to
create a rule to cache everything.</p>
</blockquote>
<p>Over the years, Cloudflare has saved me a lot of bandwidth costs (well, it
would&#39;ve if I was paying for it), but &#34;only&#34; for images, CSS, JS, etc.</p>
<p>Not video, see Section 2.8 of their Self-Serve Subscription Agreement:</p>
<blockquote>
<h3>2.8 Limitation on Serving Non-HTML Content</h3>
<p>The Services are offered primarily as a platform to cache and serve web pages
and websites. Unless explicitly included as part of a Paid Service purchased by
you, you agree to use the Services solely for the purpose of (i) serving web
pages as viewed through a web browser or other functionally equivalent
applications, including rendering Hypertext Markup Language (HTML) or other
functional equivalents, and (ii) serving web APIs subject to the restrictions
set forth in this Section 2.8.</p>
<p><strong>Use of the Services for serving video or a disproportionate percentage of
pictures, audio files, or other non-HTML content is prohibited</strong>, unless purchased
separately as part of a Paid Service or expressly allowed under our Supplemental
Terms for a specific Service. If we determine you have breached this Section
2.8, we may immediately suspend or restrict your use of the Services, or limit
End User access to certain of your resources through the Services.</p>
</blockquote>
<p>(So, pissing off a kid with a botnet will not get you booted off of Cloudflare,
but building a video platform on top of it will. They want you to use <a href="https://www.cloudflare.com/en-gb/products/cloudflare-stream/">their
product for that</a>)</p>
<p>And, as it turns out, not for HTML.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-cache-status.8ef93e3fd22de0da.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-cache-status.c56a81d275d269cb.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-cache-status.69eece64cb7984b7.jpg" title="a graph showing cache status for requests over the past 72 hours there&#39;s large orange spikes, and larger still grey spikes" alt="a graph showing cache status for requests over the past 72 hours there&#39;s large orange spikes, and larger still grey spikes"/>
            </picture>
            
<p>Both top colors there are uncached requests: the orange spikes are the requests
my origin <em>did</em> manage to serve, and the grey ones are the ones Cloudflare
generated for me when the origin struggled too much (or when I stopped it
altogether).</p>
<p>The first thing I tried to do was add a <code>cache-control: public, max-age=120</code>
response header. Still, the cache status was &#34;dynamic&#34;, so every request went
to the origin.</p>
<div>

<p>I already had the <code>cache-control</code> header set for static assets (images,
stylesheets, scripts), just not for HTML, because in two years of repeatedly
hitting the front page of various sites, it was never a performance concern.</p>
</div>
<p>Creating a page rule didn&#39;t immediately fix everything (but I&#39;m convinced I was
holding it wrong, since that&#39;s <em>the</em> thing they want you to do), but even if it
had, at least on the Free and Pro plans, you can only match by URL: so, this
would break the website for any logged-in users (who support me financially, and
have access to some articles in advance).</p>
<div>

<p>On the Business and Pro plans, there&#39;s a &#34;Bypass Cache on Cookie&#34; feature, which
even lets you specify regex patterns, like <code>PHPSESSID=.*</code>.</p>
<p>However, it wouldn&#39;t take a very motivated attacker to figure out that they can
hammer your origin with a well-formed cookie: there&#39;s no way for Cloudflare&#39;s
edge to know whether the session cookie is actually valid or not, so it only
helps for legitimate requests, not for attacks.</p>
</div>
<p>Long story short: without upgrading to the next plan over ($200/month), I can&#39;t
use Cloudflare to cache HTML in a way that doesn&#39;t break my site. <em>And</em> that
wouldn&#39;t help protect against attacks.</p>
<p>Meanwhile, back in my origin server...</p>
<div><p>Shell session</p><pre data-lang="shell">$ sudo ss | wc -l
352950
</pre></div>
<p>Oh, 350K connections.</p>
<p>That&#39;s a lot of connections </p>
<p>That&#39;s certainly more connections than there should EVER be between Cloudflare
and my server. But Cloudflare expects origin servers to signal when they&#39;re
struggling.</p>
<p>Origins should return
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429">429</a>, or
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503">503</a>, or start
refusing connections; they should do something, <em>anything</em> other than just
accept a ridiculous number of concurrent connections and let them just sit there
— that&#39;s just a bad deal for everybody.</p>
<p>And my site didn&#39;t do that! Because I half-assed that bit, and it worked for two
years straight anyway. Almost as if... it was possible to move fast, delivering
value, leaving some problems for later, even with Rust...</p>

<p>Right, right, sorry.</p>
<p>So: the lack of caching wasn&#39;t actually <em>that</em> surprising to me. I do consider
my HTML content dynamic, just like Cloudflare does: it is different for
logged-in users, there&#39;s random bits (&#34;what to read/watch next&#34;), there&#39;s a
full-text search engine (really just SQLite&#39;s, nothing fancy there yet).</p>
<p>However, I <em>did</em> expect Cloudflare&#39;s <a href="https://www.cloudflare.com/en-gb/ddos/">DDoS
protection</a>, their #1 selling point, to
kick in.</p>
<p>And it <em>mostly didn&#39;t</em>.</p>
<p>Although Cloudflare <em>did</em> block/present a challenge for some fraction of the
incoming traffic, it mostly did so when I turned on the <a href="https://support.cloudflare.com/hc/en-us/articles/200170076-Understanding-Cloudflare-Under-Attack-mode-advanced-DDOS-protection-">I&#39;m Under
Attack</a>
mode, and even then, definitely not enough to let my origin serve legitimate
requests again.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-security-events.ba498a945f310617.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-security-events.dd713fd6d7b446b6.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-security-events.de06d57d822e59ce.jpg" title="cloudflare security events graph, showing 10M total actions, 3.5M challenges, 2.5M legacy captchas, 2M js challenges, and 1.7M blocks" alt="cloudflare security events graph, showing 10M total actions, 3.5M challenges, 2.5M legacy captchas, 2M js challenges, and 1.7M blocks"/>
            </picture>
            
<p>By the time the second wave happened, I was already in touch with an engineer at
Cloudflare, who helped some, and let me know something interesting: the reason
protection wasn&#39;t kicking in was that <em>the attacker was staying just below their
detection threshold</em>.</p>
<p>Which seems to indicate the attacker knew what they were doing. But then why use
a fixed user-agent? And hit just the one endpoint?</p>
<div>

<p>Because that&#39;s all it took?</p>
</div>
<p>Eh, fair enough.</p>
<p>Which brings us to another interesting point: the amount of requests is
impressive in total, and very spikey, but it was still under Cloudflare&#39;s
detection threshold most of the time, which means... my server probably
should&#39;ve handled it like a champ!</p>
<div>

<p>And just to be clear: it didn&#39;t, right?</p>
</div>
<p>Oh no, not at all. Memory usage was quite alright (hardly went past 5%), but all
eight CPU cores were nearly maxed out, and, well, I couldn&#39;t get a single 200 OK
out of it during the attack, even locally.</p>
<div>

<p>But then again I didn&#39;t sit there patiently for <em>minutes</em> waiting for my
connection to be accepted.</p>
</div>
<p>See, at that time, my server was quite busy, doing a lot of stuff. Here&#39;s a
representative of what was going on, obtained with <a href="https://www.brendangregg.com/perf.html">perf</a>
(the exact command is just <code>sudo perf top</code>):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/perf-top.94941f1c5186302b.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/perf-top.0cf0de5335a8d0ca.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/perf-top.8dd2313b59f292dd.jpg" title="a view of where the system was spending the most time, with functions from sqlite&#39;s btree table, malloc, pthread_mutex_lock, lol_html for html rewrite, some syscall stuff, some utf-8 decoding stuff" alt="a view of where the system was spending the most time, with functions from sqlite&#39;s btree table, malloc, pthread_mutex_lock, lol_html for html rewrite, some syscall stuff, some utf-8 decoding stuff"/>
            </picture>
            
<p>As I mentioned, my website is <em>mostly</em> static content, but not just. And as I
described <a href="https://www.evalapply.org/articles/a-new-website-for-2020">in 2020</a>, I&#39;m not optimizing for
&#34;maximum server performance&#34;, I&#39;m optimizing for &#34;maximum content authoring
convenience&#34; (and also nice features for readers).</p>
<p>And so, Rust maximalism be damned, most of my website is actually powered by
<a href="https://lib.rs/crates/liquid">liquid templates</a> and SQL queries.</p>
<p>Only the very base: file watching, hashing, DB management, the HTTP stack, and
some very useful custom liquid filters (to render markdown, including my custom
extensions, etc.), is actually written in Rust.</p>
<p>The front page, for example, runs <em>several</em> SQL queries to retrieve the latest
videos, articles, and series. It then runs several liquid filters, not to
process markdown (I cache that), but to truncate the HTML body so I can show just
an excerpt with a &#34;Read more&#34; button.</p>
<p>For the curious, it looks something like this:</p>
<div><pre data-lang="">{% include &#34;html/prologue.html&#34; %}

{% capture sql_start %}
    SELECT pages.*
    FROM pages
    JOIN revision_routes ON revision_routes.hapa = pages.hapa
    WHERE revision_routes.revision = ?1
{% endcapture %}

{% capture sql_end %}
    {% unless config.drafts %}
        AND NOT pages.draft
    {% endunless %}
    {% unless config.future %}
        AND datetime(pages.date) &lt; datetime(&#39;now&#39;)
    {% endunless %}
    ORDER BY date DESC
{% endcapture %}

{% capture articles_sql %}
    {{sql_start}}
    AND revision_routes.parent_route_path = &#39;articles&#39;
    {{sql_end}}
    LIMIT 3
{% endcapture %}
{% assign articles = articles_sql | query: revision %}
</pre></div>
<p>Later on, the <code>page_listing</code> partial is invoked, which does stuff like:</p>
<div><pre data-lang="">&lt;div class=&#34;page-section post-list&#34;&gt;
    {% for page in pages %}
        {% assign page_html = page | page_markup %}

        &lt;div class=&#34;post-summary&#34;&gt;
            {{ page_html | truncate_html: max: 120 }}
        &lt;/div&gt;
    {% endfor %}
</pre></div>
<p>(A lot of code was removed - this is a very noisy template).</p>
<p>Doing it that way is <em>awesome</em>. Liquid/Rust is my Python/C. It lets me prototype
a ton of stuff really quickly, without recompiling anything, and it&#39;s absolutely
been fast enough for two years of going viral.</p>
<p>The Rust codebase has no idea what the structure of content should be, nor does
it care: all it knows is that there&#39;s <code>.md</code> assets, and those can be rendered
with <a href="https://lib.rs/crates/pulldown-cmark">pulldown-cmark</a>, and some custom
template markup processor, and <a href="https://lib.rs/crates/katex">KaTeX</a>, and, and -
those parts are built-in.</p>
<p>But series live entirely in the templates / SQL queries themselves: it&#39;s all
path matching (with regexps, which I add to sqlite as a Rust function).</p>
<p>So, at the time of the attack, the P95 (95th percentile latency) for my index
page was 168ms.</p>
<p>That&#39;s not <em>fast</em>: it&#39;s the ping between France and Brazil.</p>
<p>But it&#39;s also not slow: <a href="https://pagespeed.web.dev/report?url=https%3A%2F%2Ffasterthanli.me%2F&amp;form_factor=mobile">PageSpeed
Insights</a>
seems very happy about a First Contentful Paint (FCP) of 1 second. There&#39;s more
to the performance of a website than how long it takes to generate HTML, and I&#39;ve
spent a fair bit of effort taking care of everything else.</p>
<div>

<div>
<p>For example, I&#39;ve recently <a href="https://markoskon.com/creating-font-subsets/">created font
subsets</a> for Iosevka, which cut
down <em>several megabytes</em> per visit, even though the font assets were always
WOFF2.</p>
<p>Less recently, I&#39;ve added support for avif and webp for images, instead of
always serving png or jpg (depending on the kind of images).</p>
</div>
</div>
<p>And it was never a problem whenever one of my articles got popular, since the
P95 for any single article was more like 30ms (and only involved a couple of
very fast SQL queries, and no HTML rewriting/truncation whatsoever).</p>
<h2>Fixing my origin</h2>
<p>Adding <code>cache-control</code> headers was a bust...</p>

<p>...but I did make several other changes that should help next time, and I
thought it&#39;d be neat to show what they look like in code.</p>
<div>

<div>
<p>There&#39;s a whole bunch of Rust code there, if you want to skip it, search for
&#34;After the storm&#34;.</p>
<p>Yes, yes, I know, I should add anchor links for headers. </p>
</div>
</div>
<p>First, I added a limit to the maximum number of in-flight requests. My website
uses <a href="https://lib.rs/crates/warp">warp</a> as an HTTP framework (whereas my video
platform uses <a href="https://lib.rs/crates/axum">axum</a>), but they&#39;re both based on
<a href="https://lib.rs/crates/hyper">hyper</a>, which means I can use standard
<a href="https://lib.rs/crates/tower">tower</a> layers with it (think &#34;middleware&#34;).</p>
<p>Before in-flight requests limit:</p>
<div><p>Rust code</p><pre data-lang="rust">async <i>fn</i> <i>serve</i><i>(</i><i>)</i> {
    <i>// (omitted: everything else)</i>

    <i>let</i> addr: <i>SocketAddr</i> = config<i>.</i><i>address</i><i>.</i><i>parse</i><i>(</i><i>)</i>?<i>;</i>
    <i>// this turns a warp `Filter` into a tower `Service`</i>
    <i>let</i> svc = warp<i>::</i><i>service</i><i>(</i>all_routes<i>.</i><i>with</i><i>(</i>access_log<i>)</i><i>)</i><i>;</i>
    <i>let</i> make_svc = hyper<i>::</i>service<i>::</i><i>make_service_fn</i><i>(</i>|_: <i>_</i>| {
        <i>// this gets called whenever a new connection is accepted: it gets its</i>
        <i>// own clone of our HTTP service (this mostly increases reference counts)</i>
        async <i>move</i> { Ok<i>::</i><i>&lt;</i><i>_</i>, <i>Infallible</i><i>&gt;</i><i>(</i>svc<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i> }
    }<i>)</i><i>;</i>

    <i>let</i> server = hyper<i>::</i><i>Server</i><i>::</i><i>bind</i><i>(</i><i>&amp;</i>addr<i>)</i><i>.</i><i>serve</i><i>(</i>make_svc<i>)</i><i>;</i>
    server<i>.</i>await?<i>;</i>
}
</pre></div>
<p>After in-flight requests limit:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> tower<i>::</i>{limit<i>::</i>GlobalConcurrencyLimitLayer, ServiceBuilder}<i></i>

async <i>fn</i> <i>serve</i><i>(</i><i>)</i> {
    <i>// (omitted: everything else)</i>

    <i>let</i> addr: <i>SocketAddr</i> = config<i>.</i><i>address</i><i>.</i><i>parse</i><i>(</i><i>)</i>?<i>;</i>
    <i>let</i> svc = warp<i>::</i><i>service</i><i>(</i>all_routes<i>.</i><i>with</i><i>(</i>access_log<i>)</i><i>)</i><i>;</i>
    <i>let</i> limit = <i>GlobalConcurrencyLimitLayer</i><i>::</i><i>new</i><i>(</i><i>512</i><i>)</i><i>;</i>
    <i>let</i> make_svc = hyper<i>::</i>service<i>::</i><i>make_service_fn</i><i>(</i>|_: <i>_</i>| {
        <i>// This increases reference counts for `GlobalConcurrencyLimitLayer`&#39;s</i>
        <i>// internal semaphore: the limit is </i>
        <i>let</i> svc = <i>ServiceBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i><i>.</i><i>layer</i><i>(</i>limit<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>.</i><i>service</i><i>(</i>svc<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>;</i>
        async <i>move</i> { Ok<i>::</i><i>&lt;</i><i>_</i>, <i>Infallible</i><i>&gt;</i><i>(</i>svc<i>)</i> }
    }<i>)</i><i>;</i>
}
</pre></div>
<p>I deployed this between two attack waves, and it did not help at all.</p>
<p>It does exactly what it says on the tin, but during an attack, the abnormally
high volume means requests just keep piling up, taking up resources, and
utilization is still as high as... well, as it can go.</p>
<p>Adding a <a href="https://docs.rs/tower/latest/tower/builder/struct.ServiceBuilder.html#method.load_shed">load
shed</a>
layer would&#39;ve been smarter, I just didn&#39;t think of it at the time: it&#39;s one
more line of code, and now, if there&#39;s more than 512 requests in-flight, the others
just immediately error out.</p>
<p>Which <em>feels</em> like a bad thing at first, but once you&#39;ve determined the maximum
volume you can gracefully serve, that&#39;s what you want. Especially when there&#39;s
an edge between you and the user-agent (in this case, Cloudflare) that&#39;s capable
of backing off, retrying, etc.</p>
<p>The next thing I did was limit concurrent connections: I know Cloudflare has a
lot of <a href="https://en.wikipedia.org/wiki/Point_of_presence">PoPs</a>, but 350K
connections still feels excessive. </p>
<p>I&#39;ve covered this in <a href="https://www.evalapply.org/articles/request-coalescing-in-async-rust">Request coalescing in async
Rust</a> before, but who&#39;s got time for
that, here&#39;s some code:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>convert<i>::</i>Infallible<i>;</i>

<i>use</i> futures<i>::</i>future<i>::</i>{ready, Ready}<i>;</i>
<i>use</i> hyper<i>::</i>server<i>::</i>conn<i>::</i>AddrStream<i>;</i>
<i>use</i> tokio<i>::</i>sync<i>::</i>OwnedSemaphorePermit<i>;</i>
<i>use</i> tokio_util<i>::</i>sync<i>::</i>PollSemaphore<i>;</i>
<i>use</i> tower<i>::</i>Service<i>;</i>

<i>pub</i> <i>struct</i> <i>ServiceFactory</i><i>&lt;</i><i>S</i><i>&gt;</i> {
    <i>pub</i> <i>inner</i>: <i>S</i>,
    <i>pub</i> <i>semaphore</i>: <i>PollSemaphore</i>,
    <i>pub</i> <i>permit</i>: <i>Option</i><i>&lt;</i><i>OwnedSemaphorePermit</i><i>&gt;</i>,
}

<i>impl</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>&amp;</i><i>AddrStream</i><i>&gt;</i> <i>for</i> <i>ServiceFactory</i><i>&lt;</i><i>S</i><i>&gt;</i>
<i>where</i>
    <i>S</i>: <i>Clone</i>,
{
    <i>type</i> <i>Response</i> = <i>PermitService</i><i>&lt;</i><i>S</i><i>&gt;</i><i>;</i>
    <i>type</i> <i>Error</i> = <i>Infallible</i><i>;</i>
    <i>type</i> <i>Future</i> = <i>Ready</i><i>&lt;</i><i>Result</i><i>&lt;</i>Self<i>::</i><i>Response</i>, Self<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>poll_ready</i><i>(</i>
        <i>&amp;</i><i>mut</i> <i>self</i>,
        <i>cx</i>: <i>&amp;</i><i>mut</i> std<i>::</i>task<i>::</i><i>Context</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i>,
    <i>)</i> -&gt; std<i>::</i>task<i>::</i><i>Poll</i><i>&lt;</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i>, Self<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i> {
        <i>if</i> <i>self</i><i>.</i><i>permit</i><i>.</i><i>is_none</i><i>(</i><i>)</i> {
            <i>self</i><i>.</i><i>permit</i> = Some<i>(</i>futures<i>::</i>ready!<i>(</i><i>self</i>.semaphore.poll_acquire<i>(</i>cx<i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }
        Ok<i>(</i><i>(</i><i>)</i><i>)</i><i>.</i><i>into</i><i>(</i><i>)</i>
    }

    <i>fn</i> <i>call</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>_req</i>: <i>&amp;</i><i>AddrStream</i><i>)</i> -&gt; Self<i>::</i><i>Future</i> {
        <i>let</i> permit = <i>self</i><i>.</i><i>permit</i><i>.</i><i>take</i><i>(</i><i>)</i><i>.</i><i>expect</i><i>(</i>
            <i>&#34;you didn&#39;t drive me to readiness did you? you know that&#39;s a tower crime right?&#34;</i>,
        <i>)</i><i>;</i>
        <i>ready</i><i>(</i>Ok<i>(</i><i>PermitService</i> {
            <i>inner</i>: <i>self</i><i>.</i><i>inner</i><i>.</i><i>clone</i><i>(</i><i>)</i>,
            <i>_permit</i>: permit,
        }<i>)</i><i>)</i>
    }
}

<i>pub</i> <i>struct</i> <i>PermitService</i><i>&lt;</i><i>S</i><i>&gt;</i> {
    <i>pub</i> <i>inner</i>: <i>S</i>,
    <i>pub</i> <i>_permit</i>: <i>OwnedSemaphorePermit</i>,
}

<i>impl</i><i>&lt;</i><i>S</i>, <i>R</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>R</i><i>&gt;</i> <i>for</i> <i>PermitService</i><i>&lt;</i><i>S</i><i>&gt;</i>
<i>where</i>
    <i>S</i>: <i>Service</i><i>&lt;</i><i>R</i><i>&gt;</i>,
{
    <i>type</i> <i>Response</i> = S<i>::</i><i>Response</i><i>;</i>
    <i>type</i> <i>Error</i> = S<i>::</i><i>Error</i><i>;</i>
    <i>type</i> <i>Future</i> = S<i>::</i><i>Future</i><i>;</i>

    <i>fn</i> <i>poll_ready</i><i>(</i>
        <i>&amp;</i><i>mut</i> <i>self</i>,
        <i>cx</i>: <i>&amp;</i><i>mut</i> std<i>::</i>task<i>::</i><i>Context</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i>,
    <i>)</i> -&gt; std<i>::</i>task<i>::</i><i>Poll</i><i>&lt;</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i>, Self<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i> {
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>poll_ready</i><i>(</i>cx<i>)</i>
    }

    <i>fn</i> <i>call</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>req</i>: <i>R</i><i>)</i> -&gt; Self<i>::</i><i>Future</i> {
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>call</i><i>(</i>req<i>)</i>
    }
}
</pre></div>
<p>And it&#39;s used like this:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> conns_limit = <i>Semaphore</i><i>::</i><i>new</i><i>(</i><i>128</i><i>)</i><i>;</i>
    <i>let</i> svc = <i>ServiceBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>layer</i><i>(</i><i>GlobalConcurrencyLimitLayer</i><i>::</i><i>new</i><i>(</i><i>512</i><i>)</i><i>)</i>
        <i>.</i><i>service</i><i>(</i>warp<i>::</i><i>service</i><i>(</i>all_routes<i>.</i><i>with</i><i>(</i>access_log<i>)</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> factory = <i>ServiceFactory</i> {
        <i>inner</i>: svc,
        <i>semaphore</i>: <i>PollSemaphore</i><i>::</i><i>new</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>conns_limit<i>)</i><i>)</i>,
        <i>permit</i>: None,
    }<i>;</i>

    <i>let</i> server = hyper<i>::</i><i>Server</i><i>::</i><i>bind</i><i>(</i><i>&amp;</i>addr<i>)</i><i>.</i><i>serve</i><i>(</i>factory<i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;listening on {}&#34;</i>, addr<i>)</i><i>;</i>
    server<i>.</i>await?<i>;</i>
</pre></div>
<p>That one&#39;s <em>significantly more verbose</em>, but it&#39;s also very re-usable, that&#39;s
kind of <a href="https://lib.rs/crates/tower">tower</a>&#39;s deal. Which means it probably
exists in a crate somewhere and I&#39;m an idiot for rewriting it in every project.
Or I should just publish my own crate.</p>
<p>But the elegance here is that... it&#39;s a <code>Service</code> that takes an <code>&amp;AddrStream</code>
and returns a <code>Service</code>. That delicious meta bit can get confusing at times,
but it turns out to be super convenient.</p>
<p>Shortly after I deployed that change, things broke: the site appeared
unavailable again. The attack hadn&#39;t resumed yet though — the available 512
connection slots had simply filled up, were idle, and Cloudflare edge nodes
weren&#39;t able to establish any more connections.</p>
<p>My solution was to simply enforce idle read and write timeouts: any connection
that hasn&#39;t been read from or written to in a few seconds gets reset.</p>
<p>Because I brought in a custom &#34;acceptor&#34; for that, it was also a good occasion
to close another hole: my server was listening on <code>0.0.0.0:80</code>. If you could
guess the IP (which, there&#39;s entire sites dedicated to that), you could hammer
it <em>directly</em>, without proxying through Cloudflare.</p>
<div>

<p>That didn&#39;t happen, but it sure could have.</p>
</div>
<p>Instead, we want the origin to only accept connections from <a href="https://www.cloudflare.com/en-gb/ips/">Cloudflare IP
ranges</a>.</p>
<p>So, here&#39;s an acceptor that does both, <em>and</em> updates the IP ranges every now
and then:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>{
    collections<i>::</i>HashSet,
    io,
    net<i>::</i>{IpAddr, SocketAddr},
    pin<i>::</i>Pin,
    str<i>::</i>FromStr,
    sync<i>::</i>Arc,
    time<i>::</i>Duration,
}<i>;</i>

<i>use</i> arc_swap<i>::</i>ArcSwap<i>;</i>
<i>use</i> futures<i>::</i>TryFutureExt<i>;</i>
<i>use</i> hyper<i>::</i>server<i>::</i>accept<i>::</i>{from_stream, Accept}<i>;</i>
<i>use</i> ipnet<i>::</i>IpNet<i>;</i>
<i>use</i> tokio<i>::</i>net<i>::</i>TcpStream<i>;</i>
<i>use</i> tokio_io_timeout<i>::</i>{TimeoutReader, TimeoutWriter}<i>;</i>
<i>use</i> tracing<i>::</i>{debug, info, warn}<i>;</i>

<i>pub</i> <i>const</i> IPS_V4: <i>&amp;</i><i>str</i> = <i>include_str</i><i>!</i><i>(</i><i>&#34;ips-v4.txt&#34;</i><i>)</i><i>;</i>
<i>pub</i> <i>const</i> IPS_V6: <i>&amp;</i><i>str</i> = <i>include_str</i><i>!</i><i>(</i><i>&#34;ips-v6.txt&#34;</i><i>)</i><i>;</i>
<i>pub</i> <i>const</i> IPS_LOCAL: <i>&amp;</i><i>str</i> = <i>&#34;127.0.0.1/8&#34;</i><i>;</i>

<i>pub</i> <i>fn</i> <i>timeout_acceptor</i><i>(</i>
    <i>addr</i>: <i>SocketAddr</i>,
<i>)</i> -&gt; <i>impl</i> <i>Accept</i><i>&lt;</i><i>Conn</i> = <i>Pin</i><i>&lt;</i><i>Box</i><i>&lt;</i><i>TimeoutWriter</i><i>&lt;</i><i>TimeoutReader</i><i>&lt;</i><i>TcpStream</i><i>&gt;</i><i>&gt;</i><i>&gt;</i><i>&gt;</i>, <i>Error</i> = io<i>::</i><i>Error</i><i>&gt;</i> {
    <i>let</i> ip_nets = <i>parse_ip_nets</i><i>(</i><i>&amp;</i><i>[</i>IPS_V4, IPS_V6, IPS_LOCAL<i>]</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Loaded {} ip nets&#34;</i>, ip_nets.len<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> ip_nets = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>ArcSwap</i><i>::</i><i>from_pointee</i><i>(</i>ip_nets<i>)</i><i>)</i><i>;</i>

    tokio<i>::</i><i>spawn</i><i>(</i>{
        <i>let</i> ip_nets = ip_nets<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        async <i>move</i> {
            <i>loop</i> {
                <i>if</i> <i>let</i> Err<i>(</i>e<i>)</i> = <i>update_ip_nets</i><i>(</i><i>&amp;</i>ip_nets<i>)</i><i>.</i>await {
                    <i>warn</i><i>!</i><i>(</i><i>&#34;Could not update IP nets: {e}&#34;</i><i>)</i><i>;</i>
                }<i>;</i>
            }
        }
    }<i>)</i><i>;</i>

    <i>let</i> localhost = <i>IpAddr</i><i>::</i><i>from</i><i>(</i><i>[</i><i>127</i>, <i>0</i>, <i>0</i>, <i>1</i><i>]</i><i>)</i><i>;</i>

    <i>from_stream</i><i>(</i>
        async <i>move</i> {
            <i>let</i> ln = tokio<i>::</i>net<i>::</i><i>TcpListener</i><i>::</i><i>bind</i><i>(</i>addr<i>)</i><i>.</i>await?<i>;</i>
            <i>let</i> stream = async_stream<i>::</i>stream! {
                <i>loop</i> {
                    <i>let</i> <i>(</i>stream, addr<i>)</i> = ln.accept<i>(</i><i>)</i>.await?;

                    <i>if</i> <i>let</i> Some<i>(</i>net<i>)</i> = ip_nets.load<i>(</i><i>)</i>
                        .iter<i>(</i><i>)</i>
                        .find<i>(</i>|net| net.contains<i>(</i>&amp;addr.ip<i>(</i><i>)</i><i>)</i><i>)</i>
                    {
                        debug!<i>(</i><i>&#34;Allowing {} through net {net}&#34;</i>, addr.ip<i>(</i><i>)</i><i>)</i>;
                    } else {
                        debug!<i>(</i><i>&#34;Disallowing {}&#34;</i>, addr.ip<i>(</i><i>)</i><i>)</i>;
                        <i>continue</i>;
                    }

                    <i>let</i> should_timeout = addr.ip<i>(</i><i>)</i> != localhost;

                    <i>let</i> <i>mut</i> stream = TimeoutReader::new<i>(</i>stream<i>)</i>;
                    <i>if</i> should_timeout {
                        stream.set_timeout<i>(</i>Some<i>(</i>Duration::from_secs<i>(</i><i>5</i><i>)</i><i>)</i><i>)</i>;
                    }
                    <i>let</i> <i>mut</i> stream = TimeoutWriter::new<i>(</i>stream<i>)</i>;
                    <i>if</i> should_timeout {
                        stream.set_timeout<i>(</i>Some<i>(</i>Duration::from_secs<i>(</i><i>5</i><i>)</i><i>)</i><i>)</i>;
                    }
                    yield Ok<i>(</i>Box::pin<i>(</i>stream<i>)</i><i>)</i>
                }
            }<i>;</i>
            Ok<i>(</i>stream<i>)</i>
        }
        <i>.</i><i>try_flatten_stream</i><i>(</i><i>)</i>,
    <i>)</i>
}

<i>fn</i> <i>parse_ip_nets</i><i>(</i><i>sources</i>: <i>&amp;</i><i>[</i><i>&amp;</i><i>str</i><i>]</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>HashSet</i><i>&lt;</i><i>IpNet</i><i>&gt;</i><i>&gt;</i> {
    <i>let</i> <i>mut</i> set: <i>HashSet</i><i>&lt;</i><i>IpNet</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> input <i>in</i> sources {
        <i>for</i> line <i>in</i> input<i>.</i><i>lines</i><i>(</i><i>)</i> {
            <i>let</i> line = line<i>.</i><i>trim</i><i>(</i><i>)</i><i>;</i>
            <i>if</i> line<i>.</i><i>is_empty</i><i>(</i><i>)</i> || line<i>.</i><i>starts_with</i><i>(</i><i>&#39;#&#39;</i><i>)</i> {
                <i>continue</i><i>;</i>
            }
            <i>let</i> ip_net = <i>IpNet</i><i>::</i><i>from_str</i><i>(</i>line<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            set<i>.</i><i>insert</i><i>(</i>ip_net<i>)</i><i>;</i>
        }
    }
    Ok<i>(</i>set<i>)</i>
}

async <i>fn</i> <i>update_ip_nets</i><i>(</i><i>ip_nets_handle</i>: <i>&amp;</i><i>ArcSwap</i><i>&lt;</i><i>HashSet</i><i>&lt;</i><i>IpNet</i><i>&gt;</i><i>&gt;</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    <i>let</i> client = reqwest<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    tokio<i>::</i>time<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>15</i><i>)</i><i>)</i><i>.</i>await<i>;</i>

    <i>let</i> <i>mut</i> sources = <i>vec</i><i>!</i><i>[</i>IPS_LOCAL.to_string<i>(</i><i>)</i><i>]</i><i>;</i>
    <i>for</i> url <i>in</i> <i>[</i>
        <i>&#34;https://www.cloudflare.com/ips-v4&#34;</i>,
        <i>&#34;https://www.cloudflare.com/ips-v6&#34;</i>,
    <i>]</i> {
        sources<i>.</i><i>push</i><i>(</i>client<i>.</i><i>get</i><i>(</i>url<i>)</i><i>.</i><i>send</i><i>(</i><i>)</i><i>.</i>await?<i>.</i><i>text</i><i>(</i><i>)</i><i>.</i>await?<i>)</i><i>;</i>
    }
    <i>let</i> sources: <i>Vec</i><i>&lt;</i><i>_</i><i>&gt;</i> = sources<i>.</i><i>iter</i><i>(</i><i>)</i><i>.</i><i>map</i><i>(</i>|x| x<i>.</i><i>as_str</i><i>(</i><i>)</i><i>)</i><i>.</i><i>collect</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> ip_nets = <i>parse_ip_nets</i><i>(</i><i>&amp;</i>sources<i>[</i>..<i>]</i><i>)</i>?<i>;</i>
    <i>info</i><i>!</i><i>(</i>
        <i>&#34;Loaded {} ip nets (had {})&#34;</i>,
        ip_nets.len<i>(</i><i>)</i>,
        ip_nets_handle.load<i>(</i><i>)</i>.len<i>(</i><i>)</i>
    <i>)</i><i>;</i>
    ip_nets_handle<i>.</i><i>store</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>ip_nets<i>)</i><i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div>
<p>Featured here: <a href="https://lib.rs/crates/reqwest">reqwest</a> for easy async HTTP
requests, <a href="https://lib.rs/crates/arc-swap">arc-swap</a> to avoid using an
<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>,
<a href="https://lib.rs/crates/async-stream">async-stream</a> to be able to create
an async <code>Stream</code> using generator syntax (<code>yield</code> etc.).</p>
<p>It&#39;s pretty naive code, but I think it looks pretty neat.</p>
<div>

<div>
<p>A better way to only accept connection from Cloudflare IPs would be to set up
firewall rules (and update them periodically). Then any disallowed connection
could be simply refused (thus not taking space in the accept queue), or dropped
(thus wasting the attacker&#39;s time).</p>
<p>But hey, gotta leave stuff to do for later!</p>
</div>
</div>
<p>Also, using it is a breeze:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> acceptor = <i>timeout_acceptor</i><i>(</i>addr<i>)</i><i>;</i>
    <i>// instead of `Server::bind`:</i>
    <i>let</i> server = hyper<i>::</i><i>Server</i><i>::</i><i>builder</i><i>(</i>acceptor<i>)</i><i>.</i><i>serve</i><i>(</i>factory<i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;listening on {}&#34;</i>, addr<i>)</i><i>;</i>
    server<i>.</i>await?<i>;</i>
</pre></div>
<p>Because it doesn&#39;t return an <code>AddrStream</code> but instead a
<code>Pin&lt;Box&lt;TimeoutWriter&lt;TimeoutReader&lt;TcpStream&gt;&gt;&gt;&gt;</code>...</p>

<p>...it broke <code>ServiceFactory</code> with a <a href="https://twitter.com/fasterthanlime/status/1520449981685063682">gnarly error
message</a>, but
I&#39;ve been doing this long enough that I knew exactly to turn:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>&amp;</i><i>AddrStream</i><i>&gt;</i> <i>for</i> <i>ServiceFactory</i><i>&lt;</i><i>S</i><i>&gt;</i> {
    <i>// etc.</i>
}
</pre></div>
<p>Into:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i><i>&lt;</i><i>S</i>, <i>A</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>&amp;</i><i>A</i><i>&gt;</i> <i>for</i> <i>ServiceFactory</i><i>&lt;</i><i>S</i><i>&gt;</i> {
    <i>// etc.</i>
}
</pre></div>
<p>So that <code>ServiceFactory</code> works for <em>any</em> acceptor (it doesn&#39;t care what the
actual IO type is).</p>
<p>I added some user-agent banning on my side too (in case I ever move away from
Cloudflare), same tower boilerplate here:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>{collections<i>::</i>HashSet, sync<i>::</i>Arc}<i>;</i>

<i>use</i> futures<i>::</i>future<i>::</i>{ready, Either, Ready}<i>;</i>
<i>use</i> http<i>::</i>{Request, Response}<i>;</i>
<i>use</i> tower<i>::</i>{Layer, Service}<i>;</i>

<i>// Layer</i>
<i>pub</i> <i>struct</i> <i>BanUserAgents</i> {
    <i>banned</i>: <i>Arc</i><i>&lt;</i><i>HashSet</i><i>&lt;</i><i>String</i><i>&gt;</i><i>&gt;</i>,
}

<i>impl</i> <i>BanUserAgents</i> {
    <i>pub</i> <i>fn</i> <i>new</i><i>(</i><i>)</i> -&gt; <i>Self</i> {
        <i>let</i> <i>mut</i> banned = <i>HashSet</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
        banned<i>.</i><i>insert</i><i>(</i><i>&#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#34;</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>;</i>
        <i>Self</i> {
            <i>banned</i>: <i>Arc</i><i>::</i><i>new</i><i>(</i>banned<i>)</i>,
        }
    }
}

<i>impl</i> <i>Default</i> <i>for</i> <i>BanUserAgents</i> {
    <i>fn</i> <i>default</i><i>(</i><i>)</i> -&gt; <i>Self</i> {
        <i>Self</i><i>::</i><i>new</i><i>(</i><i>)</i>
    }
}

<i>impl</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>Layer</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>for</i> <i>BanUserAgents</i> {
    <i>type</i> <i>Service</i> = <i>BanUserAgentsService</i><i>&lt;</i><i>S</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>layer</i><i>(</i><i>&amp;</i><i>self</i>, <i>inner</i>: <i>S</i><i>)</i> -&gt; Self<i>::</i><i>Service</i> {
        <i>BanUserAgentsService</i> {
            inner,
            <i>banned</i>: <i>self</i><i>.</i><i>banned</i><i>.</i><i>clone</i><i>(</i><i>)</i>,
        }
    }
}

<i>#<i>[</i>derive<i>(</i>Clone<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>BanUserAgentsService</i><i>&lt;</i><i>S</i><i>&gt;</i> {
    <i>inner</i>: <i>S</i>,
    <i>banned</i>: <i>Arc</i><i>&lt;</i><i>HashSet</i><i>&lt;</i><i>String</i><i>&gt;</i><i>&gt;</i>,
}

<i>impl</i><i>&lt;</i><i>S</i>, <i>B</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>B</i><i>&gt;</i><i>&gt;</i> <i>for</i> <i>BanUserAgentsService</i><i>&lt;</i><i>S</i><i>&gt;</i>
<i>where</i>
    <i>S</i>: <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>B</i><i>&gt;</i>, <i>Response</i> = <i>Response</i><i>&lt;</i>hyper<i>::</i><i>Body</i><i>&gt;</i><i>&gt;</i>,
{
    <i>type</i> <i>Response</i> = S<i>::</i><i>Response</i><i>;</i>
    <i>type</i> <i>Error</i> = S<i>::</i><i>Error</i><i>;</i>
    <i>type</i> <i>Future</i> = <i>Either</i><i>&lt;</i>S<i>::</i><i>Future</i>, <i>Ready</i><i>&lt;</i><i>Result</i><i>&lt;</i>S<i>::</i><i>Response</i>, S<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>poll_ready</i><i>(</i>
        <i>&amp;</i><i>mut</i> <i>self</i>,
        <i>cx</i>: <i>&amp;</i><i>mut</i> std<i>::</i>task<i>::</i><i>Context</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i>,
    <i>)</i> -&gt; std<i>::</i>task<i>::</i><i>Poll</i><i>&lt;</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i>, Self<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i> {
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>poll_ready</i><i>(</i>cx<i>)</i>
    }

    <i>fn</i> <i>call</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>req</i>: <i>Request</i><i>&lt;</i><i>B</i><i>&gt;</i><i>)</i> -&gt; Self<i>::</i><i>Future</i> {
        <i>let</i> user_agent = req
            <i>.</i><i>headers</i><i>(</i><i>)</i>
            <i>.</i><i>get</i><i>(</i><i>&#34;user-agent&#34;</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|h| h<i>.</i><i>to_str</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> <i>self</i><i>.</i><i>banned</i><i>.</i><i>contains</i><i>(</i>user_agent<i>)</i> {
            <i>let</i> res = <i>Response</i><i>::</i><i>builder</i><i>(</i><i>)</i>
                <i>.</i><i>status</i><i>(</i><i>403</i><i>)</i>
                <i>.</i><i>body</i><i>(</i>hyper<i>::</i><i>Body</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>)</i>
                <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            <i>Either</i><i>::</i>Right<i>(</i><i>ready</i><i>(</i>Ok<i>(</i>res<i>)</i><i>)</i><i>)</i>
        } <i>else</i> {
            <i>Either</i><i>::</i>Left<i>(</i><i>self</i><i>.</i><i>inner</i><i>.</i><i>call</i><i>(</i>req<i>)</i><i>)</i>
        }
    }
}
</pre></div><div>

<p>There&#39;s no good reason to code up an entire tower layer by hand to do this, I
should&#39;ve used something like
<a href="https://docs.rs/tower/latest/tower/trait.ServiceExt.html#method.filter">ServiceExt::filter</a> and
it would&#39;ve been only a couple lines.</p>
</div>
<p>Next up, I configured <a href="https://sentry.io/">Sentry</a> and (after checking with them
that I&#39;d be okay if the attack resumed) <a href="https://www.honeycomb.io/">Honeycomb</a>
for the main site. I had both of these set up for the video platform, but never
needed to look too closely to the main site up until now.</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> config = <i>Config</i><i>::</i><i>read</i><i>(</i><i>&amp;</i>args<i>.</i><i>path</i><i>)</i>?<i>;</i>

    <i>// this reports panics</i>
    <i>let</i> _guard = sentry<i>::</i><i>init</i><i>(</i><i>(</i>
        SENTRY_DSN,
        sentry<i>::</i><i>ClientOptions</i> {
            <i>release</i>: sentry<i>::</i>release_name!<i>(</i><i>)</i>,
            <i>environment</i>: Some<i>(</i>config<i>.</i><i>env</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>,
            ..<i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i>
        },
    <i>)</i><i>)</i><i>;</i>

    <i>let</i> service_name = <i>&#34;futile&#34;</i><i>;</i>
    <i>// this allows tracking spans across services through known HTTP headers</i>
    opentelemetry<i>::</i>global<i>::</i><i>set_text_map_propagator</i><i>(</i><i>TraceContextPropagator</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>

    <i>// this&#39;ll error out locally unless I spin up an otlp-exporter. in</i>
    <i>// production, this points to an exporter I run myself, off-box.</i>
    <i>let</i> otlp_endpoint = config<i>.</i><i>otlp_endpoint</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;localhost:4317&#34;</i><i>)</i><i>;</i>
    <i>let</i> tracer = opentelemetry_otlp<i>::</i><i>new_pipeline</i><i>(</i><i>)</i>
        <i>.</i><i>tracing</i><i>(</i><i>)</i>
        <i>.</i><i>with_trace_config</i><i>(</i>
            opentelemetry<i>::</i>sdk<i>::</i>trace<i>::</i><i>config</i><i>(</i><i>)</i>
                <i>// all traces will have the same service name</i>
                <i>.</i><i>with_resource</i><i>(</i><i>Resource</i><i>::</i><i>new</i><i>(</i><i>vec</i><i>!</i><i>[</i>KeyValue::new<i>(</i>
                    opentelemetry_semantic_conventions::resource::SERVICE_NAME,
                    service_name,
                <i>)</i><i>]</i><i>)</i><i>)</i>
                <i>// send 10% of traces</i>
                <i>.</i><i>with_sampler</i><i>(</i><i>Sampler</i><i>::</i>TraceIdRatioBased<i>(</i><i>0.1</i><i>)</i><i>)</i>,
        <i>)</i>
        <i>.</i><i>with_exporter</i><i>(</i>
            <i>// use GRPC to talk to the exporter</i>
            opentelemetry_otlp<i>::</i><i>new_exporter</i><i>(</i><i>)</i>
                <i>.</i><i>tonic</i><i>(</i><i>)</i>
                <i>.</i><i>with_endpoint</i><i>(</i>otlp_endpoint<i>)</i>,
        <i>)</i>
        <i>// send all of that asynchronously, using tokio tasks</i>
        <i>.</i><i>install_batch</i><i>(</i>opentelemetry<i>::</i>runtime<i>::</i>Tokio<i>)</i>?<i>;</i>
    <i>info</i><i>!</i><i>(</i>%otlp_endpoint, <i>&#34;Setting up telemetry&#34;</i><i>)</i><i>;</i>

    <i>let</i> telemetry = tracing_opentelemetry<i>::</i><i>layer</i><i>(</i><i>)</i><i>.</i><i>with_tracer</i><i>(</i>tracer<i>)</i><i>;</i>

    <i>// filter printed-out log statements according to the RUST_LOG environment</i>
    <i>// variable, default to info</i>
    <i>let</i> rust_log_var = std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>unwrap_or_else</i><i>(</i>|_| <i>&#34;info&#34;</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> log_filter = <i>Targets</i><i>::</i><i>from_str</i><i>(</i><i>&amp;</i>rust_log_var<i>)</i>?<i>;</i>
    <i>// different filter for traces sent to honeycomb</i>
    <i>let</i> trace_filter = <i>Targets</i><i>::</i><i>from_str</i><i>(</i><i>&#34;futile=info&#34;</i><i>)</i>?<i>;</i>

    <i>Registry</i><i>::</i><i>default</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>
            tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i>
                <i>.</i><i>with_ansi</i><i>(</i><i>true</i><i>)</i>
                <i>.</i><i>with_filter</i><i>(</i>log_filter<i>)</i>,
        <i>)</i>
        <i>.</i><i>with</i><i>(</i>
            <i>ErrorLayer</i><i>::</i><i>default</i><i>(</i><i>)</i>
                <i>.</i><i>and_then</i><i>(</i>telemetry<i>)</i>
                <i>.</i><i>with_filter</i><i>(</i>trace_filter<i>)</i>,
        <i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>
</pre></div>
<p>And started instrumenting some functions with
<a href="https://lib.rs/crates/tracing">tracing</a>, one of my favorite things, since it&#39;s
so easy.</p>
<p>I re-used an <code>IncomingHttpSpanLayer</code> I had made for the video platform:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>//! Make an http span</i>

<i>// TODO: deduplicate with tube</i>

<i>use</i> std<i>::</i>{
    future<i>::</i>Future,
    pin<i>::</i>Pin,
    task<i>::</i>{Context, Poll},
}<i>;</i>

<i>use</i> http<i>::</i>{Request, Response}<i>;</i>
<i>use</i> hyper<i>::</i>Body<i>;</i>
<i>use</i> tower<i>::</i>{Layer, Service}<i>;</i>
<i>use</i> tower_request_id<i>::</i>RequestId<i>;</i>
<i>use</i> tracing<i>::</i>{field, info_span, instrument<i>::</i>Instrumented, Instrument, Span}<i>;</i>

<i>/// Layer for [IncomingHttpSpanService]</i>
<i>#<i>[</i>derive<i>(</i>Default<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>IncomingHttpSpanLayer</i> {}

<i>impl</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>Layer</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>for</i> <i>IncomingHttpSpanLayer</i>
<i>where</i>
    <i>S</i>: <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>&gt;</i> + <i>Clone</i> + <i>Send</i> + <i>&#39;</i><i>static</i>,
{
    <i>type</i> <i>Service</i> = <i>IncomingHttpSpanService</i><i>&lt;</i><i>S</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>layer</i><i>(</i><i>&amp;</i><i>self</i>, <i>inner</i>: <i>S</i><i>)</i> -&gt; Self<i>::</i><i>Service</i> {
        <i>IncomingHttpSpanService</i> { inner }
    }
}

<i>/// Extracts opentelemetry context from HTTP headers</i>
<i>#<i>[</i>derive<i>(</i>Clone<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>IncomingHttpSpanService</i><i>&lt;</i><i>S</i><i>&gt;</i>
<i>where</i>
    <i>S</i>: <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>&gt;</i> + <i>Clone</i> + <i>Send</i> + <i>&#39;</i><i>static</i>,
{
    <i>inner</i>: <i>S</i>,
}

<i>impl</i><i>&lt;</i><i>S</i>, <i>B</i><i>&gt;</i> <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>&gt;</i> <i>for</i> <i>IncomingHttpSpanService</i><i>&lt;</i><i>S</i><i>&gt;</i>
<i>where</i>
    <i>S</i>: <i>Service</i><i>&lt;</i><i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i>, <i>Response</i> = <i>Response</i><i>&lt;</i><i>B</i><i>&gt;</i><i>&gt;</i> + <i>Clone</i> + <i>Send</i> + <i>&#39;</i><i>static</i>,
{
    <i>type</i> <i>Response</i> = S<i>::</i><i>Response</i><i>;</i>
    <i>type</i> <i>Error</i> = S<i>::</i><i>Error</i><i>;</i>
    <i>type</i> <i>Future</i> = <i>PostFuture</i><i>&lt;</i><i>Instrumented</i><i>&lt;</i>S<i>::</i><i>Future</i><i>&gt;</i>, <i>B</i>, S<i>::</i><i>Error</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>poll_ready</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>cx</i>: <i>&amp;</i><i>mut</i> <i>Context</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i><i>)</i> -&gt; <i>Poll</i><i>&lt;</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i>, Self<i>::</i><i>Error</i><i>&gt;</i><i>&gt;</i> {
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>poll_ready</i><i>(</i>cx<i>)</i>
    }

    <i>fn</i> <i>call</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i>, <i>req</i>: <i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>)</i> -&gt; Self<i>::</i><i>Future</i> {
        <i>let</i> user_agent = req
            <i>.</i><i>headers</i><i>(</i><i>)</i>
            <i>.</i><i>get</i><i>(</i><i>&#34;user-agent&#34;</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|s| s<i>.</i><i>to_str</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>unwrap_or</i><i>(</i><i>&#34;&#34;</i><i>)</i><i>;</i>

        <i>let</i> host = req
            <i>.</i><i>headers</i><i>(</i><i>)</i>
            <i>.</i><i>get</i><i>(</i><i>&#34;host&#34;</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|s| s<i>.</i><i>to_str</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>unwrap_or</i><i>(</i><i>&#34;&#34;</i><i>)</i><i>;</i>

        <i>let</i> sec_ch_ua_mobile = req
            <i>.</i><i>headers</i><i>(</i><i>)</i>
            <i>.</i><i>get</i><i>(</i><i>&#34;sec-ch-ua-mobile&#34;</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|s| s<i>.</i><i>to_str</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>unwrap_or</i><i>(</i><i>&#34;&#34;</i><i>)</i><i>;</i>

        <i>let</i> sec_ch_ua_platform = req
            <i>.</i><i>headers</i><i>(</i><i>)</i>
            <i>.</i><i>get</i><i>(</i><i>&#34;sec-ch-ua-platform&#34;</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|s| s<i>.</i><i>to_str</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>unwrap_or</i><i>(</i><i>&#34;&#34;</i><i>)</i><i>;</i>

        <i>let</i> span = <i>info_span</i><i>!</i><i>(</i>
            <i>&#34;http request&#34;</i>,
            otel.name = %req.uri<i>(</i><i>)</i>.path<i>(</i><i>)</i>,
            otel.kind = <i>&#34;server&#34;</i>,
            http.method = %req.method<i>(</i><i>)</i>,
            http.url = %req.uri<i>(</i><i>)</i>,
            http.status_code = field::Empty,
            http.user_agent = &amp;user_agent,
            http.host = &amp;host,
            http.sec_ch_ua_mobile = &amp;sec_ch_ua_mobile,
            http.sec_ch_ua_platform = &amp;sec_ch_ua_platform,
            request_id = field::Empty,
            user_id = field::Empty,
        <i>)</i><i>;</i>

        <i>if</i> <i>let</i> Some<i>(</i>id<i>)</i> = req<i>.</i><i>extensions</i><i>(</i><i>)</i><i>.</i><i>get</i><i>::</i><i>&lt;</i><i>RequestId</i><i>&gt;</i><i>(</i><i>)</i> {
            span<i>.</i><i>record</i><i>(</i><i>&#34;request_id&#34;</i>, <i>&amp;</i>id<i>.</i><i>to_string</i><i>(</i><i>)</i><i>.</i><i>as_str</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }

        <i>let</i> fut = {
            <i>let</i> _guard = span<i>.</i><i>enter</i><i>(</i><i>)</i><i>;</i>
            <i>self</i><i>.</i><i>inner</i><i>.</i><i>call</i><i>(</i>req<i>)</i>
        }<i>;</i>
        <i>PostFuture</i> {
            <i>inner</i>: fut<i>.</i><i>instrument</i><i>(</i>span<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i>,
            span,
        }
    }
}

pin_project_lite<i>::</i>pin_project! {
    <i>/// Future that records http status code</i>
    <i>pub</i> <i>struct</i> PostFuture&lt;F, B, E&gt;
    <i>where</i>
        F: Future&lt;Output = Result&lt;Response&lt;B&gt;, E&gt;&gt;,
    {
        #<i>[</i>pin<i>]</i>
        inner: F,
        span: Span,
    }
}

<i>impl</i><i>&lt;</i><i>F</i>, <i>B</i>, <i>E</i><i>&gt;</i> <i>Future</i> <i>for</i> <i>PostFuture</i><i>&lt;</i><i>F</i>, <i>B</i>, <i>E</i><i>&gt;</i>
<i>where</i>
    <i>F</i>: <i>Future</i><i>&lt;</i><i>Output</i> = <i>Result</i><i>&lt;</i><i>Response</i><i>&lt;</i><i>B</i><i>&gt;</i>, <i>E</i><i>&gt;</i><i>&gt;</i>,
{
    <i>type</i> <i>Output</i> = F<i>::</i><i>Output</i><i>;</i>

    <i>fn</i> <i>poll</i><i>(</i><i>self</i>: <i>Pin</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>Self</i><i>&gt;</i>, <i>cx</i>: <i>&amp;</i><i>mut</i> <i>Context</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i><i>)</i> -&gt; <i>Poll</i><i>&lt;</i>Self<i>::</i><i>Output</i><i>&gt;</i> {
        <i>let</i> this = <i>self</i><i>.</i><i>project</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> res = futures<i>::</i>ready!<i>(</i>this.inner.poll<i>(</i>cx<i>)</i><i>)</i><i>;</i>
        <i>if</i> <i>let</i> Ok<i>(</i>res<i>)</i> = <i>&amp;</i>res {
            this<i>.</i><i>span</i><i>.</i><i>record</i><i>(</i><i>&#34;http.status_code&#34;</i>, <i>&amp;</i>res<i>.</i><i>status</i><i>(</i><i>)</i><i>.</i><i>as_u16</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }
        res<i>.</i><i>into</i><i>(</i><i>)</i>
    }
}
</pre></div>
<p>...so that all HTTP requests have their own info-level span, and show up in
Honeycomb like so:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-routes.cb93cff4cea94877.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-routes.3826a4e258ed67ee.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-routes.660af33705ef8ac3.jpg" title="" alt=""/>
            </picture>
            <div>

<p>Hey, those latencies don&#39;t line up with the figures you mentioned earlier.</p>
</div>
<div>

<p>Haha, one thing at a time.</p>
</div>
<p>That lets me answer questions like &#34;what RSS readers (that aren&#39;t browsers) is
my audience using?&#34;</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-rss.8fedce30558f657d.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-rss.4203dc2b76c7aa1a.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-rss.3a1015bc4c26e4a6.jpg" title="honeycomb screenshot showing routes being requested in the last 30 minutes: 68 requests for index.sml, P99 is 0.29ms. there&#39;s requests for the index, and a few articles. the P50 for everything is half a millisecond maximum" alt="honeycomb screenshot showing routes being requested in the last 30 minutes: 68 requests for index.sml, P99 is 0.29ms. there&#39;s requests for the index, and a few articles. the P50 for everything is half a millisecond maximum"/>
            </picture>
            
<p>I&#39;m not sure what to do with that particular answer, but hey, now we know.</p>
<p>Edit: by popular demand, here&#39;s the list <em>including</em> user-agents that contain
&#34;Mozilla/5.0&#34;:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-rss2.63a9a256ced96b99.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-rss2.da4a745e069269da.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-rss2.595b45fd3a74543f.jpg" title="honeycomb screenshot showing just top user agents: there&#39;s now Firefox 99, miniflux.app, Safari, Explorer (not internet explorer), etc." alt="honeycomb screenshot showing just top user agents: there&#39;s now Firefox 99, miniflux.app, Safari, Explorer (not internet explorer), etc."/>
            </picture>
            
<p>Also incredibly valuable, because <em>spans</em> are being sent instead of simple log
messages, we get these nice visualizations of where we&#39;re actually spending time.</p>
<p>This is for a request to the index:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-trace.8fd86c6ca7ebf1d8.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-trace.dfa0666b7058ad7b.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-trace.bd43a07ba21294a9.jpg" title="honeycomb screenshot showing where time is spent: serve_template calls liquid.render, which calls sql a bunch of times, along with page_markup and truncate_html" alt="honeycomb screenshot showing where time is spent: serve_template calls liquid.render, which calls sql a bunch of times, along with page_markup and truncate_html"/>
            </picture>
            
<p>As I explained earlier, there&#39;s a few DB queries involved, it&#39;s fetching page
markup (which is pre-rendered, but also needs a DB query), and then it
truncates, which takes... <em>forever</em>.</p>
<p>So, immediately, I jump back to the code and find a ton of actionable
information there: for example, the size of my &#34;connection pool&#34; is only 10
<a href="https://lib.rs/crates/r2d2_sqlite">r2d2-sqlite</a>&#39;s default: under load, that&#39;s
not enough.</p>
<p>How do I know? I can see it waiting for a checkout:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-trace-expanded.4eafab02fc48fb2f.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/honeycomb-trace-expanded.58d7b783b6900267.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/honeycomb-trace-expanded.e8b2eafafa1dd766.jpg" title="" alt=""/>
            </picture>
            
<p>And this is all it took:</p>
<div><p>Rust code</p><pre data-lang="rust">            <i>let</i> conn = <i>info_span</i><i>!</i><i>(</i><i>&#34;sql.checkout&#34;</i><i>)</i><i>.</i><i>in_scope</i><i>(</i>|| <i>self</i><i>.</i><i>content_pool</i><i>.</i><i>get</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
</pre></div>
<p>I also noticed a couple other things, like:</p>
<ul>
<li>I&#39;m running blocking code (SQLite queries) in an async context. I should
be using <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html">spawn_blocking</a> for that. (There&#39;s no good lint for that)</li>
<li>I&#39;m not caching prepared statements. This doesn&#39;t show up as a hotspot, but
switching from <code>prepare</code> to <a href="https://docs.rs/rusqlite/latest/rusqlite/struct.Connection.html#method.prepare_cached">prepare_cached</a> is trivial, so why not?</li>
<li>I don&#39;t have any indexes in my SQLite database! What a great freebie I kept for myself.</li>
</ul>
<p>And finally, I&#39;m spending <em>way more time</em> on <code>truncate_html</code> than I thought.</p>
<p>It is non-trivial:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i> <i>Filter</i> <i>for</i> <i>TruncateHtmlFilter</i> {
    <i>#<i>[</i>instrument<i>(</i>name = <i>&#34;truncate_html&#34;</i>, skip<i>(</i><i>self</i>, input, runtime<i>)</i>, fields<i>(</i>html_len<i>)</i><i>)</i><i>]</i></i>
    <i>fn</i> <i>evaluate</i><i>(</i>
        <i>&amp;</i><i>self</i>,
        <i>input</i>: <i>&amp;</i><i>dyn</i> <i>ValueView</i>,
        <i>runtime</i>: <i>&amp;</i><i>dyn</i> liquid_core<i>::</i><i>Runtime</i>,
    <i>)</i> -&gt; liquid_core<i>::</i><i>Result</i><i>&lt;</i>liquid_core<i>::</i><i>Value</i><i>&gt;</i> {
        <i>let</i> span = <i>Span</i><i>::</i><i>current</i><i>(</i><i>)</i><i>;</i>

        <i>convert_errors</i><i>(</i>|| {
            <i>let</i> kinput = input<i>.</i><i>to_kstr</i><i>(</i><i>)</i><i>;</i>
            <i>let</i> input = kinput<i>.</i><i>as_str</i><i>(</i><i>)</i><i>;</i>
            span<i>.</i><i>record</i><i>(</i><i>&#34;html_len&#34;</i>, <i>&amp;</i>input<i>.</i><i>len</i><i>(</i><i>)</i><i>)</i><i>;</i>

            <i>let</i> <i>mut</i> output: <i>Vec</i><i>&lt;</i><i>u8</i><i>&gt;</i> = <i>Vec</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
            <i>let</i> output_sink = |<i>c</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i>| {
                output<i>.</i><i>write_all</i><i>(</i>c<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            }<i>;</i>

            <i>let</i> max: <i>u64</i> = <i>self</i>
                <i>.</i><i>args</i>
                <i>.</i><i>max</i>
                <i>.</i><i>as_ref</i><i>(</i><i>)</i>
                <i>.</i><i>and_then</i><i>(</i>|p| p<i>.</i><i>try_evaluate</i><i>(</i>runtime<i>)</i><i>)</i>
                <i>.</i><i>and_then</i><i>(</i>|l| l<i>.</i><i>as_scalar</i><i>(</i><i>)</i><i>.</i><i>and_then</i><i>(</i>|s| s<i>.</i><i>to_integer</i><i>(</i><i>)</i><i>.</i><i>map</i><i>(</i>|x| x <i>as</i> <i>u64</i><i>)</i><i>)</i><i>)</i>
                <i>.</i><i>unwrap_or</i><i>(</i><i>180</i><i>)</i><i>;</i>

            <i>let</i> char_count = <i>AtomicU64</i><i>::</i><i>new</i><i>(</i><i>0</i><i>)</i><i>;</i>
            <i>let</i> <i>mut</i> skip: <i>bool</i> = <i>false</i><i>;</i>

            <i>let</i> <i>mut</i> rewriter = <i>HtmlRewriter</i><i>::</i><i>new</i><i>(</i>
                <i>Settings</i> {
                    <i>element_content_handlers</i>: <i>vec</i><i>!</i><i>[</i>
                        element!<i>(</i><i>&#34;*&#34;</i>, |el| {
                            <i>if</i> char_count.load<i>(</i>Ordering::SeqCst<i>)</i> &gt; max &amp;&amp; el.tag_name<i>(</i><i>)</i> == <i>&#34;p&#34;</i> {
                                skip = <i>true</i>;
                            }

                            <i>if</i> skip {
                                el.remove<i>(</i><i>)</i>;
                            }
                            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
                        }<i>)</i>,
                        text!<i>(</i><i>&#34;*&#34;</i>, |txt| {
                            <i>if</i> matches!<i>(</i>txt.text_type<i>(</i><i>)</i>, TextType::Data<i>)</i> {
                                char_count.fetch_add<i>(</i>txt.as_str<i>(</i><i>)</i>.len<i>(</i><i>)</i> <i>as</i> <i>u64</i>, Ordering::SeqCst<i>)</i>;
                            }

                            Ok<i>(</i><i>(</i><i>)</i><i>)</i>
                        }<i>)</i>,
                    <i>]</i>,
                    ..<i>Settings</i><i>::</i><i>default</i><i>(</i><i>)</i>
                },
                output_sink,
            <i>)</i><i>;</i>

            rewriter
                <i>.</i><i>write</i><i>(</i>input<i>.</i><i>as_bytes</i><i>(</i><i>)</i><i>)</i>
                <i>.</i><i>map_err</i><i>(</i>|e| liquid_core<i>::</i><i>Error</i><i>::</i><i>with_msg</i><i>(</i><i>format</i><i>!</i><i>(</i><i>&#34;rewriting error: {:?}&#34;</i>, e<i>)</i><i>)</i><i>)</i>?<i>;</i>
            <i>drop</i><i>(</i>rewriter<i>)</i><i>;</i>

            Ok<i>(</i><i>to_value</i><i>(</i><i>&amp;</i>std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i>output<i>[</i>..<i>]</i><i>)</i>?<i>)</i>?<i>)</i>
        }<i>)</i>
    }
}
</pre></div>
<p>...but also, it feeds <em>the whole article</em> through, well past the initial 120
characters of text it&#39;s trying to keep. That&#39;s wasteful, <em>and</em> it&#39;s a very
predictable transform that could be cached, just like I cache rendered markdown.</p>
<p>So what I did next...</p>
<div>

<p>You fixed all of these, right?</p>
</div>
<p>Absolutely not! I <em>ignored</em> all of these, and jumped straight to implementing
caching.</p>
<p>Latency was always &#34;fine&#34; when the site wasn&#39;t under attack. Knowing about these
bothers me, but they can wait. What I really needed was some form of whole-page
caching.</p>
<p>I&#39;ve put that off for so long, and it was <em>so easy</em>.</p>
<p>I simply plugged in <a href="https://lib.rs/crates/moka">moka</a>, a &#34;fast, concurrent
cache library for Rust&#34;, that supports async, and time-based expiry.</p>
<p>So, boom, build a cache:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> server_state = <i>ServerState</i> {
        <i>config</i>: <i>Arc</i><i>::</i><i>clone</i><i>(</i><i>&amp;</i>config<i>)</i>,
        revholder,
        content_pool,
        users_pool,
        broadcast_rev,
        <i>// this is the only new field</i>
        <i>rendered_templates_cache</i>: <i>Cache</i><i>::</i><i>builder</i><i>(</i><i>)</i>
            <i>// TTL: 5 minutes</i>
            <i>.</i><i>time_to_live</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>5</i> <i>*</i> <i>60</i><i>)</i><i>)</i>
            <i>// TTI: 1 minute</i>
            <i>.</i><i>time_to_idle</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>60</i><i>)</i><i>)</i>
            <i>.</i><i>build</i><i>(</i><i>)</i>,
    }<i>;</i>
</pre></div>
<p>And the <code>serve_template</code> function becomes:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>#<i>[</i>instrument<i>(</i>skip<i>(</i><i>self</i>, globals<i>)</i>, fields<i>(</i>cache<i>.</i>status<i>)</i><i>)</i><i>]</i></i>
    async <i>fn</i> <i>serve_template</i><i>(</i>
        <i>self</i>,
        <i>template_name</i>: <i>&amp;</i><i>str</i>,
        <i>mut</i> <i>globals</i>: <i>Object</i>,
        <i>content_type</i>: <i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i>,
    <i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Box</i><i>&lt;</i><i>dyn</i> <i>Reply</i> + <i>&#39;</i><i>static</i><i>&gt;</i>, <i>Report</i><i>&gt;</i> {
        <i>let</i> span = <i>Span</i><i>::</i><i>current</i><i>(</i><i>)</i><i>;</i>

        <i>let</i> cache_key = <i>format</i><i>!</i><i>(</i><i>&#34;{}?{}&#34;</i>, <i>self</i>.path, <i>self</i>.raw_query.as_str<i>(</i><i>)</i><i>)</i><i>;</i>

        <i>let</i> <i>(</i>creds, session_cookies<i>)</i> =
            <i>FutileCredentials</i><i>::</i><i>load_from_cookies</i><i>(</i><i>self</i><i>.</i><i>config</i><i>(</i><i>)</i>, <i>&amp;</i><i>self</i><i>.</i><i>cookies</i><i>)</i><i>.</i>await<i>;</i>
        <i>let</i> has_creds = creds<i>.</i><i>is_some</i><i>(</i><i>)</i><i>;</i>

        <i>let</i> cache_control = <i>if</i> has_creds {
            <i>&#34;no-cache&#34;</i>
        } <i>else</i> {
            <i>&#34;private, max-age=120&#34;</i>
        }<i>;</i>

        <i>let</i> <i>mut</i> body: <i>Option</i><i>&lt;</i><i>Bytes</i><i>&gt;</i> = None<i>;</i>
        <i>let</i> should_cache = <i>self</i><i>.</i><i>state</i><i>.</i><i>config</i><i>.</i><i>env</i><i>.</i><i>is_prod</i><i>(</i><i>)</i> &amp;&amp; !has_creds<i>;</i>
        <i>if</i> should_cache {
            <i>// try to hit the cache first</i>
            <i>if</i> <i>let</i> Some<i>(</i>cached_body<i>)</i> = <i>self</i><i>.</i><i>state</i><i>.</i><i>rendered_templates_cache</i><i>.</i><i>get</i><i>(</i><i>&amp;</i>cache_key<i>)</i> {
                body = Some<i>(</i>cached_body<i>)</i><i>;</i>
                span<i>.</i><i>record</i><i>(</i><i>&#34;source&#34;</i>, <i>&amp;</i><i>&#34;hit&#34;</i><i>)</i><i>;</i>
            } <i>else</i> {
                span<i>.</i><i>record</i><i>(</i><i>&#34;source&#34;</i>, <i>&amp;</i><i>&#34;miss&#34;</i><i>)</i><i>;</i>
            }
        } <i>else</i> {
            span<i>.</i><i>record</i><i>(</i><i>&#34;cache.status&#34;</i>, <i>&amp;</i><i>&#34;dynamic&#34;</i><i>)</i><i>;</i>
        }

        <i>let</i> body = <i>if</i> <i>let</i> Some<i>(</i>body<i>)</i> = body {
            body
        } <i>else</i> {
            <i>let</i> rev = <i>self</i><i>.</i><i>state</i><i>.</i><i>revholder</i><i>.</i><i>get</i><i>(</i><i>)</i><i>;</i>
            <i>let</i> template = rev
                <i>.</i><i>template_repo</i>
                <i>.</i><i>templates</i>
                <i>.</i><i>get</i><i>(</i>template_name<i>)</i>
                <i>.</i><i>ok_or_else</i><i>(</i>|| <i>Error</i><i>::</i>TemplateNotFound<i>(</i>template_name<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i>?<i>;</i>

            <i>// omitted: insert a ton of &#34;globals&#34; my templates expect, stuff</i>
            <i>// like url params, the config (minus secrets), a friend URL, user</i>
            <i>// info (if logged in), user settings (ligatures enabled, theme),</i>
            <i>// etc.</i>

            <i>let</i> rendered = {
                <i>let</i> render_span = <i>info_span</i><i>!</i><i>(</i><i>&#34;liquid.render&#34;</i><i>)</i><i>;</i>
                <i>let</i> _guard = render_span<i>.</i><i>enter</i><i>(</i><i>)</i><i>;</i>
                template
                    <i>.</i><i>render</i><i>(</i><i>&amp;</i>globals<i>)</i>
                    <i>.</i><i>map_err</i><i>(</i>|e| e<i>.</i><i>context</i><i>(</i><i>&#34;template&#34;</i>, template_name<i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>)</i>?
            }<i>;</i>
            <i>// oh yeah, I forgot: I have live-reload on my website. Adding an</i>
            <i>// idle timeout on all connections broke it, so I just disabled it</i>
            <i>// for the development environment.</i>
            <i>let</i> rendered = <i>inject_livereload</i><i>(</i><i>&amp;</i><i>self</i><i>.</i><i>state</i><i>.</i><i>config</i>, <i>&amp;</i>rendered<i>)</i><i>;</i>

            <i>let</i> body = <i>Bytes</i><i>::</i><i>copy_from_slice</i><i>(</i>rendered<i>.</i><i>as_ref</i><i>(</i><i>)</i><i>.</i><i>as_bytes</i><i>(</i><i>)</i><i>)</i><i>;</i>
            <i>// an earlier version of this article (and my site) inserted pages</i>
            <i>// rendered _with credentials_ into the cache. woops!</i>
            <i>if</i> should_cache {
                <i>self</i><i>.</i><i>state</i>
                    <i>.</i><i>rendered_templates_cache</i>
                    <i>.</i><i>insert</i><i>(</i>cache_key, body<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i>
                    <i>.</i>await<i>;</i>
            }

            body
        }<i>;</i>

        <i>let</i> res = <i>Response</i><i>::</i><i>builder</i><i>(</i><i>)</i>
            <i>.</i><i>status</i><i>(</i><i>StatusCode</i><i>::</i>OK<i>)</i>
            <i>.</i><i>header</i><i>(</i><i>&#34;cache-control&#34;</i>, cache_control<i>)</i>
            <i>.</i><i>header</i><i>(</i><i>&#34;content-type&#34;</i>, content_type<i>)</i>
            <i>.</i><i>apply_session_cookies</i><i>(</i>session_cookies<i>)</i>
            <i>.</i><i>body</i><i>(</i>body<i>)</i><i>;</i>
        <i>let</i> res: <i>Box</i><i>&lt;</i><i>dyn</i> <i>Reply</i> + <i>&#39;</i><i>static</i><i>&gt;</i> = <i>Box</i><i>::</i><i>new</i><i>(</i>res<i>)</i><i>;</i>
        Ok<i>(</i>res<i>)</i>
    }
</pre></div>
<p>Cloning a <a href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html">Bytes</a>, which
happens on cache hit, simply increments a reference count, so everything is nice
and cheap.</p>
<div>

<p>The <code>cache-control</code> header here is technically wrong, since I don&#39;t actually
ever want Cloudflare to cache hit, but since it already doesn&#39;t... I&#39;ll fix it
later.</p>
</div>
<p>With that little change (it rendered unconditionally beforehand), all pages for
logged-out users are cached for 1m-5m, depending on whether they&#39;re being
requested a lot.</p>
<p>And that makes the difference between this:</p>
<div><p>Shell session</p><pre data-lang="shell">$ oha -z 5s http://localhost -H &#39;(valid cookies omitted)&#39;
Summary:
  Success rate: 1.0000
  Total:        5.0011 secs
  Slowest:      1.0898 secs
  Fastest:      0.0791 secs
  Average:      0.5314 secs
  Requests/sec: 87.9810

  Total data:   14.61 MiB
  Size/request: 34.00 KiB
  Size/sec:     2.92 MiB

Response time histogram:
  0.171 [20] |■■■■■■■
  0.263 [18] |■■■■■■
  0.355 [48] |■■■■■■■■■■■■■■■■■
  0.447 [50] |■■■■■■■■■■■■■■■■■
  0.539 [89] |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  0.630 [82] |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  0.722 [63] |■■■■■■■■■■■■■■■■■■■■■■
  0.814 [37] |■■■■■■■■■■■■■
  0.906 [21] |■■■■■■■
  0.998 [7]  |■■
  1.090 [5]  |■

Latency distribution:
  10% in 0.2837 secs
  25% in 0.3926 secs
  50% in 0.5350 secs
  75% in 0.6570 secs
  90% in 0.7618 secs
  95% in 0.8596 secs
  99% in 0.9995 secs

Details (average, fastest, slowest):
  DNS+dialup:   0.0006 secs, 0.0001 secs, 0.0011 secs
  DNS-lookup:   0.0000 secs, 0.0000 secs, 0.0000 secs

Status code distribution:
  [200] 440 responses
</pre></div>
<p>(87 requests per second, painfully — P95 of 860ms)</p>
<p>And this:</p>
<div><p>Shell session</p><pre data-lang="shell">$ oha -z 5s http://localhost
Summary:
  Success rate: 1.0000
  Total:        5.0017 secs
  Slowest:      0.0077 secs
  Fastest:      0.0002 secs
  Average:      0.0015 secs
  Requests/sec: 34073.2242

  Total data:   5.53 GiB
  Size/request: 34.00 KiB
  Size/sec:     1.10 GiB

Response time histogram:
  0.001 [7190]  |■■■■
  0.001 [22000] |■■■■■■■■■■■■■■■
  0.001 [40329] |■■■■■■■■■■■■■■■■■■■■■■■■■■■
  0.002 [46719] |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  0.002 [32402] |■■■■■■■■■■■■■■■■■■■■■■
  0.002 [14861] |■■■■■■■■■■
  0.003 [4874]  |■■■
  0.003 [1364]  |
  0.004 [450]   |
  0.004 [130]   |
  0.004 [106]   |

Latency distribution:
  10% in 0.0008 secs
  25% in 0.0011 secs
  50% in 0.0014 secs
  75% in 0.0018 secs
  90% in 0.0022 secs
  95% in 0.0024 secs
  99% in 0.0029 secs

Details (average, fastest, slowest):
  DNS+dialup:   0.0008 secs, 0.0001 secs, 0.0025 secs
  DNS-lookup:   0.0000 secs, 0.0000 secs, 0.0003 secs

Status code distribution:
  [200] 170425 responses
</pre></div>
<p>(34K requests per second, easily — P95 of 2.4ms)</p>
<p>It&#39;s important to note that this code <em>correctly identifies</em> valid session
cookies. These are signed, so if you want to hammer an uncached endpoint, you
now need to either:</p>
<ul>
<li>Somehow reverse how cookies are signed + find the secret key (which is super
easy to swap, it&#39;ll just log out everyone once. No biggie)</li>
<li>Become a subscriber so you get a legitimate cookie (which will show up in
traces, easy to block)</li>
</ul>

<p>Which leaves cached endpoints as durable attack targets: but because the maximum
RPS (for the costliest page on the site) went from ~90 to 34K (a 37677%
increase, for those keeping track), an attack would need to be <em>above</em>
Cloudflare&#39;s threshold to even make a dent, at which point their DDoS protection
would kick in.</p>
<p>As for the video platform: I made no changes. None. It already had good
observability, and I had planned for this eventuality from the start: the <em>only</em>
thing I was trying to prevent wasn&#39;t downtime, it was a huge AWS bill. And I&#39;m
happy to report that 100% of the requests that were served, were served from the
SSD cache.</p>
<p>Also, most requests <em>were</em> served, since there&#39;s eight separate instances of the
video app in eight different regions (Paris, Tokyo, Washington, São Paulo, etc.)</p>
<h2>After the storm: collateral damage</h2>
<p>Another secondary objective of a DDoS is to generate collateral damage: to force
the target to block legitimate traffic in response to the attack, losing out on
potential business and/or generally annoying people.</p>
<p>Blocking an entire AS is often excessive (but oh-so-convenient), blocking Tor
exit nodes is very tempting, and sometimes you just don&#39;t want to hear from a
certain country in a while. But these are all overshoots.</p>
<p>Ever since the attack, I&#39;ve gotten messages from regular readers who could&#39;t
access my website, because they happened to be running the latest Google Chrome
on Linux.</p>
<p>I tried everything: attack mode has been disabled for a while, I&#39;ve started
allowlisting the IPs of my readers, forcing a &#34;managed challenge&#34; for that
user-agent (hoping it&#39;ll override the automated block), but nothing seemed to be
doing the trick, except for switching to another browser.</p>
<p>Eventually, I realized Cloudflare had nothing to do with it. During the attack,
I had started banning that same user-agent (returning a 403) from my origin
directly, and I just... forgot to disable that after the attack was over.</p>
<div>

<div>
<p>The confusing bit was that readers were seeing a Cloudflare error page saying
&#34;Sorry, you have been blocked&#34;.</p>
<p>And even after I removed <em>my</em> counter-measure, they&#39;re still seeing it. Living
behind someone else&#39;s edge is a mixed blessing.</p>
</div>
</div>
<p>This is also partly the point: you&#39;re running left and right trying to make
things better, you get sloppy. That&#39;s how it&#39;s supposed to work.</p>
<p>Anyway.</p>
<p>Performing a DDoS is <em>technically</em> an &#34;illegal cybercrime&#34;, but realistically,
receiving one is just another Saturday.</p>
<p>Until next time, take excellent care of yourselves!</p>
<h2>Update: hi again!</h2>
<p>Minutes after I posted this article, the attack resumed. Same shit, different
AS. Here are the newcomers:</p>
<ul>
<li>AS45102: <a href="https://en.wikipedia.org/wiki/Alibaba_Group">Alibaba US</a> (Global, cloud provider)</li>
<li>AS16276: <a href="https://www.ovhcloud.com/fr/">OVH</a> (France, cloud provider)</li>
<li>AS141677: <a href="https://nathosts.com">Nathosts Limited</a> (Hong Kong)</li>
<li>AS8075: <a href="https://azure.microsoft.com/en-us/">Microsoft Azure</a> (US/HK/Brazil, cloud provider)</li>
<li>AS328386: Adnexus (South Africa)</li>
<li>AS7303: Telecom Argentina</li>
<li>AS24940: <a href="https://www.hetzner.com/">Hetzner</a> (Germany, cloud provider)</li>
<li>AS45758: Triple T Broadband (Thailand, ISP)</li>
<li>AS37963: <a href="https://en.wikipedia.org/wiki/Alibaba_Group">Alibaba Hangzhou</a> (Global, cloud provider)</li>
<li>AS63949: <a href="https://www.linode.com/">Linode</a> (US, VPS provider)</li>
</ul>
<p>At first, the site immediately went down, returning 522 (Origin Connection Time-out).</p>
<p>Turns out a limit of 256 is way too low: Cloudflare has ~275 POPs, and each of
them might establish a few connections to my origin. I raised the limit to 2048
(both for connections and in-flight requests), and immediately the 522 line went
down, and a 200 line went up!</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/i-won-free-load-testing/assets/cf-200-spike.753f3f015f04b338.avif"/>
                <source type="image/webp" srcset="/content/articles/i-won-free-load-testing/assets/cf-200-spike.9b08ff4fe7d0c9d7.webp"/>
                <img loading="lazy" src="https://www.evalapply.org/content/articles/i-won-free-load-testing/assets/cf-200-spike.c8c522de2e42bce8.jpg" title="cloudflare requests graph, 522 spike, 200 spike, 403 spike" alt="cloudflare requests graph, 522 spike, 200 spike, 403 spike"/>
            </picture>
            
<p>Shortly after, Cloudflare caught up with them and they saw a 403 spike. Then
they went away. Site&#39;s back up and fast as ever.</p>

</div><div>
  
    
    
      

  


  







<div>
    <h2>Latest video</h2>









<div>
    
        
        
        
            
        

        

        

        
        
        
        
        
            
        
        
         
        
            
        
        
            
        
        <div>
            <a href="https://www.evalapply.org/videos/getting-good-at-snes">
                
                    
                    <div>
                        <picture>
                            <source type="image/avif" srcset="https://tube.fasterthanli.me/covers/joy/cover.avif"/>
                            <source type="image/webp" srcset="https://tube.fasterthanli.me/covers/joy/cover.webp"/>
                            <img alt="video cover image" src="https://tube.fasterthanli.me/covers/joy/cover.jpg"/>
                        </picture>
                    </div>
                

                <span>
                    
                        
                        Getting good at SNES games through DLL injection
                    
                </span>
            </a>
            <div>
                <div>
                    <div>
                        <p>Apr 25, 2022</p>
                        
                            
                                
                                    <p>
                                        19 minute watch
                                    </p>
                                
                            
                        

                        
                            
                            
                        

                        
                        
                        
                            
                        
                        

                        
                        
                    </div>
                </div>

                <div>
                    
                        
                            
                            <p>Are you ever confronted with a problem and then think to yourself &#34;wait a minute,
I know how to code?&#34; — that&#39;s exactly what happened there.</p>
                        
                    
                </div>

                
                    <p><a href="https://www.evalapply.org/videos/getting-good-at-snes">
                        <span>
                            
                                Watch now
                            
                        </span>
                    </a>
                
            </p></div>
        </div>
    
</div>


    <p>You can watch more videos <a href="https://www.evalapply.org/videos">over there</a></p>
</div> <!-- Latest video -->

  
</div></div>
  </body>
</html>
