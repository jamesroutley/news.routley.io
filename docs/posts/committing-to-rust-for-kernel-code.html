<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/952029/412bfd44912e90b2/">Original</a>
    <h1>Committing to Rust for Kernel Code</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
Rust has been a prominent topic at the Kernel Maintainers Summit for the
last couple of years, and the 2023 meeting continued that tradition.  As
Rust-for-Linux developer Miguel Ojeda noted at the beginning of the session
dedicated to the topic, the level of interest in using Rust for kernel
development has increased significantly over the last year.  But Rust was
explicitly added to Linux as an experiment; is the kernel community now
ready to say that the experiment has succeeded?
</p><p>
The Rust-for-Linux project has added a full-time engineer in the last year,
Ojeda said, and a student developer as well.  Various companies have joined
in to support this work.  There is also work underway to get the <a href="https://lwn.net/Articles/698724/">Coccinelle</a> tool working with Rust code.  A
priority at the moment is bringing in more reviewers for the code that is
being posted.
</p><p>
On the toolchain front, work on <a href="https://github.com/Rust-GCC/gccrs">gccrs</a>, the GCC-based Rust
compiler, has slowed significantly.  The <a href="https://github.com/rust-lang/rustc_codegen_gcc">GCC code generator
for <tt>rustc</tt></a> is showing better progress; it can compile kernel
code now and has been merged into the compiler.  This GCC-based backend
will enable the expansion of Rust support to architectures that are not
supported by the LLVM-based <tt>rustc</tt>.  Meanwhile, the Rust project
itself is increasing its involvement in this work; this is good, since the
kernel has some unique requirements and will need guarantees that language
changes won&#39;t break kernel code in the future.
</p><p>
<a href="https://lwn.net/Articles/952032/"><img src="https://static.lwn.net/images/conf/2023/lpc/MiguelOjeda-sm.png" alt="[Miguel Ojeda]" title="Miguel Ojeda"/></a>

Within the kernel, work is proceeding in a number of subsystems.  The Rust
implementation of Android&#39;s binder is working well and its performance is
on a par with the C implementation.  The amount of unsafe code that was
needed to get there was pleasingly small.  Filesystem bindings are the
subject of work by Wedson Almeida Filho, who is targeting read-only support
for now.  The object there is to make it possible to implement a filesystem
in 100% safe Rust.
</p><p>
In general, he is finding an increasing number of maintainers who are open
to the idea of using Rust.  That leads to an issue the Rust developers have
run up against, though.  It would be good to have some reference drivers in
the kernel as an example of how drivers can be written and to make it
possible to compare Rust and C drivers.  The best way to do that often
seems to be to merge a Rust driver that duplicates the functionality of an
existing C driver â€” but that sort of duplicate functionality is not
welcomed by maintainers.  Perhaps, he said, it would be good to allow a few
duplicate drivers that are not meant for actual use, but only as examples
for other developers to use.
</p><p>
There are some other challenges; upstreaming the block-layer abstractions
has run into some resistance.  Virtual filesystem layer maintainer
Christian Brauner said that he is not opposed to merging those
abstractions, but he would rather not do that and see filesystems built on
it right away.  He would prefer to see an implementation of something
relatively simple, along the lines of the binder driver, to show that
things work as expected.
</p><h4>A driver soon?</h4>
<p>
Dave Airlie, the maintainer of the DRM (graphics) subsystem, said that, if
he has his way, there will be a Rust DRM driver merged within the next
couple of releases.  Christoph Hellwig shot back that Airlie was willing to
&#34;make everybody&#39;s life hell&#34; so that he could play with his favorite toy.
Merging Rust, Hellwig said, would force others to deal with a second language,
new toolchains, and &#34;wrappers with weird semantics&#34;.  Dan Williams said
that the current situation &#34;is what success looks like&#34;, and that the
kernel community was already committed to Rust.
</p><p>
Airlie continued that a lot of the Rust work is currently blocked in a sort
of chicken-and-egg problem.  Abstractions cannot be merged until there is a
user for them, but the code needing those abstractions is blocked waiting
for code to land in multiple subsystems.  As a result, developers working
on Rust are dragging around large stacks of patches that they need to get
their code to work.  Breaking that roadblock will require letting in some
abstractions without immediate users.  Ojeda agreed that this problem has
been slowing progress, but said he has tried not to put pressure on
maintainers to merge code quickly.  In the case of networking, ironically,
the Rust developers <a href="https://lwn.net/Articles/949270/">had to ask the networking
maintainers to slow down</a> merging Rust code.
</p><p>
The conversation took several directions from there.  Greg Kroah-Hartman
said that merging the binder driver would be a good next step; it is
self-contained, has a single user that is committed to its maintenance, and
doesn&#39;t touch the rest of the kernel.  Kees Cook disputed the description
of Rust as a &#34;toy&#34;, saying that there is a lot of pressure to not use C for
new code; Hellwig responded that the developers would have to rewrite
everything in Rust, otherwise the resulting dual-language code base would
be worse than what exists now.
</p><p>
Dave Chinner worried that maintainers lack the expertise to properly review
the abstractions that are being merged.  Airlie replied that maintainers
merge a lot of C APIs now without really understanding how they work.  A
lot of mistakes have been made in the process, but &#34;we&#39;re still here&#34;.
When things turn out to be broken, they can be fixed, and that will happen
more quickly if the code goes upstream.
</p><p>
Ted Ts&#39;o expressed concern about the burden that adding Rust code will
place on maintainers.  The Rust developers are setting higher standards
than have been set in the past, he said.  Getting good abstractions merged
is one thing, but who is responsible for reviewing drivers, and how will
tree-wide changes be handled?  The Rust effort, he said, is getting to a
point where it is impacting a growing part of the community.
</p><p>
Williams pointed out that <a href="https://lwn.net/Articles/951846/">the previous
session</a> had discussed how hard it is to get kernel subsystems to move
to new APIs; now, he said, there is talk of moving to a whole new language.
Hellwig said that the real problem is that the Rust bindings tend to work
differently than the C APIs they provide abstractions for; the new APIs may
well be better, but they are still completely new APIs.  What should be done,
he said, is to first fix the C APIs so that they are directly usable by
Rust code.  He proposed that, for each subsystem that is considering
bringing in Rust code, a year or two should first be spent on cleaning up
its APIs along those lines.  Ojeda said that this kind of API improvement
has already happened in some subsystems.
</p><p>
Linus Torvalds said that he was seeing a divide between the filesystem and
driver maintainers.  Developers on the filesystem side tend to be more
conservative, while the driver world &#34;is the wild west&#34;.  Driver authors
tend not to understand concurrency, he said, and a lot of the code there is
broken and unfixable.  So it is unsurprising that there is interest in
bringing in a language that better supports the writing of correct and safe
code.
</p><p>
Brauner said that Rust can help with a lot of problems, since the compiler
can keep a lot of bugs from making it into the kernel.  But he worried
about whether there would be maintainer and development support for it a
few years from now.  Airlie again mentioned developers with out-of-tree
code needed by Rust code; Cook answered that the people shepherding that
code <i>are</i> maintainers, and that bringing it in would bring the
maintainers with it.  Airlie added that those maintainers are the sort of
younger developers that the kernel community would like to attract.
</p><p>
Chinner said that he would like to see a reimplementation of the ext2
filesystem in Rust.  It is a complete filesystem that makes wide use of the
kernel&#39;s APIs, but it is still small enough to read and understand.  If the
Rust APIs can support an ext2 implementation, they will be enough to
implement others as well.  Meanwhile, the ext2 implementation would be good
reference for maintainers, who could compare it to the C version.
</p><h4>Confidence</h4>
<p>
Ts&#39;o asked when the community would feel enough confidence that it could
have modules where the only implementation is in Rust.  Binder could be a
good start, he said, perhaps followed by a driver that sees wider use.
Airlie said that he is considering a virtual graphics driver that
reimplements an existing C driver.  There is also the driver for Apple M1
GPUs.  He is feeling a fair amount of pressure to get it upstream and
is wondering if there is any reason why he should keep it out.  After that,
he would love to see a rewrite of the Nouveau driver for NVIDIA GPUs.
</p><p>
Arnd Bergmann said those drivers could be OK, but that it will be quite a
bit longer before something like a keyboard driver could be merged; the
toolchain just isn&#39;t ready, he said, for a driver what would be widely
used.  That led to a question about the frequent version upgrades being
seen in the kernel, which moved to Rust 1.73.0 for 6.7.  That upgrade
process will eventually stop and a minimum Rust version will be set once
the important features that the kernel depends on have stabilized.  He said
that he has been working to get the kernel code into the Rust
continuous-integration tests to help ensure that it continues working as
the compiler and language evolve.
</p><p>
Bergmann said that he didn&#39;t plan to look seriously at the language until
it could be compiled with GCC.  Torvalds answered that, while he used to
find problems in the LLVM Clang compiler, now he&#39;s more likely to find
problems with GCC instead; he now builds with Clang.  Ojeda said that he is
working on finding developer resources for gccrs; the project is currently
sitting on over 800 out-of-tree patches and still has a lot of work to do
on top of that.  GCC support will be a while, he said.
</p><p>
Ts&#39;o complained that the language still isn&#39;t entirely stable.  This could
be a particular problem for the confidential-computing community; they are
concerned about security and, as a consequence, about backports to
long-term-support kernels.  But if those kernels are on different Rust
versions, those backports will be problematic.  Ojeda said that, while it
is a &#34;crazy idea&#34;, backporting the version upgrades could be considered.
He doesn&#39;t think that the change rate will be high enough to be a problem,
though.
</p><p>
At the conclusion, Torvalds pointed out that there have been problems over
the years with GCC changes breaking the kernel; the same will surely happen
with Rust, but it will be the same thing in the end.  The session, well
over time, was brought to a halt at this point.  Whether the kernel
community has truly concluded that it is committed to Rust remains to be
seen; there will almost certainly be pull requests adding significant Rust
code in the near future.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="https://lwn.net/Archives/ConferenceIndex/">Conference</a></td><td><a href="https://lwn.net/Archives/ConferenceIndex/#Kernel_Maintainers_Summit-2023">Kernel Maintainers Summit/2023</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
