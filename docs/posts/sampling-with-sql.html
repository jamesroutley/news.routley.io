<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.moertel.com/posts/2024-08-23-sampling-with-sql.html">Original</a>
    <h1>Sampling with SQL</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
<p>Sampling is one of the most powerful tools you can wield to extract meaning from large datasets.
It lets you reduce a massive pile of data into a small yet representative dataset that’s fast and easy to use.</p>
<p>If you know how to take samples using SQL, the ubiquitous query language, you’ll be able to take samples anywhere.
No dataset will be beyond your reach!</p>
<p>In this post, we’ll look at some clever algorithms for taking samples.
These algorithms are fast and easily translated into SQL.</p>
<p>First, however, I’ll note that many database systems have some built-in support for taking samples.
For example, some SQL dialects support a <code>TABLESAMPLE</code> clause.
If your system has built-in support—and it does what you need—using it will usually be your best option.</p>
<p>Often, though, the built-in support is limited to simple cases.
Let’s consider some realistic scenarios that are more challenging:</p>
<ul>
<li>We want to be able to take samples <em>with</em> and <em>without</em> replacement.</li>
<li>We want to take <em>weighted</em> samples in which each item in the input dataset is selected with probability in proportion to its corresponding weight.</li>
<li>We want to support the full range of weights we might expect to see in a FAANG-sized dataset, say between <span>\(0\)</span> to <span>\(10^{20}\)</span> for frequency distributions (e.g., clicks or impressions or RPC events) and between <span>\(0\)</span> to <span>\(1\)</span> with values as small as <span>\(10^{-20}\)</span> for normalized probability distributions. In other words, weights are non-negative numbers, possibly very large or very small.</li>
<li>We want to take deterministic samples. This property lets us take repeatable samples and, in some cases, helps query planners produce faster queries.</li>
</ul>
<h2 id="sampling-without-replacement-the-a-es-algorithm-in-sql">Sampling without replacement: the A-ES algorithm in SQL</h2>
<p>In 2006, Pavlos S. Efraimidis and Paul G. Spirakis published a one-pass algorithm for drawing a weighted random sample, without replacement, from a population of weighted items.
It’s quite simple:</p>
<p>Given a population <span>\(V\)</span> indexed by <span>\(i = 1\ldots{}n\)</span> and having weights <span>\(w_i\)</span>:</p>
<ol type="1">
<li>For each <span>\(v_i\)</span> in <span>\(V,\)</span> let <span>\(u_i = \mathrm{random}(0, 1)\)</span> and <span>\(k_i = u_i^{1/w_i}\)</span>.</li>
<li>Select the <span>\(m\)</span> items with the largest keys <span>\(k_i\)</span>.</li>
</ol>
<p>That algorithm has a straightforward implementation in SQL:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>SELECT</span> <span>*</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>FROM</span> Population</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>WHERE</span> weight <span>&gt;</span> <span>0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>ORDER</span> <span>BY</span> <span>-</span><span>LN</span>(<span>1.0</span> <span>-</span> <span>RANDOM</span>()) <span>/</span> weight</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>LIMIT</span> <span>100</span>  <span>-- Sample size.</span></span></code></pre></div>
<p>You’ll note that we changed the ordering logic a bit.
A straight translation would have been</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>ORDER</span> <span>BY</span> POW(<span>RANDOM</span>(), <span>1.0</span> <span>/</span> weight) <span>DESC</span></span></code></pre></div>
<p>Our translation</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>ORDER</span> <span>BY</span> <span>-</span><span>LN</span>(<span>1.0</span> <span>-</span> <span>RANDOM</span>()) <span>/</span> weight</span></code></pre></div>
<p>is more numerically stable and also helps to show the connection between the algorithm and the fascinating theory of Poisson processes.
This connection makes it easier to understand how the algorithm works.
More on that in a moment.</p>
<h2 id="numerical-stability-and-other-tweaks">Numerical stability and other tweaks</h2>
<p>First, the numerical stability claim.
Assume that our SQL system uses <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Double_precision">IEEE double-precision floating-point values</a> under the hood.
When the weights are large, say on the order of <span>\(w_i = 10^{17}\)</span>, it doesn’t matter what the random value <span>\(u_i\)</span> is.
The corresponding sort key <span>\(k_i = u_i^{1/w_i}\)</span> will almost always be <span>\(1.0\)</span>.
Consider the interval <span>\(0.01 \le u_i \le 1\)</span>, representing 99% of the possible random values <span>\(u_i\)</span>.
This entire interval gets mapped to <span>\(1.0\)</span> when <span>\(w_i = 10^{17}\)</span>:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span># Python.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> w_i <span>=</span> <span>1e17</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> math.<span>pow</span>(<span>0.01</span>, <span>1.0</span><span>/</span>w_i) <span>==</span> math.<span>pow</span>(<span>1.0</span>, <span>1.0</span><span>/</span>w_i) <span>==</span> <span>1.0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>True</span></span></code></pre></div>
<p>Likewise, when weights are small, say <span>\(w_i = 10^{-17}\)</span>, the corresponding sort key will almost always be zero.
Consider the interval <span>\(0 \le u_i \le 0.99\)</span>, representing 99% of the possible random values <span>\(u_i\)</span>:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> w_i <span>=</span> <span>1e-17</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> math.<span>pow</span>(<span>0.0</span>, <span>1.0</span><span>/</span>w_i) <span>==</span> math.<span>pow</span>(<span>0.99</span>, <span>1.0</span><span>/</span>w_i) <span>==</span> <span>0.0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>True</span></span></code></pre></div>
<p>For very large (or small) weights, then, the straightforward implementation doesn’t work.
The wanted sort ordering is destroyed when very large (or small) powers cause what should be distinct sort keys to collapse into indistinguishable fixed points.</p>
<p>Fortunately, logarithms are <a href="https://en.wikipedia.org/wiki/Monotonic_function">order-preserving</a> transformations, so sorting by <span>\(\ln(u_i^{1/w_i}) = \ln(u_i) / w_i\)</span> produces the same ordering as sorting by <span>\(u_i^{1/w_i}\)</span> when we’re using mathematically pure real numbers.
But the log-transformed version is much more stable when using floating-point numbers.
Distinct random inputs <span>\(u_i\)</span> now produce reliably distinct sort keys <span>\(k_i\)</span>, even when the input weights <span>\(w_i\)</span> are very large or very small:</p>
<pre><code>&gt;&gt;&gt; [math.log(u_i) / 1e17 for u_i in (0.01, 0.010001, 0.99, 0.990001)]
[-4.605170185988091e-17, -4.605070190987759e-17,
 -1.005033585350145e-19, -1.0049325753001471e-19]

&gt;&gt;&gt; [math.log(u_i) / 1e-17 for u_i in (0.01, 0.010001, 0.99, 0.990001)]
[-4.605170185988091e+17, -4.605070190987758e+17,
 -1005033585350145.0, -1004932575300147.1]</code></pre>
<!-- ![Graph showing that as the weights w_i reach 10 to the power of 14, a substantial share of the possible random numbers u_i get mapped by our sort-keying function to a single value.](../images/public_html/blog/pix-20240601/deadspace_plot.svg) -->
<p>As a final tweak, we negate the sort keys so that instead of sorting by <span>\(u_i^{1/w_i}\)</span> <strong>descending</strong>, as in the original algorithm, we do an equivalent sort by <span>\(-\ln(u_i) / w_i\)</span> <strong>ascending</strong>.
Note the leading minus sign.
The rationale for flipping the sign will become apparent when we discuss Poisson processes in the next section.</p>
<p>One last numerical subtlety.
Why do we generate random numbers with the expression <code>1.0 - RANDOM()</code> instead of just <code>RANDOM()</code>?
Since most implementations of <code>RANDOM()</code>, such as the <a href="https://www.pcg-random.org/using-pcg-c-basic.html#generating-doubles">PCG</a> implementation used by DuckDB, return a floating-point value in the semi-closed range <span>\([0, 1)\)</span>, they can theoretically return zero.
And we don’t want to take the logarithm of zero.
So we instead use <code>1.0 - RANDOM()</code> to generate a random number in the semi-closed range <span>\((0, 1]\)</span>, which excludes zero.</p>
<h2 id="does-this-algorithm-actually-work">Does this algorithm actually work?</h2>
<p>First, what do we mean by <em>work</em>?
In this case, we’ll say that we want the algorithm to produce samples that are equivalent to a succession of random draws, each draw removing an item from the population, and each draw fair with respect to the population that remains <em>at the time of the draw</em>.
Because the population grows slightly smaller with each draw, the draws in the sample are not <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent and identically distributed</a> (iid).
In practice, however, when your samples are very small compared to your population of interest, and your weights are such that it’s unlikely that iid draws would draw the same item more than once, you can generally pretend that the draws are iid and get away with it.
(When you can’t get away with it, you can use a reweighting scheme to extract unbiased estimates anyway. This subject is worth its own post, so I won’t say more here.)</p>
<p>Anyway, it’s not obvious that assigning a random number <span>\(u_i\)</span> to every row <span>\(i\)</span>, then sorting rows on <span>\(-\ln(u_i)/w_i\)</span>, and finally taking the top <span>\(m\)</span> rows is a recipe that would result in a sample that has the wanted properties.
But it does.</p>
<p>The clearest way to understand what’s going on is to first take a detour through the fascinating theory of <a href="https://ocw.mit.edu/courses/6-262-discrete-stochastic-processes-spring-2011/3a19ce0e02d0008877351bfa24f3716a_MIT6_262S11_chap02.pdf">Poisson processes</a>.
In short, <strong>a Poisson process with rate <span>\(\lambda\)</span> is a sequence of arrivals such that the times between successive arrivals are all independent, <a href="https://en.wikipedia.org/wiki/Exponential_distribution">exponentially distributed</a> random variables with rate <span>\(\lambda\)</span>.</strong>
<!-- For example, say $T_1 < T_2 < T_3 < \cdots$ is a sequence of arrival times, and $X_i = T_{i} - T_{i-1}$ for $i > 1$. Then if all $X_i$ are i.i.d. exponentially distributed with rate $\lambda$, the sequence is a Poisson process with rate $\lambda$. --></p>
<p>Poisson processes have some important (and useful!) properties:</p>
<ol type="1">
<li><em>They are memoryless</em>. No matter what has previously happened, the time until the next arrival from a Poisson process with rate <span>\(\lambda\)</span> is exponentially distributed with rate <span>\(\lambda\)</span>.</li>
<li><em>They can be merged.</em> If you have two Poisson processes with rates <span>\(\lambda_1\)</span> and <span>\(\lambda_2\)</span>, the arrivals from both processes form a combined Poisson process with rate <span>\(\lambda_1 + \lambda_2\)</span>. This holds for any number of processes.</li>
<li><em>They win races in proportion to their rates.</em> In a race between the very next arrival from a Poisson process with rate <span>\(\lambda_1\)</span> and the very next arrival from a Poisson process with rate <span>\(\lambda_2\)</span>, the probability that the first process will win the race is <span>\(\lambda_1 / (\lambda_1 + \lambda_2)\)</span>.</li>
</ol>
<p>Now that we know the basics of Poisson processes, there’s just one more tidbit we need:</p>
<ul>
<li><em>The uniform–exponential bridge.</em> If <span>\(X\)</span> is a random variable having a uniform distribution between zero and one, then <span>\(-\ln(X)/\lambda\)</span> has an exponential distribution with rate <span>\(\lambda\)</span>.</li>
</ul>
<p>With the uniform–exponential bridge in mind, we can begin to see what the algorithm is doing when it assigns every row a key <span>\(k_i = -\ln(u_i)/w_i\)</span> and sorts the population by that key.
It’s running a race over all the rows in the population!
In this race, each row arrives at the finish line at a time that’s an exponentially distributed random variable with a rate corresponding to the row’s weight <span>\(w_i\)</span>.
The first <span>\(m\)</span> arrivals form the sample.</p>
<p>To prove that this race does the sampling that we want, we will show that it is equivalent to a succession of one-row draws, each draw being fair with respect to the population that remains at the time of the draw.
Let the population’s total weight be <span>\(w\)</span>, and consider an arbitrary row <span>\(i\)</span> with weight <span>\(w_i\)</span>.
The algorithm will assign it an exponentially distributed random variable with rate <span>\(w_i\)</span>, which corresponds to the very next arrival from a Poisson process with the same rate.</p>
<p>Now consider all rows except <span>\(i\)</span>.
They too correspond to Poisson processes with rates equal to their weights.
And we can merge them into a combined process with rate <span>\(\sum_{j \ne i} w_j = w - w_i\)</span>.</p>
<p>Now, using the rule about Poisson races, we know that row <span>\(i\)</span>, represented by a process with rate <span>\(\lambda_1 = w_i\)</span>, will win the race against those other rows, represented by a combined process with rate <span>\(\lambda_2 = w - w_i\)</span>, with probability</p>
<p><span>\[\frac{\lambda_1}{\lambda_1 + \lambda_2} = \frac{w_i}{w_i + (w - w_i)} = \frac{w_i}{w}.\]</span></p>
<p>And since we chose row <span>\(i\)</span> arbitrarily, the same argument applies to all rows.
Thus every row’s probability of being drawn is equal to its weight in proportion to the population’s total weight.
This proves that running a “race of exponentials” lets us perform one fair draw from a population.</p>
<p>But, after we’ve drawn one row, what’s left but a new, slightly smaller population?
And can’t we run a new race on this slightly smaller population to correctly draw another row?</p>
<p>We can.
And, since Poisson processes are memoryless, we do not have to generate new arrival times to run this new race.
We can reuse the existing arrival times because the arrivals that have already happened have no effect on later arrivals.
Thus the next row we draw using the leftover arrival times will be another fair draw.</p>
<p>We can repeat this argument to show that successive rows are chosen fairly in relation to the population that remains at the time of each draw.
Thus algorithm A-ES selects a sample of size <span>\(m\)</span> by making <span>\(m\)</span> successive draws, each fair with respect to its remaining population.
And that’s the proof.</p>
<h2 id="tricks-for-faster-samples">Tricks for faster samples</h2>
<p>Most large analytical datasets will be stored in a column-oriented storage format, such as Parquet.
When reading from such datasets, you typically only have to pay for the columns you read.
(By “pay”, I mean wait for the query engine to do its work, but if you’re running your query on some tech company’s cloud, you may actually pay in currency too.)</p>
<p>For example, if your dataset contains a table having 100 columns but you need only four of them, the query engine will usually only read those four columns.
In row-oriented data stores, by contrast, you’ll generally have to decode entire rows, even if you only want four out of the 100 values in each row.
Additionally, most column-oriented stores support some kind of filter pushdown, allowing the storage engine to skip rows when a filtering expression evaluates to false.
These two properties—pay for what you read and filter pushdown—are ones we can exploit when taking samples.</p>
<p>Say we have a Population table with billions of rows and around 100 columns.
How can we efficiently take a weighted sample of 1000 rows?</p>
<p>We could use the basic sampling formulation, as discussed earlier:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>SELECT</span> <span>*</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>FROM</span> Population</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>WHERE</span> weight <span>&gt;</span> <span>0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span>ORDER</span> <span>BY</span> <span>-</span><span>LN</span>(<span>1.0</span> <span>-</span> <span>RANDOM</span>()) <span>/</span> weight</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span>LIMIT</span> <span>1000</span>  <span>-- Sample size.</span></span></code></pre></div>
<p>But think about what the query engine must do to execute this query.
It must read and decode all 100 columns for all of those billions of rows so that it may pass those rows into the sort/limit logic (typically implemented as a <code>TOP_N</code> operation) to determine which rows to keep for the sample.
Even though the sample will keep only 0.00001% of those rows, you’ll have to pay to read the entire Population table!</p>
<p>A much faster approach is to only read the columns we need to determine <em>which</em> rows are in the sample.
Say our table has a primary key <code>pk</code> that uniquely identifies each row.
The following variant on our sampling formulation returns only the primary keys needed to identify the rows in the sample:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>SELECT</span> pk</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>FROM</span> Population</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>WHERE</span> weight <span>&gt;</span> <span>0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>ORDER</span> <span>BY</span> <span>-</span><span>LN</span>(<span>1.0</span> <span>-</span> <span>RANDOM</span>()) <span>/</span> weight</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>LIMIT</span> <span>1000</span>  <span>-- Sample size.</span></span></code></pre></div>
<p>This variant only forces the query engine to read two columns: <code>pk</code> and <code>weight</code>:
Yes, it still must read those two columns for the billions of rows in the table, but those columns contain small values and can be scanned quickly.
After all, that’s what column-oriented stores are designed to do well.
The point is that we’re not paying to read about 100 additional columns whose values we’re just going to throw away 99.99999% of the time.</p>
<p>One we have identified the rows in our sample, we can run a second query to pull in the full set of wanted columns for just those rows.</p>
<h2 id="adding-determinism">Adding determinism</h2>
<p>Our sampling algorithm depends on randomization.
If we run our algorithm twice with the same inputs, we’ll get different results each time.
Often, that nondeterminism is exactly what we want.</p>
<p>But sometimes it isn’t.
Sometimes, it’s useful to be able to <em>control</em> the dice rolls that the algorithm depends on.
For example, sometimes it’s useful to be able to repeat a sample.
Or <em>almost</em> repeat a sample.</p>
<p>To allow us to control the nature of the randomization used when we take samples, we must replace calls to <code>RANDOM</code> with a deterministic pseudorandom function.
One common approach is to hash a primary key and then map the hashed value to a number in the range <span>\([0, 1)\)</span>.
The following DuckDB macro <code>pseudorandom_uniform</code> will do exactly that:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>-- Returns a pseudorandom fp64 number in the range [0, 1). The number</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>-- is determined by the given `key`, `seed` string, and integer `index`.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>CREATE</span> MACRO pseudorandom_uniform(<span>key</span>, seed, <span>index</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>AS</span> (</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  (<span>HASH</span>(<span>key</span> <span>||</span> seed <span>||</span> <span>index</span>) <span>&gt;&gt;</span> <span>11</span>) <span>*</span> POW(<span>2.0</span>, <span>-</span><span>53</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>We can vary the <code>seed</code> and <code>index</code> parameters to generate independent random values for the same <code>key</code>.
For example, if I fix the <code>seed</code> to “demo-seed-20240601” and generate random numbers for the <code>key</code> “key123” over the <code>index</code> values <span>\(1, 2, \ldots, 10\)</span>, I get 10 fresh random numbers:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>SELECT</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  pseudorandom_uniform(<span>&#39;key123&#39;</span>, <span>&#39;demo-seed-20240601&#39;</span>, i) <span>AS</span> u_key123</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>FROM</span> <span>RANGE</span>(<span>1</span>, <span>11</span>) <span>AS</span> t(i);</span></code></pre></div>
<table>
<caption>Ten random numbers for the key “key123” and seed “demo-seed-20240601”.</caption>
<thead>
<tr>
<th><em>i</em></th>
<th><em>u_key123</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.9592606495318252</td>
</tr>
<tr>
<td>2</td>
<td>0.6309411348395693</td>
</tr>
<tr>
<td>3</td>
<td>0.5673207749533353</td>
</tr>
<tr>
<td>4</td>
<td>0.11182926321927167</td>
</tr>
<tr>
<td>5</td>
<td>0.3375806483238627</td>
</tr>
<tr>
<td>6</td>
<td>0.12881607107157678</td>
</tr>
<tr>
<td>7</td>
<td>0.6993372364353198</td>
</tr>
<tr>
<td>8</td>
<td>0.94031652266991</td>
</tr>
<tr>
<td>9</td>
<td>0.17893798791559323</td>
</tr>
<tr>
<td>10</td>
<td>0.6903126337753016</td>
</tr>
</tbody>
</table>
<p>To take deterministic samples, we just replace calls to <code>RANDOM()</code> with calls to our function <code>pseudorandom_uniform()</code>.</p>
<p>Now that we can take deterministic samples, we can do even more useful things!
For example, we can take samples <em>with</em> replacement.</p>
<h2 id="sampling-with-replacement">Sampling with replacement</h2>
<p>Earlier, we proved that the A-ES algorithm allows us to take a sample without replacement as a series of successive draws, each draw removing an item from the population, and each draw fair with respect to the population that remains at the time of the draw.
But what if we wanted to take a sample <em>with replacement</em>?
A sample with replacement requires us to return each item to the population as it is selected so that every selection is fair with respect to the <em>original</em> population, and individual items may be selected more than once.</p>
<p>Can we efficiently implement sampling with replacement in SQL?
Yes!
But it’s a little trickier.
(I haven’t found this algorithm published anywhere; please let me know if you have.
It took me some effort to create, but I wouldn’t be surprised if it’s already known.)</p>
<p>Think back to our correctness proof for the A-ES algorithm.
For each row <span>\(i\)</span> having a weight <span>\(w_i\)</span>, the algorithm imagined a corresponding Poisson process with rate <span>\(\lambda_i = w_i\)</span> and represented the row by the very next arrival from that process.
That arrival would occur at time <span>\(k_i = -\ln(u_i) / w_i\)</span>, where <span>\(u_i\)</span> is a uniformly distributed random number in the range <span>\((0, 1]\)</span>.
Then the algorithm sorted all rows by their <span>\(k_i\)</span> values and took the first <span>\(m\)</span> arrivals as the sample.</p>
<p>With one minor tweak to this algorithm, we can take a sample with replacement.
That tweak is to consider not just the <em>very next</em> arrival from each row’s Poisson process but <em>all</em> arrivals.
Let <span>\(k_{i,j}\)</span> denote the <span>\(j\)</span>th arrival from row <span>\(i\)</span>’s process.
Since we know that in a Poisson process the times between successive arrivals are exponentially distributed random variables, we can take the running sum over interarrival times to give us the needed arrival times.
That is, <span>\(k_{i,j} = \sum_{r=1}^{j} -\ln(u_{i,r}) / w_i\)</span>, where <span>\(u_{i,r}\)</span> represents the <span>\(r\)</span>th uniformly distributed random variable for row <span>\(i\)</span>.</p>
<p>One minor problem with this tweaked algorithm is that a Poisson process generates a theoretically infinite series of arrivals.
Creating an infinite series for each row and then sorting the arrivals from all of these series is intractable.</p>
<p>Fortunately, we can avoid this problem!
Think about how the A-ES algorithm for taking a sample <em>without</em> replacement relates to our proposed intractable algorithm for taking a sample <em>with</em> replacement.
We could describe the <em>without</em> algorithm in terms of the <em>with</em> algorithm like so:
Prepare to take a sample <em>with</em> replacement, but then ignore all arrivals <span>\(k_{i,j}\)</span> for <span>\(j &gt; 1\)</span>; the remaining arrivals must be of the form <span>\(k_{i,1}\)</span>, where <span>\(i\)</span> indicates the corresponding row.
Then take the first <span>\(m\)</span> of these remaining arrivals as your sample, as before.</p>
<p>Now think about going the other way, from having a <em>without</em>-replacement sample and needing to construct a corresponding <em>with</em>-replacement sample.
Let <span>\(S\)</span> be the set of rows sampled <em>without</em> replacement.
We know these rows were represented by a corresponding set of arrival times <span>\(k_{i,1}\)</span> for <span>\(i\)</span> in <span>\(S\)</span>.
We also know that, had the sample been taken <em>with</em> replacement, the race would have included some additional arrival times <span>\(k_{i,j}\)</span> for <span>\(j &gt; 1\)</span> that could have displaced some of the winning rows in <span>\(S\)</span>.
But, crucially, we also know that if <span>\(S_{*}\)</span> represents the set of rows in the corresponding sample <em>with</em> replacement, then <span>\(S_{*}\)</span> must be contained within <span>\(S\)</span>.
This claim follows from the fact that if any arrival <span>\(k_{i,j}\)</span> for <span>\(j &gt; 1\)</span> does displace a row among the first <span>\(m\)</span> arrivals, the <span>\(j&gt;1\)</span> requirement implies that the displacing row is a duplicate of some row <span>\(i\)</span> that arrived earlier in the sample at time <span>\(k_{i,1}\)</span>; thus, displacement cannot introduce a new row from outside of <span>\(S\)</span>.</p>
<p>Therefore, if we have a sample <em>without</em> replacement, we can construct a sample <em>with</em> replacement from its rows.
<em>We can ignore all other rows in the population.</em>
This makes the problem much more approachable.</p>
<p>So now we can see an algorithm taking shape for taking a sample <em>with</em> replacement of size <span>\(m\)</span>:</p>
<ol type="1">
<li>First, take an <span>\(m\)</span>-sized sample <span>\(S\)</span> <em>without</em> replacement using the efficient A-ES algorithm.</li>
<li>For each sampled row <span>\(i\)</span> in <span>\(S\)</span>, generate <span>\(m\)</span> arrivals <span>\(k_{i,j}\)</span> for <span>\(j = 1, 2, \ldots, m\)</span> using the same pseudorandom universe that was used to generate <span>\(S\)</span>.</li>
<li>Take the first <span>\(m\)</span> arrivals as the sample.</li>
</ol>
<p>You may have noticed that step 2 of this algorithm requires us to create <span>\(m\)</span> arrivals for each of the <span>\(m\)</span> rows in <span>\(S\)</span>.
This step thus requires <span>\(O(m^2)\)</span> time.
When <span>\(m\)</span> is large, this time can be prohibitive.</p>
<p>Fortunately, we can use probability theory to reduce this cost to <span>\(O(m)\)</span>.
The idea is that if row <span>\(i\)</span> is expected to occur in the sample <span>\(n_i\)</span> times, it is very unlikely to occur more than <span>\(c \cdot n_i\)</span> times when <span>\(c \ge 2\)</span>.
So we don’t need to generate a full <span>\(m\)</span> arrivals for each row <span>\(i\)</span> in <span>\(S\)</span>; we can get away with generating <span>\(m_i = \lceil{c \cdot n_i}\rceil\)</span> arrivals instead, for a suitably large <span>\(c\)</span> to assuage our personal level of paranoia.</p>
<p>Here’s a sample implementation as a DuckDB macro:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>-- Takes a weighted sample with replacement from a table.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>--</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>-- Args:</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>--  population_table: The table to sample from. It must have a `pk` column</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>--    of unique primary keys and a `weight` column of non-negative weights.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>--  seed: A string that determines the pseudorandom universe in which the</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span>--    sample is taken. Samples taken with distinct seeds are independent.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span>--    If you wish to repeat a sample, reuse the sample&#39;s seed.</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span>--  sample_size: The number of rows to include in the sample. This value</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span>--    may be larger than the number of rows in the `population_table`.</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span>--</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span>-- Returns a sample of rows from the `population_table`.</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>CREATE</span> MACRO sample_with_replacement(population_table, seed, sample_size)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span>AS</span> <span>TABLE</span> (</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span>WITH</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span>-- First, take a sample *without* replacement of the wanted size.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    SampleWithoutReplacement <span>AS</span> (</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>      <span>SELECT</span> <span>*</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>      <span>FROM</span> query_table(population_table:<span>:varchar</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>      <span>WHERE</span> weight <span>&gt;</span> <span>0</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>      <span>ORDER</span> <span>BY</span> <span>-</span><span>LN</span>(pseudorandom_uniform(pk, seed, <span>1</span>)) <span>/</span> weight</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>      <span>LIMIT</span> sample_size</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span>-- Compute the total weight over the sample.</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    SampleWithoutReplacementTotals <span>AS</span> (</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>      <span>SELECT</span> <span>SUM</span>(weight) <span>AS</span> weight</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>      <span>FROM</span> SampleWithoutReplacement</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span>-- Generate a series of arrivals for each row in the sample.</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    SampleWithReplacementArrivals <span>AS</span> (</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>      <span>SELECT</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        S.<span>*</span>,</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        <span>SUM</span>(<span>-</span><span>LN</span>(pseudorandom_uniform(pk, seed, trial_index)) <span>/</span> S.weight)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>          <span>OVER</span> (<span>PARTITION</span> <span>BY</span> pk <span>ORDER</span> <span>BY</span> trial_index)</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>          <span>AS</span> rws_sort_key</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>      <span>FROM</span> SampleWithoutReplacement <span>AS</span> S</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>      <span>CROSS</span> <span>JOIN</span> SampleWithoutReplacementTotals <span>AS</span> T</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>      <span>CROSS</span> <span>JOIN</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        UNNEST(</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>          <span>RANGE</span>(<span>1</span>, <span>CAST</span>(<span>2.0</span> <span>*</span> sample_size <span>*</span> S.weight <span>/</span> T.weight <span>+</span> <span>2</span> <span>AS</span> <span>INT</span>)))</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span>AS</span> I(trial_index)</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>  <span>-- Form the sample *with* replacement from the first `sample_size` arrivals.</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>  <span>SELECT</span> <span>*</span> EXCLUDE (rws_sort_key)</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>  <span>FROM</span> SampleWithReplacementArrivals</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>  <span>ORDER</span> <span>BY</span> rws_sort_key</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>  <span>LIMIT</span> sample_size</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<h3 id="example-of-sampling-with-replacement">Example of sampling with replacement</h3>
<p>As an example of when we might want to sample with replacement instead of without, consider the following population table <code>ThreeToOne</code> that represents the possible outcomes of tossing a biased coin:</p>
<table>
<caption><code>ThreeToOne</code> population table.</caption>
<thead>
<tr>
<th><em>pk</em></th>
<th><em>weight</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>heads</td>
<td>3</td>
</tr>
<tr>
<td>tails</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>For this biased coin, “heads” is 3 times as likely as “tails.”
We can simulate flipping this coin 10 times by sampling 10 rows from the <code>ThreeToOne</code> population table with replacement:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>SELECT</span> pk</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>FROM</span> sample_with_replacement(ThreeToOne, <span>&#39;test-seed-20240601&#39;</span>, <span>10</span>);</span></code></pre></div>
<table>
<caption>Results of drawing a 10-row sample with replacement from <code>ThreeToOne</code>.</caption>
<thead>
<tr>
<th><em>pk</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>heads</td>
</tr>
<tr>
<td>heads</td>
</tr>
<tr>
<td>heads</td>
</tr>
<tr>
<td>tails</td>
</tr>
<tr>
<td>tails</td>
</tr>
<tr>
<td>heads</td>
</tr>
<tr>
<td>heads</td>
</tr>
<tr>
<td>heads</td>
</tr>
<tr>
<td>tails</td>
</tr>
<tr>
<td>heads</td>
</tr>
</tbody>
</table>
<p>In this sample, we got 7 heads and 3 tails.
On average, we would expect about 7.5 heads in each sample of size 10, so our observed sample is close to our expectations.</p>
<p>But maybe we just got lucky.
As a stronger test of our SQL sampling logic, let’s take 10,000 samples of size 40 and look at the count of heads across all of the samples.
We would expect this count to have a Binomial(<em>size</em> = 40, <em>p</em> = 3/4) distribution.
To compare our observed results to the expected distribution, I’ll compute the empirical distribution of the results and plot that over the expected distribution.
As you can see in the figure below, the observed distribution closely matches the expected distribution.</p>
<figure>
<img src="https://blog.moertel.com/images/public_html/blog/pix-20240601/observed_samples_vs_expected_three_to_one.svg" alt="When we take 10,000 independent samples of size n = 40 from a 3:1 biased-coin distribution, we find that the count of “heads” over the samples agrees with the expected Binomial(size = 40, p = 3/4) distribution."/>
<figcaption aria-hidden="true">When we take 10,000 independent samples of size <span>\(n = 40\)</span> from a 3:1 biased-coin distribution, we find that the count of “heads” over the samples agrees with the expected Binomial(<em>size</em> = 40, <em>p</em> = 3/4) distribution.</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>Sampling is a powerful tool.
And with the SQL logic we’ve just discussed, you can take fast, easy samples from virtually any dataset, no matter how large.
And you can take those samples with or without replacement.</p>
<p>What makes it all work is a clever connection to the theory of Poisson processes.
Those processes are memoryless and mergeable, and their arrivals win races in proportion to their rates.
These properties are exactly what we need to run races that let us take samples.</p>
<p>Beyond what we’ve discussed in this article, there are further ways we can exploit these properties.
For example, as a performance optimization, we can predict the arrival time <span>\(t\)</span> of the final row in a sample.
Then we can augment our SQL sampling logic with a pushdown filter that eliminates population rows with arrival times greater than <span>\(c \cdot t\)</span> for some constant <span>\(c\)</span>.
This filtering happens before <code>ORDER/LIMIT</code> processing and can greatly speed queries by eliminating more than 99.99% of rows early on, before they are even fully read on systems that support “late materialization.”</p>
<p>But this article is already too long, so I’ll stop here for now.</p>
<h2 id="references">References</h2>
<p>Pavlos S. Efraimidis and Paul G. Spirakis. Weighted random sampling with a reservoir. <em>Information Processing Letters</em>, 97(5):181–185, 2006.</p>
</div></div>
  </body>
</html>
