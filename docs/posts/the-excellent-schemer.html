<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://code-magazine.com/Article/2207071/The-Excellent-Schemer">Original</a>
    <h1>The Excellent Schemer</h1>
    
    <div id="readability-page-1" class="page"><div><p>Accelerate<sup>TM</sup> for Microsoft 365 is a new, commercially available Microsoft Office add-in that deeply integrates the Visual Scheme for Applications<sup>TM</sup> (VSATM) programming language into the popular back-office automation suite, for versions 2016 and later. VSA intends to serve as the “third musketeer,” alongside Visual Basic for Applications (VBA) and the popular formula expression language of Excel, but with a twist: Under the hood of this uniquely powerful language is the full reach and power of the .NET Framework.</p>
<p>VSA is implemented on top of .NET and woven directly into the fabric of the storied Office suite via the Accelerate for Microsoft 365 add-in. Initial focus is on Excel, but eventually all the applications that are part of the suite will benefit from its core value proposition. The add-in supports in-application scripting in VSA via a proper REPL (see <strong>Figure 1</strong>), available from within the host Office application (and accessible at the command line as well for external processing).</p>
<figure><img src="https://codemag.com/Article/Image/2207071/image1.png" alt="Figure 1: The REPL is where you test out ideas before you commit them to code."/></figure>
<p>In the case of Excel, an additional pretty-printing, syntax-highlighting Lambda Editor (see <strong>Figure 2</strong>) makes writing user-defined functions (UDFs) in Scheme both easy and convenient.</p>
<figure><img src="https://codemag.com/Article/Image/2207071/image2.png" alt="Figure 2: The Lambda Editor makes writing and using Scheme as a language for UDF development a pleasant breeze."/></figure>
<p>In this latter capacity within Excel, Visual Scheme for Applications compliments Microsoft&#39;s recent addition of the <code>LET()</code> and <code>LAMBDA()</code> functions to their formula expression language by providing a flavor of the same functional programming approach to creating UDFs, but with an external enterprise integration focus. Unlike the formula expression language in which <code>LET()</code> and <code>LAMBDA()</code> are available, VSA code can interact with the outside world from both directions: the inside out and the outside in. A standalone scripting engine at the command line for general-purpose programming accompanies the add-in and comes with a plethora of useful Scheme and .NET wrapper libraries for this very purpose.</p>
<p>In this article, I&#39;ll walk you through the rationale for making Scheme on .NET a first-class extension/automation language of the Office suite by way of a hands-on primer. First, I&#39;ll cover some basic facts about Scheme as I ease into reviewing VSA as a first-class language for user-defined function (UDF) development in Excel. Then, I&#39;ll explore some of the more powerful techniques around wrapping .NET libraries for use in VSA-powered Office solutions. Finally, I&#39;ll take a step back and cover syntax extensions, perhaps the most mystifying feature of the language, and how to interact with them in the built-in and command-line REPL.</p>
<h2 id="why-scheme">Why Scheme?</h2>
<p>At first glance, Scheme might seem an odd choice of a language to tag team with VBA and Excel&#39;s formula expression language. On closer inspection, and especially considering Microsoft&#39;s new, explicitly “functional programming” direction with Excel&#39;s formula expression language, Scheme seems the inevitable choice.</p>
<p>Scheme is a seasoned dialect in the venerable Lisp family of computer programming languages. Quoting Guy Steele, one of Scheme&#39;s inventors, “If you give someone FORTRAN, he has FORTRAN. If you give someone Lisp, he has any language he pleases” (Friedman, D. <em>The Reasoned Schemer,</em> Second Edition, MIT Press, 1998). The choice of providing a Lisp language is a conscious decision to put the programmer in control of the language&#39;s features and functions for a given domain. The bottom-up style of programming it encourages results in every Lisp application becoming a domain-specific language (DSL). This is because of a feature that all Lisps have, called <strong>macros</strong> (although Scheme&#39;s flavor of this feature is unique to it, and referred to as “syntax extension” instead). I&#39;ll show an example of this below.</p>
<blockquote>
<p>The choice of providing a Lisp language is a conscious decision to put the programmer in control of the language&#39;s features <code>and</code> functions for a given domain.</p>
</blockquote>
<p>Many top-flight universities teach Scheme to first-year computer science majors with no previous background in programming, because anyone can grasp its basic syntax in just a few hours. It&#39;s very easy to learn (and to teach), with an approachable and consistent core syntax based on Lisp S-expressions that&#39;s both very succinct and surprisingly malleable. Mastering Scheme is a bit like mastering chess, with the exception that even a complete beginner can do amazing things in Scheme right away.</p>
<p>The Scheme that Accelerate for Microsoft 365 integrates into Office goes by the name “Visual Scheme for Applications,” or VSA, making its mission clear: to be the perfect companion to VBA, by adding metaprogramming power and .NET reach to the Office/VBA solution developer&#39;s arsenal of tools.</p>
<p>It&#39;s worth noting briefly that Scheme is used elsewhere in the real world. For example, the Scheme programming language is the GNU project&#39;s official application extension language, where it goes by the name of Guile (see: <a href="https://gnu.org/software/guile" target="_blank">https://gnu.org/software/guile</a>). Another implementation of Scheme, called MIT Scheme, is the programming language of choice for teaching, using several advanced textbooks on diverse engineering topics, including classical mechanics (<em>Structure and Interpretation of Classical Mechanics,</em> by G.J. Sussman and J. Wisdom), differential geometry (<em>Functional Differential Geometry,</em> by G.J. Sussman and J. Wisdom), and software engineering (<em>Software Design for Flexibility - How to Avoid Programming Yourself into a Corner,</em> by C. Hanson, and G.J. Sussman). In other words, Scheme is more at home in application extensions, math-intensive, and data-intensive problem domains than you may realize. Sounds perfect for Office - especially Excel!</p>
<p>Yet another popular embodiment of Scheme goes by the name of Racket (see <a href="https://www.racket-lang.org" target="_blank">https://www.racket-lang.org</a>). Racket aspires to be an industrial-strength Scheme whose main mission is “language-oriented programming,” proving that Scheme is indeed a uniquely powerful language for creating DSLs.</p>
<p>All of these facts make Scheme, at the very least, an intriguing choice for Office solutions developers looking for ways to modernize their clients&#39; back-office systems in an interconnected, multi-cloud world.</p>
<p>So, let&#39;s see it in action, shall we?</p>
<h2 id="mary-had-a-little-lambda--">Mary Had a Little (lambda () ...)</h2>
<p>One thing that surprises developers who haven&#39;t yet had a chance to explore a proper Lisp is how similar the new <code>LET</code>/<code>LAMBDA</code> functions in Excel look, or at least feel, like Lisp/Scheme. Here is an example of an Excel <code>LAMBDA</code>/<code>LET</code> function:</p>
<pre><code>=LAMBDA(X,Y,LET(XS,X*X,YS,Y*Y,SQRT(XS+YS)))
</code></pre>
<p>Now here&#39;s the same thing in Scheme:</p>
<pre><code>(lambda (x y)
    (let ((xs (* x x))
        (ys (* y y)))
    (sqrt (+ xs ys))))
</code></pre>
<p>To make it a little bit clearer how a Schemer would almost automatically see the original <code>LAMBDA</code>/<code>LET</code> function by formatting it a more semantically revealing way, consider:</p>
<pre><code>=LAMBDA(X, Y, LET(XS, X*X, YS, Y*Y, SQRT(XS+YS)))
</code></pre>
<p>That looks a lot like Scheme to me! The only real difference is the infix notation and the semantics of the LET expression, which one simply must know to understand what&#39;s going on. The evaluation order is not particularly self-evident unless, of course, you happen to know how the <code>let</code> binding form in every Lisp works.</p>
<p>The beauty of the Scheme code is that syntactically there&#39;s a lot less going on, and no foreknowledge is required to understand it. The Scheme prefix notation makes commas unnecessary and there&#39;s zero ambiguity about what each set of parentheses do in context. The values are evaluated according to the natural structure of the nested S-expressions. A Schemer understands that the parentheses, far from being an annoyance, serve this disambiguation function and make so much syntax seem superfluous when it&#39;s related to order precedence and other grammar rules that most languages need to define and enforce somehow.</p>
<blockquote>
<p>One thing that surprises developers who haven&#39;t yet had a chance to explore a proper Lisp is how similar the new LET/LAMBDA functions in Excel look, or at least feel, like Lisp/Scheme.</p>
</blockquote>
<p>In the <code>LAMBDA</code> function, by contrast, it&#39;s necessary to simply know that the <code>LET</code> function MUST have an odd number of parameters, the last of which must evaluate to a value and the arguments you provide must alternate between a name and a value binding.</p>
<p>Now let&#39;s take a quick look at some of the more meat-and-potatoes uses of lambda expressions in Accelerate for Microsoft 365.</p>
<p><strong>Figure 3</strong> is a screenshot of an example spreadsheet provided in the download zip file (available in the download for this article) that captures several important idioms of programming in Scheme as well as a simple example of .NET interoperability. The challenge is to compose sentences from words listed in 2D regions. In the first region, the words are ordered by row, which is Excel&#39;s default evaluation order when feeding a region to a user-defined function. The second region orders the words by column.</p>
<figure><img src="https://codemag.com/Article/Image/2207071/image3.png" alt="Figure 3: Building sentences from words in 2D regions requires carefully choosing the orientation according to which the words will be flattened into a single array. "/></figure>
<p>There are four listings where lambda expressions are added to the sheet, corresponding to the numbers in <strong>Figure 3</strong>.</p>
<p><strong>Listing 1</strong> is the “join-words” lambda expression. In the sheet, this is created using the <code>=define</code> function provided by the add-in. It allows you to give a Scheme name to a lambda expression. The resulting expression in A7 tells you that the Scheme name and the arity (or number of arguments) it takes. The hash is computed every time the code is altered to trigger Excel&#39;s calculation engine (depending on what options for auto-calculation you have set up) and can be ignored.</p>
<h4 id="listing-1-the-join-words-lambda-expression">Listing 1: the “join-words” lambda expression</h4>
<pre><code>(lambda (words delimiter)
  (clr-static-call String (Join String Object[]) delimiter (list-&gt;vector words)))
</code></pre>
<p>Note the <code>clr-static-call</code> form. This is one of several .NET interop forms that are built in, making it easy for you to call into the .NET runtime directly. In this case, you&#39;re calling the static <code>Join</code> method of the <code>String</code> class in the <code>System</code> namespace.</p>
<p>The tricky bit here is that, as you can see by the signature, Join expects an array, not a list. So, you call the built-in <code>list-&gt;vector</code> Scheme function on “words,” which does just what it says: It converts a list to a vector. Vectors in Scheme are the same as arrays in .NET.</p>
<p><strong>Listing 2</strong> (shown in the Lambda Editor in <strong>Figure 4</strong>) is the <code>words-&gt;sentence</code> lambda expression, which uses <code>join-words</code> to produce all but the final period on the sentence. <code>String-append</code> is used to add that. This expression is variadic, which you can tell by the fact that the sole argument is the word <code>words</code> with no parentheses around it. This means that it can take zero or more arguments, and wraps whatever is (or isn&#39;t) sent up into a nice list that <code>=apply</code> can use.</p>
<h4 id="listing-2-the-words-sentence-lambda-expression">Listing 2: the “words-&gt;sentence” lambda expression</h4>
<pre><code>(lambda words (string-append (join-words words &#34; &#34;) &#34;.&#34;))
</code></pre>
<figure><img src="https://codemag.com/Article/Image/2207071/image4.png" alt="Figure 4: The words-&gt;sentence lambda expression uses join-words to construct a sentence from the words argument."/></figure>
<p><strong>Listing 3</strong> (shown in the Lambda Editor in <strong>Figure 5</strong>) uses the <code>=eval</code> function provided by the add-in with a lambda expression that, in turn, calls the built-in <code>=apply</code> form. The issue here is that <code>=apply</code> can only accept a single list, of whatever type is required by the function to which it is applying the list. Excel is sending a 2D array or region, and so it&#39;s necessary to flatten the input to pass a list as expected by <code>=apply</code>.</p>
<h4 id="listing-3-using-flatten-lol-in-an-inline-apply-lambda">Listing 3: using (flatten lol) in an inline “apply” lambda</h4>
<pre><code>(lambda lst (apply words-&gt;sentence (flatten lst)))
</code></pre>
<figure><img src="https://codemag.com/Article/Image/2207071/image5.png" alt="Figure 5: By default, Excel uses by-row semantics for ordering cells in 2D regions. Here we flatten the region into a 1D list using default semantics."/></figure>
<p><strong>Listing 4</strong> (shown in the Lambda Editor in <strong>Figure 6</strong>) is nearly identical, except that <code>flatten-by-column</code> is used instead to obtain the correct word order in the sentence it creates.</p>
<h4 id="listing-4-using-flatten-by-column-lol-in-an-inline-apply-lambda">Listing 4: using (flatten-by-column lol) in an inline “apply” lambda</h4>
<pre><code>(lambda lst (apply words-&gt;sentence(flatten-by-column lst)))
</code></pre>
<figure><img src="https://codemag.com/Article/Image/2207071/image6.png" alt="Figure 6: Flatten-by-column provides by-column flattening semantics. The ability to choose list ordering against 2D regions can come in handy, and not just for Mary and her little lambda!"/></figure>
<p>Although somewhat contrived, this example shows some important idioms and how they map to conventional Excel behavior that&#39;s important to understand.</p>
<h2 id="never-block-the-chain">Never Block the Chain</h2>
<p>The add-in comes with a tutorial walking you through creating a blockchain-like feature in Excel. <strong>Figure 7</strong> is a screenshot of the first part of that tutorial.</p>
<figure><img src="https://codemag.com/Article/Image/2207071/image7.png" alt="Figure 7: Reaching into the System.Security.Cryptography namespace of .NET makes it easy to model the basic concept and value proposition of a blockchain right inside Excel."/></figure>
<p>Rather than duplicate the steps here, instead I&#39;ll briefly cover the salient aspects of the code that&#39;s produced by the end of the tutorial (see <strong>Listing 5</strong>). The two things that should be paid most attention are:</p>
<ul>
<li>The direct interop with .NET via <code>clr-*</code> functions</li>
<li>How .NET abstractions are wrapped in idiomatic Scheme code in a library, conformant with the R6RS Scheme specification</li>
</ul>
<h4 id="listing-5-blockchainsls">Listing 5: blockchain.sls</h4>
<pre><code>(library (blockchain)

    (export string-&gt;sha256
            data-mine
            genesis-block
            genesis-block-hash)

    (import (ironscheme)
            (ironscheme clr))

    (clr-using System.Text)
    (clr-using System.Security.Cryptography)

    (define genesis-block (make-parameter &#34;This is my genesis block.&#34;))

    (define genesis-block-hash (lambda () (string-&gt;sha256 (genesis-block))))

    (define string-&gt;sha256 (lambda (str)
        (let* ((utf8 (clr-static-prop-get Encoding UTF8))
               (bytes (clr-call UTF8Encoding (GetBytes String) utf8 str))
               (hash-fn (clr-new SHA256Managed))
               (raw-result (clr-call SHA256Managed 
                                     (ComputeHash System.Byte[]) hash-fn bytes))
               (bits-str (clr-static-call BitConverter ToString raw-result))
               (clean-bits (clr-call String Replace bits-str &#34;-&#34; &#34;&#34;))
               (lower-bits (clr-call String ToLower clean-bits)))
        lower-bits)))

    (define data-mine (lambda (current-block-data previous-block-hash)
        (let* ((combined-data (string-append current-block-data &#34;+&#34;
                previous-block-hash))
               (result (string-&gt;sha256 combined-data)))
    result)))
)
</code></pre>
<p>All of the code to make this example work is stored in the <code>blockchain.sls</code> library file (the full contents of which are provided in <strong>Listing 5</strong>). The only code that you&#39;ll find in the sample spreadsheet that&#39;s included in the download is a lambda expression to grab the genesis block hash in B2.</p>
<pre><code>(lambda ()
(genesis-block-hash))
</code></pre>
<p>The rest of the calls use the <code>=eval</code> function provided by the add-in calling the <code>&#34;data-mine&#34;</code> function that&#39;s defined in <strong>Listing 5</strong> with the appropriate arguments. These are the data of the current block and the hash of the previous block, respectively.</p>
<pre><code>=eval(&#34;data-mine&#34;,A3,B2)
</code></pre>
<p>The tutorial does a good job of developing the code, so I&#39;ll just comment on the important highlights of <strong>Listing 5</strong>.</p>
<p>First, <code>blockchain.sls</code> is a canonical library definition per the R6RS specification, with which VSA and the underlying IronScheme implementation is 99% compliant. There are some niche aspects of continuations - a powerful Scheme feature that allows the language to be used to program constructs of other languages - that simply can&#39;t be implemented on the CLR because of low-level restrictions.</p>
<p>It exports and imports several symbols from the <code>(ironscheme clr)</code> namespace. The various <code>clr-*</code> forms encountered in <strong>Listing 5</strong> are part of a very straightforward CLR interoperability API that you, as a VSA coder, will get to know quickly, because the code here exercises most of it and is relatively easy to understand.</p>
<p>The <code>(clr-using ...)</code> form works just like the C# <code>using</code> or VB.NET <code>imports</code> statements. It allows the library to reference symbols in the respective namespaces.</p>
<p>The <code>genesis-block</code> symbol is a Scheme parameter. This is similar to a dynamic variable in Lisp or a global variable in JavaScript, intended to allow a default value that is mutable, but the normal use of parameters is to give them locally scoped values that don&#39;t affect the global default value once the local value is out of scope.</p>
<p>Parameter values in Scheme are obtained by calling them like a function with no arguments. Setting them to new values is done by passing in a single argument, the new value. At creation time, Scheme parameters can have “guards” that will test any new value and disallow anything that should not be permitted as a new value.</p>
<p>By far the most interesting symbol in <strong>Listing 5</strong> is the <code>string-&gt;sha256</code> symbol.</p>
<pre><code>  (define string-&gt;sha256
    (lambda (str)
      (let* ((utf8 (clr-static-prop-get Encoding UTF8))
              (bytes (clr-call UTF8Encoding (GetBytes String) utf8 str))
              (hash-fn (clr-new SHA256Managed))
              (raw-result (clr-call SHA256Managed (ComputeHash System.Byte[])
                                                           hash-fn bytes))
              (bits-str (clr-static-call BitConverter ToString raw-result))
              (clean-bits (clr-call String Replace bits-str &#34;-&#34; &#34;&#34;))
              (lower-bits (clr-call String ToLower clean-bits)))
      lower-bits)))
</code></pre>
<p>This function takes a string, and calls into the .NET <code>System.Security.Cryptography</code> and <code>System.Text</code> namespaces to produce a SHA256 hash of the string, and is massaged to appear in the required format. It&#39;s worth taking time to work through this tutorial, because it&#39;s representative of what developers will do to surface .NET in a concise, easy-to-use way in the context of Excel formula expressions.</p>

<p>Finally, let&#39;s take a look at a Scheme syntax extension.</p>
<p>While the team was wrapping .NET APIs, it became desirable to iterate over collections implementing the IEnumerable interface in a cleaner syntax. <strong>Listing 6</strong> provides the full code. What follows will be only a high-level description, as an entire series of articles could be written to properly explain how you might write code like this. It cannot be stressed enough just how powerful syntax extensions are in Scheme.</p>
<h4 id="listing-6-the-built-in-define-enumerable--syntax-extension">Listing 6: The built-in (define-enumerable ...) syntax extension</h4>
<pre><code>
(define-syntax define-enumerable (lambda (x)
    (syntax-case x (as)
        ((_ enum-name enum-fn)
        #&#39;(define-enumerable enum-name enum-fn as IEnumerable))
        ((_ enum-name enum-fn as enum-type)
        #&#39;(define enum-name
            (case-lambda [() (let ((iter (enum-fn))) 
                (make-iterator (lambda () (unless iter
                                            (set! iter 
                                                  (clr-call enum-type
                                                            GetEnumerator
                                                            (enum-fn))))
                               (clr-call IEnumerator MoveNext iter))
                            (lambda ()
                               (clr-prop-get IEnumerator Current iter))
                            (lambda ()
                              (set! iter (clr-call enum-type GetEnumerator
            (enum-fn))))))]
                       [(obj) (let ((iter (enum-fn obj)))
                                (make-iterator 
                                  (lambda ()
                                  (unless iter
                                    (set! iter (clr-call enum-type
                                                         GetEnumerator
                                                         (enum-fn obj))))
                                  (clr-call IEnumerator MoveNext iter))
                               (lambda ()
                                  (clr-prop-get IEnumerator Current iter))
                               (lambda ()
                                 (set! iter (clr-call enum-type
                                                      GetEnumerator
                                                      (enum-fn obj))))))]))))))

</code></pre>
<p>Most .NET developers will recall the sense of wonder and awe the first time the C# compiler team released LINQ, or “Language Integrated Query.” Most will also remember the gradual evolution of LINQ into the powerful, general-purpose DSL that it is today. What I am about to say is not meant to diminish that sense of awe, but rather to rekindle it.</p>
<p><em>In Scheme, a mostly complete version of LINQ can be implemented in a weekend in about 900 lines of pure Scheme code.</em></p>
<p>You heard that right. This may sound blasphemous to a .NET developer. However, any veteran Lisper or Schemer will know that this is a fair observation. We are used to such power at our fingertips - it&#39;s the whole point of the language.</p>
<p>We know this because that&#39;s the true story of the <code>(ironscheme linq)</code> library that&#39;s included as part of VSA. This is NOT a wrapper of .NET&#39;s LINQ features, which are specific to compilers that implement them, but rather a pure Scheme implementation of generic iterators against pure Scheme collections with most of the familiar syntax sugar .NET developers will recognize instantly.</p>
<p>Unfortunately, because it wasn&#39;t a wrapper of .NET, it left the team in a bind. There was no way to use IEnumerable collections with this pure Scheme iterator implementation. This isn&#39;t really a bind for a language like Scheme. <strong>Listing 6</strong> allowed you to bridge the gap and use .NET collections with the pure-Scheme LINQ by defining pure Scheme iterators wrapping the IEnumerable interface, which, on the surface, looks completely compatible.</p>
<blockquote>
<p>In Scheme, a mostly complete version of LINQ can be implemented in a weekend in about 900 lines of pure Scheme code.</p>
</blockquote>
<p>To be fair, <strong>Listing 6</strong> is considerably more complicated than we thought it would be. It turns out, IEnumerable is not implemented in a uniform way for what appear to be mainly historical reasons, as the interface was treated - even by Microsoft - as more of a suggestion than a contract. In particular, the <code>Reset()</code> method often produces surprising behavior depending on how the implementor of a collection that supports IEnumerable decided to handle this. In order to deal with this, we had to make the syntax extension, named <code>(define-enumerable ...)</code>, able to take different input based on the caller&#39;s understanding of the object they&#39;re dealing with. Some classes that implement IEnumerable do what you need them to do, but sadly this isn&#39;t something you can take for granted. The VSA team found it necessary to provide default functionality obtaining a fresh IEnumerable instance from the parent object in which it was defined. It&#39;s not pretty, but it works, and you have the option to provide a specific type to cast it to when you know it does the right thing.</p>
<p>Example usages below come from the <strong>(visualscheme data rdf core)</strong> library.</p>
<p>The first example is the wrapper of the <code>AllNodes</code> property of a <code>Graph</code> class as defined in <code>dotNetRDF</code>. (RDF plays an important role in the Professional edition but is also available in the Standard edition.) Basically, what the <code>(define-enumerable...)</code> syntax needs is a function to obtain the fresh collection either from the <code>(current-graph)</code> by default, or a specific graph instance passed in via the one-argument version of the method.</p>
<pre><code>(define-enumerable graph/all-nodes 
  (case-lambda 
    [() (clr-prop-get Graph AllNodes (current-graph))]
    [(graph) (begin
      (if (or (null? graph) (not (graph? graph)))
          (error &#34;graph must be a non-null Graph.&#34;)
          (if (not (eq? graph (current-graph))) (current-graph graph)))
      (clr-prop-get Graph AllNodes graph))]))
</code></pre>
<p>The following snippet is similar, except to get it to work for triples of a Graph, you have to provide an explicit type to which it needs to be cast so that the appropriate <code>Reset()</code> behavior is obtained - in this case, <code>TreeIndexedTripleCollection</code>.</p>
<pre><code>(define-enumerable graph/triples (case-lambda
    [() (clr-prop-get Graph Triples (current-graph))]

    [(graph)
     (begin
       (if (or (null? graph) (not (graph? graph)))
           (error &#34;graph must be a non-null Graph.&#34;)
           (if (not (eq? graph (current-graph))) (current-graph graph)))
       (clr-prop-get Graph Triples graph))]) as TreeIndexedTripleCollection)
</code></pre>
<p>These allow the user of the wrapper code to write the following:</p>
<pre><code>(foreach t in (graph/triples)
    (display t)
    (newline))
</code></pre>
<p><strong>Listing 7</strong> provides a fuller flavor of LINQ in VSA, all of which will now also work with .NET types that implement IEnumerable if you use <code>define-enumerable</code>, as you did above, to expose them to IronScheme&#39;s iterator framework. These are borrowed from the documentation in <code>(ironscheme linq)</code> written by Llewelyn Pritchard, the main developer of IronScheme on which VSA is based.</p>
<h4 id="listing-7-some-linq-examples-in-scheme">Listing 7: Some LINQ examples in Scheme</h4>
<pre><code>;; conformance to C# tests
;; simply permutations of the grammar and matched to the output
;; of C#
(define (print-list lst)
    (foreach x in lst (printf &#34;~a, &#34; x))
    (printf &#34;\n&#34;))

(define selectdata  &#39;(1 5 3 4 2))
(define groupdata   &#39;(2 5 2 4 2))
(define nestdata    &#39;((2 5)(2 4)(3 5)(3 1)(1 1)))


(define a (from x in selectdata select x))

(print-list a)

(define a2 (from x in (from y in selectdata select (+ y 1))
            select (- x 1)))

(print-list a2)

(define b (from x in selectdata 
           where (even? x) 
           select x))

(print-list b)

(define c (from x in selectdata 
           orderby x 
           select x))

(print-list c)

(define d (from x in selectdata 
           orderby x descending 
           select x))

(print-list d)

(define e (from x in selectdata
where (odd? x)
orderby x
select x))

(print-list e)

(define f ( from x in selectdata
let y = (* x x)
select y))

(print-list f)

(define f2 (from x in selectdata 
            let y = (* x x)
            where (odd? y)
            orderby y descending
            select y))

(print-list f2)

(define g (from x in selectdata
           select x into z
           select z))

(print-list g)

(define h (from x in nestdata
           from y in x
           select y))

(print-list h)

(define i (from x in nestdata
           where (= (car x) 2)
           from y in x
           select y))

(print-list i)

(define j (from x in nestdata
           orderby (car x)
           from y in x
           select y))

(print-list j)

(define k (from x in nestdata
           from y in x
           orderby y
           select y))

(print-list k)

(define l (from x in nestdata
           select x into y
           from z in y
           select z))

(print-list l)

(define m (from x in nestdata
           group (car x) by (cadr x)))

(print-list m)

(define n (from x in nestdata
           group (cadr x) by (car x)))

(print-list n)

(define o (from x in nestdata
           group (cadr x) by (car x) into z
           select z))

(print-list o)

(define p (from x in nestdata
           group (cadr x) by (car x) into z
           orderby (key z) descending
           select z))

(print-list p)

(define q (from x in selectdata
           join y in groupdata on x equals y into z
           from w in z
           select w))

(print-list q)

(define r (from x in selectdata
           join y in groupdata on x equals y
           select (cons x y)))

(print-list r)

(define s (from x in selectdata
           from y in groupdata
           where (and (= x 4) (= y 2))
           select (cons x y)))

(print-list s)

(define t (from x in selectdata
           join y in groupdata on x equals y into z
           orderby x
           select z))

(print-list t)

(define u (from x in selectdata
           join y in groupdata on x equals y into z
           orderby x
           select (cons x z)))

(print-list u)

(define v (from x in selectdata
           from y in groupdata
           select y into z
           where (even? z)
           select z))

(print-list v)

</code></pre>
<h2 id="i-said-all-that-so-i-can-say-this">I Said All That So I Can Say This…</h2>
<p>This novel combination of a proven functional programming language designed from the ground-up for metaprogramming with the vast ecosystem of the .NET Runtime in all its incarnations means that Office solution developers suddenly have access to two broad and deep solution spaces that previously were unavailable.</p>
<p>The sturdy yet shape-shifting Scheme language offers a way to harness and control the raw power of the Common Language Runtime. It will be exciting to see how industrious Office power users, VBA coders, Schemers, and .NET developers work together to leverage it and achieve greater returns for themselves and their clients.</p>




</div></div>
  </body>
</html>
