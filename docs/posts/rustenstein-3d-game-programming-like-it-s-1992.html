<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tech.nextroll.com/blog/dev/2022/02/02/rustenstein.html">Original</a>
    <h1>Rustenstein 3D: Game programming like it&#39;s 1992</h1>
    
    <div id="readability-page-1" class="page"><article id="blog-post"> <div> <header> <h2>Rustenstein 3D: Game programming like it&#39;s 1992</h2> <p><img src="https://tech.nextroll.com/images/authors/facundo_olano.png" alt="Facundo Olano" width="44" height="44"/> Written by , February 02, 2022 </p> </header> <p>Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice. It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company. You can learn all about Hack Week <a href="https://tech.nextroll.com/blog/culture/2019/11/26/hackweek-at-nextroll.html">here</a>.</p> <p>As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it. Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects. Last year, a group of us worked on extending my <a href="https://github.com/facundoolano/rpg-cli/">rpg-cli game</a>. This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability. And so we decided to port the classic <a href="https://en.wikipedia.org/wiki/Wolfenstein_3D">Wolfenstein 3D game</a> to Rust.</p>  <p>id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality. Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles. <a href="https://en.wikipedia.org/wiki/Masters_of_Doom">Masters of Doom</a> by David Kushner tells the story; Fabien Sanglard’s <a href="https://fabiensanglard.net/gebb/index.html">Game Engine black books</a> explains the technical details.</p> <center> <img alt="The Game Engine Black Book" src="https://tech.nextroll.com/images/post_images/rustestein/book.png"/> </center> <p>Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general. In addition, because its technology is more primitive, the source code is more approachable for study and implementation. The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called <em>Ray Casting</em>. All the drawing is done by directly putting pixels on the screen.</p> <p>A few years ago, after reading the Wolfenstein black book, I spent some time trying to <a href="https://github.com/facundoolano/wolf4py">port it to Python</a>, based on another modern port, <a href="https://github.com/facundoolano/wolf4sdl">wolf4sdl</a>. I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project. More recently, <a href="https://github.com/Oppen">Mario Rugiero</a>, who also read the book, proposed a Rust port as a project for this Hack Week. Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before. We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.</p>  <p>We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:</p> <ul> <li>graphic files decompression and parsing</li> <li>map files decompression, parsing and interpretation</li> <li>SDL graphic manipulation and texture rendering</li> <li>ray casting</li> <li>game loop and input management</li> <li>world rendering</li> </ul> <p>In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc. This allowed us to make progress in parallel.</p> <h2 id="assets">Assets</h2> <p>The first task of porting the game is to read its data. Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps. One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods. For Rustenstein, we used the .WL1 files of the shareware version, which we <a href="https://github.com/AdRoll/rustenstein/tree/main/shareware">included in the repository</a>.</p> <p>Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:</p> <ul> <li>the traditional <a href="https://moddingwiki.shikadi.net/wiki/Huffman_Compression">Huffman compression</a></li> <li><a href="https://moddingwiki.shikadi.net/wiki/Id_Software_RLEW_compression">RLEW compression</a>, a run-length encoding algorithm that works at the word level</li> <li>a <a href="https://moddingwiki.shikadi.net/wiki/Carmack_compression">“Carmack”</a> compression, which is John Carmack’s variant of the LZ (Lempel-Ziv) method. According to the Black Book, without much access to the literature, Carmack would “invent” an algorithm to later find out that someone else had done it before.</li> </ul> <p>The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C <code>malloc</code>) as well as a Page Manager to move assets from disk to RAM. Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.</p> <p>Parsing and decompression code can be found <a href="https://github.com/AdRoll/rustenstein/blob/3c4452b38dad2ba0f5f3d2c07209b89bd61e50c2/src/map_parser.rs">here</a> for maps, and <a href="https://github.com/AdRoll/rustenstein/blob/3c4452b38dad2ba0f5f3d2c07209b89bd61e50c2/src/cache.rs">here</a> for the rest of the assets.</p> <h2 id="maps">Maps</h2> <p>Wolfenstein 3D maps are defined as 64x64 grids of tiles. Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items. The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc. All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.</p> <p>Below is the first map of the first episode, as seen in a Wolfenstein map editor:</p> <center> <img alt="E1M1 viewed on an editor" src="https://tech.nextroll.com/images/post_images/rustestein/map1.png"/> </center> <p>And the same map as ASCII, as printed by our debugging code:</p> <div><pre><code>WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWW           WWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW    WWWWWWWWWWWWWWWWWWW           WWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW    WWWWWWWW          W           W   WWWWWWWWWWWWWWWWWWWW
WWWWWW     WWWWWWW          |           | W WWWWWWWWWWWWWWWWWWWW
WWWWWW     WWWWWWW          W           W   WWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWW   WWWWWWWW           WWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         WWW   WWWWWWWW           WWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         WWW   WWWWWWWWWWWWW-WWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         W       WWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         |       WWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         W       WWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWW         WWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WW         WWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WWWWWW-WWWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WWWWW   WWWWWWWWWWWWWWWW  WW      WWWWWWWWWWWWWWWWWWWWWWWWWW
WW-WWWWWW   WWWWWWWWWWWWWWWW  WWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WWWWW   WWWWWWWWWWWWWWWW  WWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   W   W   WWWWWWWWWWWWWWWW  WWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W       W   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   W   W   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WWWWWW-WWWWWWWWWWWWWWWWWWWWWWW-WWWWWWWWWWWWWWWWWWWWWWWWWWWWW
W   WW         WWWWWWWWWWWWWWWWW     WWWWWWWWWWWWWWWWW        WW
W   WW         WWWWWWWWWWWW               WWWWWWWWWWWW        WW
W   WW         WWWWWWWWWWWW               WWWWWWWWWWWW        WW
W    W         WWWWWWWWWWWW                W         W        WW
W    |         WWWWWWWWWWWW                |         |        WW
W    W         WWWWWWWWWWWW                W         W        WW
W   WW         WWWWWWWWWWWW               WWWW    WWWW        WW
W   WW         WWWWWWWWWWWW               WWWWW  WWWWW        WW
W   WW         WWWWWWWWWWWWWWWWW     WWWWWWWWWW  WWWWW        WW
W   WWWWWW-WWWWWWWWWWWWWWWWWWWWWWW-WWWWWWWWWWWW  WWWWWWW WW WWWW
W   WWWWW   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW  WWWWWWWWWWWWWWW
W   WWWWW   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW  WWWWWWWWWWWWWWW
W   W   W   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW  WWWWWWWWWWWWWWW
W       W   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW  WWW W W W WWWWW
W   W   W   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW   W         WWWW
W   WWWWW   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW   |         WWWW
W   WWWWW   WWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWW   W         WWWW
W                W      WWWWWWWWW   WWWWWWWWWWWWWWWW W W W WWWWW
W                |      W WWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
W                W     WWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWW  W  W  WWWWWWWWWWWWWW-WWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWW W  W  W WWWWWWWWW    W   W    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWW     WWWWWWWWWWW    |   |    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW    W   W    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWW  WWWWWWWWWWWWW    W   W    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWW  WWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW    W   W    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW P  |   |    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW    W   W    WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW   WWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW             WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW             WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWW             WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
</code></pre> </div>  <h2 id="pixel-drawing">Pixel drawing</h2> <p>For the graphic assets, decompressing and loading the data to memory is just half of the story. The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for. This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.</p> <p>Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D. The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in <a href="http://sandervanderburg.blogspot.com/2014/05/rendering-8-bit-palettized-surfaces-in.html">this blog post</a>. Since the <a href="https://github.com/Rust-SDL2/rust-sdl2">Rust bindings for SDL</a> use a different set of abstractions (and, in particular, they don’t expose the <a href="https://wiki.libsdl.org/SDL_ConvertPixels">SDL_ConvertPixels</a> function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas. This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.</p> <div><pre><code><span>fn</span> <span>put_pixel</span><span>(</span><span>buffer</span><span>:</span> <span>&amp;</span><span>mut</span> <span>[</span><span>u8</span><span>],</span> <span>pitch</span><span>:</span> <span>usize</span><span>,</span> <span>x</span><span>:</span> <span>u32</span><span>,</span> <span>y</span><span>:</span> <span>u32</span><span>,</span> <span>color</span><span>:</span> <span>(</span><span>u8</span><span>,</span> <span>u8</span><span>,</span> <span>u8</span><span>))</span> <span>{</span>
    <span>let</span> <span>(</span><span>r</span><span>,</span> <span>g</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>color</span><span>;</span>
    <span>let</span> <span>offset</span> <span>=</span> <span>y</span> <span>as</span> <span>usize</span> <span>*</span> <span>pitch</span> <span>+</span> <span>x</span> <span>as</span> <span>usize</span> <span>*</span> <span>3</span><span>;</span>
    <span>buffer</span><span>[</span><span>offset</span><span>]</span> <span>=</span> <span>r</span><span>;</span>
    <span>buffer</span><span>[</span><span>offset</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>g</span><span>;</span>
    <span>buffer</span><span>[</span><span>offset</span> <span>+</span> <span>2</span><span>]</span> <span>=</span> <span>b</span><span>;</span>
<span>}</span>
</code></pre> </div>  <p>The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork. The first routine handles displaying a full image directly to the screen. This is used for the title screen as well as the player status bar at the bottom of the in-game view:</p> <div><pre><code><span>fn</span> <span>draw_to_texture</span><span>(</span><span>texture</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Texture</span><span>,</span> <span>pic</span><span>:</span> <span>&amp;</span><span>Picture</span><span>,</span> <span>color_map</span><span>:</span> <span>ColorMap</span><span>)</span> <span>{</span>
    <span>texture</span><span>.with_lock</span><span>(</span><span>None</span><span>,</span> <span>|</span><span>buffer</span><span>:</span> <span>&amp;</span><span>mut</span> <span>[</span><span>u8</span><span>],</span> <span>pitch</span><span>:</span> <span>usize</span><span>|</span> <span>{</span>
        <span>for</span> <span>y</span> <span>in</span> <span>0</span><span>.</span><span>.pic.height</span> <span>{</span>
            <span>for</span> <span>x</span> <span>in</span> <span>0</span><span>.</span><span>.pic.width</span> <span>{</span>
                <span>let</span> <span>source_index</span> <span>=</span>
                    <span>(</span><span>y</span> <span>*</span> <span>(</span><span>pic</span><span>.width</span> <span>&gt;&gt;</span> <span>2</span><span>)</span> <span>+</span> <span>(</span><span>x</span> <span>&gt;&gt;</span> <span>2</span><span>))</span> <span>+</span> <span>(</span><span>x</span> <span>&amp;</span> <span>3</span><span>)</span> <span>*</span> <span>(</span><span>pic</span><span>.width</span> <span>&gt;&gt;</span> <span>2</span><span>)</span> <span>*</span> <span>pic</span><span>.height</span><span>;</span>
                <span>let</span> <span>color</span> <span>=</span> <span>pic</span><span>.data</span><span>[</span><span>source_index</span> <span>as</span> <span>usize</span><span>];</span>
                <span>put_pixel</span><span>(</span><span>buffer</span><span>,</span> <span>pitch</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>color_map</span><span>[</span><span>color</span> <span>as</span> <span>usize</span><span>]);</span>
            <span>}</span>
        <span>}</span>
    <span>});</span>
<span>}</span>
</code></pre> </div>  <center> <img alt="The Game Engine Black Book" src="https://tech.nextroll.com/images/post_images/rustestein/titlepic.png"/> </center> <p>The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon. A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.</p> <center> <img alt="Doge weapon" src="https://tech.nextroll.com/images/post_images/rustestein/doge.png"/> <i>An unexpected sprite appeared instead of the weapon during development.</i> </center> <p>It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.</p> <p>The related code can be found <a href="https://github.com/AdRoll/rustenstein/blob/3c4452b38dad2ba0f5f3d2c07209b89bd61e50c2/src/main.rs#L194-L332">here</a>.</p> <h2 id="ray-casting">Ray Casting</h2> <p>At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm. This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations. The algorithm can be summarized as follows:</p> <ol> <li>Cast a ray from the player’s current position for each pixel column in the screen width. For example, the classical Wolfenstein 3D resolution is 320x200, so this means casting 320 rays to draw a frame.</li> <li>Extend the ray in a direction determined by the current horizontal pixel, the player’s position and its field of view, until it hits a wall in the map. Because the walls are rectangular, the calculations to extend the rays are greatly simplified, since there’s a constant distance between a tile and the next.</li> <li>Once the ray intersects a wall, calculate the distance from the player to that wall, using trigonometry.</li> <li>Set a height for the wall, inversely proportional to the calculated distance. This is: the further the wall the ray hits is from the player, the smaller the wall looks from the player’s perspective (and the smaller the column of pixels we will need to draw on the screen).</li> </ol> <center> <img alt="Sample raycast map" src="https://tech.nextroll.com/images/post_images/rustestein/raycast1.gif"/> </center> <p>Below is a simplified JavaScript version of the algorithm, based on <a href="https://github.com/vinibiavatti1/RayCastingTutorial">this tutorial</a>:</p> <div><pre><code><span>function</span> <span>rayCasting</span><span>(</span><span>screen</span><span>,</span> <span>map</span><span>,</span> <span>player</span><span>)</span> <span>{</span>
  <span>let</span> <span>precision</span> <span>=</span> <span>64</span><span>;</span>
  <span>let</span> <span>incrementAngle</span> <span>=</span> <span>player</span><span>.</span><span>fieldOfView</span> <span>/</span> <span>screen</span><span>.</span><span>width</span><span>;</span>

  <span>let</span> <span>wallHeights</span> <span>=</span> <span>[];</span>
  <span>let</span> <span>rayAngle</span> <span>=</span> <span>player</span><span>.</span><span>angle</span> <span>-</span> <span>player</span><span>.</span><span>fieldOfView</span> <span>/</span> <span>2</span><span>;</span>
  <span>for</span><span>(</span><span>let</span> <span>rayCount</span> <span>=</span> <span>0</span><span>;</span> <span>rayCount</span> <span>&lt;</span> <span>screen</span><span>.</span><span>width</span><span>;</span> <span>rayCount</span><span>++</span><span>)</span> <span>{</span>

    <span>// start the ray at the player position</span>
    <span>let</span> <span>ray</span> <span>=</span> <span>{</span>
      <span>x</span><span>:</span> <span>player</span><span>.</span><span>x</span><span>,</span>
      <span>y</span><span>:</span> <span>player</span><span>.</span><span>y</span>
    <span>};</span>

    <span>// the ray moves at constant increments</span>
    <span>let</span> <span>rayCos</span> <span>=</span> <span>Math</span><span>.</span><span>cos</span><span>(</span><span>degreeToRadians</span><span>(</span><span>rayAngle</span><span>))</span> <span>/</span> <span>precision</span><span>;</span>
    <span>let</span> <span>raySin</span> <span>=</span> <span>Math</span><span>.</span><span>sin</span><span>(</span><span>degreeToRadians</span><span>(</span><span>rayAngle</span><span>))</span> <span>/</span> <span>precision</span><span>;</span>

    <span>// advance the ray until it finds a wall (a non zero tile)</span>
    <span>let</span> <span>wall</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span><span>(</span><span>wall</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
      <span>ray</span><span>.</span><span>x</span> <span>+=</span> <span>rayCos</span><span>;</span>
      <span>ray</span><span>.</span><span>y</span> <span>+=</span> <span>raySin</span><span>;</span>
      <span>wall</span> <span>=</span> <span>map</span><span>[</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>ray</span><span>.</span><span>y</span><span>)][</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>ray</span><span>.</span><span>x</span><span>)];</span>
    <span>}</span>

    <span>// calculate the distance from the player to the wall hit</span>
    <span>let</span> <span>distance</span> <span>=</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span><span>Math</span><span>.</span><span>pow</span><span>(</span><span>player</span><span>.</span><span>x</span> <span>-</span> <span>ray</span><span>.</span><span>x</span><span>,</span> <span>2</span><span>)</span> <span>+</span> <span>Math</span><span>.</span><span>pow</span><span>(</span><span>player</span><span>.</span><span>y</span> <span>-</span> <span>ray</span><span>.</span><span>y</span><span>,</span> <span>2</span><span>));</span>

    <span>// calculate height at current x inversely proportional to the distance</span>
    <span>wallHeights</span><span>.</span><span>push</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>screen</span><span>.</span><span>halfHeight</span> <span>/</span> <span>distance</span><span>));</span>

    <span>// increment the angle for the next ray</span>
    <span>rayAngle</span> <span>+=</span> <span>incrementAngle</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>wallHeights</span><span>;</span>
<span>}</span>
</code></pre> </div>  <p>For a ray casting implementation closer to the original Wolfenstein 3D one, <a href="https://lodev.org/cgtutor/raycasting.html">this series of tutorials</a> is recommended.</p> <p>This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time. First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures. Second, <a href="https://github.com/qhool">Josh Burroughs</a> figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on <code>goto</code> statements and had a lot of global side-effects in addition to calculating wall heights).</p> <p>Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:</p> <center> <img alt="E1M1 as viewed from the ray casting routine" src="https://tech.nextroll.com/images/post_images/rustestein/mapcast.png"/> </center> <p>The full implementation can be found <a href="https://github.com/AdRoll/rustenstein/blob/3c4452b38dad2ba0f5f3d2c07209b89bd61e50c2/src/ray_caster.rs">here</a>.</p> <h2 id="world-rendering">World Rendering</h2> <p>The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color. After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate. While the algorithm was still in development, we tested the rendering code with hard-coded walls:</p> <center> <img alt="Doge weapon" src="https://tech.nextroll.com/images/post_images/rustestein/hardcoded.png"/> </center> <p>Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:</p> <center> <img alt="Doge weapon" src="https://tech.nextroll.com/images/post_images/rustestein/noshadow.png"/> </center> <p>Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:</p> <center> <img alt="Doge weapon" src="https://tech.nextroll.com/images/post_images/rustestein/start.png"/> </center> <p>The <a href="[here](https://github.com/AdRoll/rustenstein/blob/3c4452b38dad2ba0f5f3d2c07209b89bd61e50c2/src/main.rs#L99-L145)">world rendering code</a>, then, looks like this:</p> <div><pre><code><span>texture</span>
 <span>.with_lock</span><span>(</span><span>None</span><span>,</span> <span>|</span><span>buffer</span><span>:</span> <span>&amp;</span><span>mut</span> <span>[</span><span>u8</span><span>],</span> <span>pitch</span><span>:</span> <span>usize</span><span>|</span> <span>{</span>
     <span>// draw floor and ceiling colors</span>
     <span>let</span> <span>floor</span> <span>=</span> <span>color_map</span><span>[</span><span>VGA_FLOOR_COLOR</span><span>];</span>
     <span>let</span> <span>ceiling</span> <span>=</span> <span>color_map</span><span>[</span><span>VGA_CEILING_COLOR</span><span>];</span>
     <span>let</span> <span>vm</span> <span>=</span> <span>view_height</span> <span>/</span> <span>6</span><span>;</span>

     <span>for</span> <span>x</span> <span>in</span> <span>0</span><span>.</span><span>.pix_width</span> <span>{</span>
         <span>for</span> <span>y</span> <span>in</span> <span>0</span><span>.</span><span>.pix_height</span> <span>/</span> <span>2</span> <span>{</span>
             <span>let</span> <span>ceilings</span> <span>=</span> <span>darken_color</span><span>(</span><span>ceiling</span><span>,</span> <span>vm</span> <span>-</span> <span>y</span><span>,</span> <span>pix_center</span><span>);</span>
             <span>put_pixel</span><span>(</span><span>buffer</span><span>,</span> <span>pitch</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>ceilings</span><span>);</span>
         <span>}</span>
         <span>for</span> <span>y</span> <span>in</span> <span>pix_height</span> <span>/</span> <span>2</span><span>.</span><span>.pix_height</span> <span>{</span>
             <span>let</span> <span>floors</span> <span>=</span> <span>darken_color</span><span>(</span><span>floor</span><span>,</span> <span>y</span> <span>-</span> <span>vm</span><span>,</span> <span>pix_center</span><span>);</span>
             <span>put_pixel</span><span>(</span><span>buffer</span><span>,</span> <span>pitch</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>floors</span><span>);</span>
         <span>}</span>
     <span>}</span>

     <span>for</span> <span>x</span> <span>in</span> <span>0</span><span>.</span><span>.pix_width</span> <span>{</span>
         <span>// use different colors for horizontal and vertical wall faces</span>
         <span>let</span> <span>mut</span> <span>color</span> <span>=</span> <span>if</span> <span>ray_hits</span><span>[</span><span>x</span> <span>as</span> <span>usize</span><span>]</span><span>.horizontal</span> <span>{</span>
             <span>color_map</span><span>[</span><span>150</span><span>]</span>
         <span>}</span> <span>else</span> <span>{</span>
             <span>color_map</span><span>[</span><span>155</span><span>]</span>
         <span>};</span>

         <span>let</span> <span>current</span> <span>=</span> <span>min</span><span>(</span><span>ray_hits</span><span>[</span><span>x</span> <span>as</span> <span>usize</span><span>]</span><span>.height</span><span>,</span> <span>pix_center</span><span>);</span>
         <span>color</span> <span>=</span> <span>darken_color</span><span>(</span><span>color</span><span>,</span> <span>current</span><span>,</span> <span>pix_center</span><span>);</span>

         <span>for</span> <span>y</span> <span>in</span> <span>pix_center</span> <span>-</span> <span>current</span><span>.</span><span>.pix_center</span> <span>+</span> <span>current</span> <span>{</span>
             <span>put_pixel</span><span>(</span><span>buffer</span><span>,</span> <span>pitch</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>color</span><span>);</span>
         <span>}</span>
     <span>}</span>
 <span>})</span>

<span>fn</span> <span>darken_color</span><span>(</span><span>color</span><span>:</span> <span>(</span><span>u8</span><span>,</span><span>u8</span><span>,</span><span>u8</span><span>),</span> <span>lightness</span><span>:</span> <span>u32</span><span>,</span> <span>max</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>(</span><span>u8</span><span>,</span><span>u8</span><span>,</span><span>u8</span><span>)</span> <span>{</span>
    <span>let</span> <span>(</span><span>r</span><span>,</span><span>g</span><span>,</span> <span>b</span><span>)</span> <span>=</span>  <span>color</span><span>;</span>
    <span>let</span> <span>factor</span> <span>=</span> <span>lightness</span> <span>as</span> <span>f64</span> <span>/</span> <span>max</span> <span>as</span> <span>f64</span> <span>/</span> <span>DARKNESS</span><span>;</span>
    <span>let</span> <span>rs</span> <span>=</span> <span>(</span><span>r</span> <span>as</span> <span>f64</span> <span>*</span> <span>factor</span><span>)</span> <span>as</span> <span>u8</span><span>;</span>
    <span>let</span> <span>gs</span> <span>=</span> <span>(</span><span>g</span> <span>as</span> <span>f64</span> <span>*</span> <span>factor</span><span>)</span> <span>as</span> <span>u8</span><span>;</span>
    <span>let</span> <span>bs</span> <span>=</span> <span>(</span><span>b</span> <span>as</span> <span>f64</span> <span>*</span> <span>factor</span><span>)</span> <span>as</span> <span>u8</span><span>;</span>
    <span>(</span><span>rs</span><span>,</span> <span>gs</span><span>,</span> <span>bs</span><span>)</span>
<span>}</span>
</code></pre> </div>   <p>A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project. In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session. We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.</p> <p>This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before. During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own. And the project ended up winning the technical award of the event!</p> <center> <img alt="Doge weapon" src="https://tech.nextroll.com/images/post_images/rustestein/gameplay.gif"/> </center> <p>The prototype is now <a href="https://github.com/AdRoll/rustenstein">published as open-source</a>, although, as said, the code still needs significant clean-up. Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it. Some of the features that we could tackle next are:</p> <ul> <li>Rendering wall textures</li> <li>Show and pick up items</li> <li>Add enemies to the map, implement combat and enemy AI</li> <li>Implement doors and keys</li> <li>Implement push walls</li> </ul>   </div> </article></div>
  </body>
</html>
