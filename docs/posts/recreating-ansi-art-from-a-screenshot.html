<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bert.org/2023/02/27/recreating-ansi-art-from-a-screenshot/">Original</a>
    <h1>Recreating ANSI Art from a Screenshot</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>In the early to mid-90s, I ran a BBS out of my bedroom. It wasn’t very popular, but I did have a lot of time on my hands and I spent a lot of that time modding it. Initially, I wrote mods for myself, but eventually I started releasing them to other people. As a teenager, this was the first software that I wrote that other people used. This was my contribution to “the scene” and now my only claim to fame from that time is that I’m part of the final member list of <a href="https://www.acid.org/members/members.html">ACiD Productions</a> under BBS Modifications.</p>

<p>During this era, I asked one of my users to create some ANSI art for me:</p>

<p><img src="https://bert.org/assets/posts/ansi/ask.jpg" alt="me asking someone to create ansi art"/></p>

<p>And they agreed!</p>

<p><img src="https://bert.org/assets/posts/ansi/agree.jpg" alt="user agreeing to create ansi art"/></p>

<p>11 days later, they uploaded the ANSI art to my BBS.</p>

<p><img src="https://bert.org/assets/posts/ansi/deliver.jpg" alt="delivering the ansi art"/></p>

<p>You may be wondering what the deal with these Windows XP-era screenshots is. Well, I used to backup my BBS with a Colorado Tape Backup drive. Here’s a picture of one I found on the Internet:</p>

<p><img src="https://bert.org/assets/posts/ansi/tape_backup.jpg" alt="colorado tape backup"/></p>

<p>In 2001, I found a 250 MB tape that was the last backup of my old BBS and restored it to my computer. Feeling nostalgic, I logged in to it locally and took a few screenshots. When I first logged-in to it, it displayed the ANSI art that my user had made for me:</p>

<p><img src="https://bert.org/assets/posts/ansi/initial.png" alt="screenshot of ansi art"/></p>

<p>It scrolled by pretty fast, so I took a series of screenshots of it and then used Photoshop to combine them. I made a little webpage for it so I could look at it every now and then and went on with my life.</p>

<p>Shortly after this, my hard drive died. I think it was an <a href="https://en.wikipedia.org/wiki/Deskstar">IBM Deathstar</a>. I have no idea what happened to the 250 MB tape, but I think it’s safe to say that even if I do find it, it probably isn’t going to work.</p>

<p>Luckily, thanks to the power of the web, I still have these screenshots. Unluckily, I never actually uploaded the original ANSI file, so I don’t have that. Every now and then I’ll search for it on the Internet, but I’ve concluded that it never made it into an artpack and thus I had the only copy of it, until I didn’t.</p>

<p>It’s not the most beautiful ANSI art, but it is something that someone made for me and I’ve always been a little bummed that I can’t look at it in one of the many ANSI viewers (or DOS emulators) that exist today.</p>

<p>Let’s fix that!</p>

<p>The first thing to understand about ANSI art is that it combines two things: characters from the <a href="https://en.wikipedia.org/wiki/Code_page_437">IBM Code page 437</a> and <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape sequences</a> that do things like change colors and move the cursor around.</p>

<p>I found this extremely <a href="http://codelobe.com/tools/cp437-character-map">handy page</a> that shows all the different characters in Codepage 437.</p>

<p><img src="https://bert.org/assets/posts/ansi/codepage437.png" alt="Codepage 437"/></p>

<p>Characters #0 - #31 are control characters, and #127 is DEL, so we can ignore those. The rest of them are used in ANSI art, although the shade blocks and half blocks are predominately used.</p>

<p>The way that you would type one of these weird characters on an IBM PC is that you could hold down ALT and type the ASCII code on your numpad. When you released ALT, the character would show up. But most artists would use a program like <a href="https://en.wikipedia.org/wiki/TheDraw">TheDraw</a> or ACiDDraw to design their art.</p>

<p>Speaking of TheDraw, let’s take a look at the color selection screen from it:</p>

<p><img src="https://bert.org/assets/posts/ansi/thedraw.png" alt="TheDraw color selection screen"/></p>

<p>There are sixteen foreground colors and eight background colors. Ignore 16-31, I captured this screenshot mid-blink.</p>

<p>Changing the foreground and background colors and writing the characters from Codepage 437 produces the ANSI art that we know today:</p>

<figure>
    <img src="https://bert.org/assets/posts/ansi/LU-Holiday.ans.png" alt="LU-Holiday.ans by Luciano Ayres from Blocktronics Blockfury"/>
    <figcaption>LU-Holiday.ans by Luciano Ayres from Blocktronics Blockfury</figcaption>
</figure>

<p>To accurately display ANSI art, it’s important to use an appropriate IBM PC font, like <a href="https://int10h.org/oldschool-pc-fonts/fontlist/font?ibm_vga_8x16">this one</a>. This will ensure that your art looks the way that it was intended by the artist.</p>

<p>The strategy for conversion that I came up with was: split the screenshot into individual characters. For each character, generate every possible permutation of background color, foreground color, and character from Codepage 437 and compare it to the character in the screenshot, then pick the one that is the most similar.</p>

<p>There’s probably a lot of different ways to do this, but I figured the easiest would be to make a webpage and use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>.</p>

<p>As a test case, I used a program called <a href="https://www.ansilove.org/">ansilove</a> to take an existing <code>.ANS</code> file and generate a PNG of it. It even came with an example ANS file:</p>

<p><img src="https://bert.org/assets/posts/ansi/example_input.png" alt="example input"/></p>

<p>The image is 640x464. Assuming that we have a 8x16 font, this means that it contains 80x29 characters.</p>

<p>We create a canvas and load the image into it:</p>

<div><div><pre><code>const canvas = document.getElementById(&#34;canvas&#34;);
const ctx = canvas.getContext(&#34;2d&#34;, { willReadFrequently: true });

const img = new Image();
img.addEventListener(&#34;load&#34;, (e) =&gt; {
    ctx.drawImage(img, 0, 0);
});

img.src = &#39;input.png&#39;;
</code></pre></div></div>

<p>Next, we have to have a list of the foreground and background colors. I found that iTerm2 has a <a href="https://github.com/mbadolato/iTerm2-Color-Schemes/#cga">color scheme for CGA</a> that looks accurate, so I loaded it into iTerm and then extracted the hex codes from it, double-checking against the TheDraw color picker. This gave me two lists:</p>

<div><div><pre><code>var fgColors = [
    &#34;000000&#34;,
    &#34;aa0000&#34;,
    &#34;00aa00&#34;,
    &#34;aa5500&#34;,
    &#34;0000aa&#34;,
    &#34;aa00aa&#34;,
    &#34;00aaaa&#34;,
    &#34;aaaaaa&#34;,
    &#34;555555&#34;,
    &#34;ff5555&#34;,
    &#34;55ff55&#34;,
    &#34;ffff55&#34;,
    &#34;5555ff&#34;,
    &#34;ff55ff&#34;,
    &#34;55ffff&#34;,
    &#34;feffff&#34;
];

var bgColors = [
    &#34;000000&#34;,
    &#34;aa0000&#34;,
    &#34;00aa00&#34;,
    &#34;aa5500&#34;,
    &#34;0000aa&#34;,
    &#34;aa00aa&#34;,
    &#34;00aaaa&#34;,
    &#34;aaaaaa&#34;,
];
</code></pre></div></div>

<p>Now we need all the characters in the Codepage 437 to loop over. Luckily, Unicode provides a <a href="http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/PC/CP437.TXT">text file that translates all CP437 codes to their UTF-8 equivalents</a>.</p>

<p>I took this text file, removed the control characters and DEL, and created an array of their UTF-8 counterparts.</p>

<p>Then I created another canvas, looped over each background color, foreground color, and character, and wrote them to the canvas using the IBM PC font.</p>

<div><div><pre><code>const char1canvas = document.getElementById(&#34;char1&#34;);
const char1ctx = char1canvas.getContext(&#34;2d&#34;, { willReadFrequently: true });

char1ctx.fillStyle = &#34;#000000&#34;;
char1ctx.fillRect(0,0,8,16);

var imgData = [];

for (var i = 0; i &lt; bgColors.length; i++) {
    for (var j = 0; j &lt; fgColors.length; j++) {

        if (bgColors[i] == fgColors[j]) {
            continue;
        }

        for (var k = 0; k &lt; chars.length; k++) {

            char2ctx.fillStyle = &#34;#&#34; + bgColors[i];
            char2ctx.fillRect(0,0,8,16);

            char2ctx.fillStyle = &#34;#&#34; + fgColors[j];

            char2ctx.font = &#34;16px xx437&#34;;
            char2ctx.fillText(chars[k], 0, 12);

            if (!imgData[i]) {
                imgData[i] = [];
            }

            if (!imgData[i][j]) {
                imgData[i][j] = [];
            }

            imgData[i][j][k] = char2ctx.getImageData(0,0,8,16);

        }
    }
}
</code></pre></div></div>

<p>For some reason I had to offset the <code>fillText</code> by 12 pixels to get it to correctly write it to the canvas as I would expect. I have no idea why, but CSS has never been a strength of mine. After each time that we write the character, we store the image data of the result in a lookup table, by background color, foreground color, and character.</p>

<p>Next, we loop over each character section of the original image’s canvas and extract the image data of this section:</p>

<div><div><pre><code>for (var y = 0; y &lt;= 24; y++) {
    for (var x = 0; x &lt;= 79; x++) {
        char1ctx.drawImage(canvas, x*8, y*16, 8, 16, 0, 0, 8, 16);
        var imgChar1 = char1ctx.getImageData(0,0,8,16);
    }
}
</code></pre></div></div>

<p>I found a library called <a href="https://github.com/mapbox/pixelmatch">pixelmatch</a> that allows you to compare two sets of imagedata. It returns the number of mismatched pixels and if you want it, a diff of the two.</p>

<div><div><pre><code>var result = pixelmatch(imgChar1.data, imgChar2.data, null, 8, 16, {
    threshold: 0.1,
});
</code></pre></div></div>

<p>So then we can loop over every permutation of background color, foreground color, and character and compare it to the image’s character and pick the one that has the lowest number of mismatched pixels - ideally 0.</p>

<p>Next we create an output canvas and using the identified combinations for each character, write back the same ANSI art to that canvas:</p>

<p><img src="https://bert.org/assets/posts/ansi/example_compare.png" alt="example comparison"/></p>

<p>The image on the left is the input image and the image on the right is the generated ANSI art. It looks pretty good! The heart in the middle of <code>ANSI</code> and <code>LOVE</code> has been converted to a rectangular bullet - possibly because I excluded the control characters and the heart happened to be in them.</p>

<p>But this is only useful if we can generate the ANSI art file. Let’s go back to the ANSI escape codes:</p>

<p><code>\033[0m</code> resets everything back to normal.</p>

<p><code>\033[31m</code> will set the foreground to red. The possible colors are 30-37.</p>

<p><code>\033[44m</code> will set the background to blue. The possible colors are 40-47.</p>

<p>In order to get the bright foreground colors, we simply have to set the bold attribute, which we can use <code>\033[1m</code> to set. We just have to remember to use <code>\033[0m</code> to reset it after we’re done.</p>

<p>So for each character, we just always reset it, set the background color, set the foreground color, and optionally set bold. Then we write the character.</p>

<p>But if we just write this to a string, this will give us a file that contains ANSI escape codes but UTF-8 characters - we need to convert it to a DOS format.</p>

<p>There’s a useful package called <a href="https://github.com/ashtuchkin/iconv-lite">iconv-lite</a> that can encode different character encodings, so we can do something like:</p>

<div><div><pre><code>iconv.encode(ansiTxt, &#39;cp437&#39;);
</code></pre></div></div>

<p>I reverse engineered how this <a href="http://codelobe.com/tools/cp437-converter">CP437 converter</a> works to output the file and I thought the way that it downloaded it was pretty clever, so I incorporated it as well:</p>

<div><div><pre><code>var c = document.createElement(&#34;a&#34;);
c.href = &#34;data:text/plain;base64,&#34; + iconv.encode(ansiTxt, &#39;cp437&#39;).toString(&#39;base64&#39;);
c.download = &#39;output.ans&#39;;
document.body.appendChild(c);
c.click();
document.body.removeChild(c);
</code></pre></div></div>

<p>This automatically started downloading the ANS file with the correct encodings.</p>

<p>Finally, it was time to send my screenshot through it!</p>

<p>The screenshots that I had taken in 2001 were one screen at a time, or 80x25 characters. This was the first one:</p>

<p><img src="https://bert.org/assets/posts/ansi/MP-H&amp;C001.gif" alt="first screenshot"/></p>

<p>The dimensions were 560x300. But that means that each character was 7x12 instead of 8x16. And this is when I remembered that when I took the screenshots, I had taken them in a DOS window in Windows, which used whatever font that Windows used for DOS prompts. What if we just… resized the image so that each character was 8x16? I resized the image to 640x400, making sure to use “Nearest Neighbor” to try to keep the pixels correct, and it sort-of worked:</p>

<p><img src="https://bert.org/assets/posts/ansi/compare1.png" alt="first comparison"/></p>

<p>The text detection is laughably bad but it seemed to get the solid and half blocks - it was really mostly struggling with the shade blocks. There are only 3 shade blocks, 4 if you count the completely solid one.</p>

<p>I wrote an ANS file to output just three different shade blocks and exported an image of it using ansilove and it was clear - whatever font Windows was using for the DOS prompt had a completely different idea of what a shade block looked like than what the IBM PC font did.</p>

<p>Then I had an idea - what if I just taught my program what the weird Windows shade blocks looked like?</p>

<p>I zoomed in on the shade blocks in the screenshot and extracted one of each of the different types. From left to right, these represent light, medium, and heavy:</p>

<p><img src="https://bert.org/assets/posts/ansi/shade_blocks.png" alt="shade blocks"/></p>

<p>I loaded each one into a canvas and looped over each pixel. When I encountered red, I stored this as a 1 in a multi-dimensional array, and when I didn’t find red, I stored this as 0. Using this mapping, I again generated every permutation of background color, foreground color, and now these new shade blocks and stored their image data in a lookup table. When the image character matched it, I selected the appropriate shade block character.</p>

<p>And that worked! Here you can see the difference between the screenshot shade blocks and the actual shade blocks is quite stark:</p>

<p><img src="https://bert.org/assets/posts/ansi/compare2.png" alt="second comparison"/></p>

<p>Apparently I hadn’t seen what this ANSI art correctly looked like since the 90s. The text was still wrong, but I figured I could easily recreate it from the screenshots. So I started processing the other screenshots, which was working great until I got to this one:</p>

<p><img src="https://bert.org/assets/posts/ansi/compare3.png" alt="third comparison"/></p>

<p>The shading on the flames was completely gone, which meant that it more closely identified the character with the solid block than the shade block. That’s weird. I zoomed in closer to the block on the original screenshot. Here it is in the middle next to two of the original shade blocks that I mapped.</p>

<p><img src="https://bert.org/assets/posts/ansi/new_shade_block.png" alt="new shade block"/></p>

<p>It seemed to be very similar to the one of the left, but flipped. I’m not sure how it got flipped, maybe something to do with the screen capture or resizing process, but I used the same procedure to map it, storing a 1 for each red pixel and generating all the permutations, finally storing it in the lookup table, and I ran it again. And.. it got the same result.</p>

<p>I was starting to feel like I was going crazy when I remembered the TheDraw color selection screen:</p>

<p><img src="https://bert.org/assets/posts/ansi/thedraw.png" alt="TheDraw color selection screen"/></p>

<p>There are two foreground colors, brown and yellow. Yellow is the bold version of brown. But there is only one background color, which happens to be brown. It dawned on me that what I was looking at was not a red shade block on yellow, but a yellow shade block on red. It really makes you appreciate the constraints of the 90s ANSI artist. After retraining it to look for yellow pixels, it correctly identified the block.</p>

<p>The text was still a garbage fire, but when I combined the ANSI files in <a href="https://en.wikipedia.org/wiki/PabloDraw">Pablodraw</a>, I just retyped it.</p>

<p>Here’s what it looked like after I cleaned it up:</p>

<p><img src="https://bert.org/assets/posts/ansi/final.png" alt="final output"/></p>

<p>And here is the ANSI file: <a href="https://bert.org/assets/posts/ansi/mp-h&amp;c.ans">mp-h&amp;c.ans</a>.</p>

<p>You can view in something like <a href="https://github.com/nrlquaker/nfov">nfov</a> or <a href="https://en.wikipedia.org/wiki/PabloDraw">Pablodraw</a>, or even <code>iconv -f 437 mp-h\&amp;c.ans</code> if you’ve got the correct <a href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/CGA.itermcolors">colors</a> and <a href="https://int10h.org/oldschool-pc-fonts/fontlist/font?ibm_vga_8x16">font</a> set up in your terminal.</p>

<p>I don’t intend on losing it again.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
