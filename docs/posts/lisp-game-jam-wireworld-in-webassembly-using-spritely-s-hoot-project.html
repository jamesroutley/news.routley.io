<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spritely.institute/news/hoot-wireworld-live-in-browser.html">Original</a>
    <h1>Lisp Game Jam – “Wireworld” in WebAssembly Using Spritely&#39;s Hoot Project</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://spritely.institute/static/images/blog/wireworld-splash.gif" alt="Wireworld + splash screen"/></p><p>This blogpost focuses on our second <a href="https://itch.io/jam/spring-lisp-game-jam-2023">Spring Lisp Game Jam 2023</a> entry,
<a href="https://gitlab.com/spritely/wasm4-wireworld/">wasm4-wireworld</a>,
an implementation of
<a href="https://en.wikipedia.org/wiki/Wireworld">Wireworld</a> on top of
<a href="https://gitlab.com/spritely/guile-hoot">Hoot</a>&#39;s lower-level assembly
tools which are a part of our <a href="https://spritely.institute/news/guile-on-web-assembly-project-underway.html">Guile → WASM</a> project to bring <a href="https://spritely.institute/goblins/">Spritely Goblins</a>-powered distributed applications to the common web browser.</p><p>For our entry, we targeted <a href="https://wasm4.org/">WASM-4</a>, a &#34;fantasy console&#34; which uses low-level WebAssembly constructs.</p><p>In fact, if you see the animated &#34;wireworld&#34; splash screen at the top
of this article, that&#39;s running wasm-wireworld itself... you can even
<a href="https://spritely.institute/static/embed/wireworld-splash.wasm4.html">run it live in your browser</a>!</p><h2>A brief intro to Wireworld</h2><p>The real point of this blogpost isn&#39;t Wireworld itself, but how
Hoot enabled making this Wireworld demo.
So we&#39;re going to walk into how Hoot turned out to be an incredible
toolkit to build this game jam entry, but first let&#39;s talk about
Wireworld to give some more context!</p><p>Wireworld is a powerful cellular automata, categorically similar to
<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&#39;s Game of Life</a>.
Unlike Life, Wireworld&#39;s paths are fixed: &#34;electrons&#34; flow upon copper
wires.
The rules of Wireworld are very simple:</p><ul><li>Blank tiles remain blank</li><li>Electron heads always become electron tails</li><li>Electron tails always become copper</li><li>Copper stays copper, <em>unless</em> there are one or two electron heads in any cardinal direction, in which case it becomes an electron head</li></ul><p>That&#39;s it!  Despite that simplicity, this leads to powerful emergent
behavior.
Electron head and tail pairs appear to &#34;flow&#34; fluidly upon copper
wires and can branch easily.
But we can also make &#34;generators&#34; and diodes that only permit
electrons to flow in one direction and not another:</p><p><img src="https://spritely.institute/static/images/blog/wireworld-intro.gif" alt="Wireworld + intro"/></p><p>(<a href="https://spritely.institute/static/embed/wireworld-intro.wasm4.html">Try it live!</a>)</p><p>These rules result in behavior which permits visually stunning examples,
many of which even <em>look</em> like computational circuitry.</p><p>Below is a
<a href="https://www.quinapalus.com/wires8.html">&#34;binary adder&#34; circuit</a>
running our implementation of Wireworld.</p><p><img src="https://spritely.institute/static/images/blog/wireworld-adder.gif" alt="Wireworld + binary adder"/></p><p>Encoded in little endian, 3 (011) + 6 (110) = 9 (1001)!
(And here&#39;s the <a href="https://spritely.institute/static/embed/wireworld-adder.wasm4.html">live version</a>...
press the &#34;x&#34; button to start the simulation when you&#39;re ready!)</p><p>If you find this kind of thing delightful, see
<a href="https://www.quinapalus.com/wi-index.html">The Wireworld Computer</a>
for a tutorial that uses Wireworld to build from the simplest elements
all the way up to a computer that can calculate prime numbers.</p><h3>Try Wireworld yourself!</h3><p>While building a cool version of Wireworld wasn&#39;t the <em>real</em> goal
of our participation in the game jam, it was a lot of fun to build...
and we hope it&#39;s fun to use and play with, too!
And since you&#39;re reading this in a web browser and we&#39;re using
Webassembly anyway, why not try playing with Wireworld right here
in the browser?</p><p>You can click to place wires and electron heads/tails and press X
to start/stop the emulation.  Enjoy!</p><h2>Insights from using Hoot to build WASM-4 Wireworld</h2><p>Our intent in this game jam was to show off how the &#34;lower level layers&#34;
of Hoot (i.e. the assembler, disassembler, etc) are themselves useful
and powerful and could be used to compile something interactive and
compelling.
WASM-4&#39;s minimalist homage to 80s video game consoles helped us deliver
on this focus by encouraging &#34;coding towards the bare metal&#34;.</p><p>As usual, game jams force you to pair down features.  For instance,
4-colored sprites were planned from the beginning, and we considered
some unusual additions to wireworld, such as tiles which could make
noise, which we thought maybe would allow Wireworld to be used as a
custom music synthesizer.</p><p><a href="https://spritely.institute/static/images/blog/wireworld-sprites-mockup.png"><img src="https://spritely.institute/static/images/blog/wireworld-sprites-mockup-scaled.png" alt="Mockup sprites for wireworld"/></a></p><p>We were happy to be able to
<a href="https://terpri.itch.io/wireworld">deliver a completed and working Wireworld demo</a>
by the end of the game jam, but most of these features were
removed, and notably we did not yet even have time to properly get
in the sprites we had designed... instead we shipped with placeholder
graphics using the &#34;hello world&#34; smiley from the WASM-4 tutorial!</p><p><img src="https://spritely.institute/static/images/blog/wireworld-release.gif" alt="Release artwork for wireworld"/></p><p>We were surprised to wake up the next morning to find that Spritely
community member <a href="https://vvv.gay/">Vivi</a> had taken our program and
not only made a cool world with it, but had modified the program
itself:</p><p>Thus it was Vivi who first put a version of the binary adder (the
<a href="https://www.quinapalus.com/wires8.html">general design</a> taken from
<a href="https://www.quinapalus.com/wi-index.html">the wireworld computer</a>)
inside of wasm4-wireworld.
With no assistance from Spritely&#39;s internal team, Vivi changed the
grid size to render at 40x40 to have sufficient space to represent
the binary adder (the sprite data was not changed for this grid
redesign in Vivi&#39;s initial hack, leading to an entertaining effect
resembling renderings from a corrupted Gameboy cartridge).
The game jam submitted entry had a 20x20 grid size, but once we saw
the binary adder, we knew we had to have it, so we resized the
official implementation to 40x40 and redrew the sprites accordingly.</p><p>But the biggest takeaways from the jam were that Hoot, while still in
early development, is already a very promising and powerful
environment for doing low-level Webassembly programming.
This merits some further explanation!</p><h2>How we used Hoot to build wasm4-wireworld</h2><p>The last time we talked about <a href="https://gitlab.com/spritely/guile-hoot">Hoot</a>
(our <a href="https://spritely.institute/news/guile-on-web-assembly-project-underway.html">Scheme-&gt;WASM</a> project)
we talked about
<a href="https://spritely.institute/news/scheme-to-wasm-lambdas-recursion.html">directly compiling Scheme to WebAssembly</a>.
This is of course the higher level goal of Hoot:
since Spritely&#39;s tooling is written in
<a href="https://www.gnu.org/software/guile/">Guile Scheme</a>,
we want Spritely to be in the browser, and compiling Scheme programs
themselves to WebAssembly is a great way to accomplish that goal.</p><p>But what if we wanted to play with WebAssembly on a lower level?
It turns out Hoot is a great choice for this: since Hoot uses Guile&#39;s
<a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">compiler tower</a>
and has multiple steps of transformation, the lower level assembler,
disassembler, etc tools of WebAssembly are also available to the
inspired Guile hacker.</p><p>Though Hoot will be a complete Scheme→WebAssembly compiler... it
already contains a nascent powerful and general WebAssembly toolkit!</p><hr/><h3>Getting Technical: Making a minimal WASM-4 cart using Hoot</h3><p><a href="https://wasm4.org/">WASM-4</a> is intentionally minimal and sparse.
No garbage collector extension, and no room for higher level constructs.
You&#39;ve got 64kb of memory, 4 colors, and individual instructions count.</p><p>WASM-4 runs fully compiled WebAssembly programs called &#34;carts&#34;.
A very minimal WASM-4 cart (in fact a cut down version of WASM-4&#39;s
&#34;hello world&#34; cart) could be defined like so:</p><pre><code><span>(</span><span>define</span> <span>$smiley$</span> <span>&#39;</span><span>(</span><span>i32.const</span> <span>#x19a0</span><span>)</span><span>)</span>   <span>(</span><span>define</span> <span>smiley-data</span>
  <span>#vu8</span><span>(</span><span>#b11000011</span>             <span>#b10000001</span>             <span>#b00100100</span>             <span>#b00100100</span>             <span>#b00000000</span>
       <span>#b00100100</span>
       <span>#b10011001</span>
       <span>#b11000011</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>our-game</span><span>)</span>
  <span>`</span><span>(</span><span>module</span>
        <span>(</span><span>import</span> <span>&#34;env&#34;</span> <span>&#34;blit&#34;</span> <span>(</span><span>func</span> <span>$blit</span> <span>(</span><span>param</span> <span>i32</span> <span>i32</span> <span>i32</span> <span>i32</span> <span>i32</span> <span>i32</span><span>)</span><span>)</span><span>)</span>

        <span>(</span><span>data</span> <span>,$smiley$</span> <span>,smiley-data</span><span>)</span>

    <span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;update&#34;</span><span>)</span>
      <span>(</span><span>call</span> <span>$blit</span> <span>,$smiley$</span>
            <span>(</span><span>i32.const</span> <span>76</span><span>)</span> <span>(</span><span>i32.const</span> <span>76</span><span>)</span>              <span>(</span><span>i32.const</span> <span>8</span><span>)</span> <span>(</span><span>i32.const</span> <span>8</span><span>)</span>                <span>(</span><span>i32.const</span> <span>0</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>              </code></pre><p>Here we are using a special lisp/scheme feature called &#34;quasiquote&#34;.
Quasiquote is enabled with the &#34;back-tick&#34; character appearing before
<code>module</code>, switching into read-only data.
In this way, inside of <code>our-game</code>, in the places we have written
<code>,$smiley$</code> we are actually substituting in the <code>$smiley$</code> definition
from the top of the program, and where we say <code>,smiley-data</code> we are
inserting the bytevector describing the smiley sprite.
This turns out to be a powerful templating system for producing
WebAssembly, and we will use it in greater detail later.</p><p>Now let&#39;s say we want to try this cart.
Since we&#39;re in a lisp and lisp culture encourages &#34;live development&#34;,
let&#39;s make a helper utility to compile and run our game:</p><pre><code><span>(</span><span>use-modules</span> <span>(</span><span>wasm</span> <span>assemble</span><span>)</span><span>)</span>

<span>(</span><span>define*</span> <span>(</span><span>try-game</span> <span>#:optional</span> <span>(</span><span>game</span> <span>(</span><span>our-game</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>call-with-output-file</span> <span>&#34;our-game.wasm&#34;</span>
    <span>(</span><span>lambda</span> <span>(</span><span>op</span><span>)</span>
      <span>(</span><span>put-bytevector</span> <span>op</span> <span>(</span><span>wat-&gt;wasm</span> <span>game</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>system*</span> <span>&#34;wasm4&#34;</span> <span>&#34;our-game.wasm&#34;</span><span>)</span><span>)</span></code></pre><p>Now giving the game a try is as simple as running <code>try-game</code> at the REPL:</p><pre><code><span>scheme@</span><span>(</span><span>guile-user</span><span>)</span><span>&gt;</span> <span>(</span><span>try-game</span><span>)</span></code></pre><p>Here&#39;s a version of the cart we just built above running live:</p><h3>Programmatically generating WebAssembly</h3><p>Unfortunately, WebAssembly is very verbose.
Consider how messy our &#34;update&#34; procedure was already looking:</p><pre><code>  <span>`</span><span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;update&#34;</span><span>)</span>
     <span>(</span><span>call</span> <span>$blit</span> <span>,$smiley$</span>
           <span>(</span><span>i32.const</span> <span>76</span><span>)</span> <span>(</span><span>i32.const</span> <span>76</span><span>)</span>             <span>(</span><span>i32.const</span> <span>8</span><span>)</span> <span>(</span><span>i32.const</span> <span>8</span><span>)</span>               <span>(</span><span>i32.const</span> <span>0</span><span>)</span><span>)</span><span>)</span>                </code></pre><p>This is very noisy!  All of those <code>i32.const</code> operations are
getting in the way of us placing our smiley and defining its width
and height.
Not to mention that the final argument defines various flags specified
by individual bits which are very hard to remember.
If we were writing many of these, this would get very hard to read indeed.
Time for an abstraction!</p><pre><code><span>(</span><span>define</span> <span>(</span><span>maybe-i32.const</span> <span>x</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>number?</span> <span>x</span><span>)</span>
      <span>`</span><span>(</span><span>i32.const</span> <span>,x</span><span>)</span>
      <span>x</span><span>)</span><span>)</span>

<span>(</span><span>define*</span> <span>(</span><span>call-blit</span> <span>sprite-ptr</span> <span>x</span> <span>y</span> <span>width</span> <span>height</span>
                    <span>#:key</span> <span>2bpp?</span> <span>rotate?</span> <span>flip-x?</span> <span>flip-y?</span><span>)</span>
  <span>(</span><span>define</span> <span>flags</span>
    <span>(</span><span>logior</span> <span>#b0</span>                                        <span>(</span><span>if</span> <span>2bpp?</span>   <span>#b00000001</span> <span>#b0</span><span>)</span>                <span>(</span><span>if</span> <span>flip-x?</span> <span>#b00000010</span> <span>#b0</span><span>)</span>                <span>(</span><span>if</span> <span>flip-y?</span> <span>#b00000100</span> <span>#b0</span><span>)</span>                <span>(</span><span>if</span> <span>rotate?</span> <span>#b00001000</span> <span>#b0</span><span>)</span><span>)</span><span>)</span>    <span>`</span><span>(</span><span>call</span> <span>$blit</span> <span>,sprite-ptr</span>
         <span>,</span><span>(</span><span>maybe-i32.const</span> <span>x</span><span>)</span> <span>,</span><span>(</span><span>maybe-i32.const</span> <span>y</span><span>)</span>
         <span>,</span><span>(</span><span>maybe-i32.const</span> <span>width</span><span>)</span> <span>,</span><span>(</span><span>maybe-i32.const</span> <span>height</span><span>)</span>
         <span>,</span><span>(</span><span>maybe-i32.const</span> <span>flags</span><span>)</span><span>)</span><span>)</span></code></pre><p>Now we can update our update procedure to rotate and place
the smiley multiple times:</p><pre><code><span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;update&#34;</span><span>)</span>
  <span>,</span><span>(</span><span>call-blit</span> <span>$smiley$</span> <span>76</span> <span>76</span> <span>8</span> <span>8</span><span>)</span>
  <span>,</span><span>(</span><span>call-blit</span> <span>$smiley$</span> <span>42</span> <span>42</span> <span>8</span> <span>8</span>
              <span>#:flip-y?</span> <span>#t</span> <span>#:rotate?</span> <span>#t</span><span>)</span><span>)</span></code></pre><p>Despite now blitting the smiley twice, and rotating and flipping it
on the second version, this is now dramatically easier to read than
the first version.</p><h3>Scheme procedures to generate data and whole programs</h3><p>While we&#39;re not translating Scheme to WebAssembly directly in this
particular usage of Hoot, we are <em>using</em> Scheme to <em>generate</em>
WebAssembly... and that means we have the full power of Scheme at our
fingertips!</p><p>This turned out to be hugely useful during the game jam.  For
instance, while the &#34;smiley&#34; sprite we showed earlier was defined in 1
bit per pixel (&#34;1BPP&#34;) and thus could be &#34;seen while squinting&#34; in
its binary representation:</p><pre><code><span>(</span><span>define</span> <span>smiley-data</span>
  <span>#vu8</span><span>(</span><span>#b11000011</span>             <span>#b10000001</span>             <span>#b00100100</span>             <span>#b00100100</span>             <span>#b00000000</span>
       <span>#b00100100</span>
       <span>#b10011001</span>
       <span>#b11000011</span><span>)</span><span>)</span></code></pre><p>However, for Wireworld we wanted to take advantage of WASM-4&#39;s support
for a 4-color palette to draw prettier sprites.
These are not readable as text in pure binary data in the same way.
However, for the sake of fast iteration and easy ability to &#34;play with&#34;
sprite appearance, we wanted to get back the defined-in-ascii-art
approach.</p><p>So we did just that.  Here are the head and tail sprite definitions:</p><pre><code><span>(</span><span>define</span> <span>head-text</span>
  <span>&#34;\
X##X
#~.#
#~~#
X##X&#34;</span><span>)</span>

<span>(</span><span>define</span> <span>tail-text</span>
  <span>&#34;\
XXXX
X#~X
X##X
XXXX&#34;</span><span>)</span></code></pre><p>Here <code>X</code> represents a dark blue pixel, <code>#</code> is dark purple,
<code>~</code> is light purple, and <code>.</code> is off-white.
These sprites are compiled into their binary representation from
within Scheme itself:</p><pre><code><span>scheme@</span><span>(</span><span>guile-user</span><span>)</span><span>&gt;</span> <span>(</span><span>text-&gt;2bpp-sprite-bv</span> <span>head-text</span><span>)</span>
<span>$7</span> <span>=</span> <span>#vu8</span><span>(</span><span>235</span> <span>146</span> <span>150</span> <span>235</span> <span>0</span><span>)</span></code></pre><p>We can then directly insert the binary representation into the
assembly of the program!
(Understanding how
<a href="https://gitlab.com/spritely/wasm4-wireworld/-/blob/46a39eb6e0b9f690e8d53cd372d6d3faac71725a/data-utils.scm#L41">text-&gt;2bpp-sprite-bv</a>
works is left as an exercise for the reader.)</p><p>When constructing this blogpost, we also wanted a way to generate
multiple Wireworld WASM-4 carts which each started with an
<a href="https://gitlab.com/spritely/wasm4-wireworld/-/tree/main/worlds">initial world state</a>.
Once again, we wanted to define these in plaintext for fast
iteration and experimentation while preserving readability:</p><pre><code>  *#                                #@
 @  ################################  *
  #                                  #
 #                                    #
  #                                  #
 #                                    #
  ######     ####### ####   ####     #
 #     #     #   #   #   # #          #
  #    #  #  #   #   ####   ###      #
 #     #  #  #   #   #  #  #          #
  #    #  #  #   #   #   # #         #
 #      ## ##  #######   ## ####      #
  #                             ######
 #                                    #
  #                                  #
 #                                    #
  #  #     #   ##   ####  #    ###   #
 #   #     #  #  #  #   # #    #  #   #
  #  #  #  # *    @ ####  #    #  #  #
 #   #  #  # @    * #  #  #    #  #   #
  #  #  #  #  #  #  #   # #    #  #  #
 #    ## ##    ##   #   # #### ###    #
  #                                  #
 #                                    #
  #                                  #
 #                                    #
  #                                  #
 *  ################################  @
  @#                                #*</code></pre><p>Writing a text parser interpreted by a WASM program for reading
textual wireworld descriptions would have been too much work
(both for us and for the spirit of an old-school fantasy console).
We took the same technique as with the textual representation of
sprites: our Scheme program
<a href="https://gitlab.com/spritely/wasm4-wireworld/-/blob/main/load-world.scm">loaded and translated worlds</a>
from the textual representation to the very in-memory representation
our WASM-4 game would use, then thanks to the power of quasiquote,
we simply inserted the game into the generated program.</p><p>The really cool thing here is that
<em>the generation of carts is itself a procedure</em>.
Generating a custom cart is as simple as:</p><pre><code><span>(</span><span>wat-&gt;wasm</span> <span>(</span><span>make-wireworld-game</span>
            <span>#:world</span> <span>(</span><span>load-world-file</span> <span>world-filename</span><span>)</span><span>)</span><span>)</span></code></pre><p>Thus our make file could simply spit out custom files with custom
initial world states, &#34;baking&#34; the initial level descriptions into
memory:</p><pre><code>$ make
Built build/wireworld-adder.wasm
Built build/wireworld-splash.wasm
Built build/wireworld-intro.wasm
Built build/wireworld-blank.wasm</code></pre><p>If you&#39;ve ever heard lisp programmers talk about &#34;programs that write
programs&#34;, consider this a nice example!</p><h2>Lessons learned and meta-observations</h2><p>Our biggest successes were when we began embracing the abstraction powers
provided by Hoot.
Initially we simply hand-coded using WebAssembly&#39;s textual format and
compiled such files.
Once we moved to the scheme-as-code-generator abstractions shown in
this article there was a marked uptick in productivity and
correctness.
Code became easier to write and understand and iteration became faster.
Tools such as the textual representations of sprites and levels became
easy to directly integrate.
And significantly, by embracing the &#34;programs that write programs&#34;
philosophy, generating the custom carts shown off in this article became
as simple as passing in the relevant arguments to the procedure which
&#34;baked&#34; the carts with the relevant levels.
This latter part was particularly satisfying but was simply a natural
outgrowth of the style of programming we took.</p><p>Hoot&#39;s primary goal is to get Spritely&#39;s tooling available in the
browser by
<a href="https://spritely.institute/news/scheme-to-wasm-lambdas-recursion.html">directly compiling Scheme to WebAssembly</a>.
However it turns out that Hoot&#39;s lower level layers of abstractions
are powerful tooling in their own right!
Game jams are a great opportunity great opportunity to put your tooling
to the test, and we&#39;re delighted with the outcome.</p></div></div>
  </body>
</html>
