<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreasimonecosta.dev/posts/what-the-heck-is-a-homomorphic-mapped-type/">Original</a>
    <h1>What the heck is a homomorphic mapped type?</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://andreasimonecosta.dev/images/mapped_type_omomorfi/the-what.jpg" alt="Featured image"/></p><h2 id="introduction">Introduction
<a href="#introduction"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>I remember back in the day when I stumbled upon the term <em>homomorphic</em> for the first time in the good ol&#39; TypeScript handbook. Honestly, the handbook’s explanation was a bit fuzzy to me.</p><p>After listing a couple of example mapped types:</p><div><pre><code data-lang="ts"><span>type</span> Nullable&lt;<span>T</span>&gt; <span>=</span> { [P <span>in</span> <span>keyof</span> T]<span>:</span> T[P] <span>|</span> <span>null</span> };
<span>type</span> Partial&lt;<span>T</span>&gt; <span>=</span> { [P <span>in</span> <span>keyof</span> T]<span>?:</span> T[P] };
</code></pre></div><p>The handbook continued by saying:</p><blockquote><p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>. This is a good template for any general use of mapped types. That’s because this kind of transformation is <strong>homomorphic</strong>, which means that the mapping applies only to properties of <code>T</code> and no others.</p></blockquote><p>Immediately afterward, it claimed that even <code>Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }</code> is homomorphic, while <code>Record</code> is not:</p><blockquote><p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not. One clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from. Non-homomorphic types are essentially creating new properties, […].</p></blockquote><p>The term <em>homomorphic</em> is a bit of a stretch from its math roots, but it’s basically saying that this kind of mapped type keeps the original type’s structure intact. In fact, the <a href="https://github.com/microsoft/TypeScript/wiki/FAQ#faqs" target="_blank" rel="noopener">TypeScript wiki</a> states:</p><blockquote><p>Mapped types declared as <code>{ [ K in keyof T ]: U }</code> where <code>T</code> is a type parameter are known as homomorphic mapped types, which means that the mapped type is a structure preserving function of <code>T</code>.</p></blockquote><p>Looking back, after getting cozy with the type system, the handbook’s explanation makes more sense now. But hey, there’s currently no up-to-date and complete definition. The new handbook doesn’t even mention the term <em>homomorphic</em>, but it does appear in the source code.</p><p>I was just tired of not having the full picture, so I opened up the compiler and tried to figure out once and for all what the heck a homomorphic mapped type is.</p><h2 id="under-the-hood">Under the hood
<a href="#under-the-hood"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><h3 id="gethomomorphictypevariable">getHomomorphicTypeVariable
<a href="#gethomomorphictypevariable"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>Here’s the function that helps us answer the question:</p><div><pre><code data-lang="ts"><span>function</span> getHomomorphicTypeVariable(<span>type</span><span>:</span> MappedType) {
  <span>const</span> constraintType <span>=</span> getConstraintTypeFromMappedType(<span>type</span>);
  <span>if</span> (constraintType.flags <span>&amp;</span> TypeFlags.Index) {
    <span>const</span> typeVariable <span>=</span> getActualTypeVariable((constraintType <span>as</span> IndexType).<span>type</span>);
    <span>if</span> (typeVariable.flags <span>&amp;</span> TypeFlags.TypeParameter) {
      <span>return</span> typeVariable <span>as</span> TypeParameter;
    }
  }
  <span>return</span> <span>undefined</span>;
}
</code></pre></div><p>A mapped type <code>{ [P in C]: ... }</code> is homomorphic if its constraint <code>C</code> is just a <code>keyof T</code>, where <code>T</code> must be a type variable. This is indicated by the <code>TypeFlags.Index</code> and <code>TypeFlags.TypeParameter</code> flags, respectively. Where does the type variable come from? It could be declared as input or inferred using the <code>infer</code> keyword. So, the examples from the old handbook are all good, except for <code>Pick</code>, which it seems TypeScript no longer considers homomorphic.</p><p>So, what properties do homomorphic mapped types have? Oh, and what about the <code>as</code> clause? It allows us to rename or even remove keys, theoretically altering the object’s structure.</p><h3 id="instantiatemappedtype">instantiateMappedType
<a href="#instantiatemappedtype"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>This function comes into play when it’s necessary to instantiate a mapped type:</p><div><pre><code data-lang="ts"><span>function</span> instantiateMappedType(<span>type</span><span>:</span> MappedType, mapper: <span>TypeMapper</span>, aliasSymbol?: <span>Symbol</span>, aliasTypeArguments?: <span>readonly</span> Type[])<span>:</span> Type {
  <span>// For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
</span><span></span>  <span>// operation depends on T as follows:
</span><span></span>  <span>// * If T is a primitive type no mapping is performed and the result is simply T.
</span><span></span>  <span>// * If T is a union type we distribute the mapped type over the union.
</span><span></span>  <span>// * If T is an array we map to an array where the element type has been transformed.
</span><span></span>  <span>// * If T is a tuple we map to a tuple where the element types have been transformed.
</span><span></span>  <span>// * Otherwise we map to an object type where the type of each property has been transformed.
</span><span></span>  <span>// For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
</span><span></span>  <span>// { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
</span><span></span>  <span>// { [P in keyof A]: X } | undefined.
</span><span></span>  <span>const</span> typeVariable <span>=</span> getHomomorphicTypeVariable(<span>type</span>);
  <span>if</span> (typeVariable) {
    <span>const</span> mappedTypeVariable <span>=</span> instantiateType(typeVariable, mapper);
    <span>if</span> (typeVariable <span>!==</span> mappedTypeVariable) {
      <span>return</span> mapTypeWithAlias(
        getReducedType(mappedTypeVariable),
        t <span>=&gt;</span> {
          <span>if</span> (t.flags <span>&amp;</span> (TypeFlags.AnyOrUnknown <span>|</span> TypeFlags.InstantiableNonPrimitive <span>|</span> TypeFlags.<span>Object</span> <span>|</span> TypeFlags.Intersection) <span>&amp;&amp;</span> t <span>!==</span> wildcardType <span>&amp;&amp;</span> <span>!</span>isErrorType(t)) {
            <span>if</span> (<span>!</span><span>type</span>.declaration.nameType) {
              <span>let</span> constraint;
              <span>if</span> (
                  isArrayType(t) <span>||</span> t.flags <span>&amp;</span> TypeFlags.Any <span>&amp;&amp;</span> findResolutionCycleStartIndex(typeVariable, TypeSystemPropertyName.ImmediateBaseConstraint) <span>&lt;</span> <span>0</span>
                  <span>&amp;&amp;</span> (constraint <span>=</span> getConstraintOfTypeParameter(typeVariable)) <span>&amp;&amp;</span> everyType(constraint, isArrayOrTupleType)
              ) {
                <span>return</span> instantiateMappedArrayType(t, <span>type</span>, prependTypeMapping(typeVariable, t, mapper));
              }
              <span>if</span> (isGenericTupleType(t)) {
                <span>return</span> instantiateMappedGenericTupleType(t, <span>type</span>, typeVariable, mapper);
              }
              <span>if</span> (isTupleType(t)) {
                <span>return</span> instantiateMappedTupleType(t, <span>type</span>, prependTypeMapping(typeVariable, t, mapper));
              }
            }
            <span>return</span> instantiateAnonymousType(<span>type</span>, prependTypeMapping(typeVariable, t, mapper));
          }
          <span>return</span> t;
        },
        aliasSymbol,
        aliasTypeArguments,
      );
    }
  }
  <span>// If the constraint type of the instantiation is the wildcard type, return the wildcard type.
</span><span></span>  <span>return</span> instantiateType(getConstraintTypeFromMappedType(<span>type</span>), mapper) <span>===</span> wildcardType <span>?</span> wildcardType : <span>instantiateAnonymousType</span>(<span>type</span>, mapper, aliasSymbol, aliasTypeArguments);
}
</code></pre></div><p>Here’s the catch: homomorphic mapped types are handled in a special way, and you can observe this by examining the first if statement. Comments help us understand some of their special properties:</p><ol><li><p>if the homomorphic mapped type is applied to a primitive type, the result is the primitive type itself</p><div><pre><code data-lang="ts">HMT&lt;<span>1</span>&gt; <span>=</span> <span>1</span>
HMT&lt;<span>string</span>&gt; <span>=</span> <span>string</span>
</code></pre></div></li><li><p>if the homomorphic mapped type is applied to a union type, the result is the union of the mapped type applied to each member of the union (therefore, TS often calls homomorphic mapped types <strong>distributive</strong>)</p><div><pre><code data-lang="ts">HMT&lt;<span>A</span> | <span>B</span>&gt; <span>=</span> HTM&lt;<span>A</span>&gt; <span>|</span> HTM&lt;<span>B</span>&gt;
</code></pre></div></li><li><p>if the homomorphic mapped type is applied to an array, the result is still an array where the element type has been transformed by the logic of the mapped type</p><div><pre><code data-lang="ts"><span>type</span> HMT&lt;<span>T</span>&gt; <span>=</span> { [P <span>in</span> <span>keyof</span> T]<span>:</span> F&lt;<span>T</span>[<span>P</span>]&gt; }

HMT&lt;<span>A</span>[]&gt; <span>=</span> F&lt;<span>A</span>&gt;[]
</code></pre></div></li><li><p>if the homomorphic mapped type is applied to a tuple, the result is still a tuple where the element types have been transformed by the logic of the mapped type</p><div><pre><code data-lang="ts"><span>type</span> HMT&lt;<span>T</span>&gt; <span>=</span> { [P <span>in</span> <span>keyof</span> T]<span>:</span> F&lt;<span>T</span>[<span>P</span>]&gt; }

HMT<span>&lt;</span>[A, B, C]<span>&gt;</span> <span>=</span> [F&lt;<span>A</span>&gt;, F&lt;<span>B</span>&gt;, F&lt;<span>C</span>&gt;]
</code></pre></div></li></ol><p>Basically, an homomorphic mapped type - without an <code>as</code> clause - iterates solely over the numeric (<code>number | `${number}`</code>) keys of the array (tuple) type, leaving the other keys untouched. Therefore the mapped type logic is applied only on element types.</p><p>The preservation of tuple and array types happens only if <code>!type.declaration.nameType</code>. If you use the <code>as</code> clause, then <code>type.declaration.nameType</code> contains whatever follows the clause, like a template literal or a conditional. It makes sense to lose tuple and array types if we rename or filter out some keys, as we would likely lose some or all the numeric keys. With an <code>as</code> clause, even a homomorphic mapped type currently iterates through all the keys of the array (tuple) type, but <a href="https://github.com/microsoft/TypeScript/pull/55774" target="_blank" rel="noopener">this could change soon</a>.</p><p>Therefore, using the <code>as</code> clause doesn’t disqualify a mapped type from being homomorphic. It simply doesn’t preserve tuple and array types.</p><h3 id="resolvemappedtypemembers-and-getmodifierstypefrommappedtype">resolveMappedTypeMembers and getModifiersTypeFromMappedType
<a href="#resolvemappedtypemembers-and-getmodifierstypefrommappedtype"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>In short words, <strong>any</strong> mapped type of the form <code>{ [P in keyof T]: ... }</code>, where <code>T</code> may be a type variable or not, is able to preserve the modifiers of the original type <code>T</code>, that is called the <em>modifiers type</em>. Because all homomorphic mapped types respect that form, they do preserve the modifiers:</p><div><pre><code data-lang="ts"><span>type</span> HMT&lt;<span>T</span>&gt; <span>=</span> { [P <span>in</span> <span>keyof</span> T]<span>:</span> F&lt;<span>T</span>[<span>P</span>]&gt; }

HMT<span>&lt;</span>{ <span>readonly</span> a: <span>A</span>, b?: <span>B</span> }<span>&gt;</span> <span>=</span> { <span>readonly</span> a: <span>F</span>&lt;<span>A</span>&gt;, b?: <span>F</span>&lt;<span>B</span>&gt; }
</code></pre></div><p>If a mapped type has the form <code>{ [P in C]: ... }</code> where <code>C</code> is a type parameter and the costraint of <code>C</code> is <code>keyof T</code>, then the modifiers type is <code>T</code>. This let utility types like <code>Pick</code> preserve the modifiers of the original type, even though they are not homomorphic:</p><div><pre><code data-lang="ts"><span>type</span> Pick&lt;<span>T</span>, <span>K</span> <span>extends</span> <span>keyof</span> <span>T</span>&gt; <span>=</span> { [P <span>in</span> K]<span>:</span> T[P]; }

Pick<span>&lt;</span>{ <span>readonly</span> a: <span>A</span>, b?: <span>B</span> }, <span>&#34;a&#34;</span><span>&gt;</span> <span>=</span> { <span>readonly</span> a: <span>A</span> }
</code></pre></div><p>Furthermore, homomorphic mapped types could preserve the symlinks between original and derived properties as well. Symlinks enable symbol navigation in the IDE (things like <em>“go to definition”</em>). Even this property is not exclusive to homomorphic mapped types: if modifiers can be preserved, then the possibility of maintaining the links is also being considered.</p><p>The following code snippet is taken from <code>resolveMappedTypeMembers</code>:</p><div><pre><code data-lang="ts"><span>// stuff...
</span><span></span>
<span>const</span> shouldLinkPropDeclarations <span>=</span> getMappedTypeNameTypeKind(mappedType) <span>!==</span> MappedTypeNameTypeKind.Remapping;
<span>const</span> modifiersType <span>=</span> getModifiersTypeFromMappedType(<span>type</span>); <span>// skipping some details
</span><span></span>
<span>// other stuff...
</span><span></span>
<span>const</span> modifiersProp <span>=</span> something_something(modifiersType, ...); <span>// skipping other details
</span><span></span>
<span>// way more stuff...
</span><span></span>
<span>if</span> (modifiersProp) {
  prop.links.syntheticOrigin <span>=</span> modifiersProp;
  prop.declarations <span>=</span> shouldLinkPropDeclarations <span>?</span> modifiersProp.declarations : <span>undefined</span>;
}
</code></pre></div><p>So, everything revolves around the value of <code>shouldLinkPropDeclarations</code>. This flag is <code>false</code> only if we are using an <code>as</code> clause for key remapping. In that case, the links are lost. If an <code>as</code> clause is employed just for key filtering or no <code>as</code> clause is used at all, then the links are preserved, provided that <code>modifiersProp</code> is not falsy.</p><h3 id="inferfromobjecttypes">inferFromObjectTypes
<a href="#inferfromobjecttypes"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h3><p>Have you ever heard about reverse mapped types? If not, check this awesome talk by <a href="https://twitter.com/AndaristRake" target="_blank" rel="noopener">Mateusz Burzyński</a> at TypeScript Congress 2023: <a href="https://portal.gitnation.org/contents/infer-multiple-things-at-once-with-reverse-mapped-types" target="_blank" rel="noopener">Infer multiple things at once with reverse mapped types</a>.</p><p>I refrain from posting the entire function, because it’s extensive. When it comes to the possibility of reversing the action of a mapped type, however, the essence lies in the following lines:</p><div><pre><code data-lang="ts"><span>if</span> (getObjectFlags(target) <span>&amp;</span> ObjectFlags.Mapped <span>&amp;&amp;</span> <span>!</span>(target <span>as</span> MappedType).declaration.nameType) {
  <span>const</span> constraintType <span>=</span> getConstraintTypeFromMappedType(target <span>as</span> MappedType);
  <span>if</span> (inferToMappedType(source, target <span>as</span> MappedType, constraintType)) {
    <span>return</span>;
  }
}
</code></pre></div><p>Once again, we have <code>!(target as MappedType).declaration.nameType</code>, which prevents the reversion in the case of using the <code>as</code> clause. While being homomorphic isn’t an absolute requirement for reversion, because even some non-homomorphic mapped types can be reverted, it does serve as a good indicator that TypeScript might pull off the reversion if there is no <code>as</code> clause.</p><p><strong>Achtung</strong>: this might be enhanced soon, thanks to <a href="https://github.com/microsoft/TypeScript/pull/52972" target="_blank" rel="noopener">this PR</a>. <strong>Filtering</strong> mapped types are easier to revert than <strong>renaming</strong> mapped types, so the <code>as</code> clause might not a big concert anymore if you use it just for filter out some keys.</p><h2 id="conclusion">Conclusion
<a href="#conclusion"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>In conclusion, homomorphic mapped types are those that take the form <code>{ [K in keyof T (as ...)]: ... }</code>, where <code>T</code> is a type variable, and the parentheses indicate that the <code>as</code> clause is optional. Homomorphic mapped types without the <code>as</code> clause are the cream of the crop, boasting special properties; those with the <code>as</code> clause aren’t that bad, but they come with a few less features. If a mapped type isn’t homomorphic, it might still have some properties, like preserving modifiers, having symlinks to the original type, and the possibility of being reverted.</p><p>When crafting a mapped type, aim for homomorphism.</p></div></div>
  </body>
</html>
