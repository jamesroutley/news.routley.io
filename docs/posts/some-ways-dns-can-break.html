<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/01/15/some-ways-dns-can-break/">Original</a>
    <h1>Some ways DNS can break</h1>
    
    

<p>When I first learned about it, DNS didn&rsquo;t seem like it should be THAT
complicated. Like, there are DNS records, they&rsquo;re stored on a server, what&rsquo;s
the big deal?</p>

<p>But with DNS, reading about how it works in a textbook doesn&rsquo;t prepare you for
the sheer volume of different ways DNS can break your system in practice. It&rsquo;s
not just caching problems!</p>

<p>So I <a href="https://twitter.com/b0rk/status/1481265429897261058">asked people on Twitter</a> for
example of DNS problems they&rsquo;ve run into, especially DNS problems that <strong>didn&rsquo;t
initially appear to be DNS problems</strong>. (the popular &ldquo;it&rsquo;s always DNS&rdquo; meme)</p>

<p>I&rsquo;m not going to discuss how to solve or avoid any of these problems in this
post, but I&rsquo;ve linked to webpages discussing the problem where I could find
them.</p>

<h3 id="problem-slow-network-requests">problem: slow network requests</h3>

<p>Your network requests are a little bit slower than expected, and it&rsquo;s actually
because your DNS resolver is slow for some reason. This might be because the
resolver is under a lot of load, or it has a memory leak, or something else.</p>

<p>I&rsquo;ve run into this before with my router&rsquo;s DNS forwarder &ndash; all of my DNS
requests were slow, and I restarted my router and that fixed the problem.</p>

<h3 id="problem-dns-timeouts">problem: DNS timeouts</h3>

<p>A couple of people mentioned network requests that were taking 2+ seconds or 30
seconds because of DNS queries that were timing out. This is sort of the same
as &ldquo;slow requests&rdquo;, but it&rsquo;s worse because queries can take several seconds to
time out.</p>

<p>Sophie Haskins has a great blog post <a href="https://blog.sophaskins.net/blog/misadventures-with-kube-dns/">Misadventures with Kube DNS</a> about DNS
timeouts with Kubernetes.</p>

<h3 id="problem-ndots">problem: ndots</h3>

<p>A few people mentioned a specific issue where Kubernetes sets <code>ndots:5</code> in its <code>/etc/resolv.conf</code></p>

<p>Here&rsquo;s an example /etc/resolv.conf from <a href="https://pracucci.com/kubernetes-dns-resolution-ndots-options-and-why-it-may-affect-application-performances.html">Kubernetes pods /etc/resolv.conf ndots:5 option and why it may negatively affect your application performances</a>.</p>

<pre><code>nameserver 100.64.0.10
search namespace.svc.cluster.local svc.cluster.local cluster.local eu-west-1.compute.internal
options ndots:5
</code></pre>

<p>My understanding is that if this is your <code>/etc/resolv.conf</code> and you look up
<code>google.com</code>, your application will call the C <code>getaddrinfo</code> function, and
<code>getaddrinfo</code> will:</p>

<ol>
<li>look up <code>google.com.namespace.svc.cluster.local.</code></li>
<li>look up <code>google.com.svc.cluster.local.</code></li>
<li>look up <code>google.com.cluster.local.</code></li>
<li>look up <code>google.com.eu-west-1.compute.internal.</code></li>
<li>look up <code>google.com.</code></li>
</ol>

<p>Basically it checks if <code>google.com</code> is actually a subdomain of everything on the <code>search</code> line.</p>

<p>So every time you make a DNS query, you need to wait for 4 DNS queries to fail
before you can get to the actual real DNS query that succeeds.</p>

<h3 id="problem-dns-servers-that-return-nxdomain-instead-of-noerror">problem: DNS servers that return NXDOMAIN instead of NOERROR</h3>

<p>Here&rsquo;s a problem that I ran into once, where nginx couldn&rsquo;t resolve a domain.</p>

<ul>
<li>I set up nginx to use a specific DNS server to resolve DNS queries</li>
<li>when visiting the domain, nginx made 2 queries, one for an <code>A</code> record, and one for an <code>AAAA</code> record</li>
<li>the DNS server returned a <code>NXDOMAIN</code> reply for the <code>A</code> query</li>
<li>nginx decided &ldquo;ok, that domain doesn&rsquo;t exist&rdquo;, and gave up</li>
<li>the DNS server returned a successful reply for the <code>AAAA</code> query</li>
<li>nginx ignored the <code>AAAA</code> record because it had already given up</li>
</ul>

<p>The problem was that the DNS server should have returned <code>NOERROR</code> &ndash; that
domain <em>did</em> exist, it was just that there weren&rsquo;t any <code>A</code> records for it. I
reported the bug, they fixed it, and that fixed the problem.</p>

<p>I&rsquo;ve implemented this bug myself too, so I understand why it happens &ndash; it&rsquo;s
easy to think &ldquo;there aren&rsquo;t any records for this query, I should return an
<code>NXDOMAIN</code> error&rdquo;.</p>

<h3 id="problem-negative-dns-caching">problem: negative DNS caching</h3>

<p>If you visit a domain before creating a DNS record for it, the <strong>absence</strong> of
the record will be cached. This is very surprising the first time your run into
it &ndash; I only learned about this last year!</p>

<p>The TTL for cache entry is the TTL of the domain&rsquo;s SOA record &ndash; for example
for <code>jvns.ca</code>, it&rsquo;s an hour.</p>

<h3 id="problem-nginx-caching-dns-records-forever">problem: nginx caching DNS records forever</h3>

<p>If you put this in your nginx config:</p>

<pre><code>location / {
    proxy_pass https://some.domain.com;
}
</code></pre>

<p>then nginx will resolve <code>some.domain.com</code> once on startup and never again. This
is especially dangerous if the IP address for <code>some.domain.com</code>  changes
infrequently, because it might keep happily working for months and then
suddenly break at 2am one day.</p>

<p>There are pretty well-known ways to fix this and this post isn&rsquo;t about nginx so
I won&rsquo;t get into it, but it&rsquo;s surprising the first time you run into it.</p>

<p>Here&rsquo;s a <a href="https://medium.com/driven-by-code/dynamic-dns-resolution-in-nginx-22133c22e3ab">blog post</a> with a story of how this happened to someone with an AWS load balanacer.</p>

<h3 id="problem-java-caching-dns-records-forever">problem: Java caching DNS records forever</h3>

<p>Same thing, but for Java: <a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-jvm-ttl.html">Apparently</a>
depending on how you configure Java, &ldquo;the JVM default TTL [might be] set so
that it will never refresh DNS entries until the JVM is restarted.&rdquo;</p>

<p>I haven&rsquo;t run into this myself but I asked a friend about it who writes more
Java than me and they told me that it&rsquo;s happened to them.</p>

<p>Of course, literally any software could have this problem of caching DNS
records forever, but the main cases I&rsquo;ve heard of in practice are nginx and
Java.</p>

<h3 id="problem-that-entry-in-etc-hosts-you-forgot-about">problem: that entry in /etc/hosts you forgot about</h3>

<p>Another variant on caching issues: entries in <code>/etc/hosts</code> that override your
usual DNS settings!</p>

<p>This is extra confusing because <code>dig</code> ignores <code>/etc/hosts</code>, so everything SEEMS
like it should be fine (&rdquo;<code>dig whatever.com</code> is working!&ldquo;).</p>

<h3 id="problem-your-email-isn-t-being-sent-is-going-to-spam">problem: your email isn&rsquo;t being sent / is going to spam</h3>

<p>The way email is sent and validated is through DNS (MX records, SPF records,
DKIM records), so a lot of email problems are DNS problems.</p>

<h3 id="problem-internationalized-domain-names-don-t-work">problem: internationalized domain names don&rsquo;t work</h3>

<p>You can register domain names with non-ASCII characters or emoji like <a href="https://ðŸ’©.la/">https://ðŸ’©.la</a>.</p>

<p>The way this works with DNS is that <code>ðŸ’©.la</code> gets translated into <code>xn--ls8h.la</code> with an encoding called &ldquo;punycode&rdquo;.</p>

<p>But even though there&rsquo;s a clear standard for how they should work with DNS, a lot of software doesn&rsquo;t handle internationalized domain names well!
There&rsquo;s a fun story about this in Julian Squires&rsquo; great talk <a href="https://www.youtube.com/watch?v=UE-fJjMasec">The emoji that Killed Chrome!!</a>.</p>

<h3 id="problem-tcp-dns-is-blocked-by-a-firewall">problem: TCP DNS is blocked by a firewall</h3>

<p>A couple of people mentioned that some firewalls allow UDP port 53 but not TCP
port 53. But large DNS queries need to use TCP port 53, so this can cause weird
intermittent problems that are hard to debug.</p>

<h3 id="problem-musl-doesn-t-support-tcp-dns">problem: musl doesn&rsquo;t support TCP DNS</h3>

<p>A lot of applications use libc&rsquo;s <code>getaddrinfo</code> to make DNS queries. musl is an
alternative to <code>glibc</code> that&rsquo;s used in Alpine Docker container which doesn&rsquo;t
support TCP DNS. This can cause problems if you make DNS queries where the
response would be too big to fit inside a regular DNS UDP packet (512 bytes).</p>

<p>I&rsquo;m still a bit fuzzy on this so I might have it wrong, but my understanding of how this can break is:</p>

<ol>
<li>musl&rsquo;s getaddrinfo makes a DNS query</li>
<li>the DNS server notices that the response is too big to fit in a single DNS response packet</li>
<li>the DNS server returns an <strong>empty</strong> truncated response, expecting that the client will retry by making a TCP DNS query</li>
<li><code>musl</code> does not support TCP so it does not retry</li>
</ol>

<p>A blog post about this: <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">DNS resolution issue in Alpine Linux</a></p>

<h3 id="problem-round-robin-dns-doesn-t-work-with-getaddrinfo">problem: round robin DNS doesn&rsquo;t work with <code>getaddrinfo</code></h3>

<p>One way you could approach load balancing is to use &ldquo;round robin DNS&rdquo;. The idea
is that every time you make a DNS query, you get a different IP address.
Apparently this works if you use <code>gethostbyname</code> to make DNS queries, but it
does not work if you use <code>getaddrinfo</code> because <code>getaddrinfo</code> sorts the IP
responses it receives.</p>

<p>So you could run into an upsetting problem if you switch from <code>gethostbyname</code> to <code>getaddrinfo</code> behind the scenes without realising that this will break your DNS load balancing.</p>

<p>Here are a couple of pages discussing this:</p>

<ul>
<li><a href="https://groups.google.com/g/consul-tool/c/AGgPjrrkw3g">getaddrinfo breaks round robin DNS</a></li>
<li><a href="https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/">getaddrinfo with round robin DNS and happy eyeballs</a></li>
</ul>

<h3 id="problem-a-race-condition-when-starting-a-service">problem: a race condition when starting a service</h3>

<p>A problem someone <a href="https://mobile.twitter.com/omatskiv/status/1481305175440646148">mentioned</a>
with Kubernetes DNS: they had 2 containers which started simultaneously and
immediately tried to resolve each other. But the DNS lookup failed because the
Kubernetes DNS change hadn&rsquo;t happened yet, and then the failure was cached so
it kept failing.</p>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>I&rsquo;ve definitely missed some important DNS problems here, so I&rsquo;d love to hear
what I&rsquo;ve missed. I&rsquo;d also love links to blog posts that write up examples of
these problems &ndash; I think it&rsquo;s really useful to see how the problem
specifically manifests in practice and how people debugged it.</p>

  </body>
</html>
