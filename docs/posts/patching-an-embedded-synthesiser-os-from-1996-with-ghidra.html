<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.petersobot.com/patching-the-k2500">Original</a>
    <h1>Patching an embedded synthesiser OS from 1996 with Ghidra</h1>
    
    <div id="readability-page-1" class="page"><article id="f2ZJqD9HUpe2wNHQPFwG2B">
	<time datetime="2021-04-23">April 23, 2021</time>
  
	<p>For reasons I won’t get into, I’ve been working on a tricky reverse engineering puzzle recently: how to patch the operating system of a 26-year-old synthesizer. To be specific, the <a href="https://www.vinta%0Agesynth.com/kurzweil/k2500.php">Kurzweil K2500</a>, a sample-based synthesizer released in 1996.</p>

<p><a href="https://svbtleusercontent.com/3zouwM9N4uforzGEfhdaUi0xspap.png"><img src="https://svbtleusercontent.com/3zouwM9N4uforzGEfhdaUi0xspap_small.png" alt="k2500xs_diagonal.png"/></a></p>

<p>As with many digital musical instruments, this synthesizer is really just a computer with some extra chips. In this case, it’s a computer based around the CPU that was popular at the time: <a href="https://en.wikipedia.org/wiki/Motorola_68000">the Motorola 68000</a>, which was also famously used in the original Macintosh and the Sega Genesis. I want to patch the operating system of this beast to do all sorts of other things, most of which which I’ll leave to the imagination in this already-very-long post.</p>
<h2 id="finding-the-operating-system_2">Finding the Operating System <a href="#finding-the-operating-system_2">#</a>
</h2>
<p>Modifying the operating system sounds great, but how do we get access to the code in the first place? Luckily, the K2500 operating systems <a href="https://kurzweil.com/content/migration/downloads/pub/Kurzweil/Pro_Products/K2000-K2vx-K2500/K2500/Operating_System/">are still provided by the manufacturer on what looks like an old FTP site</a>. Downloading and unzipping the operating system gives us a <code>.KOS</code> file, which seems to be a custom format. Opening the file in <a href="https://hexfiend.com">Hex Fiend</a> shows its bytes directly:</p>

<p><a href="https://svbtleusercontent.com/xf2sbD8vBrz54qxagvDUnL0xspap.png"><img src="https://svbtleusercontent.com/xf2sbD8vBrz54qxagvDUnL0xspap_small.png" alt="A hex dump of &#34;K25V00.KOS&#34;"/></a></p>

<p>Unfortunately, nothing stands out here. There seems to be a human-readable 4-byte header at the top: <code>SYS0</code>, possibly followed by other header bytes, but it’s really hard to tell. Regardless, we already know that this operating system runs on a Motorola 68000 CPU. Let’s just try interpreting the data as a binary, and see how far we can get.</p>
<h2 id="enter-ghidra_2">Enter Ghidra <a href="#enter-ghidra_2">#</a>
</h2>
<p>The operating system file we’re using is <em>probably</em> raw machine code: literally the instructions and data interpreted by the CPU itself. To make any sense of this whatsoever, we’re going to need to <em>disassemble</em> it, to turn it back into assembly code - and hopefully eventually <em>decompile</em> it back into C-style code.</p>

<p>To do this, let’s use a tool called <a href="https://ghidra-sre.org">Ghidra</a>: an open-source reverse-engineering program built, maintained, and released by the United States National Security Agency. (Yes, that one. Really.) To start, let’s import the <code>.KOS</code> file directly into Ghidra and analyze it with the default settings, which will search for instructions.</p>

<p><a href="https://svbtleusercontent.com/35HWgnWGJWDh3cToX5ntV0xspap.png"><img src="https://svbtleusercontent.com/35HWgnWGJWDh3cToX5ntV0xspap_small.png" alt="Untitled 4.png"/></a></p>

<p>Scrolling through the file shows that parts of the data have been analyzed by Ghidra as valid 68k instructions, but much of the file remains unanalyzed. Strangely, scrolling further through the files shows that Ghidra has correctly identified a number of human-readable strings in the file (great!) but the code seems to be referring to the strings offset by some amount, showing up as cut-off strings in Ghidra.</p>

<p><a href="https://svbtleusercontent.com/3z17RxfqhFCbymoYVDxgYK0xspap.png"><img src="https://svbtleusercontent.com/3z17RxfqhFCbymoYVDxgYK0xspap_small.png" alt="Untitled 8.png"/></a></p>

<p>This is because we just loaded the entire <code>.KOS</code> file into Ghidra, ignoring the fact that it has a header and likely some other extra bytes. This is a pretty big problem. Any cross-references between functions will be inaccurate as we continue to reverse-engineer the data, sending us in the wrong direction nearly every time we try to follow a reference. We need to fix this first.</p>
<h2 id="reverse-engineering-the-bootloader_2">Reverse Engineering the Bootloader <a href="#reverse-engineering-the-bootloader_2">#</a>
</h2>
<p>To reverse-engineer the <code>.KOS</code> file, it would be extremely useful to dig into the code that creates or consumes these files. We don’t have the creation code, but we do have access to the code that consumes these files: <a href="https://kurzweil.com/content/migration/downloads/pub/Kurzweil/Pro_Products/K2000-K2vx-K2500/K2500/Operating_System/Boot_Loader/">the bootloader for the synth itself, which is also still available online</a>! Let’s load it into Ghidra and make an assumption to make our lives easier: let’s guess that the first 8 bytes of the file are part of a header.</p>
<blockquote>
<p>Where did that number come from? Well, I tried 0, +4, +8, +12, +16, and +20 byte offsets, and +8 disassembled the most correctly. Yes, this took a while. In hindsight, all of this also happens to work because the code in the file gets loaded into address <code>0x0</code> in memory. If it was loaded somewhere else, we’d have to figure out what that location is before we could effectively disassemble the code.</p>
</blockquote>
<p>Just like before, let’s look for something human-readable first. Searching through the strings brings up a couple error strings that seem like they might get thrown by the code we care about:</p>

<p><a href="https://svbtleusercontent.com/gKVzk72q5AxiF9pCfVcjhy0xspap.png"><img src="https://svbtleusercontent.com/gKVzk72q5AxiF9pCfVcjhy0xspap_small.png" alt="Untitled 12.png"/></a></p>

<p>Ghidra has identified what it calls XREFs here - cross-references, indicating that these strings are called from a certain place. Let’s follow this reference:</p>

<p><a href="https://svbtleusercontent.com/gcBK4NjtDVJ8v5qgrjgB5k0xspap.png"><img src="https://svbtleusercontent.com/gcBK4NjtDVJ8v5qgrjgB5k0xspap_small.png" alt="Untitled 13.png"/></a></p>

<p>Aha! Now we’re getting somewhere. This looks an awful lot like a switch statement, decompiled by Ghidra here as an <code>if</code> tree. It seems like there are a series of error codes (<code>0x100</code> through <code>0x105</code>, then <code>0x200</code>, <code>0x201</code>, etc.) that each correspond with an error string that presumably gets printed on the screen. Let’s keep pulling on this thread. Using Ghidra’s “Find References” function, we end up at this function:</p>

<p><a href="https://svbtleusercontent.com/2DJ9WVpTN5TMHvFCPDQTjw0xspap.png"><img src="https://svbtleusercontent.com/2DJ9WVpTN5TMHvFCPDQTjw0xspap_small.png" alt="Untitled 15.png"/></a></p>

<p>We’re getting closer! Ghidra’s done something great for us here: the decompiled code includes some variable names, automatically determined based on the strings that those variables point to. Given that we know that some of these variables are strings, we can take some guesses and use Ghidra’s “Rename” and “Retype” tools to make this function read a lot more clearly:</p>

<p><a href="https://svbtleusercontent.com/gMeWBvZRTUGa2oJ1RxqpPa0xspap.png"><img src="https://svbtleusercontent.com/gMeWBvZRTUGa2oJ1RxqpPa0xspap_small.png" alt="Untitled 16.png"/></a></p>

<p>It looks like we have a two-stage process here: first, the new operating system file is checked by calling <code>ActuallyCheckOrFlashTheOS?(0, ?)</code>. If the check passes, then the same function is called again with <code>1</code>. It seems like that function probably reads the <code>.KOS</code> file format we’re investigating: let’s dig in there.</p>

<p><a href="https://svbtleusercontent.com/rPojvMhT4qmmU5cx729fMG0xspap.png"><img src="https://svbtleusercontent.com/rPojvMhT4qmmU5cx729fMG0xspap_small.png" alt="Untitled 17.png"/></a></p>

<p>This doesn’t have any of the hints we saw before; there are no human-readable strings we can read, nor are there any function names. Instead, we can look at the <u>structure</u> of this function to understand what it does. Even without variable names, the structure of this code looks pretty similar to opening a file in C! It looks like we have an <code>fopen</code>-style call, followed by an <code>fread</code>, followed by an <code>fread</code> again in a while loop. Let’s add comments to make this clearer.</p>

<p><a href="https://svbtleusercontent.com/2Qr5fommAbc8fv4V3yvrJA0xspap.png"><img src="https://svbtleusercontent.com/2Qr5fommAbc8fv4V3yvrJA0xspap_small.png" alt="Untitled 18.png"/></a></p>

<p>With the comments, it seems we now have a couple questions answered:</p>

<ul>
<li>The <code>.KOS</code> file starts with a 4-byte header: <code>SYS0</code>
</li>
<li>After the header, the file is divided into fixed-size chunks</li>
<li>Each chunk starts with a single 4-byte integer</li>
<li>An unknown number of bytes of actual data are read</li>
<li>Each chunk ends with a single 4-byte integer which seems to be some sort of checksum</li>
</ul>

<p>However, there’s one new question we need to answer as well: why are certain constants and functions referenced at very high addresses in memory? (i.e.: <code>0x021317ac</code> seems to contain the number of bytes in each chunk of the <code>.KOS</code> file, but the data in the ROM doesn’t reach that high!)</p>

<p>To better understand what’s at those high addresses, let’s turn to the service manual for this unit. (Huge shoutout to <a href="https://www.linkedin.com/in/david-ryskalczyk-237747b/">David Ryskalczyk</a> for this idea!) Buried deep in a non-OCR’d PDF lies this useful tidbit of information, in a list of diagnostic procedures:</p>

<p><a href="https://svbtleusercontent.com/5ZAXWk4ttBBkp68tyS6eLw0xspap.png"><img src="https://svbtleusercontent.com/5ZAXWk4ttBBkp68tyS6eLw0xspap_small.png" alt="Untitled 19.png"/></a></p>

<p>Thanks, service manual! It looks like <code>0x021317ac</code> lands directly in the middle of this synth’s “volatile RAM” - the RAM used by the processor while it’s running.</p>
<blockquote>
<p>It’s great that we had the service manual as a reference here. Without this information, we could have made an educated guess based on address prefixes that show up often in the code. If that didn’t help, we could have tried to find an electrical schematic for the unit and traced the address lines coming from the various chips to the CPU. This stuff gets complicated <em>fast</em>.</p>
</blockquote>
<p>Let’s tell Ghidra to treat this as RAM in its “Memory Map” window, and then jump to near the address we’re interested in: <code>0x021317ac</code>.</p>

<p><a href="https://svbtleusercontent.com/8tccFh78je8ZKcjR5SmwAn0xspap.png"><img src="https://svbtleusercontent.com/8tccFh78je8ZKcjR5SmwAn0xspap_small.png" alt="Untitled 21.png"/></a></p>

<p>There’s no data here (as Ghidra knows this is RAM, which is randomly initialized when a computer starts) and it looks like the address in question is being read from (<code>(R)</code>) , but never written to (<code>(W)</code>). Maybe the writes are happening further up?</p>

<p><a href="https://svbtleusercontent.com/kJu9hAXZ6qidEGWCifGPf20xspap.png"><img src="https://svbtleusercontent.com/kJu9hAXZ6qidEGWCifGPf20xspap_small.png" alt="Untitled 20.png"/></a></p>

<p>Aha! Ghidra shows us that a function is writing directly to the start of RAM. Given that we had to scroll up 6,060 bytes to find the first write, maybe this method copies a bunch of data into RAM. Let’s click through to see what’s there.</p>

<p><a href="https://svbtleusercontent.com/eMEDtuGhFbk2JSJfW9dxBM0xspap.png"><img src="https://svbtleusercontent.com/eMEDtuGhFbk2JSJfW9dxBM0xspap_small.png" alt="Untitled 22.png"/></a></p>

<p>Uh, one sec. Let’s rename some stuff again.</p>

<p><a href="https://svbtleusercontent.com/iV4t4noXP4p7a62LMoDya70xspap.png"><img src="https://svbtleusercontent.com/iV4t4noXP4p7a62LMoDya70xspap_small.png" alt="Untitled 23.png"/></a></p>

<p>Much better. It looks like we’re coping a bunch of data from ROM into RAM - specifically from <code>0x0001860a</code> to <code>0x02130000</code>. How much is a bunch? Well, <code>0x690</code> 32-bit long words, which works out to 6,720 bytes. (This snippet of code also then zeros-out the next <code>0x1e1</code> 32-bit long words, or 1,924 bytes.) Now that we know that the code is probably initialized with the same data as that part of the ROM, we can tell Ghidra to map that part of the ROM to this part of the RAM directly.</p>

<p><a href="https://svbtleusercontent.com/m7P2tJGKvPaf2ZKzsDMXas0xspap.png"><img src="https://svbtleusercontent.com/m7P2tJGKvPaf2ZKzsDMXas0xspap_small.png" alt="Untitled 24.png"/></a></p>

<p>Now, going back to the part of RAM that we were reading, we can see that there are bytes present instead of question marks. </p>

<p><a href="https://svbtleusercontent.com/rnK33wetySZthG6rGLWwEF0xspap.png"><img src="https://svbtleusercontent.com/rnK33wetySZthG6rGLWwEF0xspap_small.png" alt="Untitled 25.png"/></a></p>

<p>It looks like the value stored at <code>0x021317ac</code> is <code>0x20000</code>, which works out to <strong>131,072 bytes</strong>! (We call this “128 kilobytes” because <a href="https://en.wikipedia.org/wiki/Kilobyte#Base_2_.281024_bytes.29">numbers are complicated</a>.)</p>

<p>Great! So we’ve now figured out that each chunk of the <code>.KOS</code> file format is 128kB in size. That’s all we need to know to build a decoder for this format, remove the chunk headers, and end up with a file that will have correct relative offsets. This allows Ghidra to properly disassemble and decompile the file, and allows us to actually poke around at the operating system code. (I’ve gone ahead and done this already, and <a href="https://gist.github.com/psobot/bf50c2090bb0fbe5380aefaafea17eed">that <code>.KOS</code> file packer/unpacker is available on GitHub</a>.)</p>
<h2 id="exploring-the-operating-system_2">Exploring the Operating System <a href="#exploring-the-operating-system_2">#</a>
</h2>
<p>Alright, we’ve now got a “clean” dump of the operating system. Let’s open up that file in Ghidra, just like we tried to before. Let’s use Ghidra’s search function to find some interesting strings.</p>

<p><a href="https://svbtleusercontent.com/mnnhPaG33kotJD1mrmSCgN0xspap.png"><img src="https://svbtleusercontent.com/mnnhPaG33kotJD1mrmSCgN0xspap_small.png" alt="Untitled 26.png"/></a></p>

<p>Let’s do a quick test to see if we can modify the operating system successfully. Ghidra lets you change instructions or data in a binary; so here, let’s change one of these strings to contain different text. (We’ll need to keep the length the same, to avoid moving other code around.)</p>

<p>After re-packing the operating system, let’s load it onto a floppy disk, install it on the real hardware, and…</p>

<p><a href="https://svbtleusercontent.com/kSwaFD7KJaMhvRRnqUC2eN0xspap.png"><img src="https://svbtleusercontent.com/kSwaFD7KJaMhvRRnqUC2eN0xspap_small.png" alt="fake_error.png"/></a></p>

<p>What gives? Well, remember that “some sort of checksum” field we saw in the <code>.KOS</code> format earlier? It turns out, that’s actually checked by the hardware when installing a new OS. Luckily, Ghidra can help us here too -let’s go back to the bootloader and click through to <code>FUN_0x021302b2</code>, which looks like it computes some sort of checksum for us.</p>

<p><a href="https://svbtleusercontent.com/wQKEXn6U92waidpf4BaSvc0xspap.png"><img src="https://svbtleusercontent.com/wQKEXn6U92waidpf4BaSvc0xspap_small.png" alt="Untitled 37.png"/></a></p>

<p>And again, after guessing at some variable names:</p>

<p><a href="https://svbtleusercontent.com/5pEtT4NrqcWRazLRTk2vP70xspap.png"><img src="https://svbtleusercontent.com/5pEtT4NrqcWRazLRTk2vP70xspap_small.png" alt="Untitled 38.png"/></a></p>

<p>It looks like this checksum function is pretty simple: for each byte <code>x</code>, the checksum is equal to <code>x + checksum</code> shifted left by one bit, which is then bitwise OR’d with <code>x + checksum</code> shifted right by 31 bits. That’s a neat checksum I hadn’t seen before at all, and which advanced checksum reversing tools like the wonderful <a href="https://github.com/8051Enthusiast/delsum">delsum</a> can’t figure out either.</p>

<p>With this checksum, we can now change <a href="https://gist.github.com/psobot/bf50c2090bb0fbe5380aefaafea17eed">our <code>.KOS</code> file dumping script</a> to properly re-pack new data with correct checksums. And once that’s done, let’s try flashing the OS again:</p>

<p><a href="https://svbtleusercontent.com/o8cVnXRvAzL6jLoqkCNUsR0xspap.png"><img src="https://svbtleusercontent.com/o8cVnXRvAzL6jLoqkCNUsR0xspap_small.png" alt="fake_success.png"/></a></p>

<p>We can now flash a new operating system onto this hardware, modifying or extending its capabilities however we’d like. (That part, however, is left as an exercise for the reader.)</p>
<h2 id="what-we-learned_2">What We Learned <a href="#what-we-learned_2">#</a>
</h2>
<p>Wow, that was a bit of an ordeal. I’d never used Ghidra before trying this project, and now I feel comfortable enough to use it for future absurdly-obscure retrocomputing reverse engineering. The techniques that seemed to work the best were:</p>

<ul>
<li>Look for human-readable strings first.</li>
<li>Don’t be afraid to <a href="https://en.wiktionary.org/wiki/yak_shaving">take a “side quest”</a> (like reverse engineering a bootloader) to make your primary effort (patching an operating system) more successful.</li>
<li>Use Ghidra’s decompiler. It’s really amazing.</li>
<li>Look for structure in the decompiled code.</li>
<li>Rename functions, variables, and data types once you even have a guess at what they might do.</li>
<li>Look up documentation and resources for the system if they’re available.</li>
<li>Sometimes, you just have to manually step through dozens of possible examples to find what you’re looking for. (It gets easier the more you do it!)</li>
</ul>

<p>(And thanks in part to this reverse engineering, <a href="https://github.com/mamedev/mame/pull/9545">the K2000 emulation in the MAME project now boots</a>!)</p>

<hr/>

<p>Special thanks to David Ryskalczyk for unblocking my work half way through this project, and to David Ryskalczyk and Zameer Manji for reviewing drafts of this post.</p>

  <figure id="kudo_f2ZJqD9HUpe2wNHQPFwG2B">
    <a href="#kudo">
      
    </a>
    <p>64</p>
    <p>Kudos</p>
  </figure>
  <figure id="kudo_side_f2ZJqD9HUpe2wNHQPFwG2B">
    <a href="#kudo">
      
    </a>
    <p>64</p>
    <p>Kudos</p>
  </figure>
</article></div>
  </body>
</html>
