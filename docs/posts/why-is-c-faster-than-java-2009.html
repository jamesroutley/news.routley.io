<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marc.info/?l=git&amp;m=124111702609723&amp;w=2">Original</a>
    <h1>Why Is C Faster Than Java (2009)</h1>
    
    <div id="readability-page-1" class="page">
<pre><b>[<a href="https://marc.info/?l=git&amp;m=124111069731966&amp;w=2">prev in list</a>] [<a href="https://marc.info/?l=git&amp;m=124111765010821&amp;w=2">next in list</a>] [<a href="https://marc.info/?l=git&amp;m=124110148215703&amp;w=2">prev in thread</a>] [<a href="https://marc.info/?l=git&amp;m=124111794711383&amp;w=2">next in thread</a>] </b>
<b><SPAN size="+1">
List:       <a href="https://marc.info/?l=git&amp;r=1&amp;w=2">git</a>
Subject:    <a href="https://marc.info/?t=124109397500006&amp;r=1&amp;w=2">Re: Why Git is so fast (was: Re: Eric Sink&#39;s blog - notes on git,</a>
From:       <a href="https://marc.info/?a=116266674400008&amp;r=1&amp;w=2">&#34;Shawn O. Pearce&#34; &lt;spearce () spearce ! org&gt;</a>
Date:       <a href="https://marc.info/?l=git&amp;r=1&amp;w=2&amp;b=200904">2009-04-30 18:43:19</a>
Message-ID: <a href="https://marc.info/?i=20090430184319.GP23604%20()%20spearce%20!%20org">20090430184319.GP23604 () spearce ! org</a></SPAN>
[Download RAW <a href="https://marc.info/?l=git&amp;m=124111702609723&amp;q=mbox">message</a> or <a href="https://marc.info/?l=git&amp;m=124111702609723&amp;q=raw">body</a>]</b>

Michael Witten &lt;mfwitten@gmail.com&gt; wrote:
&gt; On Thu, Apr 30, 2009 at 07:17, Jakub Narebski &lt;jnareb@gmail.com&gt; wrote:
&gt; &gt; I hope that JGit developers can
&gt; &gt; tell us whether using higher level language affects performance, how
&gt; &gt; much, and what features of higher-level language are causing decrease
&gt; &gt; in performance.
&gt; 
&gt; Java is definitely higher than C, but you can do some pretty low-level
&gt; operations on bits and bytes and the like, not to mention the presence
&gt; of a JIT.

But its still costly compared to C.
 
&gt; My point: I don&#39;t think that Java can tell us anything special in this regard.

Sure it can.

Peff I think made a good point here, that we rely on a lot of small
tweaks in the C git code to get *really* good performance.  5% here,
10% there, and suddenly you are 60% faster than you were before.
Nico, Linus, Junio, they have all spent some time over the past
3 or 4 years trying to tune various parts of Git to just flat out
run fast.

Higher level languages hide enough of the machine that we can&#39;t
make all of these optimizations.

JGit struggles with not having mmap(), or when you do use Java NIO
MappedByteBuffer, we still have to copy to a temporary byte[] in
order to do any real processing.  C Git avoids that copy.  Sure,
other higher level langauges may offer a better mmap facility,
but they also tend to offer garbage collection and most try to tie
the mmap management into the GC &#34;for safety and ease of use&#34;.

JGit struggles with not having unsigned types in Java.  There are
many locations in JGit where we really need &#34;unsigned int32_t&#34; or
&#34;unsigned long&#34; (largest machine word available) or &#34;unsigned char&#34;
but these types just don&#39;t exist in Java.  Converting a byte up to
an int just to treat it as an unsigned requires an extra &#34; &amp; 0xFF&#34;
operation to remove the sign extension.

JGit struggles with not having an efficient way to represent a SHA-1.
C can just say &#34;unsigned char<a name="-20"></a><a href="#20">[20]</a>&#34; and have it inline into the
container&#39;s memory allocation.  A byte<a href="#20">[20]</a> in Java will cost an
*additional* 16 bytes of memory, and be slower to access because
the bytes themselves are in a different area of memory from the
container object.  We try to work around it by converting from a
byte<a href="#20">[20]</a> to 5 ints, but that costs us machine instructions.

C Git takes for granted that memcpy(a, b, 20) is dirt cheap when
doing a copy from an inflated tree into a struct object.  JGit has
to pay a huge penalty to copy that 20 byte region out into 5 ints,
because later on, those 5 ints are cheaper.

Other higher level languages also lack the ability to mark a
type unsigned.  Or face similiar penalties with storing a 20 byte
binary region.

Native Java collection types have been a snare for us in JGit.
We&#39;ve used java.util.* types when they seem to be handy and already
solve the data structure problem at hand, but they tend to preform
a lot worse than writing a specialized data structure.

For example, we have ObjectIdSubclassMap for what should be
Map&lt;ObjectId,Object&gt;.  Only it requires that the Object type you
use as the &#34;value&#34; entry in the map extend from ObjectId, as the
instance serves as both key *and* value.  But it screams when
compared to HashMap&lt;ObjectId,Object&gt;.  (For those who don&#39;t know,
ObjectId is JGit&#39;s &#34;unsigned char<a href="#20">[20]</a>&#34; for a SHA-1.)

Just a day or so ago I wrote LongMap, a faster HashMap&lt;Long,Object&gt;,
for hashing objects by indexes in a pack file.  Again, the boxing
costs in Java to convert a &#34;long&#34; (largest integer type) into an
Object that the standard HashMap type would accept was rather high.

Right now, JGit is still paying dearly when it comes to ripping
apart a commit or a tree object to follow the object links.  Or when
invoking inflate().  We spend a lot more time doing this sort of work
than C git does, and yet we&#39;re trying to be as close to the machine
as we can go by using byte[] whenever possible, by avoiding copying
whenever possible, and avoiding memory allocation when possible.

Notably, `rev-list --objects --all` takes about 2x as long in
JGit as it does in C Git on a project like the linux kernel, and
`index-pack` for the full ~270M pack file takes about 2x as long.

Both parts of JGit are about as good as I know how to make them,
but we&#39;re really at the mercy of the JIT, and changes in the JIT
can cause us to perform worse (or better) than before.  Unlike in
C Git where Linus has done assembler dumps of sections of code and
tried to determine better approaches.  :-)

So. Yes, its practical to build Git in a higher level language, but
you just can&#39;t get the same performance, or tight memory utilization,
that C Git gets.  That&#39;s what that higher level language abstraction
costs you.  But, JGit performs reasonably well; well enough that
we use internally at Google as a git server.

-- 
Shawn.
--
To unsubscribe from this list: send the line &#34;unsubscribe git&#34; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html" rel="nofollow">http://vger.kernel.org/majordomo-info.html</a>
<b>[<a href="https://marc.info/?l=git&amp;m=124111069731966&amp;w=2">prev in list</a>] [<a href="https://marc.info/?l=git&amp;m=124111765010821&amp;w=2">next in list</a>] [<a href="https://marc.info/?l=git&amp;m=124110148215703&amp;w=2">prev in thread</a>] [<a href="https://marc.info/?l=git&amp;m=124111794711383&amp;w=2">next in thread</a>] </b>
</pre>
  </div>
  </body>
</html>
