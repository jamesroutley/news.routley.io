<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jez.io/history-of-sorbet-syntax/">Original</a>
    <h1>Past, present, and future of Sorbet type syntax</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Here’s the elephant in the room: Sorbet’s syntax is ugly.</p>
<p>When people start complaining about Sorbet’s syntax, I have to spend a lot of time deflecting or even defending it, which is annoying: I’m right there with you, the syntax is ugly! It’s verbose. It’s foreign. It doesn’t resemble any typed language, <strong>nor</strong> does it complement Ruby’s unique style.</p>
<p>My counter is that when it comes to language design, <strong>semantics</strong>—what the types mean—are easily 10 times more important than <strong>syntax</strong>. This is <a href="https://www.andrew.cmu.edu/course/15-312/phil.html">what I was taught</a>; it’s also <a href="https://stripe.com/blog/sorbet-stripes-type-checker-for-ruby">what I’ve seen</a>. <a href="https://gwern.net/doc/cs/algorithm/1985-naur.pdf">Programming is an act of theory building</a>, and when you sit down to write <em>code</em>, you’re trying to codify how you’re thinking about a problem as much as instructions for the machine. Types become a tool to help get the semantics from your head into the codebase. That’s a lossy process, and types fill a role kind of like “error correcting codes” for brain dumping.</p>
<p>So I try <em>very</em> hard to not get sucked into debates about syntax—in no small part because from where I stand, tons of the people complaining about the syntax <em>also</em> don’t like the semantics, they just don’t know how to say it. And not only do they not like Sorbet’s semantics, they don’t like <strong>statically typed</strong> semantics in the first place! Even if I changed their mind on Sorbet’s syntax, there’s basically no way I’ll change their mind on the idea of static types. So why bother? They’re not prospective Sorbet users no matter what I say.</p>
<p>But in thinking that way, I ignore the cohort of committed, enthusiastic Sorbet users who actually love the semantics but tolerate the syntax.</p>
<p>So that’s who this talk is for: I’m not here to convince you to start liking typing or to start using Sorbet! Instead, I want to lay everything out there, so that the people who are motivated by syntax more than me have a view of problem space and can channel their complaints into action.</p>
<p>We’re going to cover a lot of things:</p>
<ul>
<li>The historical context at Stripe that gave rise to Sorbet</li>
<li>The goals and constraints which sprung from that historical context</li>
<li>Various problems we discovered over time, forcing redesigns of the type syntax</li>
<li>Potential future changes to the syntax, ranging from “yeah we should probably have done that yesterday” to “that sounds like it’ll never happen… but wouldn’t it be cool?”</li>
</ul>

<p>Before we get too much further, I’ve forgotten to introduce myself: my name is Jake, and I’ve been working full time on Sorbet for almost 7 years.</p>
<figure>
<img src="https://blog.jez.io/assets/img/jez-type-safety.png" alt=":jez-type-safety:"/>
<figcaption aria-hidden="true"><code>:jez-type-safety:</code></figcaption>
</figure>
<p>I started at Stripe a month before the Ruby type checker project kicked off, and I joined the team 1 year later. Most of what I have to say here is from direct experience, from chatting with people over lunch, or from combing old emails. That means some of the things that happened before 2017 are a little hazy, but I’m going to do my best.</p>
<p>In mid 2017 (when I joined, and when Sorbet was starting) there were about 750 people at Stripe, of whom about 300 were engineers.</p>
<p>Every 6 months (to this day), Stripe runs a survey of all engineers at the company, asking them about about their productivity. In the first survey of 2017, engineers were asked to pick priorities for the Developer Productivity team by choosing three things from this list:</p>
<ol type="1">
<li>Better technical documentation</li>
<li>Static type checking for Ruby</li>
<li>Unattended deploys</li>
<li>CI flakiness on feature branch builds</li>
<li>CI flakiness on master builds</li>
<li>Async programming primitives and libraries</li>
<li>Seamlessly start multiple services in development</li>
<li>GUI for running database migrations</li>
</ol>
<p>It’s in order by their responses: the top two were “better docs” and “static type checking.” Also, when looking at the free-form responses, the number of complaints mentioning themes of “code organization, interfaces, and modularity” had doubled from 6 months prior. Test speed, while substantially improved from the prior survey, was still a widespread call out.</p>
<p>One of those open-ended questions was: “What are the top 1-2 things we could do to make you more productive?” It got answers like these:</p>
<blockquote>
<p>mono-repoing all the things; better, more intuitive code/documentation (clearer interfaces, <strong>static typing</strong>, stronger assurances from linting)</p>
</blockquote>
<blockquote>
<p><strong>static types</strong> / less magic in [Stripe’s Ruby codebase]</p>
</blockquote>
<blockquote>
<p>builds being faster, tests on branches passing meaning you wont break master, <strong>static types</strong> in [Stripe’s Ruby codebase]</p>
</blockquote>
<p>I mention all this to drive home that we didn’t build Sorbet because we wanted to, we built it because people were asking for it!</p>
<p>Which is also the reason it’s hard for me to give advice to people adopting Sorbet. They’ll ask me, “How did you convince people?” and I’ll say, “we didn’t: <em>they</em> convinced <em>us</em>!” But I’m getting off track, because I’m not trying to convince people to use Sorbet today.</p>
<h2 id="appetite-for-typing-at-stripe">Appetite for typing at Stripe</h2>
<p>We can dig a little deeper and see where this appetite for typing came from. As early as 2013, Stripe had developed its own object-database mapper for defining database models:<span><label for="sn-0">⊕</label><span>Why didn’t Stripe use mongoid, the official MongoDB ODM? I have no clue. The first mongoid commit predates the first Odin commit by about 4 years, so it’s not like there was no alternative.</span></span></p>
<figure>
<img src="https://blog.jez.io/assets/img/odin-model-2013-03-18.png" alt="Documentation for Odin::Model, a precursor to Chalk::ODM, and later T::Struct"/>
<figcaption aria-hidden="true">Documentation for <code>Odin::Model</code>, a precursor to <code>Chalk::ODM</code>, and later <code>T::Struct</code></figcaption>
</figure>
<p>For anyone who uses Sorbet, this should look remarkably familiar: it’s the exact same code you’d use to define a <a href="https://sorbet.org/docs/tstruct"><code>T::Struct</code></a> today. Like any good ODM (or ORM), it did type validation at runtime to ensure that database write operations don’t store bad data.</p>
<p>Stripe also had a library for defining interfaces, circa 2013:</p>
<p><img src="https://blog.jez.io/assets/img/chalk-interface-2013-10-15.png"/></p>
<p>The idea was that an interface would expose a specific set of required methods. Then you’d box up a value of that interface, like</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>animal <span>=</span> <span>Animal</span><span>.from_instance</span>(<span>Dog</span><span>.new</span>)</span></code></pre></div>
<p>and the library would check that you implemented all the required methods. Also, it prevented calling methods <strong>not</strong> in the interface at runtime. So for example, <code>animal.bark</code> would raise a <code>NoMethodError</code>, because <code>bark</code> isn’t in the public interface of <code>Animal</code>. If you needed to call a <code>Dog</code>-specific method, you’d have to explicitly downcast to a dog:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>animal<span>.bark</span> <span># 💥</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>dog <span>=</span> <span>Chalk</span><span>::</span><span>Interface</span><span>.dynamic_cast</span>(animal, <span>Dog</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>dog<span>.bark</span>    <span># ✅</span></span></code></pre></div>
<p>If you called <code>dynamic_cast</code> on something that was not a <code>Dog</code>, you get back <code>nil</code>, like how <code>dynamic_cast</code> works in C++.</p>
<p>You should be seeing a pattern here: most of Stripe’s appetite for typing manifested as Ruby DSLs for runtime checking and declaring explicit interfaces. This came to an inflection point in November 2016—almost a year before Sorbet—when Stripe implemented what it called “interface constraints.”</p>
<p><span><label for="sn-1">⊕</label><span>For the Stripe employees playing “spot the anachronism,” this screenshot should have been of a <a href="https://github.com/dropbox/hackpad">Hackpad</a>, but that’s now long gone.</span></span></p>
<figure>
<img src="https://blog.jez.io/assets/img/interface-constraints-proposal-2016-11-08.png" alt="The proposal for declare_method, the earliest predecesor of sig, c. Nov 2016"/>
<figcaption aria-hidden="true">The proposal for <code>declare_method</code>, the earliest predecesor of <code>sig</code>, c. Nov 2016</figcaption>
</figure>
<p>It was a library for wrapping methods with runtime type checking, mimicking a primitive form of “<a href="https://en.wikipedia.org/wiki/Design_by_contract">design by contract</a>.”<span><label for="sn-2">⊕</label><span>In a recurring theme, there were already libraries for “design by contract” in Ruby, like <a href="https://github.com/egonSchiele/contracts.ruby">contracts.ruby</a>, that Stripe chose not to use. I can’t find mention of them influencing Stripe’s “interface constraints proposal,” but in retrospect I think it was important for Stripe to have control over the evolution of Sorbet’s type syntax.</span></span></p>
<p>This library directly evolved into Sorbet’s <code>sig</code> syntax, and it worked the same way: the library allowed declaring a specification for a method, and then wrapped the following method with runtime type checks.</p>
<p>The proposal mentions maybe one day building static checking for these annotations, but that was mostly hypothetical: runtime checking was the point from the beginning. Ruby is a language all about the neat things you can do at runtime!</p>
<p>Later, this <code>declare_method</code> library gained support for declaring overridable and abstract methods, which let it replace the <code>Chalk::Interface</code> library (so that interfaces could talk about required signatures, not just required methods):</p>
<figure>
<img src="https://blog.jez.io/assets/img/standard_method-2017-10-12.png" alt="Email announcing declare_method → standard_method et al."/>
<figcaption aria-hidden="true">Email announcing <code>declare_method</code> → <code>standard_method</code> et al.</figcaption>
</figure>
<p>Throw in the fact that the JavaScript codebase powering Stripe’s dashboard gained support for static typing in July 2016 (via <a href="https://flow.org">Flow</a><span><label for="sn-3">⊕</label><span>While researching, I came across the <a href="https://engineering.fb.com/2014/11/18/web/flow-a-new-static-type-checker-for-javascript/">original Flow announcement</a> from 2014, which is interesting in understanding its original design goals.</span></span>), and the stage was set. Desire for Ruby static typing came to a flash point in the first half of 2017. A particular email (which has been lost to the sands of retention) from an influential engineer at Stripe called out the difficulty of making sense of Stripe’s Ruby codebase given its size and evolution, alongside specific, high-profile instances where a static type checker would have eliminated those problems.</p>

<p>The team evaluated various approaches:</p>
<ul>
<li><p>Rewriting to a typed language wouldn’t work: Stripe had almost 2 million lines of Ruby code at the time, and as we’d say at Stripe, “<a href="https://stripe.com/jobs/culture#:~:text=classic%E2%80%9D%20Stripe%20slogans%3A-,We%20haven%E2%80%99t%20won%20yet,-Efficiency%20is%20leverage">we haven’t won yet</a>,” which is a way of saying the work never stops. There’s no time to pause all feature development and rewrite to another language, because that wouldn’t make our users’ lives better.</p></li>
<li><p>There mostly weren’t any existing type checkers for Ruby. There’s a project called <a href="https://github.com/tupl-tufts/rdl">RDL</a>, but it’s kind of a hybrid static+runtime checker. RDL’s “static” checking happens after eagerly loading all the code and using the Ruby VM to do most of the symbol lookup. At the time, eagerly loading all of Stripe’s code (not even asking RDL to check types) took a few minutes—by comparison, the first version of Sorbet ran in a few seconds.</p></li>
<li><p>There was also a project called <a href="https://github.com/typedruby/typedruby">TypedRuby</a>, largely a passion project of an engineer working at GitHub. After a few weeks of evaluation, it seemed that there were enough bugs in the project that fixing them would involve a near complete rewrite of the project anyways.</p></li>
</ul>
<p>So the team decided to write something from scratch, which meant being tasked with designing a type syntax. Let’s look at some approaches.</p>
<h2 id="the-typescript-approach-add-types-on-top-compile-them-away">The TypeScript approach: add types on top, compile them away</h2>
<p>The most obvious approach in retrospect is the approach that has worked spectacularly for TypeScript: build our own syntax, free of any constraints in the source language, and compile it away with a build step.</p>
<p>For Sorbet this would have meant a <strong>massive break with Ruby compatibility</strong>. In the JavaScript world, minifiers, tree shakers, transpilers, and compile-to-JS languages were everywhere. Most developers gave up the “save file, reload page” development paradigm ages before TypeScript became popular: CoffeeScript predated TypeScript by 4 years.</p>
<p>But even today, I’m not aware of a single Ruby codebase of significant size that has a source transform build step that blocks running the tests or reloading the service. Ruby engineers expect to run tests directly and to be able to reload a service immediately after saving a file. Introducing a mandatory build step that blocked running a test would have been a big point of friction.</p>
<p>Even if <em>Stripe</em> was okay self-imposing a build step, it would break virtually all Ruby dev tools. Linters, syntax highlighting, and code formatting would break. Observability tools would show backtraces in the wrong spots, because the Ruby VM doesn’t have source mapping. IDEs like RubyMine would fall back to being text editors.</p>
<p>Let’s say we built all those tools, too. We wanted to open source Sorbet one day: this was a top-line goal right in the project brief. If anyone were ever to adopt Sorbet, it would need to be gradual: to not require fundamentally reworking how the codebase builds, tests, and deploys code just to try it out. Adopting a build step is a huge “all or nothing” decision for a codebase.</p>

<p>If we can’t change the source syntax, maybe we make our own syntax for declaring types? Every source file could be paired with a kind of “header” type definition file that declares the types.</p>
<p>Basically all gradual languages end up supporting this anyways: TypeScript has <code>*.d.ts</code>, Python has <code>*.pyi</code>. Sorbet has <code>*.rbi</code> files, and Ruby eventually shipped <code>*.rbs</code>. You need these files to declare types for files completely outside your control: third-party gems, things defined in native extensions, etc.</p>
<p>The problem is that they’re only half of a solution: even if you use RBS files to annotate methods, you’ll still need <strong>explicit type casts</strong> inside method bodies. RBS files alone don’t have a way to say, “trust me, right here I know that this variable is an <code>Integer</code>.”</p>
<p>I will say: the nice thing about this approach is that you’re free to choose a syntax that’s as clean as you want: it’s a blank slate on type syntax design, with virtually zero constraints, even more blank than the transpiler approach. We’ll come back to this later.</p>

<p>If the types needs to be in the source, and we can’t change the syntax, maybe we’ll invent our own syntax in comments? Google’s Closure Compiler chose this strategy well before TypeScript appeared, and Ruby already had a history of comment-based type annotations via tools like YARD. Sorbet could have formalized a rigid type-based comment syntax, and used that for both method signatures and inline type casts.</p>
<p>But here we return to the issue of runtime checking: Stripe engineers were asking for <strong>static and runtime type checking</strong>, not static instead of runtime!</p>
<p>You get a lot for free if you decorate a method with runtime checking, most important being the guarantee that no one can <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> your method:</p>
<blockquote>
<p>With a sufficient number of users of an API,</p>
</blockquote>
<p>Consider code like this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  merchant<span>.default_mcc</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>If <code>charge</code> is non-<code>nil</code>, we return early before checking whether <code>merchant</code> is <code>nil</code> or not. Now suppose we need to edit the method to implement a new “merchant override MCC” feature:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb4-2"><a href="#cb4-2"></a>  override <span>=</span> merchant<span>.override_mcc</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span>return</span> override <span>if</span> override</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb4-6"><a href="#cb4-6"></a>  merchant<span>.default_mcc</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span>end</span></span></code></pre></div>
<p>This new override is meant to take precedence over any “MCC” on a charge. Is this change safe? Callers were supposed to be passing in a non-<code>nil</code> merchant into this method, but maybe some weren’t? If we aren’t sure, now we have to be defensive, which is annoying and maybe causes other problems!</p>
<p>But this problem vanishes when making a changes in methods with runtime-checked signatures.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a>sig <span>{</span> params(<span>charge:</span> <span>Charge</span>, <span>merchant:</span> <span>Merchant</span>)<span>.returns</span>(<span>MCC</span>) <span>}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb5-3"><a href="#cb5-3"></a>  override <span>=</span> merchant<span>.override_mcc</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span>return</span> override <span>if</span> override</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb5-7"><a href="#cb5-7"></a>  merchant<span>.default_mcc</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span>end</span></span></code></pre></div>
<p>If the signature says it’s non-<code>nil</code>, we can rely on that invariant throughout the method body, in all conditionals. Adding a new call to <code>merchant.override_mcc</code> cannot cause <em>net new</em> uncaught <code>NoMethodError</code> exceptions as long as the method already had a runtime-checked <code>sig</code>. In a growing codebase with changes from hundreds of people, runtime checking ensures code remains flexible without fear.</p>
<p>A comment-based approach to type syntax would have meant giving up on runtime-checked signatures. Again: runtime checking is a unique strength of Ruby’s dynamism!</p>
<h2 id="the-dsl-approach-declare_method-becomes-sig">The DSL approach: <code>declare_method</code> becomes <code>sig</code></h2>
<p>The approach that Sorbet picked was to repurpose Stripe’s <code>declare_method</code> DSL. As a benefit, it meant that the project immediately gained thousands of trustworthy annotations to use as a proving ground for the implementation.</p>
<p>Before we dive into specific considerations for the DSL approach, I want to take a second to marvel at the fact that this approach even works at all. It’s wild, isn’t it? Decorate a method with a single line—in a language that doesn’t have first-class decorators!—and the following method gets runtime checking. You can try to approximate this with higher-order functions in JavaScript, but it doesn’t look anywhere near as good.</p>
<p>At the same time that <code>declare_method</code> shortened to <code>sig</code>, type syntax shortened from things like <code>Opus::Types.any(NilClass, String)</code> to just <code>T.nilable(String)</code>.</p>
<p>The specific syntax that <code>sig</code> uses evolved a handful of times<span><label for="sn-4">⊕</label><span>Truly, while I was researching this topic, I found so many wacky old syntaxes, far too many for this post. If you want the details feel free to ask me.</span></span> and I want to talk about those changes, but not before considering one final approach.</p>
<h2 id="the-python-approach-first-party-type-hints">The Python approach: first-party type hints</h2>
<p>Support for typing in Python went differently. Way back in 2007, a proposal for “<a href="https://peps.python.org/pep-3107/">Function Annotations</a>” was accepted:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>def</span> foo(a: expression, b: expression <span>=</span> <span>5</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    ...</span></code></pre></div>
<p>The idea was that annotations would be completely devoid of meaning, so that various tools could ascribe their own. As in: you could stash arbitrary strings there and use them for documentation, or you could put class names there and use them as types, etc. Even at the time it was accepted, people were <a href="https://mail.python.org/pipermail/python-ideas/2007-January/000032.html">already discussing</a> interoperability of various project’s annotations, and eventually in 2015 a follow up proposal formalized <a href="https://peps.python.org/pep-0484/">Type Hints</a>, saying essentially, “You don’t have to use Function Annotations for types, but if you’re going to, you should follow these conventions for what the types mean.”</p>
<p>The annotations play to the strengths of Python as a dynamic, runtime-focused language. They’re not static-only annotations that get compiled away like TypeScript: they’re present at runtime via the <code>__annotations__</code> property, and annotations can evaluate arbitrary code! The Python VM does not use them for runtime checking, but <a href="https://docs.pydantic.dev/latest/concepts/validation_decorator/">multiple</a>, <a href="https://typeguard.readthedocs.io/en/latest/">third-party</a> <a href="https://beartype.readthedocs.io/en/latest/">libraries</a> provide decorators that do.</p>
<p>For Python, this approach has a lot going for it:</p>
<ul>
<li>It’s a first class syntax that feels at home with other parts of the language’s syntax.</li>
<li>Individual projects can choose whether they want runtime checks or not.</li>
<li>The annotations are always present at runtime for third-party tools to consume them directly.</li>
</ul>
<p>The obvious downside is that it requires a change to the VM. In the planning phase of Sorbet, it would have been a non-starter to ask the Ruby team to invent syntax for us.</p>
<p>… but if you squint, Sorbet’s DSL approach is almost the same as this type hint approach!</p>
<ul>
<li>Both treat annotations as completely optional.</li>
<li>Both treat annotations as runnable syntax, allowing the full flexibility of the language.</li>
<li>Both allow for optional static and optional runtime checking.</li>
<li>Both provide a reflection API to get the annotations at runtime.</li>
</ul>
<p>The biggest difference is just the syntax—both offer the <strong>semantics</strong> that we need! When Sorbet started with the DSL approach, a selling point was that it would be easy to migrate to a blessed, upstream type hint approach if that ever became an option.</p>
<p>The type hint approach has unfortunately stalled for Ruby. I have more thoughts on this, but for now let’s keep retracing the evolution of Sorbet’s DSL syntax.</p>

<p>Both the DSL approach and the type hint approach share the feature that types are expressions. This leads to three big constraints on the design of a syntax.</p>
<h2 id="when-the-syntax-we-want-is-taken">When the syntax we want is taken</h2>
<p>When types are expressions, sometimes type syntax you want already has another meaning.</p>
<p>It would be really nice to use <code>|</code> for union types, <code>&amp;</code> for intersection types, and <code>[]</code> for generic types, directly on class or module names:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>Integer</span> <span>|</span> <span>String</span>         <span># Module#|</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>Runnable</span> <span>&amp;</span> <span>HasOwner</span>      <span># Module#&amp;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>Box</span><span>[</span><span>Integer</span><span>]</span>             <span># Module#[]</span></span></code></pre></div>
<p>There are two problems:</p>
<ul>
<li><p>It would involve monkey patching <code>Module</code>, which would be controversial, and thus need to be opt-in: this syntax could not be the sole accepted syntax.</p></li>
<li><p>Some singleton classes may already define these methods. <code>Array</code> and <code>Set</code> are examples from the standard library:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>Array</span><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span>           <span># Array.[]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span># =&gt; [1, 2, 3]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>Set</span><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span>             <span># Set.[]</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span># =&gt; #&lt;Set: {1, 2, 3}&gt;</span></span></code></pre></div>
<p>So <code>Array[Integer]</code> would not make a generic type, but rather a length 1 array: <code>[Integer]</code>.<span><label for="sn-5">⊕</label><span>While we’re in the realm of the wacky, we could have “block-scoped” monkey patches where we replace the meaning of certain methods when evaluating the <code>sig</code> block to make this work, but the earlier point stands: some people won’t want that.</span></span></p></li>
</ul>
<p>Something similar comes up for tuples: the <code>|</code> and <code>&amp;</code> methods already mean something for Arrays:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>[</span><span>1</span>, <span>3</span>, <span>5</span><span>]</span> <span>|</span> <span>[</span><span>2</span>, <span>4</span>, <span>6</span><span>]</span>    <span># Array#|</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span># =&gt; [1, 3, 5, 2, 4, 6]</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span> <span>&amp;</span> <span>[</span><span>2</span>, <span>3</span>, <span>4</span><span>]</span>    <span># Array#&amp;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span># =&gt; [2, 3]</span></span></code></pre></div>
<p>In this case, it might be easier to abandon using raw <code>Array</code> literals for tuples, and instead use a syntax like <code>T[Integer, String]</code> to define a tuple, freeing up <code>|</code> and <code>&amp;</code>.</p>
<p>While building Sorbet, our goal was to have one way to do things, for consistency. Maybe it’s time to relax that? If Ruby is okay having three names for filtering a list, maybe Sorbet can be okay having more than one way to specify union types. We could let individual codebases decide which syntax they want to use.</p>
<h2 id="forward-references">Forward references</h2>
<p>When types are expressions, you have to worry about forward references in type syntax. The evolution of the DSL syntax looked like this:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>declare_method(<span>{</span><span>x:</span> <span>Integer</span><span>}</span>, <span>returns:</span> <span>String</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>standard_method(<span>{</span><span>x:</span> <span>Integer</span><span>}</span>, <span>returns:</span> <span>String</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>sig<span>.params</span>(<span>x:</span> <span>Integer</span>)<span>.returns</span>(<span>String</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>sig <span>{</span> params(<span>x:</span> <span>Integer</span>)<span>.returns</span>(<span>String</span>) <span>}</span></span></code></pre></div>
<p>The most recent change switched to specifying types inside a block, which was done so that adding a <code>sig</code> wouldn’t cause load-order problems. For example:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a><span>class</span> <span>A</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  sig<span>.params</span>(<span>x:</span> <span>MyData</span>)<span>.void</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span>def</span> <span>self</span><span>.example</span>(my_data)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span>puts</span>(my_data<span>.foo</span>)</span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span>end</span></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span>MyData</span> <span>=</span> <span>Struct</span><span>.new</span>(<span>:foo</span>)</span>
<span id="cb11-8"><a href="#cb11-8"></a><span>end</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span>A</span><span>.example</span>(<span>MyData</span><span>.new</span>(<span>42</span>))</span></code></pre></div>
<p>There’s no problem loading this file, until you add a <code>sig</code> (pictured using the old, eager syntax). Even though the <code>MyData#foo</code> method is called on line 4, above its definition on line 7, that doesn’t matter because <code>example</code> isn’t called until line 10.</p>
<p>But adding the <code>sig</code> breaks that: there’s now a forward reference to <code>MyData</code> which the sig evaluates eagerly, causing an exception at load time. This kept causing problems as people added more <code>sig</code>’s. The problem was worse because of autoloading: in development everything might have looked fine, because you only evaluated things in a certain order, but then in CI or production things loading in a different order would bite you.</p>
<p>Hiding all the types inside a block switches signatures from evaluating eagerly to lazily: the runtime implementation defers forcing the block until the first call of the method. These days, you basically only get a load-order issue if the code already had a load order issue.</p>
<p>It’s interesting to point out that Python type hints went through a very similar growing pain, and in newer versions of Python you can write:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>from</span> __future__ <span>import</span> annotations</span></code></pre></div>
<p>to convert type hints from being evaluated eagerly to lazily. The <a href="https://peps.python.org/pep-0649/">proposal introducing it</a> is very well written and has a great summary of the history and problems.</p>
<h2 id="sometimes-you-really-want-custom-syntax">Sometimes you really want custom syntax</h2>
<p>When types are expressions, you’re limited by what’s valid Ruby syntax. There’s a lot of alternative syntaxes that would be really nice for type syntax:</p>
<ul>
<li><code>Integer?</code> instead of <code>T.nilable(Integer)</code></li>
<li><code>(Integer) -&gt; String</code> instead of <code>T.proc.params(arg0: Integer).returns(String)</code></li>
<li><code>|</code> and <code>&amp;</code> without monkey patches</li>
</ul>
<p>The other approaches (transpiler, RBS files, documentation comments) don’t have this limitation: with those approaches you’re free to pick any syntax you want.</p>
<p>There’s a lot that can still be done while operating under the “types as expressions” constraint, but there’s no denying that if you give that up, you can get some really terse type syntaxes.</p>

<p>What’s next for Sorbet’s type syntax? We’ve learned a bunch of constraints in the design space:</p>
<ul>
<li>It can’t break compatibility with Ruby, or no one will use it.</li>
<li>We need a syntax that works for runtime checking too, because Ruby is a runtime-focused language at its core.</li>
<li>There’s only so far you can go with “types as expressions,” but we could probably go a little further with optional monkey patches.</li>
<li>Adding a signature can’t cause code to load out of its usual order.</li>
</ul>
<p>So this leads to a few next steps:</p>
<ul>
<li>Probably we should build opt-in support for syntax that requires monkey patches?</li>
<li>We can think about some backwards-incompatible changes, like to how tuple types are declared.</li>
<li>We can think about making some super-verbose things (like generic methods) less verbose.</li>
</ul>
<p>But I want to suggest one more option, which is a bit more radical: what if the Ruby VM parsed RBS comments and associated them with method definitions?</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>A</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span>#: (Integer) -&gt; String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span>def</span> <span>self</span><span>.foo</span>(x)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>Soutaro introduced this comment-based syntax for RBS <a href="https://youtu.be/26sbpaGbU-0?t=1143">at RubyKaigi in 2024</a>. It’s a syntax that both Steep and TypeProf understand, and that Sorbet is gaining support for. Right now it’s just in comments… but what if the Ruby VM actually parsed these comments and exposed them at runtime?</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>A</span><span>.method</span>(<span>:foo</span>)<span>.rbs_annotation</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>A</span><span>.rbs_annotation</span>(<span>:foo</span>)</span></code></pre></div>
<p>If RBS comments were exposed by the Ruby VM like this, it wouldn’t force people to choose between Ruby’s elegant RBS syntax and Sorbet’s powerful runtime type checking.</p>
<p>It also solves some of the problems with “types as expressions,” because types wouldn’t be expressions anymore: the Ruby VM would choose how to parse these annotations, meaning that we still get terse syntax, able to use <code>|</code> and <code>[]</code> free of other constraints. It would also fix the forward reference problem because the VM wouldn’t be evaluating these comments, just parsing them for other tools to consume. Those tools might attempt to resolve constant names, but that’s up to each tool to figure out when and how to do that.</p>
<p>Having RBS annotations available at runtime would be useful for more than just Sorbet:</p>
<ul>
<li>IRB could use these annotations to show completion results, without having to parse RBS comments separately and associate them with the methods.</li>
<li>Gems could get creative with how they use it. For example, you could imagine a JSON Schema library where the schemas are defined by collecting all the type hints in a <code>Struct</code> or <code>Data</code> class.</li>
<li>Linters could piggy back off the Ruby VM’s parser and be able to pass along the parsed RBS annotations to custom linter rules, so that lint rules don’t have to parse the annotations themselves.</li>
</ul>
<p>Given that it starts from a comment-based syntax, you could still make it be optional, something that doesn’t affect you at all unless you want it to.</p>
<p>This solution isn’t a silver bullet: it wouldn’t do anything for <code>T.let</code> assertions where you want to make an assertion for a specific value at runtime, but it’s a great start!</p>
<p>In the end, all I’m trying to say is: we don’t have to think of Sorbet’s syntax as “done.” Even if Ruby never adds support for type hints, we can keep improving Sorbet. But also it’s an exciting time for type annotations in Ruby itself, and I remain optimistic for the future of the wider Ruby typing ecosystem.</p>
</div></div>
  </body>
</html>
