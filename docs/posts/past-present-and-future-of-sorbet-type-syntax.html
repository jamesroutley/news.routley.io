<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jez.io/history-of-sorbet-syntax/">Original</a>
    <h1>Past, present, and future of Sorbet type syntax</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Here‚Äôs the elephant in the room: Sorbet‚Äôs syntax is ugly.</p>
<p>When people start complaining about Sorbet‚Äôs syntax, I have to spend a lot of time deflecting or even defending it, which is annoying: I‚Äôm right there with you, the syntax is ugly! It‚Äôs verbose. It‚Äôs foreign. It doesn‚Äôt resemble any typed language, <strong>nor</strong> does it complement Ruby‚Äôs unique style.</p>
<p>My counter is that when it comes to language design, <strong>semantics</strong>‚Äîwhat the types mean‚Äîare easily 10 times more important than <strong>syntax</strong>. This is <a href="https://www.andrew.cmu.edu/course/15-312/phil.html">what I was taught</a>; it‚Äôs also <a href="https://stripe.com/blog/sorbet-stripes-type-checker-for-ruby">what I‚Äôve seen</a>. <a href="https://gwern.net/doc/cs/algorithm/1985-naur.pdf">Programming is an act of theory building</a>, and when you sit down to write <em>code</em>, you‚Äôre trying to codify how you‚Äôre thinking about a problem as much as instructions for the machine. Types become a tool to help get the semantics from your head into the codebase. That‚Äôs a lossy process, and types fill a role kind of like ‚Äúerror correcting codes‚Äù for brain dumping.</p>
<p>So I try <em>very</em> hard to not get sucked into debates about syntax‚Äîin no small part because from where I stand, tons of the people complaining about the syntax <em>also</em> don‚Äôt like the semantics, they just don‚Äôt know how to say it. And not only do they not like Sorbet‚Äôs semantics, they don‚Äôt like <strong>statically typed</strong> semantics in the first place! Even if I changed their mind on Sorbet‚Äôs syntax, there‚Äôs basically no way I‚Äôll change their mind on the idea of static types. So why bother? They‚Äôre not prospective Sorbet users no matter what I say.</p>
<p>But in thinking that way, I ignore the cohort of committed, enthusiastic Sorbet users who actually love the semantics but tolerate the syntax.</p>
<p>So that‚Äôs who this talk is for: I‚Äôm not here to convince you to start liking typing or to start using Sorbet! Instead, I want to lay everything out there, so that the people who are motivated by syntax more than me have a view of problem space and can channel their complaints into action.</p>
<p>We‚Äôre going to cover a lot of things:</p>
<ul>
<li>The historical context at Stripe that gave rise to Sorbet</li>
<li>The goals and constraints which sprung from that historical context</li>
<li>Various problems we discovered over time, forcing redesigns of the type syntax</li>
<li>Potential future changes to the syntax, ranging from ‚Äúyeah we should probably have done that yesterday‚Äù to ‚Äúthat sounds like it‚Äôll never happen‚Ä¶ but wouldn‚Äôt it be cool?‚Äù</li>
</ul>

<p>Before we get too much further, I‚Äôve forgotten to introduce myself: my name is Jake, and I‚Äôve been working full time on Sorbet for almost 7 years.</p>
<figure>
<img src="https://blog.jez.io/assets/img/jez-type-safety.png" alt=":jez-type-safety:"/>
<figcaption aria-hidden="true"><code>:jez-type-safety:</code></figcaption>
</figure>
<p>I started at Stripe a month before the Ruby type checker project kicked off, and I joined the team 1 year later. Most of what I have to say here is from direct experience, from chatting with people over lunch, or from combing old emails. That means some of the things that happened before 2017 are a little hazy, but I‚Äôm going to do my best.</p>
<p>In mid 2017 (when I joined, and when Sorbet was starting) there were about 750 people at Stripe, of whom about 300 were engineers.</p>
<p>Every 6 months (to this day), Stripe runs a survey of all engineers at the company, asking them about about their productivity. In the first survey of 2017, engineers were asked to pick priorities for the Developer Productivity team by choosing three things from this list:</p>
<ol type="1">
<li>Better technical documentation</li>
<li>Static type checking for Ruby</li>
<li>Unattended deploys</li>
<li>CI flakiness on feature branch builds</li>
<li>CI flakiness on master builds</li>
<li>Async programming primitives and libraries</li>
<li>Seamlessly start multiple services in development</li>
<li>GUI for running database migrations</li>
</ol>
<p>It‚Äôs in order by their responses: the top two were ‚Äúbetter docs‚Äù and ‚Äústatic type checking.‚Äù Also, when looking at the free-form responses, the number of complaints mentioning themes of ‚Äúcode organization, interfaces, and modularity‚Äù had doubled from 6 months prior. Test speed, while substantially improved from the prior survey, was still a widespread call out.</p>
<p>One of those open-ended questions was: ‚ÄúWhat are the top 1-2 things we could do to make you more productive?‚Äù It got answers like these:</p>
<blockquote>
<p>mono-repoing all the things; better, more intuitive code/documentation (clearer interfaces, <strong>static typing</strong>, stronger assurances from linting)</p>
</blockquote>
<blockquote>
<p><strong>static types</strong> / less magic in [Stripe‚Äôs Ruby codebase]</p>
</blockquote>
<blockquote>
<p>builds being faster, tests on branches passing meaning you wont break master, <strong>static types</strong> in [Stripe‚Äôs Ruby codebase]</p>
</blockquote>
<p>I mention all this to drive home that we didn‚Äôt build Sorbet because we wanted to, we built it because people were asking for it!</p>
<p>Which is also the reason it‚Äôs hard for me to give advice to people adopting Sorbet. They‚Äôll ask me, ‚ÄúHow did you convince people?‚Äù and I‚Äôll say, ‚Äúwe didn‚Äôt: <em>they</em> convinced <em>us</em>!‚Äù But I‚Äôm getting off track, because I‚Äôm not trying to convince people to use Sorbet today.</p>
<h2 id="appetite-for-typing-at-stripe">Appetite for typing at Stripe</h2>
<p>We can dig a little deeper and see where this appetite for typing came from. As early as 2013, Stripe had developed its own object-database mapper for defining database models:<span><label for="sn-0">‚äï</label><span>Why didn‚Äôt Stripe use mongoid, the official MongoDB ODM? I have no clue. The first mongoid commit predates the first Odin commit by about 4 years, so it‚Äôs not like there was no alternative.</span></span></p>
<figure>
<img src="https://blog.jez.io/assets/img/odin-model-2013-03-18.png" alt="Documentation for Odin::Model, a precursor to Chalk::ODM, and later T::Struct"/>
<figcaption aria-hidden="true">Documentation for <code>Odin::Model</code>, a precursor to <code>Chalk::ODM</code>, and later <code>T::Struct</code></figcaption>
</figure>
<p>For anyone who uses Sorbet, this should look remarkably familiar: it‚Äôs the exact same code you‚Äôd use to define a <a href="https://sorbet.org/docs/tstruct"><code>T::Struct</code></a> today. Like any good ODM (or ORM), it did type validation at runtime to ensure that database write operations don‚Äôt store bad data.</p>
<p>Stripe also had a library for defining interfaces, circa 2013:</p>
<p><img src="https://blog.jez.io/assets/img/chalk-interface-2013-10-15.png"/></p>
<p>The idea was that an interface would expose a specific set of required methods. Then you‚Äôd box up a value of that interface, like</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>animal <span>=</span> <span>Animal</span><span>.from_instance</span>(<span>Dog</span><span>.new</span>)</span></code></pre></div>
<p>and the library would check that you implemented all the required methods. Also, it prevented calling methods <strong>not</strong> in the interface at runtime. So for example, <code>animal.bark</code> would raise a <code>NoMethodError</code>, because <code>bark</code> isn‚Äôt in the public interface of <code>Animal</code>. If you needed to call a <code>Dog</code>-specific method, you‚Äôd have to explicitly downcast to a dog:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>animal<span>.bark</span> <span># üí•</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>dog <span>=</span> <span>Chalk</span><span>::</span><span>Interface</span><span>.dynamic_cast</span>(animal, <span>Dog</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>dog<span>.bark</span>    <span># ‚úÖ</span></span></code></pre></div>
<p>If you called <code>dynamic_cast</code> on something that was not a <code>Dog</code>, you get back <code>nil</code>, like how <code>dynamic_cast</code> works in C++.</p>
<p>You should be seeing a pattern here: most of Stripe‚Äôs appetite for typing manifested as Ruby DSLs for runtime checking and declaring explicit interfaces. This came to an inflection point in November 2016‚Äîalmost a year before Sorbet‚Äîwhen Stripe implemented what it called ‚Äúinterface constraints.‚Äù</p>
<p><span><label for="sn-1">‚äï</label><span>For the Stripe employees playing ‚Äúspot the anachronism,‚Äù this screenshot should have been of a <a href="https://github.com/dropbox/hackpad">Hackpad</a>, but that‚Äôs now long gone.</span></span></p>
<figure>
<img src="https://blog.jez.io/assets/img/interface-constraints-proposal-2016-11-08.png" alt="The proposal for declare_method, the earliest predecesor of sig, c.¬†Nov 2016"/>
<figcaption aria-hidden="true">The proposal for <code>declare_method</code>, the earliest predecesor of <code>sig</code>, c.¬†Nov 2016</figcaption>
</figure>
<p>It was a library for wrapping methods with runtime type checking, mimicking a primitive form of ‚Äú<a href="https://en.wikipedia.org/wiki/Design_by_contract">design by contract</a>.‚Äù<span><label for="sn-2">‚äï</label><span>In a recurring theme, there were already libraries for ‚Äúdesign by contract‚Äù in Ruby, like <a href="https://github.com/egonSchiele/contracts.ruby">contracts.ruby</a>, that Stripe chose not to use. I can‚Äôt find mention of them influencing Stripe‚Äôs ‚Äúinterface constraints proposal,‚Äù but in retrospect I think it was important for Stripe to have control over the evolution of Sorbet‚Äôs type syntax.</span></span></p>
<p>This library directly evolved into Sorbet‚Äôs <code>sig</code> syntax, and it worked the same way: the library allowed declaring a specification for a method, and then wrapped the following method with runtime type checks.</p>
<p>The proposal mentions maybe one day building static checking for these annotations, but that was mostly hypothetical: runtime checking was the point from the beginning. Ruby is a language all about the neat things you can do at runtime!</p>
<p>Later, this <code>declare_method</code> library gained support for declaring overridable and abstract methods, which let it replace the <code>Chalk::Interface</code> library (so that interfaces could talk about required signatures, not just required methods):</p>
<figure>
<img src="https://blog.jez.io/assets/img/standard_method-2017-10-12.png" alt="Email announcing declare_method ‚Üí standard_method et al."/>
<figcaption aria-hidden="true">Email announcing <code>declare_method</code> ‚Üí <code>standard_method</code> et al.</figcaption>
</figure>
<p>Throw in the fact that the JavaScript codebase powering Stripe‚Äôs dashboard gained support for static typing in July 2016 (via <a href="https://flow.org">Flow</a><span><label for="sn-3">‚äï</label><span>While researching, I came across the <a href="https://engineering.fb.com/2014/11/18/web/flow-a-new-static-type-checker-for-javascript/">original Flow announcement</a> from 2014, which is interesting in understanding its original design goals.</span></span>), and the stage was set. Desire for Ruby static typing came to a flash point in the first half of 2017. A particular email (which has been lost to the sands of retention) from an influential engineer at Stripe called out the difficulty of making sense of Stripe‚Äôs Ruby codebase given its size and evolution, alongside specific, high-profile instances where a static type checker would have eliminated those problems.</p>

<p>The team evaluated various approaches:</p>
<ul>
<li><p>Rewriting to a typed language wouldn‚Äôt work: Stripe had almost 2 million lines of Ruby code at the time, and as we‚Äôd say at Stripe, ‚Äú<a href="https://stripe.com/jobs/culture#:~:text=classic%E2%80%9D%20Stripe%20slogans%3A-,We%20haven%E2%80%99t%20won%20yet,-Efficiency%20is%20leverage">we haven‚Äôt won yet</a>,‚Äù which is a way of saying the work never stops. There‚Äôs no time to pause all feature development and rewrite to another language, because that wouldn‚Äôt make our users‚Äô lives better.</p></li>
<li><p>There mostly weren‚Äôt any existing type checkers for Ruby. There‚Äôs a project called <a href="https://github.com/tupl-tufts/rdl">RDL</a>, but it‚Äôs kind of a hybrid static+runtime checker. RDL‚Äôs ‚Äústatic‚Äù checking happens after eagerly loading all the code and using the Ruby VM to do most of the symbol lookup. At the time, eagerly loading all of Stripe‚Äôs code (not even asking RDL to check types) took a few minutes‚Äîby comparison, the first version of Sorbet ran in a few seconds.</p></li>
<li><p>There was also a project called <a href="https://github.com/typedruby/typedruby">TypedRuby</a>, largely a passion project of an engineer working at GitHub. After a few weeks of evaluation, it seemed that there were enough bugs in the project that fixing them would involve a near complete rewrite of the project anyways.</p></li>
</ul>
<p>So the team decided to write something from scratch, which meant being tasked with designing a type syntax. Let‚Äôs look at some approaches.</p>
<h2 id="the-typescript-approach-add-types-on-top-compile-them-away">The TypeScript approach: add types on top, compile them away</h2>
<p>The most obvious approach in retrospect is the approach that has worked spectacularly for TypeScript: build our own syntax, free of any constraints in the source language, and compile it away with a build step.</p>
<p>For Sorbet this would have meant a <strong>massive break with Ruby compatibility</strong>. In the JavaScript world, minifiers, tree shakers, transpilers, and compile-to-JS languages were everywhere. Most developers gave up the ‚Äúsave file, reload page‚Äù development paradigm ages before TypeScript became popular: CoffeeScript predated TypeScript by 4 years.</p>
<p>But even today, I‚Äôm not aware of a single Ruby codebase of significant size that has a source transform build step that blocks running the tests or reloading the service. Ruby engineers expect to run tests directly and to be able to reload a service immediately after saving a file. Introducing a mandatory build step that blocked running a test would have been a big point of friction.</p>
<p>Even if <em>Stripe</em> was okay self-imposing a build step, it would break virtually all Ruby dev tools. Linters, syntax highlighting, and code formatting would break. Observability tools would show backtraces in the wrong spots, because the Ruby VM doesn‚Äôt have source mapping. IDEs like RubyMine would fall back to being text editors.</p>
<p>Let‚Äôs say we built all those tools, too. We wanted to open source Sorbet one day: this was a top-line goal right in the project brief. If anyone were ever to adopt Sorbet, it would need to be gradual: to not require fundamentally reworking how the codebase builds, tests, and deploys code just to try it out. Adopting a build step is a huge ‚Äúall or nothing‚Äù decision for a codebase.</p>

<p>If we can‚Äôt change the source syntax, maybe we make our own syntax for declaring types? Every source file could be paired with a kind of ‚Äúheader‚Äù type definition file that declares the types.</p>
<p>Basically all gradual languages end up supporting this anyways: TypeScript has <code>*.d.ts</code>, Python has <code>*.pyi</code>. Sorbet has <code>*.rbi</code> files, and Ruby eventually shipped <code>*.rbs</code>. You need these files to declare types for files completely outside your control: third-party gems, things defined in native extensions, etc.</p>
<p>The problem is that they‚Äôre only half of a solution: even if you use RBS files to annotate methods, you‚Äôll still need <strong>explicit type casts</strong> inside method bodies. RBS files alone don‚Äôt have a way to say, ‚Äútrust me, right here I know that this variable is an <code>Integer</code>.‚Äù</p>
<p>I will say: the nice thing about this approach is that you‚Äôre free to choose a syntax that‚Äôs as clean as you want: it‚Äôs a blank slate on type syntax design, with virtually zero constraints, even more blank than the transpiler approach. We‚Äôll come back to this later.</p>

<p>If the types needs to be in the source, and we can‚Äôt change the syntax, maybe we‚Äôll invent our own syntax in comments? Google‚Äôs Closure Compiler chose this strategy well before TypeScript appeared, and Ruby already had a history of comment-based type annotations via tools like YARD. Sorbet could have formalized a rigid type-based comment syntax, and used that for both method signatures and inline type casts.</p>
<p>But here we return to the issue of runtime checking: Stripe engineers were asking for <strong>static and runtime type checking</strong>, not static instead of runtime!</p>
<p>You get a lot for free if you decorate a method with runtime checking, most important being the guarantee that no one can <a href="https://www.hyrumslaw.com/">Hyrum‚Äôs Law</a> your method:</p>
<blockquote>
<p>With a sufficient number of users of an API,</p>
</blockquote>
<p>Consider code like this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  merchant<span>.default_mcc</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>If <code>charge</code> is non-<code>nil</code>, we return early before checking whether <code>merchant</code> is <code>nil</code> or not. Now suppose we need to edit the method to implement a new ‚Äúmerchant override MCC‚Äù feature:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb4-2"><a href="#cb4-2"></a>  override <span>=</span> merchant<span>.override_mcc</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span>return</span> override <span>if</span> override</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb4-6"><a href="#cb4-6"></a>  merchant<span>.default_mcc</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span>end</span></span></code></pre></div>
<p>This new override is meant to take precedence over any ‚ÄúMCC‚Äù on a charge. Is this change safe? Callers were supposed to be passing in a non-<code>nil</code> merchant into this method, but maybe some weren‚Äôt? If we aren‚Äôt sure, now we have to be defensive, which is annoying and maybe causes other problems!</p>
<p>But this problem vanishes when making a changes in methods with runtime-checked signatures.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a>sig <span>{</span> params(<span>charge:</span> <span>Charge</span>, <span>merchant:</span> <span>Merchant</span>)<span>.returns</span>(<span>MCC</span>) <span>}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span>def</span> get_mcc(charge, merchant)</span>
<span id="cb5-3"><a href="#cb5-3"></a>  override <span>=</span> merchant<span>.override_mcc</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span>return</span> override <span>if</span> override</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span>return</span> charge<span>.mcc</span> <span>if</span> charge</span>
<span id="cb5-7"><a href="#cb5-7"></a>  merchant<span>.default_mcc</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span>end</span></span></code></pre></div>
<p>If the signature says it‚Äôs non-<code>nil</code>, we can rely on that invariant throughout the method body, in all conditionals. Adding a new call to <code>merchant.override_mcc</code> cannot cause <em>net new</em> uncaught <code>NoMethodError</code> exceptions as long as the method already had a runtime-checked <code>sig</code>. In a growing codebase with changes from hundreds of people, runtime checking ensures code remains flexible without fear.</p>
<p>A comment-based approach to type syntax would have meant giving up on runtime-checked signatures. Again: runtime checking is a unique strength of Ruby‚Äôs dynamism!</p>
<h2 id="the-dsl-approach-declare_method-becomes-sig">The DSL approach: <code>declare_method</code> becomes <code>sig</code></h2>
<p>The approach that Sorbet picked was to repurpose Stripe‚Äôs <code>declare_method</code> DSL. As a benefit, it meant that the project immediately gained thousands of trustworthy annotations to use as a proving ground for the implementation.</p>
<p>Before we dive into specific considerations for the DSL approach, I want to take a second to marvel at the fact that this approach even works at all. It‚Äôs wild, isn‚Äôt it? Decorate a method with a single line‚Äîin a language that doesn‚Äôt have first-class decorators!‚Äîand the following method gets runtime checking. You can try to approximate this with higher-order functions in JavaScript, but it doesn‚Äôt look anywhere near as good.</p>
<p>At the same time that <code>declare_method</code> shortened to <code>sig</code>, type syntax shortened from things like <code>Opus::Types.any(NilClass, String)</code> to just <code>T.nilable(String)</code>.</p>
<p>The specific syntax that <code>sig</code> uses evolved a handful of times<span><label for="sn-4">‚äï</label><span>Truly, while I was researching this topic, I found so many wacky old syntaxes, far too many for this post. If you want the details feel free to ask me.</span></span> and I want to talk about those changes, but not before considering one final approach.</p>
<h2 id="the-python-approach-first-party-type-hints">The Python approach: first-party type hints</h2>
<p>Support for typing in Python went differently. Way back in 2007, a proposal for ‚Äú<a href="https://peps.python.org/pep-3107/">Function Annotations</a>‚Äù was accepted:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>def</span> foo(a: expression, b: expression <span>=</span> <span>5</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    ...</span></code></pre></div>
<p>The idea was that annotations would be completely devoid of meaning, so that various tools could ascribe their own. As in: you could stash arbitrary strings there and use them for documentation, or you could put class names there and use them as types, etc. Even at the time it was accepted, people were <a href="https://mail.python.org/pipermail/python-ideas/2007-January/000032.html">already discussing</a> interoperability of various project‚Äôs annotations, and eventually in 2015 a follow up proposal formalized <a href="https://peps.python.org/pep-0484/">Type Hints</a>, saying essentially, ‚ÄúYou don‚Äôt have to use Function Annotations for types, but if you‚Äôre going to, you should follow these conventions for what the types mean.‚Äù</p>
<p>The annotations play to the strengths of Python as a dynamic, runtime-focused language. They‚Äôre not static-only annotations that get compiled away like TypeScript: they‚Äôre present at runtime via the <code>__annotations__</code> property, and annotations can evaluate arbitrary code! The Python VM does not use them for runtime checking, but <a href="https://docs.pydantic.dev/latest/concepts/validation_decorator/">multiple</a>, <a href="https://typeguard.readthedocs.io/en/latest/">third-party</a> <a href="https://beartype.readthedocs.io/en/latest/">libraries</a> provide decorators that do.</p>
<p>For Python, this approach has a lot going for it:</p>
<ul>
<li>It‚Äôs a first class syntax that feels at home with other parts of the language‚Äôs syntax.</li>
<li>Individual projects can choose whether they want runtime checks or not.</li>
<li>The annotations are always present at runtime for third-party tools to consume them directly.</li>
</ul>
<p>The obvious downside is that it requires a change to the VM. In the planning phase of Sorbet, it would have been a non-starter to ask the Ruby team to invent syntax for us.</p>
<p>‚Ä¶ but if you squint, Sorbet‚Äôs DSL approach is almost the same as this type hint approach!</p>
<ul>
<li>Both treat annotations as completely optional.</li>
<li>Both treat annotations as runnable syntax, allowing the full flexibility of the language.</li>
<li>Both allow for optional static and optional runtime checking.</li>
<li>Both provide a reflection API to get the annotations at runtime.</li>
</ul>
<p>The biggest difference is just the syntax‚Äîboth offer the <strong>semantics</strong> that we need! When Sorbet started with the DSL approach, a selling point was that it would be easy to migrate to a blessed, upstream type hint approach if that ever became an option.</p>
<p>The type hint approach has unfortunately stalled for Ruby. I have more thoughts on this, but for now let‚Äôs keep retracing the evolution of Sorbet‚Äôs DSL syntax.</p>

<p>Both the DSL approach and the type hint approach share the feature that types are expressions. This leads to three big constraints on the design of a syntax.</p>
<h2 id="when-the-syntax-we-want-is-taken">When the syntax we want is taken</h2>
<p>When types are expressions, sometimes type syntax you want already has another meaning.</p>
<p>It would be really nice to use <code>|</code> for union types, <code>&amp;</code> for intersection types, and <code>[]</code> for generic types, directly on class or module names:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>Integer</span> <span>|</span> <span>String</span>         <span># Module#|</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>Runnable</span> <span>&amp;</span> <span>HasOwner</span>      <span># Module#&amp;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>Box</span><span>[</span><span>Integer</span><span>]</span>             <span># Module#[]</span></span></code></pre></div>
<p>There are two problems:</p>
<ul>
<li><p>It would involve monkey patching <code>Module</code>, which would be controversial, and thus need to be opt-in: this syntax could not be the sole accepted syntax.</p></li>
<li><p>Some singleton classes may already define these methods. <code>Array</code> and <code>Set</code> are examples from the standard library:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>Array</span><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span>           <span># Array.[]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span># =&gt; [1, 2, 3]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>Set</span><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span>             <span># Set.[]</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span># =&gt; #&lt;Set: {1, 2, 3}&gt;</span></span></code></pre></div>
<p>So <code>Array[Integer]</code> would not make a generic type, but rather a length 1 array: <code>[Integer]</code>.<span><label for="sn-5">‚äï</label><span>While we‚Äôre in the realm of the wacky, we could have ‚Äúblock-scoped‚Äù monkey patches where we replace the meaning of certain methods when evaluating the <code>sig</code> block to make this work, but the earlier point stands: some people won‚Äôt want that.</span></span></p></li>
</ul>
<p>Something similar comes up for tuples: the <code>|</code> and <code>&amp;</code> methods already mean something for Arrays:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>[</span><span>1</span>, <span>3</span>, <span>5</span><span>]</span> <span>|</span> <span>[</span><span>2</span>, <span>4</span>, <span>6</span><span>]</span>    <span># Array#|</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span># =&gt; [1, 3, 5, 2, 4, 6]</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>[</span><span>1</span>, <span>2</span>, <span>3</span><span>]</span> <span>&amp;</span> <span>[</span><span>2</span>, <span>3</span>, <span>4</span><span>]</span>    <span># Array#&amp;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span># =&gt; [2, 3]</span></span></code></pre></div>
<p>In this case, it might be easier to abandon using raw <code>Array</code> literals for tuples, and instead use a syntax like <code>T[Integer, String]</code> to define a tuple, freeing up <code>|</code> and <code>&amp;</code>.</p>
<p>While building Sorbet, our goal was to have one way to do things, for consistency. Maybe it‚Äôs time to relax that? If Ruby is okay having three names for filtering a list, maybe Sorbet can be okay having more than one way to specify union types. We could let individual codebases decide which syntax they want to use.</p>
<h2 id="forward-references">Forward references</h2>
<p>When types are expressions, you have to worry about forward references in type syntax. The evolution of the DSL syntax looked like this:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>declare_method(<span>{</span><span>x:</span> <span>Integer</span><span>}</span>, <span>returns:</span> <span>String</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>standard_method(<span>{</span><span>x:</span> <span>Integer</span><span>}</span>, <span>returns:</span> <span>String</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>sig<span>.params</span>(<span>x:</span> <span>Integer</span>)<span>.returns</span>(<span>String</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>sig <span>{</span> params(<span>x:</span> <span>Integer</span>)<span>.returns</span>(<span>String</span>) <span>}</span></span></code></pre></div>
<p>The most recent change switched to specifying types inside a block, which was done so that adding a <code>sig</code> wouldn‚Äôt cause load-order problems. For example:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a><span>class</span> <span>A</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  sig<span>.params</span>(<span>x:</span> <span>MyData</span>)<span>.void</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span>def</span> <span>self</span><span>.example</span>(my_data)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span>puts</span>(my_data<span>.foo</span>)</span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span>end</span></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span>MyData</span> <span>=</span> <span>Struct</span><span>.new</span>(<span>:foo</span>)</span>
<span id="cb11-8"><a href="#cb11-8"></a><span>end</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span>A</span><span>.example</span>(<span>MyData</span><span>.new</span>(<span>42</span>))</span></code></pre></div>
<p>There‚Äôs no problem loading this file, until you add a <code>sig</code> (pictured using the old, eager syntax). Even though the <code>MyData#foo</code> method is called on line 4, above its definition on line 7, that doesn‚Äôt matter because <code>example</code> isn‚Äôt called until line 10.</p>
<p>But adding the <code>sig</code> breaks that: there‚Äôs now a forward reference to <code>MyData</code> which the sig evaluates eagerly, causing an exception at load time. This kept causing problems as people added more <code>sig</code>‚Äôs. The problem was worse because of autoloading: in development everything might have looked fine, because you only evaluated things in a certain order, but then in CI or production things loading in a different order would bite you.</p>
<p>Hiding all the types inside a block switches signatures from evaluating eagerly to lazily: the runtime implementation defers forcing the block until the first call of the method. These days, you basically only get a load-order issue if the code already had a load order issue.</p>
<p>It‚Äôs interesting to point out that Python type hints went through a very similar growing pain, and in newer versions of Python you can write:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>from</span> __future__ <span>import</span> annotations</span></code></pre></div>
<p>to convert type hints from being evaluated eagerly to lazily. The <a href="https://peps.python.org/pep-0649/">proposal introducing it</a> is very well written and has a great summary of the history and problems.</p>
<h2 id="sometimes-you-really-want-custom-syntax">Sometimes you really want custom syntax</h2>
<p>When types are expressions, you‚Äôre limited by what‚Äôs valid Ruby syntax. There‚Äôs a lot of alternative syntaxes that would be really nice for type syntax:</p>
<ul>
<li><code>Integer?</code> instead of <code>T.nilable(Integer)</code></li>
<li><code>(Integer) -&gt; String</code> instead of <code>T.proc.params(arg0: Integer).returns(String)</code></li>
<li><code>|</code> and <code>&amp;</code> without monkey patches</li>
</ul>
<p>The other approaches (transpiler, RBS files, documentation comments) don‚Äôt have this limitation: with those approaches you‚Äôre free to pick any syntax you want.</p>
<p>There‚Äôs a lot that can still be done while operating under the ‚Äútypes as expressions‚Äù constraint, but there‚Äôs no denying that if you give that up, you can get some really terse type syntaxes.</p>

<p>What‚Äôs next for Sorbet‚Äôs type syntax? We‚Äôve learned a bunch of constraints in the design space:</p>
<ul>
<li>It can‚Äôt break compatibility with Ruby, or no one will use it.</li>
<li>We need a syntax that works for runtime checking too, because Ruby is a runtime-focused language at its core.</li>
<li>There‚Äôs only so far you can go with ‚Äútypes as expressions,‚Äù but we could probably go a little further with optional monkey patches.</li>
<li>Adding a signature can‚Äôt cause code to load out of its usual order.</li>
</ul>
<p>So this leads to a few next steps:</p>
<ul>
<li>Probably we should build opt-in support for syntax that requires monkey patches?</li>
<li>We can think about some backwards-incompatible changes, like to how tuple types are declared.</li>
<li>We can think about making some super-verbose things (like generic methods) less verbose.</li>
</ul>
<p>But I want to suggest one more option, which is a bit more radical: what if the Ruby VM parsed RBS comments and associated them with method definitions?</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>A</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span>#: (Integer) -&gt; String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span>def</span> <span>self</span><span>.foo</span>(x)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>Soutaro introduced this comment-based syntax for RBS <a href="https://youtu.be/26sbpaGbU-0?t=1143">at RubyKaigi in 2024</a>. It‚Äôs a syntax that both Steep and TypeProf understand, and that Sorbet is gaining support for. Right now it‚Äôs just in comments‚Ä¶ but what if the Ruby VM actually parsed these comments and exposed them at runtime?</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>A</span><span>.method</span>(<span>:foo</span>)<span>.rbs_annotation</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>A</span><span>.rbs_annotation</span>(<span>:foo</span>)</span></code></pre></div>
<p>If RBS comments were exposed by the Ruby VM like this, it wouldn‚Äôt force people to choose between Ruby‚Äôs elegant RBS syntax and Sorbet‚Äôs powerful runtime type checking.</p>
<p>It also solves some of the problems with ‚Äútypes as expressions,‚Äù because types wouldn‚Äôt be expressions anymore: the Ruby VM would choose how to parse these annotations, meaning that we still get terse syntax, able to use <code>|</code> and <code>[]</code> free of other constraints. It would also fix the forward reference problem because the VM wouldn‚Äôt be evaluating these comments, just parsing them for other tools to consume. Those tools might attempt to resolve constant names, but that‚Äôs up to each tool to figure out when and how to do that.</p>
<p>Having RBS annotations available at runtime would be useful for more than just Sorbet:</p>
<ul>
<li>IRB could use these annotations to show completion results, without having to parse RBS comments separately and associate them with the methods.</li>
<li>Gems could get creative with how they use it. For example, you could imagine a JSON Schema library where the schemas are defined by collecting all the type hints in a <code>Struct</code> or <code>Data</code> class.</li>
<li>Linters could piggy back off the Ruby VM‚Äôs parser and be able to pass along the parsed RBS annotations to custom linter rules, so that lint rules don‚Äôt have to parse the annotations themselves.</li>
</ul>
<p>Given that it starts from a comment-based syntax, you could still make it be optional, something that doesn‚Äôt affect you at all unless you want it to.</p>
<p>This solution isn‚Äôt a silver bullet: it wouldn‚Äôt do anything for <code>T.let</code> assertions where you want to make an assertion for a specific value at runtime, but it‚Äôs a great start!</p>
<p>In the end, all I‚Äôm trying to say is: we don‚Äôt have to think of Sorbet‚Äôs syntax as ‚Äúdone.‚Äù Even if Ruby never adds support for type hints, we can keep improving Sorbet. But also it‚Äôs an exciting time for type annotations in Ruby itself, and I remain optimistic for the future of the wider Ruby typing ecosystem.</p>
</div></div>
  </body>
</html>
