<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielmangum.com/posts/every-byte-wasm-module/">Original</a>
    <h1>Understanding every byte in a WASM module</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <p>In <a href="https://danielmangum.com/posts/wasm-wasi-clang-17/">my last post</a>, we
explored how to build <a href="https://webassembly.github.io/spec/core/">WASM</a> modules,
both with and without <a href="https://wasi.dev/">WASI</a> support, using
<a href="https://clang.llvm.org/">Clang</a>. In a <a href="https://www.reddit.com/r/WebAssembly/comments/18m6xjr/comment/ke2f5xy/">comment on
Reddit</a>,
it was mentioned that much of the setup I walked through in that post could be
avoided by just leveraging <a href="https://www.reddit.com/r/WebAssembly/comments/18m6xjr/comment/ke2f5xy/">Zig’s WASI
supprt</a>.
This is a great point, and I would recommend doing the same. The following
command is inarguably simpler than what I described.</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ zig cc --target=wasm32-wasi
</span></span></code></pre></div><p>However, there are two reasons why knowing how to use Clang for compilation is
useful. First, and most practical, is that I am working on a codebase that uses
Clang for its compiler toolchain, so leveraging Zig is not currently an option.
Second is that understanding the, admittedly more involved, Clang incantations
taught us a little more about what actually goes into a WASM module, and how
that changes when using WASI. In order to know <em>exactly</em> what is inside a WASM
module, we need to crack it open though. That is what we are going to do today!</p>
<p>As a recap, one of the programs we compiled was a simple <code>add()</code> function, which
accepted two integers and returned their sum.</p>
<p><code>wasm32_args.c</code></p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> add(<span>int</span> a, <span>int</span> b) {
</span></span><span><span>  <span>return</span> a+b;
</span></span><span><span>}
</span></span></code></pre></div><p>We compiled it to a WASM module using the following command.</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ /usr/lib/llvm-17/bin/clang -target wasm32 -nostdlib -Wl,--no-entry -Wl,--export-all  -o wasm32_args.wasm wasm32_args.c
</span></span></code></pre></div><p>This produced a binary file which can be recognized as a v1 WASM module.</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ file wasm32_args.wasm 
</span></span><span><span>wasm32_args.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</span></span></code></pre></div><p>We can view the hex contents of the file using <code>xxd</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000000: 0061 736d 0100 0000 010a 0260 0000 6002  .asm.......`..`.
</span></span><span><span>00000010: 7f7f 017f 0303 0200 0105 0301 0002 063f  ...............?
</span></span><span><span>00000020: 0a7f 0141 8088 040b 7f00 4180 080b 7f00  ...A......A.....
</span></span><span><span>00000030: 4180 080b 7f00 4180 080b 7f00 4180 8804  A.....A.....A...
</span></span><span><span>00000040: 0b7f 0041 8008 0b7f 0041 8088 040b 7f00  ...A.....A......
</span></span><span><span>00000050: 4180 8008 0b7f 0041 000b 7f00 4101 0b07  A......A....A...
</span></span><span><span>00000060: a701 0c06 6d65 6d6f 7279 0200 115f 5f77  ....memory...__w
</span></span><span><span>00000070: 6173 6d5f 6361 6c6c 5f63 746f 7273 0000  asm_call_ctors..
</span></span><span><span>00000080: 0361 6464 0001 0c5f 5f64 736f 5f68 616e  .add...__dso_han
</span></span><span><span>00000090: 646c 6503 010a 5f5f 6461 7461 5f65 6e64  dle...__data_end
</span></span><span><span>000000a0: 0302 0b5f 5f73 7461 636b 5f6c 6f77 0303  ...__stack_low..
</span></span><span><span>000000b0: 0c5f 5f73 7461 636b 5f68 6967 6803 040d  .__stack_high...
</span></span><span><span>000000c0: 5f5f 676c 6f62 616c 5f62 6173 6503 050b  __global_base...
</span></span><span><span>000000d0: 5f5f 6865 6170 5f62 6173 6503 060a 5f5f  __heap_base...__
</span></span><span><span>000000e0: 6865 6170 5f65 6e64 0307 0d5f 5f6d 656d  heap_end...__mem
</span></span><span><span>000000f0: 6f72 795f 6261 7365 0308 0c5f 5f74 6162  ory_base...__tab
</span></span><span><span>00000100: 6c65 5f62 6173 6503 090a 4202 0200 0b3d  le_base...B....=
</span></span><span><span>00000110: 0106 7f23 8080 8080 0021 0241 1021 0320  ...#.....!.A.!. 
</span></span><span><span>00000120: 0220 036b 2104 2004 2000 3602 0c20 0420  . .k!. . .6.. . 
</span></span><span><span>00000130: 0136 0208 2004 2802 0c21 0520 0428 0208  .6.. .(..!. .(..
</span></span><span><span>00000140: 2106 2005 2006 6a21 0720 070f 0b00 3404  !. . .j!. ....4.
</span></span><span><span>00000150: 6e61 6d65 0119 0200 115f 5f77 6173 6d5f  name.....__wasm_
</span></span><span><span>00000160: 6361 6c6c 5f63 746f 7273 0103 6164 6407  call_ctors..add.
</span></span><span><span>00000170: 1201 000f 5f5f 7374 6163 6b5f 706f 696e  ....__stack_poin
</span></span><span><span>00000180: 7465 7200 6609 7072 6f64 7563 6572 7301  ter.f.producers.
</span></span><span><span>00000190: 0c70 726f 6365 7373 6564 2d62 7901 0c55  .processed-by..U
</span></span><span><span>000001a0: 6275 6e74 7520 636c 616e 673f 3137 2e30  buntu clang?17.0
</span></span><span><span>000001b0: 2e36 2028 2b2b 3230 3233 3132 3039 3132  .6 (++2023120912
</span></span><span><span>000001c0: 3432 3237 2b36 3030 3937 3038 6234 3336  4227+6009708b436
</span></span><span><span>000001d0: 372d 317e 6578 7031 7e32 3032 3331 3230  7-1~exp1~2023120
</span></span><span><span>000001e0: 3931 3234 3333 362e 3737 2900 2c0f 7461  9124336.77).,.ta
</span></span><span><span>000001f0: 7267 6574 5f66 6561 7475 7265 7302 2b0f  rget_features.+.
</span></span><span><span>00000200: 6d75 7461 626c 652d 676c 6f62 616c 732b  mutable-globals+
</span></span><span><span>00000210: 0873 6967 6e2d 6578 74                   .sign-ext
</span></span></code></pre></div><p>As described in the Binary Format portion of the <a href="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf">WASM
specification</a>,
each module is made up of sections. Each section begins with a 1-byte
identifier.</p>
<table>
<thead>
<tr>
<th>ID (Decimal)</th>
<th>ID (Hex)</th>
<th>Section</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x00</td>
<td>Custom</td>
</tr>
<tr>
<td>1</td>
<td>0x01</td>
<td>Type</td>
</tr>
<tr>
<td>2</td>
<td>0x02</td>
<td>Import</td>
</tr>
<tr>
<td>3</td>
<td>0x03</td>
<td>Function</td>
</tr>
<tr>
<td>4</td>
<td>0x04</td>
<td>Table</td>
</tr>
<tr>
<td>5</td>
<td>0x05</td>
<td>Memory</td>
</tr>
<tr>
<td>6</td>
<td>0x06</td>
<td>Global</td>
</tr>
<tr>
<td>7</td>
<td>0x07</td>
<td>Export</td>
</tr>
<tr>
<td>8</td>
<td>0x08</td>
<td>Start</td>
</tr>
<tr>
<td>9</td>
<td>0x09</td>
<td>Element</td>
</tr>
<tr>
<td>10</td>
<td>0x0a</td>
<td>Code</td>
</tr>
<tr>
<td>11</td>
<td>0x0b</td>
<td>Data</td>
</tr>
<tr>
<td>12</td>
<td>0x0c</td>
<td>Data Count</td>
</tr>
</tbody>
</table>
<p>Each section must be present at most once, and they must be provided in-order,
with the exception being Custom sections, for which there may be an arbitrary
number and they may be present anywhere in the file. Every section begins with
its identifier, then an <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a>
variable-length encoded <code>u32</code> size, followed by the contents of the section. In fact,
all integers in a WASM module are encoded using LEB128.</p>
<hr/>
<p><strong>Decoding LEB128 Integers</strong></p>
<p>LEB128 can be used to encode signed and unsigned integers of arbitrary length.
We will primarily be focused on <code>u32</code> (unsigned 32-bit) integers today, so we’ll
skip detailing how to decode signed integers. You can find more details on the
previously linked Wikipedia page.</p>
<p>The algorithm for decoding unsigned integers is as follows:</p>
<ol>
<li>Take the least significant (lower) 7 bits of the next byte.</li>
<li>Binary shift the 7 bits to the left by 7 multiplied by the byte number
(initially 0) and bitwise <code>OR</code> with previously decoded bits.</li>
<li>If the most significant bit (i.e. the 8th bit) is a <code>0</code>, stop decoding.
Otherwise, go to step (1).</li>
</ol>
<p>As an example, if we had the byte sequence <code>a6 03</code>, we would decode it using the
following steps.</p>
<p>Take first byte and convert hex to binary.</p>
<p>Take least significant 7 bits.</p>
<p>Shift bits left by 0 (this is the “0th” byte, <code>7*0 = 0</code>) and <code>OR</code> with
previously decoded bits (none decoded yet).</p>
<p>Observe that the 8th bit in <code>0xa6</code> is a <code>1</code>, so continue to the next byte.</p>
<p>Take least significant 7 bits.</p>
<p>Shift bits left by 7 (this is the “1st” byte, <code>7*1 = 7</code>) and <code>OR</code> with
previously decoded bits.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0000011 -&gt; 0000011 0000000
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>0000000 0100110 | 0000011 0000000 = 0000011 0100110
</span></span></code></pre></div><p>Observe that the 8th bit in <code>0x03</code> is <code>0</code>. We are done. Convert the final result
to decimal.</p>
<hr/>
<p>Now that we know how to interpret integers, let’s start breaking down the
sections.</p>
<h2 id="preamble">
  Preamble
  <a href="#preamble">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000000: 0061 736d 0100 0000 .... .... .... ....  .asm.......`..`.
</span></span></code></pre></div><p>Before the first section is the “preamble”, which is how <code>file</code> was able to
recognize that our binary was a v1 WASM module. The first 4 bytes decode to
<code>\0asm</code>, with the next 4 bytes indicating the version. WASM is
<a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a>, meaning that the
least significant byte is first. Therefore, the version number is 1.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0100 0000 -&gt; 0000 0001 -&gt; 1
</span></span></code></pre></div><p>The first section begins following the preamble.</p>
<h2 id="type-section">
  Type Section
  <a href="#type-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000000: .... .... .... .... 010a 0260 0000 6002  .asm.......`..`.
</span></span><span><span>00000010: 7f7f 017f .... .... .... .... .... ....  ...............?
</span></span></code></pre></div><p>We can identify the first section as the Type section, as indicated by the first
byte <code>01</code>. Following the identifier is the size, to which we can apply our LEB128
decoding.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0x0a -&gt; 00001010 -&gt; 0001010 -&gt; 10
</span></span></code></pre></div><p>This informs us that the contents of this section should be 10 bytes in size.
The WASM specification describes the Type section contents as a <code>vec</code> of
<code>functype</code>. <em>Vectors</em> are simply an LEB128 encoded <code>u32</code> length followed by a
sequence of their specified element type. The first byte is <code>02</code>, which by now
you can probably recognize as <code>2</code> without needing to actually perform LEB128
decoding. This means that we should see 2 <code>functype</code> elements next.</p>
<p>Function types are prefixed with <code>0x60</code>, then two <code>vec</code>, one for parameter
types, and one for return types, follows. We have <code>00 00</code> for the first
<code>functype</code>. Remembering that <code>vec</code> are prefixed with length. This is essentially
saying that our first function takes 0 parameters and returns 0 values. We can
use <a href="https://webassembly.github.io/wabt/doc/wasm2wat.1.html">the <code>wasm2wat</code>
tool</a> to verify.</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -2 | tail -1
</span></span><span><span>  (type (;0;) (func))
</span></span></code></pre></div><p>The next <code>functype</code> does have parameter and result types. There are two
parameters (<code>0x02</code>), each encoded as <code>0x7f</code>, which corresponds to a signed
32-bit integer (<code>i32</code>). There is one return type (<code>0x01</code>), which is also an
<code>i32</code> (<code>0x7f</code>). Though we don’t have symbol information about this function yet,
given that it is the last one defined we can safely assume this is our <code>add()</code>.</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -3 | tail -1
</span></span><span><span>  (type (;1;) (func (param i32 i32) (result i32)))
</span></span></code></pre></div><h2 id="function-section">
  Function Section
  <a href="#function-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000010: .... .... 0303 0200 01.. .... .... ....  ...............?
</span></span></code></pre></div><p>Next is the Function section (<code>0x03</code>). We do not have an Import section (<code>0x02</code>)
in this module because we did not import any symbols. Because sections must be
provided in-order, we can be certain that no Import section will be provided now
that we have seen the Function section.</p>
<p>The size of this section is <code>3</code> (<code>0x03</code>), and the contents are specified as a
<code>vec</code> of <code>typeidx</code> (type index). A type index is a <code>u32</code>, which will once again
be LEB128 encoded. Our <code>vec</code> begins with <code>0x02</code>, so we should expect two type
indices. The following two bytes, <code>0x00</code> and <code>0x01</code>, correspond to the entries
in our previously detailed Types section.</p>
<p>At this point, we have two functions, each with their own type signature. For
this specific module, the Type and Function sections may seem redundant.
However, consider if we had another function in our module.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> multiply (<span>int</span> a, <span>int</span> b) {
</span></span><span><span>  <span>return</span> a*b
</span></span><span><span>}
</span></span></code></pre></div><p><code>multiply()</code> has the same function signature as <code>add()</code>, meaning that we would
have only one entry for <code>(i32, i32) i32</code> in the Type section, then two entries
in the Function section that referenced the type signature by the corresponding
index. Compiling the new program with <code>multiply()</code> added results in an
indentical preamble and Type section, but we can see that the Function section
(<code>0x03</code>) now has length <code>4</code> (<code>0x04</code>), with a type index <code>vec</code> of length <code>3</code>
(<code>0x03</code>), and three type index entries (<code>0x00</code>, <code>0x01</code>, <code>0x01</code>) with the latter
two referring to the same type signature.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000000: 0061 736d 0100 0000 010a 0260 0000 6002
</span></span><span><span>00000010: 7f7f 017f 0304 0300 0101 .... .... ....
</span></span></code></pre></div><h2 id="memory-section">
  Memory Section
  <a href="#memory-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000010: .... .... .... .... ..05 0301 0002 ....  ...............?
</span></span></code></pre></div><p>We once again skip a section that is not present in our module (Table with ID
<code>0x04</code>), and move on to Memory (<code>0x05</code>). The Memory section contains a <code>vec</code> of
memories (<code>mem</code>), which are made up of <code>limits</code>. In the current WASM
specification, only one memory may be defined. Our Memory section has size of
<code>3</code> bytes (<code>0x03</code>), and, as expected, the first byte (<code>0x01</code>) specifies that the
length of the <code>vec</code> is <code>1</code>. A <code>limit</code> can include both a maximum and a minimum
size (both LEB128 encoded <code>u32</code>), as indicated by the first byte. In our case,
the first byte is <code>0x00</code>, which means that only a minimum size will be defined,
and the maximum is free to grow to any size. If the first byte was <code>0x01</code>, both
a minimum and a maximum would be defined.</p>
<blockquote>
<p>The <a href="https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#spec-changes">threads
proposal</a>
extends <code>limits</code> to be allow specifying whether memory is shared or unshared.</p>
</blockquote>
<p>In our module, the minimum memory size is <code>2</code> (<code>0x02</code>).</p>
<h2 id="global-section">
  Global Section
  <a href="#global-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000010: .... .... .... .... .... .... .... 063f  ...............?
</span></span><span><span>00000020: 0a7f 0141 8088 040b 7f00 4180 080b 7f00  ...A......A.....
</span></span><span><span>00000030: 4180 080b 7f00 4180 080b 7f00 4180 8804  A.....A.....A...
</span></span><span><span>00000040: 0b7f 0041 8008 0b7f 0041 8088 040b 7f00  ...A.....A......
</span></span><span><span>00000050: 4180 8008 0b7f 0041 000b 7f00 4101 0b..  A......A....A...
</span></span></code></pre></div><p>The Global section (<code>0x06</code>) is next, with a size of <code>0x3f</code>. With a larger size,
we can quickly check our LEB128 decoding to ensure that we don’t need to
consider subsequent bytes.</p>
<p>The 8th bit is <code>0</code>, so we can simply convert to the decimal value of <code>63</code> for
our size. The section includes a <code>vec</code> of globals (<code>global</code>), where each
<code>global</code> consists of a type (<code>globaltype</code>) and expression (<code>expr</code>). A
<code>globaltype</code> is made up of a value type (<code>valtype</code>) and a 1-byte flag (<code>mut</code>)
indicating whether the value is mutable or not.</p>
<p>An expression is encoded by a sequence of instructions (<code>instr</code>) with a
terminating byte (<code>0x0b</code>) specifying the end of the sequence. The byte following
the section size, <code>0x0a</code>, informs us that 10 globals will be defined in the
<code>vec</code>. We can easily
extract the first one by looking for the first instance of <code>0x0b</code>.</p>
<p>The <code>0x7f</code> should be familiar at this point as an <code>i32</code>, which is the
<code>globaltype</code> of this <code>global</code>. The following byte, <code>0x01</code>, marks it as mutable
(<code>mut</code>).</p>
<p>This is followed by the initialization expression, which includes the first
instruction we have seen. <code>0x41</code> is the opcode for <code>i32.const</code>, which simply
returns a static <code>i32</code> constant, which is specified by the following bytes.
We’ll need to use our LEB128 decoding to interpret it.</p>
<p>Take the first byte.</p>
<p>Take the least significant 7 bits and shift left 0 bits.</p>
<p>The 8th bit is a <code>1</code> so take the next byte.</p>
<p>Take the least significant 7 bits and shift left 7 bits.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>10001000 -&gt; 0001000 0000000
</span></span></code></pre></div><p><code>OR</code> with previously decoded bits.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0000000 0000000 | 0001000 0000000 = 0001000 0000000
</span></span></code></pre></div><p>The 8th bit is a <code>1</code> so take the next byte.</p>
<p>Take the least significant 7 bits and shift left 14 bits.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000100 -&gt; 0000100 0000000 0000000
</span></span></code></pre></div><p><code>OR</code> with previously decoded bits.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0000000 0001000 0000000 | 0000100 0000000 0000000 = 0000100 0001000 0000000 
</span></span></code></pre></div><p>The 8th bit is a <code>0</code> so we are done.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>0000100 0001000 0000000 -&gt; 66560
</span></span></code></pre></div><p>We can verify our decoding using <code>wasm2wat</code> again.</p>
<blockquote>
<p>The <code>$__stack_pointer</code> symbol name will be found in a later section.</p>
</blockquote>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -34 | tail -1
</span></span><span><span>  (global $__stack_pointer (mut i32) (i32.const 66560))
</span></span></code></pre></div><p>The same process can be applied to all globals in the <code>vec</code>, as shown in the
textual representation.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -43 | tail -10
</span></span><span><span>  (global $__stack_pointer (mut i32) (i32.const 66560))
</span></span><span><span>  (global (;1;) i32 (i32.const 1024))
</span></span><span><span>  (global (;2;) i32 (i32.const 1024))
</span></span><span><span>  (global (;3;) i32 (i32.const 1024))
</span></span><span><span>  (global (;4;) i32 (i32.const 66560))
</span></span><span><span>  (global (;5;) i32 (i32.const 1024))
</span></span><span><span>  (global (;6;) i32 (i32.const 66560))
</span></span><span><span>  (global (;7;) i32 (i32.const 131072))
</span></span><span><span>  (global (;8;) i32 (i32.const 0))
</span></span><span><span>  (global (;9;) i32 (i32.const 1))
</span></span></code></pre></div><h2 id="export-section">
  Export Section
  <a href="#export-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000050: .... .... .... .... .... .... .... ..07  A......A....A...
</span></span><span><span>00000060: a701 0c06 6d65 6d6f 7279 0200 115f 5f77  ....memory...__w
</span></span><span><span>00000070: 6173 6d5f 6361 6c6c 5f63 746f 7273 0000  asm_call_ctors..
</span></span><span><span>00000080: 0361 6464 0001 0c5f 5f64 736f 5f68 616e  .add...__dso_han
</span></span><span><span>00000090: 646c 6503 010a 5f5f 6461 7461 5f65 6e64  dle...__data_end
</span></span><span><span>000000a0: 0302 0b5f 5f73 7461 636b 5f6c 6f77 0303  ...__stack_low..
</span></span><span><span>000000b0: 0c5f 5f73 7461 636b 5f68 6967 6803 040d  .__stack_high...
</span></span><span><span>000000c0: 5f5f 676c 6f62 616c 5f62 6173 6503 050b  __global_base...
</span></span><span><span>000000d0: 5f5f 6865 6170 5f62 6173 6503 060a 5f5f  __heap_base...__
</span></span><span><span>000000e0: 6865 6170 5f65 6e64 0307 0d5f 5f6d 656d  heap_end...__mem
</span></span><span><span>000000f0: 6f72 795f 6261 7365 0308 0c5f 5f74 6162  ory_base...__tab
</span></span><span><span>00000100: 6c65 5f62 6173 6503 09.. .... .... ....  le_base...B....=
</span></span></code></pre></div><p>The Export section (<code>0x07</code>) consists of a <code>vec</code> of <code>export</code>, with each
containing a <code>name</code> and an export description (<code>exportdesc</code>). The <code>name</code> is a
<code>vec</code> of <code>byte</code>, while the <code>exportdesc</code> contains a 1-byte prefix indicating the
type of export, followed by an index to the appropriate section where the export
is defined.</p>
<p>I’ll leave it to the reader to LEB128 decode <code>0xa701</code> as the section size (<code>167</code>
bytes). The first byte following the section size, <code>0x0c</code>, indicates that the
<code>vec</code> will contain 12 exports. The next byte, <code>0x06</code>, is the first byte of the
first export, and thus is defining the length of its name as <code>6</code>. The following
6 bytes can be converted to <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8
characters</a>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>6d 65 6d 6f 72 79 -&gt; memory
</span></span></code></pre></div><p>Because we compiled with <code>-Wl,--export-all</code>, all symbols will be exported. In
this case, <code>memory</code> is referring to the first element in the <code>vec</code> in our Memory
section. The export type prefixes are defined as follows.</p>
<table>
<thead>
<tr>
<th>ID (Hex)</th>
<th>Export</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Function</td>
</tr>
<tr>
<td>0x01</td>
<td>Table</td>
</tr>
<tr>
<td>0x02</td>
<td>Memory</td>
</tr>
<tr>
<td>0x03</td>
<td>Global</td>
</tr>
</tbody>
</table>
<p>As expected, the prefix following <code>memory</code> is <code>0x02</code>. The next byte <code>0x00</code>,
specifies that this export corresponds to the first memory in the <code>vec</code>. The
next two exports are our functions. The first is <code>__wasm_call_ctors</code>, which,
following the name definition, has a function prefix (<code>0x00</code>) and an index to
the first function in the Function section <code>vec</code> (<code>0x00</code>).</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>11 5f 5f 77 61 73 6d 5f 63 61 6c 6c 5f 63 74 6f 72 73 -&gt; __wasm_call_ctors
</span></span></code></pre></div><p>The second correponds out our <code>add()</code> function, and refers to the second
(<code>0x01</code>) function (<code>0x00</code>) in the Function section.</p>
<p>The remaining exports are shown in their textual representation below.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -55 | tail -12
</span></span><span><span>  (export &#34;memory&#34; (memory 0))
</span></span><span><span>  (export &#34;__wasm_call_ctors&#34; (func $__wasm_call_ctors))
</span></span><span><span>  (export &#34;add&#34; (func $add))
</span></span><span><span>  (export &#34;__dso_handle&#34; (global 1))
</span></span><span><span>  (export &#34;__data_end&#34; (global 2))
</span></span><span><span>  (export &#34;__stack_low&#34; (global 3))
</span></span><span><span>  (export &#34;__stack_high&#34; (global 4))
</span></span><span><span>  (export &#34;__global_base&#34; (global 5))
</span></span><span><span>  (export &#34;__heap_base&#34; (global 6))
</span></span><span><span>  (export &#34;__heap_end&#34; (global 7))
</span></span><span><span>  (export &#34;__memory_base&#34; (global 8))
</span></span><span><span>  (export &#34;__table_base&#34; (global 9))
</span></span></code></pre></div><h2 id="code-section">
  Code Section
  <a href="#code-section">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000100: .... .... .... .... ..0a 4202 0200 0b3d  le_base...B....=
</span></span><span><span>00000110: 0106 7f23 8080 8080 0021 0241 1021 0320  ...#.....!.A.!. 
</span></span><span><span>00000120: 0220 036b 2104 2004 2000 3602 0c20 0420  . .k!. . .6.. . 
</span></span><span><span>00000130: 0136 0208 2004 2802 0c21 0520 0428 0208  .6.. .(..!. .(..
</span></span><span><span>00000140: 2106 2005 2006 6a21 0720 070f 0b.. ....  !. . .j!. ....4.
</span></span></code></pre></div><p>In this module, we don’t have a Start (<code>0x08</code>) or Element (<code>0x09</code>) section, so
next is the Code section (<code>0x0a</code>). The section size is <code>66</code> (LEB128 encoded
<code>0x42</code>), and it consists of the body and local variables of the each function as
a <code>vec</code> of <code>code</code>. Each <code>code</code> element consists of a size (<code>u32</code>), <code>vec</code> of
<code>locals</code>, and an expression (<code>expr</code>) made up of instructions.</p>
<blockquote>
<p>Keep in mind that we didn’t specify any optimizations when compiling this
module (e.g. <code>-O3</code>), so our code section is going to be much longer than it
needs to be. However, the unoptimized function body gives us an opportunity to
explore more WASM instructions.</p>
</blockquote>
<p>The <code>vec</code> has two elements (<code>0x02</code>), which correspond to the two entries in the
Function section. The first function has a size of <code>2</code> (<code>0x02</code>), which we can
immediately know means that it has no locals or instructions. The <code>vec</code> of
<code>locals</code> has a length of <code>0</code> (<code>0x00</code>) and the <code>expr</code>, which is its sequence of
instructions, is a single <code>0x0b</code> (the expression terminating byte).</p>
<p>The next function, which is our <code>add()</code>, has a size of <code>61</code> (<code>0x3d</code>). Its <code>vec</code>
of <code>locals</code> has length <code>1</code> (<code>0x01</code>). Locals are encoded as a <code>u32</code> count and a
value type (<code>valtype</code>). That is, there is a single element in the <code>vec</code> for each
value type for which at least one local exists. Because our <code>vec</code> has length
<code>1</code>, we know that all <code>locals</code> are the same value type. Specifically, there are
<code>6</code> (<code>0x06</code>) locals of type <code>i32</code> (<code>0x7f</code>).</p>
<p>We’ll save a deep dive into the WASM instruction set architecture (ISA) for a
future post, but the key difference from most ISAs you have likely interacted
with is that WASM operates as a stack machine. Values that are to be used as
operands for an instruction must first be pushed onto the stack, before
subsequently being popped off the stack and used to compute a result, which is
then pushed onto the stack.</p>
<p>The first instruction in our <code>add()</code> function is encoded as <code>0x23</code>, which
corresponds to <code>global.get</code>. This instruction takes the index (<code>u32</code>) of a symbol in
the Global section, but you may notice something strange when LEB128 decoding
it.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>80 80 80 80 00 -&gt; 00000000 00000000 00000000 00000000
</span></span></code></pre></div><p>Why are we using the maximum length for LEB128 encoding an unsigned 32-bit
integer? The reason is related to <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md#merging-global-sections">Global section merging during
linking</a>.
Though we only need one byte to encode index <code>0</code>, if the index of
<code>$__stack_pointer</code> changes, we can now be certain that the <code>global.get</code>
instruction can be updated without changing the position of any other bytes in
the module.</p>
<p>As previously mentioned, WASM is a stack machine, so <code>global.get</code> is going to
push the value of <code>$__stack_pointer</code> onto the stack.</p>
<p>Our next instruction is <code>0x21</code>, which corresponds to <code>local.set</code>. It pops a
value off the top of the stack, then stores it in the local at the index
specified by the supplied immediate, which in this case is <code>2</code> (<code>0x02</code>).
Combining this instruction with the previous one results in storing the value of
<code>$__stack_pointer</code> in the local at index <code>2</code>. Why use <code>2</code> and not <code>0</code>? In
accordance with the WASM specification, <code>2</code> actually refers to the first
declared local, as parameters are referenced as the first locals.</p>
<blockquote>
<p>The parameters of the function are referenced through 0-based local indices in
the function’s body; they are mutable.</p>
</blockquote>
<p>You may already recognize these first few instructions as part of a <a href="https://danielmangum.com/posts/risc-v-bytes-caller-callee-registers/#an-example">function
prologue</a>
in which we are “growing the stack”. The use of a stack when coming from a
language like C can be confusing given that WASM has its own implicit stack.
Also, in this particular example, it is unnecessary to manage a stack, and, as
you’ll see in a moment, compiling with optimization removes these instructions.
Nevertheless, a “shadow stack” is necessary in some real programs, and we’ll
explore some examples in a future post.</p>
<p>Decompiling the full function body results in the following.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | head -32 | tail -28
</span></span><span><span>  (func $add (type 1) (param i32 i32) (result i32)
</span></span><span><span>    (local i32 i32 i32 i32 i32 i32)
</span></span><span><span>    global.get $__stack_pointer
</span></span><span><span>    local.set 2
</span></span><span><span>    i32.const 16
</span></span><span><span>    local.set 3
</span></span><span><span>    local.get 2
</span></span><span><span>    local.get 3
</span></span><span><span>    i32.sub
</span></span><span><span>    local.set 4
</span></span><span><span>    local.get 4
</span></span><span><span>    local.get 0
</span></span><span><span>    i32.store offset=12
</span></span><span><span>    local.get 4
</span></span><span><span>    local.get 1
</span></span><span><span>    i32.store offset=8
</span></span><span><span>    local.get 4
</span></span><span><span>    i32.load offset=12
</span></span><span><span>    local.set 5
</span></span><span><span>    local.get 4
</span></span><span><span>    i32.load offset=8
</span></span><span><span>    local.set 6
</span></span><span><span>    local.get 5
</span></span><span><span>    local.get 6
</span></span><span><span>    i32.add
</span></span><span><span>    local.set 7
</span></span><span><span>    local.get 7
</span></span><span><span>    return)
</span></span></code></pre></div><p>The only essential instructions are accesing the parameters (<code>local.get 0</code> and
<code>local.get 1</code>), and the eventual adding of the values with <code>i32.add</code>. This can
be observed by recompiling with ooptimization, then Decompiling.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>clang -target wasm32 -nostdlib -Wl,--no-entry -Wl,--export-all -O3-o wasm32_args_optimized.wasm wasm32_args.c
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args_optimized.wasm | head -8 | tail -4
</span></span><span><span>  (func $add (type 1) (param i32 i32) (result i32)
</span></span><span><span>    local.get 1
</span></span><span><span>    local.get 0
</span></span><span><span>    i32.add)
</span></span></code></pre></div><h2 id="custom-sections">
  Custom Sections
  <a href="#custom-sections">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>00000140: .... .... .... .... .... .... ..00 3404  !. . .j!. ....4.
</span></span><span><span>00000150: 6e61 6d65 0119 0200 115f 5f77 6173 6d5f  name.....__wasm_
</span></span><span><span>00000160: 6361 6c6c 5f63 746f 7273 0103 6164 6407  call_ctors..add.
</span></span><span><span>00000170: 1201 000f 5f5f 7374 6163 6b5f 706f 696e  ....__stack_poin
</span></span><span><span>00000180: 7465 7200 6609 7072 6f64 7563 6572 7301  ter.f.producers.
</span></span><span><span>00000190: 0c70 726f 6365 7373 6564 2d62 7901 0c55  .processed-by..U
</span></span><span><span>000001a0: 6275 6e74 7520 636c 616e 673f 3137 2e30  buntu clang?17.0
</span></span><span><span>000001b0: 2e36 2028 2b2b 3230 3233 3132 3039 3132  .6 (++2023120912
</span></span><span><span>000001c0: 3432 3237 2b36 3030 3937 3038 6234 3336  4227+6009708b436
</span></span><span><span>000001d0: 372d 317e 6578 7031 7e32 3032 3331 3230  7-1~exp1~2023120
</span></span><span><span>000001e0: 3931 3234 3333 362e 3737 2900 2c0f 7461  9124336.77).,.ta
</span></span><span><span>000001f0: 7267 6574 5f66 6561 7475 7265 7302 2b0f  rget_features.+.
</span></span><span><span>00000200: 6d75 7461 626c 652d 676c 6f62 616c 732b  mutable-globals+
</span></span><span><span>00000210: 0873 6967 6e2d 6578 74                   .sign-ext
</span></span></code></pre></div><p>The remaining bytes make up three Custom sections (<code>0x00</code>), as there is no Data
(<code>0x0b</code>) section or Data Count (<code>0x0c</code>) section in our module. Custom sections
are mostly unstructured, but do begin with the same <code>u32</code> size as other
sections, followed by a <code>name</code>. The <code>0x00</code> byte identifies our first custom
section, and its size is <code>52</code> bytes (<code>0x34</code>). The <code>name</code> encoding starts with
the number of bytes in the <code>name</code>, which in this case is <code>4</code> (<code>0x04</code>). The
following 4 bytes are UTF-8 characters making up the <code>name</code>.</p>
<p>The <code>name</code> of this custom section happens to literally be “name”. It also
happens to be the only Custom section that is defined in the WASM specification
(see Custom Sections in the Appendix). Like other sections, it should only be
included at most once, and it has the additional requirement of occurring after
the Data section. There are three subsections that may be included in the “name”
Custom section, identified by the following IDs.</p>
<table>
<thead>
<tr>
<th>ID (Hex)</th>
<th>Subsection</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Module name</td>
</tr>
<tr>
<td>0x01</td>
<td>Function names</td>
</tr>
<tr>
<td>0x02</td>
<td>Local names</td>
</tr>
</tbody>
</table>
<p>The first subsection is Function names (<code>0x01</code>), and has size of <code>25</code> (<code>0x19</code>).
It consists of a <code>vec</code> of <code>name</code> / <code>index</code> pairs, otherwise known as a “name
map”, which assigns the provided <code>name</code> to the given <code>index</code> in the Function
section. The <code>vec</code> here is of length <code>2</code> (<code>0x02</code>), and first element corresponds
to the first function in the Function section (<code>0x00</code>). The name assigned to the
function is <code>17</code> bytes long (<code>0x11</code>).</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>5f 5f 77 61 73 6d 5f 63 61 6c 6c 5f 63 74 6f 72 73 -&gt; __wasm_call_ctors
</span></span></code></pre></div><p>The following function name entry can be decoded in the same manner, predictably
assigning <code>add</code> to the second function in the Function section (<code>0x01</code>).</p>
<p>The next and final subsection of the “name” Custom section is not actually
standardized in the core WASM specification, but rather part of the <a href="https://github.com/WebAssembly/extended-name-section/blob/main/proposals/extended-name-section/Overview.md#global-names">Extended
Name Section
proposal</a>.
In the proposal, <code>7</code> (<code>0x07</code>) is the index for the Global names subsection. This
subsection also contains a “name map”, providing pairs of a Global section index
and name. The first entry in our Global section (<code>0x00</code>) is being assigned the
name <code>__stack_pointer</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>5f 5f 73 74 61 63 6b 5f 70 6f 69 6e 74 65 72 -&gt; __stack_pointer
</span></span></code></pre></div><p>The next two Custom sections are defined in the <a href="https://github.com/WebAssembly/tool-conventions/">WASM <code>tool-conventions</code>
repository</a>. The first is
<a href="https://github.com/WebAssembly/tool-conventions/blob/c74267a5897c1bdc9aa60adeaf41816387d3cd12/ProducersSection.md">named
<code>producers</code></a>,
and is meant to denote the tools that were used to produce the WASM module. The
second is <a href="https://github.com/WebAssembly/tool-conventions/blob/c74267a5897c1bdc9aa60adeaf41816387d3cd12/Linking.md#target-features-section">named
<code>target_features</code></a>
and must come after the <code>producers</code> Custom secion when included. It describes
what features are used, and whether linking should fail if a given feature is or
is not in the allowed set.</p>
<p>The full decompilation of all three Custom sections is as follows.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ wasm2wat --enable-annotations wasm32_args.wasm | tail -3
</span></span><span><span>  (@custom &#34;name&#34; &#34;\01\19\02\00\11__wasm_call_ctors\01\03add\07\12\01\00\0f__stack_pointer&#34;)
</span></span><span><span>  (@custom &#34;producers&#34; &#34;\01\0cprocessed-by\01\0cUbuntu clang?17.0.6 (++20231209124227+6009708b4367-1~exp1~20231209124336.77)&#34;)
</span></span><span><span>  (@custom &#34;target_features&#34; &#34;\02+\0fmutable-globals+\08sign-ext&#34;))
</span></span></code></pre></div><blockquote>
<p>The <code>--enable-annotations</code>, which we have been using for all <code>wasm2wat</code>
invocations, is required to include Custom sections in the WAT output.</p>
</blockquote>
<h2 id="final-thoughts">
  Final Thoughts
  <a href="#final-thoughts">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>The WASM module in this post did not include every section that can occur, but
hopefully this breakdown was thorough enough that you feel confident in
dissecting those that were omitted on your own. There are a number of topics,
such as linking, optimization, and shadow stacks, that were mentioned in this
post but were not covered in depth. Check back for future posts where we will go
into greater detail.</p>
<p>As always, if you have feedback, questions, or just want to chat, feel free to
reach out to <code>@hasheddan</code> on any of the platforms listed on the <a href="https://danielmangum.com/">home
page</a>.</p>

      </div></div>
  </body>
</html>
