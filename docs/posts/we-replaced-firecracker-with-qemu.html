<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hocus.dev/blog/qemu-vs-firecracker/">Original</a>
    <h1>We Replaced Firecracker with QEMU</h1>
    
    <div id="readability-page-1" class="page"><div id="docusaurus_skipToContent_fallback"><div><div><main itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><div><p><time datetime="2023-07-10T10:00:00.000Z" itemprop="datePublished">July 10, 2023</time> · </p><!-- --><p>5 min read</p></div></header><div id="post-content" itemprop="articleBody"><p><img loading="lazy" alt="Firecracker vs QEMU" src="https://hocus.dev/blog/assets/images/qemu-vs-firecracker-bg-6924bd95888c267d0fcbdbb34b61cea3.png" width="1830" height="583"/></p><p>Firecracker, the microVM hypervisor, is renowned for being lightweight, fast, and secure. It&#39;s excellent for running short-lived workloads, which is why it&#39;s the backbone of AWS Lambda. Our initial prototype for Hocus, a self-hosted alternative to Gitpod and GitHub Codespaces, utilized Firecracker. However, after weeks of testing, we decided to entirely replace it with QEMU. A little-known fact about Firecracker is its lack of support for many modern hypervisor features, such as dynamic RAM management, which is vital for long-lived workloads. In this post, I will explain why Firecracker might not be the best hypervisor choice and when you should avoid it.</p><h2 id="firecracker-optimizes-for-short-lived-workloads">Firecracker Optimizes for Short-Lived Workloads<a href="#firecracker-optimizes-for-short-lived-workloads" aria-label="Direct link to Firecracker Optimizes for Short-Lived Workloads" title="Direct link to Firecracker Optimizes for Short-Lived Workloads">​</a></h2><p>The creators of Firecracker <a href="https://github.com/firecracker-microvm/firecracker/blob/dbd9a84b11a63b5e5bf201e244fe83f0bc76792a/README.md?plain=1#L24" target="_blank" rel="noopener noreferrer">state that</a>:</p><blockquote><p>&#34;Firecracker has a minimalist design. It excludes unnecessary devices and guest-facing functionality to reduce the memory footprint and attack surface area of each microVM.&#34;</p></blockquote><p>The term &#34;unnecessary&#34; is intriguing - if this functionality is unnecessary, why was it incorporated into other hypervisors? The definition of &#34;unnecessary&#34; must be understood in the context of what Firecracker was built for. These excluded features are unnecessary for AWS Lambda, which spins up VMs to run short function calls and then shuts them down. If you&#39;re running a different kind of workload, like a VM that contains your development environment or a self-hosted GitHub Actions agent, these features cease to be unnecessary. Your VM will run for hours, days, or even months without stopping, unlike the typical Firecracker VM, which runs for seconds or minutes.</p><h2 id="firecracker-not-so-lightweight-after-all">Firecracker, Not So Lightweight After All<a href="#firecracker-not-so-lightweight-after-all" aria-label="Direct link to Firecracker, Not So Lightweight After All" title="Direct link to Firecracker, Not So Lightweight After All">​</a></h2><p>Here are the two most significant features Firecracker lacks:</p><ul><li>Dynamic memory management - Firecracker&#39;s RAM footprint starts low, but once a workload inside allocates RAM, Firecracker will never return it to the host system. After running several workloads inside, you end up with an idling VM that consumes 32 GB of RAM on the host, even though it doesn&#39;t need any of it.<sup id="fnref-1-1f96f1"><a href="#fn-1-1f96f1">1</a></sup></li><li>Discard operations on storage - if you create a 10 GB file inside a VM and then delete it, the backing space won&#39;t be reclaimed on the host. The VM will occupy that disk space until you delete the entire VM drive.<sup id="fnref-2-1f96f1"><a href="#fn-2-1f96f1">2</a></sup></li></ul><p>These deficiencies make Firecracker a memory and disk space hog. The plot below shows the memory usage of the same memory-intensive workload running in QEMU and Firecracker virtual machines.</p><p><img loading="lazy" alt="QEMU vs Firecracker VM Memory Usage" src="https://hocus.dev/blog/assets/images/vm-mem-usage-ae3ffeb0cc6a2df2f662597c653d9bf4.png" title="QEMU vs Firecracker VM Memory Usage" width="1696" height="967"/></p><p><em>The workload in Firecracker finishes running around the 200-second mark, and in QEMU around the 250-second mark. It&#39;s not a performance difference; it&#39;s just when I manually stopped them.</em></p><h2 id="other-features-firecracker-is-missing">Other Features Firecracker Is Missing<a href="#other-features-firecracker-is-missing" aria-label="Direct link to Other Features Firecracker Is Missing" title="Direct link to Other Features Firecracker Is Missing">​</a></h2><ul><li>GPU support - if you need a GPU inside the VM, <a href="https://github.com/firecracker-microvm/firecracker/issues/849" target="_blank" rel="noopener noreferrer">you have to pick a different hypervisor</a>.</li><li>High-performance disk IO - when you connect multiple drives to the VM and run intensive IO operations, you will likely run into a bottleneck. Firecracker uses a virtio-blk implementation that isn’t as memory-hungry as alternatives, but has a <a href="https://lwn.net/Articles/812055/" target="_blank" rel="noopener noreferrer">smaller throughput</a>.<sup id="fnref-3-1f96f1"><a href="#fn-3-1f96f1">3</a></sup></li></ul><h2 id="qemu-is-not-perfect-though">QEMU is Not Perfect Though<a href="#qemu-is-not-perfect-though" aria-label="Direct link to QEMU is Not Perfect Though" title="Direct link to QEMU is Not Perfect Though">​</a></h2><p>The main issue we&#39;ve had with QEMU is that it has too many options you need to configure. For instance, enabling your VM to return unused RAM to the host requires at least three challenging tasks:</p><ul><li>Knowing that the feature even exists (it&#39;s called <a href="https://docs.kernel.org/mm/free_page_reporting.html" target="_blank" rel="noopener noreferrer">free page reporting</a> and you have to specifically enable it in QEMU)</li><li>Understanding that an obscure feature of Linux called <a href="https://www.kernel.org/doc/html/v5.17/vm/damon/index.html" target="_blank" rel="noopener noreferrer">DAMON</a> exists, knowing what it&#39;s for<sup id="fnref-4-1f96f1"><a href="#fn-4-1f96f1">4</a></sup>, knowing how to configure it, and compiling a guest Linux kernel that supports it</li><li>Knowing that you need to disable transparent huge pages on the guest, otherwise the VM will never return large amounts of memory</li></ul><p>It took us two months of experimentation, reading through the source code of Firecracker, QEMU, and other hypervisors to develop a reliable QEMU proof of concept. To comprehend DAMON configuration, my co-founder spent days <a href="https://lore.kernel.org/damon/20230504171749.89225-1-sj@kernel.org/T/" target="_blank" rel="noopener noreferrer">running benchmarks and conversing with one of its authors</a>. It&#39;s great that we could talk and we are grateful that the author spent the time to help us, but it shows that the technology is not easily accessible yet.</p><h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>QEMU has the features you need to run general-purpose workloads, but configuring it requires a lot of time and patience. If you want to run short-lived, untrusted workloads, Firecracker is a great choice. However, if you just want to run your development environment in a VM, you can use <a href="https://github.com/hocus-dev/hocus" target="_blank" rel="noopener noreferrer">Hocus</a>. We&#39;ve done all the hard work for you already. It&#39;s still in alpha, but you can already check it out on <a href="https://github.com/hocus-dev/hocus" target="_blank" rel="noopener noreferrer">GitHub</a>.</p></div></article></main></div></div></div></div>
  </body>
</html>
