<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://berthub.eu/articles/posts/improved-galileo-fix-time/">Original</a>
    <h1>Improved Galileo Time to First Fix</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
  

  
  

  <div>
  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:site" content="@bert_hu_bert"/>
<meta name="twitter:creator" content="@bert_hu_bert"/>
<meta name="twitter:title" content="Improved Galileo Time to First Fix"/>
<meta name="twitter:description" content="Recently Galileo started transmitting signals that enable a more rapid and robust first fix. Here I detail how it works, and share some pitfalls"/>
<meta name="twitter:image" content="https://berthub.eu/articles/error-in-my-redced.jpeg"/>
<p>In the world of Global Navigation Satellite Systems (GNSS), change tends to happen very slowly and cautiously. It is therefore quite exciting how many new features Galileo, the “European GPS” has been rolling out lately.</p>
<p>Earlier I wrote a little bit about the <a href="https://berthub.eu/articles/posts/reed-solomon-for-programmers/">High Accuracy Service</a> (HAS), whereby the Galileo satellites themselves provide properly equipped receivers (not your phone) with near-realtime updates that can be used to achieve very good accuracy. I also wrote a series on <a href="https://berthub.eu/articles/posts/galileos-authentication-algorithm-part-1/">OSNMA, the rather special Galileo message authentication protocol</a>.</p>
<p>Recently three further new features have appeared that can be received by the hardware already found in the billions of phones that support Galileo. The goal is to get you to a ‘fix’ of time and place faster and more robustly. To do so, Galileo satellites now deploy some rather clever maths and tricks.</p>
<p>These are especially useful for unconnected devices (without ‘assisted GPS’), but the new features also provide resilience in case of disrupted communications, for example during disasters. In addition, even well connected devices can speed up their time synchronisation, which in turn speeds up the time to first fix.</p>
<h2 id="getting-a-fix">Getting a fix</h2>
<p>As I noted <a href="https://berthub.eu/articles/posts/mch-dna-and-gps-gnss-talks/">in a recent presentation on GPS, BeiDou, Galileo and GLONASS</a>, GNSS in essence consists of over one hundred satellites beeping at you every 1.0000000000 seconds. If you know exactly where those satellites are, and how their clocks are doing, the relative arrival times of those beeps can <a href="https://berthub.eu/articles/posts/gps-gnss-how-do-they-work/">tell you where you are (and what time it is)</a>.</p>
<p>In the very old days, a GPS receiver could easily take 15 minutes to get a fix. Many of those minutes would be spent merely finding the satellite radio signals. Modern chips can do this very quickly, but then we’re not yet done.</p>
<p>The satellites broadcast messages (or ‘words’), and multiple of those messages are required to precisely establish the satellite’s orbit and clock characteristics. Since GNSS transmissions are really low power, for Galileo this could take 30 seconds given perfect conditions. However, conditions rarely are perfect - if an important message is missed or too garbled, we have to wait 30 seconds for the next transmission.</p>
<p>For this reason, most phones attempt to download the orbit and clock details from the cloud. This allows them to immediately use the timing of the beeps to figure out where you are. Now, this is pretty nice, but it only works if you have connectivity and if this “assisted GPS” is working correctly.</p>
<h2 id="galileo-improved-inav">Galileo Improved INAV</h2>
<p>The European Commission set the goal to speed up the Galileo ’time to first fix’ without cloud assistance.
As noted, Galileo broadcasts a carousel of messages, and this carousel (mostly) repeats every 30 seconds. Each message takes 2 seconds, so there are 15 ‘slots’. The satellite ephemeris (orbit) and clock details are spread out over 4 messages.</p>
<p>Given typical reception conditions however, we need to be pretty lucky to receive all four messages perfectly in just one rotation.</p>
<p>The good news is that lots of the 15 slots in the carousel were in fact empty, which meant there were options for change.</p>
<p>To speed up the time to first fix, three measures have been implemented:</p>
<ul>
<li>Broadcast a new lower precision short term orbit/clock description message (word 16)</li>
<li>Broadcast 4 new messages that provide Reed-Solomon parity bits to protect the 4 existing ephemeris messages. This is construed that any four out of the now 8 messages suffice to reconstruct the full ephemeris and clock (words 17, 18, 19 and 20)</li>
<li>Wiggle some bits so every Galileo message tells you the Galileo System Time modulo 6 seconds, even without decoding the message</li>
</ul>
<h2 id="orbit-and-clock-models">Orbit and clock models</h2>
<p>From the ground the orbits and clocks of the satellites are monitored carefully. In addition, the earth’s gravitational field, the influence of the sun and the moon are all well known. There are also models of the influence of solar wind. On the ground, there is enough data to predict the orbit of a satellite perhaps 24 hours ahead of time. Roughly the same thing holds for the clock, as long as the clock behaves (which is often not the case).</p>
<p>A full Galileo ephemeris (orbit)/clock description is around 500 bits in size and contains enough information to model things for around 4 hours. On the ground, there is knowledge to calculate several such 500 bit descriptors ahead of time, and these are continuously uplinked, so that a satellite (in theory) could go without ground communications for 24 hours.</p>
<p>It is also possible to create far smaller ephemeris/clock descriptors that have far briefer predictive abilities, and this is what we find in new Galileo message type 16.</p>
<p>The word contains a 122 bit descriptor with an intended validity of 10 minutes. It gets broadcast twice in the 30 second carousel, so on average a receiver should see it after around 8 seconds (and 95% of the time within 15 seconds).</p>
<p>Although it is valid for 10 minutes, a fresh version of this descriptor gets broadcast every 30 seconds.</p>
<p>Even with the reduced validity period, there is only so much information you can cram in 122 bits, so a position derived from this reduced accuracy message will be less precise. In <a href="https://www.gsc-europa.eu/sites/default/files/sites/all/files/IonGnss19_InavOptimisation_FullPaper_GSC.pdf">this paper</a> we can read that the range established from the reduced precision ephemeris should be 3 meters less precise.</p>
<p>Technically speaking, the designers of this message have cleverly created a mapping from the reduced accuracy ephemeris parameters to the ‘regular’ ephemeris parameters. This means receivers can reuse their existing math to do orbit calculations.</p>
<p>I spent a good few hours getting this to work, and perhaps the following code snippet can serve as inspiration:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>uint32_t</span> <span>getT0e</span>(){ <span>return</span> d_t0r; }
</span></span><span><span><span>static</span> <span>constexpr</span> <span>double</span> Anominal{<span>29600000.0</span>};
</span></span><span><span><span>double</span> <span>getSqrtA</span>(){ <span>return</span> sqrt(Anominal <span>+</span> ldexp(<span>1.0</span><span>*</span>d_gm.deltaAred, <span>8</span>));   }
</span></span><span><span><span>double</span> <span>getE</span>(){ <span>return</span> ldexp(sqrt(d_gm.exred<span>*</span>d_gm.exred <span>+</span> d_gm.eyred<span>*</span>d_gm.eyred), 
</span></span><span><span>                   <span>-</span><span>22</span>); } 
</span></span><span><span><span>double</span> <span>getCuc</span>()  { <span>return</span> <span>0</span>;   } <span>// radians
</span></span></span><span><span><span></span><span>double</span> <span>getCus</span>()  { <span>return</span> <span>0</span>;   } <span>// radians
</span></span></span><span><span><span></span><span>double</span> <span>getCrc</span>()  { <span>return</span> <span>0</span>;   } <span>// meters
</span></span></span><span><span><span></span><span>double</span> <span>getCrs</span>()  { <span>return</span> <span>0</span>;   } <span>// meters
</span></span></span><span><span><span></span><span>double</span> <span>getM0</span>()   { <span>return</span> ldexp(M_PI <span>*</span> d_gm.lambda0red, <span>-</span><span>22</span>) <span>-</span> 
</span></span><span><span>                   getOmega();  } 
</span></span><span><span><span>double</span> <span>getDeltan</span>() { <span>return</span> <span>0</span>; } <span>//radians/s
</span></span></span><span><span><span></span><span>static</span> <span>constexpr</span> <span>double</span> iNominal{<span>56.0</span>};
</span></span><span><span><span>double</span> <span>getI0</span>()       { <span>return</span> M_PI<span>*</span>iNominal<span>/</span><span>180.0</span> <span>+</span> 
</span></span><span><span>                       ldexp(d_gm.deltai0red <span>*</span> M_PI, <span>-</span><span>22</span>);   } 
</span></span><span><span><span>double</span> <span>getCic</span>()      { <span>return</span> <span>0</span>;   } <span>// radians
</span></span></span><span><span><span></span><span>double</span> <span>getCis</span>()      { <span>return</span> <span>0</span>;   } <span>// radians
</span></span></span><span><span><span></span><span>double</span> <span>getOmegadot</span>() { <span>return</span> <span>0</span>;   } <span>// radians/s
</span></span></span><span><span><span></span><span>double</span> <span>getOmega0</span>()   { <span>return</span> ldexp(d_gm.omega0red <span>*</span> M_PI, <span>-</span><span>22</span>);   } 
</span></span><span><span><span>double</span> <span>getIdot</span>()     { <span>return</span> <span>0</span>;   } <span>// radians/s
</span></span></span><span><span><span></span><span>double</span> <span>getOmega</span>()    { <span>return</span> atan2(d_gm.eyred, d_gm.exred);   } 
</span></span><span><span>
</span></span><span><span><span>// pair of nanosecond, nanosecond/s 
</span></span></span><span><span><span></span>std<span>::</span>pair<span>&lt;</span><span>double</span>, <span>double</span><span>&gt;</span> getAtomicOffset(<span>int</span> tow) <span>const</span>
</span></span><span><span>{
</span></span><span><span>  <span>int</span> delta <span>=</span> ephAge(tow, d_t0r);
</span></span><span><span>  <span>//           2^-26         2^-35                 
</span></span></span><span><span><span></span>  <span>double</span> cur <span>=</span> d_gm.af0red  <span>+</span> ldexp(<span>1.0</span><span>*</span>delta<span>*</span>d_gm.af1red, <span>-</span><span>9</span>);
</span></span><span><span>  <span>double</span> trend <span>=</span> ldexp(d_gm.af1red, <span>-</span><span>9</span>);
</span></span><span><span>
</span></span><span><span>  <span>// now in units of 2^-26 seconds, which are ~14.9 nsec each
</span></span></span><span><span><span></span>  <span>double</span> factor <span>=</span> ldexp(<span>1000000000.0</span>, <span>-</span><span>26</span>);
</span></span><span><span>  <span>return</span> {factor <span>*</span> cur, factor <span>*</span> trend};
</span></span><span><span>}
</span></span></code></pre></div><p>Of special note, the <code>getE()</code> function attempts to get the most out of the floating point precision. If you do the <code>ldexp()</code> inside the <code>sqrt()</code> you might get some very small numbers. Additionally, although the Galileo OSS ICD 2.0 is quite clear, you might miss that you have to transpose ω as well and not use the ω provided by the normal Galileo ephemeris.</p>
<p>This brings me to a further point. The goal of an ephemeris descriptor is to enable you to perform the most accurate range measurement to the satellite. To do so, the supplied parameters allow you to predict the satellite’s orbit and clock offset. But even though the ephemeris parameters look a lot like physical orbital elements that Johannes Kepler would recognize, this is <em>not</em> what the parameters are. The parameters of even the full precision ephemeris are optimized to give you good results. They are not measurements of the satellite’s actual orbit.</p>
<p>Now, although this is technically true, for the full precision ephemeris, it is somewhat of a philosophical point. The parameters of the full precision ephemeris in fact do correspond closely to what is physically happening. But technically speaking, this need not be the case.</p>
<p>For the reduced precision ephemeris, this is DEFINITELY not the case. The orbital software does its best to create a description that when fed to the normal orbital algorithm delivers something that allows you to determine the range as best as possible over the next 10 minutes. To this end, the software wiggles the 122 bits of parameters to get the best fit. Two parameters that perhaps unexpectedly get wiggled are <code>af0red</code> and <code>af1red</code>, which notionally describe how far the atomic clock is ahead of Galileo System Time, and the rate at which the clock drifts.</p>
<p>In this case, these parameters are tweaked to provide around 100 meters of range corrections. By artificially making the clock appear to be ahead/behind by up to a microsecond, a receiver will conclude the satellite is further away or closer than it would otherwise be. This correction improves the range calculation.</p>
<p>The Galileo SIS ICD documents are very clear that the parameters from the reduced precision ephemeris should never be mixed with those from the full precision version. They also remind you to take the satellite clock into account. So to be clear, the ICD is correct, and if you follow its instructions, you’ll get a working receiver.</p>
<p>But if you take the reduced ephemeris and compare it to the full ephemeris, you’ll find 100 meter errors, until you project the calculated ECEF position of the satellite out by the calculated clock offsets, which as noted can differ by a microsecond (!).</p>
<p><img src="https://berthub.eu/articles/error-in-my-redced.jpeg" alt="/articles/error-in-my-redced.jpeg"/></p>
<p>So the key is - when relying on the reduced precision ephemeris, use ONLY parameters actually part of that reduced ephemeris, but do use all of them (including af0red and af1red). Once the full precision variant arrives, use nothing but that.</p>
<blockquote>
<p>I’m much indebted to <a href="https://ie.linkedin.com/in/cillian-o-driscoll-780942a">Cillian O’Driscoll</a>, <a href="https://destevez.net/">Daniel Estévez</a> and <a href="https://it.linkedin.com/in/matteopaonni">Matteo Paonni</a> who helped me figure out why my numbers were off so much, and pointing me towards the clock parameters!</p>
</blockquote>
<h2 id="parity-protection">Parity protection</h2>
<p>In the 30 second sub-frame, containing 15 messages, 2 slots have been dedicated to broadcasting parity bits for the 4 existing ephemeris messages. The clever way in which this has been done means that any 4 out of the now 8 ephemeris messages are sufficient to recover full orbit and clock data.</p>
<blockquote>
<p>The four new parity words (17, 18, 19, 20) share two slots in the 30 second carousel. This means that in the one minute it takes to broadcast two sub-frames, a receiver will have seen 8 copies of the ephemeris words (words 1, 2, 3 and 4), and 4 copies of the parity words.</p>
</blockquote>
<p>Messages often arrive slightly garbled, which is then detected because the CRC check fails. Traditionally, such messages had to be discarded. But given the many parity bits available now, such messages can now be corrected and contribute to a complete ephemeris.</p>
<p>To make this happen, the designers of the new messages used the rather miraculous Reed-Solomon algorithm, which I <a href="https://berthub.eu/articles/posts/reed-solomon-for-programmers/">wrote about earlier</a>. R-S takes a message and adds parity bits to it. But the beauty of the thing is that the algorithm can repair damage in any place it occurs - even if this happens in the parity bits itself.</p>
<p>Quoting from the earlier post:</p>
<p>In short, Reed-Solomon is a cool way to protect messages against damage or
partial arrival.  At your choice, you can add <em>t</em> parity symbols to a
message.</p>
<p>These <em>t</em> parity symbols then allow you to:</p>
<ul>
<li>recover from <em>t/2</em> corrupted symbols in unknown places</li>
<li>recover from <em>t</em> corrupted/missing symbols in known places</li>
<li>detect that the message was damaged (unless there are more than <em>t</em> corruptions)</li>
</ul>
<p>A symbol can be 8 bits long and equal a byte, but this does not have to be the case.</p>
<blockquote>
<p>Not only is this is pretty good error resilience, it provably does <a href="https://en.wikipedia.org/wiki/Singleton_bound">not get
any better than this</a> (at
least, not on a per symbol basis).</p>
</blockquote>
<p>You can pick <em>t</em> at will, which means you can choose the level of protection
you want.</p>
<p>What you can’t pick at will however is the length of the resulting protected
block: this is always 255 bytes (when using byte-sized symbols).</p>
<p>For Galileo “Outer Forward Error Correction (FEC2)”, the designers chose to add 60 parity bytes, 15 per parity message. The protected ephemeris should then be smaller than 60 bytes, which is not naively the case - the four existing ephemeris messages total 64 bytes. However, there is some repetition among the four, which allows the formulation of a protected message of only 58 bytes, from which the full 64 bytes can be regenerated.</p>
<p>This leads to a total message of 118 bytes, which is shorter than the 255 byte Reed-Solomon block. To get around this, it is typical to zero-pad an R-S block, and then not transmit the actual zeroes. Further details can be found in <a href="https://berthub.eu/articles/posts/reed-solomon-for-programmers/">my earlier Reed-Solomon page</a>, which also includes running code.</p>
<p>Reed-Solomon can be configured using a lot of parameters, and it is vital to get these right since otherwise nothing works. There is a remarkable gap between the literature and the code here. Reed-Solomon is a very clever piece of mathematics, but it has now been used so long that there are very good libraries available that do the work for you. These libraries require input of concrete parameters. It is however not easy to derive these concrete parameters from the verbose math that many standards publish. With help from expert <a href="https://destevez.net/">Daniel Estévez</a>, I found that the following parameters work for Galileo “FEC2”:</p>
<ul>
<li>Symbol size in bits: 8</li>
<li>Number of parity symbols (<em>t</em> or “number of roots”, <code>nroots</code>): 60</li>
<li>Padding: 255 - 60 - 58 = 137 bytes</li>
<li>The extended Galois field generator polynomial coefficients: \(
 1 + x^2 +x^3 + x^4 + x^8 \) aka 0x11d (<code>gfpoly</code>)</li>
<li>The primitive (<code>prim</code>) element in the Galois field used to generate the Reed Solomon code generator polynomial: 1</li>
<li>The first consecutive root (<code>fcr</code>) of the Reed Solomon code generator polynomial: 1</li>
</ul>
<p>The <code>parameter names</code> match up to the most excellent libfec library.</p>
<p>However, Galileo has (for unknown reasons) added an additional twist: the Reed-Solomon message components get broadcast (individually) in <strong>reverse order</strong>. Yes.</p>
<p>So, the whole R-S block looks like this, where ‘wt’ stands for ‘word type’, and wt 1 through 4 are the ephemeris itself, and 17 through 20 contain the parity bits.</p>



<p>
  
    <svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 800 105">
      <g transform="translate(8,16)">
<path d="M 8,16 L 16,16" fill="none" stroke="currentColor"></path>
<path d="M 64,16 L 72,16" fill="none" stroke="currentColor"></path>
<path d="M 88,16 L 104,16" fill="none" stroke="currentColor"></path>
<path d="M 144,16 L 160,16" fill="none" stroke="currentColor"></path>
<path d="M 176,16 L 192,16" fill="none" stroke="currentColor"></path>
<path d="M 232,16 L 248,16" fill="none" stroke="currentColor"></path>
<path d="M 264,16 L 280,16" fill="none" stroke="currentColor"></path>
<path d="M 320,16 L 336,16" fill="none" stroke="currentColor"></path>
<path d="M 352,16 L 368,16" fill="none" stroke="currentColor"></path>
<path d="M 408,16 L 424,16" fill="none" stroke="currentColor"></path>
<path d="M 448,16 L 464,16" fill="none" stroke="currentColor"></path>
<path d="M 504,16 L 520,16" fill="none" stroke="currentColor"></path>
<path d="M 536,16 L 552,16" fill="none" stroke="currentColor"></path>
<path d="M 592,16 L 608,16" fill="none" stroke="currentColor"></path>
<path d="M 624,16 L 640,16" fill="none" stroke="currentColor"></path>
<path d="M 680,16 L 696,16" fill="none" stroke="currentColor"></path>
<path d="M 712,16 L 728,16" fill="none" stroke="currentColor"></path>
<path d="M 768,16 L 784,16" fill="none" stroke="currentColor"></path>
<path d="M 0,32 L 80,32" fill="none" stroke="currentColor"></path>
<path d="M 80,32 L 168,32" fill="none" stroke="currentColor"></path>
<path d="M 168,32 L 256,32" fill="none" stroke="currentColor"></path>
<path d="M 256,32 L 344,32" fill="none" stroke="currentColor"></path>
<path d="M 344,32 L 432,32" fill="none" stroke="currentColor"></path>
<path d="M 432,32 L 520,32" fill="none" stroke="currentColor"></path>
<path d="M 520,32 L 608,32" fill="none" stroke="currentColor"></path>
<path d="M 608,32 L 696,32" fill="none" stroke="currentColor"></path>
<path d="M 696,32 L 784,32" fill="none" stroke="currentColor"></path>
<path d="M 0,64 L 80,64" fill="none" stroke="currentColor"></path>
<path d="M 80,64 L 168,64" fill="none" stroke="currentColor"></path>
<path d="M 168,64 L 256,64" fill="none" stroke="currentColor"></path>
<path d="M 256,64 L 344,64" fill="none" stroke="currentColor"></path>
<path d="M 344,64 L 432,64" fill="none" stroke="currentColor"></path>
<path d="M 432,64 L 520,64" fill="none" stroke="currentColor"></path>
<path d="M 520,64 L 608,64" fill="none" stroke="currentColor"></path>
<path d="M 608,64 L 696,64" fill="none" stroke="currentColor"></path>
<path d="M 696,64 L 784,64" fill="none" stroke="currentColor"></path>
<path d="M 8,80 L 384,80" fill="none" stroke="currentColor"></path>
<path d="M 432,80 L 784,80" fill="none" stroke="currentColor"></path>
<path d="M 0,32 L 0,64" fill="none" stroke="currentColor"></path>
<path d="M 80,32 L 80,64" fill="none" stroke="currentColor"></path>
<path d="M 168,32 L 168,64" fill="none" stroke="currentColor"></path>
<path d="M 256,32 L 256,64" fill="none" stroke="currentColor"></path>
<path d="M 344,32 L 344,64" fill="none" stroke="currentColor"></path>
<path d="M 432,32 L 432,64" fill="none" stroke="currentColor"></path>
<path d="M 520,32 L 520,64" fill="none" stroke="currentColor"></path>
<path d="M 608,32 L 608,64" fill="none" stroke="currentColor"></path>
<path d="M 696,32 L 696,64" fill="none" stroke="currentColor"></path>
<path d="M 784,32 L 784,64" fill="none" stroke="currentColor"></path>
<polygon points="16.000000,16.000000 4.000000,10.400000 4.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 8.000000, 16.000000)"></polygon>
<polygon points="16.000000,80.000000 4.000000,74.400002 4.000000,85.599998" fill="currentColor" transform="rotate(180.000000, 8.000000, 80.000000)"></polygon>
<polygon points="80.000000,16.000000 68.000000,10.400000 68.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 72.000000, 16.000000)"></polygon>
<polygon points="96.000000,16.000000 84.000000,10.400000 84.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 88.000000, 16.000000)"></polygon>
<polygon points="168.000000,16.000000 156.000000,10.400000 156.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 160.000000, 16.000000)"></polygon>
<polygon points="184.000000,16.000000 172.000000,10.400000 172.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 176.000000, 16.000000)"></polygon>
<polygon points="256.000000,16.000000 244.000000,10.400000 244.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 248.000000, 16.000000)"></polygon>
<polygon points="272.000000,16.000000 260.000000,10.400000 260.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 264.000000, 16.000000)"></polygon>
<polygon points="344.000000,16.000000 332.000000,10.400000 332.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 336.000000, 16.000000)"></polygon>
<polygon points="360.000000,16.000000 348.000000,10.400000 348.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 352.000000, 16.000000)"></polygon>
<polygon points="432.000000,16.000000 420.000000,10.400000 420.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 424.000000, 16.000000)"></polygon>
<polygon points="456.000000,16.000000 444.000000,10.400000 444.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 448.000000, 16.000000)"></polygon>
<polygon points="528.000000,16.000000 516.000000,10.400000 516.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 520.000000, 16.000000)"></polygon>
<polygon points="544.000000,16.000000 532.000000,10.400000 532.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 536.000000, 16.000000)"></polygon>
<polygon points="616.000000,16.000000 604.000000,10.400000 604.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 608.000000, 16.000000)"></polygon>
<polygon points="632.000000,16.000000 620.000000,10.400000 620.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 624.000000, 16.000000)"></polygon>
<polygon points="704.000000,16.000000 692.000000,10.400000 692.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 696.000000, 16.000000)"></polygon>
<polygon points="720.000000,16.000000 708.000000,10.400000 708.000000,21.600000" fill="currentColor" transform="rotate(180.000000, 712.000000, 16.000000)"></polygon>
<polygon points="792.000000,16.000000 780.000000,10.400000 780.000000,21.600000" fill="currentColor" transform="rotate(0.000000, 784.000000, 16.000000)"></polygon>
<polygon points="792.000000,80.000000 780.000000,74.400002 780.000000,85.599998" fill="currentColor" transform="rotate(0.000000, 784.000000, 80.000000)"></polygon>
<text text-anchor="middle" x="16" y="52" fill="currentColor" style="font-size:1em">p</text>
<text text-anchor="middle" x="24" y="52" fill="currentColor" style="font-size:1em">a</text>
<text text-anchor="middle" x="32" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="32" y="52" fill="currentColor" style="font-size:1em">d</text>
<text text-anchor="middle" x="40" y="20" fill="currentColor" style="font-size:1em">3</text>
<text text-anchor="middle" x="40" y="52" fill="currentColor" style="font-size:1em">d</text>
<text text-anchor="middle" x="48" y="20" fill="currentColor" style="font-size:1em">7</text>
<text text-anchor="middle" x="48" y="52" fill="currentColor" style="font-size:1em">i</text>
<text text-anchor="middle" x="56" y="52" fill="currentColor" style="font-size:1em">n</text>
<text text-anchor="middle" x="64" y="52" fill="currentColor" style="font-size:1em">g</text>
<text text-anchor="middle" x="96" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="104" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="112" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="120" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="128" y="20" fill="currentColor" style="font-size:1em">4</text>
<text text-anchor="middle" x="128" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="136" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="152" y="52" fill="currentColor" style="font-size:1em">4</text>
<text text-anchor="middle" x="184" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="192" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="200" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="208" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="216" y="20" fill="currentColor" style="font-size:1em">4</text>
<text text-anchor="middle" x="216" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="224" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="240" y="52" fill="currentColor" style="font-size:1em">3</text>
<text text-anchor="middle" x="272" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="280" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="288" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="296" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="304" y="20" fill="currentColor" style="font-size:1em">4</text>
<text text-anchor="middle" x="304" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="312" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="328" y="52" fill="currentColor" style="font-size:1em">2</text>
<text text-anchor="middle" x="360" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="368" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="376" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="384" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="392" y="20" fill="currentColor" style="font-size:1em">6</text>
<text text-anchor="middle" x="392" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="400" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="400" y="84" fill="currentColor" style="font-size:1em">2</text>
<text text-anchor="middle" x="408" y="84" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="416" y="52" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="416" y="84" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="448" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="456" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="464" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="480" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="480" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="488" y="20" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="488" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="504" y="52" fill="currentColor" style="font-size:1em">2</text>
<text text-anchor="middle" x="512" y="52" fill="currentColor" style="font-size:1em">0</text>
<text text-anchor="middle" x="528" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="536" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="544" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="560" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="568" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="568" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="576" y="20" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="584" y="52" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="592" y="52" fill="currentColor" style="font-size:1em">9</text>
<text text-anchor="middle" x="624" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="632" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="640" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="656" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="656" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="664" y="20" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="664" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="680" y="52" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="688" y="52" fill="currentColor" style="font-size:1em">8</text>
<text text-anchor="middle" x="712" y="52" fill="currentColor" style="font-size:1em">r</text>
<text text-anchor="middle" x="720" y="52" fill="currentColor" style="font-size:1em">e</text>
<text text-anchor="middle" x="728" y="52" fill="currentColor" style="font-size:1em">v</text>
<text text-anchor="middle" x="744" y="20" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="744" y="52" fill="currentColor" style="font-size:1em">w</text>
<text text-anchor="middle" x="752" y="20" fill="currentColor" style="font-size:1em">5</text>
<text text-anchor="middle" x="752" y="52" fill="currentColor" style="font-size:1em">t</text>
<text text-anchor="middle" x="768" y="52" fill="currentColor" style="font-size:1em">1</text>
<text text-anchor="middle" x="776" y="52" fill="currentColor" style="font-size:1em">7</text>
</g>

    </svg>
  
</p>

<p>A few things to note. The <a href="https://www.gsc-europa.eu/sites/default/files/sites/all/files/Galileo_OS_SIS_ICD_v2.0.pdf">Galileo OSS ICD 2.0</a> explicitly tells you which bytes to lift from the various message types, where you’ll also see that word type 1 is different - unlike the other blocks it includes the IOD and its word type.</p>
<p>The promise of this additional R-S protection is that you can recover the full ephemeris based on any four of the 8 messages. This is indeed true, but there are two things to look out for. If only types 1 through 4 are available, the Reed-Solomon decoder has nothing to work on, so you need to special case that situation.</p>
<p>A second special case to take care of is when word type 1 and three of the parity words are absent. In that case, there would be \(
16 + 3*15 = 61 \) erased symbols, which is 1 more than the FEC2 R-S configuration can recover from. The good news however is that word type 1 starts with two known bytes - a mix of the word type (1) and the IOD. The IOD can be gleaned from any of the other message types. If these two bytes are provided, the R-S decoder can recover the 59 other ones.</p>
<p>Then there is the matter of fragility - the parity words are marked with the two least significant bits from the IOD. This does leave room for ambiguity, especially under conditions of bad reception. Be very careful not to have too long a buffer to gather word types - Reed-Solomon is so good at correcting damage it will happily correct your new ephemeris to the old one!</p>
<h2 id="secondary-synchronisation-pattern-ssp">Secondary Synchronisation Pattern (SSP)</h2>
<p>Every two seconds a new Galileo message arrives. Sadly, not all these messages contain a timestamp. We do know they are being transmitted at whole Galileo System Time (GST) seconds though, we just don’t know which second. BeiDou for example transmits a timestamp with each message, but Galileo has been somewhat more frugal with bits.</p>
<p>Through some clever thinking however, it has been found possible to tag each Galileo message (or word) with three different states. These three states are associated with GST time of week MOD 6 being 0, 2 and 4. This state is both represented digitally as the SSP field of a Galileo I/NAV word, but is also visible through the RF modulation. I don’t know enough about this, but the upshot is that a receiver can tell if this is a ‘MOD 0, 2 or 4’ message without having to decode the message itself. And in turn, this is useful under bad signal conditions.</p>
<p>Of note, even receivers that are connected to a cloud-based assisted GPS provider need to know the exact time. Using these three states, a moderately precise clock (+- 3 seconds) can be used to quickly derive an accurate timestamp. In this way, the three timestamp states can contribute even to speeding up the fix of a well connected phone.</p>
<h2 id="summarising">Summarising</h2>
<p>With these three innovations, unconnected devices will be able to achieve a fix much faster than before. This provides resilience in case of disruptions in connectivity to major cloud providers like Google and Apple. In addition, even when assisted GPS is available, the SSP can help devices to synchronise their clock more quickly.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://www.gsc-europa.eu/sites/default/files/sites/all/files/Galileo_OS_SIS_ICD_v2.0.pdf">Galileo OSS ICD 2.0</a></li>
<li><a href="https://www.gsc-europa.eu/sites/default/files/sites/all/files/IonGnss19_InavOptimisation_FullPaper_GSC.pdf">Improving the Performance of Galileo E1-OS by Optimizing the I/NAV Navigation Message</a>, Proceedings of the 32nd International Technical Meeting of the Satellite Division of The Institute of Navigation (ION GNSS+ 2019), Miami, Florida, September 2019, pp. 1134-1146, M. Paonni, M. Anghileri, T. Burger, L. Ries, S. Schlötzer, B.E. Schotsch, M. Ouedraogo, S. Damy, E. Châtre, M. Jeannot, J. Godet, D. Hayes</li>
</ul>

</div>

  



</article></div>
  </body>
</html>
