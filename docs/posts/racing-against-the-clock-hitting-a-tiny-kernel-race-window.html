<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html">Original</a>
    <h1>Racing against the clock – hitting a tiny kernel race window</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-2892029424446991022" itemprop="description articleBody">

 <p><span>TL;DR:</span></p>
 <p><span>How to make a tiny kernel race window really large even on kernels without </span><span>CONFIG_PREEMPT</span><span>:</span></p><ul><li><span>use</span><span> a cache miss to widen the race window a little bit</span></li><li><span>make a timerfd expire in that window (which will run in an interrupt handler - in other words, in hardirq context)</span></li><li><span>make sure that the wakeup triggered by the timerfd has to churn through 50000 waitqueue items created by epoll</span></li></ul>
 
 <p><span>Racing one thread against a timer also avoids accumulating timing variations from two threads in each race attempt - hence the title. On the other hand, it also means you now have to deal with how hardware timers actually work, which introduces its own flavors of weird timing variations.</span></p>
 <p><span>I recently discovered a race condition (</span><span><a href="https://crbug.com/project-zero/2247">https://crbug.com/project-zero/2247</a></span><span>) in the Linux kernel.</span><span> (While trying to explain to someone how </span><span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cbcf01128d0a92e131bd09f1688fe032480b65ca">the fix for CVE-2021-0920</a></span><span> worked - I was explaining why the Unix GC is now safe, and then got confused because I couldn&#39;t actually figure out why it&#39;s safe after that fix, eventually realizing that it actually isn&#39;t safe.) It&#39;s a fairly narrow race window, so I was wondering whether it could be hit with a small number of attempts - especially on kernels that aren&#39;t built with </span><span>CONFIG_PREEMPT</span><span>, which would make it possible to preempt a thread with another thread, </span><span><a href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf#page=12">as I described at LSSEU2019</a></span><span>.</span></p>
 
 <p><span>This is a writeup of how I managed to hit the race on a normal Linux desktop kernel, with a hit rate somewhere around 30% if the proof of concept has been tuned for the specific machine. I didn&#39;t do a full exploit though, I stopped at getting evidence of use-after-free (UAF) accesses (with the help of a very large file descriptor table and </span><span><a href="https://lwn.net/Articles/819834/">userfaultfd</a></span><span>, which might not be available to normal users depending on system configuration) because that&#39;s the part I was curious about.</span></p>
 
 <p><span>This also demonstrates that even very small race conditions can still be exploitable if someone sinks enough time into writing an exploit, so be careful if you dismiss very small race windows as unexploitable or don&#39;t treat such issues as security bugs.</span></p>
 
 <p><span>The UAF reproducer is </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2247#c6">in our bugtracker</a></span><span>.</span></p>
 <p><span>In the UNIX domain socket garbage collection code (which is needed to deal with reference loops formed by UNIX</span><span> domain sockets</span><span> that use </span><span>SCM_RIGHTS</span><span> file descriptor passing), the kernel tries to figure out whether it can account for all references to some file by comparing the file&#39;s refcount with the number of references from inflight SKBs (socket buffers). If they are equal, it assumes that the UNIX domain sockets subsystem effectively has exclusive access to the file because it owns all references.</span></p>
 
 <p><span>(The same pattern also appears for files as an optimization in </span><span>__fdget_pos()</span><span>, see </span><span><a href="https://lore.kernel.org/lkml/CAG48ez1pnatAB095dnbrn9LbuQe4+ENwh-WEW36pM40ozhpruw@mail.gmail.com/">this LKML thread</a></span><span>.)</span></p>
 
 <p><span>The problem is that </span><span>struct file</span><span> can also be referenced from an RCU read-side critical section (which you can&#39;t detect by looking at the refcount), and such an RCU reference can be upgraded into a refcounted reference using </span><span>get_file_rcu()</span><span> / </span><span>get_file_rcu_many()</span><span> by </span><span>__fget_files()</span><span> as long as the refcount is non-zero. For example, when this happens in the </span><span>dup()</span><span> syscall, the resulting reference will then be installed in the FD table and be available for subsequent syscalls.</span></p>
 
 <p><span>When the garbage collector (GC) believes that it has exclusive access to a file, it will perform operations on that file that violate the locking rules used in normal socket-related syscalls such as </span><span>recvmsg()</span><span> - </span><span>unix_stream_read_generic()</span><span> assumes that queued SKBs can only be removed under the </span><span>-&gt;iolock</span><span> mutex, but the GC removes queued SKBs without using that mutex. (Thanks to Xingyu Jin for explaining that to me.)</span></p>
 
 <p><span>One way of looking at this bug is that the GC is working correctly - here&#39;s a state diagram showing some of the possible states of a </span><span>struct file</span><span>, with more specific states nested under less specific ones and with the state transition in the GC marked:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiiUbfoAfxrHV-Pi1NNsfr3MrKbRDIuiWObxlGl2OaM5pty9rc1DB96iJpDBwZDCeTda9QLXGYV-NImje4yj5MNf64YcJHCV7h6QPXfqcvBXBT3cnZje6P8hVSrWDDHQIZJlozNTa4wm8cGdBlRo0EB2CaRvQymdhA26bkyBbNP2Ja7RRdoLZCD6XaKyw/s641/image19.png"><img alt="All relevant states are RCU-accessible. An RCU-accessible object can have either a zero refcount or a positive refcount. Objects with a positive refcount can be either live or owned by the garbage collector. When the GC attempts to grab a file, it transitions from the state &#34;live&#34; to the state &#34;owned by GC&#34; by getting exclusive ownership of all references to the file." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiiUbfoAfxrHV-Pi1NNsfr3MrKbRDIuiWObxlGl2OaM5pty9rc1DB96iJpDBwZDCeTda9QLXGYV-NImje4yj5MNf64YcJHCV7h6QPXfqcvBXBT3cnZje6P8hVSrWDDHQIZJlozNTa4wm8cGdBlRo0EB2CaRvQymdhA26bkyBbNP2Ja7RRdoLZCD6XaKyw/s600/image19.png" title="All relevant states are RCU-accessible. An RCU-accessible object can have either a zero refcount or a positive refcount. Objects with a positive refcount can be either live or owned by the garbage collector. When the GC attempts to grab a file, it transitions from the state &#34;live&#34; to the state &#34;owned by GC&#34; by getting exclusive ownership of all references to the file."/></a></span></p>
 
 <p><span>While </span><span>__fget_files()</span><span> is making an incorrect assumption about the state of the </span><span>struct file</span><span> while it is trying to narrow down its possible states - it checks whether </span><span>get_file_rcu()</span><span> / </span><span>get_file_rcu_many()</span><span> succeeds, which narrows the file&#39;s state down a bit but not far enough:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTef37oRtM-RWk6371VrhcG8EKNsAQaNWvirGWbl0J8RIHY-YV-xhFdqpoij3Ofds9hnAAngEIJrtyMXKmY-Fw4en-IXOQsXMIQMQkOgRIGlKm70Ck4Q3tlYNkft6zKm4t5p3FRAmEVFmhTccmTO3ZcDQbBOZYB0a00w8DPjEBqCywmuHu5rosOaEIPg/s638/image10.png"><img alt="__fget_files() first uses get_file_rcu() to conditionally narrow the state of a file from &#34;any RCU-accessible state&#34; to &#34;any refcounted state&#34;. Then it has to narrow the state from &#34;any refcounted state&#34; to &#34;live&#34;, but instead it just assumes that they are equivalent." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTef37oRtM-RWk6371VrhcG8EKNsAQaNWvirGWbl0J8RIHY-YV-xhFdqpoij3Ofds9hnAAngEIJrtyMXKmY-Fw4en-IXOQsXMIQMQkOgRIGlKm70Ck4Q3tlYNkft6zKm4t5p3FRAmEVFmhTccmTO3ZcDQbBOZYB0a00w8DPjEBqCywmuHu5rosOaEIPg/s600/image10.png" title="__fget_files() first uses get_file_rcu() to conditionally narrow the state of a file from &#34;any RCU-accessible state&#34; to &#34;any refcounted state&#34;. Then it has to narrow the state from &#34;any refcounted state&#34; to &#34;live&#34;, but instead it just assumes that they are equivalent."/></a></span></p>
 
 <p><span>And this directly leads to how </span><span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=054aa8d439b9185d4f5eb9a90282d1ce74772969">the bug was fixed</a></span><span> (there&#39;s </span><span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e386dfc56f837da66d00a078e5314bc8382fab83">another follow-up patch</a></span><span>, but that one just tries to clarify the code and recoup some of the resulting performance loss) - the fix adds another check in </span><span>__fget_files()</span><span> to properly narrow down the state of the file such that the file is guaranteed to be live</span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUJDE3REJXgTw3j8aGxUwVTrr2H1D6Fnf0BeMUdcCYXqyCcok6eHx_7cnZ3MDLBQxbcn5ePuGnzzgoo2GjQGTK7aYVqPlwoqJ8UXOuEowvE59T436Fo2NK3O7p59Jfo9fYo3oFMfxQ8wxDAnzXVNf4nJ5t_IQ8QPQYffvWfjQpUaFqInyrBk8i9kbKg/s638/image16.png"><img alt="The fix is to properly narrow the state from &#34;any refcounted state&#34; to &#34;live&#34; by checking whether the file is still referenced by a file descriptor table entry." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUJDE3REJXgTw3j8aGxUwVTrr2H1D6Fnf0BeMUdcCYXqyCcok6eHx_7cnZ3MDLBQxbcn5ePuGnzzgoo2GjQGTK7aYVqPlwoqJ8UXOuEowvE59T436Fo2NK3O7p59Jfo9fYo3oFMfxQ8wxDAnzXVNf4nJ5t_IQ8QPQYffvWfjQpUaFqInyrBk8i9kbKg/s600/image16.png" title="The fix is to properly narrow the state from &#34;any refcounted state&#34; to &#34;live&#34; by checking whether the file is still referenced by a file descriptor table entry."/></a></span></p>
 
 <p><span>The fix ensures that a live reference can only be derived from another live reference by comparing with an FD table entry, which is guaranteed to point to a live object.</span></p>
 <p><span>[Sidenote: This scheme is similar to the one used for </span><span>struct page</span><span> - </span><span>gup_pte_range()</span><span> also uses the &#34;grab pointer, increment refcount, recheck pointer&#34; pattern for locklessly looking up a </span><span>struct page</span><span> from a page table entry while ensuring that new refcounted references can&#39;t be created without holding an existing reference. This is really important for </span><span>struct page</span><span> because a page can be given back to the page allocator and reused while </span><span>gup_pte_range()</span><span> holds an uncounted reference to it - freed pages still have their </span><span>struct page</span><span>, so there&#39;s no need to delay freeing of the page - so if this went wrong, you&#39;d get a page UAF.]</span></p>
 
 <p><span>My initial suggestion was to instead fix the issue by changing how </span><span>unix_gc()</span><span> ensures that it has exclusive access, letting it set the file&#39;s refcount to zero to prevent turning RCU references into refcounted ones; this would have avoided adding any code in the hot </span><span>__fget_files()</span><span> path, but it would have only fixed </span><span>unix_gc()</span><span>, not the </span><span>__fdget_pos()</span><span> case I discovered later, so it&#39;s probably a good thing this isn&#39;t how it was fixed:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjHXC99z29mPOQIAGScNNSVvzjt3hy7-8rmPIDE88sfR2DZwMZM0sCUamWA6Fe_sEKXIpbCrDDvbynhyqUWW6PK2sln9GqxqY1R2uXLmPwRmRyQYNeogwnbjTbcdob_VmvNlJ36TWMrTc48wHCcXd7_40UB3uaJNeOJLiFL7NRT_VbqNsYh780UdE8Xlw/s641/image5.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjHXC99z29mPOQIAGScNNSVvzjt3hy7-8rmPIDE88sfR2DZwMZM0sCUamWA6Fe_sEKXIpbCrDDvbynhyqUWW6PK2sln9GqxqY1R2uXLmPwRmRyQYNeogwnbjTbcdob_VmvNlJ36TWMrTc48wHCcXd7_40UB3uaJNeOJLiFL7NRT_VbqNsYh780UdE8Xlw/s600/image5.png" title=""/></a></span></p>
 <p><span>[Sidenote: In my original bug report I wrote that you&#39;d have to wait an RCU grace period in the GC for this, but that wouldn&#39;t be necessary as long as the GC ensures that a reaped socket&#39;s refcount never becomes non-zero again.]</span></p>
 <p><span>There are multiple race conditions involved in exploiting this bug, but by far the trickiest to hit is that we have to race an operation into the tiny race window in the middle of </span><span>__fget_files()</span><span> (which can e.g. be reached via </span><span>dup()</span><span>), between the file descriptor table lookup and the refcount increment:</span></p>
 
 <p><span>static struct file *__fget_files(struct files_struct *files, unsigned int fd,</span></p>
 <p><span>                                 fmode_t mask, unsigned int refs)</span></p>
 <p><span>{</span></p>
 <p><span>        struct file *file;</span></p>
 
 <p><span>        rcu_read_lock();</span></p>
 <p><span>loop:</span></p>
 <p><span>        file = </span><span>files_lookup_fd_rcu(files, fd)</span><span>; </span><span>// race window start</span></p>
 <p><span>        if (file) {</span></p>
 <p><span>                /* File object ref couldn&#39;t be taken.</span></p>
 <p><span>                 * dup2() atomicity guarantee is the reason</span></p>
 <p><span>                 * we loop to catch the new file (or NULL pointer)</span></p>
 <p><span>                 */</span></p>
 <p><span>                if (file-&gt;f_mode &amp; mask)</span></p>
 <p><span>                        file = NULL;</span></p>
 <p><span>                else if (!</span><span>get_file_rcu_many(file, refs)</span><span>) </span><span>// race window end</span></p>
 <p><span>                        goto loop;</span></p>
 <p><span>        }</span></p>
 <p><span>        rcu_read_unlock();</span></p>
 
 <p><span>        return file;</span></p>
 <p><span>}</span></p>
 
 <p><span>In this race window</span><span>, th</span><span>e file descriptor must be closed (to drop the FD&#39;s reference to the file) and a </span><span>unix_gc()</span><span> run must get past the point where it checks the file&#39;s refcount (&#34;</span><span>total_refs = file_count(u-&gt;sk.sk_socket-&gt;file)</span><span>&#34;).</span></p>
 
 <p><span>In the Debian 5.10.0-9-amd64 kernel at version 5.10.70-1, that race window looks as follows:</span></p>
 
 <p><span>&lt;__fget_files+0x1e&gt; cmp    r10,rax</span></p>
 <p><span>&lt;__fget_files+0x21&gt; sbb    rax,rax</span></p>
 <p><span>&lt;__fget_files+0x24&gt; mov    rdx,QWORD PTR [r11+0x8]</span></p>
 <p><span>&lt;__fget_files+0x28&gt; and    eax,r8d</span></p>
 <p><span>&lt;__fget_files+0x2b&gt; lea    rax,[rdx+rax*8]</span></p>
 <p><span>&lt;__fget_files+0x2f&gt; mov    r12,QWORD PTR [rax] </span><span>; RACE WINDOW START</span></p>
 <p><span>; r12 now contains file*</span></p>
 <p><span>&lt;__fget_files+0x32&gt; test   r12,r12</span></p>
 <p><span>&lt;__fget_files+0x35&gt; je     ffffffff812e3df7 &lt;__fget_files+0x77&gt;</span></p>
 <p><span>&lt;__fget_files+0x37&gt; mov    eax,r9d</span></p>
 <p><span>&lt;__fget_files+0x3a&gt; and    eax,DWORD PTR [r12+0x44] </span><span>; LOAD (for -&gt;f_mode)</span></p>
 <p><span>&lt;__fget_files+0x3f&gt; jne    ffffffff812e3df7 &lt;__fget_files+0x77&gt;</span></p>
 <p><span>&lt;__fget_files+0x41&gt; mov    rax,QWORD PTR [r12+0x38] </span><span>; LOAD (for -&gt;f_count)</span></p>
 <p><span>&lt;__fget_files+0x46&gt; lea    rdx,[r12+0x38]</span></p>
 <p><span>&lt;__fget_files+0x4b&gt; test   rax,rax</span></p>
 <p><span>&lt;__fget_files+0x4e&gt; je     ffffffff812e3def &lt;__fget_files+0x6f&gt;</span></p>
 <p><span>&lt;__fget_files+0x50&gt; lea    rcx,[rsi+rax*1]</span></p>
 <p><span>&lt;__fget_files+0x54&gt; lock cmpxchg QWORD PTR [rdx],rcx </span><span>; RACE WINDOW END (on cmpxchg success)</span></p>
 
 <p><span>As you can see, the race window is fairly small - around 12 instructions, assuming that the </span><span>cmpxchg</span><span> succeeds.</span></p>
 <p><span>Luckily for us, the race window contains the first few memory accesses to the </span><span>struct file</span><span>; therefore, by making sure that the </span><span>struct file</span><span> is not present in the fastest CPU caches, we can widen the race window by as much time as the memory accesses take. The standard way to do this is to use </span><span>an eviction pattern</span><span> / </span><span><a href="https://www.cs.columbia.edu/~simha/spyjs.ccs15.pdf">eviction set</a></span><span>; but instead we can also make the cache line dirty on another core (see </span><span><a href="https://dreamsofastone.blogspot.com/2016/02/row-hammer-java-script-and-mesi.html">Anders Fogh&#39;s blogpost</a></span><span> for more detail). (I&#39;m not actually sure about the intricacies of how much latency this adds on different manufacturers&#39; CPU cores, or on different CPU generations - I&#39;ve only tested different versions of my proof-of-concept on Intel Skylake and Tiger Lake. Differences in cache </span><span>coherency</span><span> protocols or snooping might make a big difference.)</span></p>
 
 <p><span>For the cache line containing the flags and refcount of a </span><span>struct file</span><span>, this can be done by, on another CPU, temporarily bumping its refcount up and then changing it back down, e.g. with </span><span>close(dup(fd))</span><span> (or just by accessing the FD in pretty much any way from a multithreaded process).</span></p>
 
 <p><span>However, when we&#39;re trying to hit the race in </span><span>__fget_files()</span><span> via </span><span>dup()</span><span>, we don&#39;t want any cache misses to occur before we hit the race window - that would slow us down and probably make us miss the race. To prevent that from happening, we can call </span><span>dup()</span><span> with a different FD number for a warm-up run shortly before attempting the race. Because we also want the relevant cache line in the FD table to be hot, we should choose the FD number for the warm-up run such that it uses the same cache line of the file descriptor table.</span></p>
 <p><span>Okay, a cache miss might be something like a few dozen or maybe hundred nanoseconds or so - that&#39;s better, but it&#39;s not </span><span>great</span><span>. What </span><span>else can we do to make this tiny</span><span> piece of code much slower to execute?</span></p>
 
 <p><span>On Android, kernels normally set </span><span>CONFIG_PREEMPT</span><span>, which would&#39;ve allowed abusing the scheduler to somehow interrupt the execution of this code. The way I&#39;ve done this in the past was to give the victim thread a low scheduler priority and pin it to a specific CPU core together with another high-priority thread that is blocked on a </span><span>read()</span><span> syscall on an empty pipe (or eventfd); when data is written to the pipe from another CPU core, the pipe becomes readable, so the high-priority thread (which is registered on the pipe&#39;s waitqueue) becomes schedulable, and an inter-processor interrupt (IPI) is sent to the victim&#39;s CPU core to force it to enter the scheduler immediately.</span></p>
 
 <p><span>One problem with that approach, aside from its reliance on </span><span>CONFIG_PREEMPT</span><span>, is that any timing variability in the kernel code involved in sending the IPI makes it harder to actually preempt the victim thread in the right spot.</span></p>
 
 <p><span>(Thanks to the </span><span><a href="https://xenproject.org/users/security/">Xen security team</a></span><span> - I think the first time I heard the idea of using an interrupt to widen a race window might have been from them.)</span></p>
 <p><span>A better way to do this on an Android phone would be to trigger the scheduler not from an IPI, but from an expiring high-resolution timer on the same core</span><span>, although I didn&#39;t get it to work (probably because my code was broken in unrelated ways)</span><span>.</span></p>
 
 <p><span>High-resolution timers (hrtimers) are exposed through many userspace APIs. Even the timeout of </span><span>select()</span><span>/</span><span>pselect()</span><span> uses an hrtimer, although this is an hrtimer that normally has some slack applied to it to allow batching it with timers that are scheduled to expire a bit later. An example of a non-hrtimer-based API is the timeout used for reading from a UNIX domain socket (and probably also other types of sockets?), which can be set via </span><span>SO_RCVTIMEO</span><span>.</span></p>
 
 <p><span>The thing that makes hrtimers &#34;high-resolution&#34; is that they don&#39;t just wait for the next periodic clock tick to arrive; instead, the expiration time of the next hrtimer on the CPU core is programmed into a hardware timer. So we could set an absolute hrtimer for some time in the future via something like </span><span>timer_settime()</span><span> or </span><span>timerfd_settime()</span><span>, and then at exactly the programmed time, the hardware will raise an interrupt! We&#39;ve made the timing behavior of the OS irrelevant for the second side of the race, the only thing that matters is the hardware! Or... well, almost...</span></p>
 <p><span>So we pick some absolute time at which we want to be interrupted, and tell the kernel using a syscall that accepts an absolute time, in nanoseconds. And then when that timer is the next one scheduled, the OS converts the absolute time to whatever clock base/scale the hardware timer is based on, and programs it into hardware. And the hardware usually supports programming timers with absolute time - e.g. on modern X86 (with </span><span>X86_FEATURE_TSC_DEADLINE_TIMER</span><span>), you can simply write an absolute Time Stamp Counter(TSC) deadline into </span><span>MSR_IA32_TSC_DEADLINE</span><span>, and when that deadline is reached, you get an interrupt. The situation on arm64 is similar, using the timer&#39;s comparator register (</span><span>CVAL</span><span>).</span></p>
 
 <p><span>However, on both X86 and arm64, even though the clockevent subsystem is theoretically able to give absolute timestamps to clockevent drivers (via </span><span>-&gt;set_next_ktime()</span><span>), the drivers instead only implement </span><span>-&gt;set_next_event()</span><span>, which takes a relative time as argument. This means that the absolute timestamp has to be converted into a relative one, only to be converted back to absolute a short moment later. The delay between those two operations is essentially added to the timer&#39;s expiration time.</span></p>
 
 <p><span>Luckily this didn&#39;t really seem to be a problem for me; if it was, I would have tried to repeatedly call </span><span>timerfd_settime()</span><span> shortly before the planned expiry time to ensure that the last time the hardware timer is programmed, the relevant code path is hot in the caches. (I did do some experimentation on arm64, where this seemed to </span><span>maybe</span><span> help a tiny bit, but I didn&#39;t really analyze it properly.)</span></p>
 <p><span>Okay, so all the stuff I said above would be helpful on an Android phone with </span><span>CONFIG_PREEMPT</span><span>, but what if we&#39;re trying to target a normal desktop/server kernel that doesn&#39;t have that turned on?</span></p>
 
 <p><span>Well, we can still trigger hrtimer interrupts the same way - we just can&#39;t use them to immediately enter the scheduler and preempt the thread anymore. But instead of using the interrupt for preemption, we could just try to make the interrupt handler run for a really long time.</span></p>
 
 <p><span>Linux has the concept of a &#34;timerfd&#34;, which is a file descriptor that refers to a timer. You can e.g. call </span><span>read()</span><span> on a timerfd, and that operation will block until the timer has expired. Or you can monitor the timerfd using epoll, and it will show up as readable when the timer expires.</span></p>
 
 <p><span>When a timerfd becomes ready, all the timerfd&#39;s waiters (including epoll watches), which are queued up in a linked list, are woken up via the </span><span>wake_up()</span><span> path - just like when e.g. a pipe becomes readable. Therefore, if we can make the list of waiters really long, the interrupt handler will have to spend a lot of time iterating over that list.</span></p>
 
 <p><span>And for any waitqueue that is wired up to a file descriptor, it is fairly easy to add a ton of entries thanks to epoll. Epoll ties its watches to specific FD numbers, so if you duplicate an FD with hundreds of </span><span>dup()</span><span> calls, you can then use a single epoll instance to install hundreds of waiters on the file. Additionally, a single process can have lots of epoll instances. I used 500 epoll instances and 100 duplicate FDs, resulting in 50 000 waitqueue items.</span></p>
 <p><span>A nice aspect of this race condition is that if you only hit the difficult race (</span><span>close()</span><span> the FD and run </span><span>unix_gc()</span><span> while </span><span>dup()</span><span> is preempted between FD table lookup and refcount increment), no memory corruption happens yet, but you can observe that the GC has incorrectly removed a socket buffer (SKB) from the victim socket. Even better, if the race fails, you can also see in which direction it failed, as long as no FDs below the victim FD are unused:</span></p>
 <ul><li><span>If </span><span>dup()</span><span> returns -1, it was called too late / the interrupt happened too soon: The </span><span>file*</span><span> was already gone from the FD table when </span><span>__fget_files()</span><span> tried to load it.</span></li><li><span>If </span><span>dup()</span><span> returns a file descriptor:</span></li></ul><ul><li><span>If it returns an FD higher than the victim FD, this implies that the victim FD was only closed after </span><span>dup()</span><span> had already elevated the refcount and allocated a new FD. This means </span><span>dup()</span><span> was called too soon / the interrupt happened too late.</span></li><li><span>If it returns the old victim FD number:</span></li></ul><ul><li><span>If </span><span>recvmsg()</span><span> on the FD returned by </span><span>dup()</span><span> returns no data, it means the race succeeded: The GC wrongly removed the queued SKB.</span></li><li><span>If </span><span>recvmsg()</span><span> returns data, the interrupt happened between the refcount increment and the allocation of a new FD. </span><span>dup()</span><span> was called a little bit too soon / the interrupt happened a little bit too late.</span></li></ul>
 
 <p><span>Based on this, I repeatedly tested different timing offsets, using a spinloop with a variable number of iterations to skew the timing, and plotted what outcomes the race attempts had depending on the timing skew.</span></p><h2 id="h.8e0qhvge46uf"><span>Results: Debian kernel, on Tiger Lake</span></h2>
 <p><span>I tested this on a Tiger Lake laptop, with the same kernel as shown in the disassembly. Note that &#34;0&#34; on the X axis is offset -300 ns relative to the timer&#39;s programmed expiry.</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhuMDxml-egYM78-ktGQ6EGTqSbY05psG-f4LspmGu4yezOf-EcECjSkJfj6tWirft2IrPiD5C2SfTSleylFckDolapTVZMbxCbPAGDvq3pze1asfz0_6b7Doj4R3hQb9QCT8THR3tcnrxILjDNSKZV6HOSFuDYPn1QhJ6tupmzAbP6mqHomgd-Hza9EA/s580/image12.png"><img alt="This graph shows histograms of race attempt outcomes (too early, success, or too late), with the timing offset at which the outcome occurred on the X axis. The graph shows that depending on the timing offset, up to around 1/3 of race attempts succeeded." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhuMDxml-egYM78-ktGQ6EGTqSbY05psG-f4LspmGu4yezOf-EcECjSkJfj6tWirft2IrPiD5C2SfTSleylFckDolapTVZMbxCbPAGDvq3pze1asfz0_6b7Doj4R3hQb9QCT8THR3tcnrxILjDNSKZV6HOSFuDYPn1QhJ6tupmzAbP6mqHomgd-Hza9EA/s580/image12.png" title="This graph shows histograms of race attempt outcomes (too early, success, or too late), with the timing offset at which the outcome occurred on the X axis. The graph shows that depending on the timing offset, up to around 1/3 of race attempts succeeded."/></a></span></p><h2 id="h.9b7pdk4c8xov"><span>Results: Other kernel, on Skylake</span></h2>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEimQ-1J6OorowaHQQmyc--zzXtYP1EZzBpzjJ-jq_KBxmrFB3D0n5p9ENdijUbenfSy2NF7qU_26fnMr9UHMz0iPSQPF-7QUXzpW_AlGXuUZ9z1q3RkWqtImLiE4W0BSM8VdSXlyr5v78ymoWNd68uZ736e5KSnfZtmrxGZu6wBejVtPV5v4MJJJo3BLw/s652/image8.png"><img alt="This graph shows similar histograms for a Skylake processor. The exact distribution is different, but again, depending on the timing offset, around 1/3 of race attempts succeeded." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEimQ-1J6OorowaHQQmyc--zzXtYP1EZzBpzjJ-jq_KBxmrFB3D0n5p9ENdijUbenfSy2NF7qU_26fnMr9UHMz0iPSQPF-7QUXzpW_AlGXuUZ9z1q3RkWqtImLiE4W0BSM8VdSXlyr5v78ymoWNd68uZ736e5KSnfZtmrxGZu6wBejVtPV5v4MJJJo3BLw/s600/image8.png" title="This graph shows similar histograms for a Skylake processor. The exact distribution is different, but again, depending on the timing offset, around 1/3 of race attempts succeeded."/></a></span></p>
 
 <p><span>These measurements are from an older laptop with a Skylake CPU, running a different kernel. Here &#34;0&#34; on the X axis is offset -1 us relative to the timer. (T</span><span>hese timings are from a system that&#39;s running a different kernel from </span><span>the one shown above, but I don&#39;t think that makes a difference.)</span></p>
 
 <p><span>The exact timings of course look different between CPUs, and they probably also change based on CPU frequency scaling? But still, if you know what the right timing is (or measure the machine&#39;s timing before attempting to actually exploit the bug), you could hit this narrow race with a success rate of about 30%!</span></p>
 
 <p><span>The previous section showed that with the right timing, the race succeeds with a probability around 30% - but it doesn&#39;t show whether the cache miss is actually important for that, or whether the race would still work fine without it. To verify that, I patched my test code to try to make the file&#39;s </span><span>cache line hot (present in the cache) instead of cold (not present in the cache):</span></p>
 
 <p><span>@@ -312,8 +312,10 @@</span></p>
 <p><span>     }</span></p>
 
 <p><span>+#if 0</span></p>
 <p><span>     // bounce socket&#39;s file refcount over to other cpu</span></p>
 <p><span>     pin_to(2);</span></p>
 <p><span>     close(SYSCHK(dup(RESURRECT_FD+1-1)));</span></p>
 <p><span>     pin_to(1);</span></p>
 <p><span>+#endif</span></p>
 
 <p><span>     //printf(&#34;setting timer\n&#34;);</span></p>
 <p><span>@@ -352,5 +354,5 @@</span></p>
 <p><span>     close(loop_root);</span></p>
 <p><span>     while (ts_is_in_future(spin_stop))</span></p>
 <p><span>-      close(SYSCHK(dup(FAKE_RESURRECT_FD)));</span></p>
 <p><span>+      close(SYSCHK(dup(RESURRECT_FD)));</span></p>
 <p><span>     while (ts_is_in_future(my_launch_ts)) /*spin*/;</span></p>
 
 <p><span>With that patch, the race outcomes look like this on the Tiger Lake laptop:</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi9avN3W5e4BGOgUr2wKyhDS767uKhmfLASj_KqKvIo3-Zo6LtGH537g_UAvVOFZ3QfEIECUGweASvgTFKNAmmy_MmWA2oGYn8ijD-Mn6JPEMt2S_mDM54-iS9kIX_p9LuofPB8cD3Nmk5SE0RKftVseOJ8KmHqqAvINyI407B5OYNL_Yr9zXZxLgXlFQ/s659/image2.png"><img alt="This graph is a histogram of race outcomes depending on timing offset; it looks similar to the previous graphs, except that almost no race attempts succeed anymore." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi9avN3W5e4BGOgUr2wKyhDS767uKhmfLASj_KqKvIo3-Zo6LtGH537g_UAvVOFZ3QfEIECUGweASvgTFKNAmmy_MmWA2oGYn8ijD-Mn6JPEMt2S_mDM54-iS9kIX_p9LuofPB8cD3Nmk5SE0RKftVseOJ8KmHqqAvINyI407B5OYNL_Yr9zXZxLgXlFQ/s600/image2.png" title="This graph is a histogram of race outcomes depending on timing offset; it looks similar to the previous graphs, except that almost no race attempts succeed anymore."/></a></span></p>
 <p><span>If you&#39;ve been paying attention, you may have noticed that the timing graphs I&#39;ve been showing are really weird. If we were deterministically hitting the race in exactly the same way every time, the timing graph should look like this (looking just at the &#34;too-early&#34; and &#34;too-late&#34; cases for simplicity):</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh6_04LyOciCrij6wwDqf1uRvEy1zNGCNvZsY5rp37uqa_HDnEJAQQRjRBpCgEnRmkflIgPLrkZK2Jg5V0X_C43bxLrn7906WDwKuNa_1zBVGxxe16rwZgyPOAKohhrowTj-Xf37UuVkXi3gybVk8wlX6OxgRxSzkc-lqhnXmM4816mK-xVh7m86pZVtg/s359/image6.png"><img alt="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome suddenly drops from 100% probability to 0% probability, and a bit afterwards, the &#34;too late&#34; outcome jumps from 0% probability to 100%" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh6_04LyOciCrij6wwDqf1uRvEy1zNGCNvZsY5rp37uqa_HDnEJAQQRjRBpCgEnRmkflIgPLrkZK2Jg5V0X_C43bxLrn7906WDwKuNa_1zBVGxxe16rwZgyPOAKohhrowTj-Xf37UuVkXi3gybVk8wlX6OxgRxSzkc-lqhnXmM4816mK-xVh7m86pZVtg/s359/image6.png" title="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome suddenly drops from 100% probability to 0% probability, and a bit afterwards, the &#34;too late&#34; outcome jumps from 0% probability to 100%"/></a></span></p>
 
 <p><span>Sure, maybe there is some microarchitectural state that is different between runs, causing timing variations - cache state, branch predictor state, frequency scaling, or something along those lines -, but a small number of discrete events that haven&#39;t been accounted for should be adding steps to the graph. (If you&#39;re mathematically inclined, you can model that as the result of a convolution of the ideal timing graph with the timing delay distributions of individual discrete events.) For two unaccounted events, that might look like this:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhrUoPbFMiuzGjxO8Wc6oKMOFbulwITmOuJPMV-xSYffwA-3AjMWp_GbBqbPblxYMsayVXVXxoGq0FN0viOunP0e7Nldp4REeQPiP5RvZ8vt-UorP4vFdRBqDADFaqBArjEiAs8edCfez0FdJ9IX1PMIENR6_8Vk0I3prhG7XKNRwJTiSmbJd70AwmnEw/s359/image18.png"><img alt="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome drops from 100% probability to 0% probability in multiple discrete steps, and overlapping that, the &#34;too late&#34; outcome goes up from 0% probability to 100% in multiple discrete steps" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhrUoPbFMiuzGjxO8Wc6oKMOFbulwITmOuJPMV-xSYffwA-3AjMWp_GbBqbPblxYMsayVXVXxoGq0FN0viOunP0e7Nldp4REeQPiP5RvZ8vt-UorP4vFdRBqDADFaqBArjEiAs8edCfez0FdJ9IX1PMIENR6_8Vk0I3prhG7XKNRwJTiSmbJd70AwmnEw/s359/image18.png" title="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome drops from 100% probability to 0% probability in multiple discrete steps, and overlapping that, the &#34;too late&#34; outcome goes up from 0% probability to 100% in multiple discrete steps"/></a></span></p>
 <p><span>But what the graphs are showing is more of a smooth, linear transition, like this:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFfiLezs131LfoNOHCsoIN0_3E4xIiDQUJOZD8fkFi44MC87ejAq-yS4-3EdJhWDzhhlAUeMH4TUfL6sSJRjaCYRSydYLLhBpiv97SNExvmWj_LKtTA_JT5DZl5n-2kb_2Rwrkg7C_bOKsI85DfwOo5ae6bBlqYjph38H5pBZBIkTG8OYF5nT8N-KFAQ/s359/image13.png"><img alt="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome&#39;s share linearly drops while the &#34;too late&#34; outcome&#39;s share linearly rises" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFfiLezs131LfoNOHCsoIN0_3E4xIiDQUJOZD8fkFi44MC87ejAq-yS4-3EdJhWDzhhlAUeMH4TUfL6sSJRjaCYRSydYLLhBpiv97SNExvmWj_LKtTA_JT5DZl5n-2kb_2Rwrkg7C_bOKsI85DfwOo5ae6bBlqYjph38H5pBZBIkTG8OYF5nT8N-KFAQ/s359/image13.png" title="A sketch of a histogram of race outcomes where the &#34;too early&#34; outcome&#39;s share linearly drops while the &#34;too late&#34; outcome&#39;s share linearly rises"/></a></span></p>
 
 <p><span>And that seems to me like there&#39;s still something fundamentally wrong. Sure, if there was a sufficiently large number of discrete events mixed together, the curve would eventually just look like a smooth smear - but it seems unlikely to me that there is such a large number of somewhat-evenly distributed random discrete events. And sure, we do get a small amount of timing inaccuracy from sampling the clock in a spinloop, but that should be bounded to the execution time of that spinloop, and the timing smear is far too big for that.</span></p>
 
 <p><span>So it looks like there is a source of randomness that isn&#39;t a discrete event, but something that introduces a random amount of timing delay within some window. So I became suspicious of the hardware timer. The kernel is using </span><span>MSR_IA32_TSC_DEADLINE</span><span>, and the Intel SDM tells us that that thing is programmed with a TSC value, which makes it look as if the timer has very high granularity. But </span><span>MSR_IA32_TSC_DEADLINE</span><span> is a newer mode of the LAPIC timer, and the older LAPIC timer modes were instead programmed in units of the APIC timer frequency. According to the </span><span><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf#page=378">Intel SDM, Volume 3A</a></span><span>, section 10.5.4 &#34;APIC Timer&#34;, that is &#34;</span><span>the processor’s bus clock or core crystal clock frequency (when TSC/core crystal clock ratio is enumerated in CPUID leaf 0x15) divided by the value specified in the divide configuration register</span><span>&#34;. This frequency is significantly lower than the TSC frequency. So perhaps </span><span>MSR_IA32_TSC_DEADLINE</span><span> is actually just a front-end to the same old APIC timer?</span></p>
 
 <p><span>I tried to measure the difference between the programmed TSC value and when execution was actually interrupted (not when the interrupt handler starts running, but when the old execution context is interrupted - you can measure that if the interrupted execution context is just running RDTSC in a loop); that looks as follows:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiW-q2Y4qk2XxZFtmNh0dVgZBg2qi_J6GIBXjssAs3Kek3XT8Mzlr76jzRv0SVspubXHHgEg1tENINosS43VBcajf3EhRn4Pwn4WnqjKgslRtQkEDzCotXBoL4iOIdpJU3vlI4e11jlso63hx61a6tDRXTY5ViS5izijo5wpJfh5Ht_L1cZxUeisSfbRA/s756/image11.png"><img alt="A graph showing noise. Delays from deadline TSC to last successful TSC read before interrupt look essentially random, in the range from around -130 to around 10." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiW-q2Y4qk2XxZFtmNh0dVgZBg2qi_J6GIBXjssAs3Kek3XT8Mzlr76jzRv0SVspubXHHgEg1tENINosS43VBcajf3EhRn4Pwn4WnqjKgslRtQkEDzCotXBoL4iOIdpJU3vlI4e11jlso63hx61a6tDRXTY5ViS5izijo5wpJfh5Ht_L1cZxUeisSfbRA/s600/image11.png" title="A graph showing noise. Delays from deadline TSC to last successful TSC read before interrupt look essentially random, in the range from around -130 to around 10."/></a></span></p>
 
 <p><span>As you can see, the expiry of the hardware timer indeed adds a bunch of noise. The size of the timing difference is also very close to the crystal clock frequency - the TSC/core crystal clock ratio on this machine is 117. So I tried plotting the </span><span>absolute</span><span> TSC values at which execution was interrupted, </span><span>modulo the TSC / core crystal clock ratio</span><span>, and got this:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjnhvIj_v78i3_Vk4BRrZSOL2rktWnNEk3HNyageLBS1YnGQt7PCGWA5EmZMF1xzo_XlSTi1z4Rqyi6ltOkOCEE17MEltCI15H4QlomxfCvWuIO0z_aKdJct-3M9PfF2RXWq-JdMTjnC1qouedbaJ8tV4PIUbpItClOwUC_nPrJV9QoQsNngpXzMb6xeA/s543/image9.png"><img alt="A graph showing a clear grouping around 0, roughly in the range -20 to 10, with some noise scattered over the rest of the graph." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjnhvIj_v78i3_Vk4BRrZSOL2rktWnNEk3HNyageLBS1YnGQt7PCGWA5EmZMF1xzo_XlSTi1z4Rqyi6ltOkOCEE17MEltCI15H4QlomxfCvWuIO0z_aKdJct-3M9PfF2RXWq-JdMTjnC1qouedbaJ8tV4PIUbpItClOwUC_nPrJV9QoQsNngpXzMb6xeA/s543/image9.png" title="A graph showing a clear grouping around 0, roughly in the range -20 to 10, with some noise scattered over the rest of the graph."/></a></span></p>
 <p><span>This confirms that </span><span>MSR_IA32_TSC_DEADLINE</span><span> is (apparently) an interface that </span><span>internally converts the specified TSC value into less granular bus clock / core crystal clock time</span><span>, at least on some Intel CPUs.</span></p>
 
 <p><span>But there&#39;s still something really weird here: The TSC values at which execution seems to be interrupted were at </span><span>negative</span><span> offsets relative to the programmed expiry time, as if the timeouts were rounded </span><span>down</span><span> to the less granular clock, or something along those lines. To get a better idea of how timer interrupts work, I measured on yet another system (an old Haswell CPU) with a patched kernel when execution is interrupted and when the interrupt handler starts executing relative to the programmed expiry time (and also plotted the difference between the two):</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj5P8-0GRdUXYX5Xyx-xoQbDZhsXDHuWWZZZoQWRHV-wPY9U7CuelBHQSODbeqrBGbGhuSDRVyKmiFmG1PiXxQHtNDKZfEwKUcmE5cw-c-3A-3wzfJrZedEfk3zyaTXv8_A4UmxMejdeWNhZ2l8AuoLhcDveiOjzsl9Lmpw4g6eS2ccT3koir8Qy0SMGg/s928/image17.png"><img alt="A graph showing that the skid from programmed interrupt time to execution interruption is around -100 to -30 cycles, the skid to interrupt entry is around 360 to 420 cycles, and the time from execution interruption to interrupt entry has much less timing variance and is at around 440 cycles." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj5P8-0GRdUXYX5Xyx-xoQbDZhsXDHuWWZZZoQWRHV-wPY9U7CuelBHQSODbeqrBGbGhuSDRVyKmiFmG1PiXxQHtNDKZfEwKUcmE5cw-c-3A-3wzfJrZedEfk3zyaTXv8_A4UmxMejdeWNhZ2l8AuoLhcDveiOjzsl9Lmpw4g6eS2ccT3koir8Qy0SMGg/s600/image17.png" title="A graph showing that the skid from programmed interrupt time to execution interruption is around -100 to -30 cycles, the skid to interrupt entry is around 360 to 420 cycles, and the time from execution interruption to interrupt entry has much less timing variance and is at around 440 cycles."/></a></span></p>
 <p><span>So it looks like the CPU starts handling timer interrupts a little bit before the programmed expiry time, but interrupt handler entry takes so long (~450 TSC clock cycles?) that by the time the CPU starts executing the interrupt handler, the timer expiry time has long passed.</span></p>
 
 <p><span>Anyway, the important bit for us is that when the CPU interrupts execution due to timer expiry, it&#39;s always at a LAPIC timer edge; and LAPIC timer edges happen when the TSC value is a multiple of the TSC/LAPIC clock ratio. An exploit that doesn&#39;t take that into account and wrongly assumes that </span><span>MSR_IA32_TSC_DEADLINE</span><span> has TSC granularity will have its timing smeared by one LAPIC clock period, which can be something like 40ns.</span></p>
 
 
 <p><span>The ~30% accuracy we could achieve with the existing PoC with the right timing is already not terrible; but if we control for the timer&#39;s weirdness, can we do better?</span></p>
 
 <p><span>The problem is that we are effectively launching the race with two timers that behave differently: One timer based on calling </span><span>clock_gettime()</span><span> in a loop (which uses the high-resolution TSC to compute a time), the other a hardware timer based on the lower-resolution LAPIC clock. I see two options to fix this:</span></p>
 <ol start="1"><li><span>Try to ensure that the second timer is set at the start of a LAPIC clock period - that way, the second timer should hopefully behave exactly like the first (or have an additional fixed offset, but we can compensate for that).</span></li><li><span>Shift the first timer&#39;s expiry time down according to the distance from the second timer to the previous LAPIC clock period.</span></li></ol>
 
 <p><span>(One annoyance with this is that while we can grab information on how wall/monotonic time is calculated from TSC from the vvar mapping used by the vDSO, the clock is subject to minuscule additional corrections at every clock tick, which occur every 4ms on standard distro kernels (with </span><span>CONFIG_HZ=250</span><span>) as long as any core is running.)</span></p>
 
 <p><span>I tried to see whether the timing graph would look nicer if I accounted for this LAPIC clock rounding and also used a custom kernel to cheat and control for possible skid introduced by the absolute-to-relative-and-back conversion of the expiry time (see further up), but that still didn&#39;t help all that much.</span></p>
 <p><span>Something I should&#39;ve thought about way earlier is that of course, clock speed matters. On newer Intel CPUs with P-states, the CPU is normally in control of its own frequency, and dynamically adjusts it as it sees fit; the OS just provides some hints.</span></p>
 
 <p><span>Linux has an interface that claims to tell you the &#34;current frequency&#34; of each CPU core in </span><span>/sys/devices/system/cpu/cpufreq/policy&lt;n&gt;/scaling_cur_freq</span><span>, but when I tried using that, I got a different &#34;frequency&#34; every time I read that file, which seemed suspicious.</span></p>
 
 <p><span>Looking at the implementation, it turns out that the value shown there is calculated in </span><span>arch_freq_get_on_cpu()</span><span> and </span><span>its</span><span> </span><span>callees</span><span> - the value is calculated on demand when the file is read, with results cached for around 10 milliseconds. The value is determined as the ratio between the deltas of </span><span>MSR_IA32_APERF</span><span> and </span><span>MSR_IA32_MPERF</span><span> between the last read and the current one. So if you have some tool that is polling these values every few seconds and wants to show average clock frequency over that time, it&#39;s probably a good way of doing things; but if you actually want the current clock frequency, it&#39;s not a good fit.</span></p>
 
 <p><span>I hacked a helper into my kernel that samples both MSRs twice in quick succession, and that gives much cleaner results. When I measure the clock speeds and timing offsets at which the race succeeds, the result looks like this (showing just two clock speeds; the Y axis is the number of race successes at the clock offset specified on the X axis and the frequency scaling specified by the color):</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMIfuP5LR9MCV5pN4dQfl-VCNLcYqE6Y0Doo0JmCsmr5QiE9NAxlhBUk2LcXsfb0HumRMsyzic3Fjtbge_JtCpgkyj4qpSSkbh6-hfVhQr3EmPwpvoWxQarBApQDXiwuCLdVEUxkngjNkh_GvO2-JB9gg53-j5oX8lXr5Ih-3Z7rz34zgB7kK2MzOnBw/s666/image1%20%281%29.png"><img alt="A graph showing that the timing of successful race attempts depends on the CPU&#39;s performance setting - at 11/28 performance, most successful race attempts occur around clock offset -1200 (in TSC units), while at 14/28 performance, most successful race attempts occur around clock offset -1000." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMIfuP5LR9MCV5pN4dQfl-VCNLcYqE6Y0Doo0JmCsmr5QiE9NAxlhBUk2LcXsfb0HumRMsyzic3Fjtbge_JtCpgkyj4qpSSkbh6-hfVhQr3EmPwpvoWxQarBApQDXiwuCLdVEUxkngjNkh_GvO2-JB9gg53-j5oX8lXr5Ih-3Z7rz34zgB7kK2MzOnBw/s600/image1%20%281%29.png" title="A graph showing that the timing of successful race attempts depends on the CPU&#39;s performance setting - at 11/28 performance, most successful race attempts occur around clock offset -1200 (in TSC units), while at 14/28 performance, most successful race attempts occur around clock offset -1000."/></a></span></p>
 <p><span>So clearly, dynamic frequency scaling has a huge impact on the timing of the race - I guess that&#39;s to be expected, really.</span></p>
 
 <p><span>But even accounting for all this, the graph still looks kind of smooth, so clearly there is still something more that I&#39;m missing - oh well. I decided to stop experimenting with the race&#39;s timing at this point, since I didn&#39;t want to sink too much time into it. (Or perhaps I actually just stopped because I got distracted by newer and shinier things?)</span></p>
 <p><span>Anyway, I could probably spend much more time trying to investigate the timing variations (and probably mostly bang my head against a wall because details of execution timing are really difficult to understand in detail, and to understand it completely, it might be necessary to use something like </span><span><a href="https://gamozolabs.github.io/metrology/2019/08/19/sushi_roll.html">Gamozo Labs&#39; &#34;Sushi Roll&#34;</a></span><span> and then go through every single instruction in detail and compare the observations to the internal architecture of the CPU). Let&#39;s not do that, and get back to how to actually exploit this bug!</span></p>
 
 <p><span>To turn this bug into memory corruption, we have to abuse that the </span><span>recvmsg()</span><span> path assumes that SKBs on the receive queue are protected from deletion by the socket mutex while the GC actually deletes SKBs from the receive queue without touching the socket mutex. For that purpose, while the unix GC is running, we have to start a </span><span>recvmsg()</span><span> call that looks up the victim SKB, block until the unix GC has freed the SKB, and then let </span><span>recvmsg()</span><span> continue operating on the freed SKB. This is fairly straightforward - while it is a race, we can easily slow down </span><span>unix_gc()</span><span> for multiple milliseconds by creating lots of sockets that are not directly referenced from the FD table and have many tiny SKBs queued up - here&#39;s a graph showing the unix GC execution time on my laptop, depending on the number of queued SKBs that the GC has to scan through:</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0LcZNwFYw4nd-9oLDSGMOfrBVQSmYhonQJ_dPBcls3arS_m0_sSkQ7W7t4uaTJlkBgUc8gKgZquaKqs5KBmO4KNRrp9O09nLg_8N3m0wTHbZ8uINXqQ2L36shkZweV2lhvMPHthSOlTrdeAt3qe-e3e-IcIIJ22jPoXUFSbUmleX7AvD2eIZJTqOP5Q/s833/image15.png"><img alt="A graph showing the time spent per GC run depending on the number of queued SKBs. The relationship is roughly linear." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0LcZNwFYw4nd-9oLDSGMOfrBVQSmYhonQJ_dPBcls3arS_m0_sSkQ7W7t4uaTJlkBgUc8gKgZquaKqs5KBmO4KNRrp9O09nLg_8N3m0wTHbZ8uINXqQ2L36shkZweV2lhvMPHthSOlTrdeAt3qe-e3e-IcIIJ22jPoXUFSbUmleX7AvD2eIZJTqOP5Q/s600/image15.png" title="A graph showing the time spent per GC run depending on the number of queued SKBs. The relationship is roughly linear."/></a></span></p>
 
 
 <p><span>To turn this into a UAF, it&#39;s also necessary to get past the following check near the end of </span><span>unix_gc()</span><span>:</span></p>
 
 <p><span>       /* All candidates should have been detached by now. */</span></p>
 <p><span>        BUG_ON(!list_empty(&amp;gc_candidates));</span></p>
 
 <p><span>gc_candidates</span><span> is a list that previously contained all sockets that were deemed to be unreachable by the GC. Then, the GC attempted to free all those sockets by eliminating their mutual references. If we manage to keep a reference to one of the sockets that the GC thought was going away, the GC detects that with the </span><span>BUG_ON()</span><span>.</span></p>
 
 <p><span>But we don&#39;t actually need the victim SKB to reference a socket that the GC thinks is going away; in </span><span>scan_inflight()</span><span>, the GC targets any SKB with a socket that is marked </span><span>UNIX_GC_CANDIDATE</span><span>, meaning it just had to be </span><span>a candidate</span><span> for being scanned by the GC. So by making the victim SKB hold a reference to a socket that is not directly referenced from a file descriptor table, but is indirectly referenced by a file descriptor table through another socket, we can ensure that the </span><span>BUG_ON()</span><span> won&#39;t trigger.</span></p>
 
 <p><span>I extended </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2247#c6">my reproducer</a></span><span> with this trick and some userfaultfd trickery to make </span><span>recv()</span><span> run with the right timing. Nowadays you don&#39;t necessarily get full access to userfaultfd as a normal user, but since I&#39;m just trying to show the concept, and there are alternatives to userfaultfd</span><span> (using FUSE or just slow disk access</span><span>)</span><span>,</span><span> that&#39;s good enough for this blogpost.</span></p>
 
 <p><span>When a normal distro kernel is running normally, the UAF reproducer&#39;s UAF accesses won&#39;t actually be noticeable; but if you add the kernel command line flag </span><span>slub_debug=FP</span><span> (to enable SLUB&#39;s poisoning and sanity checks), the reproducer quickly crashes twice, first with a poison dereference and then a poison overwrite detection, showing that one byte of the poison was incremented:</span></p>
 
 <p><span>general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] SMP NOPTI</span></p>
 <p><span>CPU: 1 PID: 2655 Comm: hardirq_loop Not tainted 5.10.0-9-amd64 #1 Debian 5.10.70-1</span></p>
 <p><span>[...]</span></p>
 <p><span>RIP: 0010:unix_stream_read_generic+0x72b/0x870</span></p>
 <p><span>Code: fe ff ff 31 ff e8 85 87 91 ff e9 a5 fe ff ff 45 01 77 44 8b 83 80 01 00 00 85 c0 0f 89 10 01 00 00 49 8b 47 38 48 85 c0 74 23 &lt;0f&gt; bf 00 66 85 c0 0f 85 20 01 00 00 4c 89 fe 48 8d 7c 24 58 44 89</span></p>
 <p><span>RSP: 0018:ffffb789027f7cf0 EFLAGS: 00010202</span></p>
 <p><span>RAX: 6b6b6b6b6b6b6b6b RBX: ffff982d1d897b40 RCX: 0000000000000000</span></p>
 <p><span>RDX: 6a0fe1820359dce8 RSI: ffffffffa81f9ba0 RDI: 0000000000000246</span></p>
 <p><span>RBP: ffff982d1d897ea8 R08: 0000000000000000 R09: 0000000000000000</span></p>
 <p><span>R10: 0000000000000000 R11: ffff982d2645c900 R12: ffffb789027f7dd0</span></p>
 <p><span>R13: ffff982d1d897c10 R14: 0000000000000001 R15: ffff982d3390e000</span></p>
 <p><span>FS:  00007f547209d740(0000) GS:ffff98309fa40000(0000) knlGS:0000000000000000</span></p>
 <p><span>CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span></p>
 <p><span>CR2: 00007f54722cd000 CR3: 00000001b61f4002 CR4: 0000000000770ee0</span></p>
 <p><span>PKRU: 55555554</span></p>
 <p><span>Call Trace:</span></p>
 <p><span>[...]</span></p>
 <p><span> unix_stream_recvmsg+0x53/0x70</span></p>
 <p><span>[...]</span></p>
 <p><span> __sys_recvfrom+0x166/0x180</span></p>
 <p><span>[...]</span></p>
 <p><span> __x64_sys_recvfrom+0x25/0x30</span></p>
 <p><span> do_syscall_64+0x33/0x80</span></p>
 <p><span> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span></p>
 <p><span>[...]</span></p>
 <p><span>---[ end trace 39a81eb3a52e239c ]---</span></p>
 <p><span>=============================================================================</span></p>
 <p><span>BUG skbuff_head_cache (Tainted: G      D          ): Poison overwritten</span></p>
 <p><span>-----------------------------------------------------------------------------</span></p>
 
 <p><span>INFO: 0x00000000d7142451-0x00000000d7142451 @offset=68. First byte 0x6c instead of 0x6b</span></p>
 <p><span>INFO: Slab 0x000000002f95c13c objects=32 used=32 fp=0x0000000000000000 flags=0x17ffffc0010200</span></p>
 <p><span>INFO: Object 0x00000000ef9c59c8 @offset=0 fp=0x00000000100a3918</span></p>
 
 <p><span>Object   00000000ef9c59c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   0000000097454be8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   0000000035f1d791: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   00000000af71b907: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   000000000d2d371e: 6b 6b 6b 6b </span><span>6c</span><span> 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkklkkkkkkkkkkk</span></p>
 <p><span>Object   0000000000744b35: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   00000000794f2935: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   000000006dc06746: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   000000005fb18682: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   0000000072eb8dd2: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   00000000b5b572a9: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   0000000085d6850b: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   000000006346150b: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span></p>
 <p><span>Object   000000000ddd1ced: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.</span></p>
 <p><span>Padding  00000000e00889a7: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ</span></p>
 <p><span>Padding  00000000d190015f: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ</span></p>
 <p><span>CPU: 7 PID: 1641 Comm: gnome-shell Tainted: G    B D           5.10.0-9-amd64 #1 Debian 5.10.70-1</span></p>
 <p><span>[...]</span></p>
 <p><span>Call Trace:</span></p>
 <p><span> dump_stack+0x6b/0x83</span></p>
 <p><span> check_bytes_and_report.cold+0x79/0x9a</span></p>
 <p><span> check_object+0x217/0x260</span></p>
 <p><span>[...]</span></p>
 <p><span> alloc_debug_processing+0xd5/0x130</span></p>
 <p><span> ___slab_alloc+0x511/0x570</span></p>
 <p><span>[...]</span></p>
 <p><span> __slab_alloc+0x1c/0x30</span></p>
 <p><span> kmem_cache_alloc_node+0x1f3/0x210</span></p>
 <p><span> __alloc_skb+0x46/0x1f0</span></p>
 <p><span> alloc_skb_with_frags+0x4d/0x1b0</span></p>
 <p><span> sock_alloc_send_pskb+0x1f3/0x220</span></p>
 <p><span>[...]</span></p>
 <p><span> unix_stream_sendmsg+0x268/0x4d0</span></p>
 <p><span> sock_sendmsg+0x5e/0x60</span></p>
 <p><span> ____sys_sendmsg+0x22e/0x270</span></p>
 <p><span>[...]</span></p>
 <p><span> ___sys_sendmsg+0x75/0xb0</span></p>
 <p><span>[...]</span></p>
 <p><span> __sys_sendmsg+0x59/0xa0</span></p>
 <p><span> do_syscall_64+0x33/0x80</span></p>
 <p><span> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span></p>
 <p><span>[...]</span></p>
 <p><span>FIX skbuff_head_cache: Restoring 0x00000000d7142451-0x00000000d7142451=0x6b</span></p>
 
 <p><span>FIX skbuff_head_cache: Marking all objects used</span></p>
 <p><span>RIP: 0010:unix_stream_read_generic+0x72b/0x870</span></p>
 <p><span>Code: fe ff ff 31 ff e8 85 87 91 ff e9 a5 fe ff ff 45 01 77 44 8b 83 80 01 00 00 85 c0 0f 89 10 01 00 00 49 8b 47 38 48 85 c0 74 23 &lt;0f&gt; bf 00 66 85 c0 0f 85 20 01 00 00 4c 89 fe 48 8d 7c 24 58 44 89</span></p>
 <p><span>RSP: 0018:ffffb789027f7cf0 EFLAGS: 00010202</span></p>
 <p><span>RAX: 6b6b6b6b6b6b6b6b RBX: ffff982d1d897b40 RCX: 0000000000000000</span></p>
 <p><span>RDX: 6a0fe1820359dce8 RSI: ffffffffa81f9ba0 RDI: 0000000000000246</span></p>
 <p><span>RBP: ffff982d1d897ea8 R08: 0000000000000000 R09: 0000000000000000</span></p>
 <p><span>R10: 0000000000000000 R11: ffff982d2645c900 R12: ffffb789027f7dd0</span></p>
 <p><span>R13: ffff982d1d897c10 R14: 0000000000000001 R15: ffff982d3390e000</span></p>
 <p><span>FS:  00007f547209d740(0000) GS:ffff98309fa40000(0000) knlGS:0000000000000000</span></p>
 <p><span>CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span></p>
 <p><span>CR2: 00007f54722cd000 CR3: 00000001b61f4002 CR4: 0000000000770ee0</span></p>
 <p><span>PKRU: 55555554</span></p>
 <p><span>Hitting a race can become easier if, instead of racing two threads against each other, you race one thread against a hardware timer to create a gigantic timing window for the other thread. Hence the title! On the other hand, it introduces extra complexity because now you have to think about how timers actually work, and turns out, time is a complicated concept...</span></p>
 
 <p><span>This shows how at least some really tight races can still be hit and </span><span>we should treat them</span><span> as security bugs, even if it seems like they&#39;d be very hard to hit at first glance.</span></p>
 
 <p><span>Also, precisely timing races is hard, and the details of how long it actually takes the CPU to get from one point to another are mysterious. (As not only exploit writers know, but also anyone who&#39;s ever wanted to benchmark a performance-relevant change...)</span></p>
 <p><span>I did also play around with this stuff on arm64 a bit, and I was wondering: At what points do interrupts actually get delivered? Does an incoming interrupt force the CPU to drop everything immediately, or do inflight operations finish first? This gets particularly interesting on phones that contain two or three different types of CPUs mixed together.</span></p>
 
 <p><span>On a Pixel 4 (which has 4 slow in-order cores, 3 fast cores, and 1 faster core), I tried firing an interval timer at 100Hz (using </span><span>timer_create()</span><span>), with a signal handler that logs the </span><span>PC</span><span> register, while running this loop:</span></p>
 
 <p><span>  400680:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  400684:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  400688:        9ac20820         udiv        x0, x1, x2</span></p>
 <p><span>  40068c:        91006800         add        x0, x0, #0x1a</span></p>
 <p><span>  400690:        91000400         add        x0, x0, #0x1</span></p>
 <p><span>  400694:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  400698:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  40069c:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006a0:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006a4:        9ac20820         udiv        x0, x1, x2</span></p>
 <p><span>  4006a8:        91006800         add        x0, x0, #0x1a</span></p>
 <p><span>  4006ac:        91000400         add        x0, x0, #0x1</span></p>
 <p><span>  4006b0:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006b4:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006b8:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006bc:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006c0:        17fffff0         b        400680 &lt;main+0xe0&gt;</span></p>
 
 <p><span>The logged interrupt PCs had the following distribution on a slow in-order core:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqse8TiPYh3VAgo0AfMkIorhlVy5WzrvROCvjOmzMYwGS1lkK4gkTiPmgDF1X3qRsCMAo53nPrsxLJKMlTkbSgDSeOV0I19IV7Rp2w20lPrlOfnfjPX1-04VnZO7NEHYxZkRBB9zyzIpLrEcsQSqgo69j6KLkNVJQbGtEqPHdZioNkTM5X4EWDgBc-CA/s1252/image3.png"><img alt="A histogram of PC register values, where most instructions in the loop have roughly equal frequency, the instructions after udiv instructions have twice the frequency, and two other instructions have zero frequency." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqse8TiPYh3VAgo0AfMkIorhlVy5WzrvROCvjOmzMYwGS1lkK4gkTiPmgDF1X3qRsCMAo53nPrsxLJKMlTkbSgDSeOV0I19IV7Rp2w20lPrlOfnfjPX1-04VnZO7NEHYxZkRBB9zyzIpLrEcsQSqgo69j6KLkNVJQbGtEqPHdZioNkTM5X4EWDgBc-CA/s600/image3.png" title="A histogram of PC register values, where most instructions in the loop have roughly equal frequency, the instructions after udiv instructions have twice the frequency, and two other instructions have zero frequency."/></a></span></p>
 <p><span>and this distribution on a fast out-of-order core:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgh-hKRfnypuIT0Q_ok_NI8dQ49QqWLmvjVFKGphIShpHLeBwZTCHg-oDza4TYMB907G0aQZkEeqVFhgw4HnXbb8HKOYVuPdGrqXQMwS_72RWjp2YVBNeJXvFlDxsTiYqj053Yqd8BEXa0fqKvN3LhBeyR2iPh_Y-uYfkjW1s6mwswfvHE3iKbvZbTfJA/s1252/image7.png"><img alt="A histogram of PC register values, where the first instruction of the loop has very high frequency, the following 4 instructions have near-zero frequency, and the following instructions have low frequencies" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgh-hKRfnypuIT0Q_ok_NI8dQ49QqWLmvjVFKGphIShpHLeBwZTCHg-oDza4TYMB907G0aQZkEeqVFhgw4HnXbb8HKOYVuPdGrqXQMwS_72RWjp2YVBNeJXvFlDxsTiYqj053Yqd8BEXa0fqKvN3LhBeyR2iPh_Y-uYfkjW1s6mwswfvHE3iKbvZbTfJA/s600/image7.png" title="A histogram of PC register values, where the first instruction of the loop has very high frequency, the following 4 instructions have near-zero frequency, and the following instructions have low frequencies"/></a></span></p>
 <p><span>As always, out-of-order (OOO) cores make everything weird, and the start of the loop seems to somehow &#34;provide cover&#34; for the following instructions; but on the in-order core, we can see that more interrupts arrive </span><span>after</span><span> the slow udiv instructions. So apparently, when one of those is executing while an interrupt arrives, it continues executing and doesn&#39;t get aborted somehow?</span></p>
 
 <p><span>With the following loop, which has a </span><span>LDR</span><span> instruction mixed in that accesses a memory location that is constantly being modified by another thread:</span></p>
 
 <p><span>  4006a0:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006a4:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006a8:        9ac20820         udiv        x0, x1, x2</span></p>
 <p><span>  4006ac:        91006800         add        x0, x0, #0x1a</span></p>
 <p><span>  4006b0:        91000400         add        x0, x0, #0x1</span></p>
 <p><span>  4006b4:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006b8:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006bc:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006c0:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006c4:        9ac20820         udiv        x0, x1, x2</span></p>
 <p><span>  4006c8:        91006800         add        x0, x0, #0x1a</span></p>
 <p><span>  4006cc:        91000400         add        x0, x0, #0x1</span></p>
 <p><span>  4006d0:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006d4:        f9400061         ldr        x1, [x3]</span></p>
 <p><span>  4006d8:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006dc:        91000442         add        x2, x2, #0x1</span></p>
 <p><span>  4006e0:        91000421         add        x1, x1, #0x1</span></p>
 <p><span>  4006e4:        17ffffef         b        4006a0 &lt;main+0x100&gt;</span></p>
 
 <p><span>the cache-missing loads obviously have a large influence on the timing. On the in-order core:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEie4WFUqhiL_H1pxbU_2lUfAaYJQLubtcW_KqPEDemtMCFxpId8H4xs9sFnhui_sqf2oCr9yARQxAGB9-ej4GD3CQdmypHDK9QD5WAL2AS64Iz-WCUgKlKFtVyjJ9swQhnZOF9NCZJw_JdmBg-BlxAtqTay9eAWSfhHjr6n_Sgg6VhpoZzh8QD-xHeOfg/s1252/image4.png"><img alt="A histogram of interrupt instruction pointers, showing that most interrupts are delivered with PC pointing to the instruction after the high-latency load instruction." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEie4WFUqhiL_H1pxbU_2lUfAaYJQLubtcW_KqPEDemtMCFxpId8H4xs9sFnhui_sqf2oCr9yARQxAGB9-ej4GD3CQdmypHDK9QD5WAL2AS64Iz-WCUgKlKFtVyjJ9swQhnZOF9NCZJw_JdmBg-BlxAtqTay9eAWSfhHjr6n_Sgg6VhpoZzh8QD-xHeOfg/s600/image4.png" title="A histogram of interrupt instruction pointers, showing that most interrupts are delivered with PC pointing to the instruction after the high-latency load instruction."/></a></span></p>
 <p><span>On the OOO core:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTuK6gNw72sreYVEF_lHfOxHPGElJG1G4_alcQQFzLup5yDnJItZ1E39nK3y7haSH3QhsTiAYmJhcyNltONZPuq-tM5Id1xL5gr6CI91n6XMZ3_ivjuahaMAhO1OiUjR4oBzChtJDh5jnlSJsW0hPQgS-H5KV-k5Gwhd68j_wwhaGGoJCxIb2SFPvhqg/s1297/image20.png"><img alt="A similar histogram as the previous one, except that an even larger fraction of interrupt PCs are after the high-latency load instruction." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTuK6gNw72sreYVEF_lHfOxHPGElJG1G4_alcQQFzLup5yDnJItZ1E39nK3y7haSH3QhsTiAYmJhcyNltONZPuq-tM5Id1xL5gr6CI91n6XMZ3_ivjuahaMAhO1OiUjR4oBzChtJDh5jnlSJsW0hPQgS-H5KV-k5Gwhd68j_wwhaGGoJCxIb2SFPvhqg/s600/image20.png" title="A similar histogram as the previous one, except that an even larger fraction of interrupt PCs are after the high-latency load instruction."/></a></span></p>
 
 <p><span>What is interesting to me here is that the timer interrupts seem to again arrive </span><span>after</span><span> the slow load - implying that if an interrupt arrives while a slow memory access is in progress, the interrupt handler may not get to execute until the memory access has finished? (Unless maybe on the OOO core the interrupt handler can start speculating already? I wouldn&#39;t really expect that, but could imagine it.)</span></p>
 
 <p><span>On an X86 Skylake CPU, we can do a similar test:</span></p>
 
 <p><span>    11b8:        48 83 c3 01                  add    $0x1,%rbx</span></p>
 <p><span>    11bc:        48 83 c0 01                  add    $0x1,%rax</span></p>
 <p><span>    11c0:        48 01 d8                     add    %rbx,%rax</span></p>
 <p><span>    11c3:        48 83 c3 01                  add    $0x1,%rbx</span></p>
 <p><span>    11c7:        48 83 c0 01                  add    $0x1,%rax</span></p>
 <p><span>    11cb:        48 01 d8                     add    %rbx,%rax</span></p>
 <p><span>    11ce:        48 03 02                     add    (%rdx),%rax</span></p>
 <p><span>    11d1:        48 83 c0 01                  add    $0x1,%rax</span></p>
 <p><span>    11d5:        48 83 c3 01                  add    $0x1,%rbx</span></p>
 <p><span>    11d9:        48 01 d8                     add    %rbx,%rax</span></p>
 <p><span>    11dc:        48 83 c3 01                  add    $0x1,%rbx</span></p>
 <p><span>    11e0:        48 83 c0 01                  add    $0x1,%rax</span></p>
 <p><span>    11e4:        48 01 d8                     add    %rbx,%rax</span></p>
 <p><span>    11e7:        eb cf                        jmp    11b8 &lt;main+0xf8&gt;</span></p>
 
 <p><span>with a similar result:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjxHiYxvnOgAAPSyH0eTO017J4AvucPKtF8lOphykESTarVjDoU5kS6pJcRMwpuVtDDCSQejL4VSNlhZrc2vlhcZb16dX93zY7xE3isNqAew29ZwIe0YTqjttivvuPPWymt8kSATx3C9Ehd797EdM5pjo23gyxyNRwkllWjwo-IFFaX5Rng9Sb1KiyIA/s540/image14.png"><img alt="A histogram of interrupt instruction pointers, showing that almost all interrupts were delivered with RIP pointing to the instruction after the high-latency load." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjxHiYxvnOgAAPSyH0eTO017J4AvucPKtF8lOphykESTarVjDoU5kS6pJcRMwpuVtDDCSQejL4VSNlhZrc2vlhcZb16dX93zY7xE3isNqAew29ZwIe0YTqjttivvuPPWymt8kSATx3C9Ehd797EdM5pjo23gyxyNRwkllWjwo-IFFaX5Rng9Sb1KiyIA/s540/image14.png" title="A histogram of interrupt instruction pointers, showing that almost all interrupts were delivered with RIP pointing to the instruction after the high-latency load."/></a></span></p>
 <p><span>This means that </span><span>if</span><span> the first access to the file terminated our race window (which is not the case), we probably wouldn&#39;t be able to win the race by making the access to the file slow - instead we&#39;d have to slow down one of the operations before that. (But note that I have only tested simple loads, not stores or read-modify-write operations here.)</span></p>

</div></div>
  </body>
</html>
