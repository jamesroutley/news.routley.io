<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/">Original</a>
    <h1>TypeScript team released an explorer for performance tuning</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            May 12th, 2023</p><!-- .entry-meta -->
        
<p>Over the past few months, during the lead-up to the TypeScript 5.0 beta, our team spent a good portion of our time
looking for ways to improve the performance of our compiler so that your projects build faster. One of the ways we
improved was by looking into an oft overlooked aspect of many JavaScript VMs: <em>inline caching</em>.</p>

<p><a href="https://en.wikipedia.org/wiki/Inline_caching">Inline caching</a> is an optimization often used in both statically typed
and dynamically typed languages. An inline cache, or <strong>IC</strong>, is a set of instructions whose goal is to speed up
operations like method calls and property lookups. It does this by taking a slow operation, like walking an object’s
prototype chain and scanning through its named properties, and caches a fast path for subsequent lookups of that
property on the same object type. If you’re curious about the inner workings of ICs,
<em><a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">Explaining JavaScript VMs in JavaScript – Inline Caches</a></em> by <a href="https://mrale.ph">Vyacheslav Egorov</a> goes into far
more depth on ICs in JavaScript than I will here. Egorov, a Senior Staff Software Engineer at Google, currently works
on the Dart programming language and previously worked on the V8 JavaScript engine.</p>
<p>ICs significantly improve the performance of property lookups when the VM always sees a single type of object. However,
IC performance degrades as an operation becomes more <em>polymorphic</em>. As the VM encounters more types of objects for that
operation, it triggers deoptimizations, switching to less efficient IC implementations. Today in V8, an inline cache
essentially comes in three flavors:</p>
<ul>
<li><em>Monomorphic</em> — The VM only ever observed a single type of object.</li>
<li><em>Polymorphic</em> — The VM observed between two and four types of objects.</li>
<li><em>Megamorphic</em> — The VM observed more than four types of objects.</li>
</ul>
<p>Monomorphic ICs are the fastest, as they only need to compare the type identity of the current value to the one
previously recorded in the cache. Polymorphic ICs are somewhat slower, as they must match the type identity of the value
against a small number of potential targets. Megamorphic ICs are the slowest as the cache is moved to the heap, is a
fixed size, and its contents can be easily overwritten. These are fairly gross approximations of actual IC behavior, so
if you would like more detail on the subject I would encourage you to read <em><a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">What’s up with monomorphism?</a></em>, also by
Egorov.</p>

<p>Many operations in the TypeScript compiler are megamorphic by nature. We have hundreds of different syntax tree nodes
that represent the various syntactic productions in the TypeScript and JavaScript languages, and often need to branch
based on node kind. In general, we might expect that once we’re in a branch for a specific kind of node, the ICs that
the JavaScript VM creates should be monomorphic. However, that is not always the case.</p>
<p>Unfortunately, JavaScript polymorphism can be insidious. Two objects produced by the same constructor can still be
considered different “types” if those properties were initialized in a different order, or if some properties are only
initialized conditionally. Unfortunately, this was the case with many data structures in the TypeScript compiler. We
often had conditional assignments, such as assigning the <code>symbol</code> of a node only during binding, and assignments
occurring in varying orders based on which functions might be called first for a given node. This ends up leading to a
lot of unintentional polymorphism.</p>
<h2 id="example-property-order-polymorphism">Example: Property Order Polymorphism</h2>
<p>In the following example, the order in which properties are initially assigned in the object returned by <code>f()</code>
is different based on which branch of the <code>if</code> is evaluated. In <code>g()</code>, the <code>p.x</code> property access will become
polymorphic because it observes two different shapes: <code>{ x, y }</code> and <code>{ y, x }</code>:</p>
<pre><code>function f(x, y) {
  if (x &lt;= y) {
    return { x, y };
  }
  else {
    return { y, x };
  }
}

function g(p) {
  const x = p.x; // polymorphic
}

g(f(0, 1));
g(f(1, 0));
</code></pre>
<h2 id="example-conditional-property-polymorphism">Example: Conditional Property Polymorphism</h2>
<p>In this example, the property <code>p.y</code> is only defined conditionally in <code>f()</code>. As a result, the <code>p.x</code> property access in
<code>g()</code> will become polymorphic because it observes two different shapes: <code>{ x }</code> and <code>{ x, y }</code>.</p>
<pre><code>function f(x, y) {
  const p = {};
  p.x = x;
  if (y !== undefined) {
    p.y = y;
  }
  return p;
}

function g(p) {
  const x = p.x; // polymorphic
}

g(f(1));
g(f(1, 0));
</code></pre>

<p>It can be fairly difficult to recognize megamorphism in a large JavaScript code base, and even more difficult to
determine whether that megamorphism is negatively impacting performance. Overoptimizing infrequently used code paths
wastes time and resources, so we needed tooling to help us analyze poorly performing code to find actual, tangible
improvements that we could make. We built benchmarking tools to monitor compiler performance over time. We used CPU
profiling and heap snapshots to investigate performance regressions. But these tools often didn’t give us the details
we needed for fine tuning. So, for the past few years we’ve been working on a tool called <em>Deopt Explorer</em> that we’ve
used internally to help us explore the various deoptimizations, ICs, and object types that V8 produces when the compiler
is executing.</p>

<p><img decoding="async" title="Overview" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-overview.png" alt="VS Code open with the Deopt Explorer extension visible in the activity bar"/></p>
<p><a href="https://github.com/microsoft/deoptexplorer-vscode">Deopt Explorer</a> is a VS Code extension that can analyze trace logs
produced by V8. It was heavily influenced by tools like Vyacheslav Egorov’s <a href="https://mrale.ph/irhydra/2/">IR Hydra</a>, and
Thorsten Lorenz’s <a href="https://github.com/thlorenz/deoptigate">Deoptigate</a>, and provides a detailed look at deoptimizations
and ICs right from within the editor.</p>
<p>To explain how Deopt Explorer works, I will walk through how we <a href="https://github.com/microsoft/TypeScript/pull/51880">used it recently</a>
to improve compiler performance by making property accesses against TypeScript’s internal <code>Symbol</code> type monomorpic.</p>
<h2 id="generating-a-log">Generating a Log</h2>
<p>To get started, we need to produce a V8 trace log that we can analyze. There are a number of V8-specific options that
control trace log output that are exposed by NodeJS. These options are known to change from release to release, so we
published a commandline utility called <a href="https://npmjs.com/package/dexnode"><code>dexnode</code></a> to make it easier to provide the
correct logging options based on the version of V8 embedded in the running version of NodeJS. <code>dexnode</code> can be invoked
from the commandline in place of the normal <code>node</code> executable, and we can use that to invoke the TypeScript compiler
against one of our test cases:</p>
<pre><code>npx dexnode --out v8.log .\built\local\tsc.js -p .\path\to\project
</code></pre>
<p>Which is the equivalent of the following:</p>
<pre><code>node --log-deopt --redirect-code-traces --redirect-code-traces-to=\\.\NUL
  --log-ic --log-maps --log-maps-details --log-code --log-source-code --prof
  --log-internal-timer-events --detailed-line-info --logfile=v8.log
  --no-logfile-per-isolate .\built\local\tsc.js -p .\path\to\project
</code></pre>
<p>This generates a file called <code>v8.log</code> that we can feed into Deopt Explorer.</p>
<h2 id="investigating-ics">Investigating ICs</h2>
<p>After the log has been processed, we can expand the <code>ICS</code> tree view to get an idea of how polymorphic the code is in
<em>binder.ts</em>:</p>
<p><img decoding="async" title="Megamorphic ICs in binder.ts" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-megamorphic-ics-in-binder.png" alt="Close up of the ICs tree view. The &#34;Megamorphic&#34; node is expanded, showing a list of files. In that list, the &#34;binder.ts&#34; node is expanded, showing a list of functions, which in turn contain a list of individual ICs"/></p>
<p>Given that there are quite a few megamorphic ICs, we’ll start by clicking on <code>addDeclarationToSymbol</code> to jump to that
function. This function is called by TypeScript’s binder for every variable, function, class, method, parameter,
property, etc., so it is invoked quite frequently. With the file open in the editor, Deopt Explorer will highlight ICs
and other deoptimizations using editor decorations, allowing us to easily pick out those that are megamorphic:</p>
<p><img decoding="async" title="&#39;addDeclarationToSymbol&#39; decorations" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-addDeclarationToSymbol-decorations.png" alt="Close up of an editor pane open to the &#34;addDeclarationToSymbol&#34; function. Several sections of code have additional highlights"/></p>
<p>Here, megamorphic ICs are highlighted in red, while polymorphic ICs are highlighted in yellow. Immediately we can see
there are megamorphic ICs for <code>symbol.flags</code>, <code>node.symbol</code>, <code>symbol.declarations</code>, and <code>symbol.constEnumOnlyModule</code>,
meaning that each IC has observed multiple different maps for our <code>Symbol</code> and <code>Node</code> objects. Hovering over
<code>symbol.flags</code> gives us more context:</p>
<p><img decoding="async" title="Megamorphic read and write to &#39;symbol.flags&#39;" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol.flags-megamorphic-read-and-write.png" alt="Close up of a Hover tooltip with the message &#34;Megamorphic read from property &#39;flags&#39;, followed by a table containing the old and new IC state, address of each map, and the names of the functions that produced each map"/></p>
<p>We can see that there were two different ICs associated with this statement, given that it is a compound assignment.
For a given IC, each line in the hover represents an IC event, and includes the current state of the IC (i.e., monomorphic,
polymorphic, megamorphic), the “map” associated with the event, and the source location where that “map” was defined. In
V8, a “map” (not to be confused with the JavaScript built-in <code>Map</code>) represents the type of an object, including its
properties, prototype, the constructor that produced it, and other related metadata.</p>
<p>TypeScript only has one kind of <code>Symbol</code>, so lets look at the V8 maps associated with the <code>Symbol</code> constructor to find
out where things went wrong.</p>
<h2 id="exploring-v8-maps">Exploring V8 Maps</h2>
<p>Expanding the <code>MAPS</code> tree view in Deopt Explorer shows the maps produced by V8, grouped by the constructor that produced
them:</p>
<p><img decoding="async" title="V8 maps for &#39;Symbol&#39;" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol-maps.png" alt="Close up of the &#39;Maps&#39; tree view, consisting of a list of constructor names, with the &#34;Symbol&#34; constructor expanded to show a long list of map addresses"/></p>
<p>Expanding the constructor shows a list of each related map’s addresses, as well as a hint to the name of the function
that introduced the property that produced the map.</p>
<p>V8 produces more than 30 different maps for <code>Symbol</code>, although Deopt Explorer will filter out a number of
inconsequential maps by default. The ones we see here are directly referenced by ICs, and, as we can see from the list,
come from far more places than the <code>Symbol</code> constructor itself. Clicking on the third map down (<code>0x03ef521c8c49_1</code>),
opens an editor showing the structure of the map:</p>
<p><img decoding="async" title="V8 maps for &#39;Symbol&#39;" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol-map-1.png" alt="Close up of an editor pane showing a conceptual syntax for a map"/></p>
<p>This view shows a number of useful pieces of information:</p>
<ul>
<li>The address of the map (<code>0x03ef521c8c49</code>).</li>
<li>A counter (<code>_1</code>) that is used to differentiate between two or more maps that existed at that address at
different points in time, such as when a map is garbage collected and that memory is reused for a different map
at a later time.</li>
<li>The constructor that produced the map (<code>Symbol</code>).</li>
<li>An optional base map, from which this map was produced when a new property was added (or some other change occurred).</li>
<li>A list of properties and their associated runtime types, such as <code>smi</code> which is a V8 “small integer”, or <code>heap</code> which
indicates a heap reference. This may also point to another V8 map.</li>
</ul>
<p>The data structure is followed by a commented section containing a timeline showing how the map has evolved, as well as
a section containing extra metadata provided by V8.</p>
<p>From within this view, you can <kbd>Ctrl</kbd>– or <kbd>Cmd</kbd>-click on various links to jump to related source code locations, use “Go to
Definition” to jump to another map, or “Find all references” on map identifiers to see their associated ICs.</p>
<p>We can also see that <em>checker.ts</em> added a new property called <code>checkFlags</code> that wasn’t initialized in the constructor.
This means that symbols produced by the checker, which we call <em>transient symbols</em>, will have a different V8 map than
those produced by the binder. But that isn’t the only case.</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol-map-2.png" alt="V8 map for a produced by #1"/></p>
<p><img decoding="async" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol-map-3.png" alt="V8 map for a produced by #2"/></p>
<p>Clicking on the first two <code>addDeclarationToSymbol</code> maps in the tree view shows us two different maps produced by the
same function: one that adds an <code>exports</code> property and one that adds a <code>members</code> property. This indicates that there
multiple conditional property assignments, which in turn leads to more maps.</p>
<h2 id="reducing-megamorphism">Reducing Megamorphism</h2>
<p>To make property accesses on <code>Symbol</code> monomorphic, we need to avoid these conditional assignments. This means ensuring
that the V8 map for an object is stable, and all properties are initialized to <em>something</em>. For properties we intend to
fill in later, this meant using <em>undefined</em>.</p>
<pre><code>function Symbol(/*...*/) {
    // ...
    // Unconditionally assign to &#39;exports&#39; and &#39;members&#39;:
    this.exports = undefined;
    this.members = undefined;
}
</code></pre>
<p>However, there is a trade off when you do this. The more properties you
assign to an object, the more space those objects take up in memory.</p>
<p>For <code>Symbol</code>, reducing megamorphism wasn’t as simple as pre-initializing these optional properties because we create so
many symbols during compilation. In addition, symbols produced by our checker not only included all of the properties of <code>Symbol</code>, but all
of the properties of <code>SymbolLinks</code>, an internal interface we use to cache checker-specific information for symbols. We
did this initially for performance reasons. Symbols from the binder are reused during incremental parsing, so
checker-specific information is stored in a lookaside table. Since symbols produced by the checker aren’t reused, we
opted to store checker-specific information on the symbol itself to avoid the cost of an additional indirection. We
obviously don’t want to pre-initialize all of the <code>SymbolLinks</code> properties on <code>Symbol</code>, since that would cause our
memory consumption to skyrocket. Instead, we chose to add a single <code>links</code> property to <code>Symbol</code> in which we would
store the <code>SymbolLinks</code> object for transient symbols. This still requires indirection, but is far cheaper than reading
from a lookaside table because we can leverage a monomorphic IC when accessing the property.</p>
<h2 id="outcomes">Outcomes</h2>
<p>After making these changes in <a href="https://github.com/microsoft/TypeScript/pull/51880">microsoft/Typescript#51880</a>, we
dramatically reduced the number of maps V8 produced for <code>Symbol</code> from thirty down to two:</p>
<p><img decoding="async" title="V8 map reduction for &#39;Symbol&#39;" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/deopt-explorer-symbol-maps-after.png" alt="Close up of the &#34;Maps&#34; tree view showing a list of constructor names. The &#34;Symbol&#34; constructor has been expanded, showing only two entries."/></p>
<p>Even though this view shows two maps, only the second one matters as the first map is the empty object produced before
any properties are assigned. All property access against <code>Symbol</code> instances in the compiler are now monomorphic, and
between <a href="https://github.com/microsoft/TypeScript/pull/51880">this change</a> (3-5%) and improvements to monomorphism for
<a href="https://github.com/microsoft/TypeScript/pull/51682">some of our <code>Node</code> subtypes</a> (4-5%), we’ve reduced the average
compile time in our benchmarks by between 8-10%! And we’re not done yet as there are still many more opportunities to
reduce megamorphism that we’re still working on.</p>

<p><a href="https://marketplace.visualstudio.com/items?itemName=rbuckton.deoptexplorer-vscode">Deopt Explorer is available now</a> in
the VS Code extension marketplace. Deopt Explorer is also <a href="https://github.com/microsoft/deoptexplorer-vscode">open source on GitHub</a>,
which is the best place to provide feedback and file issues, and PRs are welcome!</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
