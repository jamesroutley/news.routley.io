<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2025/06/17/unexpected-security-footguns-in-gos-parsers/">Original</a>
    <h1>Unexpected security footguns in Go&#39;s parsers</h1>
    
    <div id="readability-page-1" class="page"><div><p>In Go applications, parsing untrusted data creates a dangerous attack surface that‚Äôs routinely exploited in the wild. During our security assessments, we‚Äôve repeatedly exploited unexpected behaviors in Go‚Äôs JSON, XML, and YAML parsers to bypass authentication, circumvent authorization controls, and exfiltrate sensitive data from production systems.</p><p>These aren‚Äôt theoretical issues‚Äîthey‚Äôve led to documented vulnerabilities like <a href="https://nvd.nist.gov/vuln/detail/cve-2020-16250">CVE-2020-16250</a> (a Hashicorp Vault authentication bypass found by Google‚Äôs Project Zero) and numerous high-impact findings in our client engagements.</p><p>This post contextualizes these unexpected parser behaviors through three attack scenarios that every security engineer and Go developer should understand:</p><ol><li><strong>(Un)Marshaling unexpected data</strong>: How Go parsers can expose data that developers intended to be private</li><li><strong>Parser differentials</strong>: How discrepancies between parsers enable attackers to bypass security controls when multiple services parse the same input</li><li><strong>Data format confusion</strong>: How parsers process cross-format payloads with surprising and exploitable results</li></ol><p>We‚Äôll demonstrate each attack scenario with real-world examples and conclude with concrete recommendations for configuring these parsers more securely, including strategies to compensate for security gaps in Go‚Äôs standard library.</p><p>Below is a summary of the surprising behaviors we‚Äôll examine, with indicators showing their security status:</p><ul><li>üü¢ <strong>Green</strong>: Secure by default</li><li>üü† <strong>Orange</strong>: Insecure by default but configurable</li><li>üî¥ <strong>Red</strong>: Insecure by default with no secure configuration options</li></ul><div><table><thead><tr><th></th><th>JSON</th><th>JSON v2</th><th>XML</th><th>YAML</th></tr></thead><tbody><tr><td>json:&#34;-,‚Ä¶&#34;</td><td>YES (bad design)</td><td>YES (bad design)</td><td>YES (bad design)</td><td>YES (bad design)</td></tr><tr><td>json:‚Äúomitempty‚Äù</td><td>YES (expected)</td><td>YES (expected)</td><td>YES (expected)</td><td>YES (expected)</td></tr><tr><td>Duplicate keys</td><td>YES (last)</td><td>NO</td><td>YES (last)</td><td>NO</td></tr><tr><td>Case insensitivity</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>Unknown keys</td><td>YES (mitigable)</td><td>YES (mitigable)</td><td>YES</td><td>YES (mitigable)</td></tr><tr><td>Garbage leading data</td><td>NO</td><td>NO</td><td>YES</td><td>NO</td></tr><tr><td>Garbage trailing data</td><td>YES (with Decoder)</td><td>NO</td><td>YES</td><td>NO</td></tr></tbody></table></div><h2 id="parsing-in-go">Parsing in Go</h2><p>Let‚Äôs examine how Go parses JSON, XML, and YAML. Go‚Äôs standard library provides JSON and XML parsers but not a YAML parser, for which there are several third-party alternatives. For our analysis, we‚Äôll focus on:</p><ul><li><a href="https://pkg.go.dev/encoding/json">encoding/json</a> version go1.24.1</li><li><a href="https://pkg.go.dev/encoding/xml">encoding/xml</a> version go1.24.1</li><li><a href="https://pkg.go.dev/gopkg.in/yaml.v3">yaml.v3</a> version 3.0.1 (the most popular third-party Go YAML library)</li></ul><p>We‚Äôll use JSON in our following examples, but all three parsers have APIs equivalent to the ones we‚Äôll see.</p><p>At their core, these parsers provide two primary functions:</p><ul><li><code>Marshal</code> (serialize): Converts Go structs into their respective format strings</li><li><code>Unmarshal</code> (deserialize): Converts format strings back into Go structs</li></ul><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/json_parsing.png" alt="Parsing JSON in Go"/></p><p>Go uses struct field tags to allow customization of how parsers should handle individual fields. These tags consist of:</p><ul><li>A <strong>key name</strong> for serialization/deserialization</li><li>Optional <strong>comma-separated directives</strong> that modify behavior (e.g., the <code>omitempty</code> tag option tells the JSON serializer not to include the field in the JSON output string if it is empty)</li></ul><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span> <span>`json:&#34;username_json_key,omitempty&#34;`</span>
</span></span><span><span>    <span>Password</span> <span>string</span> <span>`json:&#34;password&#34;`</span>
</span></span><span><span>    <span>IsAdmin</span>  <span>bool</span>   <span>`json:&#34;is_admin&#34;`</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>To unmarshal a JSON string into the <code>User</code> structure shown above, we must use the <code>username_json_key</code> key for the <code>Username</code> field, <code>password</code> for the <code>Password</code> field, and <code>is_admin</code> for the <code>IsAdmin</code> field.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>u</span> <span>:=</span> <span>User</span><span>{}</span>
</span></span><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{
</span></span></span><span><span><span>    &#34;username_json_key&#34;: &#34;jofra&#34;,
</span></span></span><span><span><span>    &#34;password&#34;: &#34;qwerty123!&#34;,
</span></span></span><span><span><span>    &#34;is_admin&#34;: &#34;false&#34;
</span></span></span><span><span><span>}`</span><span>),</span> <span>&amp;</span><span>u</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Result: %#v\n&#34;</span><span>,</span> <span>u</span><span>)</span>
</span></span><span><span><span>// Result: User{Username:&#34;jofra&#34;, Password:&#34;qwerty123!&#34;, IsAdmin:false}</span></span></span></code></pre></figure><p>These parsers also offer stream-based alternatives that operate on <code>io.Reader</code> interfaces rather than <code>byte</code> slices. This API is ideal for parsing streaming data such as HTTP request bodies, making it a preferred choice in HTTP request handling.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/json_parsing_2.png" alt="Parsing JSON in Go with NewDecoder"/></p><hr/><h2 id="attack-scenario-1-unmarshaling-unexpected-data">Attack scenario 1: (Un)Marshaling unexpected data</h2><p>Sometimes, you need to limit which fields of a structure can be marshaled or unmarshaled.</p><p>Let‚Äôs consider a simple example in which a back-end server has an HTTP handler for creating users and another for retrieving that user after authentication.</p><p>When creating a user, you may not want the user to be able to set the <code>IsAdmin</code> field (i.e., unmarshal that field from the user input).</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/create_user.png" alt="Shows an interaction with a backend server in which the user can set the IsAdmin field of the User struct, which should not be possible"/></p><p>Similarly, when fetching the user, you may not want the user to return the user‚Äôs <code>Password</code> or other secret values.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/get_user.png" alt="Shows an interaction with a backend server in which the user can get the Password field of the User struct, which should not be possible"/></p><p>How can we instruct the parsers not to marshal or unmarshal a field?</p><h3 id="fields-without-a-tag">Fields without a tag</h3><p>Let‚Äôs first see what happens if you don‚Äôt set a JSON tag.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>In this case, you can unmarshal the <code>Username</code> field with its name, as shown below.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{&#34;Username&#34;: &#34;jofra&#34;}`</span><span>),</span> <span>&amp;</span><span>u</span><span>)</span>
</span></span><span><span><span>// Result: User{Username:&#34;jofra&#34;}</span></span></span></code></pre></figure><p>This is well documented, and most Go devs are aware of it. Let‚Äôs look at another example:</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span> <span>`json:&#34;username,omitempty&#34;`</span>
</span></span><span><span>    <span>Password</span> <span>string</span> <span>`json:&#34;password,omitempty&#34;`</span>
</span></span><span><span>    <span>IsAdmin</span>  <span>bool</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>Is it evident that the <code>IsAdmin</code> field above would be unmarshaled? A less senior or distracted developer could assume it would not and introduce a security vulnerability.</p><p>If you‚Äôd like to scan your codebase for this pattern, where some but not all fields have a JSON, XML, or YAML tag, you can use the following Semgrep rule. This rule is not on the our <a href="https://semgrep.dev/p/trailofbits">collection of rules exposed on the Semgrep registry</a> because, depending on the codebase, it is likely to produce many false positives.</p><figure><pre tabindex="0"><code data-lang="yaml"><span><span><span>rules</span><span>:</span><span>
</span></span></span><span><span><span>    </span>- <span>id</span><span>:</span><span> </span><span>unmarshaling-tag-in-only-some-fields</span><span>
</span></span></span><span><span><span>      </span><span>message</span><span>:</span><span> </span><span>&gt;-</span><span>
</span></span></span><span><span><span>          Type $T1 has fields with json/yml/xml tags on some but not other fields. This field can still be (un)marshaled using its name. To prevent a field from being (un)marshaled, use the - tag.</span><span>
</span></span></span><span><span><span>      </span><span>languages</span><span>:</span><span> </span><span>[</span><span>go]</span><span>
</span></span></span><span><span><span>      </span><span>severity</span><span>:</span><span> </span><span>WARNING</span><span>
</span></span></span><span><span><span>      </span><span>patterns</span><span>:</span><span>
</span></span></span><span><span><span>          </span>- <span>pattern-inside</span><span>:</span><span> </span><span>|</span><span>
</span></span></span><span><span><span>                type $T1 struct {
</span></span></span><span><span><span>                  ...
</span></span></span><span><span><span>                  $_ $_ `$TAG`
</span></span></span><span><span><span>                  ...
</span></span></span><span><span><span>                }</span><span>
</span></span></span><span><span><span>          </span><span># This regex attempts to remove some false positives such as structs declared inside structs</span><span>
</span></span></span><span><span><span>          </span>- <span>pattern-regex</span><span>:</span><span> </span><span>&gt;-</span><span>
</span></span></span><span><span><span>                ^[ \t]+[A-Z]+[a-zA-Z0-9]*[ \t]+[a-zA-Z0-9]+[^{`\n\r]*$</span><span>
</span></span></span><span><span><span>          </span>- <span>metavariable-regex</span><span>:</span><span>
</span></span></span><span><span><span>                </span><span>metavariable</span><span>:</span><span> </span><span>$TAG</span><span>
</span></span></span><span><span><span>                </span><span>regex</span><span>:</span><span> </span><span>&gt;-</span><span>
</span></span></span><span><span><span>                    .*(json|yaml|xml):&#34;[^,-]</span></span></span></code></pre></figure><h3 id="misusing-the---tag">Misusing the <code>-</code> tag</h3><p>To tell the parser not to (un)marshal a specific field, we must add the special <code>-</code> JSON tag!</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span> <span>`json:&#34;username,omitempty&#34;`</span>
</span></span><span><span>    <span>Password</span> <span>string</span> <span>`json:&#34;password,omitempty&#34;`</span>
</span></span><span><span>    <span>IsAdmin</span>  <span>bool</span>   <span>`json:&#34;-,omitempty&#34;`</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>Let‚Äôs try it!</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{&#34;-&#34;: true}`</span><span>),</span> <span>&amp;</span><span>u</span><span>)</span>
</span></span><span><span><span>// Result: main.User{Username:&#34;&#34;, Password:&#34;&#34;, IsAdmin:true}</span></span></span></code></pre></figure><p>Oh, whoops, we were still able to set the <code>IsAdmin</code> field. We copy-pasted the <code>,omitempty</code> part by mistake, which caused the parser to look for the <code>-</code> key in the provided JSON input. I searched for this pattern on the top 1,000 Go repositories by stars on GitHub and, among a few others, I found and reported these two results, which are now fixed:</p><ul><li><a href="https://github.com/flipt-io/flipt/blob/f2e1b1ce08a0627c44947c20b8dcbcda8f36437a/internal/config/authentication.go#L482-L483">Flipt exposes the <code>ClientID</code> field on an OIDC configuration as the <code>-</code> field</a> (fixed in <a href="https://github.com/flipt-io/flipt/pull/3658/files">#3658</a>)</li><li><a href="https://github.com/tmc/langchaingo/issues/1162">langchaingo exposes the <code>MaxTokens</code> field as the <code>-</code> field</a> (fixed in <a href="https://github.com/tmc/langchaingo/pull/1163">#1163</a>)</li></ul><p>While this behavior is error prone with minimal benefits (having the ability to name a field <code>-</code>), it is <a href="https://pkg.go.dev/encoding/json#Marshal">documented in the JSON package documentation</a>:</p><blockquote><p>As a special case, if the field tag is ‚Äú-‚Äù, the field is always omitted. Note that a field with name ‚Äú-‚Äù can still be generated using the tag ‚Äú-,‚Äù.</p></blockquote><p>The XML and YAML parsers operate similarly, with one key difference: the XML parser treats the <code>&lt;-&gt;</code> tag as invalid. To resolve this, we must prefix the <code>-</code> symbol with an XML namespace, such as <code>&lt;A:-&gt;</code>.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/tag_with_dash.png" alt="Image showing how to unmarshal a field with a tag of ‚Äú-,‚Ä¶‚Äù in JSON, XML, and YAML"/></p><p>Ok, ok, let‚Äôs do it right this time.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span>  <span>`json:&#34;username,omitempty&#34;`</span>
</span></span><span><span>    <span>Password</span> <span>string</span>  <span>`json:&#34;password,omitempty&#34;`</span>
</span></span><span><span>    <span>IsAdmin</span>  <span>bool</span>    <span>`json:&#34;-&#34;`</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>Finally! Now, there is no way for the <code>IsAdmin</code> field to be unmarshaled.</p><p>But I hear you ask: How can these misconfigurations lead to security vulnerabilities? The most common way is, like in our example, using <code>-,...</code> as the JSON tag for a field such as <code>IsAdmin</code>‚Äìa field the user should not control. This is a hard bug to detect with unit tests because unless you have an explicit test that unmarshals an input with the <code>-</code> key and detects if any field was written to, you won‚Äôt detect it. You need your IDE or an external tool to detect it.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/create_user_2.png" alt="Shows an interaction with a backend server in which the user can set the IsAdmin field with the - JSON field name"/></p><p>We created a <a href="https://semgrep.dev/playground/r/trailofbits.go.unmarshal-tag-is-dash?editorMode=advanced">public Semgrep rule</a> to help you find similar issues in your codebases. Try it with <code>semgrep -c r/trailofbits.go.unmarshal-tag-is-dash</code>!</p><h3 id="misusing-omitempty">Misusing omitempty</h3><p>Another very simple misconfiguration we‚Äôve found before was a developer mistakenly setting the field name to <code>omitempty</code>.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>User</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Username</span> <span>string</span> <span>`json:&#34;omitempty&#34;`</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>u</span> <span>:=</span> <span>User</span><span>{}</span>
</span></span><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{&#34;omitempty&#34;: &#34;a_user&#34;}`</span><span>),</span> <span>&amp;</span><span>u</span><span>)</span>
</span></span><span><span><span>// Result: User{Username:&#34;a_user&#34;}</span></span></span></code></pre></figure><p>If you set the JSON tag to <code>omitempty</code>, the parser will use <code>omitempty</code> as the field‚Äôs name (as expected). Of course, some developers have tried to use this to set the <code>omitempty</code> option in the field while keeping the default name. I searched the top 1,000 Go repositories for this pattern and found these results:</p><ul><li><a href="https://github.com/go-gitea/gitea/blob/cd225d7034f905f73319b5a9024f6f9d5b6a01c7/models/admin/task.go#L47">Gitea exposes the <code>Args</code> field of the <code>TranslatableMessage</code> structure with the omitempty key</a> (fixed in <a href="https://github.com/go-gitea/gitea/pull/33663">#33663</a>)</li><li><a href="https://github.com/kubernetes-sigs/kustomize/blob/bb7a28070905adae77c6f82b912a862de2b3a052/plugin/builtin/replacementtransformer/ReplacementTransformer.go#L20">Kustomize exposes the <code>Replacements</code> field of the <code>plugin</code> structure with the omitempty key</a> (fixed in <a href="https://github.com/kubernetes-sigs/kustomize/pull/5877">#5877</a>)</li><li><a href="https://github.com/btcsuite/btcd/blob/e9d95eed43d2c7e8afb2c3b7d1165dffe713e132/btcjson/chainsvrcmds.go#L1052-L1059">Btcd exposes the <code>MaxFeeRate</code> field of the <code>TestMempoolAcceptCmd</code> structure with the omitempty key</a></li><li><a href="https://github.com/evcc-io/evcc/blob/da4a79730d7b30a5700f2404bf802caee9dca4ea/charger/nrg/connect/types.go#L9-L17">Evcc exposes the <code>Message</code> field of the <code>Measurements</code> structure with the omitempty key</a></li></ul><p>In these cases, the developer often wanted to set the tag to <code>json:&#34;,omitempty&#34;</code>, which would keep the default name, and add the <code>omitempty</code> tag option.</p><p>Contrary to the previous example, this one is unlikely to have a security impact and should be easy to detect with tests because any attempt to serialize or deserialize input with the expected field name will fail. However, as we can see, it still shows up even in popular open-source repositories. We created a <a href="https://semgrep.dev/playground/r/trailofbits.go.unmarshal-tag-is-omitempty?editorMode=advanced">public Semgrep rule</a> to help you find similar issues in your codebases. Try it with <code>semgrep -c r/trailofbits.go.unmarshal-tag-is-omitempty</code>!</p><hr/><h2 id="attack-scenario-2-parser-differentials">Attack scenario 2: Parser differentials</h2><p>What can happen if you parse the same input with different JSON parsers and they disagree on the result? More specifically, which behaviors in Go parsers allow attackers to trigger these discrepancies ‚Äúreliably‚Äù?</p><p>As an example, let‚Äôs use the following application using a microservice architecture with:</p><ul><li>A <strong>Proxy Service</strong> that receives all user requests</li><li>An <strong>Authorization Service</strong> called by the Proxy Service to determine if the user has sufficient permission to complete their request</li><li>Multiple <strong>business logic services</strong> called by the Proxy Service to perform the business logic</li></ul><p>In this first flow, a regular, non-admin user attempts to perform a <code>UserAction</code>, an action they are <strong>allowed</strong> to perform.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_success.png" alt="Image showing the system described above with a flow in which the user successfully authenticates"/></p><p>In this second flow, the same regular user attempts to perform an <code>AdminAction</code>, an action they are <strong>forbidden</strong> to perform.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_fail.png" alt="Image showing the system described above with a flow in which the user fails to authenticate"/></p><p>Finally, the following flow is because the services disagree on the action the user is trying to perform.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_attack.png" alt="Image showing the system described above with a vulnerable flow in which Proxy and Authorization services disagree when parsing an action from the user input."/></p><p>The Authorization Service, written in a different programming language or using a non-default Go parser, will parse <code>UserAction</code> and grant the user permission to perform the operation, while the Proxy Service, using Go‚Äôs default parser, will parse <code>AdminAction</code> and proxy it to the incorrect service. The remaining question is: Which payloads can we use to achieve this behavior?</p><p>This is a common architecture we‚Äôve seen multiple times during our audits, and against which we‚Äôve found authentication bypasses because of the problems we‚Äôll describe below. Other examples exist, but most follow the same pattern: the component that does security checks and the component that performs the actions differ in their view of the input data. Here are some of those examples in a variety of scenarios:</p><ul><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-12635">CVE-2017-12635: Authorization bypass in Apache CouchDB caused by JSON parser differentials</a> (very similar to our example above)</li><li><a href="https://blog.siguza.net/psychicpaper/">MacOS sandbox escape caused by XML parser differentials (2020)</a></li><li><a href="https://i.blackhat.com/USA-22/Thursday/US-22-Fratric-XMPP-Stanza-Smuggling.pdf">0-click Zoom RCE caused by XML parser differentials in XMPP (2022)</a></li><li><a href="https://github.blog/security/sign-in-as-anyone-bypassing-saml-sso-authentication-with-parser-differentials/">GitLab SAML auth bypass caused by XML parser differentials (2025)</a></li></ul><h3 id="duplicate-fields">Duplicate fields</h3><p>The first differential attack vector we‚Äôll explore is duplicate keys. What happens when your JSON input has the same key twice? It depends on the parser!</p><p>In Go, the JSON parser will always <strong>take the last one</strong>. There is no way to prevent this behavior.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{
</span></span></span><span><span><span>    &#34;action&#34;: &#34;Action1&#34;,
</span></span></span><span><span><span>    &#34;action&#34;: &#34;Action2&#34;
</span></span></span><span><span><span>}`</span><span>),</span> <span>&amp;</span><span>a</span><span>)</span>
</span></span><span><span><span>// Result: ActionRequest{Action:&#34;Action2&#34;}</span></span></span></code></pre></figure><p>This is the default behavior of most parsers. However, as shown in the <a href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">JSON interoperability vulnerabilities</a> blog post from Bishop Fox, seven out of the 49 parsers tested take the first key:</p><ul><li>Go: jsonparser and gojay</li><li>C++: rapidjson</li><li>Java: json-iterator</li><li>Elixir: Jason and Poison</li><li>Erlang: jsone</li></ul><p>None of these are the most common JSON parsers in their corresponding languages, even though some are common alternatives.</p><p>So, if our Proxy Service uses the Go JSON parser and the Authorization Service uses one of these parsers, we get our discrepancy, as shown in the figure below.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_duplicate_fields.png" alt="Image showing the attack scenario with the exploit described above"/></p><p>The XML parser has the same behavior, while the YAML parser returns an error on duplicate fields‚Äîthe secure default we think all of these parsers should implement.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_duplicate_fields_summary.png" alt="Image summarizing the behavior for all three parsers"/></p><p>While not ideal, at least this behavior is consistent with the most commonly used JSON and XML parsers. Let‚Äôs now take a look at a much worse behavior that will almost always get you a discrepancy between Go‚Äôs default parser and any other parser.</p><h3 id="case-insensitive-key-matching">Case insensitive key matching</h3><p>Go‚Äôs JSON parser parses field names case-insensitively. Whether you write action <code>action</code>, <code>ACTION</code>, or <code>aCtIoN</code>, the parser treats them as identical!</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{
</span></span></span><span><span><span>    &#34;aCtIoN&#34;: &#34;Action2&#34;
</span></span></span><span><span><span>}`</span><span>),</span> <span>&amp;</span><span>a</span><span>)</span>
</span></span><span><span><span>// Result: ActionRequest{Action:&#34;Action2&#34;}</span></span></span></code></pre></figure><p>This is <a href="https://pkg.go.dev/encoding/json#Unmarshal">documented</a> but is very unintuitive, there‚Äôs no way to disable it, and almost no other parser has this behavior.</p><p>To make this worse, as we saw above, you can have duplicate fields, and the latter one is still chosen, eVeN wHeN tHe cAsInG dOeS nOt mAtCh.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`{
</span></span></span><span><span><span>    &#34;action&#34;: &#34;Action1&#34;,
</span></span></span><span><span><span>    &#34;aCtIoN&#34;: &#34;Action2&#34;
</span></span></span><span><span><span>}`</span><span>),</span> <span>&amp;</span><span>a</span><span>)</span>
</span></span><span><span><span>// Result: ActionRequest{Action:&#34;Action2&#34;}</span></span></span></code></pre></figure><p>This is against the documentation, which says:</p><blockquote><p>‚ÄúTo unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), <strong>preferring an exact match but also accepting a case-insensitive match</strong>.‚Äù</p></blockquote><p>You can even use Unicode characters! In the example below, we‚Äôre using <code>≈ø</code> (the unicode character named Latin small letter long s) as an <code>s</code>, and <code>‚Ñ™</code> (the unicode character for the Kelvin sign) as a <code>k</code>. From our testing of the <a href="https://cs.opensource.google/go/go/+/master:src/encoding/json/fold.go">JSON library code</a> that does the comparison, only these two unicode characters match ASCII characters.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>ActionRequest</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Action</span> <span>string</span> <span>`json:&#34;aktions&#34;`</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>a</span> <span>:=</span> <span>ActionRequest</span><span>{}</span>
</span></span><span><span><span>_</span> <span>=</span> <span>json</span><span>.</span><span>Unmarshal</span><span>([]</span><span>byte</span><span>(</span><span>`
</span></span></span><span><span><span>{
</span></span></span><span><span><span>    &#34;aktions&#34;: &#34;Action1&#34;,
</span></span></span><span><span><span>    &#34;a‚Ñ™tion≈ø&#34;: &#34;Action2&#34;
</span></span></span><span><span><span>}
</span></span></span><span><span><span>`</span><span>),</span> <span>&amp;</span><span>a</span><span>)</span>
</span></span><span><span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Result: %#v\n&#34;</span><span>,</span> <span>a</span><span>)</span>
</span></span><span><span><span>// Result: main.ActionRequest{Action:&#34;Action2&#34;}</span></span></span></code></pre></figure><p>Applying it to our running attack scenario, this is how the attack would look like:</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_case_insensitivity_1.png" alt="Image showing the attack scenario with the exploit described above"/></p><p>In our opinion, this is the most critical pitfall of Go‚Äôs JSON parser because it differs from the default parsers for JavaScript, Python, Rust, Ruby, Java, and all other parsers we tested. This has led to many high-impact security vulnerabilities, including ones we‚Äôve found during our audits.</p><p>As a final blow, there‚Äôs no way to disable this behavior, even though people have complained about this <a href="https://github.com/golang/go/issues/14750">behavior leading to security vulnerabilities</a> since at least 2016.</p><p>This only affects the JSON parser. The XML and YAML parsers use exact matches.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/parser_diff_case_insensitivity_summary.png" alt="Image summarizing the behavior for all three parsers"/></p><p>If you are interested in other kinds of JSON parsing differentials between many parsers, we recommend these two blog posts:</p><ul><li><a href="https://seriot.ch/projects/parsing_json.html">Parsing JSON is a Minefield</a> by Nicolas Seriot</li><li><a href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">JSON Interoperability Vulnerabilities</a> by Bishop Fox</li></ul><hr/><h2 id="attack-scenario-3-data-format-confusion">Attack scenario 3: Data format confusion</h2><p>For the final attack scenario, let‚Äôs see what happens if you parse a JSON file with the XML parser or use any other format with the incorrect parser.</p><p>As an example, let‚Äôs use <a href="https://nvd.nist.gov/vuln/detail/cve-2020-16250">CVE-2020-16250</a>, an Hashicorp Vault bypass in its AWS IAM authentication method. This bug was found by Google‚Äôs Project Zero team, and a detailed analysis can be found in their <a href="https://googleprojectzero.blogspot.com/2020/10/enter-the-vault-auth-issues-hashicorp-vault.html">‚ÄúEnter the Vault: Authentication Issues in HashiCorp Vault‚Äù</a> blog post if you are interested. We won‚Äôt go through all the details in this post, but in summary, this is how the normal Hashicorp Vault AWS IAM authentication flow works:</p><ol><li>An AWS resource (e.g., an AWS Lambda function) presigns a <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html">GetCallerIdentity</a> request.</li><li>The AWS resource sends it to the Vault Server.</li><li>The Vault Server builds that requests and sends it to the AWS Security Token Service (STS).</li><li>AWS STS verifies the signature.</li><li>On success, AWS STS returns the associated role‚Äôs identity in an XML document.</li><li>The Vault Server parses the XML, extracts the identity, and, if that AWS role should have access to the requested secrets, it returns them.</li><li>The AWS resource can now use the secret to, for example, authenticate against a database.</li></ol><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/data_format_confusion_1.png" alt="Image showing the Vault authentication flow"/></p><p>What Google‚Äôs Project Zero team found was that an attacker could control too much in step 2, including controlling all headers of the request that Vault builds in step 3. In particular, by setting the <code>Accept</code> header to <code>application/json</code>, AWS STS would now return a JSON document in step 5 instead of the expected XML document. As a result, the Vault Server would parse a JSON document with Go‚Äôs XML parser. Because the XML parser is very lenient and parses anything that looks like XML in between lots of other ‚Äúgarbage‚Äù data, this was sufficient for a full authentication bypass when combined with partial control of the JSON response.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/data_format_confusion_2.png" alt="Image showing the Vault authentication flow with the exploit described above"/></p><p>Let‚Äôs look at three different behaviors that make parsing files with the wrong Go parser possible and build a polyglot that can be parsed with Go‚Äôs JSON, XML, and YAML parsers and return a different result for each.</p><h3 id="unknown-keys">Unknown keys</h3><p>By default, the JSON, XML, and YAML parsers don‚Äôt prevent unknown fields‚Äîproperties in the incoming data that don‚Äôt match any fields in the target struct.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/unknown_keys_1.png" alt="Summary of the behavior of the JSON, XML, and YAML parsers for unknown keys"/></p><h3 id="leading-garbage-data">Leading garbage data</h3><p>Of the three parsers, only the XML parser accepts leading garbage data.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/leading_garbage_data_1.png" alt="Summary of the behavior of the JSON, XML, and YAML parsers for leading garbage data"/></p><h3 id="trailing-garbage-data">Trailing garbage data</h3><p>Again, only the XML parser accepts arbitrary trailing garbage data.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/trailing_garbage_data_1.png" alt="Summary of the behavior of the JSON, XML, and YAML parsers for trailing garbage data"/></p><p>The exception is using the parsers‚Äô Decoder API with streaming data, in which case the JSON parser accepts garbage trailing data. This an <a href="https://github.com/golang/go/issues/36225">open issue</a> for which a fix is not planned.</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/trailing_garbage_data_2.png" alt="Summary of the behavior of the JSON, XML, and YAML parsers for trailing garbage data with the Decoder API"/></p><h3 id="constructing-a-polyglot">Constructing a polyglot</h3><p>How can we combine all the behaviors we‚Äôve seen so far that build a polyglot that:</p><ul><li>Can be parsed by Go‚Äôs JSON, XML, and YAML parsers</li><li>Returns a different result for each</li></ul><p>A very useful piece of information is that JSON is a subset of YAML:</p><blockquote><p>Every JSON file is also a valid YAML file</p></blockquote><p>With this in mind, we can build the following polyglot:</p><p><img src="https://blog.trailofbits.com/img/go-parser-footguns/polyglot.png" alt="Image showing the polyglot above and which parsers parse which value as explained below"/></p><p>The JSON parser can parse the polyglot because the input is valid JSON, it ignores unknown keys, and it allows duplicate keys. It takes the <code>Action_2</code> value because its field matching is case-insensitive and it takes the value of the last match.</p><p>The YAML parser can parse the polyglot because the input is valid JSON (and every JSON file is also a valid YAML file), and it ignores unknown keys. It takes the <code>Action_1</code> value because, contrary to the JSON parser, it does exact field name matches.</p><p>Finally, the XML parser can parse the polyglot because it ignores all surrounding data and just looks for XML-looking data, which, in this polyglot, we hid in a JSON value. As a result, it takes <code>Action_3</code>.</p><p>The polyglot we‚Äôve constructed is a powerful starting payload when exploiting these data format confusion attacks similar to the HashiCorp Vault bypass we explored above (CVE-2020-16250).</p><h2 id="mitigations">Mitigations</h2><p>How can we minimize these risks and make JSON parsing more strict? We‚Äôd like to:</p><ul><li>Prevent parsing of <strong>unknown keys</strong> in JSON, XML, and YAML</li><li>Prevent parsing of <strong>duplicate keys</strong> in JSON and XML</li><li>Prevent <strong>case insensitive key matches</strong> in JSON (this one is especially important!)</li><li>Prevent <strong>leading garbage data</strong> in XML</li><li>Prevent <strong>trailing garbage data</strong> in JSON and XML</li></ul><p>Unfortunately, JSON only offers one option to make its parsing stricter: <a href="https://pkg.go.dev/encoding/json#Decoder.DisallowUnknownFields"><code>DisallowUnknownFields</code></a>. As the name implies, this option disallows unknown fields in the input JSON. YAML supports the same functionality with the <code>KnownFields(true)</code> function, and while there was a <a href="https://github.com/golang/go/issues/30301">proposal</a> to implement the same for XML, it was rejected.</p><p>To prevent the remaining insecure defaults, we must create a custom ‚Äúhacky‚Äù solution. The next code block shows the <code>strictJSONParse</code> function, an attempt to make JSON parsing stricter, which has several limitations:</p><ol><li><strong>Bad performance</strong>: It requires parsing JSON input twice, making it significantly slower.</li><li><strong>Incomplete detection</strong>: Some edge cases remain undetected, as detailed in the function comments.</li><li><strong>Poor adoption potential</strong>: Since these security measures aren‚Äôt built into libraries as secure defaults or configurable options, widespread adoption is unlikely.</li></ol><p>Still, if you detect a vulnerability in your codebase, perhaps this imperfect solution can help you plug a hole while you find a more permanent solution.</p><figure><pre tabindex="0"><code data-lang="go"><span><span><span>// DetectCaseInsensitiveKeyCollisions checks if the JSON data contains keys</span>
</span></span><span><span><span>// that differ only by letter case. This helps prevent subtle bugs where two</span>
</span></span><span><span><span>// different key spellings might refer to the same data.</span>
</span></span><span><span><span>func</span> <span>DetectCaseInsensitiveKeyCollisions</span><span>(</span><span>data</span> <span>[]</span><span>byte</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>  <span>// Create a map to hold the decoded JSON data and attempt to parse the JSON</span>
</span></span><span><span>  <span>// data. This keeps keys with different letter casing.</span>
</span></span><span><span>  <span>var</span> <span>res</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>interface</span><span>{}</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>:=</span> <span>json</span><span>.</span><span>NewDecoder</span><span>(</span><span>bytes</span><span>.</span><span>NewReader</span><span>(</span><span>data</span><span>)).</span><span>Decode</span><span>(</span><span>&amp;</span><span>res</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>seenKeys</span> <span>:=</span> <span>make</span><span>([]</span><span>string</span><span>,</span> <span>0</span><span>,</span> <span>len</span><span>(</span><span>res</span><span>))</span>
</span></span><span><span>
</span></span><span><span>  <span>// Iterate through all keys in the parsed JSON and detect duplicates</span>
</span></span><span><span>  <span>for</span> <span>newKey</span> <span>:=</span> <span>range</span> <span>res</span> <span>{</span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>existingKey</span> <span>:=</span> <span>range</span> <span>seenKeys</span> <span>{</span>
</span></span><span><span>      <span>if</span> <span>strings</span><span>.</span><span>EqualFold</span><span>(</span><span>existingKey</span><span>,</span> <span>newKey</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>// Return an error when a case-insensitive duplicate is found</span>
</span></span><span><span>        <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;case-insensitive duplicate keys detected:
</span></span></span><span><span><span>                        %q and %q&#34;</span><span>,</span> <span>existingKey</span><span>,</span> <span>newKey</span><span>)</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>seenKeys</span> <span>=</span> <span>append</span><span>(</span><span>seenKeys</span><span>,</span> <span>newKey</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Provides a stricter JSON parsing with additional validation:</span>
</span></span><span><span><span>//   1. Rejects unknown fields not in the target struct</span>
</span></span><span><span><span>//   2. Detects case-insensitive key collisions</span>
</span></span><span><span><span>//   3. Ensures complete parsing with no trailing content</span>
</span></span><span><span><span>// strictJSONParse does not:</span>
</span></span><span><span><span>//   - Ensure that there are no duplicate keys with the same casing</span>
</span></span><span><span><span>//   - Ensure that the casing in the input matches the expected casing</span>
</span></span><span><span><span>//     in the target struct</span>
</span></span><span><span><span>func</span> <span>strictJSONParse</span><span>(</span><span>jsonData</span> <span>[]</span><span>byte</span><span>,</span> <span>target</span> <span>interface</span><span>{})</span> <span>error</span> <span>{</span>
</span></span><span><span>  <span>decoder</span> <span>:=</span> <span>json</span><span>.</span><span>NewDecoder</span><span>(</span><span>bytes</span><span>.</span><span>NewReader</span><span>(</span><span>jsonData</span><span>))</span>
</span></span><span><span>
</span></span><span><span>  <span>// 1. Disallow unknown fields</span>
</span></span><span><span>  <span>decoder</span><span>.</span><span>DisallowUnknownFields</span><span>()</span>
</span></span><span><span>
</span></span><span><span>  <span>// 2. Disallow duplicate keys with different casing</span>
</span></span><span><span>  <span>err</span> <span>:=</span> <span>DetectCaseInsensitiveKeyCollisions</span><span>(</span><span>jsonData</span><span>)</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;strictJSONParse: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>// Decode the JSON into the provided struct</span>
</span></span><span><span>  <span>err</span> <span>=</span> <span>decoder</span><span>.</span><span>Decode</span><span>(</span><span>target</span><span>)</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;strictJSONParse: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>// 3. Ensure there&#39;s no trailing data after the JSON object</span>
</span></span><span><span>  <span>token</span><span>,</span> <span>err</span> <span>:=</span> <span>decoder</span><span>.</span><span>Token</span><span>()</span>
</span></span><span><span>  <span>if</span> <span>err</span> <span>!=</span> <span>io</span><span>.</span><span>EOF</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;strictJSONParse: unexpected trailing data after
</span></span></span><span><span><span>                    JSON: token: %v, err: %v&#34;</span><span>,</span> <span>token</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><h3 id="jsonv2">JSONv2</h3><p>To be widely adopted and solve the problem at a large scale, this functionality needs to be implemented at the library level and enabled by default. This is where <a href="https://github.com/golang/go/issues/71497">JSON v2</a> comes in. It is currently only a proposal, but a lot of work has gone into it already, and it will hopefully be released soon. It improves on JSON v1 in many ways, including:</p><ul><li>Disallowing duplicate names: ‚Äú(‚Ä¶) in v2 a JSON object with duplicate names results in an error. The <code>jsontext.AllowDuplicateNames</code> option controls this behavior difference.‚Äù</li><li>Doing case-sensitive matching: ‚Äú(‚Ä¶) v2 matches fields using an exact, case-sensitive match. The <code>MatchCaseInsensitiveNames</code> and <code>jsonv1.MatchCaseSensitiveDelimiter</code> options control this behavior difference.‚Äù</li><li>It includes a <code>RejectUnknownMembers</code> option, even though it is not enable by default (equivalent to <code>DisallowUnknownFields</code>).</li><li>It includes a <code>UnmarshalRead</code> function to process data from an <code>io.Reader</code>, verifying that an EOF is found, disallowing trailing garbage data.</li></ul><p>While this proposal addresses many of the issues discussed in this blog post, these challenges will persist within the Go ecosystem as widespread adoption takes time. The proposal needs formal acceptance, after which developers must integrate it into all existing JSON-parsing Go code. Until then, these vulnerabilities will continue to pose risks.</p><h2 id="key-takeaways-for-developers">Key takeaways for developers</h2><ol><li><p><strong>Implement strict parsing by default</strong>. Use <code>DisallowUnknownFields</code> for JSON, <code>KnownFields(true)</code> for YAML. Unfortunately, this is all you can do directly with the Go parser APIs.</p></li><li><p><strong>Maintain consistency across boundaries</strong>. When input in processed in multiple services, ensure consistent parsing behavior by always using the same parser or implement additional validation layers, such as the <code>strictJSONParse</code> function shown above.</p></li><li><p><strong>Watch for JSON v2</strong>. Keep an eye on the development of Go‚Äôs <a href="https://github.com/golang/go/issues/71497">JSON v2</a> library, which addresses many of these issues with safer defaults for JSON.</p></li><li><p><strong>Leverage static analysis</strong>. Use the Semgrep rules we‚Äôve provided to detect a few vulnerable patterns in your codebase, particularly the misuse of the <code>-</code> tag and <code>omitempty</code> fields. Try them with <code>semgrep -c r/trailofbits.go.unmarshal-tag-is-dash</code> and <code>semgrep -c r/trailofbits.go.unmarshal-tag-is-omitempty</code>!</p></li></ol><p>While we‚Äôve provided mitigations and detection strategies, the long-term solution requires fundamental changes to how these parsers operate. Until parser libraries adopt secure defaults, developers must remain vigilant.</p></div></div>
  </body>
</html>
