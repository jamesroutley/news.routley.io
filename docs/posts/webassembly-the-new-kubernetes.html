<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2021/12/13/webassembly-the-new-kubernetes">Original</a>
    <h1>WebAssembly: The New Kubernetes?</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I had an &#34;oh, duh, of course&#34; moment a few weeks ago that I wanted to share: is WebAssembly the next Kubernetes?</p><p><b>katers gonna k8s</b></p><p><a href="https://kubernetes.io/">Kubernetes</a> promises a software virtualization substrate that allows you to solve a number of problems at the same time:</p><ul>
<li><p>Compared to running services on bare metal, Kubernetes (&#34;k8s&#34;) lets you use hardware more efficiently.  K8s lets you run many containers on one hardware server, and lets you just add more servers to your cluster as you need them.</p></li>
<li><p>The &#34;cloud of containers&#34; architecture efficiently divides up the work of building server-side applications.  Your database team can ship database containers, your backend team ships java containers, and your product managers wire them all together using networking as the generic middle-layer.  It cuts with the grain of <a href="https://wingolog.org/archives/2015/11/09/embracing-conways-law">Conway&#39;s law</a>: the software looks like the org chart.</p></li>
<li><p>The container abstraction is generic enough to support lots of different kinds of services.  Go, Java, C++, whatever -- it&#39;s not language-specific.  Your dev teams can use what they like.</p></li>
<li><p>The operations team responsible for the k8s servers that run containers don&#39;t have to trust the containers that they run.  There is some sandboxing and security built-in.</p></li>
</ul><p>K8s itself is an evolution on a previous architecture, <a href="https://www.openstack.org">OpenStack</a>.  OpenStack had each container be a full virtual machine, with a whole kernel and operating system and everything.  K8s instead generally uses containers, which don&#39;t generally require a kernel in the containers.  The result is that they are lighter-weight -- think Docker versus VirtualBox.</p><p>In a Kubernetes deployment, you still have the kernel at a central place in your software architecture.  The fundamental mechanism of containerization is the <a href="https://lwn.net/Articles/491310/">Linux kernel process, with private namespaces</a>.  These containers are then glued together by TCP and UDP sockets.  However, though one or more kernel process per container does scale better than full virtual machines, it doesn&#39;t generally scale to millions of containers.  And processes do have some start-up time -- you can&#39;t spin up a container for each request to a high-performance web service.  These technical contraints lead to certain kinds of system architectures, with generally long-lived components that keep some kind of state.</p><p><b>k8s &lt;=? w9y</b></p><p>Server-side WebAssembly is in a similar space as Kubernetes -- or rather, WebAssembly is similar to processes plus private namespaces.  WebAssembly gives you a good abstraction barrier and (can give) high security isolation.  It&#39;s even better in some ways because WebAssembly provides &#34;allowlist&#34; security -- it has no capabilities to start with, requiring that the &#34;host&#34; that runs the WebAssembly explicitly delegate some of its own capabilities to the guest WebAssembly module.  Compare to processes which by default start with every capability and then have to be restricted.</p><p>Like Kubernetes, WebAssembly also gets you Conway&#39;s-law-affine systems.  Instead of shipping containers, you ship WebAssembly modules -- and some metadata about what kinds of things they need from their environment (the &#39;imports&#39;).  And WebAssembly is generic -- it&#39;s a <a href="https://twitter.com/jckarter/status/1409896927718559744">low level virtual machine</a> that anything can compile to.</p><p>But, in WebAssembly you get a few more things.  One is fast start.  Because memory is data, you can arrange to create a <a href="https://fitzgeraldnick.com/2021/05/10/wasm-summit-2021.html">WebAssembly module that starts with its state pre-initialized in memory</a>.  Such a module can start in microseconds -- fast enough to create one on every request, in some cases, just throwing away the state afterwards.  You can run function-as-a-service architectures more effectively on WebAssembly than on containers.  Another is that the virtualization is provided entirely in user-space.  One process can multiplex between many different WebAssembly modules.  This lets one server do more.  And, you don&#39;t need to use networking to connect <a href="https://www.infoq.com/podcasts/web-assembly-component-model/">WebAssembly components</a>; they can transfer data in memory, sometimes even without copying.</p><p>(A digression: this lightweight in-process aspect of WebAssembly makes it so that other architectures are also possible, e.g. <a href="https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/">this fun hack to sandbox a library linked into Firefox</a>.  They actually shipped that!)</p><p>I compare WebAssembly to K8s, but really it&#39;s more like processes and private namespaces.  So one answer to the question as initially posed is that no, WebAssembly is not the next Kubernetes; that next thing is waiting to be built, though I know of a few organizations that have started already.</p><p>One thing does seem clear to me though: WebAssembly will be at the bottom of the new thing, and therefore that the near-term trajectory of WebAssembly is likely to follow that of Kubernetes, which means...</p><ul>
<li><p>Champagne time for analysts!</p></li>
<li><p>The Gartner ✨✨Magic Quadrant✨✨™®© rides again</p></li>
<li><p>IBM spins out a new WebAssembly division</p></li>
<li><p>Accenture starts asking companies about their WebAssembly migration plan</p></li>
<li><p>The Linux Foundation tastes blood in the waters</p></li>
</ul><p>And so on.  I see turbulent waters in the near-term future.  So in that sense, in which Kubernetes is not essentially a technical piece of software but rather a nexus of frothy commercial jousting, then yes, certainly: we have a fun 5 years or so ahead of us.</p></div></div></div>
  </body>
</html>
