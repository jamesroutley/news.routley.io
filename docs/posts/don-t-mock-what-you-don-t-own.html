<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hynek.me/articles/what-to-mock-in-5-mins/">Original</a>
    <h1>Don’t mock what you don’t own</h1>
    
    <div id="readability-page-1" class="page"><section><p>A common issue programmers have when they try to test real-world software is how to deal with third-party dependencies. Let’s examine an old, but counter-intuitive principle.</p><p>Once upon a time, I made a stupid joke on Twitter about the <em>Don’t Mock What You Don’t Own</em> testing principle<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>:</p><blockquote cite="https://twitter.com/hynek/status/1478384282766913548"><p>Only mock what you own, because mocking others is rude.</p></blockquote><p>While it didn’t get me fired, it led to me <a href="https://twitter.com/christianbarra/status/1478700652989722627">being tricked</a> into giving a 5 minute-long talk<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> about it. Given the confused replies I got to the joke Tweet, I’ve decided it’s worth writing down the contents of the talk for posterity.</p><h2 id="the-principle">The Principle</h2><p><em>Don’t Mock What You Don’t Own</em> means that whenever you employ mock objects, you should use them to substitute your <em><strong>own</strong></em> objects and not third-party ones.</p><p>If you’re anything like me, that <strong>makes no sense</strong>! What <strong>else</strong> am I supposed to mock? My code is perfectly testable!</p><p><strong>Key point:</strong> there’s a difference between owning an <strong>object</strong> and owning the <strong>API</strong> to use it.</p><p>Allow me to use a simple example to demonstrate the downsides of mocking third-party objects and what to do instead.</p><div><p><strong>Disclaimer</strong>: I don’t like <em>mocks</em> in the original sense: a test object, that mimics another (usually complex) object, <em>records calls to its APIs</em>, and allows you to make assertions over those calls.</p><p>However, this principle is still useful, because it applies equally to any other type of test object (if you’re confused by the differences between <em>mocks</em>, <em>fakes</em>, <em>stubs</em>, <em>et cetera</em>, I recommend Martin Fowler’s <em><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren’t Stubs</a></em>). I will keep using the term <em>mock</em> throughout this article to remain congruent with the name of the principle and I will be using a popular mocking library in my examples for familiarity, but you don’t have to tell <em>me</em> why you don’t like mocks.</p><p><strong>I</strong> don’t use mocks in my <em>own</em> code at all. In Python I use <a href="https://github.com/alex/pretend"><em>pretend</em></a> for simple stubs and <em><a href="https://pythonspeed.com/articles/verified-fakes/">verified fakes</a></em> for more complex scenarios. In Go I reach always for <em>verified fakes</em>.</p><p>This isn’t <em>potayto potahto</em> – this is a fundamental difference in how to approach testing, but it’s out-of-scope for this article.</p></div><h2 id="a-docker-repository-client">A Docker Repository Client</h2><p>To keep my example short, I will use a Python program that uses an HTTP library, but the problem and solution are universal to any object-oriented language.</p><p>If you’ve ever run your own <em>Docker</em> container registry, chances are high that you’ve written scripts around its <a href="https://docs.docker.com/registry/spec/api/">web API</a>. For example, you might want to print out a list of your repositories, together with a list of the tags that exist within each repository:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>$ list-docker-repos-with-tags
</span></span><span><span>web-svc 1, 5, <span>7</span>
</span></span><span><span>worker-svc 8, 10, <span>11</span>
</span></span></code></pre></div><p>This is the inspiration for our example. If you don’t know what any of this means: don’t worry. All you need to understand is that we’re writing a program that makes HTTP requests against a web API and extracts data from the responses.</p><h3 id="rude-mocking">Rude Mocking</h3><p>I’m going to skip a bit ahead and start with an already testable-looking function. It takes an HTTP client (in this case, I use the excellent <a href="https://www.python-httpx.org"><em>httpx</em></a> package) and returns <a href="https://en.wikipedia.org/wiki/Hash_table">a dictionary</a> of repository names that point to a list of the version tags. Invoking this function from a CLI and printing out its return value is not interesting for our point, so I’m leaving it out:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>get_repos_w_tags</span><span>(</span><span>client</span><span>):</span>
</span></span><span><span>    <span>rv</span> <span>=</span> <span>{}</span>
</span></span><span><span>    <span>repos</span> <span>=</span> <span>client</span><span>.</span><span>get</span><span>(</span>
</span></span><span><span>        <span>&#34;https://docker.example.com/v2/_catalog&#34;</span>
</span></span><span><span>    <span>)</span><span>.</span><span>json</span><span>()[</span><span>&#34;repositories&#34;</span><span>]</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>repo</span> <span>in</span> <span>repos</span><span>:</span>
</span></span><span><span>        <span>rv</span><span>[</span><span>repo</span><span>]</span> <span>=</span> <span>client</span><span>.</span><span>get</span><span>(</span>
</span></span><span><span>            <span>f</span><span>&#34;https://docker.example.com/v2/</span><span>{</span><span>repo</span><span>}</span><span>/tags/list&#34;</span>
</span></span><span><span>        <span>)</span><span>.</span><span>json</span><span>()[</span><span>&#34;tags&#34;</span><span>]</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>rv</span>
</span></span></code></pre></div><p>This is much better than a lot of code that gets written for situations like this! Many would hard-code everything and if they need to test it, they shrug their shoulders and start <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey-patching</a>. With the code above, you can “simply” pass in a fake <code>client</code> object that returns predefined static values for calls to <code>client.get()</code> and look at the dictionary it returns. <em>Look ma, no network!</em></p><p>And yet it violates the principle that this article is about. Why?</p><p>Because it’s not simple. Let’s have a look at the simplest possible test that checks what happens if the first <code>client.get()</code> call returns an empty list for the <code>repositories</code> key:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>unittest.mock</span> <span>import</span> <span>Mock</span>
</span></span><span><span><span>import</span> <span>httpx</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_empty</span><span>():</span>
</span></span><span><span>    <span>client</span> <span>=</span> <span>Mock</span><span>(</span>
</span></span><span><span>        <span>spec_set</span><span>=</span><span>httpx</span><span>.</span><span>Client</span><span>,</span>
</span></span><span><span>        <span>get</span><span>=</span><span>Mock</span><span>(</span>
</span></span><span><span>            <span>return_value</span><span>=</span><span>Mock</span><span>(</span>
</span></span><span><span>                <span>spec_set</span><span>=</span><span>httpx</span><span>.</span><span>Response</span><span>,</span>
</span></span><span><span>                <span>json</span><span>=</span><span>lambda</span><span>:</span> <span>{</span>
</span></span><span><span>                    <span>&#34;repositories&#34;</span><span>:</span> <span>[]</span>
</span></span><span><span>                <span>},</span>
</span></span><span><span>            <span>)</span>
</span></span><span><span>        <span>),</span>
</span></span><span><span>    <span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>assert</span> <span>{}</span> <span>==</span> <span>get_repos_w_tags</span><span>(</span><span>client</span><span>)</span>
</span></span></code></pre></div><p>We need <strong>three</strong> layers of mocks to verify that an empty <code>repositories</code> key leads to an empty dictionary. And if I didn’t use a <code>lambda</code> for the <code>json</code> function, it would be even four layers.</p><p>I use the <code>spec_set</code> argument (<a href="https://nedbatchelder.com/blog/202202/why_your_mock_still_doesnt_work.html">as should you</a>) to prevent <code>unittest.mock.Mock</code> from happily returning new mocks when you access <em>any</em> attribute, and yet constructs like this tend to be brittle and unpleasant to create and debug.</p><div><p>This is a <em>business logic</em> test and the purpose of the test is drowning in boilerplate necessary to mimic the API of an HTTP client that might change any time.</p><p>That makes the test <strong>brittle</strong> and <strong>unidiomatic</strong>. When I read tests for business logic, I want <em>the intent</em> of the test to be obvious on first glimpse.</p></div><p>You could write a helper to create mock clients that do what you want, saving you the boilerplate in individual tests. However, the more complex your tests get, and the more numerous and the more complex your involved mocks get, the less you can be sure what you’re <em>actually</em> testing. Eventually, you end up in <a href="https://www.youtube.com/watch?v=CdKaZ7boiZ4"><em>Mock Hell</em></a>.</p><p>In my experience, this is the wrong path, so let’s try something different.</p><h3 id="polite-mocking">Polite Mocking</h3><blockquote cite="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering"><p>All problems in computer science can be solved by another level of indirection.</p></blockquote><p>We’ll follow Mr. Lampson’s advice and add a <em>very thin</em> layer around the HTTP library, which becomes the <a href="https://en.wikipedia.org/wiki/Facade_pattern"><em>façade</em></a> between your clean code and the messy outside world. Layers like this are notoriously difficult to test<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, so they should be kept <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatically</a> as simple as possible: go easy on conditionals and loops, otherwise you just kick the <em>testing can</em> one layer down and win nothing.</p><p>In this case we write a <code>DockerRegistryClient</code> class that offers two methods whose implementations should look familiar: <code>get_repos()</code> that returns a list of repository names and <code>get_repo_tags()</code> that returns a list of tags for a repository. The code is the same as before:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>DockerRegistryClient</span><span>:</span>
</span></span><span><span>    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>client</span><span>):</span>
</span></span><span><span>        <span>self</span><span>.</span><span>_client</span> <span>=</span> <span>client</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>get_repos</span><span>(</span><span>self</span><span>):</span>
</span></span><span><span>        <span>return</span> <span>self</span><span>.</span><span>_client</span><span>.</span><span>get</span><span>(</span>
</span></span><span><span>            <span>&#34;https://docker.example.com/v2/_catalog&#34;</span>
</span></span><span><span>        <span>)</span><span>.</span><span>json</span><span>()[</span><span>&#34;repositories&#34;</span><span>]</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>get_repo_tags</span><span>(</span><span>self</span><span>,</span> <span>repo</span><span>):</span>
</span></span><span><span>        <span>return</span> <span>self</span><span>.</span><span>_client</span><span>.</span><span>get</span><span>(</span>
</span></span><span><span>             <span>f</span><span>&#34;https://docker.example.com/v2/</span><span>{</span><span>repo</span><span>}</span><span>/tags/list&#34;</span>
</span></span><span><span>        <span>)</span><span>.</span><span>json</span><span>()[</span><span>&#34;tags&#34;</span><span>]</span>
</span></span></code></pre></div><p>I hope there’s no surprises in this code, so let’s apply it to our business code:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>get_repos_w_tags_drc</span><span>(</span><span>drc</span><span>):</span>
</span></span><span><span>    <span>rv</span> <span>=</span> <span>{}</span>
</span></span><span><span>    <span>for</span> <span>repo</span> <span>in</span> <span>drc</span><span>.</span><span>get_repos</span><span>():</span>
</span></span><span><span>        <span>rv</span><span>[</span><span>repo</span><span>]</span> <span>=</span> <span>drc</span><span>.</span><span>get_repo_tags</span><span>(</span><span>repo</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>rv</span>
</span></span></code></pre></div><p>The first pay-off is that the business logic is more idiomatic! Seeing the business logic written clearly like this also reveals that it could be re-written as a dictionary comprehension! You never know beforehand what making code clearer and more idiomatic will yield you.</p><p>Either way, let’s rewrite the test next:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>test_empty_drc</span><span>():</span>
</span></span><span><span>    <span>drc</span> <span>=</span> <span>Mock</span><span>(</span>
</span></span><span><span>        <span>spec_set</span><span>=</span><span>DockerRegistryClient</span><span>,</span>
</span></span><span><span>        <span>get_repos</span><span>=</span><span>lambda</span><span>:</span> <span>[]</span>
</span></span><span><span>    <span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>assert</span> <span>{}</span> <span>==</span> <span>get_repos_w_tags_drc</span><span>(</span><span>drc</span><span>)</span>
</span></span></code></pre></div><p>Only one <code>Mock</code>! And <em>one</em> look and you know what’s happening!</p><p>Once you want to run more complex tests where <code>get_repos()</code> returns a non-empty list and you need to mock <code>get_repo_tags()</code> too, it’s a lot easier because all you have to do is adding another line with <code>get_repo_tags=lambda repo: …</code>. No need for more nested mocks and making <code>client.get()</code> return different values for different calls.</p><p>And if you choose to replace your HTTP library, your business tests won’t care, because they only interface with <em>your</em> abstraction.</p><p><strong>Corollary</strong>: to keep your <em>business code</em> testable and idiomatic, avoid directly using third-party dependencies in it.</p><h2 id="when-to-break-the-rule">When to Break the Rule?</h2><p>Every rule and principle can be broken once you’ve fully understood its purpose. For example if an object already does have an idiomatic API, it’s probably not worth wrapping in an identical façade, just so it belongs to you.</p><p>For simple programs like in this blog post, it’s probably easier to write a test helper that creates appropriate fake HTTP clients. Although there’s the upside to the more idiomatic business code! At some point this becomes a trade-off against complexity and performance.</p><p>Sometimes it’s also easy enough to fake actual HTTP responses by running your own in-process HTTP server within the tests – but I prefer to isolate these kinds of tests when testing the <em>thin</em> outer layer. It also gets more complicated once you have to interact with an opaque SOAP servers or CLI utilities. Trade-offs, trade-offs.</p><p>The most common occasion when <strong>I</strong> break this principle is when I need to simulate errors that aren’t trivial to create organically: certain network conditions, timeouts, integrity errors, …</p><p><strong>In the end, it’s less of a rule and more of a heuristic.</strong></p><h2 id="further-reading">Further Reading</h2><p>To learn more about the principle check out <a href="https://8thlight.com/blog/eric-smith/2011/10/27/thats-not-yours.html"><em>That’s Not Yours</em></a> which takes a more database-centric approach and <a href="https://github.com/testdouble/contributing-tests/wiki/Don&#39;t-mock-what-you-don&#39;t-own">this summary</a> in <em>TestDouble</em>’s wiki.</p><p>As with many things lately, this article was inspired by the wonderful <a href="https://www.cosmicpython.com"><em>Architecture Patterns with Python</em></a> – the book that keeps transforming my gut feelings into principles like none before. Go and read it (for free on the web page if you want to). Harry also wrote a much more extensive treatise on this topic entitled <a href="https://www.cosmicpython.com/blog/2020-01-25-testing_external_api_calls.html"><em>Writing tests for external API calls‌</em></a> that offers more ideas and approaches.</p><p>If you’re interested in object-oriented programming, subclassing, and Python, I’d like to recommend my <em>magnum opus</em>: <a href="https://hynek.me/articles/python-subclassing-redux/"><em>Subclassing in Python Redux‌</em></a></p><p>And finally, this talk from 2012 has aged very well: <em>Stop Mocking, Start Testing</em>:</p><lite-youtube videoid="Xu5EhKVZdV8" playlabel="Stop Mocking, Start Testing"></lite-youtube></section></div>
  </body>
</html>
