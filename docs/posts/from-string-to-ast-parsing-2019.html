<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kubuszok.com/2019/from-string-to-ast-parsing/">Original</a>
    <h1>From string to AST: parsing (2019)</h1>
    
    <div id="readability-page-1" class="page"><article><p>Whether you have to do with data in form of CSV, JSON or a full-blooded programming language like C, JavaScript, Scala, or maybe a query language like SQL, you always transform some sequence of characters (or binary values) into a structured representation. Whatever you’ll do with that representation depends on your domain and business goals, and is quite often the core value of whatever you are doing. With a plethora of tools doing the parsing for us (including the error-handling), we might easily overlook how complex and interesting process it is.</p>

<h2 id="formal-grammars">Formal grammars</h2>

<p>First of all, most input formats that we handle follow some formal definition, telling e.g. how key-values are organized (JSON), how do you separate column names/values (CSV), how do you express projections and conditions (SQL). These rules are defined in an unambiguous way so that the input could be interpreted in a very deterministic way. It directly opposed language we use to communicate with other people, which often is ambiguous and put into the context. <em>Wanna grab some burger?</em> might be a nice suggestion if you are talking to a colleague that have to skip lunch and likes burgers, but might be offensive if told in a sarcastic tone to someone who doesn’t like meat. Then, words can have different meaning depending on the culture you are currently in, in which times you live or what are you and your conversationalist social position (<em>vide</em>, e.g. Japanese and how your position and suffixes you add at the end of the name change the tone of the whole conversation). Languages we use when communicating with a computer must be free of such uncertainties. The meaning should depend only on the input we explicitly entered and interpreted deterministically. (Just in case: by deterministically, I mean, deterministically interpreted, which doesn’t mean that it would always produce the same result. If I write <code>currentTimeMillis()</code>, the function will always return a different result, but the meaning will be always the same - compiler/interpreter will understand that I want to call <code>currentTimeMillis()</code> function, and it won’t suddenly decide that I want to e.g. change the compiler flag. Of course, the meaning of the function can change in time - for instance, if I edit the source code in between runs - and surely the value returned by it, which is bound to time).</p>

<p>Initially, it wasn’t known, how to parse languages. The reason, that we had to start with punching cards, sometime later moved on to assembly, and later on invent Fortran and Lisp, go through whole spaghetti code with Basic, get <em>The case against goto statement</em> by Dijkstra, until we could - slowly - started developing more sophisticated compilers we have today, was that there were no formal foundations to it.</p>

<p>Linguists know, that we can distinguish some <em>parts of speech</em> like: <em>noun</em> (specific thing, e.g. <em>cat</em>, <em>Alice</em>, <em>Bob</em>), <em>pronoun</em> (generic replacement for a specific thing, e.g. <em>I</em>, <em>you</em>, <em>he</em>, <em>she</em>), <em>verb</em> (action), <em>adjective</em> (description or trait of something, e.g. <em>red</em>, <em>smart</em>), etc. However, the also know that the function of part of speech changes depending on how we construct a sentence - that’s why we also have <em>the parts of the sentence</em>: <em>subject</em> (who performs the action: e.g. <em>Alice</em> in <em>Alice eats dinner</em>), <em>object</em> (who is the target of the action, e.g. <em>dinner</em> in <em>Alice eats dinner</em>), <em>modifiers</em> and <em>compliments</em>, etc. We can only tell which part of the speech and sentence the word is in the context of a whole sentence:</p>

<ul>
  <li>An alarm <em>is set</em> to 12 o’clock - here, <em>set</em> is a verb,</li>
  <li>This function returns an infinite <em>set</em> - here, <em>set</em> is a noun and an object,</li>
  <li>The <em>set</em> has the cardinality of 2 - here, <em>set</em> is a noun and a subject,</li>
  <li>All is <em>set</em> and done - here, <em>set</em> is an adverb and a modifier.</li>
</ul>

<p>As we can see the same work might be a completely different thing depending on the context. This might be a problem when we try to process the sentence bottom-up, just like we (supposedly) do when we analyze them in English lessons. <em>This is a noun. That is a verb. This noun is subject, this verb is an object. This is how subsentences relate to one another. Now we can analyze the nice tree of relations between words and understand the meaning.</em> As humans, we can understand the relationship between the words on the fly, the whole exercise is only about formalizing our intuition.</p>

<p>But machines have no intuition. They can only follow the rules, we establish for them. And when dealing with computers we quite often establish them using the divide-and-conquer strategy: split the big problem into smaller ones, and then combine the solutions. With <strong>natural languages</strong> the context makes it quite challenging, which is why no simple solution appeared even though we were regularly trying. Current progress was made mostly using machine learning, which tackles the whole problem at once, trying to fit whole parts of the sentence as patterns, without analyzing what is what. However, when it comes to communication with a computer, ambiguities can be avoided, simply by designing a language in a way that doesn’t allow them. But how to design a language?</p>

<p>One of the first researchers, that made the progress possible was Noam Chomsky. Interestingly, he is not considered a computer scientist - he is (among others) linguists, who is credited with <a href="https://en.wikipedia.org/wiki/Cognitive_revolution">cognitive revolution</a>. Chomsky believes, that how we structure languages is rooted in how our brains process speech, reading, etc. Therefore similarities between languages’ structures (parts of speech, parts of sentences, structuring ideas into sentences in the first place, grammar cases) are a result of how processes inside our brain. While he wasn’t the first one who tried to formalize a language into a <strong>formal grammar</strong> (we know of e.g. <a href="https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini">Pāṇini</a>), Chomsky was the first to formalize <strong>generative grammars</strong>, that is grammars where you define a set of rules, and create a language by combining the rules.</p>

<p>How can we define these rules? Well, we want to be able to express each <em>text</em> in such grammar as a tree - at leaves, we’ll have <em>words</em> or <em>punctuation marks</em> of sorts. Then, there will be nodes aggregating words/punctuation marks by their function (part of a sentence). At the top of the tree we’ll have a root, which might be (depending on grammar) a sentence/a statement/an expression, or maybe a sequence of sentences (a <em>program</em>). The definitions will work this way: take a node (starting with root) and add some children to it: the rules will say how the specific node (or nodes) can have children appended (and what kind of children). The grammar definitions will rarely be expressed with specific values (e.g. you won’t write down all possible names), but rather using symbols:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>→</mo><mi>S</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi><mtext> </mtext><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Sentence \rightarrow Subject\ verb\ Object .</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>e</span><span>n</span><span>t</span><span>e</span><span>n</span><span>ce</span><span></span><span>→</span><span></span></span><span><span></span><span>S</span><span>u</span><span>bj</span><span>ec</span><span>t</span><span> </span><span>v</span><span>er</span><span>b</span><span> </span><span>O</span><span>bj</span><span>ec</span><span>t</span><span>.</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>→</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>∣</mo><mi>n</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Subject \rightarrow name\ surname \mid nickname</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>u</span><span>bj</span><span>ec</span><span>t</span><span></span><span>→</span><span></span></span><span><span></span><span>nam</span><span>e</span><span> </span><span>s</span><span>u</span><span>r</span><span>nam</span><span>e</span><span></span><span>∣</span><span></span></span><span><span></span><span>ni</span><span>c</span><span>knam</span><span>e</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>→</mo><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∣</mo><mi>a</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Object \rightarrow item \mid animal</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>bj</span><span>ec</span><span>t</span><span></span><span>→</span><span></span></span><span><span></span><span>i</span><span>t</span><span>e</span><span>m</span><span></span><span>∣</span><span></span></span><span><span></span><span>anima</span><span>l</span></span></span></span></span>

<p>Here, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sentence</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>e</span><span>n</span><span>t</span><span>e</span><span>n</span><span>ce</span></span></span></span> could be a <strong>start symbol</strong>. We would build a sentence by unrolling notes according to rules. Here there is only one rule going from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sentence</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>e</span><span>n</span><span>t</span><span>e</span><span>n</span><span>ce</span></span></span></span> - one that allows adding <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Subject</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>u</span><span>bj</span><span>ec</span><span>t</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">verb</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>v</span><span>er</span><span>b</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Object</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>bj</span><span>ec</span><span>t</span></span></span></span> and the dot sign (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>.</span></span></span></span>) children (order matters!). <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">verb</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>v</span><span>er</span><span>b</span></span></span></span> is written with a small capital because it is (or eventually will be) a leaf - since unrolling ends (terminates) at leaves, we would call symbols allowed to be leaves as <strong>terminal symbols</strong>. As you might guess, nodes become <strong>nonterminal symbols</strong>. Terminal symbols will eventually be replaced with an actual word, unless they are <strong>keywords</strong> (have you noticed, how <em>if</em>, <em>else</em>, <em>function</em>, <em>class</em>, … get special treatment in many languages?) or special symbols (<code>;</code>, <code>(</code>,  <code>)</code>, <code>,</code>, …).</p>

<p>Having, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi><mtext> </mtext><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Subject\ verb\ Object.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>u</span><span>bj</span><span>ec</span><span>t</span><span> </span><span>v</span><span>er</span><span>b</span><span> </span><span>O</span><span>bj</span><span>ec</span><span>t</span><span>.</span></span></span></span>, we can continue unrolling. Our second rule lets us turn <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Subject</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span>u</span><span>bj</span><span>ec</span><span>t</span></span></span></span> into <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">name\ surname</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>nam</span><span>e</span><span> </span><span>s</span><span>u</span><span>r</span><span>nam</span><span>e</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">nickname</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ni</span><span>c</span><span>knam</span><span>e</span></span></span></span> (the vertical line <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span></span></span></span> is a shortcut - <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>∣</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B \mid C</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>B</span><span></span><span>∣</span><span></span></span><span><span></span><span>C</span></span></span></span> should be understood as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>B</span></span></span></span> <em>or</em> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \rightarrow C</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>C</span></span></span></span>). And our third rule allows us to turn <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Object</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>bj</span><span>ec</span><span>t</span></span></span></span> to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">item</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>i</span><span>t</span><span>e</span><span>m</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">animal</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>anima</span><span>l</span></span></span></span>. We can go both times with the first option and obtain <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi><mtext> </mtext><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">name\ surname\ verb\ item.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>nam</span><span>e</span><span> </span><span>s</span><span>u</span><span>r</span><span>nam</span><span>e</span><span> </span><span>v</span><span>er</span><span>b</span><span> </span><span>i</span><span>t</span><span>e</span><span>m</span><span>.</span></span></span></span> (e.g. <em>John Smith eats cereals.</em>). We might go both times with the second option - <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">nickname\ verb\ animal.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ni</span><span>c</span><span>knam</span><span>e</span><span> </span><span>v</span><span>er</span><span>b</span><span> </span><span>anima</span><span>l</span><span>.</span></span></span></span> (<em>Johnny likes cats.</em>). And so on.</p>

<p>Notice that in the end, we’ll always end up with a sequence of terminals. If we couldn’t, there would be something wrong with a language. This definition that takes a sequence of symbols and returns another sequence of symbols is called <strong>production rules</strong>. We can describe each <strong>formal language</strong> as a quadruple <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (N, \Sigma, P, S)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>G</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>N</span><span>,</span><span></span><span>Σ</span><span>,</span><span></span><span>P</span><span>,</span><span></span><span>S</span><span>)</span></span></span></span>, where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>T</span></span></span></span> is a finite set of nonterminal symbols, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span></span></span></span> a finite set of terminal symbols,  <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span> is a set of production rules and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">S \in \Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span></span><span>∈</span><span></span></span><span><span></span><span>Σ</span></span></span></span> is a start symbol.</p>

<p>Besides formalization of generative grammars, Chomsky did something else. He was responsible for the organization of formal languages in a hierarchy called after him the <strong>Chomsky hierarchy</strong>.</p>

<h2 id="the-chomsky-hierarchy">The Chomsky hierarchy</h2>

<p>On the top of the hierarchy are <strong>type-0 languages</strong> or <strong>unrestricted languages</strong>. There is no restriction placed upon how we define such language. A production rule might be any sequence of terminals and nonterminals into any sequence of terminals and nonterminals (in the earlier example there was always nonterminal symbol on the left side - that is not a rule in general!). These languages are hard to deal with, so we try to define data format and programming languages in term of a bit more restrained grammars, that are easier to analyze.</p>

<p>First restriction appears with <strong>type-1 languages</strong> or <strong>context-sensitive grammars</strong> (<strong>CSG</strong>). They require, that all production rules would be in form of:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mi>A</mi><mi>β</mi><mo>→</mo><mi>α</mi><mi>γ</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha A \beta \rightarrow \alpha \gamma \beta</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>α</span><span>A</span><span>β</span><span></span><span>→</span><span></span></span><span><span></span><span>α</span><span>γ</span><span>β</span></span></span></span></span>

<p>where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A \in N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha, \beta \in (N \cup \Sigma)^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>α</span><span>,</span><span></span><span>β</span><span></span><span>∈</span><span></span></span><span><span></span><span>(</span><span>N</span><span></span><span>∪</span><span></span></span><span><span></span><span>Σ</span><span><span>)</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\gamma \in (N \cup \Sigma)^+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>γ</span><span></span><span>∈</span><span></span></span><span><span></span><span>(</span><span>N</span><span></span><span>∪</span><span></span></span><span><span></span><span>Σ</span><span><span>)</span><span><span><span><span><span><span></span><span><span>+</span></span></span></span></span></span></span></span></span></span></span> (where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∗</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> are <a href="https://interjectedfuture.com/2018/algebras-we-love/#free-monoids">Kleene star and Kleene plus</a>). In other words, we can perform <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \gamma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>γ</span></span></span></span> only, if immediately before <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>α</span></span></span></span> and immediately after is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>β</span></span></span></span> (rule is applied in <em>context</em>). But, even these grammars appears to be difficult to deal with. That is why we apply even more restrictions to grammars we use in our everyday life.</p>

<p>More specifically, we might want our grammars to be independent of context. <strong>Type-2 languages</strong> or <strong>context-free grammars</strong> (<strong>CFG</strong>), are CSGs where context is always empty, or in other words, where each production rule is in form of:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \gamma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>γ</span></span></span></span></span>

<p>where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A \in N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\gamma \in (N \cup \Sigma)^+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>γ</span><span></span><span>∈</span><span></span></span><span><span></span><span>(</span><span>N</span><span></span><span>∪</span><span></span></span><span><span></span><span>Σ</span><span><span>)</span><span><span><span><span><span><span></span><span><span>+</span></span></span></span></span></span></span></span></span></span></span>. These grammars, are quite well researched, so we have plenty of tools helping us analyze them, check if something belongs to language, how to generate parser etc. That’s why the majority (all?) of programming languages and data inputs are defined using CFGs.</p>

<p>To be precise, when it comes to programming languages, we quite often deal with context-sensitive grammars, but it is easier to deal with them as if they were context-free - call that <strong>syntactical analysis</strong> (what meaning we can attribute to a words basing on their position in a sentence) - and then take the generated tree, called <strong>abstract syntax tree</strong>, and check if makes <strong>semantic</strong> sense (is the name a function, a variable or a type? Does it makes sense to use it in the <em>context</em> it was placed?). If we expressed it as a context-sensitive grammar we could do much (all?) of semantic analysis in the same time we check syntax, but the grammar could get too complex for us for understand it (or at least to handle it efficiently).</p>

<p>To illustrate the difference between syntax and semantics we can get back to your earlier example.</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>r</mi><mi>b</mi><mtext> </mtext><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">nickname\ verb\ item.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ni</span><span>c</span><span>knam</span><span>e</span><span> </span><span>v</span><span>er</span><span>b</span><span> </span><span>i</span><span>t</span><span>e</span><span>m</span><span>.</span></span></span></span></span>

<p>It is a correct semantics in the language. Let’s substitute terminals with some specific values.</p>

<blockquote>
  <p>Johnny eat integral.</p>
</blockquote>

<p>What we got is correct according to the rules based on words’ positions in the sentence (syntax), but as a whole - when you analyze the function of each word (semantics) - it makes no sense. Theoretically, we could define our language in an elaborate way, that would make sure that there would always be e.g. <em>eat<strong>s</strong></em> after the third person in a sentence and something edible after some form of <em>to eat</em> verb, but you can easily imagine, that the number of production rules would explode.</p>

<p>Finally, there is the most restricted kind of grammar in the Chomsky hierarchy. <strong>Type-3 grammar</strong> or <strong>regular grammar</strong> is a language, where you basically either prepend or append terminals. That is each production rule must be in the form of one of:</p>

<ul>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>a</span></span></span></span> - where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A \in N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span></span><span>∈</span><span></span></span><span><span></span><span>Σ</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>ϵ</span></span></span></span>, where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span> in an empty string,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow aB</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>a</span><span>B</span></span></span></span> - where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">B \in N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span>.</li>
</ul>

<p>(We call it <strong>right regular grammar</strong> - if we instead required that the third rule would be in the form <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow Ba</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>B</span><span>a</span></span></span></span> it would be <strong>left regular grammar</strong>). While regular grammars are too restricted to define many programming languages on its own, is we’ll find out later on, that - when combined with CFG - they allow us to build modern parsers.</p>

<h2 id="regular-languages">Regular languages</h2>

<p>Let’s start with the most limited grammars, that is regular grammars. No matter how we define production rules, we will end up with a tree of form:</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="176pt" height="308pt" viewBox="0.00 0.00 175.91 307.85" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 303.85)">
<!-- N1 -->
<g id="node1">
<title>N1</title>
<ellipse fill="lightgrey" stroke="black" cx="53.22" cy="-274.95" rx="24.9" ry="24.9"></ellipse>
<text text-anchor="middle" x="53.22" y="-270.28" font-family="FiraCode-Regular" font-size="14.00">N1</text>
</g>
<!-- t1 -->
<g id="node2">
<title>t1</title>
<ellipse fill="lightgrey" stroke="black" cx="21.22" cy="-189.15" rx="21.22" ry="21.22"></ellipse>
<text text-anchor="middle" x="21.22" y="-184.47" font-family="FiraCode-Regular" font-size="14.00">t1</text>
</g>
<!-- N1->t1 -->
<g id="edge1">
<title>N1-&gt;t1</title>
<path fill="none" stroke="black" d="M44.64,-251.49C40.9,-241.68 36.45,-230.03 32.44,-219.53"></path>
<polygon fill="black" stroke="black" points="35.46,-218.63 28.62,-210.53 28.92,-221.12 35.46,-218.63"></polygon>
</g>
<!-- N2 -->
<g id="node3">
<title>N2</title>
<ellipse fill="lightgrey" stroke="black" cx="85.22" cy="-189.15" rx="24.9" ry="24.9"></ellipse>
<text text-anchor="middle" x="85.22" y="-184.47" font-family="FiraCode-Regular" font-size="14.00">N2</text>
</g>
<!-- N1->N2 -->
<g id="edge2">
<title>N1-&gt;N2</title>
<path fill="none" stroke="black" d="M61.8,-251.49C65.14,-242.73 69.04,-232.52 72.69,-222.97"></path>
<polygon fill="black" stroke="black" points="76.21,-224.55 76.51,-213.96 69.67,-222.05 76.21,-224.55"></polygon>
</g>
<!-- t2 -->
<g id="node4">
<title>t2</title>
<ellipse fill="lightgrey" stroke="black" cx="53.22" cy="-103.34" rx="21.22" ry="21.22"></ellipse>
<text text-anchor="middle" x="53.22" y="-98.67" font-family="FiraCode-Regular" font-size="14.00">t2</text>
</g>
<!-- N2->t2 -->
<g id="edge3">
<title>N2-&gt;t2</title>
<path fill="none" stroke="black" d="M76.64,-165.69C72.9,-155.87 68.45,-144.22 64.44,-133.73"></path>
<polygon fill="black" stroke="black" points="67.46,-132.82 60.62,-124.73 60.92,-135.32 67.46,-132.82"></polygon>
</g>
<!-- N3 -->
<g id="node5">
<title>N3</title>
<ellipse fill="lightgrey" stroke="black" cx="117.22" cy="-103.34" rx="24.9" ry="24.9"></ellipse>
<text text-anchor="middle" x="117.22" y="-98.67" font-family="FiraCode-Regular" font-size="14.00">N3</text>
</g>
<!-- N2->N3 -->
<g id="edge4">
<title>N2-&gt;N3</title>
<path fill="none" stroke="black" d="M93.8,-165.69C97.14,-156.93 101.04,-146.71 104.69,-137.16"></path>
<polygon fill="black" stroke="black" points="108.21,-138.74 108.51,-128.15 101.67,-136.25 108.21,-138.74"></polygon>
</g>
<!-- t3 -->
<g id="node6">
<title>t3</title>
<ellipse fill="lightgrey" stroke="black" cx="87.22" cy="-21.22" rx="21.22" ry="21.22"></ellipse>
<text text-anchor="middle" x="87.22" y="-16.54" font-family="FiraCode-Regular" font-size="14.00">t3</text>
</g>
<!-- N3->t3 -->
<g id="edge5">
<title>N3-&gt;t3</title>
<path fill="none" stroke="black" d="M108.7,-79.6C105.47,-70.95 101.73,-60.97 98.29,-51.79"></path>
<polygon fill="black" stroke="black" points="101.22,-50.63 94.44,-42.49 94.67,-53.09 101.22,-50.63"></polygon>
</g>
<!-- ... -->
<g id="node7">
<title>...</title>
<ellipse fill="lightgrey" stroke="black" cx="147.22" cy="-21.22" rx="20.69" ry="20.69"></ellipse>
<text text-anchor="middle" x="147.22" y="-16.54" font-family="FiraCode-Regular" font-size="14.00">...</text>
</g>
<!-- N3->... -->
<g id="edge6">
<title>N3-&gt;...</title>
<path fill="none" stroke="black" d="M125.74,-79.6C129.06,-70.72 132.91,-60.44 136.42,-51.06"></path>
<polygon fill="black" stroke="black" points="139.97,-52.56 140.2,-41.97 133.42,-50.1 139.97,-52.56"></polygon>
</g>
</g>
</svg>

</p>

<p>Of course, it doesn’t mean, that each such tree would be the same. For instance we could define our grammar like this:</p>

<ul>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>→</mo><mi>a</mi><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_0 \rightarrow a A_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>→</span><span></span></span><span><span></span><span>a</span><span><span>A</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span>
  </li>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mi>a</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_1 \rightarrow a A_2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>→</span><span></span></span><span><span></span><span>a</span><span><span>A</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span>
  </li>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>→</mo><mi>a</mi><msub><mi>A</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">A_2 \rightarrow a A_3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>→</span><span></span></span><span><span></span><span>a</span><span><span>A</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span>
  </li>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>3</mn></msub><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A_3 \rightarrow \epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>→</span><span></span></span><span><span></span><span>ϵ</span></span></span></span></span>
  </li>
</ul>

<p>If we started from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, the only possible sentence in such language would be <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">aaa\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>aaa</span><span>ϵ</span></span></span></span>. And - since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span> represents an empty string, it would be actually just <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aaa</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>aaa</span></span></span></span>. Another example could be grammar like this:</p>

<ul>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">S \rightarrow a B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span><span></span><span>→</span><span></span></span><span><span></span><span>a</span><span>B</span></span></span></span></span>
  </li>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mo>→</mo><mi>b</mi><mi>B</mi><mo>∣</mo><mi>b</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">B \rightarrow bB \mid bC</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>→</span><span></span></span><span><span></span><span>b</span><span>B</span><span></span><span>∣</span><span></span></span><span><span></span><span>b</span><span>C</span></span></span></span></span>
  </li>
  <li>
    <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">C \rightarrow c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>C</span><span></span><span>→</span><span></span></span><span><span></span><span>c</span></span></span></span></span>
  </li>
</ul>

<p>If our starting symbol would be <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>S</span></span></span></span>, the sentences we could accept as belonging to grammar would be <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ab</span><span>c</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abbc</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>abb</span><span>c</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>b</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abbbc</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>abbb</span><span>c</span></span></span></span>, … If you’ve been programming for a while and you ever had to find some pattern in a text, you should have a feeling that looks familiar. Indeed, the regular language is formalism used to describe the <strong>regular expressions</strong>.</p>

<p>The first example you be described just as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aaa</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>aaa</span></span></span></span>, while the second as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mo stretchy="false">)</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a(b+)c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>(</span><span>b</span><span>+</span><span>)</span><span>c</span></span></span></span> (or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo stretchy="false">(</mo><mi>b</mi><mo>∗</mo><mo stretchy="false">)</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ab(b*)c)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ab</span><span>(</span><span>b</span><span>∗</span><span>)</span><span>c</span><span>)</span></span></span></span>. Here, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∗</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> corresponds directly with Kleene star and Kleene plus. Now, that we know we are talking about regexpes, we can provide another definition of what could be a regular language, that would be equivalent to production-rule-based, but easier to work with.</p>

<p>A regular expression is anything build using the following rules:</p>

<ul>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span> is a regular expression accepting the empty word as belonging to the language,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> is a regular expression accepting <code>&#39;a&#39;</code>  belonging to some alphabet <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> (nonterminals) as a word belonging to the language,</li>
  <li>when you <strong>concatenate</strong> two regular expressions, e.g. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span>B</span></span></span></span>, you accept words made by concatenating all valid words in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> with all valid words in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> (e.g. if <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> accepts only <code>&#34;a&#34;</code> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span> accepts only <code>&#34;b&#34;</code>, then <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ab</span></span></span></span> accepts <code>&#34;ab&#34;</code>),</li>
  <li>you can <strong>sum up</strong> regular languages <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∣</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \mid B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∣</span><span></span></span><span><span></span><span>B</span></span></span></span>, to accept all words valid either in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> or in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> (e.g. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∣</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \mid b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span></span><span>∣</span><span></span></span><span><span></span><span>b</span></span></span></span> would accept <code>&#34;a&#34;</code> or <code>&#34;b&#34;</code>, but not <code>&#34;ab&#34;</code>),</li>
  <li>you can use Kleene star <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span> and Kleene plus <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">A^+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>+</span></span></span></span></span></span></span></span></span></span></span>, to define (respectively) <em>any number of occurrences</em> or <em>at least one occurrence</em> of a pattern <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> as words accepted by regular language (e.g. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><msup><mi>b</mi><mo>+</mo></msup><mo stretchy="false">)</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a(b^+)c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>(</span><span><span>b</span><span><span><span><span><span><span></span><span><span>+</span></span></span></span></span></span></span></span><span>)</span><span>c</span></span></span></span>).</li>
</ul>

<p>That is enough to define all regular expressions, though usually, we would have some utilities provided by regexp engines, e.g. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>−</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a-z]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>[</span><span>a</span><span></span><span>−</span><span></span></span><span><span></span><span>z</span><span>]</span></span></span></span>, which is a shortcut for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∣</mo><mi>b</mi><mo>∣</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∣</mo><mi>y</mi><mo>∣</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a \mid b \mid ... \mid y \mid z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span></span><span>∣</span><span></span></span><span><span></span><span>b</span><span></span><span>∣</span><span></span></span><span><span></span><span>...</span><span></span><span>∣</span><span></span></span><span><span></span><span>y</span><span></span><span>∣</span><span></span></span><span><span></span><span>z</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">A?</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span>?</span></span></span></span> which is a shortcut for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∣</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A \mid \epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∣</span><span></span></span><span><span></span><span>ϵ</span></span></span></span>. Just in case, I’ll also mention, that some implementations of regexp allows so-called <em>backreferences</em> - expression build using there are no longer regular languages, which has some practical implications. What are these implications?</p>

<p>Well, we haven’t discussed it so far, but there are some very close relationships between types of formal grammars and computation models. It just happens, that if we wanted to define a function checking whether a word/sentence/etc belongs to a regular grammar/a regular expression - which is equivalent to defining the language - is done by defining a <strong>finite-state automaton</strong> (<strong>FSA</strong>), that accepts this language. And vice-versa, each FSA defines a regular language. That correspondence dictates, how we implement regexp patterns - basically, each time we compile a regexp pattern, we are building a FSA, that would accept all words of grammar and only them.</p>

<p>In case you’ve never met FSA, let us remind what they are. Finite-state automaton or <strong>finite-state machine</strong> (<strong>FSM</strong>) is a 5-tuple <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Q, \Sigma, \delta, q_0, F)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>Q</span><span>,</span><span></span><span>Σ</span><span>,</span><span></span><span>δ</span><span>,</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>F</span><span>)</span></span></span></span>, where:</p>

<ul>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Q</span></span></span></span> is a finite set of <strong>states</strong>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span></span></span></span> is a finite set of <strong>input symbols</strong> (an <strong>alphabet</strong> - equal to set of terminals without <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span>),</li>
  <li>a <strong>transition function</strong> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>δ</span><span></span><span>:</span><span></span></span><span><span></span><span>Q</span><span></span><span>×</span><span></span></span><span><span></span><span>Σ</span><span></span><span>→</span><span></span></span><span><span></span><span>Q</span></span></span></span>, which would take the current state and next input symbol to return the next state,</li>
  <li>an <strong>initial state</strong> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∈</span><span></span></span><span><span></span><span>Q</span></span></span></span>,</li>
  <li>a set of accepting states <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>F</span><span></span><span>⊆</span><span></span></span><span><span></span><span>Q</span></span></span></span>.</li>
</ul>

<blockquote>
  <p>On a side note: <em>an automaton</em> - singular, meaning <em>a machine</em>, <em>automata</em> - plural, meaning <em>machine<strong>s</strong></em>. Other nerdy words which works like that: <em>a criterion</em> vs <em>criteria</em>.</p>
</blockquote>

<p>For instance: our alphabet contains 3 possible characters <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{a,b,c\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>a</span><span>,</span><span></span><span>b</span><span>,</span><span></span><span>c</span><span>}</span></span></span></span>. We want to build a finite state machine accepting regular expression <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><msup><mi>b</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a(b^*)c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>(</span><span><span>b</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span><span>)</span><span>c</span></span></span></span>. Such machine:</p>

<ul>
  <li>would have to start with a state indicating that nothing was yet matched, but also that nothing is wrong yet. Let’s mark it as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>,</li>
  <li>if first incoming input symbol is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>, everything is OK, and we can move on to matching <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(b)^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>b</span><span><span>)</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span>. However, if <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> arrives, we can already tell, that the result is wrong. Let’s mark error as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span>. On <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span> no matter, what comes next, we’ll just stay at <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span> state,</li>
  <li>in this particular case we can safely assume, that if things started to go wrong, there is no way to recover, but it is not a general rule (if there was e.g. an alternative, then failing to match one expression, wouldn’t mean that we will fail to match the other expression),</li>
  <li>to indicate that we matched <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>, let’s create a new state <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>. We have to do it, because FSM (which shares its acronym with its noodle excellency Flying Spaghetti Monster) can only remember the current state it is in, so we want to change the behavior (and when we move to match <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span> we will), we can only achieve that, by creating a different state for each behavior (and step of the algorithm) and using state transition to indicate progress of computation,</li>
  <li>OK, we arrived at state <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, so <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> was matched, and we want to match <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span>. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span> means that there could be 0 or more occurrences of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span>. In case there is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>, we have to match whatever is immediately after <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span>, that is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span>. Accidentally, that would be the case when we are accepting input. Let’s mark that case as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">q_2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and let’s put it into the set accepting states,</li>
  <li>In case we are in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span> arrives, we can… simply keep the current state. Until anything from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>−</mo><mo stretchy="false">{</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma - \{b\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span><span></span><span>−</span><span></span></span><span><span></span><span>{</span><span>b</span><span>}</span></span></span></span> arrives, we can reuse current state,</li>
  <li>if we are in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> arrives, input is wrong and we’ll go to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span>,</li>
  <li>at this point, we are at <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">q_2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> (or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span> which means that things mismatched and we cannot recover). <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">q_2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> is accepting state, so, if there is nothing else, we matched the input. However, if there is anything else incoming, this means we have e.g. <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>b</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">abbca</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>abb</span><span>c</span><span>a</span></span></span></span> which shouldn’t be matched. So no matter what will come, we are moving to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span>.</li>
</ul>

<p>What we defined right, now could be described like this:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{a,b,c\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>a</span><span>,</span><span></span><span>b</span><span>,</span><span></span><span>c</span><span>}</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Q = \{q_0, q_1, q_2, e\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Q</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>e</span><span>}</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>δ</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\delta = \{ (q_0, a) \rightarrow q_1, \\
            (q_0, b) \rightarrow e, \\
            (q_0, c) \rightarrow e, \\
            (q_1, a) \rightarrow e, \\
            (q_1, b) \rightarrow q_1, \\
            (q_1, c) \rightarrow q_2, \\
            (q_2, a) \rightarrow e, \\
            (q_2, b) \rightarrow e, \\
            (q_2, c) \rightarrow e, \\
            (e, a) \rightarrow e, \\
            (e, b) \rightarrow e, \\
            (e, c) \rightarrow e \}
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>δ</span><span></span><span>=</span><span></span><span>{(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>a</span><span>)</span><span></span><span>→</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>c</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>a</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>→</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>c</span><span>)</span><span></span><span>→</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>a</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>c</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span>e</span><span>,</span><span></span><span>a</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span>e</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>,</span></span></span><span><span></span><span><span>(</span><span>e</span><span>,</span><span></span><span>c</span><span>)</span><span></span><span>→</span><span></span><span>e</span><span>}</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F = \{q_2\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>F</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>}</span></span></span></span></span>

<p>We could also make it more visual (bold border for accepting state):</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="182pt" height="364pt" viewBox="0.00 0.00 182.10 364.10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 360.1)">
<!-- q0 -->
<g id="node1">
<title>q0</title>
<ellipse fill="lightgrey" stroke="black" cx="100.35" cy="-315" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="100.35" y="-310.33" font-family="FiraCode-Regular" font-size="14.00">q0</text>
<text text-anchor="middle" x="38.25" y="-342.8" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- q1 -->
<g id="node3">
<title>q1</title>
<ellipse fill="lightgrey" stroke="black" cx="61.35" cy="-214.05" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="61.35" y="-209.38" font-family="FiraCode-Regular" font-size="14.00">q1</text>
</g>
<!-- q0->q1 -->
<g id="edge1">
<title>q0-&gt;q1</title>
<path fill="none" stroke="black" d="M91.89,-292.53C86.61,-279.14 79.72,-261.66 73.82,-246.7"></path>
<polygon fill="black" stroke="black" points="76.85,-245.84 69.93,-237.82 70.34,-248.41 76.85,-245.84"></polygon>
<text text-anchor="middle" x="87.48" y="-259.85" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e -->
<g id="node4">
<title>e</title>
<ellipse fill="lightgrey" stroke="black" cx="104.35" cy="-18" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="104.35" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">e</text>
</g>
<!-- q0->e -->
<g id="edge2">
<title>q0-&gt;e</title>
<path fill="none" stroke="black" d="M108.11,-292.02C112.99,-276.99 118.83,-256.51 121.35,-237.9 130.61,-169.54 118.28,-88.43 110.26,-46.76"></path>
<polygon fill="black" stroke="black" points="113.52,-46.22 108.13,-37.1 106.66,-47.59 113.52,-46.22"></polygon>
<text text-anchor="middle" x="135.85" y="-158.9" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q2 -->
<g id="node2">
<title>q2</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="44.35" cy="-113.1" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="44.35" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">q2</text>
</g>
<!-- q2->e -->
<g id="edge6">
<title>q2-&gt;e</title>
<path fill="none" stroke="black" d="M45.48,-88.28C46.94,-77.14 50.06,-64.13 56.6,-54 62.19,-45.34 70.72,-38.1 79.04,-32.48"></path>
<polygon fill="black" stroke="black" points="80.49,-35.08 87.17,-26.86 76.82,-29.13 80.49,-35.08"></polygon>
<text text-anchor="middle" x="74.23" y="-57.95" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q1->q2 -->
<g id="edge4">
<title>q1-&gt;q2</title>
<path fill="none" stroke="black" d="M57.41,-190.1C55.27,-177.67 52.59,-162.06 50.21,-148.23"></path>
<polygon fill="black" stroke="black" points="53.53,-147.88 48.39,-138.61 46.63,-149.06 53.53,-147.88"></polygon>
<text text-anchor="middle" x="58.1" y="-158.9" font-family="FiraCode-Regular" font-size="14.00">c</text>
</g>
<!-- q1->q1 -->
<g id="edge3">
<title>q1-&gt;q1</title>
<path fill="none" stroke="black" d="M83.74,-223.33C94.13,-224.34 103.2,-221.25 103.2,-214.05 103.2,-209.55 99.66,-206.66 94.46,-205.37"></path>
<polygon fill="black" stroke="black" points="94.92,-201.83 84.74,-204.77 94.53,-208.82 94.92,-201.83"></polygon>
<text text-anchor="middle" x="107.7" y="-209.38" font-family="FiraCode-Regular" font-size="14.00">b</text>
</g>
<!-- q1->e -->
<g id="edge5">
<title>q1-&gt;e</title>
<path fill="none" stroke="black" d="M66.37,-190.41C74.29,-154.65 89.68,-85.2 98.24,-46.58"></path>
<polygon fill="black" stroke="black" points="101.81,-47.63 100.56,-37.11 94.98,-46.11 101.81,-47.63"></polygon>
<text text-anchor="middle" x="93.48" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e->e -->
<g id="edge7">
<title>e-&gt;e</title>
<path fill="none" stroke="black" d="M121.01,-25.84C130.98,-27.59 140.35,-24.97 140.35,-18 140.35,-13.75 136.87,-11.12 131.9,-10.11"></path>
<polygon fill="black" stroke="black" points="132,-6.61 122.01,-10.16 132.03,-13.61 132,-6.61"></polygon>
<text text-anchor="middle" x="157.23" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
</g>
</svg>

</p>

<p>As we can see, each state has to have defined transition for every possible letter of the alphabet (even if that transition is returning the current state as the next state). So, the size of machine definition (all possible transitions) is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo><mi>Q</mi><mo>∣</mo><mo>×</mo><mo>∣</mo><mi mathvariant="normal">Σ</mi><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid Q \mid \times \mid \Sigma \mid</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span></span></span><span><span></span><span>Q</span><span></span><span>∣</span><span></span></span><span><span></span><span>×</span><span></span><span>∣</span><span></span></span><span><span></span><span>Σ</span><span></span><span>∣</span></span></span></span>.</p>

<p>Additionally, constructing the machine required some effort. We would like to automate the generation of FSM from regular expressions, and creating it in the final version might be troublesome. What we created is actually called <strong>deterministic finite state machine</strong> / <strong>deterministic finite automaton</strong> (<strong>DFA</strong>). It guarantees, that every single time we will deterministically get accepted a state for accepted input and non-accepted state for non-accepted input.</p>

<p>In practice, it is usually easier to define a <strong>non-deterministic finite automaton</strong> (<strong>NFA</strong>). The difference is that NFA <strong>can have several possible state moves for each state-input pair and picks one at random</strong>. So, it cannot match the right input always. However, we can say that <strong>it accepts input if there exists path within a graph, that accepts the whole input</strong>, or it <strong>accepts input if there is a non-zero probability of ending up in accepting state</strong>.</p>

<p>Let’s say we want to parse <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>∗</mo></msup><mo>∣</mo><mi>a</mi><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a^* \mid aba</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span><span></span><span>∣</span><span></span></span><span><span></span><span>aba</span></span></span></span>. It’s an alternative of two regular expressions. The first could be expressed as:</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="178pt" height="162pt" viewBox="0.00 0.00 178.10 162.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 158.2)">
<!-- q0 -->
<g id="node1">
<title>q0</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="100.35" cy="-113.1" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="100.35" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">q0</text>
<text text-anchor="middle" x="38.25" y="-140.9" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- q0->q0 -->
<g id="edge1">
<title>q0-&gt;q0</title>
<path fill="none" stroke="black" d="M123.17,-122.42C133.37,-123.3 142.2,-120.2 142.2,-113.1 142.2,-108.77 138.92,-105.93 134.05,-104.57"></path>
<polygon fill="black" stroke="black" points="134.39,-101.02 124.17,-103.78 133.89,-108 134.39,-101.02"></polygon>
<text text-anchor="middle" x="146.33" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e -->
<g id="node2">
<title>e</title>
<ellipse fill="lightgrey" stroke="black" cx="100.35" cy="-18" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="100.35" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">e</text>
</g>
<!-- q0->e -->
<g id="edge2">
<title>q0-&gt;e</title>
<path fill="none" stroke="black" d="M100.35,-88.61C100.35,-76.02 100.35,-60.44 100.35,-47.2"></path>
<polygon fill="black" stroke="black" points="103.85,-47.31 100.35,-37.31 96.85,-47.31 103.85,-47.31"></polygon>
<text text-anchor="middle" x="110.85" y="-57.95" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- e->e -->
<g id="edge3">
<title>e-&gt;e</title>
<path fill="none" stroke="black" d="M117.01,-25.84C126.98,-27.59 136.35,-24.97 136.35,-18 136.35,-13.75 132.87,-11.12 127.9,-10.11"></path>
<polygon fill="black" stroke="black" points="128,-6.61 118.01,-10.16 128.03,-13.61 128,-6.61"></polygon>
<text text-anchor="middle" x="153.23" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
</g>
</svg>

</p>

<p>and the second as:</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="181pt" height="465pt" viewBox="0.00 0.00 181.41 465.05" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 461.05)">
<!-- q0 -->
<g id="node1">
<title>q0</title>
<ellipse fill="lightgrey" stroke="black" cx="122.41" cy="-415.95" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="122.41" y="-411.28" font-family="FiraCode-Regular" font-size="14.00">q0</text>
<text text-anchor="middle" x="60.31" y="-443.75" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- q1 -->
<g id="node3">
<title>q1</title>
<ellipse fill="lightgrey" stroke="black" cx="67.41" cy="-315" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="67.41" y="-310.33" font-family="FiraCode-Regular" font-size="14.00">q1</text>
</g>
<!-- q0->q1 -->
<g id="edge1">
<title>q0-&gt;q1</title>
<path fill="none" stroke="black" d="M111.01,-394.45C103.2,-380.39 92.7,-361.5 83.96,-345.78"></path>
<polygon fill="black" stroke="black" points="86.71,-344.52 78.79,-337.48 80.59,-347.92 86.71,-344.52"></polygon>
<text text-anchor="middle" x="101.53" y="-360.8" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e -->
<g id="node4">
<title>e</title>
<ellipse fill="lightgrey" stroke="black" cx="77.41" cy="-18" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="77.41" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">e</text>
</g>
<!-- q0->e -->
<g id="edge2">
<title>q0-&gt;e</title>
<path fill="none" stroke="black" d="M132.57,-394.27C141.27,-374.62 152.41,-344.01 152.41,-316 152.41,-316 152.41,-316 152.41,-112.1 152.41,-79.05 123.39,-51.09 101.45,-34.68"></path>
<polygon fill="black" stroke="black" points="103.76,-31.32 93.59,-28.37 99.7,-37.02 103.76,-31.32"></polygon>
<text text-anchor="middle" x="162.91" y="-209.38" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q3 -->
<g id="node2">
<title>q3</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="42.41" cy="-113.1" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="42.41" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">q3</text>
</g>
<!-- q3->e -->
<g id="edge7">
<title>q3-&gt;e</title>
<path fill="none" stroke="black" d="M45.34,-88.61C47.2,-77.79 50.13,-64.96 54.66,-54 56.32,-49.97 58.46,-45.9 60.76,-42.04"></path>
<polygon fill="black" stroke="black" points="64.13,-44.28 66.62,-33.98 58.25,-40.47 64.13,-44.28"></polygon>
<text text-anchor="middle" x="71.28" y="-57.95" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q1->e -->
<g id="edge4">
<title>q1-&gt;e</title>
<path fill="none" stroke="black" d="M54.27,-294.51C29.26,-254.84 -20.15,-162.28 9.41,-89.25 18.44,-66.95 38.31,-47.8 54.26,-35.16"></path>
<polygon fill="black" stroke="black" points="55.76,-37.65 61.62,-28.83 51.54,-32.08 55.76,-37.65"></polygon>
<text text-anchor="middle" x="13.53" y="-158.9" font-family="FiraCode-Regular" font-size="14.00">a|c</text>
</g>
<!-- q2 -->
<g id="node5">
<title>q2</title>
<ellipse fill="lightgrey" stroke="black" cx="67.41" cy="-214.05" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="67.41" y="-209.38" font-family="FiraCode-Regular" font-size="14.00">q2</text>
</g>
<!-- q1->q2 -->
<g id="edge3">
<title>q1-&gt;q2</title>
<path fill="none" stroke="black" d="M67.41,-290.8C67.41,-278.27 67.41,-262.57 67.41,-248.72"></path>
<polygon fill="black" stroke="black" points="70.91,-249.11 67.41,-239.11 63.91,-249.11 70.91,-249.11"></polygon>
<text text-anchor="middle" x="71.91" y="-259.85" font-family="FiraCode-Regular" font-size="14.00">b</text>
</g>
<!-- e->e -->
<g id="edge8">
<title>e-&gt;e</title>
<path fill="none" stroke="black" d="M94.07,-25.84C104.03,-27.59 113.41,-24.97 113.41,-18 113.41,-13.75 109.93,-11.12 104.95,-10.11"></path>
<polygon fill="black" stroke="black" points="105.06,-6.61 95.07,-10.16 105.09,-13.61 105.06,-6.61"></polygon>
<text text-anchor="middle" x="130.28" y="-13.32" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q2->q3 -->
<g id="edge5">
<title>q2-&gt;q3</title>
<path fill="none" stroke="black" d="M61.74,-190.6C58.52,-177.87 54.44,-161.71 50.85,-147.53"></path>
<polygon fill="black" stroke="black" points="54.08,-146.99 48.23,-138.15 47.29,-148.7 54.08,-146.99"></polygon>
<text text-anchor="middle" x="59.53" y="-158.9" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- q2->e -->
<g id="edge6">
<title>q2-&gt;e</title>
<path fill="none" stroke="black" d="M74.31,-190.88C82.98,-160.11 95.89,-102.73 88.41,-54 87.99,-51.25 87.39,-48.41 86.68,-45.6"></path>
<polygon fill="black" stroke="black" points="89.79,-44.74 83.61,-36.14 83.07,-46.72 89.79,-44.74"></polygon>
<text text-anchor="middle" x="101.28" y="-108.43" font-family="FiraCode-Regular" font-size="14.00">a|b</text>
</g>
</g>
</svg>

</p>

<p>Now, if we wanted to simply merge these two DFAs, we would have a problem: they both start with accepting <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>, so we would have to know beforehand which one to choose in order to accept a valid input. With NFA we can make some (even all!) of transitions non-deterministic, because we are checking <strong>if a path exists</strong>, and we don’t require that we will always walk it on valid input. So let’s say we have 2 valid choices from an initial state - with an empty string  <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span> go into the first machine or the second machine (yes, we can use the empty string as well!):</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="307pt" height="629pt" viewBox="0.00 0.00 307.00 628.53" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 624.53)">
<g id="clust1">
<title>cluster_astar</title>
<polygon fill="none" stroke="gray" points="8,-310.33 8,-499.17 122,-499.17 122,-310.33 8,-310.33"></polygon>
<text text-anchor="middle" x="65" y="-481.87" font-family="FiraCode-Regular" font-size="14.00" fill="gray">a*</text>
</g>
<g id="clust2">
<title>cluster_aba</title>
<polygon fill="none" stroke="gray" points="130,-8 130,-499.7 291,-499.7 291,-8 130,-8"></polygon>
<text text-anchor="middle" x="210.5" y="-482.4" font-family="FiraCode-Regular" font-size="14.00" fill="gray">aba</text>
</g>
<!-- qa -->
<g id="node1">
<title>qa</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="51" cy="-442.6" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="51" y="-437.93" font-family="FiraCode-Regular" font-size="14.00">qa</text>
</g>
<!-- qa->qa -->
<g id="edge3">
<title>qa-&gt;qa</title>
<path fill="none" stroke="black" d="M73.11,-451.88C83.36,-452.89 92.32,-449.8 92.32,-442.6 92.32,-438.22 89,-435.35 84.08,-434.02"></path>
<polygon fill="black" stroke="black" points="84.31,-430.46 74.11,-433.32 83.87,-437.45 84.31,-430.46"></polygon>
<text text-anchor="middle" x="96.45" y="-437.93" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e1 -->
<g id="node2">
<title>e1</title>
<ellipse fill="lightgrey" stroke="black" cx="39" cy="-341.65" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="39" y="-336.97" font-family="FiraCode-Regular" font-size="14.00">e1</text>
</g>
<!-- qa->e1 -->
<g id="edge4">
<title>qa-&gt;e1</title>
<path fill="none" stroke="black" d="M48.22,-418.65C46.68,-405.95 44.73,-389.93 43.03,-375.88"></path>
<polygon fill="black" stroke="black" points="46.41,-375.64 41.73,-366.13 39.46,-376.48 46.41,-375.64"></polygon>
<text text-anchor="middle" x="56.5" y="-387.45" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- e1->e1 -->
<g id="edge5">
<title>e1-&gt;e1</title>
<path fill="none" stroke="black" d="M60.69,-350.88C71.12,-352.02 80.32,-348.95 80.32,-341.65 80.32,-337.09 76.73,-334.18 71.48,-332.91"></path>
<polygon fill="black" stroke="black" points="71.84,-329.38 61.69,-332.42 71.51,-336.37 71.84,-329.38"></polygon>
<text text-anchor="middle" x="97.2" y="-336.97" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q0 -->
<g id="node3">
<title>q0</title>
<ellipse fill="lightgrey" stroke="black" cx="201" cy="-442.6" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="201" y="-437.93" font-family="FiraCode-Regular" font-size="14.00">q0</text>
</g>
<!-- q1 -->
<g id="node4">
<title>q1</title>
<ellipse fill="lightgrey" stroke="black" cx="201" cy="-341.65" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="201" y="-336.97" font-family="FiraCode-Regular" font-size="14.00">q1</text>
</g>
<!-- q0->q1 -->
<g id="edge6">
<title>q0-&gt;q1</title>
<path fill="none" stroke="black" d="M201,-418.4C201,-405.87 201,-390.17 201,-376.32"></path>
<polygon fill="black" stroke="black" points="204.5,-376.7 201,-366.7 197.5,-376.7 204.5,-376.7"></polygon>
<text text-anchor="middle" x="205.12" y="-387.45" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e2 -->
<g id="node7">
<title>e2</title>
<ellipse fill="lightgrey" stroke="black" cx="208" cy="-39.32" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="208" y="-34.65" font-family="FiraCode-Regular" font-size="14.00">e2</text>
</g>
<!-- q0->e2 -->
<g id="edge7">
<title>q0-&gt;e2</title>
<path fill="none" stroke="black" d="M211.87,-420.99C233.59,-377.38 279.19,-272.31 266,-181.6 259.26,-135.28 256.27,-122.84 236,-80.65 233.76,-76 231.02,-71.29 228.13,-66.81"></path>
<polygon fill="black" stroke="black" points="230.66,-65.31 222.12,-59.04 224.89,-69.27 230.66,-65.31"></polygon>
<text text-anchor="middle" x="278.5" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q2 -->
<g id="node5">
<title>q2</title>
<ellipse fill="lightgrey" stroke="black" cx="182" cy="-240.7" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="182" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">q2</text>
</g>
<!-- q1->q2 -->
<g id="edge8">
<title>q1-&gt;q2</title>
<path fill="none" stroke="black" d="M196.69,-318.2C194.23,-305.38 191.1,-289.08 188.36,-274.82"></path>
<polygon fill="black" stroke="black" points="191.68,-274.57 186.36,-265.41 184.81,-275.89 191.68,-274.57"></polygon>
<text text-anchor="middle" x="196.5" y="-286.5" font-family="FiraCode-Regular" font-size="14.00">b</text>
</g>
<!-- q1->e2 -->
<g id="edge9">
<title>q1-&gt;e2</title>
<path fill="none" stroke="black" d="M209.81,-319.2C225.12,-279.13 253.66,-190.25 239,-115.9 235.92,-100.27 229.57,-83.8 223.42,-70.24"></path>
<polygon fill="black" stroke="black" points="226.25,-69.04 218.81,-61.5 219.92,-72.03 226.25,-69.04"></polygon>
<text text-anchor="middle" x="252.12" y="-185.55" font-family="FiraCode-Regular" font-size="14.00">a|c</text>
</g>
<!-- q3 -->
<g id="node6">
<title>q3</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="162" cy="-139.75" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="162" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">q3</text>
</g>
<!-- q2->q3 -->
<g id="edge10">
<title>q2-&gt;q3</title>
<path fill="none" stroke="black" d="M177.46,-217.25C174.89,-204.52 171.62,-188.36 168.76,-174.17"></path>
<polygon fill="black" stroke="black" points="172.07,-173.91 166.66,-164.8 165.21,-175.3 172.07,-173.91"></polygon>
<text text-anchor="middle" x="177.12" y="-185.55" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- q2->e2 -->
<g id="edge11">
<title>q2-&gt;e2</title>
<path fill="none" stroke="black" d="M189.13,-217.9C197.75,-190.32 211.74,-141.19 217,-97.9 217.99,-89.75 217.45,-80.99 216.25,-72.81"></path>
<polygon fill="black" stroke="black" points="219.54,-72.35 214.28,-63.15 212.65,-73.62 219.54,-72.35"></polygon>
<text text-anchor="middle" x="224.5" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q3->e2 -->
<g id="edge12">
<title>q3-&gt;e2</title>
<path fill="none" stroke="black" d="M169.15,-115.97C172.87,-105.07 177.78,-91.96 183.25,-80.65 185.22,-76.57 187.49,-72.38 189.84,-68.32"></path>
<polygon fill="black" stroke="black" points="193.19,-70.53 195.36,-60.16 187.2,-66.92 193.19,-70.53"></polygon>
<text text-anchor="middle" x="199.88" y="-84.6" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- e2->e2 -->
<g id="edge13">
<title>e2-&gt;e2</title>
<path fill="none" stroke="black" d="M229.69,-48.46C240.12,-49.59 249.32,-46.54 249.32,-39.32 249.32,-34.81 245.73,-31.93 240.48,-30.68"></path>
<polygon fill="black" stroke="black" points="240.83,-27.15 230.69,-30.19 240.52,-34.14 240.83,-27.15"></polygon>
<text text-anchor="middle" x="266.2" y="-34.65" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q00 -->
<g id="node8">
<title>q00</title>
<ellipse fill="lightgrey" stroke="black" cx="125" cy="-573.11" rx="30.16" ry="30.16"></ellipse>
<text text-anchor="middle" x="125" y="-568.44" font-family="FiraCode-Regular" font-size="14.00">q00</text>
<text text-anchor="middle" x="56.59" y="-607.23" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- q00->qa -->
<g id="edge1">
<title>q00-&gt;qa</title>
<path fill="none" stroke="black" d="M110.2,-546.42C98,-525.23 80.7,-495.18 67.95,-473.03"></path>
<polygon fill="black" stroke="black" points="70.64,-471.69 62.61,-464.77 64.57,-475.18 70.64,-471.69"></polygon>
<text text-anchor="start" x="96" y="-511.65" font-family="FiraCode-Regular" font-size="14.00">ϵ</text>
</g>
<!-- q00->q0 -->
<g id="edge2">
<title>q00-&gt;q0</title>
<path fill="none" stroke="black" d="M140.02,-546.72C152.6,-525.44 170.58,-495.05 183.75,-472.77"></path>
<polygon fill="black" stroke="black" points="187.17,-474.86 189.25,-464.47 181.15,-471.29 187.17,-474.86"></polygon>
<text text-anchor="start" x="163" y="-511.65" font-family="FiraCode-Regular" font-size="14.00">ϵ</text>
</g>
</g>
</svg>

</p>

<p>(<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span>s were relabelled to distinct which one came from which automaton).</p>

<p>What would we have to do to make it deterministic? In this particular case, we can notice, that:</p>

<ul>
  <li>correct input is either empty or starts with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>,</li>
  <li>if it starts with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> what comes next is either a sequence of more <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>s or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ba</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ba</span></span></span></span>.</li>
</ul>

<p>Let’s modify our NFA for that observation:</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="395pt" height="556pt" viewBox="0.00 0.00 394.75 556.31" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 552.31)">
<g id="clust1">
<title>cluster_astar</title>
<polygon fill="none" stroke="gray" points="177,-108.42 177,-297.27 291,-297.27 291,-108.42 177,-108.42"></polygon>
<text text-anchor="middle" x="234" y="-279.97" font-family="FiraCode-Regular" font-size="14.00" fill="gray">a*</text>
</g>
<g id="clust2">
<title>cluster_aba</title>
<polygon fill="none" stroke="gray" points="8,-8 8,-540.31 169,-540.31 169,-8 8,-8"></polygon>
<text text-anchor="middle" x="88.5" y="-523.01" font-family="FiraCode-Regular" font-size="14.00" fill="gray">aba</text>
</g>
<!-- qa -->
<g id="node1">
<title>qa</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="213" cy="-240.7" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="213" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">qa</text>
</g>
<!-- qa->qa -->
<g id="edge6">
<title>qa-&gt;qa</title>
<path fill="none" stroke="black" d="M235.11,-249.98C245.36,-250.99 254.32,-247.9 254.32,-240.7 254.32,-236.31 251,-233.45 246.08,-232.12"></path>
<polygon fill="black" stroke="black" points="246.31,-228.56 236.11,-231.42 245.87,-235.55 246.31,-228.56"></polygon>
<text text-anchor="middle" x="258.45" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e1 -->
<g id="node2">
<title>e1</title>
<ellipse fill="lightgrey" stroke="black" cx="208" cy="-139.75" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="208" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">e1</text>
</g>
<!-- qa->e1 -->
<g id="edge7">
<title>qa-&gt;e1</title>
<path fill="none" stroke="black" d="M211.83,-216.5C211.19,-203.88 210.39,-188.05 209.69,-174.12"></path>
<polygon fill="black" stroke="black" points="213.15,-174.27 209.15,-164.46 206.16,-174.63 213.15,-174.27"></polygon>
<text text-anchor="middle" x="220.5" y="-185.55" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- e1->e1 -->
<g id="edge16">
<title>e1-&gt;e1</title>
<path fill="none" stroke="black" d="M229.69,-148.98C240.12,-150.12 249.32,-147.04 249.32,-139.75 249.32,-135.19 245.73,-132.28 240.48,-131.01"></path>
<polygon fill="black" stroke="black" points="240.84,-127.48 230.69,-130.52 240.51,-134.47 240.84,-127.48"></polygon>
<text text-anchor="middle" x="266.2" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q0 -->
<g id="node3">
<title>q0</title>
<ellipse fill="lightgrey" stroke="black" cx="61" cy="-483.21" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="61" y="-478.54" font-family="FiraCode-Regular" font-size="14.00">q0</text>
</g>
<!-- q1 -->
<g id="node4">
<title>q1</title>
<ellipse fill="lightgrey" stroke="black" cx="40" cy="-370.16" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="40" y="-365.49" font-family="FiraCode-Regular" font-size="14.00">q1</text>
</g>
<!-- q0->q1 -->
<g id="edge9">
<title>q0-&gt;q1</title>
<path fill="none" stroke="black" d="M56.7,-459.47C53.71,-443.68 49.68,-422.37 46.33,-404.64"></path>
<polygon fill="black" stroke="black" points="49.59,-404.05 44.29,-394.87 42.71,-405.35 49.59,-404.05"></polygon>
<text text-anchor="middle" x="56.12" y="-421.75" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e2 -->
<g id="node7">
<title>e2</title>
<ellipse fill="lightgrey" stroke="black" cx="57" cy="-39.32" rx="23.32" ry="23.32"></ellipse>
<text text-anchor="middle" x="57" y="-34.65" font-family="FiraCode-Regular" font-size="14.00">e2</text>
</g>
<!-- q0->e2 -->
<g id="edge10">
<title>q0-&gt;e2</title>
<path fill="none" stroke="black" d="M65.2,-459.57C68.04,-443.07 71.53,-420.13 73,-399.8 82.7,-265.81 64.01,-232.11 58,-97.9 57.65,-90.09 57.42,-81.69 57.27,-73.77"></path>
<polygon fill="black" stroke="black" points="60.76,-73.98 57.11,-64.03 53.76,-74.08 60.76,-73.98"></polygon>
<text text-anchor="middle" x="85.5" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q2 -->
<g id="node5">
<title>q2</title>
<ellipse fill="lightgrey" stroke="black" cx="136" cy="-240.7" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="136" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">q2</text>
</g>
<!-- q1->q2 -->
<g id="edge11">
<title>q1-&gt;q2</title>
<path fill="none" stroke="black" d="M54.82,-351.07C66.51,-336.67 83.09,-315.91 97,-297.27 103.59,-288.44 110.57,-278.64 116.78,-269.77"></path>
<polygon fill="black" stroke="black" points="120.09,-272.14 122.92,-261.93 114.34,-268.15 120.09,-272.14"></polygon>
<text text-anchor="middle" x="94.5" y="-309.22" font-family="FiraCode-Regular" font-size="14.00">b</text>
</g>
<!-- q1->e2 -->
<g id="edge12">
<title>q1-&gt;e2</title>
<path fill="none" stroke="black" d="M34.85,-346.51C24.57,-297.08 4.75,-176.31 32,-80.65 33.27,-76.19 35.19,-71.75 37.41,-67.52"></path>
<polygon fill="black" stroke="black" points="40.87,-69.55 42.98,-59.17 34.85,-65.97 40.87,-69.55"></polygon>
<text text-anchor="middle" x="29.12" y="-185.55" font-family="FiraCode-Regular" font-size="14.00">a|c</text>
</g>
<!-- q3 -->
<g id="node6">
<title>q3</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="137" cy="-139.75" rx="23.85" ry="23.85"></ellipse>
<text text-anchor="middle" x="137" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">q3</text>
</g>
<!-- q2->q3 -->
<g id="edge13">
<title>q2-&gt;q3</title>
<path fill="none" stroke="black" d="M136.23,-216.5C136.36,-204.27 136.51,-189.03 136.65,-175.43"></path>
<polygon fill="black" stroke="black" points="140.16,-175.53 136.76,-165.49 133.16,-175.45 140.16,-175.53"></polygon>
<text text-anchor="middle" x="141.12" y="-185.55" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- q2->e2 -->
<g id="edge14">
<title>q2-&gt;e2</title>
<path fill="none" stroke="black" d="M120.71,-222.17C108.69,-207.49 92.46,-185.47 83,-163.6 70.45,-134.57 63.78,-99 60.35,-73.55"></path>
<polygon fill="black" stroke="black" points="63.75,-73.45 59.04,-63.96 56.8,-74.32 63.75,-73.45"></polygon>
<text text-anchor="middle" x="93.5" y="-135.07" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q3->e2 -->
<g id="edge15">
<title>q3-&gt;e2</title>
<path fill="none" stroke="black" d="M121.95,-120.24C109.62,-105.06 92.01,-83.4 78.24,-66.46"></path>
<polygon fill="black" stroke="black" points="80.46,-64.64 71.44,-59.09 75.03,-69.06 80.46,-64.64"></polygon>
<text text-anchor="middle" x="118.88" y="-84.6" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- e2->e2 -->
<g id="edge17">
<title>e2-&gt;e2</title>
<path fill="none" stroke="black" d="M78.69,-48.46C89.12,-49.59 98.32,-46.54 98.32,-39.32 98.32,-34.81 94.73,-31.93 89.48,-30.68"></path>
<polygon fill="black" stroke="black" points="89.83,-27.15 79.69,-30.19 89.52,-34.14 89.83,-27.15"></polygon>
<text text-anchor="middle" x="115.2" y="-34.65" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
<!-- q00 -->
<g id="node8">
<title>q00</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="287" cy="-483.21" rx="30.16" ry="30.16"></ellipse>
<text text-anchor="middle" x="287" y="-478.54" font-family="FiraCode-Regular" font-size="14.00">q00</text>
<text text-anchor="middle" x="218.59" y="-517.33" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- q0a -->
<g id="node9">
<title>q0a</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="227" cy="-370.16" rx="29.64" ry="29.64"></ellipse>
<text text-anchor="middle" x="227" y="-365.49" font-family="FiraCode-Regular" font-size="14.00">q0a</text>
</g>
<!-- q00->q0a -->
<g id="edge1">
<title>q00-&gt;q0a</title>
<path fill="none" stroke="black" d="M272.63,-455.61C264.7,-440.95 254.76,-422.54 246.18,-406.67"></path>
<polygon fill="black" stroke="black" points="248.88,-405.29 241.05,-398.16 242.72,-408.62 248.88,-405.29"></polygon>
<text text-anchor="middle" x="264.12" y="-421.75" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- e -->
<g id="node10">
<title>e</title>
<ellipse fill="lightgrey" stroke="black" cx="317" cy="-240.7" rx="18" ry="18"></ellipse>
<text text-anchor="middle" x="317" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">e</text>
</g>
<!-- q00->e -->
<g id="edge2">
<title>q00-&gt;e</title>
<path fill="none" stroke="black" d="M290.68,-452.72C296.51,-405.99 307.79,-315.53 313.5,-269.73"></path>
<polygon fill="black" stroke="black" points="317.1,-270.2 314.86,-259.84 310.15,-269.33 317.1,-270.2"></polygon>
<text text-anchor="middle" x="314.5" y="-365.49" font-family="FiraCode-Regular" font-size="14.00">b|c</text>
</g>
<!-- q0a->qa -->
<g id="edge3">
<title>q0a-&gt;qa</title>
<path fill="none" stroke="black" d="M223.79,-339.92C221.69,-320.78 218.93,-295.71 216.73,-275.69"></path>
<polygon fill="black" stroke="black" points="220.12,-275.42 215.54,-265.86 213.16,-276.18 220.12,-275.42"></polygon>
<text text-anchor="middle" x="225.12" y="-309.22" font-family="FiraCode-Regular" font-size="14.00">a</text>
</g>
<!-- q0a->q2 -->
<g id="edge4">
<title>q0a-&gt;q2</title>
<path fill="none" stroke="black" d="M208.9,-345.77C198.25,-331.84 184.63,-313.71 173,-297.27 166.9,-288.66 160.46,-279.14 154.69,-270.45"></path>
<polygon fill="black" stroke="black" points="157.17,-268.85 148.75,-262.43 151.33,-272.71 157.17,-268.85"></polygon>
<text text-anchor="middle" x="195.5" y="-309.22" font-family="FiraCode-Regular" font-size="14.00">b</text>
</g>
<!-- q0a->e -->
<g id="edge5">
<title>q0a-&gt;e</title>
<path fill="none" stroke="black" d="M249.54,-349.57C264.04,-336.04 282.45,-316.98 295,-297.27 300.59,-288.5 305.18,-278.07 308.69,-268.63"></path>
<polygon fill="black" stroke="black" points="312.22,-270.13 312.19,-259.54 305.61,-267.84 312.22,-270.13"></polygon>
<text text-anchor="middle" x="291.75" y="-309.22" font-family="FiraCode-Regular" font-size="14.00">c</text>
</g>
<!-- e->e -->
<g id="edge8">
<title>e-&gt;e</title>
<path fill="none" stroke="black" d="M332.92,-249.41C343.15,-251.69 353,-248.78 353,-240.7 353,-235.65 349.15,-232.62 343.77,-231.61"></path>
<polygon fill="black" stroke="black" points="343.79,-228.14 333.92,-231.98 344.03,-235.14 343.79,-228.14"></polygon>
<text text-anchor="middle" x="369.88" y="-236.02" font-family="FiraCode-Regular" font-size="14.00">a|b|c</text>
</g>
</g>
</svg>

</p>

<p>Let us think for a moment what happened here. We now have a <strong>deterministic</strong> version of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>∗</mo></msup><mo>∣</mo><mi>a</mi><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a^* \mid aba</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span><span></span><span>∣</span><span></span></span><span><span></span><span>aba</span></span></span></span> expression! In order to remove non-determinism, we had to look ahead to determine which branch we should go with. That was achieved by introducing and using extra states - which could be mapped into a corresponding state in either of branches - until we received the first piece of information, that would make it clear, which branch we need to go from now on because the other is no longer an option:</p>

<ul>
  <li>if we just started we could assume that if nothing arrives we are OK,</li>
  <li>however if we got <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span>, there is uncertainty - should we expect following <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">a^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ba</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ba</span></span></span></span>, so we carry on the information that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> arrived and we will delay our decision,</li>
  <li>if nothing else arrives we are at valid input so we accept the state,</li>
  <li>if <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span> arrives we finally resolved ambiguity - from now on, we can simply go into a branch directly copy-pasted from the original DFA that created.</li>
</ul>

<p>Of course, this could be optimized a bit - states <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>e</span></span></span></span>,  <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>e</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>e</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> could be merged into one, while states <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">q_1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> are inaccessible so we can remove them. This way we would arrive at the final DFA.</p>

<p>The process, that we showed here is called <strong>determination of NFA</strong>. In practice, this tracing of things until we have enough data to finally decide, requires us to create a node for each combination of “it can go here” and “it can go there”, so we effectively end up <a href="https://en.wikipedia.org/wiki/Powerset_construction">building a powerset</a>. This means that in the worst case we would have to turn our <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>-state NFA into <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span> DFA before we even run optimizer! Once we’ve done that, testing if a string is accepted by the language is relatively cheap and requires going through the whole input once. This is an important observation, because using regular expressions is so simple nowadays, that we can forget that building a matcher is itself a costly operation (<strong>very costly</strong>).</p>

<p>That explains, why in older generations of compilers the proffered flow was to <a href="https://www.gnu.org/software/flex/">generate source code with already build DFA</a> which could be compiled into a native code, that didn’t require any building in the runtime - you paid the cost of building DFA once before you even started the compilation of a program.</p>

<p>However, it is not the most comfortable flow, especially, since now we have a bit faster computers and a bit higher requirements about the speed of delivery and software maintenance. For that reason, we have 2 alternatives: <a href="https://swtch.com/~rsc/regexp/regexp1.html">one based on a lazy evaluation</a> - you build the required pieces of DFA lazily as you go through the parsed input, or with the usage of backtracking. The former is done by simulating NFA internally and building DFA states on demand. The later is probably the easiest way to implement regular expression, though the resulting implementation is no longer <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Θ</span><span>(</span><span>n</span><span>)</span></span></span></span> but <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span><span>2</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span></span></span></span></span><span>)</span></span></span></span>. (Confusingly, the algorithm is called NFA, though the implementation is not a finite-state automaton at all).</p>

<h3 id="regular-expressions-in-practice">Regular expressions in practice</h3>

<p>The format(s) used to describe regular expressions are directly taken from, how regular languages are defined: each symbol normally represents itself (so regexp <code>a</code> would match <code>a</code>), <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∗</span></span></span></span>/<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> after an expression represent Kleenie star/plus (0 or more, 1 or more repetitions of an input - <code>a*</code> would match empty string, <code>a</code>, <code>aa</code>, …), concatenation of expressions represents concatenated language (<code>aa</code> would match <code>aa</code>, <code>a+b</code> would match <code>ab</code>, <code>aab</code>, …). Or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span></span></span></span> or a sum of regular languages is represented by <code>|</code> (<code>a|b</code> matches <code>a</code>, <code>b</code>).  Parenthesis can be used to clarify in which order regular expression are concatenated (<code>ab+</code> means <code>(ab)+</code>, so if we wanted <code>a(b+)</code> the parenthesis helps us achieve what we want). There are also some utilities like <code>[abc]</code> which translates to <code>(a|b|c)</code> and allows us to use ranges instead of listing all characters manually (e.g. <code>[a-z]</code> represents <code>(a|b|c|...|z)</code>), <code>?</code> which means zero or one occurrence (<code>a?</code> is the same as<code>(|a)</code>) or predefined sets of symbols like <code>\s</code> (whitespace character), <code>\S</code> (non-whitespace character) and so on. For details, you can always consult the manual for the particular implementation that you are using.</p>

<p>If you are interested about the process of implementing regular expressions and building finite state machines out of the regexp format I recommend getting a book like <em>Compilers: Principles, Techniques, and Tools</em> by Aho, Lam, Sethi, and Ullman. There are too many details about implementations which aren’t interesting to the majority of the readers to justify rewriting and shortening them just so they would fit into this short article.</p>

<p>Since we got familiar with RE, we can try out a bit more powerful category of languages.</p>

<h2 id="context-free-grammars-and-push-down-automata">Context-Free Grammars and Push-Down Automata</h2>

<p>Any finite state machine can store a constant amount of information - namely the current state, which is a single element of a set of values defined upfront. It doesn’t let us dynamically store some additional data for the future and then retrieve data stored somewhere in the past.</p>

<p>An example of a problem, that could be solved, if we had this ability is checking if a word is a <em>palindrome</em>, that is you read it the same way left-to-right and right-to-left. <em>Anna</em>, <em>exe</em>, <em>yay</em> would be palindromes (assuming case doesn’t matter). <em>Anne</em>, <em>axe</em>, <em>ay-ay</em> would not be. If we wanted to check for some specific palindrome, we could use a finite state machine. But if we wanted to check for any? <em>A</em>. <em>Aba</em>.  <em>Ab(5-million b’s)c(5-million b’s)ba</em>. No matter what kind of FSA we came up with is easy to find a word that it would not match, but which is a valid palindrome.</p>

<p>But let’s say, we are a bit more flexible than finite state automaton. What kind of information would be helpful in deciding if we are on the right track? We could, for instance, write each letter on a piece of paper, e.g. sticky notes. We met <em>a</em>, we write down <em>a</em> and stick it to someplace. Then, we see <em>b</em>, we write it down and stick it on top of a previous sticky note. Now, let’s go non-deterministic. It some point if we see the same letter arriving as we see on the top of the sticky notes stack, we don’t add a new one, but take the top one instead - we are <em>guessing</em>, that we are in the middle of a palindrome. Then each time top note patches with an incoming letter you take it off. If you had an even-length palindrome you should end up with an empty stack. Well, we would have to think a bit more to handle the odd-length case as well, but hey! We are on the right track as the length of the word is no longer an issue!</p>

<p>What helped us get there? We had a state-machine of sorts with 2 states: <em>insert-card-mode</em> (push) and <em>take-matching-card-mode</em> (pop) (for odd-length palindrome we could use a third state for skipping over one letter - the middle one - without pushing and popping anything). Then we had a <strong>stack</strong> that we can push things on top, take a look at the top element, and take an element from the top. Actually, this data structure (which could be also thought of as a <em>last-in-first-out queue</em>) is <strong>really named stack</strong>. In combination with finite state automaton, it creates <strong>push-down automaton</strong> (<strong>PDA</strong>).</p>

<p>As a matter of the fact, what we defined for our palindrome problem is an example of <strong>non-deterministic push-down automaton</strong>. We could define deterministic PDAs (DPDA) as a 7-tuple <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>Z</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Q, \Sigma, \Gamma, \delta, q_0, Z, F)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>Q</span><span>,</span><span></span><span>Σ</span><span>,</span><span></span><span>Γ</span><span>,</span><span></span><span>δ</span><span>,</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>Z</span><span>,</span><span></span><span>F</span><span>)</span></span></span></span>, where:</p>

<ul>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Q</span></span></span></span> is a finite set of <strong>states</strong>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span></span></span></span> is a finite set of <strong>input symbols</strong> or an <strong>input alphabet</strong>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Γ</span></span></span></span> is a finite set of <strong>stack symbols</strong> or a <strong>stack alphabet</strong> (because we can use different sets for input and stack, e.g. the later could be a superset of the former),</li>
  <li>a <strong>transition function</strong> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>→</mo><mi>Q</mi><mo>×</mo><msup><mi mathvariant="normal">Γ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \times \Gamma \rightarrow Q \times \Gamma^*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>δ</span><span></span><span>:</span><span></span></span><span><span></span><span>Q</span><span></span><span>×</span><span></span></span><span><span></span><span>Σ</span><span></span><span>×</span><span></span></span><span><span></span><span>Γ</span><span></span><span>→</span><span></span></span><span><span></span><span>Q</span><span></span><span>×</span><span></span></span><span><span></span><span><span>Γ</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span></span></span></span></span></span></span></span>, which would take the current state, the top (popped) stack symbol and next input symbol (possibly empty) to return the next state and what to push to stack (which can be represented as a word made of a stack alphabet) ,</li>
  <li>an <strong>initial state</strong> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∈</span><span></span></span><span><span></span><span>Q</span></span></span></span>,</li>
  <li>an initial stack symbol <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>∈</mo><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">Z \in \Gamma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Z</span><span></span><span>∈</span><span></span></span><span><span></span><span>Γ</span></span></span></span>,</li>
  <li>a set of accepting states <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>F</span><span></span><span>⊆</span><span></span></span><span><span></span><span>Q</span></span></span></span>.</li>
</ul>

<p>A non-deterministic version (NDPDA) would allow <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ϵ</span></span></span></span> as a valid symbol in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span></span></span></span>, and return several possible values in transition function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>δ</span></span></span></span> instead of one.</p>

<p>The palindrome example showed us that there are problems that PDA can solve that FSA cannot. However, PDA can solve all problems that FSA - all you need to do is basically ignore the stack in your transition function, and you get the FSA. Therefore, <strong>push-down automata are a strict superset of finite-state automata</strong>.</p>

<p>But we were supposed to talk about formal languages. Just like finite-state machines are related to regular languages, pushdown automata are related to <strong>context-free grammars</strong>. Reminder: it’s a formal language where all production rules are in the form of:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \gamma</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>→</span><span></span></span><span><span></span><span>γ</span></span></span></span></span>

<p>where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A \in N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span> (non-terminals) and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\gamma \in (N \cup \Sigma)^+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>γ</span><span></span><span>∈</span><span></span></span><span><span></span><span>(</span><span>N</span><span></span><span>∪</span><span></span></span><span><span></span><span>Σ</span><span><span>)</span><span><span><span><span><span><span></span><span><span>+</span></span></span></span></span></span></span></span></span></span></span> (non-terminals and terminals). Another reminder: with CFG we are parsing structures, that are basically trees (in case of programming languages, where this tree represent the language’s syntax it’s called <strong>abstract syntax tree</strong>), and terminals are these parts of the syntax which are leaves of the tree, while non-terminals are nodes. The names come from the fact, that when you expand the tree according to production rules, you have to end up with terminals in all leaves. They are <em>the ends</em> of the tree.</p>

<p>Thing is, when we are parsing, we are actually given a sequence of terminals, and we must combine them into non-terminals until we get to the root of the project. Kind of opposite to what we are given in language description. How could that look like? Let’s do some motivating example.</p>

<p>Normally when we describe the order of arithmetic operations like <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>−</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>×</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>÷</span></span></span></span> we are inserting them in-between numbers. Because operations have priorities (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>×</span></span></span></span>/<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>÷</span></span></span></span> before <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span>/<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>−</span></span></span></span>) if we want to change the default order we have to use parenthesis (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 + 2 \times 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span>+</span><span></span></span><span><span></span><span>2</span><span></span><span>×</span><span></span></span><span><span></span><span>2</span></span></span></span> vs <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(2 + 2) \times 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>2</span><span></span><span>+</span><span></span></span><span><span></span><span>2</span><span>)</span><span></span><span>×</span><span></span></span><span><span></span><span>2</span></span></span></span>). This is called <strong>infix notation</strong> as the operator is between operands. But, you could use alternative notations: one where operator is before operands (<strong>prefix notation</strong> aka <a href="https://en.wikipedia.org/wiki/Polish_notation"><strong>Polish notation</strong></a>) or after operands (<strong>postfix notation</strong> aka <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation"><strong>Reverse Polish notation</strong>/<strong>RPN</strong></a>). Both of them doesn’t require usage of parenthesis, as the order of operation is unambiguous due to their position. The later is quite useful when you are working with compilers.</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + 2) \times (3 + 4)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>1</span><span></span><span>+</span><span></span></span><span><span></span><span>2</span><span>)</span><span></span><span>×</span><span></span></span><span><span></span><span>(</span><span>3</span><span></span><span>+</span><span></span></span><span><span></span><span>4</span><span>)</span></span></span></span></span>

<p>becomes</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mo>+</mo><mtext> </mtext><mo>×</mo></mrow><annotation encoding="application/x-tex">1\ 2\ +\ 3\ 4\ +\ \times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span> </span><span>2</span><span> </span><span></span><span>+</span><span> </span><span></span></span><span><span></span><span>3</span><span> </span><span>4</span><span> </span><span></span><span>+</span><span> </span><span></span></span><span><span></span><span>×</span></span></span></span></span>

<p>When it comes to calculating the value of such expression, we can use stack:</p>

<ul>
  <li>we start with an empty stack,</li>
  <li>when we see the number, we push it to the stack,</li>
  <li>when we see <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> we take the top 2 elements on the stack, we add them and we push the result to the stack,</li>
  <li>same with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>×</span></span></span></span>, take 2 top elements from the stack, multiply them and push the result to the stack,</li>
  <li>at the end the result of our calculation would be on top of a stack.</li>
</ul>

<p>Let’s check for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mo>+</mo><mtext> </mtext><mo>×</mo></mrow><annotation encoding="application/x-tex">1\ 2\ +\ 3\ 4\ +\ \times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span> </span><span>2</span><span> </span><span></span><span>+</span><span> </span><span></span></span><span><span></span><span>3</span><span> </span><span>4</span><span> </span><span></span><span>+</span><span> </span><span></span></span><span><span></span><span>×</span></span></span></span>:</p>

<ul>
  <li>we start with an empty stack,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> arrives, we push it to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span> arrives, we push it to the stack,</li>
  <li>stack is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">1\ 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span> </span><span>2</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> arrives, we take 2 top elements from the stack (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">1\ 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span> </span><span>2</span></span></span></span>), add them (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>) and push the result to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span> arrives, we push it to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext> </mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">3\ 3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span> </span><span>3</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>4</span></span></span></span> arrives, we push it to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn></mrow><annotation encoding="application/x-tex">3\ 3\ 4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span> </span><span>3</span><span> </span><span>4</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span> arrives, we take 2 top elements from the stack (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext> </mtext><mn>4</mn></mrow><annotation encoding="application/x-tex">3\ 4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span> </span><span>4</span></span></span></span>), add them (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span>) and push the result to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext> </mtext><mn>7</mn></mrow><annotation encoding="application/x-tex">3\ 7</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span> </span><span>7</span></span></span></span>,</li>
  <li><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>×</span></span></span></span> arrives, we take 2 top elements from the stack (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext> </mtext><mn>7</mn></mrow><annotation encoding="application/x-tex">3\ 7</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span> </span><span>7</span></span></span></span>), multiply them (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>21</span></span></span></span>) and push the result to the stack,</li>
  <li>stack is: <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>21</span></span></span></span>,</li>
  <li>input ends, so our result is the only number on stack (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>21</span></span></span></span>).</li>
</ul>

<p>If you ever wrote (or will write) a compiler, that outputs assembler or bytecode, or something similar low-level - that’s basically how you write down expressions. If there is an expression in an infix form, you translate it into postfix, as it pretty much aligns with how mnemonics works in many architectures.</p>

<blockquote>
  <p>To be precise, quite a lot of them would require you to have the added/multiplied/etc values in registers instead of stack, however to implement a whole expression you probably use stack and copy data from stack to registers and vice-versa, but is an implementation detail irrelevant to what we want to show here.</p>
</blockquote>

<p>Of course, the example above is not a valid grammar. We cannot have a potentially infinite number of non-terminals (numbers) and production rules (basically all results of addition/multiplication/etc). But we can describe the general idea of postfix arithmetics:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>→</mo><mo>+</mo><mo>∣</mo><mo>−</mo><mo>∣</mo><mo>×</mo><mo>∣</mo><mo>÷</mo></mrow><annotation encoding="application/x-tex">BinaryOperator \rightarrow + \mid - \mid \times \mid \div</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span>ina</span><span>ry</span><span>Op</span><span>er</span><span>a</span><span>t</span><span>or</span><span></span><span>→</span><span></span></span><span><span></span><span>+</span><span></span><span>∣</span><span></span></span><span><span></span><span>−</span><span></span><span>∣</span><span></span></span><span><span></span><span>×</span><span></span><span>∣</span><span></span></span><span><span></span><span>÷</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>→</mo><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>B</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Expression \rightarrow Number | Expression\ Expression\ BinaryOperator</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span></span><span>→</span><span></span></span><span><span></span><span>N</span><span>u</span><span>mb</span><span>er</span><span>∣</span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span> </span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span> </span><span>B</span><span>ina</span><span>ry</span><span>Op</span><span>er</span><span>a</span><span>t</span><span>or</span></span></span></span></span>

<p>We have terminals <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo separator="true">,</mo><mo>+</mo><mo separator="true">,</mo><mo>−</mo><mo separator="true">,</mo><mo>×</mo><mo separator="true">,</mo><mo>÷</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{ Number, +, -, \times, \div \}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Σ</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>N</span><span>u</span><span>mb</span><span>er</span><span>,</span><span></span><span>+</span><span>,</span><span></span><span>−</span><span>,</span><span></span><span>×</span><span>,</span><span></span><span>÷</span><span>}</span></span></span></span> and non-terminals <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">{</mo><mi>B</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">N = \{BinaryOperator, Expression\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>B</span><span>ina</span><span>ry</span><span>Op</span><span>er</span><span>a</span><span>t</span><span>or</span><span>,</span><span></span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span>}</span></span></span></span>. We could create an ADT:</p>

<div><div><pre><code><span>sealed</span> <span>trait</span> <span>Terminal</span>

<span>final</span> <span>case</span> <span>class</span> <span>Number</span><span>(</span><span>value</span><span>:</span> <span>java.lang.Number</span><span>)</span>
    <span>extends</span> <span>Terminal</span>

<span>sealed</span> <span>trait</span> <span>BinaryOperator</span>
<span>case</span> <span>object</span> <span>Plus</span> <span>extends</span> <span>BinaryOperator</span> <span>with</span> <span>Terminal</span>
<span>case</span> <span>object</span> <span>Minus</span> <span>extends</span> <span>BinaryOperator</span> <span>with</span> <span>Terminal</span>
<span>case</span> <span>object</span> <span>Times</span> <span>extends</span> <span>BinaryOperator</span> <span>with</span> <span>Terminal</span>
<span>case</span> <span>object</span> <span>Div</span> <span>extends</span> <span>BinaryOperator</span> <span>with</span> <span>Terminal</span>

<span>sealed</span> <span>trait</span> <span>Expression</span>
<span>final</span> <span>case</span> <span>class</span> <span>FromNumber</span><span>(</span><span>number</span><span>:</span> <span>Number</span><span>)</span> <span>extends</span> <span>Expression</span>
<span>final</span> <span>case</span> <span>class</span> <span>FromBinary</span><span>(</span><span>operand1</span><span>:</span> <span>Expression</span><span>,</span>
                            <span>operand2</span><span>:</span> <span>Expression</span><span>,</span>
                            <span>bin</span><span>:</span> <span>BinaryOperator</span><span>)</span>
    <span>extends</span> <span>Expression</span>
</code></pre></div></div>

<p>and now it should be possible to somehow translate <code>List[Terminal]</code> into <code>Expression</code>. (Assuming the input is a correct example of this grammar - if it isn’t we should fail). In this very simple example, it could actually be done in a similar way we evaluated the expression:</p>

<ul>
  <li>if <code>Terminal</code> is <code>Number</code>, wrap it with <code>FromNumber</code> push it to the stack,</li>
  <li>if <code>Terminal</code> is <code>BinaryOperation,</code> we take 2 <code>Expression</code>s from the stack, put it as <code>operand1</code> and <code>operand2</code>, and together with <code>BinaryOperator</code> put it into <code>FromBinary</code> and push to stack,</li>
  <li>if the input is correct, we should end up with a stack with a single element,</li>
  <li>if the input is incorrect, we should end up with a stack with more than one element, or during one of the operations we will miss some <code>Expression</code>s while popping on a stack.</li>
</ul>

<p>It is <em>almost</em> enough to represent our language as PDA. To create a binary operation we look at the two elements on top of the stack, while it is legal to only know one. But we could, represent that as a state. Initial stack symbol could be a single <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>y</mi><mi>S</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">EmptyStack</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span>m</span><span>pt</span><span>y</span><span>St</span><span>a</span><span>c</span><span>k</span></span></span></span>. Actually, we could also make sure that we end up with an empty stack at the end - if there are elements on stack, it’s an error (becasue no operator consumed some elements). If at some point we are missing some elements it’s also an error. We could end up with something like:</p>

<p>
  <!-- Generated by graphviz version 8.0.5 (20230430.1635)
 -->
<!-- Pages: 1 -->
<svg width="1179pt" height="1013pt" viewBox="0.00 0.00 1179.21 1012.91" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 1008.91)">
<!-- CheckingMode -->
<g id="node1">
<title>CheckingMode</title>
<ellipse fill="lightgrey" stroke="black" stroke-width="2" cx="330.46" cy="-309.93" rx="82.77" ry="82.77"></ellipse>
<text text-anchor="middle" x="330.46" y="-305.25" font-family="FiraCode-Regular" font-size="14.00">CheckingMode</text>
</g>
<!-- Error -->
<g id="node5">
<title>Error</title>
<ellipse fill="lightgrey" stroke="black" cx="477.46" cy="-34.9" rx="34.9" ry="34.9"></ellipse>
<text text-anchor="middle" x="477.46" y="-30.22" font-family="FiraCode-Regular" font-size="14.00">Error</text>
</g>
<!-- CheckingMode->Error -->
<g id="edge8">
<title>CheckingMode-&gt;Error</title>
<path fill="none" stroke="black" d="M248.54,-293.55C132.78,-268.29 -56.81,-211.78 16.71,-123.05 69.14,-59.77 325.44,-42.1 431.44,-37.45"></path>
<polygon fill="black" stroke="black" points="431.56,-40.91 441.41,-36.99 431.27,-33.91 431.56,-40.91"></polygon>
<text text-anchor="start" x="17.46" y="-143.8" font-family="FiraCode-Regular" font-size="14.00">Number|+|-|×|÷, pop: x, push: x</text>
</g>
<!-- CheckingMode->Error -->
<g id="edge9">
<title>CheckingMode-&gt;Error</title>
<path fill="none" stroke="black" d="M284.68,-240.3C266.16,-203.29 253.94,-158.15 276.96,-123.05 311.13,-70.93 383.96,-49.81 431.79,-41.37"></path>
<polygon fill="black" stroke="black" points="432.18,-44.69 441.48,-39.62 431.05,-37.79 432.18,-44.69"></polygon>
<text text-anchor="start" x="277.46" y="-143.8" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: Number, push: Number</text>
</g>
<!-- OK -->
<g id="node6">
<title>OK</title>
<ellipse fill="lightgrey" stroke="black" cx="528.46" cy="-148.48" rx="25.43" ry="25.43"></ellipse>
<text text-anchor="middle" x="528.46" y="-143.8" font-family="FiraCode-Regular" font-size="14.00">OK</text>
</g>
<!-- CheckingMode->OK -->
<g id="edge10">
<title>CheckingMode-&gt;OK</title>
<path fill="none" stroke="black" d="M395.02,-256.94C430.86,-228.07 473.59,-193.66 500.86,-171.7"></path>
<polygon fill="black" stroke="black" points="502.55,-174.03 508.15,-165.03 498.16,-168.57 502.55,-174.03"></polygon>
<text text-anchor="start" x="475.46" y="-195.85" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: EmptyStack, push: EmptyStack</text>
</g>
<!-- PushSymbol -->
<g id="node2">
<title>PushSymbol</title>
<ellipse fill="lightgrey" stroke="black" cx="516.46" cy="-517.15" rx="71.2" ry="71.2"></ellipse>
<text text-anchor="middle" x="516.46" y="-512.48" font-family="FiraCode-Regular" font-size="14.00">PushSymbol</text>
<text text-anchor="middle" x="407.01" y="-592.3" font-family="FiraCode-Regular" font-size="14.00">initial state</text>
</g>
<!-- PushSymbol->CheckingMode -->
<g id="edge3">
<title>PushSymbol-&gt;CheckingMode</title>
<path fill="none" stroke="black" d="M469.04,-463.84C446.02,-438.44 418.05,-407.57 393.28,-380.24"></path>
<polygon fill="black" stroke="black" points="396.35,-378.32 387.05,-373.26 391.17,-383.02 396.35,-378.32"></polygon>
<text text-anchor="start" x="435.46" y="-414.65" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: x, push: x</text>
</g>
<!-- PushSymbol->PushSymbol -->
<g id="edge1">
<title>PushSymbol-&gt;PushSymbol</title>
<path fill="none" stroke="black" d="M586.02,-534.2C597.64,-531.82 605.66,-526.13 605.66,-517.15 605.66,-511.12 602.04,-506.58 596.14,-503.52"></path>
<polygon fill="black" stroke="black" points="597.61,-499.99 587.02,-500.11 595.38,-506.62 597.61,-499.99"></polygon>
<text text-anchor="middle" x="724.53" y="-512.48" font-family="FiraCode-Regular" font-size="14.00">Number, pop: x, push: x+Number</text>
</g>
<!-- Pop2Numbers -->
<g id="node3">
<title>Pop2Numbers</title>
<ellipse fill="lightgrey" stroke="black" cx="848.46" cy="-924.76" rx="80.14" ry="80.14"></ellipse>
<text text-anchor="middle" x="848.46" y="-920.09" font-family="FiraCode-Regular" font-size="14.00">Pop2Numbers</text>
</g>
<!-- PushSymbol->Pop2Numbers -->
<g id="edge2">
<title>PushSymbol-&gt;Pop2Numbers</title>
<path fill="none" stroke="black" d="M521.86,-588.6C529.72,-648.38 549.03,-733.43 596.46,-791.37 638.82,-843.12 706.81,-877.16 761.5,-897.74"></path>
<polygon fill="black" stroke="black" points="759.96,-901.27 770.55,-901.43 762.37,-894.7 759.96,-901.27"></polygon>
<text text-anchor="start" x="596.46" y="-711.81" font-family="FiraCode-Regular" font-size="14.00">+|-|×|÷, pop: x, push: x</text>
</g>
<!-- Pop1Number -->
<g id="node4">
<title>Pop1Number</title>
<ellipse fill="lightgrey" stroke="black" cx="848.46" cy="-716.49" rx="74.88" ry="74.88"></ellipse>
<text text-anchor="middle" x="848.46" y="-711.81" font-family="FiraCode-Regular" font-size="14.00">Pop1Number</text>
</g>
<!-- Pop2Numbers->Pop1Number -->
<g id="edge4">
<title>Pop2Numbers-&gt;Pop1Number</title>
<path fill="none" stroke="black" d="M848.46,-844.31C848.46,-830.69 848.46,-816.5 848.46,-802.74"></path>
<polygon fill="black" stroke="black" points="851.96,-802.83 848.46,-792.83 844.96,-802.83 851.96,-802.83"></polygon>
<text text-anchor="start" x="848.46" y="-813.32" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: Number</text>
</g>
<!-- Pop2Numbers->Error -->
<g id="edge5">
<title>Pop2Numbers-&gt;Error</title>
<path fill="none" stroke="black" d="M918.09,-884.25C971.26,-848.35 1035.46,-789.99 1035.46,-717.49 1035.46,-717.49 1035.46,-717.49 1035.46,-147.48 1035.46,-43.34 657.02,-35.05 523.46,-35.37"></path>
<polygon fill="black" stroke="black" points="523.77,-31.87 513.79,-35.41 523.8,-38.87 523.77,-31.87"></polygon>
<text text-anchor="start" x="1035.46" y="-414.65" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: EmptyStack</text>
</g>
<!-- Pop1Number->PushSymbol -->
<g id="edge6">
<title>Pop1Number-&gt;PushSymbol</title>
<path fill="none" stroke="black" d="M784.44,-677.44C727.75,-643.74 645.13,-594.63 586.64,-559.87"></path>
<polygon fill="black" stroke="black" points="588.86,-556.52 578.47,-554.42 585.28,-562.54 588.86,-556.52"></polygon>
<text text-anchor="start" x="691.46" y="-610.3" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: Number</text>
</g>
<!-- Pop1Number->Error -->
<g id="edge7">
<title>Pop1Number-&gt;Error</title>
<path fill="none" stroke="black" d="M861.03,-642.63C866.4,-605.49 871.46,-559.54 871.46,-518.15 871.46,-518.15 871.46,-518.15 871.46,-147.48 871.46,-120.23 877.61,-106.13 857.46,-87.8 809.4,-44.09 613.86,-36.86 523.57,-35.89"></path>
<polygon fill="black" stroke="black" points="523.86,-32.39 513.83,-35.8 523.8,-39.39 523.86,-32.39"></polygon>
<text text-anchor="start" x="871.46" y="-305.25" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: EmptyStack</text>
</g>
<!-- Error->Error -->
<g id="edge13">
<title>Error-&gt;Error</title>
<path fill="none" stroke="black" d="M510.78,-46.43C521.68,-46.37 530.36,-42.53 530.36,-34.9 530.36,-30.01 526.79,-26.68 521.37,-24.89"></path>
<polygon fill="black" stroke="black" points="522.17,-21.33 511.78,-23.36 521.17,-28.26 522.17,-21.33"></polygon>
<text text-anchor="start" x="530.36" y="-30.22" font-family="FiraCode-Regular" font-size="14.00">Number|+|-|×|÷, pop: x, push: x</text>
</g>
<!-- OK->Error -->
<g id="edge12">
<title>OK-&gt;Error</title>
<path fill="none" stroke="black" d="M506.44,-134.88C496.01,-127.62 484.57,-117.47 478.71,-105.05 475.18,-97.57 473.45,-89.12 472.82,-80.75"></path>
<polygon fill="black" stroke="black" points="476.3,-80.81 472.56,-70.89 469.3,-80.98 476.3,-80.81"></polygon>
<text text-anchor="start" x="479.46" y="-91.75" font-family="FiraCode-Regular" font-size="14.00">Number|+|-|×|÷, pop: EmptyStack, push: EmptyStack</text>
</g>
<!-- OK->OK -->
<g id="edge11">
<title>OK-&gt;OK</title>
<path fill="none" stroke="black" d="M552.13,-158.08C562.72,-159 571.89,-155.8 571.89,-148.48 571.89,-143.9 568.31,-140.93 563.04,-139.58"></path>
<polygon fill="black" stroke="black" points="563.34,-136.02 553.13,-138.87 562.89,-143.01 563.34,-136.02"></polygon>
<text text-anchor="start" x="571.89" y="-143.8" font-family="FiraCode-Regular" font-size="14.00">ϵ, pop: EmptyStack, push: EmptyStack</text>
</g>
</g>
</svg>

</p>

<p>This PDA doesn’t calculate the value of RPN. It only checks if it is valid. We are pushing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Number</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span><span>u</span><span>mb</span><span>er</span></span></span></span>s on a stack, and on a binary operation, we consume 2 <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Number</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span><span>u</span><span>mb</span><span>er</span></span></span></span>s from the stack. At any point we can start “checking” - if we are at the end of input, a stack is empty (meaning that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>y</mi><mi>S</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">EmptyStack</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span>m</span><span>pt</span><span>y</span><span>St</span><span>a</span><span>c</span><span>k</span></span></span></span> is the top element) we can assume that the input was correct so we move to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">OK</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>K</span></span></span></span> through <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>M</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">CheckingMode</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>C</span><span>h</span><span>ec</span><span>kin</span><span>g</span><span>M</span><span>o</span><span>d</span><span>e</span></span></span></span>. However, if we start checking and there is some input left or there are elements on the stack - we are erring.</p>

<p>To make sure we understand what happened here we should remember that this is non-deterministic PDA - so for each valid input there <em>should exist</em> a valid path (and each path ending in an accepted state should describe a valid input), but we don’t have to necessarily walk it each time. The other thing is that on each step of PDA we have to pop from stack - if we don’t want to change stack we have to pop the same element back, if we want to add something we can pop 2 elements or more and if we want to get rid of top elements, then we simply don’t pop it back.</p>

<h3 id="parsers-in-practice">Parsers in practice</h3>

<p>Actually, there are 2 approaches to parsing context-free grammars:</p>

<ul>
  <li><strong>top-down</strong> approach: We start from the root of the AST tree and take a look at the possible transitions. We try to make a prediction - if we get the next alphabet element, do we know, which transition to go? If that is not enough you could try to look at transitions going from these transitions and check if any prediction is possible to do know, etc. We don’t necessarily look <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> symbol ahead to determine our path - we could set some <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> and assume that we can look up to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> symbols ahead before making a decision (which would be potentially reflected in the number of states). If our language contains recursion it might affect how we can and what is the minimal number of lookahead to decide. We are parsing input <strong>left-to-right</strong>, and the top-down strategy with lookahead will make us choose branch basing on <strong>leftmost</strong> non-terminal. That is why this approach is called <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> (left-to-right, leftmost derivation). The <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> parser with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> tokens lookahead is called <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span><span>(</span><span>k</span><span>)</span></span></span></span>,</li>
  <li><strong>bottom-up</strong> approach: We start with terminals and look at the production rules in reverse - we try to combine incoming terminals into terminals and then terminals and non-terminals until we get to the root. (This is what we have done in the PDA example above). Just like with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> we might need to make some predictions so we can look ahead of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> elements. Just like with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> we read <strong>left-to-right</strong>. However, <em>contrary</em> to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> we can make a decision when we get <em>the last element</em> of a production rule, <strong>rightmost</strong> non-terminal. This is why this approach is called <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">LR</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span></span></span></span> and if our parser requires <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> tokens lookahead it is an example of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span><span>(</span><span>k</span><span>)</span></span></span></span> parser. For <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> we can use some specific, simple implementation like <em>Simple LR</em> (<em>SLR</em>). There is also general implementation of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span><span>(</span><span>k</span><span>)</span></span></span></span> called <em>look-ahead <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span><span>(</span><span>k</span><span>)</span></span></span></span></em> (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>A</mi><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LALR(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>A</span><span>L</span><span>R</span><span>(</span><span>k</span><span>)</span></span></span></span>) which, for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> are called simply <em>LALR</em>.</li>
</ul>

<p>Both approaches are usually used to build a parsing table, though they differ in how you arrive at the final table.</p>

<p>With <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span><span>(</span><span>k</span><span>)</span></span></span></span> you can pretend that you can look ahead <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> chars while simply applying production rules - that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>-symbol lookahead is simulated by adding additional states. When we simulate seeing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>th symbol ahead, we are actually already at this symbol, but with state transitions arranged, so that we end up in a state that we should end up if we really were <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> symbols ago and made the decision based on a prediction. Notice, that for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> this basically means that we are always following first matching production rule and never going back, which results in a quite simple parser.</p>

<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(k)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span><span>(</span><span>k</span><span>)</span></span></span></span>, on the other hand, uses things called <strong>shift</strong> and <strong>reduce</strong>. Shift advances parsing by one symbol (<em>shifts</em> it by one symbol) (which doesn’t apply any production rule), while reduce combines (<em>reduces</em>) several non-terminals and/or terminals into a single terminal (goes into the reverse direction of production rule). When an algorithm generates such a table for an input we passed it, we might see a complaint about <em>shift-reduction conflict</em> - since well-defined LR grammar should for each PDA assign either a <em>shift</em> operation or a <em>reduce</em> operation, it shows that there is an ambiguity in the grammar, that the parser generator managed to resolve (and produce a working code), but which will bite us by <em>parsing some inputs not the way we wanted</em>.</p>

<p>For defining context-free grammars parser generators quite often use syntax heavily influenced by <strong>(extended) Backus-Naur form</strong> ((E)BNF). In EBNF, the previous example:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>→</mo><mo>+</mo><mo>∣</mo><mo>−</mo><mo>∣</mo><mo>×</mo><mo>∣</mo><mo>÷</mo></mrow><annotation encoding="application/x-tex">BinaryOperator \rightarrow + \mid - \mid \times \mid \div</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span>ina</span><span>ry</span><span>Op</span><span>er</span><span>a</span><span>t</span><span>or</span><span></span><span>→</span><span></span></span><span><span></span><span>+</span><span></span><span>∣</span><span></span></span><span><span></span><span>−</span><span></span><span>∣</span><span></span></span><span><span></span><span>×</span><span></span><span>∣</span><span></span></span><span><span></span><span>÷</span></span></span></span></span>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>→</mo><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>B</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Expression \rightarrow Number | Expression\ Expression\ BinaryOperator</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span></span><span>→</span><span></span></span><span><span></span><span>N</span><span>u</span><span>mb</span><span>er</span><span>∣</span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span> </span><span>E</span><span>x</span><span>p</span><span>ress</span><span>i</span><span>o</span><span>n</span><span> </span><span>B</span><span>ina</span><span>ry</span><span>Op</span><span>er</span><span>a</span><span>t</span><span>or</span></span></span></span></span>

<p>could look like this:</p>

<div><div><pre><code>binary operator = &#34;+&#34; | &#34;-&#34; | &#34;*&#34; | &#34;/&#34; ;
digit = &#34;0&#34; | &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; | &#34;7&#34; | &#34;8&#34; | &#34;9&#34; ;
number = number, digit | digit ;
expression = number, | expression, expression binary operator ;
</code></pre></div></div>

<p>Notice, that here terminal symbols are defined as digits. It might be quite inconvenient, which is why a lot of parser generators would rather:</p>

<ul>
  <li>assume that terminals are results of regular expression matching - the input would be matched against a set of regular expressions, each of which would be related to a terminal symbol. We would require them to accept whole input as a sequence of words matched by any of regular expressions. This way we would turn a sequence of input symbols into a sequence of terminal symbols. The part of a program responsible for this <strong>tokenization</strong> is called <strong>lexer</strong>.  Such approach is seen e.g. with parser generators based on <code>lex</code> (lexer) and <code>yacc</code> (Yet Another Compiler-Compiler) and their GNU reimplementations <code>flex</code> (free lex) and <code>bison</code> (an allusion to gnu as a lot of GNU tooling is based on <code>bison</code>). (It should also explain why certain languages have weird rules regarding class/method/function/variable names - since tokenization takes place in the very beginning, it has to reliable classify each piece of code unambiguously as a terminal symbol),</li>
  <li>alternatively allow you to use regular expressions directly in a parser-defining syntax. As this approach is much more readable it was also used in <em>parser combinators</em>.</li>
</ul>

<p>Right, we haven’t mentioned parser combinators. What are they, and why they became more popular recently?</p>

<h3 id="parser-combinators">Parser combinators</h3>

<p>When computer resources were really scarce, we didn’t have the comfort of building parsers in the most convenient way - the idea behind parsing generators was generating fast, ready to use PDA which would parse input with linear time and memory (that is, directly proportional to the input). Overhead had to be limited to the minimum, so the best way was to do all the calculations (both lexing and parsing) during code generation, so when we would run the program, it would be able to parse as soon as the code was loaded from the disk to the memory. All in all generating imperative code was the way to go.</p>

<p>But nowadays the situation is different. We have much faster computers with a lot more memory. And the requirements we have regarding programs are much higher, so the process of validating the parsed input became much more complex - so small overhead for parsing is not as painful. Additionally, we made much more progress when it comes to functional programming.</p>

<p>This opened the gate to an alternative approach called parser combinators (which is <em>not that new</em> considering, that it was described in <em>Recursive programming Techniques</em> by Burge from 1975 as <em>parsing functions</em>). What we do is basically, a function composition.</p>

<p>Let’s try by example. This time we’ll try to implement infix syntax. At first we’ll do something about lexing terminal symbols (and using spaces for separation):</p>

<div><div><pre><code><span>def</span> <span>number</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>)</span> <span>=</span> <span>&#34;&#34;&#34;\s*([0-9]+)(\s*)&#34;&#34;&#34;</span>
    <span>.</span><span>r</span>
    <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
    <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
       <span>val</span> <span>terminal</span> <span>=</span> <span>Number</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>1</span><span>).</span><span>toInt</span><span>)</span>
       <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
      <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
    <span>}</span>

<span>def</span> <span>plus</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>)</span> <span>=</span> <span>&#34;&#34;&#34;\s*(\+)(\s*)&#34;&#34;&#34;</span>
    <span>.</span><span>r</span>
    <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
    <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
       <span>val</span> <span>terminal</span> <span>=</span> <span>Plus</span>
       <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
      <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
    <span>}</span>

<span>def</span> <span>minus</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>)</span> <span>=</span> <span>&#34;&#34;&#34;\s*(-)(\s*)&#34;&#34;&#34;</span>
    <span>.</span><span>r</span>
    <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
    <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
       <span>val</span> <span>terminal</span> <span>=</span> <span>Minus</span>
       <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
      <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
    <span>}</span>

<span>def</span> <span>times</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>)</span> <span>=</span> <span>&#34;&#34;&#34;\s*(\*)(\s*)&#34;&#34;&#34;</span>
    <span>.</span><span>r</span>
    <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
    <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
       <span>val</span> <span>terminal</span> <span>=</span> <span>Times</span>
       <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
      <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
    <span>}</span>

<span>def</span> <span>div</span><span>(</span><span>input</span><span>:</span> <span>String</span><span>)</span> <span>=</span> <span>&#34;&#34;&#34;\s*(\/)(\s*)&#34;&#34;&#34;</span>
    <span>.</span><span>r</span>
    <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
    <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
       <span>val</span> <span>terminal</span> <span>=</span> <span>Div</span>
       <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
      <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
    <span>}</span>
</code></pre></div></div>

<p>It’s quite repetitive so we can introduce a helper utility:</p>

<div><div><pre><code><span>type</span> <span>Parser</span><span>[</span><span>+A</span><span>]</span> <span>=</span> <span>String</span> <span>=&gt;</span> <span>Option</span><span>[(</span><span>A</span>, <span>String</span><span>)]</span>

<span>object</span> <span>Parser</span><span>{</span>
  
  <span>def</span> <span>apply</span><span>[</span><span>A</span><span>](</span><span>re</span><span>:</span> <span>String</span><span>)(</span><span>f</span><span>:</span> <span>String</span> <span>=&gt;</span> <span>A</span><span>)</span><span>:</span> <span>Parser</span><span>[</span><span>A</span><span>]</span> <span>=</span>
    <span>input</span> <span>=&gt;</span> <span>s</span><span>&#34;&#34;&#34;\\s*($re)(\\s*)&#34;&#34;&#34;</span><span>.</span><span>r</span>
      <span>.</span><span>findPrefixMatchOf</span><span>(</span><span>input</span><span>)</span>
      <span>.</span><span>map</span> <span>{</span> <span>n</span> <span>=&gt;</span>
        <span>val</span> <span>terminal</span> <span>=</span> <span>f</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>1</span><span>))</span>
        <span>val</span> <span>unmatched</span> <span>=</span> <span>input</span><span>.</span><span>substring</span><span>(</span><span>n</span><span>.</span><span>group</span><span>(</span><span>0</span><span>).</span><span>length</span><span>)</span>
        <span>terminal</span> <span>-&gt;</span> <span>unmatched</span>
      <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>and simplify definitions a bit:</p>

<div><div><pre><code><span>val</span> <span>number</span> <span>=</span> <span>Parser</span><span>[</span><span>Number</span><span>](</span><span>&#34;&#34;&#34;[0-9]+&#34;&#34;&#34;</span><span>)(</span><span>n</span> <span>=&gt;</span> <span>Number</span><span>(</span><span>n</span><span>.</span><span>toInt</span><span>))</span>
<span>val</span> <span>plus</span> <span>=</span> <span>Parser</span><span>[</span><span>Plus.</span><span>type</span><span>](</span><span>&#34;&#34;&#34;\+&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>Plus</span><span>)</span>
<span>val</span> <span>minus</span> <span>=</span> <span>Parser</span><span>[</span><span>Minus.</span><span>type</span><span>](</span><span>&#34;&#34;&#34;-&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>Minus</span><span>)</span>
<span>val</span> <span>times</span> <span>=</span> <span>Parser</span><span>[</span><span>Times.</span><span>type</span><span>](</span><span>&#34;&#34;&#34;\*&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>Times</span><span>)</span>
<span>val</span> <span>div</span> <span>=</span> <span>Parser</span><span>[</span><span>Div.</span><span>type</span><span>](</span><span>&#34;&#34;&#34;\/&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>Div</span><span>)</span>
</code></pre></div></div>

<p>then we could start combining them:</p>

<div><div><pre><code><span>val</span> <span>binaryOperator</span><span>:</span> <span>Parser</span><span>[</span><span>BinaryOperator</span><span>]</span> <span>=</span> <span>in</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>in</span><span>.</span><span>isEmpty</span><span>)</span> <span>None</span>
  <span>else</span> <span>plus</span><span>(</span><span>in</span><span>)</span> <span>orElse</span> <span>minus</span><span>(</span><span>in</span><span>)</span> <span>orElse</span> <span>times</span><span>(</span><span>in</span><span>)</span> <span>orElse</span> <span>div</span><span>(</span><span>in</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>The curious reader might notice that this is a good candidate for a ReaderT/Kleisli composition, but we’ll try to keep this example as simple as possible. That is why we’ll create some specific utility for this case:</p>

<div><div><pre><code><span>implicit</span> <span>class</span> <span>ParserOps</span><span>[</span><span>A</span><span>](</span><span>parser</span><span>:</span> <span>Parser</span><span>[</span><span>A</span><span>])</span> <span>{</span>
  
  <span>// making another by-name param helps to prevent</span>
  <span>// stack overflow in some recursive definitions</span>
  
  <span>def</span> <span>|</span><span>[</span><span>B</span> <span>&gt;:</span> <span>A</span><span>](</span><span>another</span><span>:</span> <span>=&gt;</span> <span>Parser</span><span>[</span><span>B</span><span>])</span><span>:</span> <span>Parser</span><span>[</span><span>B</span><span>]</span> <span>=</span>
    <span>input</span> <span>=&gt;</span> <span>if</span> <span>(</span><span>input</span><span>.</span><span>isEmpty</span><span>)</span> <span>None</span>
             <span>else</span> <span>parser</span><span>(</span><span>input</span><span>)</span> <span>orElse</span> <span>another</span><span>(</span><span>input</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>and rewrite <code>binaryOperator</code> as:</p>

<div><div><pre><code><span>val</span> <span>binaryOperator</span><span>:</span> <span>Parser</span><span>[</span><span>BinaryOperator</span><span>]</span> <span>=</span>
  <span>plus</span> <span>|</span> <span>minus</span> <span>|</span> <span>times</span> <span>|</span> <span>div</span>
</code></pre></div></div>

<p>Now we are missing the concatenation - or moving input forward as we matched something already:</p>

<div><div><pre><code><span>def</span> <span>expression</span><span>:</span> <span>Parser</span><span>[</span><span>Expression</span><span>]</span> <span>=</span> <span>{</span>
  <span>val</span> <span>fromNumber</span><span>:</span> <span>Parser</span><span>[</span><span>FromNumber</span><span>]</span> <span>=</span> <span>in</span> <span>=&gt;</span> <span>{</span>
    <span>number</span><span>(</span><span>in</span><span>).</span><span>map</span> <span>{</span> <span>case</span> <span>(</span><span>n</span><span>,</span> <span>in2</span><span>)</span> <span>=&gt;</span> <span>FromNumber</span><span>(</span><span>n</span><span>)</span> <span>-&gt;</span> <span>in2</span> <span>}</span>
  <span>}</span>  
  
  <span>def</span> <span>fromBinary</span><span>:</span> <span>Parser</span><span>[</span><span>FromBinary</span><span>]</span> <span>=</span> <span>in</span> <span>=&gt;</span> <span>for</span> <span>{</span>
    <span>(</span><span>ex1</span><span>,</span> <span>in2</span><span>)</span> <span>&lt;-</span> <span>(</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)(</span><span>in</span><span>)</span>
    <span>(</span><span>bin</span><span>,</span> <span>in3</span><span>)</span> <span>&lt;-</span> <span>binaryOperator</span><span>(</span><span>in2</span><span>)</span>
    <span>(</span><span>ex2</span><span>,</span> <span>in4</span><span>)</span> <span>&lt;-</span> <span>(</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)(</span><span>in3</span><span>)</span>
  <span>}</span> <span>yield</span> <span>FromBinary</span><span>(</span><span>ex1</span><span>,</span> <span>ex2</span><span>,</span> <span>bin</span><span>)</span> <span>-&gt;</span> <span>in4</span>
  
  <span>fromBinary</span> <span>|</span> <span>fromNumber</span>
<span>}</span>

<span>def</span> <span>inParenthesis</span><span>:</span> <span>Parser</span><span>[</span><span>Expression</span><span>]</span> <span>=</span> <span>in</span> <span>=&gt;</span> <span>for</span> <span>{</span>
  <span>(</span><span>_</span><span>,</span> <span>in2</span><span>)</span> <span>&lt;-</span> <span>Parser</span><span>[</span><span>Unit</span><span>](</span><span>&#34;&#34;&#34;\(&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>())(</span><span>in</span><span>)</span>
  <span>(</span><span>ex</span><span>,</span> <span>in3</span><span>)</span> <span>&lt;-</span> <span>expression</span><span>(</span><span>in2</span><span>)</span>
  <span>(</span><span>_</span><span>,</span> <span>in4</span><span>)</span> <span>&lt;-</span> <span>Parser</span><span>[</span><span>Unit</span><span>](</span><span>&#34;&#34;&#34;\)&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>())(</span><span>in3</span><span>)</span>
<span>}</span> <span>yield</span> <span>ex</span> <span>-&gt;</span> <span>in4</span>
</code></pre></div></div>

<p>If we tested that code (which now looks like a candidate for a state monad) we would find that it parses one step of the way (so it doesn’t run recursion infinitely):</p>

<div><div><pre><code><span>expression</span><span>(</span><span>&#34;&#34;&#34; 12  + 23 &#34;&#34;&#34;</span><span>)</span>
<span>res1</span><span>:</span> <span>Option</span><span>[(</span><span>Expression</span>, <span>String</span><span>)]</span> <span>=</span>
  <span>Some</span><span>((</span><span>FromBinary</span><span>(</span><span>FromNumber</span><span>(</span><span>Number</span><span>(</span><span>12</span><span>)),</span> <span>FromNumber</span><span>(</span><span>Number</span><span>(</span><span>23</span><span>)),</span> <span>Plus</span><span>),</span> <span>&#34;&#34;</span><span>))</span>
</code></pre></div></div>

<p>We can prettify the code a bit:</p>

<div><div><pre><code><span>implicit</span> <span>class</span> <span>ParserOps</span><span>[</span><span>A</span><span>](</span><span>parser</span><span>:</span> <span>Parser</span><span>[</span><span>A</span><span>])</span> <span>{</span>
  
  <span>def</span> <span>|</span><span>[</span><span>B</span> <span>&gt;:</span> <span>A</span><span>](</span><span>another</span><span>:</span> <span>=&gt;</span> <span>Parser</span><span>[</span><span>B</span><span>])</span><span>:</span> <span>Parser</span><span>[</span><span>B</span><span>]</span> <span>=</span>
    <span>input</span> <span>=&gt;</span> <span>if</span> <span>(</span><span>input</span><span>.</span><span>isEmpty</span><span>)</span> <span>None</span>
             <span>else</span> <span>parser</span><span>(</span><span>input</span><span>)</span> <span>orElse</span> <span>another</span><span>(</span><span>input</span><span>)</span>
  
  <span>def</span> <span>&amp;</span><span>[</span><span>B</span><span>](</span><span>another</span><span>:</span> <span>=&gt;</span> <span>Parser</span><span>[</span><span>B</span><span>])</span><span>:</span> <span>Parser</span><span>[(</span><span>A</span>, <span>B</span><span>)]</span> <span>=</span>
    <span>input</span> <span>=&gt;</span> <span>if</span> <span>(</span><span>input</span><span>.</span><span>isEmpty</span><span>)</span> <span>None</span>
             <span>else</span> <span>for</span> <span>{</span>
               <span>(</span><span>a</span><span>,</span> <span>in2</span><span>)</span> <span>&lt;-</span> <span>parser</span><span>(</span><span>input</span><span>)</span>
               <span>(</span><span>b</span><span>,</span> <span>in3</span><span>)</span> <span>&lt;-</span> <span>another</span><span>(</span><span>in2</span><span>)</span>
             <span>}</span> <span>yield</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>in3</span>
  
  <span>def</span> <span>map</span><span>[</span><span>B</span><span>](</span><span>f</span><span>:</span> <span>A</span> <span>=&gt;</span> <span>B</span><span>)</span><span>:</span> <span>Parser</span><span>[</span><span>B</span><span>]</span> <span>=</span>
    <span>input</span> <span>=&gt;</span> <span>parser</span><span>(</span><span>input</span><span>).</span><span>map</span> <span>{</span> <span>case</span> <span>(</span><span>a</span><span>,</span> <span>in2</span><span>)</span> <span>=&gt;</span> <span>f</span><span>(</span><span>a</span><span>)</span> <span>-&gt;</span> <span>in2</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>def</span> <span>expression</span><span>:</span> <span>Parser</span><span>[</span><span>Expression</span><span>]</span> <span>=</span> <span>{</span>
  <span>def</span> <span>fromNumber</span> <span>=</span>
    <span>number</span><span>.</span><span>map</span><span>(</span><span>FromNumber</span><span>(</span><span>_</span><span>))</span>
  
  <span>def</span> <span>fromBinary</span> <span>=</span> 
    <span>((</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)</span> <span>&amp;</span>
      <span>binaryOperator</span> <span>&amp;</span>
     <span>(</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)).</span><span>map</span> <span>{</span>
      <span>case</span> <span>((</span><span>ex1</span><span>,</span> <span>bin</span><span>),</span> <span>ex2</span><span>)</span> <span>=&gt;</span> <span>FromBinary</span><span>(</span><span>ex1</span><span>,</span> <span>ex2</span><span>,</span> <span>bin</span><span>)</span>
    <span>}</span>
  
  <span>fromBinary</span> <span>|</span> <span>fromNumber</span>
<span>}</span>

<span>def</span> <span>inParenthesis</span><span>:</span> <span>Parser</span><span>[</span><span>Expression</span><span>]</span> <span>=</span> 
  <span>(</span><span>Parser</span><span>[</span><span>Unit</span><span>](</span><span>&#34;&#34;&#34;\(&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>())</span> <span>&amp;</span>
   <span>expression</span> <span>&amp;</span>
   <span>Parser</span><span>[</span><span>Unit</span><span>](</span><span>&#34;&#34;&#34;\)&#34;&#34;&#34;</span><span>)(</span><span>_</span> <span>=&gt;</span> <span>())).</span><span>map</span> <span>{</span>
    <span>case</span> <span>((</span><span>_</span><span>,</span> <span>ex</span><span>),</span> <span>_</span><span>)</span> <span>=&gt;</span> <span>ex</span>
  <span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>expression</span><span>(</span><span>&#34;&#34;&#34; 12 + 23 &#34;&#34;&#34;</span><span>).</span><span>map</span><span>(</span><span>_</span><span>.</span><span>_1</span><span>).</span><span>foreach</span><span>(</span><span>println</span><span>)</span>
<span>// FromBinary(FromNumber(Number(12)),FromNumber(Number(23)),Plus)</span>
</code></pre></div></div>

<p>(Complete example you can see on <a href="https://gist.github.com/MateuszKubuszok/dda5253281e59c75b7b669a1164a3db8">gist</a>).</p>

<p>Not bad! It already shows us the potential of <strong>creating small parsers and composing them as higher order functions</strong>. It should also explain to us why such a concept was named <strong>parser combinators</strong>.</p>

<p>But, can we have parser combinators out-of-the-box? We would need an implementation which:</p>

<ul>
  <li>is statically typed,</li>
  <li>gives us concatenation <code>&amp;</code>, alternative <code>|</code>, and <code>map</code>ping of parsers,</li>
  <li>let us gives suggestions if certain matching should be <em>greedy</em> (match whatever it can, potentially indefinitely) or <em>lazy</em> (finish ASAP),</li>
  <li>is probably more complex than a simple function from input into output with the unmatched part. It could e.g. make use of lookahead,</li>
  <li>give us a lot of utilities like e.g. regular expression support.</li>
</ul>

<p>Luckily for us, such implementation already exists, so we can just use it. <a href="http://www.lihaoyi.com/fastparse">FastParse</a> is a parser combinator library written by Li Haoyi (the same guy who created Ammonite and Mill). While it provides us a nice, functional interface, it uses Scala macros to generate fast code with little overhead (which gives us hardly any reason for considering parser generators, at least for Scala).</p>

<p>Our parser can be rewritten into fastparse this way:</p>

<div><div><pre><code><span>// import $ivy.`com.lihaoyi::fastparse:2.1.0`</span>
<span>import</span> <span>fastparse._</span>
<span>import</span> <span>ScalaWhitespace._</span> <span>// gives us Scala commens</span>
                         <span>// and whitespaces out-of-the-box</span>

<span>object</span> <span>Parsers</span> <span>{</span>
  
  <span>// terminals</span>
  <span>def</span> <span>number</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span>
    <span>P</span><span>(</span> <span>CharIn</span><span>(</span><span>&#34;0-9&#34;</span><span>).</span><span>rep</span><span>(</span><span>1</span><span>).!).</span><span>map</span><span>(</span><span>n</span> <span>=&gt;</span> <span>Number</span><span>(</span><span>n</span><span>.</span><span>toInt</span><span>)</span> <span>)</span>
                      <span>// ! makes parser catch input as String</span>
  <span>def</span> <span>plus</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span><span>&#34;+&#34;</span><span>).</span><span>map</span><span>(</span><span>_</span> <span>=&gt;</span> <span>Plus</span><span>)</span>
  <span>def</span> <span>minus</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span><span>&#34;-&#34;</span><span>).</span><span>map</span><span>(</span><span>_</span> <span>=&gt;</span> <span>Minus</span><span>)</span>
  <span>def</span> <span>times</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span><span>&#34;*&#34;</span><span>).</span><span>map</span><span>(</span><span>_</span> <span>=&gt;</span> <span>Times</span><span>)</span>
  <span>def</span> <span>div</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span><span>&#34;/&#34;</span><span>).</span><span>map</span><span>(</span><span>_</span> <span>=&gt;</span> <span>Div</span><span>)</span>

  <span>// non-terminals</span>
  <span>def</span> <span>binaryOperator</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span><span>plus</span> <span>|</span> <span>minus</span> <span>|</span> <span>times</span> <span>|</span> <span>div</span><span>)</span>
  <span>def</span> <span>fromNumber</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span><span>:</span> <span>P</span><span>[</span><span>FromNumber</span><span>]</span> <span>=</span>
    <span>P</span><span>(</span><span>number</span><span>.</span><span>map</span><span>(</span><span>FromNumber</span><span>(</span><span>_</span><span>)))</span>
  <span>def</span> <span>fromBinary</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span><span>:</span> <span>P</span><span>[</span><span>FromBinary</span><span>]</span> <span>=</span>
    <span>P</span><span>(((</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)</span> <span>~</span>
        <span>binaryOperator</span> <span>~</span>
       <span>(</span><span>fromNumber</span> <span>|</span> <span>inParenthesis</span><span>)).</span><span>map</span> <span>{</span>
      <span>case</span> <span>(</span><span>ex1</span><span>,</span> <span>op</span><span>,</span> <span>ex2</span><span>)</span> <span>=&gt;</span> <span>FromBinary</span><span>(</span><span>ex1</span><span>,</span> <span>ex2</span><span>,</span> <span>op</span><span>)</span>
    <span>})</span>
  <span>def</span> <span>expression</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span>
    <span>P</span><span>(</span><span>fromBinary</span> <span>|</span> <span>fromNumber</span><span>)</span>
  <span>def</span> <span>inParenthesis</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span>
    <span>P</span><span>(</span><span>&#34;(&#34;</span> <span>~</span> <span>expression</span> <span>~</span> <span>&#34;)&#34;</span><span>)</span>

  <span>def</span> <span>program</span><span>[</span><span>_</span> <span>:</span> <span>P</span><span>]</span> <span>=</span> <span>P</span><span>(</span> <span>(</span><span>expression</span> <span>|</span> <span>inParenthesis</span> <span>)</span> <span>~</span> <span>End</span><span>)</span>
<span>}</span>

<span>parse</span><span>(</span><span>&#34;12 + 23&#34;</span><span>,</span> <span>Parsers</span><span>.</span><span>program</span><span>(</span><span>_</span><span>))</span>
</code></pre></div></div>

<p>Before we jump the hype train - parser combinators are not equal to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> parsers and/or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">LR</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span></span></span></span> parsers. As we saw, we could define a parser accepting reverse Polish notation. However, if we tried to write a parser combinator that would accept it, then we would find, that recursive definition of <code>expression</code> would translate into a recursive function call without a terminating condition (parser combinators are just higher-order functions after all). <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">LR</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span></span></span></span> parser would push a symbol on the stack and take an input symbol from the input sequence, so at some point, they would have to stop (at least when the input finished). A parser combinator would need some <em>hint</em> e.g. closing block (which means that usually, it is not a problem), but we can see that parser combinators are not covering all context-free grammars.</p>

<p>Actually, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> parsers are not equal to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">LR</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span></span></span></span> parser either. Seeing how they work, one might argue that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">LL</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>LL</span></span></span></span> parsers correspond to Polish notation (because they make a decision at leftmost symbol - a prefix) while <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">LR</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span>R</span></span></span></span> corresponds to reverse Polish notation (because they take a decision at rightmost symbol - a postfix). (See a nice post about it: <a href="http://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html">LL and LR parsing demysitfied</a>). Both can be treated as special cases of PDA, while it a set of all PDAs that corresponds with a whole CFG set.</p>

<h2 id="turing-machines-linear-bounded-automata-unrestrained-and-context-sensitive-grammars">Turing machines, linear-bounded automata, unrestrained and context-sensitive grammars</h2>

<p>For the sake of completion, we can mention remaining computational models and grammar types, though this post is supposed to talk about parsing, so I’ll try to keep it short.</p>

<h3 id="turning-machines-and-unrestrained-grammars">Turning machines and unrestrained grammars</h3>

<p>A finite state machine at any given time remembers only in which one of a finite number of states it is. We read each symbol in the input once.</p>

<p>A push-down automaton remembers a current state and the last thing it put on a stack  - it can “remember” things from a stack in reverse order in which it stored them there for later. You cannot remember something from the middle of the stack without forgetting everything that was stacked before it. In a way, you can think that you can read each input element twice - once in incoming order, once in reverse order, and the only nuance is how you entangle these two modes.</p>

<p>A <strong>Turing machine</strong> (defined by Alan Turing, the same guy who designed <a href="https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma#British_bombe">cryptologic bombe against German Navy’s improved Enigma</a>, the cryptologic bombe against <a href="https://en.wikipedia.org/wiki/Bomba_(cryptography)">original Enigma was designed by Polish Cipher Bureau</a>) improved upon, that by using infinite tape, where the automaton could read and store  symbol in one cell of that tape, and then move forward or backward. This allows us to “remember” something as many times as we need it.</p>

<p>Because of that ability to read the thing as many times as we want, it is possible that your machine will get into an infinite loop and never end. The question whether we can guess if a specific machine will ever return for a given input is called the <a href="https://en.wikipedia.org/wiki/Halting_problem"><strong>halting problem</strong></a> (<strong>HP</strong>) and is proven to be in impossible to solve for a general case. The proof assumes, that you have a program that could use the halting problem solver on itself and loop if solvers says it should return and returns if solvers says it should loop - so it shows by contradiction that such thing cannot be constructed. A halting problem is used in a lot of proofs, that certain problem is impossible to solve - a reduction from the halting problem makes you use that problem to solve HP - since it is impossible to solve HP the problem is also unsolvable.</p>

<p>Turing machines are equal to <strong>unrestrained grammars</strong>, that is formal grammars that have no restriction about how you define a production rule. They are also equivalent to lambda calculus, register machine, and several other models. Usually, if we want to have a universal programming language, we make it Turing-complete (equal in power to TM, allowing you to simulate TM on it).</p>

<h3 id="linear-bounded-automata-and-context-sensitive-grammars">Linear-Bounded Automata and Context-Sensitive Grammars</h3>

<p>Between push-down automata and Turing machines lies <strong>linear-bounded automata</strong> (<strong>LBA</strong>). I decided to describe them after TMs because they are basically restricted form of TM. It puts some limits on both sides of the infinite tape, that your automaton cannot cross.</p>

<p>It was proven that LBAs are equal to context-sensitive grammars, that is grammars in the form of:</p>

<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mi>A</mi><mi>β</mi><mo>→</mo><mi>α</mi><mi>B</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha A \beta \rightarrow \alpha B \beta</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>α</span><span>A</span><span>β</span><span></span><span>→</span><span></span></span><span><span></span><span>α</span><span>Bβ</span></span></span></span></span>

<p>meaning that you can turn <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> into <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span> only if it appears in the context of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>α</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>β</span></span></span></span>.</p>

<h2 id="back-to-parsing">Back to parsing</h2>

<p>Majority of programming languages are Turing-complete. However, the first part of interpretation or compilation doesn’t require that we have this much power.</p>

<p>Some very simple interpreters can be build when you lexing (tokenization) and parsing and on reduction you immediately evaluate the computation inside parser. However, it is quite messy to maintain in the long run.</p>

<p>After all, parsers and context-free grammars can only take care of syntax analysis. So, you could preserve the results of syntax analysis into a data structure - abstract syntax tree - and then perform semantic analysis. Was variable with this name already defined? Is this identifier describing a class, object, constant? Actually, when you take into consideration how complex some of these things are, you might not be surprised, that certain compilers could decide to introduce several steps of a whole compilation process - just for verifying, that the AST is correct. <code>scalac</code> has over 20 phases in total:</p>

<div><div><pre><code>$ scalac -Xshow-phases
    phase name  id  description
    ----------  --  -----------
        parser   1  parse source into ASTs, perform simple desugaring
         namer   2  resolve names, attach symbols to named trees
packageobjects   3  load package objects
         typer   4  the meat and potatoes: type the trees
        patmat   5  translate match expressions
superaccessors   6  add super accessors in traits and nested classes
    extmethods   7  add extension methods for inline classes
       pickler   8  serialize symbol tables
     refchecks   9  reference/override checking, translate nested objects
       uncurry  10  uncurry, translate function values to anonymous classes
        fields  11  synthesize accessors and fields, add bitmaps for lazy vals
     tailcalls  12  replace tail calls by jumps
    specialize  13  @specialized-driven class and method specialization
 explicitouter  14  this refs to outer pointers
       erasure  15  erase types, add interfaces for traits
   posterasure  16  clean up erased inline classes
    lambdalift  17  move nested functions to top level
  constructors  18  move field definitions into constructors
       flatten  19  eliminate inner classes
         mixin  20  mixin composition
       cleanup  21  platform-specific cleanups, generate reflective calls
    delambdafy  22  remove lambdas
           jvm  23  generate JVM bytecode
      terminal  24  the last phase during a compilation run
</code></pre></div></div>

<blockquote>
  <p>By the way, this is a good moment to mention what compilation <em>actually is</em>. From the point of view of formal languages theory, a compilation is just translation work from one formal grammar into another. Scala into JVM byte code, C++ into binary code, Elm into JavaScript, TypeScript into JavaScript, ECMAScript 6 into ECMAScript 5… There is no need to introduce something like <em>transpiler</em> to describe compilation from one language to another. If we would use this word, then only to specify a compiler that translates into another high-level language, not because a <em>compiler</em> doesn’t cover that case.</p>

  <p>Interpreter would be something, that instead of translating into another formal grammar, translates directly into a computation. However, if we assume that we want to be <em>pure</em>, we would return something, that could be turned into a computation - e.g. free algebra. That explains, why <em>Typed Tagless Final Interpreter</em> has <em>interpreter</em> in its name, even though it doesn’t necessarily run computations immediately.</p>
</blockquote>

<p>Separation of phases serves two purposes. One is maintainability. The other is that we can separate front-end of a compiler (parsing and validating AST) and back-end (using AST to generate output). For instance, in case of Scala, we can have one front-end and several back-ends: JVM Scala, Scala.js and Native Scala (though, truth to be told Scala.js and Native Scala need to expand a language a bit).</p>

<p>If we go fully functional with all the phases (so each phase is a function working on AST element), then we have option to <em>compose</em> functions (<em>phase fusion</em>) - if our language of choice allows us to optimize combined functions, then we can obtain a compiler which is both maintainable and performant.</p>

<p>Of course, the parser doesn’t have to be a part of a compiler. The resulting tree might be our goal after all. XML, JSON or YML parsers exist in order to take some text representation and turn it into a tree of objects that is easier to work on. Notice, that grammars of languages like XML or HTML are too complex to be handled by something like <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">regular expression</a>, so if you want to use it, you’d better grab a parser.</p>

<h2 id="error-handling">Error handling</h2>

<p>If you want to discover and return to a user all errors, possibly with some meaningful description of what could go wrong and how they could fix it, it is problematic.</p>

<p>As you noticed our naive parser combinator simply returned unmatched part of the input - hardly helpful. fastparse is slightly better - it can also tell you around which character things broke and what terminal/non-terminal it was (especially if you use <em>cuts</em>, to tell the parser where it <em>should not perform a backtracking</em>).</p>

<p>With parsers created by generators, the situation is similar - out of the box you usually only get the information that parsing failed. So, how come all these compilers and document parsers can give you meaningful messages? More meaningful than <em>things broke at n-th character</em>?</p>

<p>When it comes to parser generators like Bison, <a href="https://www.gnu.org/software/bison/manual/html_node/Error-Recovery.html">you have a special terminal symbol</a> - <code>error</code>. When you match it, you can extract the position in text and create an element of AST which could mock the element, that should be there but put the error element instead. Whether you do it by having each element of AST being a coproduct of valid and invalid version, or if you will make each step of the way something like <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>E</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mo stretchy="false">[</mo><mi>E</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(A,B,C) \rightarrow Either[Error, Element]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>A</span><span>,</span><span></span><span>B</span><span>,</span><span></span><span>C</span><span>)</span><span></span><span>→</span><span></span></span><span><span></span><span>E</span><span>i</span><span>t</span><span>h</span><span>er</span><span>[</span><span>E</span><span>rror</span><span>,</span><span></span><span>El</span><span>e</span><span>m</span><span>e</span><span>n</span><span>t</span><span>]</span></span></span></span> is up to you. If that sound, as if you had to predict all possible ways a user can break the code and putting <code>error</code> there - that is exactly what you have to do there.</p>

<p>With parser combinators like fastparse, things are similar - you can tell the parser to <em>consume</em> some input after your current match, so you could e.g. try to match all right cases and - if they fail - consume the part of the input, that would fail and turn it into invalid AST element version.</p>

<p>Now, you should understand why this is not something, that you get for every language and why only some of them have user-friendly error handling. It increases the effort related to parser maintenance tremendously.</p>

<h2 id="summary">Summary</h2>

<p>In this post, we had a rather high-level overview of parsing (text) into AST. We briefly talked about the Chomsky hierarchy and relations between regular languages and different models of computation. We talked a little more about regular languages and context-free grammars, though without an in-depth description of algorithms used to create those.</p>

<p>How regular languages, computational models and compilers work in greater detail you can learn from books like <em>Compilers: Principles, Techniques, and Tools</em> by Aho, Lam, Sethi, and Ullman or <em>Structure and Interpretation of Computer Programs</em> by  Abelson,  Sussman, and Sussman.</p>

<p>I hope, that it will help you appreciate how many thoughts and effort went into letting us build REPLs, a plethora of languages - and all of that with much better syntax, than those of the first programming languages, which very unwelcome. This unblocked us from thinking about how to <em>design</em> the language to be friendly and readable. And, while we are still trying to figure out better ways of designing our tools, we should remember that all of that was possible thanks to pioneers in the formal languages theory.</p>
</article></div>
  </body>
</html>
