<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bea.goth.cafe/the-union-find-data-structure/">Original</a>
    <h1>The union-find data structure</h1>
    
    <div id="readability-page-1" class="page"><div><p>While working on my game, I needed a data structure that could efficiently answer the question “do these two elements belong to the same set?”. I found the <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">union-find data structure</a> and it was exactly what I needed. I thought it was pretty cool so I decided to write about it.</p><p>Lets say you have a bunch of elements and you want to group them into sets. For example, you might have a bunch of people and you want to group them into families. You might have a bunch of numbers and you want to group them into ranges. Or you might have a bunch of points and you want to group them into clusters.</p><p>The union-find data structure is a clever system that keeps track of a partition of elements into disjoint (non-overlapping) sets, and allows you to efficiently answer the question “do these two elements belong to the same set?” or “who is the ultimate parent of this element?”. And path compression is a neat trick to make these operations even faster by remembering the result of previous find operations on the sets.</p><p>Lets continue our family example, lets say we are building a family tree tracking system where everyone in the family can be connected together by their ancestors. In this “family”, every person knows only their immediate parent but not necessarily their ultimate ancestor (or root).</p><p>The union-find data structure allows you to efficiently answer the question “do these two people belong to the same family?” or “who is the ultimate ancestor of this person?”.</p><p>This data structure supports two operations: “union” and “find”.</p><h4 id="1-union">1. Union:</h4><p>In this “family” example, the “union” operation means “Let’s unite two families”. When two people from two different families decide to get married, we perform a “union” operation to link these two families. We sometimes say one family “joins” the other.</p><h4 id="2-find">2. Find:</h4><p>The “find” operation is like asking, “Who’s the ultimate ancestor (or the root) of this person?”. This operation traces a person’s line of parents up to the ultimate ancestor.</p><p><strong>Note:</strong> In a large family, it can take a long time to trace back up to the ultimate ancestor. To make this faster for next time, after we’ve found the ultimate ancestor of a person, we update that person’s immediate parent to be the ultimate ancestor (we “compress the path”). So next time we ask “who is this person’s ultimate ancestor?”, we get the answer in just one step.</p><p>Imagine you’re attending a huge family reunion. You meet a distant cousin and you both wonder how you’re related. So you both start asking your parents, who ask their parents, and so on, until you find the common ancestor. That’s a “find” operation. Now, to make it easier next time, you make a note that this cousin’s ultimate ancestor is the same as yours. That’s “path compression”.</p><p>By doing path compression, the union-find data structure ensures that the trees stay very flat, which makes future find operations much faster.</p><p>So in summary, the union-find data structure is a clever system that keeps track of a partition of elements into disjoint (non-overlapping) sets, and allows you to efficiently answer the question “do these two elements belong to the same set?” or “who is the ultimate parent of this element?”. And path compression is a neat trick to make these operations even faster by remembering the result of previous find operations.</p><h4 id="illustration">Illustration</h4><figure><img src="https://thepalindrome.org/images/blog-articles/union-find/illustration-union-find.png"/></figure><h4 id="implementation">Implementation:</h4><p>So this is how you would implement the union-find data structure in psuedocode:</p><h4 id="1-initialization">1. Initialization</h4><p>Start by initializing an array where the index represents each element and the value at each index represents the parent of that element. This is sometimes referred to as a “direct-access table” or a “lookup table.” For simplicity, let’s say we have 5 elements (0 to 4). At the start, each element is in a set by itself, so each element is its own parent.</p><div><pre tabindex="0"><code data-lang="python"><span><span>          <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>
</span></span><span><span>          <span>-------------</span>
</span></span><span><span>parent <span>=</span> [<span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]
</span></span></code></pre></div><h4 id="2-find-operation">2. Find operation</h4><p>The find operation will return the root of a given element (i.e., the representative of the set the element is in). This involves following the chain of parents until we find an element that is its own parent (i.e., <code>parent[i] == i</code>).</p><p>Here is a pseudocode function for find:</p><div><pre tabindex="0"><code data-lang="python"><span><span>Function Find(a)
</span></span><span><span>    <span>while</span> a <span>!=</span> parent[a]
</span></span><span><span>        a <span>=</span> parent[a]
</span></span><span><span>    End While
</span></span><span><span>    <span>return</span> a
</span></span><span><span>End Function
</span></span></code></pre></div><p>For example, if we call <code>Find(3)</code>, it will return <code>3</code>. Thats pretty straightforward since <code>3</code> is its own parent :D.</p><h4 id="3-union-operation">3. Union operation</h4><p>The union operation will connect or link two elements together. If we want to connect elements <code>a</code> and <code>b</code>, we need to find the root of <code>a</code> (which is the representative of the set <code>a</code> is currently in) and the root of <code>b</code>, and then set the parent of <code>b</code>’s root to be <code>a</code>’s root.</p><p>Here is a pseudocode function for union:</p><div><pre tabindex="0"><code data-lang="python"><span><span>Function Union(a, b)
</span></span><span><span>    aRoot <span>=</span> Find(a)
</span></span><span><span>    bRoot <span>=</span> Find(b)
</span></span><span><span>    parent[bRoot] <span>=</span> aRoot
</span></span><span><span>End Function
</span></span></code></pre></div><p>For example, if we call <code>Union(1, 3)</code>, the array becomes:</p><div><pre tabindex="0"><code data-lang="python"><span><span>          <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>
</span></span><span><span>          <span>-------------</span>
</span></span><span><span>parent <span>=</span> [<span>0</span>, <span>1</span>, <span>2</span>, <span>1</span>, <span>4</span>]
</span></span></code></pre></div><p>Here, element 3’s parent is now 1, meaning elements 1 and 3 are in the same set.</p><h4 id="4-path-compression">4. Path Compression</h4><p>We can optimize the find operation further with a technique called path compression. This involves making every node in the path from <code>a</code> to its root point directly to the root.</p><p>The find function with path compression would look like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span>Function Find(a)
</span></span><span><span>    <span>if</span> a <span>!=</span> parent[a]
</span></span><span><span>        parent[a] <span>=</span> Find(parent[a])
</span></span><span><span>    End If
</span></span><span><span>    <span>return</span> parent[a]
</span></span><span><span>End Function
</span></span></code></pre></div><p>This will “flatten” the tree over time, making subsequent find operations very fast.</p><p>And that’s it! Now you know how to implement a union-find data structure using an array. It’s a very useful and powerful data structure for solving problems that involve grouping elements into sets. I’ve implemented a version in go in case you want to play around with it.</p></div></div>
  </body>
</html>
