<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234">Original</a>
    <h1>Fork() is evil; vfork() is goodness; afork() would be better; clone() is stupid</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-fork-is-evil-vfork-is-good-afork-would-be-better-md">
      
      <div id="file-fork-is-evil-vfork-is-good-afork-would-be-better-md-readme">
    <article itemprop="text"><p dir="auto">I recently happened upon an implementation of <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html" rel="nofollow"><code>popen()</code></a> (different API, same idea) using <a href="http://man7.org/linux/man-pages/man2/clone.2.html" rel="nofollow"><code>clone(2)</code></a>, and so I opened an <a href="https://github.com/famzah/popen-noshell/issues/11">issue</a> requesting use of <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/vfork.html" rel="nofollow"><code>vfork(2)</code></a> or <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html" rel="nofollow"><code>posix_spawn()</code></a> for portability.  It turns out that on Linux there&#39;s an important advantage to using <code>clone(2)</code>.  I think I should capture the things I wrote there in a better place.  A gist, a blog, whatever.</p>
<p dir="auto">So here goes.</p>
<p dir="auto">Long ago, I, like many Unix fans, thought that <a href="https://en.wikipedia.org/wiki/Fork_(system_call)" rel="nofollow"><code>fork(2)</code></a> and the <a href="https://en.wikipedia.org/wiki/Fork-exec" rel="nofollow">fork-exec process spawning model</a> were the greatest thing, and the Windows sucked for only having <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html" rel="nofollow"><code>exec*()</code></a> and <a href="https://msdn.microsoft.com/en-us/library/20y988d2.aspx" rel="nofollow"><code>_spawn*()</code></a>, the last being a Windows-ism.</p>
<p dir="auto">After many years of experience, I learned that <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html" rel="nofollow"><code>fork(2)</code></a> is in fact evil.  And <code>vfork(2)</code>, <a href="https://www.google.com/#q=vfork+considered+harmful" rel="nofollow">long said to be evil</a>, is in fact <a href="https://www.google.com/#q=vfork+is+good" rel="nofollow"><em>goodness</em></a>.  A slight variant of <code>vfork(2)</code> that avoids the need to block the parrent would be even better (see below).</p>
<p dir="auto">Extraordinary statements require explanation, so allow me to explain.</p>
<p dir="auto">I won&#39;t bother explaining what <a href="https://en.wikipedia.org/wiki/Fork_(system_call)" rel="nofollow"><code>fork(2)</code></a> is -- if you&#39;re reading this, I assume you know.  But I&#39;ll explain <code>vfork(2)</code> and why it was said to be harmful.  <code>vfork(2)</code> is very similar to <code>fork(2)</code>, but the new process it creates runs in the same address space as the parent as if it were a thread, even sharing the same stack as the thread that called <code>vfork(2)</code>!  Two threads can&#39;t share a stack, so the parent is stopped while the child does its thing: either <code>exec*(2)</code> or <code>_exit(2)</code>.</p>
<p dir="auto">Now, 3BSD added <code>vfork(2)</code>, and a few years later 4.4BSD removed it as it was by then considered harmful.  Most subsequent man pages say as much.  But the derivatives of 4.4BSD restored it and do not call it harmful.  There&#39;s a reason for this: <code>vfork(2)</code> is <em>much</em> cheaper than <code>fork(2)</code> -- much, much cheaper.  That&#39;s because <code>fork(2)</code> has to either copy the parent&#39;s address space, or arrange for copy-on-write (which is supposed to be an optimization to avoid unnecessary copies).  But even COW is very expensive because it requires modifying memory mappings, taking expensive page faults, and so on.  Modern kernels tend to seed the child with a copy of the parent&#39;s resident set, but if the parent has a large memory footprint (e.g., is a JVM), then the RSS will be huge.  So <code>fork(2)</code> is inescapably expensive except for small programs with small footprints (e.g., a shell).</p>
<p dir="auto">So you begin to see why <code>fork(2)</code> is evil.  And I haven&#39;t yet gotten to fork-safety perils!  Fork-safety considerations are a lot like thread-safety, but it is harder to make libraries fork-safe than thread-safe.  I&#39;m not going to go into fork-safety here: it&#39;s not necessary.</p>
<p dir="auto">(Before I go on I should admit to hypocrisy: I do write code that uses <code>fork(2)</code>, often for multi-processing daemons -- as opposed to multi-threading, though I often do the latter as well.  But the forks there happen very early on when nothing fork-unsafe has happened yet and the address space is <em>small</em>, thus avoiding most evils of <code>fork(2)</code>.  <code>vfork(2)</code> cannot be used for this purpose.  On Windows one would have to <code>CreateProcess()</code> or <code>_spawn()</code> to implement multi-processed daemons, which is a huge pain in the neck.)</p>
<p dir="auto">Why did I ever think <code>fork(2)</code> was elegant then?  It was the same reason that everyone else did and does: <code>CreateProcess*()</code>, <code>_spawn()</code> and <code>posix_spawn()</code> and such functions are extremely complex, and they have to be because there is an enormous number of things one might do between <code>fork()</code> and <code>exec()</code> in, say, a shell.  But with <code>fork()</code> and <code>exec()</code> one does not need a language or API that can express all those things: the host language will do!  <code>fork(2)</code> gave the Unix&#39;s creators the ability to move all that complexity out of kernel-land into user-land, where it&#39;s much easier to develop software -- it made them more productive, perhaps much more so.  The price Unix&#39;s creators paid for that elegance was the need to copy address spaces.  Since back then programs and processes were <em>small</em> that inelegance was easy to overlook.  But now processes tend to be <em>huge</em>, and that makes copying even just a parent&#39;s resident set, and page table fiddling for the rest, extremely expensive.</p>
<p dir="auto">But <code>vfork()</code> has all that elegance, and none of the downsides of <code>fork()</code>!</p>
<p dir="auto"><code>vfork()</code> does have one downside: that the parent (specifically: the thread in the parent that calls <code>vfork()</code>) and child share a stack, necessitating that the parent (thread) be stopped until the child <code>exec()</code>s or <code>_exit()</code>s.  (This can be forgiven due to <code>vfork(2)</code>&#39;s long preceding threads -- when threads came along the need for a separate stack for each new thread became utterly clear and unavoidable.  The fix for threading was to use a new stack for the new thread and use a callback function and argument as the <code>main()</code>-alike for that new stack.)  But blocking is bad because <em>synchronous behavior</em> is bad, especially when it&#39;s the only option yet it could have been better.  An asynchronous version of <code>vfork()</code> would have to run the child in a new/alternate stack.  Let&#39;s call it <code>afork()</code>, or <code>avfork()</code>.  Now, <code>afork()</code> would have to look a lot like <code>pthread_create()</code>: it has to take a function to call on a new stack, as well as an argument to pass to that function.</p>
<p dir="auto">I should mention that <em>all</em> the <code>vfork()</code> man pages I&#39;ve seen say that the parent <em>process</em> is stopped until the child exits/execs, but this predates threads.  Linux, for example, only stops the one thread in the parent that called <code>vfork()</code>, not all threads.  I believe that is the correct thing to do, but IIRC other OSes stop all threads in the parent process (which is a mistake, IMO).</p>
<p dir="auto">An <code>afork()</code> would allow a <code>popen()</code> like API to return very quickly with appropriate pipes for I/O with the child(ren).  If anything goes wrong on the child side then the child(ren) will exit and their output pipe (if any) will evince EOF, and/or writes to the child&#39;s input will get <code>EPIPE</code> and/or will raise <code>SIGPIPE</code>, at which point the caller of <code>popen()</code> will be able to check for errors.</p>
<p dir="auto">One might as well borrow the <a href="https://wiki.illumos.org/display/illumos/illumos+Home" rel="nofollow">Illumos</a> <a href="https://illumos.org/man/2/forkx" rel="nofollow"><code>forkx()</code>/<code>vforkx()</code></a> flags, and make <code>afork()</code> look like this:</p>
<pre><code>pid_t afork(int (*start_routine)(void *), void *arg);
pid_t aforkx(int flags /* FORK_NOSIGCHLD and/or FORK_WAITPID */, int (*fn)(void *), void *arg);
</code></pre>
<p dir="auto">It turns out that <code>afork()</code> is easy to implement on Linux: it&#39;s just a <code>clone(&lt;function&gt;, &lt;stack&gt;, CLONE_VM | CLONE_SETTLS, &lt;argument&gt;)</code> call.  (One might want to request that <code>SIGCHLD</code> be sent to the parent when the child dies, but this is decidedly <em>not</em> desirable in a <code>popen()</code> implementation, as otherwise the program might reap it before <code>pclose()</code> can reap it.  For <a href="https://illumos.org/man/2/fork" rel="nofollow">more on this</a> go look at Illumos.)</p>
<p dir="auto">One can also implement something like <code>afork()</code> (minus the Illumos <code>forkx()</code> flags) on POSIX systems by using <code>pthread_create()</code> to start a thread that will block in <code>vfork()</code> while the <code>afork()</code> caller continues its business.  Add a taskq to pre-create as many such worker threads as needed, and you&#39;ll have a fast <code>afork()</code>.  However, an <code>afork()</code> implemented this way won&#39;t be able to return a <code>PID</code> unless the threads in the taskq pre-vfork (good idea!), instead it would need a completion callback, something like this:</p>
<pre><code>int emulated_afork(int (*start_routine)(void *), void *arg, void (*cb)(pid_t) /* may be NULL */);
</code></pre>
<p dir="auto">If the threads pre-vfork, then a PID-returning <code>afork()</code> can be implemented, though communicating a task to a pre-vforked thread might be tricky: <code>pthread_cond_wait()</code> might not work in the child, so one would have to use a pipe into which to write a pointer to the dispatched request.  (Pipes <em>are</em> safe to use on the child side of <code>vfork()</code>.  That is, <code>read()</code> and <code>write()</code> on pipes are safe in the child of <code>vfork()</code>.)  Here&#39;s how that would work:</p>
<pre><code>// This only works if vfork() only stops the one thread in the
// parent that called vfork(), not all threads.  E.g., as on Linux.
// Otherwise this fails outright and there is no way to implement
// avfork().  Of course, on Linux one can just use clone(2).

static struct avfork_taskq_s { /* elided */ ... } *avfork_taskq;

static void
avfork_taskq_init(void)
{
    // Elided, left as exercise for the reader
    ...
}
// Other taskq functions called below also elided here

// taskq thread create start routine
static void *
worker_start_routine(void *arg)
{
    struct worker_s *me = arg;
    struct job_s *job;
    
    // Register the worker and pthread_cond_signal() up to one thread
    // that might be waiting for a worker.
    avfork_taskq_add_worker(avfork_taskq, me);
    do {
        if ((job = calloc(1, sizeof(*job))) == NULL ||
            pipe2(job-&gt;dispatch_pipe, O_CLOEXEC) == -1 ||
            pipe2(job-&gt;ready_pipe, O_CLOEXEC) == -1 ||
            (pid = vfork()) == -1) {
            avfork_taskq_remove(avfork_taskq, me, errno); // We&#39;re out!
            break;
        }
        if (pid != 0) {
            // The child exited or exec&#39;ed
            if (job-&gt;errno)
                // The child failed to get a job
                reap_child(pid);
            else
                // The child took a job; record it so we can reap it
                // later.
                // This also marks this worker as available and signals
                // up to one thread that might be waiting for a worker.
                avfork_taskq_record_child(avfork_taskq, me, job, pid);
                
            if (avfork_taskq_too_big_p(avfork_taskq))
                break; // Dynamically shrink the taskq

            continue;
        }
        
        // This is the child
        
        // Notice that only read(2), write(2), _exit(2), and the start_routine
        // from the avfork() call are called here.  The avfork() start_routine()
        // should only call async-signal-safe functions and should not call
        // anything that&#39;s not safe on the child-side of vfork().  Depending
        // on the OS or C library it may not be possible to use some or any
        // kind of locks, condition variables, allocators, RTLD, etc...  At least
        // dup2(2), close(2), sigaction(2), signal masking functions, exec(2),
        // and _exit(2) are safe to call in start_routine(), and that&#39;s enough
        // to implement posix_spawn(), a better popen(), better system(),
        // and so on.
        
        // Note too that the child does not refer to the taskq at all.
        
        // Get a job
        if (net_read(me-&gt;dispatch_pipe[0], &amp;job-&gt;descr, sizeof(job-&gt;descr)) != sizeof(job-&gt;descr)) {
            job-&gt;errno = errno ? errno : EINVAL;
            _exit(1);
        }
        job-&gt;descr-&gt;pid = getpid(); // Save the pid where a thread in the parent can see it
        if(net_write(me-&gt;ready_pipe[1], &#34;&#34;, sizeof(&#34;&#34;)) != sizeof(&#34;&#34;))  {
            job-&gt;errno = errno;
            _exit(1);
        }
        
        // Do the job
        _exit(job-&gt;descr-&gt;start_routine(job-&gt;descr-&gt;arg));
    } while(!avfork_taskq-&gt;terminated); // Perhaps this gets set via atexit()

    return NULL;
}

pid_t
avfork(int (*start_routine)(void *), void *arg)
{
    static pthread_once_t once = PTHREAD_ONCE_INIT;
    struct worker_s *worker;
    struct job_descr_s job;
    struct job_descr_s *jobp = &amp;job;
    char c;
    
    // avfork_taskq_init() is elided here, but one can imagine what it
    // looks like.  It might grow up to N worker threads, and thereafter
    // if there are no available workers then taskq.get_worker() blocks
    // in a pthread_cond_wait() until a worker is ready.
    pthread_once(&amp;once, avfork_taskq_init);
    
    // Describe the job
    memset(&amp;job, 0, sizeof(job));
    job.start_routine = start_routine;
    job.arg = arg;

    worker = avfork_taskq_get_worker(avfork_taskq); // Lockless when possible; starts a worker if needed

    // Send the worker our job.  If we&#39;re lucky, we only wait for an already
    // pre-vfork()ed child to read our job and indicate readiness.  If we&#39;re
    // unlucky then the worker we got is busy going through vfork().  Worker
    // threads really don&#39;t do much though, so we should usually get lucky.
    //
    // The taskq should be sized so that there isn&#39;t too much contention for
    // workers, and to grow dynamically so that at first there are no workers.
    // Perhaps it could grow without bounds when demand is great, then shrink
    // when demand is low (see worker_start_routine()).
    if (net_write(worker-&gt;dispatch_pipe[1], &amp;jobp, sizeof(jobp)) != sizeof(jobp) ||
        net_read(worker-&gt;ready_pipe[0], &amp;c, sizeof(c)) != sizeof(c))
        job.errno = errno ? errno : EINVAL;

    // Cleanup
    (void) close(worker-&gt;dispatch_pipe[0]);
    (void) close(worker-&gt;dispatch_pipe[1]);
    (void) close(worker-&gt;ready_pipe[0]);
    (void) close(worker-&gt;ready_pipe[1]);
    
    if (job.errno)
        return -1;
    return job.pid; // when the read returns the PID is in pid
}
</code></pre>
<p dir="auto">The title also says that <a href="http://man7.org/linux/man-pages/man2/clone.2.html" rel="nofollow"><code>clone(2)</code></a> is stupid.  Allow me to address that.  <code>clone(2)</code> was originally added as an alternative to proper POSIX threads that could be used to implement POSIX threads.  The idea was that lots of variations on <code>fork()</code> would be nice, and as we see here, that&#39;s actually true as to <code>avfork()</code>!  <code>avfork()</code> was not the motivation, however.  A lot of mistakes were made on the way to the <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library" rel="nofollow">NPTL</a>.</p>
<p dir="auto">Linux should have had a thread creation system call -- it would have then saved itself the pain of the first pthread implementation for Linux.  Linux should have learned from Solaris/SVR4, where emulation of BSD sockets via <code>libsocket</code> on top of STREAMS proved to be a very long and costly mistake.  Emulating one API from another API with impedance mismatches is difficult at best.</p>
<p dir="auto">Since then <code>clone()</code> has become a swiss army knife -- it has evolved to have zone/jail entering features, but only sort of: Linux doesn&#39;t have proper zones/jails, instead adding new &#34;namespaces&#34; and new <code>clone(2)</code> flags to go with them.  And as new container-related <code>clone(2)</code> flags are added that old code might wish it had used them... one will have to modify and rebuild the <code>clone(2)</code>-calling world, and <em>that</em> is decidedly not elegant.</p>
<p dir="auto">Linux should have had first-class <code>fork()</code>, <code>vfork()</code>, <code>avfork()</code>, <code>thread_create()</code>, and <code>container_create()</code> system calls.  The fork family could have been one system call with options, but threads are not processes, and neither are containers (though containers may have processes, and may have a minder/init process).  Conflating all of those onto one system call seems a bit much, though even that would be OK if there was just one flag for container entry/start/fork/whatever-metaphor-applies-to-containers.  But the <code>clone(2)</code> design, or its maintainers, encourages a proliferation of flags, which means one must constantly pay attention to the possible need to add new flags at existing call sites.</p>
<p dir="auto">Now, my friends tell me, and I read around too, that &#34;nah, containers aren&#39;t zones/jails, they&#39;re not meant to be used like that&#34;, and I don&#39;t care about that line of argument.  The world needs zones/jails and Linux containers <em>really</em> want to be zones/jails.  They do.  And zones/jails need to start life maximally isolated, and sharing needs to be added explicitly from the host.  Doing it the other way around is badly broken, because every time isolation is increased one has to go patch <code>clone(2)</code> calls.  That&#39;s not a good approach to security for an OS that is not integrated top-to-bottm (on Linux everything has different maintainers and communities: the kernel, the C libraries, every important system library, the shells, the init system, all the user-land programs one expects -- everything).  In a world like that containers need to start maximally isolated.</p>
<p dir="auto">I could go on.  I could talk about fork-safety.  I could discuss all of the functions that are generally, or in specific cases, safe to call in a child of <code>fork()</code>, versus the child of <code>vfork()</code>, versus the child of <code>afork()</code> (if we had one), or a child of a <code>clone()</code> call (but I&#39;d have to consider quite a few flag combinations!).  I could go into why 4.4BSD removed <code>vfork()</code> (I&#39;d have to do a bit more digging though).  I think this post&#39;s length is probably just right, so I&#39;ll leave it here.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
