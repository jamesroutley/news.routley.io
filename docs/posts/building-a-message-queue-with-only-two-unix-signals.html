<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leandronsp.com/articles/you-dont-need-kafka-building-a-message-queue-with-only-two-unix-signals">Original</a>
    <h1>Building a message queue with only two UNIX signals</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Have you ever asked yourself what if we could replace any message broker with a very simple one using only two UNIX signals? Well, I‚Äôm not surprised if you didn‚Äôt. But I did. And I want to share my journey of how I achieved it.</p>
<p>If you want to learn about UNIX signals, binary operations the easy way, how a message broker works under the hood, and a bit of Ruby, this post is for you.</p>
<p>And if you came here just because of the clickbait title, I apologize and invite you to keep reading. It‚Äôll be fun, I promise.</p>
<p><img src="https://leandronsp.com/uploads/3491.png" alt="image"/></p>
<h2><a href="#its-all-about-unix" aria-hidden="true" id="its-all-about-unix"></a>It‚Äôs all about UNIX</h2>
<p>A few days ago, I saw some discussion on the internet about how we could send messages between processes. Many people think of sockets, which are the most common way to send messages, even allowing communication across different machines and networks. Some don‚Äôt even realize that pipes are another way to send messages between processes:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>echo</span> <span>&#39;hello&#39;</span> <span>|</span> <span>base64</span>
</p><p><span>aGVsbG8K</span>
</p></code></pre>
<p>Here‚Äôs what‚Äôs happening:</p>
<ul>
<li>The process <code>echo</code> is started with the content ‚Äúhello‚Äù</li>
<li><code>echo</code> is a program that prints the message to <em>STDOUT</em></li>
<li>Through the pipe, the content in <em>STDOUT</em> is <strong>sent</strong> directly to the <em>STDIN</em> of the <code>base64</code> process</li>
<li>The <code>base64</code> process encodes its input to Base64 and then puts the result in <em>STDOUT</em></li>
</ul>
<p>Note the word ‚Äúsend‚Äù. Yes, anonymous pipes are a form of <strong>IPC (Inter-process communication).</strong> Other forms of IPC in UNIX include:</p>
<ul>
<li>named pipes (mkfifo)</li>
<li>sockets</li>
<li>regular files</li>
<li>or even a simple <strong>signal</strong></li>
</ul>
<h2><a href="#unix-signals" aria-hidden="true" id="unix-signals"></a>UNIX signals</h2>
<p>According to <a href="https://leandronsp.com/articles/url">Wikipedia</a>:</p>
<blockquote>
<p>A UNIX signal is a standardized message sent to a program to trigger specific behaviour, such as quitting or error handling</p>
</blockquote>
<p>There are many signals we can send to a process, including:</p>
<ul>
<li>SIGTERM - sends a notification to the process to terminate. It can be ‚Äútrapped,‚Äù which means the process can do some cleanup work before termination, like releasing OS resources and closing file descriptors</li>
<li>SIGKILL - sends a termination signal that cannot be trapped or ignored, forcing immediate termination</li>
<li>SIGINT - the interrupt signal, typically sent when you press <code>Ctrl+C</code> in the terminal. It can be trapped, allowing the process to perform cleanup before exiting gracefully</li>
<li>SIGHUP - the hangup signal, originally sent when a terminal connection was lost. Modern applications often use it to reload configuration files without restarting the process</li>
<li>SIGQUIT - similar to SIGINT but also generates a core dump for debugging</li>
<li>SIGSTOP - pauses (suspends) a process. Cannot be trapped or ignored</li>
<li>SIGCONT - resumes a process that was paused by <em>SIGSTOP</em></li>
<li>SIGCHLD - sent to a parent process when a child process terminates or stops</li>
<li><strong>SIGUSR1</strong> and <strong>SIGUSR2</strong> - user-defined signals that applications can use for custom purposes</li>
</ul>
<h2><a href="#sending-messages-using--signals" aria-hidden="true" id="sending-messages-using--signals"></a>Sending messages using  signals</h2>
<p>Okay, we know that signals are a primitive form of IPC. UNIX-like systems provide a syscall called <code>kill</code> that sends signals to processes. Historically, this syscall was created solely to terminate processes. But over time, they needed to accommodate other types of signals, so they reused the same syscall for different purposes.</p>
<p>For instance, let‚Äôs create a simple Ruby script <code>sleeper.rb</code> which sleeps for 60 seconds, nothing more:</p>
<pre><code translate="no" tabindex="0"><p><span>puts</span> <span>&#34;</span><span>Process ID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>puts</span> <span>&#34;</span><span>Sleeping for 60 seconds...</span><span>&#34;</span>
</p><p><span>sleep</span> <span>60</span>
</p></code></pre>
<p>After running we see:</p>
<pre><code translate="no" tabindex="0"><p>Process ID: 55402
</p><p>Sleeping for 60 seconds...
</p></code></pre>
<p>In another window, we can <strong>send</strong> the <code>SIGTERM</code> signal to the process <code>55402</code> via syscall <code>kill</code>:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>kill</span> <span>-SIGTERM</span> <span>55402</span>
</p></code></pre>
<p>And then, in the script session:</p>
<pre><code translate="no" tabindex="0"><p>[1]    55402 terminated  ruby sleeper.rb
</p></code></pre>
<h3><a href="#signal-traps" aria-hidden="true" id="signal-traps"></a>Signal traps</h3>
<p>In Ruby, we can also <em>trap</em> a signal using the <code>trap</code> method in Ruby:</p>
<pre><code translate="no" tabindex="0"><p><span>puts</span> <span>&#34;</span><span>Process ID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>puts</span> <span>&#34;</span><span>Sleeping for 60 seconds...</span><span>&#34;</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGTERM</span><span>&#39;</span><span>)</span> <span>do</span> 
</p><p><span>puts</span> <span>&#34;</span><span>Received SIGTERM, exiting gracefully...</span><span>&#34;</span>
</p><p><span>exit</span>
</p><p><span>end</span>
</p><p><span>sleep</span> <span>60</span>
</p></code></pre>
<p>Which in turn, after sending the signal, will gracefully:</p>
<pre><code translate="no" tabindex="0"><p>Process ID: 55536
</p><p>Sleeping for 60 seconds...
</p><p>Received SIGTERM, exiting gracefully...
</p></code></pre>
<p>After all, we <em>cannot send messages using signals</em>. They are a primitive way of sending <em>standardized messages</em> which will trigger specific behaviours. At most, we can trap some signals, but nothing more.</p>
<blockquote>
<p>Okay Leandro, but what‚Äôs the purpose of this article then?</p>
</blockquote>
<p><em>Hold on</em>. That‚Äôs exactly why I‚Äôm here. To prove points by doing useless stuff, like when I <a href="https://leandronsp.com/articles/simulating-oop-in-bash-3mop">simulated OOP in Bash</a> a couple of years ago (it was fun though).</p>
<p>To understand how we can ‚Äúhack‚Äù UNIX signals and send messages between processes, let‚Äôs first talk a bit about <strong>binary operations</strong>. Yes, those ‚Äúzeros‚Äù and ‚Äúones‚Äù you were scared of when you saw them for the first time. But they don‚Äôt bite (ü•Å LOL), I promise.</p>
<h2><a href="#what-is-a-message" aria-hidden="true" id="what-is-a-message"></a>What is a message?</h2>
<p>If we model a message as a sequence of characters, we could say that at a high-level, messages are simply <em>strings</em>. But in memory, they are stored as <strong>bytes</strong>.</p>
<p>We know that bytes are made of bits. In computer terms, what‚Äôs a bit? It‚Äôs simply an abstraction representing <strong>only two states</strong>:</p>
<ul>
<li>zero</li>
<li>one</li>
</ul>
<p>That‚Äôs it. For instance, using <a href="https://leandronsp.com/articles/url">ASCII</a>, we know that the letter ‚Äúh‚Äù has the following codes:</p>
<ul>
<li>104 in decimal</li>
<li><code>0x68</code> in hexadecimal</li>
<li><code>01101000</code> in binary</li>
</ul>
<p>Binary-wise, what if we represented each ‚Äú0‚Äù with a specific signal and each ‚Äú1‚Äù with another? We know that some signals such as SIGTERM, SIGINT, and SIGCONT can be trapped, but intercepting them would harm their original purpose.</p>
<p>But thankfully, UNIX provides two user-defined signals that are perfect for our hacking experiment.</p>
<h2><a href="#sending-sigusr1-and-sigusr2" aria-hidden="true" id="sending-sigusr1-and-sigusr2"></a>Sending SIGUSR1 and SIGUSR2</h2>
<p>First things first, let‚Äôs trap those signals in the code:</p>
<pre><code translate="no" tabindex="0"><p><span>puts</span> <span>&#34;</span><span>Process ID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>puts</span> <span>&#34;</span><span>Sleeping forever. Send signals to this process to see how it responds.</span><span>&#34;</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>)</span> <span>do</span> 
</p><p><span>puts</span> <span>&#34;</span><span>Received SIGUSR1 signal</span><span>&#34;</span>
</p><p><span>end</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR2</span><span>&#39;</span><span>)</span> <span>do</span>
</p><p><span>puts</span> <span>&#34;</span><span>Received SIGUSR2 signal</span><span>&#34;</span>
</p><p><span>end</span>
</p><p><span>sleep</span>
</p></code></pre>
<pre><code translate="no" tabindex="0"><p>Process ID: 56172
</p><p>Sleeping forever. Send signals to this process to see how it responds.
</p></code></pre>
<p>After sending some <code>kill -SIGUSR1 56172</code> and <code>kill -SIGUSR2 56172</code>, we can see that the process prints the following content:</p>
<pre><code translate="no" tabindex="0"><p>Process ID: 56172
</p><p>Sleeping forever. Send signals to this process to see how it responds.
</p><p>Received SIGUSR1 signal
</p><p>Received SIGUSR2 signal
</p><p>Received SIGUSR2 signal
</p><p>Received SIGUSR1 signal
</p><p>Received SIGUSR1 signal
</p><p>Received SIGUSR2 signal
</p></code></pre>
<p><strong>Signals don‚Äôt carry data</strong>. But the example we have is perfect for changing to bits, uh?</p>
<pre><code translate="no" tabindex="0"><p>Received SIGUSR1 signal # 0
</p><p>Received SIGUSR2 signal # 1
</p><p>Received SIGUSR2 signal # 1
</p><p>Received SIGUSR1 signal # 0
</p><p>Received SIGUSR2 signal # 1
</p><p>Received SIGUSR1 signal # 0
</p><p>Received SIGUSR1 signal # 0
</p><p>Received SIGUSR1 signal # 0
</p></code></pre>
<p>That‚Äôs exactly <code>01101000</code>, the binary representation of the letter ‚Äúh‚Äù. We‚Äôre simply <strong>encoding</strong> the letter as a binary representation and sending it via signals</p>
<p>Again, we‚Äôre <strong>encoding it as a binary</strong> and sending it <strong>via signals</strong>.</p>
<p><em>How cool is that</em>?</p>
<p><img src="https://leandronsp.com/uploads/3299.png" alt="image"/></p>
<h3><a href="#decoding-the-binary-data" aria-hidden="true" id="decoding-the-binary-data"></a>Decoding the binary data</h3>
<p>On the other side, the receiver should be capable of decoding the message and converting it back to the letter ‚Äúh‚Äù:</p>
<ul>
<li>sender <em>encodes</em> the message</li>
<li>receiver <em>decodes</em> the message</li>
</ul>
<p>So, how do we decode <code>01101000</code> (the letter ‚Äúh‚Äù in ASCII)? Let‚Äôs break it down into a few steps:</p>
<ol>
<li>First, we need to see the 8 bits as individual digits in their respective positions</li>
<li>The rightmost bit is at position 0, whereas the leftmost bit is at position 7. This is how we define the most significant bit (<strong>MSB</strong>, the leftmost) and the least significant bit (<strong>LSB</strong>, the rightmost)</li>
<li>For this example, we perform a <strong>left shift</strong> operation on each bit and then sum all the values, in this case from MSB to LSB (the order doesn‚Äôt matter much for now): <code>(0 &lt;&lt; 7) + (1 &lt;&lt; 6) + (1 &lt;&lt; 5) + (0 &lt;&lt; 4) + ... + (0 &lt;&lt; 0)</code>:</li>
</ol>
<ul>
<li><code>0 &lt;&lt; 7</code> = <code>(2 ** 7) * 0</code> = <code>128 * 0</code> = 0</li>
<li><code>1 &lt;&lt; 6</code> = <code>(2 ** 6) * 1</code> = <code>64 * 1</code> = 64</li>
</ul>
<p>Similarly to the remaining bits:</p>
<ul>
<li><code>1 &lt;&lt; 5</code> = 32</li>
<li><code>0 &lt;&lt; 4</code> = 0</li>
<li><code>1 &lt;&lt; 3</code> = 8</li>
<li><code>0 &lt;&lt; 2</code> = 0</li>
<li><code>0 &lt;&lt; 1</code> = 0</li>
<li><code>0 &lt;&lt; 0</code> = 0</li>
</ul>
<p>So, our sum becomes, from MSB to LSB:</p>
<pre><code translate="no" tabindex="0"><p>MSB                          LSB
</p><p>0   1    1    0   1   0   0   0
</p><p>0 + 64 + 32 + 0 + 8 + 0 + 0 + 0 = 104
</p></code></pre>
<p>104 is exactly the <strong>decimal representation</strong> of the letter ‚Äúh‚Äù in ASCII.</p>
<p><em>How wonderful is that?</em></p>
<h3><a href="#sending-the-letter-h" aria-hidden="true" id="sending-the-letter-h"></a>Sending the letter ‚Äúh‚Äù</h3>
<p>Now let‚Äôs convert these operations to Ruby code. We‚Äôll write a simple program <code>receiver.rb</code> that receives signals in order from LSB to MSB (positions 0 to 7) and then converts them back to ASCII characters, printing to <code>STDOUT</code>.</p>
<p>Basically, we‚Äôll <strong>accumulate</strong> bits and whenever we form a complete byte, we‚Äôll decode it to its ASCII representation. The very basic implementation of our <code>accumulate_bit(bit)</code> method would look like as follows:</p>
<pre><code translate="no" tabindex="0"><p><span>@position</span> <span>=</span> <span>0</span> <span># start with the LSB</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span>
</p><p><span>def</span> <span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span># The left shift operator (&lt;&lt;) is used to </span>
</p><p><span># shift the bits of the number to the left.</span>
</p><p><span>#</span>
</p><p><span># This is equivalent of: (2 ** @position) * bit</span>
</p><p><span>@accumulator</span> <span>+=</span> <span>(</span><span>bit</span> <span>&lt;&lt;</span> <span>@position</span><span>)</span>
</p><p><span>return</span> <span>@accumulator</span> <span>if</span> <span>@position</span> <span>==</span> <span>7</span> <span># stop accumulating after 8 bits (byte)</span>
</p><p><span>@position</span> <span>+=</span> <span>1</span> <span># move to the next bit position: 0 becomes 1, 1 becomes 2, etc.</span>
</p><p><span>end</span>
</p><p><span># Letter &#34;h&#34; in binary is 01101000</span>
</p><p><span># But we&#39;ll send from the LSB to the MSB</span>
</p><p><span>#</span>
</p><p><span># 0110 1000 (MSB -&gt; LSB) becomes 0001 0110 (LSB -&gt; MSB)</span>
</p><p><span># The order doesn&#39;t matter that much, it&#39;ll depend on </span>
</p><p><span># the receiver&#39;s implementation.</span>
</p><p><span>accumulate_bit</span><span>(</span><span>0</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>0</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>0</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>1</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>0</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>1</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>1</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>0</span><span>)</span>
</p><p><span>puts</span> <span>@accumulator</span> <span># should print 104, which is the ASCII code for &#34;h&#34;</span>
</p></code></pre>
<p><em>Pay attention to this code. It‚Äôs very important and builds the foundation for the next steps. If you didn‚Äôt get it, go back and read it again. Try it yourself in the terminal or using your preferred programming language.</em></p>
<p>Now, how to convert the decimal <code>104</code> to the ASCII character representation? Luckily, Ruby provides a method called <code>chr</code> which does the job:</p>
<pre><code translate="no" tabindex="0"><p><span>irb</span><span>&gt;</span> <span>puts</span> <span>104</span><span>.</span><span>chr</span>
</p><p><span>=&gt;</span> <span>&#34;</span><span>h</span><span>&#34;</span>
</p></code></pre>
<p>We could do the same job for the rest of the word ‚Äúhello‚Äù, for instance. According to the <a href="https://www.ascii-code.com/">ASCII table</a>, it should be the following:</p>
<ul>
<li><code>e</code> in decimal is <code>101</code></li>
<li><code>l</code> in decimal is <code>108</code></li>
<li><code>o</code> in decimal is <code>111</code></li>
</ul>
<p>Let‚Äôs check if Ruby knows that:</p>
<pre><code translate="no" tabindex="0"><p><span>104</span><span>.</span><span>chr</span>    <span># &#34;h&#34;</span>
</p><p><span>101</span><span>.</span><span>chr</span>    <span># &#34;e&#34;</span>
</p><p><span>108</span><span>.</span><span>chr</span>    <span># &#34;l&#34;</span>
</p><p><span>111</span><span>.</span><span>chr</span>    <span># &#34;o&#34;</span>
</p></code></pre>
<p>We can even ‚Äúdecode‚Äù the word to the decimal representation in ASCII:</p>
<pre><code translate="no" tabindex="0"><p><span>irb</span><span>&gt;</span> <span>&#34;</span><span>hello</span><span>&#34;</span><span>.</span><span>bytes</span>
</p><p><span>=&gt;</span> <span>[</span><span>104</span><span>,</span> <span>101</span><span>,</span> <span>108</span><span>,</span> <span>108</span><span>,</span> <span>111</span><span>]</span>
</p></code></pre>
<p>Now, time to finish our receiver implementation to properly print the letter ‚Äúh‚Äù:</p>
<pre><code translate="no" tabindex="0"><p><span>@position</span> <span>=</span> <span>0</span> <span># start with the LSB</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>)</span> <span>{</span> <span>decode_signal</span><span>(</span><span>0</span><span>)</span> <span>}</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR2</span><span>&#39;</span><span>)</span> <span>{</span> <span>decode_signal</span><span>(</span><span>1</span><span>)</span> <span>}</span>
</p><p><span>def</span> <span>decode_signal</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>return</span> <span>unless</span> <span>@position</span> <span>==</span> <span>8</span> <span># if not yet accumulated a byte, keep accumulating</span>
</p><p><span>print</span> <span>&#34;</span><span>Received byte: </span><span>#{</span><span>@accumulator</span><span>}</span><span> (</span><span>#{</span><span>@accumulator</span><span>.</span><span>chr</span><span>}</span><span>)</span><span>\n</span><span>&#34;</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span> <span># reset the accumulator</span>
</p><p><span>@position</span> <span>=</span> <span>0</span> <span># reset position for the next byte</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span># The left shift operator (&lt;&lt;) is used to </span>
</p><p><span># shift the bits of the number to the left.</span>
</p><p><span>#</span>
</p><p><span># This is equivalent of: (2 ** @position) * bit</span>
</p><p><span>@accumulator</span> <span>+=</span> <span>(</span><span>bit</span> <span>&lt;&lt;</span> <span>@position</span><span>)</span>
</p><p><span>@position</span> <span>+=</span> <span>1</span> <span># move to the next bit position: 0 becomes 1, 1 becomes 2, etc.</span>
</p><p><span>end</span>
</p><p><span>puts</span> <span>&#34;</span><span>Process ID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>sleep</span>
</p></code></pre>
<p><em>Read that code and its comments. It‚Äôs very important. Do not continue reading until you really get what‚Äôs happening here.</em></p>
<ul>
<li>Whenever we get <code>SIGUSR1</code>, we accumulate the bit <code>0</code></li>
<li>When getting <code>SIGUSR2</code>, accumulate then the bit <code>1</code></li>
<li>When accumulator reaches  the position<code>8</code>, it means we have a byte. At this moment we should print the ASCII representation using the <code>.chr</code> we seen earlier. Then, reset bit position and accumulator</li>
</ul>
<p>Let‚Äôs see our receiver in action! Start the receiver in one terminal:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>receiver.rb</span>
</p><p><span>Process</span> <span>ID:</span> <span>58219</span>
</p></code></pre>
<p>Great! Now the receiver is listening for signals. In another terminal, let‚Äôs manually send signals</p>
<pre><code translate="no" tabindex="0"><p>  # Sending from LSB to MSB: 0, 0, 0, 1, 0, 1, 1, 0
</p><p>  $ kill -SIGUSR1 58219  # 0
</p><p>  $ kill -SIGUSR1 58219  # 0
</p><p>  $ kill -SIGUSR1 58219  # 0
</p><p>  $ kill -SIGUSR2 58219  # 1
</p><p>  $ kill -SIGUSR1 58219  # 0
</p><p>  $ kill -SIGUSR2 58219  # 1
</p><p>  $ kill -SIGUSR2 58219  # 1
</p><p>  $ kill -SIGUSR1 58219  # 0
</p></code></pre>
<p>And in the receiver terminal, we should see:</p>
<pre><code translate="no" tabindex="0"><p>Received byte: 104 (h)
</p></code></pre>
<p><em>How amazing is that?</em> We just sent the letter ‚Äúh‚Äù using only two UNIX signals!</p>
<p>But wait. Manually sending 8 signals for each character? That‚Äôs tedious and error-prone. What if we wanted to send the word ‚Äúhello‚Äù? That‚Äôs 5 characters √ó 8 bits = 40 signals to send manually. No way.</p>
<p><em>We need a sender.</em></p>
<h3><a href="#building-the-sender" aria-hidden="true" id="building-the-sender"></a>Building the sender</h3>
<p>The sender‚Äôs job is the opposite of the receiver: it should encode a message (string) into bits and send them as signals to the receiver process.</p>
<p>Let‚Äôs think about what we need:</p>
<ol>
<li>Take a message as input (like ‚Äúhello‚Äù)</li>
<li>Convert each character to its byte representation</li>
<li>Extract the 8 bits from each byte</li>
<li>Send <code>SIGUSR1</code> for bit 0, <code>SIGUSR2</code> for bit 1</li>
<li>Repeat for all characters</li>
</ol>
<p>The tricky part here is the step 3: <strong>how do we extract individual bits from a byte?</strong> To extract the bit at position <code>i</code>, we can use the following formula:</p>
<pre><code translate="no" tabindex="0"><p>bit = (byte &gt;&gt; i) &amp; 1
</p></code></pre>
<p>Let me break this down:</p>
<ul>
<li><code>byte &gt;&gt; i</code> performs a <em>right shift</em> by <code>i</code> positions</li>
<li><code>&amp; 1</code> is a bitwise <code>AND</code> operation that extracts only the <em>rightmost</em> bit</li>
</ul>
<p>For the letter ‚Äúh‚Äù (<code>01101000</code> in binary, <code>104</code> in decimal):</p>
<p><strong>Position 0 (LSB):</strong></p>
<ul>
<li><code>(104 &gt;&gt; 0)</code> = <code>104 / (2 ** 0)</code> = <code>104 / 1</code> = 104</li>
<li><code>01101000</code> &gt;&gt; 0 = <code>01101000</code></li>
<li><code>01101000</code> &amp; <code>00000001</code> = 0 (<em>one</em> AND <em>zero</em> is <em>zero</em>)</li>
</ul>
<p><strong>Position 1:</strong></p>
<ul>
<li><code>(104 &gt;&gt; 1)</code> = <code>104 / (2 ** 1)</code> = <code>104 / 2</code> = 52</li>
<li><code>01101000</code> &gt;&gt; 1 = <code>00110100</code></li>
<li><code>00110100</code> &amp; <code>00000001</code> = 0</li>
</ul>
<p><strong>Position 2:</strong></p>
<ul>
<li><code>(104 &gt;&gt; 2)</code> = <code>104 / (2 ** 2)</code> = <code>104 / 4</code> = 26</li>
<li><code>01101000</code> &gt;&gt; 2 = <code>00011010</code></li>
<li><code>00011010</code> &amp; <code>00000001</code> = 0</li>
</ul>
<p><strong>Position 3:</strong></p>
<ul>
<li><code>(104 &gt;&gt; 3)</code> = <code>104 / (2 ** 3)</code> = <code>104 / 8</code> = 13</li>
<li><code>01101000</code> &gt;&gt; 3 = <code>00001101</code></li>
<li><code>00001101</code> &amp; <code>00000001</code> = 1 (<em>one</em> AND <em>one</em> equals <em>one</em>)</li>
</ul>
<p>And so on for positions 4, 5, 6, and 7. This gives us: <code>0, 0, 0, 1, 0, 1, 1, 0</code> ‚Äî exactly the bits we need from LSB to MSB!</p>
<ul>
<li><code>(104 &gt;&gt; 0) &amp; 1</code> = <code>104 &amp; 1</code> = 0</li>
<li><code>(104 &gt;&gt; 1) &amp; 1</code> = <code>52 &amp; 1</code> = 0</li>
<li><code>(104 &gt;&gt; 2) &amp; 1</code> = <code>26 &amp; 1</code> = 0</li>
<li><code>(104 &gt;&gt; 3) &amp; 1</code> = <code>13 &amp; 1</code> = 1</li>
<li><code>(104 &gt;&gt; 4) &amp; 1</code> = <code>6 &amp; 1</code> = 0</li>
<li><code>(104 &gt;&gt; 5) &amp; 1</code> = <code>3 &amp; 1</code> = 1</li>
<li><code>(104 &gt;&gt; 6) &amp; 1</code> = <code>1 &amp; 1</code> = 1</li>
<li><code>(104 &gt;&gt; 7) &amp; 1</code> = <code>0 &amp; 1</code> = 0</li>
</ul>
<blockquote>
<p>Pay close attention to this technique. It‚Äôs a fundamental operation in low-level programming.</p>
</blockquote>
<p>So now time to build the <code>sender.rb</code> which is pretty simple:</p>
<pre><code translate="no" tabindex="0"><p><span>receiver_pid</span> <span>=</span> <span>ARGV</span><span>[</span><span>0</span><span>]</span><span>.</span><span>to_i</span>
</p><p><span>message</span> <span>=</span> <span>ARGV</span><span>[</span><span>1</span><span>..</span><span>-</span><span>1</span><span>]</span><span>.</span><span>join</span><span>(</span><span>&#39;</span><span> </span><span>&#39;</span><span>)</span>
</p><p><span>def</span> <span>encode_byte</span><span>(</span><span>byte</span><span>)</span>
</p><p><span>8</span><span>.</span><span>times</span><span>.</span><span>map</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
</p><p><span># Extract each bit from the byte, starting from the LSB</span>
</p><p><span>(</span><span>byte</span> <span>&gt;&gt;</span> <span>i</span><span>)</span> <span>&amp;</span> <span>1</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>message</span><span>.</span><span>bytes</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
</p><p><span>encode_byte</span><span>(</span><span>byte</span><span>)</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>bit</span><span>|</span>
</p><p><span>signal</span> <span>=</span> <span>bit</span> <span>==</span> <span>0</span> <span>?</span> <span>&#39;</span><span>SIGUSR1</span><span>&#39;</span> <span>:</span> <span>&#39;</span><span>SIGUSR2</span><span>&#39;</span>
</p><p><span>Process</span><span>.</span><span>kill</span><span>(</span><span>signal</span><span>,</span> <span>receiver_pid</span><span>)</span>
</p><p><span>sleep</span> <span>0.001</span> <span># Delay to allow the receiver to process the signal</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p></code></pre>
<p>For each byte (8-bit structure) we extract the bit performing the <em>right shift</em> + <em>AND</em> oprerations. The result is the extracted bit.</p>
<p>In the receiver window:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>receiver.rb</span>
</p><p><span>Process</span> <span>ID:</span> <span>68968</span>
</p></code></pre>
<p>And in the sender window:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>sender.rb</span> <span>68968</span> <span>h</span>
</p></code></pre>
<p>The receiver will print:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>receiver.rb</span>
</p><p><span>Process</span> <span>ID:</span> <span>68968</span>
</p><p><span>Received</span> <span>byte:</span> <span>104</span><span></span> <span>(</span><span>h</span><span>)</span>
</p></code></pre>
<p><em>Processes sending messages with only two signals!</em> How wonderful is that?</p>
<h3><a href="#sending-the-hello-message" aria-hidden="true" id="sending-the-hello-message"></a>Sending the ‚Äúhello‚Äù message</h3>
<p>Now, sending the hello message is super easy. The sender is already able to send not only a letter but any message using signals:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>sender.rb</span> <span>68968</span> <span>hello</span>
</p><p><span># And the receiver:</span>
</p><p><span>Received</span> <span>byte:</span> <span>104</span><span></span> <span>(</span><span>h</span><span>)</span>
</p><p><span>Received</span> <span>byte:</span> <span>101</span><span></span> <span>(</span><span>e</span><span>)</span>
</p><p><span>Received</span> <span>byte:</span> <span>108</span><span></span> <span>(</span><span>l</span><span>)</span>
</p><p><span>Received</span> <span>byte:</span> <span>108</span><span></span> <span>(</span><span>l</span><span>)</span>
</p><p><span>Received</span> <span>byte:</span> <span>111</span><span></span> <span>(</span><span>o</span><span>)</span>
</p></code></pre>
<p>Just change the <code>receiver</code> implementation a little bit:</p>
<pre><code translate="no" tabindex="0"><p><span>def</span> <span>decode_signal</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>return</span> <span>unless</span> <span>@position</span> <span>==</span> <span>8</span> <span># if not yet accumulated a byte, keep accumulating</span>
</p><p><span>print</span> <span>@accumulator</span><span>.</span><span>chr</span> <span># print the byte as a character</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span> <span># reset the accumulator</span>
</p><p><span>@position</span> <span>=</span> <span>0</span> <span># reset position for the next byte</span>
</p><p><span>end</span>
</p></code></pre>
<p>And then:</p>
<pre><code translate="no" tabindex="0"><p><span>$</span> <span>ruby</span> <span>sender.rb</span> <span>96875</span> <span>Hello</span>
</p><p><span># In the receiver&#39;s terminal</span>
</p><p><span>Process</span> <span>ID:</span> <span>96875</span>
</p><p><span>Hello</span>
</p></code></pre>
<p>However, if we send the message again, the receiver will print everything in the same line:</p>
<pre><code translate="no" tabindex="0"><p>$ <span>ruby</span> <span>sender</span><span>.</span><span>rb</span> <span>96875</span> <span>Hello</span>
</p><p>$ <span>ruby</span> <span>sender</span><span>.</span><span>rb</span> <span>96875</span> <span>Hello</span>
</p><p><span># In the receiver&#39;s terminal</span>
</p><p><span>Process</span> <span>ID</span><span>:</span> <span>96875</span>
</p><p><span>HelloHello</span>
</p></code></pre>
<p>It‚Äôs obvious: the receiver doesn‚Äôt know where the sender finished the message, so it‚Äôs impossible to know where we should stop one message and print the next one on a new line with <code>\n</code>.</p>
<p>We should then determine how the sender indicates the end of the message. How about being it all <em>zeroes</em> (<code>0000 0000</code>)?</p>
<ul>
<li>We send the message: first 5 bytes representing the ‚Äúhello‚Äù message</li>
<li>Then we send a ‚ÄúNULL terminator‚Äù, just one byte <em>0</em> (<code>0000 0000</code>)</li>
</ul>
<pre><code translate="no" tabindex="0"><p>0110 1000 # h
</p><p>0110 0101 # e
</p><p>0110 1000 # l
</p><p>0110 1000 # l
</p><p>0110 1111 # o
</p><p>0000 0000 # NULL
</p></code></pre>
<p>Hence, when the <em>receiver</em> gets a NULL terminator, it will print a line feed <code>\n</code>. Let‚Äôs change the <code>sender.rb</code> first:</p>
<pre><code translate="no" tabindex="0"><p><span>receiver_pid</span> <span>=</span> <span>ARGV</span><span>[</span><span>0</span><span>]</span><span>.</span><span>to_i</span>
</p><p><span>message</span> <span>=</span> <span>ARGV</span><span>[</span><span>1</span><span>..</span><span>-</span><span>1</span><span>]</span><span>.</span><span>join</span><span>(</span><span>&#39;</span><span> </span><span>&#39;</span><span>)</span>
</p><p><span>def</span> <span>encode_byte</span><span>(</span><span>byte</span><span>)</span>
</p><p><span>8</span><span>.</span><span>times</span><span>.</span><span>map</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
</p><p><span># Extract each bit from the byte, starting from the LSB</span>
</p><p><span>(</span><span>byte</span> <span>&gt;&gt;</span> <span>i</span><span>)</span> <span>&amp;</span> <span>1</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>message</span><span>.</span><span>bytes</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
</p><p><span>encode_byte</span><span>(</span><span>byte</span><span>)</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>bit</span><span>|</span>
</p><p><span>signal</span> <span>=</span> <span>bit</span> <span>==</span> <span>0</span> <span>?</span> <span>&#39;</span><span>SIGUSR1</span><span>&#39;</span> <span>:</span> <span>&#39;</span><span>SIGUSR2</span><span>&#39;</span>
</p><p><span>Process</span><span>.</span><span>kill</span><span>(</span><span>signal</span><span>,</span> <span>receiver_pid</span><span>)</span>
</p><p><span>sleep</span> <span>0.001</span> <span># Delay to allow the receiver to process the signal</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span># Send NULL terminator (0000 0000)</span>
</p><p><span>8</span><span>.</span><span>times</span> <span>do</span>
</p><p><span>Process</span><span>.</span><span>kill</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>,</span> <span>receiver_pid</span><span>)</span>
</p><p><span>sleep</span> <span>0.001</span> <span># Delay to allow the receiver to process the signal</span>
</p><p><span>end</span>
</p><p><span>puts</span> <span>&#34;</span><span>Message sent to receiver (PID: </span><span>#{</span><span>receiver_pid</span><span>}</span><span>)</span><span>&#34;</span>
</p></code></pre>
<p>Then, the <code>receiver.rb</code>:</p>
<pre><code translate="no" tabindex="0"><p><span>@position</span> <span>=</span> <span>0</span> <span># start with the LSB</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>)</span> <span>{</span> <span>decode_signal</span><span>(</span><span>0</span><span>)</span> <span>}</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR2</span><span>&#39;</span><span>)</span> <span>{</span> <span>decode_signal</span><span>(</span><span>1</span><span>)</span> <span>}</span>
</p><p><span>def</span> <span>decode_signal</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>return</span> <span>unless</span> <span>@position</span> <span>==</span> <span>8</span> <span># if not yet accumulated a byte, keep accumulating</span>
</p><p><span>if</span> <span>@accumulator</span><span>.</span><span>zero?</span> <span># NULL terminator received</span>
</p><p><span>print</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
</p><p><span>else</span>
</p><p><span>print</span> <span>@accumulator</span><span>.</span><span>chr</span> <span># print the byte as a character</span>
</p><p><span>end</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span> <span># reset the accumulator</span>
</p><p><span>@position</span> <span>=</span> <span>0</span> <span># reset position for the next byte</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span># The left shift operator (&lt;&lt;) is used to </span>
</p><p><span># shift the bits of the number to the left.</span>
</p><p><span>#</span>
</p><p><span># This is equivalent of: (2 ** @position) * bit</span>
</p><p><span>@accumulator</span> <span>+=</span> <span>(</span><span>bit</span> <span>&lt;&lt;</span> <span>@position</span><span>)</span>
</p><p><span>@position</span> <span>+=</span> <span>1</span> <span># move to the next bit position: 0 becomes 1, 1 becomes 2, etc.</span>
</p><p><span>end</span>
</p><p><span>puts</span> <span>&#34;</span><span>Process ID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>sleep</span>
</p></code></pre>
<p>Output:</p>
<pre><code translate="no" tabindex="0"><p>$ ruby sender.rb 96875 Hello, World!
</p><p>$ ruby sender.rb 96875 You&#39;re welcome
</p><p>$ ruby sender.rb 96875 How are you?
</p><p># Receiver
</p><p>Process ID: 97176
</p><p>Hello, World!
</p><p>You&#39;re welcome
</p><p>How are you?
</p></code></pre>
<blockquote>
<p>OMG Leandro! That‚Äôs amazing!</p>
</blockquote>
<p><em>Amazing, right?</em> We just built an entire communication system between two processes using one of the most primitive methods available: <strong>UNIX signals.</strong></p>
<p>The sky‚Äôs the limit now! Why not build a <em>full-fledged message broker</em> using this crazy technique?</p>
<h2><a href="#a-modest-message-broker-using-unix-signals" aria-hidden="true" id="a-modest-message-broker-using-unix-signals"></a>A modest message broker using UNIX signals</h2>
<p>We‚Äôll break down the development into three components:</p>
<ol>
<li><strong>Broker</strong>: the intermediary that routes messages</li>
<li><strong>Consumer</strong>: processes that receive messages</li>
<li><strong>Producer</strong>: processes that send messages</li>
</ol>
<p><img src="https://leandronsp.com/uploads/3395.png" alt="image"/></p>
<ol>
<li>Let‚Äôs start with the Broker. It should register itself with the producer, then trap incoming signals, decode them, and enqueue the messages for delivery to consumers via outgoing signals:</li>
</ol>
<pre><code translate="no" tabindex="0"><p><span>#!/usr/bin/env ruby</span>
</p><p><span>require_relative</span> <span>&#39;</span><span>signal_codec</span><span>&#39;</span>
</p><p><span>require_relative</span> <span>&#39;</span><span>consumer</span><span>&#39;</span>
</p><p><span>class</span> <span>Broker</span> 
</p><p><span>PID</span> <span>=</span> <span>&#39;</span><span>broker.pid</span><span>&#39;</span><span>.</span><span>freeze</span>
</p><p><span>def</span> <span>initialize</span>
</p><p><span>@codec</span> <span>=</span> <span>SignalCodec</span><span>.</span><span>new</span>
</p><p><span>@queue</span> <span>=</span> <span>Queue</span><span>.</span><span>new</span>
</p><p><span>@consumer_index</span> <span>=</span> <span>0</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>start</span> 
</p><p><span>register_broker</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>)</span> <span>{</span> <span>process_bit</span><span>(</span><span>0</span><span>)</span> <span>}</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR2</span><span>&#39;</span><span>)</span> <span>{</span> <span>process_bit</span><span>(</span><span>1</span><span>)</span> <span>}</span>
</p><p><span>puts</span> <span>&#34;</span><span>Broker PID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>puts</span> <span>&#34;</span><span>Waiting for messages...</span><span>&#34;</span>
</p><p><span>distribute_messages</span>
</p><p><span>sleep</span> <span># Keep alive</span>
</p><p><span>end</span> 
</p><p><span>private</span>
</p><p><span>def</span> <span>process_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>@codec</span><span>.</span><span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span> <span>do</span> <span>|</span><span>message</span><span>|</span>
</p><p><span>@queue</span><span>.</span><span>push</span><span>(</span><span>message</span><span>)</span> <span>unless</span> <span>message</span><span>.</span><span>empty?</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>register_broker</span> 
</p><p><span>File</span><span>.</span><span>write</span><span>(</span><span>PID</span><span>,</span> <span>Process</span><span>.</span><span>pid</span><span>)</span>
</p><p><span>at_exit</span> <span>{</span> <span>File</span><span>.</span><span>delete</span><span>(</span><span>PID</span><span>)</span> <span>if</span> <span>File</span><span>.</span><span>exist?</span><span>(</span><span>PID</span><span>)</span> <span>}</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>distribute_messages</span>
</p><p><span>Thread</span><span>.</span><span>new</span> <span>do</span>
</p><p><span>loop</span> <span>do</span>
</p><p><span>sleep</span> <span>0.1</span>
</p><p><span>next</span> <span>if</span> <span>@queue</span><span>.</span><span>empty?</span>
</p><p><span>consumers</span> <span>=</span> <span>File</span><span>.</span><span>exist?</span><span>(</span><span>Consumer</span><span>::</span><span>FILE</span><span>)</span> <span>?</span> <span>File</span><span>.</span><span>readlines</span><span>(</span><span>Consumer</span><span>::</span><span>FILE</span><span>)</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:to_i</span><span>)</span> <span>:</span> <span>[</span><span>]</span>
</p><p><span>next</span> <span>if</span> <span>consumers</span><span>.</span><span>empty?</span>
</p><p><span>message</span> <span>=</span> <span>@queue</span><span>.</span><span>pop</span><span>(</span><span>true</span><span>)</span> <span>rescue</span> <span>next</span>
</p><p><span>consumer_pid</span> <span>=</span> <span>consumers</span><span>[</span><span>@consumer_index</span> <span>%</span> <span>consumers</span><span>.</span><span>size</span><span>]</span>
</p><p><span>@consumer_index</span> <span>+=</span> <span>1</span>
</p><p><span>puts</span> <span>&#34;</span><span>[SEND] </span><span>#{</span><span>message</span><span>}</span><span> ‚Üí Consumer </span><span>#{</span><span>consumer_pid</span><span>}</span><span>&#34;</span>
</p><p><span>@codec</span><span>.</span><span>send_message</span><span>(</span><span>message</span><span>,</span> <span>consumer_pid</span><span>)</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>if</span> <span>__FILE__</span> <span>==</span> <span>$0</span> 
</p><p><span>broker</span> <span>=</span> <span>Broker</span><span>.</span><span>new</span>
</p><p><span>broker</span><span>.</span><span>start</span>
</p><p><span>end</span>
</p></code></pre>
<ul>
<li>The broker registers itself</li>
<li>Traps incoming signals <code>USR1</code> (bit 0) and <code>USR2</code> (bit 1)</li>
<li>Enqueues the messages</li>
<li>Send messages to consumers using outgoing signals (<code>USR1</code> and <code>USR2</code> too)</li>
</ul>
<p><em>Note that we‚Äôre using a module called <code>SignalCodec</code> which will be explained soon. Basically this module contains all core components to encode/decode signals and perform bitwise operations.</em></p>
<ol start="2">
<li>Now the <code>Consumer</code> implementation:</li>
</ol>
<pre><code translate="no" tabindex="0"><p><span>#!/usr/bin/env ruby</span>
</p><p><span>require_relative</span> <span>&#39;</span><span>signal_codec</span><span>&#39;</span>
</p><p><span>class</span> <span>Consumer</span>
</p><p><span>FILE</span> <span>=</span> <span>&#39;</span><span>consumers.txt</span><span>&#39;</span><span>.</span><span>freeze</span>
</p><p><span>def</span> <span>initialize</span>
</p><p><span>@codec</span> <span>=</span> <span>SignalCodec</span><span>.</span><span>new</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>start</span>
</p><p><span>register_consumer</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>)</span> <span>{</span> <span>process_bit</span><span>(</span><span>0</span><span>)</span> <span>}</span>
</p><p><span>trap</span><span>(</span><span>&#39;</span><span>SIGUSR2</span><span>&#39;</span><span>)</span> <span>{</span> <span>process_bit</span><span>(</span><span>1</span><span>)</span> <span>}</span>
</p><p><span>puts</span> <span>&#34;</span><span>Consumer PID: </span><span>#{</span><span>Process</span><span>.</span><span>pid</span><span>}</span><span>&#34;</span>
</p><p><span>puts</span> <span>&#34;</span><span>Waiting for messages...</span><span>&#34;</span>
</p><p><span>sleep</span> <span># Keep alive</span>
</p><p><span>end</span>
</p><p><span>private</span>
</p><p><span>def</span> <span>process_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>@codec</span><span>.</span><span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span> <span>do</span> <span>|</span><span>message</span><span>|</span>
</p><p><span>puts</span> <span>&#34;</span><span>[RECEIVE] </span><span>#{</span><span>message</span><span>}</span><span>&#34;</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>register_consumer</span>
</p><p><span>File</span><span>.</span><span>open</span><span>(</span><span>FILE</span><span>,</span> <span>&#39;</span><span>a</span><span>&#39;</span><span>)</span> <span>{</span> <span>|</span><span>f</span><span>|</span> <span>f</span><span>.</span><span>puts</span> <span>Process</span><span>.</span><span>pid</span> <span>}</span>
</p><p><span>at_exit</span> <span>{</span> <span>deregister_consumer</span> <span>}</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>deregister_consumer</span>
</p><p><span>if</span> <span>File</span><span>.</span><span>exist?</span><span>(</span><span>FILE</span><span>)</span>
</p><p><span>consumers</span> <span>=</span> <span>File</span><span>.</span><span>readlines</span><span>(</span><span>FILE</span><span>)</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:strip</span><span>)</span><span>.</span><span>reject</span> <span>{</span> <span>|</span><span>pid</span><span>|</span> <span>pid</span><span>.</span><span>to_i</span> <span>==</span> <span>Process</span><span>.</span><span>pid</span> <span>}</span>
</p><p><span>File</span><span>.</span><span>write</span><span>(</span><span>FILE</span><span>,</span> <span>consumers</span><span>.</span><span>join</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>)</span><span>)</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>if</span> <span>__FILE__</span> <span>==</span> <span>$0</span>
</p><p><span>consumer</span> <span>=</span> <span>Consumer</span><span>.</span><span>new</span>
</p><p><span>consumer</span><span>.</span><span>start</span>
</p><p><span>end</span>
</p></code></pre>
<ul>
<li>The consumer starts and registers itself with the broker</li>
<li>Consumer then traps incoming signals (bit 0 and bit 1)</li>
<li>Decodes and prints messages</li>
</ul>
<ol start="3">
<li>Last but not least, the <code>Producer</code> implementation, which is pretty straightforward:</li>
</ol>
<pre><code translate="no" tabindex="0"><p><span>#!/usr/bin/env ruby</span>
</p><p><span>require_relative</span> <span>&#39;</span><span>signal_codec</span><span>&#39;</span>
</p><p><span>require_relative</span> <span>&#39;</span><span>broker</span><span>&#39;</span>
</p><p><span>unless</span> <span>File</span><span>.</span><span>exist?</span><span>(</span><span>Broker</span><span>::</span><span>PID</span><span>)</span>
</p><p><span>abort</span> <span>&#34;</span><span>Error: Broker not running (</span><span>#{</span><span>Broker</span><span>::</span><span>PID</span><span>}</span><span> not found)</span><span>&#34;</span>
</p><p><span>end</span>
</p><p><span>broker_pid</span> <span>=</span> <span>File</span><span>.</span><span>read</span><span>(</span><span>Broker</span><span>::</span><span>PID</span><span>)</span><span>.</span><span>strip</span><span>.</span><span>to_i</span>
</p><p><span>message</span> <span>=</span> <span>ARGV</span><span>.</span><span>join</span><span>(</span><span>&#39;</span><span> </span><span>&#39;</span><span>)</span>
</p><p><span>if</span> <span>message</span><span>.</span><span>empty?</span>
</p><p><span>puts</span> <span>&#34;</span><span>Usage: ruby producer.rb &lt;message&gt;</span><span>&#34;</span>
</p><p><span>exit</span> <span>1</span>
</p><p><span>end</span>
</p><p><span>codec</span> <span>=</span> <span>SignalCodec</span><span>.</span><span>new</span>
</p><p><span>puts</span> <span>&#34;</span><span>Sending: </span><span>#{</span><span>message</span><span>}</span><span>&#34;</span>
</p><p><span>codec</span><span>.</span><span>send_message</span><span>(</span><span>message</span><span>,</span> <span>broker_pid</span><span>)</span>
</p><p><span>puts</span> <span>&#34;</span><span>Message sent to broker (PID: </span><span>#{</span><span>broker_pid</span><span>}</span><span>)</span><span>&#34;</span>
</p></code></pre>
<ul>
<li>Producer receives a ASCII message from the <em>STDIN</em></li>
<li>Encode and sends the message to the broker via outgoing signals</li>
</ul>
<p>So far, this architecture should look familiar. Many broker implementations follow these basic foundations.</p>
<blockquote>
<p>Of course, production-ready implementations are far more robust than this one. Here, we‚Äôre just poking around with hacking and experimentation</p>
</blockquote>
<p>The coolest part is the <code>SignalCodec</code> though:</p>
<pre><code translate="no" tabindex="0"><p><span>class</span> <span>SignalCodec</span> 
</p><p><span>SIGNAL_DELAY</span> <span>=</span> <span>0.001</span> <span># Delay between signals to allow processing</span>
</p><p><span>def</span> <span>initialize</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span>
</p><p><span>@position</span> <span>=</span> <span>0</span>
</p><p><span>@buffer</span> <span>=</span> <span>[</span><span>]</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>accumulate_bit</span><span>(</span><span>bit</span><span>)</span>
</p><p><span>@accumulator</span> <span>+=</span> <span>(</span><span>bit</span> <span>&lt;&lt;</span> <span>@position</span><span>)</span>
</p><p><span>@position</span> <span>+=</span> <span>1</span>
</p><p><span>if</span> <span>@position</span> <span>==</span> <span>8</span> <span># Byte is complete</span>
</p><p><span>if</span> <span>@accumulator</span><span>.</span><span>zero?</span> <span># Message complete - NULL terminator</span>
</p><p><span>decoded</span> <span>=</span> <span>@buffer</span><span>.</span><span>pack</span><span>(</span><span>&#34;</span><span>C*</span><span>&#34;</span><span>)</span><span>.</span><span>force_encoding</span><span>(</span><span>&#39;</span><span>UTF-8</span><span>&#39;</span><span>)</span>
</p><p><span>yield</span><span>(</span><span>decoded</span><span>)</span> <span>if</span> <span>block_given?</span>
</p><p><span>@buffer</span><span>.</span><span>clear</span>
</p><p><span>else</span> 
</p><p><span>@buffer</span> <span>&lt;&lt;</span> <span>@accumulator</span>
</p><p><span>end</span>
</p><p><span>@position</span> <span>=</span> <span>0</span>
</p><p><span>@accumulator</span> <span>=</span> <span>0</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>def</span> <span>send_message</span><span>(</span><span>message</span><span>,</span> <span>pid</span><span>)</span>
</p><p><span>message</span><span>.</span><span>each_byte</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
</p><p><span>8</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
</p><p><span>bit</span> <span>=</span> <span>(</span><span>byte</span> <span>&gt;&gt;</span> <span>i</span><span>)</span> <span>&amp;</span> <span>1</span>
</p><p><span>signal</span> <span>=</span> <span>bit</span> <span>==</span> <span>0</span> <span>?</span> <span>&#39;</span><span>SIGUSR1</span><span>&#39;</span> <span>:</span> <span>&#39;</span><span>SIGUSR2</span><span>&#39;</span>
</p><p><span>Process</span><span>.</span><span>kill</span><span>(</span><span>signal</span><span>,</span> <span>pid</span><span>)</span>
</p><p><span>sleep</span> <span>SIGNAL_DELAY</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span># Send NULL terminator (0000 0000)</span>
</p><p><span>8</span><span>.</span><span>times</span> <span>do</span>
</p><p><span>Process</span><span>.</span><span>kill</span><span>(</span><span>&#39;</span><span>SIGUSR1</span><span>&#39;</span><span>,</span> <span>pid</span><span>)</span>
</p><p><span>sleep</span> <span>SIGNAL_DELAY</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p><p><span>end</span>
</p></code></pre>
<p>If you‚Äôve been following along, this shouldn‚Äôt be hard to understand, but I‚Äôll break down how this beautiful piece of code works:</p>
<ul>
<li>The codec is initialized with the bit position at zero, as well as the accumulator</li>
<li>A buffer is also initialized to store accumulated bits until a complete byte is formed</li>
<li>The <code>accumulate_bit</code> method should be familiar from our earlier implementation, but it now accepts a closure (block) that lets the caller decide what to do with each decoded byte</li>
<li><code>send_message</code> encodes a message into bits and sends them via UNIX signals</li>
</ul>
<p>Everything in action:</p>
<p><img src="https://leandronsp.com/uploads/3170.png" alt="image"/></p>
<p><em>How cool, amazing, wonderful, impressive, astonishing is that?</em></p>
<h2><a href="#conclusion" aria-hidden="true" id="conclusion"></a>Conclusion</h2>
<p>Yes, we built a message broker using nothing but <strong>UNIX signals</strong> and a bit of Ruby magic. Sure, <strong>it‚Äôs not production-ready</strong>, and you definitely shouldn‚Äôt use this in your next startup (please don‚Äôt), but that was never the point.</p>
<p>The real takeaway here isn‚Äôt the broker itself: it‚Äôs understanding how the fundamentals work. We explored binary operations, UNIX signals, and IPC in a hands-on way that most people never bother with.</p>
<p>We took something ‚Äúuseless‚Äù and made it work, just for fun. So next time someone asks you about message brokers, you can casually mention that you once built (or saw) one using just two signals. And if they look at you weird, well, that‚Äôs their problem. Now go build something equally useless and amazing. The world needs more hackers who experiment just for the fun of it.</p>
<p><em>Happy hacking!</em></p>
      </div></div>
  </body>
</html>
