<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/clojure-macros/">Original</a>
    <h1>Clojure macros continue to surprise me</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <p>Clojure macros have two modes: avoid them at all costs/do very basic stuff, or go absolutely crazy.</p>
        <p>Here’s the problem: I’m working on <a href="https://github.com/HumbleUI/HumbleUI" target="_blank">Humble UI’s</a> component library, and I wanted to document it. While at it, I figured it could serve as an integration test as well—since I showcase every possible option, why not test it at the same time?</p>
        <p>This is what I came up with: I write component code, and in the application, I show a table with the running code on the left and the source on the right:</p>
        <figure>
<img src="https://tonsky.me/blog/clojure-macros/before@2x.png?t=1721313037" width="1190" height="916"/>        </figure>
        <p>It was important that code that I show is exactly the same code that I run (otherwise it wouldn’t be a very good test). Like a quine: hey program! Show us your source code!</p>
        <p>Simple with Clojure macros, right? Indeed:</p>
        <pre><code>(defmacro table [&amp; examples]
  (list &#39;ui/grid {:cols 2}
    (for [[_ code] (partition 2 examples)]
      (list &#39;list
        code (pr-str code)))))</code></pre>
        <p>This macro accepts code AST and emits a pair of AST (basically a no-op) back and a string that we serialize that AST to.</p>
        <p>This is what I consider to be a “normal” macro usage. Nothing fancy, just another day at the office.</p>
        <p>Unfortunately, this approach reformats code: while in the macro, all we have is an already parsed AST (data structures only, no whitespaces) and we have to pretty-print it from scratch, adding indents and newlines.</p>
        <p>I tried a couple of existing formatters (clojure.pprint, zprint, cljfmt) but wasn’t happy with any of them. The problem is tricky—sometimes a vector is just a vector, but sometimes it’s a UI component and shows the structure of the UI.</p>
        <p>And then I realized that I was thinking inside the box all the time. We already have the perfect formatting—it’s in the source file!</p>
        <p>So what if... No, no, it’s too brittle. We shouldn’t even think about it... But what if...</p>
        <p>What if our macro read the source file?</p>
        <p>Like, actually went to the file system, opened a file, and read its content? We already have the file name conveniently stored in <code>*file*</code>, and luckily Clojure keeps sources around.</p>
        <p>So this is what I ended up with:</p>
        <pre><code>(defn slurp-source [file key]
  (let [content      (slurp (io/resource file))
        key-str      (pr-str key)
        idx          (str/index-of content key)
        content-tail (subs content (+ idx (count key-str)))
        reader       (clojure.lang.LineNumberingPushbackReader.
                       (java.io.StringReader.
                         content-tail))
        indent       (re-find #&#34;\s+&#34; content-tail)
        [_ form-str] (read+string reader)]
    (-&gt;&gt; form-str
      str/split-lines
      (map #(if (str/starts-with? % indent)
              (subs % (count indent))
              %)))))</code></pre>
        <p>Go to a file. Find the string we are interested in. Read the first form after it <em>as a string</em>. Remove common indentation. Render. As a string.</p>
        <p>Voilà!</p>
        <figure>
<img src="https://tonsky.me/blog/clojure-macros/after@2x.png?t=1721313037" width="1179" height="912"/>        </figure>
        <p>I know it’s bad. I know you shouldn’t do it. I know. I know.</p>
        <p>But still. Clojure is the most fun I have ever had with any language. It lets you play with code like never before. Do the craziest, stupidest things. Read the source file of the code you are evaluating? <a href="https://github.com/tonsky/remote-require/" target="_blank">Fetch code from the internet and splice it into the currently running program?</a></p>
        <p>In any other language, this would’ve been a project. You’d need a parser, a build step... Here—just ten lines of code, on vanilla language, no tooling or setup required.</p>
        <p>Sometimes, a crazy thing is exactly what you need.</p>
        
      </article></div>
  </body>
</html>
