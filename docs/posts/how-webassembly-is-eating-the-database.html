<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dylibso.com/blog/wasm-udf/">Original</a>
    <h1>How WebAssembly Is Eating the Database</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
  <article>
        <div>
          <p>User-defined functions (UDFs) have been a fixture in database systems for a considerable period of time, allowing users to extend the database‚Äôs built-in functionality to complement good ol‚Äô SQL. Although the traditional UDF is a powerful tool, developers are in most cases forced to use unfamiliar programming languages, typically unique to the database itself. However, with a portable, low-level binary format with sandboxed security controls and broad language support (WebAssembly!), there‚Äôs a new wave of UDF implementations emerging and <em>we like what we see.</em></p>
<p>For example, <a href="https://www.singlestore.com">Singlestore‚Äôs</a> Code Engine provides users with the ability to create both UDFs and Table-Valued Functions (TVFs) using code compiled to Wasm, while both <a href="https://infinyon.com/">InfinyOn</a> and <a href="https://redpanda.com">RedPanda</a> enable developers to manipulate data streams from within their platforms using Wasm. Our own <a href="https://extism.org">Extism</a>, the universal plug-in system, pulls back the curtains with a demo showing <a href="https://github.com/extism/extism-sqlite3">how to extend SQLite3 with Wasm UDFs</a>. Let‚Äôs take a deeper look into what‚Äôs driving this trend, along with some thoughts and considerations for the future.</p>
<h2 id="polyglot-more-languages-now-and-in-the-future">Polyglot: more languages, now and in the future</h2>
<p>Supporting a wide array of programming languages for UDF creation translates to a market expansion for database providers by enabling wider reach into the many developer communities. On the flip side, database users want to write UDFs in the languages that are dearest to their hearts and that provide them with the best tools for productivity. Thus, more language support is clearly a win-win for both database creators and consumers, so why have we seen such limited language support for UDFs in the past? Time and material is the likely suspect. Without a common runtime and executable format for languages to target, a database vendor would need to build/integrate and maintain various language runtimes in order to offer Wasm‚Äôs broad language support. This is a complex and time-consuming task, so prioritization becomes the natural fall back, and the obvious move is to pick a widely used general purpose programming language (e.g. JavaScript) or create a Domain-Specific Language (DSL).</p>
<p>With the former option, the vendor has tied the success of their UDF engine to the chosen language, and with the latter, they have done the same, but also introduced more friction to product adoption due to the imposed learning curve and lack of transferrable skills.</p>
<p>We‚Äôre happy to say, it‚Äôs time to have your UDF cake ‚Äî and eat it too. At the time of this writing, there are well over ten languages that target Wasm directly, and as additional languages are able to do so in the future, database platforms could gain these additions with little to no incremental work required.</p>
<h2 id="security">Security</h2>
<p>In addition to supporting various language runtimes, database providers must also ensure proper sandbox controls are in place so that the host system (i.e. the database) is protected from any unintended or malicious side effects. Wasm is particularly well adapted to this as runtimes are designed to execute code in a sandboxed environment with restricted access to the resources of the host system by default. With this isolation built-in, database providers can spend less time rolling their own secure runtime, and more time <a href="https://twitter.com/isamlambert/status/1653802402636783617">being cute on Twitter</a>.</p>
<h2 id="performance--portability">Performance &amp; Portability</h2>
<p>Wasm code is well-known for its especially small footprint, which makes it easy to bring compute to the data, and near native execution speeds makes it a natual fit for complex data workloads.</p>
<p>Datasets grow larger by the day, making it cumbersome and costly to ferry them back-and-forth between database and application for processing. Aside from the added latency created by such workflows, additional points of failure are added with each new application connected to a database, and concerns related to data residency both make running Wasm directly alongside the data quite appealing. Being able to keep your data where it lives, and bring (at least part of) the application to it is a huge simplification to an unclear and complex regulatory environment.</p>
<p>Additionally, the ability to bring compute to data eliminates the need for as many microservices ‚Äî run those <em>in the database</em> instead!</p>
<p>As far as portability is concerned, why should database users implement their UDFs over and over again for different host databases? Write once, and run <del>anywhere</del> in any database! A traditional benefit of a UDF is that it can be reused across SQL queries, but why restrict that reusability to one database platform? With Wasm in the mix, the scope of UDF reuse can, in theory, be expanded to any database that supports a Wasm runtime along with a standardized interface into host capabilities. In practice, this would require some level of collaboration across the database provider ecosystem, or efforts by the community to virtualize various interfaces into a common standard, but the possiblity, and the associated benefits, are there for the taking.</p>
<h2 id="additional-thoughts-and-considerations">Additional Thoughts and Considerations</h2>
<p>Wasm is clearly a force multiplier for UDFs, but let‚Äôs talk about some of the design and implementation aspects that should be considered.</p>
<h4 id="host-interfaces-and-amenities">Host interfaces and amenities</h4>
<ul>
<li>
<p>The database provider must support a set of imports and exports that will serve as the foundation for the interaction between the database and a Wasm UDF. As noted above, it benefits the entire ecosystem if that interface can be standardized. <a href="https://github.com/webAssembly/wasi-sql-embed">WASI SQL Embedding</a> is an example of one such proposal to bring standards to the way in which WASM modules can be embedded in SQL databases as extensions.</p>
</li>
<li>
<p>Designing high-quality language support and libraries is critical for success as UDF creators will need such support to achieve their implementation goals. For example, Python developers will want, and expect, NumPy to be available for analytical workloads. Database providers should consider including such support at the host level, escpecially when native extensions are required for performance reasons. Doing so provides users with access to the necessary libraries without forcing them to be compiled directly into the Wasm UDF, which would increase the size of the module itself.</p>
</li>
<li>
<p>When possible, language-specific wrappers should be provided around any imports in order to provide idiomatic language support. Look to open source projects such as <a href="https://extism.org/docs/category/write-a-plug-in">Extism</a>, which provide a good head-start for teams creating these types of utilities.</p>
</li>
</ul>
<h4 id="transaction-isolationintegrity">Transaction Isolation/Integrity</h4>
<ul>
<li>Most production-ready databases already run UDFs within transactions, allowing for seamless rollbacks when exceptions occur, and eliminating the need for failure compensation to be implemented in the mutation code itself. That being said, considering how transactions fit into Wasm flavored UDFs and their view of the world is important, and still very much an ‚Äúexercise left to the reader‚Äù for database implementers to solve.</li>
</ul>
<h4 id="observability-and-validation">Observability and Validation</h4>
<ul>
<li>
<p>What tools do database providers and UDF creators need to observe and inspect the performance of UDFs and debug them when the unexpected happens? Multi-tenant observability is an underserved need within the ecosystem that should be given careful thought.</p>
</li>
<li>
<p>Back to the topic of host/guest interface standardization, if a bespoke interface is a must, consider the usage of tools such as <a href="https://dylibso.com/products/modsurfer/">Modsurfer</a>, which provide a way for database providers and UDF creators to validate mutual compatibility in a proactive manner. The existence of certain imports and exports, runtime complexity, binary size, and function signatures are all critical components that should be part of any validation scheme.</p>
</li>
</ul>
<h4 id="udfs-and-so-much-more">UDFs and so much more</h4>
<p>It would be an error of omission if we didn‚Äôt mention the other aspects of the database that are ripe for extensibility with WebAssembly aside from UDFs. Stored procedures, table-valued functions (TVFs), and user-defined aggregate functions (UDAFs) are all within scope, as are deeper modifications to the core database itself (think new types, indexes, etc.) Time to kick the tires and let users express their deepest data driven desires!</p>

<ul>
<li>
<p>As Wasm continues to entrench itself as an indespensable component of the computing landscape, we hope to see more support for it in the databases we know and love (e.g. Supabase, Planetscale, Neon). Got some additional thoughts on this topic? Reach out to us at <a href="mailto:hello@dylibso.com">hello@dylibso.com</a> ‚Äî we‚Äôd be glad to talk shop!</p>
</li>
<li>
<p><a href="https://twitter.com/neuronicnobody">Dominique Saulet</a>, Director of TPM</p>
</li>
<li>
<p><a href="https://twitter.com/nilslice">Steve Manuel</a>, Co-founder + CEO</p>
</li>
</ul>
<p><em>A special thank you to <strong><a href="https://twitter.com/carlsverre">Carl Sverre</a></strong> and <strong><a href="https://twitter.com/shomikghosh21">Shomik Ghosh</a></strong> for reviewing this post!</em></p>
        </div>
      </article>
</div>
  </div><div id="about">
  <div>
  <div>
      <p><a href="https://dylibso.com/"><img src="https://dylibso.com/dylibso-logo.svg"/></a></p>
    </div><p>
      Made with üíú in Boulder ‚õ∞, Los Angeles üèñ, New Orleans ‚öúÔ∏è, and San Francisco üåÅ
    </p><p>
      Copyright ¬© 2023
    </p>
</div>
</div></div>
  </body>
</html>
